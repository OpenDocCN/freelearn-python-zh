- en: '*Chapter 6*: Advanced Tips and Tricks in Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：Python的高级技巧和窍门'
- en: In this chapter, we will introduce some advanced tips and tricks that can be
    used as powerful programming techniques when writing code in Python. These include
    the advanced use of Python functions, such as nested functions, lambda functions,
    and building decorators with functions. Additionally, we will cover data transformations
    with the filter, mapper, and reducer functions. This will be followed by some
    tricks that can be used with data structures, such as the use of nested dictionaries
    and comprehension with different collection types. Finally, we will investigate
    the advanced functionality of the pandas library for DataFrame objects. These
    advanced tips and tricks will not only demonstrate Python's power in achieving
    advanced features with less code, but it will also help you code faster and more
    efficiently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些高级技巧和窍门，这些技巧和窍门可以在编写Python代码时作为强大的编程技术使用。这包括Python函数的高级使用，如嵌套函数、lambda函数以及使用函数构建装饰器。此外，我们将涵盖使用filter、mapper和reducer函数进行数据转换。接下来，我们将介绍一些与数据结构相关的技巧，例如嵌套字典和不同集合类型的理解。最后，我们将研究pandas库中DataFrame对象的先进功能。这些高级技巧和窍门不仅将展示Python在用更少的代码实现高级功能方面的强大能力，而且还将帮助您更快、更有效地编写代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Learning advanced tricks for using functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用函数的高级技巧
- en: Understanding advanced concepts with data structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据结构理解高级概念
- en: Introducing advanced tricks with pandas DataFrame
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍使用pandas DataFrame的高级技巧
- en: By the end of this chapter, you will have gained an understanding of how to
    use Python functions for advanced features such as data transformations and building
    decorators. Additionally, you will learn how to use data structures including
    pandas DataFrame for analytics-based applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何使用Python函数实现高级功能，如数据转换和构建装饰器。此外，您还将学习如何使用包括pandas DataFrame在内的数据结构，用于基于分析的应用程序。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: You need to have Python 3.7 or later installed on your computer.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在您的计算机上安装Python 3.7或更高版本。
- en: You need to register an account with TestPyPI and create an API token under
    your account.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在TestPyPI上注册一个账户，并在您的账户下创建一个API令牌。
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter06](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter06).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在[https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter06](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter06)找到。
- en: We will start our discussion with the advanced concepts for using functions
    in Python.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论Python中函数的高级概念。
- en: Learning advanced tricks for using functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习使用函数的高级技巧
- en: The use of functions in Python and other programming languages is key for reusability
    and modularization. However, with new advances to modern programming languages,
    the role of functions has been extended beyond reusability, which includes writing
    simple, short, and concise code without using complex loops and conditional statements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python和其他编程语言中使用函数对于可重用性和模块化至关重要。然而，随着现代编程语言的最新进展，函数的作用已经超越了可重用性，包括编写简单、简短和简洁的代码，而无需使用复杂的循环和条件语句。
- en: We will start with the use of the `counter`, `zip`, and `itertools` functions,
    which we will discuss next.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`counter`、`zip`和`itertools`函数的使用开始，我们将在下一节中讨论这些函数。
- en: Introducing the counter, itertools, and zip functions for iterative tasks
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍用于迭代任务的counter、itertools和zip函数
- en: For any data processing tasks, developers extensively use iterators. We have
    covered iterators, in detail, in [*Chapter 4*](B17189_04_Final_PG_ePub.xhtml#_idTextAnchor141),
    *Python Libraries for Advanced Programming*. In this section, we will learn about
    the next level of utility functions to help you conveniently work with iterators
    and iterables. These include the `counter` module, the `zip` function, and the
    `itertools` module. We will discuss each of these in the following subsections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何数据处理任务，开发者广泛使用迭代器。我们在[*第4章*](B17189_04_Final_PG_ePub.xhtml#_idTextAnchor141)，*高级编程的Python库*中详细介绍了迭代器。在本节中，我们将学习关于下一级实用函数的内容，这些函数可以帮助您方便地处理迭代器和可迭代对象。这些包括`counter`模块、`zip`函数和`itertools`模块。我们将在以下小节中讨论这些内容。
- en: Counter
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Counter
- en: '`Counter` class, we will present a simple code example, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`类，我们将提供一个简单的代码示例，如下所示：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code example, we created multiple `Counter` instances using
    a `String` object, a list object, and a dictionary object. The `Counter` class
    has methods such as `most_common` and `elements`. We used the `most_common` method
    with a value of `1`, which gives us the element that appears the most in the `my-counter`
    container. Additionally, we used the `elements` method to return the original
    list from the `Counter` instance. The console output of this program should be
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用一个`String`对象、一个列表对象和一个字典对象创建了多个`Counter`实例。`Counter`类有`most_common`和`elements`等方法。我们使用`most_common`方法并设置值为`1`，这会给我们返回`my-counter`容器中出现次数最多的元素。此外，我们还使用了`elements`方法从`Counter`实例返回原始列表。该程序的控制台输出应如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is important to note that in the case of the dictionary object, we deliberately
    used a repeated key, but in the `Counter` instance, we get only one key-value
    pair, which is the last one in the dictionary. Additionally, the elements in the
    `Counter` instance are ordered based on the values for each element. Note that
    the `Counter` class converts the dictionary object into a hashtable object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在字典对象的情况下，我们故意使用了重复的键，但在`Counter`实例中，我们只得到一个键值对，这是字典中的最后一个。此外，`Counter`实例中的元素根据每个元素的值进行排序。请注意，`Counter`类将字典对象转换为散列表对象。
- en: zip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: zip
- en: 'The `zip` function is used to create an aggregated iterator based on two or
    more individual iterators. The `zip` function is useful when we are required to
    iterate on multiple iterations in parallel. For example, we can use the `zip`
    function when implementing mathematical algorithms that involve interpolation
    or pattern recognition. This is also helpful in digital signal processing where
    we combine multiple signals (data sources) into a single signal. Here is a simple
    code example that uses a `zip` function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`函数用于根据两个或多个单独的迭代器创建一个聚合迭代器。当需要并行迭代多个迭代器时，`zip`函数非常有用。例如，在实现涉及插值或模式识别的数学算法时，我们可以使用`zip`函数。这也有助于数字信号处理，其中我们将多个信号（数据源）组合成一个单一信号。以下是一个使用`zip`函数的简单代码示例：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code example, we combined the two lists for iteration purposes
    by using the `zip` function. Note that one list is larger than the other in terms
    of the number of elements. The console output of this program should be as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们通过使用`zip`函数将两个列表合并以进行迭代。请注意，从元素数量来看，一个列表比另一个列表大。该程序的输出应如下所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As expected, we get the first two tuples using the `next` function, which is
    a combination of corresponding elements from each list. In the end, we used the
    `list` constructor to iterate over the rest of the tuples from the `zip` iterator.
    This gives us a list of the remaining tuples in a list format.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们使用`next`函数获取前两个元组，这是来自每个列表对应元素的组合。最后，我们使用`list`构造函数遍历`zip`迭代器中的其余元组。这给我们提供了一个剩余元组的列表。
- en: itertools
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: itertools
- en: 'Python offers a module, called `itertools`, that provides useful functions
    to work with iterators. When working with a large set of data, the use of iterators
    is a must, and that is where the utility functions provided by the `itertool`
    module prove to be very helpful. There are many functions available with the `itertools`
    module. We will briefly introduce a few key functions here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个名为`itertools`的模块，它提供了用于处理迭代器的有用函数。当处理大量数据时，迭代器的使用是必不可少的，这正是`itertool`模块提供的实用函数非常有帮助的地方。`itertools`模块提供了许多函数。在这里，我们将简要介绍几个关键函数：
- en: '`count`: This function is used to create an iterator for counting numbers.
    We can provide a starting number (default = 0) and, optionally, set a size of
    the counting step for the increment. The following code example will return an
    iterator that provides counting numbers, such as 10, 12, and 14:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`: 这个函数用于创建一个计数数字的迭代器。我们可以提供一个起始数字（默认为0），并且可选地设置计数步长的尺寸。以下代码示例将返回一个提供计数数字的迭代器，例如10、12和14：'
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`cycle`: This function allows you to cycle through an iterator endlessly. The
    following code snippet illustrates how you can use this function for a list of
    alphabet letters:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cycle`: 这个函数允许你无限循环遍历一个迭代器。以下代码片段说明了如何使用此函数遍历字母表中的字母列表：'
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Repeat`: This function provides us with an iterator that returns an object
    over and over again unless there is a `times` argument set with it. The following
    code snippet will repeat the `Python` string object five times:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repeat`：此函数为我们提供了一个迭代器，该迭代器会反复返回一个对象，除非设置了`times`参数。以下代码片段将重复`Python`字符串对象五次：'
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`accumulate`: This function will return an iterator that provides us with an
    accumulated sum or other accumulated results based on an aggregator function that
    was passed to this `accumulate` function as an argument. It is easier to understand
    the use of this function with a code example, as follows:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accumulate`：此函数将返回一个迭代器，该迭代器提供基于传递给此`accumulate`函数作为参数的聚合函数的累积总和或其他累积结果。以下代码示例将有助于理解该函数的使用方法：'
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`chain`: This function combines two or more iterables and returns a combined
    iterable. Take a look at the following example code showing two iterables (lists)
    along with the `chain` function:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chain`：此函数将两个或多个可迭代对象组合起来，并返回一个组合的可迭代对象。请看以下示例代码，展示了两个可迭代对象（列表）以及`chain`函数的使用：'
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that this function will combine the iterables in a serial manner. This
    means that items in `list1` will be accessible first, followed by the items in
    `list2`.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，此函数将以串行方式组合可迭代对象。这意味着`list1`中的项目将首先可用，然后是`list2`中的项目。
- en: '`compress`: This function can be used to filter elements from one iterable
    based on another iterable. In the example code snippet, we have selected alphabet
    letters from a list based on a `selector` iterable:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compress`：此函数可以用来根据另一个可迭代对象过滤一个可迭代对象中的元素。在以下示例代码片段中，我们根据`selector`可迭代对象从列表中选择了字母：'
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`groupby`: This function identifies the keys for each item in an iterable object
    and groups the items based on the identified keys. This function requires another
    function (known as `key_func`) that identifies a key in each element of an iterable
    object. The following example code explains the use of this function along with
    how to implement a `key_func` function:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupby`：此函数识别可迭代对象中每个项目的键，并根据识别的键对项目进行分组。此函数需要一个额外的函数（称为`key_func`），用于在可迭代对象的每个元素中识别键。以下示例代码解释了该函数的使用方法以及如何实现`key_func`函数：'
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`tee`: This is another useful function that can be used to duplicate iterators
    from a single iterator. Here is an example code that duplicates two iterators
    from a single list iterable:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tee`：这是另一个有用的函数，可以用来从单个迭代器中复制迭代器。以下是一个示例代码，展示了如何从一个列表可迭代对象中复制两个迭代器：'
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we will discuss another category of functions that is extensively used
    for data transformation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论另一个广泛用于数据转换的函数类别。
- en: Using filters, mappers, and reducers for data transformations
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用过滤器、映射器和归约器进行数据转换
- en: '`map`, `filter`, and `reduce` are three functions available in Python that
    are used to simplify and write concise code. These three functions are applied
    to iterables in a single shot without using iterative statements. The `map` and
    `filter` functions are available as built-in functions, while the `reduce` function
    requires you to import the `functtools` module. These functions are extensively
    used by data scientists for data processing. The `map` function and the `filter`
    function are used to transform or filter data, whereas the `reduce` function is
    used in data analysis to get meaningful results from a large dataset.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`、`filter`和`reduce`是Python中可用的三个函数，用于简化代码并编写简洁的代码。这三个函数在单个操作中应用于可迭代对象，而不使用迭代语句。`map`和`filter`函数作为内置函数提供，而`reduce`函数则需要导入`functools`模块。这些函数被数据科学家广泛用于数据处理。`map`函数和`filter`函数用于转换或过滤数据，而`reduce`函数用于数据分析，以从大量数据集中获取有意义的成果。'
- en: In the following subsections, we will evaluate each function with its application
    and code examples.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将评估每个函数及其应用和代码示例。
- en: map
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地图
- en: 'The `map` function in Python is defined using the following syntax:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`map`函数定义如下语法：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `func` argument is the name of the function that will be applied to each
    item of the `iter` object. The three dots indicate that it is possible to pass
    multiple iterable objects. However, it is important to understand that the number
    of arguments of the function (`func`) must match the number of iterable objects.
    The output of the `map` function is a `map` object, which is a generator object.
    The return value can be converted into a list by passing the `map` object to the
    `list` constructor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`func`参数是要应用于`iter`对象每个项目的函数的名称。三个点表示可以传递多个可迭代对象。然而，重要的是要理解函数（`func`）的参数数量必须与可迭代对象的数量相匹配。`map`函数的输出是一个`map`对象，它是一个生成器对象。可以通过将`map`对象传递给`list`构造函数将其转换成列表。'
- en: Important note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In Python 2, the `map` function returns a list. This behavior has been changed
    in Python 3.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2中，`map`函数返回一个列表。这种行为在Python 3中已经改变。
- en: 'Before discussing the use of a `map` function, first, we will implement a simple
    transformation function that converts a list of numbers into their square values.
    The code example is provided next:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论`map`函数的使用之前，首先，我们将实现一个简单的转换函数，该函数将数字列表转换为它们的平方值。接下来的代码示例提供了：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, the code example uses a `for` loop structure to iterate through a list,
    calculates the square of each entry in the list, and then adds it to a new list.
    This style of writing code is common, but it is definitely not a Pythonic way
    to write code. The console output of this program is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码示例使用`for`循环结构遍历列表，计算列表中每个条目的平方，并将其添加到新的列表中。这种编写代码的风格很常见，但绝对不是Python风格的编写代码方式。这个程序的输出如下：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the use of the `map` function, this code can be simplified and shortened,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map`函数，可以将此代码简化并缩短，如下所示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By using the `map` function, we provided the name of the function (in this example,
    it is `square`) and the reference of the list (in this example, it is `mylist`).
    The `map` object that is returned by the `map` function is converted into a list
    object by using the `list` constructor. The console output of this code example
    is the same as the previous code example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`map`函数，我们提供了函数的名称（在这个例子中，它是`square`）和列表的引用（在这个例子中，它是`mylist`）。`map`函数返回的`map`对象通过使用`list`构造函数转换为列表对象。这个代码示例的控制台输出与之前的代码示例相同。
- en: 'In the following code example, we will provide two lists as input for the `map`
    function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们将为`map`函数提供两个列表作为输入：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, the goal of the `map` function that has been implemented is to use
    the `product` function. The `product` function takes each item from two lists
    and multiplies the corresponding item in each list before returning it to the
    `map` function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，已实现的`map`函数的目标是使用`product`函数。`product`函数从两个列表中取每个项目，并在返回之前将每个列表中对应的项相乘。
- en: 'The console output of this code example is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例的控制台输出如下：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An analysis of this console output tells us that only the first four items from
    each list are used by the `map` function. The `map` function automatically stops
    when it runs out of the items in any of the iterables (in our case, these are
    the two lists). This means that even if we provide iterables of different sizes,
    the `map` function will not raise any exception but will work for the number of
    items that are possible to map across iterables using the function provided. In
    our code example, we have a smaller number of items in the `mylist2` list, which
    is four. That is why we only have four items in the output list (in our case,
    this is `new_list`). Next, we will discuss the `filter` function with some code
    examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个控制台输出的分析告诉我们，`map`函数只使用了每个列表的前四个项目。当`map`函数在任何一个可迭代对象（在我们的例子中，这些是两个列表）中运行完项目后，它会自动停止。这意味着即使我们提供了不同大小的可迭代对象，`map`函数也不会引发任何异常，但会为使用提供的函数在可迭代对象之间映射的项目数量工作。在我们的代码示例中，`mylist2`列表中的项目数量较少，是四个。这就是为什么输出列表中只有四个项目（在我们的例子中，这是`new_list`）。接下来，我们将通过一些代码示例讨论`filter`函数。
- en: filter
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: filter
- en: 'The `filter` function also operates on iterables but only on one iterable object.
    As its name suggests, it provides a filtering functionality on the iterable object.
    The filtering criteria are provided through the function definition. The syntax
    of a `filter` function is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`函数也作用于可迭代对象，但只作用于一个可迭代对象。正如其名称所暗示的，它为可迭代对象提供了过滤功能。过滤条件通过函数定义提供。`filter`函数的语法如下：'
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `func` function provides the filtering criteria, and it has to return `True`
    or `False`. Since only one iterable is allowed alongside the `filter` function,
    only one argument is allowed for the `func` function. The following code example
    uses a `filter` function to select the items whose values are even numbers. To
    implement the selection criteria, the function `is_even` is implemented to evaluate
    whether a number provided to it is an even number or not. The sample code is as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`func` 函数提供过滤条件，并且必须返回 `True` 或 `False`。由于 `filter` 函数只能允许一个可迭代对象，因此 `func`
    函数只能有一个参数。以下代码示例使用 `filter` 函数来选择值为偶数的项。为了实现选择标准，实现了 `is_even` 函数来评估传递给它的数字是否为偶数。示例代码如下：'
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The console output of the preceding code example is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例的控制台输出如下：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, we will discuss the `reduce` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 `reduce` 函数。
- en: reduce
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: reduce
- en: 'The `reduce` function is used to apply a cumulative processing function on
    each element of a sequence, which is passed to it as an argument. This cumulative
    processing function is not for transformation or filtration purposes. As its name
    suggests, the cumulative processing function is used to get a single result at
    the end based on all of the elements in a sequence. The syntax of using the `reduce`
    function is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 函数用于对序列中的每个元素应用累积处理函数，该函数作为参数传递给它。这个累积处理函数不是用于转换或过滤目的。正如其名称所暗示的，累积处理函数用于根据序列中的所有元素在最后得到一个单一的结果。使用
    `reduce` 函数的语法如下：'
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `func` function is a function that is used to apply cumulative processing
    on each element of the iterable. Additionally, `initial` is an optional value
    that can be passed to the `func` function to be used as an initial value for cumulative
    processing. It is important to understand that there will always be two arguments
    to the `func` function for the `reduce` function case: the first argument will
    either be the initial value (if provided) or the first element of the sequence,
    and the second argument will be the next element from the sequence.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`func` 函数是一个用于对可迭代对象的每个元素应用累积处理的函数。此外，`initial` 是一个可选值，可以传递给 `func` 函数作为累积处理初始值的用途。重要的是要理解，对于
    `reduce` 函数的情况，`func` 函数将始终有两个参数：第一个参数将是初始值（如果提供的话）或序列的第一个元素，第二个参数将是序列的下一个元素。'
- en: 'In the following code example, we will use a simple list of the first five
    numbers. We will implement a custom method to add the two numbers and then use
    the `reduce` method to sum all of the elements in the list. The code example is
    shown next:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们将使用一个简单的包含前五个数字的列表。我们将实现一个自定义方法来添加两个数字，然后使用 `reduce` 方法来计算列表中所有元素的总和。代码示例如下：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of this program is `15`, which is a numerical sum of all the elements
    of the list (in our example, this is called `mylist`). If we provide the initial
    value to the `reduce` function, the result will be appended as per the initial
    value. For example, the output of the same program with the following statement
    will be `25`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出是 `15`，这是列表中所有元素的数值总和（在我们的例子中，这被称为 `mylist`）。如果我们向 `reduce` 函数提供初始值，结果将根据初始值附加。例如，以下语句的相同程序的输出将是
    `25`：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As mentioned previously, the result or return value of the `reduce` function
    is a single value, which is as per the `func` function. In this example, it will
    be an integer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`reduce` 函数的结果或返回值是一个单一值，它遵循 `func` 函数。在这个例子中，它将是一个整数。
- en: In this section, we discussed the `map`, `filter`, and `reduce` functions that
    are available within Python. These functions are used extensively by data scientists
    for data transformation and data refinement. One problem of using functions such
    as `map` and `filter` is that they return an object of the `map` or `filter` type,
    and we have to convert the results explicitly into a `list` data type for further
    processing. The comprehensions and generators do not have such limitations but
    provide similar functionality, and they are relatively easier to use. That is
    why they are getting more traction than the `map`, `filter`, and `reduce` functions.
    We will discuss comprehension and generators in the *Understanding advanced concepts
    with data structures* section. Next, we will investigate the use of lambda functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了 Python 中可用的 `map`、`filter` 和 `reduce` 函数。这些函数被数据科学家广泛用于数据转换和数据精炼。使用
    `map` 和 `filter` 等函数的一个问题是，它们返回 `map` 或 `filter` 类型的对象，我们必须显式地将结果转换为 `list` 数据类型以进行进一步处理。列表推导式和生成器没有这样的限制，但提供类似的功能，并且相对更容易使用。这就是为什么它们比
    `map`、`filter` 和 `reduce` 函数更受欢迎。我们将在 *使用数据结构理解高级概念* 部分讨论列表推导式和生成器。接下来，我们将研究 Lambda
    函数的使用。
- en: Learning how to build lambda functions
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习如何构建 Lambda 函数
- en: Lambda functions are anonymous functions that are based on a single-line expression.
    Just as the `def` keyword is used to define regular functions, the `lambda` keyword
    is used to define anonymous functions. Lambda functions are restricted to a single
    line. This means they cannot use multiple statements, and they cannot use a return
    statement. The return value is automatically returned after the evaluation of
    the single-line expression.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数是基于单行表达式的匿名函数。正如使用 `def` 关键字来定义常规函数一样，使用 `lambda` 关键字来定义匿名函数。Lambda
    函数限制在单行内。这意味着它们不能使用多个语句，也不能使用返回语句。单行表达式的评估后，返回值会自动返回。
- en: The lambda functions can be used anywhere a regular function is used. The easiest
    and most convenient usage of lambda functions is with the `map`, `reduce`, and
    `filter` functions. Lambda functions are helpful when you wish to make the code
    more concise.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数可以在常规函数可以使用的任何地方使用。Lambda 函数最简单、最方便的使用方式是与 `map`、`reduce` 和 `filter`
    函数一起使用。当您希望使代码更简洁时，Lambda 函数非常有用。
- en: 'To illustrate a lambda function, we will reuse the map and filter code examples
    that we discussed earlier. In these code examples, we will replace `func` with
    a lambda function, as highlighted in the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 Lambda 函数，我们将重用我们之前讨论过的 map 和 filter 代码示例。在这些代码示例中，我们将用 Lambda 函数替换 `func`，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Although the code has become more concise, we should be careful about using
    lambda functions. These functions are not reusable, and they are not easy to maintain.
    We need to rethink this before introducing a lambda function into our program.
    Any changes or additional functionality will not be easy to add. A rule of thumb
    is to only use lambda functions for simple expressions when writing a separate
    function would be an overhead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码已经变得更加简洁，但我们应谨慎使用 Lambda 函数。这些函数是不可重用的，并且不易维护。在将 Lambda 函数引入我们的程序之前，我们需要重新思考这一点。任何更改或附加功能都不容易添加。一个经验法则是，在编写单独函数会带来开销时，仅使用
    Lambda 函数进行简单的表达式。
- en: Embedding a function within another function
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在另一个函数中嵌入函数
- en: When we add a function within an existing function, it is called an `def` keyword
    and with the appropriate indentation. The inner functions cannot be executed or
    called by the outside program. However, if the outer function returns a reference
    of the inner function, it can be used by the caller to execute the inner function.
    We will take a look at examples of returning inner function references for many
    use cases in the following subsections.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在现有函数内添加一个函数时，它被称为 `def` 关键字，并使用适当的缩进。内部函数不能被外部程序执行或调用。然而，如果外部函数返回内部函数的引用，调用者可以使用它来执行内部函数。我们将在以下小节中查看许多用例的内部函数引用示例。
- en: Inner functions have many advantages and applications. We will describe a few
    of them next.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数有许多优点和应用。我们将在下面描述其中的一些。
- en: Encapsulation
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封装
- en: 'A common use case of an inner function is being able to hide its functionality
    from the outside world. The inner function is only available within the outer
    function scope and is not visible to the global scope. The following code example
    shows one outer function that is hiding an inner function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数的一个常见用途是能够隐藏其功能对外部世界的可见性。内部函数仅在外部函数的作用域内可用，并且对全局作用域不可见。以下代码示例显示了一个隐藏内部函数的外部函数：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: From the outside of the outer function, we can only call the outer function.
    The inner function can only be called from the body of the outer function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部函数的外部，我们只能调用外部函数。内部函数只能从外部函数体内部调用。
- en: Helper functions
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 辅助函数
- en: 'In some cases, we can find ourselves in a situation where the code within a
    function code is reusable. We can turn such reusable code into a separate function;
    otherwise, if the code is reusable only within the scope of a function, then it
    is a case of building an inner function. This type of inner function is also called
    the helper function. The following code snippet illustrates this concept:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能会发现自己处于一个函数内部代码可重用的情况。我们可以将此类可重用代码转换为单独的函数；否则，如果代码仅可在函数的作用域内重用，那么它就是一个构建内部函数的例子。这种内部函数也称为辅助函数。以下代码片段说明了这个概念：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding sample code, we defined an inner function, called `get_prefix`
    (a helper function), inside an outer function to filter the first two letters
    of an argument value. Since we have to repeat this filtering process for all arguments,
    we added a helper function for reusability within the scope of this function as
    it is specific to this function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们在一个外部函数内部定义了一个内部函数，称为`get_prefix`（一个辅助函数），用于过滤参数值的第一个两个字母。由于我们必须对所有参数重复此过滤过程，因此我们添加了一个辅助函数，以便在这个函数的作用域内重用，因为它专门针对这个函数。
- en: The closure and factory functions
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包和工厂函数
- en: This is a type of use case in which the inner functions shine. A **closure**
    is an inner function along with its enclosing environment. A closure is a dynamically
    created function that can be returned by another function. The real magic of a
    closure is that the returned function has full access to the variables and namespaces
    where it was created. This is true even when the enclosing function (in this context,
    it is the outer function) has finished executing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种内部函数大放异彩的使用案例。**闭包**是一个内部函数及其封装环境。闭包是一个动态创建的函数，可以被另一个函数返回。闭包的真正魔力在于返回的函数可以完全访问其创建时的变量和命名空间。即使封装函数（在这个上下文中，是外部函数）已经执行完毕，这也是正确的。
- en: 'The closure concept can be illustrated by a code example. The following code
    example shows a use case where we have implemented a closure factory to create
    a function to calculate the power of the base value, and the base value is retained
    by the closure:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包概念可以通过代码示例来展示。以下代码示例展示了一个实现闭包工厂以创建计算基数值幂的函数的使用案例，并且基数值由闭包保留：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code example, the outer function (that is, `power_calc_factory`)
    acts as a closure factory function because it creates a new closure every time
    it is called, and then it returns the closure to the caller. Additionally, `power_calc`
    is an inner function that takes one variable (that is, `base`) from the closure
    namespace and then takes the second variable (that is, `exponent`), which is passed
    to it as an argument. Note that the most important statement is `return power_calc`.
    This statement returns the inner function as an object with its enclosure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，外部函数（即`power_calc_factory`）充当闭包工厂函数，因为它在每次被调用时都会创建一个新的闭包，然后将其返回给调用者。此外，`power_calc`是一个内部函数，它从一个闭包命名空间中获取一个变量（即`base`），然后获取第二个变量（即`exponent`），该变量作为参数传递给它。请注意，最重要的语句是`return
    power_calc`。这个语句返回一个包含其封装环境的内部函数对象。
- en: 'When we call the `power_calc_factory` function for the first time along with
    the `base` argument, a closure is created with its namespace, including the argument
    that was passed to it, and the closure is returned to the caller. When we call
    the same function again, we get a new closure with the inner function object.
    In this code example, we created 2 closures: one with a `base` value of 2 and
    the other with a `base` value of 3\. When we called the inner function by passing
    different values for the `exponent` variable, the code inside the inner function
    (in this case, the `power_calc` function) will also have access to the `base`
    value that was already passed to the outer function.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次调用`power_calc_factory`函数并传递`base`参数时，会创建一个包含其命名空间、包括传递给它的参数的闭包，并将闭包返回给调用者。当我们再次调用相同的函数时，我们得到一个新的闭包，其中包含内部函数对象。在这个代码示例中，我们创建了2个闭包：一个`base`值为2，另一个`base`值为3。当我们通过传递不同的`exponent`变量值调用内部函数时，内部函数（在这种情况下，`power_calc`函数）也将能够访问已经传递给外部函数的`base`值。
- en: These code examples illustrated the use of outer and inner functions to create
    functions dynamically. Traditionally, inner functions are used for hiding or encapsulating
    functionality inside a function. But when they are used along with the outer functions
    acting as a factory for creating dynamic functions, it becomes the most powerful
    application of the inner functions. Inner functions are also used to implement
    decorators. We will discuss this in more detail in the following section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码示例说明了使用外部和内部函数动态创建函数的使用。传统上，内部函数用于在函数内部隐藏或封装功能。但当他们与作为创建动态函数的工厂的外部函数一起使用时，这成为内部函数最强大的应用。内部函数也用于实现装饰器。我们将在下一节中更详细地讨论这个问题。
- en: Modifying function behavior using decorators
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用装饰器修改函数行为
- en: The concept of decorators in Python is based on the **Decorator** design pattern,
    which is a type of structural design pattern. This pattern allows you to add new
    behavior to objects without changing anything in the object implementation. This
    new behavior is added inside the special wrapper objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python中装饰器的概念基于**装饰器**设计模式，这是一种结构型设计模式。这种模式允许你在不改变对象实现的情况下向对象添加新行为。这种新行为被添加到特殊的包装对象中。
- en: In Python, **decorators** are special high-order functions that enable developers
    to add new functionality to an existing function (or a method) without adding
    or changing anything within the function. Typically, these decorators are added
    before the definition of a function. Decorators are used for implementing many
    features of an application, but they are particularly popular in data validation,
    logging, caching, debugging, encryption, and transaction management.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，**装饰器**是特殊的高阶函数，允许开发者在不修改现有函数（或方法）内部的情况下向其添加新功能。通常，这些装饰器被添加在函数定义之前。装饰器用于实现应用程序的许多功能，但在数据验证、日志记录、缓存、调试、加密和事务管理中特别受欢迎。
- en: To create a decorator, we have to define a callable entity (that is, a function,
    a method, or a class) that accepts a function as an argument. The callable entity
    will return another function object with a decorator-defined behavior. The function
    that is decorated (we will call it a *decorated function* for the remainder of
    this section) is passed as an argument to the function that is implementing a
    decorator (which will be called a *decorator function* for the remainder of this
    section). The decorator function executes the function passed to it in addition
    to the additional behavior that was added as part of the decorator function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个装饰器，我们必须定义一个可调用实体（即函数、方法或类），它接受一个函数作为参数。可调用实体将返回另一个具有装饰器定义行为的函数对象。被装饰的函数（在本节的其余部分我们将称之为*装饰函数*）作为参数传递给实现装饰器的函数（在本节的其余部分我们将称之为*装饰器函数*）。装饰器函数除了执行传递给它的函数外，还会执行作为装饰器函数一部分添加的额外行为。
- en: 'A simple example of a decorator is shown in the following code example in which
    we define a decorator to add a timestamp before and after the execution of a function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了装饰器的一个简单示例，其中我们定义了一个装饰器，在函数执行前后添加时间戳：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this code example, we define a `add_timestamps` decorator function that
    takes any function as an argument. In the inner function (`_add_timestamps`),
    we take the current time before and after the execution of the function, which
    is then passed as an argument. The decorator function returns the inner function
    object with a closure. The decorators are doing nothing more than using inner
    functions smartly, as we discussed in the previous section. The use of the `@`
    symbol to decorate a function is equivalent to the following lines of codes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们定义了一个`add_timestamps`装饰器函数，它接受任何函数作为参数。在内部函数`_add_timestamps`中，我们在函数执行前后获取当前时间，然后将这些时间作为参数传递。装饰器函数通过闭包返回内部函数对象。正如我们在上一节中讨论的那样，装饰器所做的不仅仅是巧妙地使用内部函数。使用`@`符号装饰函数等同于以下代码行：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, we are calling the decorator function explicitly by passing the
    function name as a parameter. In other words, the decorated function is equal
    to the inner function, which is defined inside the decorator function. This is
    exactly how Python interprets and calls the decorator function when it sees a
    decorator with the `@` symbol before the definition of a function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过传递函数名作为参数显式地调用装饰器函数。换句话说，装饰过的函数等于内部函数，它是定义在装饰器函数内部的。这正是Python在看到函数定义前有`@`符号的装饰器时，解释和调用装饰器函数的方式。
- en: 'However, a problem arises when we have to obtain additional details about the
    invocation of functions, which is important for debugging. When we use the built-in
    `help` function with the `hello_world` function, we only receive help for the
    inner function. The same happens if we use the docstring, which will also work
    for the inner function but not the decorated function. Additionally, serializing
    the code is going to be a challenge for decorated functions. There is a simple
    solution that is available in Python for all of these problems; that solution
    is to use the `wraps` decorator from the `functools` library. We will revise our
    previous code example to include the `wraps` decorator. The complete code example
    is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们需要获取关于函数调用的额外细节时，会出现问题，这对于调试非常重要。当我们使用内置的`help`函数与`hello_world`函数一起使用时，我们只收到内部函数的帮助信息。如果我们使用文档字符串，也会发生同样的事情，它将适用于内部函数但不会适用于装饰过的函数。此外，对于装饰过的函数，序列化代码将是一个挑战。Python为所有这些问题提供了一个简单的解决方案；这个解决方案就是使用`functools`库中的`wraps`装饰器。我们将修改之前的代码示例以包含`wraps`装饰器。完整的代码示例如下：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The use of the `wraps` decorators will provide additional details about the
    executions of the nested functions, and we can view these in the console output
    if we run the example code that has been provided.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`wraps`装饰器将提供关于嵌套函数执行的额外细节，如果我们运行提供的示例代码，我们可以在控制台输出中查看这些细节。
- en: So far, we have looked at a simple example of a decorator to explain this concept.
    For the remainder of this section, we will learn how to pass arguments with a
    function to a decorator, how to return value from a decorator, and how to chain
    multiple decorators. To begin, we will learn how to pass attributes and return
    a value with decorators.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过一个简单的装饰器示例来解释这个概念。在本节的剩余部分，我们将学习如何将函数的参数传递给装饰器，如何从装饰器中返回值，以及如何链式使用多个装饰器。首先，我们将学习如何使用装饰器传递属性并返回一个值。
- en: Using a decorated function with a return value and argument
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用具有返回值和参数的装饰函数
- en: 'When our decorated function takes arguments, then decorating such a function
    requires some additional tricks. One trick is to use `*args` and `**kwargs` in
    the inner wrapper function. This will make the inner function accept any arbitrary
    number of positional and keyword arguments. Here is a simple example of a decorated
    function with arguments along with the return value:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的装饰过函数接受参数时，装饰这样的函数需要一些额外的技巧。一个技巧是在内部包装函数中使用`*args`和`**kwargs`。这将使内部函数能够接受任意数量的位置参数和关键字参数。以下是一个带有参数和返回值的装饰函数的简单示例：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example, the inner function of `inner_calc` takes the generic
    parameters of `*args` and `**kwargs`. To return a value from an inner function
    (in our code example, `inner_calc`), we can hold the returned value from the function
    (in our code example, this is either `func` or `power_base2(n)`) that is executed
    inside our inner function and return the final return value from the inner function
    of `inner_calc`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`inner_calc` 的内部函数接受 `*args` 和 `**kwargs` 的通用参数。要从内部函数（在我们的代码示例中为 `inner_calc`）返回一个值，我们可以保留从函数返回的值（在我们的代码示例中，这是
    `func` 或 `power_base2(n)`），该函数在我们的内部函数内部执行，并从 `inner_calc` 的内部函数返回最终的返回值。
- en: Building a decorator with its own arguments
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立具有其自身参数的装饰器
- en: 'In the previous examples, we used what we call `decorator3.py` example. In
    the revised version, we calculate the power of a base value that is passed as
    an argument to the decorator. You can view a complete code example using nested
    decorator functions as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了所谓的 `decorator3.py` 示例。在修订版中，我们计算作为装饰器参数传递的基数值的幂。您可以通过以下方式查看使用嵌套装饰器函数的完整代码示例：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The working of this code example is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个代码示例的工作原理：
- en: The `power_calc` decorator function takes one argument base and returns the
    `inner_decorator` function, which is a standard decorator implementation.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`power_calc` 装饰器函数接受一个参数 `base` 并返回 `inner_decorator` 函数，这是一个标准的装饰器实现。'
- en: The `inner_decorator` function takes a function as an argument and returns the
    `inner_calc` function to do the actual calculation.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inner_decorator` 函数接受一个函数作为参数，并返回用于实际计算的 `inner_calc` 函数。'
- en: The `inner_calc` function calls the decorated function to get the `exponent`
    attribute (in this case) and then uses the `base` attribute, which is passed to
    the outer decorator function as an argument. As expected, the closure around the
    inner function makes the value of the `base` attribute available to the `inner_calc`
    function.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inner_calc` 函数调用装饰函数以获取 `exponent` 属性（在这种情况下）然后使用 `base` 属性，该属性作为参数传递给外部的装饰器函数。正如预期的那样，围绕内部函数的闭包使得
    `base` 属性的值对 `inner_calc` 函数可用。'
- en: Next, we will discuss how to use more than one decorator with a function or
    a method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何使用一个以上的装饰器与一个函数或方法一起使用。
- en: Using multiple decorators
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个装饰器
- en: 'We have learned numerous times that there is a possibility of using more than
    one decorator with a function. This is possible by chaining the decorators. Chained
    decorators can either be the same or different. This can be achieved by placing
    the decorators one after the other before the function definition. When more than
    one decorator is used with a function, the decorated function is only executed
    once. To illustrate its implementation and practical use, we have selected an
    example in which we log a message to a target system using a timestamp. The timestamp
    is added through a separate decorator, and the target system is also selected
    based on another decorator. The following code sample shows the definitions of
    three decorators, that is, `add_time_stamp`, `file`, and `console`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们多次了解到，使用一个以上的装饰器与一个函数一起使用是可能的。这可以通过链式装饰器实现。链式装饰器可以是相同的也可以是不同的。这可以通过在函数定义之前将装饰器一个接一个地放置来实现。当使用一个以上的装饰器与一个函数一起使用时，装饰函数只执行一次。为了说明其实现和实际应用，我们选择了一个示例，在该示例中，我们使用时间戳将消息记录到目标系统。时间戳是通过一个单独的装饰器添加的，目标系统也是基于另一个装饰器选择的。以下代码示例显示了三个装饰器的定义，即
    `add_time_stamp`、`file` 和 `console`：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code example, we implemented three decorator functions. They
    are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们实现了三个装饰器函数。它们如下：
- en: '`file`: This decorator uses a predefined text file and adds the message provided
    by the decorated function to the file.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`: 这个装饰器使用一个预定义的文本文件，并将装饰函数提供的消息添加到文件中。'
- en: '`console`: This decorator outputs the message provided by the decorated function
    to the console.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console`: 这个装饰器将装饰函数提供的消息输出到控制台。'
- en: '`add_timestamp`: This decorator adds a timestamp prior to the message provided
    by the decorated function. The execution of this decorator function has to occur
    before the file or console decorators, which means this decorator has to be placed
    last in the chain of decorators.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_timestamp`: 这个装饰器在装饰函数提供的消息之前添加一个时间戳。这个装饰器函数的执行必须在文件或控制台装饰器之前，这意味着这个装饰器必须放在装饰器链的末尾。'
- en: 'In the following code snippet, we can use these decorators for different functions
    inside our main program:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们可以在主程序中的不同函数中使用这些装饰器：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code sample, we used the three decorator functions defined
    earlier in different combinations to exhibit the different behaviors from the
    same logging function. In the first combination, we output the message to the
    file only after adding the timestamp. In the second combination, we output the
    message to both the file and the console. In the final combination, we output
    the message to the console only. This shows the flexibility that the decorators
    provide without needing to change the functions. It is worth mentioning that the
    decorators are very useful in simplifying the code and adding behavior in a concise
    way, but they have the cost of additional overheads during execution. The use
    of decorators should be limited to those scenarios where the benefit is enough
    to compensate for any overhead costs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用前面定义的三个装饰器函数的不同组合来展示来自同一日志函数的不同行为。在第一种组合中，我们只在添加时间戳后向文件输出消息。在第二种组合中，我们同时向文件和控制台输出消息。在最后一种组合中，我们只向控制台输出消息。这显示了装饰器提供的灵活性，而无需更改函数。值得一提的是，装饰器在简化代码和以简洁的方式添加行为方面非常有用，但它们在执行期间会产生额外的开销。装饰器的使用应限制在那些收益足以弥补任何开销成本的场景中。
- en: This concludes our discussion regarding advanced function concepts and tricks.
    In the next section, we will switch gears to some advanced concepts related to
    data structures.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对高级函数概念和技巧的讨论。在下一节中，我们将转向与数据结构相关的一些高级概念。
- en: Understanding advanced concepts with data structures
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据结构理解高级概念
- en: Python offers comprehensive support for data structures, including key tools
    for storing data and accessing data for processing and retrieving. In [*Chapter
    4*](B17189_04_Final_PG_ePub.xhtml#_idTextAnchor141), *Python Libraries for Advanced
    Programming*, we discussed the data structure objects that are available in Python.
    In this section, we will cover a number of advanced concepts such as a dictionary
    within a dictionary and how to use comprehension with a data structure. We will
    start by embedding a dictionary inside a dictionary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了对数据结构的全面支持，包括存储数据、访问数据以进行处理和检索的关键工具。在 [*第4章*](B17189_04_Final_PG_ePub.xhtml#_idTextAnchor141)
    *高级编程的 Python 库* 中，我们讨论了 Python 中可用的数据结构对象。在本节中，我们将介绍一些高级概念，例如字典中的字典以及如何使用数据结构进行推导。我们将从在字典中嵌入字典开始。
- en: Embedding a dictionary inside a dictionary
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在字典中嵌入字典
- en: A dictionary in a dictionary or a nested dictionary is the process of putting
    a dictionary inside another dictionary. A nested dictionary is useful in many
    real-world examples, particularly when you are processing and transforming data
    from one format into the other.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个字典中嵌套另一个字典或嵌套字典是将一个字典放入另一个字典的过程。嵌套字典在许多现实世界的例子中非常有用，尤其是在你处理和转换一种格式到另一种格式的数据时。
- en: '*Figure 6.1* shows a nested dictionary. The root dictionary has two dictionaries
    against key `1` and key `3`. The dictionary against key `1` has further dictionaries
    inside it. The dictionary against key `3` is a regular dictionary with key-value
    pairs as its entries:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1* 展示了一个嵌套字典。根字典在键`1`和键`3`处有两个字典。键`1`对应的字典内部还有其他字典。键`3`对应的字典是一个常规字典，其条目是键值对：'
- en: '![Figure 6.1: An example of a dictionary inside a dictionary'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：字典中嵌套字典的示例](img/B17189_06_01.jpg)'
- en: '](img/B17189_06_01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_06_01.jpg](img/B17189_06_01.jpg)'
- en: 'Figure 6.1: An example of a dictionary inside a dictionary'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：字典中嵌套字典的示例
- en: 'The root dictionary shown in *Figure 6.1* can be written as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1* 中显示的根字典可以写成以下形式：'
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we created a root dictionary with a mix of dictionary objects and list
    objects inside it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个根字典，其中包含字典对象和列表对象的混合。
- en: Creating or defining a nested dictionary
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建或定义嵌套字典
- en: 'A nested dictionary can be defined or created by placing comma-separated dictionaries
    within curly brackets. To demonstrate how to create a nested dictionary, we will
    create a dictionary for students. Each student entry will have another dictionary
    with `name` and `age` as its elements, which are mapped to their student number:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在花括号内放置以逗号分隔的字典来定义或创建嵌套字典。为了演示如何创建嵌套字典，我们将创建一个学生字典。每个学生条目将包含另一个字典，其中包含`name`和`age`作为其元素，这些元素映射到他们的学生编号：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we will learn how to create a dictionary dynamically and how to add or
    update nested dictionary elements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何动态创建字典以及如何添加或更新嵌套字典元素。
- en: Adding to a nested dictionary
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向嵌套字典中添加内容
- en: 'To create a dictionary in a dictionary dynamically or to add elements to an
    existing nested dictionary, we can use multiple approaches. In the following code
    example, we will used three different approaches to build a nested dictionary.
    They are the same as the ones we defined in the `dictionary1.py` module:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要动态创建字典或在现有嵌套字典中添加元素，我们可以使用多种方法。在下面的代码示例中，我们将使用三种不同的方法来构建嵌套字典。它们与我们在`dictionary1.py`模块中定义的方法相同：
- en: In the first case, we will build an inner dictionary (that is, `student101`)
    through the direct assignment of key-value pair items and then by assigning it
    to a key in the root dictionary. This is the preferred approach whenever possible
    because the code is both easier to read and manage.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们将通过直接分配键值对项并将它分配给根字典中的一个键来构建一个内部字典（即`student101`）。在可能的情况下，这是首选方法，因为代码既易于阅读也易于管理。
- en: In the second case, we created an empty inner dictionary (that is, `student102`)
    and assigned the values to the keys through assignment statements. This is also
    a preferred approach when the values are available to us through other data structures.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们创建了一个空的内部字典（即`student102`），并通过赋值语句将值分配给键。当值可以通过其他数据结构获得时，这也是一个首选方法。
- en: 'In the third case, we directly initiate an empty directory for the third key
    of the root dictionary. After the initialization process, we assign the values
    using double indexing (that is, two keys): the first key is for the root dictionary,
    and the second key is for the inner dictionary. This approach makes the code concise,
    but it is not a preferred approach if code readability is important for maintenance
    reasons.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三种情况下，我们直接为根字典的第三个键初始化一个空目录。初始化过程完成后，我们使用双重索引（即两个键）分配值：第一个键用于根字典，第二个键用于内部字典。这种方法使代码简洁，但如果代码的可读性对维护很重要，则不是首选方法。
- en: 'The complete code example for these three different cases is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个不同情况的完整代码示例如下：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, we will discuss how to access different elements from a nested dictionary.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何访问嵌套字典中的不同元素。
- en: Accessing elements from a nested dictionary
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问嵌套字典中的元素
- en: 'As we discussed earlier, to add values and dictionaries inside a dictionary,
    we can use double indexing. Alternatively, we can use the `get` method of the
    dictionary object. The same approach is applicable to access different elements
    from an inner dictionary. The following is an example code that illustrates how
    to access different elements from the inner dictionaries using the `get` method
    and double indexes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，要在字典内部添加值和字典，我们可以使用双重索引。或者，我们可以使用字典对象的`get`方法。同样的方法适用于从内部字典访问不同元素。以下是一个示例代码，说明如何使用`get`方法和双重索引从内部字典中访问不同元素：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, we will examine how to delete an inner dictionary or a key-value pair
    item from an inner dictionary.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查如何从内部字典中删除内部字典或键值对项。
- en: Deleting from a nested dictionary
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从嵌套字典中删除
- en: 'To delete a dictionary or an element from a dictionary, we can use the generic
    `del` function, or we can use the `pop` method of the `dictionary` object. In
    the following example code, we will present both the `del` function and the `pop`
    method to demonstrate their usage:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除字典或字典中的元素，我们可以使用通用的`del`函数，或者我们可以使用`dictionary`对象的`pop`方法。在下面的示例代码中，我们将展示`del`函数和`pop`方法的使用：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the next section, we will discuss how comprehension helps to process data
    from different data structure types.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论理解如何帮助处理来自不同数据结构类型的数据。
- en: Using comprehension
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用推导
- en: '**Comprehension** is a quick way in which to build new sequences such as lists,
    sets, and dictionaries from existing sequences. Python supports four different
    types of comprehension, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解**是一种快速构建新序列（如列表、集合和字典）的方法，这些新序列是从现有序列中生成的。Python支持四种不同类型的理解，如下所示：'
- en: List comprehension
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导
- en: Dictionary comprehension
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典推导
- en: Set comprehension
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合推导
- en: Generator comprehension
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器推导
- en: We will discuss a brief overview, with code examples, for each of these comprehension
    types in the following subsections.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下小节中简要概述每种理解类型，并附上代码示例。
- en: List comprehension
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表推导
- en: '**List comprehension** involves creating a dynamic list using a loop and a
    conditional statement if needed.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表推导**涉及使用循环和（如果需要）条件语句创建动态列表。'
- en: 'A few examples of how to use list comprehension will help us to understand
    the concept better. In the first example (that is, `list1.py`), we will create
    a new list from an original list by adding 1 to each element of the original list.
    Here is the code snippet:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 几个使用列表推导的示例将帮助我们更好地理解这个概念。在第一个示例（即 `list1.py`）中，我们将通过给原始列表的每个元素加 1 来创建一个新的列表。以下是代码片段：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case, the new list will be created using the `x+1` expression, where
    `x` is an element in the original list. This is equivalent to the following traditional
    code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，新列表将通过使用 `x+1` 表达式来创建，其中 `x` 是原始列表中的一个元素。这等同于以下传统代码：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using list comprehension, we can achieve these three lines of code with only
    one line of code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导，我们可以只用一行代码就实现这三行代码。
- en: 'In the second example (that is, `list2.py`), we will create a new list from
    the original list of numbers from 1 to 10 but only include even numbers. We can
    do this by simply adding a condition to the previous code example, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例（即 `list2.py`）中，我们将从原始的 1 到 10 的数字列表中创建一个新的列表，但只包含偶数。我们可以通过简单地在之前的代码示例中添加一个条件来实现这一点，如下所示：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the condition is added to the end of the comprehension expression.
    Next, we will discuss how to build dictionaries using comprehension.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，条件被添加到推导表达式的末尾。接下来，我们将讨论如何使用推导来构建字典。
- en: Dictionary comprehension
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典推导
- en: 'Dictionaries can also be created by using **dictionary comprehension**. Dictionary
    comprehension, which is similar to list comprehension, is an approach of creating
    a dictionary from another dictionary in such a way that the items from the source
    dictionary are selected or transformed conditionally. The following code snippet
    shows an example of creating a dictionary from existing dictionary elements that
    are less than or equal to 200 and by dividing each selected value by 2\. Note
    that the values are also converted back into integers as part of the comprehension
    expression:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用**字典推导**来创建字典。字典推导与列表推导类似，是一种从另一个字典中条件性地选择或转换条目的方法。以下代码片段展示了如何从一个现有字典中创建一个新字典，该字典包含小于或等于200的元素，并且通过将每个选定的值除以2来实现。请注意，值在推导表达式中也被转换回整数：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This dictionary comprehension code is equivalent to the following code snippet
    if done using traditional programming:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用传统的编程方式来实现，这段字典推导代码等同于以下代码片段：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that comprehension reduces the code significantly. Next, we will discuss
    set comprehension.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，推导可以显著减少代码量。接下来，我们将讨论集合推导。
- en: Set comrehension
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合推导
- en: 'Sets can also be created using **set comprehension**, just like list comprehension.
    The code syntax for creating sets using set comprehension is similar to list comprehension.
    The exception is that we will be using curly brackets instead of square brackets.
    In the following code snippet, you can view an example of creating a set from
    a list using set comprehension:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表推导类似，也可以使用**集合推导**来创建集合。使用集合推导创建集合的代码语法与列表推导类似。区别在于我们将使用花括号而不是方括号。在以下代码片段中，你可以查看使用集合推导从一个列表中创建集合的示例：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This set comprehension code is equivalent to the following code snippet with
    traditional programming:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段集合推导代码等同于以下使用传统编程方式的代码片段：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As expected, the duplicate entries will be discarded in the set.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，集合中会丢弃重复的条目。
- en: This concludes our discussion regarding the types of comprehension that are
    available in Python for different data structures. Next, we will discuss the filtering
    options that are available with data structures.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Python 中不同数据结构可用的推导类型的讨论。接下来，我们将讨论数据结构可用的过滤选项。
- en: Introducing advanced tricks with pandas DataFrame
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍使用 pandas DataFrame 的高级技巧
- en: '**pandas** is an open source Python library that provides tools for high-performance
    data manipulation to make data analysis quick and easy. The typical uses of the
    pandas library are to reshape, sort, slice, aggregate, and merge data.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**pandas** 是一个开源的 Python 库，它提供了高性能数据操作工具，使数据分析变得快速且简单。pandas 库的典型用途包括重塑、排序、切片、聚合和合并数据。'
- en: The pandas library is built on top of the **NumPy** library, which is another
    Python library that is used for working with arrays. The NumPy library is significantly
    faster than traditional Python lists because data is stored at one continuous
    location in memory, which is not the case with traditional lists.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: pandas库建立在**NumPy**库之上，NumPy是另一个用于处理数组的Python库。NumPy库比传统的Python列表要快得多，因为数据在内存中存储在一个连续的位置，而传统列表则不是这样。
- en: 'The pandas library deals with three key data structures, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: pandas库处理三个关键数据结构，如下所示：
- en: '`Series`: This is a single-dimensional array-like object that contains an array
    of data and an array of data labels. The array of data labels is called an `index`.
    The `index` can be specified automatically using integers from *0 to n-1* if not
    explicitly specified by a user.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series`: 这是一个单维数组样式的对象，包含数据数组和数据标签数组。数据标签数组称为`index`。如果用户没有明确指定，`index`可以使用从*0到n-1*的整数自动指定。'
- en: '`DataFrame`: This is a representation of tabular data such as a spreadsheet
    containing a list of columns. The DataFrame object helps to store and manipulate
    tabular data in rows and columns. Interestingly, the DataFrame object has an index
    for both columns and rows.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame`: 这是表格数据的表示，例如包含列列表的工作表。DataFrame对象有助于在行和列中存储和操作表格数据。有趣的是，DataFrame对象既有列索引也有行索引。'
- en: '`Panel`: This is a three-dimensional container of data.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Panel`: 这是一个三维数据容器。'
- en: The DataFrame is the key data structure that is used in data analysis. In the
    remainder of this section, we will be using the DataFrame object extensively in
    our code examples. Before we discuss any advanced tricks regarding these pandas
    DataFrame objects, we will do a quick review of the fundamental operations available
    for DataFrame objects.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame是数据分析中使用的关键数据结构。在本节的剩余部分，我们将广泛使用DataFrame对象在我们的代码示例中。在我们讨论有关这些pandas
    DataFrame对象的任何高级技巧之前，我们将快速回顾DataFrame对象的基本操作。
- en: Learning DataFrame operations
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习DataFrame操作
- en: 'We will start by creating DataFrame objects. There are several ways to create
    a DataFrame, such as from a dictionary, a CSV file, an Excel sheet, or from a
    NumPy array. One of the easiest ways is to use the data in a dictionary as input.
    The following code snippet shows how you can build a DataFrame object based on
    weekly weather data stored in a dictionary:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建DataFrame对象。创建DataFrame的方法有很多，例如从字典、CSV文件、Excel表或从NumPy数组创建。其中一种最简单的方法是使用字典中的数据作为输入。以下代码片段显示了如何根据存储在字典中的每周天气数据构建DataFrame对象：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The console output will show the contents of the DataFrame as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出将显示DataFrame的内容如下：
- en: '![Figure 6.2 – The contents of the DataFrame](img/B17189_06_02.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – DataFrame的内容](img/B17189_06_02.jpg)'
- en: Figure 6.2 – The contents of the DataFrame
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – DataFrame的内容
- en: 'The pandas library is very rich in terms of methods and attributes. However,
    it is beyond the scope of this section to cover all of them. Instead, we will
    present a quick summary of the commonly used attributes and methods of DataFrame
    objects next to refresh our knowledge before using them in the upcoming code examples:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: pandas库在方法和属性方面非常丰富。然而，本节的范围超出了涵盖所有这些内容。相反，我们将快速总结DataFrame对象常用的属性和方法，以便在使用即将到来的代码示例之前刷新我们的知识：
- en: '`index`: This attribute provides a list of indexes (or labels) of the DataFrame
    object.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`: 此属性提供了DataFrame对象的索引（或标签）列表。'
- en: '`columns`: This attribute provides a list of columns in the DataFrame object.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columns`: 此属性提供了DataFrame对象中的列列表。'
- en: '`size`: This returns the size of the DataFrame object in terms of the number
    of rows multiplied by the number of columns.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`: 这返回DataFrame对象的大小，即行数乘以列数。'
- en: '`shape`: This provides us with a tuple representing the dimension of the DataFrame
    object.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape`: 这为我们提供了一个表示DataFrame对象维度的元组。'
- en: '`axes`: This attribute returns a list that represents the axes of the DataFrame
    object. Put simply, it includes rows and columns.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`axes`: 此属性返回一个表示DataFrame对象轴的列表。简单来说，它包括行和列。'
- en: '`describe`: This powerful method generates statistics data such as the count,
    mean, standard deviation, and minimum and maximum values.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`: 此强大方法生成统计数据，如计数、平均值、标准差以及最小值和最大值。'
- en: '`head`: This method returns *n* (default = 5) rows from a DataFrame object
    similar to the head command on files.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head`: 此方法从类似于文件中head命令的DataFrame对象返回*n*（默认=5）行。'
- en: '`tail`: This method returns the last *n* (default = 5) rows from a DataFrame
    object.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tail`：此方法从 DataFrame 对象返回最后 *n* 行（默认 = 5）。'
- en: '`drop_duplicates`: This method drops duplicate rows based on all of the columns
    in a DataFrame.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop_duplicates`：此方法基于 DataFrame 中的所有列删除重复行。'
- en: '`dropna`: This method removes missing values (such as rows or columns) from
    a DataFrame. By passing appropriate arguments to this method, we can either remove
    rows or columns. Additionally, we can set whether the rows or columns will be
    removed based on a single occurrence of a missing value or only when all of the
    values in a row or column are missing.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dropna`：此方法从 DataFrame 中删除缺失值（如行或列）。通过传递适当的参数给此方法，我们可以删除行或列。此外，我们可以设置是否基于缺失值的单次出现或仅当行或列中的所有值都缺失时删除行或列。'
- en: '`sort_values`: This method can be used to sort the rows based on single or
    multiple columns.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort_values`：此方法可用于根据单个或多个列对行进行排序。'
- en: In the following sections, we will review some fundamental operations for DataFrame
    objects.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将回顾 DataFrame 对象的一些基本操作。
- en: Setting a custom index
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置自定义索引
- en: 'The column labels (index) are normally added as per the data provided with
    a dictionary or according to whatever other input data stream has been used. We
    can change the index of the DataFrame by using one of the following options:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列标签（索引）通常是按照提供的字典中的数据或根据使用的其他输入数据流添加的。我们可以使用以下选项之一更改 DataFrame 的索引：
- en: 'Set one of the data columns as an index, such as `day` in the previously mentioned
    example, by using a simple statement like this:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用简单语句，如以下示例，将其中一个数据列设置为索引，例如之前提到的 `day`：
- en: '[PRE48]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The DataFrame will start using the `day` column as an index column, and its
    contents will be as follows:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DataFrame 将开始使用 `day` 列作为索引列，其内容如下：
- en: '![Figure 6.3 – The contents of the DataFrame after using the day column as
    an index'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.3 – 使用 `day` 列作为索引后 DataFrame 的内容'
- en: '](img/B17189_06_03.jpg)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B17189_06_03.jpg](img/B17189_06_03.jpg)'
- en: Figure 6.3 – The contents of the DataFrame after using the `day` column as an
    index
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 使用 `day` 列作为索引后 DataFrame 的内容
- en: 'Set the index manually by providing it through a list, such as in the following
    code snippet:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供列表手动设置索引，如下所示代码片段：
- en: '[PRE49]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this code snippet, the DataFrame will start using the index as provided
    by us through a list object. The contents of the DataFrame will show this change
    as follows:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用此代码片段，DataFrame 将开始使用我们通过列表对象提供的索引。DataFrame 的内容将显示此更改如下：
- en: '![Figure 6.4 – The contents of the DataFrame after setting custom entries for
    an index column'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – 设置索引列的自定义条目后 DataFrame 的内容'
- en: '](img/B17189_06_04.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_06_04.jpg](img/B17189_06_04.jpg)'
- en: Figure 6.4 – The contents of the DataFrame after setting custom entries for
    an index column
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 设置索引列的自定义条目后 DataFrame 的内容
- en: Next, we will discuss how to navigate inside a DataFrame using a certain index
    and column.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何使用特定的索引和列在 DataFrame 中进行导航。
- en: Navigating inside a DataFrame
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 DataFrame 内部导航
- en: 'There are a few dozen ways in which to get a row of data or a particular location
    from a DataFrame object. The typical methods that are used to navigate inside
    a DataFrame are the `loc` and `iloc` methods. We will explore a few options of
    how to navigate through a DataFrame object using the same sample data that we
    used in the previous example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有几十种方法可以从 DataFrame 对象中获取一行数据或特定位置的数据。在 DataFrame 内部导航的典型方法有 `loc` 和 `iloc`
    方法。我们将通过使用与上一个示例相同的样本数据，探索如何使用这些方法在 DataFrame 对象中导航的几种选项：
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we will discuss a few techniques, with code samples, regarding how to
    select a row or location in this DataFrame object:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论一些关于如何在 DataFrame 对象中选择行或位置的技巧，并附上代码示例：
- en: 'We can select one or more rows by using index labels with the `loc` method.
    The index label is provided as a single item or a list. In the following code
    snippet, we have illustrated two examples of how to select one or more rows:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `loc` 方法通过索引标签选择一行或多行。索引标签以单个项或列表的形式提供。在以下代码片段中，我们展示了如何选择一行或多行的两个示例：
- en: '[PRE51]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can select a value from a location in a DataFrame object using the row index
    label and the column label, as follows:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用行索引标签和列标签从 DataFrame 对象的某个位置选择一个值，如下所示：
- en: '[PRE52]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can also select a row by using an index value without providing any labels:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以通过不提供任何标签而使用索引值来选择一行：
- en: '[PRE53]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can select a value from a location using the row index value and the column
    index value by treating the DataFrame object like a two-dimensional array. In
    the next code snippet, we will get a value from a location in which the row index
    = 2 and the column index = 2:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将 DataFrame 对象视为二维数组，使用行索引值和列索引值来从位置选择一个值。在下一个代码片段中，我们将从行索引 = 2 和列索引 =
    2 的位置获取一个值：
- en: '[PRE54]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Next, we will discuss how to add a row or a column to a DataFrame object.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何向 DataFrame 对象中添加一行或一列。
- en: Adding a row or column to a DataFrame
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向 DataFrame 中添加行或列
- en: 'The easiest way to add a row to a DataFrame object is by assigning a list of
    values to an index location or an index label. For example, we can add a new row
    with the `TST` label for the previous example (that is, `pandas3.py`) by using
    the following statement:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 向 DataFrame 对象中添加一行的最简单方法是将一个值列表赋给一个索引位置或索引标签。例如，我们可以通过以下语句为前一个示例（即 `pandas3.py`）添加一个带有
    `TST` 标签的新行：
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It is important to note that if the row label already exists in the DataFrame
    object, the same line of code can update the row with new values.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，如果行标签已经在 DataFrame 对象中存在，相同的代码行可以更新带有新值的行。
- en: 'If we are not using the index label but the default index instead, we can use
    the index number to update an existing row or add a new row by using the following
    line of code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是使用索引标签而是默认索引，我们可以使用索引号通过以下代码行来更新现有行或添加新行：
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A complete code example is shown for reference:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个完整的代码示例供参考：
- en: '[PRE57]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To add a new column to a DataFrame object, multiple options are available in
    the pandas library. We will only illustrate three options, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 DataFrame 对象中添加新列，pandas 库中提供了多种选项。我们将仅展示三种选项，如下：
- en: '**By adding a list of values next to the column label**: This approach will
    add a column after the existing columns. If we use an existing column label, this
    approach can also be used to update or replace an existing column.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在列标签旁边添加值列表**：此方法将在现有列之后添加列。如果我们使用现有的列标签，此方法也可以用于更新或替换现有列。'
- en: '**By using the insert method**: This method will take a label and a list of
    values as arguments. This is particularly useful when you want to insert a column
    at any location. Note that this method does not allow you to insert a column if
    there is already an existing column inside the DataFrame object with the same
    label. This means this method cannot be used to update an existing column.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 insert 方法**：此方法将接受一个标签和一个值列表作为参数。当您想在任何位置插入列时，此方法特别有用。请注意，此方法不允许在 DataFrame
    对象中已存在具有相同标签的列的情况下插入列。这意味着此方法不能用于更新现有列。'
- en: '**By using the assign method**: This method is useful when you want to add
    multiple columns in one go. If we use an existing column label, this method can
    be used to update or replace an existing column.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 assign 方法**：当您想一次添加多个列时，此方法很有用。如果我们使用现有的列标签，此方法也可以用于更新或替换现有列。'
- en: 'In the following code example, we will use all three approaches to insert a
    new column to a DataFrame object:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们将使用三种方法中的所有三种来向 DataFrame 对象中插入新列：
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, we will evaluate how to delete rows and columns from a DataFrame object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将评估如何从 DataFrame 对象中删除行和列。
- en: Deleting an index, a row, or a column from a DataFrame
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 DataFrame 中删除索引、行或列
- en: 'Removing an index is relatively straightforward, and you can do so by using
    the `reset_index` method. However, the `reset_index` method adds default indexes
    and keeps the custom index column as a data column. To remove the custom index
    column completely, we have to use the `drop` argument with the `reset_index` method.
    The following code snippet uses the `reset_index` method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 删除索引相对简单，您可以使用 `reset_index` 方法来完成。然而，`reset_index` 方法会添加默认索引并保留自定义索引列作为数据列。要完全删除自定义索引列，我们必须使用
    `drop` 参数与 `reset_index` 方法一起使用。以下代码片段使用了 `reset_index` 方法：
- en: '[PRE59]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To delete a duplicate row from a DataFrame object, we can use the `drop_duplicate`
    method. To delete a particular row or column, we can use the `drop` method. In
    the following code example, we will remove any rows with the `SAT` and `SUN` labels
    and any columns with the `condition` label:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 DataFrame 对象中删除重复行，我们可以使用 `drop_duplicate` 方法。要删除特定的行或列，我们可以使用 `drop` 方法。在以下代码示例中，我们将删除任何带有
    `SAT` 和 `SUN` 标签的行以及任何带有 `condition` 标签的列：
- en: '[PRE60]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Next, we will examine how to rename an index or a column.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查如何重命名索引或列。
- en: Renaming indexes and columns in a DataFrame
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 DataFrame 中重命名索引和列
- en: 'To rename an index or a column label, we will use the `rename` method. A code
    example of how to rename an index and a column is as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要重命名索引或列标签，我们将使用 `rename` 方法。以下是如何重命名索引和列的代码示例：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It is important to note that the current label and the new label for the index
    and column are provided as a dictionary. Next, we will discuss some advanced tricks
    for using DataFrame objects.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当前标签和新标签作为字典提供。接下来，我们将讨论一些使用 DataFrame 对象的高级技巧。
- en: Learning advanced tricks for a DataFrame object
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习 DataFrame 对象的高级技巧
- en: In the previous section, we evaluated the fundamental operations that can be
    performed on a DataFrame object. In this section, we will investigate the next
    level of operations on a DataFrame object for data evaluation and transformation.
    These operations are discussed in the following subsections.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们评估了可以在 DataFrame 对象上执行的基本操作。在本节中，我们将探讨 DataFrame 对象数据评估和转换的下一级操作。这些操作将在以下子节中讨论。
- en: Replacing data
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换数据
- en: 'One common requirement is to replace numeric data or string data with another
    set of values. The pandas library is full of options in which to carry out such
    data replacements. The most popular method for these operations is to use the
    `at` method. The `at` method provides an easy way to access or update data in
    any cell in a DataFrame. For bulk replacement operations, you can also use a `replace`
    method, and we can use this method in many ways. For example, we can use this
    method to replace a number with another number or a string with another string,
    or we can replace anything that matches a regular expression. Additionally, we
    can use this method to replace any entries provided through a list or a dictionary.
    In the following code example (that is, `pandastrick1.py`), we will cover most
    of these replacement options. For this code example, we will use the same DataFrame
    object that we used in previous code examples. Here is the sample code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是将数值数据或字符串数据替换为另一组值。pandas 库提供了许多选项来执行此类数据替换。这些操作中最受欢迎的方法是使用 `at` 方法。`at`
    方法提供了一种简单的方式来访问或更新 DataFrame 中的任何单元格中的数据。对于批量替换操作，您还可以使用 `replace` 方法，并且我们可以以多种方式使用此方法。例如，我们可以使用此方法将一个数字替换为另一个数字或一个字符串替换为另一个字符串，或者我们可以替换任何匹配正则表达式的项。此外，我们可以使用此方法替换通过列表或字典提供的任何条目。在以下代码示例（即
    `pandastrick1.py`）中，我们将涵盖这些替换选项的大部分。对于此代码示例，我们将使用与之前代码示例相同的 DataFrame 对象。以下是示例代码：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we will explore several replacement operations on this DataFrame object,
    one by one:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐一探索对这个 DataFrame 对象的几个替换操作：
- en: 'Replace any occurrences of the numeric value of `40` with `39` across the DataFrame
    object using the following statement:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下语句在 DataFrame 对象中将所有出现的 `40` 的数值替换为 `39`：
- en: '[PRE63]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Replace any occurrences of a `Sunny` string with `Sun` across the DataFrame
    object using the following statement:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下语句在 DataFrame 对象中将所有出现的 `Sunny` 字符串替换为 `Sun`：
- en: '[PRE64]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Replace any occurrences of a string based on a regular expression (the aim
    is to replace `Cloudy` with `Cloud`) using the following statement:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下语句替换基于正则表达式的字符串（目的是将 `Cloudy` 替换为 `Cloud`）：
- en: '[PRE65]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that the use of the `to_replace` and `value` argument labels is optional.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，使用 `to_replace` 和 `value` 参数标签是可选的。
- en: 'Replace any occurrences of multiple strings represented by a list with another
    list of strings using the following statement:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下语句将表示为列表的多个字符串替换为另一个字符串列表：
- en: '[PRE66]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this code, we replaced `Monday` and `Tuesday` with `Mon` and `Tue`.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，我们将 `Monday` 和 `Tuesday` 替换为 `Mon` 和 `Tue`。
- en: 'Replace any occurrences of multiple strings in a DataFrame object using the
    key-value pairs in a dictionary. You can do this by using the following statement:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典中的键值对替换 DataFrame 对象中的多个字符串。您可以通过以下语句来完成此操作：
- en: '[PRE67]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this case, the keys of the dictionary (that is, `Wednesday` and `Thursday`)
    will be replaced by their corresponding values (that is, `Wed` and `Thu`).
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，字典的键（即 `Wednesday` 和 `Thursday`）将被它们对应的值（即 `Wed` 和 `Thu`）替换。
- en: 'Replace any occurrences of a string for a certain column using multiple dictionaries.
    You can do this by using the column name as a key in the dictionary and a sample
    statement such as the following:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个字典替换特定列中的字符串。您可以通过使用列名作为字典的键以及如下示例语句来完成此操作：
- en: '[PRE68]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this scenario, the first dictionary is used to indicate the column name and
    the value to be replaced. The second dictionary is used to indicate the same column
    name but with a value that will replace the original value. In our case, we will
    replace all instances of `Friday` in the `day` column with the value of `Fri`.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个字典用于指示列名和要替换的值。第二个字典用于指示相同的列名，但具有将替换原始值的值。在我们的例子中，我们将 `day` 列中所有 `Friday`
    的实例替换为 `Fri` 的值。
- en: 'Replace any occurrences of multiple strings using a nested dictionary. You
    can do this by using a code sample such as the following:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套字典替换多个字符串的出现。你可以通过以下代码示例来完成此操作：
- en: '[PRE69]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this scenario, the outer dictionary (with the `day` and `condition` keys
    in our code sample) is used to identify the columns for this operation and the
    inner dictionary is used to hold the data to be replaced along with the replacing
    value. By using this approach, we replaced `Saturday` and `Sunday` with `Sat`
    and `Sun` inside the `day` column and the `Rainy` string with `Rain` inside the
    `condition` column.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，外层字典（在我们的代码示例中包含 `day` 和 `condition` 键）用于标识此操作的列，内层字典用于存储要替换的数据以及替换值。通过使用这种方法，我们在
    `day` 列中将 `Saturday` 和 `Sunday` 替换为 `Sat` 和 `Sun`，在 `condition` 列中将 `Rainy` 字符串替换为
    `Rain`。
- en: The complete code with all these sample operations is available within the source
    code of this chapter as `pandastrick1.py`. Note that we can either trigger the
    replacement operation across the DataFrame object or we can limit it to a certain
    column or a row.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有这些示例操作的完整代码位于本章源代码中的 `pandastrick1.py`。请注意，我们可以触发跨 DataFrame 对象的替换操作，或者将其限制在特定的列或行。
- en: Important note
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `inplace=True` argument is used with all `replace` method calls. This argument
    is used to set the output of the `replace` method within the same DataFrame object.
    The default option is to return a new DataFrame object without changing the original
    object. This argument is available with many DataFrame methods for convenience.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`inplace=True` 参数与所有 `replace` 方法调用一起使用。此参数用于在同一个 DataFrame 对象内设置 `replace`
    方法的输出。默认选项是返回一个新的 DataFrame 对象，而不更改原始对象。此参数在许多 DataFrame 方法中可用，以方便使用。'
- en: Applying a function to the column or row of a DataFrame object
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将函数应用于 DataFrame 对象的列或行
- en: Sometimes, we want to clean up the data, adjust the data, or transform the data
    before starting data analysis. There is an easy way in which to apply some type
    of function on a DataFrame using the `apply`, `applymap`, or `map` methods. The
    `apply` method is applicable to columns or rows, while the `applymap` method works
    element by element for the whole DataFrame. In comparison, the `map` method works
    element by element for a single series. Now, we will discuss a couple of code
    examples to illustrate the use of the `apply` and `map` methods.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们在开始数据分析之前想要清理数据、调整数据或转换数据。有一种简单的方法可以在 DataFrame 上应用某种类型的函数，使用 `apply`、`applymap`
    或 `map` 方法。`apply` 方法适用于列或行，而 `applymap` 方法对整个 DataFrame 的每个元素进行操作。相比之下，`map`
    方法对单个序列的每个元素进行操作。现在，我们将通过几个代码示例来讨论 `apply` 和 `map` 方法的使用。
- en: It is common to have data imported into a DataFrame object that might need some
    cleaning up. For example, it could have trailing or leading whitespaces, new line
    characters, or any unwanted characters. These can be removed from the data easily
    by using the `map` method and the lambda function on a column series. The lambda
    function is used on each element of the column. In our code example, first, we
    will remove the trailing whitespace, dot, and comma. Then, we will remove the
    leading whitespace, underscore, and dash for the `condition` column.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将数据导入 DataFrame 对象时可能需要进行一些清理。例如，它可能有尾随或前导空格、换行符或任何不需要的字符。这些可以通过使用 `map`
    方法和列序列上的 lambda 函数轻松地从数据中删除。lambda 函数用于列的每个元素。在我们的代码示例中，首先，我们将删除尾随空格、句点和逗号。然后，我们将删除
    `condition` 列的前导空格、下划线和破折号。
- en: 'After cleaning up the data inside the `condition` column, the next step is
    to create a new `temp_F` column from the values of the `temp` column and convert
    them from Celsius units into Fahrenheit units. Note that we will use another lambda
    function for this conversion and use the `apply` method. When we get the result
    from the `apply` method, we will store it inside a new column label, `temp_F`,
    to create a new column. Here is the complete code example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理 `condition` 列中的数据之后，下一步是从 `temp` 列的值创建一个新的 `temp_F` 列，并将它们从摄氏单位转换为华氏单位。请注意，我们将为此转换使用另一个
    lambda 函数，并使用 `apply` 方法。当我们从 `apply` 方法得到结果时，我们将它存储在一个新的列标签 `temp_F` 中，以创建一个新的列。以下是完整的代码示例：
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that for the preceding code example, we provided the same input data as
    in previous examples except that we added trailing and leading characters to the
    `condition` column data.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于前面的代码示例，我们提供了与之前示例相同的输入数据，除了我们在 `condition` 列的数据中添加了尾随和前导字符。
- en: Querying rows in a DataFrame object
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 DataFrame 对象中查询行
- en: 'To query rows based on the values in a certain column, one common approach
    is to apply a filter using *AND* or *OR* logical operations. However, this quickly
    becomes a messy approach for simple requirements such as searching a row with
    a value in between a range of values. The pandas library offers a cleaner tool:
    the `between` method, which is somewhat similar to the *between* keyword in SQL.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据某一列的值查询行，一种常见的方法是应用使用 *AND* 或 *OR* 逻辑运算的过滤器。然而，对于像在值范围内搜索行这样的简单需求，这很快就会变得杂乱无章。pandas
    库提供了一个更干净的工具：`between` 方法，它在某种程度上类似于 SQL 中的 *between* 关键字。
- en: 'The following code example uses the same `weekly_data` DataFrame object that
    we used in the previous example. First, we will show the use of a traditional
    filter, and then we will show the use of the `between` method to query the rows
    that have temperature values between 30 and 40 inclusively:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例使用了我们在上一个示例中使用的相同的 `weekly_data` DataFrame 对象。首先，我们将展示传统过滤器的使用，然后我们将展示使用
    `between` 方法查询温度值在 30 到 40（包括）之间的行：
- en: '[PRE71]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We get the same console output for both approaches we used. However, using the
    `between` method is far more convenient than writing conditional filters.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了两种方法都相同的控制台输出。然而，使用 `between` 方法比编写条件过滤器要方便得多。
- en: 'Querying rows based on text data is also very well supported in the pandas
    library. This can be achieved by using the `str` accessor on the string-type columns
    of the DataFrame object. For example, if we want to search rows in our `weekly_data`
    DataFrame object based on the condition of a day, such as `Rainy` or `Sunny`,
    we can either write a traditional filter or we can use the `str` accessor on the
    column with the `contains` method. The following code example illustrates the
    use of both options to get the rows with `Rainy` or `Sunny` as data values in
    the `condition` column:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 库中，基于文本数据的行查询也得到了很好的支持。这可以通过在 DataFrame 对象的字符串类型列上使用 `str` 访问器来实现。例如，如果我们想根据
    `Rainy` 或 `Sunny` 等条件在我们的 `weekly_data` DataFrame 对象中搜索行，我们既可以编写传统的过滤器，也可以在具有
    `contains` 方法的列上使用 `str` 访问器。以下代码示例说明了使用这两种选项获取 `condition` 列中数据值为 `Rainy` 或 `Sunny`
    的行：
- en: '[PRE72]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you run the preceding code, you will find that the console output is the
    same for both of the approaches we used for searching the data.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会发现我们用于搜索数据的两种方法都得到了相同的控制台输出。
- en: Getting statistics on the DataFrame object data
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 DataFrame 对象数据的统计信息
- en: 'To get statistical data such as central tendency, standard deviation, and shape,
    we can use the `describe` method. The output of the `describe` method for numeric
    columns includes the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取诸如集中趋势、标准差和形状之类的统计数据，我们可以使用 `describe` 方法。`describe` 方法的数值列输出包括以下内容：
- en: '`count`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`'
- en: '`mean`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mean`'
- en: '`standard deviation`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`standard deviation`'
- en: '`min`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`'
- en: '`max`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`'
- en: '`25`th `percentiles, 50`th `percentile, 75`th `percentile`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`25`th 百分位数，`50`th 百分位数，`75`th 百分位数'
- en: The default breakdown of percentiles can be changed by using the `percentiles`
    argument with the desired breakdown.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `percentiles` 参数并指定所需的分解来更改百分位数的默认分解。
- en: If the `describe` method is used for non-numeric data, such as strings, we will
    get *count*, *unique*, *top*, and *freq*. The *top* value is the most common value,
    whereas *freq* is the most common value frequency. By default, only numeric columns
    are evaluated by the `describe` method unless we provide the `include` argument
    with an appropriate value.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `describe` 方法用于非数值数据，例如字符串，我们将得到 *count*、*unique*、*top* 和 *freq*。*top* 值是最常见的值，而
    *freq* 是最常见的值频率。默认情况下，除非我们提供带有适当值的 `include` 参数，否则 `describe` 方法只会评估数值列。
- en: 'In the following code example, we will evaluate the following for the same
    `weekly_date` DataFrame object:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们将评估同一个 `weekly_date` DataFrame 对象：
- en: The use of the `describe` method with or without the `include` argument
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用或不用 `include` 参数的 `describe` 方法
- en: The use of the `percentiles` argument with the `describe` method
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `describe` 方法的 `percentiles` 参数
- en: The use of the `groupby` method to group data on a column basis and then using
    the `describe` method on top of it
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `groupby` 方法按列分组数据，然后在其上使用 `describe` 方法
- en: 'The complete code example is as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码示例如下：
- en: '[PRE73]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note that we changed the `max_columns` options for the pandas library at the
    beginning in order to display all of the columns that we expected in the console
    output. Without this, some of the columns will be truncated for the console output
    of the `groupby` method.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在开始时更改了 pandas 库的 `max_columns` 选项，以便在控制台输出中显示我们预期的所有列。如果没有这样做，`groupby`
    方法的控制台输出中的一些列将被截断。
- en: This concludes our discussion of the advanced tricks of working with a DataFrame
    object. This set of tricks and tips will empower anyone to start using the pandas
    library for data analysis. For additional advanced concepts, we recommend that
    you refer to the official documentation of the pandas library.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 DataFrame 对象高级技巧的讨论。这套技巧和提示将使任何人都能开始使用 pandas 库进行数据分析。对于额外的先进概念，我们建议您参考
    pandas 库的官方文档。
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced some advanced tricks that are important when
    you want to write efficient and concise programs in Python. We started with advanced
    functions such as the mapper, reducer, and filter functions. We also discussed
    several advanced concepts of functions, such as inner functions, lambda functions,
    and decorators. This was followed by a discussion of how to use data structures,
    including nested dictionaries and comprehensions. Finally, we reviewed the fundamental
    operations of a DataFrame object, and then we evaluated a few use cases using
    some advanced operations of the DataFrame object.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些在您想要编写高效且简洁的 Python 程序时非常重要的高级技巧。我们从高级函数，如 mapper、reducer 和 filter
    函数开始。我们还讨论了函数的几个高级概念，如内部函数、lambda 函数和装饰器。随后，我们讨论了如何使用数据结构，包括嵌套字典和推导式。最后，我们回顾了
    DataFrame 对象的基本操作，然后使用一些 DataFrame 对象的高级操作评估了一些用例。
- en: This chapter mainly focused on hands-on knowledge and experience of how to use
    advanced concepts in Python. This is important for anyone who wants to develop
    Python applications, especially for data analysis. The code examples provided
    in this chapter are very helpful for you to begin learning the advanced tricks
    that are available for functions, data structures, and the pandas library.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注如何使用 Python 的高级概念的实际知识和经验。这对于任何想要开发 Python 应用程序的人来说都很重要，尤其是对于数据分析。本章提供的代码示例对于您开始学习可用于函数、数据结构和
    pandas 库的高级技巧非常有帮助。
- en: In the next chapter, we will explore multiprocessing and multithreading in Python.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Python 中的多进程和多线程。
- en: Questions
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the `map`, `filter`, and `reduce` functions are built-in Python functions?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map`、`filter` 和 `reduce` 函数中哪些是 Python 的内置函数？'
- en: What are standard decorators?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准装饰器是什么？
- en: Would you prefer a generator comprehension or a list comprehension for a large
    dataset?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大数据集，您更愿意使用生成器推导式还是列表推导式？
- en: What is a DataFrame in the context of the pandas library?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 pandas 库的上下文中，DataFrame 是什么？
- en: What is the purpose of the `inplace` argument in pandas' library methods?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pandas 库方法中 `inplace` 参数的目的是什么？
- en: Further reading
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering Python Design Patterns*, by Sakis Kasampalis'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《精通 Python 设计模式》，作者：Sakis Kasampalis
- en: '*Python for Data Analysis*, by Wes McKinney'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Python 数据分析》，作者：Wes McKinney
- en: '*Hands-On Data Analysis with Pandas*, *Second Edition*, by Stefanie Molin'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《使用 Pandas 进行动手数据分析》（第二版），作者：Stefanie Molin
- en: '*The official Pandas documentation*, which is available at [https://pandas.pydata.org/docs/](https://pandas.pydata.org/docs/)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*官方Pandas文档*，可在[https://pandas.pydata.org/docs/](https://pandas.pydata.org/docs/)找到'
- en: Answers
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `map` and the `filter` functions are built-in.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map`和`filter`函数是内置的。'
- en: Standard decorators are the ones without any arguments.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准装饰器是没有任何参数的装饰器。
- en: The generator comprehension is preferred in this case. It is memory efficient
    as the values are generated one by one.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，推荐使用生成器推导式。因为它内存效率高，值是逐个生成的。
- en: The DataFrame is a representation of tabular data, such as a spreadsheet, and
    is a commonly used object for data analysis using the pandas library.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DataFrame是表格数据的表示，如电子表格，是使用pandas库进行数据分析的常用对象。
- en: When the `inplace` argument in pandas' library methods is set to `True`, the
    result of the operation is saved to the same DataFrame object on which the operation
    is applied.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当pandas库方法中的`inplace`参数设置为`True`时，操作的输出结果将保存到应用操作的同一DataFrame对象上。
