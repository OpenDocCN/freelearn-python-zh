- en: Chapter 1. Cython Won't Bite
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. Cython 不会咬人
- en: Cython is much more than a programming language. Its origin can be traced to
    SAGE, the mathematics software package, where it is used to increase the performance
    of mathematical computations such as those involving matrices. More generally,
    I tend to consider Cython as an alternative to SWIG to generate really good Python
    bindings to native code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 远不止是一种编程语言。其起源可以追溯到 SAGE，这是一个数学软件包，其中它被用来提高涉及矩阵等数学计算的性能。更普遍地说，我倾向于将 Cython
    视为 SWIG 的替代品，用于生成非常好的 Python 到本地代码的绑定。
- en: Language bindings have been around for years, and SWIG was one of the first
    and best tools to generate bindings for multitudes of languages. Cython generates
    bindings for Python code only, and this single purpose approach means it generates
    the best Python bindings you can get outside of doing it all manually, which should
    be attempted only if you're a Python core developer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 语言绑定已经存在多年，SWIG 是最早和最好的用于为多种语言生成绑定的工具之一。Cython 仅生成 Python 代码的绑定，这种单一目的的方法意味着它生成的
    Python 绑定是您能得到的最好的，除了手动完成之外，这应该只在您是 Python 核心开发者的情况下尝试。
- en: For me, taking control of legacy software by generating language bindings is
    a great way to reuse any software package. Consider a legacy application written
    in C/C++. Adding advanced modern features such as a web server for a dashboard
    or message bus is not a trivial thing to do. More importantly, Python comes with
    thousands of packages that have been developed, tested, and used by people for
    a long time that can do exactly that. Wouldn't it be great to take advantage of
    all of this code? With Cython, we can do exactly this, and I will demonstrate
    approaches with plenty of example codes along the way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，通过生成语言绑定来控制遗留软件是一种很好的重用任何软件包的方法。考虑一个用 C/C++ 编写的遗留应用程序。为仪表板或消息总线添加高级现代功能，如网络服务器，并不是一件简单的事情。更重要的是，Python
    拥有数千个经过开发、测试并由人们长期使用、能够完成这些任务的软件包。利用所有这些代码不是很好吗？使用 Cython，我们确实可以做到这一点，我将在过程中通过大量的示例代码来展示方法。
- en: This first chapter will be dedicated to the core concepts on using Cython, including
    compilation, and should provide a solid reference and introduction for all the
    Cython core concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将致力于 Cython 的核心概念，包括编译，并应为所有 Cython 核心概念提供一个坚实的参考和介绍。
- en: 'In this first chapter, we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Installing Cython
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Cython
- en: Getting started - Hello World
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入门 - Hello World
- en: Using distutils with Cython
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 distutils 与 Cython
- en: Calling C functions from Python
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Python 调用 C 函数
- en: Type conversion
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换
- en: Installing Cython
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Cython
- en: Since Cython is a programming language, we must install its respective compiler,
    which just so happens to be the aptly named *Cython*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Cython 是一种编程语言，我们必须安装其相应的编译器，而这个编译器恰好被恰当地命名为 *Cython*。
- en: 'There are many different ways to install Cython. The preferred one would be
    to use `pip`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Cython 有许多不同的方法。首选的方法是使用 `pip`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should work on both Linux and Mac. Alternatively, you can use your Linux
    distribution''s package manager to install Cython:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在 Linux 和 Mac 上都适用。或者，您可以使用您的 Linux 发行版的包管理器来安装 Cython：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For Windows, although there are a plethora of options available, following
    this wiki is the safest option to stay up-to-date: [http://wiki.cython.org/InstallingOnWindows](http://wiki.cython.org/InstallingOnWindows).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 系统，尽管有众多选项可用，但遵循本维基是保持最新状态的最安全选项：[http://wiki.cython.org/InstallingOnWindows](http://wiki.cython.org/InstallingOnWindows)。
- en: Emacs mode
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Emacs 模式
- en: 'There is an **emacs** mode available for Cython. Although the syntax is nearly
    the same as Python, there are differences that conflict in simply using Python-mode.
    You can grab `cython-mode.el` from the Cython source code (inside the `Tools`
    directory.) The preferred way of installing packages to emacs would be to use
    a package repository like `MELPA`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 有一个可用的 **emacs** 模式。尽管语法几乎与 Python 相同，但与简单地使用 Python-mode 存在着冲突。您可以从
    Cython 源代码（在 `Tools` 目录内）中获取 `cython-mode.el`。在 emacs 中安装包的首选方法是使用包仓库，如 `MELPA`：
- en: 'To add the package repository to emacs, open your `~/.emacs` configuration
    file and add:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要将包仓库添加到 emacs，打开您的 `~/.emacs` 配置文件并添加：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you add this and reload your configuration to install the Cython mode,
    you can simply run:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加此内容并重新加载您的配置以安装 Cython 模式，您只需运行：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once this is installed, you can activate the mode by adding this into your
    emacs config file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，您可以通过将以下内容添加到您的 emacs 配置文件中来激活模式：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can activate the mode manually at any time with:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时手动激活该模式，方法如下：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Getting the code examples
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取代码示例
- en: 'Throughout this book, I intend to show real examples that are easy to digest
    in order to help you get a feel of the different things you can achieve with Cython.
    To access and download the code used, please clone this repository:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我打算展示一些易于消化的真实示例，以帮助你了解你可以使用 Cython 实现的不同事情。要访问和下载使用的代码，请克隆此存储库：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Getting started – Hello World
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门 – Hello World
- en: 'As you will see when running the **Hello World** program, Cython generates
    native Python modules. Therefore, running any Cython code, you will reference
    it via a module import in Python. Let''s build the module:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 **Hello World** 程序时，你会看到 Cython 生成原生 Python 模块。因此，运行任何 Cython 代码时，你将通过
    Python 的模块导入来引用它。让我们构建这个模块：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should now have created `helloworld.so`! This is a Cython module of the
    same name as the Cython source code file. While in the same directory of the shared
    object module, you can invoke this code by running a respective Python import:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经创建了 `helloworld.so`！这是一个与 Cython 源代码文件同名的 Cython 模块。在共享对象模块的同一目录下，你可以通过运行相应的
    Python 导入来调用此代码：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see by opening `helloworld.pyx`, it looks just like a normal Python
    Hello World application, but as previously stated, Cython generates modules. These
    modules need a name so that they can be correctly imported by the Python runtime.
    The Cython compiler simply uses the name of the source code file. It then requires
    us to compile this to the same shared object name.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开 `helloworld.pyx`，你可以看到它看起来就像一个普通的 Python Hello World 应用程序，但如前所述，Cython
    生成模块。这些模块需要一个名称，以便它们可以被 Python 运行时正确导入。Cython 编译器简单地使用源代码文件的名称。然后它要求我们将这个模块编译成相同的共享对象名称。
- en: Overall, Cython source code files have the `.pyx`,`.pxd`, and `.pxi` extensions.
    For now, all we care about are the `.pyx` files; the others are for **cimports**
    and **includes** respectively within a `.pyx` module file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Cython 源代码文件具有 `.pyx`、`.pxd` 和 `.pxi` 扩展名。目前，我们只关心 `.pyx` 文件；其他文件分别用于 `.pyx`
    模块文件中的 **cimports** 和 **includes**。
- en: 'The following screenshot depicts the compilation flow required to have a callable
    native Python module:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了创建可调用的原生 Python 模块所需的编译流程：
- en: '![Getting started – Hello World](img/B04685_01_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![入门 – Hello World](img/B04685_01_01.jpg)'
- en: 'I wrote a basic `makefile` so that you can simply run `make` to compile these
    examples. Here''s the code to do this manually:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一个基本的 `makefile`，这样你只需运行 `make` 就可以编译这些示例。以下是手动执行此操作的代码：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using distutils with Cython
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cython 的 distutils
- en: 'You can also compile this HelloWorld example module using Python `distutils`
    and `cythonize`. Open the `setup.py` along side the Makefile and you can see the
    alternate way to compile Cython modules:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 Python 的 `distutils` 和 `cythonize` 来编译这个 HelloWorld 示例模块。打开与 Makefile
    并排的 `setup.py` 文件，你可以看到编译 Cython 模块的另一种方法：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the `cythonize` function as part of the `ext_modules` section will build
    any specified Cython source into an installable Python module. This will compile
    `helloworld.pyx` into the same shared library. This provides the Python practice
    to distribute native modules as part of `distutils`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `cythonize` 函数作为 `ext_modules` 部分的一部分，可以将任何指定的 Cython 源代码编译成可安装的 Python 模块。这将
    `helloworld.pyx` 编译成相同的共享库。这为使用 `distutils` 分发原生模块提供了 Python 实践。
- en: Calling C functions from Python
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Python 调用 C 函数
- en: We should be careful for clarity when talking about Python and Cython since
    the syntax is so similar. Let's wrap a simple `AddFunction` in C and make it callable
    from Python.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论 Python 和 Cython 时，我们应该小心清晰，因为它们的语法非常相似。让我们用 C 包装一个简单的 `AddFunction` 并使其可从
    Python 调用。
- en: 'First, open a file called `AddFunction.c`, and write a simple function in it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个名为 `AddFunction.c` 的文件，并在其中编写一个简单的函数：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the C code that we will call—just a simple function to add two integers.
    Now, let''s get Python to call it. Open a file called `AddFunction.h`, wherein
    we will declare our prototype:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要调用的 C 代码——只是一个简单的将两个整数相加的函数。现在，让我们让 Python 调用它。打开一个名为 `AddFunction.h`
    的文件，在其中我们将声明我们的原型：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need this so that Cython can see the prototype for the function we want to
    call. In practice, you will already have your headers in your own project with
    your prototypes and declarations already available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个原型，以便 Cython 可以看到我们想要调用的函数的原型。在实践中，你已经在自己的项目中有了自己的头文件，其中包含了你的原型和声明。
- en: 'Open a file called `AddFunction.pyx`, and insert the following code in it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个名为 `AddFunction.pyx` 的文件，并在其中插入以下代码：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we have to declare which code we want to call. The `cdef` is a keyword
    signifying that this is from the C code that will be linked in. Now, we need a
    Python entry point:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须声明我们想要调用的代码。`cdef` 是一个关键字，表示这是来自将被链接的 C 代码。现在，我们需要一个 Python 入口点：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `Add` function is a Python callable inside a `PyAddFunction` module this
    acts as a wrapper for Python code to be able to call directly into the C code.
    Again, I have provided a handy `makefile` to produce the module:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Add` 函数是一个位于 `PyAddFunction` 模块中的 Python 可调用函数，它作为 Python 代码的包装器，以便能够直接调用
    C 代码。再次强调，我已经提供了一个方便的 `makefile` 来生成模块：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice that `AddFunction.c` is compiled into the same `PyAddFunction.so` shared
    object. Now, let''s call this `AddFunction` and check to see if C can add numbers
    correctly:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`AddFunction.c` 被编译成相同的 `PyAddFunction.so` 共享对象。现在，让我们调用这个 `AddFunction`
    并检查 C 是否能正确地添加数字：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that the print statement inside the `AddFunction` and the final result
    are printed correctly. Therefore, we know that the control hit the C code and
    did the calculation in C, and not inside the Python runtime. This is a revelation
    of what is possible. Python can be cited to be slow in some circumstances. Using
    this technique makes it possible for Python code to bypass its own runtime and
    to run in an unsafe context, which is unrestricted by the Python runtime which
    is much faster.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`AddFunction` 内部的打印语句和最终结果打印正确。因此，我们知道控制流到达了 C 代码，并在 C 中进行了计算，而不是在 Python
    运行时内部。这是可能的揭示。在某些情况下，人们可能会引用 Python 的速度较慢。使用这种技术使得 Python 代码能够绕过其自己的运行时，并在不受 Python
    运行时限制的不安全环境中运行，这要快得多。
- en: Type conversion in Cython
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cython 中的类型转换
- en: 'Notice that we had to declare a prototype inside the Cython source code `PyAddFunction.pyx`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不得不在 Cython 源代码 `PyAddFunction.pyx` 内部声明一个原型：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It lets the compiler know that there is a function called `AddFunction` and
    it takes two ints and returns an int. This is all the information the compiler
    needs to know beside the host and target operating system''s calling convention
    to call this function safely. Then, we created the Python entry point, which is
    a Python callable that takes two parameters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这让编译器知道存在一个名为 `AddFunction` 的函数，它接受两个整数参数并返回一个整数。除了主机和目标操作系统的调用约定之外，编译器需要知道的所有信息都在这里。然后，我们创建了
    Python 入口点，它是一个接受两个参数的 Python 可调用函数：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inside this entry point, it simply returned the native `AddFunction` and passed
    the two Python objects as parameters. This is what makes Cython so powerful. Here,
    the Cython compiler must inspect the function call and generate code to safely
    try and convert these Python objects to native C integers. This becomes difficult
    when precision is taken into account as well as potential overflow, which just
    so happens to be a major use case since it handles everything so well. Also, remember
    that this function returns an integer, and Cython also generates code to convert
    the integer return into a valid Python object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个入口点内部，它简单地返回了本地的 `AddFunction` 并将两个 Python 对象作为参数传递。这就是 Cython 那么强大的原因。在这里，Cython
    编译器必须检查函数调用并生成代码，以安全地尝试将这些 Python 对象转换为原生 C 整数。当考虑到精度以及潜在的溢出时，这变得很困难，而这恰好是一个主要的使用场景，因为它处理得非常好。此外，请记住，这个函数返回一个整数，Cython
    也生成了代码将整数返回值转换为有效的 Python 对象。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.PacktPub.com](http://www.PacktPub.com) 的账户下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: Summary
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Overall, we installed the Cython compiler, ran the Hello World example, and
    took into consideration that we need to compile all code into native shared objects.
    We also saw how to wrap native C code to make it callable from Python. We have
    also seen the implicit type conversion which Cython does for us to make calling
    C work. In the next chapter, we will delve deeper into Cython programming with
    discussion on how to make Python code callable from C and manipulate native C
    data structures from Cython.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们安装了 Cython 编译器，运行了 Hello World 示例，并考虑到我们需要将所有代码编译成本地共享对象。我们还了解了如何将原生
    C 代码封装以使其可从 Python 调用。我们还看到了 Cython 为我们进行的隐式类型转换，以便调用 C 语言。在下一章中，我们将更深入地探讨 Cython
    编程，讨论如何使 Python 代码可从 C 调用，以及如何在 Cython 中操作原生 C 数据结构。
