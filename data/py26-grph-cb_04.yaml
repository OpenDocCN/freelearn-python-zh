- en: Chapter 4. Animation Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。动画原理
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Static shifting of a ball
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球的静态移动
- en: Timed shifting of a ball
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球的定时移动
- en: Animation timed draw-and-erase cycles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画定时绘制和擦除循环
- en: Two balls moving unimpeded
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个无阻碍移动的球
- en: A ball that bounces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个弹跳的球
- en: Bouncing in a gravitational field
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重力场中的弹跳
- en: Colliding balls with tracer trails
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有追踪轨迹的碰撞球
- en: Elastic ball against ball collisions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性球与球碰撞
- en: Dynamic debugging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态调试
- en: Trajectory tracing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹追踪
- en: Rotating a line and vital trigonometry
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转线条和重要的三角学
- en: Rotating lines which rotate lines
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转线条，旋转线条
- en: A digital flower
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字花
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Animation is about making graphic objects move smoothly around a screen. The
    method to create the sensation of smooth dynamic action is simple:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是关于在屏幕上使图形对象平滑移动。创建平滑动态动作感觉的方法很简单：
- en: First present a picture to the viewer's eye.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先向观众展示一幅图画。
- en: Allow the image to stay in view for about one-twentieth of a second.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许图像在视图中停留大约二十分之一秒。
- en: With a minimum of delay, present another picture where objects have been shifted
    by a small amount and repeat the process.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以最小的延迟，展示另一个图像，其中对象已经通过一个小量移动，并重复此过程。
- en: Besides the obvious applications of making animated figures move around on a
    screen for entertainment, animating the results of computer code gives you powerful
    insights into how code works at a detailed level. Animation offers an extra dimension
    to the programmers' debugging arsenal. It provides you with an all encompassing,
    holistic view of software execution in progress that nothing else can.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在屏幕上制作动画图形供娱乐的明显应用外，动画化计算机代码的结果能让你深入了解代码在详细层面的工作方式。动画为程序员的调试工具箱提供了一个额外的维度。它为你提供了一个全面的、整体的观点，关于正在进行的软件执行，这是其他任何东西都无法提供的。
- en: Static shifting of a ball
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球的静态移动
- en: We make an image of a small colored disk and draw it in a sequence of different
    positions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作了一个小彩色圆盘的图像，并在不同的位置绘制它。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Execute the program shown in exactly the same way as all the examples in [Chapter
    2](ch02.html "Chapter 2. Drawing Fundamental Shapes"), *Drawing Fundamental Shapes*
    and you will see a neat row of colored disks laid on top of each other going from
    top left to bottom right. The idea is to demonstrate the method of systematic
    position shifting that we will use again and again throughout the book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以与[第2章](ch02.html "第2章。绘制基本形状")、“绘制基本形状”中所有示例完全相同的方式执行程序，你会看到一排整齐的彩色圆盘从左上角到右下角依次排列。这个想法是展示我们将反复使用的方法，即系统的位置移动方法。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A simple ball is drawn on a canvas in a sequence of steps, one on top of the
    other. For each step, the position of the ball is shifted by three pixels as specified
    by the size of `shift_x`. Similarly, a downward shift of two pixels is applied
    by an amount to the value of `shift_y. shift_x` and `shift_y` only specify the
    amount of shift, but they do not make it happen. What makes it happen are the
    two commands `posn_x += shift_x` and `posn_y += shift_y. posn` is the abbreviation
    for position. An important word of explanation of this notation is needed here
    because we use it often throughout the book. It is neat and handy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的球在画布上按顺序绘制，一层叠在另一层之上。对于每一步，球的位置根据`shift_x`的大小移动三个像素。同样，`shift_y`的值减少两个像素，以实现向下移动。`shift_x`和`shift_y`只指定移动量，但它们并不直接导致移动。使移动发生的是两个命令`posn_x
    += shift_x`和`posn_y += shift_y`。`posn`是位置（position）的缩写。这里需要解释一下这种记法，因为我们会在整本书中经常使用它。它既整洁又方便。
- en: '`posn_x += shift_x` means "take the variable `posn_x` and add to it an amount
    `shift_x."` It is the same as `posn_x = posn_x + shift_x`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`posn_x += shift_x`意味着“将变量`posn_x`增加一个`shift_x`的量。”它与`posn_x = posn_x + shift_x`相同。'
- en: Another minor point to note is the use of the line continuation character, the
    backslash "\". We use this when we want to continue the same Python command onto
    a following line to make reading easier. Strictly speaking for text inside brackets
    "(...)" this is not needed. In this particular case you can just insert a carriage
    return character. However, the backslash makes it clear to anyone reading your
    code what your intention is.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的细微之处是使用行续字符，即反斜杠“\”。当我们想要将相同的Python命令延续到下一行以方便阅读时，我们会使用它。严格来说，对于括号内的文本“(…）”，这并不是必需的。在这个特定情况下，你可以简单地插入一个回车字符。然而，反斜杠使得阅读你代码的人清楚地知道你的意图。
- en: There's more...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The series of ball images in this recipe were drawn in a few microseconds. To
    create decent looking animation, we need to be able to slow the code execution
    down by just the right amount. We need to draw the equivalent of a movie frame
    onto the screen and keep it there for a measured time and then move on to the
    next, slightly shifted, image. This is done in the next recipe.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的球图像系列是在几微秒内绘制的。为了创建看起来不错的动画，我们需要能够通过适当的方式减慢代码的执行速度。我们需要将相当于电影帧的内容绘制到屏幕上，并保持一段时间，然后移动到下一个略微偏移的图像。这个过程将在下一个食谱中完成。
- en: Time-controlled shifting of a ball
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过时间控制移动球
- en: Here we introduce the time control function `canvas.after(milliseconds)` and
    the `canvas.update()` function that refreshes the image on the canvas. These are
    the cornerstones of animation in Python.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了时间控制函数 `canvas.after(milliseconds)` 和 `canvas.update()` 函数，后者刷新画布上的图像。这些是Python动画的基础。
- en: Control of when code gets executed is made possible by the time module that
    comes with the standard Python library.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标准Python库中的时间模块，我们可以控制代码何时执行。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Execute the program as previously. What you will see is a diagonal row of disks
    being laid in a line with a short delay of one fifth of a second (200 milliseconds)
    between updates. The result is shown in the following screenshot showing the ball
    shifting in regular intervals.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的方式执行程序。你将看到一条对角线排列的圆盘，在更新之间有五分之一秒（200毫秒）的短暂延迟。结果在下面的屏幕截图中显示，显示了球在规律间隔内的移动。
- en: '![How to do it...](img/3845_04_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3845_04_01.jpg)'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is the same as the previous one except for the `canvas.after(...)`
    and the `canvas.update()` methods. These are two functions that come from the
    Python library. The first gives you some control over code execution time by allowing
    you to specify delays in execution. The second forces the canvas to be completely
    redrawn with all the objects that should be there. There are more complicated
    ways of refreshing only portions of the screen, but they create difficulties so
    they will not be dealt with here.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱与上一个食谱相同，只是增加了 `canvas.after(...)` 和 `canvas.update()` 方法。这两个函数来自Python库。第一个允许你通过指定延迟来控制代码执行时间。第二个强制画布完全重新绘制所有应该存在的对象。虽然还有更复杂的方法来刷新屏幕的特定部分，但它们会带来困难，所以这里不会处理。
- en: The `canvas.after(your-chosen-milliseconds)` method simply causes a timed-pause
    to the execution of the code. In all the preceding code, the pause is executed
    as fast as the computer can do it, then when the pause, invoked by the `canvas.after()`
    method is encountered, execution simply gets suspended for the specified number
    of milliseconds. At the end of the pause, execution continues as if nothing ever
    happened.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas.after(your-chosen-milliseconds)` 方法只是简单地使代码执行产生定时暂停。在所有前面的代码中，暂停执行的速度尽可能快，然后当遇到由
    `canvas.after()` 方法触发的暂停时，执行将暂停指定的毫秒数。暂停结束后，执行将继续，就像什么都没发生过一样。'
- en: The `canvas.update()` method forces everything on the canvas to be redrawn immediately
    rather than wait for some unspecified event to cause the canvas to be refreshed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas.update()` 方法强制画布上的所有内容立即重新绘制，而不是等待某个未指定的事件导致画布刷新。'
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The next step in effective animation is to erase the previous image of the object
    being animated shortly before a fresh, shifted clone is drawn on the canvas. This
    happens in the next example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在有效动画的下一步中，在画布上绘制新的、偏移的克隆图像之前，需要短暂擦除动画对象的先前图像。这将在下一个示例中发生。
- en: The robustness of Tkinter
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tkinter的健壮性
- en: It is also worth noting that Tkinter is robust. When you give position coordinates
    that are off the canvas, Python does not crash or freeze. It simply carries on
    drawing the object 'off-the-page'. The Tkinter canvas can be seen as just a tiny
    window into an almost unlimited universe of visual space. We only see objects
    when they move into the view of the camera which is the Tkinter canvas.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Tkinter非常健壮。当你给出超出画布范围的坐标时，Python不会崩溃或冻结。它只是继续绘制“超出页面”的对象。Tkinter画布可以看作是进入几乎无限视觉空间的一个小窗口。我们只有在对象移动到Tkinter画布的视野中时才能看到对象。
- en: Complete animation using draw-move-pause-erase cycles
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用绘制-移动-暂停-擦除循环完成完整动画
- en: This recipe gives you the whole animation procedure. All the actions necessary
    for the human brain to interpret images on the retina as moving objects are present
    in this example. The whole craft of animation and the million dollar movies based
    thereon is demonstrated here in its simplest and purest form.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱提供了整个动画过程。在这个例子中，所有必要的人类大脑将视网膜上的图像解释为移动对象的行为都存在。动画的全部工艺以及基于此的百万美元电影在这里以最简单和最纯粹的形式展示。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Execute this program as we have done before. Note that this time we have reduced
    the timed pause to 50 milliseconds which is 20 times per second. This is close
    to the standard 24 frames per second used in movies. However, without a graphics
    card this time becomes less accurate as shorter pauses are specified. In addition,
    the distance moved between position shifts of the ball has been reduced to one
    pixel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们之前的方式执行此程序。注意这次我们将计时暂停缩短到50毫秒，即每秒20次。这接近电影中使用的标准24帧每秒。然而，如果没有图形卡，这次暂停时间会变得不那么准确，因为指定的暂停时间更短。此外，球在位置变化之间的移动距离已经减少到一像素。
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The new element in this self-contained animation is the `canvas.delete(ALL)`
    method that clears the entire canvas of everything that was drawn on it. It is
    possible to erase only specific objects on the screen through the use of identification
    tags. This is not needed now. Selective object deletion using tags will be used
    in the last three recipes of this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个自包含动画中的新元素是`canvas.delete(ALL)`方法，它可以清除画布上绘制的一切。可以通过使用标识标签来擦除屏幕上的特定对象。现在这不需要了。使用标签进行选择性对象删除将在本章的最后三个菜谱中使用。
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: How accurate is the timing of the `pause()` method?.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`pause()`方法的计时精度如何？'
- en: With modern computers, pauses of five milliseconds are realistic but the animation
    becomes jerky as the pause times get shorter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代计算机，五毫秒的暂停是现实的，但随着暂停时间的缩短，动画变得不流畅。
- en: More than one moving object
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个移动对象
- en: We want to be able to develop programs where more than one independent graphic
    object co-exists and interacts according to some rules. This is how most computer
    games work. Pilot training simulators and serious engineering design models are
    designed on the same principles. We start this process simply by working up to
    an application that ends up with two balls bouncing off the walls and each other
    under the influence of gravity and energy loss.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够开发出包含多个独立图形对象共存并按照某些规则相互作用的程序。大多数计算机游戏就是这样工作的。飞行员训练模拟器和严肃的工程设计模型也是基于相同的原则设计的。我们通过创建一个最终有两个球在重力损失和相互碰撞的影响下反弹到墙上的应用程序来开始这个过程。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The following code is very similar to that in the previous recipe, except that
    two similar objects are created. They are independent of each other and do not
    interact in any way.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码与上一个菜谱中的代码非常相似，只是创建了两个相似的对象。它们彼此独立，并且以任何方式都不相互作用。
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main point to note is that these programs, and many others in this book,
    are divided into five parts:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的主要点是，这些程序，以及本书中的许多其他程序，分为五个部分：
- en: Creating the environment where objects will exist.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建对象存在的环境。
- en: Defining the individual objects and their attributes.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义单个对象及其属性。
- en: Defining the rules of engagement between objects.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义对象之间的交互规则。
- en: Creating the objects.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建对象。
- en: Using a loop to simulate the march of time by changing properties such as position
    at rates that mimic real-time motion.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环通过改变位置等属性来模拟时间的流逝，这些属性的变化速率模仿实时运动。
- en: Controlling the environment inside which the objects exist.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制对象存在的环境。
- en: The environment in most of our examples is the Tkinter canvas. The objects that
    are going to exist inside the canvas environment in this example are two colored
    balls. The rules of engagement are that they will not have any effect on each
    other at all and they will not be affected by the edges of the canvas. Another
    rule of engagement is how their positions will shift each time the `for` loop
    is executed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的大多数例子中，环境是Tkinter画布。在这个例子中，将在画布环境中存在的对象是两个彩色球。交互规则是它们将不会对彼此产生任何影响，并且它们也不会受到画布边缘的影响。另一个交互规则是每次执行`for`循环时它们的位置将如何变化。
- en: Finally the environment is controlled by the time regulated `canvas.update()`
    and `canvas.delete(ALL)` methods.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，环境由受时间调节的`canvas.update()`和`canvas.delete(ALL)`方法控制。
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The principle idea demonstrated in this recipe is that we can create more than
    one similar, but different objects exist and react independently. This gives rise
    to the idea of object-oriented programming.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中展示的基本思想是，我们可以创建多个相似但不同的对象，并且它们可以独立地反应。这引发了面向对象编程的想法。
- en: 'Python offers more than one way to use the ideas of object-oriented programming.
    In this book, we use three ways of making objects: lists, dictionaries, and classes.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了多种使用面向对象编程思想的方法。在这本书中，我们使用三种方式来创建对象：列表、字典和类。
- en: A ball that bounces
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个弹跳的球
- en: Now and in the next three examples, we add rules of engagement that are increasingly
    complex. The overall objective is to introduce behaviors and interactions into
    our artificial world to make it behave more like the real world. We use numbers,
    calculations, and graphical drawings to represent aspects of the real world as
    we know it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以及接下来的三个例子中，我们添加了越来越复杂的交互规则。总体目标是向我们的虚拟世界引入行为和交互，使其更像现实世界。我们使用数字、计算和图形绘制来表示我们所知的现实世界的各个方面。
- en: The first new behavior is that our colored disks will bounce elastically off
    the walls of the container that is the Tkinter canvas.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新行为是，我们的彩色圆盘将在Tkinter画布的容器墙上弹性弹跳。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The code has purposely been kept as similar as possible to the previous four
    examples so that we feel we are still in familiar territory as the world we create
    gets increasingly more complicated. If we did not do this, we would get lost and
    bewildered. The whole secret in successfully constructing complex computer programs
    is to build it up gradually and systematically piece-by-piece. It is not a planned
    journey along a well-mapped road but rather a strenuous exploration through uncharted
    jungle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们感觉仍然处于熟悉的领域，随着我们创建的世界变得越来越复杂，代码有意识地保持与前面四个例子尽可能相似。如果我们不这样做，我们就会迷失方向，感到困惑。成功构建复杂计算机程序的全部秘密在于逐步和系统地逐步构建。这并不是沿着一条已经绘制好的道路的计划之旅，而是一次艰苦的未知的丛林探险。
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The new feature here is the function `detect_Wall_Collision()`. Whenever it
    is called, it checks whether the position of the ball has moved outside the boundary
    of the canvas. If it has, the direction of the ball is reversed. This method is
    crude because it does not compensate for the size of the ball. Consequently the
    ball pops out of existence.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里新增加的功能是函数`detect_Wall_Collision()`。每次调用它时，都会检查球的位置是否已经移动到画布边界之外。如果是，则球的运动方向会被反转。这种方法比较粗糙，因为它没有考虑到球的大小。因此，球会突然消失。
- en: Bouncing in a gravity field
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在重力场中的弹跳
- en: In this recipe, the influence of a gravitational field is added to the previous
    rule of bouncing off the canvas wall.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们增加了重力场的影响，作为之前在画布墙上弹跳规则的补充。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: What makes this recipe different to all the previous ones is a new attribute
    of the ball named `velocity_y`. With every cycle of the for i in `range(0,300)`
    loop the velocity is modified just as it would be in the gravitational field of
    our real world.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的所有配方不同的地方在于球的新属性`velocity_y`。在`for i in range(0,300)`循环的每一轮中，速度都会像在现实世界的重力场中一样被修改。
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertical `velocity_y` property of our ball is increased by a constant quantity
    GRAVITY every time a new position is calculated. The net result is that the speed
    gets faster when the ball is falling downward and slower when it moves upward.
    Because the y-direction of a Tkinter canvas is positively increasing downward
    (contrary to our real world) this has the effect of slowing down the ball when
    moving upward and speeding it up when moving downward.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每次计算新位置时，我们球的垂直`velocity_y`属性都会增加一个常数量GRAVITY。结果是，当球向下落时速度会加快，当球向上移动时速度会减慢。因为Tkinter画布的y方向是向下增加的（与我们的现实世界相反），这会导致球向上移动时速度减慢，向下移动时速度加快。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a flaw with this simulation of a bouncing ball. The ball disappears
    off the canvas after about three bounces because the integer arithmetic used in
    calculating each new position of the ball and the criteria used to detect collisions
    with the wall are much too coarse. The result of this is that the ball finds itself
    outside of the conditions we have set up to reverse its direction when it hits
    the floor. The GRAVITY added to its velocity kick it beyond the interval if `posn_y
    > ch ball_height`, and the ball never gets placed back inside the canvas.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种弹球模拟存在一个缺陷。球在弹跳大约三次后从画布上消失，因为计算球的新位置和检测与墙壁碰撞所使用的整数算术过于粗糙。结果是球发现自己超出了我们设定的条件，当它碰到地板时无法反转方向。添加到其速度中的重力将其踢出
    `posn_y > ch ball_height` 的区间，球永远不会被放回画布内。
- en: Positions on the canvas are defined as integers only but we need to deal with
    much greater precision than that when calculating the position of our ball. It
    turns out there is no problem here. In their wisdom the Python designers have
    allowed us to work with all our variables as floating point numbers that are very
    precise and still pass them to the `canvas.create_oval(...)` method which draws
    the ball on the canvas. For the final drawing they obviously get converted into
    integers. Thank you wise Python guys.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 画布上的位置仅定义为整数，但在计算球的位置时，我们需要处理比这更高的精度。结果证明这里没有问题。在他们的智慧中，Python 设计者允许我们使用所有非常精确的浮点数变量来工作，并且仍然可以将它们传递给
    `canvas.create_oval(...)` 方法，该方法在画布上绘制球。对于最终的绘图，显然它们被转换成了整数。感谢明智的 Python 朋友们。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe, `floating_point_collisions_1.py`, uses floating point position
    calculation to fix the flaws in this example.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配方 `floating_point_collisions_1.py` 使用浮点数位置计算来修复这个示例中的缺陷。
- en: Precise collisions using floating point numbers
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浮点数进行精确碰撞
- en: Here the simulation flaws caused by the coarseness of integer arithmetic are
    eliminated by using floating point numbers for all ball position calculations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过使用浮点数进行所有球位置计算，消除了由整数算术粗糙性引起的模拟缺陷。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: All position, velocity, and gravity variables are made floating point by writing
    them with explicit decimal points. The result is shown in the following screenshot,
    showing the bouncing balls with trajectory tracing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有位置、速度和重力变量都通过显式的小数点写成浮点数。结果在下面的屏幕截图中显示，显示了带有轨迹追踪的弹跳球。
- en: '![How to do it...](img/3845_04_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3845_04_02.jpg)'
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Use of precision arithmetic has allowed us to notice simulation behavior that
    was previously hidden by the sins of integer-only calculations. This is the UNIQUE
    VALUE OF GRAPHIC SIMULATION AS A DEBUGGING TOOL. If you can represent your ideas
    in a visual way rather than as lists of numbers you will easily pick up subtle
    quirks in your code. The human brain is designed to function best in graphical
    images. It is a direct consequence of being a hunter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 精度算术的使用使我们能够注意到以前由于仅使用整数计算而隐藏的模拟行为。这是图形模拟作为调试工具的独特价值。如果你能用视觉方式而不是数字列表来表示你的想法，你将很容易发现代码中的细微差异。人类大脑最适合在图形图像中工作。这是作为猎人的直接后果。
- en: A graphic debugging tool...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个图形调试工具...
- en: There is another very handy trick in the software debugger's arsenal and that
    is the visual trace. A trace is some kind of visual trail that shows the history
    of dynamic behavior. All of this is revealed in the next example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 软件调试器工具箱中还有一个非常实用的技巧，那就是可视化追踪。追踪是一种显示动态行为历史的视觉轨迹。所有这些都在下一个示例中揭示。
- en: Trajectory tracing and ball-to-ball collisions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轨迹追踪和球与球碰撞
- en: Now we introduce one of the more difficult behaviors in our simulation of ever
    increasing complexity the mid-air collision.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍我们模拟中更复杂行为之一的中空碰撞。
- en: The hardest thing when you are debugging a program is to try to hold in your
    short term memory some recently observed behavior and compare it meaningfully
    with present behavior. This kind of memory is an imperfect recorder. The way to
    overcome this is to create a graphic form of memory some sort of picture that
    shows accurately what has been happening in the past. In the same way that military
    cannon aimers use glowing tracer projectiles to adjust their aim, a graphic programmer
    can use trajectory traces to examine the history of execution.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在调试程序时，最难的事情是试图将最近观察到的行为保存在你的短期记忆中，并与当前行为进行有意义的比较。这种记忆是一个不完美的记录器。克服这种困难的方法是创建一种图形形式的记忆，某种类型的图片，可以准确地显示过去发生的事情。就像军事大炮瞄准手使用发光的曳光弹来调整他们的瞄准一样，图形程序员可以使用轨迹痕迹来检查执行的历史。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In our new code there is a new function called `detect_ball_collision (ball_1,
    ball_2)` whose job is to anticipate imminent collisions between the two balls
    no matter where they are. The collisions will come from any direction and therefore
    we need to be able to test all possible collision scenarios and examine the behavior
    of each one and see if it does not work as planned. This can be too difficult
    unless we create tools to test the outcome. In this recipe, the tool for testing
    outcomes is a graphic trajectory trace. It is a line that trails behind the path
    of the ball and shows exactly where it went right since the beginning of the simulation.
    The result is shown in the following screenshot, showing the bouncing with ball-to-ball
    collision rebounds.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新代码中，有一个名为 `detect_ball_collision (ball_1, ball_2)` 的新函数，其任务是预测两个球无论在哪里即将发生的碰撞。碰撞可能来自任何方向，因此我们需要能够测试所有可能的碰撞场景，并检查每一个的行为，看看它是否按计划工作。除非我们创建测试结果的工具，否则这可能过于困难。在这个菜谱中，测试结果的工具是图形轨迹痕迹。这是一条跟随球路径的线，显示了从模拟开始以来球的确切位置。结果在下面的屏幕截图中显示，显示了球与球碰撞的反弹。
- en: '![How to do it...](img/3845_04_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](img/3845_04_03.jpg)'
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Mid-air ball against ball collisions are done in two steps. In the first step,
    we test whether the two balls are close to each other inside a vertical strip
    defined by `if math.fabs(ball_1['posn_x'] - ball_2['posn_x']) < 25`. In plain
    English, this asks "Is the horizontal distance between the balls less than 25
    pixels?" If the answer is yes, then the region of examination is narrowed down
    to a small vertical distance less than 25 pixels by the statement `if math.fabs(ball_1['posn_y']
    - ball_2['posn_y']) < 25`. So every time the loop is executed, we sweep the entire
    canvas to see if the two balls are both inside an area where their bottom-left
    corners are closer than 25 pixels to each other. If they are that close then we
    simply cause a rebound off each other by reversing their direction of travel in
    both the horizontal and vertical directions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 空中球与球碰撞分为两个步骤。在第一步中，我们测试两个球是否在由 `if math.fabs(ball_1['posn_x'] - ball_2['posn_x'])
    < 25` 定义的垂直条带内彼此靠近。用简单的话说，这是在问“球之间的水平距离是否小于25像素？”如果答案是肯定的，那么通过语句 `if math.fabs(ball_1['posn_y']
    - ball_2['posn_y']) < 25`，检查区域被缩小到小于25像素的小垂直距离。所以每次循环执行时，我们都会扫描整个画布，看看两个球是否都位于一个区域，它们的左下角彼此之间的距离小于25像素。如果它们如此接近，那么我们只需通过在水平和垂直方向上反转它们的移动方向，简单地使它们相互反弹。
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Simply reversing the direction is not the mathematically correct way to reverse
    the direction of colliding balls. Certainly billiard balls do not behave that
    way. The law of physics that governs colliding spheres demands that momentum be
    conserved. This requires more complicated mathematics not covered in this book.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地反转方向并不是数学上正确的方式来反转碰撞球的方向。当然，台球不会那样表现。支配碰撞球体的物理定律要求动量守恒。这需要更复杂的数学，而这本书没有涵盖。
- en: Why do we sometimes get tkinter.TckErrors?
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们有时会得到 tkinter.TckErrors？
- en: If we click the close window button (the X in the top right) while Python is
    paused, when Python revives and then calls on `Tcl` (Tkinter) to draw something
    on the canvas we will get an error message. What probably happens is that the
    application has already shut down, but `Tcl` has unfinished business. If we allow
    the program to run to completion before trying to shut the window then termination
    is orderly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Python暂停时点击关闭窗口按钮（右上角的X），当Python恢复并调用`Tcl`（Tkinter）在画布上绘制东西时，我们会得到一个错误消息。可能发生的情况是应用程序已经关闭，但`Tcl`还有未完成的事务。如果我们允许程序运行完成后再尝试关闭窗口，那么终止将是有序的。
- en: Rotating line
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转线
- en: Now we will see how to handle rotating lines. In any kind of graphic computer
    work, the need to rotate objects arises eventually. By starting off as simply
    as possible and progressively adding behaviors we can handle some increasingly
    complicated situations. This recipe is that first simple step in the art of making
    things rotate.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何处理旋转线。在任何类型的图形计算机工作中，最终都会出现需要旋转对象的情况。通过尽可能简单地开始，并逐步添加行为，我们可以处理一些越来越复杂的情况。这个步骤是制作旋转对象艺术中的第一步简单步骤。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To understand the mathematics of rotation you need to be reasonably familiar
    with the trigonometry functions of sine, cosine, and tangent. The good news for
    those of us whose eyes glaze at the mention of trigonometry is that you can use
    these examples without understanding trigonometry. However, it is much more rewarding
    if you do try to figure out the math. It is like the difference between watching
    football or playing it. Only the players get fit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解旋转的数学，你需要对正弦、余弦和正切等三角函数有合理的熟悉度。对于那些一提到三角函数眼睛就发花的人来说，好消息是你可以使用这些例子而不需要理解三角函数。然而，如果你真的试图弄懂数学，那会更有成就感。这就像看足球和踢足球的区别。只有球员才会变得健康。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You just need to write and run this code and observe the results as you did
    for all the other recipes. The insights come from repeated tinkering and hacking
    the code. Change the values of variables `p1_x` to `p2_y` one at a time and observe
    the results.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要编写并运行这段代码，就像你为所有其他食谱所做的那样观察结果。洞察力来自于反复的尝试和修改代码。逐个改变变量`p1_x`到`p2_y`的值，并观察结果。
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In essence, all rotation comes down to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，所有旋转都归结为以下：
- en: Establish a center of rotation or pivot point
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立旋转中心或支点
- en: Pick a specific point on the object you want to rotate
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你想要旋转的对象上的一个特定点
- en: Calculate the distance from the pivot point to the specific point of interest
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算从支点到特定兴趣点的距离
- en: Calculate the angle of the line joining the pivot and the specific point
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算连接支点和特定点的线的角度
- en: Increase the angle of the line joining the points by a known amount, the rotation
    angle, and re-calculate the new x and y coordinates for that point.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将连接点的线的角度增加一个已知的量，即旋转角度，然后重新计算该点的新的x和y坐标。
- en: For math students what you do is relocate the origin of your rectangular coordinate
    system to the pivot point, express the coordinates of your specific point into
    polar coordinates, add an increment to the angular position, and convert the new
    polar coordinate position into a fresh pair of rectangular coordinates. The preceding
    recipe performs all these actions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数学学生来说，你所要做的是将你的矩形坐标系的原点移动到支点，将你的特定点的坐标表达为极坐标，增加一个增量到角位置，然后将新的极坐标位置转换成一对新的矩形坐标。上述步骤执行了所有这些操作。
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The pivot point was purposely placed near the bottom corner of the canvas so
    that the point on the end of the line to be rotated would fall outside the canvas
    for much of the rotation process. The rotation continues without errors or bad
    behavior emphasizing a point made earlier in this chapter that Python is mathematically
    robust. However, we need to exercise care when using the `arctangent` function
    `math.atan()` because it flips from a value positive infinity to negative infinity
    as angles move through 90 and 270 degrees. `Atan()` can give ambiguous results.
    Again the Python designers have taken care of business well by creating the math.
    `atan2(y,x)` function that takes into account the signs of both y and x to give
    unambiguous results between 180 degrees and -180.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 轴点故意放置在画布的底部角落，这样在旋转过程中，要旋转的线末端的点大部分时间都会落在画布之外。旋转过程继续进行，没有错误或不良行为，强调了本章前面提到的一个观点，即Python在数学上是稳健的。然而，在使用`arctangent`函数`math.atan()`时，我们需要小心，因为它会在角度通过90度和270度时从正值无穷大翻转到负值无穷大。`Atan()`可能会给出模糊的结果。再次强调，Python的设计者通过创建`atan2(y,x)`函数来很好地处理了这个问题，该函数考虑了y和x的符号，从而在180度和-180度之间给出无歧义的结果。
- en: Trajectory tracing on multiple line rotations
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多行旋转的轨迹追踪
- en: This example draws a visually appealing kind of Art Noveau arrowhead but that
    is just an issue on the happy-side. The real point of this recipe is to see how
    you can have any number of pivot points all with different motions and that the
    essential arithmetic remains simple and clean looking in Python. The use of animation
    methods to slow the execution down makes it entertaining to watch. We also see
    how tag names given to different parts of the objects drawn onto the canvas allow
    them to be selectively erased when the `canvas.delete(...)` method is invoked.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子绘制了一种视觉上吸引人的新艺术风格箭头，但这只是快乐的一面的问题。这个菜谱的真正目的是看看你如何拥有任意数量的轴点，每个轴点都有不同的运动，而在Python中，基本的算术仍然简单且看起来干净。使用动画方法来减慢执行速度使得观看变得有趣。我们还看到，给画布上绘制对象的各个部分赋予的标签名称允许在调用`canvas.delete(...)`方法时选择性地删除它们。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Imagine a skilled drum major marching in a parade whirling a staff in circles.
    Holding onto the end of the staff is a small monkey also twirling a baton but
    at a different speed. At the tip of the monkey's staff is a miniature marmoset
    twirling a baton in the opposite direction...
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个熟练的鼓队长在游行中行进，同时旋转着指挥棒。握住指挥棒末端的是一只小猴子，也在以不同的速度旋转着指挥棒。在猴子指挥棒的尖端是一只微型卷尾猴，以相反的方向旋转着指挥棒...
- en: Now run the program.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Run the Python code below as we have done before. The result is shown in following
    screenshot showing multiple line rotation traces.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们之前做的那样运行下面的Python代码。结果将在下面的屏幕截图显示，显示了多行旋转轨迹。
- en: '![How to do it...](img/3845_04_04_new.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3845_04_04_new.jpg)'
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we did in the previous recipe we have lines defined by connecting two points,
    each being specified in the rectangular coordinates that Tkinter drawing methods
    use. There are three such lines connected pivot-to-tip. It may help to visualize
    each pivot as a drum major or a monkey. We convert each pivot-to-tip line into
    polar coordinates of length and angle. Then each pivot-to-tip line is rotated
    by its own individual increment angle. If you alter these angles alpha_1 etc.
    or the positions of the various pivot points you will get a limitless variety
    of interesting patterns.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的菜谱中所做的那样，我们通过连接两个点来定义线，每个点都是用Tkinter绘图方法使用的矩形坐标来指定的。有三条这样的线连接轴点到尖端。将每个轴点到尖端线想象成一个鼓队长或是一只猴子可能会有所帮助。我们将每个轴点到尖端线转换为长度和角度的极坐标。然后，每个轴点到尖端线都以其自己的增量角度旋转。如果你改变这些角度alpha_1等或各种轴点的位置，你将得到无限多样有趣的图案。
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once you are able to control and vary color you are able to make extraordinary
    and beautiful patterns never seen before. Color control is the subject of the
    next chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你能够控制和改变颜色，你就能创造出前所未有的非凡美丽图案。颜色控制是下一章的主题。
- en: A rose for you
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给你的玫瑰
- en: This last example of the chapter is simply a gift for the reader. No illustration
    is provided. We will only see the result if we run the code. It is a surprise.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个例子只是给读者的一个礼物。没有提供插图。我们只有在运行代码后才能看到结果。这是一个惊喜。
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The structure of this program is similar to the previous example but the rotation
    parameters have been adjusted to evoke the image of a rose. The colors used are
    chosen to remind us that control over color is extremely import in graphics.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的结构与之前的示例相似，但旋转参数已被调整以唤起玫瑰花的形象。所使用的颜色是为了提醒我们，在图形中控制颜色非常重要。
