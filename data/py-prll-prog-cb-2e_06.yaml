- en: Distributed Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式 Python
- en: This chapter will introduce some important Python modules for distributed computing.
    In particular, we will describe the `socket` module, which allows you to implement
    simple applications distributed through the client-server model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一些重要的分布式计算 Python 模块。特别是，我们将描述 `socket` 模块，它允许您通过客户端-服务器模型实现简单分布式应用程序。
- en: Then, we will introduce the Celery module, which is a powerful Python framework
    that is used to manage distributed tasks. Finally, we will describe the `Pyro4`
    module, which allows you to call methods that are used in different processes,
    potentially on a different machine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将介绍 Celery 模块，这是一个强大的 Python 框架，用于管理分布式任务。最后，我们将描述 `Pyro4` 模块，它允许您调用在不同进程（可能在不同机器上）中使用的函数。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Introducing distributed computing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入分布式计算
- en: Using the Python socket module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 的 `socket` 模块
- en: Distributed task management with Celery
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Celery 进行分布式任务管理
- en: Remote Method Invocation (RMI) with `Pyro4`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Pyro4` 进行远程方法调用（RMI）
- en: Introducing distributed computing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入分布式计算
- en: '*Parallel* and *distributed computing* are similar technologies designed to
    increase the amount of processing power available for a specific task. Generally,
    these methods are used to solve problems that require large computational capabilities.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行计算* 和 *分布式计算* 是类似的技术，旨在增加特定任务可用的处理能力。通常，这些方法用于解决需要强大计算能力的问题。'
- en: When the problem is divided into many small pieces, individual sections of the
    problem can be calculated by many processors simultaneously. This allows more
    processing power to be exercised on the problem than can be provided by a single
    processor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当问题被划分为许多小块时，可以由许多处理器同时计算问题的各个部分。这允许对问题施加比单个处理器能提供的更多处理能力。
- en: The main difference between parallel and distributed processing is that parallel
    configurations include many processors within a single system, while distributed
    configurations exploit the processing power of many computers simultaneously.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理与分布式处理之间的主要区别在于，并行配置在单个系统中包含许多处理器，而分布式配置同时利用多台计算机的处理能力。
- en: 'Let''s look at the other differences:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他的不同之处：
- en: '| **Parallel processing** | **Distributed processing** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **并行处理** | **分布式处理** |'
- en: '| Parallel processing has the advantage of providing reliable processing power
    with a very low degree of latency. | Distributed processing is not extremely efficient
    on a processor-by-processor basis, as the data must travel over the network rather
    than through the internal connections of a single system. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 并行处理具有提供非常低延迟的可靠处理能力的优势。 | 分布式处理在处理器层面并不是非常高效，因为数据必须通过网络传输，而不是通过单个系统的内部连接。
    |'
- en: '| By concentrating all the processing power in one system, speed loss due to
    data transfer is minimized. | Each processor will contribute much less processing
    power than any processor in a parallel system since data transfer creates a bottleneck
    that limits processing power. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 通过将所有处理能力集中在一个系统中，由于数据传输造成的速度损失最小化。 | 由于数据传输会形成瓶颈，限制处理能力，每个处理器将贡献的处理能力远低于并行系统中的任何处理器。
    |'
- en: '| The only real limit is the number of processors incorporated in the system.
    | The system is almost infinitely scalable since there is no actual upper limit
    to the number of processors in a distributed system. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 真正的限制只是系统中集成的处理器数量。 | 由于分布式系统中处理器数量的实际上限并不存在，系统几乎可以无限扩展。 |'
- en: 'However, in the context of computer applications, it is customary to distinguish
    between local and distributed architectures:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在计算机应用的环境中，通常区分本地和分布式架构：
- en: '| **Local architectures** | **Distributed architectures** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **本地架构** | **分布式架构** |'
- en: '| All the components are on the same machine. | Applications and components
    can reside on different nodes that are connected by a network. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 所有组件都在同一台机器上。 | 应用程序和组件可以驻留在通过网络连接的不同节点上。 |'
- en: The advantages of using distributed computing consist mainly of the possibility
    of concurrent use of the programs, the centralization of the data, and the distribution
    of the processing load, which all come at the price of greater complexity, especially
    with communication between the various components.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布式计算的优势主要在于程序可以并发使用、数据集中以及处理负载的分布，这些都以更高的复杂性为代价，尤其是在各个组件之间的通信方面。
- en: Types of distributed applications
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式应用程序的类型
- en: 'Distributed applications can be classified according to the degree of distribution:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式应用程序可以根据分布程度进行分类：
- en: '**Client-server applications**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器应用程序**'
- en: '**Multi-level applications**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多层应用程序**'
- en: Client-server applications
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器应用程序
- en: There are only two levels and the operations are carried out entirely on the
    server. As an example, we can mention the classic static or dynamic websites.
    The tools for the realization of these types of applications are the network sockets,
    whose programming is possible in various languages, including C, C ++, Java, and,
    of course, Python.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个级别，所有操作都在服务器上执行。例如，我们可以提到经典的静态或动态网站。实现这些类型应用程序的工具是网络套接字，其编程可以在包括C、C++、Java和当然还有Python在内的各种语言中实现。
- en: The term *client-server system* refe*rs* to a network architecture in which
    a client computer or client terminal is generally connected to a server for the
    use of a certain service; for example, the sharing of a certain hardware/software
    resource with other clients, or relying on the underlying protocol architecture.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*客户端-服务器系统*指的是一种网络架构，其中客户端计算机或终端通常连接到服务器以使用某种服务；例如，与其他客户端共享某些硬件/软件资源，或依赖于底层协议架构。
- en: Client-server architecture
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: The client-server architecture is a system that realizes a distribution of both
    processing and data. The central element of the architecture is the server. The
    server can be considered both from a logical point of view and from a physical
    point of view. From the physical point of view—hardware—a server is a machine
    dedicated to running a software server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构是一个实现处理和数据分布的系统。架构的核心元素是服务器。服务器可以从逻辑和物理两个角度来考虑。从物理角度来看——硬件，服务器是一台专门运行软件服务器的机器。
- en: From a logical point of view, a server is software. The server, as a logical
    process, provides services to other processes that take on the role of requester
    or client. Generally, the server does not send the results to the requester until
    the results are requested by the client.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑角度来看，服务器是软件。服务器作为一个逻辑进程，为承担请求者或客户端角色的其他进程提供服务。通常，服务器不会在结果被客户端请求之前将结果发送给请求者。
- en: 'A feature that distinguishes the client from its server is that the client
    can initiate a transaction with the server, while the server can never initiate
    a transaction with the client on its own initiative:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 区分客户端与其服务器的特性在于客户端可以主动与服务器发起事务，而服务器则不能主动与客户端发起事务：
- en: '![](img/f9df2fb0-1a78-4826-b494-5e3b43effbf0.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9df2fb0-1a78-4826-b494-5e3b43effbf0.png)'
- en: Client-server architecture
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: In fact, the specific tasks of the client are to start transactions, request
    specific services, notify the completion of the service, and receive results from
    the server, as shown in the preceding diagram.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，客户端的具体任务包括启动事务、请求特定服务、通知服务的完成以及从服务器接收结果，如前图所示。
- en: Client-server communications
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器通信
- en: Communication between clients and servers can take place using a variety of
    mechanisms—from geographic to local networks, up to communication services—between
    applications at the OS level. Furthermore, a client-server architecture must be
    independent of the physical connection method that exists between the client and
    the server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与服务器之间的通信可以使用各种机制进行，从地理网络到本地网络，再到通信服务——在操作系统级别的应用程序之间。此外，客户端-服务器架构必须独立于客户端和服务器之间存在的物理连接方法。
- en: It should also be noted that it is not necessary for a client-server process
    to reside on physically separate systems. In fact, the server process and the
    client process can reside on the same computing platform.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意的是，客户端-服务器进程不必位于物理上分开的系统上。实际上，服务器进程和客户端进程可以位于同一计算平台上。
- en: The main objective of the client-server architecture, in the context of data
    management, is to allow client applications to access data managed by the servers.
    The server (understood in a logical sense as software) is often running on a remote
    system (for example, in another city or on a local network).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据管理方面，客户端-服务器架构的主要目标是允许客户端应用访问由服务器管理的数据。服务器（在逻辑意义上理解为软件）通常运行在远程系统上（例如，在另一个城市或本地网络）。
- en: Therefore, client-server applications are often associated with distributed
    processing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端-服务器应用通常与分布式处理相关联。
- en: TCP/IP client-server architecture
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP客户端-服务器架构
- en: The TCP/IP connection establishes a point-to-point connection between two applications.
    The extremes of this connection are marked by an IP address, which identifies
    the workstation by a port number, which makes it possible to have several connections
    that are connected to independent applications on the same workstation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP连接在两个应用之间建立点对点连接。这个连接的两端由IP地址标记，IP地址通过端口号识别工作站，这使得可以在同一工作站上连接到独立应用的多个连接。
- en: Once the connection is established and the protocol can exchange data over it,
    the underlying TCP/IP protocol takes care of sending this data, divided into packets,
    from one end of the connection to the other. In particular, the TCP protocol deals
    with assembling and disassembling the packets, as well as managing the handshaking
    that guarantees the reliability of the connection, while the IP protocol takes
    care of transporting the individual packets and the choice of the best routing
    of the packets along with the network.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接并且协议可以通过它交换数据，底层的TCP/IP协议就会负责将数据分成数据包，从连接的一端发送到另一端。特别是，TCP协议负责组装和拆解数据包，以及管理握手过程，以确保连接的可靠性，而IP协议负责传输单个数据包以及选择数据包在网络中的最佳路由。
- en: This mechanism underlies the robustness of the TCP/IP protocol, which, in turn,
    represents one of the reasons for the development of the protocol itself in the
    military sphere (ARPANET).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制是TCP/IP协议的健壮性的基础，反过来，这也代表了该协议在军事领域（ARPANET）自身发展的一个原因。
- en: The various existing standard applications (such as web browsing, file transfer,
    and email) use standardized application protocols, such as HTTP, FTP, POP3, IMAP,
    and SMTP.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的各种标准应用（如网页浏览、文件传输和电子邮件）使用标准化的应用协议，例如HTTP、FTP、POP3、IMAP和SMTP。
- en: Each specific client-server application must instead define and apply its own
    proprietary application protocol. This can involve the exchange of data in blocks
    of a fixed size (which is the simplest solution).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特定的客户端-服务器应用必须定义并应用其自己的专有应用协议。这可能涉及在固定大小的数据块中进行数据交换（这是最简单的解决方案）。
- en: Multi-level applications
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多级应用
- en: 'There are a greater number of levels that enable the processing load of the
    servers to be alleviated. Those that are, in fact, subdivided are the functionalities
    of the server-side, leaving the characteristics of the client part that has the
    task of hosting the application interface largely unchanged. An example of this
    type of architecture is that of the three-tier model, having a structure divided
    into three layers or levels:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 存在更多层级可以减轻服务器的处理负载。那些实际上被细分的是服务器端的功能，而客户端部分具有托管应用程序界面的任务，其特征基本保持不变。这种类型架构的一个例子是三层模型，其结构分为三层或层级：
- en: Frontend or presentation tier or interface
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端或表示层或界面
- en: Middle tier or application logic
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间层或应用逻辑
- en: Backend or data tier or persistent data management
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端或数据层或持久数据管理
- en: 'This nomenclature is typical of web applications. More generally, it is possible
    to refer to a subdivision in three levels that are applicable to any software
    application, which is the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名法是网络应用的典型特征。更普遍地说，可以提到适用于任何软件应用的三个层级细分，如下所示：
- en: '**Presentation Layer** (**PL**): This is the visualization part of the data
    (such as modules and controls of input) necessary for the user interface.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**（**PL**）：这是数据可视化部分，对于用户界面来说是必要的，例如输入的模块和控制。'
- en: '**Business Logic Layer** (**BLL**): This is the main part of the application,
    which defines the various entities and their relationships independently of the
    methods of presentation available to the user and saved in the archives.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务逻辑层** (*BLL*)：这是应用程序的主要部分，它独立于用户可用的表示方法和存档中保存的方法定义了各种实体及其关系。'
- en: '**Data Access Layer** (**DAL**): This contains everything necessary for the
    management of persistent data (essentially, database management systems).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问层** (*DAL*)：这包含管理持久数据所需的一切（基本上，数据库管理系统）。'
- en: This chapter will present some of the solutions proposed by Python for the implementation
    of distributed architectures. We will begin by describing the `socket` module
    with which we will implement some examples of the fundamental client-server model.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Python 为实现分布式架构提出的一些解决方案。我们将从描述 `socket` 模块开始，我们将使用该模块实现一些基本客户端-服务器模型的示例。
- en: Using the Python socket module
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 的 socket 模块
- en: A socket is a software object that allows data to be sent and received between
    remote hosts (via a network) or between local processes, such as **Inter-Process
    Communication** (**IPC**).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是一种软件对象，它允许在远程主机（通过网络）或本地进程（如 **进程间通信** (*IPC*)）之间发送和接收数据。
- en: Sockets were invented at Berkeley as part of the **BSD Unix** project. They
    are based precisely on the management model of input and output of Unix files.
    In fact, the operations of opening, reading, writing, and closing a socket occur
    in the same way as the management of Unix files, but with the difference that
    should be considered are the useful parameters for communication, such as addresses,
    port numbers, and protocols.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是在伯克利作为 **BSD Unix** 项目的组成部分被发明的。它们基于 Unix 文件输入/输出管理模型的精确管理。实际上，打开、读取、写入和关闭套接字的操作与
    Unix 文件的管理方式相同，但需要考虑的有用参数是通信的有用参数，如地址、端口号和协议。
- en: The success and spread of socket technology have gone hand in hand with the
    development of the internet. In fact, the combination of sockets with the internet
    has made communication between machines that are of any type, and/or are scattered
    throughout the world, incredibly easy (at least when compared with other systems).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字技术的成功和普及与互联网的发展息息相关。实际上，套接字与互联网的结合使得不同类型、散布全球的机器之间的通信变得极其简单（至少与其他系统相比）。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The socket Python module exposes low-level C APIs for communication over a network
    using the **BSD** *(*short for **Berkeley Software Distribution**) socket interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 socket 模块公开了使用 **BSD** (*即 **伯克利软件发行版**) 套接字接口进行网络通信的低级 C API。**BSD**
    (*Berkeley Software Distribution*) 是指 **伯克利软件发行版**。
- en: 'This module includes the `Socket` class, which includes the main methods for
    managing the following tasks:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块包括 `Socket` 类，它包括管理以下任务的主要方法：
- en: '`socket ([family [, type [, protocol]]])`: Builds a socket using the following
    as arguments:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket ([family [, type [, protocol]]])`: 使用以下参数构建套接字：'
- en: The `family` address, which can be `AF_INET (default)`, `AF_INET6`, or `AF_UNIX`
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`family` 地址，可以是 `AF_INET (默认)`、`AF_INET6` 或 `AF_UNIX`。'
- en: The `type` socket, which can be `SOCK_STREAM (default)`, `SOCK_DGRAM`, or perhaps
    one of the other `"SOCK_"` constants
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type` 套接字，可以是 `SOCK_STREAM (默认)`、`SOCK_DGRAM` 或其他 `"SOCK_"` 常量之一。'
- en: The `protocol` number (that is usually zero)
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protocol` 编号（通常是零）'
- en: '`gethostname()`: Returns the current IP address of the machine.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gethostname()`: 返回机器的当前 IP 地址。'
- en: '`accept ()`: Returns the following pair of values (`conn` and `address`), where
    `conn` is a socket type object (to send/receive data on the connection), while
    `address` is the address connected to the socket on the other end of the connection.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accept ()`: 返回以下一对值（`conn` 和 `address`），其中 `conn` 是套接字类型对象（用于在连接上发送/接收数据），而
    `address` 是连接到连接另一端的套接字的地址。'
- en: '`bind (address)`: Associates the socket with the `address` server.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind (address)`: 将套接字与 `address` 服务器关联。'
- en: This method historically accepted a couple of parameters for the `AF_INET` addresses
    instead of a single tuple.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法历史上接受了一组参数用于 `AF_INET` 地址，而不是单个元组。
- en: '`close ()`: Provides the option to clean up the connection once communication
    with the client is finished. The sockets are closed and collected by the garbage
    collector.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close ()`: 提供在客户端通信完成后清理连接的选项。套接字被关闭并由垃圾回收器收集。'
- en: '`connect(address)`: Connects a remote socket to an address. The `address` format
    depends on the family address.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect(address)`: 将远程套接字连接到地址。`address` 格式取决于地址族。'
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In the following example, the server is listening on a default port, and by
    following a TCP/IP connection, the client sends to the server the date and time that
    the connection was established.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，服务器正在监听默认端口，并且通过TCP/IP连接，客户端将连接建立时的日期和时间发送到服务器。
- en: 'Here is the server implementation for `server.py`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`server.py`的服务器实现：
- en: 'Import the relevant Python modules:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的Python模块：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new socket using the given address, socket type, and protocol number:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用给定的地址、套接字类型和协议号创建一个新的套接字：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Get the local machine name (`host`):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取本地机器名称（`host`）：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set the `port` number:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`端口号`：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Connect (bind) the socket to `host` and to `port`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将套接字绑定到`host`和`port`：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listen for connections made to the socket. The argument of `5` specifies the
    maximum number of connections in the queue. The maximum value depends on the system
    (usually, it is `5`) and the minimum value is always `0`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听对套接字的连接请求。`5`的参数指定了队列中的最大连接数。最大值取决于系统（通常为`5`），最小值始终为`0`：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Establish a connection:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立连接：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, the connection is accepted. The return value is a pair (`conn`, `address`),
    where `conn` is a new `socket` object that is used to send and receive data, and
    `address` is the address linked to the socket. Once accepted, a new socket is
    created and it will have its own identifier. This new socket is only used with
    this particular client:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，连接被接受。返回值是一个对（`conn`，`address`），其中`conn`是一个新的`socket`对象，用于发送和接收数据，而`address`是与套接字相关联的地址。一旦接受，就会创建一个新的套接字，它将有自己的标识符。这个新的套接字仅用于这个特定的客户端：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The address and the port that is connected are printed out:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出连接的地址和端口号：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`currentTime` is evaluated:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`currentTime`被评估：'
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following statement sends data to the socket, returning the number of bytes
    sent:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句向套接字发送数据，并返回发送的字节数：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following statement indicates the socket closure (that is, the communication
    channel); all subsequent operations on the socket will fail. The sockets are automatically
    closed when they are rejected, but it is always recommended to close them with
    the `close()` operation:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句表示套接字关闭（即通信通道）；套接字上的所有后续操作都将失败。当套接字被拒绝时，它们会自动关闭，但始终建议使用`close()`操作来关闭它们：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code for the client (`client.py`) is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的代码（`client.py`）如下：
- en: 'Import the `socket` library:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`socket`库：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `socket` object is then created:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建`socket`对象：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Get the local machine name (`host`):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取本地机器名称（`host`）：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Set the `port` number:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`端口号`：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set up the connection to `host` and `port`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置到`host`和`port`的连接：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The maximum number of bytes that can be received is no more than 1,024 bytes:
    (`tm=s.recv(1024)`).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以接收的最大字节数不超过1,024字节：（`tm=s.recv(1024)`）。
- en: 'Now, close the connection and finally print out the connection time to the
    server:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭连接，并最终打印出连接到服务器的时间：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Clients and servers create their respective sockets, and the server listens
    to them on a port. The client makes a connection request to the server. It should
    be noted that we can have two different port numbers because one could only be
    dedicated to outgoing traffic, and the other could only be dedicated to entry.
    This depends on the host configuration.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务端分别创建它们各自的套接字，服务器在端口上监听它们。客户端向服务器发起连接请求。需要注意的是，我们可以有两个不同的端口号，因为其中一个可能仅用于出站流量，而另一个可能仅用于入站。这取决于主机配置。
- en: Essentially, the client's local port does not necessarily coincide with the
    server's remote port. The server receives the request and, if accepted, a new
    connection is created. Now, the client and server communicate through a virtual
    channel, between the socket and the server, which is created specifically for
    the data flow of the data socket connection.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，客户端的本地端口不一定与服务器的远程端口相匹配。服务器接收请求，如果被接受，就会创建一个新的连接。现在，客户端和服务器通过一个虚拟通道进行通信，这个通道是在数据套接字连接的数据流中专门创建的，位于套接字和服务端之间。
- en: Consistent with what was mentioned in the first phase, the server creates the
    data socket because the first one is used exclusively for managing requests. Therefore, it
    is possible that there are many clients communicating with the server using the
    data socket created by the server for them. The TCP protocol is connection-oriented,
    which means that when there is no longer a need to communicate, the client communicates
    this to the server and the connection is closed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一阶段提到的内容一致，服务器创建数据套接字，因为第一个套接字是专门用于管理请求的。因此，可能有多个客户端正在使用服务器为它们创建的数据套接字与服务器通信。TCP协议是面向连接的，这意味着当不再需要通信时，客户端会通知服务器，然后关闭连接。
- en: 'To run the example, execute the server:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，请执行服务器：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, execute the client (in a different Windows terminal):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个Windows终端中执行客户端：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result on the client side should report the address (`addr`) and report
    `port` as connected:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的结果应报告连接的地址（`addr`）和端口（`port`）：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, on the server side, the result should be as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在服务器端，结果应该是这样的：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With a small change to the previous code, we can create a simple client-server
    application for file transfer. The server instantiates the socket and waits for
    the connection instance from the client. Once connected to the server, the client
    starts the data transfer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对之前代码的微小修改，我们可以创建一个简单的文件传输客户端-服务器应用程序。服务器实例化套接字并等待来自客户端的连接实例。一旦连接到服务器，客户端就开始数据传输。
- en: The data to be transferred, which is in the `mytext.txt` file, is copied byte
    by byte and sent to the server through the call to the `conn.send` function. The
    server then receives the data and writes it to a second file, `received.txt`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要传输的数据，位于`mytext.txt`文件中，通过调用`conn.send`函数逐字节复制并发送到服务器。然后服务器接收数据并将其写入第二个文件，`received.txt`。
- en: 'The source code for `client2.py` is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`client2.py`的源代码如下：'
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the source code for `client.py`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`client.py`的源代码：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Types of sockets
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字类型
- en: 'We can distinguish between the following three types of sockets, which are
    characterized by connection modes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分以下三种类型的套接字，它们以连接模式为特征：
- en: '**Stream sockets**: These are connection-oriented sockets, and they are based
    on reliable protocols such as TCP or SCTP.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流套接字**：这些是面向连接的套接字，基于TCP或SCTP等可靠协议。'
- en: '**Datagram** **sockets**: These are not connection-oriented (connectionless)
    sockets, and are based on the fast but unreliable UDP protocol.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据报套接字**：这些不是面向连接的（无连接）套接字，基于快速但不可靠的UDP协议。'
- en: '**Raw socket** (raw IP): The transport level is bypassed, and the header is
    accessible at the application level.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始套接字**（原始IP）：传输层被绕过，头部在应用层可访问。'
- en: Stream sockets
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流套接字
- en: We will see more in particular of this type of socket only. Being based on transport
    layer protocols such as TCP, they guarantee a reliable, full-duplex, and connection-oriented
    communication, with a variable-length byte stream.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特别看到这种类型套接字的更多内容。基于TCP等传输层协议，它们保证可靠、全双工和面向连接的通信，具有可变长度的字节流。
- en: 'Communication through this socket consists of these phases:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此套接字进行的通信包括以下阶段：
- en: '**Creation of sockets**: Clients and servers create their respective sockets,
    and the server listens to them on a port. Since the server can create multiple
    connections with different clients (but also with the same one), it needs a queue
    to handle the various requests.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**套接字创建**：客户端和服务器创建它们各自的套接字，服务器在端口上监听它们。由于服务器可以与不同的客户端（甚至同一个客户端）创建多个连接，因此它需要一个队列来处理各种请求。'
- en: '**Connection request**: The client requests a connection to the server. Note
    that we can have different port numbers because one could only be assigned to
    the outgoing traffic, and the other only to entry. This depends on the host configuration.
    Essentially, the client''s local port does not necessarily coincide with the server''s
    remote port. The server receives the request and, if accepted, a new connection
    is created. In the diagram, the port of the client socket is `8080`, while for
    the socket server, the port is `80`.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接请求**：客户端请求与服务器建立连接。请注意，我们可以有不同的端口号，因为一个可能只分配给出站流量，另一个只分配给入站流量。这取决于主机配置。本质上，客户端的本地端口不一定与服务器的远程端口相同。服务器接收请求，如果接受，则创建一个新的连接。在图中，客户端套接字的端口号为`8080`，而套接字服务器的端口号为`80`。'
- en: '**Communication**: Now, the client and server communicate through a virtual
    channel, between the client''s socket, and a new socket (server side)*,* created
    specifically for the data flow of this connection: a data socket. As it was mentioned
    in the first phase, the server creates the data socket because the first data
    socket is used exclusively for managing requests. Therefore, it is possible that
    there are many clients communicating with the server, each with the data socket
    specifically created by the server for them.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通信**：现在，客户端和服务器通过一个虚拟通道进行通信，在客户端套接字和为数据流创建的新套接字（服务器端）之间：一个数据套接字。正如在第一阶段提到的，服务器创建数据套接字，因为第一个数据套接字仅用于管理请求。因此，可能有多个客户端与服务器通信，每个客户端都有一个服务器为它们专门创建的数据套接字。'
- en: '**Closure of the connection**: Since the TCP is a connection-oriented protocol
    when there is no longer a need to communicate, the client communicates it to the
    server, which deallocates the data socket.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接关闭**：由于 TCP 是一种面向连接的协议，当不再需要通信时，客户端会通知服务器，服务器将释放数据套接字。'
- en: 'The phases of communication through stream sockets are shown in the following
    diagram:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过流套接字进行通信的阶段在以下图中展示：
- en: '![](img/4a04807a-ed49-44eb-9f21-2346ea59f835.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a04807a-ed49-44eb-9f21-2346ea59f835.png)'
- en: Stream socket phases
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 流套接字阶段
- en: See also
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: More information on Python sockets can be found at [https://docs.python.org/3/howto/sockets.html](https://docs.python.org/3/howto/sockets.html).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更多有关 Python 套接字的信息可以在 [https://docs.python.org/3/howto/sockets.html](https://docs.python.org/3/howto/sockets.html)
    找到。
- en: Distributed task management with Celery
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Celery 进行分布式任务管理
- en: '*Celery* is a Python framework that manages distributed tasks by following
    theobject-oriented middleware approach. Its main feature is handling many small
    tasks and distributing them on many computational nodes. Finally, the result of
    each task will then be reworked in order to compose the overall solution.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*Celery* 是一个 Python 框架，通过面向对象中间件方法管理分布式任务。其主要特点是处理许多小任务并将它们分布到多个计算节点上。最后，每个任务的输出将被重新处理，以组成整体解决方案。'
- en: To use Celery, a message broker is required. This is an independent (from Celery)
    software component that has the function of middleware, which is used to send
    and receive messages to distributed task workers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Celery，需要一个消息代理。这是一个独立的（与 Celery 无关）软件组件，具有中间件功能，用于向分布式任务工作者发送和接收消息。
- en: 'In fact, a message broker—also known as message middleware—deals with the exchange
    of messages in a communication network.: the addressing scheme of this type of
    middleware is no longer of the point-to-point type, but is message-oriented addressing.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，消息代理——也称为消息中间件——处理通信网络中的消息交换：此类中间件的寻址方案不再是点对点类型，而是面向消息的寻址。
- en: 'The reference architecture, with which the message broker manages the exchange
    of messages, is based on the so-called publish/subscribe paradigm, which is depicted
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理管理的消息交换的参考架构基于所谓的发布/订阅范式，如下所示：
- en: '![](img/081ba83c-57b4-44c6-aaa5-89f6d9e0989c.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/081ba83c-57b4-44c6-aaa5-89f6d9e0989c.png)'
- en: Message broker architecture
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理架构
- en: Celery supports many types of brokers. However, the more complete ones are RabbitMQ
    and Redis.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Celery 支持许多类型的代理。然而，更完整的是 RabbitMQ 和 Redis。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To install Celery, use the `pip` installer as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Celery，请使用以下 `pip` 安装程序：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, a message broker must be installed. There are several choices available,
    but for our example, it is recommended to install RabbitMQ from the following
    link: [http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须安装一个消息代理。有几种选择可用，但为了我们的示例，建议从以下链接安装 RabbitMQ：[http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html)。
- en: RabbitMQ is a message-oriented middleware that implements the **Advanced Message
    Queuing Protocol** (**AMQP**). The RabbitMQ server is written in the Erlang programming
    language, so in order to install it, you need to install Erlang after downloading
    it from [http://www.erlang.org/download.html](http://www.erlang.org/download.html).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 是一种面向消息的中间件，实现了 **高级消息队列协议**（**AMQP**）。RabbitMQ 服务器是用 Erlang 编程语言编写的，因此为了安装它，您需要从
    [http://www.erlang.org/download.html](http://www.erlang.org/download.html) 下载并安装
    Erlang。
- en: 'The steps involved are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: 'To check the `celery` installation, first start the message broker (for example, RabbitMQ).
    Then, type the following:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查 `celery` 的安装，首先启动消息代理（例如，RabbitMQ）。然后，输入以下命令：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following output, which indicates the `celery` version, is as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下输出，表示`celery`版本，如下所示：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, let's learn about how to create and call a task using the `celery` module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何使用`celery`模块创建和调用任务。
- en: '`celery` provides the following two methods to perform a call to a task:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`celery`提供了以下两种方法来调用任务：'
- en: '`apply_async(args[, kwargs[, ...]])`: This sends a task message.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_async(args[, kwargs[, ...]])`：这会发送一个任务消息。'
- en: '`delay(*args, **kwargs)`: This is a shortcut to send a task message, but it
    does not support execution options.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay(*args, **kwargs)`：这是一个发送任务消息的快捷方式，但它不支持执行选项。'
- en: 'The `delay` method is easier to use because it is called as a** regular function**: `task.delay(arg1,
    arg2, kwarg1=''x'', kwarg2=''y'')`. However, for `apply_async`, the syntax is `task.apply_async
    (args=[arg1,arg2] kwargs={''kwarg1'':''x'',''kwarg2'': ''y''})`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay`方法更容易使用，因为它被调用为一个**常规函数**：`task.delay(arg1, arg2, kwarg1=''x'', kwarg2=''y'')`。然而，对于`apply_async`，语法是`task.apply_async
    (args=[arg1,arg2] kwargs={''kwarg1'':''x'',''kwarg2'': ''y''})`。'
- en: Windows setup
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows设置
- en: 'In order to use Celery in a Windows environment, you must perform the following
    procedure:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Windows环境中使用Celery，您必须执行以下程序：
- en: Go to System Properties | Environment Variables | User or System variables |
    New.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往系统属性 | 环境变量 | 用户或系统变量 | 新建。
- en: 'Set the following values:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置以下值：
- en: 'Variable name: `FORKED_BY_MULTIPROCESSING`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名：`FORKED_BY_MULTIPROCESSING`
- en: 'Variable value: `1`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量值：`1`
- en: The reason for this setup is because of Celery's dependence on the `billiard`
    package ([https://github.com/celery/billiard](https://github.com/celery/billiard)),
    which uses the `FORKED_BY_MULTIPROCESSING` variable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置的原因是因为Celery依赖于`billiard`包([https://github.com/celery/billiard](https://github.com/celery/billiard))，它使用`FORKED_BY_MULTIPROCESSING`变量。
- en: For more information on Celery's Windows setup, read [https://www.distributedpython.com/2018/08/21/celery-4-windows/](https://www.distributedpython.com/2018/08/21/celery-4-windows/).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Celery在Windows上的设置更多信息，请参阅[https://www.distributedpython.com/2018/08/21/celery-4-windows/](https://www.distributedpython.com/2018/08/21/celery-4-windows/)。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The task here is a sum of two numbers. To perform this easy task, we have to
    compose the `addTask.py` and `addTask_main.py` script files:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的任务是对两个数字的求和。为了执行这个简单的任务，我们必须组合`addTask.py`和`addTask_main.py`脚本文件：
- en: 'For `addTask.py`, start to import the Celery framework as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`addTask.py`，开始导入Celery框架如下：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, define the task. In our example, the task is a sum of two numbers:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义任务。在我们的例子中，任务是对两个数字的求和：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, import the `addTask.py` file that was defined previously into `addtask_main.py`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将之前定义的`addTask.py`文件导入到`addtask_main.py`中：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, call `addTask.py` to execute the sum of two numbers:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用`addTask.py`来执行两个数字的求和：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to use Celery, the first thing to do is to run the RabbitMQ service,
    and then execute the Celery worker server (that is, the `addTask.py` file script)
    by typing the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Celery，首先要做的是运行RabbitMQ服务，然后通过键入以下内容来执行Celery工作服务器（即`addTask.py`文件脚本）：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, the second script is launched using Python:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用Python启动第二个脚本：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, the result should be as follows in the first Command Prompt:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第一个命令提示符中的结果应该如下所示：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, the result is `10`. Let''s focus on the first script, `addTask.py`:
    in the first two lines of code, we create a `Celery` application instance that
    uses the RabbitMQ service broker:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果是`10`。让我们专注于第一个脚本，`addTask.py`：在前两行代码中，我们创建了一个使用RabbitMQ服务代理的`Celery`应用程序实例：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first argument in the `Celery` function is the name of the current module
    (`addTask.py`), and the second is the broker keyboard argument; this indicates
    the URL that is used to connect the broker (RabbitMQ).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Celery`函数的第一个参数是当前模块的名称（`addTask.py`），第二个是代理键盘参数；这表示用于连接代理（RabbitMQ）的URL。'
- en: Now, let's introduce the task to be accomplished.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍要完成的任务。
- en: Each task must be added with the `@app.task` annotation (namely, decorator); the
    decorator helps `Celery` to identify which functions can be scheduled in the task
    queue.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务都必须使用`@app.task`注解（即，装饰器）来添加；装饰器帮助`Celery`识别哪些函数可以被调度到任务队列中。
- en: 'After the decorator, we create the task that the workers can execute: this
    will be a simple function that performs the sum of two numbers:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在装饰器之后，我们创建了一个工人可以执行的任务：这将是一个简单的执行两个数字求和的函数：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the second script, `addTask_main.py`, we call our task by using the `delay()`
    method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个脚本`addTask_main.py`中，我们使用`delay()`方法调用我们的任务：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let's remember that this method is a shortcut to the `apply_async()` method,
    which gives us greater control over the task execution.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住，此方法是 `apply_async()` 方法的快捷方式，它为我们提供了对任务执行的更多控制。
- en: There's more...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Celery usage is very simple. It can be executed by using the following commands:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Celery 的使用非常简单。可以使用以下命令执行：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, the options are as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，选项如下：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The main commands are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 主要命令如下：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Celery protocol can be implemented in any language by using Webhooks ([https://developer.github.com/webhooks/](https://developer.github.com/webhooks/)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Celery 协议可以通过使用 Webhooks 在任何语言中实现（[https://developer.github.com/webhooks/](https://developer.github.com/webhooks/)）。
- en: See also
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: More information on Celery can be found at [http://www.celeryproject.org/](http://www.celeryproject.org/).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 Celery 的信息可以在 [http://www.celeryproject.org/](http://www.celeryproject.org/)
    找到。
- en: The recommended message brokers ([https://en.wikipedia.org/wiki/Message_broker](https://en.wikipedia.org/wiki/Message_broker)) are RabbitMQ
    ([https://en.wikipedia.org/wiki/RabbitMQ](https://en.wikipedia.org/wiki/RabbitMQ)) or Redis
    ([https://en.wikipedia.org/wiki/Redis](https://en.wikipedia.org/wiki/Redis)).
    Additionally, there is MongoDB ([https://en.wikipedia.org/wiki/MongoDB](https://en.wikipedia.org/wiki/MongoDB)),
    Beanstalk, Amazon SQS ([https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service](https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service)), CouchDB
    ([https://en.wikipedia.org/wiki/Apache_CouchDB](https://en.wikipedia.org/wiki/Apache_CouchDB)),
    and IronMQ ([https://www.iron.io/mq](https://www.iron.io/mq)).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐的消息代理（[https://en.wikipedia.org/wiki/Message_broker](https://en.wikipedia.org/wiki/Message_broker)）是
    RabbitMQ ([https://en.wikipedia.org/wiki/RabbitMQ](https://en.wikipedia.org/wiki/RabbitMQ)）或
    Redis ([https://en.wikipedia.org/wiki/Redis](https://en.wikipedia.org/wiki/Redis)）。此外，还有
    MongoDB ([https://en.wikipedia.org/wiki/MongoDB](https://en.wikipedia.org/wiki/MongoDB))、Beanstalk、Amazon
    SQS ([https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service](https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service))、CouchDB
    ([https://en.wikipedia.org/wiki/Apache_CouchDB](https://en.wikipedia.org/wiki/Apache_CouchDB))
    和 IronMQ ([https://www.iron.io/mq](https://www.iron.io/mq))。
- en: RMI with Pyro4
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pyro4 的 RMI
- en: '**Pyro **is short for **Python Remote Objects**. It works exactly like the
    Java **RMI **(short for **Remote Method Invocation**) allowing to invoke a method
    of a remote object (belonging to a different process) exactly as if the object
    were local (belonging to the same process in which the invocation runs).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pyro** 是 **Python Remote Objects** 的缩写。它的工作方式与 Java 的 **RMI**（远程方法调用）完全相同，允许像本地对象（属于在调用中运行的同一进程）一样调用远程对象的函数（属于不同的进程）。'
- en: The use of an RMI mechanism, in an object-oriented system, involves significant
    advantages of uniformity and symmetry in the project, as this mechanism enables
    the modelling of interactions between distributed processes using the same conceptual
    tool.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的系统中使用 RMI 机制，涉及项目中的统一性和对称性的显著优势，因为此机制允许使用相同的概念工具对分布式进程之间的交互进行建模。
- en: 'As you can see from the following diagram, `Pyro4` enables objects to be distributed in
    a client/server style; this means that the main parts of a `Pyro4` system may
    switch from a client caller to a remote object, which is called to serve a function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，`Pyro4` 允许对象以客户端/服务器风格进行分布式；这意味着 `Pyro4` 系统的主要部分可以从客户端调用者切换到远程对象，该对象被调用以执行函数：
- en: '![](img/1782750b-b3f5-4ac1-8274-f01d46cff0ec.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1782750b-b3f5-4ac1-8274-f01d46cff0ec.png)'
- en: RMI
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: RMI
- en: 'It is important to note that during the remote calling, there are always two
    distinct parts: a client and a server that accept and execute the client call.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在远程调用过程中，始终有两个不同的部分：一个客户端和一个服务器，它们接受并执行客户端调用。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The entire method of managing this mechanism in a distributed way is provided
    by `Pyro4`. To install the latest release of `Pyro4`, use the `pip` installer
    (Windows installation is used here) and add the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式方式中管理此机制的全部方法由 `Pyro4` 提供。要安装 `Pyro4` 的最新版本，使用 `pip` 安装程序（此处使用 Windows 安装）并添加以下命令：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are using the `pyro_server.py` and `pyro_client.py` codes for this recipe.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `pyro_server.py` 和 `pyro_client.py` 代码来完成此菜谱。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this example, we''ll see how to build and use a simple client-server communication using
    the `Pyro4` middleware. The code for the client is `pyro_server.py`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将看到如何使用 `Pyro4` 中间件构建和使用简单的客户端-服务器通信。客户端的代码是 `pyro_server.py`：
- en: 'Import the `Pyro4` library:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `Pyro4` 库：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the `Server` class that contains the `welcomeMessage()` method that
    will be exposed:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义包含将要公开的 `welcomeMessage()` 方法的 `Server` 类：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that the decorator, `@Pyro4.expose`, means that the preceding method will
    be remotely accessible.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，装饰器`@Pyro4.expose`表示前面的方法将可以远程访问。
- en: 'The `startServer` function contains all the instructions that are used to start
    the server:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`startServer`函数包含了启动服务器所需的所有指令：'
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, build the `server` instance of the `Server` class:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建`Server`类的`server`实例：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, define the `Pyro4` daemon:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义`Pyro4`守护程序：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To execute this script, we must run a `Pyro4` statement to locate a nameserver:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行此脚本，我们必须运行一个`Pyro4`语句来定位名称服务器：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Register the object server as *Pyro object*; it will only be known inside the
    Pyro daemon:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象服务器注册为*Pyro对象*；它只会在Pyro守护程序内部被知晓：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can register the object server with a name in the nameserver:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在名称服务器中以一个名称注册对象服务器：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The function ends with a call to the daemon''s `requestLoop` method. This starts
    the event loop of the server and waits for calls:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数以调用守护程序的`requestLoop`方法结束。这启动了服务器的事件循环并等待调用：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, call `startServer` via the `main` program:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过`main`程序调用`startServer`：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is the code for the client (`pyro_client.py`):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为客户端（`pyro_client.py`）编写的代码：
- en: 'Import the `Pyro4` library:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Pyro4`库：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `Pyro4` API enables the developer to distribute objects in a transparent
    way. In this example, the client script sends requests to the server program in
    order to execute the `welcomeMessage()` method:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pyro4` API允许开发者以透明的方式分布对象。在这个例子中，客户端脚本向服务器程序发送请求以执行`welcomeMessage()`方法：'
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, the remote call is created:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建远程调用：
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, the client calls the server, printing a message:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，客户端调用服务器，打印一条消息：
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding example is composed of two main functions: `pyro_server.py` and
    `pyro_client.py`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子由两个主要函数组成：`pyro_server.py`和`pyro_client.py`。
- en: 'In `pyro_server.py`, the `Server` class object provides the `welcomeMessage()` method,
    returning a string equal to the name inserted in the client session:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pyro_server.py`中，`Server`类对象提供了`welcomeMessage()`方法，返回一个等于客户端会话中插入的名称的字符串：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Pyro4` uses daemon objects to dispatch incoming calls to appropriate objects.
    A server must create just one daemon that manages everything from its instance.
    Each server has a daemon that knows about all the Pyro objects that the server
    provides:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pyro4`使用守护程序对象将传入的调用分配到适当的对象。服务器必须创建一个守护程序来管理其实例的所有内容。每个服务器都有一个守护程序，它了解服务器提供的所有Pyro对象：'
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As for the `pyro_client.py` function, the remote call is first performed and
    creates a `Proxy` object. In particular, the `Pyro4` client uses proxy objects
    to forward method calls to the remote objects, and then passes the results back
    to the calling code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`pyro_client.py`函数，首先执行远程调用并创建一个`Proxy`对象。特别是，`Pyro4`客户端使用代理对象将方法调用转发到远程对象，然后将结果返回给调用代码：
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to execute a client-server connection, we need to have a `Pyro4` nameserver
    running. In Command Prompt, type the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行客户端-服务器连接，我们需要有一个正在运行的`Pyro4`名称服务器。在命令提示符中，输入以下内容：
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After this, you''ll see the following message:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会看到以下信息：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding message means that the nameserver is running in your network.
    Finally, we can start the server and the client scripts in two separate Windows
    consoles:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的信息表示名称服务器正在你的网络中运行。最后，我们可以在两个单独的Windows控制台中启动服务器和客户端脚本：
- en: 'To run `pyro_server.py`, just type the following:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行`pyro_server.py`，只需输入以下内容：
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Following that, you''ll see something like this:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你会看到类似以下的内容：
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, run the client by typing the following:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过输入以下内容运行客户端：
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following message will be printed out:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将打印出以下信息：
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Insert a name (for example, `Ruvika`):'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个名称（例如，`Ruvika`）：
- en: '[PRE65]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following welcome message will be displayed:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示以下欢迎信息：
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There's more...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Among the features of `Pyro4`, there is the creation of object topologies.
    For example, let''s suppose we want to build a distributed architecture that follows
    a chain topology, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Pyro4`的特性中，有创建对象拓扑的功能。例如，假设我们想要构建一个遵循链式拓扑的分布式架构，如下所示：
- en: '![](img/7f93a4ab-70f7-4ecb-8a0b-f5633c11bad1.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f93a4ab-70f7-4ecb-8a0b-f5633c11bad1.png)'
- en: Chaining objects with Pyro4
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pyro4链式对象
- en: The Client makes a request to **Server 1**, and then the request is forwarded to
    **Server *2***, which then calls **Server** **3**. The chain call ends when **Server
    3 **calls **Server 1**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端向**服务器1**发起请求，然后请求被转发到**服务器*2**，然后**服务器2**调用**服务器** **3**。链式调用在**服务器3**调用**服务器1**时结束。
- en: Implementing chain topology
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现链式拓扑
- en: To implement a chain topology using `Pyro4`**,** we need to implement a `chain`
    object and the `client` and `server` objects. The `Chain` class allows the call
    to be redirected to the next server by processing the input message and reconstructing
    the server address to which the request should be addressed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Pyro4`实现链式拓扑，我们需要实现`chain`对象以及客户端和服务器对象。`Chain`类允许通过处理输入消息并重建请求应发送到的服务器地址，将调用重定向到下一个服务器。
- en: 'Also note, in this case, the `@Pyro4.expose` decorator, which allows all the
    methods of the class (`chainTopology.py`) to be exposed:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在这种情况下，`@Pyro4.expose`装饰器允许暴露类（`chainTopology.py`）的所有方法：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the chain is closed (the last call is done from `server_chain_3.py` to `server_chain_1.py`),
    then a closing message is printed out:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链已关闭（最后一个调用是从`server_chain_3.py`到`server_chain_1.py`），则打印出关闭消息：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A forwarding message is printed out if there is a next element in the chain:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链中存在下一个元素，则打印出转发消息：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, we have the source code for the client (`client_chain.py`):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有客户端的源代码（`client_chain.py`）：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Following this is the source code for the first server (namely, `server_1`)
    in the chain that is called from the client (`server_chain_1.py`). Here, the relevant
    libraries are imported. Note, the import to the `chainTopology.py` file that was described
    previously:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是第一个服务器（即`server_1`）的源代码，它是由客户端（`server_chain_1.py`）调用的。在这里，导入了相关的库。注意，之前描述的`chainTopology.py`文件的导入：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Note also that the source code for the servers only differs as regards the
    definitions of the current and the next servers of the chain:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，服务器的源代码仅在定义链中的当前服务器和下一个服务器方面有所不同：
- en: '[PRE72]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The remaining lines of code define the communication with the next element
    in the chain:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码行定义了与链中下一个元素的通信：
- en: '[PRE73]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To execute this example, first run the `Pyro4` nameserver:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，首先运行`Pyro4`名称服务器：
- en: '[PRE74]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the three servers in three different terminals, typing each of them respectively 
    (Windows terminals are used here):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在三个不同的终端中运行三个服务器，分别输入每个服务器的名称（这里使用Windows终端）：
- en: 'The first server (`server_chain_1.py`) in the first terminal:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个终端中的第一个服务器（`server_chain_1.py`）：
- en: '[PRE75]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Followed by the second server (`server_chain_2.py`) in the second terminal:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第二个终端中运行第二个服务器（`server_chain_2.py`）：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And finally, the third server  (`server_chain_3.py`) in the third terminal:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第三个终端中运行第三个服务器（`server_chain_3.py`）：
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, run the `client_chain.py` script from another terminal:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从另一个终端运行`client_chain.py`脚本：
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This is the output, as shown in the Command Prompt:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令提示符中显示的输出：
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The preceding message is displayed as a result of the forwarding request passed
    across the three servers after it returned the fact that the task is completed
    to `server_chain_1`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的消息是在三个服务器之间传递转发请求后显示的，因为它返回了任务已完成的消息给`server_chain_1`。
- en: 'Also, we can focus on the behavior of the object servers while the request
    is forwarded to the next object in the chain (refer to the message underneath
    the start message):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以关注在请求转发到链中的下一个对象时对象服务器的行为（参考启动消息下的消息）：
- en: '**`server_ 1`** is started and the following message is forwarded to `server_ 2`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`server_1`**启动并将以下消息转发给`server_2`：'
- en: '[PRE80]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`server_2` forwards the following message to `server_3`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`server_2`将以下消息转发给`server_3`：'
- en: '[PRE81]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`server_ 3` forwards the following message to `server_1`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`server_3`将以下消息转发给`server_1`：'
- en: '[PRE82]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, the message returns to the starting point (in other words, `server_1`),
    closing the chain :'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，消息返回到起点（换句话说，`server_1`），关闭链：
- en: '[PRE83]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: See also
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `Pyro4` documentation is available at [https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf](https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pyro4`文档可在[https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf](https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf)找到。'
- en: This contains a description and some application examples of the 4.75 release.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了4.75版本的描述和一些应用示例。
