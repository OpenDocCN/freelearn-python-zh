- en: Chapter 2. Fast Array Operations with NumPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 使用NumPy进行快速数组操作
- en: NumPy is the *de facto* standard for scientific computing in Python. It extends
    Python with a flexible multidimensional array that allows fast mathematical calculations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是Python中科学计算的**事实标准**。它通过提供灵活的多维数组扩展了Python，允许快速进行数学计算。
- en: 'NumPy works as a framework that allows coding complex operations using a concise
    syntax. The multidimensional array (`numpy.ndarray`) is internally based on C
    arrays: in this way, the developer can easily interface NumPy with existing C
    and FORTRAN code. NumPy constitutes a bridge between Python and the legacy code
    written using those languages.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy作为一个框架，允许使用简洁的语法进行复杂操作。多维数组(`numpy.ndarray`)在内部基于C数组：这样，开发者可以轻松地将NumPy与现有的C和FORTRAN代码接口。NumPy构成了Python和这些语言编写的遗留代码之间的桥梁。
- en: In this chapter, we will learn how to create and manipulate NumPy arrays. We
    will also explore the NumPy broadcasting feature to rewrite complex mathematical
    expressions in an efficient and succinct manner.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建和操作NumPy数组。我们还将探索NumPy广播功能，以高效简洁的方式重写复杂的数学表达式。
- en: In the last few years a number of packages were developed to further increase
    the speed of NumPy. We will explore one of these packages, `numexpr`, that optimizes
    array expressions and takes advantage of multi-core architectures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，开发了许多包以进一步提高NumPy的速度。我们将探索这些包中的一个，`numexpr`，它优化数组表达式并利用多核架构。
- en: Getting started with NumPy
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用NumPy
- en: NumPy is founded around its multidimensional array object, `numpy.ndarray`.
    NumPy arrays are a collection of elements of the same data type; this fundamental
    restriction allows NumPy to pack the data in an efficient way. By storing the
    data in this way NumPy can handle arithmetic and mathematical operations at high
    speed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy围绕其多维数组对象`numpy.ndarray`建立。NumPy数组是相同数据类型元素的集合；这种基本限制允许NumPy以高效的方式打包数据。通过这种方式存储数据，NumPy可以以高速处理算术和数学运算。
- en: Creating arrays
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组
- en: 'You can create NumPy arrays using the `numpy.array` function. It takes a list-like
    object (or another array) as input and, optionally, a string expressing its data
    type. You can interactively test the array creation using an IPython shell as
    follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`numpy.array`函数创建NumPy数组。它接受一个类似列表的对象（或另一个数组）作为输入，并可选地接受一个表示其数据类型的字符串。你可以使用IPython
    shell交互式测试数组创建，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Every NumPy array has a data type that can be accessed by the `dtype` attribute,
    as shown in the following code. In the following code example, `dtype` is a 64-bit
    integer:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个NumPy数组都有一个数据类型，可以通过`dtype`属性访问，如下面的代码所示。在下面的代码示例中，`dtype`是一个64位整数：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we want those numbers to be treated as a `float` type of variable, we can
    either pass the `dtype` argument in the `np.array` function or cast the array
    to another data type using the `astype` method, as shown in the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将这些数字视为`float`类型的变量，我们可以在`np.array`函数中传递`dtype`参数，或者使用`astype`方法将数组转换为另一种数据类型，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create an array with two dimensions (an array of arrays) we can initialize
    the array using a nested sequence, shown as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个二维数组（数组数组），我们可以使用嵌套序列初始化数组，如下所示：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The array created in this way has two dimensions—**axes** in NumPy''s jargon.
    Such an array is like a table that contains two rows and three columns. We can
    access the axes structure using the `ndarray.shape` attribute:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建的数组有两个维度——在NumPy术语中称为**轴**。这样的数组就像一个包含两行三列的表格。我们可以使用`ndarray.shape`属性访问轴结构：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Arrays can also be reshaped, only as long as the product of the shape dimensions
    is equal to the total number of elements in the array. For example, we can reshape
    an array containing 16 elements in the following ways: (2, 8), (4, 4), or (2,
    2, 4). To reshape an array, we can either use the `ndarray.reshape` method or
    directly change the `ndarray.shape` attribute. The following code illustrates
    the use of the `ndarray.reshape` method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以被重塑，只要形状维度的乘积等于数组中元素的总数。例如，我们可以以下列方式重塑包含16个元素的数组：(2, 8)，(4, 4)，或(2, 2,
    4)。要重塑数组，我们可以使用`ndarray.reshape`方法或直接更改`ndarray.shape`属性。以下代码展示了`ndarray.reshape`方法的使用：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Thanks to this property you are also free to add dimensions of size one. You
    can reshape an array with 16 elements to (16, 1), (1, 16), (16, 1, 1), and so
    on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特性，你也可以自由地添加大小为1的维度。你可以将包含16个元素的数组重塑为(16, 1)，(1, 16)，(16, 1, 1)等等。
- en: 'NumPy provides convenience functions, shown in the following code, to create
    arrays filled with zeros, filled with ones, or without an initialization value
    (*empty*—their actual value is meaningless and depends on the memory state). Those
    functions take the array shape as a tuple and optionally its `dtype`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了便捷的函数，如下面的代码所示，用于创建填充零的数组、填充一的数组或没有初始化值（*empty*—它们的实际值没有意义，取决于内存状态）的数组。这些函数接受数组形状作为元组，并可选地接受其
    `dtype`：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our examples, we will use the `numpy.random` module to generate random floating
    point numbers in the (0, 1) interval. In the following code we use the `np.random`.`rand`
    function to generate an array of random numbers of shape (3, 3):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用 `numpy.random` 模块在 (0, 1) 区间内生成随机浮点数。在下面的代码中，我们使用 `np.random.rand`
    函数生成一个形状为 (3, 3) 的随机数数组：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sometimes, it is convenient to initialize arrays that have a similar shape
    to other arrays. Again, NumPy provides some handy functions for that purpose such
    as `zeros_like`, `empty_like`, and `ones_like`. These functions are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，初始化与其它数组形状相似的数组很方便。同样，NumPy 提供了一些方便的函数来实现这个目的，如 `zeros_like`，`empty_like`
    和 `ones_like`。这些函数如下所示：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Accessing arrays
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数组
- en: 'The NumPy array interface is, on a shallow level, similar to Python lists.
    They can be indexed using integers, and can also be iterated using a `for` loop.
    The following code shows how to index and iterate an array:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组接口在浅层上与 Python 列表相似。它们可以使用整数进行索引，也可以使用 `for` 循环进行迭代。以下代码展示了如何索引和迭代一个数组：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is also possible to index an array in multiple dimensions. If we take a
    (3, 3) array (an array containing 3 triplets) and we index the first element,
    we obtain the first triplet shown as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在多维中对数组进行索引。如果我们取一个 (3, 3) 的数组（包含 3 个三元组的数组）并索引第一个元素，我们将获得如下所示的第一个三元组：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can index the triplet again by adding the other index separated by a comma.
    To get the second element of the first triplet we can index using [0, 1], as shown
    in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加另一个索引并用逗号分隔来再次索引三元组。要获取第一个三元组的第二个元素，我们可以使用 [0, 1] 进行索引，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'NumPy allows you to slice arrays in single and multiple dimensions. If we index
    on the first dimension we will get a collection of triplets shown as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 允许你在单维和多维中切片数组。如果我们对第一维进行索引，我们将得到如下所示的一组三元组：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we slice the array with [0:2]. for every selected triplet we extract the
    first two elements, resulting in a (2, 2) array shown in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用 [0:2] 切片数组，对于每个选定的三元组，我们提取前两个元素，结果是一个 (2, 2) 的数组，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Intuitively, you can update values in the array by using both numerical indexes
    and slices. The syntax is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地，你可以使用数值索引和切片来更新数组中的值。语法如下：
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Indexing with the slicing syntax is fast because it doesn''t make copies of
    the array. In NumPy terminology it returns a *view* over the same memory area.
    If we take a slice of the original array and then change one of its values; the
    original array will be updated as well. The following code illustrates an example
    of the same:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片语法进行索引速度快，因为它不会复制数组。在 NumPy 术语中，它返回对相同内存区域的 *视图*。如果我们从原始数组中取一个切片并更改其值之一；原始数组也将被更新。以下代码演示了同样的例子：
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can take a look at another example that shows how the slicing syntax can
    be used in a real-world scenario. We define an array `r_i`, shown in the following
    line of code, which contains a set of 10 coordinates (x, y); its shape will be
    (10, 2):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看看另一个例子，展示如何在现实场景中使用切片语法。我们定义一个数组 `r_i`，如下面的代码行所示，它包含一组 10 个坐标（x, y）；其形状将是
    (10, 2)：
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A typical operation is extracting the x component of each coordinate. In other
    words, you want to extract the items [0, 0], [1, 0], [2, 0], and so on, resulting
    in an array with shape (10,). It is helpful to think that the first index is *moving*
    while the second one is *fixed* (at 0). With this in mind, we will slice every
    index on the first axis (the moving one) and take the first element (the fixed
    one) on the second axis, as shown in the following line of code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的操作是提取每个坐标的 x 分量。换句话说，你想要提取项目 [0, 0]，[1, 0]，[2, 0]，依此类推，结果是一个形状为 (10,) 的数组。有助于思考的是，第一个索引是
    *移动的*，而第二个索引是 *固定的*（在 0）。有了这个想法，我们将切片第一轴（移动的那个）上的每个索引，并在第二轴（固定的那个）上取第一个元素，如下面的代码行所示：
- en: '[PRE17]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the other hand, the following expression of code will keep the first index
    fixed and the second index moving, giving the first (x, y) coordinate:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下代码表达式将第一个索引固定，第二个索引移动，给出第一个（x, y）坐标：
- en: '[PRE18]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Slicing all the indexes over the last axis is optional; using `r_i[0]` has the
    same effect as `r_i[0, :]`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个轴上对索引进行切片是可选的；使用`r_i[0]`与`r_i[0, :]`具有相同的效果。
- en: NumPy allows to index an array by using another NumPy array made of either integer
    or Boolean values—a feature called *fancy indexing*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy允许使用另一个由整数或布尔值组成的NumPy数组来索引数组——这被称为*花式索引*。
- en: 'If you index with an array of integers, NumPy will interpret the integers as
    indexes and will return an array containing their corresponding values. If we
    index an array containing 10 elements with `[0, 2, 3]`, we obtain an array of
    size 3 containing the elements at positions 0, 2 and 3\. The following code gives
    us an illustration of this concept:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用整数数组进行索引，NumPy将解释这些整数为索引，并返回一个包含它们对应值的数组。如果我们用`[0, 2, 3]`索引包含10个元素的数组，我们将得到一个大小为3的数组，包含位置0、2和3的元素。以下代码展示了这一概念：
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can use fancy indexing on multiple dimensions by passing an array for each
    dimension. If we want to extract the elements [0, 2] and [1, 3] we have to pack
    all the indexes acting on the first axis in one array, and the ones acting on
    the second axis in another. This can be seen in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过为每个维度传递一个数组来在多个维度上使用花式索引。如果我们想提取元素[0, 2]和[1, 3]，我们必须将作用于第一个轴的所有索引打包在一个数组中，将作用于第二个轴的索引打包在另一个数组中。这可以在以下代码中看到：
- en: '[PRE20]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can also use normal lists as index arrays, but not tuples. For example
    the following two statements are equivalent:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用普通列表作为索引数组，但不能使用元组。例如，以下两个语句是等价的：
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, if you use a tuple, NumPy will interpret the following statement as
    an index on multiple dimensions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您使用一个元组，NumPy将解释以下语句为在多个维度上的索引：
- en: '[PRE22]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The index arrays are not required to be one-dimensional; we can extract elements
    from the original array in any shape. For example we can select elements from
    the original array to form a (2, 2) array shown as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数组不必是一维的；我们可以以任何形状从原始数组中提取元素。例如，我们可以从原始数组中选择元素以形成一个（2, 2）的数组，如下所示：
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The array slicing and fancy indexing features can be combined. For example,
    this is useful if we want to swap the x and y columns in a coordinate array. In
    the following code, the first index will be running over all the elements (a slice),
    and for each of those we extract the element in position 1 (the y) first and then
    the one in position 0 (the x):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以组合数组切片和花式索引功能。例如，如果我们想在坐标数组中交换x和y列，这很有用。在下面的代码中，第一个索引将遍历所有元素（一个切片），然后对于这些元素，我们首先提取位置1（y）的元素，然后是位置0（x）的元素：
- en: '[PRE24]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the index array is a boolean there are slightly different rules. The Boolean
    array will act like a *mask*; every element corresponding to `True` will be extracted
    and put in the output array. This procedure is shown as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引数组是布尔值时，有一些不同的规则。布尔数组将像*掩码*一样作用；每个对应于`True`的元素将被提取并放入输出数组中。这个过程如下所示：
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The same rules apply when dealing with multiple dimensions. Furthermore, if
    the index array has the same shape as the original array, the elements corresponding
    to `True` will be selected and put in the resulting array.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多个维度时，同样适用这些规则。此外，如果索引数组与原始数组具有相同的形状，则对应于`True`的元素将被选中并放入结果数组中。
- en: 'Indexing in NumPy is a reasonably fast operation. Anyway, when speed is critical,
    you can use the slightly faster `numpy.take` and `numpy.compress` functions to
    squeeze out a little more speed. The first argument of `numpy.take` is the array
    we want to operate on, and the second is the list of indexes we want to extract.
    The last argument is `axis`; if not provided, the indexes will act on the flattened
    array, otherwise they will act along the specified axis. The following code shows
    the use of `np.take` and its execution time compared to fancy indexing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy中的索引操作是一个相对快速的操作。无论如何，当速度至关重要时，您可以使用稍微快一点的`numpy.take`和`numpy.compress`函数来挤出更多速度。`numpy.take`的第一个参数是我们想要操作的数组，第二个参数是我们想要提取的索引列表。最后一个参数是`axis`；如果没有提供，索引将作用于展平后的数组，否则将沿着指定的轴进行。以下代码显示了`np.take`的使用及其与花式索引的执行时间比较：
- en: '[PRE26]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The similar, but a faster way to index using Boolean arrays is `numpy.compress`
    which works in the same way as `numpy.take`. The use of `numpy.compress` is shown
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔数组索引的类似但更快的方法是 `numpy.compress`，它的工作方式与 `numpy.take` 相同。以下是如何使用 `numpy.compress`
    的示例：
- en: '[PRE27]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Broadcasting
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播
- en: The true power of NumPy lies in its fast mathematical operations. The approach
    used by NumPy is to avoid stepping into Python by performing an element-wise calculation
    between matching arrays.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的真正力量在于其快速的数学运算。NumPy 使用的策略是通过在匹配的数组之间进行逐元素计算来避免进入 Python。
- en: 'Whenever you do an arithmetic operation on two arrays (like a product), if
    the two operands have the same shape, the operation will be applied in an element-wise
    fashion. For example, upon multiplying two (2, 2) arrays, the operation will be
    done between pairs of corresponding elements, producing another (2, 2) array,
    as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你在两个数组（如乘积）上进行算术运算，如果两个操作数具有相同的形状，该操作将以逐元素的方式应用。例如，在乘以两个 (2, 2) 的数组时，操作将在对应元素对之间进行，产生另一个
    (2, 2) 的数组，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the shapes of the operand don''t match, NumPy will attempt to match them
    using certain rules—a feature called *broadcasting*. If one of the operands is
    a single value, it will be applied to every element of the array, as shown in
    the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数的形状不匹配，NumPy 将尝试使用某些规则来匹配它们——这被称为 *广播* 功能。如果一个操作数是一个单独的值，它将被应用到数组的每个元素上，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the operand is another array, NumPy will try to match the shapes starting
    from the last axis. For example, if we want to combine an array of shape (3, 2)
    with one of shape (2,), the second array is repeated three times to generate a
    (3, 2) array. The array is *broadcasted* to match the shape of the other operand,
    as shown in the following figure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数是另一个数组，NumPy 将从最后一个轴开始尝试匹配形状。例如，如果我们想将一个形状为 (3, 2) 的数组与一个形状为 (2,) 的数组组合，第二个数组将被重复三次以生成一个
    (3, 2) 的数组。数组被 *广播* 以匹配另一个操作数的形状，如下面的图所示：
- en: '![Broadcasting](img/8458OS_02_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![广播](img/8458OS_02_01.jpg)'
- en: If the shapes mismatch, for example by combining an array (3, 2) with an array
    (2, 2), NumPy will throw an exception.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果形状不匹配，例如通过将一个形状为 (3, 2) 的数组与一个形状为 (2, 2) 的数组组合，NumPy 将抛出异常。
- en: 'If one of the axes size is 1, the array will be repeated over this axis until
    the shapes match. To illustrate that point, if we have an array of the following
    shape:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个轴的大小是 1，数组将在这个轴上重复，直到形状匹配。为了说明这一点，如果我们有一个形状如下的数组：
- en: '[PRE30]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'and we want to broadcast it with an array (5, 1, 2), the array will be repeated
    on the second axis for 10 times which is shown as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们想将它与一个形状为 (5, 1, 2) 的数组广播，数组将在第二个轴上重复 10 次，如下所示：
- en: '[PRE31]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have seen earlier, that we can freely reshape arrays to add axes of size
    1\. Using the `numpy.newaxis` constant while indexing will introduce an extra
    dimension. For instance, if we have a (5, 2) array and we want to combine it with
    one of shape (5, 10, 2), we could add an extra axis in the middle, as shown in
    the following code, to obtain a compatible (5, 1, 2) array:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，我们可以自由地重塑数组以添加大小为 1 的轴。在索引时使用 `numpy.newaxis` 常量将引入一个额外的维度。例如，如果我们有一个
    (5, 2) 的数组，并且我们想将它与一个形状为 (5, 10, 2) 的数组结合，我们可以在中间添加一个额外的轴，如下面的代码所示，以获得兼容的 (5,
    1, 2) 数组：
- en: '[PRE32]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This feature can be used, for example, to operate on all possible combinations
    of the two arrays. One of these applications is the *outer product*. If we have
    the following two arrays:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能可以用来操作两个数组的所有可能的组合。其中一个应用是 *外积*。如果我们有以下两个数组：
- en: '[PRE33]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The outer product is a matrix containing the product of all the possible combinations
    (i, j) of the two array elements, as shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 外积是一个矩阵，包含两个数组元素所有可能的组合（i, j）的乘积，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To calculate this using NumPy we will repeat the elements `[a1, a2, a3]` in
    one dimension, the elements `[b1, b2, b3]` in another dimension, and then take
    their product, as shown in the following figure:.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 NumPy 计算这个，我们将在一个维度上重复元素 `[a1, a2, a3]`，在另一个维度上重复元素 `[b1, b2, b3]`，然后取它们的乘积，如下面的图所示：
- en: '![Broadcasting](img/8458OS_02_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![广播](img/8458OS_02_02.jpg)'
- en: 'Our strategy will be to transform the array `a` from shape (3,) to shape (3,
    1), and the array `b` from shape (3,) to shape (1, 3). The two arrays are broadcasted
    in the two dimensions and get multiplied together using the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的战略是将数组 `a` 从形状 (3,) 转换为形状 (3, 1)，将数组 `b` 从形状 (3,) 转换为形状 (1, 3)。两个数组在两个维度上广播，并使用以下代码相乘：
- en: '[PRE35]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This operation is very fast and extremely effective as it avoids Python loops
    and is able to process a high number of elements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作非常快且非常有效，因为它避免了Python循环并能处理大量元素。
- en: Mathematical operations
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学运算
- en: 'NumPy includes the most common mathematical operations available for broadcasting,
    by default, ranging from simple algebra to trigonometry, rounding, and logic.
    For instance, to take the square root of every element in the array we can use
    the `numpy.sqrt` function, as shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy默认包含了广播中最常见的数学运算，从简单的代数到三角学、舍入和逻辑。例如，为了取数组中每个元素的平方根，我们可以使用`numpy.sqrt`函数，如下所示：
- en: '[PRE36]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The comparison operators are extremely useful when trying to filter certain
    elements based on a condition. Imagine that we have an array of random numbers
    in the range [0, 1] and we want to extract the numbers greater than 0.5\. We can
    use the `>` operator on the array; The result will be a boolean array, shown as
    follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符在尝试根据条件过滤某些元素时非常有用。想象一下，我们有一个范围在[0, 1]内的随机数数组，我们想要提取大于0.5的数字。我们可以在数组上使用`>`运算符；结果将是一个布尔数组，如下所示：
- en: '[PRE37]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The resulting boolean array can then be reused as an index to retrieve the
    elements greater than 0.5, as shown in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结果布尔数组然后可以被用作索引来检索大于0.5的元素，如下所示：
- en: '[PRE38]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'NumPy also implements methods such as `ndarray.sum`, which takes the sum of
    all the elements on an axis. If we have an array (5, 3), we can use the `ndarray.sum`
    method, as follows, to add elements on the first axis, the second axis, or over
    all the elements of the array:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还实现了`ndarray.sum`等方法，该方法在轴上对所有元素求和。如果我们有一个形状为(5, 3)的数组，我们可以使用`ndarray.sum`方法，如下所示，来在第一个轴、第二个轴或整个数组上的元素进行求和：
- en: '[PRE39]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that by summing the elements over an axis we eliminate that axis. From
    the previous example, the sum on the axis 0 produces a (3,) array while the sum
    on the axis 1 produces a (5,) array.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过在一个轴上求和元素，我们消除了该轴。从上一个例子中，轴0上的求和产生一个(3,)数组，而轴1上的求和产生一个(5,)数组。
- en: Calculating the Norm
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算范数
- en: 'We can review the basic concepts illustrated in this section by calculating
    the Norm of a set of coordinates. For a two-dimensional vector the norm is defined
    as:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计算一组坐标的范数来回顾本节中阐述的基本概念。对于二维向量，范数被定义为：
- en: '[PRE40]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Given an array of 10 coordinates (x, y) we want to find the Norm of each coordinate.
    We can calculate the norm by taking these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个包含10个坐标(x, y)的数组，我们想要找到每个坐标的范数。我们可以通过以下步骤来计算范数：
- en: 'Square the coordinates: obtaining an array which contains `(x**2, y**2)` elements.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对坐标进行平方：得到一个包含`(x**2, y**2)`元素的数组。
- en: Sum those using `numpy.sum` over the last axis.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`numpy.sum`在最后一个轴上对这些值进行求和。
- en: Take the square root, element-wise, using `numpy.sqrt`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`numpy.sqrt`逐元素取平方根。
- en: 'The final expression can be compressed in a single line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最终表达式可以压缩成一行：
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Rewriting the particle simulator in NumPy
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用NumPy重写粒子模拟器
- en: 'In this section, we will optimize our particle simulator by rewriting some
    parts of it in NumPy. From the profiling we did in [Chapter 1](ch01.html "Chapter 1. Benchmarking
    and Profiling"), *Benchmarking and Profiling*, the slowest part of our program
    is the following loop contained in the `ParticleSimulator.evolve` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过用NumPy重写其部分来优化我们的粒子模拟器。从我们在[第1章](ch01.html "第1章。基准测试和性能分析")中进行的性能分析来看，我们程序中最慢的部分是包含在`ParticleSimulator.evolve`方法中的以下循环：
- en: '[PRE42]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We may notice that the body of the loop acts solely on the current particle.
    If we had an array containing the particle positions and angular speed, we could
    rewrite the loop using a broadcasted operation. In contrast, the loop over the
    time steps depends on the previous step and cannot be treated in a parallel fashion.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会注意到循环的主体仅作用于当前粒子。如果我们有一个包含粒子位置和角速度的数组，我们可以使用广播操作重写循环。相比之下，时间步长上的循环依赖于前一步，不能以并行方式处理。
- en: 'It''s natural then, to store all the array coordinates in an array of shape
    (nparticles, 2) and the angular speed in an array of shape (nparticles,). We''ll
    call those arrays `r_i` and `ang_speed_i` and initialize them using the following
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将所有数组坐标存储在一个形状为(nparticles, 2)的数组中，并将角速度存储在一个形状为(nparticles,)的数组中是很自然的。我们将这些数组称为`r_i`和`ang_speed_i`，并使用以下代码进行初始化：
- en: '[PRE43]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The velocity direction, perpendicular to the vector (x, y), was defined as:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 速度方向，垂直于向量（x, y），被定义为：
- en: '[PRE44]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The Norm can be calculated using the strategy illustrated in the *Calculating
    the Norm* section under the *Getting Started with NumPy* heading. The final expression
    is shown in the following line of code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用在“**NumPy 入门**”标题下的“*计算范数*”部分中说明的策略来计算范数。最终的表达式在以下代码行中显示：
- en: '[PRE45]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the components (-y, x) we need first to swap the x and y columns in `r_i`
    and then multiply the first column by -1, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 (-y, x) 分量，我们首先需要在 `r_i` 中交换 x 和 y 列，然后将第一列乘以 -1，如下所示：
- en: '[PRE46]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To calculate the displacement we need to compute the product of `v_i`, `ang_speed_i`,
    and `timestep`. Since `ang_speed_i` is of shape (nparticles,) it needs a new axis
    in order to operate with `v_i` of shape (nparticles, 2). We will do that using
    `numpy.newaxis` constant as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算位移，我们需要计算 `v_i`、`ang_speed_i` 和 `timestep` 的乘积。由于 `ang_speed_i` 的形状为 (nparticles,)，它需要一个新轴才能与形状为
    (nparticles, 2) 的 `v_i` 操作。我们将使用 `numpy.newaxis` 常量来完成此操作，如下所示：
- en: '[PRE47]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Outside the loop, we have to update the particle instances with the new coordinates
    x and y as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 循环外部，我们需要按照以下方式更新粒子实例的新坐标 x 和 y：
- en: '[PRE48]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To summarize, we will implement a method called `ParticleSimulator.evolve_numpy`
    and benchmark it against the pure Python version, renamed as `ParticleSimulator.evolve_python`.
    The complete `ParticleSimulator.evolve_numpy` method is shown in the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将实现一个名为 `ParticleSimulator.evolve_numpy` 的方法，并将其与重命名为 `ParticleSimulator.evolve_python`
    的纯 Python 版本进行基准测试。完整的 `ParticleSimulator.evolve_numpy` 方法如下所示：
- en: '[PRE49]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also update the benchmark to conveniently change the number of particles
    and the simulation method as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了基准测试，以便方便地更改粒子数量和模拟方法，如下所示：
- en: '[PRE50]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can run the updated benchmark in an IPython session as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 IPython 会话中运行更新后的基准测试，如下所示：
- en: '[PRE51]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We have some improvement but it doesn''t look like a huge speed boost. The
    power of NumPy is revealed when handling big arrays. If we increase the number
    of particles, we will notice a more significant performance boost. We can re-run
    the benchmark with a higher number of particles using the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些改进，但看起来速度提升并不大。NumPy 的强大之处在于处理大型数组。如果我们增加粒子数量，我们会注意到更明显的性能提升。我们可以使用以下代码重新运行具有更多粒子数量的基准测试：
- en: '[PRE52]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The plot in the following figure was produced by running the benchmark with
    different particle numbers:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图中的图表是通过运行具有不同粒子数量的基准测试生成的：
- en: '![Rewriting the particle simulator in NumPy](img/8458OS_02_03.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![用 NumPy 重写粒子模拟器](img/8458OS_02_03.jpg)'
- en: The plot shows that both implementations scale linearly with the particle size,
    but the runtime in the pure Python version (denoted with diamonds) grows much
    faster than the NumPy version (denoted with circles); at greater sizes we have
    a greater NumPy advantage. In general, when using NumPy you should try to pack
    things into large arrays and group the calculations by using the broadcasting
    feature.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示，两种实现都与粒子大小成线性关系，但纯 Python 版本（用菱形表示）的运行时间比 NumPy 版本（用圆圈表示）增长得更快；在更大的尺寸上，NumPy
    的优势更加明显。一般来说，当使用 NumPy 时，应尝试将事物打包到大型数组中，并使用广播功能按组进行计算。
- en: Reaching optimal performance with numexpr
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 numexpr 达到最佳性能
- en: When handling complex expressions, NumPy stores intermediate results in the
    memory. David M. Cooke wrote a package called `numexpr` which optimizes and compiles
    array expressions on-the-fly. It works by optimizing the usage of the CPU cache
    and by taking advantage of multiple processors.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理复杂表达式时，NumPy 会将中间结果存储在内存中。David M. Cooke 编写了一个名为 `numexpr` 的包，该包可以即时优化和编译数组表达式。它通过优化
    CPU 缓存的使用并利用多处理器来实现。
- en: 'Its usage is generally straightforward and is based on a single function—`numexpr.evaluate`.
    The function takes a string containing an array expression as its first argument.
    The syntax is basically identical to that of NumPy. For example, we can calculate
    a simple `a + b * c` expression in the following way:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 其用法通常很简单，基于一个单一的功能——`numexpr.evaluate`。该函数将包含数组表达式的字符串作为其第一个参数。语法基本上与 NumPy
    相同。例如，我们可以以下这种方式计算一个简单的 `a + b * c` 表达式：
- en: '[PRE53]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `numexpr` package increases the performances in almost all cases, but to
    achieve a substantial advantage you should use it with large arrays. An application
    that involves a large array is the calculation of a *distance matrix*. In a particle
    system, a distance matrix contains all the possible distances between the particles.
    To calculate it, we should first calculate all the vectors connecting any two
    particles (i, j) defined as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`numexpr` 包在几乎所有情况下都会提高性能，但要实现实质性的优势，你应该使用它来处理大型数组。一个涉及大型数组的应用是计算 *距离矩阵*。在粒子系统中，距离矩阵包含粒子之间所有可能距离。为了计算它，我们首先应该计算连接任意两个粒子（i，j）的所有向量，如下定义：'
- en: '[PRE54]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we calculate the length of this vector by taking its Norm, as in the
    following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过取其范数来计算这个向量的长度，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can write this in NumPy by employing the usual broadcasting rules (the operation
    is similar to the outer product):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用常规广播规则（操作类似于外积）来用 NumPy 实现这一点：
- en: '[PRE56]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we calculate the Norm over the last axis using the following line
    of code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下代码行在最后一个轴上计算范数：
- en: '[PRE57]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Rewriting the same expression using the `numexpr` syntax is extremely easy.
    The `numexpr` package doesn''t support slicing in its array expression, therefore
    we first need to prepare the operands for broadcasting by adding an extra dimension
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `numexpr` 语法重写相同的表达式非常简单。`numexpr` 包不支持数组表达式的切片，因此我们首先需要通过添加一个额外的维度来准备广播操作符，如下所示：
- en: '[PRE58]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At that point, we should try to pack as many operations as possible in a single
    expression to allow a significant optimization.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该尝试在一个单独的表达式中尽可能多地组合操作，以允许进行显著的优化。
- en: 'Most of the NumPy mathematical functions are also available in `numexpr`; however,
    there is a limitation. The reduction operations—the ones which reduce an axis,
    such as sum—have to happen last. So, we have to first calculate the sum, step
    out of `numexpr`, and calculate the square root in another expression. The `numexpr`
    code for those operations is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 NumPy 数学函数也存在于 `numexpr` 中；然而，有一个限制。减少操作——比如求和——必须放在最后执行。因此，我们必须首先计算总和，然后退出
    `numexpr`，并在另一个表达式中计算平方根。这些操作的 `numexpr` 代码如下：
- en: '[PRE59]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `numexpr` compiler will optimize memory usage by avoiding the storage of
    intermediate results and by taking advantage of multiple processors. In the `distance_matrix.py`
    file you will find two functions that implement the two versions of the distance
    matrix calculation: `distance_matrix_numpy` and `distance_matrix_numexpr`. We
    can import and benchmark them as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`numexpr` 编译器将通过避免存储中间结果并利用多个处理器来优化内存使用。在 `distance_matrix.py` 文件中，你可以找到实现距离矩阵计算两种版本的函数：`distance_matrix_numpy`
    和 `distance_matrix_numexpr`。我们可以这样导入和基准测试它们：'
- en: '[PRE60]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: By simply copying the expressions using `numexpr` we were able to obtain a 4.5x
    increase in performance in a real-world scenario over standard NumPy. The `numexpr`
    package can be used every time you need to optimize a NumPy expression that involves
    large arrays and complex operations, and you can do so with minimal changes in
    the code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地使用 `numexpr` 复制表达式，我们能够在实际场景中获得比标准 NumPy 高出 4.5 倍的性能提升。`numexpr` 包可以在你需要优化涉及大型数组和复杂操作的
    NumPy 表达式时使用，并且你可以通过最小的代码更改来实现这一点。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to manipulate NumPy arrays and how to write
    fast mathematical expressions using array broadcasting. This knowledge will help
    you to design better programs while obtaining massive performance gains. We also
    introduced the `numexpr` library to further increase the speed of our calculations
    with a minimal amount of effort.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何操作 NumPy 数组以及如何使用数组广播编写快速数学表达式。这些知识将帮助你设计更好的程序，同时获得巨大的性能提升。我们还介绍了
    `numexpr` 库，以最小的努力进一步加快我们的计算速度。
- en: NumPy works very well when handling independent sets of inputs, but it's not
    suitable when the expressions grow complex and cannot be split in element-wise
    operations. In such cases, we can leverage Python capabilities as a glue language
    by interfacing it with C using the Cython package.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 在处理独立输入集时工作得非常好，但当表达式变得复杂且无法分割为逐元素操作时，它就不适用了。在这种情况下，我们可以通过使用 Cython 包将
    Python 与 C 进行接口，利用 Python 作为粘合语言的能力。
