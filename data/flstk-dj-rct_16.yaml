- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Performance, Optimization, and Security
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能、优化和安全
- en: In the previous chapters of the book, we have created a full stack application
    from scratch, starting with building and creating a REST API using Django and
    Django REST Framework and then creating a web interface with React to communicate
    with the API we created. We have also deployed applications on services such as
    AWS EC2 and AWS S3\. However, we need to further investigate some important aspects
    of having an application deployed on the internet, such as performance checks,
    query optimization, frontend optimization, and finally, security aspects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们从零开始创建了一个全栈应用程序，首先使用Django和Django REST Framework构建和创建了一个REST API，然后使用React创建了一个与API通信的Web界面。我们还已经在AWS
    EC2和AWS S3等服务上部署了应用程序。然而，我们需要进一步调查在互联网上部署应用程序的一些重要方面，例如性能检查、查询优化、前端优化，以及最终的安全方面。
- en: 'In this chapter, we will learn how to create a performant API with fewer SQL
    queries and faster API responses, how to serve the API and the React frontend
    over HTTPS using AWS CloudFront, and how to log out users using the API. In this
    chapter, we will cover the following points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何通过减少SQL查询和使用更快的API响应来创建一个高性能的API，如何使用AWS CloudFront通过HTTPS提供API和React前端，以及如何使用API登出用户。在本章中，我们将涵盖以下内容：
- en: Revoking JWT tokens
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 撤销JWT令牌
- en: Adding caching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加缓存
- en: Optimizing the deployment of a React application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化React应用程序的部署
- en: Securing deployed applications with HTTPS with AWS CloudFront
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS CloudFront通过HTTPS保护已部署的应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you need to have an active AWS account with access to services
    such as S3, EC2, and CloudFront. You can also find the code for this chapter at:
    [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要有一个活跃的AWS账户，可以访问S3、EC2和CloudFront等服务。你还可以在本章的代码：[https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16)中找到代码。
- en: Revoking JWT tokens
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撤销JWT令牌
- en: In this book, we have implemented an authentication system using **JSON Web
    Tokens** (**JWTs**), and because it is a stateless authentication system, most
    of the authentication flow is handled by the frontend. If we want to log the user
    out of the Postagram React application, we must clear the tokens from the local
    storage of the browser, and the user is automatically redirected to the login
    page. But even if the tokens are deleted from the browser, they are still active.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用**JSON Web Tokens**（JWTs）实现了一个身份验证系统，因为它是一个无状态的身份验证系统，所以大部分的身份验证流程都是由前端处理的。如果我们想从Postagram
    React应用程序中登出用户，我们必须从浏览器的本地存储中清除令牌，用户将自动重定向到登录页面。但是即使令牌从浏览器中删除，它们仍然有效。
- en: The refresh tokens have a longer life period, so if a hacker gets their hands
    on a refresh token, they can still request access tokens and make HTTP requests
    using someone else’s identity. To avoid that, we will add a logout feature to
    invalidate access and refresh tokens from the server side.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新令牌的有效期更长，因此如果黑客获得了刷新令牌，他们仍然可以请求访问令牌并使用他人的身份进行HTTP请求。为了避免这种情况，我们将添加一个登出功能，从服务器端使访问和刷新令牌失效。
- en: The package used to add JWT authentication on the Django REST API (`djangorestframework-simplejwt`)
    supports blacklisting tokens, and that is the perfect feature we need here. Let’s
    set up the required configurations for the logout feature, and let’s add the feature
    to the Django REST API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在Django REST API上添加JWT身份验证的包（`djangorestframework-simplejwt`）支持黑名单令牌，这正是我们需要的完美功能。让我们设置登出功能所需的配置，并将该功能添加到Django
    REST API中。
- en: Adding a logout endpoint
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加登出端点
- en: 'In this section, we will write some code on the Django application to add an
    endpoint for logout:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为Django应用程序编写一些代码以添加一个登出端点：
- en: 'In the `settings.py` file of the project, add the following entry to the `INSTALLED_APPS`
    list:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`settings.py`文件中，将以下条目添加到`INSTALLED_APPS`列表中：
- en: CoreRoot/settings.py
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After that, create a file called `logout.py` in the `core/auth/viewsets` directory.
    This file will contain the code for the `viewsets` and the logic to blacklist
    a token.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`core/auth/viewsets`目录中创建一个名为`logout.py`的文件。此文件将包含`viewsets`的代码以及黑名单令牌的逻辑。
- en: 'In this file, add the required imports and define the `LogoutViewSet` class:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，添加所需的导入并定义`LogoutViewSet`类：
- en: core/auth/viewsets/logout.py
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/viewsets/logout.py
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The logout endpoint will only accept `POST` requests, as the client will be
    required to pass a refresh token within the body of the `POST` request. We also
    specify that only authenticated users have permission to access this endpoint.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注销端点将只接受`POST`请求，因为客户端需要在`POST`请求体中传递刷新令牌。我们还指定只有经过认证的用户才有权访问此端点。
- en: 'Let’s write the `create` method of the `LogoutViewSet` class:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来编写`LogoutViewSet`类的`create`方法：
- en: core/auth/viewsets/logout.py
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/viewsets/logout.py
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we ensure that the refresh token is present in the body
    of the request. Otherwise, we raise an error. Once the verification is done, we
    encapsulate the blacklisting logic in a `try/except` block:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们确保请求体中存在刷新令牌。否则，我们将引发错误。一旦完成验证，我们将黑名单逻辑封装在`try/except`块中：
- en: If the token is valid, then the token is blacklisted, and we return a response
    with a `204 HTTP` status code.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果令牌有效，则将令牌加入黑名单，并返回一个带有`204 HTTP`状态码的响应。
- en: If there is an error related to the token, then the token is invalid, and we
    return a validation error.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在与令牌相关的错误，则令牌无效，我们将返回一个验证错误。
- en: 'Let’s not forget to add the newly created `ViewSet` in the `routers.py` file
    and register a new route:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们别忘了在`routers.py`文件中添加新创建的`ViewSet`并注册一个新的路由：
- en: core/routers.py
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: core/routers.py
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Great! To follow best practices for building software, we must add a test for
    the newly added route in the `core/auth/tests.py` file:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！为了遵循构建软件的最佳实践，我们必须在`core/auth/tests.py`文件中为新增的路由添加一个测试：
- en: core/auth/tests.py
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/tests.py
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we log in to retrieve a refresh token and force the authentication
    for the user so we can access the logout endpoint. After that, we ensure that
    we have returned the right status code when the logout is successful.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们登录以获取刷新令牌并强制用户进行认证，以便我们可以访问注销端点。之后，我们确保在注销成功时返回了正确的状态码。
- en: 'Run the tests using the `pytest` command. If you are using Docker, then you
    can run the tests using this command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pytest`命令运行测试。如果你使用Docker，则可以使用此命令运行测试：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the logout endpoint ready, we can now make some modifications to the authentication
    logic (mostly the logout logic) in the React application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当注销端点准备就绪后，我们现在可以对React应用程序中的认证逻辑（主要是注销逻辑）进行一些修改。
- en: Handling the logout with React
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用React处理注销
- en: 'We have already handled the logout on the React application to a certain extent
    by just deleting the tokens from the local storage. There is nothing big to modify
    here, we will just add a function to make a request to the API, and if this request
    is successful, we will delete the tokens and the user from the local storage of
    the browser. The current logout logic on the React application is handled in the
    `NavigationBar` component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在React应用程序中对注销进行了一定程度的处理，只是从本地存储中删除了令牌。这里没有太多需要修改的，我们只需添加一个函数来向API发起请求，如果这个请求成功，我们将删除令牌和用户从浏览器的本地存储中。React应用程序上当前的注销逻辑在`NavigationBar`组件中处理：
- en: src/components/NavBar.jsx
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/NavBar.jsx
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside the `useActions` Hook function, let’s tweak the `logout` method to make
    an API call before deleting the user:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useActions`钩子函数内部，让我们调整`logout`方法，在删除用户之前发起API调用：
- en: src/hooks/user.actions.js
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: src/hooks/user.actions.js
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once it is done, let’s create a function in the `NavigationBar` component to
    handle the cases when there is an error from the API. We will display a toast
    HTML bloc on the page with the error message:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，让我们在`NavigationBar`组件中创建一个函数来处理API错误的情况。我们将在页面上显示一个带有错误信息的toast HTML块：
- en: src/components/NavBar.jsx
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/NavBar.jsx
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Great! Our full stack application now supports logout. In the next section,
    we will discuss a recurrent topic when deploying a project online, caching.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的全栈应用程序现在支持注销。在下一节中，我们将讨论在线部署项目时的一个常见话题，缓存。
- en: Adding caching
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加缓存
- en: In software computing, caching is the process of storing copies of files in
    a cache so they can be accessed more quickly. A **cache** is a temporary storage
    location that stores data, files, and information concerning software that is
    regularly requested.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件计算中，缓存是将文件的副本存储在缓存中以便更快访问的过程。**缓存**是一个临时存储位置，用于存储数据、文件以及有关经常请求的软件的信息。
- en: 'A great example and explanation of caching comes from Peter Chester, who asked
    the audience at one of his speeches: *“What’s 3,485,250 divided by 23,235?” Everyone
    fell silent for a moment, but someone pulled a calculator and yelled out the answer
    “150!”*. Then, Peter Chester asked the same question again, and this time, everyone
    was able to answer the question immediately.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的优秀示例和解释来自彼得·切斯特，他在一次演讲中向听众提出了一个问题：“3,485,250除以23,235等于多少？”大家沉默了一会儿，但有人拿出计算器喊出了答案“150！”然后，彼得·切斯特再次提出了相同的问题，这一次，大家都能立即回答这个问题。
- en: 'This is a great demo of the concept of caching: *The computation is only done
    once by the machine and then saved in quick memory for* *faster access*.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对缓存概念的一个很好的演示：*计算只由机器执行一次，然后将其保存在快速内存中以* *加快访问速度*。
- en: It is a concept used widely by companies and primarly social media websites
    where millions of users access the same posts, videos, and files. It would be
    very primitive to hit the database whenever millions of people want to access
    the same information. For example, if a tweet is gaining traction on Twitter,
    it is automatically moved to cache storage for quick access. And, if you have
    an influencer such as Kim Kardashian posting a picture on Instagram, you should
    expect a lot of requests for this picture. Thus caching can be useful here to
    avoid thousands of queries on the database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个被公司和主要社交媒体网站广泛使用的一个概念，其中数百万用户访问相同的帖子、视频和文件。每当数百万人都想访问相同的信息时，直接击中数据库将会非常原始。例如，如果一条推文在Twitter上开始流行，它会被自动移动到缓存存储中以便快速访问。而且，如果你有一个像金·卡戴珊这样的影响者将图片发布在Instagram上，你应该预期会有很多对这个图片的请求。因此，缓存在这里可以很有用，以避免对数据库进行数千次查询。
- en: 'To recapitulate, caching brings the following benefits:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，缓存带来的以下好处：
- en: Reduced load time
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少加载时间
- en: Reduced bandwidth usage
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少带宽使用
- en: Reduced SQL queries on databases
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少数据库上的SQL查询
- en: Reduced downtime
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少停机时间
- en: Now that we have an idea about caching and its benefits, we can implement the
    concept using Django and even Docker. But before that, let’s quickly discuss the
    complexity caching brings to your application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对缓存及其好处有了了解，我们可以使用Django甚至Docker来实现这一概念。但在那之前，让我们快速讨论一下缓存给应用程序带来的复杂性。
- en: The cons of caching
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存的缺点
- en: You already know the advantages of using caching, mostly if your application
    is scaling or you want to improve load time and reduce costs. However, caching
    introduces some complexity to your system (it can also depend on the type of application
    you are developing). If your application is based on news or feeds, you might
    be in trouble, as you will need to define a good architecture for caching.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道使用缓存的优点，尤其是如果你的应用程序正在扩展或者你想要提高加载时间并减少成本。然而，缓存会给你的系统带来一些复杂性（它也可能取决于你正在开发的应用程序类型）。如果你的应用程序基于新闻或动态，你可能会遇到麻烦，因为你将需要定义一个良好的缓存架构。
- en: On the one hand, you have the chance to reduce load times by showing your users
    the same content for a period, but at the same time, your users might miss updates
    and maybe some important updates. Here, cache invalidation comes to the rescue.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，你可以通过在一段时间内向用户展示相同的内容来减少加载时间，但与此同时，你的用户可能会错过更新，也许是一些重要的更新。在这里，缓存失效就派上用场了。
- en: 'Cache invalidation is the process of declaring cached content as invalid or
    stale. The content is invalidated, as it is no longer marked as being the most
    up-to-date version of a file. There are some methods available to invalidate a
    cache, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存失效是声明缓存内容无效或过时的过程。内容被失效，因为它不再被标记为文件的最新版本。有一些方法可以用来使缓存失效，如下所示：
- en: '**Purge (flush)**: Cache purging instantly removes the content from the cache.
    When the content is requested again, it is stored in the memory cache before returning
    it to the client.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除（刷新）**：缓存清除会立即从缓存中移除内容。当内容再次被请求时，它会在返回给客户端之前存储在内存缓存中。'
- en: '**Refresh**: A cache refresh consists of refreshing the same content from the
    server and replacing the content stored in the cache with the new version fetched
    from the server. This is done in the React application using **state-while-revalidate**
    (**SWR**). Each time a post is created, we call a refresh function to fetch data
    again from the server.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**刷新**：缓存刷新包括从服务器刷新相同的内容，并用从服务器获取的新版本替换缓存中存储的内容。这是在React应用程序中使用**state-while-revalidate**（**SWR**）完成的。每次创建帖子时，我们都会调用一个刷新函数来再次从服务器获取数据。'
- en: '**Ban**: A cache ban does not remove content from the cache immediately. Rather,
    the content is marked as blacklisted. Then, when the client makes a request, it
    is matched with the blacklist content, and if a match is found, new content is
    fetched again and updated in the memory cache before returning to the client.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁止**：缓存禁止不会立即从缓存中删除内容。相反，内容会被标记为黑名单。然后，当客户端发起请求时，它会与黑名单内容进行匹配，如果找到匹配项，则会再次获取新内容并在内存缓存中更新，然后再返回给客户端。'
- en: With the cons of caching and how to invalidate the cache understood, you are
    well equipped to add caching to the Django application. In the next section, let’s
    add caching to the Django API of Postagram.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了缓存的缺点以及如何使缓存失效之后，你已经为将缓存添加到Django应用程序做好了充分的准备。在下一节中，让我们将缓存添加到Postagram的Django
    API中。
- en: Adding caching to the Django API
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将缓存添加到Django API
- en: In the previous paragraphs, we have explored caching, its advantages, and the
    cons of the concept. Now, it’s time to implement caching within our Django application.
    Django provides useful support for caching, which makes the configuration of caching
    within Django straightforward. Let’s start by making the required configurations
    depending on your environment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段落中，我们已经探讨了缓存、其优点以及该概念的缺点。现在，是时候在我们的Django应用程序中实现缓存了。Django为缓存提供了有用的支持，使得在Django中配置缓存变得简单直接。让我们根据你的环境开始进行必要的配置。
- en: Configuring Django for caching
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Django以进行缓存
- en: Using caching within Django requires configuring a memory cache. For the quickest
    read and write access, it is better to use a different data storage solution from
    SQL databases as SQL databases are known to be slower than memory databases (again,
    it depends on your needs). In this book, we will use Redis. Redis is an open source,
    in-memory data store used as a database, cache, streaming engine, and message
    broker.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中使用缓存需要配置一个内存缓存。为了实现最快的读写访问，最好使用不同于SQL数据库的数据存储解决方案，因为众所周知，SQL数据库比内存数据库慢（当然，这也取决于你的需求）。在这本书中，我们将使用Redis。Redis是一个开源的内存数据存储，用作数据库、缓存、流引擎和消息代理。
- en: We’ll review the configurations you need to make to start using Redis in your
    Django project, whether you are using Docker or not. However, for the deployment,
    we’ll use Docker for configuring Redis.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾你需要进行的配置，以便在你的Django项目中开始使用Redis，无论你是否使用Docker。然而，对于部署，我们将使用Docker来配置Redis。
- en: 'So, if you are not going to use Docker, you can install Redis using the following
    link: [https://redis.io/download/](https://redis.io/download/).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你不打算使用Docker，你可以通过以下链接安装Redis：[https://redis.io/download/](https://redis.io/download/)。
- en: Important note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you are working in a Linux environment, you can check whether the service
    is running using the `sudo service redis-server status` command. If the service
    is not active, use the `sudo service redis-server start` command to start the
    Redis server. If you are using Windows, you will need to install or enable WSL2\.
    You can read more at: [https://redis.io/docs/getting-started/installation/install-redis-on-windows/](https://redis.io/docs/getting-started/installation/install-redis-on-windows/).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个Linux环境中工作，你可以使用`sudo service redis-server status`命令来检查服务是否正在运行。如果服务未激活，请使用`sudo
    service redis-server start`命令来启动Redis服务器。如果你使用Windows，你需要安装或启用WSL2。你可以在此处了解更多信息：[https://redis.io/docs/getting-started/installation/install-redis-on-windows/](https://redis.io/docs/getting-started/installation/install-redis-on-windows/)。
- en: 'After the installation on your machine, you can configure caching in Django
    using the `CACHES` setting in the `settings.py` file of the Django project:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的机器上安装完成后，你可以通过Django项目的`settings.py`文件中的`CACHES`设置来配置缓存：
- en: CoreRoot/settings.py
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This configuration will require the installation of a Python package called
    `django-redis`. Install it by running the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将需要安装一个名为`django-redis`的Python包。通过运行以下命令来安装它：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you are working with Docker, you just need to add the following configurations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Docker，你只需要添加以下配置：
- en: 'Add the `django-redis` package to the `requirements.txt` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`django-redis`包添加到`requirements.txt`文件中：
- en: requirements.txt
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: requirements.txt
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `docker-compose.yaml` configuration. We will add a new image in the
    Docker configuration to make sure that the Django application requires `redis-server`
    to be ready before the API service starts running:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`docker-compose.yaml`配置。我们将在Docker配置中添加一个新的镜像，以确保Django应用程序在API服务开始运行之前需要`redis-server`已准备好：
- en: docker-compose.yaml
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose.yaml
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Great! Add the following custom backend in the `settings.py` file of the Django
    project:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！在Django项目的`settings.py`文件中添加以下自定义后端：
- en: CoreRoot/settings.py
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You will notice here that we are using `redis` as the host instead of `127.0.0.1`.
    This is because, with Docker, you can use the name of the service as a host. This
    is a better solution; otherwise, you will have to configure a static IP address
    for the services.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这里我们使用`redis`作为主机而不是`127.0.0.1`。这是因为，在使用Docker时，您可以使用服务名称作为主机。这是一个更好的解决方案；否则，您将不得不为服务配置静态IP地址。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you want to learn more about assigning a static IP address to your containers
    with Docker, you can read the following resource: [https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/](https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解如何使用Docker为容器分配静态IP地址的更多信息，您可以阅读以下资源：[https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/](https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/)。
- en: Great! Now that we have configured Django for caching, let’s build the caching
    system for the Postagram application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经为Django配置了缓存，让我们为Postagram应用程序构建缓存系统。
- en: Using caching on the endpoints
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在端点上使用缓存
- en: 'Caching depends a lot on the business requirements for how much time you want
    to cache the data. Well, Django provides many levels for caching:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存很大程度上取决于您希望缓存数据多长时间的业务需求。嗯，Django提供了许多缓存级别：
- en: '**Per-site cache**: This enables you to cache your entire website.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按站点缓存**：这使您能够缓存整个网站。'
- en: '**Template fragment cache**: This enables you to cache some components of the
    website. For example, you can decide to only cache the footer.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板片段缓存**：这使您能够缓存网站的一些组件。例如，您可以决定只缓存页脚。'
- en: '**Per-view cache**: This enables you to cache the output of individual views.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按视图缓存**：这使您能够缓存单个视图的输出。'
- en: '**Low-level cache**: Django provides an API you can use for interacting directly
    with the cache. It is useful if you want to produce a certain behavior based on
    a set of actions. For example, in this book, if a post is updated or deleted,
    we will update the cache.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级缓存**：Django提供了一个API，您可以使用它直接与缓存进行交互。如果您想根据一系列操作产生某种行为，这很有用。例如，在这本书中，如果帖子被更新或删除，我们将更新缓存。'
- en: Now that we have a better idea about the levels of caching Django provides,
    let’s define the caching requirements for the Postagram API.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Django提供的缓存级别有了更好的了解，让我们为Postagram API定义缓存需求。
- en: Our requirement is if there is a delete or an update on a comment or a post,
    the cache is updated. Otherwise, we return the same information in the cache to
    the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的要求是，如果对评论或帖子进行了删除或更新，缓存将被更新。否则，我们将返回缓存中的相同信息给用户。
- en: This can be achieved in many ways. We can use Django signals or directly add
    custom methods to the manager of the model’s `Post` and `Comment` classes. Let’s
    go with the latter. We will surcharge the `save` and `delete` methods of the `AbstractModel`
    class, so if there is an update on a `Post` or `Comment` object, we update the
    cache.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过多种方式实现。我们可以使用Django信号或直接向`Post`和`Comment`类的管理器添加自定义方法。让我们选择后者。我们将覆盖`AbstractModel`类的`save`和`delete`方法，这样如果`Post`或`Comment`对象有更新，我们将更新缓存。
- en: 'Inside the `core/abstract/models.py` file, add the following method on top
    of the file after the imports:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core/abstract/models.py`文件中，在导入之后在文件顶部添加以下方法：
- en: core/abstract/models.py
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: core/abstract/models.py
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The function in the preceding code takes an application label, and according
    to the value of this `app_label`, we invalidate the corresponding cache. For the
    moment, we only support caching for posts and comments. Notice how the name of
    the function is prefixed with a `_`. It is a coding convention to specify that
    this method is private and should not be used outside the file where it is declared.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的函数接受一个应用程序标签，并根据此`app_label`的值，我们使相应的缓存失效。目前，我们只支持对帖子或评论进行缓存。注意函数名称前有一个下划线`_`。这是一个编码约定，表示此方法为私有，不应在声明它的文件外部使用。
- en: 'Inside the `AbstractModel` class, we can surcharge the `save` method. Before
    the `save` method is executed, we invalidate the cache. It means that on operations
    such as `create` and `update`, the cache will be reset:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AbstractModel`类中，我们可以覆盖`save`方法。在`save`方法执行之前，我们将使缓存失效。这意味着在`create`和`update`等操作中，缓存将被重置：
- en: core/abstract/models.py
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: core/abstract/models.py
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we retrieve `app_label` from the `_meta` attribute on
    the model. If it corresponds to either `core_post` or `core_comment`, we invalidate
    the cache, and the rest of the instructions can proceed. Let’s do the same for
    the `delete` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从模型的`_meta`属性中检索`app_label`。如果它对应于`core_post`或`core_comment`，则失效缓存，其余指令可以继续。让我们为`delete`方法做同样的事情：
- en: Core/abstract/models.py
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Core/abstract/models.py
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great. The cache invalidation logic has been implemented on the models. Let’s
    add the logic for cache data retrieving on the viewsets of the `core_post` application
    and the `core_comment` application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。模型上的缓存失效逻辑已经实现。让我们为`core_post`应用程序和`core_comment`应用程序的视图集添加缓存数据检索的逻辑。
- en: Retrieving data from the cache
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从缓存中检索数据
- en: The cache invalidation is ready, so we can freely retrieve data from the cache
    on the endpoints for the posts and the comments. Let’s start with `PostViewSet`
    as the portion of code that will be written on `PostViewSet` and `CommentViewSet`
    will be the same. As a small exercise, you can write the logic for retrieving
    the cache for the comments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存失效已经就绪，因此我们可以自由地从帖子端点和评论端点的缓存中检索数据。让我们从`PostViewSet`的部分代码开始写起，而`CommentViewSet`的代码将是相同的。作为一个小练习，您可以编写检索评论缓存的逻辑。
- en: 'Inside the `PostViewSet` class, we will rewrite the `list()` method. On the
    **Django REST framework** (**DRF**) open source repository, the code looks like
    this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PostViewSet`类内部，我们将重写`list()`方法。在**Django REST framework**（**DRF**）开源仓库中，代码看起来是这样的：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, a `queryset` call is made to retrieve the data, and
    then this `queryset` call is paginated, serialized, and returned inside a `Response`
    object. Let’s tweak the method a little bit:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，调用`queryset`以检索数据，然后对这个`queryset`调用进行分页、序列化，并在`Response`对象中返回。让我们稍微调整一下这个方法：
- en: core/post/viewsets.py
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/viewsets.py
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, instead of doing a lookup on the database directly, we
    check the cache. If `post_objects` is `None` when making a query to the database,
    save `queryset` in the cache and finally proceed to return the cache objects to
    the user.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们不是直接在数据库上查找，而是检查缓存。如果对数据库的查询中`post_objects`为`None`，则在缓存中保存`queryset`，并最终返回给用户缓存对象。
- en: 'As you can see, the process is very simple. You just need to have a robust
    caching strategy. You can do the same for `CommentViewSet` as an exercise. You
    can check the code at this link to compare your results: [https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py](https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个过程非常简单。您只需要有一个健壮的缓存策略。您可以作为一个练习对`CommentViewSet`做同样的事情。您可以通过这个链接检查代码以比较您的结果：[https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py](https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py).
- en: In this section, we have explored the benefits of caching, and we have implemented
    caching in the Django application. In the next section, we will see how to optimize
    the React build using tools such as `webpack`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了缓存的优点，并在 Django 应用程序中实现了缓存。在下一节中，我们将看到如何使用如`webpack`等工具优化 React 构建。
- en: Optimizing the React application build
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 React 应用程序构建
- en: In the previous chapter, we successfully built the React application and made
    the deployment on AWS S3\. However, we could have done better in terms of optimization
    and performance. In this section, we will use the famous webpack module builder
    to optimize the React build of Postagram.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们成功构建了 React 应用程序并在 AWS S3 上进行了部署。然而，在优化和性能方面，我们本可以做得更好。在本节中，我们将使用著名的
    webpack 模块构建器来优化 Postagram 的 React 构建。
- en: 'There are a lot of advantages of using webpack in React:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中使用 webpack 有很多优点：
- en: '**It speeds up development and build times**: Using webpack in development
    enhances the speed of fast reload of React.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它加快了开发和构建时间**：在开发中使用 webpack 可以提高 React 快速重新加载的速度。'
- en: '**It provides minification**: Webpack automatically minimizes the code without
    changing the functionalities. This results in a faster load on the browser side.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它提供了代码压缩**：Webpack 自动最小化代码而不改变其功能。这导致浏览器端的加载速度更快。'
- en: '**Code splitting**: Webpack converts JavaScript files into modules.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码分割**：Webpack 将 JavaScript 文件转换为模块。'
- en: '**It eliminates dead assets**: Webpack only builds the images and CSS that
    your code uses and needs.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它消除了无效资产**：Webpack 只构建您的代码使用和需要的图片和 CSS。'
- en: Let’s start by integrating webpack into the project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将 webpack 集成到项目中开始。
- en: Integrating webpack
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成 webpack
- en: 'Follow these steps to integrate webpack into your project:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将 webpack 集成到你的项目中：
- en: 'Inside the React project, run the following command to add the `webpack` and
    `webpack-cli` packages:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 React 项目内部，运行以下命令以添加 `webpack` 和 `webpack-cli` 包：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the installation is done, modify the `package.json` scripts:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，修改 `package.json` 脚本：
- en: package.json
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Also, we need to install Babel, which is a JavaScript compiler that converts
    next-generation JavaScript code into browser-compatible JavaScript.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要安装 Babel，这是一个 JavaScript 编译器，它将下一代 JavaScript 代码转换为浏览器兼容的 JavaScript。
- en: 'In the React project, Babel will convert the React components, the ES6 variables,
    and JSX code to regular JavaScript so old browsers can render the components correctly:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 React 项目中，Babel 将将 React 组件、ES6 变量和 JSX 代码转换为常规 JavaScript，以便旧浏览器可以正确渲染组件：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`babel-loader` is the webpack loader for Babel, `babel/preset-env` compiles
    with JavaScript to ES5, and `babel/preset-react` is for compiling JSX to JS.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`babel-loader` 是 Babel 的 webpack 加载器，`babel/preset-env` 将 JavaScript 编译为 ES5，而
    `babel/preset-react` 用于将 JSX 编译为 JS。'
- en: 'Then create a new file called `.babelrc`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个名为 `.babelrc` 的新文件：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then create a new file called `webpack.config.js`. This file will contain the
    configurations for webpack. Before writing the configuration, add some plugins
    for optimizing HTML, CSS, and copy files:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个名为 `webpack.config.js` 的新文件。此文件将包含 webpack 的配置。在编写配置之前，添加一些用于优化 HTML、CSS
    和复制文件的插件：
- en: '[PRE26]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And then add the following configuration on `webpack.config.js`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在 `webpack.config.js` 上添加以下配置：
- en: webpack.config.js
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: webpack.config.js
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code above tells webpack to send all files in `.js` and `.jsx`
    through `babel-loader`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码告诉 webpack 将所有 `.js` 和 `.jsx` 文件通过 `babel-loader` 传递。
- en: 'Let’s add another configuration called `resolve` to generate all the possible
    paths to the module. For example, webpack would then proceed to look up each of
    those paths until it finds a file:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个名为 `resolve` 的配置，以生成所有可能的模块路径。例如，webpack 将继续查找这些路径，直到找到文件：
- en: webpack.config.js
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: webpack.config.js
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s add the configuration for the plugins we will use in this project:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加我们将在这个项目中使用的插件的配置：
- en: webpack.config.js
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: webpack.config.js
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we have added plugin configurations for the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为以下插件添加了配置：
- en: '`html-loader`: This will send the HTML files through `html-loader`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html-loader`：这将通过 `html-loader` 传递 HTML 文件'
- en: '`copy`: This will copy the content of the public file to the `dist` file'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy`：这将把公共文件的内容复制到 `dist` 文件中'
- en: '`define`: This plugin declares the `process` object so we can access environment
    variables in the production environment'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`define`：此插件声明 `process` 对象，这样我们就可以在生产环境中访问环境变量'
- en: 'Once it is done, run the `build` command:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `build` 命令：
- en: '[PRE30]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Webpack will take control and build the React application in the `dist` directory:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 将接管并在 `dist` 目录中构建 React 应用程序：
- en: '![Figure 16.1 – The content of the dist directory](img/Figure_16.01_B18221.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1 – dist 目录的内容](img/Figure_16.01_B18221.jpg)'
- en: Figure 16.1 – The content of the dist directory
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – dist 目录的内容
- en: Great! You can push the changes made to GitHub, and the code will be deployed
    on AWS S3\. To make the testing and build faster, we will change the package manager
    from `yarn` to `pnpm`. The next section is optional, but it will help you with
    a faster build for your React application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你可以将所做的更改推送到 GitHub，代码将在 AWS S3 上部署。为了使测试和构建更快，我们将包管理器从 `yarn` 更改为 `pnpm`。下一节是可选的，但它将帮助你为你的
    React 应用程序实现更快的构建。
- en: Using pnpm
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pnpm
- en: '`pnpm` is a replacement for the `npm` JavaScript package manager, which is
    built on top of `npm`, and is much faster and more efficient. It provides advantages
    such as disk space efficiency, improved speed, and better security. The `pnpm`
    package manager is the one to use if you want to spend less time building and
    making cuts to the minutes spent on the GitHub Actions.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`pnpm` 是 `npm` JavaScript 包管理器的替代品，它建立在 `npm` 之上，并且更快、更高效。它提供了诸如磁盘空间效率、改进的速度和更好的安全性等优势。如果你想要在构建和
    GitHub Actions 上节省时间，`pnpm` 包管理器是你要使用的。'
- en: 'Let’s install `pnpm` on our machine:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的机器上安装 `pnpm`：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After that, we can generate a `pnpm-lock.yaml` file. We can generate this file
    from another manager’s lock file, in our case, from the `yarn.lock` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以生成一个 `pnpm-lock.yaml` 文件。我们可以从另一个管理器的锁文件中生成此文件，在我们的例子中，是从 `yarn.lock`
    文件中：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Figure 16.2 – Result of pnpm import](img/Figure_16.02_B18221.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.2 – pnpm 导入的结果](img/Figure_16.02_B18221.jpg)'
- en: Figure 16.2 – Result of pnpm import
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 – pnpm 导入的结果
- en: 'A new file will be generated in the directory of the React project. Then, modify
    the `deploy-frontend.yml` file to configure for `pnpm` usage:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 项目的目录中会生成一个新文件。然后，修改 `deploy-frontend.yml` 文件以配置 `pnpm` 的使用：
- en: .github/workflows/deploy-frontend.yml
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: .github/workflows/deploy-frontend.yml
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After that, just replace `yarn` with `pnpm` in the `deploy-frontend.yml` file.
    You will notice a faster build for the React application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，只需在 `deploy-frontend.yml` 文件中将 `yarn` 替换为 `pnpm`。您将注意到 React 应用程序的构建速度更快。
- en: In this section, we have covered pnpm and webpack and how they can boost the
    performance of the React application. In the next section, we will learn how to
    secure HTTP requests using AWS CloudFront.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 pnpm 和 webpack 以及它们如何提高 React 应用程序的性能。在下一节中，我们将学习如何使用 AWS CloudFront
    保护 HTTP 请求。
- en: Securing deployed applications with HTTPS with AWS CloudFront
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWS CloudFront 通过 HTTPS 保护已部署的应用程序
- en: 'When we have deployed the backend and the frontend on AWS S3, the applications
    are served through HTTP. Basically, our full stack application is not secured
    on the internet, and we are vulnerable. According to the **Open Web Application
    Security Project** (**OSWAP**) description of Insecure Transport ([https://owasp.org/www-community/vulnerabilities/Insecure_Transport](https://owasp.org/www-community/vulnerabilities/Insecure_Transport)),
    our application is vulnerable to the following attacks:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 AWS S3 上部署了后端和前端后，应用程序通过 HTTP 提供服务。基本上，我们的全栈应用程序在互联网上没有安全措施，我们容易受到攻击。根据
    **Open Web 应用安全项目**（**OWASP**）对不安全传输的描述（[https://owasp.org/www-community/vulnerabilities/Insecure_Transport](https://owasp.org/www-community/vulnerabilities/Insecure_Transport)），我们的应用程序容易受到以下攻击：
- en: Attacks targeting login credentials, session IDs, and other sensitive information
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对登录凭证、会话 ID 和其他敏感信息的攻击
- en: Bypassing **Secure Sockets Layer** (**SSL**) protocol by entering HTTP instead
    of HTTPS at the beginning of the URL in the browser
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在浏览器中 URL 的开头输入 HTTP 而不是 HTTPS 来绕过 **安全套接字层**（**SSL**）协议
- en: Sending non-protected URLs of authentication pages to users to trick them into
    authenticating via HTTP
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户发送未经保护的认证页面 URL，诱使他们通过 HTTP 进行认证
- en: AWS EC2 and AWS S3 don’t serve content through HTTPS by default. But AWS also
    has a service called CloudFront that can help you serve your applications via
    HTTPS, plus it also makes the content available globally.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: AWS EC2 和 AWS S3 默认不通过 HTTPS 提供内容。但 AWS 还有一个名为 CloudFront 的服务，可以帮助您通过 HTTPS
    提供应用程序，同时它还使内容在全球范围内可用。
- en: '**AWS CloudFront** is a content delivery network service, and in the next section,
    we will configure the AWS S3 bucket hosting the React application with AWS Cloudfront.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS CloudFront** 是一个内容分发网络服务，在下一节中，我们将配置 AWS S3 存储桶以使用 AWS CloudFront。'
- en: Configuring the React project with CloudFront
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 React 项目以使用 CloudFront
- en: 'Follow these steps to configure our React project with CloudFront:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置我们的 React 项目以使用 CloudFront：
- en: On the AWS dashboard, select the **CloudFront** service in the AWS console and
    click on **Create Distribution**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中，选择 AWS 控制面板中的 **CloudFront** 服务并点击 **创建分发**。
- en: 'Copy the origin of your website hosted on AWS and paste it into the **Origin
    domain** name field:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将托管在 AWS 上的网站的原点复制并粘贴到 **原点域名** 字段中：
- en: '![Figure 16.3 – Origin configuration of the CloudFront distribution](img/Figure_16.03_B18221.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.3 – CloudFront 分发的原始配置](img/Figure_16.03_B18221.jpg)'
- en: Figure 16.3 – Origin configuration of the CloudFront distribution
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – CloudFront 分发的原始配置
- en: 'Next, configure the default cache behaviors:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，配置默认的缓存行为：
- en: '![Figure 16.4 – Viewer configuration of the CloudFront distribution](img/Figure_16.04_B18221.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.4 – CloudFront 分发的查看器配置](img/Figure_16.04_B18221.jpg)'
- en: Figure 16.4 – Viewer configuration of the CloudFront distribution
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 – CloudFront 分发的查看器配置
- en: 'Once the cache configuration is done, create the distribution. AWS will take
    some time to create the distribution and once it is done, click on the distribution
    **ID** field to copy the URL:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成缓存配置，创建分发。AWS 将花费一些时间来创建分发，一旦完成，点击分发 **ID** 字段以复制 URL：
- en: '![Figure 16.5 – List of the CloudFront distribution](img/Figure_16.05_B18221.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.5 – CloudFront 分发的列表](img/Figure_16.05_B18221.jpg)'
- en: Figure 16.5 – List of the CloudFront distribution
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – CloudFront 分发的列表
- en: 'Once **Status** changes to **Enabled**, click on the distribution **ID** field
    to access more details about the distribution and copy the distribution domain
    name:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦**状态**变为**启用**，点击**分布ID**字段以访问有关分布的更多详细信息并复制分布域名：
- en: "![Figure 16.6\uFEFF – Details about the created CloudFront distribution](img/Figure_16.06_B18221.jpg)"
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6 – 关于创建的CloudFront分布的详细信息](img/Figure_16.06_B18221.jpg)'
- en: Figure 16.6 – Details about the created CloudFront distribution
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 – 关于创建的CloudFront分布的详细信息
- en: The CloudFront distribution URL will return the React application over HTTPS.
    Great, the React application is secured on the internet and well distributed worldwide.
    Great! We have successfully secured our application over HTTPS using AWS CloudFront.
    From now, you can build a full stack application with Django and React, assure
    code quality with tests and linting, automate **continuous integration** and **continuous
    delivery** (**CI/CD**) pipelines using GitHub Actions and use AWS services such
    as S3, EC2, and CloudFront to deploy and serve your web application around the
    world.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFront分布的URL将返回通过HTTPS的React应用程序。太好了，React应用程序在互联网上得到了保护，并且在全球范围内得到了良好的分发。太棒了！我们已经成功使用AWS
    CloudFront在HTTPS上保护了我们的应用程序。从现在起，你可以使用Django和React构建全栈应用程序，通过测试和linting确保代码质量，使用GitHub
    Actions自动化**持续集成**和**持续交付**（**CI/CD**）管道，并使用AWS服务如S3、EC2和CloudFront在全球范围内部署和托管你的Web应用程序。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered some important points about optimizations and
    security. We have implemented a logout endpoint to blacklist tokens, added caching
    to the Django application using Redis, optimized the backend build using webpack,
    and secured the full stack application over HTTPS using AWS CloudFront. And that’s
    the final touch of this book.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些关于优化和安全的要点。我们实现了一个登出端点来黑名单令牌，使用Redis添加了Django应用程序的缓存，优化了使用webpack的后端构建，并使用AWS
    CloudFront通过HTTPS保护了全栈应用程序。这就是这本书的最后一笔。
- en: We have covered how to build a powerful and robust full stack application using
    Django and React. We have covered how to create a project from scratch, build
    an API secured with JWT tokens, build a frontend application with React and Bootstrap,
    and deploy the applications on AWS. We have explored Docker and tools such as
    GitHub Actions to make the development and deployment process secure, faster,
    and automated. You can now build and deploy a full stack application using Django
    and React!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何使用Django和React构建一个强大且健壮的全栈应用程序。我们已经介绍了如何从头开始创建项目，构建使用JWT令牌进行安全保护的API，使用React和Bootstrap构建前端应用程序，并在AWS上部署应用程序。我们已经探讨了Docker和GitHub
    Actions等工具，以使开发和部署过程更加安全、快速和自动化。现在，你可以使用Django和React构建和部署全栈应用程序了！
- en: We are now at the end of this book, and if you are looking for best practices
    and what to learn next, feel free to go through the *Appendix* directly after
    this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在到了这本书的结尾，如果你在寻找最佳实践和下一步要学习的内容，请随意直接在本章之后查看*附录*。
- en: Questions
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is AWS CloudFront?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是AWS CloudFront？
- en: What are the cache invalidation strategies?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存失效策略有哪些？
- en: Why is logging important?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么日志记录很重要？
- en: Appendix
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Every successful application will eventually need to scale, and this process
    can cause resource issues and more optimization problems. In this appendix, I
    will list what you can read to deepen your studies after this book so you can
    become a better full stack developer.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个成功的应用程序最终都需要进行扩展，这个过程可能会引起资源问题和更多的优化问题。在这个附录中，我将列出你在阅读完这本书之后可以阅读的内容，以便你成为一个更好的全栈开发者。
- en: Logging
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: Logging is the action of collecting information about an application as it performs
    different tasks or events. In the development process of an application, if you
    have a bug, you can use `print()` or `console.log()` to identify the issues. Even
    better, with `DEBUG` as `true` in Django, you have access to the whole traceback
    of a `500` error. Once your project deployed in production, this is no longer
    the case. You can implement logging in files using the default logging package
    provided by Python; Django has full support that you can explore in the official
    documentation at [https://docs.djangoproject.com/en/4.1/topics/logging/](https://docs.djangoproject.com/en/4.1/topics/logging/).
    If you are looking to get real-time notifications when you have a `500` error,
    you can connect your backend to services such as Sentry, Datadog, or Bugsnag.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是在应用程序执行不同任务或事件时收集有关应用程序信息的行为。在应用程序的开发过程中，如果您遇到错误，可以使用`print()`或`console.log()`来识别问题。更好的是，当Django中的`DEBUG`设置为`true`时，您可以访问`500`错误的整个跟踪信息。一旦您的项目部署到生产环境，这种情况就不再适用了。您可以使用Python提供的默认日志包在文件中实现日志记录；Django提供了全面的支持，您可以在官方文档中探索，链接为[https://docs.djangoproject.com/en/4.1/topics/logging/](https://docs.djangoproject.com/en/4.1/topics/logging/)。如果您希望在出现`500`错误时获得实时通知，可以将您的后端连接到Sentry、Datadog或Bugsnag等服务。
- en: Database queries optimization
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库查询优化
- en: The Django ORM is a very flexible and powerful tool, and it can be used well
    or badly. Databases are important in your full stack applications and the fewer
    queries you make, the better it is for the high availability of the SQL database.
    Django provides many methods you can study and explore if you need to optimize
    database queries. You can read more at [https://docs.djangoproject.com/en/4.1/topics/db/optimization/](https://docs.djangoproject.com/en/4.1/topics/db/optimization/).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Django ORM是一个非常灵活且强大的工具，它可以被很好地使用，也可以被糟糕地使用。数据库在您的全栈应用程序中非常重要，您执行的查询越少，对SQL数据库的高可用性就越好。Django提供了许多您可以学习和探索的方法，如果您需要优化数据库查询。您可以在[https://docs.djangoproject.com/en/4.1/topics/db/optimization/](https://docs.djangoproject.com/en/4.1/topics/db/optimization/)中了解更多。
- en: Security
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: 'If you are deploying a web application on the internet, it’s important to ensure
    that you have a secure application. In the beginning, you don’t really need a
    lot, but you do need to ensure that your system is secured against the top 10
    threats listed by OWASP. You can learn more about this at the following link:
    [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要将Web应用程序部署到互联网上，确保您有一个安全的应用程序非常重要。一开始，您可能不需要很多，但您确实需要确保您的系统能够抵御OWASP列出的前10大威胁。您可以在以下链接中了解更多信息：[https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)。
- en: Answers
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Chapter 1
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章
- en: A **Representational State Transfer** (**REST**) API is a web architecture and
    a set of constraints that provide simple interfaces to interact with resources,
    allowing clients to retrieve or manipulate them using standard HTTP requests.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表示状态转移**（**REST**）API是一种Web架构和一组约束，它提供简单的接口来与资源交互，允许客户端使用标准的HTTP请求检索或操作它们。'
- en: Django is a Python web framework that enables the fast development of secure
    and maintainable websites. It follows the **Model-View-Controller** (**MVC**)
    architectural pattern and emphasizes reusability and pluggability.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django是一个Python Web框架，它能够快速开发安全且易于维护的网站。它遵循**模型-视图-控制器**（**MVC**）的架构模式，并强调可重用性和可插拔性。
- en: 'To create a Django project, you need to have Django installed on your OS. Once
    you have it installed, you can use the following command to create a new Django
    project:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个Django项目，您需要在您的操作系统上安装Django。一旦安装完成，您可以使用以下命令创建一个新的Django项目：
- en: '**django-admin startproject DjangoProject**'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**django-admin startproject DjangoProject**'
- en: The preceding command will create a Django project with the name `DjangoProject`
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个名为`DjangoProject`的Django项目
- en: Migrations are Django’s way of synchronizing changes you make to your models
    (adding a field, deleting a model, etc.) into your database.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移是Django将您对模型所做的更改（添加字段、删除模型等）同步到数据库中的方式。
- en: A virtual environment in Python is a tool to keep the dependencies required
    by different projects in separate places by creating isolated python virtual environments
    for them. This is useful in case of different projects and when you want to avoid
    conflicting dependencies.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python中的虚拟环境是一个工具，通过为不同的项目创建隔离的Python虚拟环境来将它们所需的依赖项保存在不同的位置。这在处理不同项目时非常有用，并且当您想要避免冲突的依赖项时也很有用。
- en: Chapter 2
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章
- en: '**JSON Web Token** (**JWT**) is a JSON object meant of representing claims
    to be transferred between two parties. JWT is often used to authenticate users
    in REST APIs.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**JSON Web Token**（**JWT**）是一个用于在双方之间表示声明的JSON对象。JWT常用于在REST API中验证用户。'
- en: '**Django Rest Framework** (**DRF**) is a third-party package for Django that
    makes it easy to build, test, debug, and maintain RESTful APIs written using the
    Django framework.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Django Rest Framework**（**DRF**）是Django的一个第三方包，它使得使用Django框架编写RESTful API变得简单，包括构建、测试、调试和维护。'
- en: A Django model is a Python class that represents a database table, and it defines
    the fields and behaviors of the data you’re storing.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django模型是一个Python类，它代表一个数据库表，并定义了存储数据的字段和行为。
- en: Serializers in DRF are used to convert complex data types, such as Django model
    instances or QuerySets, into JSON, XML, or other content types. Serializers also
    provide deserialization, which allows parsed data to be converted back into complex
    types.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DRF中的序列化器用于将复杂的数据类型，如Django模型实例或QuerySets，转换为JSON、XML或其他内容类型。序列化器还提供反序列化，允许解析的数据被转换回复杂类型。
- en: Viewsets in DRF are classes that provide actions on model-backed resources.
    Viewsets are built on top of Django’s class-based views and provide actions like
    `list`, `create`, `update`, and `delete`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DRF中的Viewsets是提供对基于模型资源操作的类。Viewsets建立在Django的基于类的视图之上，并提供如`list`、`create`、`update`和`delete`等操作。
- en: DRF routers provide a simple, quick, and consistent way of wiring viewsets to
    URLs. It allows you to automatically generate the URL conf for your API views.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DRF路由器提供了一种简单、快速且一致的方法来将视图集连接到URL。它允许你自动生成API视图的URL配置。
- en: A refresh token is a token that is issued by an authentication server and is
    used to obtain a new access token. Refresh tokens are used to keep the user authenticated
    indefinitely, by periodically obtaining a new access token.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新令牌是由认证服务器签发的令牌，用于获取新的访问令牌。刷新令牌通过定期获取新的访问令牌来保持用户无限期地认证。
- en: Chapter 3
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章
- en: 'Some common database relationships in relational databases are:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关系型数据库中一些常见的数据库关系包括：
- en: '**One-to-one**: This relationship is used when one record in a table is related
    to only one record in another table.'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**：当表中的一条记录只与另一表中的一条记录相关联时，使用这种关系。'
- en: '**One-to-many**: This relationship is used when one record in a table is related
    to multiple records in another table.'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多**：当表中的一条记录与另一表中的多条记录相关联时，使用这种关系。'
- en: '**Many-to-many**: This relationship is used when multiple records in one table
    are related to multiple records in another table.'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**：当一张表中的多条记录与另一张表中的多条记录相关联时，使用这种关系。'
- en: Django REST permissions are used to control access to specific actions on specific
    viewsets. They can be used to restrict who can view, add, change, or delete data
    in your REST API.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django REST权限用于控制对特定视图集的特定操作的访问。它们可以用来限制谁可以查看、添加、更改或删除REST API中的数据。
- en: In DRF, you can use the `LimitOffsetPagination` class to paginate the results
    of an API response. To use this class, you can include it in `REST_FRAMEWORK`
    in the `settings.py` file of your project.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DRF中，你可以使用`LimitOffsetPagination`类来分页API响应的结果。要使用这个类，你可以在项目的`settings.py`文件中包含它到`REST_FRAMEWORK`。
- en: 'To use the Django shell, you need to open the command line in the root directory
    of your Django project, and then run the following command:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Django shell，你需要打开Django项目的根目录下的命令行，然后运行以下命令：
- en: '**python manage.py shell**'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**python manage.py shell**'
- en: Chapter 4
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: A nested route is a URL endpoint that represents a relationship between two
    or more resources. For example, in a social media application, you might have
    a route for all posts and another route for a specific post’s comments. The comments
    route would be nested within the post route, allowing you to access the comments
    for a specific post.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套路由是一个表示两个或多个资源之间关系的URL端点。例如，在一个社交媒体应用程序中，你可能有一个所有帖子的路由和另一个特定帖子评论的路由。评论路由将嵌套在帖子路由中，允许你访问特定帖子的评论。
- en: '`drf-nested-routers` is a package for DRF that allows you to easily create
    nested routes for your API. It automatically creates the appropriate URLs for
    related resources and allows you to nest your views within other views.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`drf-nested-routers`是DRF的一个包，它允许你轻松地为你的API创建嵌套路由。它自动为相关资源创建适当的URL，并允许你在其他视图内嵌套视图。'
- en: The `partial` attribute on the `ModelSerializer` can help you determine whether
    the user is submitting all the fields of the resource on an HTTP request for mutating
    like `PUT`, `PATCH`, or `DELETE`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ModelSerializer`上的`partial`属性可以帮助你确定用户是否在HTTP请求中提交了资源的所有字段，用于修改操作，如`PUT`、`PATCH`或`DELETE`。'
- en: Chapter 5
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: Testing is a process of verifying that a system or software behaves in the way
    that it is expected to. Testing can be done manually or automatically.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试是一个验证系统或软件是否按预期行为的过程。测试可以是手动或自动进行的。
- en: A unit test is a test that verifies the functionality of a small and isolated
    piece of code, usually a single function or a method.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试是一种验证小型和独立代码片段功能性的测试，通常是一个单独的函数或方法。
- en: The testing pyramid is a concept that describes the balance between different
    types of tests in a software project. It suggests that most of the tests should
    be unit tests, which are fast and isolated, followed by a smaller number of integration
    tests, which test the interactions between different units of code, and a small
    number of end-to-end tests, which test the entire system.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔是一个描述软件项目中不同类型测试之间平衡的概念。它建议大多数测试应该是单元测试，这些测试快速且独立，然后是较少的集成测试，这些测试检查不同代码单元之间的交互，以及少量端到端测试，这些测试检查整个系统。
- en: Pytest is a popular testing framework for Python that makes it easy to write
    small, focused unit tests and provides many useful features such as test discovery,
    test parametrization, fixtures, and powerful and expressive assertion syntax.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pytest 是一个流行的 Python 测试框架，它使得编写小型、专注的单元测试变得容易，并提供了许多有用的功能，如测试发现、测试参数化、固定值和强大的表达式断言语法。
- en: A Pytest fixture is a way to provide data or set up resources that are needed
    for your tests. Fixtures are defined using the `@pytest.fixture` decorator and
    can be passed as arguments to test functions, allowing you to write more expressive
    and maintainable tests.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pytest 固定值是一种提供测试所需数据或设置资源的方法。固定值使用`@pytest.fixture`装饰器定义，并可以作为参数传递给测试函数，使您能够编写更具有表达性和可维护性的测试。
- en: Chapter 6
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. It allows
    developers to run JavaScript on the server side to build fast and scalable network
    applications. Yarn is a package manager for Node.js, like npm but it is faster
    and more secure and provides a more consistent experience across different environments.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 是一个基于Chrome的V8 JavaScript引擎构建的JavaScript运行时。它允许开发者将JavaScript运行在服务器端，以构建快速和可扩展的网络应用程序。Yarn
    是一个Node.js的包管理器，类似于npm，但它更快、更安全，并在不同环境中提供更一致的经验。
- en: Frontend development is the process of building the user interface of a software
    application. In web development, it involves using languages such as **HTML**,
    **CSS**, and **JavaScript** to create the visual elements, layout, and functionality
    of a website.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端开发是构建软件应用程序用户界面的过程。在Web开发中，它涉及使用**HTML**、**CSS**和**JavaScript**等语言来创建网站的视觉元素、布局和功能。
- en: To install Node.js, you can download the installer package from the official
    Node.js website ([https://nodejs.org/](https://nodejs.org/)) and then run it.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装Node.js，您可以从官方Node.js网站（[https://nodejs.org/](https://nodejs.org/)）下载安装程序包，然后运行它。
- en: '**Visual Studio Code** (**VS Code**) is a free, open-source code editor developed
    and maintained by Microsoft. It is a popular choice among developers for its support
    for multiple languages, debugging, and integrated Git control.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**（**VS Code**）是由微软开发和维护的一个免费、开源的代码编辑器。它因其对多种语言的支持、调试和集成Git控制而成为开发者的热门选择。'
- en: In VS Code, you can install extensions by clicking on the **Extensions** icon
    in the **Activity Bar** on the side of the editor, or by typing *Ctrl* + *Shift*
    + *X* (*Cmd* + *Shift* + *X* on macOS) to open the **Extensions** pane. You can
    then search for and install any installation you need.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中，您可以通过点击编辑器侧边的**活动栏**中的**扩展**图标，或者通过按*Ctrl* + *Shift* + *X*（在macOS上为*Cmd*
    + *Shift* + *X*）来打开**扩展**面板来安装扩展。然后，您可以搜索并安装所需的任何扩展。
- en: Hot reloading is a feature that allows you to see the changes you make to your
    code immediately in the browser, without having to manually refresh the page.
    This makes development faster and more efficient, as you can see the effects of
    your changes in real-time.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 热重载是一个允许您立即在浏览器中看到对代码所做的更改的功能，而无需手动刷新页面。这使得开发更快、更高效，因为您可以在实时中看到更改的效果。
- en: 'To create a React application with `create-react-app`, you first need to have
    Node.js and yarn installed on your OS. Then, you can use `yarn` to create a new
    React application by running the following command in your terminal:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `create-react-app` 创建一个 React 应用程序，你首先需要在你的操作系统上安装 Node.js 和 yarn。然后，你可以在终端中运行以下命令来使用
    `yarn` 创建一个新的 React 应用程序：
- en: '**yarn create react-app my-app**'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**yarn create react-app my-app**'
- en: Chapter 7
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章
- en: '`localStorage` is an API provided by web browsers that allow developers to
    store `localStorage` persists even when the browser is closed, or the computer
    is restarted.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`localStorage` 是由网络浏览器提供的 API，允许开发者存储数据，即使浏览器关闭或计算机重启，`localStorage` 中的数据也会持续存在。'
- en: '`React-Router` is a popular library for client-side routing in React. It allows
    you to declaratively map your application’s component structure to specific URLs,
    making it easy to navigate between pages and manage the browser history'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`React-Router` 是一个流行的 React 客户端路由库。它允许你声明性地将应用程序的组件结构映射到特定的 URL，这使得在页面之间导航和管理浏览器历史记录变得容易'
- en: 'To configure a protected route in React, you can use React-Router’s `<Route>`
    component along with a **higher-order component** (**HOC**) or a custom Hook that
    checks if the user is authenticated before rendering the protected component.
    For example:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 React 中配置受保护的路由，你可以使用 React-Router 的 `<Route>` 组件以及一个**高阶组件**（**HOC**）或自定义
    Hook，在渲染受保护组件之前检查用户是否已认证。例如：
- en: '[PRE34]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A React Hook is a special function that allows you to use state and other React
    features in a functional component. Hooks were introduced in React 16.8 to make
    it easier to write and manage stateful logic in functional components.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Hook 是一个特殊的函数，它允许你在函数组件中使用状态和其他 React 功能。Hooks 在 React 16.8 中引入，以使在函数组件中编写和管理状态逻辑变得更加容易。
- en: 'Some examples of React Hooks are:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Hooks 的例子包括：
- en: '`useState`: allows you to add a state to a functional component.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`：允许你在函数组件中添加状态。'
- en: '`useEffect`: allows you to run side effects such as fetching data or subscribing
    to an event in a functional component.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect`：允许你在函数组件中运行副作用，如获取数据或订阅事件。'
- en: '`useContext`: allows you to access the context values from a functional component.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useContext`：允许你从函数组件中访问上下文值。'
- en: 'The two rules of React Hooks are:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Hooks 的两条规则是：
- en: Only call Hooks at the top level. Don’t call Hooks inside loops, conditions,
    or nested functions.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在顶层调用 Hooks。不要在循环、条件或嵌套函数内部调用 Hooks。
- en: Only call Hooks from React function components. Don’t call Hooks from regular
    JavaScript functions.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能在 React 函数组件中调用 Hooks。不要从常规 JavaScript 函数中调用 Hooks。
- en: Chapter 8
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章
- en: A modal is a dialog box/pop-up window that is displayed on top of the current
    page. Modals are used to display content that requires the user’s attention or
    input, such as forms, images, videos, or alerts.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模态对话框是一个显示在当前页面之上的对话框/弹出窗口。模态对话框用于显示需要用户注意或输入的内容，例如表单、图片、视频或警报。
- en: In React, a `props` object.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 React 中，一个 `props` 对象。
- en: The `children` element in React is a special prop that is used to pass content
    between elements. It is used to nest UI elements inside of other elements, and
    it can be accessed using the `props.children` property inside of the parent component.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 中的 `children` 元素是一个特殊的属性，用于在元素之间传递内容。它用于在元素内部嵌套 UI 元素，并且可以在父组件中使用 `props.children`
    属性访问。
- en: A wireframe is a simplified visual representation of a web page or application,
    used to communicate the layout, structure, and functionality of a user interface.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线框是一个简化的网页或应用的视觉表示，用于传达用户界面的布局、结构和功能。
- en: The `map` method is an array method in JavaScript that is used to iterate over
    an array and create a new array with the results of a function applied to each
    element of the original array. It can also be used in JSX to map over an array
    and create a new set of elements.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map` 方法是 JavaScript 中的一个数组方法，用于遍历数组并创建一个新的数组，该数组包含对原始数组中每个元素应用函数的结果。它也可以在
    JSX 中使用，以遍历数组并创建一组新的元素。'
- en: The `mutate` method on SWR objects allows you to programmatically update the
    data in the cache, without waiting for the revalidation to happen. The `mutate`
    method triggers a re-render on the components that are using the data in the cache,
    updating the UI to reflect the new data.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SWR 对象上的 `mutate` 方法允许你以编程方式更新缓存中的数据，而无需等待重新验证发生。`mutate` 方法会在使用缓存数据的组件上触发重新渲染，更新
    UI 以反映新数据。
- en: Chapter 9
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章
- en: The `useParams` Hook is a built-in Hook in React Router that allows you to access
    the dynamic parameters passed in the URL of a route. It returns an object containing
    the **key-value** pairs of the parameters in the parameters.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useParams`钩子是React Router内置的钩子，允许你访问路由URL中传递的动态参数。它返回一个包含参数**键值对**的对象。'
- en: In React, you can write a route that can support parameter passing by using
    the `:` syntax in the path of the route. For example, you can have `post/:postId`
    where `postId` is an URL parameter.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React中，你可以使用路由的路径中的`:`语法来编写支持参数传递的路由。例如，你可以有`post/:postId`，其中`postId`是一个URL参数。
- en: The `useContext` Hook is a built-in hook in React that allows you to access
    a context value within a functional component. This can be useful for sharing
    data across multiple components without having to pass props down through multiple
    levels of the component tree.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useContext`钩子是React内置的钩子，允许你在功能组件中访问上下文值。这可以在不通过组件树的多级传递props的情况下，在多个组件之间共享数据。'
- en: Chapter 10
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: The `FormData` object is a built-in JavaScript object that allows you to construct
    and send `multipart/form-data` requests. It can be used to upload files or other
    forms of binary data, as well as to send `FormData` object can be passed as the
    body of an `XMLHttpRequest` or `fetch` request, and it will automatically set
    the appropriate `Content-Type` header.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FormData`对象是一个内置的JavaScript对象，允许你构建并发送`multipart/form-data`请求。它可以用来上传文件或其他二进制数据形式，以及将`FormData`对象作为`XMLHttpRequest`或`fetch`请求的主体，它将自动设置适当的`Content-Type`头。'
- en: In Django, the `MEDIA_URL` setting is used to specify the URL at which user-uploaded
    media files will be served.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Django中，`MEDIA_URL`设置用于指定用户上传的媒体文件将被服务的URL。
- en: The `MEDIA_ROOT` setting in Django is used to specify the filesystem path where
    user-uploaded media files will be stored.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django中的`MEDIA_ROOT`设置用于指定用户上传的媒体文件将被存储的文件系统路径。
- en: Chapter 11
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: The `render` method of the `render` method can be used to test the behavior
    and output of a component in a real-world-like environment.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render`方法的`render`方法可以用来测试组件在类似真实环境中的行为和输出。'
- en: Jest is a JavaScript testing framework that allows you to write and run unit
    tests for JavaScript code, including React components.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jest是一个JavaScript测试框架，允许你为JavaScript代码（包括React组件）编写和运行单元测试。
- en: The `data-testid` attribute is a special attribute that allows you to add an
    identifier to an element for the purpose of testing. This attribute can be used
    to query the element in a test and make assertions about its state or behavior.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`data-testid`属性是一个特殊属性，允许你为测试目的向元素添加标识符。这个属性可以在测试中查询元素，并对它的状态或行为进行断言。'
- en: 'Some drawbacks of snapshot testing are:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快照测试的一些缺点包括：
- en: Snapshots can become stale over time as the component changes, and they need
    to be updated manually.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着组件的变化，快照可能会过时，需要手动更新。
- en: Snapshot tests can be difficult to understand, as they often show the entire
    component tree, which can be large and complex.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照测试可能难以理解，因为它们通常会显示整个组件树，这可能很大且复杂。
- en: To trigger user events in a React test suite, you can use React Testing Library
    `fireEvent` and `userEvent` methods.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React测试套件中触发用户事件，你可以使用React Testing Library的`fireEvent`和`userEvent`方法。
- en: Chapter 12
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: In Git, a branch is a separate line of development that allows one or multiple
    developers to work on different features or bug fixes simultaneously without interfering
    with each other’s work. Branches are also used to isolate changes and make it
    easy to merge them back into the main codebase or branch.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Git中，分支是一条独立的开发线，允许一个或多个开发者同时在不干扰彼此工作的情况下工作在不同的功能或错误修复上。分支还用于隔离更改，并使其易于合并回主代码库或分支。
- en: Git is a **version control system** (**VCS**) that allows developers to track
    changes in their code over time, collaborate with others, and revert to previous
    versions if needed. GitHub is a web-based hosting service for Git repositories.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Git是一个**版本控制系统**（**VCS**），允许开发者跟踪代码随时间的变化，与他人协作，并在需要时回滚到以前的版本。GitHub是一个基于Web的Git仓库托管服务。
- en: An HTTP Host header attack is a type of web application attack that exploits
    a vulnerability in the way some web servers handle the HTTP Host header. The HTTP
    Host header is used to specify the domain name of the website that the user is
    trying to access. By manipulating the Host header, an attacker can trick a vulnerable
    web server into serving content from a different domain, potentially exposing
    sensitive information, or allowing the attacker to perform actions on the user’s
    behalf.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP主机头攻击是一种利用某些Web服务器处理HTTP主机头方式中的漏洞的Web应用程序攻击。HTTP主机头用于指定用户试图访问的网站域名。通过操纵主机头，攻击者可以欺骗一个易受攻击的Web服务器从不同的域名提供内容，可能暴露敏感信息，或者允许攻击者代表用户执行操作。
- en: In Django, the `SECRET_KEY` setting is used to provide a secret key that is
    used to secure certain aspects of the Django framework, such as session management,
    password hashing, and the generation of cryptographic signatures. As it is a sensible
    piece of information, the value should be stored using environment variables.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Django中，`SECRET_KEY`设置用于提供用于保护Django框架某些方面的密钥，例如会话管理、密码散列和生成加密签名。由于这是一条合理的信息，其值应使用环境变量存储。
- en: Chapter 13
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: Docker is a platform for developing, shipping, and running applications that
    uses containerization technology to package an application and its dependencies
    into a single, portable container that can run on any platform that supports Docker.
    Containers provide a lightweight, isolated environment for running applications,
    which makes it easy to move them between development, staging, and production
    environments.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker是一个用于开发、运输和运行应用程序的平台，它使用容器化技术将应用程序及其依赖项打包成一个单一、可移植的容器，该容器可以在支持Docker的任何平台上运行。容器为运行应用程序提供了一个轻量级、隔离的环境，这使得它们在开发、预演和生产环境之间移动变得容易。
- en: Docker Compose is a tool for defining and running multi-container Docker applications.
    It allows you to use a single `docker-compose.yml` file to configure and start
    multiple services (containers) that make up your application. This makes it easy
    to manage the dependencies and configuration of a complex application.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。它允许您使用单个`docker-compose.yml`文件来配置和启动构成您应用程序的多个服务（容器）。这使得管理复杂应用程序的依赖项和配置变得容易。
- en: The main difference between Docker and Docker Compose is that Docker is a platform
    for creating, shipping, and running containers, while Docker Compose is a tool
    for defining and running multi-container applications. Additionally, Docker Compose
    relies on Docker to create and run the containers.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker与Docker Compose之间的主要区别在于，Docker是一个用于创建、运输和运行容器的平台，而Docker Compose是一个用于定义和运行多容器应用程序的工具。此外，Docker
    Compose依赖于Docker来创建和运行容器。
- en: Virtualization is a technology that allows you to run multiple operating systems
    on a single physical machine, by creating virtual machines that emulate the hardware
    of a physical computer. Each virtual machine runs its operating system, and applications
    running inside the virtual machines are isolated from each other. Containerization
    is a technology that allows you to package an application and its dependencies
    into a single, portable container that can run on any platform. Containers are
    lightweight, isolated environments that share the host operating system kernel,
    which makes them faster and more efficient than virtual machines.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟化是一种技术，允许您通过创建模拟物理计算机硬件的虚拟机，在单个物理机器上运行多个操作系统。每个虚拟机运行其操作系统，运行在虚拟机内的应用程序彼此隔离。容器化是一种技术，允许您将应用程序及其依赖项打包成一个单一、可移植的容器，该容器可以在任何平台上运行。容器是轻量级、隔离的环境，它们共享宿主操作系统的内核，这使得它们比虚拟机更快、更高效。
- en: An environment variable is a value that can be passed to an operating system
    or application at runtime. It allows you to configure system-wide settings or
    to pass information to an application without hard-coding it in the source code.
    Environment variables can be used to set configuration options, such as the location
    of a file or the value of a secret key, and they can be easily changed without
    modifying the application’s code.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境变量是在运行时可以传递给操作系统或应用程序的值。它允许您配置系统范围的设置或将信息传递给应用程序，而无需在源代码中硬编码。环境变量可以用于设置配置选项，例如文件的位置或密钥的值，并且可以轻松更改而无需修改应用程序的代码。
- en: Chapter 14
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: 'The differences between **Continuous Integration** (**CI**) and **Continuous
    Deployment** (**CD**) are:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）和**持续部署**（**CD**）之间的区别是：'
- en: CI is a software development practice in which developers integrate code into
    a shared repository multiple times a day. Each integration is verified by an automated
    build and test process to catch errors early.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI是一种软件开发实践，开发者每天多次将代码集成到共享仓库中。每次集成都会通过自动构建和测试过程进行验证，以尽早捕捉错误。
- en: CD is an extension of CI that goes a step further and automatically deploys
    the code changes to production after they pass the automated build and test process.
    The goal of CD is to make sure that the code is always in a releasable state and
    to shorten the time between code being written and it being available to end-users.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD是CI的扩展，在代码通过自动构建和测试过程后，进一步自动将代码更改部署到生产环境。CD的目标是确保代码始终处于可发布状态，并缩短代码编写和提供给最终用户之间的时间。
- en: GitHub Actions is a feature provided by GitHub that allows developers to automate
    their software development workflows, such as building, testing, and deploying
    code. These workflows are defined in YAML files and can be triggered by various
    events such as a push to a branch, a pull request, or a scheduled time. Developers
    can use GitHub Actions to automate their CI/CD workflows.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub Actions是GitHub提供的一项功能，允许开发者自动化他们的软件开发工作流程，如构建、测试和部署代码。这些工作流程定义在YAML文件中，可以由各种事件触发，例如向分支推送、拉取请求或计划的时间。开发者可以使用GitHub
    Actions来自动化他们的CI/CD工作流程。
- en: CD is the practice of automatically building, testing, and deploying code changes
    to different environments after they pass the automated build and test process.
    It is an extension of CI, and the goal is to ensure that the code changes are
    always in a releasable state, so that they can be deployed to production at any
    time.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CD是一种实践，在代码通过自动构建和测试过程后，自动构建、测试和部署代码更改到不同的环境。它是CI的扩展，目标是确保代码更改始终处于可发布状态，以便可以随时部署到生产环境。
- en: Chapter 15
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: '**Amazon Simple Storage Service** (**S3**) is an object storage service provided
    by **Amazon Web Services** (**AWS**) that allows you to store and retrieve large
    amounts of data.'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Amazon Simple Storage Service**（**S3**）是由**Amazon Web Services**（**AWS**）提供的一种对象存储服务，允许您存储和检索大量数据。'
- en: 'To create an **Identity and Access Management** (**IAM**) user on AWS, you
    can use the AWS Management Console. Here’s an example of how to create an IAM
    user using the AWS Management Console:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在AWS上创建一个**身份和访问管理**（**IAM**）用户，您可以使用AWS管理控制台。以下是如何使用AWS管理控制台创建IAM用户的示例：
- en: Log in to the AWS Management Console
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录AWS管理控制台
- en: Open the IAM console.
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IAM控制台。
- en: In the **Navigation** pane, choose **Users** and then choose **Add user**.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导航**面板中，选择**用户**然后选择**添加用户**。
- en: Type the username and select the **AWS** **access type**.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入用户名并选择**AWS** **访问类型**。
- en: Choose **Permissions**.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**权限**。
- en: Choose **Add user to a group**, create group, or **Add existing groups** as
    appropriate.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要选择**添加用户到组**、创建组或**添加现有组**。
- en: Choose **Tags**.
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**标签**。
- en: Choose **Review**.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**审查**。
- en: Choose **Create user**.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建用户**。
- en: The command used to build a React application is `react-scripts build`. This
    command will take all the code and assets in your application and create a production-ready
    build that can be deployed on a web server.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建React应用的命令是`react-scripts build`。此命令将应用中的所有代码和资源打包成一个可用于部署到Web服务器的生产就绪构建。
- en: In a Node.js or more specifically a React project, environment variables are
    typically retrieved using the `process.env` object. For example, you can access
    the value of an environment variable named `VARIABLE` using `process.env.VARIABLE`.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Node.js或更具体地说在React项目中，环境变量通常使用`process.env`对象检索。例如，您可以使用`process.env.VARIABLE`访问名为`VARIABLE`的环境变量的值。
- en: Chapter 16
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: Amazon CloudFront is a **content delivery network** (**CDN**) provided by AWS.
    It allows you to distribute content, such as web pages, images, videos, and more,
    to users across the world by caching the content on servers located in various
    geographic locations. CloudFront can be used to deliver content from a variety
    of origins, such as an S3 bucket or a custom origin.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Amazon CloudFront是由AWS提供的**内容分发网络**（**CDN**）。它允许您通过在位于不同地理位置的服务器上缓存内容，将网页、图片、视频等内容分发到全球用户。CloudFront可以从多种来源交付内容，例如S3存储桶或自定义来源。
- en: 'There are several strategies for cache invalidation in Django:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django中缓存失效的策略有几种：
- en: '**Per-site cache**: This enables you to cache your entire website.'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**站点级缓存**：这使您能够缓存整个网站。'
- en: '**Template fragment cache**: This enables you to cache some components of the
    website. For example, you can decide to only cache the footer.'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板片段缓存**：这使您能够缓存网站的一些组件。例如，您可以选择只缓存页脚。'
- en: '**Per-view cache**: This enables you to cache the output of individual views.'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图级缓存**：这使您能够缓存单个视图的输出。'
- en: '**Low-level cache**: Django provides an API you can use for interacting directly
    with the cache. It is useful if you want to produce a certain behavior based on
    a set of actions.'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级缓存**：Django提供了一个API，您可以使用它直接与缓存进行交互。如果您想根据一系列操作产生特定的行为，这将非常有用。'
- en: Logging is important because it allows you to track the activity of your system,
    troubleshoot issues, and gather data for analysis. Logs provide a detailed history
    of what has happened in your system, including events such as user actions, system
    failures, and performance metrics. This information can be used to identify trends,
    detect patterns, and troubleshoot problems.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录日志非常重要，因为它允许您跟踪系统的活动，解决问题，并收集用于分析的数据。日志提供了系统发生事件的详细历史记录，包括用户操作、系统故障和性能指标等事件。这些信息可用于识别趋势、检测模式并解决问题。
