- en: Testing Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据持久性测试
- en: Repeatable unit testing of code is rarely more critical than in the case of
    data persistence. Code can change or be replaced over time, perhaps even to the
    point of changing to a completely different system, written in a completely different
    language, but once data exists, it can potentially outlive any number of code
    bases that make use of it. The data in a system, it could be argued, is where
    the real business value usually exists, so testing of the processes that interact
    with it, and have the potential to destroy that value, is extremely important.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的可重复单元测试在数据持久性的情况下很少比这更重要。代码可能随着时间的推移而发生变化或被替换，甚至可能完全更改为完全不同的系统，用完全不同的语言编写，但一旦数据存在，它可能比使用它的任何代码库都更持久。可以说，系统中的数据通常存在真正的业务价值，因此对与其交互的过程进行测试，并有可能破坏该价值的过程进行测试非常重要。
- en: 'With that in mind, the bulk of this chapter will be focused on the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，本章的大部分内容将集中在以下内容上：
- en: 'Writing the unit tests for the data object and related classes created in this
    iteration:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写本次迭代中创建的数据对象和相关类的单元测试：
- en: The new `hms_artisan` classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`hms_artisan`类
- en: The new `hms_core` classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`hms_core`类
- en: Integration of those tests with the build process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些测试与构建过程集成
- en: 'There''s also been enough new functionality added that some attention will
    have to be paid to the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 还添加了足够多的新功能，因此必须对以下内容进行一些注意：
- en: Other effects of the new code on the build process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码对构建过程的其他影响
- en: Demonstration of the new code, and how acceptance of the related stories might
    be facilitated
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示新代码以及如何促进相关故事的验收
- en: How the new code affects operations, use, maintenance, and decommissioning concerns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码如何影响操作、使用、维护和停用的关注点
- en: Writing the unit tests
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'Most of the process of writing the unit tests for the new data object classes
    can simply follow the process established in previous iterations:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写新数据对象类的单元测试的大部分过程可以简单地遵循之前迭代中建立的过程：
- en: Create the top-level test module for the package being tested.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为正在测试的包创建顶级测试模块。
- en: Identify the child modules of the package being tested, and create a corresponding
    test module for each.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别正在测试的包的子模块，并为每个创建相应的测试模块。
- en: Add references to the child test modules to the package test module and import
    their tests.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子测试模块的引用添加到包测试模块中并导入它们的测试。
- en: 'For each child test module:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个子测试模块：
- en: Execute the module and create test case classes for each item reported as missing
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行模块并为每个报告为缺失的项目创建测试用例类
- en: Execute the module and create tests methods for each member (property or method)
    reported as missing
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行模块并为每个报告为缺失的成员（属性或方法）创建测试方法
- en: 'There are several test modules that need to be created, one for each module
    that was created in the `src` directories across the projects this iteration touched,
    yielding the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建几个测试模块，每个模块对应本次迭代中涉及的项目的`src`目录中创建的每个模块，得到以下结果：
- en: '`hms_core/../data_objects.py → test_hms_core/test_data_objects.py` (already
    tested, but listed here for the sake of having a complete list)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hms_core/../data_objects.py → test_hms_core/test_data_objects.py`（已经测试过，但为了完整起见列在这里）'
- en: '`hms_artisan/../data_storage.py → test_hms_artisan/test_data_storage.py`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hms_artisan/../data_storage.py → test_hms_artisan/test_data_storage.py`'
- en: '`hms_artisan/../artisan_objects.py → test_hms_artisan/test_artisan_objects.py`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hms_artisan/../artisan_objects.py → test_hms_artisan/test_artisan_objects.py`'
- en: '`hms_core/../co_objects.py → test_hms_core/test_co_objects.py`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hms_core/../co_objects.py → test_hms_core/test_co_objects.py`'
- en: Testing hms_artisan.data_storage
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试`hms_artisan.data_storage`
- en: The unit tests for `hms_artisan.data_storage` are, at this point, all concerned
    with testing the `JSONFileDataStore` class. Because of what that class actually
    does, the typical patterns for unit testing apply poorly, if at all. It has no
    properties to test, and the one class attribute that can be tested (`_file_store_dir`)
    is overridden by derived classes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`hms_artisan.data_storage`的单元测试都与测试`JSONFileDataStore`类有关。由于该类实际上所做的事情，通常的单元测试模式不适用，甚至根本不适用。它没有要测试的属性，而且可以测试的一个类属性（`_file_store_dir`）被派生类覆盖。
- en: 'It''s probably worth asserting that the default attribute is what''s expected,
    though, since if it doesn''t default to `None`, that could cause failures in derived
    classes and instances of those classes:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 值得肯定的是，默认属性是否符合预期，因为如果它不默认为`None`，可能会导致派生类和这些类的实例失败：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As far as the testing of methods is concerned, while there are several, they
    are somewhat intertwined, and they also frequently rely upon implementations of
    methods that are abstract themselves and thus not available in the ABC itself:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就方法的测试而言，虽然有几种方法，但它们有些相互交织，并且它们经常依赖于抽象方法的实现，这些抽象方法本身不在ABC中，因此无法使用：
- en: '`get`, `delete`, and `save` all call the `_load_objects` helper class method'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`、`delete`和`save`都调用`_load_objects`辅助类方法'
- en: That `_load_objects` method relies on a concrete implementation of `from_data_dict`
    in order to generate the collection of objects that the other methods refer to
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_load_objects`方法依赖于`from_data_dict`的具体实现，以生成其他方法所引用的对象集合'
- en: The `save` method also requires a concrete implementation of the `to_data_dict`
    method
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save`方法还需要`to_data_dict`方法的具体实现'
- en: 'Since unit testing is about proving predictable functionality, the question
    then becomes: what can we prove?'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单元测试是关于证明可预测功能，因此问题变成了：我们能证明什么？
- en: 'The first, and probably most obvious, item is that object initialization works
    in pretty much the same fashion that it does in `BaseDataObject`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，也可能是最明显的项目是对象初始化的工作方式与`BaseDataObject`中的工作方式几乎相同：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `GoodDateTimes` test values are the same values we used to test `BaseDataObject`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`GoodDateTimes`的单元测试值与我们用来测试`BaseDataObject`的值相同。'
- en: 'Since the `_create` and `_update` methods aren''t going to be used, we can
    prove that they raise the expected errors when called:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`_create`和`_update`方法将不会被使用，我们可以证明当调用它们时它们会引发预期的错误：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The individual CRUD operations, plus the `_load_objects` method, since they
    are joined at the hip, would end up with a lot of overlap – tests for one method
    would have to execute tests for other methods as part of their own testing process
    in order to really prove that everything was working as expected. Tests of that
    complexity are tedious to write, but more importantly, require more effort and
    discipline to maintain, and are thus more prone to getting out of touch with the
    code they are testing. A better option, in this case, might be to skip those tests,
    and create one larger, unified test of all the related functionality. Python''s
    stock `unittest` module provides a `skip` decorator function that provides the
    ability to tag tests to be skipped by standard unit testing runs, and calling
    that requires that we log a reason for the test being skipped. In this case, the
    reason is that all of the methods in question will be tested in one large pass
    in a different test method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单独的CRUD操作以及`_load_objects`方法是相互关联的，它们之间会有很多重叠——对一个方法的测试将不得不执行其他方法的测试作为自己的测试过程的一部分，以真正证明一切都按预期工作。编写这种复杂的测试是乏味的，但更重要的是，需要更多的努力和纪律来维护，因此更容易脱离正在测试的代码。在这种情况下，更好的选择可能是跳过这些测试，并创建一个更大、统一的测试来测试所有相关功能。Python的标准`unittest`模块提供了一个`skip`装饰器函数，可以标记要在标准单元测试运行中跳过的测试，并调用它需要记录跳过测试的原因。在这种情况下，原因是所有相关方法将在不同的测试方法中进行一次大规模的测试：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That leaves the responsibility for testing most of `JSONFileDataObject` in
    the hands of a single test-method – one that''s not required by the code that
    enforces the standard test policy, but that represents the best compromise between
    individual class-member test coverage and maintainability: `testCRUDOperations`.
    There''s not a lot of opportunity for elegance in it; it has to brute-force its
    way through a lot of conditions and object states simply because of the nature
    of the methods being tested. If it''s well thought out, though, it leaves the
    tests for the classes derived from it free to not have to test the common functionality.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，大部分`JSONFileDataObject`的测试责任都落在一个单独的测试方法上——这不是代码强制执行标准测试政策所必需的，但它代表了在个别类成员测试覆盖率和可维护性之间的最佳折衷：`testCRUDOperations`。在其中并没有太多机会进行优雅的处理；它必须通过大量的条件和对象状态来强行执行，这仅仅是因为正在测试的方法的性质。但是，如果它经过深思熟虑，它将使得从它派生的类的测试不必再测试常见功能。
- en: 'The first thing that it has to do is ensure that there''s a clean object repository,
    both in memory and on the filesystem. In order to do that, a throwaway class has
    to be defined, with the bare minimum of the required functionality needed to assure
    that all the necessary method classes are being made. That class, `JSONFileDataObjectDerived`,
    looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先要做的是确保内存和文件系统中都有一个干净的对象存储库。为了做到这一点，必须定义一个一次性类，其中包含确保所有必要的方法类都被创建的最低限度的功能。这个类`JSONFileDataObjectDerived`看起来是这样的：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re providing a file storage location that is not in use by any real objects,
    which can be deleted and recreated with object data however and whenever we need
    to:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个文件存储位置，该位置没有被任何真实对象使用，可以随时删除并重新创建对象数据：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because these tests are concerned with file system data-persistence, they were
    written for the OS that system development was undertaken on—a Linux installation—though
    they would execute without modification on any Unix-like OS. Converting them to
    run under Windows isn''t difficult:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些测试涉及文件系统数据持久性，它们是针对进行系统开发的操作系统编写的——一个Linux安装——尽管它们在任何类Unix操作系统上都可以执行而无需修改。将它们转换为在Windows下运行并不困难：
- en: Create a test-data directory (`C:\TestData`, for example), and change all filesystem
    references that start with `/tmp/` to `C:\\TestData\\` (note the double-backslashes),
    and alter the remaining filesystem paths to use Windows' filesystem notation (`C:\\TestData\\path\\to\\some\\file.ext`,
    note the double-backslashes again).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个测试数据目录（例如`C:\TestData`），并将所有以`/tmp/`开头的文件系统引用更改为`C:\\TestData\\`（注意双反斜杠），并修改其余的文件系统路径以使用Windows的文件系统表示法（`C:\\TestData\\path\\to\\some\\file.ext`，再次注意双反斜杠）。
- en: 'We supply the bare minimum required functionality, using defaults or proven/provable
    functionality from parent classes wherever possible, or the simplest possible
    implementations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供所需功能的最低限度，尽可能使用父类的默认或经过验证/可证明的功能，或者使用最简单的可能实现：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Where no default or inheritable functionality is available, we keep to the
    bare minimum necessary for the tests to be meaningful – in the case of the `to_data_dict`
    method, that means sticking to the properties and data structure required by all
    classes derived from `BaseDataObject`, including `JSONFileDataObject`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有默认或可继承功能的情况下，我们保持最低限度的功能，以使测试具有意义——对于`to_data_dict`方法，这意味着坚持`BaseDataObject`的所有派生类所需的属性和数据结构：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That, then, lets us start the `testCRUDOperations` test method by directly
    clearing the in-memory object cache, and removing any files in the storage location:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们通过直接清除内存中的对象缓存，并删除存储位置中的任何文件，来开始`testCRUDOperations`测试方法：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `rmtree` function is from a Python package called `shutils`, and recursively
    deletes files and sub directories from a specified location, raising an error
    if the target location doesn't exist. The `os.path.exists` call, from the built-in
    `os` module, checks for the existence of a file or directory at the specified
    path, returning `True` if something exists there, and `False` otherwise.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmtree`函数来自一个名为`shutils`的Python包，它可以递归地从指定位置删除文件和子目录，并在目标位置不存在时引发错误。内置的`os`模块中的`os.path.exists`调用检查指定路径处的文件或目录是否存在，如果存在则返回`True`，否则返回`False`。'
- en: 'We''ll need at least one object stored in the newly cleared caches to start
    our testing process, so the creation of a data object, and saving its state data,
    comes next:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至少需要一个对象存储在新清除的缓存中，以开始我们的测试过程，因此接下来是创建一个数据对象，并保存其状态数据：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With one object created and saved, we can verify that the data-write and -read
    processes allow us to read the same data that we were expecting to be written.
    We can leverage the `matches` method of the class, since it's inherited from `BaseDataObject`,
    ultimately, and has been tested earlier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并保存一个对象后，我们可以验证数据写入和读取过程是否允许我们读取我们期望被写入的相同数据。我们可以利用类的`matches`方法，因为它最终是从`BaseDataObject`继承而来，并且之前已经经过测试。
- en: 'Since `matches` uses the `data dict` generated by `to_data_dict`, and that
    doesn''t include properties that don''t persist, such as `is_dirty` and `is_new`,
    those need to be checked separately:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`matches`使用`to_data_dict`生成的`data dict`，而其中不包括不持久的属性，比如`is_dirty`和`is_new`，这些需要单独检查：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A viable alternative, if any concerns arise about using `matches` as a data-structure-verification
    process, would be to explicitly check each property of the retrieved object against
    the corresponding property of the original. Using `matches` is a convenience,
    not a requirement.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对使用`matches`作为数据结构验证过程有任何疑虑，一个可行的替代方案是显式检查检索到的对象的每个属性与原始属性相对应。使用`matches`只是一种便利，而不是必须的。
- en: 'Next, we will check to make sure that multiple objects are saved and read as
    expected. Since the files and the keys for the objects are both functions of the
    `oid` of the objects, and we now know that the files and in-memory copies of data
    objects work with the creation of one object, we just need to ensure that multiples
    don''t break anything. Creating two more objects also allows us to re-verify the
    entire collection later on:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查确保多个对象被保存和读取如预期。由于文件和对象的键都是对象的`oid`的函数，而且我们现在知道文件和内存中的数据对象的创建与一个对象的创建有关，我们只需要确保多个对象不会出现任何问题。创建另外两个对象还允许我们稍后重新验证整个集合：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to test that deletions behave as expected, removing the deleted
    object from the in-memory cache and deleting the applicable file. Before performing
    the deletion, we need to confirm that the file that''s going to be deleted exists,
    in order to avoid a false positive test result once the deletion executes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要测试删除行为是否符合预期，从内存缓存中删除已删除的对象并删除适用的文件。在执行删除之前，我们需要确认要删除的文件是否存在，以避免删除执行后出现错误的测试结果：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we can delete the item and verify the deletion from both the memory and
    filesystem:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以删除该项，并验证从内存和文件系统中的删除：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also need to verify that data writes of updated state data work. We can
    check that by changing the `is_active` and `is_deleted` flags of an existing object,
    then saving it, and retrieving a copy of it for comparison, and checking with
    `matches`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要验证更新状态数据的数据写入是否有效。我们可以通过更改现有对象的`is_active`和`is_deleted`标志，然后保存它，并检索其副本进行比较，并使用`matches`进行检查：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the event that other tests might be added to this test case class later,
    and in the interests of cleaning up files once they are no longer needed, we''ll
    repeat the process of clearing out the in-memory and on-disk object stores. If
    other tests, created later for whatever ends, need to start with the in-memory
    and on-disk stores in any particular state, they''ll have to make arrangements
    to get that state set up, but they won''t have to worry about clearing it first:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后可能向此测试用例类添加其他测试，并且为了清理不再需要的文件，我们将重复清除内存和磁盘对象存储的过程。如果以后为任何目的创建其他测试需要以特定状态开始内存和磁盘存储，它们将不得不安排设置该状态，但它们不必担心首先清除它：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The original `test_file_store_dir` test method did not account for proving
    that derived classes will not allow themselves to be instantiated without a `_file_store_dir`
    class attribute that is set to something other than `None`. Revising that, and
    using another class derived from `JSONFileDataObject`, which is essentially a
    copy of the `JSONFileDataObjectDerived` class used for CRUD operations testing
    but without the attribute specification, allows that to be tested as part of the
    original test method like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`test_file_store_dir`测试方法没有考虑到派生类不允许在没有设置为`None`以外的其他值的`_file_store_dir`类属性的情况下实例化自己。修改这一点，并使用另一个从`JSONFileDataObject`派生的类，这个类本质上是用于CRUD操作测试的`JSONFileDataObjectDerived`类的副本，但没有属性规范，允许将其作为原始测试方法的一部分进行测试：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing hms_artisan.artisan_objects
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试hms_artisan.artisan_objects
- en: 'After the initial unit test setup, there are 74 tests that need to be implemented,
    largely due to the overrides of properties and their setter and deleter methods
    from their `Base` counterpart classes in `hms_core`. Since the main difference
    between the properties and their overridden methods is the inclusion of an automatic
    change in the instance''s `is_dirty` property during a set or delete call, that
    might appear to be the only thing that the property-related tests at this level
    need to be concerned with:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 初始单元测试设置完成后，需要实现74个测试，这主要是由于在`hms_core`中的`Base`对应类中覆盖了属性及其setter和deleter方法。由于属性及其重写方法之间的主要区别在于在设置或删除调用期间自动更改实例的`is_dirty`属性，因此在这个级别上与属性相关的测试可能需要关注的唯一事情可能是这个：
- en: '![](assets/36de70e3-fbd5-4fbc-91ec-7c4b2f885d1c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/36de70e3-fbd5-4fbc-91ec-7c4b2f885d1c.png)'
- en: The tests for the properties are all close to the standard structure that has
    been used so far, essentially verifying that each property has the appropriate
    getter, setter, and deleter method associations. The only real difference is in
    which of those methods are being specified. Looking at the `testArtisan.testcontact_name`,
    which tests `Artisan.contact_name` as an example, the test assertions for the
    setter and deleter methods are structurally identical to their counterparts from
    the tests for `BaseArtisan` – they assert that the Artisan setter and deleter
    methods are associated with the property's set and delete actions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属性的测试都接近迄今为止使用的标准结构，基本上是验证每个属性是否具有适当的获取器、设置器和删除器方法关联。唯一的真正区别在于指定了哪些方法。例如，查看`testArtisan.testcontact_name`，它测试`Artisan.contact_name`，测试设置器和删除器方法的断言在结构上与`BaseArtisan`的测试相同——它们断言Artisan的设置器和删除器方法与属性的设置和删除操作相关联。
- en: 'The getter method assertion is where things get different:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 获取方法的断言是不同的地方：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since the `Artisan` class provided overridden methods for each setter and deleter
    method, but not for the getter method, the assertion for that aspect of the property
    is pointing instead to the original getter method, in this case, the one defined
    in and inherited from `BaseArtisan`. The same basic pattern holds true even for
    properties without a local setter or deleter method, such as `Product.metadata`,
    tested by `testProduct.testmetadata`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Artisan`类为每个设置器和删除器方法提供了重写方法，但没有为获取器方法提供重写方法，因此属性的这一方面的断言指向原始获取器方法，即在`BaseArtisan`中定义并继承的方法。即使对于没有本地设置器或删除器方法的属性，例如`Product.metadata`，也是如此，它由`testProduct.testmetadata`测试：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The tests for the setter and deleter methods themselves can also be very simple,
    with a caveat. If the fundamental assumptions are that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器和删除器方法本身的测试也可以非常简单，但有一个警告。如果基本假设是：
- en: All the properties inherited from a `Base` class in `hms_core.business_objects`
    will be tested (which is true as things stand right now)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hms_core.business_objects`中从`Base`类继承的所有属性都将被测试（就目前而言是真的）'
- en: Those tests can be trusted to prove the predictable behavior of those properties
    when they are set or deleted
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些测试可以被信任，以证明这些属性在设置或删除时的可预测行为
- en: The local setter and deleter methods will always call back to their tested counterparts
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地设置器和删除器方法将始终回调到它们的测试对应方法
- en: 'Then all that needs to be done in testing the local methods is checking that
    they set `is_dirty` accordingly. There may not be any way, realistically, to verify
    that those assumptions are in play as part of a unit-test set, though. It becomes
    a matter of knowing that these items are expected, standard procedure, and maintaining
    those procedures as new code is developed. If those principles and procedures
    can be counted upon, the tests for the derived class property-method overrides
    don''t need to go through the same level of effort/detail that their ancestors
    do, and can be as simple as these:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在测试本地方法时，需要检查它们是否相应地设置了`is_dirty`。然而，实际上可能没有任何方法来验证这些假设是否在单元测试集中发挥作用。这变成了一种知道这些项目是预期的、标准程序，并在开发新代码时保持这些程序的问题。如果这些原则和程序可以被信赖，那么派生类属性方法覆盖的测试就不需要像它们的祖先那样经过同样程度的努力/细节，可以简单如下：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The data-dict methods (`to_data_dict` and `from_data_dict`) are common across
    all of the data objects, and show up in the list of tests to be implemented across
    all of the test case classes as a result. All of them have their own particular
    challenges to writing good, thorough unit tests. The variations of `to_data_dict` all
    follow a pretty consistent pattern:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 数据字典方法（`to_data_dict`和`from_data_dict`）在所有数据对象中都是通用的，并且作为结果出现在要实现的所有测试用例类的测试列表中。所有这些都有编写良好、彻底的单元测试的特殊挑战。`to_data_dict`的变化都遵循一个相当一致的模式：
- en: Iterate over a (hopefully short) list of representative values for each property
    that should appear in the output
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历每个应该出现在输出中的属性的（希望是短的）代表性值列表
- en: Create an expected dictionary value that can be used to compare the output against
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个预期的字典值，可以用来与输出进行比较
- en: Assert that the expected dictionary and the results of `to_data_dict` are the
    same
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言预期的字典和`to_data_dict`的结果是相同的
- en: 'In theory, the best way to ensure that all possible good and bad value combinations
    get tested is to iterate over all those possible combinations, nesting loops within
    other loops so that, for example, all possible combinations of `name`, `street_address`,
    `city` values are tested. In practice, tests built using that strategy will take
    a long time to execute, with a large number of combinations to test (the number
    of `name` values × the number of `street_address` values × the number of `city`
    values, and so on). The class with the fewest properties that needs to appear
    in a data-dict representation is the `Order` class, with five local properties
    in addition to the ones that are inherited from other classes that are already
    tested. An incomplete start of the relevant `testto_data_dict` method, with only one of
    those properties included in the mix, comes to 72 lines:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，确保测试所有可能的良好和坏的值组合的最佳方法是遍历所有这些可能的组合，将循环嵌套在其他循环中，以便例如测试所有可能的`name`、`street_address`、`city`值的组合。实际上，使用该策略构建的测试将需要很长时间来执行，因为要测试的组合数量很大（`name`值的数量×`street_address`值的数量×`city`值的数量等等）。需要出现在数据字典表示中的属性最少的类是`Order`类，除了已经测试过的其他类继承的属性外，还有五个本地属性。相关的`testto_data_dict`方法的不完整开始，只包括其中一个属性，共72行：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each additional property that needs to be tested results in another loop inside
    the current loop, and the creation of a new test object, making sure to include
    the new property item/argument being tested:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要测试的每个附加属性都会导致当前循环内的另一个循环，并创建一个新的测试对象，确保包括正在测试的新属性项/参数：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Each sub-loop has to create its own `expected` value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子循环都必须创建自己的`expected`值：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Each sub-loop also has to perform its own assertion to test `expected` against
    the actual value returned by the `test_object.to_data_dict` call:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子循环还必须执行自己的断言来测试`expected`与`test_object.to_data_dict`调用返回的实际值是否相符：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are, at this point, four more properties that have to be tested, each
    of which will start with its own nested loop:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，还有四个属性需要测试，每个属性都将以自己的嵌套循环开始：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Forcing a failure, with a notation that the test-method is not complete, helps
    prevent false positives from sneaking in, and can also help to track down which
    test is being worked on in a large list of results:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 强制失败，并注明测试方法尚未完成，有助于防止假阳性的出现，并且还可以帮助跟踪在大量结果列表中正在进行的测试：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The tests for the various `from_data_dict` methods are similarly complex and
    deeply nested, for a variation of the same reason – they have to account for reasonable
    possibilities for all of the values that could be supplied. An incomplete start
    to testing that method in the `Order` class shows the pattern that''s started
    to take shape in 72 lines:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 各种`from_data_dict`方法的测试同样复杂且深度嵌套，原因是相同的变体，它们必须考虑所有可能提供的值的合理可能性。在`Order`类中测试该方法的不完整开始显示了在72行中开始形成的模式：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since there should always be default `None` values for certain results in the
    expected values of each iteration segment, we can define them once, then add them
    to the expected at each point needed:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个迭代段的预期值中应始终存在默认的`None`值，因此我们可以一次定义它们，然后在每个需要的点添加到预期值中：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The collection of nested loops themselves is identical to the ones for testing
    `to_data_dict`, starting with variants of all of the required properties/arguments:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环的集合本身与测试`to_data_dict`的循环相同，从所有必需的属性/参数的变体开始：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Each loop segment needs to create a `data_dict` with the current values in
    it, and create a test object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个循环段需要创建一个带有当前值的`data_dict`，并创建一个测试对象：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we''ll also be testing `to_data_dict`, we can assume that it''s trustworthy
    for the purposes of comparison to the test object''s `data-dict`. If the `to_data_dict`
    tests fail, they will raise those failures on their own, and not allow the test
    run to pass until those failures are resolved, with the same net result tests
    failing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还将测试`to_data_dict`，我们可以假定它对于与测试对象的`data-dict`进行比较是可信的。如果`to_data_dict`测试失败，它们将自行引发这些失败，并且不允许测试运行通过，直到这些失败得到解决，结果是相同的测试失败：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Creation of the expected value is a bit more complicated. It starts with a
    copy of the preceding `defaults` values (since we don''t want test iterations
    to pollute the master defaults values). We also need to capture the expected values
    from the instance, as we''d expect them to appear in the final data dict:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建预期值有点复杂。它始于前面`defaults`值的副本（因为我们不希望测试迭代污染主要默认值）。我们还需要从实例中捕获预期值，因为我们期望它们出现在最终数据字典中：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Building the `expected` value at this point, then, is simply a matter of updating
    it with the data dict and instance values. With that done, we can perform the
    actual test assertion:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上构建`expected`值，只是简单地更新它与数据字典和实例值。完成后，我们可以执行实际的测试断言：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As before, each property/argument that needs to be tested requires its own
    nested loop, and a copy of the same process from the topmost loop. At each successive
    loop level, the `data_dict` value has to include more and more data to pass to
    the `from_data_dict` method, but the balance of each sub-loop is otherwise identical:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，每个需要测试的属性/参数都需要自己的嵌套循环，并且需要从最顶层循环复制相同的过程。在每个连续的循环级别上，`data_dict`值必须包含更多的数据以传递给`from_data_dict`方法，但每个子循环的平衡在其他方面都是相同的：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Testing the `matches` method turns out to be less complicated than might be
    expected at first glance. A complete test, after all, needs to test for both `True`
    and `False` results, across all the properties of an object instance, with criteria
    that might be 1 value or 12, or (theoretically) dozens or hundreds. Fortunately,
    by using the same nested loop structure that''s been used for `to_data_dict` and
    `from_data_dict` tests, but varying it to create the criteria being used for the
    test and determining what the expected value needs to be at every step along the
    way, it''s actually not that difficult. The test process starts by creating an
    object with known functional data in every attribute:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`matches`方法的结果实际上没有预期的那么复杂。毕竟，一个完整的测试需要测试对象实例的所有属性，对`True`和`False`结果进行测试，标准可能是1个值或12个值，或者（理论上）数十个或数百个。幸运的是，通过使用与`to_data_dict`和`from_data_dict`测试相同的嵌套循环结构，但变化以创建用于测试的标准，并确定在每一步中预期值需要是什么，实际上并不那么困难。测试过程从创建一个具有已知功能数据的对象的每个属性开始：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The nested loop structure iterates over a range of numbers (`0` and `1`), and
    retrieves the test value from the appropriate list based on the type of value
    that the property in the loop relates to, creates or adds to the criteria, and
    determines whether the expected result should be `True` or `False` based on any
    previous expected value and the comparison of the loop''s criteria value against
    the corresponding object property. All that remains after that is the assertion
    that the expected value equals the actual value from calling the test object''s
    `matches` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环结构遍历一系列数字（`0`和`1`），并根据循环中的属性相关的值的类型从适当的列表中检索测试值，创建或添加到条件，并根据任何先前的预期值和循环的条件值与相应对象属性的比较来确定预期结果是否应为`True`或`False`。在此之后，剩下的就是断言预期值是否等于调用测试对象的`matches`方法返回的实际值：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The reason that each sub-loop pays attention to the `expected` value set in
    its parent is to make sure that `False` results at a higher loop level won''t
    get overridden by a potential `True` result at the current loop level. For example,
    at this point in the test iterations, if `name` results in a `False` result (because
    it doesn''t match `test_object.name`), even if `street_address` does match, it
    should still return a `False` result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子循环关注其父级中设置的“expected”值的原因是为了确保更高级别的“False”结果不会被当前循环级别的潜在“True”结果覆盖。例如，在测试迭代的这一点上，如果“name”导致“False”结果（因为它与“test_object.name”不匹配），即使“street_address”匹配，它仍应返回“False”结果：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The pattern for each sub-loop is, apart from the name of the property value
    being added to the criteria, and the redefinition of the `expected` value, identical
    all the way down the tree of loops:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子循环的模式，除了添加到条件中的属性值的名称和“expected”值的重新定义之外，在循环树的所有层次上都是相同的：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last remaining method that''s common to all of the new data objects is
    the `_load_objects` helper class method. Initial unit testing raised some syntax
    concerns that made it necessary to remove the abstraction on the method in `JSONFileDataObject`,
    and implement an overriding class method in each of the subordinate classes, all
    of which call the original class method as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新数据对象共有的最后一个方法是“_load_objects”辅助类方法。初始单元测试引发了一些语法问题，这使得有必要删除“JSONFileDataObject”中该方法的抽象，并在每个从属类中实现一个覆盖类方法，所有这些方法都调用原始类方法，如下所示：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That, in turn, started raising test-method requirements for the methods in
    the test runs. The implementation of those tests was not difficult, building to
    some extent on the original test method written for `JSONFileDataObject`, where
    it originated. The structure for that test against the `Order` class is the simplest
    example, and starts much the same way, but forcing the on-disk and in-memory data
    stores to clear, but after setting the on-disk location to a disposable directory:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来开始提高测试运行中方法的要求。这些测试的实施并不困难，在一定程度上建立在最初为“JSONFileDataObject”编写的原始测试方法上。对“Order”类进行的测试结构是最简单的例子，并且开始方式基本相同，但是强制清除磁盘和内存数据存储，但在将磁盘位置设置为一次性目录之后：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Again, in order to test the loading process, it''s necessary to create and
    save some objects:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试加载过程，需要创建并保存一些对象：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As each object is created, its presence in the in-memory and on-disk stores
    is verified:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建每个对象时，都会验证其在内存和磁盘存储中的存在：
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It''s also necessary to clear the in-memory store, reload it, and verify that
    the newly created object is still there. This happens in each object-creation
    iteration:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要清除内存存储，重新加载它，并验证新创建的对象是否仍然存在。这在每个对象创建迭代中都会发生：
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Verification that the deletion process removes in-memory and on-disk objects
    works by iterating over a list of instances, selecting one at random, deleting
    that instance, and verifying its removal the same way that the initial creation
    was verified:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代实例列表，随机选择一个实例，删除该实例，并验证其删除方式与最初的创建方式相同，以验证删除过程是否移除了内存和磁盘对象：
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The list of instances is updated at the end of each iteration:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代结束时，实例列表都会更新：
- en: '[PRE45]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, any files that might remain are deleted, just to be safe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了安全起见，任何可能剩下的文件都会被删除：
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Most of the balance of the test methods follow patterns established previously:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试方法的平衡遵循先前建立的模式：
- en: The various properties and their getter, setter, and deleter methods use the
    structure noted at the beginning of this section
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种属性及其getter、setter和deleter方法使用本节开头提到的结构
- en: The various `__init__` methods still create and assert argument-to-property
    settings for a reasonable subset of good values for all arguments/properties
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种“__init__”方法仍然为所有参数/属性的合理子集创建并断言参数到属性设置
- en: 'There are a few outliers, though. First and foremost, the `sort` class method
    that was defined without implementation, as an abstract class method in `BaseDataObject`, has
    surfaced. At this point, we don''t even know whether we''re going to need it,
    let alone what shape it will need to take. Under the circumstances, deferring
    both its implementation and the testing of that implementation feels prudent.
    In order to allow the required unit test to be ignored, it can be decorated with
    `unittest.skip`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些离群值。首先，定义了但没有实现的“sort”类方法，作为“BaseDataObject”中的抽象类方法，已经出现。在这一点上，我们甚至不知道我们是否需要它，更不用说它需要采取什么形式了。在这种情况下，推迟其实现和该实现的测试似乎是明智的。为了允许忽略所需的单元测试，可以用“unittest.skip”进行装饰：
- en: '[PRE47]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Two more outliers surfaced in the Artisan class: `add_product` and `remove_product`,
    which had no testable concrete implementation before now. With the addition of
    the `Goodproducts` and `Badproducts` value lists to test with, `testadd_product`
    is very similar to previous test methods utilizing value lists to test against:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Artisan类中又出现了两个离群值：“add_product”和“remove_product”，在此之前没有可测试的具体实现。通过添加“Goodproducts”和“Badproducts”值列表进行测试，“testadd_product”与以前利用值列表进行测试的测试方法非常相似：
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The process for testing `remove_product` starts by using that same process
    to create a collection of products, then removes them one at a time, verifying
    the removal at each iteration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 测试“remove_product”的过程是通过使用相同的过程创建产品集合，然后逐个删除它们，并在每次迭代中验证删除：
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Because `hms_artisan..Order` was built from the ground up, its property method
    tests needed to explicitly perform that same sort of `is_dirty` check noted earlier,
    but also had to implement any of several standard property tests. A typical deleter
    and setter method test looks like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为“hms_artisan..Order”是从头开始构建的，其属性方法测试需要明确执行与之前提到的相同类型的“is_dirty”检查，但还必须实现几种标准属性测试中的任何一种。典型的删除器和设置器方法测试如下所示：
- en: '[PRE50]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The final test-run report for all tests for the `hms_artisan` namespace shows
    that all the tests were run except the seven that were explicitly skipped, with
    no test failures:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`hms_artisan`命名空间的所有测试的最终测试报告显示，除了明确跳过的七个测试外，所有测试都已运行，没有测试失败：'
- en: '![](assets/290e854c-1c7d-4088-a9f8-01f8281be892.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/290e854c-1c7d-4088-a9f8-01f8281be892.png)'
- en: Testing the new hms_core Classes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试新的hms_core类
- en: 'After going through the usual setup process for the unit tests of a module
    (creating the test module, executing the test module, creating test case classes
    for each item reported as missing, executing the test module, and creating test
    methods for each item reported as missing), the initial results show far fewer
    tests in need of implementation than in previous unit test modules, with only
    11 tests that need to be populated:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行模块的单元测试的常规设置过程之后（创建测试模块，执行测试模块，为每个报告为缺失的项目创建测试用例类，执行测试模块，并为每个报告为缺失的项目创建测试方法），初始结果显示需要实现的测试要少得多，只有11个需要填充：
- en: '![](assets/f61743e9-8d38-40f4-8d8c-af52dfab303b.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f61743e9-8d38-40f4-8d8c-af52dfab303b.png)'
- en: 'There is a caveat to these results, though: they **do not** include tests of
    the data object methods required by `BaseDataObject` and `HMSMongoDataObject`,
    just of the properties and methods defined as part of the `Artisan` and `Product`
    classes that were created. Those, living in their own test module, add another
    33 tests that need to be implemented:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这些结果有一个警告：它们**不包括**对`BaseDataObject`和`HMSMongoDataObject`所需的数据对象方法的测试，只包括作为创建的`Artisan`和`Product`类的一部分定义的属性和方法的测试。这些属性和方法位于它们自己的测试模块中，需要实现另外33个测试：
- en: '![](assets/aedb6c7e-2e4e-4661-a292-bfa7ab1f351b.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aedb6c7e-2e4e-4661-a292-bfa7ab1f351b.png)'
- en: Unit testing hms_core.data_storage.py
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试hms_core.data_storage.py
- en: 'The bulk of the testing for the `DatastoreConfig` class follows testing patterns
    that''ve been established earlier. The noteworthy exception is in testing its
    `from_config` class method, which requires actual config files to be written to
    test against. Testing all of the good values by creating a config file full of
    them doesn''t look that much different from other test methods that involve creating
    an object instance from a `dict` value, though – the same sort of iteration over
    all the good test values starts it off:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatastoreConfig`类的大部分测试遵循先前建立的测试模式。值得注意的例外是测试其`from_config`类方法，它需要实际的配置文件进行测试。通过创建一个充满良好值的配置文件来测试所有良好值并不看起来与涉及从`dict`值创建对象实例的其他测试方法有多大不同，尽管开始时对所有良好测试值的相同迭代：'
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is where the temporary configuration file is created:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建临时配置文件的地方：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then `from_config` is called, and the various assertions are executed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`from_config`，并执行各种断言：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A similar approach/structure is used in testing the various bad values for
    each argument/property (`database`, `host`, `password`, `port`, and `user`). They
    all look much like the test of bad database values:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试每个参数/属性（`database`、`host`、`password`、`port`和`user`）的各种错误值时使用了类似的方法/结构（它们看起来都很像测试错误数据库值的测试）：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Much of the testing processes for `HMSMongoDataObject` are also in the vein
    of previously established test-writing patterns:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`HMSMongoDataObject`的大部分测试过程也与先前建立的测试编写模式相同：'
- en: Because the class derives from `BaseDataObject`, there are many of the same
    required test methods that depend on abstract functionality being implemented,
    so a derived class is created to test against, if only to ensure that the dependent
    method calls are successful
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为该类派生自`BaseDataObject`，所以有许多相同的必需测试方法依赖于实现抽象功能，因此创建了一个派生类进行测试，即使只是为了确保依赖方法调用是成功的
- en: The tests of the `_create` and `_update` methods are essentially identical to
    those created while testing their `hms_artisan` counterparts, since they too simply
    raise `NotImplementedError`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_create`和`_update`方法的测试与测试它们的`hms_artisan`对应方法基本相同，因为它们也只是简单地引发`NotImplementedError`'
- en: Testing the functionality of any `HMSMongoDataObject`-derived class requires
    an operational MongoDB installation. Without one, the tests may raise errors (which
    would hopefully at least indicate what the problem is), or may just sit waiting
    for a connection to a MongoDB to resolve until the connection-effort times out.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 测试任何`HMSMongoDataObject`派生类的功能都需要一个运行中的MongoDB安装。如果没有，测试可能会引发错误（希望至少能指出问题所在），或者可能会一直等待连接到MongoDB，直到连接尝试超时解决。
- en: 'The local properties, since they all use actual deletion of their underlying
    storage attributes, and are lazily instantiated (created when they are needed
    if they aren''t already available), require a different approach than previous
    property tests. In the interests of keeping all of the related test code in one
    spot, the `test_del_` methods have been skipped, and the testing of the deletion
    aspects of the properties merged in with the `test_get_` methods. Using `test_get_connection`
    as an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本地属性，因为它们都使用其底层存储属性的实际删除，并且是懒惰实例化（在需要时创建，如果它们尚不可用），因此需要与以前的属性测试不同的方法。为了将所有相关的测试代码放在一个地方，`test_del_`方法已被跳过，并且属性删除方面的测试与`test_get_`方法合并。以`test_get_connection`为例：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The process for each is similar:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试的过程都类似：
- en: Create a `test_object` instance
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`test_object`实例
- en: Assert that the tested property getter returns the common class attribute value
    when called (`HMSMongoDataObjectDerived._connection` in this case)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言当调用测试属性getter时返回公共类属性值（在这种情况下为`HMSMongoDataObjectDerived._connection`）
- en: Call the deleter method
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用删除方法
- en: Reassert that the common class attribute value is returned when the getter is
    called again
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新断言当再次调用getter时返回公共类属性值
- en: It might also be a good idea to assert, between the deleter and getter method
    calls, that the class attribute value is deleted, but it's not really necessary
    so long as the final getter call assertion still passes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用删除方法和getter方法之间进行断言，断言类属性值已被删除可能也是一个好主意，但只要最终的getter调用断言仍然通过，这并不是真正必要的。
- en: There are several items in the test case class for `HMSMongoDataObject` that
    depend on an actual database connection in order to be even remotely useful. In
    addition, there are test methods that directly relate to that dependency that
    can be skipped, or whose implementation is noteworthy. Since we'll need a database
    connection, that has to be configured every time that the test case class runs.
    Ideally, it should not run for every test that needs a connection, though – it's
    not a big deal if it does, at least not at the scale of the system so far, but
    in larger-scale systems, creating a new database for every test method that needs
    it could slow things down. Maybe substantially.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`HMSMongoDataObject`的测试用例类中有几个项目依赖于实际的数据库连接，以便能够有用。此外，还有一些直接与该依赖关系相关的测试方法可以跳过，或者其实现值得注意。由于我们需要一个数据库连接，因此每次测试用例类运行时都必须进行配置。理想情况下，它不应该为每个需要连接的测试运行
    - 如果它确实如此，至少在目前的系统规模上并不是什么大问题，但在更大规模的系统中，为每个需要它的测试方法创建一个新的数据库可能会减慢速度。也许会大大减慢。'
- en: 'Fortunately, the standard Python `unittest` module provides methods that can
    be used to both initialize the database connection data, and delete the database
    used for testing after all the tests are complete. Those are, respectively, the
    `setUp` and `tearDown` methods. `setUp` need do nothing more than configure the
    data access, since `HMSMongoDataObjects` will take care of creating the `connection`,
    `database`, and `collection` objects it needs when they are needed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，标准的Python `unittest`模块提供了可以用来初始化数据库连接数据，并在所有测试完成后删除用于测试的数据库的方法。分别是`setUp`和`tearDown`方法。`setUp`只需要配置数据访问，因为`HMSMongoDataObjects`会在需要时负责创建它需要的`connection`、`database`和`collection`对象：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`tearDown` is responsible for completely deleting the test database that will
    have been created for the test case class, and simply creates a `MongoClient`,
    then uses it to drop the database specified in the configuration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`tearDown`负责完全删除为测试用例类创建的测试数据库，并简单地创建一个`MongoClient`，然后使用它来删除配置中指定的数据库：'
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `setUp` and `tearDown` methods won''t behave the same way as a typical
    test method if we try to assert any expected values or behavior – any assertions
    made that fail will simply raise errors. That, then, means that while we could
    assert that configuration has completed accurately, it doesn''t really do anything
    useful from the perspective of reporting. In this case, if the configuration call
    doesn''t raise any errors, and the various test methods that rely on it pass,
    it can be taken as proof that configuration is doing what it''s expected to do.
    In that case, we can skip the relevant test methods:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试断言任何预期值或行为，`setUp`和`tearDown`方法将不会像典型的测试方法一样行为 - 任何失败的断言都将简单地引发错误。这意味着，虽然我们可以断言配置已经准确完成，但从报告的角度来看，它实际上并没有做任何有用的事情。在这种情况下，如果配置调用没有引发任何错误，并且依赖于它的各种测试方法都通过了，那么可以认为配置正在按预期进行。在这种情况下，我们可以跳过相关的测试方法：
- en: '[PRE58]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to fully test the `delete`, `get`, and `save` methods, we have to
    implement a throwaway derived class – `HMSMongoDataObjectDerived`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全测试“delete”、“get”和“save”方法，我们必须实现一个一次性的派生类 - `HMSMongoDataObjectDerived`：
- en: '[PRE59]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We''ll want some local properties that can be used to test `get`, in particular,
    but they don''t need to be anything more than simple attributes that are set during
    initialization and that appear in the results of a `to_data_dict` call:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一些本地属性可以用来测试“get”，但它们不需要更多，只需要在初始化期间设置为简单的属性，并在“to_data_dict”调用的结果中出现：
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In order to test the `delete` method, we need to first create and save some
    objects:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试“delete”方法，我们需要首先创建并保存一些对象：
- en: '[PRE61]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We''ll want to test that we can delete multiple items and single items alike,
    so we''ll take the last half of the collection of objects created, delete those,
    then take the last half of the remaining items, and so on, until we''re down to
    a single object. In each iteration, we delete the current collection of `oid`,
    and verify that they don''t exist after they''ve been deleted. Finally, we verify
    that all of the created objects have been deleted:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望测试我们可以删除多个项目和单个项目，因此我们将删除创建的对象集合的后半部分，然后删除剩余项目的后半部分，依此类推，直到只剩下一个对象。在每次迭代中，我们删除当前的`oid`集合，并验证它们在被删除后是否不存在。最后，我们验证所有创建的对象都已被删除：
- en: '[PRE62]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'A similar approach is taken for testing `get` – creating several items with
    easily identifiable property values that can be used as `criteria`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 测试“get”采用类似的方法 - 创建几个具有易于识别属性值的项目，这些值可以用作“criteria”：
- en: '[PRE63]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then we can iterate over those same values, creating a `criteria` set to use,
    and verifying that the returned objects have the `criteria` values that we passed.
    One `criteria` value first:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以迭代相同的值，创建一个`criteria`集合来使用，并验证返回的对象是否具有我们传递的`criteria`值。首先是一个`criteria`值：
- en: '[PRE64]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then we test with multiple `criteria`, to assure that more than one `criteria`
    value behaves as expected:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用多个“criteria”进行测试，以确保多个“criteria”值的行为符合预期：
- en: '[PRE65]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Between the tests of the `delete` and `get` methods, we''ve effectively already
    tested the `save` method as well – we had to save objects to get or delete them,
    after all – so `testsave` is arguably not really needed. In the interest of having
    an actual test, rather that an entry for another skipped test, we''ll implement
    it anyway, and use it to test that we can also get an object by its `oid` value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在“删除”和“获取”方法的测试之间，我们实际上已经测试了“保存”方法 - 毕竟我们必须保存对象才能获取或删除它们，因此可以说“testsave”实际上并不是真正需要的。为了进行实际测试，而不是跳过另一个测试，我们将实施它，并用它来测试我们也可以通过其“oid”值获取对象：
- en: '[PRE66]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The final test output, once everything is implemented and passes, shows 47
    tests, with five skipped:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有内容都实施并通过，最终的测试输出显示有47个测试，其中有五个被跳过：
- en: '![](assets/c22f40e6-92ce-4f9c-bc68-507be164440b.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c22f40e6-92ce-4f9c-bc68-507be164440b.png)'
- en: Unit testing hms_core.co_objects.py
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试hms_core.co_objects.py
- en: The `Artisan` and `Product` classes in `co_objects`, like their counterparts
    in the `artisan_objects` module of `hms_artisan`, had to be overridden in order
    to provide the appropriate `is_dirty` behavior when any of those properties that
    are part of a state data record are altered. As a result, their corresponding
    test methods had to be created, just as happened when testing their counterparts
    in the `hms_artisan` package. Effectively, the same changes were made in both
    modules, and as a result the test classes and the test methods within them for
    classes that exist in both packages turned out to be identical.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`co_objects`中的`Artisan`和`Product`类，就像`hms_artisan`的`artisan_objects`模块中的对应类一样，必须被覆盖以在修改了状态数据记录的任何属性时提供适当的`is_dirty`行为。因此，必须创建相应的测试方法，就像在测试`hms_artisan`软件包中的对应类时发生的那样。实际上，两个模块都进行了相同的更改，因此两个软件包中存在的类的测试类和其中的测试方法结果是相同的。'
- en: Unit tests and trust
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和信任
- en: It was noted earlier that the real purpose of unit testing code is about ensuring
    that code behaves in a predictable fashion across all possible execution cases.
    In a very real way, it is also about establishing a measure of trust in a code
    base. In that context, there is a line that has to be drawn with respect to where
    that trust can simply be taken as a given. For example, the various unit tests
    in this iteration have focused on ensuring that the code created for data persistence
    gets everything that is necessary to and from the database engine. It has not
    been concerned with whether the library to connect to the database engine is trustworthy;
    for our purposes, we assume that it is, at least until we encounter a test failure
    that cannot be explained in any other way.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候已经指出，单元测试代码的真正目的是确保代码在所有可能的执行情况下都以可预测的方式运行。从非常实际的角度来看，这也是在代码库中建立信任的一种方式。在这种情况下，必须就可以简单地接受这种信任的地方划定一条线。例如，这次迭代中的各种单元测试都侧重于确保为数据持久性创建的代码可以从数据库引擎获取并传递所有必要的内容。它并不关心用于连接到数据库引擎的库是否值得信赖；对于我们的目的，我们假设它是可信赖的，至少直到我们遇到无法用其他方式解释的测试失败。
- en: Unit tests provide that trust for others who might consume our code – knowing
    that everything that needs to be tested has been, and that all the tests have
    passed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试为可能使用我们的代码的其他人提供了信任 - 知道已经测试了所有需要测试的内容，并且所有测试都已通过。
- en: Building/distribution, demonstration, and acceptance
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/分发，演示和验收
- en: The build process for the individual modules will not have changed much, though
    with unit tests now available, those can be added to the `setup.py` files that
    are used to package the individual Python packages. The `setup` function that's
    already in place can, with minimal changes, be used to execute the entire test
    suite simply by providing a `test_suite` argument that points to the root test
    suite directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 各个模块的构建过程不会有太大变化，尽管现在有了单元测试，可以将其添加到用于打包各个Python软件包的`setup.py`文件中。已经存在的`setup`函数可以在进行最小更改的情况下用于执行整个测试套件，只需提供指向根测试套件目录的`test_suite`参数即可。
- en: 'It may be necessary to ensure that the path to the test suite directory has
    been added to `sys.path` as well:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要确保已将测试套件目录的路径添加到`sys.path`中：
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The current `setup` function call, then, includes `test_suite` like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当前的`setup`函数调用包括`test_suite`，如下所示：
- en: '[PRE68]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The entire test suite can then be executed with `python setup.py test`, which
    returns a line-by-line summary of the tests executed and their results:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用`python setup.py test`执行整个测试套件，该命令返回测试执行的逐行摘要及其结果：
- en: '![](assets/1b2a20c0-4b4f-41d7-b01b-63d65a66e9ef.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1b2a20c0-4b4f-41d7-b01b-63d65a66e9ef.png)'
- en: 'Packaging the code in a component project still uses `python setup.py sdist`
    from within the individual project directories, and still yields an installable
    package:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码打包到组件项目中仍然使用`python setup.py sdist`，并且仍然会生成可安装的软件包：
- en: '![](assets/d6b72172-6fef-4178-b77b-8fef817def58.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d6b72172-6fef-4178-b77b-8fef817def58.png)'
- en: 'Demonstrating the new data-persistence functionality could be done in several
    ways, but requires the creation of disposable/temporary demo data objects in a
    disposable/temporary database. There''s code in the `test_co_objects` test module
    that does just that, so creating a minimal data object class based on that structure
    (calling it `ExampleObject` for demonstrative purposes), then running:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 展示新的数据持久性功能可以通过多种方式完成，但需要在一次性/临时数据库中创建一次性/临时演示数据对象。`test_co_objects`测试模块中有代码可以做到这一点，因此可以基于该结构创建一个最小的数据对象类（称之为`ExampleObject`以示范目的），然后运行：
- en: '[PRE69]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'It takes care of generating a dataset that can be examined. From that point,
    any tool – the command-line `mongo` client or a GUI, such as Robo3T – can be used
    to view and verify that data was, in fact, persisted:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 它负责生成可以检查的数据集。从那时起，任何工具 - 命令行`mongo`客户端或GUI，例如Robo3T - 都可以用于查看和验证数据是否实际上已被持久化：
- en: '![](assets/e59a1ff0-2bc4-42a8-bea5-4c6e3090b0a8.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e59a1ff0-2bc4-42a8-bea5-4c6e3090b0a8.png)'
- en: If more detailed acceptance examples are needed – such as examples for each
    of the business object types – a similar script could be written to create `Artisan`
    and `Product` instances and save them as well. Similarly, with respect to the
    `hms_artisan` data object classes, simply showing the files written for objects
    in an example/demo environment should suffice.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更详细的验收示例 - 例如每种业务对象类型的示例 - 可以编写类似的脚本来创建`Artisan`和`Product`实例并保存它们。同样，就`hms_artisan`数据对象类而言，仅显示为示例/演示环境中的对象编写的文件应该就足够了。
- en: Operations/use, maintenance, and decommissioning considerations
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作/使用，维护和 decommissioning 考虑
- en: 'There is no substantial change yet as these items are concerned:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些项目而言，还没有实质性的变化：
- en: The packages, though there are now three of them, are still very simple.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管现在有三个包，但它们仍然非常简单。
- en: Although we've added an external dependency with the inclusion of the `pymongo`
    library, we're not yet at a point where we need to worry about how that dependency
    will be handled.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们通过包含`pymongo`库添加了外部依赖，但我们还没有到需要担心如何处理该依赖的地步。
- en: There will obviously need to be a MongoDB installation, but until the code is
    ready to be integrated to some shared environment, even that is a non-issue –
    local development can use local database engines for now.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然需要安装MongoDB，但在代码准备好集成到共享环境之前，这甚至不是问题 - 目前本地开发可以使用本地数据库引擎。
- en: From a decommissioning perspective, uninstalling the software hasn't really
    changed except that there are now three packages to uninstall – but the process
    for each is a variation of the process as it stood at the end of the last iteration
    (`pip uninstall HMS-Core`).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从退役的角度来看，卸载软件实际上并没有什么变化，只是现在有三个要卸载的软件包 - 但每个软件包的过程都是上一次迭代结束时的过程的变体（`pip uninstall
    HMS-Core`）。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While there may be other data-access and data-persistence tweaks in later iterations,
    and there are a few data objects whose specific details aren't known yet because
    of integration concerns with other systems, the bulk of the data objects work
    is complete.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在后续迭代中可能会有其他数据访问和数据持久化调整，也有一些数据对象的具体细节因为与其他系统集成的原因而尚不清楚，但大部分数据对象的工作已经完成。
- en: Thus far, the development iterations against the `hms_sys` code bases have had
    most of their attention focused on what might be thought of as system functionality – ensuring
    that data structures are well formed, can be validated, and will live longer than
    a single user session or Python run. Interaction with system data from a user
    perspective hasn't been addressed yet at all. Before that can be addressed, though,
    there is another layer that needs to be at least analyzed, if not built – the
    Artisan Gateway service, which acts as a central point where data from remote
    artisans and Central Office staff comes together.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，针对`hms_sys`代码库的开发迭代主要关注的是系统功能 - 确保数据结构良好形成，可以验证，并且将生存时间超过单个用户会话或Python运行。从用户角度与系统数据的交互尚未得到解决。不过，在解决这个问题之前，还有另一层需要至少进行分析，如果可能的话，进行构建
    - 即工匠网关服务，它充当远程工匠和中央办公室工作人员数据汇聚的中心点。
