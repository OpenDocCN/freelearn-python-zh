- en: Creating Token in Ethereum
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在以太坊中创建代币
- en: In this chapter, you are going to learn how to create a token on top of Ethereum.
    Tokens have a variety of uses; it may be for local currency in a local community,
    it may represent a physical good, it may be virtual money in a game, or it may
    be loyalty points. With this token, you can build a new cryptocurrency. While
    Ethereum is a cryptocurrency itself, you can build a new cryptocurrency on top
    of it. Ethereum makes it far easier to create a new token, and this fueled the
    creation of many new cryptocurrencies in 2017.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在以太坊上创建代币。代币有各种用途；它可以是一个社区的本地货币，它可以代表一个实物商品，它可以是游戏中的虚拟货币，或者它可以是忠诚度积分。有了这个代币，您可以构建一个新的加密货币。虽然以太坊本身就是一种加密货币，但您可以在其上构建一个新的加密货币。以太坊使得创建新代币变得更加容易，这推动了2017年许多新加密货币的诞生。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to create a simple token smart contract
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个简单的代币智能合约
- en: ERC 20 (Ethereum token standard)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ERC 20（以太坊代币标准）
- en: How to sell your token
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何出售您的代币
- en: How to customize your token
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何自定义您的代币
- en: Token smart contract
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代币智能合约
- en: Creating a token on top of Ethereum with Vyper is easy. Let's follow the initial
    steps to prepare our development environment before we build a token.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vyper在以太坊上创建代币很容易。在构建代币之前，让我们遵循初始步骤准备我们的开发环境。
- en: 'Start by ensuring that you have geth installed and that the `geth` program
    is in the `$PATH` environment variable (meaning that you can call `geth` without
    its full path):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保您已经安装了geth，并且`geth`程序在`$PATH`环境变量中（这意味着您可以在不输入完整路径的情况下调用`geth`）：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add Vyper support to `project.json` by changing the value of the `compilation`
    key to the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`compilation`键的值更改为以下内容，向`project.json`添加Vyper支持：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The latest version of Vyper is 0.1.0b6 and it breaks Populus. The developer
    needs some time to fix this problem. If the bug has still not been fixed by the
    time you are reading this book, you can patch Populus yourself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper的最新版本是0.1.0b6，它破坏了Populus。开发者需要一些时间来解决这个问题。如果到您阅读本书时错误仍未被修复，您可以自己修补Populus。
- en: 'First, check whether the bug has been fixed by using the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令检查错误是否已被修复：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our case here, the bug has not been fixed. So, let''s patch Populus to fix
    the bug. Make sure you are still in the same directory (`token-venv/src/populus`):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，错误尚未被修复。因此，让我们修补Populus以修复错误。确保您仍然在同一个目录（`token-venv/src/populus`）中：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the `token_project` directory, run the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`token_project`目录中，运行以下命令：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, initialize the private chain using the `init_chain.sh` script:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`init_chain.sh`脚本初始化私有链：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Edit `chains/localblock/run_chain.sh`and change the value of `--ipcpath` to
    `/tmp/geth.ipc`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`chains/localblock/run_chain.sh`并将`--ipcpath`的值更改为`/tmp/geth.ipc`。
- en: 'Then, run the blockchain:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行区块链：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, edit the `project.json` file. `chains` has one object that has four keys:
    `tester`, `temp`, `ropsten`, and `mainnet`. Add one key named `localblock` with
    its value to this object:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑`project.json`文件。`chains`有一个包含四个键的对象：`tester`，`temp`，`ropsten`和`mainnet`。向此对象添加一个名为`localblock`的键，并将其值添加到此对象中：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Mist
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mist
- en: In [Chapter 2](8932df34-bbc2-47b9-99f1-18ea76844f44.xhtml), *Smart Contract
    Fundamentals*, and [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing
    Smart Contracts Using Vyper*, you used the Truffle console to interact with the
    smart contract. Now, we are going to use another software to interact with the
    smart contract. The software we will use is `Mist`, an Ethereum wallet.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](8932df34-bbc2-47b9-99f1-18ea76844f44.xhtml)中，*智能合约基础*，和[第3章](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml)中，*使用Vyper实现智能合约*，您使用Truffle控制台与智能合约进行交互。现在，我们将使用另一种软件与智能合约进行交互。我们将使用的软件是`Mist`，一个以太坊钱包。
- en: For this, go to [https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases).
    If you use Linux Ubuntu, download the `Mist-linux64-0-11-1.deb` file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请访问[https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases)。如果您使用Linux
    Ubuntu，下载`Mist-linux64-0-11-1.deb`文件。
- en: Ensure that `geth` is already installed and that the path of `geth` is in the `$PATH`
    environment variable, so that you can call `geth` from anywhere.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`geth`已经安装，并且`geth`的路径在`$PATH`环境变量中，这样您就可以从任何地方调用`geth`。
- en: 'You can then install Mist, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下步骤安装Mist：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, run the application, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照以下步骤运行应用程序：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice the `--rpc /tmp/geth.ipc` flag. We use this flag because we run the private
    blockchain with the socket file defined in `/tmp/geth.ipc`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`--rpc /tmp/geth.ipc`标志。我们使用这个标志是因为我们使用在`/tmp/geth.ipc`中定义的套接字文件运行私有区块链。
- en: 'You will see this screen after you run the application. You can create an Ethereum
    blokchain account by clicking the ADD ACCOUNT button:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序后，您将看到这个屏幕。您可以通过点击“添加账户”按钮创建一个以太坊区块链账户：
- en: '![](assets/3f26bd6d-89a2-4f50-b54c-cc85f63bb210.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3f26bd6d-89a2-4f50-b54c-cc85f63bb210.png)'
- en: 'Just as you did in the `geth` console, you need to supply a password to create
    a new account:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您在`geth`控制台中所做的那样，您需要提供密码来创建一个新账户：
- en: '![](assets/b2ce2a62-f078-42ba-9974-f9f075a14c59.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2ce2a62-f078-42ba-9974-f9f075a14c59.png)'
- en: 'Once your wallet account has been created, you can send some money from the
    first account to this new account by clicking the SEND tab:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的钱包账户创建完成，您可以通过点击“发送”选项卡，从第一个账户向这个新账户发送一些钱：
- en: '![](assets/c21dc65e-899b-4cb8-8ecf-c5e66309fccc.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c21dc65e-899b-4cb8-8ecf-c5e66309fccc.png)'
- en: 'Then, you can insert your new account''s address in the TO field. Don''t forget
    to include the amount of ether you want to send, and then click the SEND button
    at the bottom of the window:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在“TO”字段中插入您的新账户地址。不要忘记包括您想发送的以太币数量，然后点击窗口底部的“发送”按钮：
- en: '![](assets/3c9af6dc-e952-4ae9-a94c-323f9aea1e9e.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3c9af6dc-e952-4ae9-a94c-323f9aea1e9e.png)'
- en: 'You must fill in the password to create a transaction. The password of the
    default account can be found in the `chains/localblock/password` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须填写密码以创建交易。默认账户的密码可以在`chains/localblock/password`文件中找到：
- en: '![](assets/b34ad24f-6084-454a-a6d1-463093fd3681.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b34ad24f-6084-454a-a6d1-463093fd3681.png)'
- en: 'Soon, your transaction will be confirmed in the blockchain:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，您的交易将在区块链中得到确认：
- en: '![](assets/2326f84c-1b29-4c50-bb8a-ed5db93f48f2.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2326f84c-1b29-4c50-bb8a-ed5db93f48f2.png)'
- en: 'Let''s create a simple token smart contract inside the `token_project/contracts`
    directory:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`token_project/contracts`目录中创建一个简单的代币智能合约：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This smart contract digitally creates 10,000 coins of the token and gives all
    of them to the owner of the smart contract. Then, the owner can forward the coins
    to other accounts using the `transfer` method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个智能合约数字化地创建了10,000个代币，并将它们全部分配给智能合约的所有者。然后，所有者可以使用`transfer`方法将代币转发给其他账户。
- en: This simple smart contract is special in comparison to creating a simple token
    traditional web application because, once this smart contract is deployed, the
    owner cannot change the token amount, no matter how desperate they are. If the
    owner has just executed the `transfer` method to transfer some coins to another
    account's address, they cannot take it back again. Other people can verify the
    rule of the play in the smart contract before interacting with it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建传统网络应用程序中的简单代币相比，这个简单的智能合约是特殊的，因为一旦部署了这个智能合约，所有者无论多么绝望都无法更改代币数量。如果所有者刚刚执行了`transfer`方法将一些代币转移到另一个账户的地址，他们就无法再拿回来了。其他人在与之交互之前可以验证智能合约中的游戏规则。
- en: Compare this with the simple token we created in the traditional web application.
    Once you create 10,000 coins here, you can change the number of tokens by updating
    the number of coins in the database. You can change the rule as you like, which
    places other people who want to interact with this application at a disadvantage.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个与我们在传统的网络应用程序中创建的简单代币进行比较。一旦您在这里创建了10,000个代币，您可以通过更新数据库中的代币数量来改变代币的数量。您可以随意更改规则，这会让其他想要与这个应用程序交互的人处于不利地位。
- en: 'You can also add a method to increase the number of token coins in the smart
    contract:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加一个方法来增加智能合约中代币的数量：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Look at the `mint` method. This can be used to increase the token coins in the
    owner's balance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`mint`方法。这可以用来增加所有者账户中的代币数量。
- en: The difference is that you cannot change the rule of the game after you deploy
    the smart contract. If you deploy this version of the smart contract, people could
    ask for the source and the compiler's version to verify the code. If you don't
    give the source code, people could turn away from your smart contract. If you
    do give the source code, people can check and see that you have a method that
    can increase your coins any time you like. Whether they accept this rule is up
    to them, but at least with a smart contract, there is transparency.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，您无法在部署智能合约后更改游戏规则。如果您部署了这个版本的智能合约，人们可以要求源代码和编译器的版本来验证代码。如果您不提供源代码，人们可能会对您的智能合约失去兴趣。如果您提供了源代码，人们可以检查并看到您有一个可以随时增加代币的方法。他们是否接受这个规则取决于他们自己，但至少通过智能合约，有透明度。
- en: 'The following code block is the test for this simple token smart contract;
    this test is not exhaustive, but it gives you a good start. The importance of
    a test for a token smart contract is paramount. To begin with, name the test `test_simple_token.py`
    and put it inside the `token_project/tests` directory. Refer to the code file
    in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_simple_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_simple_token.py):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是对这个简单代币智能合约的测试；这个测试并不全面，但它可以让你有一个良好的开始。对于代币智能合约来说，测试的重要性是至关重要的。首先，将测试命名为`test_simple_token.py`，并将其放在`token_project/tests`目录中。请参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_simple_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_simple_token.py)：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's deploy our simple token smart contract (the first one, without the `mint`
    function) to the blockchain using Mist.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Mist将我们的简单代币智能合约（第一个，没有`mint`函数）部署到区块链上。
- en: 'To do this, click on the CONTRACTS tab, and then click on the DEPLOY NEW CONTRACT
    button:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，点击CONTRACTS选项卡，然后点击DEPLOY NEW CONTRACT按钮：
- en: '![](assets/3fc98058-6cd6-4a8a-8bd3-e38db31d79bb.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3fc98058-6cd6-4a8a-8bd3-e38db31d79bb.png)'
- en: 'In the Deploy contract screen, choose the account you want to deploy from,
    and then click on the CONTRACT BYTE CODE tab. Insert our simple token smart contract''s
    bytecode there. You can get our simple token''s bytecode from `token_project/build/contracts.json`
    after compiling the smart contract''s source code first, of course. Find the value
    with the `bytecode` key and copy the value without the double quote, pasting it
    into the CONTRACT BYTE CODE tab. After doing this, click the DEPLOY button (not
    visible in the following screenshot; you will have to scroll down) and fill in
    the password as usual in a password dialog:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署合约屏幕上，选择要从中部署的账户，然后单击CONTRACT BYTE CODE选项卡。在那里插入我们简单代币智能合约的字节码。当然，首先编译智能合约的源代码，然后可以从`token_project/build/contracts.json`中获取我们简单代币的字节码。找到`bytecode`键的值，并将该值复制到CONTRACT
    BYTE CODE选项卡中，不包括双引号。完成后，单击DEPLOY按钮（在下面的截图中看不到；您需要向下滚动），然后像往常一样在密码对话框中填写密码：
- en: '![](assets/fb0d402c-51fb-4197-b844-32bbf3293abf.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb0d402c-51fb-4197-b844-32bbf3293abf.png)'
- en: Soon, your smart contract creation will be confirmed in the blockchain.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，您的智能合约创建将在区块链中得到确认。
- en: 'Then, to interact with the smart contract, click the CONTRACTS tab, followed
    by the WATCH CONTRACT button. A dialog will then appear. Fill in the address of
    the smart contract and then the name of the smart contract itself. You can apply
    any name you like here. Next, fill in the `json` interface of the smart contract
    inside the JSON INTERFACE field. You can get the `json` interface from `token_project/build/contracts.json` (in
    the `contracts.json` file, locate the value of the `abi` key). The form for watching
    a smart contract looks like the following screen:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要与智能合约交互，请单击“合同”选项卡，然后单击“监视合同”按钮。然后会出现对话框。填写智能合约的地址，然后填写智能合约本身的名称。您可以在此处使用任何名称。接下来，在JSON
    INTERFACE字段中填写智能合约的`json`接口。您可以从`token_project/build/contracts.json`（在`contracts.json`文件中，找到`abi`键的值）中获取`json`接口。观看智能合约的表单如下屏幕所示：
- en: '![](assets/860121e9-d162-4b21-9a27-ef489e88e880.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/860121e9-d162-4b21-9a27-ef489e88e880.png)'
- en: 'Now, your simple token smart contract will appear on the screen. Click the SIMPLE
    TOKEN label to get into this smart contract''s screen:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的简单代币智能合约将出现在屏幕上。点击“简单代币”标签，进入此智能合约的屏幕：
- en: '![](assets/434e57a5-8819-4796-baf0-5b0e740f086b.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/434e57a5-8819-4796-baf0-5b0e740f086b.png)'
- en: You can read the balance of the owner of the smart contract using the `Balances`
    method (Mist likes to capitalize methods). Insert the address of the owner's account
    in the Arg 0 - address field and press Enter. From this, you will get 10,000 as
    the output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Balances`方法（Mist喜欢大写方法）读取智能合约所有者的余额。在“Arg 0 - address”字段中插入所有者帐户的地址，然后按Enter。从中，您将得到10000作为输出。
- en: 'Now, let''s transfer some token coins. Pick a function. Right now, there is
    only one function: `Transfer` (the capitalized version of the `transfer` method).
    Choose Account 1 in the Execute from field, choose the Account 2 address in to, and
    insert 20 in the amount field. Finally, click the EXECUTE button:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转移一些代币。选择一个功能。现在只有一个功能：`Transfer`（`transfer`方法的大写版本）。在“执行自”字段中选择帐户1，在“到”字段中选择帐户2的地址，并在“金额”字段中插入20。最后，点击“执行”按钮：
- en: '![](assets/67c0f501-e87d-439b-a08c-ba613e2a9852.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/67c0f501-e87d-439b-a08c-ba613e2a9852.png)'
- en: 'Wait for confirmation before checking the balance of the destination account.
    Type the destination address into the Balance field and then press Enter. This
    will give you `20` as the output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查目标帐户余额之前，请等待确认。将目标地址输入“余额”字段，然后按Enter。这将给您输出`20`：
- en: '![](assets/e730caab-063a-469e-a2c8-2b357269b3d6.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e730caab-063a-469e-a2c8-2b357269b3d6.png)'
- en: ERC20
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ERC20
- en: More than likely, you will have heard of ERC20\. When a new cryptocurrency is
    out, the first question that usually arises is—is it an ERC20 token? People assume
    incorrectly regarding the ERC20 token; they think it is a cryptocurrency based
    on Ethereum. Well, technically speaking, this is true, but it does not tell the
    whole story. ERC20 is a standard in Ethereum for creating a token. The simple
    token that we have just created does not fulfill the ERC20 standard. Yes, it is
    a digital token smart contract, but it is not an ERC20 token. ERC20 is one of
    many reasons why we have seen an increase in the number of new cryptocurrencies
    in 2017\. However, ERC20 is not a requirement for creating a token on top of Ethereum.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，您已经听说过ERC20。当有新的加密货币问世时，通常会出现的第一个问题是——它是ERC20代币吗？人们对ERC20代币的错误假设是，他们认为它是基于以太坊的加密货币。从技术上讲，这是正确的，但这并不是全部。ERC20是以太坊中用于创建代币的标准。我们刚刚创建的简单代币并不满足ERC20标准。是的，它是数字代币智能合约，但它不是ERC20代币。ERC20是我们在2017年看到新加密货币数量增加的许多原因之一。但是，ERC20并不是在以太坊上创建代币的要求。
- en: 'To create an ERC20 token, you must implement the following methods:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建ERC20代币，您必须实现以下方法：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These methods use Solidity syntax. There are optional methods, given in the
    following code block, that you can implement too:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法使用Solidity语法。以下是可选方法，您也可以实现：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So what is so special about this ERC20 token? Is this an obligation when creating
    a token smart contract? Why can't we create a digital token without fulfilling
    the ERC20 standard?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ERC20代币有什么特别之处？在创建代币智能合约时是否有义务？为什么我们不能在不满足ERC20标准的情况下创建数字代币？
- en: Actually, you don't have to follow this standard; there is no law that forces
    you to create an ERC20 token. For example, the ERC20 standard expects you to tell
    users the overall amount of tokens in the `totalSupply` method. However, you could
    create a method named `taylorSwiftIsTheBest` to return the total supply of the
    token, and then you could create a document to explain this method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您不必遵循此标准；没有法律强制您创建ERC20代币。例如，ERC20标准希望您告诉用户`totalSupply`方法中的代币总量。但是，您可以创建一个名为`taylorSwiftIsTheBest`的方法来返回代币的总供应量，然后您可以创建一个文档来解释这个方法。
- en: 'However, there are some advantages if you follow the ERC20 token standard:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您遵循ERC20代币标准，将会有一些优势：
- en: First, it makes it easier for users to audit your smart contract.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它使用户更容易审计您的智能合约。
- en: Second, your ERC20 token would be recognized automatically by an Ethereum wallet,
    such as `Mist` (the one we used just now) and Metamask (the Ethereum wallet is
    a `Firefox/Opera/Chrome` plugin).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，您的ERC20代币将被以太坊钱包（例如我们刚刚使用的`Mist`和Metamask）自动识别（以太坊钱包是`Firefox/Opera/Chrome`插件）。
- en: Third, it is easier for cryptocurrency exchange to list your token. Basically,
    it makes everyone's lives easier.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，这样做可以更容易地让加密货币交易所列出您的代币。基本上，这会让每个人的生活更轻松。
- en: 'However, you should treat the ERC20 standard as guidance, and not strict law.
    You don''t have to follow the ERC20 standard to 100%. Not all popular tokens built
    on top of Ethereum are 100% ERC20-compliant. One such example is the Golem token
    smart contract. This does not implement the `approve` method, among other things.
    You can read the source code of the Golem token smart contract at the following
    link: [https://etherscan.io/token/0xa74476443119A942dE498590Fe1f2454d7D4aC0d#readContract](https://etherscan.io/token/0xa74476443119A942dE498590Fe1f2454d7D4aC0d#readContract).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该把ERC20标准视为指导，而不是严格的法律。你不必100%遵循ERC20标准。并非所有建立在以太坊之上的热门代币都是100%符合ERC20标准的。一个例子是Golem代币智能合约。它没有实现`approve`方法，等等。你可以在以下链接阅读Golem代币智能合约的源代码：[https://etherscan.io/token/0xa74476443119A942dE498590Fe1f2454d7D4aC0d#readContract](https://etherscan.io/token/0xa74476443119A942dE498590Fe1f2454d7D4aC0d#readContract)。
- en: 'Having said that, let''s create an ERC20 token. This code has been modified
    from the official example included in the Vyper project ([https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy](https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy)).
    Refer to the code file in the following GitLab link for the full modified code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/ERC20Token.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/ERC20Token.vy):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们创建一个ERC20代币。这段代码是从Vyper项目的官方示例修改而来的([https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy](https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy))。请参考以下GitLab链接中的代码文件获取完整修改后的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/ERC20Token.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/ERC20Token.vy)：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s describe this smart contract line by line:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行描述这个智能合约：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You must define two kinds of events, `Transfer` and `Approval`. You can define
    more events if you wish. A `Transfer` event is used when the transfer of coins
    occurs, so users of the smart contract can subscribe to this event. An `Approval`
    event is used when you approve of an amount to spend for an account:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须定义两种类型的事件，`Transfer`和`Approval`。如果愿意，你可以定义更多的事件。`Transfer`事件用于在代币转移时使用，这样智能合约的用户可以订阅此事件。`Approval`事件用于在你批准某个账户的支出金额时使用：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are six variables. The first variable is the name of the token. I used `bytes[10]`
    as the data type because the name of my token is less than 10 bytes. Feel free
    to change the length. The second variable is the symbol of the token; the name
    and symbol are different. For example, the name of the Ethereum cryptocurrency
    is Ethereum, but the symbol is ETH. Usually, the symbol''s character length is
    3\. The third variable is `totalSupply`, which is the total amount of tokens,
    and the fourth variable is decimals. You know that 1 bitcoin is 100,000,000 satoshis,
    so there will be 21,000,000 bitcoins being created in total in the Bitcoin algorithm.
    Therefore, we can say that the total supply in the Bitcoin algorithm is 2,100,000,000,000,000\.
    The decimal is 8 (because 1 bitcoin is 100,000,000, or 10⁸). Furthermore, the
    fifth variable is `balances`. This is the variable that keeps track of the balance
    of the account''s address. The final variable is `allowed`, which is a nested
    mapping. This is designed to keep track of accounts that have been approved to
    spend ethers from another account''s balance up to a certain amount. If this is
    still not clear, we''ll talk about it in depth later. Now, we will move on to
    the initialization method of this ERC20 token smart contract, as demonstrated
    in the following code block:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个变量。第一个变量是代币的名称。我使用了`bytes[10]`作为数据类型，因为我的代币名称少于10个字节。可以随意更改长度。第二个变量是代币的符号；名称和符号是不同的。例如，以太坊加密货币的名称是以太坊，但符号是ETH。通常，符号的字符长度为3。第三个变量是`totalSupply`，即代币的总数量，第四个变量是小数位。你知道1比特币等于100,000,000聪，所以比特币算法中总共会创建21,000,000比特币。因此，我们可以说比特币算法中的总供应量是2,100,000,000,000,000。小数位是8（因为1比特币等于100,000,000，或10⁸）。此外，第五个变量是`balances`。这是用于跟踪账户地址余额的变量。最后一个变量是`allowed`，这是一个嵌套映射。它旨在跟踪已获批准从另一个账户余额中支出以太币的账户。如果这还不清楚，我们稍后会深入讨论。现在，我们将继续讨论此ERC20代币智能合约的初始化方法，如下代码块所示：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is how we initialize the token in the smart contract. We create the token
    in the air, and then give all of the token''s coins to the owner. Then, we set
    the name and the symbol of the token as well as the decimal number. Finally, we
    emit the event of the transfer. The address is `ZERO_ADDRESS is 0x000000000000000000000000000000000000000`.
    This is an indicator that the owner of the smart contract has transferred coins
    from nowhere:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在智能合约中初始化代币的方式。我们在空中创建代币，然后将所有代币的硬币交给所有者。然后，我们设置代币的名称和符号以及小数位数。最后，我们发出转移事件。地址是`ZERO_ADDRESS
    is 0x000000000000000000000000000000000000000`。这表明智能合约的所有者已经从无处转移了硬币：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This method is used to return the balance of a specific account:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法用于返回特定账户的余额：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the method for transferring the coin. First, you make sure that the
    balance of the sender has enough coins to spend. Then, you just subtract the balance
    of the sender from the number of transfer processes and add that amount to the
    balance of the destination. Don''t forget to log this transaction with the event:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于转移代币的方法。首先，确保发送者的余额足够支出。然后，只需从发送者的余额中减去转移过程的数量，并将该金额添加到目标的余额中。不要忘记使用事件记录此交易：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's take a look at the `approve` method first. So each account has a mapping
    called `allowed`, but what is this mapping for? It's how each account can let
    other accounts spend its money. For example, let's say there are 5 accounts—account
    A, account B, account C, account D, and account E.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下`approve`方法。因此，每个账户都有一个名为`allowed`的映射，但这个映射是用来做什么的呢？这是每个账户如何让其他账户花费它的钱。例如，假设有5个账户——A账户、B账户、C账户、D账户和E账户。
- en: 'Account A has a balance of 50 coins and a mapping variable called `allowed`
    that has account B, account C, account D, and account E keys. The values of this
    mapping are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: A账户有50个硬币的余额和一个名为`allowed`的映射变量，其中包括B账户、C账户、D账户和E账户的键。这个映射的值如下：
- en: Account B → 3 coins
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: B账户→3个硬币
- en: Account C → 7 coins
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C账户→7个硬币
- en: Account D → 2 coins
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: D账户→2个硬币
- en: Account E → 3 coins
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: E账户→3个硬币
- en: This means that at most, account B can spend 3 coins from the balance of account
    A, account C can spend at most 7 coins from the balance of account A, account
    D can spend at most 2 coins from the balance of account A, and account E can spend
    at most 3 coins from the balance of account A.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着最多，B账户可以从A账户的余额中花费3个硬币，C账户最多可以从A账户的余额中花费7个硬币，D账户最多可以从A账户的余额中花费2个硬币，E账户最多可以从A账户的余额中花费3个硬币。
- en: 'Inside the `approve` method, we have the following line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`approve`方法内部，我们有以下行：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To ensure that account B can spend 3 coins from the balance of account A, account
    A called the `approve` method, with `_spender` set to account B's address, and
    `_amount` is set to 3 coins. Don't forget to log this approval.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保B账户可以从A账户的余额中花费3个硬币，A账户调用了`approve`方法，`_spender`设置为B账户的地址，`_amount`设置为3个硬币。不要忘记记录这个批准。
- en: 'Then, if account B wants to spend some or all of the 3 coins, account B can
    call the `transferFrom` method, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果B账户想要花费3个或全部3个硬币，B账户可以调用`transferFrom`方法，如下所示：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first assertion inside the `transferFrom` method is to make sure that account
    B does not spend more than 3 coins:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`transferFrom`方法内的第一个断言是确保B账户不花费超过3个硬币。'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We make sure that account A has at least 3 coins in its balance as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保A账户的余额至少有3个硬币，如下所示：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then, we subtract the amount of spending from the balance of account A, and
    the allowance of account A to account B. After this, we increase the balance of
    the destination account. Don't forget to log this transaction as a `Transfer`
    event.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从A账户的余额和A账户对B账户的津贴中减去花费的金额。之后，我们增加目标账户的余额。不要忘记记录这笔交易作为`Transfer`事件。
- en: 'The last method is to check the mapping of this allowance:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法是检查这个津贴的映射：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is designated to establish how much account B can spend from the balance
    of account A.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了确定B账户可以从A账户的余额中花费多少。
- en: At this point, you may ask what the point of this method is. Why don't we just
    transfer the amount of coins to account B if we want to allow account B to spend
    some ethers in the name of account A? For example, if account A allows account
    B to spend 5 coins from the balance of account A, this means that account A lets
    account B send 5 coins from the balance of account A to the address of account
    B directly. So, why doesn't account A send 5 coins directly to the address of
    account B to save the hassle? If account B changes their mind, they could refund
    the amount of tokens to account A.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会问这个方法的意义是什么。如果我们想允许B账户代表A账户花费一些以太币，为什么我们不直接将硬币的数量转移到B账户呢？例如，如果A账户允许B账户从A账户的余额中花费5个硬币，这意味着A账户让B账户直接从A账户的余额中向B账户的地址发送5个硬币。那么，为什么A账户不直接向B账户的地址发送5个硬币以节省麻烦呢？如果B账户改变主意，他们可以退还代币的数量给A账户。
- en: Normally, we would not allow a normal account to spend on our behalf. However,
    we do allow the smart contract to do this. There are a number of valid reasons
    why we want to allow a smart contract to spend our money. One of these reasons
    is the decentralized exchange smart contract case, in which you want to let the
    decentralized exchange smart contract sell your token. Let's say that you have
    created 1,000 HHH coins, and then you want to sell some of them in decentralized
    exchange. So, you allow this decentralized exchange to spend some coins on your
    behalf. Perhaps you approve the decentralized exchange to spend 30 HHH coins.
    This decentralized exchange can try to sell 30 HHH coins on your behalf. You wouldn't
    allow the decentralized exchange smart contract to have access to all of the coins
    in your balance just because you only want to sell 30 HHH coins. Although you
    could audit the smart contract to make sure the smart contract does not try to
    steal your coins, it's better to have another layer of security. The `approve`
    method is such a layer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们不允许普通账户代表我们花费。但是，我们允许智能合约这样做。有许多有效的原因，我们希望允许智能合约花费我们的钱。其中一个原因是去中心化交易智能合约的情况，您希望让去中心化交易智能合约出售您的代币。假设您创建了1,000个HHH硬币，然后您想在去中心化交易中出售其中一些。因此，您允许这个去中心化交易代表您花费一些硬币。也许您批准去中心化交易代表您花费30个HHH硬币。这个去中心化交易可以尝试代表您出售30个HHH硬币。您不会允许去中心化交易智能合约访问您余额中的所有硬币，只是因为您只想出售30个HHH硬币。尽管您可以审计智能合约，以确保智能合约不会尝试窃取您的硬币，但最好有另一层安全性。`approve`方法就是这样一层。
- en: Compile your token smart contract and deploy it, just like before.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 编译您的代币智能合约并部署它，就像以前一样。
- en: 'After doing this, go to the CONTRACTS tab and click the WATCH TOKEN button.
    In the Add token window, insert your ERC20 smart contract''s address. Then, other
    fields such as TOKEN NAME, TOKEN SYMBOL, and DECIMAL PLACES OF SMALLEST UNIT will
    be filled in automatically. This is one of the reasons why we should implement
    the ERC20 standard:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，转到“合同”选项卡，然后单击“WATCH TOKEN”按钮。在“添加代币”窗口中，插入您的ERC20智能合约的地址。然后，其他字段，如“TOKEN
    NAME”、“TOKEN SYMBOL”和“DECIMAL PLACES OF SMALLEST UNIT”将自动填充。这就是我们应该实现ERC20标准的原因之一：
- en: '![](assets/fb7d5a7f-c62d-42a9-9048-63714e24e6da.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb7d5a7f-c62d-42a9-9048-63714e24e6da.png)'
- en: 'After adding the token, you should see the HAHA COIN label on the CONTRACTS
    screen:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 添加代币后，您应该在合同屏幕上看到HAHA COIN标签：
- en: '![](assets/fae0c984-6f33-4902-b576-2285792514f2.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fae0c984-6f33-4902-b576-2285792514f2.png)'
- en: 'Then, in the SEND tab, choose the owner of the ERC20 smart contract and then
    choose Haha Coin instead of ether. Send 1,000 Haha coins to Account 2, and then
    await confirmation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在发送标签中，选择ERC20智能合约的所有者，然后选择Haha Coin而不是以太币。向账户2发送1,000个Haha代币，然后等待确认：
- en: '![](assets/d2121471-d8f5-412d-abd9-82033420abbf.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2121471-d8f5-412d-abd9-82033420abbf.png)'
- en: 'Now, choose Account 2 in the same tab; you will see that Account 2 now has
    1,000 Haha coins:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个标签页中选择账户2；您会看到账户2现在有1,000个Haha代币：
- en: '![](assets/9461d0e9-61dc-481c-a4b7-ca57879f1a75.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9461d0e9-61dc-481c-a4b7-ca57879f1a75.png)'
- en: All ERC20 compatible wallets, such as Mist and MetaMask, can recognize and interact
    with your token easily. The people behind cryptocurrency exchange would not have
    any technical difficulties either in integrating your ERC20 coins into their exchange.
    Imagine that you don't follow the ERC20 standard, and that you name a method to
    transfer coins as `tailorSwiftTransferCoin`. In this case, you must build a custom
    wallet for users before they can interact with your token.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与ERC20兼容的钱包，如Mist和MetaMask，都可以轻松识别和与您的代币进行交互。加密货币交易背后的人也不会在将您的ERC20代币整合到他们的交易所中遇到任何技术困难。想象一下，如果您不遵循ERC20标准，并且将一个方法命名为`tailorSwiftTransferCoin`来转移代币。在这种情况下，您必须为用户构建一个自定义钱包，然后他们才能与您的代币进行交互。
- en: 'Here is the test for this ERC20 token. Remember, this test is not comprehensive.
    Refer to the code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_erc20_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_erc20_token.py):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对这个ERC20代币的测试。请记住，这个测试并不全面。请参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_erc20_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_erc20_token.py)：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As well as transferring coin methods, this test also tests the `approval` and
    `transferFrom` methods.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了转账方法，这个测试还测试了`approval`和`transferFrom`方法。
- en: Selling a token
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出售代币
- en: Now that we have a token, it's time to sell the coins. We want to sell our custom
    token for ethers. A crowdsourcing token is very easy do create on the Ethereum
    platform compared to the Bitcoin platform. You already know how to create a method
    in a smart contract to accept ethers. You also know how to increase the token
    balance of some accounts. To sell tokens, you must combine those two things. That's
    all.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个代币，是时候出售这些代币了。我们希望用以太币出售我们的自定义代币。与比特币平台相比，在以太坊平台上创建一个众售代币非常容易。您已经知道如何在智能合约中创建一个方法来接受以太币。您还知道如何增加一些账户的代币余额。要出售代币，您必须将这两件事结合起来。就是这样。
- en: This is the core of the **Initial Coin Offering** (**ICO**). The currency of
    Ethereum is valuable. Although the price of ether fluctuates, 1 ether is valued
    at around USD 100\. People would pay real money for some ethers, but not our custom
    token. To make our custom token worthy, we have to make it useful first, or at
    least make it appear useful. But to do that, we need capital. So why not sell
    some of our tokens (say 60%) to early adopters? They can then purchase our custom
    token with ethers. Then, we can withdraw ethers before changing it to fiat money,
    so we can hire more programmers and rent an office to develop our new cryptocurrency.
    This is the basic idea. Of course, because ICO involves a lot of money, it also
    attracts predators.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**首次代币发行**（**ICO**）的核心。以太坊的货币很有价值。尽管以太币的价格波动，但1个以太币的价值大约是100美元。人们会用真钱购买一些以太币，但不会购买我们的自定义代币。为了使我们的自定义代币有价值，我们首先必须使其有用，或者至少使其看起来有用。但要做到这一点，我们需要资本。那么为什么不将我们的代币（比如60%）出售给早期采用者呢？然后，他们可以用以太币购买我们的自定义代币。然后，我们可以在将其转换为法定货币之前提取以太币，这样我们就可以雇佣更多的程序员并租用办公室来开发我们的新加密货币。这就是基本的想法。当然，因为ICO涉及大量资金，它也会吸引捕食者。
- en: 'This is the crowdsale token smart contract. This is the same as our previous
    ERC20 token smart contract''s source code, but with slight variations. Name this
    smart contract `CrowdSaleToken.vy` and save it inside the `token_project/contracts`
    directory. Refer to the code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/CrowdSaleToken.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/CrowdSaleToken.vy):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是众售代币智能合约。这与我们之前的ERC20代币智能合约源代码相同，但有些许变化。将这个智能合约命名为`CrowdSaleToken.vy`，并保存在`token_project/contracts`目录中。请参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/CrowdSaleToken.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/CrowdSaleToken.vy)：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s discuss this smart contract line by line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行讨论这个智能合约：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We add one event named `Payment` on top of another two events. This event will
    be called when someone pays for the token with ethers:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在另外两个事件之上添加了一个名为`Payment`的事件。当有人用以太币购买代币时，将调用此事件：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We add a couple of new variables, which are `ethBalances`, `beneficiary`, `minFundingGoal`,
    `maxFundingGoal`, `amountRaised`, `deadline`, `price`, `fundingGoalReached`, and `crowdsaleClosed`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些新变量，包括`ethBalances`、`beneficiary`、`minFundingGoal`、`maxFundingGoal`、`amountRaised`、`deadline`、`price`、`fundingGoalReached`和`crowdsaleClosed`。
- en: '`ethBalances` is a variable that''s designed to keep track of how many ethers
    a buyer has spent in this smart contract. We want to keep track of this number
    because we want to refund the ethers if we cannot raise the necessary amount. `beneficiary`
    is a variable that''s used to track who launches this smart contract. This `beneficiary` variable
    is the only account that is able to withdraw the ethers.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ethBalances`是一个变量，用于跟踪买家在这个智能合约中花费了多少以太币。我们想跟踪这个数字，因为如果我们无法筹集到必要的金额，我们想要退还以太币。`beneficiary`是一个用于跟踪谁启动了这个智能合约的变量。这个`beneficiary`变量是唯一能够提取以太币的账户。'
- en: '`minFundingGoal` and `maxFundingGoal` are variables that were designed to make
    sure that the amount that''s raised is greater than the minimum funding goal and
    lower than the maximum funding goal.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`minFundingGoal`和`maxFundingGoal`是设计为确保筹集的金额大于最低筹资目标且低于最高筹资目标的变量。'
- en: '`amountRaised` is a variable that''s designed to track how many ethers we have
    raised in this smart contract.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`amountRaised`是一个变量，用于跟踪在这个智能合约中筹集了多少以太币。'
- en: '`deadline` is a variable  that''s used to track the deadline of this crowdsale
    process.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`deadline`是一个用于跟踪众筹过程截止日期的变量。'
- en: '`price` is how we want to value our digital token in terms of ethers. This
    variable is designed to answer how many coins of our token the buyer can get with
    1 ether.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`price`是我们希望以太币价值我们数字代币的方式。这个变量旨在回答买家用1个以太币可以获得多少个我们的代币。'
- en: '`fundingGoalReached` is a `boolean` variable stating whether our smart contract
    has reached our target.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`fundingGoalReached`是一个布尔变量，表示我们的智能合约是否已经达到了目标。'
- en: '`crowdsaleClosed` is a `boolean` variable stating whether our smart contract
    still receives the buying process. We''ll start from the initialization method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`crowdsaleClosed`是一个布尔变量，表示我们的智能合约是否仍在接收购买过程。我们将从初始化方法开始：'
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The total coin supply in this smart contract is 10,000\. We want to raise at
    least 30 ethers, up to a maximum of 50 ethers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个智能合约中的总代币供应量为10,000。我们希望至少筹集30个以太币，最多筹集50个以太币。
- en: The deadline is set to 100 days from the time when the smart contract is deployed
    on the blockchain. `block.timestamp` is approximately the current time, or the
    time when the block containing this smart contract code is confirmed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 截止日期设置为智能合约部署在区块链上后的100天。`block.timestamp`大致是当前时间，或者包含此智能合约代码的区块确认的时间。
- en: 'The price of 1 coin is set to `0.01` ether. This means that 1 ether can buy
    100 coins of our token. Then, we move into a default function in a smart contract:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 1个代币的价格设定为`0.01`以太币。这意味着1个以太币可以购买100个我们的代币。然后，我们进入智能合约中的默认函数：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is the method that the user can use to buy the token. `__default__` is
    a default, fallback function. If someone does not execute a method on the smart
    contract and pays ethers, this function will be executed. Actually, we don't have
    to use the default function to accept the payment. You can use the standard method,
    just like you have done in previous smart contracts. We simply use the default
    function to explain this concept.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户用来购买代币的方法。`__default__`是一个默认的回退函数。如果有人没有在智能合约上执行方法并支付以太币，将执行此函数。实际上，我们不必使用默认函数来接受付款。您可以使用标准方法，就像您在以前的智能合约中所做的那样。我们只是使用默认函数来解释这个概念。
- en: In this payment method, we ensure that the buyer is not the beneficiary, that
    the crowdsale is still happening, and that the amount that has been raised with
    the ethers sent into this method does not exceed the maximum funding goal of 50
    ethers. Lastly, each purchasing action must be at least 0.01 ether. Then, we increase
    the balance of ethers for this buyer as well as increasing the amount of ethers
    raised. We then check the amount of coins they purchased by dividing the amount
    of ethers by the price of 1 coin.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个付款方法中，我们确保买家不是受益人，众筹仍在进行，并且用以太币发送到此方法的金额不超过50个以太币的最高筹资目标。最后，每次购买行为必须至少为0.01以太币。然后，我们增加该买家的以太币余额，并增加筹集的以太币金额。然后，我们通过将以太币金额除以1个代币的价格来检查他们购买的代币数量。
- en: 'Finally, we have to increase the balance of the token for this buyer and decrease
    the balance of the token for the owner of the smart contract. Don''t forget to
    log this event. Then, we move onto the method where we can check whether we have
    reached our target:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须增加该买家的代币余额，并减少智能合约所有者的代币余额。不要忘记记录此事件。然后，我们进入可以检查是否达到目标的方法：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we make sure that this method can only be executed successfully if the
    deadline has passed. If the amount raised is more than the minimum funding goal,
    we set the `fundingGoalReached` variable to `true`. Then, finally, we set the `crowdsaleClosed` variable to
    `true`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保只有在截止日期过去后才能成功执行此方法。如果筹集的金额超过最低筹资目标，我们将`fundingGoalReached`变量设置为`true`。最后，我们将`crowdsaleClosed`变量设置为`true`。
- en: 'For the sake of simplicity, we only check whether the `block.timestamp` variable
    is larger than the deadline. However, the timestamp in the block could be filled
    with anything the miner likes; it does not have to be the current time that the
    block is confirmed. But, of course, if the miner gave the past timestamp as the
    value to `block.timestamp`, all other miners would reject it. Similarly, if the
    miner gives the future timestamp, which is really far away (for example, a year
    ahead), as the value for `block.timestamp`, all other miners would also reject
    it. To make checking the deadline process more secure, you have to combine it
    with `block.number` to check how many blocks have been confirmed since this smart
    contract launched. Then, we move into the method where the manager of the smart
    contract can withdraw ethers that have accumulated in the smart contract:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们只检查`block.timestamp`变量是否大于截止日期。然而，区块中的时间戳可以填入矿工喜欢的任何内容；它不一定是区块确认时的当前时间。但是，如果矿工将过去的时间戳作为`block.timestamp`的值，所有其他矿工都会拒绝它。同样，如果矿工将未来时间戳（例如，一年后）作为`block.timestamp`的值，所有其他矿工也会拒绝它。为了使截止日期检查过程更安全，您必须将其与`block.number`结合起来，以检查自从智能合约启动以来已确认了多少个区块。然后，我们进入智能合约的管理者可以提取在智能合约中累积的以太币的方法：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `safeWithdrawal` method runs differently, depending on whether the funding
    goal is attained. Inside the preceding method, we make sure that the crowdsale
    is already closed. If the funding goal is not reached, we make sure that every
    buyer can get their ethers back. If the funding goal is reached, then we make
    sure that the beneficiary can withdraw all ethers in the smart contract. The remainder
    of the methods are the same as in the previous smart contract. However, we add
    a number of assertions to make sure that these methods can only be executed after
    the crowdsale is closed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`safeWithdrawal`方法的运行方式不同，取决于是否达到了筹资目标。在上述方法内部，我们确保众筹已经关闭。如果未达到筹资目标，我们确保每个买家都可以取回他们的以太币。如果达到了筹资目标，我们确保受益人可以从智能合约中提取所有以太币。其他方法的剩余部分与先前的智能合约相同。但是，我们添加了一些断言来确保这些方法只能在众筹结束后执行。'
- en: 'The following code block is the test for this crowdsale smart contract. Refer
    to the code file in the following GitLab link for the full code file: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_crowd_sale_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_crowd_sale_token.py):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是对这个众筹智能合约的测试。请参考以下GitLab链接中的代码文件获取完整的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_crowd_sale_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_crowd_sale_token.py)：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Take a look at `test_withdrawal` and `test_refund`, especially these lines:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 特别关注`test_withdrawal`和`test_refund`，尤其是这些行：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Rather than waiting for 100 days, we want to manipulate the clock in the test
    to believe that the deadline has been reached (101 days from now). Consequently,
    we pretend that we have passed 101 days and then we confirm 1 block. Therefore,
    the `block.timestamp` variable inside the smart contract would be 101 days from
    now.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想等待100天，我们想在测试中操纵时钟，使其相信已经到达截止日期（从现在开始的101天）。因此，我们假装已经过去了101天，然后我们确认了1个区块。因此，智能合约内部的`block.timestamp`变量将是从现在开始的101天。
- en: Stable coin
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳定币
- en: You have created a digital token that can be sold autonomously. However, you
    should not restrict yourself to the generic token. You could be more creative
    in your token smart contract by adding more methods to spice up your smart contract.
    What methods you should add are dependent on your smart contract's purpose. The
    token smart contract that is used in a game as currency will have different methods
    to the token smart contract that is used in a supply chain tracking system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经创建了一个可以自主出售的数字代币。但是，您不应该局限于通用代币。您可以通过添加更多方法来使您的代币智能合约更具创意。您应该添加哪些方法取决于您的智能合约的目的。在游戏中用作货币的代币智能合约将具有不同的方法，而在供应链跟踪系统中使用的代币智能合约将具有不同的方法。
- en: Let's create a stable coin smart contract. This is a token smart contract that
    is pegged to fiat money, such as the US dollar. We also want this smart contract
    to be a bank where we, as an owner, can freeze an account.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个稳定币智能合约。这是一个与法定货币（如美元）挂钩的代币智能合约。我们还希望这个智能合约成为一个银行，作为所有者，我们可以冻结账户。
- en: We can base our work on an ERC 20 token smart contract. We just need to add
    three methods—a method to freeze an account, a method to add some coins, and a
    method to throw away some coins.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以基于ERC 20代币智能合约进行工作。我们只需要添加三种方法——一个冻结账户的方法，一个添加代币的方法，以及一个丢弃代币的方法。
- en: 'This is the smart contract. You can refer to the code file in the following
    GitLab link for the full code file: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/StableCoin.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/StableCoin.vy):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是智能合约。您可以参考以下GitLab链接中的代码文件获取完整的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/StableCoin.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/StableCoin.vy)：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s discuss the smart contract line by line:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行讨论智能合约：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We need to add another event for freezing an account action in the preceding
    code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在上述代码中添加另一个事件，用于冻结账户操作。
- en: 'We add two new variables on top of variables from the ERC20 token smart contract,
    which are `frozenBalances` and `owner`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在ERC20代币智能合约的变量之上添加了两个新变量，即`frozenBalances`和`owner`：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`frozenBalances` is a mapping variable to track which accounts have been frozen.
    `owner` is a variable to track the owner of the smart contract.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`frozenBalances`是一个映射变量，用于跟踪已被冻结的账户。`owner`是一个变量，用于跟踪智能合约的所有者。'
- en: 'In this initialization method, we set the `owner` variable as the account that
    launched this smart contract:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始化方法中，我们将`owner`变量设置为启动这个智能合约的账户：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the following method, we make sure that only the owner can call this method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的方法中，我们确保只有所有者可以调用此方法：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then, we set the value of the `frozenBalances` mapping variable. The true value
    means that the account is frozen. Don't forget to call the `Freeze` event.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置了`frozenBalances`映射变量的值。真值表示账户被冻结。不要忘记调用`Freeze`事件。
- en: 'The next method is to increase the coins:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是增加硬币：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We increase the total supply and the balance of the owner's account as well.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加了总供应量和所有者账户的余额。
- en: 'The following method is designed to burn the coins:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的方法旨在销毁硬币：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is similar to the previous method, but its purpose is to decrease the amount
    of coins from the total supply. Why do you want to annihilate coins? There are
    a number of valid reasons for this. Suppose you are tracking US dollars with this
    smart contract. Let's say you have 10,000 US dollars in your pocket. So, the total
    supply in the smart contract is 10,000 (1 coin is pegged to 1 US dollar), but
    one day, USD 2,000 of your USD 10,000 is stolen by a thief. To make sure the smart
    contract is consistent, you burn 2,000 coins with this method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一种方法类似，但其目的是减少总供应量中的硬币数量。你为什么要销毁硬币？有许多有效的原因。假设您正在使用这个智能合约跟踪美元。假设您口袋里有1万美元。因此，智能合约中的总供应量为10,000（1个硬币等于1美元），但有一天，您的10,000美元中有2,000美元被小偷偷走了。为了确保智能合约的一致性，您可以使用这种方法销毁2,000个硬币。
- en: 'The remainder of the methods are exactly the same as under the ERC20 token
    smart contract, with two exceptions: `transfer` and `transferFrom`. We have additional
    assertions in those methods:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法与ERC20代币智能合约下完全相同，只有两个例外：`transfer`和`transferFrom`。在这些方法中，我们有额外的断言：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following code block is the test for this smart contract. You can refer
    to the code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_stable_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_stable_token.py):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是对这个智能合约的测试。您可以参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_stable_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_stable_token.py)：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to create a token on top of Ethereum.
    You used Mist an Ethereum wallet, to deploy the contract and interact with the
    token smart contract. Then, you implemented the ERC 20 standard in creating the
    token smart contract by creating implementations of certain methods. You also
    saw how these standard methods help Mist to recognize your token. Then, you created
    a method to sell tokens for ethers. You put a deadline in this smart contract
    and then you used a time travel method to simulate the expired deadline in the
    test of the smart contract. Finally, you added other methods to freeze and unfreeze
    other accounts. The example you used is a stable coin that pegs coins to real-world
    assets, such as fiat.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何在以太坊上创建代币。您使用了Mist作为以太坊钱包，部署了合约并与代币智能合约进行交互。然后，您通过创建某些方法的实现来实现ERC
    20标准的代币智能合约。您还看到了这些标准方法如何帮助Mist识别您的代币。然后，您创建了一种方法来出售代币以获取以太币。您在这个智能合约中设置了截止日期，然后使用时间旅行方法来模拟智能合约的测试中过期的截止日期。最后，您添加了其他方法来冻结和解冻其他账户。您使用的示例是将硬币与实际资产（如法定货币）挂钩的稳定币。
- en: In the next chapter, you are going to create a cryptocurrency wallet that can
    handle ethers and ERC20 tokens.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将创建一个可以处理以太币和ERC20代币的加密货币钱包。
- en: Further reading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)'
- en: '[https://ethereum.org/token](https://ethereum.org/token)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://ethereum.org/token](https://ethereum.org/token)'
