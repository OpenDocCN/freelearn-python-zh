- en: Using Python to Drive Hardware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 驱动硬件
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Controlling an LED
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制LED
- en: Responding to a button
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应按钮
- en: The controlled shutdown button
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制关机按钮
- en: The GPIO keypad input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPIO键盘输入
- en: Multiplexed color LEDs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多路复用彩色LED
- en: Writing messages using persistence of vision
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视觉暂留原理编写信息
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the key features of a Raspberry Pi computer that sets it apart from most
    other home/office computers is that it has the ability to directly interface with
    other hardware. The **general-purpose input/output** (**GPIO**) pins on the Raspberry
    Pi can control a wide range of low-level electronics, from **light-emitting diodes**
    (**LEDs**) to switches, sensors, motors, servos, and even extra displays.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派电脑的一个关键特性，使其与其他大多数家用/办公电脑区别开来的是，它能够直接与其他硬件进行接口。树莓派上的**通用输入/输出**（**GPIO**）引脚可以控制一系列低级电子设备，从**发光二极管**（**LEDs**）到开关、传感器、电机、伺服机构和甚至额外的显示屏。
- en: This chapter will focus on connecting the Raspberry Pi with some simple circuits
    and getting to grips with using Python to control and respond to the connected
    components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于将树莓派与一些简单的电路连接起来，并掌握使用Python来控制和响应连接组件的方法。
- en: The Raspberry Pi hardware interface consists of 40 pins located along one side
    of the board.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派硬件接口由位于板边一侧的40个引脚组成。
- en: The GPIO pins and their layout will vary slightly according to the particular
    model you have.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO引脚及其布局将根据您所拥有的特定型号略有不同。
- en: The Raspberry Pi 3, Raspberry Pi 2, and Raspberry Pi B+ all have the same 40-pin
    layout.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 3、Raspberry Pi 2和Raspberry Pi B+都拥有相同的40针布局。
- en: The older Raspberry Pi 1 models (nonplus types) have a 26-pin header, which
    is the same as the 1-26 pins of the newer models.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 较早的 Raspberry Pi 1 型号（非plus型号）有一个26针引脚，这与较新型号的1-26针相同。
- en: '![](img/e50c6102-ea75-4379-9ac2-05c5d73b0826.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e50c6102-ea75-4379-9ac2-05c5d73b0826.png)'
- en: Raspberry Pi 2, Raspberry Pi B+, and Raspberry Pi Model Plus GPIO header pins
    (pin functions)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 2、Raspberry Pi B+和Raspberry Pi Model Plus的GPIO引脚（引脚功能）
- en: The layout of the connector is shown in the preceding diagram; the pin numbers
    are shown as seen from pin 1 of the GPIO header.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器的布局显示在先前的图中；引脚编号是从GPIO引脚1处看到的。
- en: '**Pin 1** is at the end that is nearest to the SD card, as shown in the following
    photo:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**引脚1**位于最靠近SD卡的一端，如图所示：'
- en: '![](img/f196e25a-2289-4e35-8cd5-6606c5cb27ee.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f196e25a-2289-4e35-8cd5-6606c5cb27ee.png)'
- en: The Raspberry Pi GPIO header location
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派GPIO引脚位置
- en: Care should be taken when using the GPIO header, since it also includes power
    pins (3V3 and 5 V), as well as **ground** (**GND**) pins. All of the GPIO pins
    can be used as standard GPIO, but several also have special functions; these are
    labeled and highlighted with different colors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPIO引脚时需小心，因为它还包括电源引脚（3V3和5V），以及**地**（**GND**）引脚。所有的GPIO引脚都可以用作标准GPIO，但其中一些也具有特殊功能；这些引脚被标记并用不同颜色突出显示。
- en: It is common for engineers to use a 3V3 notation to specify values in schematics
    in order to avoid using decimal places that could easily be missed (using 33V
    rather than 3.3V would cause severe damage to the circuitry). The same can be
    applied to the values of other components, such as resistors, for example, 1.2K
    ohms can be written as 1K2 ohms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师们通常会在电路图中使用3V3这样的记法来指定值，以避免使用容易被遗漏的小数点（使用33V而不是3.3V会对电路造成严重损坏）。同样的方法也适用于其他组件的值，例如，1.2K欧姆可以写成1K2欧姆。
- en: The **TX** and **RX** pins are used for serial communications, and with the
    aid of a voltage-level converter, information can be transferred via a serial
    cable to another computer or device.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**TX** 和 **RX** 引脚用于串行通信，借助电压等级转换器，信息可以通过串行电缆传输到另一台计算机或设备。'
- en: 'We also have the **SDA** and **SCL** pins, which are able to support a two-wire
    bus communication protocol called **I**²**C** (there are two I²C channels on Raspberry
    Pi 3 and Model Plus boards: **channel 1 ARM**, which is for general use, and **channel
    0 VC**, which is typically used for identifying **hardware attached on top** (**HAT**)
    modules). There are also the **SPI MOSI**, **SPI MISO**, **SPI SCLK**, **SPI CE0**,
    and **SPI CE1** pins, which support another type of bus protocol called **SPI**
    for high-speed data. Finally, we have the **PWM0/1** pin, which allows a **pulse-width
    modulation** signal to be generated, which is useful for servos and generating
    analog signals.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有 **SDA** 和 **SCL** 引脚，它们能够支持一种称为 **I²C** 的双线总线通信协议（在 Raspberry Pi 3 和 Model
    Plus 板上，有两个 I²C 通道：**通道 1 ARM**，用于通用，以及 **通道 0 VC**，通常用于识别 **顶部连接的硬件**（**HAT**）模块）。还有
    **SPI MOSI**、**SPI MISO**、**SPI SCLK**、**SPI CE0** 和 **SPI CE1** 引脚，它们支持另一种称为
    **SPI** 的总线协议，用于高速数据传输。最后，我们还有 **PWM0/1** 引脚，它允许生成 **脉冲宽度调制** 信号，这对于伺服系统和生成模拟信号非常有用。
- en: 'However, we will focus on using just the standard GPIO functions in this chapter.
    The GPIO pin layout is shown in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中我们将专注于仅使用标准的GPIO功能。GPIO引脚布局如图所示：
- en: '![](img/d59a7392-0b90-4ff4-925f-6ba223b41867.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d59a7392-0b90-4ff4-925f-6ba223b41867.png)'
- en: Raspberry Pi GPIO header pins (GPIO.BOARD and GPIO.BCM)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派GPIO引脚头（GPIO.BOARD和GPIO.BCM）
- en: 'The Raspberry Pi Rev 2 (pre-July 2014) has the following differences compared
    to the Raspberry Pi 2 GPIO layout:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Rev 2（2014年7月之前）与Raspberry Pi 2 GPIO布局相比有以下不同之处：
- en: 26-GPIO-pin header (matching the first 26 pins).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 26-GPIO引脚排针（与第一个26个引脚相匹配）。
- en: 'An additional secondary set of eight holes (P5) located next to the pin header.
    The details are as follows:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于引脚头旁边的额外一组八个孔（P5）。具体细节如下：
- en: '![](img/b09b727f-30eb-4aba-a332-fb0c12da3f55.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b09b727f-30eb-4aba-a332-fb0c12da3f55.png)'
- en: Raspberry Pi Rev 2 P5 GPIO header pins
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Rev 2 P5 GPIO 头引脚
- en: 'The original Raspberry Pi Rev 1 (pre-October 2012) has only 26 GPIO pins in
    total, (matching the first 26 pins of the current Raspberry Pi, except for the
    following details:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的Raspberry Pi Rev 1（2012年10月之前）总共只有26个GPIO引脚，（与当前Raspberry Pi的前26个引脚相匹配，除了以下细节：
- en: '![](img/6b1df0d2-c988-41a3-bb88-18def3482504.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b1df0d2-c988-41a3-bb88-18def3482504.png)'
- en: Raspberry Pi Rev 1 GPIO header differences
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Rev 1 GPIO 头部差异
- en: The `RPi.GPIO` library can reference the pins on the Raspberry Pi using one
    of two systems. The numbers shown in the center refer to the physical position
    of the pins, and are also the numbers referenced by the `RPi.GPIO` library when
    in **GPIO.BOARD** mode. The numbers on the outside (**GPIO.BCM**) are the actual
    reference numbers of the physical ports of the processor that indicate which of
    the pins are wired (which is why they are not in any specific order). They are
    used when the mode is set to **GPIO.BCM**, and they allow control of the GPIO
    header pins as well as any peripherals connected to other GPIO lines. This includes
    the LED on the add-on camera on BCM GPIO 4 and the status LED on the board. However,
    this can also include the GPIO lines used for reading/writing to the SD card,
    which would cause serious errors if interfered with.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPi.GPIO` 库可以使用两种系统之一来引用 Raspberry Pi 上的引脚。中间显示的数字代表引脚的物理位置，也是 `RPi.GPIO`
    库在 **GPIO.BOARD** 模式下所引用的数字。外部的数字（**GPIO.BCM**）是处理器物理端口的实际参考编号，它们指示哪些引脚是连接的（这就是为什么它们没有特定的顺序）。当模式设置为
    **GPIO.BCM** 时，它们被用来控制 GPIO 头部引脚以及连接到其他 GPIO 线的任何外围设备。这包括连接到 BCM GPIO 4 的附加摄像头上的
    LED 以及板上的状态 LED。然而，这也可以包括用于读取/写入 SD 卡的 GPIO 线，如果被干扰，将导致严重错误。'
- en: If you use other programming languages to access the GPIO pins, the numbering
    scheme may be different, so it will be helpful if you are aware of the BCM GPIO
    references, which refer to the physical GPIO ports of the processor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用其他编程语言来访问GPIO引脚，编号方案可能不同，因此了解BCM GPIO引用会有所帮助，这些引用指的是处理器的物理GPIO端口。
- en: Be sure to check out the Appendix, *Hardware and Software List*, which lists
    all the items used in this chapter and the places that you can obtain them from.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看附录，*硬件和软件列表*，其中列出了本章中使用的所有物品以及你可以从中获取它们的地方。
- en: Controlling an LED
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制LED
- en: The hardware equivalent of `hello world` is an LED flash, which is a great test
    to ensure that everything is working and that you have wired it correctly. To
    make it a little more interesting, I've suggested using a **red, blue, and green**
    (**RGB**) LED, but feel free to use separate LEDs if that is all you have available.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件上的“hello world”相当于一个LED闪烁，这是一个很好的测试，以确保一切正常工作并且你已经正确地连接了线路。为了让它更有趣，我建议使用一个**红色、蓝色和绿色**（RGB）的LED，但如果这是你唯一可用的LED，也请随意使用。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You will need the following equipment:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下设备：
- en: 4 x DuPont female-to-male patch wires
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 x 杜邦公对母贴片线
- en: Mini breadboard (170 tie points) or a larger one
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型面包板（170个接线点）或更大型的面包板
- en: RGB LED (common cathode)/3 standard LEDs (ideally red, green, and blue)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB LED（共阴极）/3 标准LED（理想情况下为红色、绿色和蓝色）
- en: Breadboard wire (solid core)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板线（实心芯）
- en: 3 x 470 ohm resistors
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 x 470 欧姆电阻
- en: 'Each of the preceding components shouldn''t cost many dollars and can be reused
    for other projects afterwards. The breadboard is a particularly useful item that
    allows you to try out your own circuits without needing to solder them:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每个组件的成本都不应超过几美元，并且在之后的项目中可以重复使用。面包板是一个特别有用的物品，它允许你在不需要焊接的情况下尝试自己的电路：
- en: '![](img/96e27010-2851-4ffb-8b57-4fe8ef3d20b4.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96e27010-2851-4ffb-8b57-4fe8ef3d20b4.png)'
- en: Diagrams of an RGB LED, a standard LED, and an RGB circuit
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED、标准LED和RGB电路的图示
- en: 'The following diagram shows the breadboard circuitry:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了面包板电路：
- en: '![](img/03967de1-5654-44d2-9db7-5d44a5bfa065.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03967de1-5654-44d2-9db7-5d44a5bfa065.png)'
- en: The wiring of an RGB LED/standard LEDs connected to the GPIO header
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到GPIO头部的RGB LED/标准LED的接线
- en: There are several different kinds of RGB LEDs available, so check the datasheet
    of your component to confirm the pin order and type you have. Some are RGB, so
    ensure that you wire accordingly or adjust the `RGB_` pin settings in the code.
    You can also get common anode variants, which will require the anode to be connected
    to 3V3 (GPIO-pin 1) for it to light up (and they will also require `RGB_ENABLE`
    and `RGB_DISABLE` to be set to `0` and `1` `respectively`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有多种不同类型的RGB LED可供选择，因此请检查您组件的数据表以确认您所拥有的引脚顺序和类型。有些是RGB类型的，所以请确保您正确接线或调整代码中的`RGB_`引脚设置。您还可以获得常见的正极版本，这需要将正极连接到3V3（GPIO引脚1）才能点亮（并且它们还需要将`RGB_ENABLE`和`RGB_DISABLE`分别设置为`0`和`1`）。
- en: The breadboard and component diagrams of this book have been created using a
    free tool called **Fritzing** ([www.fritzing.org](http://www.fritzing.org)); it
    is great for planning your own Raspberry Pi projects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的面包板和组件图都是使用一款名为**Fritzing**的免费工具制作的([www.fritzing.org](http://www.fritzing.org))；它非常适合规划您自己的树莓派项目。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the `ledtest.py` script as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `ledtest.py` 脚本如下：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `RPi.GPIO` library will require `sudo` permissions to access the GPIO pin
    hardware, so you will need to run the script using the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RPi.GPIO` 库访问 GPIO 引脚硬件需要 `sudo` 权限，因此您需要使用以下命令来运行脚本：'
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run the script, you should see the red, green, and blue parts of the
    LED (or each LED, if you're using separate ones) light up in turn. If not, double-check
    your wiring or confirm that the LED is working by temporarily connecting the red,
    green, or blue wire to the 3V3 pin (pin 1 of the GPIO header).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行脚本时，你应该看到LED（或如果你使用的是单独的LED，则是每个LED）的红、绿、蓝部分依次点亮。如果没有，请检查你的接线是否正确，或者通过临时将红、绿或蓝线连接到3V3引脚（GPIO引脚的1号引脚）来确认LED是否工作。
- en: The `sudo` command is required for most hardware-related scripts because it
    isn't normal for users to directly control hardware at such a low level. For example,
    setting or clearing a control pin that is part of the SD card controller could
    corrupt data being written to it. Therefore, for security purposes, superuser
    permissions are required to stop programs from using hardware by accident (or
    with malicious intent).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`命令对于大多数与硬件相关的脚本来说是必需的，因为用户通常不会在如此低级别直接控制硬件。例如，设置或清除SD卡控制器的一部分控制引脚可能会损坏正在写入的数据。因此，出于安全考虑，需要超级用户权限以防止程序意外（或恶意意图）使用硬件。'
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To access the GPIO pins using Python, we import the `RPi.GPIO` library, which
    allows direct control of the pins through the module functions. We also require
    the `time` module to pause the program for a set number of seconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python访问GPIO引脚，我们需要导入`RPi.GPIO`库，该库允许通过模块函数直接控制引脚。我们还需要`time`模块来暂停程序，使其暂停设定的时间数秒。
- en: We then define values for the LED wiring and active states (see *Controlling
    the GPIO current* segment in the *There's more...* section of this recipe).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后为LED的布线和激活状态定义值（参见本食谱“更多内容...”部分中的*控制GPIO电流*部分）。
- en: Before the GPIO pins are used by the program, we need to set them up by specifying
    the numbering method—`GPIO.BOARD`—and the direction—`GPIO.OUT` or `GPIO.IN` (in
    this case, we set all the RGB pins to outputs). If a pin is configured as an output,
    we will be able to set the pin state; similarly, if it is configured as an input,
    we will be able to read the pin state.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序使用GPIO引脚之前，我们需要通过指定编号方法—`GPIO.BOARD`—和方向—`GPIO.OUT`或`GPIO.IN`（在这种情况下，我们将所有RGB引脚设置为输出）来设置它们。如果一个引脚被配置为输出，我们将能够设置引脚状态；同样地，如果它被配置为输入，我们将能够读取引脚状态。
- en: Next, we control the pins using `GPIO.ouput()` by stating the number of the
    GPIO pin and the state we want it to be in (`1` = high/on and `0` = low/off).
    We switch each LED on, wait five seconds, and then switch it back off.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用 `GPIO.output()` 函数来控制引脚，指定 GPIO 引脚的编号和我们希望其处于的状态（`1` = 高/开，`0` =
    低/关）。我们依次打开每个 LED，等待五秒钟，然后将其关闭。
- en: Finally, we use `GPIO.cleanup()` to return the GPIO pins back to their original
    default state and release control of the pins for use by other programs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `GPIO.cleanup()` 将 GPIO 引脚恢复到它们原始的默认状态，并释放对引脚的控制权，以便其他程序使用。
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using the GPIO pins on the Raspberry Pi must be done with care since these pins
    are directly connected to the main processor of the Raspberry Pi without any additional
    protection. Caution must be used as any incorrect wiring will probably damage
    the Raspberry Pi processor and cause it to stop functioning altogether.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用树莓派的GPIO引脚时必须小心谨慎，因为这些引脚直接连接到树莓派的主处理器，没有任何额外的保护措施。必须小心操作，因为任何错误的接线都可能损坏树莓派处理器，并导致其完全停止工作。
- en: 'Alternatively, you could use one of the many modules available that plug directly
    into the GPIO header pins (reducing the chance of wiring mistakes):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用许多可直接插入GPIO引脚头部的模块之一（从而降低布线的错误率）：
- en: For example, the Pi-Stop is a simple pre-built LED board that simulates a set
    of traffic lights, designed to be a stepping stone for those who are interested
    in controlling hardware but want to avoid the risk of damaging their Raspberry
    Pi. After the basics have been mastered, it also makes an excellent indicator
    to aid debugging.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Pi-Stop 是一块简单的预构建 LED 板，它模拟了一套交通信号灯，旨在为那些对控制硬件感兴趣但希望避免损坏他们的 Raspberry Pi
    的用户提供一个过渡。在掌握基础知识之后，它也成为一个出色的指示器，有助于调试。
- en: Just ensure that you update the `LED CONFIG` pin references in the `ledtest.py`
    script to reference the pin layout and location used for the hardware you are
    using.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已将 `ledtest.py` 脚本中的 `LED CONFIG` 引脚引用更新为引用您所使用的硬件的引脚布局和位置。
- en: '![](img/74c29f6d-4113-4a2d-b3f1-0efe6f4b73f9.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74c29f6d-4113-4a2d-b3f1-0efe6f4b73f9.png)'
- en: See the Appendix, *Hardware and Software List*, for a list of Raspberry Pi hardware
    retailers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅附录，*硬件和软件列表*，以获取树莓派硬件零售商的列表。
- en: Controlling the GPIO current
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制GPIO电流
- en: Each GPIO pin is only able to handle a certain current before it burns out (a
    maximum of 16 mA from a single pin or 30 mA in total), and similarly, the RGB
    LED should be limited to no more than 100 mA. By adding a resistor before or after
    an LED, we will be able to limit the current that will be passed through it and
    control how bright it is (more current will equal a brighter LED).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GPIO引脚在烧毁之前只能处理一定电流（单个引脚最大为16 mA，总电流为30 mA），同样地，RGB LED也应该限制在不超过100 mA。通过在LED之前或之后添加一个电阻，我们就能限制通过它的电流，并控制其亮度（电流越大，LED越亮）。
- en: Since we may wish to power more than one LED at a time, we typically aim to
    set the current as low as we can get away with while still providing enough power
    to light up the LED.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能希望同时点亮多个LED，我们通常的目标是将电流设置得尽可能低，同时仍然提供足够的电力来点亮LED。
- en: 'We can use Ohm''s law to tell us how much resistance to use to provide a particular
    current. The law is as shown in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用欧姆定律来告诉我们需要使用多少电阻来提供特定的电流。该定律如图所示：
- en: '![](img/a3c149d7-3baf-422d-9168-f80691dd9d82.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3c149d7-3baf-422d-9168-f80691dd9d82.png)'
- en: 'Ohm''s law: The relationship between the current, resistance, and voltage in
    electrical circuits'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 欧姆定律：电流、电阻和电压在电路中的关系
- en: 'We will aim for a minimum current (3 mA) and maximum current (16 mA), while
    still producing a reasonably bright light from each of the LEDs. To get a balanced
    output for the RGB LEDs, I tested different resistors until they provided a near
    white light (when viewed through a card). A 470 ohm resistor was selected for
    each one (your LEDs may differ slightly):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是确保电流最小（3 mA）和最大（16 mA），同时从每个LED中发出足够明亮的光。为了获得RGB LED的平衡输出，我测试了不同的电阻，直到它们提供了接近白色的光（通过卡片观察）。每个LED选择了470欧姆的电阻（你的LED可能略有不同）：
- en: '![](img/6ac65729-679f-4038-87ab-1b3c1043b09a.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ac65729-679f-4038-87ab-1b3c1043b09a.png)'
- en: Resistors are needed to limit the current that passes through the LEDs
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用电阻来限制通过LED的电流
- en: 'The voltage across the resistor is equal to the GPIO voltage (**Vgpio** = 3.3V)
    minus the voltage drop on the particular LED (**Vfwd**); we can then use this
    resistance to calculate the current used by each of the LEDs, as shown in the
    following formulas:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻两端的电压等于GPIO电压（**Vgpio** = 3.3V）减去特定LED上的电压降（**Vfwd**）；然后我们可以利用这个电阻来计算每个LED所使用的电流，如下公式所示：
- en: '![](img/86a42336-dc5c-4e66-9a97-1a8116abf611.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86a42336-dc5c-4e66-9a97-1a8116abf611.png)'
- en: We can calculate the current drawn by each of the LEDs
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算每个LED所吸取的电流
- en: Responding to a button
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应按钮
- en: Many applications using the Raspberry Pi require that actions are activated
    without requiring a keyboard and screen to be attached to it. The GPIO pins provide
    an excellent way for the Raspberry Pi to be controlled by your own buttons and
    switches without a mouse/keyboard and screen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多使用树莓派的程序都需要在不连接键盘和屏幕的情况下激活动作。GPIO引脚为树莓派通过您自己的按钮和开关进行控制提供了一种极好的方式，无需鼠标/键盘和屏幕。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You will need the following equipment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下设备：
- en: 2 x DuPont female-to-male patch wires
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 杜邦公对母贴片线
- en: Mini breadboard (170 tie points) or a larger one
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型面包板（170个接线点）或更大型的面包板
- en: Push-button switch (momentary close) or a wire connection to make/break the
    circuit
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮开关（瞬时闭合）或通过电线连接来闭合/断开电路
- en: Breadboard wire (solid core)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板线（实心芯线）
- en: 1K ohm resistor
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1K欧姆电阻
- en: 'The switches are as shown in the following diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 开关的配置如图所示：
- en: '![](img/327bd9b0-47ff-4ca7-b466-fbf8ac361c4f.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/327bd9b0-47ff-4ca7-b466-fbf8ac361c4f.png)'
- en: The push-button switch and other types of switch
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮开关和其他类型的开关
- en: The switches used in the following examples are **single-pole, single-throw**
    (**SPST**), momentary close, push-button switches. **Single pole** (**SP**) means
    that there is one set of contacts that makes a connection. In the case of the
    push switch used here, the legs on each side are connected together with a single-pole
    switch in the middle. A **double-pole** (**DP**) switch acts just like a SP switch,
    except that the two sides are separated electrically, allowing you to switch two
    separate components on/off at the same time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中使用的开关是**单刀单掷**（**SPST**），瞬时闭合，按钮开关。**单刀**（**SP**）意味着有一组触点可以建立连接。在本例中使用的推开关的情况下，每侧的腿通过中间的单刀开关连接在一起。**双刀**（**DP**）开关的作用就像一个SP开关，只不过两侧在电气上是分离的，允许你同时切换两个独立组件的开启/关闭。
- en: '**Single throw** (**ST**) means the switch will make a connection with just
    one position; the other side will be left open. **Double throw** (**DT**) means
    both positions of the switch will connect to different parts.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**单掷**（**ST**）表示开关只会与一个位置建立连接；另一侧将保持断开。**双掷**（**DT**）表示开关的两个位置都会连接到不同的部分。'
- en: '**Momentary close** means that the button will close the switch when pressed
    and automatically open it when released. A **latched** push-button switch will
    remain closed until it is pressed again.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**瞬间关闭**意味着按钮在被按下时会关闭开关，并在释放时自动打开。一个**锁定**的按钮开关将保持关闭状态，直到再次被按下。'
- en: Trying a speaker or headphone with Raspberry Pi
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用树莓派连接扬声器或耳机
- en: '![](img/b945e963-5897-43c3-84f4-c75001fb73c6.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b945e963-5897-43c3-84f4-c75001fb73c6.png)'
- en: The layout of the button circuit
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮电路的布局
- en: We will use sound in this example, so you will also need speakers or headphones
    attached to the audio socket of the Raspberry Pi.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用声音，因此您还需要将扬声器或耳机连接到树莓派的音频插孔。
- en: 'You will need to install a program called `flite` using the following command,
    which will let us make the Raspberry Pi talk:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用以下命令安装名为 `flite` 的程序，这将使我们能够让树莓派说话：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After it has been installed, you can test it with the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用以下命令进行测试：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If it is a little too quiet (or too loud), you can adjust the volume (0-100
    percent) using the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声音有点太安静（或者太响），你可以使用以下命令来调整音量（0-100 百分比）：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the `btntest.py` script as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `btntest.py` 脚本如下：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As in the previous recipe, we set up the GPIO pin as required, but this time
    as an input, and we also enable the internal pull-up resistor (see *Pull-up and
    pull-down resistor circuits* in the *There''s more...* section of this recipe
    for more information) using the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一道菜谱中所述，我们按照要求设置了GPIO引脚，但这次将其设置为输入模式，并且我们还启用了内部上拉电阻（有关更多信息，请参阅本菜谱“更多内容...”部分的*上拉和下拉电阻电路*），使用以下代码：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the GPIO pin is set up, we create a loop that will continuously check
    the state of `BTN` using `GPIO.input()`. If the value returned is `false`, the
    pin has been connected to 0V (ground) through the switch, and we will use `flite`
    to count out loud for us each time the button is pressed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好GPIO引脚后，我们创建一个循环，该循环将不断使用`GPIO.input()`检查`BTN`的状态。如果返回的值是`false`，则表示引脚通过开关连接到了0V（地），每次按钮被按下时，我们将使用`flite`为我们大声计数。
- en: Since we have called the main function from within a `try`/`finally` condition,
    it will still call `GPIO.cleanup()` even if we close the program using *Ctrl*
    + *Z*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`try`/`finally`条件内部调用了主函数，即使我们使用*Ctrl* + *Z*关闭程序，它仍然会调用`GPIO.cleanup()`。
- en: We use a short delay in the loop; this ensures that any noise from the contacts
    on the switch is ignored. This is because when we press the button, there isn't
    always perfect contact as we press or release it, and it may produce several triggers
    if we press it again too quickly. This is known as **software debouncing**; we
    ignore the bounce in the signal here.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在循环中使用短暂的延迟；这确保了开关接触上的任何噪音都被忽略。这是因为当我们按下按钮时，并不总是能够完美接触，当我们按下或释放它时，如果再次按下得太快，可能会产生几个触发信号。这被称为**软件去抖动**；我们在这里忽略信号的抖动。
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Raspberry Pi GPIO pins must be used with care; voltages used for inputs
    should be
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 的 GPIO 引脚必须谨慎使用；用于输入的电压应该是
- en: within specific ranges, and any current drawn from them should be minimized
    using
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定范围内，并且从它们中抽取的任何电流都应该被最小化使用
- en: protective resistors.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 保护电阻。
- en: Safe voltages
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全电压
- en: We must ensure that we only connect inputs that are between 0 (ground) and 3V3\.
    Some processors use voltages between 0V and 5V, so extra components are required
    to interface safely with them. Never connect an input or component that uses 5V
    unless you are certain it is safe, or you will damage the GPIO ports of the Raspberry
    Pi.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保我们只连接介于0（地线）和3V3之间的输入。一些处理器使用0V到5V之间的电压，因此需要额外的组件才能安全地与它们接口。除非你确定它是安全的，否则不要连接使用5V的输入或组件，否则你会损坏树莓派的GPIO端口。
- en: Pull-up and pull-down resistor circuits
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉上和下拉电阻电路
- en: The previous code sets the GPIO pins to use an internal pull-up resistor. Without
    a pull-up resistor (or pull-down resistor) on the GPIO pin, the voltage is free
    to float somewhere between 3V3 and 0V, and the actual logical state remains undetermined
    (sometimes 1 and sometimes 0).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将GPIO引脚设置为使用内部上拉电阻。如果没有在GPIO引脚上使用上拉电阻（或下拉电阻），电压将在3V3和0V之间自由浮动，实际的逻辑状态将无法确定（有时为1，有时为0）。
- en: Raspberry Pi's internal pull-up resistors are 50K ohm-65K ohm, and the pull-down
    resistors are 50K ohm-65K ohm. External pull-up/pull-down resistors are often
    used in GPIO circuits (as shown in the following diagram), typically using 10K
    ohm or larger for similar reasons (giving a very small current draw when they
    are not active).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派的内部上拉电阻为50K欧姆-65K欧姆，下拉电阻也是50K欧姆-65K欧姆。在GPIO电路中（如下所示图），通常使用10K欧姆或更大的外部上拉/下拉电阻，出于类似的原因（当它们不活跃时，电流消耗非常小）。
- en: 'A pull-up resistor allows a small amount of current to flow through the GPIO
    pin and will provide a high voltage when the switch isn''t pressed. When the switch
    is pressed, the small current is replaced by the larger one flowing to 0V, so
    we get a low voltage on the GPIO pin instead. The switch is active low and logic
    0 when pressed. It works as shown in the following diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 拉伸电阻允许少量电流通过GPIO引脚，当开关未被按下时，将提供高电压。当按下开关时，小电流被流向0V的大电流所取代，因此GPIO引脚上得到的是低电压。开关在按下时为低电平，逻辑0。其工作原理如下图中所示：
- en: '![](img/47dd205d-c592-49ae-b43b-c7edc60236e8.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47dd205d-c592-49ae-b43b-c7edc60236e8.png)'
- en: A pull-up resistor circuit
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 拉伸电阻电路
- en: 'Pull-down resistors work in the same way, except the switch is active high
    (the GPIO pin is logic 1 when pressed). It works as shown in the following diagram:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 拉下电阻器的工作原理相同，只是开关是高电平激活（当按下时GPIO引脚为逻辑1）。其工作原理如图所示：
- en: '![](img/bc223b08-57bc-41a4-ba6e-0f12573ca47c.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc223b08-57bc-41a4-ba6e-0f12573ca47c.png)'
- en: A pull-down resistor circuit
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拉下拉电阻电路
- en: Protection resistors
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护电阻
- en: 'In addition to the switch, the circuit includes a resistor in series with the
    switch to protect the GPIO pin, as shown in the following diagram:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开关之外，电路还包括一个与开关串联的电阻，以保护GPIO引脚，如下所示图示：
- en: '![](img/6e8ea49d-ab35-4ac6-bfc0-68b17642fcae.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e8ea49d-ab35-4ac6-bfc0-68b17642fcae.png)'
- en: A GPIO protective current-limiting resistor
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个GPIO保护限流电阻
- en: The purpose of the protection resistor is to protect the GPIO pin if it is accidentally
    set as an output rather than an input. Imagine, for instance, that we have our
    switch connected between the GPIO and ground. Now the GPIO pin is set as an output
    and switched on (driving it to 3V3) as soon as we press the switch, without a
    resistor present, the GPIO pin will be directly connected to 0V. The GPIO will
    still try to drive it to 3V3; this will cause the GPIO pin to burn out (since
    it will use too much current to drive the pin to the high state). If we use a
    1K ohm resistor here, the pin is able to be driven high using an acceptable amount
    of current (I = V/R = 3.3/1K = 3.3 mA).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 保护电阻的作用是在GPIO引脚意外设置为输出而不是输入时对其进行保护。想象一下，例如，我们的开关连接在GPIO和地之间。现在GPIO引脚被设置为输出并打开（驱动它到3V3），当我们按下开关时，如果没有电阻，GPIO引脚将直接连接到0V。GPIO仍然会尝试将其驱动到3V3；这将导致GPIO引脚烧毁（因为它将使用过多的电流来驱动引脚到高电平状态）。如果我们在这里使用一个1K欧姆的电阻，引脚就能够使用可接受的电流量被驱动到高电平（I
    = V/R = 3.3/1K = 3.3 mA）。
- en: A controlled shutdown button
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个受控的关机按钮
- en: The Raspberry Pi should always be shut down correctly to avoid the SD card being
    corrupted (by losing power while performing a write operation to the card). This
    can pose a problem if you don't have a keyboard or screen connected (you might
    be running an automated program or controlling it remotely over a network and
    forget to turn it off) as you can't type the command or see what you are doing.
    By adding our own buttons and LED indicator, we can easily command a shutdown
    and reset, and then start up again to indicate when the system is active.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 应始终正确关机，以避免 SD 卡在执行写入操作时因断电而损坏。如果你没有连接键盘或屏幕（你可能正在运行自动化程序或通过网络远程控制它并忘记关闭），这可能会造成问题，因为你无法输入命令或看到你在做什么。通过添加我们自己的按钮和
    LED 指示灯，我们可以轻松地发出关机和重置命令，然后再次启动以指示系统何时处于活动状态。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You will need the following equipment:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下设备：
- en: 3 x DuPont female-to-male patch wires
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 x 杜邦公对母贴片线
- en: Mini breadboard (170 tie points) or a larger one
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型面包板（170个接线点）或更大型的面包板
- en: Push-button switch (momentary close)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮式开关（瞬时闭合）
- en: General-purpose LED
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用LED
- en: 2 x 470 ohm resistors
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 470欧姆电阻
- en: Breadboard wire (solid core)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板线（实心线）
- en: 'The entire layout of the shutdown circuit will look as shown in the following
    figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 关断电路的整体布局将如图所示：
- en: '![](img/1940ff02-9a95-429b-a649-2eeeaa0497ae.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1940ff02-9a95-429b-a649-2eeeaa0497ae.png)'
- en: The controlled shutdown circuit layout
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 控制关机电路布局
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the `shtdwn.py` script as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤创建 `shtdwn.py` 脚本：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To get this script to run automatically (once we have tested it), we can place
    the script in the `~/bin` (we can use `cp` instead of `mv` if we just want to
    copy it) and add it to `crontab` with the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使此脚本自动运行（一旦我们测试过它），我们可以将脚本放置在`~/bin`目录下（如果我们只想复制它，可以使用`cp`代替`mv`）并使用以下代码将其添加到`crontab`：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the end of the file, we add the following code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾，我们添加以下代码：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This time, when we set up the GPIO pin, we define the pin connected to the shutdown
    button as an input and the pin connected to the LED as an output. We turn the
    LED on to indicate that the system is running.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们设置 GPIO 引脚时，我们将连接到关机按钮的引脚定义为输入，将连接到 LED 的引脚定义为输出。我们打开 LED 以指示系统正在运行。
- en: By setting the `DEBUG` flag to `True`, we can test the functionality of our
    script without causing an actual shutdown (by reading the terminal messages);
    we just need to ensure that we set `DEBUG` to `False` when using the script for
    real.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`DEBUG`标志设置为`True`，我们可以在不实际关闭的情况下测试脚本的功能（通过读取终端消息）；我们只需确保在使用脚本进行实际操作时将`DEBUG`设置为`False`即可。
- en: We enter a `while` loop and check the pin every second to see whether the GPIO
    pin is set to `LOW` (that is, to check whether the switch has been pressed); if
    so, we enter the `doShutdown()` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入一个`while`循环，每秒检查一次引脚，看GPIO引脚是否设置为`LOW`（即检查是否按下了开关）；如果是，我们进入`doShutdown()`函数。
- en: The program will wait for three seconds and then test again to see whether the
    button is still being pressed. If the button is no longer being pressed, we return
    to the previous `while` loop. However, if it is still being pressed after three
    seconds, the program will flash the LED and trigger the shutdown (and also provide
    an audio warning using `flite`).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将等待三秒钟，然后再次测试以查看按钮是否仍在被按下。如果按钮不再被按下，我们将返回到之前的`while`循环。然而，如果在三秒后按钮仍然被按下，程序将闪烁LED并触发关机（并且使用`flite`提供音频警告）。
- en: When we are happy with how the script is operating, we can disable the `DEBUG`
    flag (by setting it to `False`) and add the script to `crontab`. `crontab` is
    a special program that runs in the background and allows us to schedule (at specific
    times, dates, or periodically) programs and actions when the system is started
    (`@reboot`). This allows the script to be started automatically every time the
    Raspberry Pi is powered up. When we press and hold the shutdown button for more
    than three seconds, it safely shuts down the system and enters a low power state
    (the LED switches off just before this, indicating that it is safe to remove the
    power shortly after). To restart the Raspberry Pi, we briefly remove the power;
    this will restart the system, and the LED will light up when the Raspberry Pi
    has loaded.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对脚本的运行情况感到满意时，我们可以禁用`DEBUG`标志（将其设置为`False`）并将脚本添加到`crontab`。`crontab`是一个特殊的程序，它在后台运行，并允许我们在系统启动时（在特定时间、日期或周期性地）安排程序和动作（`@reboot`）。这允许脚本在每次树莓派开机时自动启动。当我们按下并保持关机按钮超过三秒钟时，它会安全地关闭系统并进入低功耗状态（在此之前的LED灯熄灭，表示可以在稍后安全地移除电源）。要重启树莓派，我们短暂地移除电源；这将重启系统，当树莓派加载完成后，LED灯会亮起。
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can extend this example further using the reset header by adding extra functionality
    and making use of additional GPIO connections (if available).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用重置头进一步扩展这个示例，通过添加额外功能并利用额外的GPIO连接（如果可用）。
- en: Resetting and rebooting Raspberry Pi
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置和重启树莓派
- en: The Raspberry Pi has holes for mounting a reset header (marked **RUN** on the
    Raspberry Pi 3/2 and **P6** on the Raspberry Pi 1 Model A and Model B Rev 2).
    The reset pin allows the device to be reset using a button rather than removing
    the micro USB connector each
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派上设有用于安装复位跳线的孔（在树莓派 3/2 上标记为**RUN**，在树莓派 1 型号 A 和型号 B Rev 2 上标记为**P6**）。复位引脚允许通过按钮来重置设备，而不是每次都需要拔掉微型
    USB 连接器。
- en: 'time to cycle the power:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 周转电力时间：
- en: '![](img/458dc851-ae96-414c-bb35-ea425a7fbd96.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/458dc851-ae96-414c-bb35-ea425a7fbd96.png)'
- en: Raspberry Pi reset headers - on the left, Raspberry Pi Model A/B (Rev2), and
    on the right, Raspberry Pi 3
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派重置引脚 - 在左侧，树莓派型号A/B（Rev2），在右侧，树莓派3
- en: 'To make use of it, you will need to solder a wire or pin header to the Raspberry
    Pi and connect a button to it (or briefly touch a wire between the two holes each
    time). Alternatively, we can extend our previous circuit, as shown in the following
    diagram:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，您需要将一根电线或引脚头焊接在树莓派上，并将一个按钮连接到它（或者每次短暂触摸两个孔之间的电线）。或者，我们可以扩展我们之前的电路，如下面的图所示：
- en: '![](img/6715c947-d675-486c-b7c1-ff809307cbe9.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6715c947-d675-486c-b7c1-ff809307cbe9.png)'
- en: The controlled shutdown circuit layout and reset button
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 控制关机电路布局和复位按钮
- en: We can add this extra button to our circuit, which can be connected to the reset
    header (this is the hole nearest the middle on the Raspberry Pi 3 or closest to
    the edge on other models). This pin, when temporarily pulled low by connecting
    to ground (such as the hole next to it or by another ground point, such as pin
    6 of the GPIO header), will reset the Raspberry Pi and allow it to boot up again
    following a shutdown.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向电路中添加这个额外的按钮，该按钮可以连接到复位引脚头（这是在Raspberry Pi 3上靠近中间的孔，在其他型号上则靠近边缘）。当这个引脚通过连接到地（例如旁边的孔或另一个地线点，如GPIO引脚头的6号引脚）临时被拉低时，它将重置Raspberry
    Pi，并允许它在关机后再次启动。
- en: Adding extra functions
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加额外功能
- en: Since we now have the script monitoring the shutdown button all the time, we
    can add extra buttons/switches/jumpers to be monitored at the same time. This
    will allow us to trigger specific programs or set up particular states just by
    changing the inputs. The following example allows us to easily switch between
    automatic DHCP networking (the default networking setup) and using a direct IP
    address, as used in the *Networking directly to a laptop or computer* recipe of
    [Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml), *Getting Started with
    a Raspberry Pi 3 Computer*, for direct LAN connections.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有脚本持续监控关机按钮，我们可以添加额外的按钮/开关/跳线同时进行监控。这将使我们能够通过改变输入来触发特定的程序或设置特定的状态。以下示例允许我们轻松地在自动DHCP网络（默认网络设置）和使用直接IP地址之间切换，正如在[第1章](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml)，“使用Raspberry
    Pi 3计算机入门”中*直接连接到笔记本电脑或计算机*的食谱中所述，用于直接LAN连接。
- en: 'Add the following components to the previous circuit:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下组件添加到之前的电路中：
- en: A 470 ohm resistor
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个470欧姆的电阻
- en: Two pin headers with a jumper connector (or, optionally, a switch)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个带有跳线连接器（或可选的开关）的引脚头
- en: Breadboard wire (solid core)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板线（实心芯）
- en: 'After adding the preceding components, our controlled shutdown circuit now
    looks as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了前面的组件之后，我们的控制关机电路现在看起来如下所示：
- en: '![](img/66c0e8be-1385-478a-be3c-d584f60cef5f.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66c0e8be-1385-478a-be3c-d584f60cef5f.png)'
- en: The controlled shutdown circuit layout, reset button, and jumper pins
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 控制关机电路布局、复位按钮和跳线引脚
- en: 'In the previous script, we add an additional input to detect the status of
    the `LAN_SWA` pin (the jumper pins we added to the circuit) using the following
    code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的脚本中，我们添加了一个额外的输入来检测`LAN_SWA`引脚的状态（我们添加到电路中的跳线引脚）使用以下代码：
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Ensure that it is set up as an input (with a pull-up resistor) in the `gpio_setup()`
    function using the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`gpio_setup()`函数中将它设置为输入（带有上拉电阻）使用以下代码：
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new function to switch between the LAN modes and read out the new IP
    address. The `doChangeLAN()` function checks whether the status of the `LAN_SWA`
    pin has changed since the last call, and if so, it sets the network adapter to
    DHCP or sets the direct LAN settings accordingly (and uses `flite` to speak the
    new IP setting, if available). Finally, the LAN being set for direct connection
    causes the LED to flash slowly while that mode is active. Use the following code
    to do this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新功能以在局域网模式之间切换并读取新的IP地址。`doChangeLAN()` 函数检查自上次调用以来 `LAN_SWA` 引脚的状态是否已更改，如果是，则将网络适配器设置为DHCP或相应地设置直接局域网设置（如果可用，则使用
    `flite` 语音新IP设置）。最后，当设置为直接连接时，该模式激活期间LED会缓慢闪烁。使用以下代码来完成此操作：
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add another function, `flashled()`, which will just toggle the state of the
    LED each time it is called. The code for this function is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个函数，`flashled()`，每次调用时只会切换LED的状态。该函数的代码如下：
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we adjust the main loop to also call `doChangeLAN()` and use the result
    to decide whether we call `flashled()` using `ledon` to keep track of the LED''s
    previous state each time. The `main()` function should now be updated as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将主循环调整为同时调用 `doChangeLAN()` 并使用其结果来决定是否使用 `ledon` 调用 `flashled()` 以跟踪每次
    LED 的先前状态。现在应将 `main()` 函数更新如下：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The GPIO keypad input
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO按键输入
- en: We have seen how we can monitor inputs on the GPIO to launch applications and
    control the Raspberry Pi; however, sometimes we need to control third-party programs.
    Using the `uInput` library, we can emulate key presses from a keyboard (or even
    mouse movement) to control any program using our own custom hardware.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何通过GPIO监控输入来启动应用程序和控制树莓派；然而，有时我们需要控制第三方程序。使用`uInput`库，我们可以模拟键盘（甚至鼠标移动）的按键操作，从而通过我们自己的定制硬件来控制任何程序。
- en: For more information about using `uInput`, visit [http://tjjr.fi/sw/python-uinput/](http://tjjr.fi/sw/python-uinput/).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解有关使用 `uInput` 的更多信息，请访问 [http://tjjr.fi/sw/python-uinput/](http://tjjr.fi/sw/python-uinput/).
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Perform the following steps to install `uInput`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以安装 `uInput`：
- en: First, we need to download `uInput`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要下载 `uInput`。
- en: 'You will need to download the `uInput` Python library from GitHub (~50 KB)
    using the following commands:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '您需要使用以下命令从GitHub下载`uInput` Python库（约50 KB）:'
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The library will unzip to a directory called `python-uinput-master`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆将解压到一个名为 `python-uinput-master` 的目录中。
- en: 'Once completed, you can remove the ZIP file using the following command:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，您可以使用以下命令删除ZIP文件：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Install the required packages using the following commands (if you have installed
    them already, the `apt-get` command will ignore them):'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装所需的软件包（如果您已经安装了它们，`apt-get` 命令将忽略它们）：
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compile and install `uInput` using the following commands:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译和安装 `uInput`：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we load the new `uinput` kernel module using the following command:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令加载新的`uinput`内核模块：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To ensure it is loaded upon startup, we can add `uinput` to the `modules` file
    using the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它在启动时加载，我们可以使用以下命令将`uinput`添加到`modules`文件中：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Put `uinput` on a new line in the file and save it (*Ctrl* + *X*, *Y*).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中把`uinput`放在新的一行，并保存它（*Ctrl* + *X*, *Y*）。
- en: 'Create the following circuit using the following equipment:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下设备创建以下电路：
- en: Breadboard (half-sized or larger)
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板（半尺寸或更大）
- en: 7 x DuPont female-to-male patch wires
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7 x 杜邦公对母贴片线
- en: Six push buttons
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个按钮
- en: 6 x 470 ohm resistors
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个470欧姆电阻
- en: Breadboarding wire (solid core)
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板布线（实心线）
- en: '![](img/3d2b7fcf-7078-441c-8d25-a2ece8737c81.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d2b7fcf-7078-441c-8d25-a2ece8737c81.png)'
- en: GPIO keypad circuit layout
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO键盘电路布局
- en: 'The keypad circuit can also be built into a permanent circuit by soldering
    the components into a Vero prototype board (also known as a stripboard), as shown
    in the following photo:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘电路也可以通过将元件焊接到一个Vero原型板（也称为条形板）上而构建成一个永久电路，如下面的照片所示：
- en: '![](img/5f5f6c94-8411-4fad-b732-34157090a0a5.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f5f6c94-8411-4fad-b732-34157090a0a5.png)'
- en: GPIO keypad Pi hardware module
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO键盘Pi硬件模块
- en: This circuit is available as a solder-yourself kit from [PiHardware.com](http://pihardware.com/).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此电路可作为自焊套件从 [PiHardware.com](http://pihardware.com/) 购得。
- en: 'Connect the circuit to the Raspberry Pi GPIO pins by matching the appropriate
    buttons with the appropriate pins, as shown in the following table:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电路连接到树莓派的GPIO引脚，通过将相应的按钮与相应的引脚匹配，如下表所示：
- en: '|  | **Button** | **GPIO pin** |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|  | **按钮** | **GPIO引脚** |'
- en: '| GND |  | 6 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| GND |  | 6 |'
- en: '| v | B_DOWN | 22 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| v | B_DOWN | 22 |'
- en: '| < | B_LEFT | 18 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| < | B_LEFT | 18 |'
- en: '| ^ | B_UP | 15 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| ^ | B_UP | 15 |'
- en: '| > | B_RIGHT | 13 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| > | B_RIGHT | 13 |'
- en: '| 1 | B_1 | 11 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 1 | B_1 | 11 |'
- en: '| 2 | B_2 | 7 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 2 | B_2 | 7 |'
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a `gpiokeys.py` script as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `gpiokeys.py` 脚本，如下所示：
- en: '[PRE21]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we import `uinput` and define the wiring of the keypad buttons. For each
    of the buttons in `BTN`, we enable them as inputs, with internal pull-ups enabled.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`uinput`并定义键盘按钮的接线。对于`BTN`中的每个按钮，我们将其设置为输入，并启用内部上拉电阻。
- en: Next, we set up `uinput`, defining the keys we want to emulate and adding them
    to the `uinput.Device()` function. We wait a few seconds to allow `uinput` to
    initialize, set the initial button and key states, and start our `main` loop.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置`uinput`，定义我们想要模拟的按键并将它们添加到`uinput.Device()`函数中。我们等待几秒钟以允许`uinput`初始化，设置初始按钮和按键状态，并启动我们的`main`循环。
- en: 'The `main` loop is split into two sections: the first section checks through
    the buttons and records the states in `btn_state`, and the second section compares
    the `btn_state` with the current `key_state` array. This way, we can detect a
    change in `btn_state` and call `device.emit()` to toggle the state of the key.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环分为两个部分：第一部分检查按钮并记录状态到`btn_state`中，第二部分将`btn_state`与当前的`key_state`数组进行比较。这样，我们可以检测到`btn_state`的变化并调用`device.emit()`来切换按键的状态。
- en: To allow us to run this script in the background, we can run it with `&`, as
    shown in the
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够在后台运行这个脚本，我们可以通过使用`&`来运行它，如下所示：
- en: 'following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `&` character allows the command to run in the background, so we can continue
    with the command line to run other programs. You can use `fg` to bring it back
    to the foreground, or `%1`, `%2`, and so on if you have several commands running.
    Use `jobs` to get a list.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`字符允许命令在后台运行，因此我们可以继续使用命令行来运行其他程序。你可以使用`fg`将其调回前台，或者如果你有多个命令正在运行，可以使用`%1`、`%2`等等。使用`jobs`来获取列表。'
- en: You can even put a process/program on hold to get to Command Prompt by pressing
    *Ctrl* + *Z* and then resume it with `bg` (which will let it run in the background).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过按*Ctrl* + *Z*将进程/程序挂起，然后使用`bg`（这将允许它在后台运行）来恢复它。
- en: You can test the keys using the game created in the *Creating an overhead scrolling
    game* recipe in [Chapter 5](d795b1aa-9d5e-4ad6-8352-600d547f0af3.xhtml), *Creating
    Games and Graphics*, which you can now control using your GPIO directional pad.
    Don't forget that if you are connecting to the Raspberry Pi remotely, any key
    presses will only be active on the locally connected screen.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用在[第5章](d795b1aa-9d5e-4ad6-8352-600d547f0af3.xhtml)“创建滚动游戏”中创建的游戏来测试按键，该章节位于“创建游戏和图形”部分，您现在可以使用GPIO方向垫来控制它。别忘了，如果您是通过远程连接到树莓派，那么任何按键操作都只会激活本地连接的屏幕。
- en: There's more...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can do more using `uinput` to provide hardware control for other programs,
    including those that require mouse input.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `uinput` 为其他程序提供硬件控制，包括那些需要鼠标输入的程序。
- en: Generating other key combinations
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成其他密钥组合
- en: 'You can create several different key mappings in your file to support different
    programs. For instance, the `events_z80` key mapping would be useful for a spectrum
    emulator, such as **Fuse** (browse to [http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi](http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi)
    for more details). The `events_omx` key mappings are suitable for controlling
    video played through the OMXPlayer using the following command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的文件中创建几个不同的键映射来支持不同的程序。例如，`events_z80` 键映射对于模拟器，如 **Fuse**（浏览至 [http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi](http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi)
    获取更多详情）非常有用。`events_omx` 键映射适合通过以下命令控制通过 OMXPlayer 播放的视频：
- en: '[PRE23]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can get a list of keys supported by `omxplayer` by using the `-k` parameter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `-k` 参数来获取 `omxplayer` 支持的键列表。
- en: 'Replace the line that defines the `events` list with a new key mapping, and
    select different ones by assigning them to events using the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将定义`events`列表的行替换为新的键映射，并通过以下代码将不同的映射分配给事件：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can find all the `KEY` definitions in the `input.h` file; you can view
    it using the `less` command (press *Q* to exit), as shown in the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`input.h`文件中找到所有的`KEY`定义；你可以使用`less`命令查看它（按*Q*键退出），如下所示命令：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Emulating mouse events
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟鼠标事件
- en: 'The `uinput` library can emulate mouse and joystick events, as well as keyboard
    presses. To use the buttons to simulate a mouse, we can adjust the script to use
    mouse events (as well as defining `mousemove` to set the step size of the movement)
    using the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`uinput` 库可以模拟鼠标和游戏手柄事件，以及键盘按键。要使用按钮模拟鼠标，我们可以调整脚本以使用鼠标事件（以及定义 `mousemove` 来设置移动的步长）使用以下代码：'
- en: '[PRE26]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need to modify the button handling to provide continuous movement,
    as we don''t need to keep track of the state of the keys for the mouse. To do
    so, use the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改按钮处理以提供连续移动，因为我们不需要跟踪鼠标按键的状态。为此，请使用以下代码：
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Multiplexed color LEDs
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多路复用彩色LED
- en: The next example in this chapter demonstrates that some seemingly simple hardware
    can produce some impressive results if controlled with software. For this, we
    will go back to using RGB LEDs. We will use five RGB LEDs that are wired so that
    we only need to use eight GPIO pins to control their red, green, and blue elements
    using a method called **hardware multiplexing** (see the *Hardware multiplexing*
    subsection in the *There's more...* section of this recipe).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一个示例演示了，如果用软件控制，一些看似简单的硬件可以产生一些令人印象深刻的结果。为此，我们将回到使用RGB LED。我们将使用五个RGB LED，它们被连接得只需要使用八个GPIO引脚，通过一种称为**硬件复用**的方法来控制它们的红、绿和蓝元素（参见本食谱“更多内容...”部分的*硬件复用*小节）。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You will need the RGB LED module shown in the following picture:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下图片中所示的RGB LED模块：
- en: '![](img/83669445-a359-4f4f-9842-78585d70168e.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83669445-a359-4f4f-9842-78585d70168e.png)'
- en: The RGB LED module from PiHardware.com
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 来自PiHardware.com的RGB LED模块
- en: As you can see in the preceding photo, the RGB LED module from [http://pihardware.com/](http://pihardware.com/) comes
    with GPIO pins and a DuPont female-to-female cable for connecting it. Although
    there are two sets of pins labelled from 1 to 5, only one side needs to be connected.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的照片中所见，来自[http://pihardware.com/](http://pihardware.com/)的RGB LED模块配备了GPIO引脚和一根杜邦公对公电缆，用于连接它。尽管有两个从1到5标记的引脚组，但只需连接其中一边即可。
- en: 'Alternatively, you can recreate your own with the following circuit using five
    common cathode RGB LEDs, 3 x 470 ohm resistors, and a Vero prototype board (or
    large breadboard). The circuit will look as shown in the following diagram:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下电路来重新创建自己的电路，该电路包括五个常见的负极RGB LED、3个470欧姆电阻和一个Vero原型板（或大型面包板）。电路将如下图中所示：
- en: '![](img/34cf8120-46bf-4b71-9ed0-9b0aea34f126.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34cf8120-46bf-4b71-9ed0-9b0aea34f126.png)'
- en: Circuit diagram for the RGB LED module
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED模块的电路图
- en: Strictly speaking, we should use 15 resistors in this circuit (one for each
    RGB LED element), which will avoid interference from LEDs sharing the same resistor,
    and will also prolong the life of the LEDs themselves if switched on together.
    However, there is only a slight advantage in using this, particularly since we
    intend to drive each RGB LED independently of the other four to achieve multi-color
    effects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，在这个电路中我们应该使用15个电阻（每个RGB LED元件一个），这样可以避免LED共享同一个电阻时产生的干扰，并且如果同时开启，还能延长LED本身的使用寿命。然而，使用这种方法的优势微乎其微，尤其是考虑到我们打算独立驱动每个RGB
    LED，以实现多彩效果。
- en: 'You will need to connect the circuit to the Raspberry Pi GPIO header as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要按照以下方式将电路连接到树莓派的GPIO引脚头：
- en: '| **RGB LED** |  |  |  |  |  | 1 |  | 2 | 3 |  | 4 |  |  |  |  |  |  |  |  |  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **RGB LED** |  |  |  |  |  | 1 |  | 2 | 3 |  | 4 |  |  |  |  |  |  |  |  |'
- en: '| **Rpi GPIO pin** | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24
    | 26 | 28 | 30 | 32 | 34 | 36 | 38 | 40 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **树莓派GPIO引脚** | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24 | 26
    | 28 | 30 | 32 | 34 | 36 | 38 | 40 |'
- en: '| **Rpi GPIO pin** | 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 | 21 | 23 |
    25 | 27 | 29 | 31 | 33 | 35 | 37 | 39 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **树莓派 GPIO 引脚** | 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 | 21 | 23 |
    25 | 27 | 29 | 31 | 33 | 35 | 37 | 39 |'
- en: '| **RGB LED** |  |  |  | 5 |  | R | G | B |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **RGB LED** |  |  |  | 5 |  | R | G | B |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the `rgbled.py` script and perform the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `rgbled.py` 脚本并执行以下步骤：
- en: 'Import all the required modules and define the values to be used with the help
    of the following code:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有必需的模块并使用以下代码定义要使用的值：
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define functions to set up the GPIO pins using the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义函数以设置GPIO引脚，请使用以下代码：
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define our utility functions to help control the LEDs using the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的效用函数以帮助控制LED，使用以下代码：
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a test function to demonstrate the functionality of the module:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试函数以展示模块的功能：
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To start with, we define the hardware setup by defining the states required
    to **Enable** and **Disable** the LED depending on the type of RGB LED (common
    cathode) used. If you are using a common anode device, just reverse the **Enable**
    and **Disable** states.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过定义根据所使用的RGB LED（共阴极）类型所需的**启用**和**禁用**LED的状态来定义硬件设置。如果你使用的是共阳极设备，只需反转**启用**和**禁用**状态。
- en: Next, we define the GPIO mapping to the pins to match the wiring we did previously.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义GPIO到引脚的映射，以匹配我们之前所做的布线。
- en: 'We also define some basic color combinations by combining red, green, and/or
    blue together, as shown in the following diagram:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过将红色、绿色和/或蓝色组合在一起来定义一些基本的颜色组合，如下所示：
- en: '![](img/06b6baa0-aba5-4a4a-a559-54261a81f562.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06b6baa0-aba5-4a4a-a559-54261a81f562.png)'
- en: LED color combinations
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: LED 颜色组合
- en: We define a series of useful functions, the first being `led_setup()`, which
    will set the GPIO numbering to `GPIO.BOARD` and define all the pins that are to
    be used as outputs. We also call a function named `led_clear()`, which will set
    the pins to the default state with all the pins disabled.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一系列有用的函数，第一个是 `led_setup()`，它将设置GPIO编号为 `GPIO.BOARD` 并定义所有要作为输出使用的引脚。我们还调用了一个名为
    `led_clear()` 的函数，该函数将引脚设置为默认状态，所有引脚均被禁用。
- en: This means that the LED pins, 1-5 (the common cathode on each LED), are set
    to `HIGH`, while the RGB pins (the separate anodes for each color) are set to
    `LOW`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着LED引脚1-5（每个LED的公共阴极）被设置为`HIGH`，而RGB引脚（每个颜色的独立阳极）被设置为`LOW`。
- en: We create a function called `led_gpiocontrol()` that will allow us to set the
    state of one or more pins. The `isinstance()` function allows us to test a value
    to see whether it matches a particular type (in this case, a single integer);
    then we can either set the state of that single pin or iterate through the list
    of pins and set each one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `led_gpiocontrol()` 的函数，它将允许我们设置一个或多个引脚的状态。`isinstance()` 函数使我们能够测试一个值以查看它是否与特定类型匹配（在这种情况下，一个单独的整数）；然后我们可以设置该单个引脚的状态，或者遍历引脚列表并设置每个引脚。
- en: Next, we define two functions, `led_activate()` and `led_deactivate()`, which
    will enable and disable the specified LED and color. Finally, we define `led_time()`,
    which will allow us to specify an LED, color, and time to switch it on for.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了两个函数，`led_activate()` 和 `led_deactivate()`，它们将启用和禁用指定的 LED 和颜色。最后，我们定义了
    `led_time()` 函数，它将允许我们指定一个 LED、颜色和时间来开启它。
- en: We also create `led_cleanup()` to reset the pins (and LEDs) to the default values
    and call `GPIO.cleanup()` to release the GPIO pins in use.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了`led_cleanup()`函数来将引脚（和LED）重置为默认值，并调用`GPIO.cleanup()`来释放正在使用的GPIO引脚。
- en: 'This script is intended to become a library file, so we will use the `if __name__==''__main__''`
    check to only run our test code when running the file directly:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本旨在成为一个库文件，因此我们将使用`if __name__=='__main__'`检查来确保仅在直接运行文件时执行我们的测试代码：
- en: By checking the value of `__name__`, we can determine whether the file was run
    directly (it will equal `__main__`) or whether it was imported by another Python
    script.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`__name__`的值，我们可以确定该文件是直接运行（它将等于`__main__`）还是被另一个Python脚本导入。
- en: This allows us to define a special test code that is only executed when we directly
    load and run the file. If we include this file as a module in another script,
    then this code will not be executed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们定义一个特殊的测试代码，该代码仅在直接加载并运行文件时执行。如果我们将此文件作为模块包含在其他脚本中，那么此代码将不会执行。
- en: As before, we will use `try`/`finally` to allow us to always perform cleanup
    actions, even if we exit early.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用 `try`/`finally` 来确保我们总是能够执行清理操作，即使我们在早期退出。
- en: To test the script, we will set the LEDs to light up in various colors, one
    after another.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试脚本，我们将依次设置LED灯以显示不同的颜色。
- en: There's more...
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can create a few different colors by switching on one or more parts of the
    RGB LED at a time. However, with some clever programming, we can create a whole
    spectrum of colors. Also, we can display different colors on each LED, seemingly
    at the same time.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过同时打开一个或多个RGB LED的部分来创建几种不同的颜色。然而，通过一些巧妙的编程，我们可以创建出整个光谱的颜色。此外，我们还可以在每个LED上显示不同的颜色，看起来像是同时进行的。
- en: Hardware multiplexing
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件复用
- en: An LED requires a high voltage on the anode side and a lower voltage on the
    cathode side in order to light up. The RGB LEDs used in the circuit are common
    cathodes, so we must apply a high voltage (3V3) on the RGB pins and a low voltage
    (0V) on the cathode pin (wired to pins 1 to 5 for each of the LEDs).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一个LED需要在阳极侧施加高电压，在阴极侧施加低电压才能点亮。电路中使用的RGB LED是共阴极的，因此我们必须在RGB引脚上施加高电压（3V3），在阴极引脚上施加低电压（0V），这些阴极引脚（每个LED的1到5号引脚）都连接在一起。
- en: 'The cathode and RGB pin states are as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 阴极和 RGB 引脚状态如下：
- en: '![](img/1f96fef2-54f1-4b85-8393-ec53785dbfd7.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f96fef2-54f1-4b85-8393-ec53785dbfd7.png)'
- en: Cathode and RGB pin states
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 阴极和 RGB 引脚状态
- en: Therefore, we can enable one or more of the RGB pins, but still control which
    of the LEDs are lit. We enable the pins of the LEDs we want to light up and disable
    the ones we don't. This allows us to use far fewer pins than we would need to
    control each of the 15 RGB lines separately.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以启用一个或多个RGB引脚，同时仍然控制哪些LED灯被点亮。我们启用想要点亮的LED的引脚，并禁用不需要的引脚。这使我们能够使用比单独控制15条RGB线所需的引脚数量少得多。
- en: Displaying random patterns
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示随机图案
- en: 'We can add new functions to our library to produce different effects, such
    as generating random colors. The following function uses `randint()` to get a
    value between 1 and the number of colors. We ignore any values that are over the
    number of the available colors so that we can control how often the LEDs are switched
    off. Perform the following steps to add the required functions:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的库中添加新的功能以产生不同的效果，例如生成随机颜色。以下函数使用 `randint()` 来获取介于1和颜色数量之间的值。我们忽略任何超过可用颜色数量的值，这样我们可以控制LED灯关闭的频率。执行以下步骤以添加所需的函数：
- en: 'Add the `randint()` function from the `random` module to the `rgbled.py` script
    using the following code:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `random` 模块中的 `randint()` 函数添加到 `rgbled.py` 脚本中，使用以下代码：
- en: '[PRE32]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now add `led_rgbrandom()` using the following code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加 `led_rgbrandom()` 函数，使用以下代码：
- en: '[PRE33]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Use the following commands in the `main()` function to create a series of
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中使用以下命令创建一系列
- en: 'flashing LEDs:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 闪烁的LED灯：
- en: '[PRE34]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Mixing multiple colors
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合多种颜色
- en: Until now, we have only displayed a single color at a time on one or more of
    the LEDs. If you consider how the circuit is wired up, you might wonder how we
    can get one LED to display one color and another a different one at the same time.
    The simple answer is that we don't need to-we just do it quickly!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在一或多个LED上一次显示一种颜色。如果你考虑电路是如何连接的，你可能会想知道我们如何让一个LED显示一种颜色，而另一个同时显示不同的颜色。简单的答案是，我们不需要这么做——我们只是做得很快！
- en: 'All we need to do is display one color at a time, but change it back and forth,
    so quickly that the color looks like a mix of the two (or even a combination of
    the three red/green/blue LEDs). Fortunately, this is something that computers
    such as the Raspberry Pi can do very easily, even allowing us to combine the RGB
    elements to make multiple shades of colors across all five LEDs. Perform the following
    steps to mix the colors:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是每次显示一种颜色，但快速地交替变换，使得颜色看起来像是两种（甚至三种红色/绿色/蓝色LED）的混合。幸运的是，像树莓派这样的计算机可以非常容易地做到这一点，甚至允许我们将RGB元素组合起来，在所有五个LED上制作出多种颜色的阴影。执行以下步骤来混合颜色：
- en: 'Add combo color definitions to the top of the `rgbled.py` script, after the
    definition of the mixed colors, using the following code:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`rgbled.py`脚本的顶部添加组合颜色定义，在混合颜色定义之后，使用以下代码：
- en: '[PRE35]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code will provide the combination of colors needed to create our
    shades, with `RGB_COLORS` providing a smooth progression through the shades.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将提供创建我们阴影所需的颜色组合，其中`RGB_COLORS`提供了通过阴影的平滑过渡。
- en: 'Next, we need to create a function called `led_combo()` to handle single or
    multiple colors. The code for the function will be as follows:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个名为 `led_combo()` 的函数来处理单色或多色。该函数的代码如下：
- en: '[PRE36]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can create a new script, `rgbledrainbow.py`, to make use of the new
    functions in our `rgbled.py` module. The `rgbledrainbow.py` script will be as
    follows:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的脚本，`rgbledrainbow.py`，以利用我们`rgbled.py`模块中的新功能。`rgbledrainbow.py`脚本将如下所示：
- en: '[PRE37]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `main()` function will first cycle through the LEDs, setting each color
    from the `RGB_COLORS` array on all the LEDs. Then, it will cycle through the colors,
    creating a rainbow effect across the LEDs:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数首先会遍历 LED，将 `RGB_COLORS` 数组中的每种颜色设置到所有 LED 上。然后，它会遍历这些颜色，在 LED 上创建出彩虹效果：'
- en: '![](img/8db3e951-4809-41ac-931a-18f13f837a74.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8db3e951-4809-41ac-931a-18f13f837a74.png)'
- en: Cycling through multiple colors on the five RGB LEDs
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在五个RGB LED上循环多种颜色
- en: Writing messages using persistence of vision
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视觉暂留原理编写信息
- en: '**Persistence of vision** (**POV**) displays can produce an almost magical
    effect, displaying images in the air by moving a line of LEDs back and forth very
    quickly or around in circles. The effect works because your eyes are unable to
    adjust fast enough to separate out the individual flashes of light, and so you
    observe a merged image (the message or picture being displayed):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉持久性**（**POV**）显示屏可以产生几乎神奇的效果，通过快速前后移动或绕圈移动一串LED灯，在空中显示图像。这种效果之所以有效，是因为你的眼睛无法快速调整以分离出单个的光闪，因此你观察到的是一个合并的图像（显示的消息或图片）：'
- en: '![](img/d1a235b8-74b1-4711-8e61-b136becc1ec8.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1a235b8-74b1-4711-8e61-b136becc1ec8.png)'
- en: Persistence of vision using RGB LEDs
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RGB LED实现视觉持久性
- en: Getting ready
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'This recipe uses the RGB LED kit used in the previous recipe; you will also
    need the following additional items:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用了之前菜谱中使用的RGB LED套件；你还需要以下额外的物品：
- en: Breadboard (half-sized or larger)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板（半尺寸或更大）
- en: 2 x DuPont female-to-male patch wires
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 杜邦公对母贴片线
- en: Tilt switch (the ball-bearing type is suitable)
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倾斜开关（球轴承类型适用）
- en: 1 x 470 ohm resistor (R_Protect)
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 470 欧姆电阻 (R_Protect)
- en: Breadboard wire (solid core)
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板线（实心芯）
- en: 'The tilt switch should be added to the RGB LED (as described in the *Getting
    ready* section of the *Multiplexed color LEDs* recipe). The tilt switch is wired
    as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关应该添加到RGB LED（如*多路复用彩色LED*配方中的*准备就绪*部分所述）。倾斜开关的接线方式如下：
- en: '![](img/51c2d882-d703-4337-9565-5e74effd196c.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51c2d882-d703-4337-9565-5e74effd196c.png)'
- en: The tilt switch is connected to GPIO Input (GPIO pin 24) and Gnd (GPIO pin 6)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关连接到GPIO输入（GPIO引脚24）和地（GPIO引脚6）
- en: 'To reproduce the POV image, you will need to be able to quickly move the LEDs
    and tilt the switch back and forth. Note how the tilt switch is mounted angled
    to the side, so the switch will open when moved to the left. It is recommended
    that the hardware is mounted onto a length of wood or similar piece of equipment.
    You can even use a portable USB battery pack along with a Wi-Fi dongle to power
    and control the Raspberry Pi through a remote connection (see the *Connecting
    Remotely to the Raspberry Pi over the Network using SSH (and X11 forwarding) recipe
    in *[Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml), *Getting Started
    with a Raspberry Pi 3 Computer*, for details):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要重现POV图像，你需要能够快速移动LED灯并来回倾斜开关。注意倾斜开关是如何以角度安装在侧面的，因此当向左移动时开关会打开。建议将硬件安装在一根木头或类似的设备上。你甚至可以使用便携式USB电池组和Wi-Fi适配器，通过远程连接来供电和控制Raspberry
    Pi（有关详细信息，请参阅[第1章](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml)中的*通过SSH（以及X11转发）在网络中远程连接到Raspberry
    Pi*配方，*使用Raspberry Pi 3计算机入门*）：
- en: '![](img/3b79de7f-91ee-469c-b72e-86208b427b38.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b79de7f-91ee-469c-b72e-86208b427b38.png)'
- en: Persistence of vision hardware setup
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉持久性硬件设置
- en: You will also need the completed `rgbled.py` file, which we will extend further
    in the *How to do it*... section.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要完成的 `rgbled.py` 文件，我们将在 *如何操作*... 部分对其进行进一步扩展。
- en: How to do it...
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a script called `tilt.py` to report the state of the tilt switch:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `tilt.py` 的脚本以报告倾斜开关的状态：
- en: '[PRE38]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can test the script by running it directly with the following command:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过以下命令直接运行脚本来测试它：
- en: '[PRE39]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the following `rgbled_pov()` function to the `rgbled.py` script we created
    previously; this will allow us to display a single line of our image:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `rgbled_pov()` 函数添加到我们之前创建的 `rgbled.py` 脚本中；这将使我们能够显示图像的单行：
- en: '[PRE40]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will now create the following file, called `rgbledmessage.py`, to perform
    the required actions to display our message. First, we will import the modules
    used: the updated `rgbled` module, the new `tilt` module, and the Python `os`
    module. Initially, we set `DEBUG` to `True`, so the Python terminal will display
    additional information while the script is running:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建以下文件，名为 `rgbledmessage.py`，以执行显示我们消息所需的操作。首先，我们将导入所需的模块：更新的 `rgbled`
    模块、新的 `tilt` 模块，以及 Python 的 `os` 模块。最初，我们将 `DEBUG` 设置为 `True`，这样在脚本运行时 Python
    终端将显示额外的信息：
- en: '[PRE41]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add a `readMessageFile()` function to read the content of the `letters.txt`
    file and then add `processFileContent()` to generate a **Python dictionary** of
    the LED patterns for each letter:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`readMessageFile()`函数来读取`letters.txt`文件的内容，然后添加`processFileContent()`函数来生成每个字母的LED模式**Python字典**：
- en: '[PRE42]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add a `createBuffer()` function, which will convert a message into a series
    of LED patterns for each letter (assuming the letter is defined by the `letters.txt`
    file):'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `createBuffer()` 函数，该函数将消息转换为一系列代表每个字母的LED图案（假设字母由 `letters.txt` 文件定义）：
- en: '[PRE43]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we define a `displayBuffer()` function to display the LED patterns using
    the `rgbled_pov()` function in the `rgbled` module:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`displayBuffer()`函数，用于使用`rgbled_pov()`函数在`rgbled`模块中显示LED图案：
- en: '[PRE44]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we create a `main()` function to perform each of the required steps:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`main()`函数来执行每个所需的步骤：
- en: Set up the hardware components (RGB LEDs and the tilt switch).
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置硬件组件（RGB LED灯和倾斜开关）。
- en: Read the `letters.txt` file.
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取`letters.txt`文件。
- en: Define the dictionary of LED letter patterns.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义LED字母图案的字典。
- en: Generate a buffer to represent the required message.
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个缓冲区来表示所需的消息。
- en: 'Display the buffer using the `rgbled` module and control it with the `tilt`
    module:'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `rgbled` 模块显示缓冲区，并用 `tilt` 模块控制它：
- en: '[PRE45]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the following file, called `letters.txt`, to define the LED patterns
    needed to display the example `''_COOKBOOK_''` message. Note that this file only
    needs to define a pattern for each unique letter or symbol in the message:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下名为 `letters.txt` 的文件，用于定义显示示例消息 `'_COOKBOOK_'` 所需的 LED 模式。请注意，此文件只需为消息中的每个唯一字母或符号定义一个模式：
- en: '[PRE46]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first function, `readMessageFile()`, will open and read the contents of
    a given file. This will then use `processFileContent()` to return a Python dictionary
    containing the corresponding patterns for the letters defined in the file provided.
    Each line in the file is processed, ignoring any line containing a `#` character
    and checking for `"` characters to indicate the name of the LED pattern that follows
    after. After the file has been processed, we end up with a Python dictionary that
    contains LED patterns for the `''_''`, `''C''`, `''B''`, `''K''`, and `''O''`
    characters:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 `readMessageFile()` 将会打开并读取指定文件的內容。然后，它会使用 `processFileContent()` 函数来返回一个包含文件中定义的字母对应模式的
    Python 字典。文件中的每一行都会被处理，忽略包含 `#` 字符的行，并检查 `"` 字符以指示随后的 LED 模式的名称。在文件被处理后，我们最终得到一个包含
    `'_'`、`'C'`、`'B'`、`'K'` 和 `'O'` 字符的 LED 模式的 Python 字典：
- en: '[PRE47]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that we have a selection of letters to choose from, we can create a sequence
    of LED patterns using the `createBuffer()` function. As the name suggests, the
    function will build up a buffer of LED patterns by looking up each letter in the
    message and adding the related pattern row by row. If a letter isn't found in
    the dictionary, then a space will be used instead.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一组可供选择的字母，我们可以使用`createBuffer()`函数来创建一个LED图案序列。正如其名所示，该函数将通过逐个查找消息中的每个字母，并逐行添加相关的图案行来构建一个LED图案缓冲区。如果一个字母在字典中找不到，那么将使用空格代替。
- en: 'Finally, we now have a list of LED patterns ready to display. To control when
    we start the sequence, we will use the TILT module and check the status of the
    tilt switch:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在有一份准备显示的LED图案列表。为了控制何时开始序列，我们将使用TILT模块并检查倾斜开关的状态：
- en: '![](img/498405aa-c0f8-4de7-bade-88e49cf495ba.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/498405aa-c0f8-4de7-bade-88e49cf495ba.png)'
- en: The tilt switch position when not moving (left) and moving (right)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转开关在未移动（左侧）和移动（右侧）时的位置
- en: 'The tilt switch consists of a small ball bearing enclosed in a hollow, insulated
    cylinder; the connection between the two pins is closed when the ball is resting
    at the bottom of the cylinder. The tilt switch is open when the ball is moved
    to the other end of the cylinder, out of contact of the pins:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关由一个装在空心、绝缘圆柱体内的微型球轴承组成；当球轴承位于圆柱体底部时，两个引脚之间的连接是闭合的。当球轴承移动到圆柱体的另一端，与引脚失去接触时，倾斜开关处于开启状态：
- en: '![](img/b0ca0f15-3e36-44a7-a184-ffc2fad38031.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0ca0f15-3e36-44a7-a184-ffc2fad38031.jpg)'
- en: The tilt switch circuit with the switch closed and with the switch open
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 开关关闭和开关打开的倾斜开关电路
- en: The tilt switch circuit shown previously will allow GPIO pin 24 to be connected
    to the ground when the switch is closed. Then, if we read the pin, it will return
    `False` when it is at rest. By setting the GPIO pin as an input and enabling the
    internal pull-up resistor, when the tilt switch is open, it will report `True`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的倾斜开关电路将允许当开关关闭时，GPIO引脚24连接到地。然后，如果我们读取该引脚，当它处于静止状态时，它将返回`False`。通过将GPIO引脚设置为输入并启用内部上拉电阻，当倾斜开关打开时，它将报告`True`。
- en: 'If the tilt switch is open (reporting `True`), then we will assume the unit
    is being moved and begin displaying the LED sequences, incrementing the current
    position each time we display a row of the LED pattern. Just to make the pattern
    a little more colorful (just because we can!) we repeat each row in another color.
    As soon as the `TILT.tilt_moving()` function reports that we have stopped moving
    or that we are moving in the opposite direction, we will reset the current position,
    ready to start the whole pattern all over again:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果倾斜开关处于开启状态（报告`True`），那么我们将假设设备正在移动，并开始显示LED序列，每次显示LED图案的一行时，都会增加当前位置。为了使图案更加多彩（因为我们能这么做！），我们将每一行重复一遍，用另一种颜色。一旦`TILT.tilt_moving()`函数报告我们已经停止移动或者正在向相反方向移动，我们将重置当前位置，准备从头开始整个图案：
- en: '![](img/e772078c-2e3f-47de-94f9-10ba77b34d50.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e772078c-2e3f-47de-94f9-10ba77b34d50.png)'
- en: The message is displayed by the RGB LEDs - here, we are using green and blue
    together
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通过RGB LED显示 - 这里，我们正在一起使用绿色和蓝色
- en: When the RGB LED module and tilt switch are moved back and forth, we should
    see the message displayed in the air!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当RGB LED模块和倾斜开关来回移动时，我们应该看到空中显示的信息！
- en: Try experimenting with different color combinations, speeds, and arm waviness
    to see what effects you can produce. You could even create a similar setup mounted
    on a wheel to produce a continuous POV effect.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的颜色组合、速度和手臂摆动幅度进行实验，看看你能产生什么效果。你甚至可以在轮子上创建一个类似的设置，以产生连续的POV效果。
