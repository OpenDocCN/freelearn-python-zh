- en: Chapter 7. Some Fun Project Ideas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 一些有趣的项目想法
- en: In the previous projects, we have explored most of the important features of
    Tkinter. Developing new projects is now about extending what we have learned so
    far. In this project, we will build several partly-functional applications that
    you can take forward.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的项目中，我们已经探索了Tkinter的大部分重要功能。现在开发新项目就是扩展我们迄今为止所学的内容。在这个项目中，我们将构建几个部分功能的应用程序，您可以继续开发。
- en: Mission Briefing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: 'In this project, we will develop "bare bone structures" for several applications
    from different domains. The applications we will build here include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将为来自不同领域的几个应用程序开发“裸骨结构”。我们将构建的应用程序包括：
- en: Screen saver
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕保护程序
- en: Snake game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪吃蛇游戏
- en: Weather Reporter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天气预报员
- en: Phonebook application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话簿应用程序
- en: Graphing with Tkinter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tkinter绘图
- en: Why Is It Awesome?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它如此出色？
- en: You will find this project useful as we will delve further in to learning about
    the power of Tkinter **Canvas** widget, and develop some basic animations for
    our screen saver program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现这个项目很有用，因为我们将进一步深入了解Tkinter **Canvas**小部件的力量，并为我们的屏幕保护程序程序开发一些基本动画。
- en: When developing the Snake game, we will learn to develop a multithreaded Python
    application efficiently using the **Queue implementation** . As you will see,
    this is a handy tool to have when working on multithreaded applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发贪吃蛇游戏时，我们将学习如何高效地使用**队列实现**来开发多线程Python应用程序。正如您将看到的，当处理多线程应用程序时，这是一个非常有用的工具。
- en: The Weather Reporter application will introduce you to the basics of network
    programming. You will learn how to mine into the seemingly infinite resource that
    is available to us over the Internet.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 天气预报员应用程序将向您介绍网络编程的基础。您将学习如何挖掘互联网上看似无限的资源。
- en: The phonebook application will show you how to work with databases. This is
    vital for developing any large-scale application where persistence is required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 电话簿应用程序将向您展示如何与数据库一起工作。这对于开发任何需要持久性的大型应用程序至关重要。
- en: Finally, we look at basic graphing abilities of Tkinter. We also look at ways
    of embedding matplotlib graphs in Tkinter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨Tkinter的基本绘图能力。我们还将探讨在Tkinter中嵌入matplotlib图表的方法。
- en: Your Hotshot Objectives
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的热门目标
- en: 'The key objectives outlined for this project include developing and understanding
    the followings:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为此项目概述的关键目标包括开发和理解以下内容：
- en: Basic animations with Tkinter canvas
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter画布的基本动画
- en: Queue implementation for a multithreaded Tkinter application
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为多线程Tkinter应用程序实现队列
- en: Network programming and tapping into resources over the Internet
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络编程和利用互联网资源
- en: Working with data interchange formats like JSON and XML
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据交换格式（如JSON和XML）一起工作
- en: Database programming and basic CRUD operations on a database
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库编程和数据库的基本CRUD操作
- en: Graphing with Tkinter
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tkinter绘图
- en: Building a screen saver
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建屏幕保护程序
- en: 'We will start by building a screen saver for our desktop. The screen saver
    will consist of several random-colored and random-sized balls bouncing all over
    the screen at random velocity, as shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为我们的桌面创建一个屏幕保护程序。屏幕保护程序将包含几个随机颜色和随机大小的球，以随机速度在屏幕上弹跳，如下面的截图所示：
- en: '![Building a screen saver](img/7941OT_07_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![创建屏幕保护程序](img/7941OT_07_01.jpg)'
- en: Engage Thrusters
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Carry out the following steps to create the screen saver:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建屏幕保护程序：
- en: 'Let''s create a class to generate balls with random attributes. Accordingly,
    we define a new class named `RandomBall` to achieve this (refer to the `7.01 screensaver.py`
    Python file, available in the code bundle):'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个类来生成具有随机属性的球。相应地，我们定义一个新的类名为`RandomBall`来实现这一点（请参阅代码包中的`7.01 screensaver.py`Python文件）：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The description of the code is as follows:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是代码的描述：
- en: The `__init__` method takes three arguments, an instance of the Canvas widget,
    the screen width and the screen height. It then initializes the initial *x* and
    *y* positions for a ball as random numbers, starting from `0` up to the maximum
    screen coordinates.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`方法接受三个参数，即Canvas小部件的实例、屏幕宽度和屏幕高度。然后它将球的初始*x*和*y*位置初始化为随机数，从`0`开始，到最大屏幕坐标。'
- en: It also initializes the velocity of the ball in *x* and *y* directions, the
    radius and color of the ball changes in a random fashion.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还初始化了球在*x*和*y*方向上的速度，球的半径和颜色以随机方式变化。
- en: Because the hexadecimal color coding system uses two hexadecimal digits for
    each of red, green and blue colors, there are 16^2 (256) possibilities for each
    color. We therefore create a lambda function that generates a random number from
    0-255, and use this function to generate three random numbers. We convert this
    decimal number to its two-digit equivalent hexadecimal notation using the format
    %02x to generate a random color for the balls.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为十六进制颜色编码系统为红色、绿色和蓝色中的每一个颜色使用两个十六进制数字，所以每种颜色有16^2（256）种可能性。因此，我们创建了一个生成0-255之间随机数的lambda函数，并使用这个函数生成三个随机数。我们使用格式%02x将这个十进制数转换为它的两位等效十六进制表示，以生成球的随机颜色。
- en: 'The second method creates the actual ball using the canvas `create_oval` method
    (refer to the `7.01 screensaver.py` Python file available in the code bundle):'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个方法使用画布的`create_oval`方法创建实际的球（参考代码包中可用的`7.01 screensaver.py` Python文件）：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's now code the method to handle ball movement on the screen.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写处理屏幕上球移动的方法。
- en: The method also checks if the ball has reached the end of the screen on any
    of the sides. If the ball has actually reached the end of the screen, it simply
    changes the direction by appending a negative sign to the velocity of the ball.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法还会检查球是否已经到达屏幕的任何一边的尽头。如果球实际上已经到达屏幕的尽头，它将简单地通过给球的速率添加负号来改变方向。
- en: 'The method finally moves the ball using the `canvas.move` method (refer to
    `7.01 screensaver.py`):'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法最终使用`canvas.move`方法移动球（参考`7.01 screensaver.py`）：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That is all to our `RandomBall` class. We can use this class to create as many
    ball objects as we want to display in our screen saver.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是我们的`RandomBall`类的全部内容。我们可以使用这个类来创建我们想要在屏幕保护程序中显示的任意数量的球对象。
- en: 'Now, that we have coded methods to generate balls and to move them, let''s
    create our screen saver. We now create a class named `ScreenSaver` that will show
    the actual screen saver:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经编写了生成球和移动它们的代码方法，让我们创建我们的屏幕保护程序。我们现在创建一个名为`ScreenSaver`的类，它将显示实际的屏幕保护程序：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The description of the code is as follows:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `__init__` method of the `ScreenSaver` class takes the number of balls (`num_balls`)
    as its argument.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScreenSaver`类的`__init__`方法接受球的数量（`num_balls`）作为其参数。'
- en: We then create a root window and calculate the height and width of the screen
    using the `winfo` method.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个根窗口并使用`winfo`方法计算屏幕的高度和宽度。
- en: We use `root.overrideredirect(1)` to remove the enclosing frame from the parent
    window.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`root.overrideredirect(1)`来从父窗口中移除封装的框架。
- en: We then specify the geometry of the parent window to fill the entire screen.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们指定父窗口的几何形状以填充整个屏幕。
- en: We make the parent window transparent using `root.attributes('-alpha', 0.3)`.
    We add a transparency of `0.3` to make the window translucent.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`root.attributes('-alpha', 0.3)`使父窗口透明。我们添加了`0.3`的透明度，使窗口半透明。
- en: We then bind the root to call our `quit` command on the event of clicking the
    mouse button, pressing any keyboard button, or mouse motion. This is to ensure
    that our program behaves like a screen saver, exiting on any interactions from
    the user's end.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将根绑定到在点击鼠标按钮、按下任何键盘按钮或鼠标移动时调用我们的`quit`命令。这是为了确保我们的程序表现得像屏幕保护程序，在用户端有任何交互时退出。
- en: We then create a canvas to cover the entire screen with `Canvas(self.root, width=w,
    height=h)`.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个画布来覆盖整个屏幕，使用`Canvas(self.root, width=w, height=h)`。
- en: We create several random ball objects outs of the `RandomBall` class, passing
    along the Canvas widget instance, the width, and the height of the screen as its
    arguments.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`RandomBall`类中创建了几个随机球对象，并将画布小部件实例、屏幕的宽度和高度作为其参数传递。
- en: We finally make a call to run the screen saver with the `run_screen_saver()`
    method within the `ScreenSaver` class, which is discussed in the following.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终在`ScreenSaver`类中调用`run_screen_saver()`方法来运行屏幕保护程序，这将在下文中讨论。
- en: 'In this step, we will run the `ScreenSaver` class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，我们将运行`ScreenSaver`类：
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The description of the code is as follows:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `run_screensaver()` method simply moves each ball by calling itself at a
    regular interval of 20 milliseconds
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_screensaver()`方法通过每隔20毫秒调用自身来简单地移动每个球。'
- en: 'We also define the `quit` method in our `ScreenSaver` class to quit from the
    main loop and exit the program:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还在`ScreenSaver`类中定义了`quit`方法，用于从主循环退出并退出程序：
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run the screen saver, we instantiate an object from our `ScreenSaver` class,
    passing the number of balls as its argument:'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行屏幕保护程序，我们从一个`ScreenSaver`类实例中实例化一个对象，并将球的数量作为其参数传递：
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have used two Toplevel window methods `root.overrideredirect` and `root.attributes`,
    in the previous code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的代码中使用了两个顶层窗口方法 `root.overrideredirect` 和 `root.attributes`。
- en: For a complete list of methods that can be applied to the Toplevel window, refer
    to the *The Toplevel window methods* section in [Appendix B](apb.html "Appendix B. Quick
    Reference Sheets"), *Quick Reference Sheets*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可以应用于顶层窗口的方法的完整列表，请参阅附录B中的 *The Toplevel window methods* 部分，*快速参考表*。
- en: Objective Complete – Mini Debriefing
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: Our screen saver is ready!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的屏保已经准备好了！
- en: In fact, if you are working on a Windows platform, and when you learn to create
    an executable program from Python programs (discussed in [Appendix A](apa.html
    "Appendix A. Miscellaneous Tips"), *Miscellaneous Tips*), you can create an executable
    file with `.exe` extension for this screen saver. So then, you can change its
    extension from `.exe` to `.scr` and right-click, and select **Install** to add
    it to your list of screensavers!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你在Windows平台上工作，并且当你学习如何从Python程序（在附录A中讨论，*杂项提示*）创建可执行程序时，你可以为这个屏保创建一个具有`.exe`扩展名的可执行文件。然后，你可以将其扩展名从`.exe`更改为`.scr`，右键单击，并选择**安装**将其添加到你的屏保列表中！
- en: Building a Snake game
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建贪吃蛇游戏
- en: Let's now build a simple Snake game. As usual, we will be making use of the
    Canvas widget to provide the platform for our Snake program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来构建一个简单的贪吃蛇游戏。像往常一样，我们将使用画布小部件为我们的贪吃蛇程序提供平台。
- en: We will use `canvas.create_line` to draw our snake, and `canvas.create_rectangle`
    to draw the snake-food.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `canvas.create_line` 来绘制我们的蛇，并使用 `canvas.create_rectangle` 来绘制蛇的食物。
- en: Prepare for Lift Off
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: One of the primary objectives for this project is to introduce the Queue implementation
    in Python as we used it in conjunction with the **threading** module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的首要目标之一是介绍Python中的队列实现，正如我们与**线程**模块结合使用的那样。
- en: So far, we have built single-threaded applications. However, threading can be
    difficult to handle when there is more than one thread in an application, and
    these threads need to share attributes or resources among them. In this case,
    you cannot predict the thread execution order at all. OS does it very randomly
    and swiftly each time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们构建了单线程应用程序。然而，当应用程序中有多个线程时，线程处理可能会变得困难，并且这些线程需要在它们之间共享属性或资源。在这种情况下，你根本无法预测线程的执行顺序。操作系统每次都非常随机和迅速地执行它。
- en: To handle this complexity, threading module provides some synchronization tools,
    such as locks, join, semaphores, events, and condition variables. However, it
    is—in most cases—safer and simpler to use queues. Simply put, a **queue** is a
    compound memory structure that is thread-safe; queues effectively channel access
    to a resource to multiple threads in a sequential order, and are a recommended
    design pattern that uses threads for most of the scenarios that require concurrency.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种复杂性，线程模块提供了一些同步工具，例如锁、join、信号量、事件和条件变量。然而，在大多数情况下，使用队列更安全、更简单。简单来说，**队列**是一个线程安全的复合内存结构；队列有效地以顺序方式将资源访问渠道传递给多个线程，并且是推荐的设计模式，适用于大多数需要并发的场景。
- en: The **Queue** module provides a way to implement different kinds of queuing,
    such as **FIFO** (default implementation), **LIFO** queue, and **Priority** queue,
    and this module comes with a built-in implementation of all locking semantics
    required for running multithreaded programs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**模块提供了一种实现不同类型的队列的方法，例如**FIFO**（默认实现）、**LIFO**队列和**优先级**队列，并且此模块包含运行多线程程序所需的所有锁定语义的内置实现。'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information about the Queue module can be found in the following link:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于队列模块的更多信息可以在以下链接中找到：
- en: '[http://docs.Python.org/2/library/queue.html](http://docs.Python.org/2/library/queue.html)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.Python.org/2/library/queue.html](http://docs.Python.org/2/library/queue.html)'
- en: 'Here''s a quick roundup of the basic usage of the Queue module:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对队列模块基本用法的一个快速总结：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s see a simple demonstration of using queue to implement a multithreaded
    application (refer to `7.02 threading with queue.py` available in the code bundle):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用队列实现多线程应用程序的一个简单示例（请参阅代码包中可用的 `7.02 threading with queue.py`）：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The description of the code is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We first create a `Worker` class, which inherits from the `threading` module
    of Python. The `__init__` method takes in a queue as its argument.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `Worker` 类，它继承自Python的 `threading` 模块。`__init__` 方法接受一个队列作为其参数。
- en: We then override the `run` method of the `threading` module to get each item
    from the queue using `queue.get()`, which is then passed on to the `taskHandler`
    method, which actually executes the task specified in the current queue item.
    In our example, it does nothing useful but printing the name of the task.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们覆盖了`threading`模块的`run`方法，使用`queue.get()`从队列中获取每个项目，然后将其传递给`taskHandler`方法，该方法实际上执行当前队列项中指定的任务。在我们的例子中，它没有做任何有用的事情，只是打印出任务的名称。
- en: After the work is done on a particular thread by our `taskHandler` method, it
    sends a signal to the queue telling that the task has been completed using the
    `queue.task_done()` method.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`taskHandler`方法完成特定线程的工作后，它通过使用`queue.task_done()`方法向队列发送一个信号，表明任务已经完成。
- en: Outside our `Worker` class, we create an empty queue in our `main()` method.
    This queue is populated with a list of tasks using `queue.put(task)`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`Worker`类外部，我们在`main()`方法中创建了一个空队列。这个队列使用`queue.put(task)`用一系列任务填充。
- en: We then create six different threads and pass this populated queue as its argument.
    Now that the tasks are handled by the queue, all threads automatically ensure
    that the tasks are completed in a sequence in which they are encountered by the
    threads, without causing any deadlocks or two different threads trying to work
    on the same queued task.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了六个不同的线程，并将这个填充好的队列作为其参数传递。现在，由于任务由队列处理，所有线程都会自动确保任务按照线程遇到的顺序完成，而不会造成任何死锁或两个不同的线程试图处理同一个队列任务。
- en: At the time of creating each thread, we also create a pool of daemon threads
    using the `mythread.setDaemon(True)` method. Doing this passes control to our
    main program once all threads have completed execution. If you comment out the
    line, the program would still run, but would fail to exit after all threads have
    completed executing the tasks in the queue. Without the daemon threads, you'd
    have to keep track of all the threads and tell them to exit before your program
    could completely quit.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建每个线程的时候，我们也使用`mythread.setDaemon(True)`方法创建了一个守护线程池。这样做会在所有线程完成执行后将控制权交回主程序。如果你注释掉这一行，程序仍然会运行，但在所有线程完成队列中的任务执行后，程序将无法退出。如果没有守护线程，你将不得不跟踪所有线程，并在你的程序完全退出之前告诉它们退出。
- en: Finally, the `queue.join()` method ensures that the program flow waits there
    until the queue is empty.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`queue.join()`方法确保程序流程等待在那里，直到队列变为空。
- en: 'Now that we know how to use queues to handle multithreaded applications effectively,
    let''s build our Snake game. In its final form, the game would be like the one
    shown in the following screenshot (refer to the `7.03 game of snake.py` Python
    file available in the code bundle):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用队列有效地处理多线程应用程序，让我们构建我们的蛇游戏。在其最终形式中，游戏将类似于以下截图所示（请参考代码包中可用的`7.03 game
    of snake.py` Python文件）：
- en: '![Prepare for Lift Off](img/7941OT_07_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941OT_07_02.jpg)'
- en: Engage Thrusters
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Let's start coding our game, by first creating a basic `GUI` class.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始编写我们的游戏，首先创建一个基本的`GUI`类。
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The description of the code is as follows:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: This code should be mostly familiar to you by now, because we have created similar
    `GUI` classes several times in the past.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到现在为止，这段代码对你来说应该已经很熟悉了，因为我们之前已经多次创建了类似的`GUI`类。
- en: However, rather than passing the root instance as an argument to its `__init__`
    method, our GUI class now inherits from the Tk class. The line `Tk.__init__(self)`ensures
    that the root window is available to all methods of this class. This way we can
    avoid writing `root` attribute on every line by referencing `self.root` simply
    as `self`.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，我们的GUI类现在不是将根实例作为参数传递给其`__init__`方法，而是从Tk类继承。`Tk.__init__(self)`这一行确保根窗口对所有这个类的方法都是可用的。这样我们就可以通过简单地引用`self`来避免在每一行都写上`root`属性。
- en: We then initialize the canvas, line (snake), rectangle (food) and text (to display
    score).
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们初始化画布、线条（蛇）、矩形（食物）和文本（用于显示分数）。
- en: We then call the function `queueHandler().` This yet to be defined method would
    be similar to `main` method defined in the previous queue example. This would
    be the central method which will process all tasks in the queue. We will come
    back to define this method once we have added some tasks to the queue.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们调用函数`queueHandler()`。这个尚未定义的方法将与之前队列示例中定义的`main`方法类似。这将是一个中心方法，它将处理队列中的所有任务。一旦我们向队列中添加了一些任务，我们就会回来定义这个方法。
- en: 'Now, we will create the `Food` class, as shown in the following code snippet:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`Food`类，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The description of the code is as follows:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是代码的描述：
- en: Because we want to process all data centrally from within a queue, we pass the
    queue as an argument to the `__init__` method of the `Food` class. We choose to
    run this from the main program thread to demonstrate how a code which is being
    executed in the main thread can communicate with attributes and methods from other
    threads.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们希望从队列内部集中处理所有数据，所以我们把队列作为一个参数传递给`Food`类的`__init__`方法。我们选择在主程序线程中运行这个操作，以展示一个在主线程中执行的字节码如何与其他线程的属性和方法进行通信。
- en: The `__init__` method calls another method called `generate_food()`, which is
    responsible for generating the snake-food at random positions on the canvas.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`方法调用另一个名为`generate_food()`的方法，该方法负责在画布上随机位置生成蛇食物。'
- en: The `generate_food` method generates a random *(x, y)* position on the canvas.
    However, because the place where the coordinates coincide is just a small point
    on the canvas, it would be barely visible. We therefore generate an expanded coordinate
    (`self.exppos`) ranging from five values less than the *(x,y)* coordinate up to
    five values higher than the same coordinate. Using this range, we can create a
    small rectangle on the canvas which would be easily visible and would represent
    our food.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_food`方法在画布上生成一个随机的*(x, y)*位置。然而，因为坐标重合的地方只是画布上的一个小点，几乎看不见。因此，我们生成一个扩展的坐标(`self.exppos`)，范围从*(x,y)*坐标的五值以下到五值以上。使用这个范围，我们可以在画布上创建一个小的矩形，这将很容易看见，并代表我们的食物。'
- en: Note
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, we do not create the rectangle here. Instead, we pass the coordinates
    for the food (rectangle) into our queue using `queue.put`. Because this queue
    is to be made available to all our classes, we will have a centralized worker
    named `queue_handler()`, which will process this queue to generate the rectangle
    from our GUI class later. This is the central idea behind a Queue implementation.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我们在这里并没有创建矩形。相反，我们使用`queue.put`将食物（矩形）的坐标传递到我们的队列中。因为这个队列将被所有我们的类使用，我们将有一个名为`queue_handler()`的集中式工作者，它将处理这个队列，并在稍后从我们的GUI类生成矩形。这是队列实现背后的核心思想。
- en: 'Let''s now create the `Snake` class. We have already passed a task to generate
    our food to the central queue. However, no thread was involved in the task. We
    could also generate our Snake class without using threads. However, because we
    are talking about ways to implement multithreaded applications, let''s implement
    our Snake class to work from a separate thread (refer to `7.03 game of snake.py`):'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来创建`Snake`类。我们已经将生成食物的任务传递给了中央队列。然而，这个任务没有涉及任何线程。我们也可以不使用线程来生成我们的蛇类。然而，因为我们正在讨论实现多线程应用程序的方法，所以让我们将我们的蛇类实现为从单独的线程中工作（参考`7.03
    game of snake.py`）：
- en: '[PRE11]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The description of the code is as follows:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是代码的描述：
- en: First, we create a class named `Snake` to run from a separate thread. This class
    takes the GUI and queue as its input arguments.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`Snake`的类，从单独的线程中运行。这个类接受GUI和队列作为它的输入参数。
- en: We initialize the points earned by the player from zero and set the initial
    location of the snake using the attribute `self.snake_points`.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们初始化玩家获得的成绩为零，并使用属性`self.snake_points`设置蛇的初始位置。
- en: Finally, we start the thread and create an infinite loop to call the `move()`
    method at small intervals. During every run of the loop, the method populates
    the queue with a dictionary having the key as `'move'` and the value equal to
    the updated position of the snake through the `self.snake_points` attribute.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们启动线程并创建一个无限循环，以小间隔调用`move()`方法。在每次循环运行中，该方法通过`self.snake_points`属性将一个包含键为`'move'`和值为蛇更新位置的字典填充到队列中。
- en: In this step, we will be making the snake move.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，我们将使蛇移动。
- en: The thread initialized above calls the `Snake` class `move()` method to move
    the snake around on the canvas. However, before we can move the snake, we need
    to know the direction in which the snake should move. This obviously depends on
    the particular key pressed by the user (Left/Right/Top/Down key).
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上面的线程初始化调用`Snake`类的`move()`方法，在画布上移动蛇。然而，在我们能够移动蛇之前，我们需要知道蛇应该移动的方向。这显然取决于用户按下的特定键（左/右/上/下键）。
- en: Accordingly, we need to bind these four events to the Canvas widget. We will
    do the actual binding later. However, we can now create a method named called
    `key_pressed`, which takes the `key_press` event itself as its argument and sets
    the direction value according to the key that is pressed.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们需要将这些四个事件绑定到Canvas小部件上。我们将在稍后进行实际的绑定。然而，我们现在可以创建一个名为`key_pressed`的方法，该方法将`key_press`事件本身作为其参数，并根据按下的键设置方向值。
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have the directions, let''s code the `move` method:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有了方向，让我们编写`move`方法：
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The description for the code is as follows:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: First, the `move` method obtains the latest coordinates for the snake depending
    on the keyboard event. It uses a separate method called `calculate_new_coordinates`
    to get the latest coordinates.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`move`方法根据键盘事件获取蛇的最新坐标。它使用一个名为`calculate_new_coordinates`的单独方法来获取最新坐标。
- en: It then checks if the location of the new coordinates coincide with the location
    of the food. If they match, it increases the score of the player by one and calls
    the `Food` class `generate_food` method to generate a new food at a new location.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它会检查新坐标的位置是否与食物的位置一致。如果它们匹配，它会将玩家的得分增加一分，并调用`Food`类的`generate_food`方法在新的位置生成新的食物。
- en: If the current point does not coincide with the food coordinates, it deletes
    the last item from the snake coordinates using `self.snake_points.pop(0)`.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前点与食物坐标不一致，它将使用`self.snake_points.pop(0)`从蛇坐标中删除最后一个项目。
- en: Then, it calls another method named `check_game_over` to check if the snake
    collides against the wall or against itself. If the snake does collide, it appends
    a new dictionary item in the queue with the value `'game_over':True`.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它会调用另一个名为`check_game_over`的方法来检查蛇是否撞到墙壁或撞到自己。如果蛇确实撞到了，它会在队列中追加一个新的字典项，其值为`'game_over':True`。
- en: Finally, if the game is not over, it appends the new position of the snake to
    the list `self.snake_points`. This is automatically added to the queue, because
    we have defined `self.queue.put({'move':self.snake_points})` in the `Snake` class's
    `run()` method to update every 0.1 seconds as long as the game is not over.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果游戏没有结束，它会将蛇的新位置追加到列表`self.snake_points`中。这会自动添加到队列中，因为我们已经在`Snake`类的`run()`方法中定义了`self.queue.put({'move':self.snake_points})`，以便在游戏没有结束时每0.1秒更新一次。
- en: Now, let's create the Queue handler.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建队列处理程序。
- en: We now have a `Food` class feeding the centralized queue from the main program
    thread. We also have the `Snake` class adding data to the queue from one thread
    and a `GUI` class running the `queue_handler` method from another thread. So,
    the queue is the central point of interaction between these three threads.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们有一个`Food`类从主程序线程中向集中队列提供食物。我们还有一个`Snake`类从一个线程中向队列添加数据，以及一个`GUI`类从另一个线程中运行`queue_handler`方法。因此，队列是这三个线程之间交互的中心点。
- en: Now, it is time to handle these data to update the content on the canvas. We
    accordingly define the `queue_handler()` method in our `GUI` class to work on
    items in the queue.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，是时候处理这些数据以更新画布上的内容了。因此，我们在`GUI`类中相应地定义了`queue_handler()`方法来处理队列中的项目。
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The description for the code is as follows:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `queue_handler` method gets into an infinite loop looking for tasks in the
    queue using `task = self.queue.get(block=False)`. If the queue becomes empty,
    the loop is restarted using `canvas.after`.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue_handler`方法进入一个无限循环，使用`task = self.queue.get(block=False)`在队列中查找任务。如果队列变为空，循环会使用`canvas.after`重新启动。'
- en: Once a task is fetched from the queue, the method checks its key.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦从队列中获取了一个任务，该方法会检查其键。
- en: If the key is `'game_over'`, it calls another method named `game_over()` that
    we defined next.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键是`'game_over'`，它调用我们定义的另一个名为`game_over()`的方法。
- en: If the key of task is `'move'`, it uses `canvas.coords` to move the line to
    its new position.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务的键是`'move'`，它使用`canvas.coords`将线移动到新的位置。
- en: If the key is `'points_earned'`, it updates the score on the canvas.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键是`'points_earned'`，它会在画布上更新得分。
- en: When execution of a task completes, it signals the thread with the `task_done()`
    method.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个任务的执行完成后，它会使用`task_done()`方法向线程发出信号。
- en: Note
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`queue.get` can take both `block=True` (default) and `block=False` as its argument.'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`queue.get`可以接受`block=True`（默认）和`block=False`作为其参数。'
- en: When the block is set to `False`, it removes and returns an item from the queue,
    if available. If the queue is empty, it raises `Queue.Empty`. When the block is
    set to `True`, `queue.get` fetches an item from the queue by suspending the calling
    thread, if required, until an item is available.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当块设置为 `False` 时，如果队列中有可用项，它会移除并返回一个项。如果队列为空，它将引发 `Queue.Empty`。当块设置为 `True`
    时，`queue.get` 通过如果需要暂停调用线程，直到队列中有可用项。
- en: In this step, we will code the method to handle the `game_over` feature for
    the game.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，我们将编写处理游戏 `game_over` 功能的方法。
- en: 'The `queue_handler` method calls the `game_over` method in case of a matching
    queue key:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`queue_handler` 方法在匹配队列键的情况下调用 `game_over` 方法：'
- en: '[PRE15]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The description for the code is as follows:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是代码的描述：
- en: We first set the `game_over` attribute to `True`. This helps us exit out of
    the infinite loop of `queue_handler`. Then, we add a text on the canvas displaying
    the content **Game Over**.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先将 `game_over` 属性设置为 `True`。这有助于我们退出 `queue_handler` 的无限循环。然后，我们在画布上添加一个显示内容为
    **游戏结束** 的文本。
- en: We also add a **Quit** button inside the canvas, which has a command callback
    attached to quit the root window.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还在画布内添加了一个 **退出** 按钮，该按钮附加了一个命令回调，用于退出根窗口。
- en: Tip
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take a note of how to attach other widgets inside the canvas widget.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住如何在画布小部件内附加其他小部件。
- en: 'Let''s Run the game. The game is now ready. To run the game, we create a function
    outside all other classes named `main()`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行游戏。游戏现在已准备就绪。要运行游戏，我们在所有其他类之外创建一个名为 `main()` 的函数：
- en: '[PRE16]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We create an empty queue, and pass it as an argument to all three of our classes
    so that they can feed tasks into the queue. We also bind the four directional
    keys to the `key_pressed` method, which is defined earlier within our `Snake`
    class.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建一个空队列，并将其作为参数传递给我们的三个类，以便它们可以将任务喂送到队列中。我们还绑定四个方向键到之前在 `Snake` 类中定义的 `key_pressed`
    方法。
- en: Objective Complete – Mini Debriefing
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简要回顾
- en: Our game is now functional. Go try your hands at controlling the snake, while
    keeping its stomach filled.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在已功能正常。去尝试控制蛇，同时保持它的肚子饱饱的。
- en: To summarize, we created three classes such as `Food`, `Snake`, and `GUI`. These
    three classes feed information about the task related to their class to a centralized
    queue which is passed as an argument to all the classes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们创建了三个类，如 `Food`、`Snake` 和 `GUI`。这三个类将它们各自类相关的任务信息喂送到一个集中的队列中，这个队列作为参数传递给所有类。
- en: Then, we create a centralized method named `queue_handler`, which handle tasks
    from the queue by polling tasks one at a time and completing it in a non-blocking
    manner.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为 `queue_handler` 的集中式方法，该方法通过轮询任务一次并以非阻塞方式完成任务来处理队列中的任务。
- en: The game could have been implemented without threads and queues, but it would
    have been slower, longer, and more complex. By using queues to manage data from
    multiple threads effectively, we have been able to contain the program to less
    than 150 lines of code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏可以不使用线程和队列来实现，但会慢一些，更长，也更复杂。通过使用队列来有效管理多个线程的数据，我们能够将程序代码控制在150行以下。
- en: Hopefully, you should now be able to implement queues for managing other programs
    that you design at your work.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在能够实现队列来管理你在工作中设计的其他程序。
- en: Creating a Weather Reporter
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建天气报告
- en: Let's now build a simple Weather Reporter application. The goal of this project
    is to introduce you to the basics of network programming, as used in conjunction
    with Tkinter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来构建一个简单的天气报告应用。这个项目的目标是向您介绍网络编程的基础，这是与 Tkinter 结合使用的。
- en: Prepare for Lift Off
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: Python has great support for network programming. At the lowest level, Python
    provides a socket module that lets you connect and interact with the network using
    a simple-to-use object-oriented interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对网络编程有很好的支持。在最低级别，Python 提供了一个套接字模块，它允许你使用简单易用的面向对象接口连接和与网络交互。
- en: For those unaware of network programming, sockets are the fundamental concept
    behind any kind of network communications done by your computer. This is the lowest
    level at which a programmer can access the network. Underneath the socket layer
    lie raw UDP and TCP connections, which are handled by your computer's operating
    system with no direct access points for the programmers. For instance, when you
    type [www.packtpub.com](http://www.packtpub.com) in your browser, the operating
    system on your computer opens a socket and connects to [packtpub.com](http://packtpub.com)
    to fetch the web page and show it to you. Same happens with any application that
    needs to connect to the network.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不了解网络编程的人来说，套接字是计算机进行任何类型网络通信的基本概念。这是程序员可以访问网络的最低级别。在套接字层之下是原始的 UDP 和 TCP
    连接，这些连接由计算机的操作系统处理，程序员没有直接的访问点。例如，当你将 [www.packtpub.com](http://www.packtpub.com)
    输入到浏览器中时，你的计算机操作系统打开一个套接字并连接到 [packtpub.com](http://packtpub.com) 来获取网页并显示给你。任何需要连接到网络的应用程序都会发生同样的事情。
- en: 'Let''s take a brief look at some of the APIs available in the socket module:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看套接字模块中可用的某些 API：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you look at the `7.04 socket demo.py` Python file in the code bundle of
    this project, you''ll find that it sends a very obscure looking GET request to
    fetch the contents from the URL in the following line of code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看此项目的代码包中的 `7.04 socket demo.py` Python 文件，你会发现它发送了一个非常晦涩的 GET 请求来从以下代码行获取
    URL 的内容：
- en: '`message = "GET / HTTP/1.1\r\n\r\n"`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`message = "GET / HTTP/1.1\r\n\r\n"`'
- en: The data received from the server is also sent in packets, and it is our task
    to collect all the data and assemble them at our end. All these make direct socket
    programming a tedious approach. We do not want to be writing code for all that
    to fetch data from the network.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器接收的数据也以数据包的形式发送，我们的任务是收集所有数据并在我们这一端组装它们。所有这些使得直接套接字编程变得繁琐。我们不希望编写代码来从网络中获取数据。
- en: 'We will therefore use a higher-level module named `urllib`, which is built
    on top of sockets module but is easier to use. The `urllib` module forms a part
    of Python standard library. With this protocol, fetching contents of a web page
    turns into a four-line code (see the code in `7.05 urllib demo.py`):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用一个名为 `urllib` 的高级模块，该模块建立在套接字模块之上，但使用起来更简单。`urllib` 模块是 Python 标准库的一部分。使用此协议，从网页获取内容变为四行代码（请参阅
    `7.05 urllib demo.py` 中的代码）：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This prints the entire HTML source code or whatever is the response from the
    web page [http://www.packtpub.com](http://www.packtpub.com). This is, in essence,
    the core of mining the Web for data and information.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印整个 HTML 源代码或网页的响应。本质上，这是从网络中挖掘数据和信息的核心。
- en: Now that we know how to get data from a URL, let's apply it to build a small
    Weather Reporter application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从 URL 获取数据，让我们将其应用于构建一个小型天气报告应用程序。
- en: This application should take the location as an input from the user, and fetch
    relevant weather-related data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序应从用户处获取位置作为输入，并获取相关的天气数据。
- en: '![Prepare for Lift Off](img/7941OT_07_03.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941OT_07_03.jpg)'
- en: Engage Thrusters
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First, we will create the GUI of the application. This should now be easy for
    you. We create a class `WeatherReporter`, and call it from outside the class within
    the main loop. See the code of `7.06 weather reporter.py`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建应用程序的 GUI。现在这对你来说应该很容易。我们创建一个名为 `WeatherReporter` 的类，并在主循环外部调用它。请参阅
    `7.06 weather reporter.py` 的代码：
- en: '[PRE19]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The GUI component of the `WeatherReporter` class consists of two methods: `top_frame()`
    and `display_frame()`. The `top_frame()` method creates an entry widget and a
    button that says **Show Weather Info**.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`WeatherReporter` 类的 GUI 组件由两个方法组成：`top_frame()` 和 `display_frame()`。`top_frame()`
    方法创建一个输入小部件和一个显示 **显示天气信息** 的按钮。'
- en: 'The `display_frame()` method creates a canvas where the actual weather data
    would be displayed:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`display_frame()` 方法创建一个画布，实际天气数据将在其中显示：'
- en: '[PRE20]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the second step, we are going to fetch the weather data from a website.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，我们将从网站上获取天气数据。
- en: There are two ways to fetch data from a website. The first method involves getting
    an HTML response from a website, and then parsing the received HTML response for
    data that is relevant to us. This type of data extraction is called **site scraping**
    .
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从网站获取数据有两种方式。第一种方法涉及从网站获取 HTML 响应，然后解析收到的 HTML 响应以获取与我们相关的数据。这种数据提取称为 **网站抓取**。
- en: Site scraping is a rather crude method which is employed only when a given website
    does not provide a structured way to retrieve data. On the other hand, some websites
    are willing to share data through a set of APIs, provided you query it for data
    using the specified URL structure. This is clearly more elegant than site scraping,
    because data is interchanged in a reliable and "mutually agreed" format.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 网站抓取是一种相当原始的方法，仅在给定网站不提供结构化数据检索方式时使用。另一方面，一些网站愿意通过一组API共享数据，前提是你使用指定的URL结构查询数据。这显然比网站抓取更优雅，因为数据以可靠和“相互同意”的格式交换。
- en: For our Weather Reporter application, we want to query some weather channel
    for a given location, and in turn retrieve and display the data in our canvas.
    Fortunately, there are several weather APIs which lets us do that.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的天气报告应用，我们希望查询给定位置的某些天气频道，并相应地检索和显示数据在我们的画布上。幸运的是，有几个天气API允许我们这样做。
- en: Note
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In our example, we will use the weather data provided by a the following website:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用以下网站提供的天气数据：
- en: '[http://openweathermap.org/](http://openweathermap.org/)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://openweathermap.org/](http://openweathermap.org/)'
- en: The OpenWeatherMap service provides free weather data and forecast APIs. This
    site collates weather data from more than 40,000 weather stations across the globe,
    and the data can be assessed by city name and geographic coordinates or their
    internal city ID.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OpenWeatherMap服务提供免费的天气数据和预报API。该网站从全球超过40,000个气象站收集天气数据，数据可以通过城市名称、地理坐标或其内部城市ID进行评估。
- en: 'The website provides weather data in two data formats:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该网站提供两种数据格式的天气数据：
- en: JSON (JavaScript Object Notation)
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON（JavaScript对象表示法）
- en: XML
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML
- en: Note
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: XML and JSON are two popular interchangeable data serialization formats widely
    used for data-interchanging among different applications, which may be running
    on different platforms and using different programming languages, thus providing
    the benefit of interoperability.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: XML和JSON是两种广泛使用的可互换数据序列化格式，广泛用于不同平台和不同编程语言的应用程序之间的数据交换，从而提供了互操作性的好处。
- en: JSON is simpler than XML, because its grammar is simpler and it maps more directly
    onto the data structures used in modern programming languages. JSON is better
    suited for data exchanging, but XML is good for document exchanging.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JSON比XML简单，因为它的语法更简单，并且它更直接地映射到现代编程语言中使用的数结构。JSON更适合数据交换，但XML更适合文档交换。
- en: 'The API documentation for the website tells us that a query, such as `api.openweathermap.org/data/2.5/weather?q=London,uk`
    returns us weather data for London in a JSON format as follows:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 网站的API文档告诉我们，查询如`api.openweathermap.org/data/2.5/weather?q=London,uk`将返回以JSON格式表示的伦敦天气数据，如下所示：
- en: '[PRE21]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The syntax of JSON is simple. Any JSON data is a name/value pair where each
    data is separated from the others by commas. JSON uses curly braces `{}` to hold
    objects and square brackets `[ ]` to hold arrays. We accordingly define a method
    to get the weather data in JSON format in our application (refer to `7.06 weather
    reporter.py` available in the code bundle of this project):'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JSON的语法很简单。任何JSON数据都是一个名称/值对，其中每个数据项通过逗号与其他数据项分隔。JSON使用花括号`{}`来包含对象，使用方括号`[
    ]`来包含数组。因此，我们在我们的应用程序中定义了一个方法来获取JSON格式的天气数据（参考此项目代码包中的`7.06 weather reporter.py`）：
- en: '[PRE22]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method uses `urllib` to retrieve responses from the website. It returns
    the response in JSON format.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法使用`urllib`从网站检索响应。它以JSON格式返回响应。
- en: Now, we'll start processing the JSON data. The weather data returned using API
    is encoded in JSON format. We need to convert this data into Python data type.
    Python provides a built-in `json` module that eases the process of "encoding-decoding"
    JSON data. We therefore import the `json` module into our current namespace.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将开始处理JSON数据。通过API返回的天气数据是编码在JSON格式的。我们需要将此数据转换为Python数据类型。Python提供了一个内置的`json`模块，它简化了“编码-解码”JSON数据的过程。因此，我们将`json`模块导入到当前命名空间中。
- en: 'Then, we''ll use this module to convert the retrieved JSON data into Python
    dictionary format (refer to `7.06 weather reporter.py`):'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将使用此模块将检索到的JSON数据转换为Python字典格式（参考`7.06 weather reporter.py`）：
- en: '[PRE23]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we''ll display the retrieved weather data. Now that we have a dictionary
    of all weather-related information provided by the API, let''s add a command callback
    to the button:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将显示检索到的天气数据。现在，我们已经有了API提供的所有与天气相关的信息的字典，让我们给按钮添加一个命令回调：
- en: '[PRE24]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `display_final` method simply takes each item from the dictionary and displays
    it on the canvas using `create_text`. We do not include the code for `display_final`
    because it merely displays the data on the canvas, and this idea should be self-explanatory
    by now. The API also provides an icon-related data. The icons are stored in a
    folder named `weatherimages` (refer to the folder with the same name provided
    in the code bundle) and an appropriate icon is displayed using `canvas.create_image`.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`display_final`方法简单地从字典中取出每个条目，并使用`create_text`在画布上显示它。我们不包含`display_final`的代码，因为它仅仅是在画布上显示数据，这个想法现在应该已经很明确了。API还提供了与图标相关的数据。图标存储在名为`weatherimages`的文件夹中（参考代码包中提供的同名文件夹），并使用`canvas.create_image`显示适当的图标。'
- en: Objective Complete – Mini Debriefing
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简要回顾
- en: Our Weather Reporter application is now functional. In essence, the application
    uses the `urllib` module to query the weather API provided by our data provider.
    The data is fetched in JSON format. The JSON data is then decoded into a Python-readable
    format (dictionary).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的天气报道应用程序现在已功能齐全。本质上，该应用程序使用`urllib`模块查询我们数据提供商提供的天气API。数据以JSON格式获取。然后JSON数据被解码成Python可读的格式（字典）。
- en: The converted data is then displayed on the canvas using `create_text` and `create_image`
    methods.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的数据随后使用`create_text`和`create_image`方法在画布上显示。
- en: Classified Intel
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类情报
- en: When you access a server from your Python program, it is very important to send
    requests after small time gaps.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从Python程序访问服务器时，在发送请求后保持小的时间间隔非常重要。
- en: A typical Python program is capable of running several million instructions
    per second. However, the server that sends you the data at the other end is never
    equipped to work at that speed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Python程序每秒可以运行数百万条指令。然而，在另一端向您发送数据的服务器永远不会配备以这种速度工作的能力。
- en: If you knowingly or unknowingly send large number of requests to a server within
    a short time-span, you may hamper it from servicing its routine requests from
    normal web users. This constitutes what is called the **denial of service** (**DOS**)
    attack on the server. You may be banned or, in worse case, sued for disrupting
    a server, if your program does not make a limited number of well-behaved requests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在短时间内有意或无意地发送大量请求到服务器，可能会妨碍它为正常网络用户处理常规请求。这构成了对服务器的**拒绝服务**（DOS）攻击。如果您的程序没有发送有限数量的良好行为请求，您可能会被禁止，或者在更糟糕的情况下，因破坏服务器而起诉。
- en: Creating a phonebook application
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建电话簿应用程序
- en: Let's now build a simple phonebook application that allows the user to store
    names and phone numbers. The user should be able to create new records, read existing
    records, update existing records, and delete records from the database using this
    application. Together, these activities constitute what is known as **CRUD** (Create,
    Read, Update and Delete) operations on a database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来构建一个简单的电话簿应用程序，允许用户存储姓名和电话号码。用户应该能够使用此应用程序创建新记录、读取现有记录、更新现有记录以及从数据库中删除记录。这些活动共同构成了在数据库上所知的**CRUD**（创建、读取、更新和删除）操作。
- en: The main learning objective for this project relates to being able to use a
    relational database with Tkinter to store and manipulate records.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的核心学习目标是与Tkinter一起使用关系数据库存储和操作记录。
- en: We have already seen some basic examples of object persistence with serialization.
    Relational databases extend this persistence using rules of relational algebra
    to store data into tables.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些使用序列化的基本对象持久化示例。关系数据库通过关系代数的规则扩展这种持久性，将数据存储到表中。
- en: Python provides database interfaces for a wide range of database engines. In
    addition, Python provides a generic interface standard that can be used to access
    database engines, but it is not natively available as a Python module.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Python为广泛的数据库引擎提供了数据库接口。此外，Python提供了一个通用的接口标准，可以用来访问数据库引擎，但它不是作为Python模块原生的。
- en: Some of the commonly-used database engines include MySQL, SQLite, PostgreSQL,
    Oracle, Ingres, SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server,
    Microsoft Access, and so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的数据库引擎包括MySQL、SQLite、PostgreSQL、Oracle、Ingres、SAP DB、Informix、Sybase、Firebird、IBM
    DB2、Microsoft SQL Server、Microsoft Access等等。
- en: We will use SQLite to store data for our phonebook application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用SQLite存储电话簿应用程序的数据。
- en: Prepare for Lift Off
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: SQLite is a server-less, zero-configuration, self-contained SQL database engine
    suitable for developing embedded applications. The source code for SQLite is in
    the public domain, which makes it freely available for use in all sorts of commercial
    and non-commercial projects.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是一个无服务器、零配置、自包含的 SQL 数据库引擎，适用于开发嵌入式应用程序。SQLite 的源代码属于公共领域，这使得它可以在所有商业和非商业项目中免费使用。
- en: Unlike many other SQL databases, SQLite does not require running a separate
    server process. Instead, SQLite stores all the data directly onto flat files which
    get stored on a computer disk. These files are easily portable across different
    platforms, making it a very popular choice for smaller and simpler database implementation
    requirements.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他 SQL 数据库不同，SQLite 不需要运行单独的服务器进程。相反，SQLite 将所有数据直接存储到计算机磁盘上的平面文件中。这些文件在不同平台上易于移植，使其成为小型和简单数据库实现需求的热门选择。
- en: Python 2.7 comes with a built-in standard library for sqlite3 support. However,
    we need to download the sqlite3 command-line tool that lets us create, modify,
    and access the database using a command-line tool. The command-line shell for
    Windows, Linux, and Mac OS X can be downloaded from [http://sqlite.org/download.html](http://sqlite.org/download.html).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.7 内置了 sqlite3 支持的标准库。然而，我们需要下载 sqlite3 命令行工具，这样我们就可以使用命令行工具创建、修改和访问数据库。Windows、Linux
    和 Mac OS X 的命令行壳可以从 [http://sqlite.org/download.html](http://sqlite.org/download.html)
    下载。
- en: Following the instruction on the website, install the SQLite command shell into
    any location of your choice.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按照网站上的说明，将 SQLite 命令行工具安装到您选择的任何位置。
- en: 'Let us now implement our phonebook application. The application will look like
    the screenshot shown in the following. The application will demonstrate some of
    the common operations involved in database programming, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现我们的电话簿应用程序。该应用程序将类似于以下截图所示。该应用程序将演示数据库编程中的一些常见操作，如下所示：
- en: '![Prepare for Lift Off](img/7941OT_07_04.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941OT_07_04.jpg)'
- en: Engage Thrusters
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: In order to create the database, we open the command-line tool of our operating
    system. On Windows, we generally invoke the command line by typing `cmd` in the
    run console.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建数据库，我们打开操作系统的命令行工具。在 Windows 上，我们通常通过在运行控制台中键入 `cmd` 来调用命令行。
- en: 'Within the command line, we first navigate to the directory where we need to
    create the new database file. In order to create the database, we simply use this
    command:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在命令行中，我们首先导航到需要创建新数据库文件的目录。为了创建数据库，我们只需使用此命令：
- en: '[PRE25]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This creates a database file named `phonebook.db` in the folder from which
    we execute the command. It also displays a message similar to the one shown below:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在我们执行命令的文件夹中创建一个名为 `phonebook.db` 的数据库文件。它还会显示类似于以下的消息：
- en: '[PRE26]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have now created a database named `phonebook.db`. However, the database
    file is currently empty. It does not contain any tables or any data. So, we get
    no results if we run the command:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个名为 `phonebook.db` 的数据库。然而，数据库文件目前是空的。它不包含任何表或数据。因此，如果我们运行以下命令，我们将得到没有结果：
- en: '[PRE27]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s for now exit the command-line tool by typing:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们通过键入以下内容退出命令行工具：
- en: '[PRE28]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We want to store contacts in our database, and that is why we need to create
    the c`ontacts` table. Intuitively, our database table should store a person's
    name and phone number. In addition, it is a good practice to keep a unique identification
    number for each person or each entry in the table. This is because multiple people
    might have the same name or same contact number.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想在数据库中存储联系人，这就是为什么我们需要创建 `contacts` 表。直观上，我们的数据库表应该存储一个人的姓名和电话号码。此外，为每个人或表中的每个条目保留一个唯一的识别号码是一个好习惯。这是因为可能有多个人的名字或联系号码相同。
- en: 'To create a table within our `phonebook.db` database, we again open the command-line
    tool and navigate to the directory where we had created the database. We again
    get into the sqlite3 terminal by typing:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在 `phonebook.db` 数据库中创建一个表，我们再次打开命令行工具并导航到创建数据库的目录。我们再次通过键入以下内容进入 sqlite3 终端：
- en: '[PRE29]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This time a new database is not created. Rather, the command now opens the existing
    `phonebook.db` database, because it is already present on the disk.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次没有创建新的数据库。相反，该命令现在打开现有的 `phonebook.db` 数据库，因为它已经存在于磁盘上。
- en: 'Next, we create a table named `contacts`, and add three columns to the table
    from the command line:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 `contacts` 的表，并从命令行向表中添加三个列：
- en: '[PRE30]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can verify if the `contacts` table was created by typing the following
    command:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过输入以下命令来验证是否创建了 `contacts` 表：
- en: '[PRE31]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This prints the name of all the tables present in the currently open database.
    You will get the following output:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印出当前打开的数据库中所有表的名字。您将得到以下输出：
- en: '[PRE32]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s first begin by creating a basic GUI that would let us add, view, delete,
    and modify the records. We create a class named `PhoneBook` and create all GUI
    widgets from within its `__init__` method (refer to `7.07 phonebook.py`):'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个基本的GUI，这样我们就可以添加、查看、删除和修改记录。我们创建一个名为 `PhoneBook` 的类，并在其 `__init__` 方法中创建所有GUI小部件（参考
    `7.07 phonebook.py`）：
- en: '[PRE33]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We do not rewrite the code here, because we have created similar widgets in
    all our previous projects.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里不重写代码，因为我们已经在所有之前的项目中创建了类似的部件。
- en: Let's start creating the records in the database file we created. A new record
    is to be created every time a user enters a new name and a phone number in the
    entry widgets provided, and clicks on the **Add Record** button.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始创建我们创建的数据库文件中的记录。每次用户在提供的输入小部件中输入新的姓名和电话号码，并点击 **添加记录** 按钮时，都会创建一个新的记录。
- en: '[PRE34]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The description of the code is as follows:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `create_record` method, as defined above, is attached as a command callback
    to the **Add Record** button.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如上所述定义的 `create_record` 方法被附加为 **添加记录** 按钮的命令回调。
- en: When the `create_record` method is called, it retrieves the name and number
    values entered in the **Name** and **Contact Number** entry field.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 `create_record` 方法时，它会检索在 **姓名** 和 **联系号码** 输入字段中输入的姓名和号码值。
- en: If the name or number field is empty, it prints an error message and exits.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果姓名或号码字段为空，它将打印一条错误消息并退出。
- en: If name and number fields are valid, the method establishes connection to the
    `phonebook.db` database we had created earlier.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果姓名和号码字段有效，该方法将连接到我们之前创建的 `phonebook.db` 数据库。
- en: The next line, `c = conn.cursor()`, creates a cursor object. The cursor is a
    control structure that is required as per SQL standards, and it enables us to
    traverse over the records in a database.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个行，`c = conn.cursor()`，创建了一个游标对象。游标是一个按照SQL标准要求的控制结构，它使我们能够遍历数据库中的记录。
- en: 'The next line, `c.execute(query)` is the line that actually inserts the name
    and phone number into database. Note that it includes three insertion values:
    the first is the NULL value corresponding to autoincrement contact ID which is
    added through that we had created in our `contacts` table.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个行，`c.execute(query)` 是实际将姓名和电话号码插入数据库的行。注意，它包括三个插入值：第一个是自动递增的联系人ID对应的NULL值，这是通过我们在
    `contacts` 表中创建的来添加的。
- en: The line `conn.commit()` actually commits these changes to the database and
    line `c.close()` closes the connection to the database.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conn.commit()` 这一行实际上将更改提交到数据库，而 `c.close()` 行则关闭了与数据库的连接。'
- en: After the above steps are carried out, we will view the records stored in the
    database. This method is responsible for fetching all the records from the database
    and displaying them in the tree widget.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行上述步骤之后，我们将查看存储在数据库中的记录。该方法负责从数据库中检索所有记录并在树形小部件中显示它们。
- en: '[PRE35]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The description of the code is as follows:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `view_records` method first deletes all existing items being displayed in
    the tree widget
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view_records` 方法首先删除在树形小部件中显示的所有现有项目'
- en: It then establishes a database connection and queries the database to fetch
    all the data sorted by name in descending order
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它建立数据库连接并查询数据库以按姓名降序获取所有数据
- en: Finally, it iterates over the fetched record to update the tree widget with
    the content
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它遍历检索到的记录以更新树形小部件的内容
- en: 'Now, on the phonebook application we''ll delete some records. The `delete_record`
    method is simply responsible for deleting a row from the database based on a given
    name criterion:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在电话簿应用程序中，我们将删除一些记录。`delete_record` 方法简单地负责根据给定的姓名标准从数据库中删除一行：
- en: '[PRE36]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although we have created this deletion query based on name, this method runs
    the risk of deleting multiple entries if two or more person have the same name.
    A better approach would be to delete the entries based on the primary key or contact
    id, which is unique for every entry in the table.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管我们根据姓名创建了此删除查询，但如果两个人或更多人具有相同的姓名，这种方法会存在删除多个条目的风险。更好的方法是根据主键或联系人ID来删除条目，因为每个条目在表中的联系人ID都是唯一的。
- en: The final operation in the phonebook application is modifying the records. When
    a user selects a particular record and clicks on the **Modify Selected** button,
    it opens a new Toplevel window like the one shown here:![Engage Thrusters](img/7941OT_07_05.jpg)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电话簿应用程序中的最终操作是修改记录。当用户选择一个特定的记录并点击**修改所选**按钮时，它会打开一个新顶层窗口，就像这里显示的那样：![Engage
    Thrusters](img/7941OT_07_05.jpg)
- en: This window is created using the `open_modify_window` method, as defined in
    the `7.07 phonebook.py` Python file. We will not reproduce the code for this method,
    because you should be comfortable making such windows by now.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此窗口是通过`open_modify_window`方法创建的，该方法定义在`7.07 phonebook.py` Python文件中。我们不会复制此方法的代码，因为现在你应该已经能够舒适地创建这样的窗口。
- en: 'When a user specifies a new number and clicks the **Update Record** button,
    it calls the `update_record` method, which is defined in the following:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户指定一个新的数字并点击**更新记录**按钮时，它会调用`update_record`方法，该方法定义如下：
- en: '[PRE37]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Objective Complete – Mini Debriefing
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: We have completed coding a basic phonebook application.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了基本电话簿应用程序的编码。
- en: More importantly, we have seen how to work with databases. Our phonebook application
    has demonstrated how to execute basic create, read, update, and delete (CRUD)
    operations on a database.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们已经看到了如何与数据库一起工作。我们的电话簿应用程序展示了如何在数据库上执行基本的创建、读取、更新和删除（CRUD）操作。
- en: We have seen how to create database, add tables to the database, and query the
    database to add, modify, delete, and view items in the database.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建数据库，向数据库添加表，以及查询数据库以添加、修改、删除和查看数据库中的项目。
- en: Furthermore, due to similarity of basic database operations, you can now consider
    working with other database systems, such as MySQL, PostgreSQL, Oracle, Ingres,
    SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server, and Microsoft
    Access.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于基本数据库操作相似，你现在可以考虑使用其他数据库系统，例如MySQL、PostgreSQL、Oracle、Ingres、SAP DB、Informix、Sybase、Firebird、IBM
    DB2、Microsoft SQL Server和Microsoft Access。
- en: Graphing with Tkinter
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter进行绘图
- en: Let us wrap up this project by looking at the graphing abilities of the Tkinter
    canvas widget.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看Tkinter canvas小部件的绘图能力来总结这个项目。
- en: Engage Thrusters
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Engage Thrusters
- en: 'In this recipe we will see how we can plot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到我们如何可以绘制：
- en: Pie chart
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼图
- en: Scatter chart
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图
- en: Bar graph
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条形图
- en: Embedding matplotlib graphs
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入matplotlib图形
- en: 'Let''s look at the pie chart first:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看饼图：
- en: '![Engage Thrusters](img/7941OT_07_06.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![Engage Thrusters](img/7941OT_07_06.jpg)'
- en: 'You can easily create pie charts in Tkinter using the Canvas widget''s `create_arc`
    method. A sample Pie Chart code is provided in `7.08 pie chart.py`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用Canvas小部件的`create_arc`方法轻松地在Tkinter中创建饼图。示例饼图代码在`7.08 pie chart.py`中提供：
- en: '[PRE38]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The description of the code is as follows:'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: 'Each portion of the pie chart is drawn by changing the two following `create_arc`
    options:'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼图的每个部分都是通过改变以下两个`create_arc`选项来绘制的：
- en: '`start`: This option specifies the start angle. Default is `0.0`.'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start`：此选项指定起始角度。默认为`0.0`。'
- en: '`extent`: This option specifies the size of `arc` relative to the start angle.
    Default is `90.0`.'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`extent`：此选项指定`arc`相对于起始角度的大小。默认为`90.0`。'
- en: Next, we'll plot a sample scatter chart:![Engage Thrusters](img/7941OT_07_07.jpg)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制一个示例散点图：![Engage Thrusters](img/7941OT_07_07.jpg)
- en: 'Similarly, we can use `create_line` to draw the *x* and *y* axes and `create_oval`
    to draw the scatter plots, as shown in the preceding screenshot here. A sample
    scatter plot code is provided in the `7.09 scatter plot.py` Python file:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用`create_line`来绘制*x*和*y*轴，并使用`create_oval`来绘制散点图，如前述截图所示。示例散点图代码在`7.09
    scatter plot.py` Python文件中提供：
- en: '[PRE39]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's plot a sample bar graph:![Engage Thrusters](img/7941OT_07_08.jpg)
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们绘制一个示例条形图：![Engage Thrusters](img/7941OT_07_08.jpg)
- en: 'A bar graph can be easily generated using the Canvas widget''s `create_rectangle`
    method. A sample bar graph code is provided in `7.10 bar graph.py`:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用Canvas小部件的`create_rectangle`方法轻松生成条形图。示例条形图代码在`7.10 bar graph.py`中提供：
- en: '[PRE40]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, we're going to look at how to embed matplotlib graphs in Tkinter Toplevel
    window.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何在Tkinter Toplevel窗口中嵌入matplotlib图形。
- en: Using Tkinter Canvas to draw graphs may work fine for trivial cases. However,
    Tkinter may not be the best library when it comes to drawing more sophisticated
    and interactive graphs.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Tkinter Canvas绘制图形对于简单情况可能工作得很好。然而，当涉及到绘制更复杂和交互式图形时，Tkinter可能不是最好的库。
- en: In fact, matplotlib is used in conjunction with the **NumPy** module is the
    preferred choice when it comes to producing professional-quality graphs with Python.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实上，当涉及到使用 Python 生成专业质量的图形时，matplotlib 与 **NumPy** 模块结合使用是首选选择。
- en: '![Engage Thrusters](img/7941OT_07_09.jpg)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Engage Thrusters](img/7941OT_07_09.jpg)'
- en: Although a detailed discussion on matplotlib is beyond the scope of this book,
    we will take a brief look at embedding matplotlib-generated graphs on a Tkinter
    canvas.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管对 matplotlib 的详细讨论超出了本书的范围，但我们将简要看看如何在 Tkinter 画布上嵌入由 matplotlib 生成的图形。
- en: Tip
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are interested in exploring advanced graphing with Python, you can install
    matplotlib and NumPy (a dependency for matplotlib) with the help of the installation
    instructions available at [http://matplotlib.org/users/installing.html](http://matplotlib.org/users/installing.html)
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你对探索 Python 的高级绘图感兴趣，你可以通过在 [http://matplotlib.org/users/installing.html](http://matplotlib.org/users/installing.html)
    可用的安装说明的帮助下安装 matplotlib 和 NumPy（matplotlib 的依赖项）。
- en: '[PRE41]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Objective Complete – Mini Debriefing
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简要回顾
- en: This completes our brief discussion on the graphing abilities of Tkinter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对 Tkinter 绘图能力的简要讨论。
- en: In this iteration, we saw how to use Tkinter Canvas to draw basic graphs such
    as pie chart, scatter plots, and bar graphs.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们看到了如何使用 Tkinter Canvas 绘制基本的图表，如饼图、散点图和条形图。
- en: We also saw how to embed more sophisticated matplotlib graphs, on the Tkinter
    drawing area.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何在 Tkinter 绘图区域嵌入更复杂的 matplotlib 图形。
- en: Mission Accomplished
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: This brings us to the end of this project. In this project, we took a deeper
    look into some of the many things that can be done with Tkinter Canvas widget.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着本项目的结束。在这个项目中，我们深入研究了 Tkinter Canvas 小部件可以完成的一些众多事情。
- en: We also learned how to use the Queue implementation to program a multithreaded
    application.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用 Queue 实现来编写多线程应用程序。
- en: The Weather Reporter application introduced us to the basics of network programming
    and how to tap into the Internet for our data needs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 天气预报员应用程序向我们介绍了网络编程的基础知识以及如何利用互联网来满足我们的数据需求。
- en: The phonebook application showed us how to work with databases.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 电话簿应用程序展示了我们如何与数据库协同工作。
- en: Finally, we looked at basic graphing abilities of Tkinter, and we also looked
    at ways of embedding matplotlib graphs in Tkinter.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了 Tkinter 的基本绘图能力，以及如何在 Tkinter 中嵌入 matplotlib 图形。
- en: A Hotshot Challenge
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热门挑战
- en: '**Screen saver challenge**: We have used the `create_oval` method of the Canvas
    widget to create multiple balls in our screen saver program. Try to experiment
    by replacing the oval with other canvas-supported shapes, such as lines, rectangles,
    and arcs.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏保挑战**：我们在屏保程序中使用了 Canvas 小部件的 `create_oval` 方法来创建多个球。尝试通过用其他 Canvas 支持的形状（如线条、矩形和弧线）替换椭圆来实验。'
- en: In fact, because you can use the `create_image` method on Canvas, how about
    creating an aquarium brimming with different varieties of fishes, snails, aquatic
    animals, and plants? You can even add sky divers bubbling their way through the
    marine life!
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实上，因为你可以使用 Canvas 上的 `create_image` 方法，那么创建一个充满不同种类鱼、蜗牛、水生动物和植物的鱼缸怎么样？你甚至可以添加正在海洋生物中穿梭的跳伞者！
- en: '**Snake game challenge**: Implement different levels of the Snake game by introducing
    mazes on the canvas.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蛇游戏挑战**：通过在画布上引入迷宫来实现蛇游戏的多个级别。'
- en: '**Network programming challenge**: Implement any other program that leverages
    the data available on the Internet to provide some value to the end user.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络编程挑战**：实现任何其他利用互联网上可用数据为最终用户提供价值的程序。'
- en: '**Database challenge**: Revisit your media player program and implement a database
    to store playlists and automatically populate the media player when it is run.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库挑战**：回顾你的媒体播放器程序，并实现一个数据库来存储播放列表，并在程序运行时自动填充媒体播放器。'
- en: '**Graphing challenge**: Explore advanced graphing capabilities of matplotlib.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘图挑战**：探索 matplotlib 的高级绘图功能。'
