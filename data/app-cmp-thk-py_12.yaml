- en: '*Chapter 10*: Control Flow'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：控制流'
- en: In this chapter, we will take a deeper look at problems and identify the input
    and output necessary to design an algorithm for our problems. Throughout this
    chapter, you will learn how algorithms are read and the order in which instructions
    are carried out. You will also learn how to use functions and loops to manipulate
    the control flow in your algorithms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究问题，并确定设计算法所需的输入和输出。在本章中，你将学习算法的阅读方式以及指令执行的顺序。你还将学习如何使用函数和循环来操纵算法中的控制流。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining control flow and its tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义控制流及其工具
- en: Using if, for, and range() and other control flow tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用if、for和range()以及其他控制流工具
- en: Using loops and conditionals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环和条件语句
- en: Revisiting functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视函数
- en: By the end of the chapter, we will learn how control flow is defined, how we
    use the `if`, `for`, and `range()` functionalities when designing algorithms in
    computational thinking, and how to incorporate these functionalities into function
    definitions in our algorithms. Let's take a look at what control flow is first.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学习控制流是如何定义的，我们在计算思维中设计算法时如何使用`if`、`for`和`range()`功能，以及如何将这些功能纳入算法中的函数定义中。让我们先来看看什么是控制流。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter10](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter10)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要最新版本的Python来运行本章中的代码。你可以在这里找到本章使用的完整源代码：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter10](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter10)
- en: Defining control flow and its tools
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义控制流及其工具
- en: 'Simply defined, **control flow** is the order in which an algorithm reads and
    executes instructions, functions, and statements. Control flow means the computer
    will make a decision. Think about it this way: when I go outside my building,
    I''ll either use an umbrella or I won''t use an umbrella. That depends on whether
    or not it is raining (and whether or not I remembered my umbrella, I guess). Depending
    on that condition, we make a decision. That process is the control flow process
    in algorithm design.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，**控制流**是算法读取和执行指令、函数和语句的顺序。控制流意味着计算机会做出决定。想想看：当我走出大楼时，我要么用伞，要么不用伞。这取决于天气是否下雨（我是否记得带伞，我猜）。根据这个条件，我们做出决定。这个过程就是算法设计中的控制流程。
- en: 'Let''s look at some of the control flow statements available in the Python
    programming language:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Python编程语言中可用的一些控制流语句。
- en: '`while`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`当`'
- en: '`if`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`如果`'
- en: '`for`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对于`'
- en: '`range()`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`范围()`'
- en: '`break`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`中断`'
- en: '`continue`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`继续`'
- en: list comprehensions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导
- en: The `pass` statement
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通过`语句'
- en: The `try` statement
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`尝试`语句'
- en: These tools allow the algorithm to do things such as run so long as a certain
    condition or set of conditions is met, stop or break when a condition happens,
    continue for a range of values only, and so on. Let's take a closer look at some
    of these tools.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具允许算法做一些事情，比如只要满足某个条件或一组条件，就可以运行，当条件发生时停止或中断，仅在一定范围内继续等等。让我们更仔细地看看其中一些工具。
- en: Using if, for, and range() and other control flow statements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if、for和range()以及其他控制流语句
- en: 'Let''s start with `if` statements, which we first discussed in [*Chapter 4*](B15413_04_Final_SK_ePub.xhtml#_idTextAnchor071),
    *Understanding Logical Reasoning*. These are probably the most commonly used and
    known statements in algorithm design. You may recall learning about **conditional
    statements** in geometry as you studied reasoning and proofs. In those classes,
    you would write statements in *if-then* format. Take the following statement:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`if`语句开始，我们在[*第4章*](B15413_04_Final_SK_ePub.xhtml#_idTextAnchor071)中首次讨论了这些内容，*理解逻辑推理*。这可能是算法设计中最常用和最知名的语句。你可能还记得在学习推理和证明时，在几何学中学习了**条件语句**。在那些课程中，你会以*如果-那么*的格式编写语句。接下来是一个例子：
- en: '*When it rains, I wear a raincoat.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*下雨时，我穿雨衣。*'
- en: 'This is not a conditional statement, at least not yet. If we were going to
    write it as a conditional sentence, then we''d have to have the *if-then* format,
    much like this sentence. Take a look at the converted statement that follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个条件语句，至少现在不是。如果我们要将它写成条件句，那么我们就必须以*如果-那么*的格式来写，就像这个句子一样。看看接下来转换后的语句：
- en: '*If it rains, then I wear a raincoat.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下雨，我就穿雨衣。
- en: As you can see, we use conditions as part of our everyday lives. We just don't
    point them out.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在日常生活中使用条件。我们只是没有指出它们。
- en: When writing algorithms, we have to explicitly state what we need the algorithm
    to do, so we have to explicitly state these statements. In programming, we have
    to state each condition. Additionally, if we have a series of conditions that
    need to be met, we sometimes need to *nest* the statements. This is best explained
    with some examples. Let's start with how we use nested statements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写算法时，我们必须明确陈述算法需要做什么，所以我们必须明确陈述这些语句。在编程中，我们必须陈述每个条件。此外，如果我们有一系列需要满足的条件，有时我们需要*嵌套*这些语句。这最好通过一些例子来解释。让我们从如何使用嵌套语句开始。
- en: Using nested if statements
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用嵌套if语句
- en: Even in our everyday lives, some conditions depend on others. For example, if
    it's Monday, we have to go to work. If we have to go to work and it's raining,
    we may need an umbrella. But if we're not going to work (and assuming we're staying
    home), we won't need to check whether we need an umbrella. That's the same with
    nested statements. We use them to check one condition, then another, which is
    nested.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在日常生活中，某些条件也取决于其他条件。例如，如果是星期一，我们就必须去上班。如果我们必须去上班而且下雨了，我们可能需要一把伞。但如果我们不去上班（假设我们呆在家里），我们就不需要检查是否需要伞。嵌套语句也是如此。我们使用它们来检查一个条件，然后是另一个条件，这是嵌套的。
- en: 'Let''s say we are playing a dice game. You roll a die and get points as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在玩一个掷骰子游戏。你掷骰子并得到如下分数：
- en: 2, 4, or 6 = 10 points
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2、4或6 = 10分
- en: 1 or 3 = 5 points
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1或3 = 5分
- en: 5 = 0 points and removes all previous points
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 = 0分并清除所有之前的点数
- en: 'Each round, a player has to roll twice. Let''s look at a flowchart with the
    first roll shown, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每一轮，玩家都必须掷两次骰子。让我们看一个包含第一次掷骰子的流程图，如下所示：
- en: '![Figure 10.1 – Flowchart of first roll scores'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 - 第一次掷骰子得分的流程图'
- en: '](image/Figure_10.1_B15413.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.1_B15413.jpg)'
- en: Figure 10.1 – Flowchart of first roll scores
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - 第一次掷骰子得分的流程图
- en: 'As you can see from the flowchart, the score depends on the number rolled.
    Now, let''s say you had rolled a **1**. Then, let''s take a look at what your
    second roll could look like in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从流程图中可以看出，得分取决于掷出的数字。现在，假设你掷出了**1**。然后，让我们看看你的第二次掷骰子可能是什么样子，如下图所示：
- en: '![Figure 10.2 – Flowchart of the second roll after rolling 1'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 - 在掷出1后进行第二次掷骰子的流程图'
- en: '](image/Figure_10.2_B15413.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.2_B15413.jpg)'
- en: Figure 10.2 – Flowchart of the second roll after rolling 1
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - 在掷出1后进行第二次掷骰子的流程图
- en: 'As you can see, we have three possible total points by the player. To translate
    this into an algorithm, we''ll need to do a few things:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，玩家有三种可能的总得分。为了将其转化为算法，我们需要做一些事情：
- en: Define the roll.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义掷骰子。
- en: Determine the score based on the number rolled.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据掷出的数字确定得分。
- en: Roll again.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再掷一次。
- en: Determine the final score based on the second roll.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据第二次掷骰子确定最终得分。
- en: 'Let''s first define that roll. We''ll need to virtually roll the dice. That
    means that we''ll need the program to choose a number between `1` and `6`. Let''s
    take a look at how we code that. Keep in mind that this is just a snippet of the
    larger code contained in this file. We''ll use the second `ready` (`ready2`) in
    a subsequent snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义那个点数。我们需要虚拟地掷骰子。这意味着我们需要程序在`1`和`6`之间选择一个数字。让我们看看我们如何编写代码。请记住，这只是包含在这个文件中的更大代码的一部分。我们将在随后的片段中使用第二个`ready`(`ready2`)：
- en: ch10_rollDice.py
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_rollDice.py
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice in the preceding snippet that we had to import the `random` library
    for this particular algorithm. Importing it as `rand` instead of `random` allows
    us to truncate a bit of the code so that we type less. So, instead of `random.randint()`,
    we use `rand.randint()`. We need the `random` library because we want to have
    access to the *random integer function* so that the algorithm can choose a number
    between `1` and `6` (including both endpoints). Let''s take a look at the output
    as it stands now:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的代码片段中，我们需要为这个特定的算法导入`random`库。将其导入为`rand`而不是`random`可以让我们缩短一些代码，从而减少输入。因此，我们使用`rand.randint()`而不是`random.randint()`。我们需要`random`库，因为我们希望能够访问*随机整数函数*，以便算法可以在`1`和`6`之间选择一个数字（包括两个端点）。让我们看看当前的输出：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice from the preceding output that the instructions were provided first,
    then once the player chose to roll by pressing the `r` key, the game chose a random
    integer and displayed it. It also displayed the current score after round `1`.
    Now, let''s take a look at the next part of the algorithm, which does the second
    roll. Notice that the indentations follow the previous code snippet. This snippet
    is contained in the previous larger file as well:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出中可以看出，首先提供了说明，然后一旦玩家按下`r`键选择掷骰子，游戏就会选择一个随机整数并显示出来。它还显示了第一轮后的当前得分。现在，让我们看看算法的下一部分，即进行第二次掷骰子。请注意，缩进遵循前面的代码片段。这个片段也包含在之前的较大文件中：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we run the new code, it shows the *first-round score*, both rolls, and
    a final score for the game. Remember, if we roll a `5` in the second round, we
    lose all our points:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行新代码时，它会显示*第一轮得分*，两次掷骰子和游戏的最终得分。请记住，如果我们在第二轮中掷出`5`，我们将失去所有的点数：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the program printed a few things for us. First, we rolled a
    `2` and a `6`, so we did not lose our points. Second, both `2` and `6` carry a
    score of `10` each, for a final score of `20`. But let's look back at the nested
    `if` statements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，程序为我们打印了一些内容。首先，我们掷出了`2`和`6`，所以我们没有失去我们的点数。其次，`2`和`6`都有10分，最终得分为20分。但让我们回顾一下嵌套的`if`语句。
- en: To even begin the game, we had to verify whether the player was ready to roll.
    That first `if` statement is necessary to carry on to the rest of the decisions.
    *Could we have rolled without the go-ahead?* Yes. But think of all the games out
    there, including app versions of traditional board games. In those apps, the player
    always hits a button or the die to play. This is a similar scenario.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始游戏，我们必须验证玩家是否准备好掷骰子。第一个`if`语句是必要的，以便继续进行其他决定。*我们可以在没有许可的情况下掷骰子吗？* 可以。但想想所有的游戏，包括传统棋盘游戏的应用版本。在这些应用中，玩家总是按下按钮或骰子来玩。这是一个类似的情况。
- en: After we have said we are ready to roll, decisions have to be made about the
    points. We needed `if`, `elif`, and `else` statements again to loop through the
    various options. Now, let's take a look at when we can use `for` loops and `range`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们说好准备掷骰子之后，就必须对点数做出决定。我们再次需要使用`if`、`elif`和`else`语句来循环遍历各种选项。现在，让我们看看何时可以使用`for`循环和`range`。
- en: Using for loops and range
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用for循环和range
- en: 'The first thing we need to discuss with `for` loops is that there can sometimes
    be some confusion over variables and `for` loop conditions. To see what I mean,
    let''s look at an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先讨论的是`for`循环中有时会对变量和`for`循环条件产生一些混淆。为了理解我的意思，让我们看一个例子：
- en: ch10_forLoop1.py
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_forLoop1.py
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding snippet of code, `letter` isn''t a variable. It''s just telling
    Python that we want to iterate over each character in the word `mountain`. However,
    I could have called it anything. The program will do the exact same thing if I
    wrote it as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，`letter`不是一个变量。它只是告诉Python我们想要迭代单词`mountain`中的每个字符。不过，我可以随便起名字。如果我写成下面这样，程序会做完全相同的事情：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In each case, using `letter`, or `pin`, or whatever word makes me happy at
    that moment, the output of the program looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，使用`letter`、`pin`或者任何让我当时感到高兴的单词，程序的输出看起来像这样：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, Python iterated through each letter in the word `mountain`
    and printed it to the console. This same thing can be done with numbers in a range.
    For example, if I wanted to print the numbers `1` through `10`, I could use a
    `for` loop, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Python迭代了单词`mountain`中的每个字母，并将其打印到控制台上。同样的事情也可以用范围内的数字来做。例如，如果我想打印出`1`到`10`的数字，我可以使用`for`循环，如下所示：
- en: ch10_forLoop2.py
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_forLoop2.py
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Wait, I said I wanted the numbers 1 through 10, so why is there an 11 in the
    range function?* That''s because the `range()` function always includes the minimum
    value in the range, but not the upper boundary. So, we need to add `1` to whatever
    our top number is. Let''s take a look at what the output for this program looks
    like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*等等，我说我想要1到10的数字，为什么范围函数中有11呢？*那是因为`range()`函数总是包括范围内的最小值，但不包括上限。因此，我们需要在我们的顶部数字上加`1`。让我们看看这个程序的输出是什么样子的：'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, each number is printed on a separate line. So, let''s look
    at what we can do if we just wanted to add those same numbers to a list instead.
    Instead of printing them one at a time, we could append them to a new list, then
    print out the list. This is really helpful for some kinds of algorithms and games.
    But before I get into those, let''s first look at how we append the numbers with
    just a few more lines of code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个数字都打印在单独的一行上。因此，让我们看看如果我们只想将这些数字添加到一个列表中会怎么样。我们可以将它们附加到一个新列表中，然后打印出列表。这对某些类型的算法和游戏非常有帮助。但在我深入讨论这些之前，让我们首先看看如何使用几行代码附加这些数字：
- en: ch10_forLoop3.py
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_forLoop3.py
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, pay close attention to when you print the list. If you have it indented
    in correctly, it will print the list every single time you append a new number.
    But if your indentation is correct, you''ll only print the final list so that
    the output looks as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您打印列表时，请注意。如果您正确缩进了它，它将在每次附加新数字时都打印列表。但如果您的缩进是正确的，您只会打印最终列表，使输出看起来如下：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we now have representations of the same information. In this
    case, we printed out the list of numbers. This is helpful if you're trying to
    append specific things to a list, even if it is with user input. We'll look at
    another list problem in the next section as we look at `while` loops, but before
    we move on, let's look at one more `for` loop problem and algorithm.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们现在有了相同信息的表示。在这种情况下，我们打印出了数字列表。如果您试图将特定的东西附加到列表中，即使是用户输入，这是很有帮助的。在下一节中，当我们看`while`循环时，我们将看另一个列表问题，但在我们继续之前，让我们再看一个`for`循环问题和算法。
- en: 'Let''s say you wanted an algorithm that will print out the cubes of a range
    of numbers. There is one condition: the range will vary depending on user input.
    Let''s take a look at an algorithm that does this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要一个算法，它将打印出一系列数字的立方。有一个条件：范围将根据用户输入而变化。让我们看看一个可以做到这一点的算法：
- en: ch10_forLoop4.py
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_forLoop4.py
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s note a few things from the preceding program:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从前面的程序中注意几点：
- en: We converted the inputs into `int` types. We did this so that we can use the
    number in the mathematical expression inside the `for` loop.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将输入转换为`int`类型。我们这样做是为了可以在`for`循环内使用数字进行数学表达式。
- en: We have an empty list so we can append the cubes to it.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个空列表，所以我们可以将立方附加到它上面。
- en: We added `1` to `maxRange` because if not, the number would not be included
    in our result.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`maxRange`加`1`，因为如果不这样做，该数字将不包括在我们的结果中。
- en: We have a range based on two variables, which are the user input.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个基于两个变量的范围，这两个变量是用户输入。
- en: We have a printed list of the values.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个打印出的值列表。
- en: 'Here is what that program looks like when we enter the `range(3, 6)`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入`range(3, 6)`时，程序看起来像这样：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the program took the input provided, a minimum of `3` and a
    maximum of `6`, and created a list of the cubes of the numbers in that range.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，程序接受了提供的输入，最小值为`3`，最大值为`6`，并创建了该范围内数字的立方的列表。
- en: 'Important Note:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Remember that to get the exponents, we use the `**` symbol in Python. So, *2**2*
    is *4*, *3**4* is *81*, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要得到指数，我们在Python中使用`**`符号。所以，*2**2*是*4*，*3**4*是*81*，等等。
- en: Remember, the *control flow* is the order in which things are done. With `for`
    loops and `range`, we are asking the program to repeat things without having to
    enter each line separately, effectively manipulating the control flow to do things
    in loops rather than one line after another after another.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*控制流*是事情完成的顺序。通过`for`循环和`range`，我们要求程序重复执行事情，而不必每次输入一行，有效地操纵控制流以循环而不是一行接着一行地做事情。
- en: Now that we've looked at `for` loops and `range`, let's take a look at other
    ways we can iterate in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了`for`循环和`range`，让我们看看在Python中我们可以以其他方式进行迭代的方法。
- en: Using other loops and conditionals
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他循环和条件
- en: Python offers a variety of ways to iterate through information in addition to
    the `for` loop. One of the commonly used loops is a `while` loop. When using a
    `while` loop, we're checking for a condition constantly. Again, it's easier to
    understand this by looking at an example.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了各种迭代信息的方法，除了`for`循环之外，还有`while`循环。使用`while`循环时，我们不断检查条件。再次，通过看一个例子来理解这一点会更容易。
- en: 'Let''s say we were playing a game and ask the user to provide as many animals
    as they can. We''d want to be able to do a few things:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在玩一个游戏，并要求用户提供尽可能多的动物。我们希望能够做一些事情：
- en: Check whether the player has animals to add.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查玩家是否有要添加的动物。
- en: If yes, append each animal to a list.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，将每个动物附加到列表中。
- en: If no, end the program and provide the final list.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，结束程序并提供最终列表。
- en: Provide the final list and a count for how many animals the player was able
    to enter.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供最终列表和玩家能够输入的动物数量。
- en: 'Let''s take a look at an algorithm that does the basics for this game:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个为这个游戏做基本工作的算法：
- en: ch10_whileLoop1.py
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_whileLoop1.py
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s break this code down a bit:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微解释一下这段代码：
- en: We created an empty list, `myAnimals`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个空列表`myAnimals`。
- en: We then asked the player whether they were ready.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们问玩家是否准备好了。
- en: If the answer was yes, we asked for an animal.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果答案是肯定的，我们就会要求输入一个动物。
- en: Then, we checked whether they had more to add.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查他们是否还有更多要添加的。
- en: We checked how many items were added to the list.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查了列表中添加了多少项。
- en: We printed the list.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印了列表。
- en: Notice that we had to use a `while` loop and `if` statements. That's because
    we want to continue asking the player to add animals until they are done or can't
    think of any more to add. So, while the player can still add items, we want the
    program to keep asking the question. But if the player is done, then they can
    say no to adding another animal, therefore ending the program.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须使用`while`循环和`if`语句。这是因为我们希望继续询问玩家添加动物，直到他们完成或无法想到更多要添加的动物为止。因此，只要玩家仍然可以添加项目，我们希望程序继续询问问题。但是如果玩家完成了，那么他们可以拒绝添加另一个动物，从而结束程序。
- en: Now, I want to be clear, this program can be made a lot better. We could add
    a timer to see how many items can be entered in 30 seconds. We could also add
    a conditional that breaks the program and explains why it does so when the player
    tries to enter an animal instead of saying yes first. You could add a condition
    for when the player tries to enter an animal that's already on the list. *A challenge
    for you would be to try to add those components to the existing program!*
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想明确一点，这个程序可以做得更好。我们可以添加一个计时器，看看在30秒内可以输入多少项。当玩家试图输入动物而不是先说“是”时，我们也可以添加一个条件来中断程序并解释为什么这样做。你可以为玩家试图输入已经在列表中的动物添加一个条件。*你的挑战是尝试将这些组件添加到现有的程序中！*
- en: 'But let''s take a look at what this program looks like when we run it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但是让我们看看当我们运行它时，这个程序是什么样子的：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the way this program is written requires us to answer whether we
    want to add an animal each time. That's because the conditions will run if we
    answer `yes` for as long as we answer `yes`. But once we answer `no`, the program
    ends, giving us the list of animals and how many we were able to name.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个程序的写法要求我们每次都要回答是否要添加一个动物。这是因为只要我们回答“是”，条件就会继续运行。但一旦我们回答“否”，程序就会结束，给我们动物列表和我们能够命名的数量。
- en: 'Now, let''s take a look at another `while` loop. This time, we''ll check whether
    or not the condition is `True`. Take a look at the following snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再看一个`while`循环。这一次，我们将检查条件是否为`True`。看一下以下代码片段：
- en: ch10_whileLoop2.py
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_whileLoop2.py
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding algorithm, the control flow dictates that we get asked for
    a number between `0` and `9` repeatedly. The program will continue to ask until
    we make a mistake. That''s because it will continue to be `True` if I give it
    a number between `0` and `9`. Let''s look at a sample output for this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的算法中，控制流规定我们反复要求一个介于`0`和`9`之间的数字。只要我们给它一个介于`0`和`9`之间的数字，程序就会继续询问，直到我们犯错为止。这是因为只要我给它一个介于`0`和`9`之间的数字，它就会继续为`True`。让我们看一下这个的一个示例输出：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that the program kept asking the same question over and over again.
    This is unhelpful sometimes if the user doesn''t know how to break the cycle.
    We could potentially add a line to our statement so that it asks the question
    but provides a hint. Take a look at the edited code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序一直重复询问同一个问题。有时如果用户不知道如何打破循环，这是没有帮助的。我们可以在我们的陈述中潜在地添加一行，这样它会问问题但提供一个提示。看看编辑后的代码：
- en: ch10_whileLoop3.py
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_whileLoop3.py
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we are now telling the user that if they get tired of providing
    ranges, then they can opt out by providing an input outside of the range. While
    this example doesn't seem very useful, think of all the applications you could
    have. This type of algorithm can be used for card games, for example. You could
    also use something like this to check input against an existing list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在告诉用户，如果他们厌倦了提供范围，那么他们可以通过提供范围之外的输入来选择退出。虽然这个例子似乎不是很有用，但想想你可以有多少应用。例如，这种类型的算法可以用于纸牌游戏。你也可以使用类似这样的东西来检查输入是否与现有列表匹配。
- en: Now, let's take a look at functions again, but now combining some of our loops
    and adding some capabilities.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次看一下函数，但现在结合一些我们的循环并添加一些功能。
- en: Revisiting functions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视函数
- en: If you recall from [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114),
    *Introduction to Python*, we looked at built-in functions, but we also looked
    at how we can define our own functions. We are now going to talk about arguments
    in *functions* and *loops*, as we delve deeper into how *control flow* works in
    Python.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[*第8章*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114)，*Python简介*，我们看过内置函数，但我们也看过如何定义我们自己的函数。现在我们将讨论*函数*和*循环*中的参数，深入探讨Python中*控制流*的工作方式。
- en: 'Let''s think about problems that involve range. The range takes two arguments:
    a minimum and a maximum. However, in Python, I should note that you can just give
    one argument, which then assumes your minimum is `0`. For example, if I write
    `range(8)`, that''s the same as `range (0, 8)`. Take a look at what happens if
    you type `range(2)` in the Python shell:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下涉及范围的问题。范围需要两个参数：最小值和最大值。然而，在Python中，我应该注意到你可以只给一个参数，这样就假定你的最小值是`0`。例如，如果我写`range(8)`，那就相当于`range(0,
    8)`。看看如果你在Python shell中输入`range(2)`会发生什么：
- en: '![Figure 10.3 – Python range interpretation with one argument'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 - Python范围解释与一个参数'
- en: '](image/Figure_10.3_B15413.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.3_B15413.jpg)'
- en: Figure 10.3 – Python range interpretation with one argument
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 - Python范围解释与一个参数
- en: 'In *Figure 10.3*, you can see that the program interpreted the code as `range(0,
    2)`. But let''s say you are always changing your range. Think of the range algorithm
    we wrote earlier. We are now going to rewrite it using a function. This function
    now has a `for` loop inside it as well:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.3*中，你可以看到程序将代码解释为`range(0, 2)`。但假设你总是在改变你的范围。想想我们之前写的范围算法。我们现在将使用一个函数来重新编写它。这个函数现在也在里面有一个`for`循环：
- en: ch10_functions1.py
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_functions1.py
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice that we are calling the function based on user input. When this program
    runs, it calls the function based on that input. We will revisit that and run
    the program by calling multiple ranges within the algorithm in a second, but take
    a look at what the preceding snippet gives as the output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们是根据用户输入调用函数的。当此程序运行时，它根据该输入调用函数。我们将在一秒钟内重新访问并通过在算法中调用多个范围来运行程序，但是看看前面的片段给出了什么输出：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how we also adjusted the maximum number in the range in the `for` loop
    to include the top number provided. That's so that we get the full list of numbers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还调整了“for”循环中的范围中的最大数字，以包括提供的顶部数字。这样我们就可以得到完整的数字列表。
- en: 'Now, let''s take out the input completely. We are going to call the function
    multiple times using different ranges within the algorithm. Take a look at the
    updated snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们完全取消输入。我们将使用不同的范围多次调用函数在算法中。看看更新后的片段：
- en: ch10_functions2.py
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_functions2.py
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final three statements are where we call the function. Since we defined
    the function to take two arguments, it uses both the arguments to run the function.
    Because we called the function three times, we should see three lists as output.
    Let''s take a look:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个语句是我们调用函数的地方。由于我们定义了函数以接受两个参数，它使用这两个参数来运行函数。因为我们调用了函数三次，所以应该看到三个列表作为输出。让我们看一下：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we printed each range on a separate line. That's one of the
    most useful things functions can do for us. If we were working with images, for
    example, which we can do with libraries, then we could create a shape, then define
    a function with loops that changes some parameters. With one function and a few
    loops, we can create multiple circles in different locations with different radiuses
    based on calling the function and using some loops.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在单独的行上打印了每个范围。这是函数可以为我们做的最有用的事情之一。例如，如果我们正在处理图像，我们可以使用库来创建形状，然后定义一个带有改变一些参数的循环的函数。通过一个函数和几个循环，我们可以根据调用函数和使用一些循环在不同位置创建多个具有不同半径的圆。
- en: 'Functions are also not limited to two arguments. We can have multiple arguments
    and define them within the functions. Let''s look at a function that uses three
    arguments:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也不限于两个参数。我们可以有多个参数并在函数内定义它们。让我们看一个使用三个参数的函数：
- en: ch10_functions3.py
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_functions3.py
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this case, we''re calling the function with the values already given. *I
    love, and I mean love, Mexican food*. So, that menu would make me extremely happy!
    Here''s what that output looks like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用已经给定的值调用函数。*我喜欢，我的意思是我非常喜欢，墨西哥食物*。因此，那个菜单会让我非常开心！这是输出的样子：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the function uses each argument in the `print` statements. The
    `%s` statements are used to let the program know where the values will be substituted.
    The `%()` statements let the program know which value to grab from the call function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该函数在“print”语句中使用了每个参数。 “％s”语句用于让程序知道值将被替换的位置。 “％（）”语句让程序知道从调用函数中获取哪个值。
- en: 'Now, let''s look at the code if we wanted to get input from the user:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们想从用户那里获取输入的代码：
- en: ch10_functions4.py
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_functions4.py
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, our definitions and arguments are repeated. We use `input`
    statements to get information from the program user, then print out statements.
    Here''s what that looks like now in the Python shell:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的定义和参数是重复的。我们使用“input”语句从程序用户那里获取信息，然后打印出语句。现在在Python shell中看起来是这样的：
- en: '![Figure 10.4 – User input in function with three arguments'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 - 具有三个参数的函数中的用户输入'
- en: '](image/Figure_10.4_B15413.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.4_B15413.jpg)'
- en: Figure 10.4 – User input in function with three arguments
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 - 具有三个参数的函数中的用户输入
- en: As you can see, the first three lines take the user input, then the last three
    lines incorporate the inputs into the function definition. Depending on what you
    are looking to create, this matters. If you are building an online menu for a
    store, for example, you would want user input, but you would also want to be able
    to confirm purchases. Same with online libraries if you wanted to confirm an e-book
    being lent out, and so on. We use **confirmation statements** often in algorithms.
    After looking at these, go check out some of your favorite websites and see where
    there are confirmation statements based on user input. You'll see that the use
    is widespread. Functions allow us to simplify that process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前三行接受用户输入，然后最后三行将输入合并到函数定义中。这取决于您要创建的内容。例如，如果您要为商店构建在线菜单，您需要用户输入，但您还希望能够确认购买。如果您想要确认借出电子书等在线图书馆，也是如此。我们在算法中经常使用**确认语句**。查看这些之后，去看看一些您喜欢的网站，看看基于用户输入的确认语句在哪里。您会发现使用非常广泛。函数使我们能够简化该过程。
- en: Before we move on, let's work with a few algorithms that provide the same information
    using our different loops and functions. Remember, we're looking at iterations
    because control flow means **order**. The iterations, functions, range, and more
    are ways in which we tell the program how it should respond to the instructions
    in the algorithm and when to repeat or move on from our program.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们使用几个算法，使用不同的循环和函数提供相同的信息。请记住，我们正在研究迭代，因为控制流意味着**顺序**。迭代、函数、范围等是我们告诉程序如何响应算法中的指令以及何时重复或继续执行程序的方式。
- en: 'Let''s look at a function that prints the triple of the given user maximum
    input:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个打印给定用户最大输入的三倍的函数：
- en: ch10_functions5.py
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_functions5.py
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice that the `while` loop and function definitions depend on the user input.
    The program will then print the triple of the value provided by the user, then
    reduce that number by one and find the triple of that number. Let''s take a look
    at what that means:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“while”循环和函数定义取决于用户输入。然后，程序将打印用户提供的值的三倍，然后减少该数字一次并找到该数字的三倍。让我们看看这意味着什么：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the program found the triple of `4`, which is `12`, then the
    triple of `3`, which is `9`, and so on. It stopped because we told it to run the
    loop while the number was greater than `0`. But recall that we can also just add
    those to a list, and we can use a `for` loop instead.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，程序找到了`4`的三倍，即`12`，然后找到了`3`的三倍，即`9`，依此类推。它停止是因为我们告诉它在数字大于`0`时运行循环。但要记住，我们也可以将它们添加到一个列表中，并且我们可以使用`for`循环。
- en: 'Let''s take a look at a similar program with a function, but a `for` loop rather
    than the `while` loop and using `range`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个类似的程序，它使用了一个函数，但是使用了`for`循环而不是`while`循环，并使用了`range`：
- en: ch10_functions6.py
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ch10_functions6.py
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice we defined some more things and added an empty list to the algorithm.
    While it has a few more lines of code, it does essentially the same thing as the
    previous code. Notice too that we started the range at `1`; otherwise, it would
    also include `0` in the list. Take a look at the output for this algorithm:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们定义了一些更多的东西，并在算法中添加了一个空列表。虽然代码行数多了一些，但它基本上与先前的代码做了相同的事情。还要注意，我们从`1`开始范围；否则，它也会在列表中包括`0`。看一下这个算法的输出：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have the same information but organized from least to greatest and in a list.
    From our algorithm, the order of things happening is important, of course. We
    first gathered the user input. The algorithm then defined the empty list, before
    defining a function. The function then used a `for` loop that uses the input to
    create a range and iterate over the range of numbers. Each iteration was then
    appended to the list. Finally, the algorithm printed the list.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有相同的信息，但是按照从小到大的顺序排列，并且放在一个列表中。从我们的算法中，发生事情的顺序很重要，当然。我们首先收集了用户输入。然后算法定义了一个空列表，然后定义了一个函数。函数然后使用了一个`for`循环，该循环使用输入创建一个范围，并在数字范围内进行迭代。然后每次迭代都被添加到列表中。最后，算法打印了列表。
- en: As you can see, there are multiple ways to get to the same information. We just
    have to look at what works best for our scenarios, how to organize the information
    so that the program can read it, and write an algorithm that will organize the
    information in a way that can be read when running the program.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有多种方法可以获得相同的信息。我们只需要看看哪种方法最适合我们的场景，如何组织信息以便程序可以读取它，并编写一个算法，该算法可以在运行程序时组织信息。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we discussed control flow and order by looking at `for` loops,
    `range`, `while` loops, and functions. **Control flow** refers to the order a
    program reads an algorithm. Typically in Python, one line is read right after
    the other. In this chapter, we learned how you can control that order. Specifically,
    we learned that we could do so by iterating through data. Here are some important
    points to remember: `while` loops run so long as a condition is met, `for` loops
    iterate over a sequence (string, numerical, list, dictionary, set, or tuple),
    and `range` is used to create a sequence of numbers.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过查看`for`循环、`range`、`while`循环和函数来讨论控制流和顺序。**控制流**指的是程序读取算法的顺序。通常在Python中，一行代码紧跟着一行代码被读取。在本章中，我们学会了如何控制这个顺序。具体来说，我们学会了可以通过迭代数据来实现这一点。以下是一些重要的要点需要记住：`while`循环在条件满足的情况下运行，`for`循环迭代一个序列（字符串、数字、列表、字典、集合或元组），`range`用于创建一系列数字。
- en: We also learned that we can combine these things when creating conditions, defining
    functions, and designing our algorithms. The most important thing to continue
    keeping in mind is that order matters, so we need to be careful about when we
    define necessary variables and how to write the algorithms so that they don't
    run infinitely or break before they should. Control flow is important so that
    our algorithms work without errors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了在创建条件、定义函数和设计算法时可以将这些东西结合起来。继续牢记的最重要的事情是顺序很重要，所以我们需要小心地定义必要的变量以及如何编写算法，以便它们不会无限运行或在应该之前就中断。控制流很重要，这样我们的算法才能正常工作而没有错误。
- en: In the next chapter, we will use the knowledge gained so far to complete the
    computational thinking process when solving challenges in multiple disciplines.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用迄今为止所学到的知识，完成在多个学科中解决挑战时的计算思维过程。
