- en: Using ipfsapi to Interact with IPFS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ipfsapi与IPFS进行交互
- en: In this chapter, we are going to learn how to interact with IPFS programmatically
    with Python. There are a couple of interactions that we can do here, such as adding
    files, retrieving files, hosting mutable files, subscribing to topics, publishing
    topics, and copying files to the **Mutable File System** (**MFS**). First, we
    have to install the IPFS software and launch it. Then, we will learn how to install
    the IPFS Python library and learn about most of its API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Python以编程方式与IPFS进行交互。我们可以在这里进行一些交互，例如添加文件，检索文件，托管可变文件，订阅主题，发布主题，并将文件复制到**可变文件系统**（**MFS**）。首先，我们必须安装IPFS软件并启动它。然后，我们将学习如何安装IPFS
    Python库，并了解其大部分API。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing the IPFS software and it's library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装IPFS软件及其库
- en: Content hashing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容哈希
- en: The ipfsapi API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ipfsapi API
- en: Installing the IPFS software and its library
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装IPFS软件及其库
- en: 'At the time of writing, there are only two IPFS implementations: `go-ipfs`
    (written in the Go language) and `js-ipfs` (written in JavaScript). There is no
    IPFS implementation written in Python as of yet. The Go implementation is the
    more popular one, so we will use that.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，只有两种IPFS实现：`go-ipfs`（用Go语言编写）和`js-ipfs`（用JavaScript编写）。截至目前，还没有用Python编写的IPFS实现。Go实现是更受欢迎的，因此我们将使用它。
- en: Go to, [https://dist.ipfs.io/#go-ipfs](https://dist.ipfs.io/#go-ipfs), and download
    the software for your platform. For Ubuntu Linux, the file is named `go-ipfs_v0.4.18_linux-amd64.tar.gz`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[https://dist.ipfs.io/#go-ipfs](https://dist.ipfs.io/#go-ipfs)，并为您的平台下载软件。对于Ubuntu
    Linux，文件名为`go-ipfs_v0.4.18_linux-amd64.tar.gz`。
- en: 'Extract this using the following command line:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令行提取此内容：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, install the binary using the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令安装二进制文件：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This step is optional. Here, we export the `IPFS_PATH` environment variable
    to our shell:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤是可选的。在这里，我们将`IPFS_PATH`环境变量导出到我们的shell：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is where the `ipfs` stores the files. You can store this statement in `~/.bashrc`.
    By default (without this environment variable), the `ipfs` would use `~/.ipfs`
    (the `.ipfs` directory in the home directory) as the place to store data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ipfs`存储文件的位置。您可以将此语句存储在`~/.bashrc`中。默认情况下（没有此环境变量），`ipfs`将使用`~/.ipfs`（主目录中的`.ipfs`目录）作为存储数据的位置。
- en: 'After setting up the environment variable, initialize the `ipfs` local repository.
    You only perform this step once:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境变量后，初始化`ipfs`本地存储库。您只需执行此步骤一次：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you run the `ipfs` in the cloud (such as Amazon Web Services, Google Cloud
    Platform, Digital Ocean, or Azure), you should use a server profile flag:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在云中运行`ipfs`（例如Amazon Web Services，Google Cloud Platform，Digital Ocean或Azure），您应该使用服务器配置文件标志：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If not, you will get a pesky warning letter from the cloud provider because
    the IPFS `daemon`, by default (without a server profile flag), would do something
    resembling port scanning.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您将收到来自云提供商的烦人警告信，因为IPFS `守护程序`默认情况下（没有服务器配置文件标志），会执行类似于端口扫描的操作。
- en: 'Then, launch `daemon`, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动`守护程序`，如下所示：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By default, the API server is listening on port 5001\. We will interact with
    the IPFS programmatically through this port. By default, it only listens in localhost.
    Be careful if you want to open this port to the outside world. There is no **Access
    Control List** (**ACL**) in the IPFS. Anyone who has access to this port can upload
    data to the IPFS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，API服务器正在端口5001上监听。我们将通过此端口以编程方式与IPFS进行交互。默认情况下，它只在本地侦听。如果您想向外界打开此端口，请小心。IPFS中没有**访问控制列表**（**ACL**）。任何可以访问此端口的人都可以向IPFS上传数据。
- en: By default, the Gateway server is listening on port 8080\. We download the file
    from the IPFS peer-to-peer file system using this port. The Swarm, by default,
    is listening on port 4001\. This is how other nodes download the file from our
    storage. All of these ports can be changed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，网关服务器正在端口8080上监听。我们使用此端口从IPFS点对点文件系统下载文件。默认情况下，Swarm正在端口4001上监听。这是其他节点从我们的存储中下载文件的方式。所有这些端口都可以更改。
- en: 'The IPFS has a dashboard that can be accessed at the following link: [http://localhost:5001/webui](http://localhost:5001/webui).
    The following is a screenshot of the dashboard:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: IPFS有一个仪表板，可以通过以下链接访问：[http://localhost:5001/webui](http://localhost:5001/webui)。以下是仪表板的屏幕截图：
- en: '![](assets/f8ed742f-d554-4bb6-a2df-99f53cb32300.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/f8ed742f-d554-4bb6-a2df-99f53cb32300.png)
- en: As you can see, most IPFS nodes are located in the US, China, and Germany.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，大多数IPFS节点位于美国，中国和德国。
- en: 'Click on the Peers tab to see the distribution of IPFS nodes according to their
    IP address, as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 单击Peers选项卡，以查看IPFS节点根据其IP地址的分布，如下屏幕截图所示：
- en: '![](assets/151a3ee6-7eb8-47cb-afda-750c2d72faea.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/151a3ee6-7eb8-47cb-afda-750c2d72faea.png)
- en: The nodes can be seen in this tab, including their IP addresses. If you are
    concerned about the privacy of nodes, bear in mind that the development of the
    privacy feature is still in its infancy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此选项卡中看到节点，包括它们的IP地址。如果您担心节点的隐私，请记住隐私功能的开发仍处于初期阶段。
- en: 'You can configure the IPFS setting in the Settings tab, as shown in the following
    screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在设置选项卡中配置IPFS设置，如下屏幕截图所示：
- en: '![](assets/e13e2e31-c830-4c68-8b0e-b8b5f7f06e68.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/e13e2e31-c830-4c68-8b0e-b8b5f7f06e68.png)
- en: Now that our IPFS daemon has been launched, let's install our `ipfs` Python
    library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的IPFS守护程序已启动，让我们安装我们的`ipfs` Python库。
- en: 'Open a new Terminal since we don''t want to disturb our daemon. Then, run the
    following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端，因为我们不想打扰我们的守护程序。然后，运行以下命令：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Previously, the `ipfs` Python library was called `py-ipfs-api`, but it has since
    been renamed to `ipfsapi`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`ipfs` Python库被称为`py-ipfs-api`，但现在已更名为`ipfsapi`。
- en: Content hashing
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容哈希
- en: 'In the IPFS quick start documentation ([https://docs.ipfs.io/introduction/usage](https://docs.ipfs.io/introduction/usage)),
    the first thing that they teach you is to download the cute cat picture. Use the
    following code to do this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPFS快速入门文档中（[https://docs.ipfs.io/introduction/usage](https://docs.ipfs.io/introduction/usage)），他们教您的第一件事是下载可爱的猫图片。使用以下代码来执行此操作：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you run the preceding code, the cat picture will be downloaded and you
    will get the following as output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，将下载猫图片，并且您将得到以下输出：
- en: '![](assets/53ded3eb-4636-40f0-992a-b8fc5e79a398.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/53ded3eb-4636-40f0-992a-b8fc5e79a398.jpg)'
- en: '`eog` is an image viewer in Ubuntu.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`eog`是Ubuntu中的图像查看器。'
- en: 'To respect the tradition, let''s create a Python script to download the preceding
    image programmatically with Python and name the script `download_cute_cat_picture.py`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循传统，让我们创建一个Python脚本，以便使用Python以编程方式下载前面的图像，并将脚本命名为`download_cute_cat_picture.py`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After executing this script, the image will be named `cat.jpg` in your directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本后，图像将在您的目录中命名为`cat.jpg`。
- en: 'As you may have noticed, there is a `cat.jpg` filename after the long hash.
    Technically speaking, what we are doing here is downloading a file inside a directory
    that contains a cute cat picture. You can try this if you like. To do so, create
    another script and name it `download_a_directory_of_cute_cat_picture.py` and then
    run the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的那样，在长哈希之后有一个`cat.jpg`文件名。从技术上讲，我们在这里做的是在包含一张可爱猫图片的目录中下载文件。如果您愿意，可以尝试一下。要这样做，创建另一个脚本并将其命名为`download_a_directory_of_cute_cat_picture.py`，然后运行以下代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After executing this script, you will get a directory named `QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ`
    in the directory that contains this script. If you peek inside this directory,
    you will find the cat picture file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本后，您将在包含此脚本的目录中得到一个名为`QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ`的目录。如果您查看此目录的内部，将找到猫图片文件。
- en: 'Let''s take a look at the script line by line to understand the usage of the `ipfsapi`
    library. You can use the following code to import the library:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看脚本，以了解`ipfsapi`库的用法。您可以使用以下代码导入库：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code is used to get a connection object to IPFS daemon:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于获取到IPFS守护程序的连接对象：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `connect` method accepts a couple of parameters. The two most important
    parameters are `host` and `port`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect`方法接受一些参数。最重要的两个参数是`host`和`port`：'
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, we connect to localhost with port 5001:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们连接到本地主机的5001端口：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we use the methods of the IPFS HTTP API from the *c* object. `get` is
    one of the methods that''s used to interact with IPFS daemon. For this method,
    there is usually an equivalent argument with the `ipfs` client software:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用IPFS HTTP API的方法从*c*对象中。`get`是用于与IPFS守护程序交互的方法之一。对于此方法，通常有一个与`ipfs`客户端软件相对应的参数：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You may notice that we use the `ipfs cat` command in the command-line interface
    before we created our first Python script. However, in the script, we use the
    `get` method. There is also a `cat` method in the `ipfsapi` library.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，在创建第一个Python脚本之前，我们在命令行界面中使用了`ipfs cat`命令。但是，在脚本中，我们使用了`get`方法。`ipfsapi`库中也有一个`cat`方法。
- en: The `get` method is used to download the file, while the `cat` method is used
    to get the content of the file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法用于下载文件，而`cat`方法用于获取文件的内容。'
- en: 'Let''s create a script that uses the `cat` method and name it `cat_cute_cat.py`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用`cat`方法的脚本，并将其命名为`cat_cute_cat.py`：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `cat` method returns the bytes object of the content of the file. It accepts
    two optional parameters, `offset` and `length`. `offset` is a starting position
    in the file where you want to start to get the content. `length` is the length
    of the content you want to get starting from the `offset `position. These parameters
    are important if you want to build a download manager (with pausing and resuming
    capabilities) or a video streaming player. You may not always want to download
    the whole file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`方法返回文件内容的字节对象。它接受两个可选参数，`offset`和`length`。`offset`是文件中要开始获取内容的起始位置。`length`是从`offset`位置开始获取的内容的长度。如果要构建一个具有暂停和恢复功能的下载管理器（或视频流播放器），这些参数非常重要。您可能并不总是想要下载整个文件。'
- en: 'Now, let''s add a file to the IPFS. To do this, create a simple file and name
    it `hello.txt`. This is the content of the file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将一个文件添加到IPFS。要做到这一点，创建一个简单的文件并将其命名为`hello.txt`。这是文件的内容：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make sure you have a new line after the string:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在字符串之后有一个新行：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the command prompt comes after the line of the string, then all is well.
    You can carry on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令提示符出现在字符串的下一行，则一切正常。您可以继续进行。
- en: 'However, Let''s say the command prompt comes on the right of the string, as
    shown in the following code block:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，假设命令提示符出现在字符串的右侧，如下面的代码块所示：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This means you don't have the new line and you need to add this after the string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您没有新行，需要在字符串之后添加它。
- en: 'Now, let''s create a script to add this file to the IPFS and name it `add_file.py`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个脚本将此文件添加到IPFS，并将其命名为`add_file.py`：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Executing this code will give you the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码将给出以下输出：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can retrieve the content of the file, which is `I am a good unicorn.\n`,
    by using the `cat` or `get` method. Let''s use the `cat` method in the script
    named `get_unicorn.py`, as given in the following code block:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cat`或`get`方法检索文件的内容，即`I am a good unicorn.\n`。让我们在名为`get_unicorn.py`的脚本中使用`cat`方法，如下面的代码块所示：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running this will give you the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将给出以下输出：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we mentioned in [Chapter 10](f50b5479-887d-48ab-a1db-381f2d3beb4f.xhtml)
    , *InterPlanetary – A Brave New File System*, we get the content of the file through
    the hash. Through this, we only retrieve the content, not the name of the file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第10章](f50b5479-887d-48ab-a1db-381f2d3beb4f.xhtml)中提到的*星际文件系统-一个勇敢的新文件系统*，我们通过哈希获取文件的内容。通过这种方式，我们只检索内容，而不是文件的名称。
- en: 'But how do you turn `b''I am a good unicorn.\n''` into `''QmY7MiYeySnsed1Z3KxqDVYuM8pfiT5gGTqprNaNhUpZgR''`?
    Is it just by hashing the content? For example, to `hash` the content of the file,
    you could use the SHA-256 hash function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如何将`b'I am a good unicorn.\n'`转换为`'QmY7MiYeySnsed1Z3KxqDVYuM8pfiT5gGTqprNaNhUpZgR'`？只是通过对内容进行哈希吗？例如，要对文件的内容进行哈希，你可以使用SHA-256哈希函数：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Not so fast! It turns out you need to learn about protobuf, multihash, and base58
    first to understand the process. Let's discuss these in the following sections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不要那么快！原来你需要先了解protobuf、multihash和base58的过程。让我们在接下来的部分讨论这些。
- en: Protobuf
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Protobuf
- en: If you have tried to install Google open source software such as `Tensorflow`,
    you would encounter protobuf because it is used by `Tensorflow`. `Protobuf` is
    a serialization library. If you learned about Python from the official documentation,
    you would know that Pickle as a way to serialize data. If you learned about web
    development programming, most likely, you would use `.json` or `.xml` as data
    serialization.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试安装Google开源软件，比如`Tensorflow`，你会遇到protobuf，因为它被`Tensorflow`使用。`Protobuf`是一个序列化库。如果你从官方文档中学习Python，你会知道Pickle是一种序列化数据的方式。如果你学习Web开发编程，很可能你会使用`.json`或`.xml`作为数据序列化。
- en: 'Before we pass `b''I am a good unicorn.\n''` to the IPFS, we wrap our data
    in a data structure. Let''s create a script to prove my claim and name the script
    `get_unicorn_block.py`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`b'I am a good unicorn.\n'`传递给IPFS之前，我们需要将我们的数据包装在一个数据结构中。让我们创建一个脚本来证明我的说法，并将脚本命名为`get_unicorn_block.py`：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running the script will allow you to see that the content of the file is wrapped
    by other stuff:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本将允许你看到文件内容被其他内容包裹：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see that we still have our content of the file intact, `b'I am a good
    unicorn.\n'`, between the cryptic strings. What are the junk characters on the
    left and on the right? This is the data structure of a data node in the IPFS.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的文件内容仍然完整，`b'I am a good unicorn.\n'`，在神秘的字符串之间。左边和右边的垃圾字符是什么？这是IPFS中数据节点的数据结构。
- en: 'Before we unserialize this serialized data, let''s quickly learn how to use
    `protobuf`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对这个序列化数据进行反序列化之前，让我们快速学习如何使用`protobuf`：
- en: 'Install the `protobuf-compiler` using the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装`protobuf-compiler`：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Your `protobuf` compiler is `protoc`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`protobuf`编译器是`protoc`：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, let''s install the Python `protobuf` library using the following command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令安装Python的`protobuf`库：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Before serializing data with `protobuf`, you need to create a data structure
    format first. The format must be saved in a file. Let''s name the format file
    `crypto.proto` and use the following script:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`protobuf`对数据进行序列化之前，你需要先创建一个数据结构格式。这个格式必须保存在一个文件中。让我们把格式文件命名为`crypto.proto`，并使用以下脚本：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you look at this data structure, it's like a struct or class without methods.
    After declaring the syntax you use, you declare the `package` to avoid a name
    collision. `message` is just like a class or struct keyword in another mainstream
    programming language. This `message` is an encapsulation of many data types. In
    our case, they are `string`, `int32`, and `enum`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看这个数据结构时，它就像一个没有方法的结构或类。在声明你使用的语法之后，你声明`package`以避免名称冲突。`message`就像另一种主流编程语言中的类或结构关键字。这个`message`是许多数据类型的封装。在我们的情况下，它们是`string`、`int32`和`enum`。
- en: 'Before we can serialize data with protobuf in Python, we need to convert this
    `.proto` file into a Python module file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中对数据进行protobuf序列化之前，我们需要将这个`.proto`文件转换成一个Python模块文件：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `python_out` parameter is used to indicate in which directory you want to
    output this Python file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`python_out`参数用于指示你想要将这个Python文件输出到哪个目录。'
- en: You should get the `crypto_pb2.py` file generated for you. Refer to the code
    file in GitLab link for the script: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_11](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_11).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该为你生成的`crypto_pb2.py`文件。参考GitLab链接中的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_11](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_11)。
- en: 'If you did not read the comment on the top of the file, let me read it for
    you: Do not edit the file directly. If you want to change the data structure in
    a serialization process, you modify the `.proto` file and then compile it. Now
    that you have this `Python` library file generated for you, you can throw away
    the `.proto` file. However, it''s a good idea to keep it for documentation.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有阅读文件顶部的注释，让我为你读一下：不要直接编辑这个文件。如果你想要在序列化过程中更改数据结构，你需要修改`.proto`文件，然后编译它。现在你已经为你生成了这个`Python`库文件，你可以丢掉`.proto`文件。但是，保留它作为文档是个好主意。
- en: 'Now, let''s test the serialization and unserialization processes with a Python
    script. Name the script `serialize_crypto_data.py`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用一个Python脚本测试序列化和反序列化过程。将脚本命名为`serialize_crypto_data.py`：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you execute the script, you will get the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行这个脚本，你将得到以下输出：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The serialized output, `b'\n\x0cBitcoin Cash\x10\xc0\xde\x81\n\x18\x00'`, resembles
    our unicorn data block in the IPFS. If you parse this binary data, you should
    get the original Python object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化输出，`b'\n\x0cBitcoin Cash\x10\xc0\xde\x81\n\x18\x00'`，类似于我们在IPFS中的独角兽数据块。如果你解析这个二进制数据，你应该得到原始的Python对象。
- en: 'Now that you understand the basic usage of protobuf, let''s get back to our
    block data in the IPFS:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了protobuf的基本用法，让我们回到IPFS中的块数据：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is the serialized data in protobuf. Before we unserialize it, we need to
    get the related `.proto` files. Apparently, we need two `.proto` files, `unixfs.proto`
    and `merkledag.proto`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是protobuf中的序列化数据。在我们对其进行反序列化之前，我们需要获取相关的`.proto`文件。显然，我们需要两个`.proto`文件，`unixfs.proto`和`merkledag.proto`。
- en: '`unixfs.proto` can be downloaded from [https://github.com/ipfs/go-unixfs/blob/master/pb/unixfs.proto](https://github.com/ipfs/go-unixfs/blob/master/pb/unixfs.proto),
    while `merkeldag.proto` can be downloaded from [https://github.com/ipfs/go-merkledag/blob/master/pb/merkledag.proto](https://github.com/ipfs/go-merkledag/blob/master/pb/merkledag.proto).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`unixfs.proto`可以从[https://github.com/ipfs/go-unixfs/blob/master/pb/unixfs.proto](https://github.com/ipfs/go-unixfs/blob/master/pb/unixfs.proto)下载，而`merkeldag.proto`可以从[https://github.com/ipfs/go-merkledag/blob/master/pb/merkledag.proto](https://github.com/ipfs/go-merkledag/blob/master/pb/merkledag.proto)下载。'
- en: 'The following code block is the content of the `unixfs.proto` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是`unixfs.proto`文件的内容：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code block is the content of the `merkledag.proto` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是`merkledag.proto`文件的内容：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To simplify the process, you should remove the following lines in the `merkledag.proto`
    file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化流程，你应该删除`merkledag.proto`文件中的以下行：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, compile both `.proto` files using the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令编译两个`.proto`文件：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After doing this, you will get the `unixfs_pb2.py` and `merkledag_pb2.py` files
    that were generated as the output.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将得到生成的`unixfs_pb2.py`和`merkledag_pb2.py`文件。
- en: Let's create a script to decode our block data, `b'\n\x1b\x08\x02\x12\x15I am
    a good unicorn.\n\x18\x15'`, and name the script `unserialize_unicorn.py`*:*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本来解码我们的块数据，`b'\n\x1b\x08\x02\x12\x15I am a good unicorn.\n\x18\x15'`，并将脚本命名为`unserialize_unicorn.py`：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the script. This will give you the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本。这将给出以下输出：
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's dissect what’s happening here. Our original data, `b'I am a good unicorn.\n'`,
    is wrapped in `Data` from the `unixfs` proto module, and is then wrapped again
    in `PBNode` from the `merkledag` proto module. That's why we unserialize the serialized
    data in the script with `PBNode` first. Then, we unserialize the result with `Data`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来剖析一下这里发生了什么。我们的原始数据，`b'I am a good unicorn.\n'`，被包裹在`unixfs` proto模块的`Data`中，然后再次被包裹在`merkledag`
    proto模块的`PBNode`中。这就是为什么我们首先在脚本中用`PBNode`反序列化序列化的数据。然后，我们用`Data`反序列化结果。
- en: Multihash
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Multihash
- en: Now, let's hash the serialized data. IPFS uses multihash to hash the data. This
    means it is not just outputting the hash output, but it also outputs the hash
    function that it uses, the length of the hash output from that hash function,
    and the hash output from that hash function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对序列化数据进行哈希。IPFS使用multihash对数据进行哈希。这意味着它不仅输出哈希输出，还输出它使用的哈希函数、来自该哈希函数的哈希输出的长度以及该哈希函数的哈希输出。
- en: 'Let''s take a look at an example of the usage of multihash. Suppose the data
    that we want to hash is `b''i love you''`. We choose `sha256` as a hash function,
    as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个multihash的使用示例。假设我们要哈希的数据是`b'i love you'`。我们选择`sha256`作为哈希函数，如下：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s check out the length of this hash output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查一下这个哈希输出的长度：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since a number in hexadecimal format always takes two characters, the length
    of the hash output is 32 (64 / 2). However, we want the hexadecimal version of
    32, which is 0x20 or `20`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于十六进制格式的数字始终占据两个字符，哈希输出的长度为32（64/2）。但是，我们想要32的十六进制版本，即0x20或`20`。
- en: 'There is a hash function table that lists all hash functions that multihash
    supports (sha1, shake, blake, keccak, and so on). This can be seen here: [https://github.com/multiformats/multicodec/blob/master/table.csv](https://github.com/multiformats/multicodec/blob/master/table.csv).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个哈希函数表，列出了multihash支持的所有哈希函数（sha1、shake、blake、keccak等）。可以在这里看到：[https://github.com/multiformats/multicodec/blob/master/table.csv](https://github.com/multiformats/multicodec/blob/master/table.csv)。
- en: As you can see, `sha256` is given the number `12`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`sha256`被赋予了数字`12`。
- en: 'Now, we combine them using the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用以下命令将它们组合起来：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, we can use the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下命令：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s do this again, but using another function, which is `sha1`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一次，但是使用另一个函数，即`sha1`：
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The hex version of 20 (40 / 2) is 0x14, or `14`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 20的十六进制版本是0x14，或`14`。
- en: 'The `sha1` hash function is given the number 0x11 or `11` from the hash functions
    table. Hence, the output is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`sha1`哈希函数被赋予了数字0x11或`11`，来自哈希函数表。因此，输出如下：'
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, why would you want to use multihash and not just a normal hash function,
    such as `sha1`, `sha256`, or `keccak256`? The argument is sometimes that the hash
    function is broken, meaning that someone could find two different inputs with
    the same hash output in a reasonable time. If this happens, it is very dangerous.
    Hashing is used for integrity checks. Imagine I sent you a secret document to
    create a cure for cancer. To make sure it is not tampered with, we hash this document
    and then broadcast the hash output. Consequently, anyone who wants to learn this
    document needs to verify the hash of the document first before reading and executing
    it. However, imagine my enemy could create a different document. Now, instead
    of a cure for cancer, this document is a guide to creating a virus, but it still has
    the same hash output. If you hash the wrong document, you will innocently execute
    the file and create the virus.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要使用multihash而不是普通的哈希函数，比如`sha1`、`sha256`或`keccak256`？有时的论点是哈希函数已经被破解，这意味着有人可以在合理的时间内找到两个不同的输入，得到相同的哈希输出。如果发生这种情况，那就非常危险。哈希用于完整性检查。想象一下，我给你发送了一份秘密文件，用来治愈癌症。为了确保它没有被篡改，我们对这份文件进行哈希，然后广播哈希输出。因此，任何想要了解这份文件的人都需要在阅读和执行之前验证文件的哈希。然而，想象一下我的敌人可以创建一个不同的文件。现在，这份文件不再是治愈癌症的文件，而是创建病毒的指南，但它仍然具有相同的哈希输出。如果你对错误的文件进行哈希，你将无意中执行该文件并创建病毒。
- en: If a hash function is broken (and it happened, the `sha1` hash function is already
    broken), programmers need to upgrade their system. However, they will encounter
    difficulties because usually, they make assumptions regarding the hash function.
    For example, if they use the `sha1` function, they would expect the output from
    the hash function to be 20 numbers in length. If they choose to upgrade the hash
    function to `sha256`, they need to replace all the code that anticipates a length
    of 20 characters when dealing with the old hash function, which is cumbersome.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个哈希函数被破解了（而且已经发生了，`sha1`哈希函数已经被破解了），程序员们需要升级他们的系统。然而，他们会遇到困难，因为通常他们对哈希函数做了一些假设。例如，如果他们使用`sha1`函数，他们会期望从哈希函数得到的输出是20个数字的长度。如果他们选择将哈希函数升级到`sha256`，他们需要替换所有预期旧哈希函数处理时长度为20个字符的代码，这是很麻烦的。
- en: With `multihash`, we expect the upgrade process to be simplified because the
    function and the length of the output of the hash function is embedded in the
    output of the `multihash` function. We no longer make assumptions regarding the
    length of hashing output.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`multihash`，我们期望升级过程会变得简化，因为哈希函数的输出的函数和长度都嵌入在`multihash`函数的输出中。我们不再对哈希输出的长度做假设。
- en: 'If you still cannot get your head around the motivation of `multihash`, let''s
    experiment with it using the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不能理解`multihash`的动机，让我们用以下代码来实验一下：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Did you observe that when we want to check the integrity of the `b''i love
    you'' `data, we don''t make assumptions regarding the length of the hash output?
    We then discovered the bad news that the `sha1` hash function is broken. To upgrade
    our system, what we need to do is merely replace the `''sha1''` string with the `''sha2_256''`
    string:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当我们想要检查`b'i love you'`数据的完整性时，我们不会对哈希输出的长度做假设？然后我们发现了一个坏消息，那就是`sha1`哈希函数已经被破解了。为了升级我们的系统，我们需要做的只是将`'sha1'`字符串简单地替换为`'sha2_256'`字符串：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By using multihash, upgrading the hash function in the IPFS software becomes
    an easy task. The hash function is just a matter of configuration.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用multihash，升级IPFS软件中的哈希函数变得非常容易。哈希函数只是一个配置问题。
- en: Base58
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Base58
- en: 'The last thing we need to learn is `base58`. Base58 is a modified version of
    `base64`. This is usually used to encode the binary data as an ASCII string. The
    following code block is used to encode `b''i love you''` as an ASCII string:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要学习的最后一件事是`base58`。Base58是`base64`的修改版本。这通常用于将二进制数据编码为ASCII字符串。以下代码块用于将`b'i
    love you'`编码为ASCII字符串：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `base64` module is part of the Python standard library.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`base64`模块是Python标准库的一部分。'
- en: 'Usually, you will not encode another ASCII string with `base64`. Instead, you
    will encode binary data, such as an image file. If you open `cat.jpg` with the
    text editor, you would get gibberish text similar to the text that''s shown in
    the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会用`base64`来编码另一个ASCII字符串。相反，你会编码二进制数据，比如一个图片文件。如果你用文本编辑器打开`cat.jpg`，你会得到类似于以下截图中显示的无意义文本：
- en: '![](assets/f82c64d6-d77d-4a81-8569-18c5a45381bc.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f82c64d6-d77d-4a81-8569-18c5a45381bc.png)'
- en: 'This is a perfect example of encoding with `base64`. Why would you want to
    encode binary data with `base64`? One of the use cases is if you want to attach
    a cute cat picture in an email to your friend. Email protocol does not allow binary
    data. The following code block shows what the result will be if we attach the
    picture:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`base64`进行编码的一个完美例子。为什么你想要用`base64`来编码二进制数据呢？一个用例是，如果你想在电子邮件中给你的朋友附上一张可爱的猫图片。电子邮件协议不允许二进制数据。以下代码块展示了如果我们附上图片会得到什么结果：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The process of encoding with `base64` (how you turn `b'i love you'` into `b'aSBsb3ZlIHlvdQ=='`)
    is beyond the scope of this book. You can look into the `base64` specification
    if you are curious enough.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`base64`进行编码的过程（如何将`b'i love you'`转换为`b'aSBsb3ZlIHlvdQ=='`）超出了本书的范围。如果你很好奇，你可以查看`base64`规范。
- en: Now that you are familiar with `base64`, `base58` will be very simple. In `base58`
    encoding, the ambiguous letters when printed, such as 0, O, I, and l, are removed.
    The + (plus) and / (slash) characters are also removed. This `base58` encoding
    was designed by Satoshi Nakamoto to encode large integers. A Bitcoin address is
    just a very large integer in a nutshell. If you have ever transferred any amount
    in cryptocurrency (not necessarily Bitcoin), you would most likely have double
    checked the address to make sure the address is correct. For example, you want
    to transfer 1 Bitcoin to your grandma's Bitcoin address, and her address is `1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2`.
    If you are like most people, you would verify the correctness of the address a
    couple of times to make sure the address is not incorrect. By removing ambiguous
    characters such as 0, O, I, and l, you would find it easier to make sure this
    address is what it is supposed to be. Base58 is one of the good UX designs in
    software that is used to solve this problem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了`base64`，`base58`会变得非常简单。在`base58`编码中，打印时会产生歧义的字母，如0、O、I和l，都被移除了。+（加号）和/（斜杠）字符也被移除了。这种`base58`编码是由中本聪设计的，用于编码大整数。比特币地址本质上就是一个非常大的整数。如果你曾经转移过任何加密货币的金额（不一定是比特币），你很可能会多次检查地址以确保地址是正确的。例如，你想要向你奶奶的比特币地址转移1比特币，她的地址是`1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2`。如果你和大多数人一样，你会多次验证地址的正确性，以确保地址不是错误的。通过移除0、O、I和l等模棱两可的字符，你会发现更容易确保这个地址是它应该是的。Base58是软件中用来解决这个问题的良好用户体验设计之一。
- en: So, `base58` is not designed to encode a cute cat picture. You would use `base64`
    encoding for that purpose.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`base58`并不是设计用来编码可爱的猫图片的。你应该使用`base64`编码来实现这个目的。
- en: 'Let''s install the `base58` library to experiment with it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装`base58`库来进行实验：
- en: '[PRE50]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: By using `base58`, we can create a long hexadecimal string that can be checked
    and verified with ease using our own eyes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`base58`，我们可以创建一个长的十六进制字符串，可以轻松地用我们自己的眼睛进行检查和验证。
- en: Combining protobuf, multihash, and base58
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合protobuf、multihash和base58
- en: Now that you have learned about protobuf, multihash, and base58, we can finally make
    sense of the puzzle of how the content of the `b'I am a good unicorn.\n'` file turned
    into `'QmY7MiYeySnsed1Z3KxqDVYuM8pfiT5gGTqprNaNhUpZgR'`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了protobuf、multihash和base58，我们终于可以理解`b'I am a good unicorn.\n'`文件内容如何变成`'QmY7MiYeySnsed1Z3KxqDVYuM8pfiT5gGTqprNaNhUpZgR'`的谜题了。
- en: The `b'I am a good unicorn.\n'` data is wrapped in an IPFS node and serialized
    with protobuf into `b'\n\x1b\x08\x02\x12\x15I am a good unicorn.\n\x18\x15'`.
    Here's how to do it in Python.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`b''I am a good unicorn.\n''`数据被包装在IPFS节点中，并使用protobuf序列化为`b''\n\x1b\x08\x02\x12\x15I
    am a good unicorn.\n\x18\x15''`。以下是如何在Python中执行的。'
- en: 'Create a script and name it `serialize_unicorn.py`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`serialize_unicorn.py`的脚本：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run it. You should get the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它。您应该得到以下输出：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, this protobuf-serialized data is hashed with `sha256` (the multihash in
    the IPFS uses the `sha256` hashing function by default) into `'912d1af8f0013cd12a514859d20e9a196eb2845981408a84cf3543bb359a4536'`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个protobuf序列化的数据被`sha256`（IPFS中的multihash默认使用`sha256`哈希函数）哈希为`'912d1af8f0013cd12a514859d20e9a196eb2845981408a84cf3543bb359a4536'`。
- en: 'Here''s how to do it in Python:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在Python中执行的：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The number of `sha256` functions in the multihash table used by the IPFS is
    12\. The table can be seen here: [https://github.com/multiformats/multicodec/blob/master/table.csv](https://github.com/multiformats/multicodec/blob/master/table.csv).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: IPFS在multihash表中使用的`sha256`函数数量为12。表可以在这里看到：[https://github.com/multiformats/multicodec/blob/master/table.csv](https://github.com/multiformats/multicodec/blob/master/table.csv)。
- en: 'The length of the hash output is `32`, or 0x20 in hexadecimal. One hex number
    occupies two characters:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希输出的长度为`32`，或者用十六进制表示为0x20。一个十六进制数字占据两个字符：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s concatenate them:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它们连接起来：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you encode this output in base58 encoding, you should get `'QmY7MiYeySnsed1Z3KxqDVYuM8pfiT5gGTqprNaNhUpZgR'`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用base58编码对此输出进行编码，您应该得到`'QmY7MiYeySnsed1Z3KxqDVYuM8pfiT5gGTqprNaNhUpZgR'`。
- en: 'Here''s how you do it in Python. The `b58encode()` method only accepts byte
    objects, not hexadecimal objects, so you have to convert hexadecimal string into
    byte objects first:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在Python中执行的。`b58encode()`方法只接受字节对象，而不是十六进制对象，因此您必须首先将十六进制字符串转换为字节对象：
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`codecs` is part of the Python standard library.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`codecs`是Python标准库的一部分。'
- en: 'Upon executing the code, you will get the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，您将得到以下输出：
- en: '[PRE57]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Voilà! The puzzle has finally been solved.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 大功告成！谜题终于解开了。
- en: The ipfsapi API
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ipfsapi API
- en: Let's go back to the API of ipfsapi. We have added a file with IPFS API and
    received the hash that we use to refer to the content of the file. But if we add
    a big file, this will be split into many chunks. This is for efficiency purposes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到ipfsapi的API。我们已经使用IPFS API添加了一个文件，并收到了用于引用文件内容的哈希。但是，如果我们添加一个大文件，它将被分成许多块。这是为了提高效率。
- en: Let's download quite a big image file from Unsplash. Go to, [https://unsplash.com/photos/UBtUB4Qc-_4](https://unsplash.com/photos/UBtUB4Qc-_4) to
    download an image file. The name of the downloaded file is `milada-vigerova-1284157-unsplash.jpg`.
    Put this in the same directory as your IPFS Python script files. You could use
    any image file for this, but make sure its size is at least 1 MB. However, if
    you use another image file, you should get a different hash.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Unsplash下载一个相当大的图像文件。转到[https://unsplash.com/photos/UBtUB4Qc-_4](https://unsplash.com/photos/UBtUB4Qc-_4)下载一个图像文件。下载的文件名为`milada-vigerova-1284157-unsplash.jpg`。将其放在与您的IPFS
    Python脚本文件相同的目录中。您可以使用任何图像文件，但请确保其大小至少为1 MB。但是，如果您使用另一个图像文件，您应该得到一个不同的哈希。
- en: 'Create a script named `add_image_file.py` using the following code block:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码块创建一个名为`add_image_file.py`的脚本：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run it. You should get the following output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它。您应该得到以下输出：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, create another script to list all blocks from this block and name the
    script `list_blocks.py`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个脚本来列出此块中的所有块，并将脚本命名为`list_blocks.py`：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`pprint` is part of the Python standard library.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`pprint`是Python标准库的一部分。'
- en: 'Run the script. You should get the following output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本。您应该得到以下输出：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As I have explained in [Chapter 10](f50b5479-887d-48ab-a1db-381f2d3beb4f.xhtml),
    *InterPlanetary – A Brave New File System*, a big file would not be hashed straight
    away because of memory concerns. Instead, it will be divided into many chunks.
    Each chunk has a size of 262,158 bytes, except for the last one. However, you
    can configure the size of the chunk. Each chunk would be hashed separately. Then,
    the root hash of the content of the file is the combination of these hashes. The
    IPFS uses the Merkle tree to calculate the root hash. Of course, however, you
    must wrap each chunk inside the IPFS node before serializing it with protobuf.
    Then, there will be the container node that contains all of the links to these
    chunks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第10章](f50b5479-887d-48ab-a1db-381f2d3beb4f.xhtml)中解释的那样，*星际文件系统-一个崭新的文件系统*，一个大文件不会立即被哈希，因为内存问题。相反，它将被分成许多块。每个块的大小为262,158字节，最后一个除外。但是，您可以配置块的大小。每个块将被单独哈希。然后，文件内容的根哈希是这些哈希的组合。IPFS使用默克尔树来计算根哈希。当然，您必须在使用protobuf序列化之前将每个块包装在IPFS节点内。然后，将包含所有这些块链接的容器节点。
- en: 'You can reverse engineer the following IPFS block without `.proto` files:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在没有`.proto`文件的情况下对以下IPFS块进行逆向工程：
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Remember the hash from this image file. Get the IPFS block of this file content.
    You can use Python script or the IPFS command-line utility to do so:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个图像文件的哈希。获取此文件内容的IPFS块。您可以使用Python脚本或IPFS命令行实用程序来执行：
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We save the block, which is in binary format, to a binary file. Then, we can
    `decode` this binary file using the `protoc` compiler.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以二进制格式保存块，然后可以使用`protoc`编译器`解码`此二进制文件。
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You should get the following result:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下结果：
- en: '[PRE65]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You may be familiar with this structure. When you decode the serialized data
    in protobuf without proto files, the problem is that you have to guess what 1,
    2, 3, and 4 means inside a certain block. If you have proto files, this line, `3:
    2604197`, would turn into `filesize: 2604197`. Consequently, it is a good idea
    to get the proto files before decoding serialized data in protobuf.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能对这种结构很熟悉。当你在没有proto文件的情况下解码protobuf中的序列化数据时，问题在于你必须猜测某个块内的1、2、3和4代表什么。如果你有proto文件，这一行`3:
    2604197`将变成`filesize: 2604197`。因此，在解码protobuf中的序列化数据之前获取proto文件是一个好主意。'
- en: 'We can reconstruct the original file from these chunks. Let''s create the script
    and name it `construct_image_from_blocks.py`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这些块中重建原始文件。让我们创建脚本并将其命名为`construct_image_from_blocks.py`：
- en: '[PRE66]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: After running the script, if you open `image_from_blocks.jpg`, you will view
    the original image file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，如果你打开`image_from_blocks.jpg`，你将看到原始的图像文件。
- en: We have added one file. Now, let's try to add a directory of files.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个文件。现在，让我们尝试添加一个文件目录。
- en: Create a directory named `mysite`. Inside this directory, create a directory
    named `img`. Put the `cat.jpg` image file inside this `img` directory. Then, adjacent
    to the `img` directory, create a file named `index.html`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`mysite`的目录。在这个目录里，创建一个名为`img`的目录。将`cat.jpg`图像文件放在这个`img`目录中。然后，在`img`目录旁边创建一个名为`index.html`的文件。
- en: 'The following code block is the content of `index.html`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`的内容如下代码块所示：'
- en: '[PRE67]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, create a `README.md` file adjacent to the `img` directory as well. The
    following code block is the content of the `README.md` file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`img`目录旁边创建一个`README.md`文件。下面的代码块是`README.md`文件的内容：
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, create a Python script to add this directory to the IPFS and name the
    script `add_directory.py`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个Python脚本将这个目录添加到IPFS，并将脚本命名为`add_directory.py`：
- en: '[PRE69]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Running the, script will give you the following output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本将给你以下输出：
- en: '[PRE70]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The second argument of the `add` method concerns `recursive` arguments. The
    IPFS uses the Merkle DAG data structure to save this directory of files.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`方法的第二个参数涉及`recursive`参数。IPFS使用Merkle DAG数据结构来保存这个文件目录。'
- en: 'We can open our website in a browser with the following URL: `http://localhost:8080/ipfs/QmZamPcNnfZjjTkoyrYjYMEA8pp29KmpmkuSvkicSGiZDp/`.
    The following screenshot is how the website will appear in a browser:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器中打开我们的网站，使用以下URL：`http://localhost:8080/ipfs/QmZamPcNnfZjjTkoyrYjYMEA8pp29KmpmkuSvkicSGiZDp/`。以下截图是网站在浏览器中的显示方式：
- en: '![](assets/59d9a3a2-3131-4d20-a21d-0e5fcf154063.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/59d9a3a2-3131-4d20-a21d-0e5fcf154063.png)'
- en: 'You could also access the IPFS path from another gateway (using another node)
    using the following URL: [https://ipfs.io/ipfs/QmZamPcNnfZjjTkoyrYjYMEA8pp29KmpmkuSvkicSGiZDp/](https://ipfs.io/ipfs/QmZamPcNnfZjjTkoyrYjYMEA8pp29KmpmkuSvkicSGiZDp/).
    Depending on your internet connection, this could take some time because a node
    in the ipfs.io server needs to locate the content in your computer.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下URL从另一个网关（使用另一个节点）访问IPFS路径：[https://ipfs.io/ipfs/QmZamPcNnfZjjTkoyrYjYMEA8pp29KmpmkuSvkicSGiZDp/](https://ipfs.io/ipfs/QmZamPcNnfZjjTkoyrYjYMEA8pp29KmpmkuSvkicSGiZDp/)。根据你的互联网连接，这可能需要一些时间，因为ipfs.io服务器中的一个节点需要定位你计算机中的内容。
- en: IPNS
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPNS
- en: Being able to publish a file or a directory of files in which their integrities
    are guarded by hashes is wonderful. Occasionally, however, you may want to be
    able to publish a dynamic file with the same link. What I mean here is that a
    hash link would generate different content at different times. One of the use
    cases is that you want to publish news. Depending on the situation, news can change
    every minute or hour.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 能够发布由哈希保护完整性的文件或文件目录是很棒的。然而，偶尔你可能希望能够发布一个具有相同链接的动态文件。我在这里的意思是，哈希链接会在不同的时间生成不同的内容。一个用例是你想发布新闻。根据情况，新闻可能每分钟或每小时都会改变。
- en: The way you do that is by using the **Interplanetary Name System** (**IPNS**).
    The hash link is derived from the cryptography key in our IPFS node. When we launch
    the IPFS daemon, we become one node among many in IPFS peer-to-peer networks.
    Our identity is based on a cryptography key.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用**星际命名系统**（**IPNS**）来做到这一点。哈希链接是从我们的IPFS节点中的加密密钥派生出来的。当我们启动IPFS守护程序时，我们成为IPFS点对点网络中的众多节点之一。我们的身份是基于一个加密密钥的。
- en: 'Let''s create two horoscope predictions. The predictions here should change
    over time. The first filename is `horoscope1.txt`, and the content of this file
    is given in the following code block:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个星座预测。这里的预测应该随着时间的推移而改变。第一个文件名是`horoscope1.txt`，这个文件的内容在下面的代码块中给出：
- en: '[PRE71]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The second filename is `horoscope2.txt`, and the content of this file is given
    in the following code block:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件名是`horoscope2.txt`，这个文件的内容在下面的代码块中给出：
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s add those two files using this Python script, named `add_horoscope_predictions.py`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个Python脚本添加这两个文件，命名为`add_horoscope_predictions.py`：
- en: '[PRE73]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Running this will give you the following output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这将给你以下输出：
- en: '[PRE74]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note these two hashes that we obtained in the output.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在输出中获得的这两个哈希值。
- en: 'Now, create a script to list all of our keys and name the script `keys_list.py`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个脚本来列出我们所有的密钥，并将脚本命名为`keys_list.py`：
- en: '[PRE75]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Running the preceding script will give you the following output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述脚本将给你以下输出：
- en: '[PRE76]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, let''s publish our first horoscope prediction. Create a Python script
    named `publish_horoscope1.py` using the following code block:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们发布我们的第一个星座预测。使用以下代码块创建一个名为`publish_horoscope1.py`的Python脚本：
- en: '[PRE77]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Running this may take a while. Publishing a file in the IPNS is a little slow.
    If you are patient enough, you will get the following output:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这可能需要一些时间。在IPNS中发布文件有点慢。如果你足够耐心，你会得到以下输出：
- en: '[PRE78]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You publish content with the `name_publish()` method. It accepts a hash link
    of the content (IPFS path, not the filename) as the first argument.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`name_publish()`方法发布内容。它接受内容的哈希链接（IPFS路径，而不是文件名）作为第一个参数。
- en: Then, to access the content from the IPFS, you can use the `cat` or `get` methods.
    Here, we are using the `cat` method. The argument for the `cat` method is not
    a hash link or IPFS path, but an IPNS path, which is just a key that you can get
    from the `keys_list.py` script. You must prefix this with the `'/ipns/'` string.
    Consequently, the IPNS path is `'/ipns/ QmVPUMd7mFG54zKDNNzPRgENsr5VTbBxWJThfVd6j9V4U8'`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要从IPFS访问内容，可以使用`cat`或`get`方法。在这里，我们使用`cat`方法。`cat`方法的参数不是哈希链接或IPFS路径，而是IPNS路径，它只是一个可以从`keys_list.py`脚本中获取的密钥。您必须在此之前加上`'/ipns/'`字符串。因此，IPNS路径是`'/ipns/
    QmVPUMd7mFG54zKDNNzPRgENsr5VTbBxWJThfVd6j9V4U8'`。
- en: 'Now, let''s publish more data. Create a script named `publish_horoscope2.py` using
    the following code block:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们发布更多数据。使用以下代码块创建一个名为`publish_horoscope2.py`的脚本：
- en: '[PRE79]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Running this will give you a different result from the previous one:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将给出与上一个不同的结果：
- en: '[PRE80]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The IPNS path, which is `'ipns/ QmVPUMd7mFG54zKDNNzPRgENsr5VTbBxWJThfVd6j9V4U8'`,
    is still the same, but we got a different result.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: IPNS路径是`'ipns/ QmVPUMd7mFG54zKDNNzPRgENsr5VTbBxWJThfVd6j9V4U8'`，但我们得到了不同的结果。
- en: This is very interesting, but are we limited to a single IPNS path? No. You
    could generate another key so that you can have another IPNS path.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有趣，但我们是否仅限于单个IPNS路径？不。您可以生成另一个密钥，以便您可以有另一个IPNS路径。
- en: 'Create a Python script named `generate_another_key.py` using the following
    code block:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码块创建一个名为`generate_another_key.py`的Python脚本：
- en: '[PRE81]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Running the preceding script will give you the following output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述脚本将给出以下输出：
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Your new IPNS path from `'another_key'` is `'/ipns/ QmcU8u2Koy4fdrSjnSEjrMRYZVPLKP5YXQhLVePfUmjmkv'`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新IPNS路径从`'another_key'`是`'/ipns/ QmcU8u2Koy4fdrSjnSEjrMRYZVPLKP5YXQhLVePfUmjmkv'`。
- en: 'Then, when you want to publish content on the IPNS path, just use the `key`
    argument in `name_publish()`. Create a script named `publish_horoscope1_in_another_ipns.py` using
    the following code block:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当您想要在IPNS路径上发布内容时，只需在`name_publish()`中使用`key`参数。使用以下代码块创建一个名为`publish_horoscope1_in_another_ipns.py`的脚本：
- en: '[PRE85]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Run it. You should get the first horoscope prediction. As you may have observed,
    we use another peer ID. Notice the index 1 in `peer_id = c.key_list()['Keys'][1]['Id']`.
    Previously, we used the index 0.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它。您应该会得到第一个星座预测。正如您可能已经观察到的那样，我们使用了另一个对等ID。注意`peer_id = c.key_list()['Keys'][1]['Id']`中的索引1。之前，我们使用的是索引0。
- en: 'Publishing in the IPNS would not store it forever. By default, it stores the
    IPFS file for 24 hours. You could change the duration by using the `lifetime`
    keyword in `name_publish()`. For example, if you want to publish the IPFS file
    in the IPNS for `5h`, you could do this instead:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPNS中发布不会永久存储它。默认情况下，它会将IPFS文件存储24小时。您可以使用`name_publish()`中的`lifetime`关键字来更改持续时间。例如，如果您想要在IPNS中发布IPFS文件`5h`，您可以这样做：
- en: '[PRE86]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Pinning
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定
- en: 'What if you want to delete the file on the IPFS? Let''s say you accidentally
    add a nude picture of yourself using the `ipfs add` command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在IPFS上删除文件怎么办？假设您意外使用`ipfs add`命令添加了一张裸照：
- en: '[PRE87]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How do you remove your nude picture? There is no such thing as `ipfs rm QmPCqvJHUs517pdcFNZ7EJMKcjEtbUBUDYxZcwsSijRtBx`
    because this command does not make any sense. What is it supposed to do? Tell
    every node that holds your nude picture to delete the picture? That would defeat
    the noble purpose of IPFS. What you can do is remove the picture on your IPFS
    local storage. The term for removing the local file in IPFS is called *removing
    the pin*. After removing the pin of your nude picture file, the content is still
    in IPFS local storage. But when the garbage collector of the IPFS works to clean
    up objects, it would remove the content of your nude picture file. Hopefully,
    no one has had the opportunity to pin (download) this sensitive file on their
    nodes!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如何删除您的裸照？没有`ipfs rm QmPCqvJHUs517pdcFNZ7EJMKcjEtbUBUDYxZcwsSijRtBx`这样的东西，因为这个命令没有任何意义。它应该做什么？告诉每个持有您裸照的节点删除照片？那将违背IPFS的崇高目的。您可以做的是删除IPFS本地存储中的照片。在IPFS中删除本地文件的术语称为*删除固定*。在删除裸照文件的固定之后，内容仍然在IPFS本地存储中。但是当IPFS的垃圾收集器工作以清理对象时，它将删除您裸照文件的内容。希望没有人有机会在他们的节点上固定（下载）这个敏感文件！
- en: 'Let''s create a script to remove the pin and ask the garbage collector to do
    its job. Name the script `removing_nude_picture.py`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本来删除固定并要求垃圾收集器执行其工作。将脚本命名为`removing_nude_picture.py`：
- en: '[PRE88]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Run the script. Then, if you try to get the content of your nude picture, it
    will fail:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本。然后，如果您尝试获取您的裸照的内容，将会失败：
- en: '[PRE89]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Of course, if someone has already pinned your nude picture in another node,
    then you would still get the content of your nude picture.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果有人已经在另一个节点上固定了您的裸照，那么您仍然会得到您的裸照的内容。
- en: 'The nude picture in this example is basically a nude picture of a panda, which
    can be downloaded from the Unsplash website from: [https://unsplash.com/photos/IgdVdJCmzf4](https://unsplash.com/photos/IgdVdJCmzf4).
    If you use this picture in this example, be prepared that there are other people
    who will use it as well. To test whether deleting a pin really works, you could
    use a truly unique file that no one in this world has. There is a way to check
    whether the file has been deleted on your local storage by dissecting the `LevelDB`
    file in the IPFS store path. However, that is beyond the scope of this book.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，裸照基本上是一张熊猫的裸照，可以从Unsplash网站下载：[https://unsplash.com/photos/IgdVdJCmzf4](https://unsplash.com/photos/IgdVdJCmzf4)。如果您在这个例子中使用这张图片，请准备好其他人也会使用它。要测试删除固定是否真的有效，您可以使用一个这个世界上没有人拥有的真正独特的文件。有一种方法可以通过解剖IPFS存储路径中的`LevelDB`文件来检查文件是否已从您的本地存储中删除。但是，这超出了本书的范围。
- en: Pubsub
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pubsub
- en: The IPFS has an experimental feature, which is **Publish-Subscribe**, or **pubsub**.
    Basically, a node in the IPFS can subscribe to a topic. Let's say this topic is
    a Bitcoin topic. A node in the IPFS can publish a *To the moon!* message to a
    bitcoin topic. Then, any node that subscribes to the 'bitcoin' topic could get
    the message.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: IPFS有一个实验性功能，即**发布-订阅**，或**pubsub**。基本上，IPFS中的一个节点可以订阅一个主题。假设这个主题是比特币主题。IPFS中的一个节点可以向比特币主题发布*To
    the moon!*消息。然后，任何订阅'bitcoin'主题的节点都可以收到该消息。
- en: 'Because pubsub is an experimental feature, you need to run IPFS daemon with
    a particular flag. Run IPFS daemon with the `--enable-pubsub-experiment` flag
    using the following command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因为pubsub是一个实验性功能，您需要使用特定标志运行IPFS守护程序。使用以下命令使用`--enable-pubsub-experiment`标志运行IPFS守护程序：
- en: '[PRE90]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Both the subscriber and the publisher need to run the daemon with this particular
    flag.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者和发布者都需要使用特定标志运行守护程序。
- en: 'Let''s create a script to subscribe to a certain topic and name the script
    `subscribe_topic.py`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本来订阅特定主题，并将脚本命名为`subscribe_topic.py`：
- en: '[PRE91]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The method to subscribe to a topic is `pubsub_sub`. The first argument is a
    topic we want to subscribe to. When we receive data from our subscription, we
    will also get the information about the sender. However, for now, we only care
    about the message. This message is in `base64` encoding, so we have to decode
    it first.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅主题的方法是`pubsub_sub`。第一个参数是我们想要订阅的主题。当我们从订阅中接收数据时，我们还将获得有关发送者的信息。但是，目前我们只关心消息。这条消息是以`base64`编码的，所以我们必须先解码它。
- en: Run the script. This will wait until any message is received before exiting.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本。这将在接收到任何消息之前等待。
- en: 'Let''s create a script to publish to this topic and name the script `publish_topic.py`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本来发布到这个主题，并将脚本命名为`publish_topic.py`：
- en: '[PRE92]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: It would be better if you run this script in another computer so you can marvel
    at the wonder of the decentralized technology. Don't forget that you must run
    the IPFS daemon with a particular flag. But if you are lazy, you could run this
    script in the same computer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在另一台计算机上运行此脚本，这样您就可以对去中心化技术的奇迹感到惊叹。不要忘记您必须使用特定标志运行IPFS守护程序。但是如果您懒得话，也可以在同一台计算机上运行此脚本。
- en: While the subscribing script is running, run the publishing script.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当订阅脚本正在运行时，运行发布脚本。
- en: 'Then, in the Terminal where you run the subscribing script, you should get
    the following output:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在运行订阅脚本的终端中，您应该会得到以下输出：
- en: '[PRE93]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: So, what is pubsub good for? To start with, you could build a notification system.
    Imagine you run a home file-sharing system for your family. When you add a picture
    of your daughter, you want to give notice to all of your family members. Not just
    a notification; you could build a decentralized chatting system (something such
    as IRC or Slack). When combined with other technologies, such as a content-free
    replicated data type, you could even build a decentralized online pair programming
    system on top of the IPFS!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，pubsub有什么好处呢？首先，您可以构建一个通知系统。想象一下，您为家人运行一个家庭文件共享系统。当您添加您女儿的照片时，您希望通知所有家庭成员。不仅仅是通知；您还可以构建一个去中心化的聊天系统（类似于IRC或Slack）。当与其他技术结合使用时，例如无内容复制数据类型，甚至可以在IPFS之上构建一个去中心化的在线配对编程系统！
- en: Beware that pubsub are still experimental features. The developers of the IPFS
    have many interesting plans in the pipeline. Among the most interesting is the
    plan to add an authentication system to the top of the pubsub system based on
    a cryptography key. Now, everyone can publish and subscribe to a topic.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，pubsub仍然是实验性功能。IPFS的开发人员在计划中有许多有趣的计划。其中最有趣的计划之一是计划在pubsub系统的顶部添加基于密码学密钥的身份验证系统。现在，每个人都可以发布和订阅主题。
- en: Mutable File System
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变文件系统
- en: 'The IPFS has a feature called Mutable File System (MFS). The MFS is different
    from your OS file system. Let''s create a script to explore this feature and name
    the script `exploring_mfs.py`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: IPFS有一个名为可变文件系统（MFS）的功能。MFS与您的操作系统文件系统不同。让我们创建一个脚本来探索这个功能，并将脚本命名为`exploring_mfs.py`：
- en: '[PRE94]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Running this will give you the following output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这将给出以下输出：
- en: '[PRE95]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You may wonder what the point of this feature is. There is nothing that you
    can do in your MFS that you cannot do in your OS file system. In terms of this
    particular example, yes, you are right that this feature is pointless. But there
    is one subtle difference between MFS and your OS file system when copying files.
    Let''s create a script to prove this assertion and name the script `copy_in_mfs.py`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道这个功能的意义是什么。在您的MFS中，没有任何您不能在操作系统文件系统中做的事情。在这个特定的例子中，是的，您是对的，这个功能是毫无意义的。但是在复制文件时，MFS和您的操作系统文件系统之间有一个微妙的区别。让我们创建一个脚本来证明这个断言，并将脚本命名为`copy_in_mfs.py`：
- en: '[PRE96]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Running the script will give you the following output:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本将给出以下输出：
- en: '[PRE97]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The file with the hash link `QmY8zTocoVNDJWUr33nhksBiZ3hxugFPhb6qSzpE761bVN`
    is a cute bear video that can be downloaded from: [https://videos.pexels.com/videos/bear-in-a-forest-855113](https://videos.pexels.com/videos/bear-in-a-forest-855113).
    You can download this with the following command: `ipfs get QmY8zTocoVNDJWUr33nhksBiZ3hxugFPhb6qSzpE761bVN`
    (assuming my IPFS node is online, you could download the video from that URL and
    pin the video yourself in another computer to test the script if no other IPFS
    nodes pinning this video are online). The file size is 46 MB, but the script was
    executed very quickly. The runtime of the script is too fast considering we have
    to download the video file. That happened because we do not download the video
    to our storage. The path of `/46MB_cute_bear.mp4` in our MFS is not a genuinely
    traditional file, as in our OS file system. You can say it''s like a symbolic
    link to a real file in the IPFS, pinned by some nodes in the IPFS ecosystem.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 具有哈希链接`QmY8zTocoVNDJWUr33nhksBiZ3hxugFPhb6qSzpE761bVN`的文件是一个可爱的熊视频，可以从以下链接下载：[https://videos.pexels.com/videos/bear-in-a-forest-855113](https://videos.pexels.com/videos/bear-in-a-forest-855113)。您可以使用以下命令下载：`ipfs
    get QmY8zTocoVNDJWUr33nhksBiZ3hxugFPhb6qSzpE761bVN`（假设我的IPFS节点在线，您可以从该URL下载视频并将视频固定在另一台计算机上以测试脚本，如果没有其他固定此视频的IPFS节点在线）。文件大小为46
    MB，但脚本执行非常快。考虑到我们必须下载视频文件，脚本的运行时间太快了。这是因为我们没有将视频下载到我们的存储中。在我们的MFS中`/46MB_cute_bear.mp4`的路径不是真正的传统文件，就像我们的操作系统文件系统中一样。您可以说它就像是指向IPFS中真实文件的符号链接，由IPFS生态系统中的一些节点固定。
- en: That means you could copy 100 TB files from IPFS paths to your MFS and it would
    not take any storage (except for some metadata).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以从IPFS路径复制100 TB文件到您的MFS，而不会占用任何存储空间（除了一些元数据）。
- en: If you think like a computer scientist, the IPFS file system is like a giant
    graph database.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像计算机科学家一样思考，IPFS文件系统就像一个巨大的图形数据库。
- en: Other APIs
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他API
- en: There are other methods of the IPFS HTTP API that we don't have room to discuss
    here. The complete reference can be found in [https://docs.ipfs.io/reference/api/http/](https://docs.ipfs.io/reference/api/http/).
    There are APIs to bootstrap your nodes (which is useful if you want to construct
    your nodes list based on certain existing nodes), to find nearby nodes from a
    node, to connect to a particular node, to configure the IPFS, to shutdown IPFS
    daemon, and so on.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: IPFS HTTP API还有其他我们没有空间讨论的方法。完整的参考资料可以在[https://docs.ipfs.io/reference/api/http/](https://docs.ipfs.io/reference/api/http/)中找到。有API可以引导您的节点（如果您想要基于某些现有节点构建您的节点列表），从节点中找到附近的节点，连接到特定节点，配置IPFS，关闭IPFS守护程序等。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about interacting with the IPFS through the
    HTTP API using Python. First of all, you installed IPFS software and ran the daemon.
    You started this by adding a file to the IPFS and studied how to get the hash
    of the content of the file, which is based on protobuf, multihash, and base58\.
    Then, you saw that a big file would be divided into many chunks if added to the
    IPFS. You could also add a directory of files into the IPFS. Based on this ability,
    you could host a static website on the IPFS. Then, you learned about publishing
    IPFS files in the IPNS on which you could have dynamic content. After this, you
    learned about the MFS, where you could copy a large file from the IPFS without
    incurring any significant costs in your local storage.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何使用Python通过HTTP API与IPFS进行交互。首先，您安装了IPFS软件并运行了守护进程。您通过将文件添加到IPFS并学习如何获取文件内容的哈希值（基于protobuf、multihash和base58）来开始这一过程。然后，您看到如果将大文件添加到IPFS中，它将被分成许多块。您还可以将文件目录添加到IPFS中。基于这种能力，您可以在IPFS上托管静态网站。然后，您了解了如何在IPNS上发布IPFS文件，从而可以拥有动态内容。之后，您了解了MFS，可以在其中从IPFS复制大文件，而不会在本地存储中产生任何显著的成本。
- en: In the next chapter, you will combine the IPFS and smart contracts to build
    a decentralized application.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将结合IPFS和智能合约来构建一个去中心化的应用程序。
- en: Further reading
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are the references to the various sites associated with this
    chapter:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与本章相关的各个网站的参考资料：
- en: '[https://github.com/ipfs/py-ipfs-api](https://github.com/ipfs/py-ipfs-api)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/ipfs/py-ipfs-api](https://github.com/ipfs/py-ipfs-api)'
- en: '[https://docs.ipfs.io/](https://docs.ipfs.io/)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.ipfs.io/](https://docs.ipfs.io/)'
