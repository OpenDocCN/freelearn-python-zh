- en: Chapter 4. Variables, Assignment and Scoping Rules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：变量、赋值和作用域规则
- en: An expression creates objects; we can assign objects to variables to preserve
    them for future use. Python offers a number of variations on the theme of assignment.
    In addition to simply assigning a single variable, we can assign items from a
    tuple to multiple variables. We can also combine an operator with assignment,
    which updates a mutable object.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式创建对象；我们可以将对象赋值给变量以保留它们供将来使用。Python在赋值主题上提供了一系列变体。除了简单地赋值给单个变量外，我们还可以将元组中的项赋值给多个变量。我们还可以将运算符与赋值结合，以更新可变对象。
- en: In this chapter, we'll also look at the `input()` function as a way to introduce
    new objects into a running script. This is limited—it doesn't compare with a proper
    **graphical user interface** (**GUI**). It will, however, help us learn more Python
    programming techniques before we introduce how to read data from files and the
    filesystem in [Chapter 10](ch10.html "Chapter 10. Files, Databases, Networks,
    and Contexts"), *Files, Databases, Networks, and Contexts*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将探讨`input()`函数作为将新对象引入运行脚本的一种方式。这有限制——它无法与合适的**图形用户界面**（**GUI**）相提并论。然而，它将帮助我们学习更多Python编程技术，在我们介绍如何在[第10章](ch10.html
    "第10章。文件、数据库、网络和上下文")中从文件和文件系统中读取数据之前。
- en: We'll also look at some important Python language concepts. We'll look at the
    way Python programs are always written generically, without specific bindings
    to data types or classes. We'll also look at the general concept of a namespace,
    and how this is applied widely in various Python language constructs. It defines
    the scope in which an identifier is visible; something that will become increasingly
    important as our programs become more complex.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨一些重要的Python语言概念。我们将探讨Python程序总是以通用方式编写的的方式，而不绑定到特定数据类型或类。我们还将探讨命名空间的一般概念，以及它在各种Python语言构造中的应用。它定义了标识符可见的作用域；随着我们的程序变得更加复杂，这将成为越来越重要的事情。
- en: Simple assignment and variables
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的赋值和变量
- en: 'We''ve seen a few examples of the essential Python assignment statement in
    previous chapters. The statement includes a variable, `=`, and an expression.
    Since a single object is an expression, we can write:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中已经看到了几个Python基本赋值语句的例子。该语句包括一个变量、`=`和一个表达式。由于单个对象是一个表达式，我们可以这样写：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create the floating-point literal `3.14` and assign this object to
    a variable named `pi`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建浮点字面量`3.14`并将其赋值给名为`pi`的变量。
- en: Variable names must follow the rules in section 2.3, *Identifiers and Keywords*,
    of the *Python Language Reference*. The reference manual uses the Unicode character
    class definitions provided in the `unicodedata` module.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名必须遵循《Python语言参考》中第2.3节“标识符和关键字”的规则。参考手册使用`unicodedata`模块提供的Unicode字符类定义。
- en: Interesting background information on the problem of programming language identifiers
    is available in Unicode Standard Annex 31, *Unicode Identifier and Pattern Syntax*.
    This shows how the Python problem of how "what is an identifier?" fits into the
    larger context of other programming languages and the variety of natural languages
    used around the world.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编程语言标识符问题的有趣背景信息可在Unicode标准附录31《Unicode标识符和模式语法》中找到。这展示了Python中“标识符是什么？”的问题如何融入其他编程语言和世界各地使用的各种自然语言的更广泛背景中。
- en: 'In Python, identifiers have a small set of start characters; these are chosen
    to allow a lexical scanner to determine what kinds of characters can follow. If
    identifiers began with digits, it would be rather complex to distinguish identifiers
    from numbers. Consequently, identifiers must begin with a letter or `_`. After
    the initial character, Python allows an identifier to continue with characters
    that may come from a larger set of characters: letters, digits, and `_`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，标识符有一组小的起始字符；这些字符的选择是为了允许词法扫描器确定可以跟随的字符类型。如果标识符以数字开头，那么区分标识符和数字将会相当复杂。因此，标识符必须以字母或`_`开头。在初始字符之后，Python允许标识符继续使用可能来自更大字符集的字符：字母、数字和`_`。
- en: What do we really mean by "letter" or "digit"? In earlier versions of Python,
    these terms were defined by the Latin-based ASCII alphabet. Using Unicode means
    that the terms now have more inclusive definitions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的“字母”或“数字”究竟是什么意思？在Python的早期版本中，这些术语由基于拉丁字母的ASCII字母表定义。使用Unicode意味着这些术语现在有更包容的定义。
- en: 'Python defines the identifier starting character as belonging to the following
    Unicode categories: uppercase letters (`Lu`), lowercase letters (`Ll`), title
    case letters (`Lt`), modifier letters (`Lm`), other letters (`Lo`), and letter
    numbers (`Nl`). Python also includes the small set of characters in the `Other_ID_Start`
    category. The set of characters defined by these categories is large. Latin letters
    in the ranges `a-z` and `A-Z`, for example, are in this set. When writing more
    mathematically-oriented programs, the Greek letters `α-ω` and `A-Ω` can also be
    used as identifier start characters. We can write this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python定义的标识符起始字符属于以下Unicode类别：大写字母（`Lu`），小写字母（`Ll`），标题字母（`Lt`），修饰字母（`Lm`），其他字母（`Lo`），和字母数字（`Nl`）。Python还包括`Other_ID_Start`类别中的小字符集。这些类别定义的字符集很大。例如，`a-z`和`A-Z`范围内的拉丁字母属于这个集合。当编写更多数学导向的程序时，希腊字母`α-ω`和`A-Ω`也可以用作标识符起始字符。我们可以这样写：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This assigns the result of the expression to the variable, `π`. Some programmers
    find that their OS keyboard interface makes letters outside a single national
    alphabet awkward to use; consequently, they suggest focusing on Latin letters
    for programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将表达式的结果赋值给变量，`π`。一些程序员发现他们的操作系统键盘界面使得使用非单一国家字母的字母难以使用；因此，他们建议专注于拉丁字母进行编程。
- en: 'Identifiers can continue with any of the letters defined in the previous paragraph,
    the `_` character, and characters from the following categories: nonspacing marks
    (`Mn`), spacing combining marks (`Mc`), decimal numbers (`Nd`), and connector
    punctuations (`Pc`). This allows us to include ordinary decimal digits as well
    as other "combining" marks that modify the previous character. For example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符可以继续使用前一段中定义的任何字母，下划线字符，以及以下类别的字符：非间距标记（`Mn`），间距组合标记（`Mc`），十进制数字（`Nd`），和连接标点（`Pc`）。这允许我们包括普通的十进制数字以及其他“组合”标记，这些标记会修改前面的字符。例如：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This shows the character **GREEK SMALL LETTER PI** followed by the **COMBINING
    DIACRITICAL CIRCUMFLEX** to create a "pi-hat" variable, ![Simple assignment and
    variables](img/B03671_04_01.jpg). It may be awkward to type for some developers,
    but it also may fit nicely with a population genomics formulae which use this
    symbol combination. The Inheritance By Descent estimator, for example, uses ![Simple
    assignment and variables](img/B03671_04_01.jpg). The expression shown earlier
    involves two other variables, `p_2` and `p_1`, which use more common Latin letters,
    `_,` and digits.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了字符**希腊小写字母PI**后面跟着**组合重音符号**来创建一个“pi-hat”变量，![简单的赋值和变量](img/B03671_04_01.jpg)。对于一些开发者来说，这可能难以输入，但它也可能很好地与使用这种符号组合的群体基因组公式相匹配。例如，遗传下降估计器使用![简单的赋值和变量](img/B03671_04_01.jpg)。之前显示的表达式涉及两个其他变量，`p_2`和`p_1`，它们使用更常见的拉丁字母`_`和数字。
- en: Note that variable names that begin and end with `__` (two underscores) are
    reserved by Python for special purposes. For example, we have global variables
    such as `__name__`, `__debug__`, and `__file__` which are set when our script
    starts running.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以`__`（两个下划线）开头和结尾的变量名被Python保留用于特殊目的。例如，我们有全局变量如`__name__`、`__debug__`和`__file__`，这些变量在脚本开始运行时被设置。
- en: There's no reason for our application to ever create new names which begin and
    end with `__`. We're not prohibited from creating such variables, but any name
    that we might adopt could be used by some internal feature of Python.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序没有必要创建以`__`开头和结尾的新名称。我们没有被禁止创建这样的变量，但任何我们可能采用的名称都可能被Python的一些内部特性使用。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's best to assume that at all names beginning and ending with `__` (double
    underscore) are reserved by Python and do something special. Even if the name
    is not used in the current release, that doesn't mean it won't be used in a future
    release.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最好假设所有以`__`（双下划线）开头和结尾的名称都被Python保留并执行特殊操作。即使名称在当前版本中没有使用，这并不意味着在未来的版本中不会使用。
- en: Multiple assignment
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重赋值
- en: We looked at tuples in [Chapter 2](ch02.html "Chapter 2. Simple Data Types"),
    *Simple Data Types*. One of the important reasons for using a tuple is that it
    has a fixed number of items. Since a tuple is a kind of sequence, we can refer
    to items within a tuple using numeric indices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章。简单数据类型")*简单数据类型*中探讨了元组。使用元组的一个重要原因是有固定数量的项目。由于元组是一种序列，我们可以使用数字索引来引用元组内的项目。
- en: 'Consider the following RGB triple:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下RGB三元组：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can use `brick_red[0]` to get the red element of this triple.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`brick_red[0]`来获取这个三元组的红色元素。
- en: 'We can also do this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样做：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've used multiple assignment to decompose the RGB three-tuple into three individual
    variables.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用多重赋值将 RGB 三元组分解为三个单独的变量。
- en: This works when the number of variables on the left side of the `=` matches
    the number of items in the collection on the right side. When working with fixed-sized
    tuples, this is an easy condition to guarantee.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当左侧 `=` 的变量数量与右侧集合中的项目数量匹配时，这会起作用。当处理固定大小的元组时，这是一个容易保证的条件。
- en: When working with mutable collections such as `list`, `set`, or `dict`, this
    kind of assignment may not work out well. If we can't guarantee the number of
    elements in a mutable collection, we may wind up with a `ValueError` exception
    because our collection doesn't match the number of variables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理如 `list`、`set` 或 `dict` 这样的可变集合时，这种赋值可能不会很好用。如果我们不能保证可变集合中元素的数量，我们可能会遇到 `ValueError`
    异常，因为我们的集合与变量的数量不匹配。
- en: 'Note that Python''s syntax flexibility means that we can also do things like
    this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python 的语法灵活性意味着我们也可以这样做：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It isn't absolutely necessary to wrap a tuple in `()`. It's generally a best
    practice to use `()` around a tuple. However, in a few cases, the statement is
    perfectly clear without the additional parentheses.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 并非绝对必要将元组用 `()` 括起来。通常，在元组周围使用 `()` 是一种最佳实践。然而，在少数情况下，没有额外的括号，语句也是完全清晰的。
- en: Using repeated assignment
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用重复赋值
- en: 'Python allows us to write statements like this: `a = b = 0`. This must be used
    carefully, because a single object is now shared by two variables. When working
    with immutable objects like numbers, strings, and tuples, multiple variables share
    a reference to a common object.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许我们编写这样的语句：`a = b = 0`。这必须谨慎使用，因为现在两个变量共享一个对象。当处理像数字、字符串和元组这样的不可变对象时，多个变量共享对公共对象的引用。
- en: When we look at mutable objects in [Chapter 6](ch06.html "Chapter 6. More Complex
    Data Types"), *More Complex Data Types*, we'll see that this kind of repeated
    assignment can become a source of confusion. While this assignment is legal, it
    must be used only with immutable objects like numbers, strings, or tuples.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第6章](ch06.html "第6章。更复杂的数据类型")中查看可变对象时，*更复杂的数据类型*，我们会看到这种重复赋值可能成为混淆的来源。虽然这种赋值是合法的，但它必须仅用于像数字、字符串或元组这样的不可变对象。
- en: Using the head, *tail assignment
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用头部，*尾部赋值
- en: When working with sequences, there are some algorithms which work by separating
    the head of the sequence from the rest of the sequence. We can do this with a
    variation on the assignment statement. We like to call this the `head, *tail =`
    assignment statement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理序列时，有一些算法通过将序列的头部与序列的其余部分分离来工作。我们可以通过赋值语句的变体来做这件事。我们喜欢称这种赋值语句为 `head, *tail
    =` 赋值语句。
- en: 'Let''s say that we have an input string with a list of values, something like
    this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含值的输入字符串，类似于这样：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have split the string into space-delimited words with `line.split()`. In
    this case, the head of the list is the first three fields of the red, green, and
    blue elements of a color. The tail is all the remaining fields, which is the name
    parsed into separate words.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `line.split()` 将字符串分割成空格分隔的单词。在这种情况下，列表的头部是红色、绿色和蓝色元素的第一个三个字段。尾部是所有剩余的字段，即解析成单独单词的名字。
- en: We can use `head, *tail =` assignment to split the first three fields from the
    remaining files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `head, *tail =` 赋值来从剩余的文件中分离出前三个字段。
- en: 'It looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've assigned the first three items to three separate variables, `r`, `g`,
    and `b`. The `*` means that all of the remaining items will be collected into
    a single variable, `name`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将前三个项目分配给了三个单独的变量，`r`、`g` 和 `b`。`*` 表示所有剩余的项目都将收集到一个单独的变量 `name` 中。
- en: 'We can reconstruct the original name with the `join()` method, with a space
    as the separator string:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `join()` 方法，以空格作为分隔字符串来重建原始名称：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've used a space to join the elements of the sequence named `name`. This will
    reconstruct the original color name as a single string instead of a list of words.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用空格将名为 `name` 的序列的元素连接起来。这将重建原始颜色名称作为一个单独的字符串，而不是一个单词列表。
- en: Augmented assignment
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增量赋值
- en: 'The augmented assignment statement combines an operator with assignment. A
    common example is this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 增量赋值语句结合了一个运算符和赋值。一个常见的例子是：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is equivalent to
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When working with immutable objects (numbers, strings, and tuples) the idea
    of an augmented assignment is syntactic sugar. It allows us to write the updated
    variable just once. The statement `a += 1` always creates a fresh new number object,
    and replaces the value of *a* with the new number object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当与不可变对象（数字、字符串和元组）一起工作时，扩展赋值的概念是语法糖。它允许我们只更新一次变量。语句`a += 1`始终创建一个新的数字对象，并用新的数字对象替换*a*的值。
- en: Any of the operators can be combined with assignment. The means that `+=`, `-=`,
    `*=`, `/=`, `//=`, `%=`, `**=`, `>>=`, `<<=`, `&=`,`^=`, and `|=` are all assignment
    operators. We can see obvious parallels between sums using `+=`, and products
    using `*=`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 任何运算符都可以与赋值操作结合使用。这意味着`+=`、`-=`、`*=`、`/=`、`//=`、`%=`、`**=`、`>>=`、`<<=`、`&=`、`^=`和`|=`都是赋值运算符。我们可以看到使用`+=`进行求和和使用`*=`进行乘积之间的明显平行关系。
- en: 'In the case of mutable objects, this augmented assignment can take on special
    significance. When we look at `list` objects in [Chapter 6](ch06.html "Chapter 6. More
    Complex Data Types"), *More Complex Data Types*, we''ll see how we can append
    an item to a `list` object. Here''s a forward-looking example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在可变对象的情况下，这种扩展赋值可以具有特殊的意义。当我们查看[第6章](ch06.html "第6章。更复杂的数据类型")*更复杂的数据类型*中的`列表`对象时，我们将看到我们如何向`列表`对象追加一个项目。以下是一个前瞻性的例子：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This assigns a `list` object, a variable-length sequence of items, to the variable
    `some_list`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个`列表`对象，一个由项目组成的可变长度序列，赋值给变量`some_list`。
- en: 'We can update this `list` object with an augmented assignment statement:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用扩展赋值语句来更新这个`列表`对象：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, we''re actually mutating a single `list` object, changing its
    internal state by extending it with items from another `list` instance. The existing
    object was updated; this does not create a new object. It is equivalent to using
    the `extend()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们实际上是在修改单个`列表`对象，通过从另一个`列表`实例中扩展它来改变其内部状态。现有的对象被更新；这不会创建一个新的对象。它相当于使用`extend()`方法：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've mutated the `list` object a second time, extending it with items from
    another single-item `list` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经第二次修改了`列表`对象，通过从另一个单元素`列表`对象中添加项目来扩展它。
- en: This optimization of a `list` object is something that we'll look at in [Chapter
    6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex Data Types*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对`列表`对象的优化是我们将在[第6章](ch06.html "第6章。更复杂的数据类型")*更复杂的数据类型*中探讨的内容。
- en: The input() function
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`input()`函数'
- en: 'For simple applications, the `input()` function can be used to gather input
    from a user. This function writes a prompt and accepts input. The returned value
    is a string. We might use this in a script file as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的应用程序，可以使用`input()`函数从用户那里收集输入。该函数写入提示并接受输入。返回的值是一个字符串。我们可以在脚本文件中使用如下方式：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will write a simple prompt on the console, and accept a string as input.
    The string value will be converted to a floating-point number, if possible. If
    the string is not a valid number, the `float()` function will raise an exception.
    This will then print a line of output.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上写入一个简单的提示，并接受一个字符串作为输入。如果可能，字符串值将被转换为浮点数。如果字符串不是一个有效的数字，`float()`函数将引发异常。这将然后打印一行输出。
- en: 'Here''s how it looks when we run it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行它时的样子：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've highlighted the command, which is entered after the OS shell prompt. The
    statements in the script file, named as part of the command, are executed in order.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出显示了命令，这是在操作系统shell提示符之后输入的。脚本文件中的语句，作为命令的一部分命名，将按顺序执行。
- en: Our input to Python, `11`, is also highlighted, to show how the `input()` function
    supports simple interaction.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入Python的`11`也被突出显示，以展示`input()`函数如何支持简单的交互。
- en: The `input()` function only returns a Unicode string. Our script is responsible
    for any further parsing, validation, or conversion.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()`函数只返回一个Unicode字符串。我们的脚本负责任何进一步的解析、验证或转换。'
- en: When working on simple console applications, there are some additional libraries
    which may prove helpful. There is a `getpass` module which helps to get passwords
    by suppressing the character echo that's a default feature of console input. This
    is highly recommended as an alternative to plain passwords in a parameter file
    or the passwords provided on the command line.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理简单的控制台应用程序时，有一些额外的库可能很有帮助。有一个`getpass`模块，它通过抑制控制台输入的默认字符回显来帮助获取密码。这作为参数文件中的明文密码或命令行上提供的密码的替代方案是非常推荐的。
- en: We can include the `readline` module to provide a comprehensive history of input
    that makes it easier for interactive users to recover previous inputs. Additionally,
    the `rlcompleter` module can be used to provide auto-complete features so that
    users only need to enter partial commands.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以包含`readline`模块，以提供全面的输入历史记录，这使得交互式用户更容易恢复以前的输入。此外，`rlcompleter`模块可以用来提供自动完成功能，这样用户只需输入部分命令。
- en: Beyond this, Python can include an implementation of the Linux `curses` library
    for building richly interactive **character user interface** (**CUI**) applications.
    This is sometimes used to provide colored output on the console, something that
    can make a complex log easier to read.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python可以包含Linux `curses`库的实现，用于构建丰富的**字符用户界面**（**CUI**）应用程序。这有时用于在控制台上提供彩色输出，这可以使复杂的日志更容易阅读。
- en: Python is used in a wide variety of application contexts. When building a web
    server, for example, the idea of console or command-line input is utterly out
    of place. Similarly, the `input()` function isn't going to be part of a GUI application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Python被用于各种应用程序环境中。例如，在构建Web服务器时，控制台或命令行输入的想法是完全不合适的。同样，`input()`函数也不会是GUI应用程序的一部分。
- en: Python language concepts
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python语言概念
- en: We'll introduce a few central concepts of the Python language before looking
    at more complex examples in later chapters. The first of the central concepts
    is that everything in Python is an object. Several popular languages have **primitive**
    types which escape the object-oriented nature of the language. Python doesn't
    have this feature. Even simple integers are objects, with defined methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看后续章节中的更复杂示例之前，我们将介绍Python语言的一些核心概念。这些核心概念中的第一个是Python中的一切都是对象。几种流行的语言有**原始**类型，这些类型逃避了语言面向对象的本性。Python没有这个特性。即使是简单的整数也是对象，具有定义良好的方法。
- en: Because everything is an object, we're assured of consistent behavior with no
    special cases. In some languages, the `==` operator works in one way for primitive
    types and in another way for objects. Python lacks this divergent behavior. All
    built-in classes implement the `==` operator consistently; unless we make specific
    (and pathological) implementation choices, our own classes will also behave consistently.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切都是对象，我们确保了没有特殊情况的一致行为。在某些语言中，`==`运算符对原始类型和对象的工作方式不同。Python缺乏这种分歧行为。所有内置类都一致地实现了`==`运算符；除非我们做出特定的（并且病态的）实现选择，我们的类也将保持一致的行为。
- en: This consistency is particularly pleasant when working with strings. In Python,
    we always compare strings for equality using something like `txt.lower() = "hours"`.
    This will make the expected character-by-character comparison between the value
    of `txt.lower()` and the literal `"hours"`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当与字符串一起工作时，这种一致性尤其令人愉快。在Python中，我们总是使用类似`txt.lower() = "hours"`的方式来比较字符串的相等性。这将使得`txt.lower()`的值与字面量`"hours"`之间的预期逐字符比较。
- en: Less commonly, we can see if two variables are references to the same underlying
    object using the `is` comparison operator. This is generally used to compare a
    variable with the `None` object. We use `is None` because the `None` object is
    a proper singleton; there can be only one instance of `None`. We'll look at this
    again in [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"),
    *Logic, Comparisons, and Conditions*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不太常见的是，我们可以使用`is`比较运算符来检查两个变量是否引用了同一个底层对象。这通常用于将变量与`None`对象进行比较。我们使用`is None`是因为`None`对象是一个正确的单例；只能有一个`None`实例。我们将在[第5章](ch05.html
    "第5章。逻辑、比较和条件")中再次探讨这一点，*逻辑、比较和条件*。
- en: Object types versus variable declarations
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象类型与变量声明
- en: In Python, we specify the processing generically with respect to type. We may
    write a sequence of statements with the implicit understanding that floating-point
    values should be used. We can formalize this to an extent using an explicit `float()`
    conversion function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们根据类型对处理进行通用指定。我们可以编写一系列语句，隐含地理解应该使用浮点值。我们可以通过显式的`float()`转换函数将此形式化到一定程度。
- en: In some languages, each variable has a statically defined type. Only objects
    of the named type can be assigned to the variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，每个变量都有一个静态定义的类型。只有具有指定类型的对象才能分配给该变量。
- en: In contrast to languages with statically defined variables, a Python variable
    can be understood as a name which is attached to an object. We can attach a name
    to any object of any class. We don't statically declare a narrow range of allowed
    types for a variable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态定义变量的语言相比，Python 变量可以理解为附加到对象上的名称。我们可以将名称附加到任何类的任何对象上。我们不会为变量静态声明一个狭窄的允许类型范围。
- en: 'Python allows us to assign multiple names to the same object by assigning the
    object to several variables. For example, when we evaluate a function, the function
    parameter variable names are assigned to the argument objects. (We''ll look at
    this in more depth in [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"),
    *Basic Function Definitions*.) This means that each object may have two variables
    referring to it: one parameter variable inside the function and another variable
    outside the function.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许我们通过将对象分配给多个变量来为同一个对象分配多个名称。例如，当我们评估一个函数时，函数参数变量名会被分配给参数对象。（我们将在[第7章](ch07.html
    "第7章。基本函数定义")中更深入地探讨这一点，*基本函数定义*。）这意味着每个对象可能有两个变量指向它：一个在函数内部的参数变量，另一个在函数外部的变量。
- en: 'We can use the internal `id()` function to see if two variables refer to the
    same underlying object:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内部的 `id()` 函数来查看两个变量是否指向相同的底层对象：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From this, we can see that Python variables `a` and `b` have references to the
    underlying object, not copies of the object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以看出 Python 变量 `a` 和 `b` 指向的是底层对象，而不是对象的副本。
- en: In the rare cases that object copying is necessary, we must do it explicitly.
    Details vary, based on the general kind of class. For example, sequences are trivially
    cloned by creating a slice that includes the entire sequence. Some classes offer
    a `copy()` method. Objects can also be cloned via functions in the `copy` library.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象复制必要时，我们必须显式地进行。具体细节根据类的通用类型而异。例如，序列可以通过创建包含整个序列的切片来简单地克隆。一些类提供了 `copy()`
    方法。对象也可以通过 `copy` 库中的函数进行克隆。
- en: 'The lack of a fixed type declaration for a variable has several consequences:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 变量缺乏固定的类型声明有几种后果：
- en: 'It''s trivial to introduce a variable to decompose a complex expression. Here''s
    a complex expression:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入变量以分解复杂表达式是微不足道的。这里有一个复杂的表达式：
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can trivially rewrite this by pulling out subexpressions and assigning them
    to variables:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过提取子表达式并将它们分配给变量来简单地重写这一点：
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've extracted each subexpression and assigned them to separate variables.
    We never need to know what the intermediate result types are.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经提取了每个子表达式并将它们分配给单独的变量。我们永远不需要知道中间结果类型是什么。
- en: All algorithms are written generically. When we run a script, we apply our generic
    Python code to concrete objects. Our canonical example of this binding is based
    on the numeric tower. We can apply the same expression, `32+9*c/5`, to objects
    of the classes `complex`, `float`, `int`, `Decimal`, and `Fraction`. All of these
    classes provide the necessary implementations of the various operators. However,
    a string object won't implement all of the arithmetic operations required, and
    won't work. Similarly, we can execute statements like `head, *tail = sequence`
    for a wide variety of sequence-like classes, including `list`, `str`, `bytes`,
    and `tuple`. However, if we assign a numeric value to the variable named `sequence`,
    the statement won't work.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有算法都是通用的。当我们运行脚本时，我们将通用的 Python 代码应用于具体对象。我们这个绑定的典范例子基于数字塔。我们可以将相同的表达式 `32+9*c/5`
    应用到 `complex`、`float`、`int`、`Decimal` 和 `Fraction` 等类的对象上。所有这些类都提供了必要的运算符实现。然而，字符串对象不会实现所有所需的算术运算，并且无法工作。同样，我们可以对包括
    `list`、`str`、`bytes` 和 `tuple` 在内的广泛序列类执行类似 `head, *tail = sequence` 的语句。然而，如果我们将一个数值赋给名为
    `sequence` 的变量，该语句将无法工作。
- en: Avoiding the declaration of variables with static types is a great simplification.
    We can introduce variables as needed. We can write clear, simple, generic software
    and leave it to the Python runtime processing to determine if the runtime objects
    have the required implementations for operators and methods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 避免声明具有静态类型的变量是一种极大的简化。我们可以按需引入变量。我们可以编写清晰、简单的通用软件，并将其留给 Python 运行时处理来确定运行时对象是否具有运算符和方法所需的实现。
- en: Avoiding confusion when naming variables
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免在命名变量时产生混淆
- en: Without variable declarations, there's a small possibility of creating programs
    which are confusing if we use vague, generic variables. A variable with a vague
    name like `list_of_items` might get used more than once in a longish sequence
    of statements. Worse, of course, are variables with names like `t` or `temp`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 没有变量声明，如果我们使用模糊、通用的变量，可能会创建出令人困惑的程序。一个像`list_of_items`这样的模糊名称的变量可能在较长的语句序列中被多次使用。当然，更糟糕的是像`t`或`temp`这样的变量名称。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Name variables as specifically as possible. Avoid vague, generic names.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能具体地命名变量。避免模糊、通用的名称。
- en: The other aspect of overusing variable names is the idea of a "longish" sequence
    of statements. If the body of a function is so long that generically-named variables
    could get reused accidentally, the size of the function has become a problem.
    No stretch of Python code should be so long that the variables used within it
    are confusing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名过度使用的一个方面是“较长的”语句序列的概念。如果一个函数的主体如此之长，以至于通用命名的变量可能会意外地被重复使用，那么函数的大小就变成了一个问题。没有任何一段Python代码应该如此之长，以至于其中的变量会让人困惑。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep sequences of code short and focused. Avoid long sequences of code where
    variables might get reused incorrectly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 保持代码序列简短且专注。避免可能错误地重复使用变量的长代码序列。
- en: It's import to name variables simply and clearly. In Python, the use of *Hungarian
    notation* to decorate a variable name with type information is considered deplorable.
    The original concept of Hungarian notation was to place a few characters as a
    prefix on a variable to indicate the type. In Python, we do not name a variable
    `lst_str_names` using a prefix to indicate that the variable refers to a list
    of string values.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的命名要简单明了。在Python中，使用*匈牙利命名法*来装饰变量名以添加类型信息被认为是可鄙的。匈牙利命名法的原始概念是在变量名前放置几个字符作为前缀，以指示类型。在Python中，我们不使用前缀来命名变量`lst_str_names`，以表明该变量指的是字符串值的列表。
- en: 'Because Python code is written generically, a well-written function can apply
    to many different data types. If we try to encode data type information in variable
    names, we may actually be sowing confusion: the algorithm may work for types not
    explicitly stated in the variable name.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python代码是通用编写的，一个编写良好的函数可以应用于许多不同的数据类型。如果我们试图在变量名中编码数据类型信息，我们实际上可能是在制造混乱：算法可能适用于变量名中未明确声明的类型。
- en: In some situations, we need to distinguish between a collection of items and
    an individual item. We might have a `name_list` and an individual `name`. Or we
    might have a `name_iter`, when working with generator functions, and an individual
    `name`. A small, clear naming convention like this is better than elaborately
    misleading Hungarian notation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要区分一组项目和单个项目。我们可能有一个`name_list`和一个单独的`name`。或者，当我们使用生成器函数时，我们可能有一个`name_iter`和一个单独的`name`。这样的小型、清晰的命名约定比详尽的误导性匈牙利命名法要好。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid complex Hungarian notation in variable names.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在变量名中使用复杂的匈牙利命名法。
- en: In a more complex program, we might have a dictionary that maps integer keys
    to sets associated with those keys; each set may have a collection of individual
    strings. It's difficult to summarize this with a Hungarian prefix or suffix. Would
    we want to try and call this `map_int_set_str_something`?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的程序中，我们可能有一个将整数键映射到与这些键关联的集合的字典；每个集合可能包含一系列单独的字符串。用匈牙利前缀或后缀来总结这一点是困难的。我们是否想要尝试将其称为`map_int_set_str_something`？
- en: Looking ahead to [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"),
    *Basic Function Definitions* and [Chapter 11](ch11.html "Chapter 11. Class Definitions"),
    *Class Definitions*, we'll often use `docstring` comments in functions, classes,
    and modules to capture the details of what kind of structure is appropriate for
    a function. We may even include test cases in the `docstring` comments; test cases
    are perhaps the clearest and most precise way to describe data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 展望到[第7章](ch07.html "第7章。基本函数定义")，*基本函数定义*和[第11章](ch11.html "第11章。类定义")，*类定义*，我们经常在函数、类和模块中使用`docstring`注释来捕获适合函数的结构细节。我们甚至可以在`docstring`注释中包含测试用例；测试用例可能是描述数据的最清晰和最精确的方式。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Write `docstring` comments in every context that allows them: function, class,
    module, and package.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在允许的每个上下文中编写`docstring`注释：函数、类、模块和包。
- en: One consequence of Python's use of variables is that we rely on unit test cases
    to ensure that results are of the expected types as well as being correct. Programmers
    who work in languages with statically-typed variables are very aware that unit
    test cases are essential for correctness, even when a compiler does type checking
    of all variable declarations. In Python, the test cases are just as important
    as in languages that have static type checking. If it is necessary to clarify
    the intent of a function or class, we can include type checking in the test cases.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用变量的一个后果是我们依赖于单元测试用例来确保结果既符合预期的类型，又正确无误。在静态类型变量语言中工作的程序员非常清楚，单元测试用例对于正确性至关重要，即使编译器对所有变量声明进行类型检查。在Python中，测试用例与具有静态类型检查的语言中的测试用例一样重要。如果需要明确函数或类的意图，我们可以在测试用例中包含类型检查。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Write unit tests; use the `unittest` module, the `doctest` module, or both.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试；使用`unittest`模块、`doctest`模块或两者都使用。
- en: Garbage collection via reference counting
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过引用计数进行垃圾回收
- en: We've seen how expressions create new objects. Even something as simple as `2**2024`
    creates a new integer object. What happens to these objects? When will we run
    out of memory?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到表达式如何创建新的对象。即使是像`2**2024`这样简单的东西也会创建一个新的整数对象。这些对象会发生什么？什么时候我们会耗尽内存？
- en: 'Python uses reference counting to determine how many times an object is being
    used when we do something like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行类似这样的操作时，Python使用引用计数来确定对象被使用的次数：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The resulting object is a very large integer; it is assigned to the variable
    `_` automatically. The object, shown as `192624...497216`, has a single reference;
    this keeps it alive in memory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结果对象是一个非常大的整数；它被自动赋值给变量`_`。显示为`192624...497216`的对象只有一个引用；这使它在内存中保持活跃。
- en: 'When we do this, next:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，接下来：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We get a new object, and it is assigned to the variable `_`. The large integer
    value formerly assigned to `_` has no more references. Since it's no longer being
    used, it's garbage, and the memory it occupied can be reused.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个新的对象，并将其赋值给变量`_`。之前赋值给`_`的大整数值不再有任何引用。由于它不再被使用，它是垃圾，它占用的内存可以被重用。
- en: Each time we assign an object to a variable, the reference count goes up by
    one. Each time the variable's value is reassigned, the previous object that is
    no longer in use has its reference count decreased by one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们将对象赋值给变量时，引用计数增加一个。每次变量的值被重新赋值时，不再使用的先前对象的引用计数减少一个。
- en: When a variable is no longer required, the variable is removed, and the objects
    referred to by the variable also have their reference counts reduced by one.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量不再需要时，该变量将被移除，并且该变量所引用的对象的引用计数也会减少一个。
- en: 'Variables belong to namespaces. Most of our early examples used the global
    namespace. In [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"),
    *Basic Function Definitions*, we''ll see local namespaces. To summarize: when
    a namespace is removed, all of the variables in that namespace are removed, and
    all of the object references are decremented by one.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 变量属于命名空间。我们的大部分早期示例使用了全局命名空间。在[第7章](ch07.html "第7章。基本函数定义")，*基本函数定义*中，我们将看到局部命名空间。总结一下：当删除命名空间时，该命名空间中的所有变量都将被删除，并且所有对象引用的计数都减少一个。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When the number of references to an object reaches zero, the object is no longer
    needed. The memory occupied by that object can be reclaimed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的引用数达到零时，该对象不再需要。该对象占用的内存可以被回收。
- en: We can easily create two complex objects which refer to each other. In the presence
    of these kinds of circular references, of course, the counts can never reach zero.
    The objects may never get removed from memory. We can use the `gc` module to discover
    more about this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地创建两个相互引用的复杂对象。在这些类型的循环引用存在的情况下，当然，计数永远不会达到零。对象可能永远不会从内存中移除。我们可以使用`gc`模块来了解更多信息。
- en: In the case where we must have objects with mutual references, we need to leverage
    the `weakref` module. This module provides references among objects that do not
    interfere with reference counting, allowing a large data structure of multiple
    objects to gracefully vanish from memory when no longer in use.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们必须有相互引用的对象的情况下，我们需要利用`weakref`模块。此模块提供对象之间的引用，这些引用不会干扰引用计数，允许当不再使用时，多个对象的大型数据结构优雅地从内存中消失。
- en: The little-used del statement
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 很少使用的`del`语句
- en: 'We can remove variables manually with the `del` statement. Here''s an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`del`语句手动删除变量。以下是一个示例：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've created an integer object, and assigned it to the variable `a`. When we
    remove the variable, this will reduce the reference count on the integer object.
    The memory occupied by the big integer is now eligible to be reclaimed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个整数对象，并将其赋值给变量 `a`。当我们移除这个变量时，这将减少整数对象的引用计数。现在，这个大整数所占用的内存可以被视为可回收。
- en: This kind of thing is done very rarely. Python's ordinary reference counting
    does almost everything we need. It's generally best not to waste brain calories
    tying to micro-manage memory allocation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种事情很少做。Python 的普通引用计数几乎可以做我们需要的所有事情。通常最好不要浪费脑力试图微观管理内存分配。
- en: The Python namespace concept
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 命名空间概念
- en: We've already seen two applications of the Python namespace. When we assign
    variables at the `>>>` prompt, we're introducing the variable into the global
    namespace. When we import a module, the module creates its own namespace within
    the global namespace.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Python 命名空间的两个应用。当我们使用 `>>>` 提示符赋值变量时，我们是在将变量引入全局命名空间。当我们导入一个模块时，该模块在全局命名空间内创建自己的命名空间。
- en: That's why we can then use qualified names like `math.sqrt()` to refer to objects
    inside the module's namespace.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们才能使用像 `math.sqrt()` 这样的合格名称来引用模块命名空间内的对象。
- en: When we look at functions and class definitions, we'll see additional use, of
    namespaces. In particular, when evaluating a function or a class method, a local
    namespace is created, and all variables are part of that local namespace. When
    the function evaluation finishes (because of an explicit `return` statement or
    the end of the indented block,) the local namespace is dropped, removing all local
    variables and reducing the reference count on all objects assigned to those local
    variables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看函数和类定义时，我们会看到命名空间有额外的用途。特别是，当评估一个函数或类方法时，会创建一个局部命名空间，所有变量都是该局部命名空间的一部分。当函数评估完成（由于显式的
    `return` 语句或缩进块的末尾）时，局部命名空间会被丢弃，移除所有局部变量，并减少分配给这些局部变量的所有对象的引用计数。
- en: 'Additionally, the `types` module includes the `SimpleNamespace` class. An instance
    of this class allows us to build a complex object without a formal class definition.
    Here''s an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`types` 模块还包括 `SimpleNamespace` 类。这个类的实例允许我们在不进行正式类定义的情况下构建复杂对象。以下是一个例子：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've imported the `SimpleNamespace` class. We created an instance of that class,
    assigning three local variables, `red`, `green`, and `blue`, that are part of
    the new `SimpleNamespace` object. When we examine the object as a whole, we see
    that it has three internal variables.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了 `SimpleNamespace` 类。我们创建了该类的实例，并分配了三个局部变量，`red`、`green` 和 `blue`，它们都是新
    `SimpleNamespace` 对象的一部分。当我们整体检查这个对象时，我们会看到它有三个内部变量。
- en: We can use syntax like `red_violet.blue` to see the `blue` variable inside the
    `red_violet` namespace.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用像 `red_violet.blue` 这样的语法来查看 `red_violet` 命名空间内的 `blue` 变量。
- en: The `argparse` module is used by command-line programs to parse the command-line
    arguments. This module also contains a `Namespace` class definition. An instance
    of `Namespace` is used to collect the various arguments parsed from the command
    line. An application can set additional variables in the `Namespace` object to
    handle particularly complex parsing and configuration issues.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse` 模块被命令行程序用于解析命令行参数。此模块还包含一个 `Namespace` 类定义。`Namespace` 的一个实例用于收集从命令行解析的各种参数。应用程序可以在
    `Namespace` 对象中设置额外的变量来处理特别复杂的解析和配置问题。'
- en: Globals and locals
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量和局部变量
- en: When we use a variable name in an expression, Python searches two namespaces
    to resolve the name and locate the object to which it refers. First, it checks
    the local namespace. If the name is not found, it will check the global namespace.
    This two-step search will ensure that local variables used inside a function or
    class method are used before global variables with the same name.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在表达式中使用一个变量名时，Python 会搜索两个命名空间来解析名称并定位它所引用的对象。首先，它会检查局部命名空间。如果找不到该名称，它将检查全局命名空间。这个两步搜索将确保在函数或类方法内部使用的局部变量在使用具有相同名称的全局变量之前被使用。
- en: When working from the `>>>` prompt using the REPL, we can only create and use
    global variables. Further examples will have to wait until [Chapter 7](ch07.html
    "Chapter 7. Basic Function Definitions"), *Basic Function Definitions*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 REPL 的 `>>>` 提示符工作时，我们只能创建和使用全局变量。更多示例将不得不等到 [第 7 章](ch07.html "第 7 章。基本函数定义")，*基本函数定义*。
- en: When we use the `locals()` and `globals()` functions at the `>>>` prompt, we
    can see that they have the same results. At the `>>>` prompt, and at the top-level
    of a script file, the local namespace is the global namespace. When evaluating
    a function, however, the function works in a separate, local namespace.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `>>>` 提示符下使用 `locals()` 和 `globals()` 函数时，我们可以看到它们具有相同的结果。在 `>>>` 提示符下，以及在脚本文件的最高级别，局部命名空间是全局命名空间。然而，在评估函数时，函数是在一个独立的、局部命名空间中工作的。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've looked at how we assign objects to variables. We've looked at the simple
    assignment statement, as well as multiple assignment and augmented assignment.
    With augmented assignment, we can update a variable by applying an operator and
    an operand. This is a handy syntactic shortcut.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何将对象赋值给变量。我们探讨了简单的赋值语句，以及多重赋值和增强赋值。使用增强赋值，我们可以通过应用运算符和操作数来更新变量。这是一个方便的语法快捷方式。
- en: We've also addressed the `input()` function, which is a way to create new objects
    based on user input. It's very handy for simple command-line scripts. More sophisticated
    GUIs, of course, will have considerably more sophisticated input mechanisms.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了 `input()` 函数，这是一种基于用户输入创建新对象的方法。对于简单的命令行脚本来说，它非常方便。当然，更复杂的 GUI 将会有更复杂的输入机制。
- en: The concept of a namespace, and how variables are tracked via a namespace, is
    central to Python. When a namespace is no longer needed, it's discarded, removing
    all of the variables. This will also reduce the reference count on all of the
    objects referred to by the variables. Once an object's reference count is reduced
    to zero, the object can be removed from memory. This is a tidy and simple way
    to handle variables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的概念以及变量如何通过命名空间进行跟踪，这是 Python 的核心。当一个命名空间不再需要时，它会被丢弃，移除所有变量。这也会减少所有由变量引用的对象的引用计数。一旦一个对象的引用计数减少到零，该对象就可以从内存中移除。这是一种整洁且简单的方式来处理变量。
- en: 'In [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"),
    *Logic, Comparisons, and Conditions*, we''ll look at another fundamental data
    type: Boolean. We''ll look at Python''s approach to Boolean values and the logical
    operators of `and`, `or`, `not`, and `if-else`. We''ll also look at the various
    comparison operators.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。逻辑、比较和条件")中，我们将探讨另一个基本的数据类型：布尔值。我们将探讨 Python 对布尔值的处理方法以及逻辑运算符
    `and`、`or`、`not` 和 `if-else`。我们还将探讨各种比较运算符。
- en: We'll look at several kinds of Python statements, include the `if-elif-else`
    statement, the `pass` statement, and the `assert` statement. This will allow us
    to write somewhat more sophisticated scripts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨几种 Python 语句，包括 `if-elif-else` 语句、`pass` 语句和 `assert` 语句。这将使我们能够编写更复杂的脚本。
