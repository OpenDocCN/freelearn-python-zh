- en: Making the Move – Design, Plan, and Execute
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移 - 设计、规划和执行
- en: As web services get more and more complex, and software service companies grow
    in size, we require new ways of working to adapt and increase the speed of change,
    while setting a high quality standard. Microservices architecture has emerged
    as one of the best tools to control big software systems, enabled by new tools
    such as containers and orchestrators. We will start by presenting the differences
    between the traditional monolith architecture and the microservices architecture,
    as well as the advantages of moving to the latter. We will cover how to structure
    an architecture migration and how to plan to succeed in this difficult process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web服务变得越来越复杂，软件服务公司的规模也在增长，我们需要新的工作方式来适应并提高变化的速度，同时确保高质量标准。微服务架构已经成为控制大型软件系统的最佳工具之一，得益于容器和编排器等新工具的支持。我们将首先介绍传统单体架构和微服务架构之间的区别，以及迁移到后者的优势。我们将介绍如何构建架构迁移以及如何计划成功完成这一困难的过程。
- en: In this book, we will deal with web server services, though some of the ideas
    can be used for other kinds of software applications, obviously by adapting them.
    The monolith/microservice architectures have some similarities with the monolithic/microkernel
    discussions in operating system design, including the famous debate ([https://www.oreilly.com/openbook/opensources/book/appa.html](https://www.oreilly.com/openbook/opensources/book/appa.html)) between
    Linus Torvalds and Andrew S. Tanenbaum, back in 1992\. This chapter is relatively
    agnostic about tools, while the following chapters will present specific ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将处理Web服务器服务，尽管一些想法也可以用于其他类型的软件应用程序，显然需要进行调整。单体/微服务架构与操作系统设计中的单体/微内核讨论有一些相似之处，包括1992年Linus
    Torvalds和Andrew S. Tanenbaum之间的著名辩论（[https://www.oreilly.com/openbook/opensources/book/appa.html](https://www.oreilly.com/openbook/opensources/book/appa.html)）。本章对工具相对中立，而接下来的章节将介绍具体的工具。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The traditional monolith approach and its problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的单体方法及其问题
- en: The characteristics of a microservices approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务方法的特点
- en: Parallel deployment and development speed
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行部署和开发速度
- en: Challenges and red flags
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战和警示信号
- en: Analyzing the current system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析当前系统
- en: Preparing and adapting by measuring usage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测量使用情况进行准备和调整
- en: Strategic planning to break the monolith
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解单体的战略规划
- en: Executing the move
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行迁移
- en: At the end of the chapter, you'll be familiar with the basic concepts we will
    be using throughout the book, different strategies for how to proceed with and
    structure work during the migration to microservices, and a practical example
    that we will be working on in the remaining chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，您将熟悉我们将在整本书中使用的基本概念，不同的策略，以及在迁移到微服务期间如何进行和构建工作的实际示例。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not focus on specific technologies, going for a more agnostic
    approach. We will discuss a Python Django application for our monolith example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不专注于特定技术，而采用更中立的方法。我们将讨论一个Python Django应用程序作为我们单体示例。
- en: 'The monolith example can be found at: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith).
    Installation and running instructions can be found in its `README.md` file.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单体示例可以在以下位置找到：[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith)。安装和运行说明可以在其`README.md`文件中找到。
- en: The traditional monolith approach and its problems
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的单体方法及其问题
- en: 'The traditional approach to the software when developing a system has been
    to create a monolith. This is a fancy word to say *a single element, containing
    everything*, and it is the way virtually every project starts. In the context
    of web applications, that means creating deployable code that can be replicated
    so that requests can be directed to any of the deployed copies:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发系统时，传统的软件方法是创建一个单体。这是一个花哨的词，意思是“包含一切的单一元素”，这几乎是每个项目开始的方式。在Web应用程序的上下文中，这意味着创建可部署的代码，可以复制，以便请求可以指向任何已部署的副本：
- en: '![](img/a6a73149-82f7-4880-9121-7b110bda40ad.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6a73149-82f7-4880-9121-7b110bda40ad.png)'
- en: After all, every project will start off small. Making strict divisions early
    on is inconvenient and even doesn't make sense. A newly created project is small
    and probably handled by a single developer. While the design can fit in the head
    of a few people, making strict boundaries between parts of the system is counterproductive.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，每个项目都会从小处开始。在早期进行严格的划分是不方便的，甚至没有意义。新创建的项目很小，可能由单个开发人员处理。虽然设计可以适合几个人的头脑，但在系统的各个部分之间进行严格的界限是适得其反的。
- en: There are a lot of options for running a web service, but one will typically
    consist of one or more servers (physical boxes, virtual machines, and cloud instances
    such as EC2 and more)  running a  web server application (such as NGINX or Apache)
    to direct requests directed to HTTP port `80` or HTTPS port `443` toward one or
    more Python workers (normally, through the WSGI protocol), run by `mod_wsgi`—[https://github.com/GrahamDumpleton/mod_wsgi](https://github.com/GrahamDumpleton/mod_wsgi) (Apache
    only), uWSGI, GNUnicorn, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多运行Web服务的选项，但通常会包括一个或多个服务器（物理服务器、虚拟机和云实例，如EC2等），运行Web服务器应用程序（如NGINX或Apache）来将请求指向HTTP端口`80`或HTTPS端口`443`，指向一个或多个Python工作进程（通常通过WSGI协议），由`mod_wsgi`运行
    - [https://github.com/GrahamDumpleton/mod_wsgi](https://github.com/GrahamDumpleton/mod_wsgi)（仅限Apache）、uWSGI、GNUnicorn等。
- en: If more than one server is used, there will be a load balancer to spread the
    load among them. We'll talk about them later in this chapter. The server (or load
    balancer) needs to be accessible on the internet, so it will have a dedicated
    DNS and a public IP address.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用多台服务器，将会有一个负载均衡器来在它们之间分配负载。我们将在本章后面讨论它们。服务器（或负载均衡器）需要在互联网上可访问，因此它将拥有专用的DNS和公共IP地址。
- en: 'In other programming languages, the structure will be similar: a frontend web
    server that exposes the port in HTTP/HTTPS, and a backend that runs the monolith
    code in a dedicated web worker.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言中，结构将是类似的：一个前端web服务器公开端口以进行HTTP/HTTPS通信，以及在专用web工作人员中运行单体代码的后端。
- en: But things change, successful software grows and, after some time, having a
    big ball of code is maybe not the best way of structuring a big project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但事情会改变，成功的软件会增长，经过一段时间，拥有一大堆代码可能不是构建大型项目的最佳方式。
- en: Monoliths can have, in any case, internal structure, meaning they don't necessarily
    get into the realms of spaghetti code. It may be perfectly structured code. What
    defines a monolith is the requirement to deploy the system as a whole, without
    being able to make partial deployments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用在任何情况下都可以有内部结构，这意味着它们不一定会变成意大利面代码。它可能是完全结构化的代码。定义单体应用的是需要将系统作为一个整体部署，而不能进行部分部署。
- en: Spaghetti code is a common way of referring to code that lacks any structure
    and is difficult to read and follow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码是指缺乏任何结构且难以阅读和理解的代码的常见方式。
- en: 'As the monolith grows, some of its limitations will start to show up:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着单体应用的增长，一些限制将开始显现：
- en: '**The code will increase in size**: Without strict boundaries between modules,
    developers will start having problems understanding the whole code base. While
    good practices can help, the complexity naturally tends to increase, making it
    more difficult to change the code in certain ways and increasing subtle bugs.
    Running all tests will become slow, decreasing the speed of any Continuous Integration
    system.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码将增加**：没有模块之间的严格边界，开发人员将开始遇到理解整个代码库的问题。尽管良好的实践可以帮助，但复杂性自然倾向于增加，使得在某些方面更改代码变得更加困难，并增加微妙的bug。运行所有测试将变得缓慢，降低任何持续集成系统的速度。'
- en: '**Inefficient utilization of resources**: Each individual deployed web worker
    will require all the resources required for the whole system to work, for example,
    the maximum amount of memory for any kind of request, even if a request that demands
    a lot of memory is rare and just a couple of workers will be sufficient. The same
    may happen with the CPU. If the monolith connects to a database, each individual
    worker will require a connection to it, whether that''s used regularly or not,
    and so on.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源利用效率低下**：每个部署的web工作人员都需要整个系统工作所需的所有资源，例如，任何类型的请求所需的最大内存，即使需要大量内存的请求很少，只需要几个工作人员就足够了。CPU也可能出现相同的情况。如果单体应用连接到数据库，每个工作人员都需要连接到它，无论是否经常使用等等。'
- en: '**Issues with development scalability**: Even if the system is perfectly designed
    to be horizontally scalable (unlimited new workers can be added), as the system
    grows and the development team grows, development will be more and more difficult
    without stepping on each other''s toes. A small team can coordinate easily, but
    once several teams are working on the same code base, the probability of clashing
    will increase. Imposing boundaries for teams in terms of ownership and responsibility
    can also become blurry unless strict discipline is enforced. In any case, teams
    will need to be actively coordinated, which reduces their independence and speed.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发可扩展性问题**：即使系统被设计成可以水平扩展（可以添加无限数量的新工作人员），随着系统和开发团队的增长，开发将变得越来越困难，而不会相互干扰。一个小团队可以轻松协调，但一旦有几个团队在同一个代码库上工作，冲突的可能性就会增加。除非严格执行纪律，否则对团队的所有权和责任进行界定也可能变得模糊。无论如何，团队都需要积极协调，这会降低他们的独立性和速度。'
- en: '**Deployment limitations**: The deployment approach will need to be shared
    across teams, and teams can''t be individually responsible for each deployment,
    as deployment will probably involve work for multiple teams. A deployment problem
    will bring down the whole system.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署限制**：部署方法需要在团队之间共享，并且团队不能分别对每个部署负责，因为部署可能涉及多个团队的工作。部署问题将导致整个系统崩溃。'
- en: '**Interdependency of technologies**: Any new tech needs to fit with the tech
    in use in the monolith. A new technology, for example, a tool that''s perfect
    for a particular problem, may be complicated to add to the monolith, due to a
    mismatch of technologies. Updating dependencies can also cause issues. For example,
    an update to a new version of Python (or a submodule) needs to operate with the
    whole code base. Some required maintenance tasks, such as a security patch, can
    cause a problem just because the monolith already uses a specific version of a
    library, which will break if changed. Adapting to these changes requires extra
    work too.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术的相互依赖**：任何新技术都需要与单体应用中使用的技术相匹配。例如，一个对特定问题非常适合的工具可能很难添加到单体应用中，因为技术不匹配。更新依赖项也可能会导致问题。例如，更新到Python的新版本（或子模块）需要与整个代码库一起运行。一些必要的维护任务，如安全补丁，可能会导致问题，因为单体应用已经使用了特定版本的库，如果更改将会破坏。适应这些变化也需要额外的工作。'
- en: '**A bug in a small part of the system can bring down the whole service**: As
    the service is a whole, any critical issue that affects the stability affects
    everything, making it difficult to generate quality service strategies or causing
    degraded results.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统的一小部分出现bug可能导致整个服务崩溃**：由于服务是一个整体，任何影响稳定性的关键问题都会影响到一切，使得难以制定高质量的服务策略或导致结果下降。'
- en: As you can see in the examples, most of the monolith issues are growing issues.
    They are not really important unless the system has a sizeable code base. There
    are some things that work very well in monoliths, such as the fact that, because
    there are no boundaries in the code, the code can be changed very quickly and
    efficiently. But as teams grow and more and more developers are working in the
    system, boundaries help to define objectives and responsibilities. Too much flexibility
    becomes a problem in the long term.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在示例中所看到的，大多数单体问题都是逐渐增长的问题。除非系统有相当大的代码库，否则它们并不真正重要。在单体系统中有一些非常有效的东西，比如，由于代码中没有边界，代码可以被迅速高效地改变。但随着团队的壮大，越来越多的开发人员在系统中工作，边界有助于定义目标和责任。过度的灵活性在长期内会成为问题。
- en: The characteristics of a microservices approach
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务方法的特点
- en: The monolith approach works until the point it doesn't. But, what is the alternative?
    That's where the microservices architecture enters into the scene.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单体方法适用，直到它不适用为止。但是，替代方案是什么？这就是微服务架构进入场景的地方。
- en: 'A system following a microservices architecture *is a collection of loosely
    coupled specialized services that work in unison to provide a comprehensive service*.
    Let''s divide the definition a bit, in more specific terms:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循微服务架构的系统*是一组松散耦合的专门化服务，它们协同工作以提供全面的服务*。让我们稍微分解一下这个定义，更具体地说：
- en: A **collection of specialized services**, meaning that there are different,
    well-defined modules.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一组专门的服务**，意味着有不同的、明确定义的模块。'
- en: '**Loosely coupled**, meaning that each of the microservices can be independently
    deployed.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**松散耦合**，意味着每个微服务都可以独立部署。'
- en: That **work in unison**—each microservice is capable of communicating with others.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们**协同工作**——每个微服务都能够与其他微服务通信。
- en: To provide a **comprehensive service**, because our microservice system will
    need to replicate the same functionalities that were available using a monolith
    approach. There is an intent behind its design.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供**全面的服务**，因为我们的微服务系统将需要复制使用单体方法可用的相同功能。这是其设计背后的意图。
- en: 'In contrast to the previous diagram, the microservice architecture will look
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的图表相比，微服务架构将如下所示：
- en: '![](img/037b0910-8b4b-48af-b863-4c1ece183ba4.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/037b0910-8b4b-48af-b863-4c1ece183ba4.png)'
- en: Each of the external requests will be channeled to either **Microservice A**
    or **Microservice B**, each one specializing in a particular kind of requests.
    In certain cases, **Microservice B** communicates with **Microservice C**, not
    directly available externally. Note that there may be multiple workers per microservice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个外部请求将被引导到**微服务 A**或**微服务 B**，每个微服务专门处理一种特定类型的请求。在某些情况下，**微服务 B**与**微服务 C**通信，而不是直接对外可用。请注意，每个微服务可能有多个工作人员。
- en: 'There are several advantages and implications to this architecture:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构有几个优势和含义：
- en: If the communication between microservices is done through a standard protocol,
    each microservice can be programmed in different languages.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果微服务之间的通信是通过标准协议进行的，那么每个微服务可以用不同的语言编程。
- en: Throughout the book, we will use HTTP requests with data encoded in JSON to
    communicate between microservices. Though there are more options, this is definitively
    the most standard and widely-used option, as virtually every widely-used programming
    language has good support for it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用 HTTP 请求，并使用 JSON 编码的数据在微服务之间进行通信。虽然还有更多的选择，但这绝对是最标准和广泛使用的选项，因为几乎每种广泛使用的编程语言都对其有很好的支持。
- en: This is very useful in cases where a specialized language is ideal for a specialized
    problem, but limiting its use so that it is contained, not requiring a drastic
    change in the company.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某些情况下非常有用，比如专门的问题需要专门的语言，但限制其使用，使其受控，不需要公司进行 drastical 的变化。
- en: Better resource utilization—if **Microservice A** requires more memory, we can
    reduce the number of worker copies. While on a monolith, each worker requires
    the maximum resource allocation, now each microservice uses only the resources
    required for its part of the whole system. Maybe some of them don't need to connect
    to the database, for example. Each individual element can be tweaked, potentially even at
    the hardware level.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更好的资源利用——如果**微服务 A**需要更多的内存，我们可以减少工作人员的副本数量。而在单体系统中，每个工作人员都需要最大的资源分配，现在每个微服务只使用其所需的整个系统部分的资源。也许其中一些不需要连接到数据库，例如。每个单独的元素都可以进行微调，甚至在硬件级别。
- en: Each individual service is smaller and can be dealt with independently. That
    means fewer lines of code to maintain, faster builds, and a simpler design, with
    less technical debt to maintain. There are no dependency issues between services,
    as each can define and move them at their own pace. Performing refactors can be
    done in a more controlled way, as they won't affect the totality of the system. Furthermore,
    each microservice can change the programming language it's written in, without
    affecting other microservices.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个单独的服务都更小，可以独立处理。这意味着更少的代码需要维护，更快的构建，更简单的设计，更少的技术债务需要维护。服务之间没有依赖问题，因为每个服务都可以自己定义和移动它们的步伐。进行重构可以以更受控的方式进行，因为它们不会影响整个系统的完整性。此外，每个微服务都可以更改其编程语言，而不会影响其他微服务。
- en: 'From a certain point of view, the microservices architecture is similar to
    the UNIX philosophy, applied to web services: write each program (service) to
    do one thing and do it well, write programs (services) to work together and write
    programs (services) to handle text streams (HTTP calls), because that is a universal
    interface.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种角度来看，微服务架构类似于 UNIX 哲学，应用于 Web 服务：编写每个程序（服务）来做一件事，并且做得很好，编写程序（服务）来协同工作，编写程序（服务）来处理文本流（HTTP
    调用），因为这是一个通用接口。
- en: Some services can be hidden from external access. For example, **Microservice
    C** is only called by other services, not externally. In some scenarios, that
    can improve security, reducing the attack surface area for sensitive data or services.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些服务可以隐藏不对外部访问。例如，**微服务C**只能被其他服务调用，而不能被外部访问。在某些情况下，这可以提高安全性，减少对敏感数据或服务的攻击面积。
- en: As the systems are independent, a stability problem in one won't completely
    stop the system. This reduces critical responses and limits the scope of a catastrophic
    failure.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于系统是独立的，一个系统中的稳定问题不会完全停止整个系统。这减少了关键响应并限制了灾难性故障的范围。
- en: Each service can be maintained independently by different developers. This allows
    for parallel development and deployment, increasing the amount of work that can
    be done by the company. This requires the exposed APIs to be backward compatible,
    as we will describe later.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个服务可以由不同的开发人员独立维护。这允许并行开发和部署，增加了公司可以完成的工作量。这要求暴露的API是向后兼容的，我们将在后面描述。
- en: Docker containers
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器
- en: The microservice architecture is pretty agnostic about the platform that supports
    it. It can be deployed on old physical boxes in a dedicated data center, in a
    public cloud, or in containerized form.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构对支持它的平台非常不可知。它可以部署在专用数据中心中的旧物理盒子上，也可以在公共云中或以容器化形式部署。
- en: There's a tendency, though, to use containers to deploy microservices. Containers
    are a packetized bundle of software that encapsulates everything that is required
    to run, including all dependencies. It only requires a compatible OS kernel to
    run autonomously.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种倾向是使用容器来部署微服务。容器是一种软件的打包捆绑，封装了运行所需的一切，包括所有依赖项。它只需要兼容的操作系统内核来自主运行。
- en: Docker is the lead actor in containers for web applications. It has an extremely
    vibrant community supporting it as well as great tooling to work on all kinds
    of operations. We will learn how to work and operate using Docker.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是Web应用程序容器的主角。它有一个非常充满活力的社区支持，以及用于处理各种操作的出色工具。我们将学习如何使用Docker进行工作和操作。
- en: The first time that I worked with Docker containers, they looked like a sort
    of *light virtual machine* to me; a small operative system that didn't require
    simulating the hardware to run. But after a while, I realized that's not the correct
    approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用Docker容器时，它们对我来说看起来像一种*轻量级虚拟机*；一个不需要模拟硬件即可运行的小型操作系统。但过了一段时间，我意识到这不是正确的方法。
- en: The best way to describe a container is to think of *a process that's surrounded
    by its own filesystem*. You run one process (or a few related ones), and they
    *see* a whole filesystem, not shared by anyone.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 描述容器的最佳方式是将其视为*被自己的文件系统包围的进程*。您运行一个进程（或几个相关的进程），它们*看到*一个完整的文件系统，不被任何人共享。
- en: This makes containers extremely portable, as they are detached from the underlying
    hardware and the platform that runs them; they are very lightweight, as a minimal
    amount of data needs to be included, and they are secure, as the exposed attack
    surface of a container is extremely small. You don't need applications to manage
    them in the same way you do on a traditional server, such as an `sshd` server,
    or a configuration tool such as Puppet. They are specialized and designed to be
    small and single-purpose.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得容器非常易于移植，因为它们与运行它们的底层硬件和平台分离；它们非常轻量级，因为只需要包含最少量的数据，它们是安全的，因为容器的暴露攻击面非常小。您不需要像在传统服务器上那样管理它们的应用程序，比如`sshd`服务器，或者像Puppet这样的配置工具。它们是专门设计成小而单一用途的。
- en: In particular, try to keep your containers small and single-purpose. If you
    end up adding several daemons and a lot of configuration, it's likely that you
    are trying to include too much; maybe you need to split it into several containers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，尽量保持您的容器小而单一用途。如果最终添加了几个守护程序和大量配置，那么很可能您试图包含太多；也许您需要将其拆分成几个容器。
- en: Working with Docker containers has two steps. First, we build the container,
    executing layer after layer of changes on the filesystem, such as adding the software
    and configuration files that will be executed. Then, we execute it, launching
    its main command. We will see exactly how to do this in [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml),
    *Dockerizing the Service*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker容器有两个步骤。首先，我们构建容器，对文件系统执行一层又一层的更改，比如添加将要执行的软件和配置文件。然后，我们执行它，启动它的主要命令。我们将在[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)中看到如何做到这一点，*将服务Docker化*。
- en: The microservices architecture aligns very well with some of the characteristics
    of Docker containers—small, single-purpose elements that communicate through HTTP
    calls. That's why, even though it's not a hard requirement, they're typically
    presented together these days.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构与Docker容器的一些特征非常契合——小型、单一用途的元素，通过HTTP调用进行通信。这就是为什么尽管这不是一个硬性要求，但这些天它们通常一起呈现的原因。
- en: The Twelve-Factor App principles ([https://12factor.net/](https://12factor.net/)),
    which are a collection of practices that have been proven successful in developing
    web applications, are also very aligned with Docker containers and with the microservice
    architecture. Some of the principles are extremely easy to follow with Docker,
    and we will comment on them in depth later in the book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[十二要素应用](https://12factor.net/)原则是一系列在开发Web应用程序中被证明成功的实践，它们也与Docker容器和微服务架构非常契合。其中一些原则在Docker中非常容易遵循，我们将在本书后面深入讨论它们。'
- en: An important factor for dealing with containers is that containers should be
    stateless (Factor VI—[https://12factor.net/processes](https://12factor.net/processes)).
    Any state needs to be stored in a database and each container stores no persistent
    data. This is one of the key elements for scalable web servers that, when dealing
    with a couple of servers, may not be done. Be sure to keep it in mind.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 处理容器的一个重要因素是容器应该是无状态的（Factor VI—[https://12factor.net/processes](https://12factor.net/processes)）。任何状态都需要存储在数据库中，每个容器都不存储持久数据。这是可扩展的Web服务器的关键元素之一，当涉及到几台服务器时，可能无法完成。请务必记住这一点。
- en: Another advantage of Docker is the availability of a lot of ready-to-use containers. Docker
    Hub ([https://hub.docker.com/](https://hub.docker.com/)) is a public registry
    full of interesting containers to inherit or to use directly, either in development
    or production. This helps you to have examples for your own services, and to quickly
    create small services that require little configuration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的另一个优势是有大量现成的容器可用。Docker Hub（[https://hub.docker.com/](https://hub.docker.com/)）是一个充满有趣容器的公共注册表，可以继承或直接使用，无论是在开发还是生产中。这有助于您为自己的服务提供示例，并快速创建需要很少配置的小型服务。
- en: Container orchestration and Kubernetes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器编排和Kubernetes
- en: Though Docker presents on how to deal with each of the individual microservices,
    we will need an orchestrator to handle the whole cluster of services. For that,
    we will use Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)) throughout
    the book. This is the main orchestration project, and it has great support from
    the main cloud vendors. We will talk in detail about it in [Chapter 5](1cdffcc1-54b3-4502-8862-20eddc002dbc.xhtml), *Using
    Kubernetes to Coordinate Microservices*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Docker提供了如何处理每个单独微服务的方法，但我们需要一个编排器来处理整个服务集群。为此，我们将在整本书中使用Kubernetes（[https://kubernetes.io/](https://kubernetes.io/)）。这是主要的编排项目，并且得到了主要云供应商的大力支持。我们将在[第5章](1cdffcc1-54b3-4502-8862-20eddc002dbc.xhtml)中详细讨论它，*使用Kubernetes协调微服务*。
- en: Parallel deployment and development speed
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行部署和开发速度
- en: The single most important element is the capacity to deploy independently. Rule
    number one for creating a successful microservices system is to ensure that each
    microservice can operate as **independently** as possible from the rest. That
    includes development, testing, and deployment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的元素是能够独立部署。创建成功的微服务系统的第一条规则是确保每个微服务尽可能独立地运行。这包括开发、测试和部署。
- en: This is the key element that allows developing in parallel between different
    teams, allowing them to scale the work. This increases the speed of change in
    a complex system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是允许不同团队并行开发的关键因素，使它们能够扩展工作。这增加了复杂系统变更的速度。
- en: The team responsible for a specific microservice needs to be capable of deploying
    a new version of the microservice without interrupting any other teams or services.
    The objective is to increase the number of deployments and the speed of each of
    them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 负责特定微服务的团队需要能够在不中断其他团队或服务的情况下部署微服务的新版本。目标是增加部署次数和每次部署的速度。
- en: The microservice architecture is strongly related to Continuous Integration
    and Continuous Deployment principles. Small services are easy to keep up to date
    and to continuously build, as well as to deploy without interruption. In that
    regard, a CI/CD system tends to be microservices due to the increase in parallelization
    and the speed of delivery.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构与持续集成和持续部署原则密切相关。小型服务易于保持最新状态和持续构建，以及在不中断的情况下部署。在这方面，CI/CD系统倾向于采用微服务，因为它增加了并行化和交付速度。
- en: As deploying a microservice should be transparent for dependent services, special
    attention should be paid to backward compatibility. Some changes will need to
    be escalated and coordinated with other teams to remove old, incorrect functionality
    without interrupting the system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务的部署对于依赖服务应该是透明的，因此应特别注意向后兼容性。一些更改需要逐步升级并与其他团队协调，以删除旧的、不正确的功能，而不会中断系统。
- en: While, theoretically, it's possible to have totally disconnected services, that's
    not realistic in practice. Some services will have dependencies between them.
    A microservice system will force you to define strong boundaries between the services,
    and any feature that requires cross-service communication will carry some overhead,
    maybe even having to coordinate the work across different teams.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在理论上，完全断开的服务是可能的，但在实践中并不现实。一些服务之间会存在依赖关系。微服务系统将迫使您在服务之间定义明确的边界，并且任何需要跨服务通信的功能都将带来一些额外的开销，甚至可能需要协调不同团队的工作。
- en: When moving to a microservices architecture, the move is not purely technical
    but also implies a big change in the way the company works. The development of
    microservices will require autonomy and structured communication, which requires
    extra effort up front in planning the general architecture of the system. In monolith
    systems, this may be ad hoc and could have evolved into a not-so-separated internal
    structure, increasing the risk of tangled code and technical debt.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 转向微服务架构时，这一举措不仅仅是技术上的改变，还意味着公司工作方式的重大变革。微服务的开发将需要自治和结构化的沟通，这需要在系统的总体架构规划中提前付出额外的努力。在单体系统中，这可能是临时的，并且可能已经演变成一个内部结构不太分离的结构，增加了纠缠的代码和技术债务的风险。
- en: The need to clearly communicate and define owners cannot be stressed enough.
    Aim to allow each team to make their own decisions about their code and formalize
    and maintain the external APIs where other services depend on them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰沟通和定义所有者的需求不言而喻。目标是允许每个团队就其代码做出自己的决定，并规范和维护其他服务依赖的外部API。
- en: This extra planning, though, increases long-term delivery bandwidth, as teams
    are empowered to make more autonomous decisions, including big ones such as which operating
    system to use, or which programming language, but also a myriad of smaller ones,
    such as using third-party packages, frameworks, or module structures. This increases
    the development pace in day-to-day operations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种额外的规划增加了长期交付带宽，因为团队被授权做出更多自主决策，包括诸如使用哪种操作系统或编程语言等重大决策，以及使用第三方软件包、框架或模块结构等许多较小的决策。这增加了日常开发速度。
- en: Microservices may also affect how the teams are structured in your organization.
    As a general rule, existing teams should be respected. There will be expertise
    in them that will be very useful, and causing a total revolution will disrupt
    that. But some tweaks may be necessary. Some concepts, such as understanding web
    services and RESTful interfaces will need to be present in every microservice,
    as well as knowledge on how to deploy its own service.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构也可能影响组织中团队的结构。一般规则是要尊重现有的团队。他们会有非常有用的专业知识，而彻底革命会破坏这一点。但可能需要进行一些微调。一些概念，比如理解Web服务和RESTful接口，需要在每个微服务中出现，以及如何部署自己的服务的知识。
- en: A traditional way of dividing teams is to create an operations team that is
    in charge of infrastructure and any new deployments because they are the only
    ones allowed to have access to the production servers. The microservices approach
    interferes with this as it needs teams to be able to have control over their own
    deployments. In [Chapter 5](1cdffcc1-54b3-4502-8862-20eddc002dbc.xhtml), *Using
    Kubernetes to Coordinate Microservices*, we'll see how using Kubernetes helps
    in this situation, detaching the maintenance of the infrastructure from the deployment
    of services.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的团队划分方式是创建一个负责基础设施和任何新部署的运维团队，因为他们是唯一被允许访问生产服务器的人。微服务方法会干扰这一点，因为它需要团队能够控制自己的部署。在[第5章](1cdffcc1-54b3-4502-8862-20eddc002dbc.xhtml)中，*使用Kubernetes协调微服务*，我们将看到使用Kubernetes如何在这种情况下有所帮助，将基础设施的维护与服务的部署分离开来。
- en: It also allows creating a big sense of ownership, as teams are encouraged to
    work in their own preferred way in their own kingdom, while they play the game
    with the rest of the teams within clearly defined and structured borders. Microservices
    architecture can allow experimentation and innovation in small parts of the system
    that, once proven, can be disseminated across the whole system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这也允许创建一种强烈的所有权感，因为团队被鼓励以自己喜欢的方式在自己的领域内工作，同时与其他团队一起在明确定义和结构化的边界内进行游戏。微服务架构可以允许在系统的小部分进行实验和创新，一旦证明有效，就可以在整个系统中传播。
- en: Challenges and red flags
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战和红旗
- en: We've discussed a lot of advantages that the microservice architecture has over
    a monolith, but migrating is a massive undertaking that should not be underestimated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了微服务架构相对于单体应用的许多优势，但迁移是一项庞大的工程，不应该被低估。
- en: Systems get started as monoliths, as it is simpler and allows for quicker iteration
    in a small code base. In any new company, pivoting and changing the code, searching
    for a successful business model is critical. This takes preference over clear
    structures and architecture separations—it is the way it should be.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 系统开始时是单体应用，因为这样更简单，可以在小的代码库中进行更快的迭代。在任何新公司中，转变和改变代码，寻找成功的商业模式至关重要。这比清晰的结构和架构分离更重要——这就是应该的方式。
- en: However, once the system matures, the company grows. As more and more developers
    get involved, the advantages of a monolith start to become less evident, and the
    need for long-term strategy and structure becomes more important. More structure
    doesn't necessarily mean moving toward a microservice architecture. A great deal
    can be achieved with a well-architected monolith.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦系统成熟，公司发展起来。随着越来越多的开发人员参与进来，单体应用的优势开始变得不那么明显，长期战略和结构的需求变得更加重要。更多的结构并不一定意味着向微服务架构迈进。一个良好架构的单体应用可以实现很多。
- en: 'Moving to microservices also has its own problems. Some of them are the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 转向微服务也有自己的问题。其中一些是：
- en: Migrating to microservices requires a lot of effort, actively changing the way
    an organization operates, and a big investment until it starts to pay off. The
    transition will probably be painful, as a pragmatic approach is required and compromises
    will need to be made. It will also involve a lot of designing documents and meetings
    to plan the migration—all while the business continues to operate. This requires
    full commitment and an understanding of what's involved.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移到微服务需要大量的努力，积极改变组织的运作方式，并且需要大量的投资，直到开始见效。过渡可能会很痛苦，因为需要采取务实的方法，并需要做出妥协。这还将涉及大量的设计文件和会议来规划迁移，而业务仍在继续运营。这需要全面的承诺和对所涉及内容的理解。
- en: Do not underestimate the cultural change—organizations are made of people, and
    people do not like change. A lot of the changes in microservices are related to
    different ways of operating and doing things in different ways. While this empowers
    different teams, it also forces them to clarify their interfaces and APIs and
    to formalize communication and boundaries. This can lead to frustration and resistance
    by members of the teams.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要低估文化变革——组织是由人组成的，人们不喜欢变化。微服务中的许多变化与不同的运营方式和不同的做事方式有关。虽然这赋予了不同的团队权力，但也迫使他们澄清他们的接口和API，并形式化沟通和边界。这可能导致团队成员的挫折和抵制。
- en: There's an adage called Conway's law ([http://www.melconway.com/Home/Conways_Law.html](http://www.melconway.com/Home/Conways_Law.html))
    that states that *organizations which design systems are constrained to produce
    designs which are copies of the communication structures of these organizations.*
    For microservices, this means that divisions between teams should reflect the
    different services. Having multiple teams working in the same microservice will
    blur the interfaces. We will discuss Conway's law in detail in [Chapter 12](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml),
    *Collaborating and Communicating across Teams*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有一句叫康威定律的格言（[http://www.melconway.com/Home/Conways_Law.html](http://www.melconway.com/Home/Conways_Law.html)），它指出*设计系统的组织受限于产生与这些组织的沟通结构相同的设计*。对于微服务来说，这意味着团队之间的分工应该反映不同的服务。让多个团队在同一个微服务中工作会模糊界面。我们将在第12章《跨团队协作和沟通》中详细讨论康威定律。
- en: There's also a learning curve in learning the tools and procedures. Managing
    clusters is done differently than a single monolith, and developers will need
    to understand how to interoperate different services for testing locally. In the
    same way, that deployment will be different from traditional, local development
    as well. In particular, learning Docker takes some time to adapt. Plan accordingly
    and give support and training to everyone involved.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习工具和程序也需要一定的学习曲线。管理集群与单体的方式不同，开发人员需要了解如何在本地进行测试时相互操作不同的服务。同样，部署也与传统的本地开发不同。特别是，学习Docker需要一些时间来适应。因此，要做好计划，并为所有参与者提供支持和培训。
- en: Debugging a request that moves across services is more difficult than a monolithic
    system. Monitoring the life cycle of a request is important and some subtle bugs
    can be difficult to replicate and fix in development.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试跨服务的请求比单体系统更困难。监控请求的生命周期很重要，一些微妙的错误在开发中可能很难复制和修复。
- en: Splitting a monolith into different services requires careful consideration.
    A bad division line can make two services tightly coupled, not allowing independent
    deployment. A red flag in that means almost any change to one service requires
    a change in the other, even if, normally, it could be done independently. This
    creates duplication of work, as routinely working on a single feature requires
    changing and deploying multiple microservices. Microservices can be mutated later
    and boundaries redefined, but there's a cost associated with that. The same care
    should be taken when adding new services.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单体拆分为不同的服务需要仔细考虑。糟糕的划分线会使两个服务紧密耦合，不允许独立部署。这意味着几乎任何对一个服务的更改都需要对另一个服务进行更改，即使通常情况下可以独立完成。这会导致工作的重复，因为通常需要对单个功能进行更改和部署多个微服务。微服务以后可以进行变异，边界可以重新定义，但这是有成本的。在添加新服务时也应该采取同样的谨慎。
- en: There's an overhead in creating microservices, as there's some work that gets
    replicated on each service. That overhead gets compensated by allowing independent
    and parallel development. But, to fully take advantage of that, you need numbers.
    A small development team of up to 10 people can coordinate and handle a monolith
    very efficiently. It's only when the size grows and independent teams are formed
    that migrating to microservices starts to make sense. The bigger the company,
    the more it makes sense.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建微服务存在一些额外开销，因为一些工作会在每个服务上复制。这种额外开销通过允许独立和并行开发来进行补偿。但是，要充分利用这一点，你需要数量。一个最多有10人的小型开发团队可以高效地协调和处理单体。只有当规模扩大并形成独立团队时，迁移到微服务才开始变得有意义。公司规模越大，这种做法就越有意义。
- en: A balance between freedom and allowing each team to make their own decisions
    and standardize some common elements and decisions is necessary. If teams have
    too little direction, they'll keep reinventing the wheel over and over. They'll
    also end up creating knowledge silos where the knowledge in a section of the company
    is totally nontransferable to another team, making it difficult to learn lessons
    collectively. Solid communication between teams is required to allow consensus
    and the reuse of common solutions. Allow controlled experimentation, label it
    as such, and get the lessons learned across the board so that the rest of the
    teams benefit. There will be tension between shared and reusable ideas and independent,
    multiple-implementation ideas.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自由和允许每个团队做出自己的决定以及标准化一些共同的元素和决定之间需要保持平衡。如果团队缺乏方向，他们会一遍又一遍地重新发明轮子。他们也会最终创建知识孤岛，其中公司的某一部分的知识完全无法转移到另一个团队，这使得共同学习变得困难。团队之间需要良好的沟通，以便达成共识并重复使用共同的解决方案。允许受控实验，将其标记为实验，并让所有团队从中汲取教训，以使其他团队受益。共享和可重复使用的想法与独立的、多重实施的想法之间会产生紧张关系。
- en: Be careful when introducing shared code across services. If the code grows,
    it will make services dependent on each other. This can reduce the independence
    of the microservices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入跨服务共享代码时要小心。如果代码增长，它将使服务相互依赖。这可能会减少微服务的独立性。
- en: Following the Agile principles, we know that working software is more important
    than extensive documentation. However, in microservices, it's important to maximize
    the usability of each individual microservice to reduce the amount of support
    between teams. That involves some degree of documentation. The best approach is
    to create self-documenting services. We'll look at some examples later in the
    book on how to use tools to allow documenting how to use a service with minimal
    effort.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循敏捷原则，我们知道，工作软件比广泛的文档更重要。然而，在微服务中，最大限度地提高每个单独微服务的可用性以减少团队之间的支持量是很重要的。这涉及一定程度的文档编制。最好的方法是创建自我记录的服务。我们将在本书的后面看一些例子，介绍如何使用工具来允许以最小的努力记录如何使用服务。
- en: Each call to another service, such as internal microservices calling each other,
    can increase the delay of responses, as multiple layers will have to be involved.
    This can produce latency problems, with external responses taking longer. They
    will also be affected by the performance and capacity of the internal network
    connecting the microservices.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次调用另一个服务，比如内部微服务相互调用，都会增加响应的延迟，因为将涉及多个层。这可能会产生延迟问题，外部响应时间更长。它们也会受到内部网络连接微服务的性能和容量的影响。
- en: A move to microservices should be taken with care and by carefully analyzing
    its pros and cons. It is possible that it will take years to complete the migration
    in a mature system. But for a big system, the resulting system will be much more
    agile and easy to change, allowing you to tackle technical debt effectively and
    to empower developers to take full ownership and innovate, structuring communication
    and delivering a high quality, reliable service.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到微服务应该谨慎进行，并仔细分析其利弊。在成熟的系统中，完成迁移可能需要数年的时间。但对于一个大型系统来说，结果系统将更加灵活和易于更改，使您能够有效地处理技术债务，并赋予开发人员充分的所有权和创新能力，构建沟通并提供高质量、可靠的服务。
- en: Analyzing the current system
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析当前系统
- en: The very first step, as we defined before, to migrate from a monolith to a collection
    of microservices is understanding the current system. This stage should not be
    underestimated. It is highly likely that no single person has a good understanding
    of the different components of the monolith, especially if some parts are legacy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前定义的，从单体迁移到一组微服务的第一步是了解当前系统。这个阶段不应该被低估。很可能没有一个人对单体的不同组件有很好的理解，特别是如果一些部分是遗留的。
- en: The objective of this phase is to determine whether a change to microservices
    will actually be beneficial and to get an initial idea of what microservices will
    be the result of the migration. As we have discussed, making the move is a big
    investment and should not be taken lightly. Making a detailed estimation of the
    effort required won't be possible at this stage; uncertainty will be big at this
    point, but a thousand-mile journey starts with a single step.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的目标是确定迁移到微服务是否真的有益，并初步了解迁移的结果将是什么样的微服务。正如我们所讨论的，迁移是一个巨大的投资，不应该轻率对待。在这个阶段无法对所需的工作量进行详细估计；此时的不确定性将会很大，但千里之行始于足下。
- en: The effort involved will vastly depend on how structured the monolith is. This
    may vary from a mess of spaghetti code that has grown organically without much
    direction, to a well-structured and modularized code base.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所涉及的工作将大大取决于单体的结构化程度。这可能从一团没有太多方向的有机生长的意大利面代码混乱到一个结构良好、模块化的代码库。
- en: We will use an example application in this book—a micro-blogging site called
    MyThoughts, a simple service that will allow us to post and read short messages
    or thoughts. The website allows us to log in, post a new thought, see our thoughts,
    and search for thoughts in the system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中使用一个示例应用程序——一个名为MyThoughts的微博网站，这是一个简单的服务，允许我们发布和阅读短消息或想法。该网站允许我们登录、发布新想法、查看我们的想法，并在系统中搜索想法。
- en: '![](img/9169859c-18ea-4693-8c23-c0d91fc9aaab.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9169859c-18ea-4693-8c23-c0d91fc9aaab.png)'
- en: As a first step, we will draw an architectural diagram of the monolith. Reduce
    the current system to a list of blocks that interact with each other.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们将绘制单体的架构图。将当前系统简化为相互交互的块列表。
- en: 'The code for our example is available here: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith).
    It is a Django application that uses Bootstrap for its HTML interface. See the
    `README` for instructions on how to run it.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例的代码在这里可用：[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith)。这是一个使用Bootstrap作为其HTML界面的Django应用程序。查看`README`以获取运行说明。
- en: 'In our example, the MyThoughts model is described in the following diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，MyThoughts模型在以下图表中描述：
- en: '![](img/db5b3617-82b8-4ffd-b2fc-5e01ba308c01.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db5b3617-82b8-4ffd-b2fc-5e01ba308c01.png)'
- en: 'As you can see, the monolith seems to be following a Model View Controller
    structure ([https://www.codecademy.com/articles/mvc](https://www.codecademy.com/articles/mvc)):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，单体似乎遵循了模型视图控制器结构（[https://www.codecademy.com/articles/mvc](https://www.codecademy.com/articles/mvc)）：
- en: Django uses a structure called Model Template View, which follows a similar
    pattern to the MVC one. Read the article at [https://medium.com/shecodeafrica/understanding-the-mvc-pattern-in-django-edda05b9f43f](https://medium.com/shecodeafrica/understanding-the-mvc-pattern-in-django-edda05b9f43f)
    for more information. Whether it's 100% MCV or not is debatable. Let's not get
    stuck on semantics, but use the definition as a starting point to describe the
    system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用一种称为模型模板视图的结构，它遵循与MVC类似的模式。阅读[https://medium.com/shecodeafrica/understanding-the-mvc-pattern-in-django-edda05b9f43f](https://medium.com/shecodeafrica/understanding-the-mvc-pattern-in-django-edda05b9f43f)上的文章以获取更多信息。它是否完全符合MVC是值得商榷的。让我们不要陷入语义，而是将定义作为描述系统的起点。
- en: 'There are three entities stored in a database and accessed through the models:
    the user, the thoughts, and the session models. The session is used for keeping
    track of logins.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库中存储并通过模型访问的三个实体：用户、想法和会话模型。会话用于跟踪登录。
- en: A user can log in and out to access the site through the code in `login.py`.
    If the user logs in, a session is created that allows the user to see the rest
    of the website.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过`login.py`中的代码登录和退出以访问网站。如果用户登录，将创建一个会话，允许用户查看网站的其余部分。
- en: Please note that the handling of authentication and passwords in this example
    is for demonstration purposes only. Use the default mechanisms in Django for more
    secure access. It's the same for the session, where the native session management
    is not used.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此示例中身份验证和密码的处理仅用于演示目的。请使用Django中的默认机制以获得更安全的访问。会话也是一样，原生会话管理未被使用。
- en: A user can see their own thoughts. On the same page, there's a new form that
    creates a new thought. This is handled by the `thoughts.py` file, which retrieves
    and stores the thoughts through `ThoughtModel`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以看到他们自己的想法。在同一页上，有一个新的表单可以创建一个新的想法。这由`thoughts.py`文件处理，通过`ThoughtModel`检索和存储想法。
- en: To search other users' thoughts, there's a search bar that connects to the `search.py`
    module and returns the obtained values.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要搜索其他用户的想法，有一个搜索栏连接到`search.py`模块并返回获取的值。
- en: The HTML is rendered through the `login.html`, `search.html`, `list_thoughts.html`, and
    `base.html` templates.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML通过`login.html`、`search.html`、`list_thoughts.html`和`base.html`模板呈现。
- en: On top of that, there are static assets that style the website.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有样式网站的静态资产。
- en: 'This example is very simple, but we are able to see some of the interdependencies:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常简单，但我们能够看到一些相互依赖：
- en: The static data is very isolated. It can be changed at any point without requiring
    any changes anywhere else (as long as the templates are compatible with Bootstrap).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态数据非常隔离。它可以在任何时候更改，而无需在其他任何地方进行任何更改（只要模板与Bootstrap兼容）。
- en: The search functionality is strongly related to list down thoughts. The template
    is similar, and the information is displayed in the same way.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索功能与列出想法密切相关。模板相似，信息以相同的方式显示。
- en: Login and logout don't interact with `ThoughtModel`*.* They edit the session,
    but the rest of the application only reads the information there.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录和注销不与`ThoughtModel`交互。它们编辑会话，但应用程序的其余部分只读取那里的信息。
- en: The `base.html` template generates the top bar and it's used for all pages.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base.html`模板生成顶部栏，并用于所有页面。'
- en: 'After this analysis, some ideas on how to proceed come to mind:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这项分析之后，一些关于如何继续的想法浮现在脑海中：
- en: Just leave it the way it is, investing in structuring it, but without splitting
    it into several services. It has a certain structure already, though some parts
    could be improved. For example, the handling of whether the user is logged in
    or not could be better. This is obviously a small example, and, in real life,
    splitting it into microservices would have a big overhead. Remember that sticking
    with a monolith may be a viable strategy, but if you do, please invest time in
    cleaning up code and paying technical debt.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持现状，投资于结构化，但不将其拆分为多个服务。它已经有一定的结构，尽管有些部分可以改进。例如，处理用户是否已登录的方式可能会更好。这显然是一个小例子，在现实生活中，将其拆分为微服务将会产生很大的开销。请记住，坚持使用单体架构可能是一种可行的策略，但如果这样做，请投入时间来清理代码和偿还技术债务。
- en: Searching for thoughts is pretty basic. At the moment, we directly search the
    database. If there are millions of thoughts, this won't be a viable option. The
    code in `search.py` could call a specific search microservice, backed by a search
    engine such as Solr ([https://lucene.apache.org/solr/](https://lucene.apache.org/solr/)) or
    Elasticsearch ([https://www.elastic.co/products/elasticsearch](https://www.elastic.co/products/elasticsearch)).
    This will scale the searches and could add capabilities like searching between
    dates or displaying the text matches. Search is also read-only, so it may be a
    good idea to detach calls creating new thoughts from calls searching them.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索想法非常基本。目前，我们直接搜索数据库。如果有数百万个想法，这将不是一个可行的选择。`search.py`中的代码可以调用一个特定的搜索微服务，由Solr（[https://lucene.apache.org/solr/](https://lucene.apache.org/solr/)）或Elasticsearch（[https://www.elastic.co/products/elasticsearch](https://www.elastic.co/products/elasticsearch)）支持的搜索引擎。这将扩展搜索，并可以添加诸如在日期之间搜索或显示文本匹配等功能。搜索也是只读的，因此将创建新想法的调用与搜索它们的调用分离可能是一个好主意。
- en: Authentication is also a different problem from reading and writing thoughts.
    Splitting it will allow us to keep on track for new security issues and have a
    team specifically dealing with those issues. From the point of view of the rest
    of the application, it only requires you to have something available to check
    whether a user is logged or not, and that can be delegated in a module or package.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 身份验证也是与阅读和编写想法不同的问题。拆分它将使我们能够跟踪新的安全问题，并有一个专门处理这些问题的团队。从应用程序的角度来看，它只需要有一个可用于检查用户是否已登录的东西，这可以委托给一个模块或包。
- en: The frontend is pretty static at the moment. Maybe we want to create a single-page
    application that calls a backend API to render the frontend in the client. To
    do that, a RESTful API microservice that is able to return elements for thoughts
    and searches will need to be created. The frontend could be coded in a JavaScript
    framework, such as Angular ([https://angular.io](https://angular.io)) or React
    ([https://reactjs.org/](https://reactjs.org/)). In this case, the new microservice
    will be the frontend, which will be served as static, precompiled code, and will
    pull from the backend.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端目前非常静态。也许我们想创建一个单页面应用程序，调用后端API在客户端渲染前端。为此，需要创建一个能够返回想法和搜索元素的RESTful API微服务。前端可以使用JavaScript框架编码，例如Angular（[https://angular.io](https://angular.io)）或React（[https://reactjs.org/](https://reactjs.org/)）。在这种情况下，新的微服务将成为前端，将作为静态的预编译代码提供，并将从后端拉取。
- en: The RESTful API backend will also be available to allow external developers
    to create their own tools on top of the MyThoughts data, for example, to create
    a native phone app.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RESTful API后端也将可用于允许外部开发人员在MyThoughts数据之上创建自己的工具，例如创建原生手机应用程序。
- en: These are just some ideas, which will need to be discussed and evaluated. What
    are the specific pain points for your monolithic app? What is the roadmap and
    the strategic future? What are the most important points and features for the
    present or the future? Maybe, for one company, having strong security is a priority,
    and point 3 is critical, but for another, point 5 might be part of the expansion
    model to work with partners.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一些想法，需要讨论和评估。对于您的单片应用程序来说，具体的痛点是什么？路线图和战略未来是什么？现在或未来最重要的点和功能是什么？也许对于某家公司来说，拥有强大的安全性是优先考虑的，第3点至关重要，但对于另一家公司来说，第5点可能是与合作伙伴合作的扩展模型的一部分。
- en: The team's structure is also important. Point 4 will require a team with good
    frontend and JavaScript skills, while point 2 may involve backend optimization
    and database work to allow an efficient search of millions of records.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 团队的结构也很重要。第4点将需要具有良好的前端和JavaScript技能的团队，而第2点可能涉及后端优化和数据库工作，以允许对数百万条记录进行高效搜索。
- en: Do not jump too quickly to conclusions here; think about what capacity is viable
    and what your teams can achieve. As we discussed before, the change to microservices
    requires a certain way of working. Check with the people involved for their feedback
    and suggestions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不要过快地得出结论；考虑一下什么样的能力是可行的，您的团队可以实现什么。正如我们之前讨论过的，转变为微服务需要一定的工作方式。与相关人员核实他们的反馈和建议。
- en: 'After some consideration, for our example, we propose the following potential
    architecture:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些考虑，对于我们的示例，我们提出以下潜在架构：
- en: '![](img/e0b5fd45-46bf-49e7-ac45-ecfe9c6daca7.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0b5fd45-46bf-49e7-ac45-ecfe9c6daca7.png)'
- en: 'The system will be divided into the following modules:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将分为以下模块：
- en: '**Users backend:** This will have the responsibility for all authentication
    tasks and keep information about the users. It will store its data in the database.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Users backend:** 这将负责所有身份验证任务，并保留有关用户的信息。它将在数据库中存储其数据。'
- en: '**Thoughts backend:** This will create and store *thoughts*.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Thoughts backend:** 这将创建和存储*thoughts*。'
- en: '**Search backend**: This will allow searching *thoughts*.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Search backend:** 这将允许搜索*thoughts*。'
- en: A proxy that will route any request to the proper backend. This needs to be
    externally accessible.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个代理将任何请求路由到适当的后端。这需要是外部可访问的。
- en: '**HTML frontend:** This will replicate the current functionality. This will
    ensure that we work in a backward-compatible way and that the transition can be
    made smoothly.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTML frontend:** 这将复制当前的功能。这将确保我们以向后兼容的方式工作，并且过渡可以顺利进行。'
- en: Allowing clients to access the backends will allow the creation of other clients
    than our HTML frontend. A dynamic frontend server will be created, and there are
    talks with an external company to create a mobile app.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许客户端访问后端将允许创建除我们的HTML前端之外的其他客户端。将创建一个动态前端服务器，并且正在与外部公司讨论创建移动应用程序的事宜。
- en: '**Static assets:** A web server capable of handling static files. This will
    serve the styling for the HTML frontend and the index files and JavaScript files
    for the dynamic frontend.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Static assets:** 能够处理静态文件的Web服务器。这将为HTML前端提供样式和动态前端的索引文件和JavaScript文件。'
- en: This architecture will need to adapt to real-life usage; to validate it, we'll
    need to measure the existing usage.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构需要适应实际使用；为了验证它，我们需要测量现有的使用情况。
- en: Preparing and adapting by measuring usage
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过测量来准备和适应。
- en: Obviously, any real-world system will be more complicated than our example.
    There's a limit to what a code analysis can discover just by looking at it carefully,
    and plans often don't survive contact with the real world.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，任何真实世界的系统都会比我们的示例更复杂。通过仔细观察，代码分析能够发现的内容是有限的，而计划往往在接触真实世界时无法生存。
- en: Any division needs to be validated to ensure that it will have the expected
    result and that the effort will be worth it. So double-check that the system is
    working the way you think it is working.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任何划分都需要经过验证，以确保它将产生预期的结果，并且付出的努力是值得的。因此，请仔细检查系统是否按您认为的方式运行。
- en: The ability to know how a live system is working is called **observability**.
    The main tools for it are metrics and logs. The problem you'll find is that they
    will normally be configured to reflect external requests and give no information
    about internal modules. We will talk about the observability of systems in depth
    in [Chapter 10](ca9b0606-730a-4006-a575-de8e897a19ba.xhtml), *Monitoring Logs
    and Metrics*. You can refer to it for more information and apply the techniques
    described there at this stage.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 了解实时系统运行情况的能力被称为**可观测性**。它的主要工具是指标和日志。您将发现的问题是，它们通常会配置为反映外部请求，并且不提供有关内部模块的信息。我们将在[第10章](ca9b0606-730a-4006-a575-de8e897a19ba.xhtml)中深入讨论系统的可观测性，*监控日志和指标*。您可以参考它以获取更多信息，并在此阶段应用那里描述的技术。
- en: If your system is a web service, by default, it will have activated its access
    log. This will log each HTTP request that comes into the system and store the
    URL, result, and time when it happens. Check with your team where these logs are
    located, as they will provide good information on what URLs are being called.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统是一个网络服务，默认情况下，它将已激活其访问日志。这将记录系统中进入的每个HTTP请求，并存储URL、结果和发生时间。与您的团队核实这些日志的位置，因为它们将提供关于调用哪些URL的良好信息。
- en: This analysis, though, will probably give only information about what the external
    endpoints being called are, but won't say much about internal modules that will
    be split into different microservices according to our plan. Remember that the
    most important element for the long-term success of the move to microservices
    is to allow teams to be independent. If you split across modules that constantly
    need to be changed in unison, deployments won't be truly independent, and, after
    the transition, you'll be forced to work with two tightly coupled services.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种分析可能只会提供有关被调用的外部端点的信息，但对于根据我们的计划将被分割为不同微服务的内部模块，它不会提供太多信息。请记住，对于微服务长期成功的最重要因素是允许团队独立。如果您跨模块进行分割，而这些模块需要不断协同变更，部署将不会真正独立，并且在过渡后，您将被迫使用两个紧密耦合的服务。
- en: Be careful, in particular, about making a microservice that's a dependency for
    every other service. Unless the service is extremely stable, that will make frequent
    updates likely when any other service requires a new feature.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要小心的是，不要创建一个对每个其他服务都是依赖的微服务。除非该服务非常稳定，否则当任何其他服务需要新功能时，可能会频繁更新。
- en: To verify that the new microservices won't be tightly coupled, make the teams
    aware of the divisions and how often they have to change the interfaces surrounding
    them. Monitor these changes for a few weeks to be sure that the division lines
    are stable and don't require constant change. If the interface between microservices
    is very actively being changed, any feature will require multiple changes in several
    services, and that will slow the pace of delivering new features.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证新的微服务不会紧密耦合，让团队了解这些分割以及他们周围的接口需要多久改变一次。在接下来的几周内监控这些变化，确保分割线是稳定的，不需要不断变化。如果微服务之间的接口被频繁更改，任何功能都将需要在多个服务中进行多次更改，这将减缓交付新功能的速度。
- en: 'In our example, after analyzing the proposed architecture, we decide to simplify
    the design, as shown in this diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，经过分析提出的架构后，我们决定简化设计，如图所示：
- en: '![](img/82ea1d40-9fc8-4d9a-8452-84332c3e2780.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82ea1d40-9fc8-4d9a-8452-84332c3e2780.png)'
- en: 'Some changes have been decided after monitoring and talking with the teams:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控和与团队交流之后，已经做出了一些决定：
- en: The teams don't have good knowledge of JavaScript dynamic programming. The change
    to the frontend, at the same time as making the move to microservices, is seen
    as too risky.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队对JavaScript动态编程的了解不够。在同时进行前端变更和转向微服务的情况下，被视为过于冒险。
- en: The external mobile application, on the other hand, is seen as a strategic move
    for the company, making the externally accessible API a desirable move.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，外部移动应用被视为公司的战略举措，使外部可访问的API成为一个可取的举措。
- en: Analyzing the logs, it seems like the search functionality is not often used.
    The growth in the number of searches is small, and splitting search into its own
    service will require coordination with the Thoughts Backend, as it's an area of
    active development, with new fields being added. It is decided to keep search under
    the Thoughts Backend, as both work with the same thoughts.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析日志，似乎搜索功能并不经常使用。搜索次数的增长很小，将搜索拆分为独立的服务将需要与Thoughts后端进行协调，因为这是一个积极开发的领域，正在添加新字段。决定将搜索保留在Thoughts后端，因为它们都与相同的Thoughts一起工作。
- en: The Users Backend has been received well. It will allow improving the security
    of authentication by having clear ownership of who's responsible for patching
    security vulnerabilities and improving the services. The rest of the microservices
    will have to work independently with verification by the Users Backend, which
    means the team responsible for this microservice will need to create and maintain
    a package with information on how to validate a request.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户后端已经得到了良好的接受。这将通过明确负责修补安全漏洞和改进服务的所有权来提高身份验证的安全性。其余的微服务将需要独立工作，并由用户后端进行验证，这意味着负责这个微服务的团队将需要创建和维护一个包，其中包含验证请求的信息。
- en: Once we've decided on the final state, we still have to decide how are we going
    to move from one state to another.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定了最终状态，我们仍然需要决定如何从一个状态转移到另一个状态。
- en: Strategic planning to break the monolith
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解单体的战略规划
- en: As we've discussed previously, moving from the initial state to the desired
    one will be a slow process. Not only because it involves new ways of doing things,
    but also because it will happen in parallel with other features and developments
    that are "business as usual." Being realistic, the company's business activities
    will not stop. That's why a plan should be in place to allow a smooth transition
    between one state and the other.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，从初始状态到期望状态的转变将是一个缓慢的过程。不仅因为它涉及到新的工作方式，而且还因为它将与其他“业务如常”的功能和发展并行进行。实际上，公司的业务活动不会停止。因此，应该制定一个计划，以便在一个状态和另一个状态之间实现平稳过渡。
- en: This is known as the **strangler pattern** ([https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler](https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler))—replacing
    parts of a system gradually until the old system is "strangled" and can be removed
    safely.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**窒息模式**（[https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler](https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler)）-逐渐替换系统的部分，直到旧系统被“窒息”，可以安全地移除。
- en: 'There are a few alternatives as to what technical approach to take to make
    the move and how to divide each of the elements to migrate to the new system:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种技术方法可以选择，以进行转变并将每个元素分割以迁移到新系统：
- en: The replacement approach, which replaces the older code with new code written
    from scratch the new service
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换方法，将旧代码替换为全新编写的新服务
- en: The divide approach, which cherry-picks existing code and moves it into its
    own new service
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割方法，挑选现有代码并将其移入全新的服务
- en: A combination of the two
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者的结合
- en: Let's take a better look at them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一看。
- en: The replacement approach
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换方法
- en: Services are replaced in big chunks, only taking into account their external
    interfaces or effects. This black-box approach completely replaces existing functionality
    coding with an alternative from scratch. Once the new code is ready, it gets activated
    and the functionality in the old system is deprecated.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大块地替换服务，只考虑它们的外部接口或影响。这种黑盒方法完全用从头开始的替代功能编码替换现有功能。一旦新代码准备就绪，它就会被激活，旧系统中的功能就会被弃用。
- en: Note that this does not refer to a single deployment that replaces the whole
    system. This can be done partially, chunk by chunk. The basis of this approach
    is that it creates a new external service that aims to replace the old system.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并不是指替换整个系统的单个部署。这可以部分地、一块一块地完成。这种方法的基础是创建一个新的外部服务，旨在取代旧系统。
- en: The pros of this approach are that it greatly helps in structuring the new service,
    as it doesn't inherit the technical debt, and allows for a fresh look at an old
    problem, with hindsight.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于它极大地有助于构建新服务，因为它不会继承技术债务，并且可以以新的视角审视旧问题。
- en: The new service can also use new tools and doesn't need to continue with any
    old stack that is not aligned with the strategic views on the future direction
    of the technology in the company.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 新服务还可以使用新工具，并且不需要继续使用与公司技术未来方向战略观点不一致的旧技术栈。
- en: The problem with this approach is that it can be costly and can take a long
    time. For old services that are undocumented, replacing them could take a lot
    of effort. Also, this approach can only be applied to modules that are stable;
    if they are developed actively, trying to replace them with something else is
    moving the goalposts all the time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于成本可能很高，而且可能需要很长时间。对于未经记录的旧服务，替换它们可能需要大量的工作。此外，这种方法只能应用于稳定的模块；如果它们在积极开发中，试图用其他东西替换它们就会不断改变目标。
- en: This approach makes the most sense for old legacy systems that are small, or
    at least have a small part that performs limited functionality, and are developed
    in an old tech stack that's difficult or is no longer considered desirable to
    maintain.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于小型的旧遗留系统或者至少有一小部分执行有限功能的系统来说是最合理的，而且这些系统是使用难以维护的旧技术栈开发的，或者已不再被认为是可取的。
- en: The divide approach
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割的方法
- en: If the system is well structured, maybe some parts of it can be cleanly split
    into its own system, maintaining the same code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统结构良好，也许它的一些部分可以干净地分割成自己的系统，保持相同的代码。
- en: In this case, creating a new service is more an exercise of copy-pasting and
    wrapping it around with the minimal amount of code to allow it to be executed
    independently and to interoperate with other systems, in other words, to structure
    its API around HTTP requests to have a standard interface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建一个新服务更多地是一个复制粘贴的练习，并用最少量的代码包装它，以使其能够独立执行并与其他系统进行交互，换句话说，以HTTP请求为基础来构建其API以获得标准接口。
- en: If this approach can be used, it means that the code was already quite structured,
    which is fantastic news.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以使用这种方法，这意味着代码已经相当结构化，这是个好消息。
- en: 'The systems that are called to this part will also have to be adapted to make
    the call, not to internal code, but through HTTP calls. The good part is that
    this can be done in a few steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用到这一部分的系统也必须进行调整，不是调用内部代码，而是通过HTTP调用。好处是这可以分几步完成：
- en: Copy the code into its own microservice and deploy it.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码复制到自己的微服务中并部署它。
- en: The old calling system is using the old embedded code.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧的调用系统正在使用旧的嵌入式代码。
- en: Migrate a call and check that the system is working fine.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移一个调用并检查系统是否正常工作。
- en: Iterate until all old calls are migrated to the new system.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代，直到所有旧的调用都迁移到新系统。
- en: Delete the divided code from the old system.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从旧系统中删除分割的代码。
- en: If the code is not so cleanly structured, we will need to change it first.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码结构不太干净，我们需要先进行更改。
- en: Change and structured approach
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改和结构化方法
- en: If the monolith has been growing organically, it's not likely that all its modules
    will be cleanly structured. Some structures may exist, but maybe they're not the
    correct ones for our desired microservices division.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单体系统是有机增长的，那么它的所有模块都不太可能是干净的结构化。可能存在一些结构，但也许它们并不是我们期望的微服务划分的正确结构。
- en: To adapt the service, we will need to make some internal changes. These internal
    changes could be done iteratively until the service can be cleanly divided.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应服务，我们需要进行一些内部更改。这些内部更改可以进行迭代，直到服务可以被干净地分割。
- en: These three approaches can be combined to generate full migration. The effort
    involved in each is not the same, as an easily divisible service will be able
    to make the move faster than a replacement of badly-documented legacy code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法可以结合起来进行完整的迁移。每种方法所涉及的工作量并不相同，因为一个易于分割的服务将能够比替换文档不完整的遗留代码更快地进行迁移。
- en: 'In this phase of the project, the objective is to have a clear roadmap, that
    should analyze the following elements:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的这个阶段，目标是拥有一个清晰的路线图，应该分析以下元素：
- en: An ordered plan of what microservices will be available first, taking into account
    how to deal with dependencies.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有序的计划，确定哪些微服务将首先可用，考虑如何处理依赖关系。
- en: An idea of what the biggest pain points are, and whether working on them is
    a priority. Pain points are the elements that are worked with frequently and the
    current way of dealing with the monolith makes them difficult.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解最大的痛点是什么，以及是否解决它们是一个优先事项。痛点是经常处理的元素，而目前处理单体系统的方式使它们变得困难。
- en: What are the difficult points and the cans of worms? It's likely that there'll
    be some. Acknowledge that they exist and minimize their impact on other services.
    Note that they may be the same as the pain points, or not. The difficult points
    may be old systems that are very stable.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些困难点和棘手的问题？很可能会有一些。承认它们的存在，并将它们对其他服务的影响最小化。请注意，它们可能与痛点相同，也可能不同。困难点可能是非常稳定的旧系统。
- en: A couple of quick wins that will keep the momentum of the project going. Show
    the advantages to your teams and stakeholders quickly! This will also allow everyone
    to understand the new mode of operation you want to move to and start working
    that way.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些快速的成功案例将保持项目的动力。快速向您的团队和利益相关者展示优势！这也将使每个人都能够理解您想要转移到的新操作模式并开始以这种方式工作。
- en: An idea of the training that teams will require and what the new elements are
    that you want to introduce. Also, whether there are any skills lacking in your
    team – it's possible that you may plan to hire.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队需要的培训和您想要引入的新元素的想法。此外，您的团队是否缺乏任何技能——您可能计划招聘。
- en: Any team changes and ownership of the new services. It's important to consider
    feedback from the teams, so they can express their concerns over any oversights
    during the creation of the plan.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何团队变化和对新服务的所有权。重要的是要考虑团队的反馈，这样他们就可以表达他们对计划制定过程中任何疏忽的担忧。
- en: 'For our specific example, the resulting plan will be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的具体示例，结果计划如下：
- en: As a prerequisite, a load balancer will need to be in front of the operation.
    This will be responsible for channeling requests to the proper microservice. Then,
    changing the configuration of this element, we will be able to route the requests
    toward the old monolith or any new microservice.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为先决条件，负载均衡器需要位于操作的前面。这将负责将请求引导到适当的微服务。然后，更改这个元素的配置，我们将能够将请求路由到旧的单体或任何新的微服务。
- en: After that, the static files will be served through their own independent service,
    which is an easy change. A static web server is enough, though it will be deployed
    as an independent microservice. This project will help in understanding the move
    to Docker.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，静态文件将通过它们自己独立的服务提供，这是一个简单的更改。一个静态的Web服务器就足够了，尽管它将部署为一个独立的微服务。这个项目将有助于理解转移到Docker。
- en: 'The code for authentication will be replicated in a new service. It will use
    a RESTful API to log in and generate a session, and to log out. The service will
    be responsible for checking whether a user exists or not, as well as adding them
    and removing them:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证的代码将被复制到一个新的服务中。它将使用RESTful API进行登录和生成会话，以及注销。该服务将负责检查用户是否存在，以及添加和删除他们：
- en: The first idea was to check each session retrieved against the service, but,
    given that checking a session is a very common operation, we decided to generate
    a package, shared across the externally faced microservices, which will allow
    checking to see whether a session has been generated with our own service. This
    will be achieved by signing the session cryptographically and sharing the secret
    across our services. This module is expected not to change often, as it's a dependency
    for all the microservices. This makes the session one that does not need to be
    stored.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初的想法是针对每个检索到的会话进行检查，但是，鉴于检查会话是一个非常常见的操作，我们决定生成一个包，在外部面向的微服务之间共享，这将允许检查会话是否已经使用我们自己的服务生成。这将通过对会话进行加密签名并在我们的服务之间共享密钥来实现。预计这个模块不会经常更改，因为它是所有微服务的依赖项。这使得会话不需要存储。
- en: The Users Backend needs to be able to allow authentication using OAuth 2.0 schema,
    which will allow other external services, not based on web browsers, to authenticate
    and operate, for example, a mobile app.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户后端需要能够使用OAuth 2.0模式进行身份验证，这将允许其他不基于Web浏览器的外部服务进行身份验证和操作，例如移动应用程序。
- en: The Thoughts Backend will also be replicated as a RESTful API. This backend
    is quite simple at the moment, and it will include the search functionality.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thoughts后端也将作为RESTful API进行复制。这个后端目前非常简单，它将包括搜索功能。
- en: After both backends are available, the current monolith will be changed, from
    calling the database directly, to use the RESTful APIs of the backends. After
    this is successfully done, the old deployment will be replaced with a Docker build
    and added to the load balancer.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个后端都可用之后，当前的单体将被更改，从直接调用数据库到使用后端的RESTful API。成功完成后，旧的部署将被Docker构建替换，并添加到负载均衡器。
- en: The new API will be added externally to the load balancer and promoted as externally
    accessible. The company making the mobile app will then start integrating their
    clients.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的API将被添加到负载均衡器并作为外部可访问的推广。制作移动应用程序的公司将开始集成他们的客户端。
- en: 'Our new architecture schema is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新架构图如下：
- en: '![](img/4eebde2f-2787-40c3-855e-855bb045daf0.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4eebde2f-2787-40c3-855e-855bb045daf0.png)'
- en: Note that the HTML frontend will use the same APIs that are available externally.
    This will validate that the calls are useful, as we will use them first for our
    own client.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HTML前端将使用与外部可用的相同的API。这将验证调用是否有用，因为我们将首先为我们自己的客户使用它们。
- en: 'This action plan can have measurable times and a schedule. Some technology
    options can be taken as well—in our case, the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个行动计划可以有可衡量的时间和日程安排。还可以采取一些技术选项——在我们的情况下，如下：
- en: Each of the microservices will be deployed in its own Docker container ([https://www.docker.com/](https://www.docker.com/)).
    We will set up a Kubernetes cluster to orchestrate the different services.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务将部署在自己的Docker容器中（[https://www.docker.com/](https://www.docker.com/)）。我们将建立一个Kubernetes集群来编排不同的服务。
- en: We decided to make the new backend services in Flask ([https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/)),
    using Flask-RESTPlus ([https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/))
    to generate a well-documented RESTful app and connect to the existing database
    with SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)).
    These tools are Python, but take a lighter approach than Django.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们决定使用Flask（[https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/)）制作新的后端服务，使用Flask-RESTPlus（[https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/)）生成一个文档完备的RESTful应用，并使用SQLAlchemy（[https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)）连接到现有的数据库。这些工具都是Python编写的，但比Django更轻量级。
- en: The backend services will be served using the uWSGI server ([https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/)).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端服务将使用uWSGI服务器提供（[https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/)）。
- en: The static files will be served using NGINX ([https://www.nginx.com/](https://www.nginx.com/)).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态文件将使用NGINX提供（[https://www.nginx.com/](https://www.nginx.com/)）。
- en: NGINX will also be used as a load balancer to control the inputs.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX也将用作负载均衡器来控制输入。
- en: HTML frontend will continue to use Django ([https://www.djangoproject.com/](https://www.djangoproject.com/)).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML前端将继续使用Django ([https://www.djangoproject.com/](https://www.djangoproject.com/))。
- en: The teams are OK with proceeding with these tech stacks, and are looking forward
    to learning some new tricks!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 团队们同意继续使用这些技术栈，并期待学习一些新技巧！
- en: Executing the move
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行移动
- en: The final step is to execute the carefully devised plan to start moving from
    the outdated monolith to the new promised land of microservices!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是执行精心设计的计划，开始从过时的单体架构向新的微服务乐土迁移！
- en: But this stage of the trip can actually be the longest and most difficult—especially
    if we want to keep the services running and not have outages that interrupt our
    business.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个阶段可能是最长和最困难的，特别是如果我们希望保持服务运行而不会出现中断业务的情况。
- en: The single most important idea during this phase is **backward compatibility**.
    This means that the system is still behaving as the old system was from an external
    point of view. If we are able to behave like that, we can transparently change
    our internal operation while our customers are able to continue their operations
    uninterrupted.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段最重要的想法是**向后兼容**。这意味着系统在外部看来仍然像旧系统一样运行。如果我们能够做到这一点，我们就可以在客户继续无中断操作的情况下透明地改变我们的内部操作。
- en: That's obviously more easy to say than to do and sometimes has been referred
    to as starting a race with a Ford T and ending it with a Ferrari, changing every
    single piece of it without stopping. The good news is that software is so absolutely
    flexible and malleable that it is actually possible.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然更容易说而不易做，有时被称为用福特T型车开始比赛，最后用法拉利结束，而不停下来更换每一个零件。好消息是，软件是如此灵活和可塑的，实际上是可能的。
- en: Web services' best friend – the load balancer
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务的好朋友 - 负载均衡器
- en: A load balancer is a tool that allows distributing HTTP requests (or other kinds
    of network requests) among several backend resources.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器是一种工具，允许将HTTP请求（或其他类型的网络请求）分配给多个后端资源。
- en: 'The main operation of a load balancer is to allow traffic to be directed to
    a single address to be distributed among several identical backend servers that
    can spread the load and achieve better throughput. Typically, the traffic will
    be distributed through round-robin, that is, sequentially across all of them:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器的主要操作是允许将流量定向到单个地址，然后分发到几个相同的后端服务器，以分担负载并实现更好的吞吐量。通常，流量将通过轮询方式分发，即依次分配到所有服务器上：
- en: '![](img/a75b18b4-6475-4d39-b42c-3db3a565acf2.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a75b18b4-6475-4d39-b42c-3db3a565acf2.png)'
- en: 'First one worker, then the other, consecutively:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先一个工作进程，然后是另一个，依次类推：
- en: '![](img/67724773-c5dd-4193-8803-14b43fd27f9b.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67724773-c5dd-4193-8803-14b43fd27f9b.png)'
- en: That's the normal operation. But it can also be used to replace services. The
    load balancer ensures that each request goes cleanly to one worker or another.
    The services in the pool of workers can be different, so we can use it to cleanly
    make the transition between one version of the web service and another.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常的操作。但它也可以用来替换服务。负载均衡器确保每个请求都干净地发送到一个工作进程或另一个。工作进程池中的服务可以是不同的，因此我们可以使用它来干净地在Web服务的一个版本和另一个版本之间进行过渡。
- en: For our purposes, a group of old web services that are behind a load balancer
    can add one or more replacement services that are backward compatible, without
    interrupting the operation. The new service replacing the old one will be added
    in small numbers (maybe one or two workers) to split the traffic in a reasonable
    configuration, and ensure that everything is working as expected. After the verification,
    replace it completely by stopping sending new requests to the old services, draining
    them, and leaving only the new servers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，一个老的Web服务组在负载均衡器后面可以添加一个或多个向后兼容的替代服务，而不会中断操作。替换旧服务的新服务将以较小的数量（也许是一个或两个工作进程）添加到合理的配置中，确保一切都按预期工作。验证后，通过停止向旧服务发送新请求，排空它们，只留下新服务器来完全替换它。
- en: If done in a quick movement, like when deploying a new version of a service,
    this is called a rolling update, so the workers are replaced one by one.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以快速的方式进行，就像部署服务的新版本一样，这被称为滚动更新，因此工作进程逐个替换。
- en: But for migrating from the old monolith to the new microservices, a slower pace
    is wiser. A service can live for days in a split of 5%/95% so any unexpected error
    will appear only a twentieth of the time, before moving to 33/66, then 50/50,
    then 100% migrated.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对于从旧的单体架构迁移到新的微服务，更慢的步伐更明智。一个服务可以在5%/95%的分裂中生存几天，因此任何意外错误只会出现五分之一的时间，然后转移到33/66，然后50/50，然后100%迁移。
- en: A highly loaded system with good observability will be able to detect problems
    very quickly and may only need to wait minutes before proceeding. Most legacy
    systems will likely not fall into this category, though.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高负载的系统具有良好的可观测性，将能够非常快速地检测到问题，并且可能只需要等待几分钟就可以继续。但大多数传统系统可能不会属于这一类。
- en: Any web server capable of acting in reverse proxy mode, such as NGINX, is capable
    of working as a load balancer, but, for this task, probably the most complete
    option is HAProxy ([http://www.haproxy.org/](http://www.haproxy.org/)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 任何能够以反向代理模式运行的Web服务器，如NGINX，都可以作为负载均衡器工作，但是，对于这项任务，可能最完整的选择是HAProxy ([http://www.haproxy.org/](http://www.haproxy.org/))。
- en: HAProxy is specialized in acting as a load balancer in situations of high availability
    and high demand. It's very configurable and accepts traffic from HTTP to lower-level
    TCP connection if necessary. It also has a fantastic status page that will help
    to monitor the traffic going through it, as well as taking fast action such as
    disabling a failing worker.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy专门用于在高可用性和高需求的情况下充当负载均衡器。它非常灵活，并且在必要时接受从HTTP到更低级别的TCP连接的流量。它还有一个出色的状态页面，将帮助监视通过它的流量，并采取快速行动，如禁用失败的工作进程。
- en: Cloud providers such as AWS or Google also offer integrated load balancer products.
    They are very interesting to work from the edge of our network, as their stability
    makes them great, but they won't be as configurable and easy to integrate into
    your operating system as HAProxy. For example, the offering by Amazon Web Services
    is called **Elastic Load Balancing** (**ELB**)—[https://aws.amazon.com/elasticloadbalancing/](https://aws.amazon.com/elasticloadbalancing/).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 云提供商如AWS或Google也提供集成的负载均衡器产品。它们非常适合从网络边缘工作，因为它们的稳定性使它们非常出色，但它们不会像HAProxy那样易于配置和集成到您的操作系统中。例如，亚马逊网络服务提供的产品称为**弹性负载均衡**（**ELB**）-[https://aws.amazon.com/elasticloadbalancing/](https://aws.amazon.com/elasticloadbalancing/)。
- en: 'To migrate from a traditional server with an external IP referenced by DNS
    and put a load balancer in the front, you need to follow the following procedure:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要从具有由DNS引用的外部IP的传统服务器迁移到前端放置负载均衡器，您需要遵循以下程序：
- en: Create a new DNS to access the current system. This will allow you to refer
    to the old system independently when the transition is done.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的DNS来访问当前系统。这将允许您在过渡完成后独立地引用旧系统。
- en: Deploy your load balancer, configured to serve the traffic to your old system
    on the old DNS. This way, accessing either the load balancer or the old system,
    the request will ultimately be delivered in the same place. Create a DNS just
    for the load balancer, to allow referring specifically to it.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署负载均衡器，配置为为旧DNS上的旧系统提供流量。这样，无论是访问负载均衡器还是旧系统，请求最终都将在同一位置交付。为负载均衡器创建一个专门的DNS，以允许特别引用它。
- en: 'Test that sending a request to the load balancer directed to the host of the
    old DNS works as expected. You can send a request using the following `curl` command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试向负载均衡器发送请求，指向旧DNS的主机是否按预期工作。您可以使用以下`curl`命令发送请求：
- en: '[PRE0]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Change the DNS to point to the load balancer IP. Changing DNS registries takes
    time, as caches will be involved. During that time, no matter where the request
    is received, it will be processed in the same way. Leave this state for a day
    or two, to be totally sure that every possible cache is outdated and uses the
    new IP value.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改DNS指向负载均衡器IP。更改DNS注册表需要时间，因为会涉及缓存。在此期间，无论请求从何处接收，都将以相同的方式处理。保持这种状态一两天，以确保每个可能的缓存都已过时并使用新的IP值。
- en: The old IP is no longer in use. The server can (and should) be removed from
    the externally facing network, leaving only the load balancer to connect. Any
    request that needs to go to the old server can use its specific new DNS.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧IP不再使用。服务器可以（也应该）从外部网络中删除，只留下负载均衡器进行连接。需要访问旧服务器的任何请求都可以使用其特定的新DNS。
- en: Note that a load balancer like HAProxy can work with URL paths, meaning it can
    direct different paths to different microservices, something extremely useful
    in the migration from a monolith.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像HAProxy这样的负载均衡器可以使用URL路径工作，这意味着它可以将不同的路径指向不同的微服务，这在从单体架构迁移中非常有用。
- en: Because a load balancer is a single point of failure, you'll need to load balance
    your load balancer. The easiest way of doing it is creating several identical
    copies of HAProxy, as you'd do with any other web service, and adding a cloud
    provider load balancer on top.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于负载均衡器是单点故障，您需要对负载均衡器进行负载平衡。最简单的方法是创建几个相同的HAProxy副本，就像您对任何其他网络服务所做的那样，并在顶部添加一个云提供商负载均衡器。
- en: Because HAProxy is so versatile and fast, when properly configured, you can
    use it as a central point to redirect your requests—in true microservices fashion!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因为HAProxy如此多才多艺和快速，当正确配置时，您可以将其用作重定向请求的中心点-真正的微服务风格！
- en: Keeping the balance between new and old
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持新旧之间的平衡
- en: Plans are just plans, and a move to microservices is something to do for internal
    benefits, as it requires investment until external improvements can be shown in
    the shape of a better pace of innovation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 计划只是计划，而转移到微服务是为了内部利益而做的事情，因为它需要投资，直到外部改进可以以更好的创新速度的形式显示出来。
- en: This means that there'll be external pressure on the development team to add
    new features and requirements on top of the normal operation of the company. Even
    if we make this migration to move faster, there's an initial stage where you'll
    move slower. After all, changing things is difficult and you will need to overcome
    the initial inertia.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着开发团队将面临外部压力，要求在公司正常运营的基础上增加新功能和要求。即使我们进行这种迁移以加快速度，也会有一个初始阶段，您将移动得更慢。毕竟，改变事物是困难的，您需要克服最初的惯性。
- en: The migration will take three rough phases.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移将经历三个大致阶段。
- en: The pilot phase – setting up the first couple of microservices
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 试点阶段-设置前两个微服务
- en: 'A lot of infrastructures may be required before seeing the first deployment.
    This phase can be difficult to overcome and it''s the one that needs the biggest
    push. A good strategy for that is to put together a dedicated team of **enthusiasts**
    in the new microservice architecture and allow them to lead the development. They
    can be people that have been involved in the design, or maybe they like the new
    technologies or have worked with Docker and Kubernetes on side projects. Not every
    developer in your team will be excited about changing the way you operate, but
    some of them will be. Use their passion to start the project and take care of
    it in its initial steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到第一个部署之前可能需要很多基础设施。这个阶段可能很难克服，也是需要最大努力的阶段。一个好的策略是组建一个专门的新微服务架构团队，并允许他们领导开发。他们可以是参与设计的人，或者可能喜欢新技术或在副业项目中使用过Docker和Kubernetes的人。并不是你团队中的每个开发人员都会对改变运营方式感到兴奋，但其中一些人会。利用他们的热情开始项目，并在其初步阶段加以照顾：
- en: Start **small**—there'll be enough work to set up the infrastructure. The objective
    in this phase is to learn the tools, set up the platform, and adjust how to work
    with the new system. The aspect of teamwork and coordination is important and
    starting with a small team allows us to test a couple of approaches and iterate
    to be sure that they work.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从小开始** - 将有足够的工作来建立基础设施。这个阶段的目标是学习工具，建立平台，并调整如何使用新系统。团队合作和协调的方面很重要，从一个小团队开始可以让我们测试一些方法，并迭代以确保它们有效。'
- en: Choose **non-critical services**. At this stage, there are a lot of things that
    can go wrong. Be sure that a problem does not have a huge impact on operations
    or revenue.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**非关键服务**。在这个阶段，有很多事情可能会出错。确保问题不会对运营或收入产生巨大影响。
- en: Be sure to maintain **backward compatibility**. Substitute parts of the monolith
    with new services, but do not try to change the behavior at the same time, unless
    they are obvious bugs.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保保持**向后兼容性**。用新服务替换单体架构的部分，但不要试图同时改变行为，除非它们显然是错误。
- en: If there's a new feature that can be implemented as a new microservice, take
    the chance to go straight for the new approach, but be sure that the risk in extra
    time to deliver, or bugs, is worth it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个新功能可以作为新的微服务实现，那就抓住机会采用新方法，但要确保额外花费的时间或错误的风险是值得的。
- en: The consolidation phase – steady migration to microservices
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 巩固阶段 - 稳定迁移至微服务
- en: After the initial setup, other teams start working with the microservices approach.
    This expands the number of people dealing with containers and new deployments,
    so the initial team will need to give them support and training.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始设置之后，其他团队开始采用微服务方式工作。这扩大了处理容器和新部署的人数，因此最初的团队需要给予他们支持和培训。
- en: Training will be a critical part of the migration project—be sure to allocate
    enough time. While training events such as workshops and courses can be very useful
    to kickstart the process, constant support from experienced developers is invaluable.
    Appoint developers as a point of contact for questions, and tell them explicitly
    that their job is to ensure that they answer questions and help other developers.
    Make the supporting team meet up regularly to share concerns and improvements
    on the knowledge transfer.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 培训将是迁移项目的关键部分 - 确保分配足够的时间。虽然培训活动如研讨会和课程对于启动流程非常有用，但经验丰富的开发人员的持续支持是无价的。指定开发人员作为问题的联系点，并明确告诉他们，他们的工作是确保他们回答问题并帮助其他开发人员。让支持团队定期会面，分享对知识转移的关注和改进。
- en: 'Spreading knowledge is one of the main focuses in this phase, but there are
    another two: clarify and standardize the process and maintain an adequate pace
    of migrating the microservices.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 传播知识是这个阶段的主要重点之一，但还有另外两个：澄清和规范流程，以及保持迁移微服务的适当速度。
- en: Documenting standards will be helpful to give clarity and direction. Create
    checkpoints to make very explicit requirements across the board, so it's very
    clear when a microservice is ready for production. Create adequate channels for
    feedback, to be sure that the process can be improved.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 文档化标准将有助于提供清晰和方向。创建检查点，明确要求，以便非常清楚地知道何时一个微服务准备投入生产。创建适当的反馈渠道，以确保流程可以得到改进。
- en: During this time, the pace of migration can be increased because a lot of uncertainties
    and problems have already been ironed out; and because the development will be
    done in parallel. You should try to work on any new feature in a microservice
    way, though compromises may need to be taken. Be sure to keep the motivation and
    follow the plan.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段时间里，迁移的速度可以加快，因为很多不确定性和问题已经得到解决；并且开发将同时进行。尽管可能需要做出妥协，但一定要保持动力并遵循计划。
- en: The final phase – the microservices shop
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终阶段 - 微服务商店
- en: The monolith has been split, and the architecture is now microservices. There
    may be remains of the monolith that are deemed to have lower priority. Any new
    feature is implemented in the microservices style.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构已经拆分，架构现在是微服务。可能会有被认为优先级较低的单体架构残留部分。任何新功能都是以微服务方式实现的。
- en: While desirable, it may not be realistic to migrate absolutely everything from
    the monolith. Some parts may take a long time to migrate because they are especially
    difficult to migrate or they deal with strange corners of your company. If that's
    the case, at least clearly define the boundaries and limit their action radius.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理想情况下，从单体架构迁移绝对所有东西可能并不现实。有些部分可能需要很长时间才能迁移，因为它们特别难以迁移，或者涉及公司的奇怪角落。如果是这种情况，至少要清晰地定义边界并限制它们的行动范围。
- en: This phase is where the teams can take full ownership of their microservices
    and start making tests and innovations such as changing the programming language.
    Architecture can change as well, and microservices can be split or joined. Have
    clear boundaries defining what the agreed requirements for microservices are,
    but allow freedom within them.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段是团队可以完全拥有他们的微服务并开始进行测试和创新，比如改变编程语言。架构也可以改变，微服务可以分割或合并。明确界定微服务的约定要求，但在其中允许自由。
- en: Teams will be well-established and the process will run smoothly. Keep an eye
    on good ideas coming from different teams and be sure to spread the word.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 团队将会成熟稳定，流程会运行顺利。密切关注来自不同团队的好主意，并确保传播开来。
- en: Congratulations! You did it!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你做到了！
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw what the differences are between the traditional monolith
    approach and microservices architecture, and how microservices allow us to scale
    development across several teams and improve the delivery of quality software.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了传统单体架构方法和微服务架构之间的区别，以及微服务如何使我们能够跨多个团队扩展开发，并改善高质量软件的交付。
- en: 'We discussed the main challenges that are faced during a transition from a
    monolith to microservices and how to perform the change in different stages: analyzing
    the current system, measuring to validate our assumptions, creating a plan to
    split the monolith in a controlled way, and tactics to successfully perform the
    move.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了从单体架构到微服务架构过渡中所面临的主要挑战，以及如何在不同阶段执行变更的方法：分析当前系统，测量以验证我们的假设，制定分割单体架构的计划，并成功执行迁移的策略。
- en: Though this chapter was written in a technology-agnostic way, we've learned
    why Docker containers are a great way of implementing microservices, something
    that will be explored in the following chapters. You also now know how using a
    load balancer helps to maintain backward compatibility and deploy new services
    in an uninterrupted way.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章是以技术中立的方式编写的，但我们了解了为什么Docker容器是实现微服务的一种好方法，这将在接下来的章节中进行探讨。您现在也知道使用负载均衡器如何帮助保持向后兼容性并以不间断的方式部署新服务。
- en: You learned how to structure a plan to divide a monolith into smaller microservices.
    We described an example of such a process and an example of a monolith and how
    it will be divided. We'll see how to do this in detail in the following chapters.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何制定将单体架构分割为更小的微服务的计划。我们描述了这样一个过程的示例以及单体架构的示例以及如何分割它。我们将在接下来的章节中详细了解如何做到这一点。
- en: Questions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a monolith?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体架构是什么？
- en: What are some of the problems of monoliths?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体架构的一些问题是什么？
- en: Describe the microservice architecture.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述微服务架构。
- en: Which is the most important property of microservices?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务的最重要特性是什么？
- en: What are the main challenges to overcome in a migration from a monolith to microservices?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从单体架构迁移到微服务架构的主要挑战是什么？
- en: What are the basic steps to make such a migration?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这样迁移的基本步骤是什么？
- en: Describe how to use a load balancer to migrate from an old server to a new one
    without interrupting the system.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述如何使用负载均衡器从旧服务器迁移到新服务器而不中断系统。
- en: Further reading
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can learn more about systems architecture and how to divide and structure
    complex systems in the books *Architectural Patterns* ([https://www.packtpub.com/application-development/architectural-patterns](https://www.packtpub.com/application-development/architectural-patterns))
    and *Software Architect's Handbook* ([https://www.packtpub.com/application-development/software-architects-handbook](https://www.packtpub.com/application-development/software-architects-handbook))[.](https://prod.packtpub.com/application-development/architectural-patterns)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书籍《架构模式》（[https://www.packtpub.com/application-development/architectural-patterns](https://www.packtpub.com/application-development/architectural-patterns)）和《软件架构师手册》（[https://www.packtpub.com/application-development/software-architects-handbook](https://www.packtpub.com/application-development/software-architects-handbook)）中了解更多关于系统架构以及如何划分和构建复杂系统的知识。
