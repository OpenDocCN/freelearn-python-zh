- en: Python Debugging and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 调试与测试
- en: This last chapter will introduce two important software engineering topics—debugging
    and testing—that are important steps in the software development process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分将介绍两个重要的软件工程主题——调试和测试，它们是软件开发过程中的重要步骤。
- en: The first part of the chapter is focused on code debugging. A bug is a mistake
    in a program and can cause different problems that may be more or less serious
    depending on the situation. To encourage programmers to search for bugs, special
    software tools are used, called **debuggers***;* using these software tools, we
    have the ability to find errors or malfunctions within a program by taking advantage
    of specific debugging functions, an activity that exists precisely for identifying
    the portion of software affected by a bug.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分专注于代码调试。错误是程序中的错误，可能会引起不同的问题，这些问题可能严重程度不同，具体取决于情况。为了鼓励程序员寻找错误，使用了特殊的软件工具，称为
    **调试器**；使用这些软件工具，我们可以利用特定的调试功能，通过查找程序中的错误或故障来识别受错误影响的软件部分。
- en: In the second part, the main topic is *software testing: * it is a process used
    to identify deficiencies of *correctness*, *completeness*, and *reliability* in
    a software product that is being developed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，主要话题是 *软件测试*：它是一个用于识别正在开发的软件产品中 *正确性*、*完整性* 和 *可靠性* 缺陷的过程。
- en: In this context, we will, therefore, examine the three most important Python
    tools for debugging code in action. These are `winpdb-reborn`, which involves
    debugging with a visualization tool; `pdb`, the debugger from the Python standard
    library; and `rpdb`, where `r` stands for remote, meaning that it is code debugging
    from a remote machine*.*
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，我们将检查三个最重要的用于调试代码的 Python 工具的实际应用。这些是 `winpdb-reborn`，它涉及使用可视化工具进行调试；`pdb`，Python
    标准库中的调试器；以及 `rpdb`，其中 `r` 代表远程，意味着它是来自远程机器的代码调试*。
- en: 'Regarding software testing, we will examine the following tools: `unittest`
    and `nose`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于软件测试，我们将检查以下工具：`unittest` 和 `nose`。
- en: These are frameworks for developing unit tests, whereby the unit is the minimum
    component of a program within an independent operation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于开发单元测试的框架，其中单元是程序在独立操作中的最小组成部分。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is debugging?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是调试？
- en: What is software testing?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是软件测试？
- en: Debugging using Winpdb Reborn
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Winpdb Reborn 进行调试
- en: Interacting with `pdb`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `pdb` 交互
- en: Implementing `rpdb` for debugging
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `rpdb` 进行调试
- en: Dealing with `unittest`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 `unittest`
- en: Application testing using `nose`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `nose` 进行应用程序测试
- en: What is debugging?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是调试？
- en: The term *debugging* indicates the activity of identifying the portion of code
    in which one or more errors (bugs) are detected in software following its use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *调试* 指的是在软件使用后识别代码中一个或多个错误（错误）的活动。
- en: The error can be localized during the testing phase of the program; that is
    when it is still in the development phase and is not yet ready to be used by the
    end-user, or during the use of the program by the latter. After finding the error,
    the debugging phase ensues and identifies the software part in which the error
    lies, which is sometimes very complex.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可以在程序的测试阶段定位；也就是说，它仍然处于开发阶段，尚未准备好供最终用户使用，或者在使用程序时。在找到错误后，调试阶段随之而来，并识别出错误所在的软件部分，这有时可能非常复杂。
- en: Nowadays, this activity is supported by specific applications and debuggers,
    which show the execution to the programmer using step-by-step software instructions,
    allowing the viewing and analysis of the inputs and outputs of the program itself at
    the same time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这项活动得到了特定应用程序和调试器的支持，它们通过逐步的软件指令向程序员展示执行过程，同时允许查看和分析程序本身的输入和输出。
- en: Before these tools were available for the activity of identifying and correcting
    errors (and even now, in the absence of them), the simplest (but also least effective)
    techniques for code inspection were printing a file or printing the instructions
    on the screen that the program was executing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些工具可用于识别和纠正错误（甚至在它们不可用的情况下，现在也是如此）之前，代码检查的最简单（但也是最无效）的技术是打印文件或打印程序正在执行的屏幕指令。
- en: Debugging is one of the most important operations for the development of a program.
    It is often extremely difficult due to the complexity of the software that is
    being developed. It is even delicate due to the risk of introducing new errors
    or behaviors that are not in line with those desired in the attempt to correct
    those for which the activity was undertaken.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是程序开发中最重要的操作之一。由于正在开发的软件的复杂性，它通常非常困难。由于引入新的错误或不符合预期行为的风险，它甚至更加微妙，这些错误或行为是在尝试纠正那些导致活动进行的活动时出现的。
- en: 'Although the task of perfecting software using debugging is unique every time
    and constitutes a story in itself, some general principles are always applicable.
    In particular, in the context of software applications, it is possible to recognize
    the following four *debugging phases*, summarized in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用调试完善软件的任务每次都是独特的，并构成一个故事本身，但一些基本原则始终适用。特别是，在软件应用程序的背景下，可以识别以下四个调试阶段，如下面的图表所示：
- en: '![](img/16de8223-a2d3-4378-8677-70527c657df8.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16de8223-a2d3-4378-8677-70527c657df8.png)'
- en: Debugging phases
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 调试阶段
- en: Of course, Python offers the developer numerous debugging tools (see [https://wiki.python.org/moin/PythonDebuggingTools](https://wiki.python.org/moin/PythonDebuggingTools)
    for a list of Python debuggers). In this chapter, we will consider Winpdb Reborn, `rpdb`, and
    `pdb`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Python为开发者提供了许多调试工具（有关Python调试器的列表，请参阅[https://wiki.python.org/moin/PythonDebuggingTools](https://wiki.python.org/moin/PythonDebuggingTools)）。在本章中，我们将考虑Winpdb
    Reborn、`rpdb`和`pdb`。
- en: What is software testing?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是软件测试？
- en: As mentioned in the introduction of this chapter, software testing is a process
    used to identify deficiencies of correctness, completeness, and reliability in
    a software product that is being developed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言中所述，软件测试是用于识别正在开发的软件产品中正确性、完整性和可靠性缺陷的过程。
- en: With this activity, we, therefore, want to ensure the quality of the product
    by searching search for defects, or a sequence of instructions and procedures
    that, when executed with particular input data and in particular operating environments,
    generate malfunctions. A malfunction is a behavior of the software that is not
    expected by the user; therefore, it is different from the specifications and from
    the implicit or explicit requirements defined for such applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过搜索缺陷，或一系列指令和程序，当在特定的输入数据和特定的操作环境中执行时，会产生故障，我们想要确保产品的质量。故障是用户未预期的软件行为；因此，它与规格不同，也与为这些应用程序定义的隐含或显式要求不同。
- en: The purpose of testing is, therefore, to detect defects through malfunctions,
    so as to minimize the probability of such malfunctions occurring in the normal
    use of the software product. Testing cannot establish that a product functions
    correctly under all possible conditions of execution, but it can highlight defects
    under specific conditions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试的目的是通过故障来检测缺陷，以最大限度地减少在软件产品的正常使用中发生此类故障的概率。测试不能确定产品在所有可能的执行条件下都能正确运行，但它可以在特定条件下突出显示缺陷。
- en: In fact, given the impossibility of testing all the input combinations and the
    possible software and hardware environments in which the application may be operating,
    the probability of malfunctions cannot be reduced to zero, but it must be reduced
    to a minimum in order to be acceptable to the user.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，鉴于测试所有输入组合以及应用程序可能运行的软件和硬件环境的不可行性，无法将故障的概率降低到零，但必须将其降低到最小，以便用户可以接受。
- en: A particular type of software testing is the unit test (which we will learn
    about in this chapter), the purpose of which is to isolate each part of a program
    and show its correctness and completeness in the implementation. It also promptly
    brings out any defects so that they can be corrected easily before integration.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的软件测试是单元测试（我们将在本章中学习），其目的是隔离程序的一部分，并展示其实施中的正确性和完整性。它还可以及时揭示任何缺陷，以便在集成之前轻松纠正。
- en: Furthermore, the unit test lowers the costs—in terms of time and resources—of
    identifying and correcting defects, compared to achieving the same result by performing
    tests on the entire application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单元测试与对整个应用程序进行测试以实现相同结果相比，降低了识别和纠正缺陷的成本——在时间和资源方面。
- en: Debugging using Winpdb Reborn
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Winpdb Reborn进行调试
- en: '**Winpdb Reborn** is one of the most important and well-known Python debuggers.
    The major strength of this debugger is managing the debugging of thread-based
    code.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Winpdb Reborn**是Python中最重要的和最知名的调试器之一。这个调试器的最大优势是管理基于线程的代码的调试。'
- en: 'Winpdb Reborn is based on the RPDB2 debugger, while Winpdb is the GUI frontend
    to RPDB2 (see: [https://github.com/bluebird75/winpdb/blob/master/rpdb2.py](https://github.com/bluebird75/winpdb/blob/master/rpdb2.py)).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Winpdb Reborn基于RPDB2调试器，而Winpdb是RPDB2的GUI前端（见：[https://github.com/bluebird75/winpdb/blob/master/rpdb2.py](https://github.com/bluebird75/winpdb/blob/master/rpdb2.py)）。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The most commonly used way to install Winpdb Reborn (*release 2.0.0 dev5*)
    is via `pip`, so from your console, you need to type the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Winpdb Reborn（版本2.0.0 dev5）最常用的方法是使用`pip`，因此你需要在控制台中输入以下内容：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, if you have not already installed wxPython in your Python distribution,
    then you need to do so. wxPython is a cross-platform GUI toolkit for the Python
    language.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你还没有在你的Python发行版中安装wxPython，那么你需要这样做。wxPython是Python语言的跨平台GUI工具包。
- en: For Python Version 2.x, please refer to [https://sourceforge.net/projects/wxpython/files/wxPython/](https://sourceforge.net/projects/wxpython/files/wxPython/).
    For Python Version 3.x, wxPython is automatically installed as a dependency via
    `pip`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 2.x版本，请参阅[https://sourceforge.net/projects/wxpython/files/wxPython/](https://sourceforge.net/projects/wxpython/files/wxPython/)。对于Python
    3.x版本，wxPython会自动通过`pip`作为依赖项安装。
- en: In the next section, we will examine the main features and the graphical interface
    of Winpdb Reborn through a simple example of its use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过Winpdb Reborn的一个简单使用示例来检查其主要特性和图形界面。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Suppose we want to analyze the following Python application, which uses the
    threading library. An example that is very similar to the following example is
    already described in the *How to define a thread subclass* section of [Chapter
    2](c95be391-9558-4d2d-867e-96f61fbc5bbf.xhtml), *Thread-Based Parallelism*. In
    the following example, we use the `MyThreadClass` class to create and manage the
    execution of three threads. Here is the entire code to debug:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要分析以下使用线程库的Python应用程序，以下示例与第2章*基于线程的并行性*中*如何定义线程子类*部分描述的示例非常相似。在以下示例中，我们使用`MyThreadClass`类创建和管理三个线程的执行。以下是调试整个代码的完整代码：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s have a look at the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Open your console and type in the name of the folder containing the sample
    file, `winpdb_reborn_code_example.py`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的控制台，输入包含示例文件文件夹的名称，`winpdb_reborn_code_example.py`：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This works on macOS as well, but you have to use a framework build of Python.
    If you are using Winpdb Reborn with Anaconda, simply use `pythonw` instead of
    `python` to launch a Winpdb Reborn session.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这在macOS上同样适用，但你必须使用Python的框架构建。如果你使用Anaconda与Winpdb Reborn一起使用，只需用`pythonw`代替`python`来启动Winpdb
    Reborn会话。
- en: 'If the installation was successful, then the Winpdb Reborn GUI should open:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果安装成功，Winpdb Reborn的GUI应该会打开：
- en: '![](img/2fba89a5-4840-407f-8266-63aab36b85ba.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fba89a5-4840-407f-8266-63aab36b85ba.png)'
- en: Windpdb Reborn GUI
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Winpdb Reborn GUI
- en: 'As you can see in the following screenshot, we have inserted two breakpoints
    (using the Breakpoints menu), in both line 12 and line 23 (highlighted in red):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，我们在第12行和第23行（用红色突出显示）插入了两个断点（使用断点菜单）：
- en: '***![](img/5a2ccb87-7020-4948-8b20-80a3f393b972.png)***'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '***![](img/5a2ccb87-7020-4948-8b20-80a3f393b972.png)***'
- en: Code breakpoints
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码断点
- en: To learn about what a breakpoint is, move on to the *There's more...* section
    of this recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解断点是什么，请继续阅读本食谱的*更多内容...*部分。
- en: 'Remaining in the Source window, we place the mouse on line 23, where we have
    inserted the second breakpoint, and press the *F8* key, and then the *F5* key.
    The breakpoint allows the code to be executed up to the selected line. As you
    can see, Namespace indicates that we are considering the instance of the `MyThreadClass`
    class, with `thread#1` as an argument:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源代码窗口中，我们将鼠标放在第23行，我们在这里插入了第二个断点，然后按*F8*键，然后按*F5*键。断点允许代码执行到所选行。如你所见，命名空间表示我们正在考虑`MyThreadClass`类的实例，其中`thread#1`作为参数：
- en: '![](img/1a27af00-4468-449f-88ee-ee0c6b9bb6a4.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a27af00-4468-449f-88ee-ee0c6b9bb6a4.png)'
- en: Namespace
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Another fundamental feature of the debugger is the **Step Into** capability,
    which is the ability to inspect not only the code being debugged but also the
    library functions and the subroutines called for execution.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试器的另一个基本功能是**进入函数**的能力，这不仅可以检查正在调试的代码，还可以检查执行过程中调用的库函数和子程序。
- en: 'Before you start to delete the previous breakpoints (Menu | Breakpoints | Clear
    All), insert the new breakpoint on line 28:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始删除之前的断点（菜单 | 断点 | 清除所有）之前，在第28行插入新的断点：
- en: '![](img/b27f1402-d9ab-4924-bfa2-df62a894b50c.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b27f1402-d9ab-4924-bfa2-df62a894b50c.png)'
- en: Line 28 breakpoint
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行断点
- en: Finally, press the *F5* key and the application will be executed up to the breakpoint
    of line **28**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按*F5*键，应用程序将执行到第**28**行的断点。
- en: Then, press *F7*. Here, the source window no longer shows our sample code, but
    rather, the `threading` library we are using (see the next screenshot).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按*F7*键。在这里，源窗口不再显示我们的示例代码，而是显示我们正在使用的`threading`库（见下一张截图）。
- en: 'Therefore, the Breakpoints functionality, together with that of Step Into, not
    only allow the debugging of the code in question but also allow the inspection
    of all the library functions and any other subroutines used:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，断点功能以及进入函数功能不仅允许调试相关代码，还允许检查所有库函数和任何其他使用的子程序：
- en: '![](img/70c4308b-78e8-4633-8a9c-7435c583eb9c.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70c4308b-78e8-4633-8a9c-7435c583eb9c.png)'
- en: Line 28 Source window after executing Step Into
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 执行“进入函数”后的第28行源窗口
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this first example, we have become familiar with the Winpdb Reborn tool.
    This debugging environment (like every environment in general) allows you to stop
    program execution at precise points, inspect the execution stack, the contents
    of the variables, the status of the objects created, and much more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们已经熟悉了Winpdb Reborn工具。这个调试环境（就像一般环境一样）允许您在精确的点停止程序执行，检查执行堆栈、变量的内容、创建的对象的状态等等。
- en: 'To use Winpdb Reborn, just take a note of the following basic steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Winpdb Reborn，只需记住以下基本步骤：
- en: Set some breakpoints in the source code (the Source window).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源代码（源窗口）中设置一些断点。
- en: Inspect the functions through the Step Into function.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过“进入函数”来检查函数。
- en: View the status of the variables (the Namespace window) and the execution stack
    (the Stack window).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看变量状态（命名空间窗口）和执行堆栈（堆栈窗口）。
- en: The breakpoints are set by simply double-clicking the desired line with the
    left mouse button (you will see the selected line underlined in red). As a general
    warning, it is inadvisable to have multiple commands on the same line; otherwise,
    it will not be possible to associate breakpoints with some of them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地用左鼠标按钮双击所需的行来设置断点。作为一般警告，不建议在同一行上有多个命令；否则，将无法将这些断点与其中一些关联。
- en: When you use the right mouse button, you can selectively *disable breakpoints* without
    removing them (the red highlighting will disappear). To remove all the breakpoints
    instead, use the Clear All command, which is present in the Breakpoints menu, as
    mentioned previously.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用鼠标右键时，可以选择性地*禁用断点*而不删除它们（红色高亮将消失）。要删除所有断点，请使用之前提到的“清除所有”命令，该命令位于断点菜单中。
- en: 'When the first breakpoint is reached, it is good to keep an eye on the following
    views in the point of the program that is being analyzed:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到第一个断点时，最好关注正在分析程序中的以下视图：
- en: The Stack view shows the contents of the execution stack, where all the instances
    of various methods that are currently suspended appear. Typically, the one at
    the bottom of the stack is the main method and the one at the top of the stack
    is the method containing the breakpoint that has been reached.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈视图显示了执行堆栈的内容，其中显示了当前挂起的各种方法的实例。通常，堆栈底部的那个是主方法，而堆栈顶部的那个是包含已达到断点的那个方法。
- en: The Namespace view shows the local variables of the method and allows you to
    inspect the values. If the variables refer to objects, then it is possible to
    find out the unique identifier of the object and inspect its status.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间视图显示了方法中的局部变量，并允许您检查其值。如果变量引用对象，则可以找出对象的唯一标识符并检查其状态。
- en: In general, the execution of a program can be managed with different modes associated
    with the icon (or the *Fx* keys) present on the Winpdb Reborn command bar.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以使用与Winpdb Reborn命令栏上的图标（或*Fx*键）关联的不同模式来管理程序的执行。
- en: 'Finally, we''ll point out the following important execution methods:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将指出以下重要的执行方法：
- en: 'Step Into (*F7* key): This resumes the execution of the program one line at
    a time, and invocations of library methods or subroutines.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单步进入（*F7* 键）：这将逐行恢复程序的执行，包括库方法或子例程的调用。
- en: 'Return (*F12* key): This allows you to resume execution at the exact point
    where the Step Into function was activated.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回（*F12* 键）：这允许你在单步进入函数激活的确切点恢复执行。
- en: 'Next (*F6* key): This resumes the execution of the program one line at a time
    without stopping in any methods invoked.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一步（*F6* 键）：这将逐行恢复程序的执行，而不会在任何调用的方法中停止。
- en: Run to Line (*F8* key) This runs the program until it stops (waiting for new
    commands) at the indicated line.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行到行（*F8* 键）这将运行程序，直到它停止（等待新命令）在指定的行。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As you saw in the Winpdb Reborn GUI screenshot, the GUI is divided into five
    main windows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在Winpdb Reborn GUI截图中所看到的，GUI被分为五个主要窗口：
- en: Namespace: In this window, the names of entities are displayed, which are various
    variables and identifiers that are defined by the program and used in the source
    file.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间：在这个窗口中，显示实体名称，这些实体是程序定义并用于源文件中的各种变量和标识符。
- en: Threads: The current thread of the execution is shown, and it is characterized
    by the **TID**  (short for **T**hread **ID**entification) fields, the name of
    the thread, and the thread status.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程：显示执行中的当前线程，它由**TID**（**T**hread **ID**entification的缩写）字段、线程名称和线程状态来表征。
- en: Stack: This is where the execution stack of the program to be analyzed is shown.
    Stacks are also known as**Last In, First Out** (**LIFO**) data structures, as
    the last element inserted is the first to be removed. When a program calls a function,
    the called function must know how to return the calling control, so the return
    address of the calling function is entered into the program execution stack. The
    program execution stack also contains the memory for the local variables used
    at each invocation of the function.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈：这是要分析程序的执行栈显示的地方。栈也被称为**后进先出**（**LIFO**）数据结构，因为最后插入的元素是第一个被移除的。当程序调用一个函数时，被调用的函数必须知道如何返回调用控制，因此调用函数的返回地址被输入到程序执行栈中。程序执行栈还包含在函数每次调用时使用的局部变量的内存。
- en: Console: This is a command-line interface, thus allowing a textual interaction
    between the user and Winpdb Reborn.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台：这是一个命令行界面，因此允许用户与Winpdb Reborn进行文本交互。
- en: Source:This window shows the source code to debug. By scrolling along the lines
    of code, it is also possible to insert the breakpoints by pressing *F9 *once you
    are on the line of code of interest.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码：此窗口显示要调试的源代码。通过滚动代码行，也可以通过按*F9* 键在感兴趣的代码行上设置断点。
- en: The breakpoint is a very basic debugging tool. In fact, it allows you to run
    a program, but with the possibility of interrupting it at the desired point or
    when certain conditions occur, in order to acquire information on a running program***.***
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 断点是调试的一个非常基本的工具。实际上，它允许你运行程序，但具有在期望的点或当某些条件发生时中断程序的可能性，以便获取正在运行的程序的信息***。***
- en: 'There are multiple debugging strategies. Here, we list some of them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种调试策略。在此，我们列出其中一些：
- en: '**Reproduce the error**: Identify the input data that caused it.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重现错误**：确定导致错误的输入数据。'
- en: '**Simplify the error**: Identify the simplest possible data that caused it.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化错误**：确定导致错误的最简单可能的数据。'
- en: '**Divide and** **rule**: Perform the main proceeding in step-over mode until
    the anomaly occurs. The method that caused it is the last performed before it
    was possible to find the problem, so we can re-debug by doing step-in into that
    particular invocation, and proceeding again with step-over following the method''s
    instructions.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分而治之**：在单步执行模式下执行主要过程，直到出现异常。导致异常的方法是在找到问题之前最后执行的方法，因此我们可以通过单步进入该特定调用并按照方法说明再次执行来重新调试。'
- en: '**Proceed consciously**: During debugging, you constantly compare the current
    values of the variables with the ones you would expect.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有意识地执行**：在调试过程中，你不断地将变量的当前值与预期的值进行比较。'
- en: '**Check all the details**: Don''t overlook the details while debugging. It
    is best to make a note if you notice any discrepancies in the source code.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查所有细节**：在调试时不要忽略细节。如果你在源代码中注意到任何差异，最好做笔记。'
- en: '**Correct the errors**: Correct the error only if you are sure you have understood
    the problem well.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纠正错误**：只有在你确信你已经很好地理解了问题的情况下，才纠正错误。'
- en: See also
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: A good Winpdb Reborn tutorial can be found at [http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin](http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的 Winpdb Reborn 教程可以在 [http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin](http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin)
    找到。
- en: Interacting with pdb
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 pdb 交互
- en: '`pdb` is a Python module for performing interactive debugging.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb` 是一个用于执行交互式调试的 Python 模块。'
- en: 'The main features of `pdb` are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb` 的主要功能如下：'
- en: The use of breakpoints
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点的使用
- en: Interactive processing of the source code line by line
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐行交互处理源代码
- en: Stack frame analysis
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈帧分析
- en: The debugger is implemented through the `pdb` class. For this reason, it can
    be easily extended with new features.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是通过 `pdb` 类实现的。因此，它可以很容易地通过新功能进行扩展。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'No installation of `pdb` is required because it is part of the Python standard
    library. It can be launched with the following main use pattern:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要安装 `pdb`，因为它已经是 Python 标准库的一部分。它可以通过以下主要使用模式启动：
- en: Interacting with the command line
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与命令行交互
- en: Using the Python interpreter
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 解释器
- en: Inserting a directive (that is, a `pdb` statement) in the code to debug
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在要调试的代码中插入指令（即 `pdb` 语句）
- en: Interacting with the command line
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与命令行交互
- en: 'The simplest method is simply passing the name of your program as input. For
    example, for the `pdb_test.py` program, this is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是直接将程序的名称作为输入。例如，对于 `pdb_test.py` 程序，如下所示：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By executing from the command line, `pdb` loads the source file to be analyzed
    and stops its execution at the first statement found. In this case, the debug
    stops at line `1` (that is, at the definition of the`Pdb_test` class):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令行执行，`pdb` 加载要分析的源文件，并在找到的第一个语句处停止执行。在这种情况下，调试在行 `1`（即 `Pdb_test` 类的定义处）停止：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the Python interpreter
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 解释器
- en: 'The `pdb` module can be used in interactive mode by using the `run()` command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `run()` 命令以交互模式使用 `pdb` 模块：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the `run()` statement is from the debugger and will stop the execution
    before evaluating the first expression.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`run()` 语句来自调试器，将在评估第一个表达式之前停止执行。
- en: Inserting a directive in the code to debug
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中插入调试指令
- en: 'For a long-running process, where the problem occurs much later in the program
    execution, it would be much more convenient to start the debugger within the program
    using the `pdb set_trace()` directive:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间运行的过程，如果在程序执行中问题出现得较晚，那么在程序内部使用 `pdb set_trace()` 指令启动调试器会更加方便：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`set_trace()` can be called at any point in the program to debug. For example,
    it can be called based on conditions, exception handlers, or a specific branch
    of control instructions.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_trace()` 可以在任何程序点调用以进行调试。例如，可以根据条件、异常处理程序或特定的控制指令分支调用它。'
- en: 'In this case, the output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出如下：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code run stops, exactly after the `pdb.set_trace()` statement completes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码运行在 `pdb.set_trace()` 语句完成后停止。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To interact with `pdb`, you need to use its language, which allows you to move
    around the code, examine and modify the values of the variables, insert breakpoints,
    or move through stack calls:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 `pdb` 交互，你需要使用它的语言，这允许你在代码中移动，检查和修改变量的值，插入断点或遍历堆栈调用：
- en: 'Use the `where` command (or alternatively, the compact form, `w`) to view which
    line of code is running and the call stack. In this case, this is on line 17 in
    the `go()` method of the `pdb_test.py` module:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `where` 命令（或其紧凑形式 `w`）查看正在运行的代码行和调用栈。在这种情况下，这是在 `pdb_test.py` 模块的 `go()`
    方法中的第 17 行：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inspect the lines of code near the current location (indicated by an arrow)
    by using `list`. In the default mode, `11` rows are listed around the current
    one (five before and five after):'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `list` 检查当前位置（由箭头指示）附近的代码行。在默认模式下，`11` 行被列出在当前行周围（五行之前和五行之后）：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If `list` receives two parameters, then they are interpreted as the first and
    last lines to be displayed:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `list` 接收两个参数，则它们被解释为要显示的第一行和最后一行：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use `up` (or `u`) to move to older frames on the stack and `down` (or `d`)
    to move to more recent stack frames:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `up`（或 `u`）移动到堆栈上的旧帧，并使用 `down`（或 `d`）移动到更近的堆栈帧：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The debugging activity is carried out following the flow of the running program
    (tracing). In each line of code, the coder displays the operations performed by
    the instructions in real time and the values recorded in the variables. In this
    way, the developer can check that everything is working properly or identify the
    cause of a malfunction.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 调试活动是按照运行程序的流程（跟踪）进行的。在每一行代码中，编码者会实时显示指令执行的操作和记录在变量中的值。这样，开发者可以检查一切是否正常工作或确定故障的原因。
- en: Each programming language has its own debugger. However, there is no valid debugger
    for all programming languages because each language has its own syntax and grammar.
    The debugger executes the step-by-step source code. Therefore, the debugger must
    know the rules of the language, like the compiler.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有自己的调试器。然而，没有适用于所有编程语言的调试器，因为每种语言都有自己的语法和语法。调试器执行逐步源代码。因此，调试器必须了解语言的规则，就像编译器一样。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The most useful `pdb` commands, along with their short forms, to keep in mind
    while working with the Python debugger are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python调试器时，需要记住以下最有用的`pdb`命令及其简称：
- en: '| **Command** | **Action** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **操作** |'
- en: '| `args` | Prints the argument list of the current function |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `args` | 打印当前函数的参数列表 |'
- en: '| `break` | Creates a breakpoint (requires parameters)  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `break` | 创建一个断点（需要参数） |'
- en: '| `continue` | Continues program execution |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `continue` | 继续程序执行 |'
- en: '| `help` | Lists the commands (or help) for a command (as a parameter) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `help` | 列出命令（或帮助）的命令（作为参数） |'
- en: '| `jump` | Sets the next line to be executed |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `jump` | 设置下一个要执行的行 |'
- en: '| `list` | Prints the source code around the current line |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 打印当前行周围的源代码 |'
- en: '| `next` | Continues execution until the next line in the current function
    is reached or returns |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `next` | 继续执行直到当前函数的下一行或返回 |'
- en: '| `step` | Executes the current line, stopping at the first possible occasion
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `step` | 执行当前行，在第一个可能的机会停止 |'
- en: '| `pp` | Pretty-prints the value of the expression |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `pp` | 美化打印表达式的值 |'
- en: '| **`quit` **or** `exit`** | Aborts from `pdb` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **`quit`** 或 **`exit`** | 从`pdb`中退出 |'
- en: '| `return` | Continues execution until the current function returns |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `return` | 继续执行直到当前函数返回 |'
- en: See also
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: You can find out more about `pdb` by watching this interesting video tutorial: [https://www.youtube.com/watch?v=bZZTeKPRSLQ](https://www.youtube.com/watch?v=bZZTeKPRSLQ).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过观看这个有趣的视频教程了解更多关于`pdb`的信息：[https://www.youtube.com/watch?v=bZZTeKPRSLQ](https://www.youtube.com/watch?v=bZZTeKPRSLQ)。
- en: Implementing rpdb for debugging
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现rpdb进行调试
- en: In some cases, it is appropriate to debug code in a remote location; that is,
    a location that doesn't reside on the same machine in which we run the debugger.
    For this purpose, `rpdb` was developed. This is a wrapper on `pdb` that uses a
    TCP socket to communicate with the world outside.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，调试远程位置的代码是合适的；也就是说，该位置不在运行调试器的同一台机器上。为此，开发了`rpdb`。这是一个在`pdb`上包装的组件，它使用TCP套接字与外部世界通信。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The installation of `rpdb` first requires the main step of using `pip`. For
    Windows OS, just type the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpdb`的安装首先需要使用`pip`的主要步骤。对于Windows操作系统，只需输入以下内容：'
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then, you need to be sure that you have a working **telnet** client enabled
    on your machine. In Windows 10, if you open Command Prompt and type `telnet`,
    then the OS will respond with an error as it is not present by default in the
    installation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要确保你的机器上有一个启用的**telnet**客户端。在Windows 10中，如果你打开命令提示符并输入`telnet`，那么操作系统会响应一个错误，因为它默认没有安装。
- en: 'Let''s see how to install it with a few simple steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过几个简单的步骤来安装它：
- en: Open Command Prompt in administrator mode.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以管理员模式打开命令提示符。
- en: Click on the Cortana button and type `cmd`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Cortana按钮并输入`cmd`。
- en: In the list that appears, right-click on the Command Prompt item and select
    Run as Administrator.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的列表中，右键单击“命令提示符”项，然后选择“以管理员身份运行”。
- en: 'Then, when running Command Prompt as an administrator, type the following command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在以管理员身份运行命令提示符时，输入以下命令：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Wait a few minutes until the installation finishes. If the process is successful,
    then you will see this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几分钟，直到安装完成。如果过程成功，那么你会看到以下内容：
- en: '![](img/92df2ec3-4eb3-43be-a8a0-f6351d39f5de.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92df2ec3-4eb3-43be-a8a0-f6351d39f5de.png)'
- en: 'Now, you can use telnet directly from the prompt. By typing `telnet`, the following
    window should appear:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以直接从提示符使用telnet。通过输入`telnet`，应该会出现以下窗口：
- en: '![](img/1e25886f-dca3-41a6-8e2a-efaf80ff5b05.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e25886f-dca3-41a6-8e2a-efaf80ff5b05.png)'
- en: In the following example, let's see how to run a remote debug with `rpdb`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，让我们看看如何使用`rpdb`进行远程调试。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s perform the following steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Consider the following sample code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下示例代码：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To use `rpdb`, you need to insert the following lines of code (just after the
    `import threading` statement). In fact, these three lines of code enable the use
    of `rpdb` via a remote client on port `4444` with an IP address of `127.0.0.1`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`rpdb`，你需要插入以下代码行（在`import threading`语句之后）。实际上，这三行代码通过远程客户端在端口`4444`和IP地址`127.0.0.1`上启用`rpdb`的使用：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run the sample code after inserting these three lines of code that enable
    the use of `rpdb`, then you should see the following message on Python Command
    Prompt:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在这三行代码之后运行示例代码，这些代码启用了`rpdb`的使用，那么你应该在Python命令提示符上看到以下消息：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, you can switch to debug the sample code remotely by making the following
    telnet connection:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以通过以下telnet连接远程切换以调试示例代码：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following window should open:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该打开以下窗口：
- en: '![](img/9f1b0949-3689-4ca7-9cd9-502cdaf6a028.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f1b0949-3689-4ca7-9cd9-502cdaf6a028.png)'
- en: 'In the sample code, note the arrow in line 7\. The code is not running, it
    is just waiting for an instruction to execute:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例代码中，注意第`7`行的箭头。代码没有运行，它只是在等待执行指令：
- en: '![](img/1aa03050-e016-4563-94a9-b3418cef7ef4.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1aa03050-e016-4563-94a9-b3418cef7ef4.png)'
- en: 'For example, here, we execute the code and type the `next` statement repeatedly:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，在这里，我们执行代码并反复输入`next`语句：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once the program is finished, you can still run a new debug section. Now, let's
    see how `rpdp` works in the next section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序完成，你仍然可以运行新的调试部分。现在，让我们看看下一节中`rpdp`是如何工作的。
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this section, we'll see how to simply move through the code by using the
    `next` statement, which continues execution until the next line in the current
    function is reached or returned.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何通过使用`next`语句简单地移动到代码中，该语句将继续执行直到当前函数的下一行或返回。
- en: 'To use `rpdb`, follow these steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`rpdb`，请按照以下步骤操作：
- en: 'Import the relevant `rpdb` library:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的`rpdb`库：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Set the `debugger` parameter, which specifies the telnet port to connect to
    in order to run the debugger:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`debugger`参数，该参数指定连接以运行调试器的telnet端口：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Call the  `set_trace()`  directive, which makes it possible to enter into debugging
    mode:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`set_trace()`指令，这使得可以进入调试模式：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In our case, we placed the `set_trace()` directive immediately after the `debugger`
    instance. In reality, we can place it anywhere in the code; for example, if conditions
    are satisfied, or within a section managed by an exception.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们在`debugger`实例之后立即放置了`set_trace()`指令。实际上，我们可以在代码的任何位置放置它；例如，如果条件满足，或者在由异常管理的部分内。
- en: 'The second step, instead, consists of opening Command Prompt and launching
    `telnet` by setting the same port value specified in the `debugger` parameter
    definition within the sample code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，相反，是在命令提示符下打开，通过设置与示例代码中`debugger`参数定义中指定的相同端口号来启动`telnet`：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is possible to interact with the `rpdb` debugger by using a small command
    language that allows movement between calls to the stack, to examine and to modify
    the values of the variables and control the way in which the debugger executes
    its own program.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用一个小型命令语言与`rpdb`调试器进行交互，该语言允许在堆栈调用之间移动，检查并修改变量的值，并控制调试器执行其程序的方式。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The list of commands with which you can interact with in `rpdb` can be displayed
    by typing the `help` command from the `Pdb` prompt:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`Pdb`提示符下输入`help`命令来显示你可以在`rpdb`中与之交互的命令列表：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Among the most useful commands, this is how we insert the breakpoints in the
    code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在最有用的命令中，这就是我们如何在代码中插入断点的方式：
- en: 'Type `b` and the line numberto set a breakpoint. Here, a breakpoint is set
    in lines `5` and `10`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`b`和行号来设置断点。在这里，断点设置在第`5`行和第`10`行：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is sufficient to type the `b` command to display the list of breakpoints
    implemented:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需输入`b`命令即可显示已实现的断点列表：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At each new breakpoint added, a numeric identifier is assigned. These identifiers
    are used to enable, disable, and interactively remove breakpoints. To disable
    a breakpoint, use the `disable` command, which tells the debugger not to stop
    when that line is reached. The breakpoint is not forgotten but is ignored.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每添加一个新的断点，都会分配一个数字标识符。这些标识符用于启用、禁用和交互式地删除断点。要禁用断点，请使用`disable`命令，该命令告诉调试器在到达该行时不要停止。断点不会被遗忘，但会被忽略。
- en: See also
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can find a lot of information on `pdb`, and then on `rpdb`, on this site:
    [https://github.com/spiside/pdb-tutorial](https://github.com/spiside/pdb-tutorial).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本网站上找到关于`pdb`和`rpdb`的大量信息：[https://github.com/spiside/pdb-tutorial](https://github.com/spiside/pdb-tutorial)。
- en: 'In the next two sections, we will look at some Python tools that are used for
    the implementation of unit tests:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将探讨一些用于实现单元测试的Python工具：
- en: '`unittest`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest`'
- en: '`nose`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nose`'
- en: Dealing with unittest
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理unittest
- en: The `unittest` module is provided with the standard Python library. It has an
    extensive set of tools and procedures for performing unit tests. In this section,
    we'll briefly see how the `unittest` module works.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块由标准Python库提供。它提供了一套广泛的工具和过程，用于执行单元测试。在本节中，我们将简要介绍`unittest`模块的工作原理。'
- en: 'A unit test consists of two parts:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试由两部分组成：
- en: The code to manage the so-called *test system*
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理所谓的*测试系统*的代码
- en: The test itself
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试本身
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The simplest `unittest` module can be obtained via the `TestCase` subclass,
    to which the appropriate methods must be rewritten or added.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的`unittest`模块可以通过`TestCase`子类获得，必须重写或添加适当的方法。
- en: 'A simple `unittest` module can be composed as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`unittest`模块可以组成如下：
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To run the `unittest` module, you need to include `unittest.main ()`, while
    we have a single method, `test()`, which fails if `True` is ever `False`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`unittest`模块，你需要包含`unittest.main()`，而我们有单个方法`test()`，如果`True`是`False`，则测试失败。
- en: 'By executing the preceding example, you get the following result:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行前面的示例，你得到以下结果：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The test was successful, thus giving the result, `OK`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 测试成功，因此结果是`OK`。
- en: In the following section, we go into more detail about how the `unittest` module
    works. In particular, we want to study what the possible outcomes of a unit test are.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地介绍`unittest`模块的工作原理。特别是，我们想研究单元测试可能的结果。
- en: How to do it...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how we can characterize the results of a test with this example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个例子看看我们如何用这个例子来描述测试结果：
- en: 'Import the relevant module:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关模块：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define the `outcomesTest` class, which has the `TestCase` subclass as its argument:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`outcomesTest`类，其参数为`TestCase`子类：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first method we define is `testPass`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义的第一个方法是`testPass`：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the `TestFail` method:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`TestFail`方法：
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we have the `TestError` method:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有`TestError`方法：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we have the `main` function, with which we recall our procedure:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`main`函数，通过它我们回忆我们的程序：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, the possible outcomes of a unit test by `unittest` are shown.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，展示了`unittest`单元测试的可能结果。
- en: 'The possible outcomes are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的结果如下：
- en: '`ERROR`: The test raises an exception other than `AssertionError`. There is
    no explicit way to pass a test, so the test status depends on the presence (or
    absence) of an exception.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR`: 测试抛出除`AssertionError`之外的异常。没有明确的方法可以通过测试，因此测试状态取决于异常的存在（或不存在）。'
- en: '`FAILED`: The test is not passed and an `AssertionError` exception is raised.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAILED`: 测试未通过，并抛出`AssertionError`异常。'
- en: '`OK`: The test is passed.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OK`: 测试通过。'
- en: 'The output is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Most tests affirm the truth of a condition. There are different ways of writing
    tests that verify a truth, depending on the perspective of the author of the test
    and whether the desired result of the code is verified. If the code produces a
    value that can be evaluated as true, then the `failUnless ()` and `assertTrue ()`
    methods should be used. If the code produces a false value, then it makes more
    sense to use the `failIf ()` and `assertFalse ()` methods:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试确认条件的真实性。根据测试作者的视角以及是否验证了代码期望的结果，验证真实性的测试有不同的编写方式。如果代码产生一个可以评估为真的值，那么应该使用`failUnless()`和`assertTrue()`方法。如果代码产生一个假值，那么使用`failIf()`和`assertFalse()`方法则更有意义：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There's more...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: As mentioned previously, if a test raises an exception other than `AssertionError`,
    then it is treated as an error. This is very useful for discovering errors that
    occur while you are editing code for which a matched test already exists.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果测试抛出了除`AssertionError`之外的异常，则被视为错误。这对于发现你在编辑已经存在匹配测试的代码时发生的错误非常有用。
- en: 'There are circumstances, however, in which you would want to run a test to
    verify that certain code actually produces an exception. For example, in cases
    when an invalid value is passed as an attribute of an object. In such cases, `failUnlessRaises()`
    makes the code clearer than capturing the exception in your code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你可能想要运行一个测试来验证某些代码实际上是否产生了异常。例如，当将无效值作为对象的属性传递时。在这种情况下，`failUnlessRaises()`使代码比在代码中捕获异常更清晰：
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The results for both are the same. However, the result for the second test,
    which uses `failUnlessRaises()`, is shorter:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试的结果都是相同的。然而，第二个测试的结果，使用`failUnlessRaises()`，更短：
- en: '[PRE38]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: More information on Python testing can be found at [https://realpython.com/python-testing/](https://realpython.com/python-testing/).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Python测试的信息可以在[https://realpython.com/python-testing/](https://realpython.com/python-testing/)找到。
- en: Application testing using nose
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nose进行应用程序测试
- en: '`nose` is an important Python module for defining unit tests. It allows us
    to write simple test functions using subclasses of `unittest.TestCase` but also,
    classes of tests that are *not subclasse*s of `unittest.TestCase`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`是一个重要的Python模块，用于定义单元测试。它允许我们使用`unittest.TestCase`的子类编写简单的测试函数，也可以编写不是`unittest.TestCase`子类的测试类。'
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install `nose` by using `pip`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`安装`nose`：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The source package can be downloaded and installed at [https://pypi.org/project/nose/](https://pypi.org/project/nose/)
    by following these steps:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤在[https://pypi.org/project/nose/](https://pypi.org/project/nose/)下载并安装源包：
- en: Unzip the source package.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压源包。
- en: '`cd` to the new directory.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到新目录。
- en: 'Then, enter the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'One of the strengths of `nose` is automatically collecting tests from the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`的一个优点是自动从以下内容收集测试：'
- en: Python source files
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python源文件
- en: Directories and packages found in the working directory
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作目录中找到的目录和包
- en: 'To specify which tests to run, pass the relevant test names on the command
    line:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定要运行的测试，请在命令行上传递相关的测试名称：
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The test names specified may be file or module names, and may optionally indicate
    the test case to run by separating the module or filename from the test case name
    with a colon. Filenames may be relative or absolute.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的测试名称可以是文件或模块名称，并且可以通过用冒号分隔模块或文件名和测试用例名称来可选地指示要运行的测试用例。文件名可以是相对的或绝对的。
- en: 'Some examples are as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You may also change the working directory, where `nose` looks for tests, by
    using the `-w` switch:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`-w`开关更改工作目录，其中`nose`查找测试：
- en: '[PRE43]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note, however, that support for multiple `-w` arguments is now deprecated and
    will be removed in a future release. However, it is possible to get the same behavior
    by specifying the target directories without the `-w` switch:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，现在对多个`-w`参数的支持已被弃用，并将在未来版本中删除。但是，可以通过指定不带`-w`开关的目标目录来获得相同的行为：
- en: '[PRE44]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Further customization of test selection and loading is possible through the
    use of plugins.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用插件进一步自定义测试选择和加载。
- en: The test result output is identical to that of `unittest`, except for the additional
    features, such as error classes, and plugin-supplied features such as output capture
    and assert introspection.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果输出与`unittest`相同，除了额外的功能，如错误类，以及插件提供的功能，如输出捕获和断言内省。
- en: In the next section, we look at testing a class using `nose`*.*
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用`nose`*.*进行类测试。
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the steps that follow:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: Import the relevant `nose.tools`*:*
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的`nose.tools`*：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, set the `TestSuite` class. Here,the methods of the class are tested by
    the `eq_` function:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置`TestSuite`类。在这里，类的方程序通过`eq_`函数进行测试：
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A unit test can be developed independently by the developer, but it is good
    practice to have a standard product such as `unittest` and adhere to a common
    test practice.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以由开发者独立开发，但遵循一个标准产品，如`unittest`，并遵守常见的测试实践是一个好的做法。
- en: 'As you can see from the following example, the test method was set by using
    the `eq_` function. This is similar to `assertEquals` by `unittest`, which verifies
    that the two parameters are equal:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下示例中可以看到，测试方法是通过使用`eq_`函数设置的。这与`unittest`的`assertEquals`类似，它验证两个参数是否相等：
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This testing practice, despite good in intentions, has obvious limitations,
    such as not being able to be repeated over time (for example, when a software
    module changes) for so-called **regression tests**.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试实践，尽管初衷良好，但存在明显的局限性，例如不能随着时间的推移重复进行（例如，当软件模块发生变化时）所谓的**回归测试**。
- en: 'Here is the output:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In general, testing is not able to identify all the errors in a program and
    the same is true for unit testing, which, by analyzing individual units by definition,
    cannot identify integration errors, performance problems, and other system-related
    problems. In general, unit testing is more effective when used in conjunction
    with other software testing techniques.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试无法识别程序中的所有错误，单元测试也是如此，因为根据定义，单元测试通过分析单个单元无法识别集成错误、性能问题和其他系统相关的问题。通常，当与其他软件测试技术结合使用时，单元测试更有效。
- en: Like any form of testing, even unit testing cannot certify the absence of errors,
    but can only *highlight* their presence.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何测试形式一样，即使是单元测试也不能证明错误的不存在，但只能*突出*错误的存在。
- en: There's more...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Software testing is a combinatorial mathematics problem. For example, each Boolean
    test requires at least two tests, one for the true condition and one for the false
    condition. It can be shown that, for each functional code line, three to five
    lines of code are required for a test. It is therefore unrealistic to test all
    possible input combinations of any non-trivial code without a dedicated test case
    generation tool.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是一个组合数学问题。例如，每个布尔测试至少需要两个测试，一个用于真条件，一个用于假条件。可以证明，对于每行功能代码，测试至少需要三到五行代码。因此，在没有专门的测试用例生成工具的情况下，测试任何非平凡代码的所有可能的输入组合是不切实际的。
- en: To achieve the desired benefits from a unit test, a strict sense of discipline
    is required throughout the development process. It is essential to keep track
    not only of the tests that have been developed and performed but also of all the
    changes made to the functional code of the unit in question and all the other
    units. The use of a version control system is essential. If a later version of
    a unit fails a test that it previously passed, then a version control system allow
    you to highlight the code changes that have occurred in the meantime.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要从单元测试中获得预期的收益，在整个开发过程中都需要有严格的纪律感。不仅要跟踪已开发和执行的测试，还要跟踪对所讨论单元的功能代码以及所有其他单元所做的所有更改。使用版本控制系统是必不可少的。如果一个单元的后续版本在之前通过测试时失败了，那么版本控制系统可以帮助你突出显示在此期间发生的代码更改。
- en: See also
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: A valid tutorial on `nose` is available at [https://nose.readthedocs.io/en/latest/index.html](https://nose.readthedocs.io/en/latest/index.html).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://nose.readthedocs.io/en/latest/index.html](https://nose.readthedocs.io/en/latest/index.html)有一个有效的`nose`教程。
