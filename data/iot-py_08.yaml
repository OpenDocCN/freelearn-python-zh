- en: Chapter 8. Displaying Information and Performing Actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 显示信息并执行操作
- en: 'In this chapter, we will work with a variety of breakout boards and an actuator
    to display data and perform actions by writing a Python code. We shall:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用各种扩展板和执行器，通过编写Python代码来显示数据和执行操作。我们将：
- en: Understand LCD displays and their connection types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解LCD显示屏及其连接类型
- en: Learn the most important things we must consider when choosing LCD displays
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习在选择LCD显示屏时必须考虑的最重要事项
- en: Take advantage of the `upm` library with LCD displays and actuators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用LCD显示屏和执行器利用`upm`库
- en: Use an LCD display with an RGB backlight that works with the I²C bus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与I²C总线兼容的RGB背光LCD显示屏
- en: Display and update text in a 16x2 LCD screen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在16x2 LCD屏幕上显示和更新文本
- en: Use an OLED display that works with the I²C bus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与I²C总线兼容的OLED显示屏
- en: Display and update text on a 96-by-96 dot matrix OLED display
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在96x96点阵OLED显示屏上显示和更新文本
- en: Wire a standard servo motor to be controlled with PWM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标准伺服电机连接到PWM进行控制
- en: Display a value with a servo motor and a shaft
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用伺服电机和轴显示值
- en: Understanding LCD displays and their connection types
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解LCD显示屏及其连接类型
- en: Sometimes, our IoT device has to provide information to the user with any device
    connected to an Intel Galileo Gen 2 board. We can use different kinds of electronic
    components, shields, or breakout boards to achieve this goal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的物联网设备必须通过连接到英特尔Galileo Gen 2板的任何设备向用户提供信息。我们可以使用不同类型的电子组件、屏蔽或扩展板来实现这一目标。
- en: For example, we can use simple LEDs to provide information that we can represent
    with colors. For example, a red LED that turns on can indicate that our temperature
    sensor connected to the board has detected that the ambient temperature is higher
    than 80 degrees Fahrenheit (ºF) or 26.66 degrees Celsius (ºC). A blue LED that
    turns on can indicate that our temperature sensor had detected that the ambient
    temperature is lower than 40 degrees Fahrenheit (ºF) or 4.44 degrees Celsius (ºC).
    A red LED turned on can indicate that the temperature is between these two values.
    These three LEDs allow us to provide valuable information to the user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用简单的LED灯来提供可以用颜色表示的信息。例如，一个亮起的红色LED可以表示连接到板上的温度传感器检测到环境温度高于80华氏度（ºF）或26.66摄氏度（ºC）。一个亮起的蓝色LED可以表示我们的温度传感器检测到环境温度低于40华氏度（ºF）或4.44摄氏度（ºC）。一个亮起的红色LED可以表示温度介于这两个值之间。这三个LED灯使我们能够向用户提供有价值的信息。
- en: We can also achieve the same goal using a single RGB LED and work with **pulse
    width modulation** (**PWM**) to change its color based on the measured ambient
    temperature value, as we learned in [Chapter 4](ch04.html "Chapter 4. Working
    with a RESTful API and Pulse Width Modulation"), *Working with a RESTful API and
    Pulse Width Modulation*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用单个RGB LED并利用**脉冲宽度调制**（**PWM**）来根据测量的环境温度值改变其颜色，正如我们在[第4章](ch04.html
    "第4章. 使用RESTful API和脉冲宽度调制")中学习的，*使用RESTful API和脉冲宽度调制*。
- en: However, sometimes colors aren't enough to provide a detailed and accurate information
    to the user. For example, sometimes we want to display the humidity level with
    a percentage value and a few LEDs aren't enough to represent numbers from 0 to
    100%. If we want to be able to display a 1% step, we would require 100 LEDs. We
    don't have 100 GPIO pins, and therefore, we would require a shield or breakout
    board with 100 LEDs and a digital interface such as an I²C bus to allow us to
    send commands indicating the number of LEDs that we want to be turned on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时颜色不足以向用户提供详细和准确的信息。例如，有时我们希望用百分比值显示湿度水平，而几个LED灯不足以表示从0到100%的数字。如果我们想要能够显示1%的步进值，我们就需要100个LED灯。我们没有100个GPIO引脚，因此我们需要一个带有100个LED灯和数字接口（如I²C总线）的屏蔽或扩展板，以便我们可以发送指示要打开的LED灯数量的命令。
- en: In these cases, an LCD screen that allows us to print a specific number of characters
    might be an appropriate solution. For example, on an LCD screen that allows us
    to display 16 characters per line, with 2 lines of 16 characters, known as a 16x2
    LCD module, we can display the temperature in the first line and the humidity
    level in the second line. The following table shows an example of each line with
    the text and the values considering that we have 16 columns and 2 rows for the
    characters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，一个允许我们打印特定数量字符的液晶屏幕可能是一个合适的解决方案。例如，在一个允许我们每行显示16个字符的液晶屏幕上，有2行16个字符，称为16x2液晶模块，我们可以在第一行显示温度，在第二行显示湿度水平。以下表格显示了每一行文本和值的示例，考虑到我们有16列和2行字符。
- en: '| T | e | m | p | . |   |   |   |   | 4 | 0 | . | 2 | F |   |   |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| T | e | m | p | . |   |   |   |   | 4 | 0 | . | 2 | F |   |   |'
- en: '| H | u | m | i | d | i | t | y |   |   |   | 8 | 0 | % |   |   |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| H | u | m | i | d | i | t | y |   |   |   | 8 | 0 | % |   |   |'
- en: 'The 16x2 LCD module provides a clear description for each value, a floating
    point value and a unit of measure. Thus, we will use a 16x2 LCD module for our
    example. The following picture shows an example of the location of each character
    in a 16x2 LCD screen:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 16x2液晶模块为每个值提供清晰的描述，包括浮点值和度量单位。因此，我们将使用16x2液晶模块作为示例。以下图片显示了16x2液晶屏幕中每个字符位置的示例：
- en: '![Understanding LCD displays and their connection types](img/B05042_08_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![理解液晶显示器及其连接类型](img/B05042_08_01.jpg)'
- en: There are LCD modules with different features and we must consider a lot of
    the things we learned when we analyzed sensors in [Chapter 7](ch07.html "Chapter 7. Retrieving
    Data from the Real World with Sensors"), *Retrieving Data from the Real World
    with Sensors*. The following list enumerates the most important things that we
    must consider when we select an LCD module and their description. As we analyzed
    many of these things when we learned about sensors, we won't repeat the descriptions
    for the common items.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同功能的液晶模块，我们必须考虑我们在[第7章](ch07.html "第7章. 使用传感器从现实世界获取数据")“使用传感器从现实世界获取数据”中分析传感器时学到的大量内容。以下列表列举了在选择液晶模块时我们必须考虑的最重要的因素及其描述。由于我们在学习传感器时分析了这些内容中的许多，因此我们不会重复常见项目的描述。
- en: '**Compatibility with Intel Galileo Gen 2 board and the voltage supply that
    we are using (5V or 3.3V)**.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与英特尔Galileo Gen 2板和我们所使用的电压供应（5V或3.3V）的兼容性**。'
- en: '**Power consumption**.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功耗**。'
- en: '**Connection type**: Some LCD displays consume too many pins, and therefore,
    it is very important to check all the pins that they require. The most common
    connection types for LCD displays are the I²C bus, the SPI bus, and the UART port.
    However, some LCD displays require a bus or port combined with additional GPIO
    pins.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接类型**：一些液晶显示器消耗太多的引脚，因此，检查它们所需的全部引脚非常重要。液晶显示器最常见的连接类型是I²C总线、SPI总线和UART端口。然而，一些液晶显示器需要总线或端口与额外的GPIO引脚结合使用。'
- en: '**Operating range and special environment requirements**.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作范围和特殊环境要求**。'
- en: '**Dimensions**: LCD displays come with different dimensions. Sometimes only
    specific dimensions are suitable for our project.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸**：液晶显示器有不同的尺寸。有时只有特定的尺寸适合我们的项目。'
- en: '**Number of columns and rows**: Based on the text we have to display, we will
    select the LCD display with the appropriate number of columns and rows that can
    display the characters.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列数和行数**：根据我们必须显示的文本，我们将选择具有适当列数和行数的液晶显示器，以便显示字符。'
- en: '**Response time**: It is very important to determine how much we can wait for
    the LCD display to show the new content that replaces the text that is being displayed
    or to clear the display.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应时间**：确定我们能够等待液晶显示器显示替换正在显示的文本或清除显示器的新内容的时间非常重要。'
- en: '**Protocol, support in the upm library and Python bindings**.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议，upm库中的支持以及Python绑定**。'
- en: '**Supported character set and built-in fonts**: Some LCD displays support user-defined
    characters, and therefore, they allow us to configure and display custom characters.
    It is also important to check whether the LCD display supports characters for
    the languages in which we have to display the text.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的字符集和内置字体**：一些液晶显示器支持用户自定义字符，因此，它们允许我们配置和显示自定义字符。检查液晶显示器是否支持我们必须显示的文本的语言中的字符也很重要。'
- en: '**Backlight color, text color and contrast level**: Some LCD displays allow
    us to change the backlight color while others have a fixed backlight color. An
    RGB backlight makes it possible to combine red, green, and blue components to
    determine the desired backlight color. In addition, it is always important to
    take into account whether the contrast level is appropriate for the light conditions
    in which you will need to display information.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背光颜色、文本颜色和对比度级别**：一些LCD显示器允许我们更改背光颜色，而另一些则具有固定的背光颜色。RGB背光使我们能够结合红色、绿色和蓝色组件来确定所需的背光颜色。此外，始终需要考虑对比度级别是否适合您需要显示信息的照明条件。'
- en: '**Cost**.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**。'
- en: Wiring an LCD RGB backlight to the I²C bus
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将LCD RGB背光连接到I²C总线
- en: In our last example in [Chapter 7](ch07.html "Chapter 7. Retrieving Data from
    the Real World with Sensors"), *Retrieving Data from the Real World with Sensors*,
    we worked with a multifunctional digital sensor that provided us with the temperature
    and relative humidity information. We worked with a breakout board that uses the
    I²C bus to allow the Intel Galileo Gen 2 board to communicate with the sensor.
    Now, we will add a breakout board with a 16x2 LCD RGB backlight to allow us to
    display the measured temperature and humidity values with text and numbers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第7章[“使用传感器从现实世界获取数据”](ch07.html "Chapter 7. Retrieving Data from the Real
    World with Sensors")的最后一个示例中，我们使用了一个多功能数字传感器，为我们提供了温度和相对湿度信息。我们使用了一个使用I²C总线允许Intel
    Galileo Gen 2板与传感器通信的扩展板。现在，我们将添加一个带有16x2 LCD RGB背光的扩展板，以便我们可以用文本和数字显示测量的温度和湿度值。
- en: 'The LCD RGB backlight breakout board will also be connected to the same I²C
    bus to which the temperature and humidity digital sensor is connected. We can
    connect many slaves to the I²C bus in the Intel Galileo Gen 2 board as long as
    their have different I²C addresses. In fact, the LCD RGB backlight breakout board
    has two I²C addresses: one for the LCD display and the other for the backlight.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: LCD RGB背光扩展板也将连接到与温度和湿度数字传感器相同的I²C总线。只要它们的I²C地址不同，我们就可以在Intel Galileo Gen 2板上将许多从设备连接到I²C总线。实际上，LCD
    RGB背光扩展板有两个I²C地址：一个用于LCD显示器，另一个用于背光。
- en: 'We need the following parts to work with this example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下部分来使用这个示例：
- en: 'A SeeedStudio Grove temperature and humidity sensor (high-accuracy and mini)
    breakout. The following URL provides detailed information about this breakout
    board: [http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html](http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块SeeedStudio Grove温度和湿度传感器（高精度和迷你）扩展板。以下网址提供了有关此扩展板的详细信息：[http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html](http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html)。
- en: 'A SeeedStudio Grove LCD RGB backlight breakout. The following URL provides
    detailed information about this breakout board: [http://www.seeedstudio.com/depot/Grove-LCD-RGB-Backlight-p-1643.html](http://www.seeedstudio.com/depot/Grove-LCD-RGB-Backlight-p-1643.html).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块SeeedStudio Grove LCD RGB背光扩展板。以下网址提供了有关此扩展板的详细信息：[http://www.seeedstudio.com/depot/Grove-LCD-RGB-Backlight-p-1643.html](http://www.seeedstudio.com/depot/Grove-LCD-RGB-Backlight-p-1643.html)。
- en: 'The following diagram shows the digital temperature and humidity breakout,
    the LCD RGB backlight breakout, the necessary wirings, and the wirings from the
    Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample
    is `iot_fritzing_chapter_08_01.fzz` and the following image is the breadboard
    view:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了数字温度和湿度扩展板、LCD RGB背光扩展板、必要的连接以及从Intel Galileo Gen 2板到面包板的连接。该示例的Fritzing文件为`iot_fritzing_chapter_08_01.fzz`，以下图像是面包板视图：
- en: '![Wiring an LCD RGB backlight to the I2C bus](img/B05042_08_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![将LCD RGB背光连接到I2C总线](img/B05042_08_02.jpg)'
- en: 'The following image shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了用符号表示的电子元件的原理图：
- en: '![Wiring an LCD RGB backlight to the I2C bus](img/B05042_08_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![将LCD RGB背光连接到I2C总线](img/B05042_08_03.jpg)'
- en: 'As seen in the previous schematic, we have the following connections:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个原理图所示，我们有以下连接：
- en: The **SDA** pin is connected to both the breakout board pins labeled **SDA**.
    This way, we connect both the digital temperature and humidity sensor and the
    LCD backlight to the serial data line for the I²C bus.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDA**引脚连接到标记为**SDA**的扩展板引脚。这样，我们将数字温度和湿度传感器以及LCD背光连接到I²C总线的串行数据线。'
- en: The **SCL** pin is connected to both the breakout board pins labeled **SCL**.
    This way, we can connect both the digital temperature and humidity sensor and
    the LCD backlight to the serial clock line for the I²C bus.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCL** 引脚连接到标有 **SCL** 的扩展板引脚。这样，我们可以将数字温度和湿度传感器以及 LCD 背光连接到 I²C 总线的串行时钟线上。'
- en: The power pin labeled **3V3** is connected to the digital temperature and humidity
    sensor breakout board power pin labeled **VCC**.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标有 **3V3** 的电源引脚连接到标有 **VCC** 的数字温度和湿度传感器扩展板电源引脚。
- en: The power pin labeled **5V** is connected to the LCD backlight breakout board
    power pin labeled **VCC**.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标有 **5V** 的电源引脚连接到标有 **VCC** 的 LCD 背光扩展板电源引脚。
- en: The ground pin labeled **GND** is connected to both the breakout board pins
    labeled **GND**.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标有 **GND** 的地线连接到标有 **GND** 的扩展板引脚。
- en: Now, it is time make all the necessary wirings. Don't forget to shut down the
    Yocto Linux, wait for all the onboard LEDs to turn off and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行所有必要的接线了。在从板上的引脚添加或移除任何电线之前，不要忘记关闭 Yocto Linux，等待所有板载 LED 灯熄灭，并从 Intel
    Galileo Gen 2 板上拔掉电源。
- en: Displaying text on an LCD display
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 LCD 显示器上显示文本
- en: The `upm` library includes support for the 16x2 LCD RGB backlight breakout board
    in the `pyupm_i2clcd` module. The `Jhd1313m1` class declared in this module represents
    a 16x2 LCD display and its RGB backlight, connected to our board. The class makes
    it easy to set the color components for the RGB backlight, clear the LCD display,
    specify the cursor location, and write text through the I²C bus. The class works
    with the `mraa.I2c` class under the hoods to talk with the RGB backlight and the
    LCD display. These two devices act as slave devices connected to the I²C bus,
    and therefore, each of them have a specific address in this bus.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`upm` 库在 `pyupm_i2clcd` 模块中包括对 16x2 LCD RGB 背光扩展板的支持。在此模块中声明的 `Jhd1313m1` 类代表一个
    16x2 LCD 显示屏及其 RGB 背光，连接到我们的板上。该类使得设置 RGB 背光的颜色组件、清除 LCD 显示、指定光标位置以及通过 I²C 总线写入文本变得简单。该类在幕后与
    `mraa.I2c` 类一起工作，以与 RGB 背光和 LCD 显示进行通信。这两个设备作为连接到 I²C 总线的从设备，因此，它们在这个总线中都有特定的地址。'
- en: We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor and we will use this code as a baseline to
    add the new features. The code file for the sample was `iot_python_chapter_07_05.py`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一章中编写的代码来读取传感器的温度和湿度值，并将此代码作为基准来添加新功能。示例代码文件为 `iot_python_chapter_07_05.py`。
- en: We will create an `Lcd` class to represent the 16x2 LCD RGB backlight and make
    it easier for us to set the background color and write the text in two lines without
    worrying about the specific methods when working with an instance of the `Jhd1313m1`
    class. We will use the `Jhd1313m1` class to interact with the LCD and its RGB
    backlight. The following lines show the code for the new `Lcd` class that works
    with the `upm` library, specifically with the `pyupm_i2clcd` module. The code
    file for the sample is `iot_python_chapter_08_01.py`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `Lcd` 类来表示 16x2 LCD RGB 背光，并使我们在设置背景颜色和在不担心 `Jhd1313m1` 类实例的具体方法的情况下写入两行文本时更加容易。我们将使用
    `Jhd1313m1` 类与 LCD 及其 RGB 背光进行交互。以下行显示了与 `upm` 库一起工作的新 `Lcd` 类的代码，特别是与 `pyupm_i2clcd`
    模块一起工作。示例代码文件为 `iot_python_chapter_08_01.py`。
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Lcd` class declares two class attributes: `lcd_i2c_address` and `rgb_i2c_address`.
    The first class attribute defines the I²C address for the LCD display, that is,
    the address that will process the commands that locate the cursor and write text
    once the cursor is located in a specific row and column. The address is `3E` in
    hexadecimal (`0x3E`). If we just see a `0x3E` within the code, we don''t understand
    that it is an I²C bus address for the LCD display. The second class attribute
    defines the I²C address for the RGB backlight, that is, the address that will
    process the commands that set the red, green, and blue components for the backlight
    color. The address is `62` in hexadecimal (`0x62`). If we just see a `0x62` within
    the code, we don''t understand that it is an I²C bus address for the RGB backlight.
    These class attributes make it easier to read the code.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lcd` 类声明了两个类属性：`lcd_i2c_address` 和 `rgb_i2c_address`。第一个类属性定义了 LCD 显示的 I²C
    地址，即当光标位于特定行和列时，将处理定位光标和写入文本的命令的地址。该地址为十六进制的 `3E`（即 `0x3E`）。如果我们只是在代码中看到 `0x3E`，我们不会理解它是一个
    LCD 显示的 I²C 总线地址。第二个类属性定义了 RGB 背光的 I²C 地址，即处理设置背光红色、绿色和蓝色组件的命令的地址。该地址为十六进制的 `62`（即
    `0x62`）。如果我们只是在代码中看到 `0x62`，我们不会理解它是一个 RGB 背光的 I²C 总线地址。这些类属性使得代码更容易阅读。'
- en: We have to specify the I²C bus number to which the both the 16x2 LCD and the
    RGB backlight are wired when we create an instance of the `Lcd` class in the `bus`
    required argument. In addition, it is necessary to specify the values for the
    red, green and blue color components to configure the background color for the
    RGB backlight. The constructor, that is, the `__init__` method, creates a new
    `upmLcd.Jhd1313m1` instance with the received `bus` argument followed by the `lcd_i2c_address`
    and `rgb_i2c_address` class attributes and saves the reference for the new instance
    in the `lcd` attribute. Then, the code calls the `clear` method for the new instance
    to clear the LCD screen. Finally, the code calls the `set_background_color` method
    with the red, green, and blue values received as arguments to configure the background
    color for the RGB backlight.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `bus` 必要参数中创建 `Lcd` 类的实例时，我们必须指定连接到 16x2 LCD 和 RGB 背光的 I²C 总线编号。此外，还需要指定红色、绿色和蓝色颜色组件的值来配置
    RGB 背光的背景颜色。构造函数，即 `__init__` 方法，使用接收到的 `bus` 参数以及 `lcd_i2c_address` 和 `rgb_i2c_address`
    类属性创建一个新的 `upmLcd.Jhd1313m1` 实例，并将新实例的引用保存在 `lcd` 属性中。然后，代码调用新实例的 `clear` 方法来清除
    LCD 屏幕。最后，代码调用 `set_background_color` 方法，并使用作为参数接收的红色、绿色和蓝色值来配置 RGB 背光的背景颜色。
- en: The class declares the `set_background_color` method that calls the `lcd.setColor`
    method with the `red`, `green` and `blue` values received as arguments. Under
    the hoods, the `upmLcd.Jhd1313m1` instance will write data to the slave device
    whose address is equal to the `rgb_i2c_address` class attribute through the I²C
    bus to specify the desired value for each color component. We just create a specific
    method to follow Python naming conventions and make our final code that uses our
    class easier to read.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了 `set_background_color` 方法，该方法使用接收到的 `red`、`green` 和 `blue` 值调用 `lcd.setColor`
    方法。在底层，`upmLcd.Jhd1313m1` 实例将通过 I²C 总线将数据写入地址等于 `rgb_i2c_address` 类属性的从设备，以指定每个颜色组件的期望值。我们只是创建了一个特定方法来遵循
    Python 命名约定，并使使用我们的类的最终代码更容易阅读。
- en: 'The class defines the following two additional methods to make it easy to print
    text on the first and the second row of the LCD display:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了以下两个额外的方法，以便于在 LCD 显示的第一行和第二行打印文本：
- en: '`print_line_1`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_line_1`'
- en: '`print_line_2`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_line_2`'
- en: The `print_line_1` method calls the `setCursor` method for the `upmLcd.Jhd1313m1`
    instance (`self.lcd`), with `0` as the value for both the `row` and the `column`
    argument, to locate the cursor in the first row and the first column. Then, a
    call to the write method for the the `upmLcd.Jhd1313m1` instance (`self.lcd`)
    with the `message` reviewed as a parameter as an argument prints the received
    string in the LCD display. Under the hoods, the `upmLcd.Jhd1313m1` instance will
    write the data to the slave device whose address is equal to the `lcd_i2c_address`
    class attribute through the I²C bus to specify the desired location for the cursor
    and then to write the specified text starting in the position in which we have
    located the cursor. The first row is identified with 0, but we named the method
    `print_line_1` because it makes it easier for us to understand that we are writing
    a message in the first line of the LCD screen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_line_1`方法调用`upmLcd.Jhd1313m1`实例（`self.lcd`）的`setCursor`方法，其中`row`和`column`参数的值均为`0`，以将光标定位在第一行和第一列。然后，调用`upmLcd.Jhd1313m1`实例（`self.lcd`）的写入方法，将`message`作为参数传递，在LCD显示屏中打印接收到的字符串。在底层，`upmLcd.Jhd1313m1`实例将通过I²C总线将数据写入地址等于`lcd_i2c_address`类属性的从设备，以指定光标所需的位置，然后从我们定位光标的位置开始写入指定的文本。第一行用0标识，但我们将其命名为`print_line_1`，因为这使我们更容易理解我们正在在LCD屏幕的第一行写入消息。'
- en: 'The `print_line_2` method has the same two lines of code than the `print_line_1`
    method with just one difference: the call to the `setCursor` method specifies
    1 as the value for the row argument. This way, the method prints a message in
    the second line of the LCD screen.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_line_2`方法与`print_line_1`方法具有相同的两行代码，只是对`setCursor`方法的调用指定了`1`作为行参数的值。这样，该方法将在LCD屏幕的第二行打印消息。'
- en: Now, we will create a subclass of the previously coded `Lcd` class named `TemperatureAndHumidityLcd`.
    The subclass will specialize the `Lcd` class to allow us to easily print a temperature
    value expressed in degrees Fahrenheit in the first line of the LCD screen and
    print a humidity value expressed in percentage in the second line of the LCD screen.
    The following lines show the code for the new `TemperatureAndHumidityLcd` class.
    The code file for the sample is `iot_python_chapter_08_01.py`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`TemperatureAndHumidityLcd`的之前编写的`Lcd`类的子类。该子类将专门化`Lcd`类，使我们能够轻松地在LCD屏幕的第一行打印华氏度表示的温度值，并在第二行打印百分比表示的湿度值。以下行显示了新`TemperatureAndHumidityLcd`类的代码。示例的代码文件是`iot_python_chapter_08_01.py`。
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The new class (`TemperatureAndHumidityLcd`) adds the following two methods
    to its superclass (`Lcd`):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类（`TemperatureAndHumidityLcd`）向其超类（`Lcd`）添加了以下两个方法：
- en: '`print_temperature`: Calls the `print_line_1` method with the formatted text
    that displays the temperature value expressed in degrees Fahrenheit (ºF) received
    in the `temperature_fahrenheit` argument.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_temperature`：调用`print_line_1`方法，并使用在`temperature_fahrenheit`参数中接收到的格式化文本来显示温度值。'
- en: '`print_humidity`: Calls the `print_line_2` method with the formatted text that
    displays the humidity level expressed in percentage received in the `humidity`
    argument.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_humidity`：调用`print_line_2`方法，并使用在`humidity`参数中接收到的格式化文本来显示湿度水平。'
- en: Now, we will write a loop that will display the ambient temperature expressed
    in degrees Fahrenheit (ºF) and the humidity value in the LCD screen, every 10
    seconds. The code file for the sample is `iot_python_chapter_08_01.py`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个循环，每10秒在LCD屏幕上显示环境温度（华氏度，ºF）和湿度值。示例的代码文件是`iot_python_chapter_08_01.py`。
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The highlighted lines show the changes made to the `__main__` method compared
    with the previous version. The first highlighted line creates an instance of the
    previously coded `TemperatureAndHumidityLcd` class with `0` as the value of the
    `bus` argument, `0` for `red` and `green`, and `128` for `blue` to set the background
    color to light blue. The code saves the reference to this instance in the `lcd`
    local variable. This way, the instance will establish a communication with the
    LCD screen and the RGB backlight through the I²C bus. The RGB backlight will display
    a light blue background.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行显示了与上一个版本相比对`__main__`方法所做的更改。第一行突出显示了使用`0`作为`bus`参数的值、`0`用于`red`和`green`以及`128`用于`blue`来设置背景颜色为浅蓝色的新实例`TemperatureAndHumidityLcd`类的代码。该代码将此实例的引用保存到`lcd`局部变量中。这样，该实例将通过I²C总线与LCD屏幕和RGB背光建立通信。RGB背光将显示浅蓝色背景。
- en: Then, the code runs a loop forever and the highlighted line calls the `lcd.print_temperature`
    method with `temperature_and_humidity_sensor.temperature_fahrenheit`, that is,
    the measured temperature expressed in degrees Fahrenheit (ºF), as an argument.
    This way, the code displays this temperature value in the first line of the LCD
    screen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码运行一个无限循环，并使用突出显示的行调用`lcd.print_temperature`方法，并使用`temperature_and_humidity_sensor.temperature_fahrenheit`作为参数，即以华氏度（ºF）表示的测量温度。这样，代码在LCD屏幕的第一行显示这个温度值。
- en: The next hightlighted line calls the `lcd.print_humidity` method with `temperature_and_humidity_sensor.humidity`,
    that is, the measured humidity expressed in percentage, as an argument. This way,
    the code displays this humidity value in the second line of the LCD screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条突出显示的行调用`lcd.print_humidity`方法，并使用`temperature_and_humidity_sensor.humidity`作为参数，即以百分比表示的测量湿度。这样，代码在LCD屏幕的第二行显示这个湿度值。
- en: 'The following line will start the example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动示例：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After you run the example, turn on an air conditioner or heating system, to
    generate a change in the ambient temperature and humidity. The LCD screen will
    display the temperature and humidity and refresh it every 10 seconds.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例之后，打开空调或加热系统，以产生环境温度和湿度的变化。LCD屏幕将显示温度和湿度，并且每10秒刷新一次。
- en: Wiring an OLED dot matrix to the I²C bus
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将OLED点阵连接到I²C总线
- en: LCD displays are not the only option when we have to display content on an external
    screen through the I²C or SPI buses. There are also OLED dot matrixes that allow
    us to control a specific number of dots. In OLED dot matrices we have control
    over each dot, instead of controlling each character space. Some of them are grayscale
    and others RGB.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要通过I²C或SPI总线在外部屏幕上显示内容时，LCD显示屏并不是唯一的选择。还有一些OLED点阵，允许我们控制特定数量的点。在OLED点阵中，我们可以控制每个点，而不是控制每个字符空间。其中一些是灰度的，而另一些是RGB的。
- en: 'The key advantage of OLED dot matrixes is that we can display any kind of graphics
    and not just text. In fact, we can mix any kind of graphics and images with text.
    The Grove OLED Display 0.96" is an example of a 16 grayscale 96-by-96 dot matrix
    OLED display module that works with the I²C bus. The following URL provides detailed
    information about this breakout board: [http://www.seeedstudio.com/depot/Grove-OLED-Display-096-p-824.html](http://www.seeedstudio.com/depot/Grove-OLED-Display-096-p-824.html).
    The Xadow RGB OLED 96x24 is an example of an RGB color 96-by-64 dot matrix OLED
    display module that works with the SPI bus. The following URL provides detailed
    information about this breakout board: [http://www.seeedstudio.com/depot/Xadow-RGB-OLED-96x64-p-2125.html](http://www.seeedstudio.com/depot/Xadow-RGB-OLED-96x64-p-2125.html).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: OLED点阵的关键优势在于我们可以显示任何类型的图形，而不仅仅是文本。实际上，我们可以将任何类型的图形和图像与文本混合。Grove OLED Display
    0.96"是一个16灰度96-by-96点阵OLED显示屏模块的例子，它支持I²C总线。以下URL提供了关于这块扩展板的详细信息：[http://www.seeedstudio.com/depot/Grove-OLED-Display-096-p-824.html](http://www.seeedstudio.com/depot/Grove-OLED-Display-096-p-824.html)。Xadow
    RGB OLED 96x24是一个RGB彩色96-by-64点阵OLED显示屏模块的例子，它支持SPI总线。以下URL提供了关于这块扩展板的详细信息：[http://www.seeedstudio.com/depot/Xadow-RGB-OLED-96x64-p-2125.html](http://www.seeedstudio.com/depot/Xadow-RGB-OLED-96x64-p-2125.html)。
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Another option is to work with TFT LCD dot matrices or displays. Some of them
    include support for touch detection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是与TFT LCD点阵或显示屏一起工作。其中一些包括触摸检测的支持。
- en: Now, we will replace the breakout board with a 16x2 LCD RGB backlight with a
    16 grayscale 96-by-96 dot matrix OLED display module that also works with the
    I²C bus, and we will use this new screen to display similar values with a different
    configuration. The wirings are compatible with the previous breakout board.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将用一块带有16灰度96-by-96点阵的OLED显示屏的16x2 LCD RGB背光板来替换扩展板，这块显示屏也支持I²C总线，我们将使用这块新屏幕以不同的配置显示类似值。这些接线与之前的扩展板兼容。
- en: As it happened in our previous example, the dot matrix OLED will also be connected
    to the same I²C bus to which the temperature and humidity digital sensor is connected.
    As the dot matrix OLED has an I²C address that is different than the one used
    by the temperature and humidity digital sensor, we don't have problems to wire
    the two devices to the same I²C bus.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们之前的示例，点阵OLED也将连接到与温度和湿度数字传感器相同的I²C总线。由于点阵OLED的I²C地址与温度和湿度数字传感器使用的地址不同，因此我们不需要将两个设备连接到同一个I²C总线上。
- en: 'We need the following additional part to work with this example: A SeeedStudio
    Grove OLED Display 0.96", 16 grayscale 96-by-96 dot matrix OLED display module.
    The 96-by-96 dot matrix OLED display provides us the chance to control 9,216 dots,
    known as pixels. However, in this case, we just want to use the OLED display to
    display a similar text than the one we displayed in our previous example, but
    with a different layout.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下额外的部件来使用此示例：一个SeeedStudio Grove OLED显示屏0.96英寸，16灰度96x96点阵OLED显示模块。96x96点阵OLED显示屏为我们提供了控制9,216个点，即像素的机会。然而，在这种情况下，我们只想使用OLED显示屏来显示类似于我们之前示例中的文本，但布局不同。
- en: If we use the default 8-by-8 character box, we have 12 columns (96/8) and 12
    rows (96/8) for characters. The following table shows an example of each line
    with the text and the values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用默认的8x8字符框，我们就有12列（96/8）和12行（96/8）用于字符。以下表格显示了每行文本及其值的示例。
- en: '| T | e | m | p | e | r | a | t | u | r | e |   |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 温 | 度 |  |  |  |  |  |  |  |  |  |  |'
- en: '|   |   |   |   |   |   |   |   |   |   |   |   |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| F | a | h | r | e | n | h | e | i | t |   |   |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 法 | 雷 | 尼 | 哈恩 | 海 | 特 | 海 | 伊 | 特 |  |  |'
- en: '| 4 | 0 | . | 2 |   |   |   |   |   |   |   |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0 | . | 2 |  |  |  |  |  |  |  |  |'
- en: '|   |   |   |   |   |   |   |   |   |   |   |   |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| C | e | l | s | i | u | s |   |   |   |   |   |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 细 | 节 |  |  |  |  |  |  |  |  |  |  |'
- en: '| 4 | . | 5 | 5 |   |   |   |   |   |   |   |   |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 4 | . | 5 | 5 |  |  |  |  |  |  |  |  |'
- en: '|   |   |   |   |   |   |   |   |   |   |   |   |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| H | u | m | i | d | i | t | y |   |   |   |   |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 湿 | 度 |  |  |  |  |  |  |  |  |  |  |'
- en: '| L | e | v | e | l |   |   |   |   |   |   |   |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 级 | 别 |  |  |  |  |  |  |  |  |  |  |'
- en: '| 8 | 0 | % |   |   |   |   |   |   |   |   |   |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 0 | % |  |  |  |  |  |  |  |  |  |'
- en: '|   |   |   |   |   |   |   |   |   |   |   |   |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |'
- en: The possibility to work with 12 columns and 12 rows of characters allows us
    to provide a very clear description for each value. In addition, we are able to
    display the temperature values expressed in both degrees Fahrenheit and degrees
    Celsius. The following picture shows an example of the location of each character
    in the 96-by-96 dot matrix OLED display module with an 8-by-8 character box.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用12列和12行的字符，使我们能够为每个值提供非常清晰的描述。此外，我们能够显示以华氏度和摄氏度表示的温度值。以下图片显示了带有8x8字符框的96x96点阵OLED显示模块中每个字符的位置示例。
- en: '![Wiring an OLED dot matrix to the I2C bus](img/B05042_08_04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![将OLED点阵连接到I2C总线](img/B05042_08_04.jpg)'
- en: 'After we replace the LCD screen breakout board with the OLED module, we will
    have the following connections:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将LCD屏幕扩展板替换为OLED模块后，我们将有以下连接：
- en: The **SDA** pin is connected to both breakout board pins labeled **SDA**. This
    way, we connect both the digital temperature and humidity sensor and the OLED
    module to the serial data line for the I²C bus.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDA**引脚连接到标记为**SDA**的扩展板引脚。这样，我们将数字温度和湿度传感器以及OLED模块连接到I²C总线的串行数据线。'
- en: The **SCL** pin is connected to both the breakout board pins labeled **SCL**.
    This way, we connect both the digital temperature and humidity sensor and the
    OLED module to the serial clock line for the I²C bus.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCL**引脚连接到标记为**SCL**的扩展板引脚。这样，我们将数字温度和湿度传感器以及OLED模块连接到I²C总线的串行时钟线。'
- en: The power pin labeled **3V3** is connected to the digital temperature and humidity
    sensor breakout board power pin labeled **VCC**.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**3V3**的电源引脚连接到数字温度和湿度传感器扩展板的标记为**VCC**的电源引脚。
- en: The power pin labeled **5V** is connected to the OLED module power pin labeled
    **VCC**.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**5V**的电源引脚连接到OLED模块的标记为**VCC**的电源引脚。
- en: The ground pin labeled **GND** is connected to both the breakout board pins
    labeled **GND**.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**GND**的地线连接到标记为**GND**的扩展板引脚。
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行所有必要的接线了。在添加或从板上的引脚移除任何电线之前，不要忘记关闭Yocto Linux，等待所有板载LED熄灭，并从Intel Galileo
    Gen 2板上拔掉电源。
- en: Displaying text on an OLED display
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OLED显示屏上显示文本
- en: The `upm` library includes support for the SeeedStudio Grove OLED display 0.96",
    16 grayscale 96-by-96 dot matrix OLED display breakout board the in the `pyupm_i2clcd`
    module. As this OLED display uses SSD1327 driver integrated circuit, the `SSD1327`
    class declared in this module represents a 96-by-96 dot matrix OLED display, connected
    to our board. The class makes it easy to clear the OLED screen, draw bitmap images,
    specify the cursor location, and write text through the I²C bus. The class works
    with the `mraa.I2c` class under the hoods to talk with the OLED display.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`upm`库在`pyupm_i2clcd`模块中包括了对SeeedStudio Grove OLED显示屏0.96英寸、16灰度96x96点阵OLED显示屏模块的支持。由于该OLED显示屏使用SSD1327驱动集成电路，因此在此模块中声明的`SSD1327`类代表一个96x96点阵OLED显示屏，连接到我们的板上。该类使得清除OLED屏幕、绘制位图图像、指定光标位置和通过I²C总线写入文本变得容易。该类在幕后与`mraa.I2c`类一起工作，以与OLED显示屏通信。'
- en: 'We will create a new `Oled` class that will represent the 96-by-96 dot matrix
    OLED and will use its default 8-by-8 character box to display text. We will use
    the `SSD1327` class to interact with the OLED display. The following lines show
    the code for the new `Oled` class that works with the `upm` library, specifically
    with the `pyupm_i2clcd` module and its `SSD1327` class. The code file for the
    sample is `iot_python_chapter_08_02.py`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`Oled`类，该类将代表96x96点阵OLED显示屏，并使用其默认的8x8字符框来显示文本。我们将使用`SSD1327`类与OLED显示屏进行交互。以下行显示了与`upm`库一起工作的新`Oled`类的代码，特别是与`pyupm_i2clcd`模块及其`SSD1327`类。示例代码文件为`iot_python_chapter_08_02.py`：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Oled` class declares the `oled_i2c_address` class attribute that defines
    the I²C address for the OLED display, that is, the address that will process the
    commands that locate the cursor and write text once the cursor is located in a
    specific row and column. The address is `3C` in hexadecimal (`0x3C`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Oled`类声明了`oled_i2c_address`类属性，该属性定义了OLED显示屏的I²C地址，即一旦光标定位在特定的行和列，将处理定位光标和写入文本的命令的地址。该地址为十六进制的`3C`（`0x3C`）。'
- en: We have to specify the I²C bus number to which the OLED display is wired when
    we create an instance of the `Oled` class in the `bus` required argument. The
    constructor, that is, the `__init__` method, creates a new `upmLcd. SSD1327` instance
    with the received `bus` argument followed by the `oled_i2c_address` class attribute,
    and saves the reference for the new instance in the `oled` attribute. Finally,
    the code calls the `clear` method for the new instance to clear the OLED screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Oled`类的实例时，我们必须指定OLED显示屏所连接的I²C总线编号，该参数在`bus`必需参数中。构造函数，即`__init__`方法，使用接收到的`bus`参数和`oled_i2c_address`类属性创建一个新的`upmLcd.
    SSD1327`实例，并将新实例的引用保存在`oled`属性中。最后，代码调用新实例的`clear`方法以清除OLED屏幕。
- en: The class declared the `print_line` method to make it easy to print text on
    a specific row. The code calls the `setCursor` method for the `upmLcd.SSD1327`
    instance (`self.oled`), with the received `row` value as the value for the `row`
    argument and `0` for the `column` argument, to locate the cursor in the specified
    row and the first column. Then, a call to the `setGrayLevel` and the `write` method
    for the the `upmLcd.SSD1327` instance (`self.oled`) with the `message` reveiced
    as a parameter as an argument prints the received string in the OLED display with
    the default 8-by-8 character box with the gray level set to 12\. Under the hoods,
    the `upmLcd.SSD1327` instance will write data to the slave device whose address
    is equal to the `oled_i2c_address` class attribute through the I²C bus to specify
    the desired location for the cursor and then to write the specified text starting
    in the position in which we have located the cursor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了`print_line`方法，以便于在特定行上打印文本。代码调用`upmLcd.SSD1327`实例（`self.oled`）的`setCursor`方法，将接收到的`row`值作为`row`参数的值，并将`0`作为`column`参数的值，以将光标定位在指定的行和第一列。然后，调用`setGrayLevel`和`write`方法，将`upmLcd.SSD1327`实例（`self.oled`）的`message`接收作为参数的参数，以默认的8x8字符框和灰度设置为12打印接收到的字符串到OLED显示屏。在幕后，`upmLcd.SSD1327`实例将通过I²C总线将数据写入地址等于`oled_i2c_address`类属性的从设备，以指定光标所需的位置，然后从我们定位光标的位置开始写入指定的文本。
- en: Now, we will create a subclass of the previously coded `Oled` class named `TemperatureAndHumidityOled`.
    The subclass will specialize the `Oled` class to allow us to easily print a temperature
    value expressed in degrees Fahrenheit, the temperature value expressed in degrees
    Celsius and a humidity value expressed in percentage. We will use the previously
    explained layout for the text. The following lines show the code for the new `TemperatureAndHumidityOled`
    class. The code file for the sample is `iot_python_chapter_08_02.py`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`TemperatureAndHumidityOled`的子类，该子类基于之前编写的`Oled`类。这个子类将专门化`Oled`类，使我们能够轻松地打印华氏度表示的温度值、摄氏度表示的温度值以及百分比表示的湿度值。我们将使用之前解释过的文本布局。以下行显示了新`TemperatureAndHumidityOled`类的代码。示例的代码文件是`iot_python_chapter_08_02.py`。
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The new class (`TemperatureAndHumidityOled`) adds the following two methods
    to its superclass (`Oled`):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类（`TemperatureAndHumidityOled`）向其超类（`Oled`）添加了以下两个方法：
- en: '`print_temperature`: Calls the `print_line` method many times to display the
    temperature in both degrees Fahrenheit (ºF) and Celsius (ºC) received as arguments'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_temperature`: 多次调用`print_line`方法来显示接收到的温度参数，以华氏度（ºF）和摄氏度（ºC）的形式'
- en: '`print_humidity`: Calls the `print_line` method many times to display the humidity
    value received as an argument'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_humidity`: 多次调用`print_line`方法来显示接收到的湿度参数'
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this case, we refresh many lines to change just a few values. As we will
    run a loop every 10 seconds, it won't be a problem. However, in other cases in
    which we want to update values in a shorter amount of time, we can write optimized
    code that just clears a single line and updates the specific value in this line.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们刷新许多行来更改仅几个值。由于我们将每10秒运行一个循环，所以这不会成为问题。然而，在其他情况下，如果我们想在更短的时间内更新值，我们可以编写优化后的代码，该代码仅清除单行并更新该行中的特定值。
- en: Now, we will write a loop that will display the ambient temperature expressed
    in Fahrenheit (ºF) and Celsius (ºC) and the humidity value in the OLED screen,
    every 10 seconds. The code file for the sample is `iot_python_chapter_08_02.py`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个循环，每10秒在OLED屏幕上显示以华氏度（ºF）和摄氏度（ºC）表示的环境温度以及以百分比表示的湿度值。示例的代码文件是`iot_python_chapter_08_02.py`。
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The highlighted lines show the changes made in the `__main__` method compared
    with the previous version. The first highlighted line creates an instance of the
    previously coded `TemperatureAndHumidityOled` class with `0` as the value of the
    `bus` argument. The code saves the reference to this instance in the `oled` local
    variable. This way, the instance will establish a communication with the OLED
    screen through the I²C bus.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮行显示了与上一个版本相比在`__main__`方法中做出的更改。第一条高亮行使用`0`作为`bus`参数的值创建了一个之前编写的`TemperatureAndHumidityOled`类的实例。代码将此实例的引用保存在`oled`局部变量中。这样，实例将通过I²C总线与OLED屏幕建立通信。
- en: Then, the code runs a loop forever and the highlighted line calls the `oled.print_temperature`
    method with `temperature_and_humidity_sensor.temperature_fahrenheit` and `temperature_and_humidity_sensor.temperature_celsius`
    as arguments. This way, the code displays both temperature values in the first
    lines of the OLED screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码无限循环运行，高亮行调用`oled.print_temperature`方法，并使用`temperature_and_humidity_sensor.temperature_fahrenheit`和`temperature_and_humidity_sensor.temperature_celsius`作为参数。这样，代码在OLED屏幕的第一行显示这两个温度值。
- en: The next hightlighted line calls the `oled.print_humidity` method with `temperature_and_humidity_sensor.humidity`.
    This way, the code uses many lines to display this humidity value at the bottom
    of the OLED screen.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条高亮行调用了`oled.print_humidity`方法，并使用`temperature_and_humidity_sensor.humidity`。这样，代码通过多行来显示这个湿度值在OLED屏幕的底部。
- en: 'The following line will start the example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动示例：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After you run the example, turn on an air conditioner or a heating system to
    generate a change in the ambient temperature and humidity. The OLED screen will
    display the temperature and humidity and refresh it every 10 seconds.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，打开空调或加热系统以产生环境温度和湿度的变化。OLED屏幕将显示温度和湿度，并且每10秒刷新一次。
- en: Wiring a servo motor
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接伺服电机
- en: So far, we have been using sensors to retrieve data from the real world and
    we displayed information in LCD and OLED displays. However, IoT devices are not
    limited to sensing and displaying data, they can also move things. We can connect
    different components, shields, or breakout boards to our Intel Galileo Gen 2 board
    and write Python code to move things connected to the board.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用传感器从现实世界获取数据，并在液晶显示屏和OLED显示屏上显示信息。然而，物联网设备并不仅限于感应和显示数据，它们还可以移动物体。我们可以将不同的组件、屏蔽或分线板连接到我们的英特尔Galileo
    Gen 2板上，并编写Python代码来移动连接到板上的物体。
- en: Standard servo motors are extremely useful to precisely control a shaft and
    position it at various angles, usually between 0 and 180 degrees. In [Chapter
    4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width Modulation"),
    *Working with a RESTful API and Pulse Width Modulation*, we worked with pulse
    width modulation, known as PWM, to control the brightness of an LED and a RGB
    LED. We can also use PWM to control a standard analog servo motor and position
    its shaft at a specific angle.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 标准伺服电机对于精确控制轴并使其在0到180度之间的各种角度定位非常有用。在[第4章](ch04.html "第4章。使用RESTful API和脉冲宽度调制")中，*使用RESTful
    API和脉冲宽度调制*，我们使用了脉冲宽度调制，简称PWM，来控制LED和RGB LED的亮度。我们还可以使用PWM来控制标准模拟伺服电机，并使其轴在特定角度定位。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Standard servo motors are DC motors that includes gears and feedback control
    loop circuitry that provides precision positioning. They are ideal for pinion
    steering, robot arms and legs, among other usages that require a precise positioning.
    Standard servo motors don't require motor drivers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 标准伺服电机是包含齿轮和反馈控制回路电路的直流电机，它提供了精确的位置定位。它们非常适合齿轮转向、机器人手臂和腿部，以及其他需要精确定位的应用。标准伺服电机不需要电机驱动器。
- en: Obviously, not all servor motors have the same features and we must take into
    account many of them when we select a specific servo motor for our project. It
    depends on what we need to position, the accuracy, the required torque, the optimal
    servo rotational velocity, among other factors. In this case, we will focus on
    the usage of PWM to position a standard servo motor. However, you cannot use the
    same servo to rotate a lighter plastic piece than the one you will need to rotate
    a heavy robotic arm. It is necessary to research about the appropriate servo for
    each task.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，不是所有的伺服电机都具有相同的特性，我们在为我们的项目选择特定的伺服电机时必须考虑许多因素。这取决于我们需要定位什么，精度，所需的扭矩，最佳伺服电机旋转速度等因素。在这种情况下，我们将专注于使用PWM定位标准伺服电机。然而，你不能用同一个伺服电机旋转比你需要旋转的重型机械臂更轻的塑料件。对于每个任务，有必要研究合适的伺服电机。
- en: Now, we will wire a standard high sensitive mini servo motor to our existing
    project and we will rotate the shaft to display the measured temperature expressed
    in degrees Fahrenheit with the shaft. The shaft will allow us to display the measured
    temperature in a half circle protractor that measures angles in degrees and will
    display the number for the angle from 0 to 180 degrees. The combination of the
    servo with the shaft and the protactor will allow us to display the temperature
    with moving parts. Then, we can create our own protactor with a scale that can
    add colors, specific thresholds and many other visual artifacts to make temperature
    measurement funnier. Specifically, we can create a gauge chart, speedometer or
    semicircle donut, that is, a combination of a doughnut chart and a pie chart in
    a single chart with the different temperature values. The following picture shows
    and example of a half circle protractor that we can use in combination with the
    servo with the shaft.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把标准高灵敏度微型伺服电机连接到我们的现有项目中，并将旋转轴以华氏度数显示测量的温度。轴将允许我们在半圆形的量角器上显示测量的温度，该量角器以度为单位测量角度，并将显示从0到180度的角度数值。伺服电机与轴和量角器的组合将允许我们通过移动部件显示温度。然后，我们可以创建自己的量角器，带有可以添加颜色、特定阈值和许多其他视觉效果的刻度，使温度测量更有趣。具体来说，我们可以创建一个仪表盘图表、速度计或半圆形甜甜圈，即一个饼图和甜甜圈的组合，在单个图表中显示不同的温度值。以下图片显示了我们可以与伺服电机和轴一起使用的半圆形量角器示例。
- en: '![Wiring a servo motor](img/B05042_08_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![连接伺服电机](img/B05042_08_05.jpg)'
- en: 'We need the following additional part to work with this example: A SeeedStudio
    Grove Servo or a EMAX 9g ES08A High Sensitive Mini Servo. The following URLs provide
    detailed information about these servos: [http://www.seeedstudio.com/depot/Grove-Servo-p-1241.html](http://www.seeedstudio.com/depot/Grove-Servo-p-1241.html)
    and [http://www.seeedstudio.com/depot/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html](http://www.seeedstudio.com/depot/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下附加部件来使用此示例：SeeedStudio Grove 伺服或EMAX 9g ES08A 高灵敏度迷你伺服。以下网址提供了关于这些伺服的详细信息：[http://www.seeedstudio.com/depot/Grove-Servo-p-1241.html](http://www.seeedstudio.com/depot/Grove-Servo-p-1241.html)
    和 [http://www.seeedstudio.com/depot/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html](http://www.seeedstudio.com/depot/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html)。
- en: 'The following diagram shows the digital temperature and humidity breakout,
    the LCD RGB backlight breakout, the mini servo, the necessary wirings and the
    wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file
    for the sample is `iot_fritzing_chapter_08_03.fzz` and the following picture is
    the breadboard view:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了数字温度和湿度扩展板、LCD RGB背光扩展板、迷你伺服、必要的布线以及从Intel Galileo Gen 2板到面包板的布线。示例的Fritzing文件为`iot_fritzing_chapter_08_03.fzz`，以下图片是面包板视图：
- en: '![Wiring a servo motor](img/B05042_08_06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![连接伺服电机](img/B05042_08_06.jpg)'
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了用符号表示的电子组件的原理图：
- en: '![Wiring a servo motor](img/B05042_08_07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![连接伺服电机](img/B05042_08_07.jpg)'
- en: 'As seen in the previous schematic, we added the following additional connections
    to our existing project:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们在现有项目中添加了以下附加连接：
- en: The power pin labeled **5V** in the board's symbol is connected to the servo's
    pin labeled **+**. Servos usually use a red wire for this connection.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在电路符号中标有**5V**的电源针与标有**+**的伺服针相连。伺服通常使用红色电线进行此连接。
- en: The PWM capable GPIO pin labeled **D3 PWM** in the board's symbol is connected
    to the servo's pin labeled **PULSE**. Servos usually use a yellow wire for this
    connection.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在电路符号中标有**D3 PWM**的具有PWM功能的GPIO针与标有**PULSE**的伺服针相连。伺服通常使用黄色电线进行此连接。
- en: The ground pin labeled **GND** in the board's symbol is connected to the servo's
    pin labeled **-**. Servos usually use a black wire for this connection.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在电路符号中标有**GND**的接地针与标有**-**的伺服针相连。伺服通常使用黑色电线进行此连接。
- en: Now, it is time make all the necessary wirings. Don't forget to shut down the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行所有必要的布线了。在添加或从板上的引脚移除任何电线之前，不要忘记关闭Yocto Linux，等待所有板载LED熄灭，并从Intel Galileo
    Gen 2板上拔掉电源。
- en: Positioning a shaft to indicate a value with a servo motor
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用伺服电机定位轴以指示值
- en: We can use the `mraa.Pwm` class to control PWM on the PWM capable GPIO pin labeled
    **~3**, as we learned in [Chapter 4](ch04.html "Chapter 4. Working with a RESTful
    API and Pulse Width Modulation"), *Working with a RESTful API and Pulse Width
    Modulation*. However, this would require us to read the detailed specs for the
    servo. The `upm` library includes support for both the SeeedStudio Grove Servo
    or the EMAX 9g ES08A High Sensitive Mini Servo in the `pyupm_servo` module. The
    `ES08A` class declared in this module represents any of the two mentioned servors
    connected to our board.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`mraa.Pwm`类来控制标有**~3**的具有PWM功能的GPIO针上的PWM，正如我们在[第4章](ch04.html "第4章。使用RESTful
    API和脉宽调制")中学习的，*使用RESTful API和脉宽调制*。然而，这需要我们阅读伺服的详细规格。`upm`库在`pyupm_servo`模块中包括了对SeeedStudio
    Grove 伺服或EMAX 9g ES08A 高灵敏度迷你伺服的支持。在此模块中声明的`ES08A`类代表连接到我们板上的两种提到的伺服器中的任何一个。
- en: The class makes it easy to set the desired angle for the servo shaft and work
    with angles instead of duty cycles and other PWM details. The class works with
    the `mraa.Pwm` class under the hoods to configure PWM and control the duty cycle
    based on the desired angle for the shaft.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使得设置伺服轴所需的角度并使用角度而不是占空比和其他PWM细节进行工作变得容易。该类在幕后与`mraa.Pwm`类一起工作以配置PWM并根据轴所需的角度控制占空比。
- en: We will take the code we wrote in the previous example and we will use this
    code as a baseline to add the new features. The code file for the sample was `iot_python_chapter_08_02.py`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前示例中编写的代码，并将此代码作为添加新功能的基准。示例代码文件为`iot_python_chapter_08_02.py`。
- en: We will create a `TemperatureServo` class to represent the servo and make it
    easier for us to position the shaft in a valid angle (from 0 to 180 degrees) based
    on the temperature expressed in degrees Fahrenheit. We will use the `ES08A` class
    to interact with the servo. The following lines show the code for the new `TemperatureServo`
    class that works with the `upm` library, specifically with the `pyupm_servo` module.
    The code file for the sample is `iot_python_chapter_08_03.py`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`TemperatureServo`类来表示伺服器，并使我们能够根据华氏度表示的温度将轴定位在有效角度（从0到180度）内。我们将使用`ES08A`类与伺服器交互。以下行显示了与`upm`库一起工作的新`TemperatureServo`类的代码，特别是与`pyupm_servo`模块一起工作。示例的代码文件是`iot_python_chapter_08_03.py`。
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have to specify the pin number to which the servo is connected when we create
    an instance of the `TemperatureServo` class in the `pin` required argument. The
    constructor, that is, the `__init__` method, creates a new `upmServo.ES08A` instance
    with the received `pin` as its `pin` argument, saves its reference in the `servo`
    attribute and calls its `setAngle` with `0` as the value for the `angle` required
    argument. This way, the underlying code will configure the output duty cycle for
    the PWM enabled GPIO pin based on the received value in the `angle` argument to
    position the shaft at the desired angle. In this case, we want the shaft to be
    positioned at 0 degrees.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`TemperatureServo`类的实例时，我们必须指定与伺服器连接的引脚号，作为`pin`必需参数。构造函数，即`__init__`方法，使用接收到的`pin`作为其`pin`参数创建一个新的`upmServo.ES08A`实例，将其引用保存在`servo`属性中，并调用其`setAngle`方法，将`0`作为`angle`必需参数的值。这样，底层代码将根据`angle`参数中接收到的值配置PWM启用GPIO引脚的输出占空比，以将轴定位在所需的角位置。在这种情况下，我们希望轴定位在0度。
- en: 'The class defines a `print_temperature` method that receives a temperature
    value expressed in degrees Fahrenheit (ºF) in the `temperature_fahrenheit` argument.
    The code defines an `angle` local variable that makes sure that the desired angle
    for the shaft is in a valid range: from 0 to 180 (inclusive). If the value received
    in the `temperature_fahrenheit` argument is lower than `0`, the `angle` value
    will be `0`. If the value received in the `temperature_fahrenheit` argument is
    greater than `180`, the `angle` value will be `180`. Then, the code calls the
    `setAngle` method for the `upmServo.ES08A` instance (`self.servo`) with `angle`
    as an argument. Under the hoods, the `upmServo.ES08A` instance will configure
    the output duty cycle for the PWM enabled GPIO pin based on the received value
    in the `angle` argument to position the shaft at the desired angle. This way,
    the shaft will position at an angle that will be the same than the received temperature
    in degrees Fahrenheit (ºF), as long as the temperature value is between 0 and
    180 degrees Fahrenheit (ºF).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了一个`print_temperature`方法，该方法接收一个以华氏度（ºF）表示的温度值，作为`temperature_fahrenheit`参数。代码定义了一个`angle`局部变量，确保所需的轴角度在有效范围内：从0到180度（包括）。如果`temperature_fahrenheit`参数中接收到的值低于`0`，则`angle`值将为`0`。如果`temperature_fahrenheit`参数中接收到的值大于`180`，则`angle`值将为`180`。然后，代码使用`angle`作为参数调用`upmServo.ES08A`实例（`self.servo`）的`setAngle`方法。在底层，`upmServo.ES08A`实例将根据`angle`参数中接收到的值配置PWM启用GPIO引脚的输出占空比，以将轴定位在所需的角位置。这样，只要温度值在0到180华氏度（ºF）之间，轴将定位在与其接收到的华氏度（ºF）温度相同的角位置。
- en: In case it is too cold, (less than 0 degrees Fahrenheit) the shaft will stay
    at a 0 degrees angle. In case the temperature is higher than 180 degrees Fahrenheit,
    the shaft will stay at a 180 degrees angle.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果温度太低（低于0华氏度），则轴将保持在0度角度。如果温度高于180华氏度，则轴将保持在180度角度。
- en: Now, we will make changes to our main loop to display the ambient temperature
    expressed in Fahrenheit (ºF) with the shaft, every 10 seconds. The code file for
    the sample is `iot_python_chapter_08_03.py`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改我们的主循环，每10秒显示以华氏度（ºF）表示的环境温度，并用轴表示。示例的代码文件是`iot_python_chapter_08_03.py`。
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The highlighted lines show the changes made to the `__main__` method compared
    with the previous version. The first highlighted line creates an instance of the
    previously coded `TemperatureServo` class with `3` as the value of the `pin` argument.
    The code saves the reference to this instance in the `temperature_servo` local
    variable. This way, the instance will configure PWM for pin number 3 and position
    the shaft at `0` degrees.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行显示了与上一个版本相比对`__main__`方法所做的更改。第一条突出显示的行使用`3`作为`pin`参数的值创建了一个先前编码的`TemperatureServo`类的实例。代码将此实例的引用保存在`temperature_servo`局部变量中。这样，该实例将为3号引脚配置PWM并将轴定位在`0`度。
- en: Then, the code runs a loop forever and the highlighted line calls the `temperature_servo.print_temperature`
    method with `temperature_and_humidity_sensor.temperature_fahrenheit` as an argument.
    This way, the code makes the shaft point to the temperature value in the protractor.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码无限循环运行，突出显示的行调用`temperature_servo.print_temperature`方法，并将`temperature_and_humidity_sensor.temperature_fahrenheit`作为参数。这样，代码使轴指向温度计中的温度值。
- en: The following line will start the example.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将开始示例。
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After you run the example, turn on an air conditioner or a heating system and
    generate a change in the ambient temperature. You will notice how the shaft starts
    moving to reflect the changes in the temperature every 10 seconds.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例后，打开空调或供暖系统并生成环境温度的变化。您将注意到轴每10秒开始移动以反映温度的变化。
- en: Test your knowledge
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'The Intel Galileo Gen 2 board works as an I²C bus master and allows us to:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 英特尔Galileo Gen 2板可以作为I²C总线主控器，并允许我们：
- en: Connect many slaves to the I²C bus as long as their have different I²C addresses.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要它们的I²C地址不同，就可以将许多从设备连接到I²C总线上。
- en: Connect many slaves to the I²C bus as long as their have the same I²C addresses.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要它们的I²C地址相同，就可以将许多从设备连接到I²C总线上。
- en: Connect a maximum of two slaves to the I²C bus as long as their have different
    I²C addresses.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要它们的I²C地址不同，就可以将最多两个从设备连接到I²C总线上。
- en: 'A 16x2 LCD module allows us to display:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个16x2液晶模块允许我们显示：
- en: Two lines of text with 16 characters each.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每行16个字符，共两行。
- en: Sixteen lines of text with 2 characters each.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每行16个字符，每个字符2个。
- en: Sixteen lines of text with 3 characters each.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每行16个字符，每个字符3个。
- en: 'A 16 grayscale 96-by-96 dot matrix OLED display module allows us to control:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个16灰度96x96点阵OLED显示器模块允许我们控制：
- en: 96 lines of text with 96 characters each.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每行96个字符，共96行。
- en: A single line with 96 dots or 96 characters, based on how we configure the OLED
    display.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一行有96个点或96个字符，具体取决于我们如何配置OLED显示器。
- en: 9,216 dots (96*96).
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 9,216个点（96*96）。
- en: 'A 16 grayscale 96-by-96 dot matrix OLED display with an 8-by-8 character box
    allows us to display:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个16灰度96x96点阵OLED显示器，带有8x8字符框，允许我们显示：
- en: '96 lines of text with 96 characters each: 96 columns and 96 rows.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每行96个字符，共96行：96列和96行。
- en: '16 lines of text with 16 characters each: 16 columns and 16 rows.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每行16个字符，共16行：16列和16行。
- en: '12 lines of text with 12 characters each: 12 columns and 12 rows.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每行12个字符，共12行：12列和12行。
- en: 'Standard servos allow us to:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准伺服允许我们：
- en: Display text on an OLED display.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OLED显示器上显示文本。
- en: Position the shaft at various specific angles.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将轴定位在各个特定角度。
- en: Move the shaft to a specific location by specifying the desired latitude and
    longitude.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定所需的纬度和经度来将轴移动到特定位置。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about different displays the we could connect to
    our board through the I²C bus. We worked with an LCD display, an RGB backlight,
    and then replaced it with an OLED dot matrix.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了我们可以通过I²C总线连接到我们的板上的不同显示器。我们使用了一个液晶显示器、一个RGB背光，然后将其替换为OLED点阵。
- en: We wrote the code that took advantage of the modules and classes included in
    the `upm` library that made it easier for us to work with LCD and OLED display
    and show text on them. In addition, we wrote the code that interacted with an
    analog servo. Instead of writing our own code to set the output duty cycle based
    on the desired position for the shaft, we took advantage of a specific module
    and a class in the `upm` library. We could control the shaft to allow us to create
    a gauge chart to display the temperature value retrieved with a sensor. Our Python
    code could make things move.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了利用`upm`库中包含的模块和类来简化我们与LCD和OLED显示屏以及在其上显示文本的代码。此外，我们还编写了与模拟伺服电机交互的代码。我们不是编写自己的代码来根据轴的期望位置设置输出占空比，而是利用了`upm`库中的一个特定模块和一个类。我们可以控制轴，以便创建一个仪表图表来显示通过传感器获取的温度值。我们的Python代码可以使物体移动。
- en: Now that we are able to show data next to the board and work with servos, we
    will connect our IoT device to the entire world and work with cloud services,
    which is the topic of the next chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够将数据展示在黑板上并使用伺服电机，我们将把我们的物联网设备连接到整个世界，并使用云服务，这正是下一章的主题。
