- en: Setting Up Projects and Processes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目和流程
- en: Our first iteration is all about getting things ready for all of the following
    iterations, and for any development efforts after the project is initially complete—bug
    fixes, maintenance, new feature requests, and so on. This sort of preparation
    will need to be undertaken for any new development effort over a certain expected
    degree of complexity, but it may not be broken out into its own iteration. Creating
    many of the foundational structures could be managed as part of other iterations;creating
    the project's structure when the first development that needs it starts, for example.
    The trade-off that's tied into taking that approach is that there is a higher
    probability that early definition work will have to be significantly altered as
    later development unfolds because that original structure couldn't accommodate
    multiple Python virtual environments, or the addition of a new project to the
    system's code base.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个迭代是为所有以下迭代以及项目最初完成后的任何开发工作做好准备。这种准备工作需要为预期复杂程度的任何新开发工作进行，但可能不会被分解为自己的迭代。许多基础结构的创建可以作为其他迭代的一部分来管理；例如，当需要它的第一个开发开始时创建项目的结构。采取这种方法的权衡是，较早的定义工作很可能会在后续开发展开时被显著改变，因为最初的结构无法容纳多个Python虚拟环境，或者将新项目添加到系统代码库中。
- en: Having some standard structural definitions, like the ones from [Chapter 6](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=30&action=edit), *Development
    Tools and Best Practices,* will minimize a fair number of these concerns going
    forward, but may not prevent them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一些标准的结构定义，比如[第6章](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=30&action=edit)，《开发工具和最佳实践》，将最大程度地减少这些问题，但可能无法完全防止它们。
- en: 'This chapter will cover the setup and preparation items that are common to
    most projects:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖大多数项目共有的设置和准备工作：
- en: '**Source Code Management** (**SCM**)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码管理（SCM）
- en: Project organization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目组织
- en: Unit testing structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试结构
- en: Build and deploy processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和部署流程
- en: Iteration goals
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代目标
- en: 'The deliverables of this iteration are mostly focused, then, on the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这次迭代的交付成果主要集中在以下方面：
- en: A master repository, stored in a Git server or service (local server, GitHub,
    or Bitbucket, for example) that contains the complete, empty project structure
    for the system and its component projects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主存储库，存储在Git服务器或服务（例如本地服务器、GitHub或Bitbucket）中，包含系统及其组件项目的完整空项目结构
- en: A component project for each deployable class library or application in the
    system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中每个可部署的类库或应用程序的组件项目
- en: A unit test suite that can be executed and whose execution passes for each component
    project in the system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中每个组件项目的单元测试套件都可以执行，并且其执行对每个组件项目都通过
- en: A build process for each component project – also executable – that results
    in a deployable package, even if that package starts as something that's essentially
    useless
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件项目的构建过程-也是可执行的-会产生一个可部署的软件包，即使该软件包起初是基本无用的
- en: Assembly of stories and tasks
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故事和任务的组装
- en: 'The needs of developers can also be expressed as stories, with tasks to execute. These
    foundational stories may be reused over multiple projects, and if they are, will
    likely evolve over time to better capture common needs and goals across development
    efforts—even for radically different systems. These should suffice as a starting
    point for now:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员的需求也可以表达为故事，并附有要执行的任务。这些基础故事可能会在多个项目中重复使用，并且如果是这样，它们可能会随着时间的推移而不断发展，以更好地捕捉跨开发工作的常见需求和目标-即使是对于根本不同的系统。这些应该足以作为现在的起点：
- en: 'As a developer, I need to know how source code for the system is going to be
    managed and version controlled so that I will be able to appropriately keep/store
    the code I write:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要知道系统的源代码将如何被管理和版本控制，以便我能够适当地保留/存储我编写的代码：
- en: Create a blank SCM repository for the system—`hms_sys`
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为系统创建一个空的SCM存储库-`hms_sys`
- en: Populate the repository with baseline information and documentation needed for
    ongoing use
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充存储库所需的基线信息和文档，以供持续使用
- en: Establish and distribute whatever credentials are needed for dev team members
    to access the repository
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立和分发开发团队成员访问存储库所需的凭据
- en: 'As a developer, I need to know what the full structure of the system looks
    like, at least at a high level, so that I will be able to write code that fits
    into that structure. This will involve:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要知道系统的完整结构看起来是什么样子，至少在高层次上，以便我能够编写符合该结构的代码。这将涉及：
- en: Analyzing the use cases, and the logical and physical architecture, to define
    the component project's needs and its structure
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析用例以及逻辑和物理架构，以定义组件项目的需求和结构
- en: Building out standard project starting points for each component project identified
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个组件项目构建标准的项目起点
- en: Implementing a minimal `setup.py` for each component project that completes
    a source package build
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个组件项目实施一个最小的`setup.py`，完成源代码包的构建
- en: Determining whether or not to use Python virtual environments for component
    projects, implement them, and document how they can be reproduced
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定是否要为组件项目使用Python虚拟环境，实施它们，并记录如何复制它们
- en: 'As a developer, I need to know how and where to write unit tests for the code
    base so that I can create unit tests after the code is written. I also need to
    ensure that the code is thoroughly tested:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要知道如何以及在哪里为代码库编写单元测试，以便在编写代码后创建单元测试。我还需要确保代码经过彻底测试：
- en: Define unit testing standards/requirements (coverage, standard values by type,
    and so on)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义单元测试的标准/要求（覆盖率、按类型的标准值等）
- en: Implement a mechanism for enforcing those standards
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施强制执行这些标准的机制
- en: Define where unit test code is going to reside in a component project's structure
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义单元测试代码将存放在组件项目结构中的位置
- en: Implement a basic, top-level test for each component project that executes without
    any failures
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个组件项目实施一个基本的顶层测试，以确保没有任何失败
- en: 'As a developer, I need to know how to integrate unit tests for a component
    project into the build process for that component project so that builds can automatically
    execute unit tests, which involves:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要知道如何将组件项目的单元测试集成到该组件项目的构建过程中，以便构建可以自动执行单元测试，其中包括：
- en: Determining how to integrate unit tests into the build process; and
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定如何将单元测试集成到构建过程中；以及
- en: Determining how to deal with build/test integration for different environments
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定如何处理不同环境的构建/测试集成
- en: Setting Up SCM
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置SCM
- en: 'Since the balance of the activities that need to happen in this iteration will
    ultimately need to be stored in SCM, the first story from the list that will be
    undertaken, with its tasks, is the following one:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此迭代中需要进行的大部分活动最终需要存储在SCM中，因此将首先进行列表中的第一个故事及其任务：
- en: 'As a developer, I need to know how source code for the system is going to be
    managed and version controlled, so that I will be able to appropriately keep/store
    the code I write:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要知道系统的源代码将如何被管理和版本控制，以便我能够适当地保留/存储我编写的代码：
- en: Create a blank SCM repository for the system—``hms_sys``
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为系统创建一个空的SCM存储库——`hms_sys`
- en: Populate the repository with the baseline information and documentation needed
    for ongoing use
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充存储库所需的基线信息和文档，以供日常使用
- en: Establish and distribute whatever credentials are needed for dev team members
    to access the repository
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立并分发团队成员访问存储库所需的凭据
- en: 'The code for `hms_sys` is going to live in Bitbucket ([https://bitbucket.org](https://bitbucket.org)),
    in a Git repository, so the first step is to set Up a new repository there:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`hms_sys`的代码将存储在Bitbucket（[https://bitbucket.org](https://bitbucket.org)）中的Git存储库中，因此第一步是在那里设置一个新存储库：'
- en: '![](assets/3633e5d7-d6fd-47de-97a4-ea8ac5c36ee2.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3633e5d7-d6fd-47de-97a4-ea8ac5c36ee2.png)'
- en: 'The settings for the new repository are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 新存储库的设置如下：
- en: 'Owner: The user who owns the repository. If multiple users have access to the
    repository through the Bitbucket account, or if there are groups associated with
    it, those users and groups will be available as options for this setting.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有者：拥有存储库的用户。如果多个用户通过Bitbucket帐户访问存储库，或者与之关联的组，这些用户和组将作为此设置的选项可用。
- en: 'Repository name: The (required) name of the repository. Ideally, a repository
    name should be easily associated with the system or project that it contains,
    and since `hms_sys` is both the name of the overall project and it wasn''t already
    taken, that was used.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库名称：存储库的（必需）名称。理想情况下，存储库名称应该与其包含的系统或项目轻松关联起来，由于`hms_sys`既是整个项目的名称，而且尚未被使用，因此被使用。
- en: 'Access level: Determines whether the repository is public or private. Since
    `hms_sys` is not intended for public perusal or distribution, the repository has
    been made private.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问级别：确定存储库是公共的还是私有的。由于`hms_sys`不打算供公众查阅或分发，因此存储库已被设置为私有。
- en: 'Include a README?: Whether the system will create a `README` file as part of
    the creation process. The options are as follows:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括README？：系统是否将在创建过程中创建一个`README`文件。选项如下：
- en: No: Will require the manual creation of the file later, if one is even needed/desired.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否：如果需要/希望，将需要手动创建文件。
- en: Yes, with a template: Creates a basic file with minimal information. This option
    was selected so that a basic `README` file would be created.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是，带模板：创建一个带有最少信息的基本文件。选择此选项是为了创建一个基本的`README`文件。
- en: Yes, with a tutorial (for beginners).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是，有教程（适用于初学者）。
- en: 'Version control system: Allows the repository to use either Git or Mercurial
    as its SCM engine. Git was selected because that''s what we decided to use.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制系统：允许存储库使用Git或Mercurial作为其SCM引擎。选择了Git，因为这是我们决定使用的。
- en: 'The Advanced settings have to be expanded to be available, and are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 高级设置必须扩展才能使用，并且如下所示：
- en: 'Description: Any description provided here will be added to the `README` file
    if the Yes, with a template option was selected.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：如果选择了“是，带模板”选项，此处提供的任何描述都将添加到`README`文件中。
- en: 'Forking: Controls whether/how forking is allowed from the repository. The options
    are as follows:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生：控制是否/如何允许从存储库派生。选项如下：
- en: Allow forks: Anyone who has access can fork the repository
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许派生：任何有权限的人都可以派生存储库
- en: Allow only private forks
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅允许私有派生
- en: No forks
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许派生
- en: 'Project management: Allows the integration of issue tracking and wiki systems
    with the repository.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目管理：允许将问题跟踪和wiki系统与存储库集成。
- en: 'Language: Specifies a primary programming language for the code in the repository.
    This setting doesn''t do anything other than categorize the repository by its
    primary language, at least initially. Some SCM providers will use the language
    settings to pre-populate Git''s `.gitignore` file with commonly ignored file patterns,
    though, so it''s advantageous to specify it if possible.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言：指定存储库中代码的主要编程语言。最初，此设置除了按其主要语言对存储库进行分类外，并不起作用。一些SCM提供商将使用语言设置来预先填充Git的`.gitignore`文件，其中包含常被忽略的文件模式，因此如果可能的话，指定它是有利的。
- en: 'Once the Create repository button is clicked, the repository will be created:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“创建存储库”按钮后，将创建存储库：
- en: '![](assets/bd3bedd7-14cd-4d16-9248-6e73670d0d99.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bd3bedd7-14cd-4d16-9248-6e73670d0d99.png)'
- en: 'From the overview page for any repository, the HTTPS and SSH options for connecting
    to and cloning/pulling the repository are available, and anyone who has the requisite
    permissions can clone it (by whatever means are preferred) to a local copy to
    work with it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何存储库的概述页面，连接和克隆/拉取存储库的HTTPS和SSH选项都可用，有必要权限的任何人都可以克隆它（以任何首选方式）到本地副本进行操作：
- en: '![](assets/c9c540d9-904a-4c59-98e7-a05af6cc69c8.png)There are several ways
    to initialize a new Git repository. This process, starting at the repository''s
    provider, assures that the repository is well-formed and accessible, as well as
    allowing for some initial configuration and documentation setup that won''t have
    to be done by hand later.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c9c540d9-904a-4c59-98e7-a05af6cc69c8.png)有几种初始化新的Git存储库的方法。这个过程从存储库的提供者开始，确保存储库格式良好且可访问，同时允许进行一些初始配置和文档设置，以后不必手动完成。'
- en: 'At this point, two of the tasks from the story are resolved:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，故事中的两项任务已解决：
- en: Create a blank SCM repo for the system—`hms_sys`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为系统创建一个空的SCM存储库——`hms_sys`。
- en: Establish and distribute whatever credentials are needed for dev team members
    to access the repository. Since the repository was created through the external
    service provider's interface, the credentials needed for access are managed there,
    and anyone whose user account is associated with the repository's accounts or
    groups either has the access they'll need, or can be given it through the user
    management in the provider's system.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立并分发开发团队成员访问存储库所需的凭据。由于存储库是通过外部服务提供商的界面创建的，因此访问所需的凭据是在那里管理的，任何与存储库的帐户或组相关联的用户帐户都具有他们需要的访问权限，或者可以通过提供商系统中的用户管理来获得访问权限。
- en: The remaining task, populated with baseline information and the documentation
    needed for ongoing use, has ties to the project structure that haven't been addressed,
    but there are still items that can be addressed that are independent of that.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的任务，填充了基线信息和持续使用所需的文档，与尚未解决的项目结构有关，但仍然有一些可以解决的独立项目。
- en: First is the creation and documentation of the base component projects in the
    top-level repository directory. Initially, it's probably a good idea to create
    a top-level project, encompassing the entire system code base—this will provide
    a single project that can be used to organize items that span two or more of the
    component projects, as well as anything that encompasses the system as a whole.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是在顶层存储库目录中创建和记录基本组件项目。最初，创建一个顶层项目，包含整个系统代码库可能是一个好主意——这将提供一个单一的项目，用于组织跨两个或多个组件项目的项目，以及涵盖整个系统的任何内容。
- en: 'In Geany, that''s accomplished by using Project → New, supplying a project
    name, project file path, and a base path for the project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Geany中，通过使用Project → New来完成，提供项目名称、项目文件路径和项目的基本路径：
- en: '![](assets/f2e94a29-c46c-450b-a006-5ed04eae1f5d.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f2e94a29-c46c-450b-a006-5ed04eae1f5d.png)'
- en: 'Since Geany project files store filesystem paths that may vary from one machine
    to another, those need to be added to Git''s `.gitignore` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Geany项目文件存储可能因机器而异的文件系统路径，这些路径需要添加到Git的`.gitignore`文件中：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `.gitignore` file is, ultimately, a list of files and/or folders that Git
    will ignore when committing or pushing code to the central repository. Any file
    or folder that matches one of the paths in `.gitignore` will not be tracked by
    the SCM.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`.gitignore`文件最终是Git提交或推送代码到中央存储库时Git将忽略的文件和/或文件夹的列表。与`.gitignore`中路径匹配的任何文件或文件夹将不会被SCM跟踪。'
- en: 'Additionally, instructions for creating a local `hms_sys.geany` file should
    probably be documented so that any other developer who needs one can create one
    as needed. That sort of information can be dropped into the `README.md` file,
    and similar efforts will be undertaken as the component projects for the system
    are added:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可能需要记录创建本地`hms_sys.geany`文件的说明，以便任何其他需要的开发人员可以根据需要创建。这类信息可以放入`README.md`文件中，并且在添加系统的组件项目时将进行类似的工作：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once these changes are staged, committed locally, and pushed to the master
    repository, what should appear there is a revised `README.md` file and a new `.gitignore`,
    but not the `hms_sys.geany` project file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些更改被暂存、本地提交并推送到主存储库，那里应该出现一个修订后的`README.md`文件和一个新的`.gitignore`，但不会出现`hms_sys.geany`项目文件：
- en: '![](assets/a1d0b88d-71d2-413b-bcf5-a0fe8a54df03.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a1d0b88d-71d2-413b-bcf5-a0fe8a54df03.png)'
- en: As the component projects get added into the code base, the same sort of documentation
    and setup should be followed, yielding similar results. At this point, the final
    task of the first story is as complete as it can be, so it would be reviewed and
    closed if it was judged complete and approved.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着组件项目被添加到代码库中，应该遵循相同类型的文档和设置，产生类似的结果。此时，第一个故事的最终任务已经完成，如果被判定为完成并获得批准，那么它将被审查和关闭。
- en: Stubbing out component projects
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件项目的存根
- en: 'On, then, to the next story:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进行下一个故事：
- en: 'As a developer, I need to know what the full structure of the system looks
    like, at least at a high level, so that I will be able to write code that fits
    into that structure:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要知道系统的完整结构是什么样子，至少在高层次上，这样我才能编写适合该结构的代码：
- en: Analyze the use cases, and the logical and physical architecture to define the
    component project's needs and its structure
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析用例和逻辑和物理架构，以定义组件项目的需求和结构。
- en: Build out standard project starting points for each component project identified
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个确定的组件项目构建标准项目起点
- en: Implement a minimal `setup.py` for each component project that completes a source
    package build
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个组件项目实现一个最小的`setup.py`，完成源包构建
- en: Component project analysis
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件项目分析
- en: 'The logical architecture, along with the use cases diagram from [Chapter 6](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=30&action=edit), *Development
    Tools and Best Practices,* indicates three obvious component projects that will
    need to be accounted for, one each for the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑架构以及[第6章](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=30&action=edit)的用例图，*开发工具和最佳实践*，指出了三个明显的组件项目，需要分别为以下内容进行核算：
- en: The **Artisan Application**
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠应用程序
- en: The **Artisan Gateway**
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠门户
- en: The **Review/Manage Application**
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查/管理应用程序
- en: 'Each of these component projects, in turn, needs access to some common object
    types—they all need to be able to handle **Product** instances, and most of them
    also need to be able to work with **Artisan** and **Order** instances as well:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件项目中的每一个都需要访问一些常见的对象类型——它们都需要能够处理**产品**实例，并且它们中的大多数也需要能够处理**工匠**和**订单**实例：
- en: '![](assets/4d63b4a0-ca46-4c5d-80a0-24978af874b5.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4d63b4a0-ca46-4c5d-80a0-24978af874b5.png)'
- en: 'There may well be other business objects that aren''t immediately apparent
    from this breakout, but the fact that there are any is a good sign that there
    is probably a need for a fourth component project to collect the code that provides
    those business objects and their functionality. With that in mind, the initial
    component project structure boils down to this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他业务对象，从这个分解中并不立即显而易见，但是有任何业务对象的事实都表明可能需要第四个组件项目来收集提供这些业务对象及其功能的代码。考虑到这一点，初始的组件项目结构归结如下：
- en: '**HMS Core** (`hms-core`): A class library collecting all of the baseline business
    object definitions to provide representations of objects such as **artisans**,
    **products**, and **orders**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HMS核心**（`hms-core`）：一个类库，收集所有基线业务对象定义，以提供**工匠**、**产品**和**订单**等对象的表示'
- en: '**The Central Office Application** (`hms-co-app`): Provides an executable application
    that allows Central Office staff to perform various tasks that require communication
    with an **Artisan** about **products**, **orders**, and perhaps other items as
    well'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中央办公室应用**（`hms-co-app`）：提供一个可执行的应用程序，允许中央办公室工作人员执行需要与**工匠**关于**产品**、**订单**以及可能其他项目进行通信的各种任务'
- en: '**The Artisan Application** (`hms-artisan`): Provides an executable local application
    that allows an **Artisan** to manage **products** and **orders**, communicating
    with the Central Office as needed'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工匠应用**（`hms-artisan`）：提供一个可执行的本地应用程序，允许**工匠**管理**产品**和**订单**，根据需要与中央办公室进行通信'
- en: '**The HMS Artisan Gateway** (`hms-gateway`): Provides an executable service
    that the **Artisan** Application and Central Office Application use to send information
    back and forth between the artisans and the Central Office'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HMS工匠网关**（`hms-gateway`）：提供一个可执行服务，**工匠**应用程序和中央办公室应用程序用于在工匠和中央办公室之间发送信息'
- en: Component project setup
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件项目设置
- en: Some decisions will have to be made later on about how the `hms-core` code will
    be included in distributions of the other projects that require it, but those
    don't need to be tackled until they're reached, so they'll be set aside for now.
    In the meantime, setting Up starting point project structures for each of the
    component projects is the next step. The basic structure, for now, is identical
    across all four of the component projects;the only differences will be in the
    names of the various files and directories.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`hms-core`代码将如何包含在需要它的其他项目的分发中，稍后将需要做出一些决定，但这些不需要立即解决，因此它们将被搁置。与此同时，为每个组件项目设置起点项目结构是下一步。目前，基本结构在所有四个组件项目中都是相同的；唯一的区别在于各种文件和目录的名称。
- en: 'Using `hms-core` as an example, since that''s the first logical code set to
    start working on, the project structures will look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以`hms-core`为例，因为这是第一个逻辑上要开始工作的代码集，项目结构将如下所示：
- en: '![](assets/3246869b-f7de-4208-9ee1-e93b0521f081.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3246869b-f7de-4208-9ee1-e93b0521f081.png)'
- en: Packaging and build process
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和构建过程
- en: 'Setting up the minimal standard Python packaging for a project and providing
    the bare-bones build process makes very few changes to the baseline `setup.py`
    and `Makefile` files that were discussed earlier. There are only a few specifics
    that are available before code starts being written: the package name and the
    top-level directory of the main package that `setup.py` will use, and the `setup.py`
    file itself that can be added to the `Makefile`.  The `Makefile` changes are the
    simplest:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目设置最小标准的Python打包，并提供基本的构建过程，对之前讨论过的`setup.py`和`Makefile`文件几乎没有做出任何改变。在编写代码之前只有一些具体的内容可用：`setup.py`将使用的包名称和主包的顶级目录，以及可以添加到`Makefile`中的`setup.py`文件。`Makefile`的更改是最简单的：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `setup.py` file, though it''s been populated with some starting data and
    information, is still pretty much the same bare-bones starting point file that
    we saw earlier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件，尽管它已经填充了一些起始数据和信息，但仍然基本上是我们之前看到的同样基本的起点文件：'
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This structure will not acquire any of the various directories and files outside
    the core package just yet either—at this point, there''s no indication that any
    of them will be needed, so their inclusion will be left until there''s an actual
    need for them. Even without those, though, the `setup.py` file can successfully
    build and install the source distribution package, though it throws a few warnings
    during the build process, and the installed package doesn''t provide any functionality
    yet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构暂时还不会包括核心包之外的各种目录和文件——在这一点上，没有迹象表明它们中的任何一个是必需的，因此它们的包含将被推迟，直到确实需要它们。即使没有这些，`setup.py`文件也可以成功构建和安装源分发包，尽管在构建过程中会抛出一些警告，并且安装的包目前还没有提供任何功能：
- en: '![](assets/41827bb6-0523-4d13-bd79-6c1031958583.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/41827bb6-0523-4d13-bd79-6c1031958583.png)'
- en: 'In larger (or at least more formally structured) development shops, the build/packaging
    processes for component projects may well need to accommodate different builds
    for different environments:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大（或至少更正式结构化）的开发商店中，组件项目的构建/打包过程可能需要适应不同环境的不同构建：
- en: A local environment, such as the developers' local machines
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地环境，比如开发人员的本地机器
- en: A shared development environment, where all developers' local code changes first
    mix together
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个共享的开发环境，所有开发人员的本地代码更改首先混合在一起
- en: A shared test server for QA and broader integration testing
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于QA和更广泛的集成测试的共享测试服务器
- en: A User Acceptance Testing server, using realistic, production-like data that
    can be used to demonstrate functionality to whoever needs to give final approval
    for changes to be promoted to a live environment or build
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用真实的、类似生产的数据的用户验收测试服务器，可以用来向需要最终批准变更的人演示功能
- en: A staging environment that has full access to a complete copy of production
    data, with an eye toward being able to perform load and other tests that require
    access to that dataset
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有完整生产数据副本访问权限的暂存环境，以便能够执行需要访问该数据集的负载和其他测试
- en: The live environment/build code base
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: live环境/构建代码库
- en: There is at least *some* potential for needing significant differentiation between
    these different builds (`local`, `dev`, `test`, `stage`, and `live`, with the
    user acceptance build assumed to be identical to a stage build for the time being).
    At this point in the development effort, though, there really isn't anything to
    differentiate, so the best that can be done is to plan around what will happen
    if it is needed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有一些潜力需要在这些不同的构建（`local`、`dev`、`test`、`stage`和`live`，用户验收构建暂时假定与阶段构建相同）之间进行重大区分。然而，在开发工作的这一阶段，实际上并没有什么可以区分的，因此唯一能做的就是计划如果需要时会发生什么。
- en: Until there is a need for a completely different package structure for any given
    environment, the current `setup.py` file will remain untouched. It's highly unlikely
    that there will be an environment-specific need that isn't common across all environments.
    If such a need does arise, then the approach will be to create a distinct `setup.py`
    for each environment that has any distinct needs, and execute that specific `setup.py`,
    either manually or though the `Makefile`. With some care and thought, this should
    allow any environment-specific variances to be contained in a single location,
    and in a reasonably standard fashion.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定环境需要完全不同的包结构之前，当前的`setup.py`文件将保持不变。几乎不太可能存在一个环境特定的需求，这种需求在所有环境中都不常见。如果确实出现这种需求，那么方法将是为每个具有任何独特需求的环境创建一个单独的`setup.py`，并手动或通过`Makefile`执行该特定的`setup.py`。经过一些谨慎和思考，这应该可以将任何特定于环境的差异包含在一个单一位置，并以合理标准的方式进行。
- en: 'That, in turn, means that there will have to be changes made to the `Makefile`.
    Specifically, there will need to be a target for each environment-specific build
    process (`dev` through `live` again), and some way of managing files that are
    specific to one of those environments. Since the `make` process can manipulate
    files, create directories, and so on, the strategy that will be used will be to
    do the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`Makefile`将需要进行更改。具体来说，每个特定环境的构建过程（从`dev`到`live`）都需要一个目标，并且需要一种管理特定环境文件的方法。由于`make`过程可以操作文件，创建目录等，将使用以下策略：
- en: Identify environment-specific files by prefixing them with the build target/environment
    name that they relate to. For example, there would be a `dev-setup.py` file in
    the code base, as well as a `test-setup.py` file, and so on.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为特定环境的文件添加构建目标/环境名称前缀来识别特定于环境的文件。例如，代码库中将有一个`dev-setup.py`文件，以及一个`test-setup.py`文件，依此类推。
- en: Altering the `Makefile` to make a copy of all relevant files in the project's
    code tree that can be altered (and destroyed) without impacting the core project
    files.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`Makefile`以复制项目代码树中所有可以更改（和销毁）的相关文件，而不影响核心项目文件
- en: Adding a process that will find and rename all of the environment-specific files
    in the temporary copy as needed for a specific environment's build, and removing
    any environment-specific files from the temporary tree that aren't relevant to
    the build.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个过程，将在临时副本中查找并重命名所有特定于环境的文件，以满足特定环境的构建需求，并删除临时树中与构建无关的特定环境文件。
- en: Executing the `setup.py` file as normal.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`setup.py`文件
- en: The changes that would be made to the `Makefile` would look something like this,
    at least as a starting point.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Makefile`的更改将至少在起点上看起来像这样。
- en: 'First, define a common temporary build directory—the local build will be the
    default, and will simply execute the standard `setup.py` file, just as the original
    process did:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个通用的临时构建目录——本地构建将是默认的，并且将简单地执行标准的`setup.py`文件，就像原始过程一样
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A new target, `build_dir`, is created to create the temporary build directory,
    and to copy all of the project files that can be part of any build into it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的目标`build_dir`，用于创建临时构建目录，并将可以成为任何构建的项目文件复制到其中
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A prep target for each environment, as well as the final target for each, will
    be written to rename and remove files as needed, and to execute the `setup.py` file in
    the temporary build directory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个环境编写一个准备目标，以及每个环境的最终目标，将重命名和删除文件，并在临时构建目录中执行`setup.py`文件
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, when `make dev` is executed against this `Makefile`, the `dev` target runs
    the `unit_test` target, and then the `build_dir` target is used to create the
    temporary copy of the project. Afterwards, `dev_prep` is used to deal with the
    filename changes and the removal of files from other environments. Then, and only
    then, will it execute the remaining `setup.py`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当针对此`Makefile`执行`make dev`时，`dev`目标运行`unit_test`目标，然后使用`build_dir`目标创建项目的临时副本。之后，使用`dev_prep`处理文件名更改和其他环境的文件删除。然后才会执行剩余的`setup.py`。
- en: Python virtual environments
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python虚拟环境
- en: The final task to address is determining whether or not to use Python virtual
    environments for the various component projects, creating them if needed, and
    documenting how to create them so that other developers will be able to reproduce
    them if/as needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要解决的任务是确定是否要为各个组件项目使用Python虚拟环境，如有需要则创建它们，并记录如何创建它们，以便其他开发人员在需要时能够复制它们。
- en: Given the structure across the component projects, what is known about them,
    and how their installed code is expected to interact with other system members,
    there isn't an obvious need for different environments, or even an obvious advantage
    to establishing them. Provided that sufficient care and discipline were exercised
    during development, making sure that dependencies got added to each component
    project's `setup.py` or other build process artifacts or configuration, the worst-case
    scenario that would likely arise is that a missing dependency would be discovered
    during the process of performing a test installation. In an otherwise bug-free
    live installation, there might be some trivial inefficiencies that would creep
    in—the `hms-gateway` project, for example, might install database or GUI libraries
    that it won't need or doesn't use, or the two component projects might both have
    message-system libraries that the other users installed, but which aren't needed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于组件项目之间的结构、对它们的了解以及预期安装代码与其他系统成员的交互方式，显然没有必要为不同的环境建立，甚至没有明显的优势。只要在开发过程中充分注意和遵守，确保每个组件项目的`setup.py`或其他构建过程工件或配置中添加了依赖关系，最有可能出现的最坏情况是在执行测试安装的过程中发现缺少的依赖关系。在其他方面没有错误的实时安装中，可能会出现一些微不足道的低效率，例如`hms-gateway`项目可能会安装数据库或GUI库，它不需要或不使用，或者两个组件项目可能都安装了其他用户安装的消息系统库，但并不需要。
- en: None of these represent any sort of imminent threat to the operation of the
    individual component project installations, but they do throw unnecessary code
    into the installations. The potential for significant creep of needless library
    installations is very real if it isn't carefully watched and managed, and could
    be a vector for security issues in the future. Worse, any potential security issues
    might not be visible as a result; if no-one is really aware that something not
    needed got installed with a given program, then it may not get fixed until it's
    too late.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不会对单个组件项目的操作构成任何即将发生的威胁，但它们确实会将不必要的代码引入到安装中。如果不仔细观察和管理，不必要的库安装可能会大量增加，这可能成为未来安全问题的一个因素。更糟糕的是，任何潜在的安全问题可能不会被视为结果；如果没有人真正意识到某个程序安装了不需要的东西，那么直到为时已晚才会得到修复。
- en: One of the first best steps that can be taken to keep systems secure is to assure
    that they only have exactly what they need to function installed. That won't cover
    every possibility, but it will reduce the bandwidth needed to keep current with
    patches and security issues.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保系统安全，可以采取的第一步是确保它们只安装了必要的功能。这样做不会覆盖所有可能性，但会减少保持当前补丁和安全问题所需的带宽。
- en: Keeping track of dependencies on a project-by-project basis is something that
    virtual environments can make a difference in. That's a point in favor of setting
    them Up for each project individually. Another point in favor of this practice
    is that some platforms, such as the various public clouds, will require the ability
    to include dependent packages as part of their deployment process, and a virtual
    environment will keep those nicely separated from the core system installation
    package set. In that respect, virtual environments are also, then, a type of future-proofing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个项目跟踪依赖关系是虚拟环境可以发挥作用的地方。这是为每个项目单独设置它们的一个优点。另一个支持这种做法的观点是，一些平台，如各种公共云，将需要能够在其部署过程中包含依赖包的能力，而虚拟环境将把它们很好地与核心系统安装包集分开。在这方面，虚拟环境也是一种未来的保障。
- en: 'In the context of developing `hms_sys`, then, we''ll set up a separate virtual
    environment for each component project. If they prove unnecessary later on, they
    can always be deleted. The processes for creating, activating, and deactivating
    them are pretty straightforward, and can be created wherever is convenient—there
    isn''t really any standard location — the commands vary per Operating System,
    though, as shown below:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开发`hms_sys`的情况下，我们将为每个组件项目设置一个单独的虚拟环境。如果以后证明它们是不必要的，它们总是可以被删除的。创建、激活和停用它们的过程非常简单，并且可以在任何方便的地方创建——实际上没有标准位置——命令因操作系统而异，如下所示：
- en: '| Virtual Environment Activity | Operating system |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: 虚拟环境活动 | 操作系统
- en: '| Linux/MacOS/Unix | Windows |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: Linux/MacOS/Unix | Windows
- en: '| Creating | `python3 -m venv ~/path/to-myenv` | `c:\>c:\Python3\python -m
    venv c:\path\to\myenv` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: 创建 | `python3 -m venv ~/path/to-myenv` | `c:\>c:\Python3\python -m venv c:\path\to\myenv`
- en: '| Activating | `source ~/path/to-myenv/bin/activate` | `C:\> c:\path\to\myenv\Scripts\activate.bat`
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: 激活 | `source ~/path/to-myenv/bin/activate` | `C:\> c:\path\to\myenv\Scripts\activate.bat`
- en: '| Deactivating | `deactivate` | `C:\> c:\path\to\myenv\Scripts\deactivate.bat`
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: 停用 | `deactivate` | `C:\> c:\path\to\myenv\Scripts\deactivate.bat`
- en: Once a virtual environment is created and activated, packages can be installed
    in it with `pip` (or `pip3`), just like outside the virtual environment's context.
    Installed packages are stored in the virtual environment's libraries, instead
    of in the global system libraries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和激活虚拟环境后，可以像在虚拟环境之外一样使用`pip`（或`pip3`）在其中安装包。安装的包存储在虚拟环境的库中，而不是全局系统库中。
- en: Documenting which virtual environments are associated with which component projects
    is just a matter of copying the commands needed to create it into project-level
    documentation somewhere. For `hms_sys`, these will be stored in the `README.md`
    files for each component project.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 记录哪些虚拟环境与哪些组件项目相关，只是将创建它所需的命令复制到项目级文档的某个地方。对于`hms_sys`，这些将存储在每个组件项目的`README.md`文件中。
- en: 'Let''s review the tasks for this story:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个故事的任务：
- en: Analyze the use cases, and the logical and physical architecture to define component-project
    needs and structure—**Done**
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析用例，逻辑和物理架构，以定义组件项目的需求和结构——**完成**
- en: Build out standard project starting points for each component project identified—**Done**
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个已识别的组件项目构建标准项目起点——**完成**
- en: Implement a minimal `setup.py` file for each component project that completes
    a source package build—**Done**
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个组件项目实施一个最小的`setup.py`文件，完成源包构建—**完成**
- en: Determine whether or not to use Python virtual environments for component projects,
    implement them, and document how they can be reproduced—**Done**
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定是否要为组件项目使用Python虚拟环境，实施它们，并记录如何重现它们—**完成**
- en: Providing a unit testing structure
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个单元测试结构
- en: 'At the end of the previous chapter, it was noted that although an expectation
    had been set that all code would be unit-tested, with all public members of modules
    and classes subject to that requirement, it was also noted that no test policy
    details had been defined yet, which is a good part of what the unit testing story
    in this iteration is all about:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的最后指出，尽管已经设定了对所有代码进行单元测试的期望，并且所有模块和类的公共成员都受到了该要求的约束，但也指出尚未定义任何测试策略细节，这正是本次迭代中单元测试故事的重要部分：
- en: 'As a developer, I need to know how and where to write unit tests for the code
    base so that I can create unit tests after the code is written. I also need to
    assure that the code is thoroughly tested:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要知道如何以及在何处为代码库编写单元测试，以便在编写代码后创建单元测试。我还需要确保代码经过彻底测试：
- en: Define unit testing standards/requirements (coverage, standard values by type,
    and so on)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义单元测试标准/要求（覆盖率、按类型的标准值等）
- en: Implement a mechanism for enforcing those standards
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施一个机制来强制执行这些标准
- en: Define where unit test code is going to reside in a component project's structure
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义单元测试代码将存放在组件项目结构中的何处
- en: Implement a basic, top-level test for each component project that executes without
    any failures
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个组件项目实施一个基本的顶层测试，以确保没有任何失败
- en: The bulk of this unit testing material was adapted and converted into Python
    3 from Python 2.7.x code and a discussion of this is on the author's blog (starting
    at [bit.ly/HOSEP-IDIC-UT](http://bit.ly/HOSEP-IDIC-UT)). Though that code was
    written for an older version of Python, there may be additional insights to be
    gained from the unit testing articles there.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单元测试材料的大部分内容都是从Python 2.7.x代码转换和改编而来的，关于这一点的讨论可以在作者的博客上找到（从[bit.ly/HOSEP-IDIC-UT](http://bit.ly/HOSEP-IDIC-UT)开始）。尽管该代码是为较旧版本的Python编写的，但可能还可以从那里的单元测试文章中获得额外的见解。
- en: 'It could be argued that all members, not just the public ones, should be tested—after
    all, if the code in question gets used anywhere, it should also be held to the
    same standards as far as predictable behavior is concerned, yes? Technically,
    there''s no reason that can''t be done, particularly in Python where protected
    and private class members aren''t really protected or private they are merely
    treated as such by convention—in earlier versions of Python, protected members
    were accessible, and private members (prefixed with two underscores: `__private_member`)
    were not directly accessible in derived classes, except by calling them by their
    mangled name. In Python 3, there is no language-level enforcement of nominally
    protected or private scope, even though the name mangling is still in play. This
    is quickly demonstrated. Consider the following class definition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，应该测试所有成员，而不仅仅是公共成员——毕竟，如果涉及到的代码在任何地方被使用，那么就应该在可预测行为方面也要符合相同的标准，是吗？从技术上讲，没有理由不能这样做，特别是在Python中，受保护和私有类成员实际上并不受保护或私有——它们只是按照惯例被视为这样——在Python的早期版本中，受保护的成员是可以访问的，而私有成员（以两个下划线作为前缀：`__private_member`）在派生类中是不能直接访问的，除非通过它们的变形名称来调用。在Python
    3中，尽管名称修饰仍在起作用，但在语言级别上不再强制执行名义上的受保护或私有范围。这很快就可以证明。考虑以下类定义：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we were to create an instance of `ExampleParent`, and call its `show` method,
    we''d expect to see all three groups of output and that''s exactly what happens:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建`ExampleParent`的一个实例，并调用它的`show`方法，我们期望看到所有三组输出，这正是发生的：
- en: '![](assets/2b1d4a55-d5ba-4906-a7da-27ee5dd81a70.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2b1d4a55-d5ba-4906-a7da-27ee5dd81a70.png)'
- en: 'If the `ExampleParent` class structure is examined with `dir(ExampleParent)`,
    all three of the methods can be seen: [''`_ExampleParent__private_method`'', …,
    ''`_protected_method`'', ''`public_method`'', …]. In earlier versions of Python,
    a class derived from `ExampleParent` would still have access to `public_method`
    and `_protected_method`, but would raise an error if `__private_method` was called
    by that name. In Python 3 (and some later versions of Python 2.7.x), that is no
    longer the case.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`dir(ExampleParent)`检查`ExampleParent`类结构，可以看到所有三种方法：['`_ExampleParent__private_method`',
    …, '`_protected_method`', '`public_method`', …]。在Python的早期版本中，从`ExampleParent`派生的类仍然可以访问`public_method`和`_protected_method`，但如果通过该名称调用`__private_method`，则会引发错误。在Python
    3（以及一些较新版本的Python 2.7.x）中，情况已经不再是这样了。
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating an instance of this class, and calling its `show` method yields the
    same results:![](assets/24ed77f9-a8fd-49ac-a999-51d090e8aaa1.png)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个类的一个实例，并调用它的`show`方法会产生相同的结果：![](assets/24ed77f9-a8fd-49ac-a999-51d090e8aaa1.png)
- en: Technically then, all members of a Python class are public.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，那么Python类的所有成员都是公共的。
- en: 'So, what does that mean from the perspective of defining a unit testing policy,
    if all class members are public? If the public/protected/private convention is
    adhered to, then the following apply:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，从定义单元测试策略的角度来看，如果所有类成员都是公共的，这意味着什么？如果遵守了公共/受保护/私有的约定，那么以下内容适用：
- en: Public members should be tested in the test suite that corresponds to the class
    they are defined in (their class of origin)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共成员应该在与它们定义的类相对应的测试套件中进行测试（它们的原始类）
- en: Most protected members are likely intended to be inherited by derived classes,
    and should be tested in depth in the test suite that corresponds with the class
    they are defined in
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数受保护的成员可能打算被派生类继承，并且应该在与定义它们的类相对应的测试套件中进行深入测试
- en: Private members should be treated as if they really were private—not accessible
    at all outside their class of origin—or as if they were implementation details
    that are subject to breaking changes without warning
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有成员应该被视为真正的私有成员——在其原始类之外根本不可访问——或者被视为可能发生突发变化而无需警告的实现细节
- en: Inherited members shouldn't require any testing again, then, since they will
    have been tested against their class of origin
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承成员不需要再次进行任何测试，因为它们已经针对其原始类进行了测试
- en: Members that are overridden from their parent classes will be tested in the
    suite that relates to the class they are overridden in
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其父类重写的成员将在与其被重写的类相关的套件中进行测试
- en: Setting Up a unit testing process that applies all of these rules is possible,
    though it's moderately complex and substantial enough that it'd be really advantageous
    to be able to wrap it Up in some sort of reusable function or class so that it
    doesn't have to be recreated in every test process, or maintained across dozens
    or hundreds of copies of it if test policies change. The end goal would be to
    have a repeatable test structure that's quickly and easily implemented which implies
    that it could also be templated out in much the same way that modules and package
    headers were earlier.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 建立一个适用于所有这些规则的单元测试过程是可能的，尽管它相当复杂且足够实质性，以至于将其封装在某种可重复使用的函数或类中将非常有利，这样它就不必在每个测试过程中重新创建，或者在测试策略发生变化时在数十甚至数百个副本中进行维护。最终目标是拥有一个可重复的测试结构，可以快速轻松地实现，这意味着它也可以以与先前模块和包头部相同的方式进行模板化。
- en: 'First, though, we need something to test. Specifically, we need classes that
    have methods that fall into the categories that were noted previously:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些东西来测试。具体来说，我们需要具有方法的类，这些方法属于先前指出的类别：
- en: Defined locally
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地定义
- en: Inherited from a parent class
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从父类继承
- en: Overridden from a parent class
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从父类重写
- en: 'This covers all of the public/protected/private options. Though it wasn''t
    specifically mentioned previously, we should also include a class that has at
    least one abstract method.Those are still classes, and will also need to be tested;
    they just haven''t been addressed yet. They don''t need to be very complex to
    illustrate the test process, though they should return testable values. With all
    of that in mind, here is a simple set of classes that we''ll use to test against
    and to generate the core test process:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了所有公共/受保护/私有选项。虽然先前没有明确提到，但我们还应该包括一个至少有一个抽象方法的类。它们仍然是类，也需要进行测试；只是还没有被讨论过。它们不需要非常复杂来说明测试过程，尽管它们应该返回可测试的值。考虑到所有这些，这里是一组简单的类，我们将用它们来进行测试，并生成核心测试过程：
- en: These files are in the `hms_sys` code base, in the top-level `scratch-space`
    directory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件位于`hms_sys`代码库中，位于顶层`scratch-space`目录中。
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Creating a quick instance of each concrete class, and calling the `show` method
    of each instance, shows the anticipated results:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建每个具体类的快速实例，并调用每个实例的`show`方法，显示预期的结果：
- en: '![](assets/76292447-5806-4101-acb0-c649c747d0ba.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76292447-5806-4101-acb0-c649c747d0ba.png)'
- en: Basic unit testing
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本单元测试
- en: 'Unit testing in Python is supported by the built-in `unittest` module. There
    may be other modules that also provide unit testing functionality, but `unittest`
    is readily available, is installed in Python virtual environments by default,
    and provides all the testing functionality necessary for our purposes, at least
    as a starting point. The initial test module for the preceding classes is quite
    simple, even if it doesn''t do anything more than define the test case classes
    that apply to the code being tested:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的单元测试由内置的`unittest`模块支持。可能还有其他模块也提供单元测试功能，但`unittest`是readily available的，它默认安装在Python虚拟环境中，并且至少作为起点，提供了我们所需的所有测试功能。先前类的初始测试模块非常简单，即使它除了定义适用于被测试代码的测试用例类之外，什么也没做：
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each of the classes that begin with `test` (and that are derived from `unittest.TestCase`)
    will be instantiated by the `unittest.main()` call at the end of the module, and
    each method within those classes whose name also starts with `test` will be executed.
    If we add test methods to one of them, `testParent `for example, and run the test
    module as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以`test`开头的每个类（并且派生自`unittest.TestCase`）将由模块末尾的`unittest.main()`调用实例化，并且这些类中以`test`开头的每个方法都将被执行。如果我们向其中一个添加测试方法，例如`testParent`，并按以下方式运行测试模块：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The execution of the test methods can be seen:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到测试方法的执行：
- en: '![](assets/8564487b-106a-4bdd-9069-98606419bd70.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8564487b-106a-4bdd-9069-98606419bd70.png)'
- en: 'If the `print()` calls are replaced with a pass, as shown in the following
    code, the output is even simpler, printing a period for each test case''s test
    method that executes without raising an error:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`print()`调用被替换为`pass`，如下面的代码所示，输出会更简单，对于每个执行而不引发错误的测试用例的测试方法，会打印一个句点：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When executed, this yields the following:![](assets/f2124f2f-1f61-400a-9028-6170a1628ac4.png)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，会产生以下结果：![](assets/f2124f2f-1f61-400a-9028-6170a1628ac4.png)
- en: 'So far, so good then;we have tests that can be executed, so the next question
    is how to apply the test policy rules that we want applied. The first policy,
    having a test module for each source module, is an aspect of project structure
    rather than one tied to test execution processes. All that we really need to do
    in order to address that is define where test code will live in any given project.
    Since we know that we''re going to want to address running tests during the build
    process later on, we need to have a common test directory, a file just inside
    it (call it `run_tests.py`) that can run all the project''s tests on demand, and
    a test directory and file structure that''s accessible to that file should be
    included, which ends Up looking like this for the `hms_core` component project:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利；我们有可以执行的测试，所以下一个问题是如何应用我们想要应用的测试策略规则。第一个策略，为每个源模块拥有一个测试模块，是项目结构的一个方面，而不是与测试执行流程相关的一个方面。为了解决这个问题，我们真正需要做的就是定义在任何给定项目中测试代码将存放的位置。由于我们知道我们将来会想要在构建过程中运行测试，我们需要有一个公共的测试目录，一个刚好在其中的文件（称之为`run_tests.py`）可以按需运行项目的所有测试，以及一个测试目录和文件结构，该结构对该文件应该是可访问的，这最终看起来像是`hms_core`组件项目的这样：
- en: '![](assets/e13fc4d7-5a42-4fd5-bde1-e66d4c44920d.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e13fc4d7-5a42-4fd5-bde1-e66d4c44920d.png)'
- en: Identifying missing test case classes
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别缺失的测试用例类
- en: 'The balance of the testing goals noted earlier all require the ability to examine
    the code being tested in order to identify module members, and members of those
    members, that need to be tested. This might sound daunting, but Python provides
    a module dedicated to that purpose: `inspect`. It provides a very robust collection
    of functions that can be used to examine Python code at runtime, which can be
    leveraged to generate collections of member names that can, in turn, be used to
    determine whether the high-level test coverage meets the standard we''re establishing.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候指出的测试目标的平衡都需要能够检查被测试的代码，以识别需要进行测试的模块成员，以及这些成员的成员。这可能听起来令人生畏，但Python提供了一个专门用于此目的的模块：`inspect`。它提供了一系列非常强大的函数，可以用于在运行时检查Python代码，这可以用来生成成员名称的集合，进而用于确定高级测试覆盖是否符合我们正在建立的标准。
- en: For the purposes of illustration, the preceding classes that we need to test
    will be saved in a module called `me.py`, which makes them importable, and each
    step demonstrating the process for finding the needed information about the `me`
    module will be collected in `inspect_me.py`, as this shown here. The corresponding
    test cases will live in `test_me.py`, which will start as a near-empty file—no
    test case classes will be defined there at first.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们需要测试的前述类将被保存在一个名为`me.py`的模块中，这使它们可以被导入，每一步展示关于`me`模块的所需信息的过程都将被收集在`inspect_me.py`中，如此所示。相应的测试用例将存在于`test_me.py`中，它将首先作为一个几乎空白的文件开始——一开始不会在那里定义任何测试用例类。
- en: 'The first step is identifying the target members of `me` that we''re going
    to require test case classes for. As things stand right now, all we need is a
    list of classes in the target module, which can be retrieved as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是识别我们将需要测试用例类的`me`的目标成员。就目前而言，我们所需要的只是目标模块中的类的列表，可以按如下方式检索：
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Step by step, what''s happening is this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一步一步，正在发生的是这样的：
- en: The `inspect` module is being imported.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在导入`inspect`模块。
- en: The `me` module is being imported, using `target_module` as an override to its
    default module-name—we'll want to be able to keep imported module names predictable
    and relatively constant to make things easier to reuse down the line, and that
    starts here.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在导入`me`模块，使用`target_module`作为其默认模块名的覆盖——我们希望能够保持导入的模块名称可预测且相对恒定，以便在以后更容易地重用，而这从这里开始。
- en: The `getmembers` function of `inspect` is called against the `target_module`,
    using `isclass` as a filtering predicate. This returns a list of tuples that look
    like `('ClassName', <class object>)`. Those results are run through a list comprehension
    to extract only the class names, and that list is handed off to a Python `set`
    to yield a formal set of class names that were discovered.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`target_module`调用`inspect`的`getmembers`函数，使用`isclass`作为过滤谓词。这将返回一个类似`('ClassName',
    <class object>)`的元组列表。这些结果通过列表推导提取出只有类名的列表，并将该列表传递给Python的`set`，以产生发现的类名的正式集合。
- en: Python's `set` type is a very useful basic data type it provides an iterable
    collection of values that are distinct (never repeated in the set), and that can
    be merged with other sets (with `union`), have its members removed from other
    sets (with `difference`), and a host of other operations that would be expected
    from standard set theory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`set`类型是一种非常有用的基本数据类型，它提供了一个可迭代的值集合，这些值是不同的（在集合中从不重复），并且可以与其他集合合并（使用`union`），从其他集合中删除其成员（使用`difference`），以及一系列其他操作，这些操作都符合标准集合理论的预期。
- en: 'With those names available, creating a set of expected test case class names
    is simple:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些名称，创建一组预期的测试用例类名就很简单了：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is just another list comprehension that builds a set of class names that
    start with `test` from the target class name set. A similar approach to the one
    that gathered the class names in the target module can be used to find the test
    case classes that exist in the `test_me.py` module:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是另一个列表推导，它构建了一个以`test`开头的类名集合，从目标类名集合中。与收集目标模块中的类名的方法类似，可以用类似的方法找到存在于`test_me.py`模块中的测试用例类：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Apart from the `issubclass` check of each member found, which will limit the
    members of the set to names of classes that are derived from `unittest.TestCase`,
    this is identical to the process that built the initial `target_classes` set.
    Now that we have sets that collect what''s expected and what''s actually defined,
    determining what test case classes need to be created is a simple matter of removing
    the defined test case names from the set of expected ones:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对每个找到的成员进行`issubclass`检查，这将限制集合的成员为从`unittest.TestCase`派生的类的名称，这与构建初始`target_classes`集合的过程完全相同。现在我们有了收集预期和实际定义的内容的集合，确定需要创建的测试用例类是一个简单的事情，只需从预期的集合中删除已定义的测试用例名称：
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If `missing_tests` is not empty, then its collection of names represents the
    test case class names that need to be created in order to meet the first part
    of the "all members will be tested" policy. A simple print of the results at this
    point will suffice for now:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`missing_tests`不为空，则其名称集合代表需要创建的测试用例类名称，以满足“所有成员将被测试”的政策的第一部分。此时对结果的简单打印就足够了：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](assets/0a3a9422-8343-452d-860f-528ac0c04b40.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0a3a9422-8343-452d-860f-528ac0c04b40.png)'
- en: 'Having identified the missing test case class items that need to be created,
    they can be added to `test_me.py`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 已经确定了需要创建的缺失的测试用例类项，它们可以添加到`test_me.py`中：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once they have been added (and once subclasses are derived from `unittest.TestCase`,
    because of the check performed earlier in identifying actual test case classes),
    there are no missing test cases that need to be addressed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们被添加（并且一旦从`unittest.TestCase`派生出子类，因为之前执行了识别实际测试用例类的检查），就不再有需要解决的缺失的测试用例。
- en: A similar approach could be taken for identifying module-level functions that
    should arguably also be tested—they are also public members of a module, after
    all, and that's what the policy is concerned with, public members of modules.
    The actual implementation of tests against functions, or any other callable element,
    would follow the structures and processes that will be established later for class
    methods.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的方法也可以用于识别应该进行测试的模块级函数——毕竟，它们也是模块的公共成员，而政策关注的正是模块的公共成员。对函数或任何其他可调用元素进行测试的实际实现将遵循稍后为类方法建立的结构和过程。
- en: Really, the only public members that may not be easily identified with this
    sort of process are unmanaged attributes—module constants or variables that are
    created at the module level. While those could still be tested, and arguably should
    be, the fact that they are unmanaged, and can be changed at runtime without any
    checks to assure that they aren't going to break things somewhere down the line,
    might well make any formal testing policy around them little more than a waste
    of time. That said, there's no harm in testing them, if only to assure that changes
    to them, intentional or accidental, don't pass unnoticed and raise issues and
    bugs later on.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可能无法轻松使用这种类型的过程识别的唯一公共成员是未受管理的属性——在模块级别创建的模块常量或变量。尽管这些仍然可以进行测试，并且可以说应该进行测试，但它们是未受管理的，可以在运行时更改，而没有任何检查来确保它们不会在后续某个地方出现问题，这可能会使围绕它们的任何正式测试政策几乎成为一种浪费时间。也就是说，测试它们并没有坏处，即使只是为了确保对它们的更改（有意或意外的）不会被忽视并在以后引发问题和错误。
- en: Identifying missing test methods
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别缺失的测试方法
- en: 'The `inspect.getmembers` function that was used to identify classes in modules
    earlier can also be used to identify other member types of other target elements,
    such as properties and methods of classes. The process for identifying either
    is similar to what''s already been shown for identifying classes in modules, and
    looks like this (for properties):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前用于识别模块中的类的`inspect.getmembers`函数也可以用于识别其他目标元素的其他成员类型，例如类的属性和方法。识别任一成员的过程与之前已经展示的识别模块中的类的过程类似，看起来像这样（对于属性）：
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only significant differences here from the process for finding classes in
    a module are the target that's being inspected (in this case, the `target_class`,
    which we've set to the `Parent` class) and the predicate (`inspect.isdatadescriptor`),
    which filters the results to data descriptors—managed attributes or formal properties.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与在模块中查找类的过程的唯一显著差异是被检查的目标（在这种情况下是`target_class`，我们已将其设置为`Parent`类）和谓词（`inspect.isdatadescriptor`），它将结果过滤为数据描述符——受控属性或正式属性。
- en: 'In [Chapter 6](62f5861c-5fbb-44f3-82c3-585d2b238773.xhtml), *Development Tools
    and Best Practices*, when the various internal code standards were being discussed
    and defined, one aspect of using managed attributes/properties was noted as being
    significant for unit testing purposes:the ability to know what kinds of values
    to test with for any given property. This is another advantage of taking that
    approach: class properties defined using the built-in `property()` function can
    be detected as class members that need to be tested. Unmanaged attributes, though
    they may well be detectable, may not be readily identifiable as members of a class
    that need to be tested, and that identification is almost certainly not something
    that can be automated.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](62f5861c-5fbb-44f3-82c3-585d2b238773.xhtml) *开发工具和最佳实践*中，当讨论和定义各种内部代码标准时，注意到使用受控属性/属性的一个重要方面是对于单元测试目的的重要性：知道为任何给定属性测试的值类型。这是采用这种方法的另一个优势：使用内置的`property()`函数定义的类属性可以被检测为需要测试的类成员。尽管未受管理的属性可能是可检测的，但可能不容易识别为需要测试的类的成员，并且几乎可以肯定这种识别几乎肯定不是可以自动化的。
- en: 'A similar `inspect.getmembers` call can be used to identify class methods:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的`inspect.getmembers`调用可以用于识别类方法：
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Both of these member name collections include items that the test policy doesn't
    require tests for, though the `__weakref__` property is a built-in property of
    all classes and the `_Parent__private` method entry ties back to our original
    `__private` method, and neither of those need to be included in our lists of required
    test methods. Some basic filtering can be accomplished by simply adding a check
    for a leading `__` in the property list names (since we'd never be testing a private
    property according to our test policy). That'd take care of removing `__weakref__`
    from the test list, and allow public and protected properties to appear.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个成员名称集合都包括测试策略不要求测试的项目，尽管`__weakref__`属性是所有类的内置属性，而`_Parent__private`方法条目与我们最初的`__private`方法相关联，这两者都不需要包含在我们所需测试方法的列表中。通过简单地添加对属性列表名称中前导`__`的检查，可以实现一些基本的过滤（因为根据我们的测试策略，我们永远不会测试私有属性）。这将处理掉测试列表中的`__weakref__`，并允许公共和受保护的属性出现。
- en: 'After adding a property declaration (`prop`) to Parent, and adding that filtering
    criteria, we would get the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在向`Parent`添加属性声明（`prop`）并添加过滤条件后，我们将得到以下结果：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That same approach would not work well for finding class methods that need to
    be tested, though;some common methods, such as `__init__`, have names that would
    be removed based on name-based filtering, but are members that we'd want to assure
    have tests required. This simple name-based filtering also doesn't deal with not
    including member names that exist in a class but aren't defined in that class—like
    all of the properties and members of the `Child` class. While the name-based filtering
    is a step in the right direction, it feels like it's time to take a step back
    and look at a broader solution,one that does account for where a member is defined.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，同样的方法并不适用于查找需要测试的类方法；一些常见的方法，比如`__init__`，其名称会基于名称进行过滤，但是我们希望确保需要测试的成员。这种简单的基于名称的过滤也无法处理不包括在类中但在该类中没有定义的成员名称，比如`Child`类的所有属性和成员。虽然基于名称的过滤是朝着正确方向迈出的一步，但感觉是时候退一步，看看更广泛的解决方案，一个能考虑成员定义位置的解决方案。
- en: 'That involves building the list of test names in a more complex fashion, and
    paying attention to the **Method Resolution Order** (**MRO**) of each class, which
    can be found in a class built-in `__mro__` property. We''ll start by defining
    an empty set and acquiring the MRO of the class, then the same list of property
    names that were available from the target class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及以更复杂的方式构建测试名称列表，并注意每个类的**方法解析顺序**（**MRO**），这可以在类的内置`__mro__`属性中找到。我们将从定义一个空集开始，并获取类的MRO，然后获取与目标类相同的属性名称列表：
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll also need to keep track of where a property''s definition can be found,that
    is, what class it originates in, as well as the actual implementation of the properties.
    We''ll want to start with a complete data structure for each, which associates
    the names with the source classes and implementations eventually, but that''s
    initialized with `None` values to start with. That will allow the final structure,
    once it''s populated, to be used to identify members of the class that aren''t
    defined there:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要跟踪属性的定义位置，即它来自哪个类，以及属性的实际实现。我们希望从每个完整的数据结构开始，将名称与源类和最终实现关联起来，但最初用`None`值初始化。这将允许最终的结构在填充后用于识别类的成员，这些成员在那里没有定义：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With that data in hand, the generation of the list of required property test
    methods is similar to the required test case class list shown earlier:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些数据，生成所需属性测试方法列表与之前显示的所需测试用例类列表类似：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The process for acquiring and filtering down the method members of a class
    looks almost the same, though we''re going to include all members, even those
    whose names begin with `__`, and acquire members that are either functions or
    methods, just to ensure that we''ll include class and static methods of classes:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和筛选类的方法成员的过程几乎相同，尽管我们将包括所有成员，甚至是以`__`开头的成员，并获取函数或方法，以确保包括类和静态方法。
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The process for constructing the `dict` items used to keep track of method
    sources and implementations can actively skip local, private members and anything
    that''s been defined as abstract:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 用于跟踪方法源和实现的`dict`项的构建过程可以主动跳过本地、私有成员以及已定义为抽象的成员：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The balance of the test name list generation is the same, though:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 测试名称列表生成的平衡是相同的：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So, what are the takeaways from all of this exploration? To put it briefly,
    they are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，从所有这些探索中得出了什么结论？简而言之，它们如下：
- en: It's possible to automate the process of detecting what members of a module
    should require test cases to be created
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以自动化检测模块的成员应该需要创建测试用例
- en: It's possible to automate the process of verifying that those required test
    cases exist in the test module that corresponds to a given source module, though
    it still requires some discipline to assure that the test modules are created
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然可以自动化验证所需的测试用例是否存在于与给定源模块对应的测试模块中，但仍需要一些纪律来确保创建测试模块
- en: It's possible to automate the process of detecting what test methods need to
    be required for any given test case/source class combination, and to do so without
    requiring the testing of private and abstract members, neither of which make much
    sense in the context of the test policies we're looking to establish
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以自动化检测对于任何给定的测试用例/源类组合需要哪些测试方法，并且可以在不需要测试私有和抽象成员的情况下进行
- en: That's a fair chunk of code, though. 80-odd lines, without some of the actual
    testing of class members and the announcement of issues, and after stripping out
    all the comments. That's a lot more code than should ever be copied and pasted
    around, especially for a process that has the kind of high damage potential or
    impact that a unit testing process has. It'd be a lot better to be able to keep
    it all in one place. Fortunately, the `unittest` module's classes provide some
    options that will make creating module-by-module code coverage tests amazingly
    easy—though it will require some design and implementation first.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是相当多的代码。大约80行，没有一些实际测试类成员和问题公告，以及剥离所有注释后。这比应该被复制和粘贴的代码要多得多，尤其是对于具有高破坏潜力或影响的流程。最好能够将所有内容都保存在一个地方。幸运的是，`unittest`模块的类提供了一些选项，可以使逐模块的代码覆盖测试变得非常容易——尽管这将首先需要一些设计和实现。
- en: Creating reusable module code coverage tests
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的模块代码覆盖测试
- en: A good unit testing framework will allow not just the creation of tests for
    members of code elements, but will also provide mechanisms for executing code
    before any of the tests are run, as well as after all tests have executed, successfully
    or not. Python's `unittest` module handles that in the individual `TestCase` classes,
    which allow the class to implement the `setUpClass` and `tearDownClass` methods
    to handle the pre- and post-test setup and teardown, respectively.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的单元测试框架不仅允许为代码元素的成员创建测试，还提供了在运行任何测试之前以及在所有测试执行成功或失败后执行代码的机制。Python的`unittest`模块在各个`TestCase`类中处理这一点，允许类实现`setUpClass`和`tearDownClass`方法来分别处理测试前和测试后的设置和拆卸。
- en: 'That, then, means that it''d be possible to create a test class that could
    be imported, extended with module-specific properties, and added to a test module
    that could leverage all of the capabilities just shown to do the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可以创建一个测试类，该类可以被导入，扩展具有特定于模块的属性，并添加到测试模块中，该测试模块可以利用刚刚显示的所有功能来执行以下操作：
- en: Find all of the classes and functions in the target module
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找目标模块中的所有类和函数
- en: Determine what test case classes need to exist in the test module, and test
    them to make sure they exist
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定测试模块中需要存在哪些测试用例类，并测试它们以确保它们存在
- en: Determine, for each source module member's test case class, what tests need
    to exist in order to meet our unit testing policies and criteria
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定每个源模块成员的测试用例类需要存在哪些测试，以满足我们的单元测试政策和标准。
- en: Test for the existence of those test methods
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查这些测试方法是否存在
- en: 'The code coverage test case class will need to know what module to examine
    in order to find all of that information, but it should be able to manage everything
    else on its own. Ultimately, it will define just one test of its own that it will
    execute the one to assure that every class or function in the source module has
    a corresponding test case class in the test module:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖测试用例类将需要知道要检查哪个模块以找到所有信息，但它应该能够自行管理其他所有内容。最终，它将定义自己的一个测试，以确保源模块中的每个类或函数在测试模块中都有一个相应的测试用例类：
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It will also need to be able to provide a mechanism to allow the checks for
    property and method test methods. Doing so on a fully automated basis is tempting,
    if it could even be achieved, but there may be cases where that could prove more
    troublesome bring up than worthwhile. At least for the time being, the addition
    of those tests will be made available by creating some decorators that will make
    attaching those tests to any given test case class easy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它还需要能够提供一种机制，以允许检查属性和方法测试方法。如果可以实现的话，以完全自动化的方式进行这样的检查是很诱人的，但可能有些情况会比值得的麻烦。至少目前，通过创建一些装饰器来使这些测试附加到任何给定的测试用例类变得容易，这些测试将被添加到可用的测试中。
- en: Python's decorators are a fairly detailed topic in their own right. For now,
    don't worry about how they work  just be aware of what using them looks like and
    trust that they do work.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Python的装饰器本身是一个相当详细的主题。现在，不要担心它们是如何工作的，只要知道它们的使用方式，并相信它们是有效的。
- en: 'Our starting point is just a class derived from `unittest.TestCase` that defines
    the `setUpClass` class method noted earlier, and does some initial checking for
    a defined class-level `_testModule` attribute—if there is no test module, then
    all tests should simply skip or pass, since there''s nothing being tested:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起点只是一个从`unittest.TestCase`派生的类，该类定义了前面提到的`setUpClass`类方法，并对定义的类级`_testModule`属性进行了一些初始检查——如果没有测试模块，那么所有测试应该简单地跳过或通过，因为没有任何被测试的内容：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `@classmethod` line is a built-in class method decorator.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`@classmethod`行是内置的类方法装饰器。'
- en: 'We need to start by finding all the classes and functions available in the
    target module:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先找到目标模块中所有可用的类和函数：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ll keep track of the name of the module being tested as an additional check
    criteria for class and function members, just in case:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跟踪被测试模块的名称作为类和函数成员的额外检查标准，以防万一：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The mechanism for keeping track of the class and function tests is similar
    to the sources-and-implementations dictionaries in the initial exploration:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪类和函数测试的机制类似于初始探索中的源和实现字典：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The list of required test case class names is the aggregated list of all class
    and function test case class names:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所需测试用例类名称的列表是所有类和函数测试用例类名称的聚合列表：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The collection of actual test case classes will be used later to test against:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 实际测试用例类的集合将稍后用于测试：
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we''ll generate the list of missing test case names that the class `testCodeCoverage`
    test method uses:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将生成缺少的测试用例名称列表，该列表由类`testCodeCoverage`测试方法使用：
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At this point, that lone test method would be able to execute, and either pass
    or fail with an output that indicates what test cases are missing. If we write
    out the `test_me.py` module as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，该单独的测试方法将能够执行，并且会输出指示缺少哪些测试用例的输出。如果我们将`test_me.py`模块写成如下形式：
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then after it''s been executed, we would get the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在执行后，我们将得到以下结果：
- en: '![](assets/9c2a3323-b640-4cec-b3ee-6065dc67fc9b.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c2a3323-b640-4cec-b3ee-6065dc67fc9b.png)'
- en: 'All that needs to be done to make that top-level code coverage test pass is
    to add the missing test case classes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要使顶层代码覆盖测试通过，只需添加缺少的测试用例类：
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This approach, taking a proactive stance on ensuring code coverage in this
    fashion, lends itself well to making unit testing a lot less troublesome. If the
    process for writing tests starts with a common test that will tell the test developer
    what''s missing at every step along the way, then the entire process of writing
    tests really becomes repeating the following steps until there are no tests failing:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这种以主动方式确保代码覆盖率的方法非常适合使单元测试变得不那么麻烦。如果编写测试的过程始于一个通用测试，该测试将告诉测试开发人员在每一步中缺少了什么，那么编写测试的整个过程实际上就是重复以下步骤，直到没有测试失败为止：
- en: Execute the test suite
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行测试套件
- en: 'If there are failing tests, make whatever code changes are needed to make the
    last one pass:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有测试失败，进行必要的代码更改以使最后一个测试通过。
- en: If it's a missing test failure, add the necessary test class or method
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是缺少测试失败，添加必要的测试类或方法
- en: If it's a failure because of the code in the source, alter that accordingly
    after verifying that the test values involved in the failure should have passed
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是因为源代码中的代码而失败，请在验证所涉及的测试值应该通过后相应地更改
- en: Onward!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进！
- en: 'In order to be able to test for missing property and method tests across all
    the test case classes in the test module, we''ll need to find all of them and
    keep track of them on a class-by-class basis. This is mostly the same process
    that we discovered earlier, but the stored values have to be retrievable by class
    name since we want the single coverage test instance to check all of the source
    and test case classes, so we''ll store them in a couple of dictionaries, `propSources`
    for the sources of each, and `propImplementations` for the actual functionality
    objects:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够测试测试模块中所有测试用例类中缺少的属性和方法测试，我们需要找到它们并按类进行跟踪。这基本上与我们之前发现的过程相同，但存储的值必须能够按类名检索，因为我们希望单个覆盖测试实例检查所有源代码和测试用例类，因此我们将它们存储在两个字典中，`propSources`用于每个的源，`propImplementations`用于实际的功能对象：
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The acquisition of the method tests works in the same way, and uses the same
    approach from the previous exploration as well:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 方法测试的获取方式与之前的探索方式相同：
- en: '[PRE40]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once these last two blocks have executed, the code coverage test class will
    have a complete breakout of all the test methods needed for each test case class
    in the test module. The property test collection (`cls._propertyTestsByClass`)
    is sparse, since there''s only one property associated with any class, `Parent.prop`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了最后两个代码块，代码覆盖测试类将完整地列出测试模块中每个测试用例类所需的所有测试方法。属性测试集合（`cls._propertyTestsByClass`）是稀疏的，因为与任何类相关联的属性只有一个，即`Parent.prop`：
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The method test structure (`cls._methodTestsByClass`) has a bit more meat to
    it, though, and is accurately representing that the `public` and `_protected`
    methods in the `ChildOverride` class need their own test methods, and that the
    abstract `show` method in `Showable` does not need to be tested:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 方法测试结构（`cls._methodTestsByClass`）有更多内容，准确地表示了`ChildOverride`类中的`public`和`_protected`方法需要它们自己的测试方法，并且`Showable`中的抽象`show`方法不需要被测试：
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That data is all that's needed to handle the tests for the required property
    and method tests. All that remains is working out a way to attach them to each
    test case class.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据是处理所需属性和方法测试的所有内容。剩下的就是想出一种方法将它们附加到每个测试用例类上。
- en: The property and method testing decorators
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性和方法测试装饰器
- en: A decorator can be thought of as a function that takes another function as an
    argument, and extends or wraps other functionality around the decorated function
    without actually modifying it. Any callable—a function, an instance method of
    a class, or (in this case) a class method belonging to a class—can be used as
    the decorating function. In this case, the code coverage test case class is going
    to define two class methods (`AddPropertyTesting` and `AddMethodTesting`) using
    a decorator function structure in order to add new methods (`testPropertyCoverage`
    and `testMethodCoverage`) to any classes that are decorated with them. Those two
    methods, since they are nested members of the main code coverage class, have access
    to the data in the class—specifically the lists of required property and method
    test names that were generated. Also, because they are nested members of the decorator
    functions themselves, they will have access to the variables and data in those
    methods.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可以被视为接受另一个函数作为参数，并在装饰的函数周围扩展或包装其他功能的函数，而不实际修改它。任何可调用的东西——函数、类的实例方法或（在本例中）属于类的类方法——都可以用作装饰函数。在这种情况下，代码覆盖测试用例类将使用装饰器函数结构定义两个类方法（`AddPropertyTesting`和`AddMethodTesting`），以便向使用它们进行装饰的任何类添加新方法（`testPropertyCoverage`和`testMethodCoverage`）。由于这两个方法是主代码覆盖类的嵌套成员，它们可以访问类中的数据，特别是生成的所需属性和方法测试名称列表。此外，因为它们是装饰函数本身的嵌套成员，它们将可以访问这些方法中的变量和数据。
- en: 'The two decorator methods are almost identical, except for their names, their
    messaging, and where they look for their data, so only the first, `AddMethodTesting`,
    will be detailed. The method starts by checking to make sure that it''s a member
    of a class that extends the `ModuleCoverageTest` class—this assures that the data
    it''s going to be looking at is limited to only that which is relevant to the
    combined source and test modules:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个装饰器方法几乎是相同的，除了它们的名称、消息和它们查找数据的位置，因此只详细介绍第一个`AddMethodTesting`。该方法首先检查以确保它是`ModuleCoverageTest`类的成员，这确保了它要查看的数据仅限于与源代码和测试模块相关的数据：
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `target` argument that's passed in at the start of the function is a `unittest.TestCase` class
    (though it's not explicitly type checked).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始时传入的`target`参数是一个`unittest.TestCase`类（尽管它没有明确进行类型检查）。
- en: 'It also needs to make sure that the data it''s going to use is available. If
    it''s not, for whatever reason, that can be remedied by explicitly calling the
    class `setUpClass` method ,which was just defined:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 它还需要确保要使用的数据是可用的。如果不可用，无论出于什么原因，都可以通过显式调用刚刚定义的`setUpClass`方法来解决：
- en: '[PRE44]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The next step is defining a function instance to actually execute the test.
    This function is defined as if it were a member of a class because it will be
    by the time the decoration process has completed, but because it''s nested inside
    the decorator method, it has access to, and will preserve the values of, all of
    the variables and arguments defined in the decorator method so far. Of these,
    the most important is the `target`, since that''s the class that''s going to be
    decorated. That `target` value is, essentially, attached to the function that''s
    being defined/created:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义一个函数实例来实际执行测试。这个函数被定义得好像它是类的成员，因为在装饰过程完成时它将成为类的成员，但因为它嵌套在装饰器方法内部，所以它可以访问并保留到目前为止在装饰器方法中定义的所有变量和参数的值。其中最重要的是`target`，因为它将被装饰的类。`target`值本质上附加到正在定义/创建的函数上：
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The test method itself is pretty straightforward: it creates a set of active
    test method names that are defined in the test case class it''s attached to, removes
    those from the required test methods for the test case class that it retrieves
    from the coverage test class, and if there are any left over, the test will fail
    and announce what''s missing.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法本身非常简单：它创建了一组活动的测试方法名称，这些名称在附加到的测试用例类中被定义，然后从覆盖测试类中检索到的测试用例类的必需测试方法中移除这些名称，如果还有剩余的，测试将失败并宣布缺少了什么。
- en: 'All that remains to do is attach the function to the target and return the
    target so that access to it isn''t disrupted:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是将函数附加到目标上并返回目标，以便不会中断对它的访问：
- en: '[PRE46]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once those decorators are defined, they can be applied to the unit testing
    code like so:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些装饰器被定义，它们就可以像这样应用于单元测试代码：
- en: '[PRE47]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And, with them in place, the test run starts reporting what''s missing:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有了它们，测试运行开始报告缺少了什么：
- en: '![](assets/4f0e03da-20e0-492e-bf6c-1734514a639c.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4f0e03da-20e0-492e-bf6c-1734514a639c.png)'
- en: Creating unit test template files
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单元测试模板文件
- en: The bare-bones starting point for the collection of tests just shown would work
    as a starting point for any other collection of tests that are concerned with
    a single module. The expected code structure for `hms_sys`, however, includes
    whole packages of code, and may include packages inside those packages. We don't
    know yet, because we haven't gotten that far. That's going to have an impact on
    the final unit testing approach, as well as on the creation of template files
    to make the creation of those test modules faster and less error-prone.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚显示的测试集合的最基本起点将作为任何其他关注单个模块的测试集合的起点。然而，`hms_sys`的预期代码结构包括整个代码包，并且可能包括这些包内的包。我们还不知道，因为我们还没有到那一步。这将对最终的单元测试方法产生影响，以及对模板文件的创建产生影响，以使得创建这些测试模块更快速和更少出错。
- en: The main impact is centered around the idea that we want to be able to execute
    all of the tests for an entire project with a single call, while at the same time
    not being required to execute every test in the component project's test suite
    in cases where the interest is in one or more tests running against something
    deeper in the package structure. It would make sense, then, to break the tests
    out in the same sort of organizational structure as the package that they are
    testing, and allow test modules at any level to import child tests when they are
    called or imported themselves by a parent higher Up the module tree.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 主要影响集中在这样一个想法上，即我们希望能够通过单个调用执行整个项目的所有测试，同时在组件项目的测试套件中不需要执行每个测试的情况下，只需运行一个或多个测试以针对包结构中更深层次的内容。因此，将测试按照与它们正在测试的包相同类型的组织结构进行拆分，并允许在任何级别的测试模块调用或被父级模块导入时导入子测试。
- en: 'To that end, the template module for unit tests needs to accommodate the same
    sort of import capabilities that the main code base does, while keeping track
    of all the tests that result from whatever import process originated with the
    test run. Fortunately, the `unittest` module also provides classes that can be
    used to manage that need, such as the `TestSuite` class, which is a collection
    of tests that can be executed and that can have new tests added to it as needed.
    The final test module template looks much like the module template we created
    earlier, though it starts with some search-and-replace boilerplate comments:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，单元测试模板模块需要适应与主代码库相同类型的导入功能，同时跟踪由测试运行发起的任何导入过程产生的所有测试。幸运的是，`unittest`模块还提供了可以用来管理这种需求的类，例如`TestSuite`类，它是可以执行的测试集合，并且可以根据需要向其添加新测试。最终的测试模块模板看起来很像我们之前创建的模块模板，尽管它以一些搜索和替换的样板注释开头：
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Unlike the packages and modules that provide application functionality, the
    unit test module template doesn''t expect or need to provide much in the way of `**all**` entries—only
    the test case classes that reside in the module itself, and any child test modules:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 与提供应用功能的包和模块不同，单元测试模块模板不需要提供太多的`**all**`条目，只需要提供模块本身中的测试用例类和任何子测试模块：
- en: '[PRE49]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'There are a few standard imports that will occur in all test modules, and there
    is the potential for third-party imports as well, though that''s probably not
    going to be common:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试模块中都会发生一些标准导入，并且还可能存在第三方导入的可能性，尽管这可能不太常见：
- en: '[PRE50]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'All the test modules will define a `unittest.TestSuite` instance named `LocalSuite`,
    which contains all of the local test cases and can be imported by name in parent
    modules when needed:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的测试模块都将定义一个名为`LocalSuite`的`unittest.TestSuite`实例，其中包含所有本地测试用例，并且在需要时可以在父模块中按名称导入：
- en: '[PRE51]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ll also define boilerplate code that defines the code coverage test case
    class:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一些样板代码，用于定义代码覆盖测试用例类：
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'From this point on, everything that isn''t part of the `__main__` execution
    of the module should be definitions of the test case classes:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，除了模块的`__main__`执行之外的所有内容都应该是测试用例类的定义：
- en: '[PRE53]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If child test modules need to be imported later on, the code structure for
    doing so is here, commented out and ready to copy, paste, uncomment, and rename
    as needed:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后需要导入子测试模块，这里有用于执行此操作的代码结构，已注释并准备好复制、粘贴、取消注释和根据需要重命名：
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There more standard module sections, following the organization structure of
    the standard module and package templates:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多标准模块部分，遵循标准模块和包模板的组织结构：
- en: '[PRE55]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, there''s some provision for executing the module directly, running
    the tests, and displaying and writing out the reports when no failures occur:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些用于直接执行模块、运行测试并在没有失败时显示和写出报告的准备：
- en: '[PRE56]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The template provides a handful of items that can be found and replaced when
    it''s first copied to a final test module:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 模板提供了一些可以在首次复制到最终测试模块时找到并替换的项目：
- en: '`PackagePath`: The full namespace to the module being tested, minus the module
    itself. For example, if a test module was being created for a module whose full
    namespace was `hms_core.business.processes.artisan`, the `PackagePath` would be
    `hms_core.business.processes`'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackagePath`：被测试模块的完整命名空间，减去模块本身。例如，如果为一个完整命名空间为`hms_core.business.processes.artisan`的模块创建了一个测试模块，`PackagePath`将是`hms_core.business.processes`'
- en: '`ModuleName`: The name of the module being tested (`artisan`, using the preceding
    example)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleName`：被测试的模块的名称（使用前面的例子中的`artisan`）'
- en: That search-and-replace operation will also provide a unique name for the `ModuleCoverageTest` subclass definition
    that's embedded in the template. As soon as those replacements are completed,
    the test module can be run, as shown in the preceding example, and will start
    reporting on missing test cases and methods.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和替换操作还将为嵌入在模板中的`ModuleCoverageTest`子类定义提供一个唯一的名称。一旦这些替换完成，测试模块就可以运行，就像前面的例子中所示的那样，并且将开始报告缺少的测试用例和方法。
- en: 'Each test module that follows this structure keeps track of its local tests
    in a `unittest.TestSuite` object that can be imported by parent test modules,
    and this can add tests from child `TestSuite` instances as needed a commented-out
    example of what that would look like is in place of the template file:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这种结构的每个测试模块都在一个`unittest.TestSuite`对象中跟踪其本地测试，该对象可以被父测试模块导入，并且可以根据需要从子`TestSuite`实例中添加测试，模板文件中有一个注释掉的示例，显示了这种情况的样子：
- en: '[PRE57]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, the template file makes use of some display and reporting functions
    defined in the custom `unit_testing` module to write summary test result data
    to the console and (when tests run without failure) to a local file that can be
    tracked in source control if/as desired.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模板文件利用了自定义的`unit_testing`模块中定义的一些显示和报告函数，将总结的测试结果数据写入控制台，并且（当测试运行时没有失败）写入一个本地文件，如果需要的话可以在源代码控制中进行跟踪。
- en: Integrating tests with the build process
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将测试与构建过程集成
- en: 'There''s only one story/task set remaining how to integrate unit tests with
    whatever build process will be put into play for the component projects:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一个故事/任务集，即如何将单元测试与组件项目的任何构建过程集成起来：
- en: 'As a developer, I need to know how to integrate unit tests for a component
    project into the build process for that component project so that builds can automatically
    execute unit tests:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要知道如何将组件项目的单元测试集成到该组件项目的构建过程中，以便构建可以自动执行单元测试：
- en: Determine how to integrate unit tests into the build process
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定如何将单元测试集成到构建过程中
- en: Determine how to deal with build/test integration for different environments
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定如何处理不同环境的构建/测试集成
- en: 'With the unit testing structures just defined in place in a component project,
    integrating them into a build process is relatively easily accomplished. In a
    `setup.py` file-based build, the test modules can be specified in the `test_suite`
    argument for the `setup` function itself, and tests can be run by executing `python
    setup.py test`. It will be necessary in the `hms_sys` component projects to add
    the path for the unit testing standards code to `setup.py` as well:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件项目中刚刚定义的单元测试结构中，将它们集成到构建过程中相对容易。在基于`setup.py`文件的构建中，测试模块可以在`setup`函数的`test_suite`参数中指定，并且可以通过执行`python
    setup.py test`来运行测试。在`hms_sys`组件项目中，还需要将单元测试标准代码的路径添加到`setup.py`中：
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If a Makefile-based build process becomes necessary, the specific call to `setup.py
    test` can simply be included in whatever Make targets are relevant:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要基于Makefile的构建过程，`setup.py test`的具体调用可以简单地包含在相关的Make目标中：
- en: '[PRE59]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: A test suite executed from within `setup.py` will return the appropriate values
    to stop the Make process if an error is raised or a failure occurs.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从`setup.py`中执行的测试套件将返回适当的值，以阻止Make进程在出现错误或失败时停止。
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It's probable, barring the setup of a new team or new business, that most of
    these processes and policies will have been established well before the start
    of a project—usually before or during the first project that the team undertook.
    Most development shops and teams will have discovered the needs that underlie
    the sorts of solutions presented in this chapter, and will have acted upon them.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置新团队或新业务之外，大多数这些流程和政策很可能在项目开始之前就已经建立好了——通常是在团队承担的第一个项目之前或期间。大多数开发商和团队都会发现这一章节中提出的解决方案的需求，并且会采取行动。
- en: With all of these items set and committed to the SCM, the foundations are laid
    for all of the subsequent iterations' development work. The first “real” iteration
    will tackle the basic business object's definition and implementation.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些项目都已经设置并提交到版本控制系统，为随后的迭代开发工作奠定了基础。第一个“真正的”迭代将着手处理基本业务对象的定义和实现。
