- en: Chapter 1. Interacting with the Web Using Requests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 使用 Requests 与网络交互
- en: Reading data and obtaining information from web services tends to be a crucial
    task in these modern days. Everyone knows how an **Application Programming Interface**
    (**API**) allowed Facebook to spread the use of the Like button all over the Web
    and dominated the field of social communication. It has got its own flair to influence
    the business development, product development and supply chain management. At
    this stage, learning an efficient way to deal with the API's and opening the web
    URLs is the need of the hour. This will greatly affect many processes of web development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些现代日子里，从网络服务中读取数据和获取信息往往是一项至关重要的任务。每个人都知道**应用程序编程接口**（**API**）是如何让Facebook将“赞”按钮的使用推广到整个网络，并在社交通信领域占据主导地位的。它具有自己的特色，能够影响商业发展、产品开发和供应链管理。在这个阶段，学习一种有效处理API和打开网络URL的方法是当务之急。这将极大地影响许多网络开发过程。
- en: Introduction to HTTP request
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求简介
- en: Whenever our Web browser tries communicating with a Web server, it is done by
    using the **Hypertext Transfer Protocol** (**HTTP**) which functions as a request-response
    protocol. In this process of communication, we send a request to the web server
    and expect a response in return. Take an example of downloading a PDF from a website.
    We send a request saying "Get me this specific file", and we get a response from
    the Web server with "Here is the file followed by the file itself". The HTTP request
    we are sending possibly has much interesting information. Let us dig inside it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的网页浏览器试图与网页服务器进行通信时，它都是通过使用**超文本传输协议**（**HTTP**）来完成的，该协议作为一个请求-响应协议。在这个过程中，我们向网页服务器发送一个请求，并期待得到一个回应。以从网站下载PDF文件为例。我们发送一个请求说“给我这个特定的文件”，然后我们从网页服务器得到一个响应，其中包含“这里是文件，接着是文件本身”。我们发送的HTTP请求可能包含许多有趣的信息。让我们深入挖掘它。
- en: 'Here is the raw information of the HTTP request, that I have sent through my
    device. We can grasp the important parts of the request after looking at the following
    example:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是经过我的设备发送的HTTP请求的原始信息。通过查看以下示例，我们可以掌握请求的重要部分：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will send a request to the server. Let us make use of these parts of
    the HTTP request:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向服务器发送一个请求。让我们利用HTTP请求的这些部分：
- en: '**Method**: The `GET / http /1.1` in the preceding example, is the HTTP method
    which is case sensitive. Here are some of the HTTP request methods:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：前一个示例中的 `GET / http /1.1` 是一个大小写敏感的 HTTP 方法。以下是一些 HTTP 请求方法：'
- en: '`GET`: This fetches information from the given server using the given URI.'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：此操作通过给定的URI从指定的服务器获取信息。'
- en: '`HEAD`: The functionality of this is similar to GET but the difference is,
    it delivers only the status line and header section.'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`: 这个功能与GET类似，但不同之处在于，它只返回状态行和头部部分。'
- en: '`POST`: This can submit data to the server that we wish to process.'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：这可以将我们希望处理的数据提交到服务器。'
- en: '`PUT`: This creates or overwrites all the current representations of the target
    resource, when we intend to create a new URL.'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：当我们打算创建一个新的URL时，这个操作会创建或覆盖目标资源的所有当前表示。'
- en: '`DELETE`: This removes all the resources that are described by the given `Request-URI`.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：此操作将删除由给定`Request-URI`描述的所有资源。'
- en: '`OPTIONS`: This specifies the communication options for a request/response
    cycle. It lets the client to mention different options associated with the resource.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`: 这指定了请求/响应周期的通信选项。它允许客户端提及与资源相关联的不同选项。'
- en: '**Request URI**: Uniform Resource Identifier (URI) has the ability to recognize
    the name of the resource. In the previous example, the hostname is the `Request-URI`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求URI**：统一资源标识符（URI）具有识别资源名称的能力。在先前的例子中，主机名是`请求URI`。'
- en: '**Request Header fields**: If we want to add more information about the request,
    we can use the requests header fields. They are colon-separated key value pairs.
    Some of the `request-headers` values are:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求头字段**：如果我们想添加更多关于请求的信息，我们可以使用请求头字段。它们是冒号分隔的键值对。一些`request-headers`的值包括：'
- en: '`Accept-Charset`: This is used to indicate the character sets that are acceptable
    for the response.'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accept-Charset`: 这用于指示响应可接受的字符集。'
- en: '`Authorization`: This contains the value of the credentials which has the authentication
    information of the user agent.'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authorization`: 这包含用户代理的认证信息的凭证值。'
- en: '`Host`: This identifies the Internet host and port number of the resource that
    has been requested, using the original URI given by the user.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`主机`: 这标识了用户请求的资源所对应的互联网主机和端口号，使用用户提供的原始URI。'
- en: '`User-agent`: It accommodates information about the user agent that originates
    the request. This can be used for statistical purposes such as tracing the protocol
    violations.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User-agent`: 它容纳了关于发起请求的用户代理的信息。这可以用于统计目的，例如追踪协议违规行为。'
- en: Python modules
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 模块
- en: 'There are some extensively used Python modules which help in opening URLs.
    Let us have a look at them:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有些广泛使用的Python模块可以帮助打开URL。让我们来看看它们：
- en: '`httplib2`: This is a comprehensive HTTP client library. It supports many features
    that are left out of other HTTP libraries. It supports features like caching,
    keep-alive, compression, redirects and many kinds of authentication.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httplib2`: 这是一个功能全面的HTTP客户端库。它支持许多其他HTTP库中未提供的特性。它支持诸如缓存、持久连接、压缩、重定向以及多种认证等功能。'
- en: '`urllib2`: This is an extensively used module for fetching HTTP URLs in a complex
    world. It defines functions and classes that help with URL actions such as basic
    and digest authentication, redirections, cookies, and so on.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urllib2`：这是一个在复杂世界中广泛使用的模块，用于获取HTTP URL。它定义了帮助进行URL操作的功能和类，例如基本和摘要认证、重定向、cookies等。'
- en: '`Requests`: This is an Apache2 licensed HTTP library which is written in Python,
    gifted with many capabilities to result in productivity.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Requests`：这是一个Apache2许可的Python编写的HTTP库，拥有许多功能，从而提高了生产力。'
- en: Requests versus urllib2
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求与 urllib2
- en: Let's compare `urllib2` and `Requests`; `urllib2.urlopen()`, which can be used
    to open a URL (which can be a string or a request object), but there are many
    other things that can be a burden while interacting with the web. At this point,
    a simple HTTP library which has the capabilities to make interaction with the
    web smooth is the need of the hour, and Requests is one of its kind.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较`urllib2`和`Requests`；`urllib2.urlopen()`可以用来打开一个URL（可以是字符串或请求对象），但在与网络交互时，还有很多其他事情可能会成为负担。在这个时候，一个简单的HTTP库，它具有使网络交互变得顺畅的能力，正是当务之急，而Requests就是其中之一。
- en: 'The following is an example for fetching the data from a web service with `urllib2`
    and `Requests` gives us a clear picture of how easy it is to work with `Requests`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `urllib2` 和 `Requests` 获取网络服务数据的示例，它清晰地展示了使用 `Requests` 的工作是多么简单：
- en: 'The following code gives an example of `urllib2`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码给出了`urllib2`的一个示例：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The same example implemented with `Requests`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Requests` 实现的相同示例：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These examples can be found at [https://gist.github.com/kennethreitz/973705](https://gist.github.com/kennethreitz/973705).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可以在[https://gist.github.com/kennethreitz/973705](https://gist.github.com/kennethreitz/973705)找到。
- en: At this initial stage, the example may look much complicated. Don't go deep
    into the details of the example. Just see the beauty of `requests` that allowed
    us to login to GitHub with very few lines of code. The code with `requests` seems
    much simpler and efficient than the `urllib2` example. This would help us increase
    the productivity in all sorts of things.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始阶段，示例可能看起来相当复杂。不要深入到示例的细节中。只需看看`requests`库带来的美丽之处，它使我们能够用非常少的代码登录GitHub。使用`requests`的代码似乎比`urllib2`示例简单且高效得多。这将有助于我们在各种事情上提高生产力。
- en: Essence of Requests
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求的本质
- en: As with `HTTP/1.0`, `HTTP/1.1` has a lot of perks and added features like reusing
    a connection multiple times which decreases the considerable overhead, keep-alive
    mechanism, and so on. And fortunately, `requests` is built from it, giving us
    the benefits of interacting with the web smoothly and seamlessly. There is no
    need to manually add query strings to our URLs, or to encode our POST data. Keep-alive
    and HTTP connection pooling are 100 percent automatic, powered by `urllib3`, which
    is embedded within `requests`. With `requests` we are gifted with a means to forget
    about encoding parameters again and again, irrespective of whether it is GET/POST.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `HTTP/1.0` 类似，`HTTP/1.1` 具有很多优点和新增功能，例如多次重用连接以减少相当大的开销、持久连接机制等。幸运的是，`requests`
    库就是基于它构建的，这让我们能够与网络进行平滑和无缝的交互。我们无需手动将查询字符串添加到我们的 URL 中，也不必对 POST 数据进行编码。持久连接和
    HTTP 连接池是完全自动的，由嵌入在 `requests` 中的 `urllib3` 提供。使用 `requests`，我们得到了一种无需再次考虑编码参数的方法，无论它是
    GET 还是 POST。
- en: There is no requirement for manually adding query strings to the URLs, and also
    to the features such as connection pooling keep-alive, sessions with cookie persistence,
    Basic/Digest Authentication, Browser-style SSL Verification, Connection Timeouts,
    Multipart File Uploads, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL中无需手动添加查询字符串，同样也不需要添加诸如连接池保持活动状态、带有cookie持久性的会话、基本/摘要认证、浏览器风格的SSL验证、连接超时、多部分文件上传等功能。
- en: Making a simple request
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提出一个简单的请求
- en: 'Now let us create our first request for getting a web page, which is very simple.
    The process includes importing the `requests` module, and then getting the web
    page with the `get` method. Let us look into an example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建第一个获取网页的请求，这个过程非常简单。它包括导入`requests`模块，然后使用`get`方法获取网页。让我们来看一个例子：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Voila! We are done.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！我们完成了。
- en: In the preceding example, we get the `google` webpage, using `requests.get`
    and saving it in the variable `r,` which turns out to be the `response` object.
    The `response` object `r` contains a lot of information about the response, such
    as header information, content, type of encoding, status code, URL information
    and many more sophisticated details.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 `requests.get` 获取了 `google` 网页，并将其保存在变量 `r` 中，该变量最终变成了 `response`
    对象。`response` 对象 `r` 包含了关于响应的大量信息，例如头部信息、内容、编码类型、状态码、URL信息以及许多更复杂的细节。
- en: In the same way, we can use all the HTTP request methods like GET, POST, PUT,
    DELETE, HEAD with `requests`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以使用所有 HTTP 请求方法，如 GET、POST、PUT、DELETE、HEAD，与 `requests` 一起使用。
- en: Now let us learn how to pass the parameters in URLs. We can add the parameters
    to a request using using the `params` keyword.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来学习如何在URL中传递参数。我们可以使用`params`关键字将参数添加到请求中。
- en: 'The following is the syntax used for passing parameters:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为传递参数所使用的语法：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For getting a clear picture on this, let us get a GitHub user details by logging
    into GitHub, using `requests` as shown in the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对此有一个清晰的了解，让我们通过登录GitHub，使用以下代码中的`requests`来获取GitHub用户详细信息：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have used the `auth` tuple which enables Basic/Digest/Custom Authentication
    to login to GitHub and get the user details. The `r.status_code` result indicates
    that we have successfully got the user details, and also that we have accessed
    the URL, and the type of request.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`auth`元组，它支持基本/摘要/自定义认证，用于登录GitHub并获取用户详情。`r.status_code`的结果表明我们已成功获取用户详情，并且我们已经访问了URL，以及请求的类型。
- en: Response content
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应内容
- en: Response content is the information about the server's response that is delivered
    back to our console when we send a request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 响应内容是在我们发送请求时，服务器返回到我们控制台的信息。
- en: While interacting with the web, it's necessary to decode the response of the
    server. While working on an application, there are many cases in which we may
    have to deal with the raw, or JSON, or even binary response. For this, `requests`
    has the capability to automatically decode the content from the server. Requests
    can smoothly decode many of the Unicode charsets. To add to that, Requests makes
    informed guesses about the encoding of the response. This basically happens taking
    the headers into consideration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在与网络交互时，解码服务器的响应是必要的。在开发应用程序时，我们可能会遇到许多需要处理原始数据、JSON格式或甚至二进制响应的情况。为此，`requests`库具有自动解码服务器内容的能力。Requests可以顺畅地解码许多Unicode字符集。此外，Requests还会根据响应的编码进行有根据的猜测。这基本上是通过考虑头部信息来实现的。
- en: If we access the value of `r.content`, it results us the response content in
    a raw string format. And if we access `r.text`, the Requests library encodes the
    response (`r.content` value) using `r.encoding` and returns a new encoding string.
    In case, if the value of `r.encoding` is `None`, Requests assumes the encoding
    type using `r.apparent_encoding`, which is provided by the `chardet` library.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问 `r.content` 的值，它将返回一个原始字符串格式的响应内容。如果我们访问 `r.text`，Requests 库将使用 `r.encoding`
    对响应（`r.content` 的值）进行编码，并返回一个新的编码字符串。在这种情况下，如果 `r.encoding` 的值为 `None`，Requests
    将使用 `r.apparent_encoding` 来假设编码类型，`r.apparent_encoding` 是由 `chardet` 库提供的。
- en: 'We can access the server''s response content in the following way:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式访问服务器的响应内容：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding lines, we try to get the `google` homepage, using `requests.get()`
    and assigning it to a variable `r`. The `r` variable turns out to be a request
    object here, and we can access the raw content using `r.content` and the encoded
    response content with `r.text`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们尝试使用 `requests.get()` 获取 `google` 首页，并将其赋值给变量 `r`。这里的 `r` 变量实际上是一个请求对象，我们可以使用
    `r.content` 访问原始内容，以及使用 `r.text` 获取编码后的响应内容。
- en: 'If we wish to find what encoding Requests is using, or if we desire to change
    the encoding, we can use the property `r.encoding` as shown in the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想找出Requests正在使用的编码，或者如果我们想更改编码，我们可以使用属性`r.encoding`，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first line of the code, we are trying to access the type of encoding
    that is being followed by Requests. It resulted in `'ISO-8859-1'`. In the next
    line, I wished to change the encoding to `'utf-8'`. So I assigned the type of
    encoding to `r.encoding`. If we change the encoding like we did in the second
    line, Requests tends to use the latest value of `r.encoding` that has been assigned.
    So from that point in time, it uses the same encoding whenever we call `r.text`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一行，我们正在尝试访问Requests所使用的编码类型。结果是`'ISO-8859-1'`。在下一行，我希望将编码更改为`'utf-8'`。因此，我将编码类型赋值给了`r.encoding`。如果我们像第二行那样更改编码，Requests通常会使用已分配的`r.encoding`的最新值。所以从那时起，每次我们调用`r.text`时，它都会使用相同的编码。
- en: 'For an instance, if the value of `r.encoding` is `None`, Requests tend to use
    the value of `r.apparent_encoding`. The following example explains the case:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`r.encoding`的值为`None`，Requests通常会使用`r.apparent_encoding`的值。以下示例解释了这种情况：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Generally, the value of apparent encoding is specified by the `chardet` library.
    With more enthusiasm, if we attempt to set a new encoding type to `r.apparent_encoding`,
    Requests raises an `AttributeError` as its value can't be altered.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，显式编码的值由`chardet`库指定。如果我们充满热情地尝试将新的编码类型设置为`r.apparent_encoding`，Requests将引发一个`AttributeError`，因为其值不能被更改。
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Requests are efficient enough to use custom encodings. Take a case in which
    we have created an encoding of our own, and got it registered with the module
    of `codecs`. We can use our custom codec with ease; this is because the values
    of `r.encoding` and Requests will take care of the decoding.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请求足够高效，可以自定义编码。以我们创建了自己的编码并已在`codecs`模块中注册为例，我们可以轻松地使用我们的自定义编解码器；这是因为`r.encoding`的值和Requests会处理解码工作。
- en: Different types of request contents
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的请求内容
- en: Requests has the facility to deal with different types of Request contents like
    binary response content, JSON response content, and raw response content. To give
    a clear picture on different types of response content, we listed the details.
    The examples used here are developed using Python 2.7.x.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Requests 具有处理不同类型的请求内容的功能，例如二进制响应内容、JSON响应内容和原始响应内容。为了清晰地展示不同类型的响应内容，我们列出了详细信息。这里使用的示例是用
    Python 2.7.x 开发的。
- en: Custom headers
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义标题
- en: 'We can send custom headers with a request. For that, we just need to create
    a dictionary with our headers and pass the headers parameter in the `get`, or
    `post` method. In the dictionary, key is the name of the header and the value
    is, well, the value of the pair. Let us pass an HTTP header to a request:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在请求中发送自定义的头部信息。为此，我们只需创建一个包含我们头部信息的字典，并在`get`或`post`方法中传递头部参数。在这个字典中，键是头部信息的名称，而值则是，嗯，这对的值。让我们将一个HTTP头部信息传递给一个请求：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example has been taken from the Request documents found at [http://docs.python-requests.org/en/latest/user/quickstart/#custom-headers](http://docs.python-requests.org/en/latest/user/quickstart/#custom-headers).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例取自[http://docs.python-requests.org/en/latest/user/quickstart/#custom-headers](http://docs.python-requests.org/en/latest/user/quickstart/#custom-headers)中的请求文档。
- en: In this example, we have sent a header `content-type` with a value `application/json`,
    as a parameter to the request.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们向请求发送了一个带有值`application/json`的头部`content-type`作为参数。
- en: 'In the same way, we can send a request with a custom header. Say we have a
    necessity to send a request with an authorization header with a value as some
    token. We can create a dictionary with a key `''Authorization''` and value as
    a token which would look like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以发送带有自定义头部的请求。比如说，我们有必要发送一个带有授权头部且值为某个令牌的请求。我们可以创建一个字典，其键为`'Authorization'`，值为一个看起来如下所示的令牌：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sending form-encoded data
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送表单编码的数据
- en: We can send form-encoded data like an HTML form using Requests. A simple dictionary
    to the data argument gets this done. The dictionary of data will turn as form-encoded
    automatically, when a request is made.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Requests发送类似HTML表单的表单编码数据。将一个简单的字典传递给data参数即可完成此操作。当发起请求时，数据字典将自动转换为表单编码。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, we tried sending data that is form-encoded. While
    dealing with data that is not form-encoded, we should send a string in the place
    of a dictionary.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们尝试发送了表单编码的数据。而在处理非表单编码的数据时，我们应该在字典的位置发送一个字符串。
- en: Posting multipart encoded files
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布多部分编码的文件
- en: 'We tend to upload multipart data like images or files through POST. We can
    achieve this in `requests` using `files` which is a dictionary of `''name''` and
    value of `file-like-objects`. And also we can specify it as `''name''`, and value
    could be `''filename''`, `fileobj` just like in the following way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于通过 POST 方法上传多部分数据，如图片或文件。在 `requests` 库中，我们可以使用 `files` 参数来实现，它是一个包含 `'name'`
    和 `file-like-objects` 值的字典。同时，我们也可以将其指定为 `'name'`，值可以是 `'filename'` 或 `fileobj`，就像以下这种方式：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The example is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例如下：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the former example, we didn''t specify the content-type or headers. To add
    to that, we have the capability to set the name for the file we are uploading:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子中，我们没有指定内容类型或头部信息。除此之外，我们还有能力为上传的文件设置名称：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also send strings to be received as files in the following way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以下这种方式发送字符串作为文件接收：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Looking up built-in response status codes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看内置响应状态码
- en: 'Status codes are helpful in letting us know the result, once a request is sent.
    To know about this, we can use `status_code`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码有助于让我们知道请求发送后的结果。为了了解这一点，我们可以使用`status_code`：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To make it much easier to deal with `status_codes`, Requests has got a built-in
    status code lookup object which serves as an easy reference. We must compare the
    `requests.codes.ok` with `r.status_code` to achieve this. If the result turns
    out to be `True`, then it's `200` status code, and if it's `False`, it's not.
    We can also compare the `r.status.code` with `requests.codes.ok`, `requests.code.all_good`
    to get the lookup work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使处理`状态码`变得更加容易，Requests 模块内置了一个状态码查找对象，它作为一个便捷的参考。我们必须将`requests.codes.ok`与`r.status_code`进行比较以实现这一点。如果结果为`True`，则表示是`200`状态码，如果为`False`，则不是。我们还可以将`r.status.code`与`requests.codes.ok`、`requests.code.all_good`进行比较，以使查找工作得以进行。
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's try checking with a URL that is non-existent.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试检查一个不存在的URL。
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have got the facility to deal with the bad `requests` like 4XX and 5XX type
    of errors, by notifying with the error codes. This can be accomplished by using
    `Response.raise_for_status()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有处理不良`请求`的能力，例如4XX和5XX类型的错误，通过通知错误代码来实现。这可以通过使用`Response.raise_for_status()`来完成。
- en: 'Let us try this by sending a bad request first:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过发送一个错误请求来尝试一下：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now if we try a working URL, we get nothing in response, which is a sign of
    success:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们尝试一个有效的URL，我们不会得到任何响应，这是成功的标志：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您购买的所有Packt Publishing书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Viewing response headers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看响应头
- en: 'The server response header helps us to know about the software used by the
    origin server to handle the request. We can access the server response headers
    using `r.headers`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应头帮助我们了解原始服务器处理请求所使用的软件。我们可以通过`r.headers`访问服务器响应头：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Requests for Comments** (**RFC**) 7230 says that HTTP header names are not
    case-sensitive. This gives us a capability to access the headers with both capital
    and lower-case letters.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求评论**（**RFC**）7230 表示 HTTP 头部名称不区分大小写。这使我们能够使用大写和小写字母访问头部。'
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Accessing cookies with Requests
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Requests访问Cookies
- en: 'We can access cookies from the response, if they exist:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问响应中的cookie，如果存在的话：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can send our own cookies, as shown in the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发送自己的cookie，如下例所示：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tracking redirection of the request using request history
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求历史跟踪请求的重定向
- en: Sometimes the URL that we are accessing may have been moved or it might get
    redirected to some other location. We can track them using Requests. The response
    object's history property can be used to track the redirection. Requests can accomplish
    location redirection with every verb except with HEAD. The `Response.history`
    list contains the objects of the Requests that were generated in order to complete
    the request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们访问的URL可能已经被移动，或者可能会被重定向到其他位置。我们可以使用Requests来追踪它们。响应对象的history属性可以用来追踪重定向。Requests除了HEAD之外，可以用每个动词完成位置重定向。`Response.history`列表包含了为了完成请求而生成的Requests对象。
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, when we tried sending a request to `'www.google.com',`
    we got the `r.history` value as `302` which means the URL has been redirected
    to some other location. The `r.url` shows us the proof here, with the redirection
    URL.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当我们尝试向`'www.google.com'`发送请求时，我们得到了`r.history`的值为`302`，这意味着URL已经被重定向到了其他位置。`r.url`在这里显示了这一重定向的证明，包括重定向的URL。
- en: If we don't want Requests to handle redirections, or if we are using POST, GET,
    PUT, PATCH, OPTIONS, or DELETE, we can set the value of `allow_redirects=False,`
    so that redirection handling gets disabled.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想让Requests处理重定向，或者我们在使用POST、GET、PUT、PATCH、OPTIONS或DELETE时，我们可以将`allow_redirects=False,`的值设置为False，这样重定向处理就会被禁用。
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, we used the parameter `allow_redirects=False,` which
    resulted the `r.url` without any redirection in the URL and the `r.history` as
    empty.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了参数 `allow_redirects=False,`，这导致在URL中没有任何重定向，`r.url` 的值保持不变，而 `r.history`
    被设置为空。
- en: If we are using the head to access the URL, we can facilitate redirection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用头部来访问URL，我们可以简化重定向过程。
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we tried accessing the URL with head and the parameter `allow_redirects`
    enabled which resulted us the URL redirected.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们尝试使用带有启用参数`allow_redirects`的head方法访问URL，结果导致URL被重定向。
- en: Using timeout to keep productive usage in check
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超时来控制高效使用
- en: Take a case in which we are trying to access a response which is taking too
    much time. If we don't want to get the process moving forward and give out an
    exception if it exceeds a specific amount of time, we can use the parameter `timeout`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个案例，我们正在尝试访问一个耗时过多的响应。如果我们不想让进程继续进行，并在超过特定时间后抛出异常，我们可以使用参数`timeout`。
- en: When we use the `timeout` parameter, we are telling Requests not to wait for
    a response after some specific time period. If we use `timeout`, it's not equivalent
    to defining a time limit on the whole response download. It's a good practice
    to raise an exception if no bytes have been acknowledged on the underlying socket
    for the stated `timeout` in seconds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`timeout`参数时，我们是在告诉Requests在经过特定的时间段后不要等待响应。如果我们使用`timeout`，这并不等同于在整个响应下载上定义一个时间限制。如果在指定的`timeout`秒内底层套接字上没有确认任何字节，抛出一个异常是一个好的实践。
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example we have specified the `timeout` value as `0.03` in which the
    timeout has been exceeded to bring us the response and so it resulted us the `timeout`
    exception. The timeout may occur in two different cases:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们已将`timeout`值指定为`0.03`，超时时间已超过，从而带来了响应，因此导致了`timeout`异常。超时可能发生在两种不同的情况下：
- en: The request getting timed out while attempting to connect to the server that
    is in a remote place.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尝试连接到位于远程位置的服务器时，请求超时了。
- en: The request getting timed out if the server did not send the whole response
    in the allocated time period.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务器在分配的时间内没有发送完整的响应，请求将超时。
- en: Errors and exceptions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误和异常
- en: 'Different types of errors and exceptions will be raised when something goes
    wrong in the process of sending a request and getting back a response. Some of
    them are as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送请求和获取响应的过程中，如果出现问题，将会引发不同类型的错误和异常。其中一些如下：
- en: '`HTTPError`: When there are invalid HTTP responses, Requests will raise an
    `HTTPError` exception'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPError`: 当存在无效的HTTP响应时，Requests将引发一个`HTTPError`异常'
- en: '`ConnectionError`: If there is a network problem, such as refused connection
    and DNS failure, Requests will raise a `ConnectionError` exception'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionError`：如果存在网络问题，例如连接被拒绝和DNS故障，Requests将引发`ConnectionError`异常'
- en: '`Timeout`: If the request gets timed out, this exception will be raised'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timeout`: 如果请求超时，将抛出此异常'
- en: '`TooManyRedirects`: If the request surpasses the configured number of maximum
    redirections, this type of exception is raised'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TooManyRedirects`: 如果请求超过了配置的最大重定向次数，则会引发此类异常'
- en: Other types of exception that come in to the picture are `Missing schema Exception`,
    `InvalidURL`, `ChunkedEncodingError`, and `ContentDecodingError` and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些出现的异常类型包括`Missing schema Exception`、`InvalidURL`、`ChunkedEncodingError`、`ContentDecodingError`等等。
- en: This example has been taken from Request documents available at [http://docs.python-requests.org/en/latest/user/quickstart/#errors-and-exceptions](http://docs.python-requests.org/en/latest/user/quickstart/#errors-and-exceptions).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例取自[http://docs.python-requests.org/en/latest/user/quickstart/#errors-and-exceptions](http://docs.python-requests.org/en/latest/user/quickstart/#errors-and-exceptions)提供的请求文档。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a few basic topics. We learned why Requests is better
    than `urllib2`, how to make a simple request, different types of response contents,
    adding custom headers to our Requests, dealing with form encoded data, using the
    status code lookups, locating request redirection location and about timeouts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些基本主题。我们学习了为什么Requests比`urllib2`更好，如何发起一个简单的请求，不同类型的响应内容，如何为我们的Requests添加自定义头信息，处理表单编码数据，使用状态码查找，定位请求的重定向位置以及关于超时的问题。
- en: In the next chapter, we will learn the advanced concepts in Requests, in depth,
    which will help us to use the Requests library flexibly, according to the requirements.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入学习Requests的高级概念，这将帮助我们根据需求灵活地使用Requests库。
