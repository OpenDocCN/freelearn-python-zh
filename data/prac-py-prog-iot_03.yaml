- en: Getting Started with Python and IoT
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Python和IoT
- en: In [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml), *Setting Up Your
    Development Environment*, we went through the essentials of the Python ecosystem,
    virtual environments, and package management and set up your Raspberry Pi for
    development and GPIO interfacing. In this chapter, we will begin our journey in
    Python and IoT.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)中，*设置您的开发环境*，我们介绍了Python生态系统、虚拟环境和软件包管理的基本知识，并为您的树莓派进行了开发和GPIO接口设置。在本章中，我们将开始我们的Python和IoT之旅。
- en: What we cover in this chapter will lay the foundations and give us a working
    point of reference for the more advanced content that we'll cover in later chapters.
    We will learn to create a simple electrical circuit with a button, resistor, and
    LED (or light-emitting diode) and explore alternative ways to interact with the
    button and LED with Python. We will then proceed to create and discuss a complete
    end-to-end IoT program to control the LED over the internet and complete this
    chapter by looking at ways that you can extend the program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的内容将奠定基础，并为我们在后续章节中将要涵盖的更高级内容提供一个工作参考点。我们将学习如何使用按钮、电阻和LED（或发光二极管）创建一个简单的电路，并探索使用Python与按钮和LED交互的替代方法。然后，我们将继续创建和讨论一个完整的端到端IoT程序，以控制LED通过互联网，并通过查看您可以扩展程序的方式来完成本章。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a breadboard prototype circuit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个面包板原型电路
- en: Reading an electronic schematic diagram
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读电子原理图
- en: Exploring two ways to flash a LED in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索两种在Python中闪烁LED的方法
- en: Exploring two ways to integrate a push button in Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索两种在Python中集成按钮的方法
- en: Creating your first IoT program
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个IoT程序
- en: Extending your IoT program
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展您的IoT程序
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter and throughout this book, you will
    need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章和整本书的练习，您将需要以下内容：
- en: Raspberry Pi 4 Model B. A 1 GB RAM version will be adequate to run our examples. If
    you are working directly on your Raspberry Pi versus a **Secure Shell** (**SSH**)
    session; for example, more RAM is recommended to improve the Raspbian Desktop
    experience and responsiveness.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B型。1 GB RAM版本足以运行我们的示例。如果您直接在树莓派上工作而不是通过SSH会话；例如，更多的RAM建议以改善Raspbian桌面体验和响应能力。
- en: You will need Raspbian OS Buster (with desktop and recommended software).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将需要Raspbian OS Buster（带桌面和推荐软件）。
- en: You will need a minimum of Python version 3.5.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将需要至少Python版本3.5。
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B, Raspberry Pi Zero W, or a different version of Raspbian
    OS as long as your Python version is 3.5 or higher.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望代码示例应该在不修改的情况下在树莓派3型B、树莓派Zero W或不同版本的Raspbian OS上工作，只要您的Python版本是3.5或更高。
- en: You will find this chapter's source code in the `chapter02` folder in the GitHub
    repository available at the following URL: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在以下URL提供的GitHub存储库中的`chapter02`文件夹中找到本章的源代码：[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)。
- en: 'You will need to execute the following commands in a Terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在终端中执行以下命令来设置虚拟环境并安装本章代码所需的Python库：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖项已从`requirements.txt`中安装：
- en: '**GPIOZero**: The GPIOZero GPIO library ([https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOZero**：GPIOZero GPIO库（[https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero)）'
- en: '**PiGPIO**:The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: '**Requests**:A high-level Python library for making HTTP requests ([https://pypi.org/project/requests](https://pypi.org/project/requests))'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Requests**：用于发出HTTP请求的高级Python库（[https://pypi.org/project/requests](https://pypi.org/project/requests)）'
- en: 'We are going to require a few physical electronic components:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一些物理电子元件：
- en: 1 x 5 mm red LED
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 5毫米红色LED
- en: '1 x 200 Ω resistor: Its color bands will be red, black, brown, and then gold
    or silver'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 200Ω电阻：其色带将是红色、黑色、棕色，然后是金色或银色
- en: Momentary push button (**Single Pole Single Throw**—**SPST**)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瞬时按钮（单极单刀开关-SPST）
- en: A breadboard
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: Male-to-female and male-to-male jumper cables (sometimes called Dupont cables)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 母对公和公对公跳线（有时称为杜邦线）
- en: You will find a complete parts list cataloging all of the electrical components
    required for every chapter in the *Preface*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*前言*中找到一个完整的零件清单，其中列出了每一章所需的所有电子元件。
- en: When you have your electronic components ready, we can proceed and arrange them
    on your breadboard.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好您的电子元件后，我们可以继续并在您的面包板上安排它们。
- en: Creating a breadboard prototype circuit
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个面包板原型电路
- en: Throughout this book, we will be building many electrical circuits, and we will
    do this using an electronic breadboard. In the initial chapters, I will present
    many of the circuits with both a breadboard layout similar to that illustrated
    toward the end of this section in *Figure 2.7* and with a schematic diagram as
    shown in *Figure 2.8**.*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将建立许多电路，并将使用电子面包板进行。在最初的章节中，我将使用类似于本节末尾所示的面包板布局以及如图2.8所示的原理图来呈现许多电路。
- en: As we progress through this book and you gain more experience building breadboard
    circuits, I will cease with the breadboard layouts for the simpler circuits; however,
    I will still present them for the more complex circuits so you have something
    to compare your builds against.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，以及您在构建面包板电路方面的经验增加，我将停止对更简单电路的面包板布局；然而，对于更复杂的电路，我仍会呈现它们，这样您就有东西可以与您的构建进行比较。
- en: Please note that the proceeding circuit examples and discussions are only brief.
    At this stage of this book, we intend to build a simple electronic circuit that
    will be the basis for our Python examples in this chapter and [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask,* and [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml),
    *Networking with MQTT, Python, and the Mosquitto MQTT Broker.* We will discuss
    the Raspberry Pi and its pin numbering in detail in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World*. Furthermore, we will cover
    in detail circuits and electronics fundamentals in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*, where among other topics we will
    learn the *why* behind how the button interacts electrically with your Raspberry
    Pi and why a 200 Ω resistor accompanies our LEDs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下电路示例和讨论仅为简要介绍。在本书的这个阶段，我们打算构建一个简单的电子电路，这将是本章和第三章《使用Flask进行RESTful API和Web套接字的网络》以及第四章《使用MQTT，Python和Mosquitto
    MQTT Broker进行网络》中Python示例的基础。我们将在第五章《将您的Raspberry Pi连接到物理世界》中详细讨论树莓派及其引脚编号。此外，我们将在第六章《软件工程师的电子学101》中详细介绍电路和电子基础知识，其中我们将学习按钮如何在电气上与您的树莓派进行交互的*原因*，以及为什么200Ω电阻器伴随我们的LED。
- en: Let's get started with building our first circuit. I'll walk you through the
    breadboard build step by step and talk briefly about each component as we work
    with them. We will start by discussing what a breadboard is and how it works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的第一个电路。我将逐步为您介绍面包板的构建过程，并在我们使用它们时简要讨论每个组件。我们将从讨论面包板是什么以及它是如何工作的开始。
- en: Understanding the breadboard
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解面包板
- en: 'An electronic *breadboard,* as illustrated in *Figure 2.1*, is a prototyping
    board that helps you to electrically connect components and wires quickly and
    easily. In this section, we will discuss the general properties of a breadboard
    in preparation for connecting components and wires together in the following sections:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 电子*面包板*，如*图2.1*所示，是一个原型板，可以帮助您快速轻松地进行电气连接组件和电线。在本节中，我们将讨论面包板的一般属性，以便在接下来的部分中连接组件和电线时做好准备：
- en: '![](assets/a1acecae-ed38-4c66-9da8-9d6cd9d7c9dc.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a1acecae-ed38-4c66-9da8-9d6cd9d7c9dc.png)'
- en: Figure 2.1 – Breadboard
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 面包板
- en: Breadboards come in many different sizes, and our illustrated breadboard is
    a half-sized breadboard. Irrespective of their size, however, their basic layout
    and electrical connectivity are similar—with one small exception that I'll mention
    later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板有许多不同的尺寸，我们插图中的面包板是半尺寸面包板。然而，无论它们的尺寸如何，它们的基本布局和电气连接方式是相似的，只有一个小例外，我稍后会提到。
- en: Real breadboards may, or may not, have the row and column numbers markings on
    them. They have been included in the illustration to assist with the following
    discussion and explanations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的面包板可能有，也可能没有，行和列号码标记。它们已经包括在插图中，以帮助以下讨论和解释。
- en: 'The *holes* in the breadboard are where you place electrical components and
    wires to electrically connect them. The holes are electrically connected in the
    following ways:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板上的*孔*是您放置电子元件和电线以进行电气连接的地方。孔的电气连接方式如下：
- en: 'The two outer columns of holes are commonly referred to as *power rails*. There
    is a positive (+) column and a negative (-) column on either side of the breadboard.
    Each column of holes is electrically connected and run for the full length of
    the breadboard. Hence, there are four independent power rails on this breadboard:
    a *+* and *-* rail on the left-hand side of the breadboard and a *+* and *-* rail
    on the right-hand side.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板的两个外部列孔通常被称为*电源轨*。面包板的两侧分别有一个正（+）列和一个负（-）列。每一列孔都是电气连接的，并且贯穿整个面包板的长度。因此，这个面包板上有四个独立的电源轨：面包板左侧有一个*+*和*-轨，右侧也有一个*+*和*-轨。
- en: The power rails are frequently used to help to distribute power around the breadboard
    to components. Please note that they do not provide power themselves! They need
    a power source such as a power supply or battery connected to them to provide
    power.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 电源轨经常用于帮助在面包板上向组件分配电源。请注意，它们本身不提供电源！它们需要连接到电源供应或电池等电源源才能提供电源。
- en: The center of the breadboard has two banks of holes, which I have labeled *Bank
    A-E* and *Bank F-J*. Each *row* of holes in a bank is electrically connected.
    For example, holes A1 through to E1 are electrically connected, as are holes F1
    through to J1\. However, to be clear in our understanding, A1-E1 are *not* electrically
    connected to F1-J1 because they are on a separate bank.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板的中间有两排孔，我标记为*A-E*和*F-J*。每个银行的每一行孔都是电气连接的。例如，孔A1到E1是电气连接的，孔F1到J1也是如此。然而，为了清楚地理解，A1-E1与F1-J1并*不*是电气连接的，因为它们在不同的银行上。
- en: We straddle **Integrated Circuits** (**ICs**)—commonly called *chips—*acros*s* the gap
    between the two banks when we connect them into a breadboard. We will see an example
    of this in [Chapter 10](8b0b4483-ccde-4a92-896b-039eb94d911a.xhtml), *Movement
    with Servos, Motors, and Steppers*, when we use an IC to control motors.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它们连接到面包板时，我们跨越两个银行之间的间隙放置**集成电路**（**ICs**）—通常称为*芯片*。当我们使用IC来控制电机时，我们将在第十章《使用舵机，电机和步进电机进行运动》中看到一个例子。
- en: 'Here are a few more examples of how the holes are connected that you can work
    through to help with your understanding:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于孔是如何连接的更多示例，可以帮助你理解：
- en: B5 is electrically connected to C5 (they share the same row).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B5与C5电上连接（它们共享同一行）。
- en: H25 is electrically connected to J25 (they share the same row).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H25与J25电上连接（它们共享同一行）。
- en: A2 is *not* electrically connected to B2 (they don't share the same row).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A2与B2*不*电上连接（它们不共享同一行）。
- en: E30 is *not* electrically connected to F30 (they are on different banks).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E30与F30*不*电上连接（它们位于不同的银行）。
- en: The third + hole (from the top of the breadboard) on the left-hand side power
    rail is electrically connected to the last + hole on the left-hand side power
    rail (they are in the same vertical column).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧电源轨道顶部的第三个+孔（从面包板顶部开始）与左侧电源轨道的最后一个+孔电上连接（它们位于同一垂直列）。
- en: The third + hole (from the top of the breadboard) on the left-hand side power
    rail is *not* electrically connected to the third + hole on the right-hand side
    power rail (they are on different power rails).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧电源轨道顶部的第三个+孔（从面包板顶部开始）与右侧电源轨道的第三个+孔*不*电上连接（它们位于不同的电源轨道上）。
- en: I mentioned at the start of this section that all breadboards are basically
    the same, with one minor exception. This exception relates to the power rails.
    Some full-size breadboards may split their power rails into two separate vertical
    banks (so, electrically, the vertical holes in a rail do not run the full length
    of the breadboard). It is not always visually obvious that the power rails are
    split, so discovery needs to happen on a breadboard-by-breadboard basis. I mention
    this just in case you are using a full-size breadboard and experience connectivity
    issues when using the power rails.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节开始时提到，所有的面包板基本上都是一样的，只有一个小小的例外。这个例外与电源轨道有关。一些全尺寸的面包板可能会将它们的电源轨道分成两个独立的垂直银行（因此，电上地，轨道中的垂直孔并不贯穿整个面包板的长度）。电源轨道被分割并不总是在视觉上明显，因此需要根据面包板逐个发现。我提到这一点只是为了防止在使用电源轨道时出现连接问题时，以防你使用的是全尺寸的面包板。
- en: Now that we have introduced breadboards, and we understand how the holes are
    electrically related to one another, let's start plugging components and wires
    into our breadboards to create our first circuit. We'll start with the push button.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了面包板，并且了解了孔是如何在电上相互关联的，让我们开始将元件和导线插入我们的面包板，以创建我们的第一个电路。我们将从按键开始。
- en: Positioning and connecting the push button
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位和连接按键
- en: 'We are using a simple on/off button, also commonly known as an **Single Pole,
    Single Throw** (**SPST**) momentary switch. An example is shown in *Figure 2.2*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是一个简单的开关按钮，也被称为**单极单刀**（**SPST**）瞬时开关。一个例子如*图2.2*所示：
- en: '![](assets/ddfb0e64-b89d-4881-a9f4-7452f4205b00.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ddfb0e64-b89d-4881-a9f4-7452f4205b00.png)'
- en: Figure 2.2 – A push button and schematic symbol
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - 一个按键和原理图符号
- en: On the left-hand side of *Figure 2.2 *is a photograph of a momentary push button,
    while the right-hand side shows the schematic symbol for a momentary push button.
    We'll see this symbol and discuss schematic diagrams where these types of symbols
    appear in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图2.2*的左侧是一个瞬时按键的照片，右侧显示了瞬时按键的原理图符号。我们将在下一节看到这个符号，并讨论原理图中出现这些类型符号的地方。
- en: Push buttons come in many shapes and sizes; however, their general operation
    is the same. This specific push button pictured on the left-hand side is known
    as a *tactile* push button. They are small and well suited for use with a breadboard.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按键有各种形状和大小；然而，它们的一般操作是相同的。左侧显示的这个特定按键被称为*触觉*按键。它们小巧，非常适合与面包板一起使用。
- en: '*Figure 2.3 *illustrates the push button connection we need to create on our
    breadboard. Please refer to this as you follow the forthcoming steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.3*说明了我们需要在面包板上创建的按键连接。请在按照接下来的步骤时参考这个图：'
- en: '![](assets/14c9d62c-822d-4016-adcf-963d7850656a.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14c9d62c-822d-4016-adcf-963d7850656a.png)'
- en: Figure 2.3 – Connecting the push button
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 连接按键
- en: 'Here is how to connect the push button into your breadboard and connect it
    to your Raspberry Pi. The following step numbers match the numbered black circles
    in *Figure 2.3*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将按键连接到你的面包板并连接到你的树莓派。以下步骤编号与*图2.3*中编号的黑色圆圈相匹配：
- en: Position the button on the breadboard as shown. It does not matter exactly which
    row of holes the button goes into, however, *Figure 2.3* shows the button positioned
    (top-left leg) at hole B10.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照所示将按钮放在面包板上。按钮放入哪一行孔并不重要，但是*图2.3*显示了按钮的位置（左上腿）在孔B10处。
- en: Next, connect a jumper wire into the same row as the push button's top-most
    leg (our illustration uses hole A10). Connect the other end of this wire to the
    eighth pin counted down from the outer edge of your Raspberry Pi's GPIO header.
    This pin is known as GPIO 23.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将一根跳线插入与按键最顶端腿部相同的那一行（我们的插图使用孔A10）。将这根导线的另一端连接到树莓派的GPIO引脚头部外缘向下数第八个引脚。这个引脚被称为GPIO
    23。
- en: You can get header pin labels and breadboard compatible modules to assist you
    with Raspberry Pi pin connections and identification. Here is a link to a printable
    version to get you started: [https://github.com/splitbrain/rpibplusleaf](https://github.com/splitbrain/rpibplusleaf).
    We will cover GPIO pins and their numbering in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以获得引脚标签和面包板兼容模块，以帮助你进行树莓派引脚连接和识别。这里有一个可打印版本的链接，可以帮助你入门：[https://github.com/splitbrain/rpibplusleaf](https://github.com/splitbrain/rpibplusleaf)。我们将在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中介绍GPIO引脚及其编号，*将你的树莓派连接到物理世界*。
- en: Finally, using another wire (labeled* gnd'*), we connect the other side of the
    push button (the leg in hole B2) to the negative power rail on your breadboard.
    Our illustration shows the *gnd'* wire connection from hole A12 to a nearby hole
    on the left-hand side negative (-) power rail. The abbreviation *gnd* means ground.
    We will cover this term in more detail in the forthcoming section, *Understanding
    ground connections and symbols*.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用另一根线（标记为*gnd'*），将按钮的另一侧（B2孔中的腿）连接到面包板上的负电源轨。我们的插图显示了从A12孔到左侧负（-）电源轨上的附近孔的*gnd'*线连接。缩写*gnd*表示地线。我们将在接下来的部分*理解地线连接和符号*中更详细地介绍这个术语。
- en: Electrically, an SPST switch can be installed any way around. If your button
    has four legs (two sets will be electrically connected) and your circuit below
    does not work when we test it later in the *Exploring two ways to integrate a
    push button in Python *section try rotating the button in your breadboard 90 degrees.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 电气上，一个SPST开关可以安装在任何方向。如果你的按钮有四条腿（两组将被电连接），并且当我们在*探索两种方法在Python中集成一个按钮*部分测试电路时不起作用，请尝试将按钮在面包板上旋转90度。
- en: Now that our push button is in position and wired, we will next position and
    connect our LED.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的按钮已经就位并接线，接下来我们将定位和连接LED。
- en: Positioning and connecting the LED
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位和连接LED
- en: An LED is a small, yet bright, light made of a tiny crystal that emits a color
    when electricity is connected to it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: LED是由一个微小的晶体制成的小而明亮的灯，当电流连接到它时会发出颜色。
- en: 'A typical LED is shown in  *Figure 2.4.* The left-hand side of the diagram
    shows a physical representation of a LED, while the right-hand side shows the
    schematic symbol for a LED:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.4*显示了一个典型的LED。图表的左侧显示了LED的物理表示，而右侧显示了LED的原理图符号：'
- en: '![](assets/124bcbfb-9922-4e2a-8483-310489e81016.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/124bcbfb-9922-4e2a-8483-310489e81016.png)'
- en: Figure 2.4 – LED and schematic symbol
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 - LED和原理图符号
- en: LEDs need to be connected the correct way around into a circuit, otherwise,
    they will not work. If you look closely at your LED, you will notice a flat side
    on the LED casing. The leg on this side is the *cathode,* which connects to the
    negative or ground side of a power source. The cathode leg will also be the shorter
    of the LED's legs. The other leg is known as the *anode* and connects to the positive
    side of a power source. If you examine the LED symbol, you will notice that the
    cathode side of the LED has a line drawn across the tip of the triangle—if you
    think of this line as being like a big negative sign, it'll help you to remember
    which side of the symbol is the cathode leg.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: LED需要正确连接到电路中，否则它们将无法工作。如果你仔细观察LED，你会注意到LED外壳上有一面是平的。这一面的腿是*cathode*，连接到电源的负极或地线。cathode腿也是LED腿中较短的一个。另一个腿称为*anode*，连接到电源的正极。如果你仔细观察LED符号，你会注意到LED的cathode一侧有一条线横穿三角形的顶端
    - 如果你把这条线看作一个大的负号，它会帮助你记住符号的哪一侧是cathode腿。
- en: '*Figure 2.5 *the LED connection we are about to create. Please refer to this
    diagram as you follow the forthcoming steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.5*我们即将创建的LED连接。请在按照接下来的步骤时参考这个图表：'
- en: '![](assets/0b60e866-a29c-4456-b964-b0de7e2561c5.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0b60e866-a29c-4456-b964-b0de7e2561c5.png)'
- en: Figure 2.5 – Connecting the LED
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 连接LED
- en: 'Here is how to connect the LED into your breadboard and connect it to your
    Raspberry Pi. The following step numbers match the numbered black circles in *Figure
    2.5 *:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将LED连接到面包板并连接到树莓派的方法。以下步骤编号与*图2.5*中编号的黑色圆圈相匹配：
- en: Connect the LED into your breadboard as illustrated, taking care to ensure that
    the LED is installed the correct way around. Our illustration shows the cathode
    leg in hole E15 and the anode leg in hole E16.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照插图将LED连接到面包板上，确保LED安装的方向正确。我们的插图显示了cathode腿在E15孔，anode腿在E16孔。
- en: You may need to bend the legs on your LED to get it into position. As you position
    your LED, make sure the two legs are not touching one another! If they are touching,
    this will cause what is known as an* electrical short*, and the LED part of the
    circuit will not work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要弯曲LED的腿来使其就位。在安装LED时，请确保两条腿不要相互接触！如果它们接触，这将导致所谓的*电短路*，LED电路部分将无法工作。
- en: Next, using a jumper wire (labeled *gnd"*), connect the cathodeleg of the LED
    into the same power rail shared by the push button. We have shown this connection
    with one end of the *gnd"* wire connected in hole A15, while the other end of
    the wire connected to a nearby hole on the left-hand side negative (-) power rail.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用一根跳线（标记为*gnd"*），将LED的cathode腿连接到与按钮共享的相同电源轨。我们展示了这个连接，一端连接在A15孔，另一端连接到左侧负（-）电源轨上的附近孔。
- en: Finally, using another jumper wire (labeled *gnd),* connect the negative (-)
    power rail to the 17^(th) outer edge pin on your Raspberry Pi's GPIO header. This
    pin is a ground (GND) pin on your Raspberry Pi.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用另一根跳线（标记为*gnd*），将负（-）电源轨连接到树莓派GPIO引脚头的第17个外侧引脚。这个引脚是树莓派上的地线（GND）引脚。
- en: Well done! That's our LED connected. Next, we add the resistor, which will complete
    our circuit.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！这就是我们的LED连接。接下来，我们添加电阻，这将完成我们的电路。
- en: Positioning and connecting the resistor
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位和连接电阻
- en: A resistor is an electronic component used to limit (that is, resist) current
    flow and divide voltage and they are a very common electrical component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻是用来限制（即阻止）电流流动和分压的电子元件，它们是非常常见的电子元件。
- en: 'Shown in *Figure 2.6 *are a physical resistor (left-hand side) and two schematic
    symbols (right-hand side). There is no practical difference between the schematic
    symbols pictured. They represent different documentation standards, and you will
    find that the author of a schematic diagram will choose and stick with one type
    of symbol. We''ll be using the zig-zag symbol throughout this book:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.6*中显示了一个物理电阻（左侧）和两个原理图符号（右侧）。这些原理图符号之间没有实际区别。它们代表不同的文档标准，您会发现原理图图表的作者会选择并坚持使用一种类型的符号。我们将在本书中始终使用这种波浪形符号：'
- en: '![](assets/c378274d-bc70-4c00-8441-fc5d7a45713d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c378274d-bc70-4c00-8441-fc5d7a45713d.png)'
- en: Figure 2.6 – Resistor and schematic symbols
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 - 电阻和原理图符号
- en: Resistors come in many shapes, sizes, and colors. As a general guide, their
    physical shape and size relate to their physical properties and capabilities,
    while the color of their casing is usually insignificant, at least as far as their
    properties are concerned. The colored bands on a resistor, however, are very significant
    as they identify the resistor's value. It's worth mentioning that small general-purpose
    resistors (which are what we will be using) use color bands for specifying their
    value, while physically larger resistors used in high power applications frequently
    have their resistance value printed on their casing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻有许多形状、大小和颜色。作为一般指南，它们的物理形状和大小与它们的物理特性和能力有关，而它们外壳的颜色通常是无关紧要的，至少就它们的性能而言。然而，电阻上的彩色条带非常重要，因为它们标识了电阻的值。值得一提的是，小型通用电阻（我们将使用的）使用彩色条带来指定它们的值，而在高功率应用中使用的物理上更大的电阻通常在外壳上印有它们的电阻值。
- en: Resistors are an unbiased electrical component, meaning that they can be installed
    in an electrical circuit either way around. Their values, however, need to be
    chosen correctly, otherwise a circuit may not work as intended, or worse, the
    resistor and/or other components (including your Raspberry Pi) can be damaged.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻是一种无偏电子元件，这意味着它们可以以任何方式安装在电路中。然而，它们的值需要正确选择，否则电路可能无法按预期工作，或者更糟的是，电阻和/或其他组件（包括您的树莓派）可能会受到损坏。
- en: When starting out and learning about circuits, it is highly recommended and
    safest to always use the intended resistor values that are listed for a circuit.
    Avoid any temptation to substitute different values when you do not have the correct
    value on hand as this can result in damage to components and even your Raspberry
    Pi.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始学习电路时，强烈建议并且最安全的做法是始终使用电路所列的预期电阻值。避免在没有正确值的情况下替换不同的值，因为这可能会导致元件甚至您的树莓派受损。
- en: Our use of resistors through this book will be pragmatic. although I will be
    explaining how and why we arrive at the certain values we use from [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer,* onward. If you are new to resistors,
    you will find two links in the *Further reading* section where you can learn more
    about them, including how to read their values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中对电阻的使用将是实用的。虽然我将解释我们为什么选择特定值以及如何得出这些值的原因，从[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)开始，*软件工程师的电子学101*。如果您对电阻不熟悉，您会在*进一步阅读*部分找到两个链接，您可以在其中了解更多信息，包括如何读取它们的值。
- en: '*Figure 2.7 *demonstrates the resistor connection we need to create. Please
    refer to this as you follow the forthcoming steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.7*展示了我们需要创建的电阻连接。请在按照接下来的步骤时参考这个图：'
- en: '![](assets/f0765bac-ced0-413e-a255-230365d8066c.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f0765bac-ced0-413e-a255-230365d8066c.png)'
- en: Figure 2.7 – Completed button and LED circuit on the breadboard
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 - 面包板上完成的按钮和LED电路
- en: 'Here is how to connect the resistor into your breadboard. The following step
    numbers match the numbered black circles in *Figure 2.7*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何将电阻连接到您的面包板中的。以下步骤编号与*图2.7*中编号的黑色圆圈相匹配：
- en: Place one leg (is does not matter which one) of the resistor into a hole that
    shares the same row as the LED's anode leg. This connection is shown at hole D16. Insert
    the other leg inserted into a vacant row, shown at D20 (it'll be a vacant row
    on your breadboard until we connect the wire next).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电阻的一条腿（无论哪一条）插入与LED的阳极腿相同行的孔中。这个连接显示在D16孔。将另一条腿插入一个空行，显示在D20（在连接下一个导线之前，它将是面包板上的一个空行）。
- en: Using a jumper wire (illustrated starting at hole A20*)*, we connect the other
    leg of our resistor to the 20^(th) pin on the outer edge of your Raspberry Pi's
    GPIO header. This pin is known as GPIO 21.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线（从A20孔开始插入）*，我们将电阻的另一条腿连接到树莓派GPIO引脚的外侧边缘上的第20个引脚。这个引脚被称为GPIO 21。
- en: Well done! With that last connection, we have created our first circuit. We'll
    be using this base circuit throughout the rest of this chapter and in the next
    two chapters, [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking
    with RESTful APIs and Web Sockets Using Flask*, and [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml),
    *Networking with MQTT, Python, and the Mosquitto MQTT Broker*. We will start to
    explore a range of other circuits from [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World*, onward.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！通过最后一次连接，我们已经创建了我们的第一个电路。我们将在本章的其余部分以及接下来的两章中使用这个基本电路，[第3章](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)，*使用Flask进行RESTful
    API和Web套接字网络*，以及[第4章](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml)，*使用MQTT，Python和Mosquitto
    MQTT Broker进行网络连接*。我们将从[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)开始，开始探索一系列其他电路。
- en: Now that we have completed our breadboard circuit and learned how components
    and wires are connected on our breadboard, we are ready to explore a diagramming
    technique that is used to describe electrical circuits.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了面包板电路，并学会了如何连接面包板上的元件和导线，我们准备探索一种用于描述电路的图表技术。
- en: Reading an electronic schematic diagram
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读电子原理图
- en: In the last section, we built our first circuit on a breadboard by following
    a series of illustrated steps. In this section, we will learn about *schematic** diagrams*,
    which is a formal way of documenting and describing an electrical circuit. These
    are the diagrams you find in electronic texts and datasheets.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们通过一系列图示步骤在面包板上建立了我们的第一个电路。在本节中，我们将学习*原理图*，这是一种记录和描述电路的正式方式。这些是你在电子文本和数据表中找到的图表。
- en: We will learn how to read a simple schematic diagram and how it relates back
    to the breadboard layout we just created. Understanding how the two relate, and
    especially being able to create a breadboard layout from a schematic diagram,
    is an important skill you will need to develop as you continue your electronics
    and IoT journey.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何阅读简单的原理图，并了解它如何与我们刚刚创建的面包板布局相关联。理解这两者之间的关系，特别是能够从原理图创建面包板布局，是你在继续学习电子和物联网过程中需要发展的重要技能。
- en: The electronic circuits and schematic diagrams we will be seeing and working
    with throughout this book will be relatively simple as far as schematic diagrams
    are concerned. We will address important concepts and component symbols as we
    encounter them on a case-by-case basis. For our journey, a full and detailed explanation
    of the ins and outs of schematic diagramming is unnecessary and beyond the practical
    scope of this book. However, I encourage you to read through the Spark Fun tutorial
    that's mentioned in the *Further reading* section. It provides a brief, yet comprehensive
    overview of reading schematic diagrams and will provide you with a good foundational
    understanding of this diagramming technique and its semantics.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将看到和使用的电子电路和原理图相对简单。我们将根据具体情况讨论重要概念和组件符号。对于我们的旅程来说，不需要对原理图的细节进行全面解释，这超出了本书的实际范围。然而，我鼓励你阅读*进一步阅读*部分提到的Spark
    Fun教程。它提供了对阅读原理图的简要但全面的概述，并将为你提供对这种图表技术及其语义的良好基础理解。
- en: 'Let''s start by looking at a schematic diagram that represents the breadboard
    circuit we just created as shown in *Figure 2.7*. Our semantic diagram is illustrated
    here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从看一个代表我们刚刚创建的面包板电路的原理图开始，如*图2.7*所示。我们的原理图如下所示：
- en: '![](assets/1951077c-d77c-492a-954c-3cbc86eb172b.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1951077c-d77c-492a-954c-3cbc86eb172b.png)'
- en: Figure 2.8 – Schematic diagram of the breadboard circuit from Figure 2.7
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 - 图2.7中面包板电路的原理图
- en: A schematic diagram can be correctly drawn in a multitude of ways; however,
    I've purposely drawn this diagram (and will do so where appropriate in this book)
    to closely resemble its equivalent breadboard layout to help with its interpretation
    and understanding.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 原理图可以以多种方式正确绘制；然而，我特意绘制了这个图表（并将在本书中适当的地方这样做），以使其与等效的面包板布局紧密相似，以帮助理解和解释。
- en: We'll learn to read this schematic diagram by first explaining the push button
    connection and wiring.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过首先解释按钮连接和布线来学习阅读这个原理图。
- en: Reading the push button schematic connection
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读按钮原理图连接
- en: 'I''ve combined the breadboard layout and schematic diagram (with a few additional
    labels) as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将面包板布局和原理图（带有一些额外的标签）结合如下：
- en: '![](assets/1c4ef234-81bf-4871-ba1c-d85820c635d0.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1c4ef234-81bf-4871-ba1c-d85820c635d0.png)'
- en: Figure 2.9 – Combined breadboard and schematic diagram, part 1 of 2
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 - 组合面包板和原理图，第1部分共2部分
- en: 'Here is how to read the pushbutton connection. The following step numbers match
    the numbered black circles in *Figure 2.9*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何阅读按钮连接。以下步骤编号与*图2.9*中编号的黑色圆圈相匹配：
- en: Start at the breadboard with the wire labeled *wire 1.* If we look at the ends
    of this wire, we see that one end is connected to GPIO 23 on the Raspberry Pi,
    while the other end (at hole A10) connects to a row shared by the push button.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从标有*wire 1*的面包板开始。如果我们看这根导线的两端，我们会发现一端连接到树莓派上的GPIO 23，而另一端（在孔A10处）连接到一个与按钮共享的行。
- en: Looking at the schematic diagram, this breadboard connection is depicted diagrammatically
    by the line labeled *wire 1.* You will notice one end of the line is labeled GPIO23,
    while the other end leads into one side of the button symbol.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从原理图来看，这个面包板连接通过标有*wire 1*的线条图示。你会注意到线条的一端标有GPIO23，而另一端通向按钮符号的一侧。
- en: The color of a wire's casing has no inherent meaning. The color is simply a
    visual aid to help to distinguish different wires and connections. However, there
    are some common conventions such as using a red wire for a positive power connection
    and a black wire for the negative or ground wire
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 导线外壳的颜色没有固有的含义。颜色只是一种视觉辅助，用于区分不同的导线和连接。然而，有一些常见的惯例，比如使用红色导线表示正电源连接，黑色导线表示负极或地线。
- en: Next, starting at the other side of the push button on the breadboard (hole
    A12), notice the wire labeled *gnd'*. This wire connects the push button to the
    outer power rail on the breadboard.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从面包板上按钮的另一侧（孔A12）开始，注意标有*gnd'*的导线。这根导线将按钮连接到面包板上的外部电源轨。
- en: Five holes down from this first power rail connection, we see a second ground
    wire (labeled *gnd)* leading from the breadboard back to a GND pin on the Raspberry
    Pi.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个第一个电源轨连接下来的五个孔，我们看到第二根地线（标有*gnd*），从面包板返回到树莓派上的一个GND引脚。
- en: The breadboard *gnd* and *gnd'* wire connections are seen in the schematic diagram
    as the line labeled *gnd*, which leads out of the button and ends at a downward
    pointing *arrow* symbol annotated *GND* (remember *gnd* and *gnd'* are electrically
    connected on the breadboard and are therefore logically a single wire)*.* This
    is the symbol for a *ground connection*, and you will frequently see this symbol
    repeated a lot in schematic diagrams. I'll have more to say about this symbol
    when we reach the section titled *Reading and understanding the ground symbol*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原理图中，面包板上的*gnd*和*gnd'*线连接被表示为标有*gnd*的线，这条线从按钮出来并以一个向下的*箭头*符号注释为*GND*（记住*面包板上的*gnd*和*gnd'*是电连接的，因此在逻辑上是一根线）。这是*地线连接*的符号，你会经常在原理图中看到这个符号。当我们到达标题为*阅读和理解地线符号*的部分时，我会对这个符号有更多的话要说。
- en: Examine the button symbol in the schematic diagram and you will notice that
    the *wire 1* and *gnd* lines are not joined but rather terminate in the button
    symbol (the small circles). This is known as a *normally open* *connection* or,
    in our specific case, *a **normally open* switch. You can think of *normally open*
    as meaning the line is broken (and remember a *line* represents a *wire).* Now,
    if you imagine the button *pressed,* then the button touches each circle and connects
    the *blue* and *gnd* lines, resulting in a *closed* connection that completes
    the circuit between GPIO 23 and GND. We'll discuss this idea more in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查原理图中的按钮符号，你会注意到*wire 1*和*gnd*线并没有连接，而是终止在按钮符号（小圆圈）。这被称为*常开*连接，或者在我们的特定情况下，是*常开*开关。你可以把*常开*理解为意味着线路断开（记住*线*代表*导线*）。现在，如果你想象按钮被按下，那么按钮会触碰每个圆圈，并连接*蓝色*和*gnd*线，形成一个*闭合*连接，完成了GPIO
    23和GND之间的电路。我们将在[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)中更详细地讨论这个概念，*软件工程师的电子学101*。
- en: When you are comfortable that you understand how the push button connections
    on the breadboard match the push button section of the schematic diagram, we will
    proceed and discuss LED and resistor connections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确信你理解了面包板上按键的连接如何与原理图上的按键部分匹配时，我们将继续讨论LED和电阻的连接。
- en: Reading the LED and resistor schematic connection
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读LED和电阻的原理图连接
- en: 'Continuing from the previous section, where we learned how to read and understand
    the push button part of the schematic diagram, next we complete our explanation
    by covering the LED and resistor connections, as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一节，我们学习了如何阅读和理解原理图上按键部分，接下来我们将通过讨论LED和电阻的连接来完成我们的解释，如下所示：
- en: '![](assets/397ae268-fac0-4b72-93cd-447a7c8e845a.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/397ae268-fac0-4b72-93cd-447a7c8e845a.png)'
- en: Figure 2.10 – Combined breadboard and schematic diagram, part 2 of 2
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 - 组合面包板和原理图，第2部分
- en: 'Here is how to read the LED and resistor connection. The following step numbers
    match the numbered black circles in *Figure 2.10*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何阅读LED和电阻的连接。以下步骤编号与*图2.10*中编号的黑色圆圈相匹配：
- en: Start at the wire labeled *wire 2* on the breadboard. This wire connects GPIO
    21 on the Raspberry Pi into the row shared by one end of the resistor (hole A25).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从面包板上标有*wire 2*的线开始。这根线将树莓派上的GPIO 21连接到一个端子上，这个端子与一个电阻的一端（孔A25）共用。
- en: The *wire 2* connection is depicted by the line also labeled *wire 2* on the
    schematic diagram.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原理图上也标有*wire 2*的线连接。
- en: On the breadboard, the other end of the resistor is connected to the anode leg
    of the LED (hole E15). Remember, the resistor and anode leg of the LED are electrically
    connected because they share the same row of holes in the same bank on the breadboard.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面包板上，电阻的另一端连接到LED的阳极腿（孔E15）。记住，电阻和LED的阳极腿是电连接的，因为它们在面包板上的同一排孔中的同一组孔中。
- en: We see the resistor/LED connection in the schematic diagram where the resistor
    symbol meets the LED symbol. We know the resistor connects to the anode side of
    the LED in the diagram by the way the LED symbol is orientated.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在原理图中看到了电阻/LED连接，电阻符号与LED符号相遇。我们知道电阻通过LED符号的方向连接到了LED的阳极一侧。
- en: Next, on the breadboard, the other leg of the LED (hole E15)—the cathode leg—connects
    to the *gnd"* wire (hole A15), which then connects back to the outer power rail
    that is also shared by the push button's *gnd'* wire (which is then connected
    back to the Raspberry Pi's GND pin with the *gnd* wire.)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在面包板上，LED的另一端（孔E15）——阴极腿——连接到*gnd'*线（孔A15），然后连接回外部电源轨，这也是按键的*gnd'*线所共用的（然后通过*gnd*线连接回树莓派的GND引脚）。
- en: Finally, on the schematic diagram, this connection from the LED cathode leg
    to GND is depicted by the line labeled *gnd* (the same one used by the push button).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在原理图上，LED阴极腿到GND的连接由标有*gnd*的线表示（与按键使用的相同线）。
- en: We have now completed our schematic diagram explanation. How did you do? I hope
    you were able to trace around the diagram and see how it relates back to the circuit
    we built on the breadboard.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了我们的原理图解释。你做得怎么样？我希望你能够追踪原理图并看到它如何与我们在面包板上构建的电路相关联。
- en: Our last step illustrates an important concept in electronics—a *common ground*.
    We'll discuss this concept in more detail next.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步展示了电子学中一个重要的概念——*公共地*。我们将在接下来更详细地讨论这个概念。
- en: Introducing ground connections and symbols
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入地线连接和符号
- en: Electrical circuits all require a common electrical point of reference, and
    we call this point *ground.* This is why we see the push button and LED sharing
    a common connection on both the breadboard and schematic diagram (as a reminder,
    refer to *Figure 2.10*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有电路都需要一个共同的电参考点，我们称之为*地*。这就是为什么我们看到按键和LED在面包板和原理图上共享一个公共连接的原因（作为提醒，请参考*图2.10*）。
- en: For the simple circuits presented throughout this book and when working with
    your Raspberry Pi's GPIO pins, it will be practical to consider the terms *negative* and *ground* as
    interchangeable. This is because the *negative* side of a power source will be
    our common point of electrical reference (and yes, GPIO pins are a source of power,
    which we will explore more in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中提出的简单电路以及使用树莓派的GPIO引脚时，将考虑将术语*负*和*地*视为可互换的是实用的。这是因为电源的*负*端将是我们的电气参考点（是的，GPIO引脚是电源，我们将在[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)，*软件工程师的电子学101*中更多地探索）。
- en: 'As mentioned previously in the *Reading the push button schematic connection* section,
    in *step 4*, we diagrammed the ground point using an arrow symbol. Our ground
    symbol (made out of line segments) is one common variation of a ground symbol.
    You''ll see another variation in *Figure 2.11*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面在*阅读按钮原理图连接*部分提到的，在*步骤4*中，我们用箭头符号标注了地点。我们的地面符号（由线段组成）是一个常见的地面符号变体。您将在*图2.11*中看到另一个变体：
- en: '![](assets/48acfd85-f903-40d0-98e2-fdbd5211bef1.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48acfd85-f903-40d0-98e2-fdbd5211bef1.png)'
- en: Figure 2.11 – Common schematic diagram ground symbols
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 - 常见原理图地面符号
- en: All ground points are electrically connected, and we may repeat the symbol many
    times in a schematic diagram to help to simplify the diagram. By using the ground
    symbol to indicate a common ground connection, we remove the need to draw many
    interconnecting lines to join all ground connections together (which would get
    rather messy for large or more complex circuits).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有地点都是电气连接的，我们可以在原理图中多次重复符号，以帮助简化原理图。通过使用地面符号来指示共同的地面连接，我们消除了绘制许多互连线以连接所有地面连接在一起的需要（对于大型或更复杂的电路来说，这将变得非常混乱）。
- en: 'Our simple circuit certainly does not come under the banners of *large* or
    *complex*, however, to illustrate the concept of common ground, I have redrawn
    the schematic diagram shown originally in *Figure 2.8 *here, only this time using
    multiple ground symbols:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单电路当然不属于*大型*或*复杂*的范畴，但是为了说明共同地面的概念，我已经重新绘制了最初在*图2.8*中显示的原理图，只是这次使用了多个地面符号：
- en: '![](assets/95c85560-0269-4686-a3c1-dfbb79602628.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/95c85560-0269-4686-a3c1-dfbb79602628.png)'
- en: Figure 2.12 – Alternative schematic diagrams of the breadboard circuit in Figure
    2.7
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 - *图2.7*中面包板电路的替代原理图
- en: Although our alternative schematic diagram looks like two separate circuits,
    they are electrically connected exactly the same as our original schematic diagram
    in *Figure 2.8.*
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的替代原理图看起来像是两个独立的电路，但它们在电气上与我们原始的*图2.8*中的原理图完全相同。
- en: Please take a moment now to examine both *Figure 2.8 *and *Figure 2.12 *and
    see whether you can work out how the two diagrams are electrically the same.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请花一点时间查看*图2.8*和*图2.12*，看看你能否弄清楚这两个图是如何在电气上相同的。
- en: All I have done here is broken the line (labeled *gnd* in *Figure 2.8*) and
    redrawn the push button subcircuit and LED/resistor subcircuit in a different
    orientation and used separate ground symbol for each subcircuit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里所做的只是打破了线（在*图2.8*中标记为*gnd*）并重新绘制了按钮子电路和LED/电阻子电路，使用了不同的方向，并为每个子电路使用了单独的地面符号。
- en: As mentioned previously, at this stage of this book, we do not go into how or
    why this circuit works electronically or how it interacts electrically with the
    GPIO pins on your Raspberry Pi. We'll cover these topics and many more with practical
    and illustrative exercises when we reach [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics
    101 for the Software Engineer*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在本书的这个阶段，我们不会深入讨论这个电路在电子上是如何工作的，或者它如何与树莓派上的GPIO引脚进行电气交互。当我们到达[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)，*软件工程师的电子学101*时，我们将通过实际和说明性的练习来涵盖这些主题以及更多内容。
- en: Now that you have seen the schematic diagram that documents our breadboard circuit
    and see how they relate to one another, we're finally ready to dive into code
    and learn two ways to make our LED flash in Python!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了记录我们面包板电路的原理图，并了解了它们之间的关系，我们终于准备好深入代码，学习在Python中让LED闪烁的两种方法！
- en: Exploring two ways to flash an LED in Python
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中探索闪烁LED的两种方法
- en: 'In this section, we will investigate two alternative GPIO libraries and ways
    to make an LED flash in Python, including the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究两种替代的GPIO库和在Python中让LED闪烁的方法，包括以下内容：
- en: 'The GPIOZero library: An entry-level GPIO library'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPIOZero库：一个入门级的GPIO库
- en: 'The PiGPIO library: An advanced GPIO library'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PiGPIO库：一个高级的GPIO库
- en: As we learn to use these two libraries, we will see how they approach GPIO control
    differently and discover their relative strengths and weaknesses.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习使用这两个库时，我们将看到它们如何不同地处理GPIO控制，并发现它们的相对优势和劣势。
- en: After completing this section (and the following section, *Exploring two ways
    to integrate a push button in Python*), you will have explored and compared two
    very different approaches to GPIO control—the high-level (using GPIOZero) and
    a lower-level (using PiGPIO)—and have a good introductory grasp of when and how
    you would choose between the alternative when building an electronic interfacing
    program.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本节（以及接下来的*在Python中探索集成按钮的两种方法*部分）后，您将探索并比较了GPIO控制的两种非常不同的方法——高级（使用GPIOZero）和低级（使用PiGPIO），并且对在构建电子接口程序时何时以及如何选择这两种方法有一个很好的入门理解。
- en: Let's start our practical exercises by making the LED blink using GPIOZero.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用GPIOZero使LED闪烁来开始我们的实际练习。
- en: Blinking with GPIOZero
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GPIOZero闪烁
- en: We are now ready to investigate our first blinking method using the GPIOZero
    library. You will find the code we are about to cover in the `chapter02/led_gpiozero.py` file.
    Please review this file before proceeding.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用GPIOZero库来研究我们的第一种闪烁方法。您将在`chapter02/led_gpiozero.py`文件中找到我们即将涵盖的代码。请在继续之前查看此文件。
- en: In the *Further reading* section, you will find relevant links to the GPIOZero
    API documentation for the specific features of this library that we use in this
    section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在*进一步阅读*部分，您将找到与我们在本节中使用的库的特定功能相关的GPIOZero API文档的相关链接。
- en: We will start by running our example code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从运行我们的示例代码开始。
- en: 'Run the program using the following command, remembering that you need to be
    in the *activated* virtual environment (if you need a refresher on how to activate
    a Python virtual environment, see [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml), *Setting
    Up Your Development Environment*):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序，记住您需要在*activated*虚拟环境中（如果您需要关于如何激活Python虚拟环境的复习，请参阅[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)，*设置您的开发环境*）：
- en: '[PRE1]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the LED is connected correctly, it should blink.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LED连接正确，它应该会闪烁。
- en: If you receive an error about PiGPIO when you run the program, make sure you
    have enabled the `pigpio` daemon as outlined in [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml),* Setting
    Up Your Development Environment*. We'll talk more about PiGPIO and the PiGPIO
    daemon in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting
    Your Raspberry Pi to the Physical World*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行程序时收到有关PiGPIO的错误，请确保您已经按照[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)中概述的方式启用了`pigpio`守护程序。我们将在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中更多地讨论PiGPIO和PiGPIO守护程序，*将您的树莓派连接到物理世界*。
- en: Now that we have run the code and seen the LED blink, it's time to look through
    the code that makes this happen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了代码并看到LED闪烁，是时候浏览使这一切发生的代码了。
- en: '**Imports**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入**'
- en: 'We will start our code exploration by looking at the external libraries we
    are importing in our Python program. They appear near the top of the source file,
    as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看我们在Python程序中导入的外部库开始我们的代码探索。它们出现在源文件的顶部附近，如下所示：
- en: '[PRE2]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The imports of interest are the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的导入如下：
- en: At line (1), we import the `Device` and `LED` classes from the GPIOZero package.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第（1）行，我们从GPIOZero包中导入`Device`和`LED`类。
- en: At line (2), we are importing a GPIOZero *Pin Factory*. This is used together
    with the `Device` class, which we'll see next.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第（2）行，我们导入了一个GPIOZero *Pin Factory*。这与`Device`类一起使用，接下来我们将看到。
- en: Next, we see how to set the GPIOZero Pin Factory implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何设置GPIOZero Pin Factory实现。
- en: Pin Factory configuration
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引脚工厂配置
- en: 'A *Pin Factory* is used in GPIOZero specify which concrete GPIO library GPIOZero
    will use to perform the actual GPIO work. We will discuss Pin Factories in more
    detail when we compare the GPIOZero and PiGPIO examples later in this chapter in
    the *Comparing the GPIOZero and PiGPIO examples *section:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPIOZero中使用*Pin Factory*指定GPIOZero将使用哪个具体的GPIO库来执行实际的GPIO工作。当我们在本章的*比较GPIOZero和PiGPIO示例*部分比较GPIOZero和PiGPIO示例时，我们将更详细地讨论Pin
    Factory：
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On line (3), we are telling GPIOZero to use PiGPIO as its *Pin Factory* using
    the `Device` and `PiGPIOFactory` imports.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（3）行，我们告诉GPIOZero使用PiGPIO作为其*Pin Factory*，使用`Device`和`PiGPIOFactory`导入。
- en: Now that we've seen how a Pin Factory is set up, let's look at the code that makes
    our LED blink.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了如何设置Pin Factory，让我们看看使我们的LED闪烁的代码。
- en: Blinking the LED
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LED闪烁
- en: 'Here, we see the `LED` class at line (4) in the following is created and assigned
    to the `led` variable. The parameter to `LED` is the GPIO pin that the physical
    LED is connected to, as per the breadboard in *Figure 2.1*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在第（4）行看到了`LED`类，它被创建并分配给了`led`变量。`LED`的参数是物理LED连接到的GPIO引脚，如*图2.1*中的面包板上所示：
- en: '[PRE4]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On line (5), we start the LED blinking. The `background=False` parameter to `blink()` is
    needed to run the LED on the main thread so the program does not exit (an alternative
    of `background=True` would be to use `signal.pause()`. We'll see an example of
    this in the next section).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（5）行，我们开始LED闪烁。`blink()`的`background=False`参数需要在主线程上运行LED，以便程序不会退出（`background=True`的另一种选择是使用`signal.pause()`。我们将在下一节中看到一个例子）。
- en: GPIOZero makes it very easy to interface with common electronic components such
    as an LED. Next, we will perform the same exercise, only this time using the PiGPIO
    library.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOZero使得与LED等常见电子元件进行接口非常容易。接下来，我们将执行相同的练习，只是这次使用PiGPIO库。
- en: Blinking with PiGPIO
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PiGPIO闪烁
- en: Now that we have seen how to blink our LED using the GPIOZero library, let's
    look at an alternative method using the PiGPIO library.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用GPIOZero库闪烁LED，让我们看看使用PiGPIO库的另一种方法。
- en: The code we are about to walk through is contained in the `chapter02/led_pigpio.py` file. Terminate
    the previous example if it is still running, and run `led_pigpio.py`. The LED
    should blink again.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将要讲解的代码包含在`chapter02/led_pigpio.py`文件中。如果之前的示例仍在运行，请终止它，并运行`led_pigpio.py`。LED应该会再次闪烁。
- en: In the *Further reading* section, you will find relevant links to the PiGPIO
    API documentation for the specific features of this library that we are using
    in this section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在*进一步阅读*部分，您将找到与我们在本节中使用的PiGPIO库的特定功能相关的PiGPIO API文档的相关链接。
- en: Let's walk through the PiGPIO version of our LED blinking code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览一下我们LED闪烁代码的PiGPIO版本。
- en: '**Imports**'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入**'
- en: 'Starting at the top of the file, we have the `import` section of the source
    file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件的顶部开始，我们有源文件的`import`部分：
- en: '[PRE5]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time around, on line (1), we only need to import the PiGPIO module.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，在第（1）行，我们只需要导入PiGPIO模块。
- en: Next, we will see how to configure PiGPIO and set the I/O mode on the GPIO pin
    that is connected to our LED.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何配置PiGPIO并设置连接到我们的LED的GPIO引脚的I/O模式。
- en: '**PiGPIO and pin configuration**'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**PiGPIO和引脚配置**'
- en: 'Let''s look at the code that configures PiGPIO and the LED''s GPIO pin:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看配置PiGPIO和LED的GPIO引脚的代码：
- en: '[PRE6]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We create an instance of PiGPIO on line (2) and assign it to the `pi` variable.
    We use this variable to interact with the PiGPIO library from this point forward
    in the code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第（2）行创建了一个PiGPIO的实例，并将其分配给了`pi`变量。我们将使用这个变量从代码的这一点开始与PiGPIO库进行交互。
- en: On line (3), we configure GPIO pin 21 to be an *output* pin. Configuring a pin
    as *output* means we want to use that pin to control something connected to it
    from our Python code. In this example, we want to control the LED. Later in this
    chapter, we'll see an example of an input pin used to respond to button presses.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（3）行，我们配置GPIO引脚21为*输出*引脚。配置引脚为*输出*意味着我们希望使用该引脚来从我们的Python代码控制连接到它的东西。在这个示例中，我们想要控制LED。在本章的后面，我们将看到一个使用输入引脚来响应按钮按下的示例。
- en: Now that we have imported our required libraries and configured PiGPIO and the
    out GPIO pin, let's now see how we are making the LED blink.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所需的库并配置了PiGPIO和输出GPIO引脚，让我们看看我们是如何让LED闪烁的。
- en: '**Blinking the LED**'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**闪烁LED**'
- en: 'Finally, we make our LED blink:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们让LED闪烁：
- en: '[PRE7]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We achieve the blinking with PiGPIO using a `while` loop. As the loop executes,
    we are toggling GPIO pin 21— our *output* pin—on and off (lines (4) and (5)),
    with a short `sleep()` function in between, hence making the LED appear to blink.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用PiGPIO通过一个`while`循环来实现闪烁。当循环执行时，我们在GPIO引脚21上进行切换-我们的*输出*引脚-打开和关闭（第（4）和（5）行），之间有一个短的`sleep()`函数，因此LED看起来在闪烁。
- en: Next, we will compare our two libraries and their different approaches to blinking
    the LED.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将比较我们的两个库及它们对LED闪烁的不同方法。
- en: Comparing the GPIOZero and PiGPIO examples
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较GPIOZero和PiGPIO示例
- en: If you look at the code for the GPIOZero example, it's pretty obvious we're
    making an LED blink—it's pretty explicit in the code. But what about the PiGPIO
    example? There is no mention of LEDs or blinking. In truth, it could be doing
    anything—it's just we know an LED is connected to GPIO 21.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看GPIOZero示例的代码，很明显我们正在让LED闪烁-代码中非常明显。但是PiGPIO示例呢？没有提到LED或闪烁。事实上，它可以做任何事情-只是我们知道LED连接到GPIO
    21。
- en: 'Our two blinking examples reveal important aspects of GPIOZero and PiGPIO:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个闪烁示例揭示了GPIOZero和PiGPIO的重要方面：
- en: '**GPIOZero** is a higher-level wrapper library. On the surface, it abstracts
    common electronic components such as LEDs into simple-to-use classes while, underneath,
    it is delegating the actual interfacing work to a concrete GPIO library.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOZero**是一个更高级的包装库。在表面上，它将常见的电子元件（如LED）抽象成易于使用的类，而在底层，它将实际的接口工作委托给一个具体的GPIO库。'
- en: '**PiGPIO** is a lower-level GPIO library where you work with, control, and
    access GPIO pins directly.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**是一个更低级的GPIO库，您可以直接使用、控制和访问GPIO引脚。'
- en: The "zero" in GPIOZero refers to a naming convention for zero boilerplate code
    libraries where all of the complex internals are abstracted away to make it easier
    for beginners to get started.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOZero中的“zero”指的是零样板代码库的命名约定，其中所有复杂的内部部分都被抽象化，以使初学者更容易上手。
- en: GPIOZero performs its delegation to an external GPIO library using a *Pin Factory*.
    In our example, we delegated to PiGPIO using the line, `Device.pin_factory = PiGPIOFactory()`.
    We'll pick up the topic of GPIOZero and delegation again in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting
    your Raspberry Pi to the Physical World*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOZero通过*Pin Factory*将其委托给外部GPIO库。在我们的示例中，我们使用了一行代码将其委托给了PiGPIO，`Device.pin_factory
    = PiGPIOFactory()`。我们将在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中再次讨论GPIOZero和委托的主题，*将您的树莓派连接到物理世界*。
- en: As we proceed through this book, we will be using both GPIOZero and PiGPIO.
    We'll use GPIOZero to simplify and condense code where appropriate, while we will
    be using PiGPIO for more advanced code examples and to teach core GPIO concepts
    that are otherwise abstracted away by GPIOZero.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将同时使用GPIOZero和PiGPIO。我们将使用GPIOZero来简化和压缩代码，同时我们将使用PiGPIO来进行更高级的代码示例，并教授通过GPIOZero抽象掉的核心GPIO概念。
- en: Next, we will continue building on our LED blinking examples by integrating
    the push button.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续通过集成按钮来构建LED闪烁示例。
- en: Exploring two ways to integrate a push button in Python
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索在Python中集成*按钮的两种方法
- en: In the previous section, we explored two different approaches to making our
    LED blink—one using the GPIOZero library and the other with the PiGPIO library. In
    this section, we will integrate the push button from the circuit in *Figure 2.1 *with
    Python and see how we can integrate the button using both the GPIOZero and PiGPIO
    libraries.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们探讨了两种不同的方法来使我们的LED闪烁-一种使用GPIOZero库，另一种使用PiGPIO库。在本节中，我们将集成*图2.1*中电路中的按钮，并看看如何使用GPIOZero和PiGPIO库集成按钮。
- en: We will start by making our LED turn on and off with a button that is integrated
    using the GPIOZero library.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用GPIOZero库来使我们的LED与使用GPIOZero库集成的按钮打开和关闭。
- en: Responding to a button press with GPIOZero
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GPIOZero响应按钮按下
- en: The code we are about to cover is included in the `chapter02/button_gpiozero.py` file. Please
    review and run this file. The LED should turn on and off as you press the button.
    As per the circuit in *Figure 2.1*, the LED is still connected to GPIO 21, while
    our button is connected to GPIO 23.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的代码包含在`chapter02/button_gpiozero.py`文件中。请查看并运行此文件。按下按钮时，LED应该会打开和关闭。根据*图2.1*中的电路，LED仍连接到GPIO
    21，而我们的按钮连接到GPIO 23。
- en: As mentioned previously in the *Creating a breadboard circuit* section, if your
    button has four legs (two sets will be electrically joined) and your circuit does
    not work, try rotating the button in the breadboard 90 degrees.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的*创建面包板电路*部分所述，如果您的按钮有四条腿（两组将被电气连接），而您的电路不起作用，请尝试将按钮在面包板上旋转90度。
- en: Let's walk through the significant parts of the code, noting that we are skipping sections
    of code that we've already covered.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走一遍代码的重要部分，注意我们跳过了我们已经涵盖过的代码部分。
- en: '**Imports**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入**'
- en: 'Starting at the top of the source file, you will find the section of code where
    we import external libraries, as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从源文件的顶部开始，您将找到导入外部库的代码部分，如下所示：
- en: '[PRE8]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this example, we have also imported the GPIOZero `Button` class (1) and
    the Python `signal` module (2).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们还导入了GPIOZero的`Button`类（1）和Python的`signal`模块（2）。
- en: Now that you have seen that we are importing the `Button` class, let's look
    at the handler function that will be called when the button is pressed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到我们正在导入`Button`类，让我们看一下当按下按钮时将调用的处理程序函数。
- en: '**Button pressed handler**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**按钮按下处理程序**'
- en: 'We are using a callback handler to respond to button presses, defined in the
    `pressed()` function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用回调处理程序来响应按钮按下，定义在`pressed()`函数中：
- en: '[PRE9]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On line (3), our LED is turned on and off each time `pressed()` is invoked using
    the `toggle()` method of `led`. On line (4), we query the `value` property of
    `led` to determine whether the LED is on (`value == 1`) or off (`value == 0`)
    and store it in the `state` variable, which we print to the Terminal on line (5).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（3）行，我们的LED在每次调用`pressed()`时使用`led`的`toggle()`方法打开和关闭。在第（4）行，我们查询`led`的`value`属性来确定LED是开启（`value
    == 1`）还是关闭（`value == 0`），并将其存储在`state`变量中，然后在第（5）行打印到终端。
- en: You can also control the LED with the `led.on()`, `led.off()`, and `led.blink()` methods.
    You can also directly set the LED on/off state by setting `led.value`, for example, `led.value
    = 1` will turn the LED on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`led.on()`、`led.off()`和`led.blink()`方法来控制LED。您还可以通过设置`led.value`直接设置LED的开/关状态，例如，`led.value
    = 1`将打开LED。
- en: Let's continue and see how to create and configure a `Button` class instance
    and register the `pressed()` function so it is called when you press the physical
    button.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看如何创建和配置`Button`类实例，并注册`pressed()`函数，以便在按下物理按钮时调用它。
- en: '**Button configuration**'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**按钮配置**'
- en: 'Following are the lines used to configure the push button. On line (6), the
    class we use is `Button`. In GPIOZero, we use a `Button` class for any *input*
    device that can be either on or off, such as buttons and switches:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于配置按钮的行。在第（6）行，我们使用的类是`Button`。在GPIOZero中，我们使用`Button`类来表示任何可以处于开启或关闭状态的*输入*设备，例如按钮和开关：
- en: '[PRE10]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On line (7), we register the `pressed()` callback handler with our `button` instance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（7）行，我们使用`button`实例注册了`pressed()`回调处理程序。
- en: 'Here are the meanings of the parameters to the `Button` constructor on line
    (6):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第（6）行中`Button`构造函数的参数含义：
- en: The first parameter is the button's GPIO pin (`BUTTON_GPIO_PIN == 23`).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是按钮的GPIO引脚（`BUTTON_GPIO_PIN == 23`）。
- en: The second parameter, `pull_up=True`, enables an internal pull-up resistor for
    GPIO 23\. Pull-up and pull-down resistors are an important concept in digital
    electronics. We're are going to skip over this concept for now because we will
    be covering the importance and use of pull-up and pull-down resistors in greater
    detail in [Chapter 6,](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml) *Electronics
    101 for the Software Engineers*.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数`pull_up=True`为GPIO 23启用了内部上拉电阻。上拉和下拉电阻是数字电子学中的重要概念。我们现在将跳过这个概念，因为我们将在[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)“软件工程师的电子学101”中更详细地介绍上拉和下拉电阻的重要性和用途。
- en: The third parameter `bounce_time=0.1` (0.1 seconds), is used to compensate for
    an occurrence known as switch or contact *bounce*.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数`bounce_time=0.1`（0.1秒）用于补偿开关或接触*抖动*。
- en: Bounce is a type of electrical noise that occurs as the metal contacts within
    a physical button or switch come together. The result of this noise is seen as
    a rapid succession of on-off (or high-low) states changes on a digital input pin.
    This is undesirable because we want *one* physical press of a button (or toggle
    of a switch) to be seen as *one* state change on the input pin*.* This is commonly
    achieved in code using a **debounce threshold** or **timeout***,* which in our
    case is the amount of time that our Raspberry Pi ignores successive pin stage
    changes following an initial state change.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 抖动是一种电气噪声，当物理按钮或开关内的金属触点接触时会发生。这种噪声的结果是在数字输入引脚上看到快速连续的开关（或高低）状态变化。这是不希望的，因为我们希望*一个*按钮的物理按下（或开关的切换）被视为输入引脚上的*一个*状态变化。在代码中通常使用**去抖动阈值**或**超时**来实现这一点，而在我们的情况下，这是我们的树莓派在初始状态变化后忽略连续引脚状态变化的时间量。
- en: Try setting `bounce_time=0` (no debouncing). You should find that the button
    behaves very erratically. Then, use a higher number such as `bounce_time=5` (5 
    seconds), and you will find that after the first press the button is non-responsive
    until the duration expires.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试设置`bounce_time=0`（不去抖动）。您会发现按钮的行为非常不稳定。然后，使用更高的数字，例如`bounce_time=5`（5秒），您会发现在第一次按下按钮后，按钮在持续时间到期之前都无响应。
- en: When it comes to push buttons, selecting an appropriate debounce threshold is
    a matter of balancing how rapidly a user needs to press the button (this demands
    lower thresholds) versus how much bounce is inherent in your button (this demands
    higher thresholds). About 0.1 seconds is a good suggested starting value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择适当的去抖动阈值时，需要权衡用户需要多快按下按钮（这需要较低的阈值）与按钮固有的抖动量（这需要较高的阈值）。大约0.1秒是一个很好的建议起始值。
- en: Finally, let's cover a common technique that is used to prevent an electronic-interfacing
    Python program from exiting.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们介绍一种常见的技术，用于防止电子接口Python程序退出。
- en: '**Preventing the main thread from terminating**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**防止主线程终止**'
- en: 'It''s common to see the use of `signal.pause()` or an equivalent construct
    in GPIO examples and programs:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPIO示例和程序中经常看到使用`signal.pause()`或等效构造：
- en: '[PRE11]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Line (8) prevents the main program thread from reaching its natural end, which
    under normal circumstances is where the program terminates.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第（8）行防止主程序线程达到其自然结束，正常情况下程序会在那里终止。
- en: Forgetting to add `signal.pause()` to the end of a GPIO-interfacing Python program
    is a common and often confusing mistake when starting out. If your program exits
    immediately after it's started, try adding `signal.pause()` at the end of your
    program as a first step.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，忘记在GPIO接口Python程序的末尾添加`signal.pause()`是一个常见且常常令人困惑的错误。如果您的程序在启动后立即退出，请尝试将`signal.pause()`添加到程序的末尾作为第一步。
- en: 'We didn''t need `signal.pause()` with our previous LED flashing examples. Here
    is why:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以前的LED闪烁示例中不需要`signal.pause()`。原因如下：
- en: Our GPIOZero example (`chapter02/led_gpiozero.py`) used `background=False` in
    the LED constructor. This prevented our program from exiting by keeping the LED's
    thread in the foreground.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的GPIOZero示例（`chapter02/led_gpiozero.py`）在LED构造函数中使用了`background=False`。这通过将LED的线程保持在前台来防止程序退出。
- en: In the PiGPIO example (`chapter02/led_pigpio.py`), it's the `while` loop that
    prevents the program from exiting.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PiGPIO示例（`chapter02/led_pigpio.py`）中，是`while`循环阻止程序退出。
- en: If this seems confusing, don't worry! Knowing how to prevent a program from
    existing abnormally all comes down to experience, practice, and understanding
    how Python and GPIO libraries work.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来令人困惑，不要担心！知道如何防止程序异常退出归根结底取决于经验、实践和理解Python和GPIO库的工作原理。
- en: Next, let's see how to integrate the button using PiGPIO.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用PiGPIO集成按钮。
- en: Responding to a button press with PiGPIO
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PiGPIO响应按钮按下
- en: We will now replicate the same functionality as our previous GPIOZero example
    to turn our LED on and off with a button press, only this time using the PiGPIO
    library. The code for our PiGPIO example can be found in the `chapter02/button_pigpio.py` file.
    Please review and run this file now, and confirm that the LED responds to your
    button presses.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用PiGPIO库复制与之前的GPIOZero示例相同的功能，通过按下按钮来打开和关闭LED，只是这次使用PiGPIO库。我们的PiGPIO示例的代码可以在`chapter02/button_pigpio.py`文件中找到。请现在查看并运行此文件，并确认LED是否响应您的按钮按下。
- en: Let's unravel the interesting parts of the code, starting with the GPIO pin
    configuration for the push button (again, noting that we're skipping sections
    of code that we've already covered).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解开代码的有趣部分，从推按钮的GPIO引脚配置开始（再次注意，我们跳过了已经涵盖的代码部分）。
- en: '**Button pin configuration**'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**按钮引脚配置**'
- en: 'Starting on line (1), we configure GPIO pin 23 (`BUTTON_GPIO_PIN == 23`) as
    an *input* pin:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从第1行开始，我们将GPIO引脚23（`BUTTON_GPIO_PIN == 23`）配置为*输入*引脚：
- en: '[PRE12]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, on line (2), we enable an internal pull-up resistor for pin 23\. In PiGPIO,
    we debounce the push button on line (3) using the `pi.set_glitch_filter()` method.
    This method takes the parameter in milliseconds.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第2行，我们为引脚23启用内部上拉电阻。在PiGPIO中，我们在第3行使用`pi.set_glitch_filter()`方法对推按钮进行去抖动。此方法以毫秒为参数。
- en: Notice, in PiGPIO, we needed to configure each property for our button (pin
    input mode, a pull-up resistor, and debouncing) as a discrete method call, whereas
    in the previous GPIOZero example this all occurred on a single line when we created
    an instance of the GPIOZero LED class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在PiGPIO中，我们需要为我们的按钮配置每个属性（引脚输入模式、上拉电阻和去抖动）作为单独的方法调用，而在之前的GPIOZero示例中，当我们创建GPIOZero
    LED类的实例时，所有这些都发生在一行上。
- en: '**Button pressed handler**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**按钮按下处理程序**'
- en: 'Our button callback handler is defined at starting on line (4) and is more
    involved than the previous GPIOZero handler:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的按钮回调处理程序在第4行开始定义，比之前的GPIOZero处理程序更复杂：
- en: '[PRE13]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice the signature of `pressed(gpio_pin, level, tick)`. Our previous GPIOZero
    version has no parameters while PiGPIO has three mandatory parameters. Our simple
    one-button example does not use these parameters; however, for completeness they
    are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`pressed(gpio_pin, level, tick)`的签名。我们之前的GPIOZero版本没有参数，而PiGPIO有三个强制参数。我们的简单单按钮示例不使用这些参数；然而，为了完整起见，它们如下：
- en: '`gpio_pin`: This is the pin responsible for invoking the callback. This will
    be 23 in our example.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpio_pin`：这是负责调用回调的引脚。在我们的示例中将是23。'
- en: '`level`: This the state of the pin. For us, this will be `pigpio.FALLING_EDGE` (we''ll
    see why shortly).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level`：这是引脚的状态。对我们来说，这将是`pigpio.FALLING_EDGE`（我们马上就会知道为什么）。'
- en: '`tick`: This is the number of microseconds since boot.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tick`：这是自启动以来的微秒数。'
- en: On line (5), we read the current state of GPIO 21 (our LED) into a variable
    with `led_state = pi.read()`. Then, starting on line (6), depending on whether
    the LED is currently on (`led_state == 1`) or off (`led_state == 0`), we set the
    GPIO 21 high or low using `pi.write()` to toggle the LED to its inverse on or
    off state.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5行，我们使用`led_state = pi.read()`将GPIO 21（我们的LED）的当前状态读入变量。然后，从第6行开始，根据LED当前是否打开（`led_state
    == 1`）或关闭（`led_state == 0`），我们使用`pi.write()`将GPIO 21设置为高电平或低电平，以切换LED到其相反的打开或关闭状态。
- en: 'Finally, the callback handler is registered on line (7). The parameter value, `pigpio.FALLING_EDGE`,
    means the call handler is `pressed()` whenever the GPIO pin, `BUTTON_GPIO_PIN`,
    (that is, 23) starts to transition from a digital high to a digital low. This
    is a lot more explicit than simply testing whether a pin is *high* or *low;* however,
    for simplicity, consider the following level parameter options to `pi.callback()`.
    Try changing the parameter and see what happens when you press the button:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回调处理程序在第7行注册。参数值`pigpio.FALLING_EDGE`意味着每当GPIO引脚`BUTTON_GPIO_PIN`（即23）开始从数字高转换为数字低时，调用处理程序为`pressed()`。这比简单地测试引脚是*高*还是*低*更明确；然而，为了简单起见，考虑以下级别参数选项`pi.callback()`。尝试更改参数，看看当您按下按钮时会发生什么：
- en: '`pigpio.FALLING_EDGE`: This is low (think *falling* toward low). `pressed()`
    is called when you *press* the button.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pigpio.FALLING_EDGE`：这是低的（想*向低处下降*）。当您*按下*按钮时，将调用`pressed()`。'
- en: '`pigpio.RAISING_EDGE`: This is high (think *raising* toward high). `pressed()` is
    called when you *release* the button.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pigpio.RAISING_EDGE`：这是高的（想*向高处升起*）。当您*释放*按钮时，将调用`pressed()`。'
- en: '`pigpio.EITHER_EDGE`: This can be high or low. `pressed()` is called when you
    both *press* and *release* the button, effectively meaning the LED will only illuminate when
    you hold down the button.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pigpio.EITHER_EDGE`：这可以是高或低。当您*按下*和*释放*按钮时，将调用`pressed()`，实际上意味着只有当您按住按钮时LED才会亮起。'
- en: Did you notice or think at any stage in the PiGPIO example that when the button
    is pressed—that is, you *activated* the button—GPIO pin 23 becomes low (that is,
    the `pigpio.FALLING_EDGE` parameter on line (7)), and this results in `pressed()`
    begin called? Did this seem a bit back-to-front or false from a programming perspective?
    We'll revisit this idea and discuss the reasons behind it in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在PiGPIO示例中，您是否注意到或认为当按下按钮时，即*激活*按钮时，GPIO引脚23变为低电平（即第7行上的`pigpio.FALLING_EDGE`参数），这导致`pressed()`被调用？从编程的角度来看，这似乎有点前后颠倒或错误？我们将在[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)中重新讨论这个想法，并讨论背后的原因，即*软件工程师的电子学101*。
- en: That's enough on GPIO libraries and electronics for now. We've seen how to respond
    to button presses with both the GPIOZero and PiGPIO libraries. In particular,
    we saw that the GPIOZero approach was rather simple and straightforward compared
    to the PiGPIO approach, which involved more code and more configuration. This
    is the same outcome we discovered in the previous section, *Exploring two ways
    to flash an LED in Python*—that is, the GPIOZero approach was simpler.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于GPIO库和电子学的内容就到此为止。我们已经看到如何使用GPIOZero和PiGPIO库响应按钮按下。特别是，我们发现与涉及更多代码和更多配置的PiGPIO方法相比，GPIOZero方法更简单直接。这与我们在上一节*探索Python中闪烁LED的两种方法*中发现的结果相同，即GPIOZero方法更简单。
- en: Is one approach better than the other? The answer to that all depends on what
    goal you are trying to achieve and how much lower-level control you require over
    your electronic interfacing to achieve that goal. At this stage of this book,
    I just wanted to give you contrasting options regarding GPIO libraries and how
    we interface them with electronics. We'll be picking this topic up again in greater
    detail when we revisit popular GPIO libraries for Python in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting
    Your Raspberry Pi to the Physical World*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法是否比另一个更好？答案取决于您试图实现的目标以及您对电子接口的低级控制需求。在本书的这个阶段，我只是想给您提供有关GPIO库及其与电子设备接口的对比选项。当我们在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中重新讨论Python的流行GPIO库时，我们将更详细地讨论这个话题，*将您的树莓派连接到物理世界*。
- en: Let's move on and create an IoT program to control our LED over the internet.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个IoT程序，以通过互联网控制我们的LED。
- en: Creating your first IoT program
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个IoT程序
- en: 'We are about to create a Python program to integrate with a service called [dweet.io](http://dweet.io/).
    This is how their website describes the service: "*it''s like Twitter for social
    machines*."'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将创建一个Python程序，与名为[dweet.io](http://dweet.io/)的服务集成。这是他们网站对该服务的描述：“*就像社交机器的Twitter*。”
- en: We will create simple *dweets,* which are the dweet.io equivalent of a *tweet,* by
    pasting a URL into a web browser.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建简单的*dweets*，它们是dweet.io版的*tweet*，通过将URL粘贴到Web浏览器中。
- en: Our program will monitor and receive our dweets by polling a dweet.io RESTful
    API endpoint for data. As data is received, it will be parsed to find an instruction
    specifying whether our LED should be turned on or off or made to blink. Based
    on this instruction, our LED state will be changed using the GPIOZero library.
    We'll have a look at data format received from dweet.io when we discuss the program's
    code in a subsequent section titled *Understanding the server code*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将通过轮询dweet.io的RESTful API端点来监视和接收我们的dweets。当接收到数据时，将对其进行解析，以查找指示是否应打开或关闭LED或使其闪烁的指令。根据此指令，将使用GPIOZero库更改LED状态。在我们讨论程序代码的下一部分*理解服务器代码*中，我们将查看从dweet.io接收的数据格式。
- en: We're using the free public [dweet.io](http://dweet.io/) service where all information
    is publicly accessible, so do not publish any sensitive data. There is a professional
    service available at [dweetpro.io](http://dweetpro.io/) that provides data privacy,
    security, dweet retention, and other advanced features.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用免费的公共[dweet.io](http://dweet.io/)服务，所有信息都是公开可访问的，因此不要发布任何敏感数据。还有一个专业服务可用于[dweetpro.io](http://dweetpro.io/)，提供数据隐私、安全性、dweet保留和其他高级功能。
- en: The code for this program is contained in the `chapter02/dweet_led.py` file.
    Read through the source code in this file to get a broad perspective about what's
    happening before continuing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的代码包含在`chapter02/dweet_led.py`文件中。在继续之前，阅读此文件中的源代码，以获得关于发生了什么的广泛视角。
- en: Running and testing the Python server
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和测试Python服务器
- en: In this section, we will run and interact with a Python server program that
    will let us control our LED from a web browser by copying and pasting links. Once
    we have used the program to control our LED, we'll then delve into the mechanics
    of the code and how it works in the next section.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将运行并与一个Python服务器程序进行交互，该程序将允许我们通过复制和粘贴链接从Web浏览器控制我们的LED。一旦我们使用程序控制了我们的LED，我们将在下一节深入探讨代码的机制以及它是如何工作的。
- en: 'Here are the steps to follow:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要遵循的步骤：
- en: 'Run the `chapter02/dweet_led.py` program. You should see output similar to
    the following:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`chapter02/dweet_led.py`程序。您应该会看到类似以下的输出：
- en: '[PRE14]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On line (1), the program has created a unique name for our *thing* to use with
    dweet.io. You'll notice this name in the URLs starting on line (2). The name created
    for your *thing* will be different from the preceding example.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（1）行，程序已为我们的*thing*创建了一个唯一的名称，用于与dweet.io一起使用。您将在第（2）行开始的URL中注意到此名称。为您的*thing*创建的名称将与前面的示例不同。
- en: A *thing* name in dweet.io is analogous to an @handle on Twitter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: dweet.io中的*thing*名称类似于Twitter上的@handle。
- en: Copy and paste the URLs at starting on line (2) into a web browser (it could
    be a computer other than your Raspberry Pi). After a short delay, the LED should
    change its state (on, off, or blinking) depending on the URL used.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL复制并粘贴到Web浏览器中（可以是树莓派以外的计算机）。经过短暂延迟后，LED应根据使用的URL更改其状态（打开、关闭或闪烁）。
- en: Once you have confirmed that the LED is controllable using the URLs, we will
    proceed and look at the program.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确认LED可以使用URL进行控制，我们将继续查看程序。
- en: Understanding the server code
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解服务器代码
- en: In this section, we will step through the major parts of the `dweet_led.py`
    program and discover how it works, starting with the imports.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步介绍`dweet_led.py`程序的主要部分，并了解它的工作原理，从导入开始。
- en: '**Imports**'
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入**'
- en: 'First, at the start of the source code file, we see the Python imports:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在源代码文件的开头，我们看到Python的导入：
- en: '[PRE15]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is one specific import I want to draw your attention to. On line (1),
    we are importing the `request` module (this was installed earlier in this chapter
    when you ran `pip install -r requirements.txt`). `requests` is a high-level library
    for making HTTP requests in Python. Our program uses this module to communicate
    with the dweet.io APIs, which we'll see shortly.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要引起您注意的一个特定的导入是在第1行，我们导入了`request`模块（这是在本章早些时候运行`pip install -r requirements.txt`时安装的）。`requests`是一个用于在Python中进行HTTP请求的高级库。我们的程序使用这个模块与dweet.io
    API进行通信，我们很快就会看到。
- en: Now that we understand that we are importing and will later use the `requests`
    library, let's cover the global variables used in our program.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们正在导入并且稍后将使用`requests`库，让我们来了解一下我们程序中使用的全局变量。
- en: '**Variable definitions**'
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**变量定义**'
- en: 'Next, we define several global variables. For now, review the following comments
    for their purposes. You''ll see them being used as we progress through the code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了几个全局变量。现在，请查看下面的注释以了解它们的用途。随着我们在代码中的进展，您将看到它们被使用：
- en: '[PRE16]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you read through the master source file, following these variable definitions,
    you''ll also notice that we are using the Python logging system instead of `print()`
    statements:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读主源文件时，除了这些变量定义，您还会注意到我们使用Python日志系统而不是`print()`语句：
- en: '[PRE17]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you need to turn on debugging for the program to diagnose a problem or to
    see the raw JSON data exchanged between our program and the dweet.io service,
    change line (2) to `logger.setLevel(logging.DEBUG)`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为程序打开调试以诊断问题或查看我们的程序与dweet.io服务之间交换的原始JSON数据，将第2行更改为`logger.setLevel(logging.DEBUG)`。
- en: Next, we will step through the significant methods in the program and see what
    they do.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐步介绍程序中的重要方法，并了解它们的作用。
- en: '**The resolve_thing_name() method**'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**resolve_thing_name()方法**'
- en: The `resolve_thing_name()` method is responsible for loading or creating a unique
    name for our *thing* for use with dweet.io.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve_thing_name()`方法负责加载或创建用于dweet.io的*thing*的唯一名称。'
- en: 'Our intention when using this method is to always reuse a name so that our
    dweet URLs for controlling our LED remain the same between the program restarts:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种方法的意图是始终重复使用一个名称，以便我们的dweet LED的URL在程序重新启动之间保持不变：
- en: '[PRE18]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On line (3), we load a name stored previously in `thing_file` if the file exists;
    otherwise, we use the Python `UUID` module method `uuid1()` on line (4) to create
    an 8-character unique identifier and use that as the thing name. We store this
    newly created identifier-cum-name in `thing_file` on line (5).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，如果文件存在，我们加载之前存储在`thing_file`中的名称；否则，我们在第4行使用Python的`UUID`模块方法`uuid1()`创建一个8个字符的唯一标识符，并将其用作物体名称。我们在第5行将这个新创建的标识符兼名称存储在`thing_file`中。
- en: Next, we will look at the function that retrieves the last dweet made to our
    *thing.*
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下检索发送到我们*thing*的最后一个dweet的函数。
- en: '**The get_lastest_dweet() method**'
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**get_lastest_dweet()方法**'
- en: '`get_lastest_dweet()` queries the dweet.io service to retrieve the latest dweet
    (if any) made for our *thing.* Following is an example of the JSON response we
    expect to receive. It is the `content.state` property on line (1) that we are
    ultimately interested in:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_lastest_dweet()`查询dweet.io服务以检索我们*thing*的最新dweet（如果有）。以下是我们期望收到的JSON响应的示例。最终我们感兴趣的是第1行的`content.state`属性：'
- en: '[PRE19]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Looking at the following code, we see, on line (6), the creation of the resource
    URL used to query the dweet.io service. A call to this URL will return us a JSON
    similar to that shown in the preceding. You will find a link in the *Further reading*
    section to the complete dweet.io API reference.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的代码，我们在第6行看到了用于查询dweet.io服务的资源URL的创建。对这个URL的调用将返回一个类似于前面所示的JSON。您将在*进一步阅读*部分找到一个链接，链接到完整的dweet.io
    API参考。
- en: 'Next, on line (7), the `requests` module use used to make an HTTP GET request
    to retrieve the latest dweet:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第7行，`requests`模块用于发出HTTP GET请求以检索最新的dweet：
- en: '[PRE20]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Starting on line (8) in the following, we check whether the request succeeded
    at the HTTP protocol level. If successful on line (9), we then proceed to parse
    the JSON response and extract and return the `content` property starting on line
    (10):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下第8行开始，我们检查请求是否在HTTP协议级别成功。如果成功，我们将在第9行继续解析JSON响应并提取并返回从第10行开始的`content`属性：
- en: '[PRE21]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our next method to cover is `poll_dweets_forever()`, which will use `get_lastest_dweet()`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要讨论的下一个方法是`poll_dweets_forever()`，它将使用`get_lastest_dweet()`。
- en: '**The poll_dweets_forever() method**'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**poll_dweets_forever()方法**'
- en: '`poll_dweets_forever()` is a long-running function that periodically calls
    on line (11) the `get_lastest_dweet()` method we just covered. When a dweet is
    available, it is handled on line (12) by `process_dweet()`, which we will discuss
    shortly:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll_dweets_forever()`是一个长时间运行的函数，它周期性地调用第11行的`get_lastest_dweet()`方法，我们刚刚讨论过。当有dweet可用时，它将在第12行由`process_dweet()`处理，我们将很快讨论：'
- en: '[PRE22]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We sleep for a default delay of 2 seconds on line (13) before continuing the
    loop. Practically, this means there will be up to an approximate 2-second delay
    between using one of the dweeting URLs to request a LED state change and the LED
    altering its state.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第13行休眠默认延迟2秒，然后继续循环。实际上，这意味着在使用dweeting URL之一请求LED状态更改和LED改变其状态之间可能会有长达约2秒的延迟。
- en: At this point in the master source file, you will come across a function named
    `stream_dweets_forever()`.  This is an alternative and more efficient stream-based
    method of accessing dweets in real time using HTTP streaming.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在主源文件的这一点上，你会遇到一个名为`stream_dweets_forever()`的函数。这是一种替代的、更高效的基于流的方法，使用HTTP流来实时访问dweets。
- en: The polling-based approach of `poll_dweets_forever()` was chosen here for discussion
    for simplicity. It will become clear as you read on where you can switch approaches.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择了`poll_dweets_forever()`的基于轮询的方法进行讨论，这样做是为了简单起见。当你继续阅读时，你会清楚地知道在哪里可以切换方法。
- en: Our next stop is the method we use to control the LED.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的是我们用来控制LED的方法。
- en: '**The process_dweet() method**'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**process_dweet()方法**'
- en: 'As we saw previously when `poll_dweets_forever()` (similar to `stream_dweets_forever()`)
    gets a dweet, it parses out the `content` property from the dweet''s JSON. This
    is then passed to `process_dweet()` for handling, where we extract the `state`
    child property from the `content` property:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，当`poll_dweets_forever()`（类似于`stream_dweets_forever()`）获取一个dweet时，它会从dweet的JSON中解析出`content`属性。然后将其传递给`process_dweet()`进行处理，我们从`content`属性中提取`state`子属性：
- en: '[PRE23]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On line (15) (and (17) in the subsequent code block), we test for and maintain
    the LED's last known state and avoid interacting with the LED if it's already
    in the requested state. This will avoid potential visual glitching of the LED
    that can occur if it's repeatedly put into a blinking state when already blinking.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15行（和后续代码块的第17行），我们测试并保持LED的上一个已知状态，并且如果它已经处于请求的状态，则避免与LED进行交互。这将避免LED在已经闪烁时重复进入闪烁状态时可能出现的潜在视觉故障。
- en: 'The core of `process_dweet()` is to access the `state` property of the dweet
    and change the LED''s state, which starts on line (16):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_dweet()`的核心是访问dweet的`state`属性并改变LED的状态，这从第16行开始：'
- en: '[PRE24]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Following line (16), we set the LED state based on the dweet (remember the `led` variable is
    a GPIOZero LED instance) before keeping track of the new state on line (17), as
    mentioned, for subsequent testing when `process_dweet()` is called on line (15).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16行之后，我们根据dweet设置LED状态（记住`led`变量是一个GPIOZero LED实例），然后在第17行跟踪新状态，如前所述，当在第15行调用`process_dweet()`进行后续测试时。
- en: Thanks to the simplicity of GPIOZero, our LED controlling code only makes a
    fleeting appearance in the code!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GPIOZero的简单性，我们的LED控制代码在代码中只是一闪而过！
- en: We will conclude by covering the program's main entry point.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论程序的主入口来结束。
- en: '**The main program entry point**'
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**主程序入口点**'
- en: 'At the end of the source file, we have the following code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件的末尾，我们有以下代码：
- en: '[PRE25]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On line (8), `print_instructions()`  is responsible for printing the sweet URLs
    to the Terminal, while on line (19), we see a call to `get_latest_dweet()`. This
    call initializes our LED to the last dweeted state when the program starts. Finally,
    on line (20), we start polling the dweet.io service to access the latest dweets.
    It's here you swap the dweet polling method to the streaming method.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8行，`print_instructions()`负责将sweet URL打印到终端上，而在第19行，我们看到了对`get_latest_dweet()`的调用。这个调用在程序启动时将我们的LED初始化为最后一个dweet的状态。最后，在第20行，我们开始轮询dweet.io服务以访问最新的dweets。在这里，你可以将dweet轮询方法切换到流式方法。
- en: This now completes our walk-through of `dweet_led.py`. Through this discussion,
    we have now seen how to leverage the dweet.io service to create a simple and functional
    IoT program. Before we complete this chapter, I want to leave you with two bonus
    source code files that you can use to extend your IoT program.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们完成了对`dweet_led.py`的演示。通过这次讨论，我们已经看到了如何利用dweet.io服务来创建一个简单而实用的物联网程序。在完成本章之前，我想给你留下两个额外的源代码文件，你可以用它们来扩展你的物联网程序。
- en: Extending your IoT program
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展你的物联网程序
- en: 'The following two files in the `chapter02` folder complement what we have covered
    in this chapter by combining the concepts we have learned. As the overall code
    and approach are similar to what we have already covered, we will not go through
    the code in detail:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`chapter02`文件夹中的以下两个文件补充了我们在本章中所涵盖的内容，结合了我们所学到的概念。由于整体代码和方法与我们已经涵盖的内容相似，我们不会详细讨论代码：'
- en: '`dweet_button.py` provides an implementation showing how to use a push button
    to create a dweet with the dweet.io service. This will let you change your LED
    state with the press of a button.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dweet_button.py`提供了一个实现，展示了如何使用按钮创建一个dweet，并通过dweet.io服务来改变LED的状态。'
- en: '`pigpio_led_class.py` provides a code-level example of how a low-level library
    like PiGPIO relates to a high-level library like GPIOZero.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pigpio_led_class.py`提供了一个代码级别的例子，展示了低级库PiGPIO和高级库GPIOZero之间的关系。'
- en: We'll start by discussing `dweet_button.py`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`dweet_button.py`开始讨论。
- en: Implementing a dweeting button
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个dweeting按钮
- en: This program in `dweet_button.py` integrates the GPIOZero push button example
    with dweet.io. Earlier in this chapter, in the section titled *Running and testing
    the Python server*, we copied and pasted URLs into a web browser to control our
    LED.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`dweet_button.py`中的这个程序将GPIOZero的按钮示例与dweet.io集成。在本章的前面部分，标题为*运行和测试Python服务器*的部分中，我们将URL复制并粘贴到Web浏览器中来控制我们的LED。'
- en: 'When you run `dweet_button.py`, each time you press the button, this program
    cycles through the dweet.io URLs to change the LED''s state. To configure this
    program, find and update the following line with the thing name you are using
    with `dweet_led.py`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`dweet_button.py`时，每次按下按钮，这个程序都会循环遍历dweet.io的URL来改变LED的状态。要配置这个程序，找到并更新以下行，使用你在`dweet_led.py`中使用的`thing
    name`：
- en: '[PRE26]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember, that you'll also need the `dweet_led.py` program to be running in
    a Terminal, otherwise, the LED will not respond to your button presses.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你还需要在终端中运行`dweet_led.py`程序，否则LED将不会对你的按钮按下做出响应。
- en: Next, we see how to mimic GPIOZero using PiGPIO and a Python class.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用PiGPIO和Python类来模拟GPIOZero。
- en: PiGPIO LED as a class
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PiGPIO LED作为一个类
- en: 'In the `pigpio_led_class.py` file, we have a Python class that is a re-engineering
    of the PiGPIO LED example to wrap it as a class that mimics the GPIOZero `LED`
    class. It demonstrates the basic principle of how GPIOZero abstracts away lower-level
    GPIO complexity. This re-engineered class can be used as a drop-in replacement
    for the GPIOZero `LED` examples in this chapter, as shown here. See the header
    comments in `pigpio_led_class.py` for more information:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pigpio_led_class.py`文件中，我们有一个Python类，它是对PiGPIO LED示例的重新设计，将其包装为一个模仿GPIOZero
    `LED`类的类。它演示了GPIOZero如何将低级GPIO复杂性抽象化的基本原理。这个重新设计的类可以作为本章中GPIOZero `LED`示例的一个替代，如此所示。有关更多信息，请参阅`pigpio_led_class.py`中的头部注释。
- en: '[PRE27]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I hope you find these two bonus files interesting, and that by exploring the
    PiGPIO LED as a class example, you can better appreciate how the higher-level
    GPIOZero library and lower-level PiGPIO library relate to one another.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您会对这两个额外的文件感兴趣，并且通过探索PiGPIO LED作为一个类的示例，您可以更好地理解高级GPIOZero库和低级PiGPIO库之间的关系。
- en: At this stage of your journey, if you are a little unclear about what's happening
    with `pigpio_led_class.py`, do not get worried. I wanted to simply set out a brief example
    of GPIO library interactions for you to ponder in the context of an end-to-end
    application, as this will serve as a point of reference as you continue reading. We'll
    be covering the GPIOPZero and PiGPIO libraries (plus others) in greater detail
    in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry
    Pi to the Physical World*, plus we'll be covering more advanced concepts such
    as threading in electronic interfacing programs (similar to the use of threads
    in `pigpio_led_class.py`) in [Chapter 12](b2a583d8-ea6d-4e0e-9018-26997fbdda4e.xhtml),
    *Advanced IoT Programming Concepts – Threads, AsyncIO, and Event Loops*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的学习过程中，如果您对`pigpio_led_class.py`发生的情况有些不清楚，不要担心。我只是想简单地为您提供一个GPIO库交互的简要示例，供您在继续阅读时作为参考。我们将在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中更详细地介绍GPIOPZero和PiGPIO库（以及其他库），另外我们还将在[第12章](b2a583d8-ea6d-4e0e-9018-26997fbdda4e.xhtml)中涵盖更高级的概念，比如电子接口程序中的线程（类似于`pigpio_led_class.py`中的线程）。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Through this chapter, you've just created a real functional IoT application
    using a Raspberry Pi and Python. We saw two alternative ways to flash a LED and
    read a button press in Python using both the GPIOZero and PiGPIO GPIO libraries.
    We also compared the use of these libraries and saw that GPIOZero takes a higher-level
    and more abstract approach to coding and GPIO control than does the lower-level
    PiGPIO library. We also connected the LED to the internet using the online dweet.io
    service. Using simple URLs, we were able to turn on and off and blink the LED
    by simply visiting the URLs in a web browser.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，您刚刚使用树莓派和Python创建了一个真正的功能性物联网应用程序。我们看到了使用GPIOZero和PiGPIO GPIO库在Python中闪烁LED和读取按钮按下的两种替代方法。我们还比较了这些库的使用，并发现GPIOZero比低级PiGPIO库更高级和更抽象地处理编码和GPIO控制。我们还使用在线的dweet.io服务将LED连接到了互联网。通过简单的URL，我们能够通过简单地访问网页浏览器中的URL来打开、关闭和闪烁LED。
- en: As you proceed through the subsequent chapters in this book, we'll be building
    on and going deeper into the core knowledge you have learned in this chapter about
    GPIO interfacing, electronic circuits, and controlling a circuit over the internet.
    We will learn alternative approaches to building an application to those we have
    covered in this chapter and discover the core principles related to GPIO control
    and electronic interfacing. Equipped with this deepening knowledge, you'll be
    able to create even more powerful and grand IoT solutions by the time you complete
    this book!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在本书的后续章节中继续学习时，我们将在本章学到的关于GPIO接口、电子电路和通过互联网控制电路的核心知识的基础上进行更深入的建设。我们将学习构建应用程序的替代方法，以及发现与GPIO控制和电子接口相关的核心原则。掌握了这些深入的知识，您将能够在完成本书时创建更强大、更宏伟的物联网解决方案！
- en: In [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking with
    RESTful APIs and Web Sockets Using Flask*, we will be looking at the popular Flask
    microservices framework, and we will create two Python-based web servers and accompanying
    web pages to control the LED over a local network or the internet.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)中，*使用Flask进行RESTful API和Web套接字网络*，我们将研究流行的Flask微服务框架，并创建两个基于Python的Web服务器和相应的网页，以控制LED在本地网络或互联网上的状态。
- en: Questions
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here is a list of questions for you to test your knowledge regarding this chapter''s
    material. You will find the answers in the *Assessments* section of the book:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些问题列表，供您测试对本章材料的了解。您将在本书的*评估*部分找到答案：
- en: You don't have the correct resistor value. Can you just substitute another value
    resistor that you have lying around?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你没有正确的电阻值。你能否用周围的另一个电阻值替代？
- en: The GPIOZero package is a compete GPIO library. Is it all you'll ever need?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPIOZero包是一个完整的GPIO库。这就是你所需要的全部吗？
- en: Should you always use the built-in Python packages for networking wherever possible?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可能的情况下，您应该始终使用内置的Python网络包吗？
- en: 'True or false: an LED is unbiased, meaning it can be plugged into a circuit
    any way around and still work.'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：LED是无偏的，意味着它可以以任何方式插入电路并仍然工作。
- en: You are building an IoT application that interacts with other existing networked
    devices and it times out. What could be the problem?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在构建一个与其他现有网络设备交互的物联网应用程序，但它超时了。可能出了什么问题？
- en: What Python module and function can be used to stop a program exiting?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Python模块和函数可以用来阻止程序退出？
- en: Further reading
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'We connected our LED to the internet using the dweet.io service and called
    its RESTful APIs, which are documented at the following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用dweet.io服务将LED连接到互联网，并调用其RESTful API，这些API在以下文档中有所记录：
- en: Dweet.io API documentation:  [https://dweet.io](https://dweet.io)
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dweet.io API文档：[https://dweet.io](https://dweet.io)
- en: 'You may wish to familiarize yourself with the GPIOZero library briefly to get
    an idea about what it can do. It''s well documented with heaps of examples. Here
    are a couple of useful links to relevant parts of the API documentation that we''ve
    covered so far:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望简要了解一下GPIOZero库，以了解它的功能。它有大量的示例和详细的文档。以下是我们目前涵盖的API文档的一些有用链接：
- en: GPIOZero home page: [https://gpiozero.readthedocs.io](https://gpiozero.readthedocs.io/en/stable/api_output.html)
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPIOZero首页：[https://gpiozero.readthedocs.io](https://gpiozero.readthedocs.io/en/stable/api_output.html)
- en: Output Devices (LED): [https://gpiozero.readthedocs.io/en/stable/api_output.html](https://gpiozero.readthedocs.io/en/stable/api_output.html)
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出设备（LED）：[https://gpiozero.readthedocs.io/en/stable/api_output.html](https://gpiozero.readthedocs.io/en/stable/api_output.html)
- en: Input Devices (Button): [https://gpiozero.readthedocs.io/en/stable/api_input.html](https://gpiozero.readthedocs.io/en/stable/api_input.html)
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入设备（按钮）：[https://gpiozero.readthedocs.io/en/stable/api_input.html](https://gpiozero.readthedocs.io/en/stable/api_input.html)
- en: Regarding PiGPIO, here are the relevant parts of its API documentation. You'll
    notice that PiGPIO is a more advanced GPIO library with less verbose documentation.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 关于PiGPIO，这里是其API文档的相关部分。您会注意到PiGPIO是一个更高级的GPIO库，文档不太冗长。
- en: The PiGPIO Python home page: [http://abyz.me.uk/rpi/pigpio/python.html](http://abyz.me.uk/rpi/pigpio/python.html)
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PiGPIO Python首页：[http://abyz.me.uk/rpi/pigpio/python.html](http://abyz.me.uk/rpi/pigpio/python.html)
- en: The `read()` method: [http://abyz.me.uk/rpi/pigpio/python.html#read](http://abyz.me.uk/rpi/pigpio/python.html#read)
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read()`方法：[http://abyz.me.uk/rpi/pigpio/python.html#read](http://abyz.me.uk/rpi/pigpio/python.html#read)'
- en: The `write()` method: [http://abyz.me.uk/rpi/pigpio/python.html#write](http://abyz.me.uk/rpi/pigpio/python.html#write)
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write()`方法：[http://abyz.me.uk/rpi/pigpio/python.html#write](http://abyz.me.uk/rpi/pigpio/python.html#write)'
- en: The `callback()` method: [http://abyz.me.uk/rpi/pigpio/python.html#callback](http://abyz.me.uk/rpi/pigpio/python.html#callback)
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback()`方法：[http://abyz.me.uk/rpi/pigpio/python.html#callback](http://abyz.me.uk/rpi/pigpio/python.html#callback)'
- en: '`set_glitch_filter()`: [https://abyz.me.uk/rpi/pigpio/python.html#set_glitch_filter](https://abyz.me.uk/rpi/pigpio/python.html#set_glitch_filter)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_glitch_filter()`：[https://abyz.me.uk/rpi/pigpio/python.html#set_glitch_filter](https://abyz.me.uk/rpi/pigpio/python.html#set_glitch_filter)'
- en: 'Resistors are a very common electronic component. The following resources provide
    an overview of resistors and how to read their color bands to determine their
    resistance value in Ohms:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻器是一种非常常见的电子元件。以下资源提供了电阻器的概述，以及如何阅读它们的色带以确定它们的电阻值（欧姆）：
- en: 'Resistor overview: [https://www.electronics-tutorials.ws/resistor/res_1.html ](https://www.electronics-tutorials.ws/resistor/res_1.html)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电阻器概述：[https://www.electronics-tutorials.ws/resistor/res_1.html](https://www.electronics-tutorials.ws/resistor/res_1.html)
- en: 'Reading color bands: [https://www.electronics-tutorials.ws/resistor/res_2.html](https://www.electronics-tutorials.ws/resistor/res_2.html)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读色带：[https://www.electronics-tutorials.ws/resistor/res_2.html](https://www.electronics-tutorials.ws/resistor/res_2.html)
- en: 'The following Spark Fun tutorial provides an excellent introduction to reading
    schematic diagrams:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Spark Fun教程提供了一个很好的引言来阅读原理图：
- en: '*How to Read a Schematic Diagram*: [https://learn.sparkfun.com/tutorials/how-to-read-a-schematic/all](https://learn.sparkfun.com/tutorials/how-to-read-a-schematic/all)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何阅读原理图*：[https://learn.sparkfun.com/tutorials/how-to-read-a-schematic/all](https://learn.sparkfun.com/tutorials/how-to-read-a-schematic/all)'
