- en: Populus Development Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Populus开发框架
- en: In this chapter, you're going to learn how to use Populus, which is a smart
    contract development framework. Populus, like Truffle, is a tool designed to make
    it easier for you to develop a smart contract. If we cast our minds back to [Chapter
    3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing Smart Contracts
    Using Vyper*, you may recall that we had to manually create a `.json` file and
    then copy the `abi` output in the console to the `.json` file. With Populus, you
    can avoid repeating manual jobs that you've executed previously.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Populus，这是一个智能合约开发框架。Populus与Truffle一样，是一个旨在使您更容易开发智能合约的工具。如果我们回顾一下[第3章](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml)，*使用Vyper实现智能合约*，您可能还记得我们必须手动创建一个`.json`文件，然后将控制台中的`abi`输出复制到`.json`文件中。使用Populus，您可以避免重复执行先前执行过的手动工作。
- en: 'This chapter will explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨以下主题：
- en: Setting up Populus
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Populus
- en: Smart contract unit test
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能合约单元测试
- en: Deploying a smart contract with Populus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Populus部署智能合约
- en: Setting up Populus
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Populus
- en: Populus is a smart contract development framework, just like Truffle. So why
    should we use Populus instead of Truffle? Basically, this is a personal choice.
    Populus is written with Python and supports unit testing with Python by default.
    If you use Truffle, you use unit testing with JavaScript by default. This is like
    choosing `web3.py` (Python) or `web3.js` (JavaScript) to build a decentralized
    application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Populus是一个智能合约开发框架，就像Truffle一样。那么为什么我们应该使用Populus而不是Truffle呢？基本上，这是个人选择。Populus是用Python编写的，并默认支持Python进行单元测试。如果您使用Truffle，则默认使用JavaScript进行单元测试。这就像选择`web3.py`（Python）或`web3.js`（JavaScript）来构建去中心化应用程序。
- en: 'To set up Populus, let''s observe the following steps:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Populus，请遵循以下步骤：
- en: 'Create a virtual environment from scratch:'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从头开始创建一个虚拟环境：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We install `web3`, `populus`, and `vyper`:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们安装`web3`，`populus`和`vyper`：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The reason why we have to install the specific version of `web3` is because
    the latest version of `web3` (4.8.2) breaks Populus.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须安装特定版本的`web3`的原因是因为最新版本的`web3`（4.8.2）会破坏Populus。
- en: 'Install the Solidity compiler:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Solidity编译器：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a symbolic link:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个符号链接：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a project directory:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个项目目录：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Initialize this project directory with `populus`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`populus`初始化此项目目录：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command is like `truffle init`. After learning `populus`, you may not even
    need this command any more. This command will put two directories in your project
    directory—`contracts` and `tests`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令就像`truffle init`。学习了`populus`之后，您可能甚至不再需要这个命令。这个命令将在您的项目目录中放置两个目录—`contracts`和`tests`。
- en: 'Inside `contracts`, there is a sample Solidity file: `Greeter.sol`. Inside
    the `tests` directory, there is a sample test file: `test_greeter.py`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`contracts`中，有一个示例Solidity文件：`Greeter.sol`。在`tests`目录中，有一个示例测试文件：`test_greeter.py`。
- en: 'Open `Greeter.sol`, a simple smart contract, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Greeter.sol`，一个简单的智能合约，如下所示：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before you can compile the smart contract, you have to create a project configuration
    called `project.json`. You must enter the project directory first:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以编译智能合约之前，您必须创建一个名为`project.json`的项目配置。您必须首先进入项目目录：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`populus-venv` is where you create a virtual environment. If you take a look
    at it, it''s a significant file, containing 255 lines. You can compile it by using
    the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`populus-venv`是您创建虚拟环境的地方。如果您看一下，它是一个重要的文件，包含255行。您可以使用以下命令编译它：'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The result of the compilation is `build/contracts.json`. You can find `abi`
    and `bytecode` in that `.json` file. There's additional information that you can
    find in that `.json` file, apart from `abi` and `bytecode`, such as the compiler
    version.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编译的结果是`build/contracts.json`。您可以在该`.json`文件中找到`abi`和`bytecode`。除了`abi`和`bytecode`之外，该`.json`文件中还有其他信息，例如编译器版本。
- en: You'll already be familiar with the workflow of smart contract development.
    Compile `Solidity/Vyper` files so we can get `abi` and `bytecode`. Then, use `abi`
    and `bytecode` with the `web3` library.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了智能合约开发的工作流程。编译`Solidity/Vyper`文件，以便我们可以获得`abi`和`bytecode`。然后，使用`web3`库的`abi`和`bytecode`。
- en: 'Now, you''ll encounter something new. There is another directory that you haven''t
    seen yet: the `tests` directory. Inside that directory, there is a test file called
    `test_greeter.py`, whichis a unit test. Take a look at it here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将遇到一些新的东西。有另一个目录是您还没有见过的：`tests`目录。在该目录中，有一个名为`test_greeter.py`的测试文件，这是一个单元测试。在这里看一下：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can execute this test file as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式执行此测试文件：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will give you the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给您以下输出：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Your test will now pass. We'll discuss smart contract unit testing in more depth later
    in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试现在将通过。我们将在本章后面更深入地讨论智能合约单元测试。
- en: Adding support for Vyper
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对Vyper的支持
- en: 'As you know, we aren''t focusing on Solidity in this book, but Vyper. We need
    to add support for Vyper. First, because this is a new virtual environment, install
    `vyper`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，我们在本书中并不专注于Solidity，而是Vyper。我们需要为Vyper添加支持。首先，因为这是一个新的虚拟环境，所以安装`vyper`：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, in the project directory, create a `.vy` file called `Greeter.vy` in
    the `contracts` directory:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在项目目录中，在`contracts`目录中创建一个名为`Greeter.vy`的`.vy`文件：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Before you can compile this Vyper code, you need to change something in the `project.json`
    file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以编译这个Vyper代码之前，您需要在`project.json`文件中更改一些内容。
- en: 'Go to  `compilation` key. The value of the key is an object with these keys:
    `backend`, `backends`, `contract_source_dirs`, and`import_remappings`. Delete
    the `backends` key and then change the `backend` key to the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`compilation`键。该键的值是一个具有这些键的对象：`backend`，`backends`，`contract_source_dirs`和`import_remappings`。删除`backends`键，然后将`backend`键更改为以下代码：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Hence, the content of the `compilation` key appears as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`compilation`键的内容如下：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, run the compilation as usual:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像往常一样运行编译：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To make sure it is indeed a Vyper compilation and not a Solidity compilation,
    you could open `build/contracts.json`. Inside, you will be able to see the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这确实是一个Vyper编译，而不是Solidity编译，你可以打开`build/contracts.json`。在里面，你将能够看到以下内容：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The latest version of Vyper is 0.1.0b6 and it breaks Populus. The developer
    needs some time to fix this. If the bug hasn't yet been fixed while you're reading
    this book, you could patch Populus yourself.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper的最新版本是0.1.0b6，它破坏了Populus。开发者需要一些时间来修复这个问题。如果在你阅读本书时这个bug还没有被修复，你可以自己修补Populus。
- en: 'First, check whether the bug is fixed or not using the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令检查bug是否已经修复：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our case here, the bug has not been fixed. So, let''s patch Populus to fix
    the bug. Make sure you''re still in the same directory (`populus-venv/src/populus`):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这个bug还没有被修复。所以，让我们修补Populus来解决这个bug。确保你仍然在同一个目录下（`populus-venv/src/populus`）：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our Populus development framework now has Vyper support.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Populus开发框架现在支持Vyper。
- en: Smart contract unit test
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能合约单元测试
- en: If you run unit testing, you will receive an error due to the incorrect data
    type. The solution here would be to change all string data types to a bytes data
    type. Then, owing to a deprecation warning, you should change the way you call
    methods in a smart contract.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行单元测试，你将收到一个错误，因为数据类型不正确。解决方法是将所有字符串数据类型更改为`bytes`数据类型。然后，由于弃用警告，你应该改变调用智能合约方法的方式。
- en: 'Ultimately, your unit test, which is located in `tests/test_greeter.py`, should
    look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你的单元测试，位于`tests/test_greeter.py`，应该是这样的：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then, if you were to run your unit test again, it would be successful.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你再次运行你的单元测试，它将会成功。
- en: 'Let''s take a look at the first method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下第一个方法：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Your unit test function should accept the `chain` argument most of the time.
    From the `chain` object, you could get a provider. If you remember, a provider
    is an object that connects to an Ethereum blockchain, be it through HTTP or IPC.
    From there, you could get the contract object. Whether the test framework gets
    the contract object directly from the blockchain or whether it deploys the contract
    first before fetching the contract depends on the situation. In our case, it is
    the latter option. The test framework creates a contract object in memory and
    interacts with it. After unit testing, everything vanishes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你的单元测试函数大部分时间应该接受`chain`参数。从`chain`对象中，你可以获取一个提供者。如果你记得的话，提供者是一个连接到以太坊区块链的对象，无论是通过HTTP还是IPC。从那里，你可以获取合约对象。测试框架是直接从区块链获取合约对象，还是在获取合约之前先部署合约，这取决于情况。在我们的情况下，是后者选项。测试框架在内存中创建一个合约对象并与之交互。单元测试结束后，一切都消失了。
- en: Later, you would fetch the contract object from a permanent blockchain. `get_or_deploy_contract`
    from the `provider` object returns two objects. You only need to concern yourself
    with the first one, the contract object, most of the time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将从永久区块链中获取合约对象。`provider`对象的`get_or_deploy_contract`返回两个对象。你通常只需要关注第一个对象，即合约对象。
- en: From the `contract` object, executing the methods on the smart contract should
    be familiar to you. To execute the `public` method or to get the value of public
    variables, you would use `functions`, followed by the method or the public variables
    added with `()` and ending with `call()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从`contract`对象开始，执行智能合约的方法对你来说应该很熟悉。要执行`public`方法或获取公共变量的值，你将使用`functions`，接着是方法或公共变量加上`()`，最后以`call()`结束。
- en: After executing the public method, you would get the return value. In this case,
    you get as a `byte` object, unlike `string` in the Solidity example. In Vyper,
    there is no first class string support. String is stored as `byte` object. Vyper
    is still in active development mode, but expect this to change in the future.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 执行公共方法后，你将得到返回值。在这种情况下，你会得到一个`byte`对象，不像Solidity示例中的`string`。在Vyper中，没有一流的字符串支持。字符串被存储为`byte`对象。Vyper仍处于活跃的开发模式中，但预计将来会发生变化。
- en: 'On the second unit test, you would test a method in the smart contract to change
    the state of a variable:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个单元测试中，你将测试智能合约中改变变量状态的方法：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Everything is the same as the first unit test, except that here are two new lines
    in the middle:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都和第一个单元测试一样，只是这里有两行新的内容：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the way to use a transaction. Remember, a transaction is anything that
    involves changing the state of the contract. You call `functions`, followed by
    the method that's going to change the state of the contract augmented by `()`,
    ending with `transact()` with the necessary parameters. After that, using the
    `chain` object, you wait for the transaction to finish. During testing, this has
    been very fast. But if you test this on another Ethereum blockchain, say, in the
    Rinkeby network, the transaction could last a couple of minutes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用交易的方式。记住，交易是任何涉及改变合约状态的事情。你调用`functions`，接着是将改变合约状态的方法加上`()`，最后以`transact()`和必要的参数结束。之后，使用`chain`对象，你等待交易完成。在测试期间，这非常快。但如果你在另一个以太坊区块链上测试，比如在Rinkeby网络上，交易可能会持续几分钟。
- en: Let's move to a more complicated example. Remember our donation smart contract
    that you wrote in [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing
    Smart Contracts Using Vyper*. Why don't we test that smart contract?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更复杂的例子。还记得你在[第3章](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml)中编写的捐赠智能合约吗，*使用Vyper实现智能合约*。为什么我们不测试一下那个智能合约呢？
- en: 'Let''s save the donation smart contract in the source code folder that you
    developed in [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing
    Smart Contracts Using Vyper*. You can save the code in `contracts/donation.vy`.
    If you''ve forgotten this, you can refer to the code file on the following GitLab
    link for the full code, [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/contracts/Donation.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/contracts/Donation.vy):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将捐赠智能合约保存在您在[第3章](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml)中开发的源代码文件夹中，*使用Vyper实现智能合约*。您可以将代码保存在`contracts/donation.vy`中。如果您忘记了这一点，可以参考以下GitLab链接上的代码文件获取完整的代码，[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/contracts/Donation.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/contracts/Donation.vy)：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We want to test a number of different things here.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在这里测试许多不同的事情。
- en: 'To begin with, let''s take a look at the constructor method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下构造方法：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We want to test whether the `donatee` variable will contain the address of the
    account that launches the smart contract or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想测试`donatee`变量是否包含启动智能合约的账户地址。
- en: 'Let''s write our first unit test. You can save this unit test in `tests/test_donation.py`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的第一个单元测试。您可以将此单元测试保存在`tests/test_donation.py`中：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this unit test, we're using the two arguments version because we want to
    get the `web3` object. It does not actually matter if you switch the order of
    the parameters. `def test_donatee(web3, chain):` is the same as `def test_donatee(chain,
    web3):`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单元测试中，我们使用了两个参数版本，因为我们想获取`web3`对象。如果您交换参数的顺序，实际上并不重要。`def test_donatee(web3,
    chain):`与`def test_donatee(chain, web3):`是一样的。
- en: The argument in `get_or_deploy_contract` is taken from the name of your `.vy`
    file. So be careful naming your source code filename.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_or_deploy_contract`中的参数取自您的`.vy`文件的名称。因此，在命名源代码文件名时要小心。'
- en: One thing that's new (but not really new since you already encountered this
    in [Chapter 4](37b25b74-5f3e-4217-ad46-c8a33ae337c6.xhtml), *Interacting With
    Smart Contracts Using Web3,* is `web3.eth.coinbase`. This is the default account.
    In this context (unit test), it means the address of the account that launched
    the smart contract.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件新的事情（但实际上并不新，因为您已经在[第4章](37b25b74-5f3e-4217-ad46-c8a33ae337c6.xhtml)中遇到过这个），那就是`web3.eth.coinbase`。这是默认账户。在这个上下文（单元测试）中，它表示启动智能合约的账户的地址。
- en: 'If this unit test succeeds, let''s continue testing another method in this
    smart contract:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个单元测试成功，让我们继续测试这个智能合约中的另一个方法：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this method, you're forced to send at least 1 ether to the smart contract.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，您被迫向智能合约发送至少1个以太币。
- en: 'Let''s test the fail case by writing the second unit test:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写第二个单元测试来测试失败情况：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, you need to add two `import` statements:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要添加两个`import`语句：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's learn how to deal with an exception in this unit test. You can put a troubled
    transaction inside the `with` statement that will catch an exception. Basically,
    you expect the transaction to fail. When something fails in the program, it returns
    a special code (for example, -1) or it throws an exception. In this case, it throws
    an exception.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在这个单元测试中处理异常。您可以将有问题的交易放在`with`语句中，该语句将捕获异常。基本上，您期望交易失败。当程序中出现故障时，它会返回一个特殊代码（例如，-1）或抛出异常。在这种情况下，它会抛出异常。
- en: 'Run the test to see whether it works. Then, let''s test the success case, meaning
    the donation is accepted (refer to the code file in the following GitLab link
    for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/tests/test_donation.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/tests/test_donation.py)):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '运行测试以查看它是否有效。然后，让我们测试成功的情况，也就是捐赠被接受（请参考以下GitLab链接上的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/tests/test_donation.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/tests/test_donation.py)）:'
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a lot to digest, so let's discuss it step by step.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多东西要消化的，所以让我们一步一步地讨论。
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''re going to use the `time` library to check the timestamp later in this
    unit test:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`time`库来检查此单元测试中的时间戳：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You already know this statement. Using the `chain` object, you could get the
    provider and then you use the `get_or_deploy_contract` method from this provider.
    The result is a donation smart contract object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道这个声明。使用`chain`对象，您可以获取提供者，然后使用该提供者的`get_or_deploy_contract`方法。结果是一个捐赠智能合约对象：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`eth_tester` is a library designed to make you test a smart contract easier.
    To do that, you create an object of `EthereumTester`. There are many helper functions
    in this library. One of them is there to give you some accounts loaded with a
    lot of ETH, sort of like Ganache. The first account is the manager account or
    the account that launched the smart contract. As demonstrated previously, you
    could also get that account from `web3.eth.coinbase`. The second account and so
    on are testing accounts that you could use in your unit test.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`eth_tester`是一个旨在使您更轻松地测试智能合约的库。为此，您创建一个`EthereumTester`对象。该库中有许多辅助函数。其中一个函数是为您提供一些加载了大量ETH的账户，有点像Ganache。第一个账户是管理账户或启动智能合约的账户。如前所示，您也可以从`web3.eth.coinbase`获取该账户。第二个账户等等是您可以在单元测试中使用的测试账户。'
- en: '`t.get_accounts()` gives you a lot of accounts. However, don''t use the first
    account because that would be the manager account. Here, you use the second account:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`t.get_accounts()`会给您很多账户。但是不要使用第一个账户，因为那将是管理账户。在这里，您使用第二个账户：'
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You''ve seen the `transact` function in the previous unit test with the greeter
    smart contract. In this `transact` method, you could specify an ether amount that
    you want to send to the smart contract. You could also use a different account.
    In these `transact` parameters, we also use the helper function, `web3.toWei`.
    Otherwise, you have to use a number with a lot of zeros. Then, you wait for the
    transaction to be confirmed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你在之前的与greeter智能合约的单元测试中看到了`transact`函数。在这个`transact`方法中，你可以指定你想发送到智能合约的以太币金额。你也可以使用不同的账户。在这些`transact`参数中，我们还使用了辅助函数`web3.toWei`。否则，你必须使用很多零的数字。然后，你等待交易被确认：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After doing this, you can access the public variables to confirm the change
    in state.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，你可以访问公共变量来确认状态的变化。
- en: For an array, you put an index inside the array method, as in `donation.functions.donaturs(0).call()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，你在数组方法中放入一个索引，就像`donation.functions.donaturs(0).call()`中一样。
- en: For mapping, instead of the integer index, you provide the key inside the parameter
    of the mapping method, as in `donation.functions.donatur_details__sum(donatur).call()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射，你提供映射方法的参数中的键，而不是整数索引，就像`donation.functions.donatur_details__sum(donatur).call()`中一样。
- en: For a struct, you access the member by appending two underscores, as in `donation.functions.donatur_details__sum(donatur).call(`*)*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构体，你通过追加两个下划线来访问成员，就像`donation.functions.donatur_details__sum(donatur).call()`中一样。
- en: 'Then, we test the donation by asserting all of these variables as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过断言所有这些变量来测试捐款：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then check that the donator address is recorded correctly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查捐赠者地址是否被正确记录：
- en: '[PRE37]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then check that the donation amount is recorded correctly:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查捐款金额是否被正确记录：
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We then check that the donator''s name is recorded correctly:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查捐赠者的姓名是否被正确记录：
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We then check the time when the donation occurred. We do this because the time
    is recorded when the transaction is confirmed in blockchain, so you never know
    when the transaction is being confirmed. In our case, it would be fast. However,
    if you test it in the Rinkeby network, that's something to keep in mind. Here,
    I make sure that the difference between the unit test time and the timestamp recorded
    in the smart contract doesn't differ by more than 10 minutes (600 seconds).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查捐款发生的时间。我们这样做是因为时间是在交易在区块链中确认时记录的，所以你永远不知道交易何时被确认。在我们的情况下，这会很快。然而，如果你在Rinkeby网络中测试，这是需要牢记的事情。在这里，我确保单元测试时间和智能合约中记录的时间戳之间的差异不超过10分钟（600秒）。
- en: 'We then check the donation amount directly from the balance of the smart contract:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们直接从智能合约的余额中检查捐款金额：
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is different from the previous test, where you test the balance by checking
    the value of the public variable. In our case, we have many donations, so they'll
    be different.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的测试不同，之前的测试是通过检查公共变量的值来测试余额。在我们的情况下，我们有很多捐款，所以它们会不同。
- en: 'Let''s take a look at the last method in the smart contract:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看智能合约中的最后一个方法：
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is the method to withdraw the donation. Don't laugh; some people launched
    a smart contract that does not have a way to withdraw the ethers in it. All ethers
    in those smart contracts are locked forever, which is why testing is important.
    It ensures that you don't make stupid mistakes like this.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提取捐款的方法。不要笑；有些人启动了一个没有提取以太币方法的智能合约。这些智能合约中的所有以太币都将永远被锁定，这就是为什么测试很重要。它确保你不会犯这样的愚蠢错误。
- en: In this withdrawal method, you want to test that you can withdraw ethers in
    the smart contract. Then, you need to make sure that only a certain account (in
    this case, it is the manager account) is able to withdraw ethers from the smart
    contract.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个提款方法中，你想要测试你能否从智能合约中提取以太币。然后，你需要确保只有特定的账户（在这种情况下是经理账户）能够从智能合约中提取以太币。
- en: 'Let''s create a unit test for that. First, we create a unit test to make sure
    that another account can''t withdraw ethers from the smart contract:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为此创建一个单元测试。首先，我们创建一个单元测试，以确保另一个账户无法从智能合约中提取以太币：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Everything should look familiar to you now. You wrap the fail case of withdrawing
    ethers in the `with` statement that catches the exception.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切应该对你来说都很熟悉了。你在`with`语句中包装提取以太币的失败情况，以捕获异常。
- en: 'Now, let''s test the success case that the manager account could indeed withdraw
    ethers to their account:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试经理账户确实能够提取以太币的成功情况：
- en: '[PRE43]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Everything here will be familiar to you, except maybe the last line. The manager''s
    account balance after withdrawal minus the `initial_balance` wouldn''t be exactly
    `1` `ether` because the manager''s account needs to pay the fee. In this case,
    we just use a rough measurement to ensure that the withdrawal is successful. As
    long as the difference is below 10 gwei, that should be fine. Gwei is the currency
    we use to calculate the fee for sending a transaction. 1 gwei is 1,000,000,000
    wei. If you find this confusing, you could assert it using ether currency, as
    follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一切对你来说都很熟悉，除了最后一行。经理账户提取后的余额减去`initial_balance`不会完全是`1`个以太币，因为经理账户需要支付手续费。在这种情况下，我们只是使用一个粗略的测量来确保提取成功。只要差异低于10
    gwei，那就没问题。Gwei是我们用来计算发送交易手续费的货币。1 gwei等于1,000,000,000 wei。如果你觉得这很困惑，你可以使用以太币货币进行断言，如下所示：
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the test:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试：
- en: '[PRE45]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should get a successful result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个成功的结果：
- en: '![](assets/5560df57-4bd6-4a7d-90e3-8287d1a540b4.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5560df57-4bd6-4a7d-90e3-8287d1a540b4.png)'
- en: Using arguments in the constructor
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造函数中的参数
- en: Both smart contracts that we test have no arguments in the constructor. But
    what if we write a smart contract that has arguments in the constructor? How do
    we test that?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的两个智能合约在构造函数中都没有参数。但是如果我们编写一个构造函数中带有参数的智能合约呢？我们如何测试呢？
- en: 'Let''s write a simple smart contract that has arguments in the constructor.
    Name it `contracts/Greeter2.vy`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的智能合约，构造函数中带有参数。命名为`contracts/Greeter2.vy`：
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, write the following test. Name it `tests/test_greeter2.py`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编写以下测试。命名为`tests/test_greeter2.py`：
- en: '[PRE47]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, you customize the deployment of your smart contract using the `fixture`
    feature from `pytest`. First, you get the contract factory from the chain's provider,
    and then you put your argument in the `constructor` method of the `factory` object,
    ending with the `transact()` method. Then, wait until it is deployed on the blockchain.
    Finally, you will receive the address.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用`pytest`的`fixture`功能自定义部署智能合约。首先，您从链的提供者那里获取合约工厂，然后将参数放在`factory`对象的`constructor`方法中，以`transact()`方法结束。然后，等待直到它在区块链上部署。最后，您将收到地址。
- en: In the test function, you put the argument exactly as the fixture function's
    name. Here, our fixture function is `greeter2_contract`. Inside the test function,
    you just use this object as a smart contract object that's similar to an object
    returned by `chain.provider.get_or_deploy_contract('Donation')`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试函数中，您将参数放置在与fixture函数名称完全相同的位置。在这里，我们的fixture函数是`greeter2_contract`。在测试函数中，您只需将此对象用作类似于`chain.provider.get_or_deploy_contract('Donation')`返回的对象的智能合约对象。
- en: 'Now, test this as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按以下方式进行测试：
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should get a successful result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到一个成功的结果：
- en: '![](assets/e7e24a72-078d-4e91-a64e-6836b011d7a0.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e7e24a72-078d-4e91-a64e-6836b011d7a0.png)'
- en: There are still many things you could test. We only test for one donation, but
    we could accept up to 10 donations. This should be checked as well. How complete
    you want the test coverage to be is up to you and the requirements of the project.
    There are still a plethora of unit testing aspects that we haven't discussed here,
    such as setup, tear down, and test-driven development.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以测试许多事项。我们只测试了一次捐赠，但我们可以接受多达10次捐赠。这也应该被检查。您希望测试覆盖率有多完整取决于您和项目的要求。还有许多单元测试方面我们在这里没有讨论，例如设置、拆卸和测试驱动开发。
- en: Deploying a smart contract with Populus
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Populus部署智能合约
- en: Populus isn't just a framework designed to easily develop and test a smart contract.
    It has a tool to deploy a smart contract to a blockchain, including a private
    chain.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Populus不仅是一个旨在轻松开发和测试智能合约的框架。它还有一个部署智能合约到区块链的工具，包括私有链。
- en: A private chain is basically your private Ethereum blockchain, similar to Ganache,
    except that you build it yourself. It's like blockchain in the Rinkeby network,
    but you're the sole miner. You can create a private blockchain manually using
    geth software; `populus` just makes it easier for you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 私有链基本上是您的私有以太坊区块链，类似于Ganache，只是您自己构建它。就像在Rinkeby网络中的区块链一样，但您是唯一的矿工。您可以使用geth软件手动创建私有区块链；`populus`只是让您更容易。
- en: 'The command to create a new private `chain` is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的私有`chain`的命令如下：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This command will create some files in your project directory. All generated
    files are located inside the `chains` directory. One of the files generated is
    `chains/localblock/genesis.json`. The purpose of the genesis file is to dictate
    the initial configuration of the Ethereum blockchain:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在您的项目目录中创建一些文件。所有生成的文件都位于`chains`目录内。生成的文件之一是`chains/localblock/genesis.json`。创世文件的目的是指示以太坊区块链的初始配置：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You don't need to know all of the meanings of these keys. `coinbase` means all
    mining rewards should go into this account. `alloc` means the initial balance
    of the accounts.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要知道这些键的所有含义。`coinbase`表示所有挖矿奖励应该进入这个账户。`alloc`表示账户的初始余额。
- en: 'Apart from the genesis file, you should get `chains/localblock/init_chain.sh`.
    Open it and you should have the following content:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创世文件之外，您还应该获得`chains/localblock/init_chain.sh`。打开它，您应该有以下内容：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This script is basically running geth software with certain parameters. The
    most important parameter is `init`, which you feed to your `genesis.json` file.
    Then, run the initialization of your private blockchain:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本基本上是用特定参数运行geth软件。最重要的参数是`init`，您将其提供给您的`genesis.json`文件。然后，运行您的私有区块链的初始化：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, open the `chains/localblock/run_chain.sh` file and you should have this
    content:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`chains/localblock/run_chain.sh`文件，您应该有以下内容：
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The important flags that you need to note for now are `--mine`, `--password`,
    `--ipcpath`, `--unlock`, and `--datadir`. `--mine` indicates that you want to
    mine in this private blockchain, `--password` is the location of the password
    file, `--unlock` unlocks the account with the password file, `--datadir` is the
    location of your private Ethereum blockchain directory, and `--ipcpath` is where
    your `geth.ipc` will be located when you run your private Ethereum blockchain.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在需要注意的重要标志是`--mine`，`--password`，`--ipcpath`，`--unlock`和`--datadir`。`--mine`表示您想在这个私有区块链中进行挖矿，`--password`是密码文件的位置，`--unlock`解锁带有密码文件的账户，`--datadir`是您的私有以太坊区块链目录的位置，`--ipcpath`是当您运行您的私有以太坊区块链时`geth.ipc`将位于的位置。
- en: 'Before running the blockchain, edit the `chains/localblock/run_chain.sh` script*,*
    change the value of the `--ipcpath` flag to `/tmp/geth.ipc`, and then run the
    blockchain:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行区块链之前，编辑`chains/localblock/run_chain.sh`脚本，将`--ipcpath`标志的值更改为`/tmp/geth.ipc`，然后运行区块链：
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, edit the `project.json` file. The `chains` key has one object that has
    four keys: `tester`, `temp`, `ropsten`, and `mainnet`. Add the `localblock` key with
    its value in this object. Hence, the `localblock` key must be adjacent to the `tester`,
    `mainnet`, `temp`, and `ropsten` keys, as demonstrated in the following code block:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑`project.json`文件。`chains`键有一个包含四个键的对象：`tester`，`temp`，`ropsten`和`mainnet`。在这个对象中添加`localblock`键及其值。因此，`localblock`键必须与`tester`，`mainnet`，`temp`和`ropsten`键相邻，如下面的代码块所示：
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, you could deploy your smart contract to your private blockchain as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将您的智能合约部署到您的私有区块链中，如下所示：
- en: '[PRE56]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, you can play around with your smart contract such as you did in [Chapter
    4](37b25b74-5f3e-4217-ad46-c8a33ae337c6.xhtml)*, Interacting with Smart Contracts
    Using Web3*. You can refer to the code file at the following GitLab link: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_private_chain.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_private_chain.py),
    for the complete code of the following code block:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像在[第4章](37b25b74-5f3e-4217-ad46-c8a33ae337c6.xhtml)*使用Web3与智能合约交互*中那样玩弄你的智能合约。你可以参考以下GitLab链接的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_private_chain.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_private_chain.py)，获取以下代码块的完整代码：
- en: '[PRE57]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Are you still attached to Ganache? If so, we can deploy to a Ganache blockchain.
    Start by firing up Ganache and then add this content to the `chains` key object
    in the `projects.json` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你还在使用Ganache吗？如果是的，我们可以部署到Ganache区块链。首先启动Ganache，然后将以下内容添加到`projects.json`文件中的`chains`键对象中：
- en: '[PRE58]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the deployment as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式运行部署：
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Then, when you want to play around with your smart contract in Ganache, you
    just have to adjust the provider as you learned in [Chapter 4](37b25b74-5f3e-4217-ad46-c8a33ae337c6.xhtml),
    *Interacting with Smart Contracts Using Web3:*
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你想在Ganache中玩弄你的智能合约时，你只需要像在[第4章](37b25b74-5f3e-4217-ad46-c8a33ae337c6.xhtml)中学到的那样调整提供者，*使用Web3与智能合约交互*：
- en: '[PRE60]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The remainder of the code is the same. You can name the script `interact_smart_contract_in_ganache.py`.
    In Ganache, the coinbase account and the manager account are the first accounts
    in Ganache. Refer to the GitLab link for the full code to interact with the smart
    contract in Ganache, [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_ganache.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_ganache.py):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码是一样的。你可以将脚本命名为`interact_smart_contract_in_ganache.py`。在Ganache中，coinbase账户和manager账户是Ganache中的第一个账户。参考GitLab链接获取与Ganache中智能合约交互的完整代码，[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_ganache.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_ganache.py)：
- en: '[PRE61]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to develop a smart contract with the Populus
    development framework. Populus isn't equipped with Vyper support, only Solidity.
    Consequently, you need to add Vyper support by installing Vyper and editing the
    Populus project configuration file. You also learned how to create unit tests
    for a smart contract. In this unit test, you used the `web3` object to interact
    with a smart contract and test it programmatically. After this, you learned how
    to create a private chain. Finally, you deployed a smart contract to this private
    chain and Ganache.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何使用Populus开发框架开发智能合约。Populus不支持Vyper，只支持Solidity。因此，你需要通过安装Vyper并编辑Populus项目配置文件来添加Vyper支持。你还学会了如何为智能合约创建单元测试。在这个单元测试中，你使用`web3`对象与智能合约进行交互并进行程序化测试。之后，你学会了如何创建私有链。最后，你将智能合约部署到了这个私有链和Ganache。
- en: In the next chapter, you're going to build an application on top of a blockchain
    that's more complicated than the donation smart contract. This application is
    the voting decentralized application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将构建一个比捐赠智能合约更复杂的区块链应用。这个应用是去中心化的投票应用。
