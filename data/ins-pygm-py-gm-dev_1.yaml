- en: Chapter 1. Instant Pygame for Python Game Development How-to
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. Instant Pygame for Python Game Development How-to
- en: 'Welcome to *Pygame for Python Game Development How-to*. This book is for developers
    who want to create games with Pygame quickly and easily and get familiar with
    the important aspects of it. The typical things you would learn are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用 *Pygame for Python Game Development How-to*。这本书是为那些想要快速、轻松地使用 Pygame 创建游戏并熟悉其重要方面的开发者而编写的。你通常会学到以下典型内容：
- en: Pygame basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pygame 基础
- en: Sprites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵
- en: OpenGL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL
- en: Pygame is part of the Python framework, originally written by Pete Shinners,
    that as its name suggests can be used to create video games. Pygame is free and
    open source since 2004 and licensed under the GPL license, which means that you
    are allowed to basically make any type of game. Pygame is built on top of the
    **Simple DirectMedia Layer** (**SDL**). SDL is a C framework that gives access
    to graphics, sound, keyboard, and other input devices on various operating systems
    including Linux, Mac OS X, and Windows.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 是由 Pete Shinners 编写的 Python 框架的一部分，正如其名称所暗示的，可以用来创建视频游戏。Pygame 自 2004
    年以来是免费和开源的，并受 GPL 许可证的许可，这意味着你可以基本上制作任何类型的游戏。Pygame 是建立在 **Simple DirectMedia
    Layer**（**SDL**）之上的。SDL 是一个 C 框架，它为包括 Linux、Mac OS X 和 Windows 在内的各种操作系统上的图形、声音、键盘和其他输入设备提供了访问权限。
- en: Preparing your development environment (Simple)
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备你的开发环境（简单）
- en: We will install Python, Pygame, and other software we will need.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装 Python、Pygame 以及我们需要的其他软件。
- en: Getting ready
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we install Pygame, we need to have Python installed. On some operating
    systems Python is already installed. Pygame should be compatible with all Python
    versions. We will also need the NumPy numerical library. I am the author of two
    books published by Packt Publishing about NumPy – *NumPy Beginner's Guide* and
    *NumPy Cookbook*. Please refer to these books for more info about NumPy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装 Pygame 之前，我们需要确保 Python 已经安装。在某些操作系统上，Python 已经预装了。Pygame 应该与所有 Python
    版本兼容。我们还需要 NumPy 数值库。我是 Packt Publishing 出版的两本关于 NumPy 的书的作者——*NumPy 初学者指南*和*NumPy
    烹饪书*。请参考这些书籍以获取更多关于 NumPy 的信息。
- en: How to do it...
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Installing on Debian and Ubuntu
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Debian 和 Ubuntu 上安装
- en: 'Python might be already installed on Debian and Ubuntu, but the development
    headers are usually not. On Debian and Ubuntu, install python and python-dev with
    these commands:'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python 可能已经在 Debian 和 Ubuntu 上安装，但通常开发头文件没有安装。在 Debian 和 Ubuntu 上，使用以下命令安装 python
    和 python-dev：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Pygame can be found in the Debian archives [http://packages.qa.debian.org/p/pygame.html](http://packages.qa.debian.org/p/pygame.html).
    We can install NumPy with the following command:'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Pygame 可以在 Debian 存档 [http://packages.qa.debian.org/p/pygame.html](http://packages.qa.debian.org/p/pygame.html)
    中找到。我们可以使用以下命令安装 NumPy：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing on Windows
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上安装
- en: The Windows Python installer can be found on [www.python.org/download](http://www.python.org/download).
    On this website we can also find installers for Mac OS X and source tarballs for
    Linux, Unix, and Mac OS X.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Windows 的 Python 安装程序可以在 [www.python.org/download](http://www.python.org/download)
    找到。在这个网站上，我们还可以找到 Mac OS X 和 Linux、Unix、Mac OS X 的源代码压缩包。
- en: From the Pygame website ([http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml)),
    we can download the appropriate binary installer for the Python version we are
    using.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 Pygame 网站 ([http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml))，我们可以下载适用于我们使用的
    Python 版本的相应二进制安装程序。
- en: Download a NumPy installer for Windows from the SourceForge website ([http://sourceforge.net/projects/numpy/files/](http://sourceforge.net/projects/numpy/files/)).
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 SourceForge 网站下载 Windows 的 NumPy 安装程序（[http://sourceforge.net/projects/numpy/files/](http://sourceforge.net/projects/numpy/files/)）。
- en: Installing Python on the Mac
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Mac 上安装 Python
- en: 'Python comes preinstalled on Mac OS X. We can also get Python via MacPorts,
    Fink, or similar projects. We can install for instance the Python 2.6 port by
    running the following command:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python 预装在 Mac OS X 上。我们也可以通过 MacPorts、Fink 或类似的项目来获取 Python。例如，我们可以通过运行以下命令来安装
    Python 2.6 版本的端口：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Binary Pygame packages for Mac OS X 10.3 and up can be found on [http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml).
    We can get a NumPy installer from the SourceForge website ([http://sourceforge.net/projects/numpy/files/](http://sourceforge.net/projects/numpy/files/)).
    Download the appropriate `.DMG` file. Usually the latest one is the best.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 二进制 Pygame 软件包可以从 [http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml)
    下载，适用于 Mac OS X 10.3 及以上版本。我们可以从 SourceForge 网站获取 NumPy 安装程序（[http://sourceforge.net/projects/numpy/files/](http://sourceforge.net/projects/numpy/files/)）。通常，最新版本是最好的。
- en: Installing from source
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码安装
- en: 'Pygame is using the `distutils` system for compiling and installing. To start
    installing Pygame with the default options, simply run the following command:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Pygame使用`distutils`系统进行编译和安装。要使用默认选项开始安装Pygame，只需运行以下命令：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you need more information about the available options, type the following
    command:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您需要有关可用选项的更多信息，请键入以下命令：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to compile the code, you need to have a compiler for your operating
    system. Setting this up is beyond the scope of this book. More information about
    compiling Pygame on Windows can be found on [http://pygame.org/wiki/CompileWindows](http://pygame.org/wiki/CompileWindows).
    More information about compiling Pygame on Mac OS X can be found at [http://pygame.org/wiki/MacCompile](http://pygame.org/wiki/MacCompile).
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了编译代码，您需要为您的操作系统安装一个编译器。设置此内容超出了本书的范围。有关在Windows上编译Pygame的更多信息，请参阅[http://pygame.org/wiki/CompileWindows](http://pygame.org/wiki/CompileWindows)。有关在Mac
    OS X上编译Pygame的更多信息，请参阅[http://pygame.org/wiki/MacCompile](http://pygame.org/wiki/MacCompile)。
- en: Running a simple game (Simple)
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行一个简单的游戏（简单）
- en: We will create a simple game that we will improve on further in the book. As
    is traditional in books about programming, we will start with a Hello World! example.
    It's not a game per se. It's important to notice the so-called main game loop
    where all the action happens and the usage of the `Font` module to render text.
    In this program we will manipulate a Pygame's `Surface` object, that is used for
    drawing and we will handle a quit event.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的游戏，我们将在书中进一步改进它。正如编程书籍的传统做法，我们将从一个Hello World!示例开始。这本身不是一个游戏。重要的是要注意所谓的“主游戏循环”，在这里所有动作发生，以及使用`Font`模块来渲染文本。在这个程序中，我们将操作Pygame的`Surface`对象，用于绘图，并且我们将处理退出事件。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: '**Imports**: First we will import the required Pygame modules. If Pygame is
    installed properly, we should get no errors, otherwise please return to the *Preparing
    your development environment (Simple)* recipe:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导入**：首先，我们将导入所需的Pygame模块。如果Pygame安装正确，我们应该不会出现错误，否则请返回到*准备你的开发环境（简单）*食谱：'
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Initialization**: We will initialize Pygame by creating a display of 400
    by 300 pixels and setting the window title to `Hello world`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化**：我们将通过创建一个400 x 300像素的显示并设置窗口标题为`Hello World`来初始化Pygame：'
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**The main game loop**: Games usually have a game loop, which runs forever
    until, for instance, a quit event occurs. In this example, we will only set a
    label with the text `Hello world` at coordinates (100, 100). The text has a font
    size of 19, red color, and falls back to the default font:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主游戏循环**：游戏通常有一个游戏循环，它永远运行，直到例如发生退出事件。在这个例子中，我们将只在坐标（100，100）处设置一个带有文本`Hello
    world`的标签。文本的字体大小为19，红色，并回退到默认字体：'
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We get the following screenshot as the end result:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们得到以下截图作为最终结果：
- en: '![How to do it...](img/2865OS_01.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/2865OS_01.jpg)'
- en: 'The following is the complete code for the Hello World example:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是为Hello World示例提供的完整代码：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'It might not seem like much, but we learned a lot in this recipe. The functions
    that passed the review are summarized in the following table:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不多，但我们在这一步学到了很多。通过审查的函数总结在下表中：
- en: '| Function | Description |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pygame.init()` | This function performs the initialization and needs to
    be called before any other Pygame functions are called. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.init()` | 此函数执行初始化，需要在调用任何其他Pygame函数之前调用。 |'
- en: '| `pygame.display.set_mode((400, 300))` | This function creates a so-called
    `Surface` object to draw on. We give this function a tuple representing the width
    and height of the surface. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.display.set_mode((400, 300))` | 此函数创建一个所谓的`Surface`对象进行绘制。我们给这个函数一个表示表面宽度和高度的元组。
    |'
- en: '| `pygame.display.set_caption(''Hello World!'')` | This function sets the window
    title to a specified string value. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.display.set_caption(''Hello World!'')` | 此函数将窗口标题设置为指定的字符串值。 |'
- en: '| `pygame.font.SysFont("None", 19)` | This function creates a system font from
    a comma-separated list of fonts (in this case none) and a font size parameter.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.font.SysFont("None", 19)` | 此函数从逗号分隔的字体列表（在这种情况下为无）和字体大小参数创建系统字体。
    |'
- en: '| `sysFont.render(''Hello World'', 0, (255, 100, 100))` | This function draws
    text on a surface. The second parameter indicates whether anti-aliasing is used.
    The last parameter is a tuple representing the RGB values of a color. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `sysFont.render(''Hello World'', 0, (255, 100, 100))` | 此函数在表面上绘制文本。第二个参数指示是否使用抗锯齿。最后一个参数是一个表示颜色RGB值的元组。
    |'
- en: '| `screen.blit(rendered, (100, 100))` | This function draws on a surface. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `screen.blit(rendered, (100, 100))` | 此函数在表面上绘制。 |'
- en: '| `pygame.event.get()` | This function gets a list of `Event` objects. Events
    represent some special occurrence in the system, such as a user quitting the game.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.event.get()` | 此函数获取一个`Event`对象列表。事件代表系统中的某些特殊事件，例如用户退出游戏。 |'
- en: '| `pygame.quit()` | This function cleans up resources used by Pygame. Call
    this function before exiting the game. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.quit()` | 此函数清理Pygame使用的资源。在退出游戏之前调用此函数。 |'
- en: '| `pygame.display.update()` | This function refreshes the surface. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.display.update()` | 此函数刷新表面。 |'
- en: Drawing with Pygame (Simple)
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pygame进行绘图（简单）
- en: Before we start creating cool games, we need an introduction to the drawing
    functionality of Pygame. As we noticed in the previous recipe, in Pygame we draw
    on the `Surface` objects. There is a myriad of drawing options—different colors,
    rectangles, polygons, lines, circles, ellipses, animation, and different fonts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建酷炫的游戏之前，我们需要了解Pygame的绘图功能。正如我们在前面的菜谱中注意到的，在Pygame中我们在`Surface`对象上绘制。有无数种绘图选项——不同的颜色、矩形、多边形、线条、圆形、椭圆、动画和不同的字体。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps will help you diverge into the different drawing options
    you can use with Pygame:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你了解你可以使用Pygame进行的不同绘图选项：
- en: '**Imports**: We will need the NumPy library to randomly generate RGB values
    for the colors, so we will add an extra import for that:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导入**：我们需要NumPy库来随机生成用于颜色的RGB值，因此我们将添加一个额外的导入：'
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Initializing colors**: Generate four tuples containing three RGB values each
    with NumPy:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化颜色**：使用NumPy生成包含三个RGB值的四个元组：'
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then define the white color as a variable:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后定义白色为变量：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Set the background color**: We can make the whole screen white with the following
    code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置背景颜色**：我们可以使用以下代码使整个屏幕变为白色：'
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Drawing a circle**: Draw a circle in the center with the window using the
    first color we generated:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绘制圆形**：使用我们生成的第一种颜色在窗口中心绘制一个圆形：'
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Drawing a line**: To draw a line we need a start point and an end point.
    We will use the second random color and give the line a thickness of `3`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绘制线条**：要绘制线条，我们需要一个起点和一个终点。我们将使用第二种随机颜色，并给线条设置厚度为`3`：'
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Drawing a rectangle**: When drawing a rectangle, we are required to specify
    a color, the coordinates of the upper-left corner of the rectangle, and its dimensions:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绘制矩形**：绘制矩形时，我们需要指定颜色、矩形左上角的坐标以及其尺寸：'
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Drawing an ellipse**: You might be surprised to discover that drawing an
    ellipse requires similar parameters as for rectangles. The parameters actually
    describe an imaginary rectangle that can be drawn around the ellipse:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绘制椭圆**：你可能惊讶地发现，绘制椭圆需要与矩形类似的参数。这些参数实际上描述了一个可以围绕椭圆绘制的想象中的矩形：'
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resulting window with a circle, line, rectangle, and ellipse using random
    colors:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用随机颜色绘制的包含圆形、线条、矩形和椭圆的窗口结果：
- en: '![How to do it...](img/2685OS_02.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/2685OS_02.jpg)'
- en: 'The code for the drawing demo is as follows:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 绘图演示的代码如下：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Animating objects (Simple)
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单对象动画
- en: Now that we know how to draw with Pygame, it's time to try something more dynamic.
    Most games, even the most static ones, have some level of animation. From a programmer's
    standpoint, animation is nothing more than displaying an object at a different
    place at a different time, thus simulating movement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用Pygame进行绘图，是时候尝试一些更动态的内容了。大多数游戏，即使是静态的，都有一定程度的动画。从程序员的角度来看，动画不过是将对象在不同的时间和不同的位置显示出来，从而模拟运动。
- en: Pygame offers a `Clock` object that manages how many frames are drawn per second.
    This ensures that animation is independent of how fast the user's CPU is.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame提供了一个`Clock`对象，用于管理每秒绘制多少帧。这确保了动画与用户CPU的速度无关。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load an image and use NumPy again to define a clockwise path around
    the screen:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载一张图片，并使用NumPy再次定义一个围绕屏幕的顺时针路径：
- en: 'First, we need to create a clock as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个时钟，如下所示：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Loading an image**: As part of the source code accompanying this book, there
    should be a picture of a head. We will load this image and move it around on the
    screen:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**加载图像**：作为本书附带源代码的一部分，应该有一张头像图片。我们将加载这张图片并在屏幕上移动它：'
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Initializing arrays**: We will define some arrays to hold the coordinates
    of the positions, where we would like to put the image during the animation. Since
    the object will be moved, there are four logical sections of the path: right,
    down, left, and up. Each of these sections will have 40 equidistant steps. We
    will initialize all the values in the sections to 0:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化数组**：我们将定义一些数组来保存动画期间图像位置的坐标，我们希望在动画中放置图像的位置。由于对象将被移动，路径有四个逻辑部分：右、下、左和上。每个部分将有40个等距步骤。我们将初始化这些部分的所有值为0：'
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Setting the coordinates of the positions**: It''s trivial to set the coordinates
    of the positions of the image. However, there is one tricky bit to notice, the
    `[::-1]` notation leads to reversing the order of the array elements:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置位置坐标**：设置图像位置坐标是微不足道的。然而，有一个需要注意的技巧，`[::-1]`表示法会导致数组元素的顺序反转：'
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Joining the sections**: The path sections can be joined, but before we can
    do this, the arrays have to be transposed with the `T` operator:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接部分**：路径部分可以连接，但在我们能够这样做之前，数组必须使用 `T` 操作符进行转置：'
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Setting the clock rate**: In the main event loop, we will let the clock tick
    at a rate of 30 frames per second:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置时钟速率**：在主事件循环中，我们将让时钟以每秒30帧的速度滴答：'
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot is of the moving head:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图是移动头部的：
- en: '![How to do it...](img/2865OS_03.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/2865OS_03.jpg)'
- en: Note
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should be able to watch a movie of this animation on [https://www.youtube.com/watch?v=m2TagGiq1fs](https://www.youtube.com/watch?v=m2TagGiq1fs).
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该能够在[https://www.youtube.com/watch?v=m2TagGiq1fs](https://www.youtube.com/watch?v=m2TagGiq1fs)上观看这个动画的电影。
- en: 'The code of this example uses almost everything we learned so far, but should
    still be simple enough to understand:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此示例的代码几乎使用了我们迄今为止学到的所有内容，但仍然足够简单，易于理解：
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We learned a bit about animation in this recipe. The most important concept
    we learned is the clock. The new functions that we used are described in the following
    table:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们了解了一些关于动画的知识。我们学到的最重要的概念是时钟。我们使用的新的函数描述如下表：
- en: '| Function | Description |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pygame.time.Clock()` | This function creates a game clock |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.time.Clock()` | 此函数创建一个游戏时钟 |'
- en: '| `numpy.linspace(20, 360, 40)` | This function creates an array with 40 equidistant
    values between 20 and 360 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.linspace(20, 360, 40)` | 此函数创建一个包含20和360之间40个等距值的数组 |'
- en: '| `numpy.zeros((2, len(steps)))` | This function creates an array of the specified
    dimensions filled with zeroes |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.zeros((2, len(steps)))` | 此函数创建一个指定维度的数组，并用零填充 |'
- en: '| `numpy.concatenate((right.T, down.T, left.T, up.T))` | This function concatenates
    arrays to form a new array |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.concatenate((right.T, down.T, left.T, up.T))` | 此函数将数组连接起来形成一个新的数组
    |'
- en: '| `clock.tick(30)` | This function executes a tick of the game clock, where
    30 is the number of frames per second |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `clock.tick(30)` | 此函数执行游戏时钟的滴答，其中30是每秒的帧数 |'
- en: Using fonts (Simple)
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字体（简单）
- en: Frequently there is a need to display some text, for instance, a counter or
    a message.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要显示一些文本，例如计数器或消息。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Pygame has a `font` module that can help us to show text.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 有一个 `font` 模块可以帮助我们显示文本。
- en: '**Creating a font**: We can create a font by specifying, the font filename,
    and font size as constructor parameters:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建字体**：我们可以通过指定字体文件名和字体大小作为构造函数参数来创建字体：'
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Displaying text**: Since we made an image move around the edge in the previous
    recipe, it would be great to display a counter and the position of the image in
    the center of the screen with a blue background and red letters. The following
    code snippet accomplishes this:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**显示文本**：由于我们在之前的食谱中使图像在边缘移动，所以在屏幕中央显示计数器和图像位置，背景为蓝色，文字为红色，将会非常棒。以下代码片段实现了这一点：'
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A screenshot of the animation is shown as follows and should be on YouTube too
    at [https://www.youtube.com/watch?v=xhjfcFhaXN0](https://www.youtube.com/watch?v=xhjfcFhaXN0).
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动画截图如下，也应该在[https://www.youtube.com/watch?v=xhjfcFhaXN0](https://www.youtube.com/watch?v=xhjfcFhaXN0)上。
- en: '![How to do it...](img/2865OS_04.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/2865OS_04.jpg)'
- en: 'The code is almost the same as for the previous recipe, with the addition of
    code for the creation and display of fonts:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码几乎与之前的食谱相同，只是增加了创建和显示字体的代码：
- en: '[PRE27]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using Matplotlib with Pygame (Simple)
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 和 Pygame（简单）
- en: Matplotlib is an open source library for easy plotting. We can integrate Matplotlib
    into Pygame game and create various plots. You can find the Matplotlib installation
    instructions at [http://matplotlib.org/users/installing.html](http://matplotlib.org/users/installing.html).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib是一个易于绘图的开源库。我们可以将Matplotlib集成到Pygame游戏中并创建各种图表。您可以在[http://matplotlib.org/users/installing.html](http://matplotlib.org/users/installing.html)找到Matplotlib的安装说明。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe we will take the position coordinates of the previous recipe
    and make a graph of them:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用前一个食谱中的位置坐标并绘制它们的图表：
- en: '**Using a non-interactive backend**: In order to integrate Matplotlib with
    Pygame, we need to use a non-interactive backend, otherwise Matplotlib will present
    us with a GUI window by default. We will import the main Matplotlib module and
    call the `use` function. This function has to be called immediately after importing
    the main `matplotlib` module and before other `matplotlib` modules are imported:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用非交互式后端**：为了将Matplotlib与Pygame集成，我们需要使用非交互式后端，否则Matplotlib将默认为我们提供一个GUI窗口。我们将导入主Matplotlib模块并调用`use`函数。此函数必须在导入主`matplotlib`模块之后以及导入其他`matplotlib`模块之前立即调用：'
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Creating a Matplotlib canvas**: Non-interactive plots can be drawn on a Matplotlib
    canvas. Creating this canvas requires imports, a figure, and a subplot. We will
    specify the figure to be 3 by 3 inches large. More details can be found at the
    end of this recipe:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建Matplotlib画布**：非交互式图表可以绘制在Matplotlib画布上。创建此画布需要导入、一个图形和一个子图。我们将指定图形大小为3英寸乘以3英寸。更多详细信息可以在本食谱的末尾找到：'
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Plotting data**: In a non-interactive mode, plotting data is a bit more complicated
    than in the default mode. Since we need to plot repeatedly, it makes sense to
    organize the plotting code in a function. The plot is eventually drawn on the
    canvas. The canvas adds a bit of complexity to our setup. At the end of this example,
    you can find more detailed explanation of the functions:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绘图数据**：在非交互式模式下，绘图比默认模式复杂一些。由于我们需要重复绘图，将绘图代码组织在函数中是有意义的。图表最终绘制在画布上。画布给我们的设置增加了一些复杂性。在本例的末尾，您可以找到关于函数的更详细说明：'
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following screenshot shows the animation in action. You can also view a
    screencast on YouTube at [https://www.youtube.com/watch?v=t6qTeXxtnl4](https://www.youtube.com/watch?v=t6qTeXxtnl4).
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了动画的实际效果。您还可以在YouTube上观看一个屏幕录制视频，链接为[https://www.youtube.com/watch?v=t6qTeXxtnl4](https://www.youtube.com/watch?v=t6qTeXxtnl4)。
- en: '![How to do it...](img/2865OS_05.jpg)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/2865OS_05.jpg)'
- en: 'We get the following code after the changes:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改后，我们得到以下代码：
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The plotting-related functions are explained in this table:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本表中解释了与绘图相关的函数：
- en: '| Function | Description |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `matplotlib.use("Agg")` | This function specifies to use the non-interactive
    backend |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `matplotlib.use("Agg")` | 此函数指定使用非交互式后端 |'
- en: '| `plt.figure(figsize=[3, 3])` | This function creates a figure of 3 by 3 inches
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `plt.figure(figsize=[3, 3])` | 此函数创建一个3英寸乘以3英寸的图形 |'
- en: '| `fig.add_subplot(111)` | This function creates a subplot (in this case we
    only need 1 subplot) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `fig.add_subplot(111)` | 此函数创建一个子图（在这种情况下我们只需要一个子图） |'
- en: '| `agg.FigureCanvasAgg(fig)` | This function creates a canvas in non-interactive
    mode |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `agg.FigureCanvasAgg(fig)` | 此函数以非交互式模式创建一个画布 |'
- en: '| `ax.plot(data)` | This function creates a plot using specified data |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `ax.plot(data)` | 此函数使用指定数据创建一个图表 |'
- en: '| `canvas.draw()` | This function draws on the canvas |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `canvas.draw()` | 此函数在画布上绘制 |'
- en: '| `canvas.get_renderer()` | This function gets a renderer for the canvas |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `canvas.get_renderer()` | 此函数获取画布的渲染器 |'
- en: Accessing surface pixel data (Intermediate)
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问表面像素数据（中级）
- en: The Pygame `surfarray` module handles the conversion between Pygame `Surface`
    objects and NumPy arrays. As you may recall, NumPy can manipulate big arrays in
    a fast and efficient manner.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame `surfarray` 模块处理Pygame `Surface`对象和NumPy数组之间的转换。如您所回忆的，NumPy可以以快速和高效的方式操作大型数组。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe we will tile a small image to fill the game screen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用小图像填充游戏屏幕。
- en: '**Copying pixels to array**: The `array2d` function copies pixels into a two-dimensional
    array. There is a similar function for three-dimensional arrays. We will copy
    the pixels from the avatar image into an array:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将像素复制到数组中**：`array2d`函数将像素复制到二维数组中。还有一个类似的三维数组函数。我们将从头像图像中复制像素到一个数组中：'
- en: '[PRE32]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Creating the game screen**: A NumPy array has a shape attribute that corresponds
    to the dimensions of the array. This attribute is a tuple. A two-dimensional array
    for instance, will have a two-element shape tuple. Let''s create the game screen
    from the shape of the pixels array using the `shape` attribute of the array. The
    screen will be seven times larger in both directions:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建游戏屏幕**：NumPy数组有一个形状属性，对应于数组的维度。这个属性是一个元组。例如，一个二维数组将有一个包含两个元素的形状元组。让我们使用数组的`shape`属性从像素数组的形状创建游戏屏幕。屏幕在两个方向上都会大七倍：'
- en: '[PRE33]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Tiling the image**: Tiling the image is easy with the NumPy `tile` function.
    The data needs to be converted to integer values, since colors are defined as
    integers:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**平铺图像**：使用NumPy的`tile`函数平铺图像很容易。数据需要转换为整数值，因为颜色定义为整数：'
- en: '[PRE34]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Displaying the array**: The `surfarray` module has the following special
    function (`blit_array`) to display the array on the screen:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**显示数组**：`surfarray`模块有以下特殊函数（`blit_array`）用于在屏幕上显示数组：'
- en: '[PRE35]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following screenshot displays the result of the code:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了代码的结果：
- en: '![How to do it...](img/2865OS_06.jpg)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/2865OS_06.jpg)'
- en: 'The following code does the tiling of the image:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码执行图像平铺：
- en: '[PRE36]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The following table gives us a brief description of the new functions and attributes
    we used:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格简要描述了我们使用的新函数和属性：
- en: '| Function | Description |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pygame.surfarray.array2d(img)` | This copies pixel data into a 2D array
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.surfarray.array2d(img)` | 这将像素数据复制到一个二维数组中 |'
- en: '| `pixels.shape[0]` | The `shape` attribute holds the dimensions of a NumPy
    array as a tuple |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `pixels.shape[0]` | `shape`属性以元组的形式持有NumPy数组的维度 |'
- en: '| `numpy.tile(pixels, (7, 7))` | This tiles an array the given dimensions specified
    as a tuple |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.tile(pixels, (7, 7))` | 这将数组平铺到指定的维度，维度由元组指定 |'
- en: '| `pygame.surfarray.blit_array(screen, new_pixels)` | This displays array values
    on the screen |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.surfarray.blit_array(screen, new_pixels)` | 这将在屏幕上显示数组值 |'
- en: Accessing sound data (Simple)
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问声音数据（简单）
- en: A good game needs to have great music and sound effects. The Pygame `mixer`
    module lets us play a sound or any audio for that matter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一款好的游戏需要优秀的音乐和音效。Pygame的`mixer`模块让我们可以播放声音或任何音频。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will download a WAV audio file using standard Python. We will play this sound
    when the game quits. This example requires you to actually execute the example
    code, because this book has no audio support.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标准的Python下载WAV音频文件。当游戏退出时，我们将播放这个声音。这个例子要求你实际执行示例代码，因为这本书没有音频支持。
- en: '**Creating a sound object**: We can create a Pygame `Sound` object after specifying
    the name of the audio file. This class as you would expect embodies the concept
    of sounds:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建声音对象**：在指定音频文件名后，我们可以创建一个Pygame `Sound`对象。这个类正如你所期望的那样，体现了声音的概念：'
- en: '[PRE37]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Playing the sound**: The `Sound` object has a `play` method, which has a
    number of loops parameters. If the value of this parameter is set to -1, the sound
    will loop indefinitely:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**播放声音**：`Sound`对象有一个`play`方法，它有几个循环参数。如果这个参数的值设置为-1，声音将无限循环：'
- en: '[PRE38]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Pausing the game**: Sometimes we need to pause the execution of a game, as
    in our case in order to be able to hear a sound. We can do this with the following
    code snippet:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**暂停游戏**：有时我们需要暂停游戏的执行，就像在我们的例子中，以便能够听到声音。我们可以使用以下代码片段来完成：'
- en: '[PRE39]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The delay is specified in milliseconds, that's why we are multiplying by 1000.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 延迟以毫秒为单位指定，这就是为什么我们要乘以1000。
- en: '**Stopping the sound**: After a while we need to stop the sound with the corresponding
    `stop` method:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**停止声音**：过了一段时间后，我们需要使用相应的`stop`方法来停止声音：'
- en: '[PRE40]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The audio demo code is listed as follows:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 音频演示代码如下：
- en: '[PRE41]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The most important functions of this demo are summed up in the following table:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本演示最重要的函数总结如下表：
- en: '| Function | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pygame.mixer.Sound(WAV_FILE)` | This function creates a `Sound` object given
    a filename. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.mixer.Sound(WAV_FILE)` | 这个函数根据文件名创建一个`Sound`对象。 |'
- en: '| `audio.play(-1)` | This function plays and loops indefinitely (-1 means indefinitely).
    By default the sound is played only once. This corresponds with 0 loops. If the
    value is 2, the sound will be played once and then repeated 2 more times. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `audio.play(-1)` | 这个函数播放并无限循环（-1表示无限）。默认情况下，声音只播放一次。这对应于0次循环。如果值为2，声音将播放一次，然后重复播放2次。
    |'
- en: '| `pygame.time.delay(TIMEOUT * 1000)` | This function pauses the game for a
    specified number of milliseconds. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.time.delay(TIMEOUT * 1000)` | 此函数使游戏暂停指定的毫秒数。 |'
- en: '| `audio.stop()` | This function stops audio playback. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `audio.stop()` | 此函数停止音频播放。 |'
- en: Playing a movie (Intermediate)
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放电影（中级）
- en: Most commercial games these days have small movie clips that try to explain
    the plot to us. For instance, a first-person shooter could have a movie showing
    a briefing about the next mission. Movie playback is a cool feature to have. Pygame
    offers limited support for MPEG movies.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数商业游戏都有小电影片段，试图向我们解释剧情。例如，一款第一人称射击游戏可能有一个显示下一场任务简报的电影。电影播放是一个很酷的功能。Pygame为MPEG视频提供了有限的支持。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to have a MPEG movie for this demo. Once you have a movie you can convert
    it to be used in a Pygame game with the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个演示准备一个MPEG电影。一旦您有了电影，您可以使用以下命令将其转换为在Pygame游戏中使用：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Installing `ffmpeg` and the command-line options are outside the scope of this
    book, but shouldn't be too difficult (see [http://ffmpeg.org/](http://ffmpeg.org/)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`ffmpeg`和命令行选项超出了本书的范围，但不应太难（见[http://ffmpeg.org/](http://ffmpeg.org/)）。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The movie playback is set up similarly to the audio playback that we covered
    in the previous recipe. The following code demonstrates playing a MPEG video.
    Pay particular attention to the `play` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 电影播放的设置与我们在前一个菜谱中介绍的声音播放类似。以下代码演示了播放MPEG视频。请注意`play`函数：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The relevant functions for the movie playback can found in this table:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 电影播放的相关函数可以在以下表中找到：
- en: '| Function | Description |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pygame.movie.Movie(''out.mpg'')` | This function creates a `Movie` object
    given the filename of the MPEG movie |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.movie.Movie(''out.mpg'')` | 此函数根据MPEG电影的文件名创建一个`Movie`对象 |'
- en: '| `movie.play()` | This function starts playing the movie |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `movie.play()` | 此函数开始播放电影 |'
- en: '| `movie.stop()` | This function stops playback of the movie |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `movie.stop()` | 此函数停止电影的播放 |'
- en: Pygame on Android (Intermediate)
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pygame在Android上（中级）
- en: Android is an open source smartphone operating system initially developed by
    Google. Most of the Android apps are written in the Java programming language
    and run on a Java-based virtual machine. Fortunately, we can create Pygame games
    for Android phones. This is not a trivial matter and we will only cover the bare
    basics.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Android是一个由Google最初开发的开源智能手机操作系统。大多数Android应用程序是用Java编程语言编写的，并在基于Java的虚拟机上运行。幸运的是，我们可以为Android手机创建Pygame游戏。这不是一件小事，我们只会介绍最基本的内容。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will install the **Pygame Subset For Android** (**PGS4A**). You will need
    to have the JDK, Python 2.7 or a later version installed before we start. Download
    the appropriate software for your operating system from [http://pygame.renpy.org/dl](http://pygame.renpy.org/dl).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装**Pygame Subset For Android**（**PGS4A**）。在我们开始之前，您需要安装JDK、Python 2.7或更高版本。从[http://pygame.renpy.org/dl](http://pygame.renpy.org/dl)下载适合您操作系统的相应软件。
- en: 'To install the necessary software, we will require an Internet connection and
    quite a lot of room on your hard drive. If you don''t have a couple of gigabytes
    to spare, you may need to make more space. We can install the Android SDK and
    other software we will need such as Apache Ant by running the following command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装必要的软件，我们需要一个互联网连接和相当大的硬盘空间。如果您没有几个GB的空闲空间，您可能需要腾出更多空间。我们可以通过运行以下命令来安装Android
    SDK和其他我们将需要的软件，如Apache Ant：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will start a wizard that will guide you through the installation. It's
    safe to accept all the default options during the installation procedure, but
    you do have to generate a key. Unless you are really serious about creating apps,
    you don't have to worry how secure this key is.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个向导，引导您完成安装。在安装过程中，您可以接受所有默认选项，但您确实需要生成一个密钥。除非您真的认真对待创建应用程序，否则您不必担心这个密钥的安全性。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will create a simple game that prints "Hello World From Android!" and call
    it `mygame`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的游戏，打印"Hello World From Android!"，并将其命名为`mygame`。
- en: '**Setting up the game**: Create a directory with the same name as the name
    of the game and place a `main.py` file in there with the following contents:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置游戏**：创建一个与游戏名称相同的目录，并在其中放置一个包含以下内容的`main.py`文件：'
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is basically the code from the PGS4A website changed to print a welcome
    message. A more thorough explanation will be given at the end of the recipe.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这基本上是将PGS4A网站上的代码修改为打印欢迎信息的代码。更详细的解释将在食谱的末尾给出。
- en: '**Configuring the game**: We can configure the game with the following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置游戏**: 我们可以使用以下命令配置游戏：'
- en: '[PRE46]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We will accept all the defaults and set the storage setting to internal.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将接受所有默认设置并将存储设置设置为内部。
- en: '**Building, installing, and running the game**: Android is essentially a Java
    framework, so there is a lot of compiling involved. This is a bit different than
    in the Python world. Since this game is simple, building will not take that long.
    First we will start the emulator—this is an application that mimics the behavior
    of an actual phone. Find the `android` executable that is part of the Android
    SDK. Launch it and choose **Tools** | **Manage AVDs…** | **New…** in the GUI application
    that opens. Create an **Android Virtual Device** (**AVD**) and give it a name.
    Hit the **Launch…** button. A phone emulator will start. If it is locked, you
    can unlock it by pressing *F2*.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建、安装和运行游戏**: Android本质上是一个Java框架，因此涉及大量的编译。这和Python世界有点不同。由于这个游戏很简单，构建不会花费很长时间。首先，我们将启动模拟器——这是一个模拟实际手机行为的程序。找到Android
    SDK中的`android`可执行文件。启动它，在打开的GUI应用程序中选择**工具** | **管理AVD...** | **新建...**。创建一个**Android虚拟设备**（**AVD**）并给它命名。点击**启动...**按钮。一个手机模拟器将启动。如果它被锁定，你可以按*F2*解锁。'
- en: 'We can now build and install the game with the command:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令构建和安装游戏：
- en: '[PRE47]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The relevant functions used in this code are described as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中使用的相关函数描述如下：
- en: '| Function | Description |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `android.init()` | This function initializes Android |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `android.init()` | 此函数初始化Android |'
- en: '| `android.map_key(android.KEYCODE_BACK, pygame.K_ESCAPE)` | This function
    maps the Android back button to the Pygame escape button |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `android.map_key(android.KEYCODE_BACK, pygame.K_ESCAPE)` | 此函数将Android返回按钮映射到Pygame的escape按钮
    |'
- en: '| `pygame.time.set_timer(TIMEREVENT, 1000 / FPS)` | This function fires events
    at specified time intervals given in milliseconds |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.time.set_timer(TIMEREVENT, 1000 / FPS)` | 此函数在指定的毫秒时间间隔内触发事件 |'
- en: '| `android.check_pause()` | This function checks for a pause request |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `android.check_pause()` | 此函数检查暂停请求 |'
- en: '| `android.wait_for_resume()` | This function puts the game in sleep mode |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `android.wait_for_resume()` | 此函数将游戏置于睡眠模式 |'
- en: Artificial intelligence (Intermediate)
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能（中级）
- en: Often we need to mimic intelligent behavior within a game. The `scikits-learn`
    project aims to provide an API for Machine Learning. What I like most about it
    is the amazing documentation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们经常需要模拟智能行为。`scikits-learn`项目旨在提供机器学习的API。我最喜欢它的地方是它惊人的文档。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'We can install `scikit-learn` by typing the following command at the command
    line:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在命令行中输入以下命令来安装`scikit-learn`：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Or:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This might not work because of permissions, so you might need to put `sudo`
    in front of the commands or log in as admin.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能因为权限问题而无法工作，因此你可能需要在命令前加上`sudo`或者以管理员身份登录。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will generate some random points and cluster them, which means that points
    that are close to each other are put in the same cluster. This is only one of
    the many techniques that you can apply with `scikits-learn`. **Clustering** is
    a type of machine learning algorithm that aims to group items based on similarities.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成一些随机点并将它们聚类，这意味着彼此靠近的点将被放入同一个聚类中。这是你可以使用`scikits-learn`应用到的许多技术之一。**聚类**是一种旨在根据相似性对项目进行分组的机器学习算法。
- en: '**Generating random points**: We will generate 30 random point positions within
    a square of 400 by 400 pixels:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成随机点**: 我们将在一个400像素乘400像素的正方形内生成30个随机点位置：'
- en: '[PRE50]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Calculating the affinity matrix**: We will use the Euclidean distance to
    the origin as the **affinity metric**. The affinity matrix is a matrix holding
    affinity scores, in this case distances:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算亲和矩阵**: 我们将使用到原点的欧几里得距离作为**亲和度度量**。亲和矩阵是一个包含亲和度分数的矩阵，在这种情况下是距离：'
- en: '[PRE51]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Clustering the points**: Give the `AffinityPropagation` class the result
    from the previous step. This class labels the points with the appropriate cluster
    number:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**聚类点**: 将上一步的结果传递给`AffinityPropagation`类。此类将点标记为适当的聚类编号：'
- en: '[PRE52]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Drawing polygons**: We will draw polygons for each cluster. The function
    involved requires a list of points, a color (let''s paint it red), and a surface:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绘制多边形**：我们将为每个簇绘制多边形。涉及到的函数需要一个点的列表、一个颜色（让我们将其涂成红色），和一个表面：'
- en: '[PRE53]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result is a bunch of polygons for each cluster as shown in the following
    screenshot:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果是每个簇都有一组多边形，如下面的截图所示：
- en: '![How to do it...](img/2865OS_08.jpg)'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/2865OS_08.jpg)'
- en: 'The clustering example code is shown as follows:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 簇示例代码如下所示：
- en: '[PRE54]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The most important lines in the artificial intelligence recipe are described
    in more detail in the following table:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能配方中最重要的一行在以下表格中描述得更为详细：
- en: '| Function | Description |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `numpy.random.randint(0, 400, size=(30, 2))` | This creates an array of 30
    by 2 random integers. This corresponds to 30 points in two-dimensional space.
    The values are between 0 and 400. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.random.randint(0, 400, size=(30, 2))` | 这创建了一个 30 行 2 列的随机整数数组。这对应于二维空间中的
    30 个点。值在 0 到 400 之间。|'
- en: '| `numpy.sum(positions ** 2, axis=1)` | This sums an array of the square of
    the positions array. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.sum(positions ** 2, axis=1)` | 这计算了位置数组平方的数组之和。|'
- en: '| `numpy.dot(positions, positions.T)` | This computes the dot product of the
    positions array and its transpose. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.dot(positions, positions.T)` | 这计算了位置数组和其转置的点积。|'
- en: '| `sklearn.cluster.AffinityPropagation().fit(S)` | This creates an `AffinityPropagation`
    object and performs a fit using an affinity matrix. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `sklearn.cluster.AffinityPropagation().fit(S)` | 这创建了一个 `AffinityPropagation`
    对象并使用亲和矩阵进行拟合。|'
- en: '| `pygame.draw.polygon(screen, (255, 0, 0), polygon_points[i])` | This draws
    a polygon given a surface, a color (red in this case), and a list of points. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.draw.polygon(screen, (255, 0, 0), polygon_points[i])` | 这根据一个表面、一个颜色（在这种情况下是红色）和一系列点绘制一个多边形。|'
- en: Drawing sprites (Intermediate)
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制精灵（中级）
- en: '**Sprite** is a term from computer graphics meaning a two-dimensional visible
    object, that has been optimized for rendering. Pygame offers the `Sprite` class
    that deals with sprites. It can draw sprites on a `Surface` object. It also has
    collision functions. For complex games, we can group sprites together for easy
    management. Sprites are not thread safe, so you should take care when using multiple
    threads.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵**是计算机图形学中的一个术语，指的是一个二维的可视对象，它已经被优化用于渲染。Pygame 提供了处理精灵的 `Sprite` 类。它可以在
    `Surface` 对象上绘制精灵。它还具有碰撞函数。对于复杂的游戏，我们可以将精灵分组在一起以便于管理。精灵不是线程安全的，所以在使用多个线程时你应该小心。'
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will redo the animation demo, but this time with sprites and using `Rect`
    objects, which represent rectangles. A `Rect` object has `left`, `top`, `width`,
    and `height` attributes. We will use these and other attributes throughout the
    example. Also we will let the avatar spin when the mouse button is clicked. However,
    we will not care for now where we click exactly.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新做动画演示，但这次使用精灵和 `Rect` 对象，这些对象代表矩形。一个 `Rect` 对象有 `left`、`top`、`width` 和
    `height` 属性。我们将在整个示例中使用这些和其他属性。此外，当鼠标按钮被点击时，我们将让角色旋转。然而，我们现在不会关心我们确切点击了哪里。
- en: We will create a class that extends the `Sprite` class. Sprite classes have
    an `update` method which fires for each frame. All logic involving the movement
    of the sprite should be placed here.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个扩展 `Sprite` 类的类。精灵类有一个 `update` 方法，它在每一帧都会触发。所有涉及精灵移动的逻辑都应该放在这里。
- en: '**Constructor**: First, we need to create the sprite and perform subclassing.
    All the initialization logic goes here. Further details for the functions can
    be found in the next section. We define an image, rectangle, and variables tracking
    the movement of the avatar:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构造函数**：首先，我们需要创建精灵并执行子类化。所有的初始化逻辑都放在这里。有关函数的更多详细信息可以在下一节中找到。我们定义了一个图像、矩形，以及跟踪角色移动的变量：'
- en: '[PRE55]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**The update method**: The `update` method calls helper methods that either
    cause the head to spin or move it in clockwise direction. The movement is achieved
    with this line:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新方法**：`update` 方法调用辅助方法，这些方法要么使头部旋转，要么按顺时针方向移动它。移动是通过以下行实现的：'
- en: '[PRE56]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following line take care of the rotation:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下行负责旋转：
- en: '[PRE57]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'You can find a short clip of the game on YouTube ([https://www.youtube.com/watch?v=EFQlc_siPrI](https://www.youtube.com/watch?v=EFQlc_siPrI)).
    A screenshot of the game is shown as follows:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 YouTube 上找到一个游戏的短片 ([https://www.youtube.com/watch?v=EFQlc_siPrI](https://www.youtube.com/watch?v=EFQlc_siPrI))。以下是一个游戏的截图：
- en: '![How to do it...](img/2865OS_09.jpg)'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/2865OS_09.jpg)'
- en: 'The complete code of the Sprite demo is listed as follows:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是 Sprite 演示的完整代码列表：
- en: '[PRE58]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'A more in-depth description of the various functions used in this demo is given
    as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对本演示中使用的各种函数的更详细描述：
- en: '| Function | Description |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pygame.sprite.Sprite.__init__(self)` | This creates sprites. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.sprite.Sprite.__init__(self)` | 这将创建精灵。|'
- en: '| `screen.get_rect()` | This gets a `Rect` object. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `screen.get_rect()` | 这将获取一个 `Rect` 对象。|'
- en: '| `pygame.display.get_surface()` | This gets a `Surface` object. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.display.get_surface()` | 这将获取一个 `Surface` 对象。|'
- en: '| `self.rect.move((self.xstep, self.ystep))` | This moves a rectangle given
    a `x` and `y` coordinate. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `self.rect.move((self.xstep, self.ystep))` | 这将根据 `x` 和 `y` 坐标移动一个矩形。|'
- en: '| `pygame.transform.rotate(self.original, self.degrees)` | This rotates an
    image given a `Surface` object and angle in degrees. Positive values correspond
    with counter clockwise rotation, negative with clockwise rotation. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.transform.rotate(self.original, self.degrees)` | 这将根据一个 `Surface`
    对象和角度（以度为单位）旋转一个图像。正值对应逆时针旋转，负值对应顺时针旋转。|'
- en: '| `self.image.get_rect(center=center)` | This gets the rectangle for the image
    given its center coordinates. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `self.image.get_rect(center=center)` | 这将根据图像的中心坐标获取矩形。|'
- en: '| `pygame.sprite.RenderPlain(head)` | This renders the sprite. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.sprite.RenderPlain(head)` | 这将渲染精灵。|'
- en: Using OpenGL with Pygame (Advanced)
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pygame 和 OpenGL（高级）
- en: OpenGL specifies an API for 2D and 3D computer graphics. The API consists of
    functions and constants. We will be concentrating on the Python implementation
    called **PyOpenGL**.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 为 2D 和 3D 计算机图形指定了一个 API。该 API 由函数和常量组成。我们将专注于名为 **PyOpenGL** 的 Python
    实现。
- en: Getting ready
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install PyOpenGL with the following command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装 PyOpenGL：
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You might need to have root access to execute this command. The corresponding
    `easy_install` command is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要具有 root 权限才能执行此命令。相应的 `easy_install` 命令如下：
- en: '[PRE60]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How to do it...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: For the purpose of demonstration we will draw a Sierpinski gasket with OpenGL.
    This is a fractal pattern in the shape of a triangle created by the mathematician
    Waclaw Sierpinski. The triangle is obtained via a recursive and in principle infinite
    procedure.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将使用 OpenGL 绘制 Sierpinski 网格。这是由数学家 Waclaw Sierpinski 创建的三角形形状的分形模式。通过递归和原则上无限的过程获得三角形。
- en: '**OpenGL Initialization**: First, we will start out by initializing some of
    the OpenGL-related primitives. This includes setting the display mode and background
    color. A line-by-line explanation is given at the end of the recipe:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**OpenGL 初始化**：首先，我们将初始化一些与 OpenGL 相关的原始数据。这包括设置显示模式和背景颜色。在食谱的末尾给出了逐行解释：'
- en: '[PRE61]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Displaying points**: The algorithm requires us to display points, the more
    the better. First, we set the drawing color to red. Second, we define the vertices
    (I call them points myself) of a triangle. Then we define random indices, which
    are to be used to choose one of the three triangle vertices. We pick a random
    point somewhere in the middle, it doesn''t really matter where. After that we
    draw points halfway between the previous point and one of the vertices picked
    at random. Finally, we "flush" the result:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**显示点**：算法要求我们显示点，越多越好。首先，我们将绘图颜色设置为红色。其次，我们定义三角形的顶点（我自己称它们为点）。然后我们定义随机索引，这些索引将用于选择三个三角形顶点中的一个。我们在中间某个地方随机选择一个点，实际上并不重要。之后，我们在前一个点和随机选择的顶点之间绘制一个中点。最后，我们“刷新”结果：'
- en: '[PRE62]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The Sierpinski triangle looks like this:'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Sierpinski 三角形看起来是这样的：
- en: '![How to do it...](img/2865OS_10.jpg)'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/2865OS_10.jpg)'
- en: 'The full Sierpinski gasket demo code with all the imports is shown as follows:'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下展示了包含所有导入的完整 Sierpinski 网格演示代码：
- en: '[PRE63]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'As promised here is a line-by-line explanation of the most important parts
    of the example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如承诺，以下是示例中最重要的部分的逐行解释：
- en: '| Function | Description |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pygame.display.set_mode((w,h), pygame.OPENGL&#124;pygame.DOUBLEBUF)` | This
    sets the display mode to the required width, height, and OpenGL display. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.display.set_mode((w,h), pygame.OPENGL | pygame.DOUBLEBUF)` | 这将设置显示模式为所需的宽度、高度和
    OpenGL 显示。|'
- en: '| `glClear(GL_COLOR_BUFFER_BIT&#124;GL_DEPTH_BUFFER_BIT)` | This clears the
    buffers using a mask. Here we clear the color buffer and depth buffer bits. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)` | 这使用一个掩码清除缓冲区。在这里，我们清除颜色缓冲区和深度缓冲区位。|'
- en: '| `gluOrtho2D(0, w, 0, h)` | This defines a 2D orthographic projection matrix
    with the coordinates of the left, right, top, and bottom clipping planes. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `gluOrtho2D(0, w, 0, h)` | 这定义了一个2D正交投影矩阵，其中包含左、右、上、下裁剪平面的坐标。 |'
- en: '| `glColor3f(1.0, 0, 0)` | This defines the current drawing color using three
    float values for RGB (0-1 instead of 0-255 that is usual for Pygame). In this
    case we will be painting in red. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `glColor3f(1.0, 0, 0)` | 这使用三个浮点值定义当前绘图颜色，用于RGB（0-1，而不是Pygame中常用的0-255）。在这种情况下，我们将用红色进行绘制。
    |'
- en: '| `glBegin(GL_POINTS)` | This delimits the vertices of primitives or a group
    of primitives. Here the primitives are points. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `glBegin(GL_POINTS)` | 这定义了原语或一组原语的顶点。在这里，原语是点。 |'
- en: '| `glVertex2fv(point)` | This renders a point given a vertex. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `glVertex2fv(point)` | 这用于根据顶点渲染一个点。 |'
- en: '| `glEnd()` | This closes a section of code started with `glBegin`. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `glEnd()` | 这关闭了由`glBegin`开始的代码部分。 |'
- en: '| `glFlush()` | This forces execution of GL commands. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `glFlush()` | 这强制执行GL命令。 |'
- en: Detecting collisions (Intermediate)
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞（中级）
- en: In the sprite demo, we left out the collision detection bit. Pygame has a number
    of useful collision detection functions in the `Rect` class. For instance, we
    can check whether a point is in a rectangle or whether two rectangles overlap.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在精灵演示中，我们省略了碰撞检测部分。Pygame的`Rect`类中有许多有用的碰撞检测函数。例如，我们可以检查一个点是否在矩形内，或者两个矩形是否重叠。
- en: How to do it...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Beside the collision detection we will replace the mouse cursor with an image
    of a hammer that we created. It's not a very pretty image, but it beats the boring
    old cursor.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 除了碰撞检测，我们还将用我们创建的锤子图像替换鼠标光标。这不是一个非常漂亮的图像，但比无聊的旧光标要好。
- en: '**Updating the hit method**: We will update the `hit` method of the sprite
    demo code. In the new version, we check whether the mouse cursor is within the
    avatar sprite. Actually to make it easier to hit the head, we create a slightly
    bigger rectangle:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新击中方法**：我们将更新精灵演示代码中的`hit`方法。在新版本中，我们检查鼠标光标是否在头像精灵内。实际上为了更容易击中头部，我们创建了一个稍微大一点的矩形：'
- en: '[PRE64]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Replacing the mouse cursor**: All the steps necessary to replace the mouse
    cursor were already covered. Except making the mouse cursor invisible:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**替换鼠标光标**：替换鼠标光标的所有必要步骤都已经介绍过了。除了使鼠标光标不可见：'
- en: '[PRE65]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A screenshot of the game is shown as follows:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 游戏的截图如下所示：
- en: '![How to do it...](img/2865OS_11.jpg)'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/2865OS_11.jpg)'
- en: The complete code for this example can be found in the code bundle of this book.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的完整代码可以在本书的代码包中找到。
- en: How it works...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We learned a bit about collision detection, the mouse cursor, and rectangles
    in this recipe:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们了解了一些关于碰撞检测、鼠标光标和矩形的知识：
- en: '| Function | Description |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pygame.mouse.get_pos()` | This gets the mouse position as a tuple. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.mouse.get_pos()` | 这以元组的形式获取鼠标位置。 |'
- en: '| `self.rect.inflate(40, 40)` | This creates a bigger rectangle based on an
    offset. If the offset is negative this results in a smaller rectangle. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `self.rect.inflate(40, 40)` | 这基于偏移量创建一个更大的矩形。如果偏移量是负数，这将导致一个更小的矩形。 |'
- en: '| `bigger_rect.collidepoint(mouse_x, mouse_y)` | This checks whether a point
    is within a rectangle. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `bigger_rect.collidepoint(mouse_x, mouse_y)` | 这检查一个点是否在矩形内。 |'
- en: '| `pygame.mouse.set_visible(False)` | This hides the mouse cursor. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.mouse.set_visible(False)` | 这隐藏了鼠标光标。 |'
- en: Adding networking functionality (Advanced)
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加网络功能（高级）
- en: Games become more engaging when you are able to play against other people. Usually
    this means playing over the Internet using some sort of client-server architecture.
    In the Python world, Twisted is commonly used for this kind of architecture.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当你能够与其他人一起玩游戏时，游戏会变得更加有趣。通常这意味着通过某种客户端-服务器架构在互联网上玩游戏。在Python世界中，Twisted通常用于这种架构。
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Twisted can be installed in several ways depending on your operating system.
    For more information see [https://twistedmatrix.com/trac/wiki/Downloads](https://twistedmatrix.com/trac/wiki/Downloads).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Twisted可以根据您的操作系统以多种方式安装。更多信息请参阅[https://twistedmatrix.com/trac/wiki/Downloads](https://twistedmatrix.com/trac/wiki/Downloads)。
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Unfortunately, we cannot create a massive multiplayer game in this tutorial,
    but we can create a simple client-server setup, which will lay the foundations
    for a puzzle we will create in a later recipe.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我们无法在这个教程中创建一个大型多人游戏，但我们可以创建一个简单的客户端-服务器设置，这将为我们稍后要创建的谜题奠定基础。
- en: '**The server**: First, we will set up the server, which will echo the message
    from the client and prepend it with a sequence number:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器**：首先，我们将设置服务器，它将回显客户端的消息并在其前面添加一个序列号：'
- en: '[PRE66]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see the server runs on port 8888 over TCP (see [http://en.wikipedia.org/wiki/Transmission_Control_Protocol](http://en.wikipedia.org/wiki/Transmission_Control_Protocol)).
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，服务器在 TCP 上运行在端口 8888（见 [http://en.wikipedia.org/wiki/Transmission_Control_Protocol](http://en.wikipedia.org/wiki/Transmission_Control_Protocol)）。
- en: '**Client setup**: The client sends messages over the same port as the server
    and also shows the messages from the server in a Pygame GUI. We will go over the
    details in the next section. In a later example we will do more interesting things
    with this code:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端设置**：客户端通过与服务器相同的端口发送消息，并在 Pygame GUI 中显示来自服务器的消息。我们将在下一节中详细介绍。在后面的示例中，我们将使用此代码做更多有趣的事情：'
- en: '[PRE67]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We need to start the server, before we can start the client. In the game GUI,
    you should see **Hello** being displayed followed by **1 IMPORTANT MESSAGE!**
    to **19 IMPORTANT MESSAGE!** as shown in the following screenshot:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们可以启动客户端之前，我们需要启动服务器。在游戏 GUI 中，您应该看到 **Hello** 被显示，然后是 **1 重要消息**！到 **19 重要消息**！，如下截图所示：
- en: '![How to do it...](img/2865OS_12.jpg)'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/2865OS_12.jpg)'
- en: How it works...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We saw in this example how to create a simple server and client with a Pygame
    GUI. In principle, we can now extend this setup to create a multiplayer game.
    The details of the Twisted client and server setup are given as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们看到了如何使用 Pygame GUI 创建一个简单的服务器和客户端。原则上，我们现在可以扩展这个设置来创建一个多人游戏。以下给出了 Twisted
    客户端和服务器设置的详细信息：
- en: '| Function | Description |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `self.transport.write("%d %s" % (self.count, msg))` | This writes a message.
    In this case we are prepending a sequence number to the message. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `self.transport.write("%d %s" % (self.count, msg))` | 这写入了一条消息。在这种情况下，我们在消息前面添加了一个序列号。
    |'
- en: '| `factory = protocol.ServerFactory()` | This creates a Twisted server factory,
    which itself creates Twisted servers. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `factory = protocol.ServerFactory()` | 这创建了一个 Twisted 服务器工厂，它本身创建 Twisted
    服务器。 |'
- en: '| `reactor.listenTCP(8888,factory)` | This listens to port 8888 using the given
    factory. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `reactor.listenTCP(8888,factory)` | 这使用给定的工厂监听端口 8888。 |'
- en: '| `reactor.run()` | This starts the server or client. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `reactor.run()` | 这将启动服务器或客户端。 |'
- en: '| `reactor.stop()` | This stops the client or server. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `reactor.stop()` | 这停止客户端或服务器。 |'
- en: '| `reactor.callLater(i * .1, p.sendMessage, "IMPORTANT MESSAGE!")` | This registers
    a callback function with a parameter to be executed after a specified time in
    seconds. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `reactor.callLater(i * .1, p.sendMessage, "IMPORTANT MESSAGE!")` | 这注册了一个在指定秒数后执行的带有参数的回调函数。
    |'
- en: '| `protocol.ClientCreator(reactor, Client)` | This creates a Twisted client.
    |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `protocol.ClientCreator(reactor, Client)` | 这创建了一个 Twisted 客户端。 |'
- en: '| `c.connectTCP("localhost", 8888).addCallback(send)` | This connects the client
    via TCP on port 8888 and registers a callback function. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `c.connectTCP("localhost", 8888).addCallback(send)` | 这通过 TCP 在端口 8888 上连接客户端并注册了一个回调函数。
    |'
- en: Debugging your game (Intermediate)
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试游戏（中级）
- en: Debugging is one of those things that nobody really likes, but is very important
    to master. It can take hours, and because of Murphy's law you, most likely, don't
    have that time. Therefore, it is important to be systematic and know your tools
    well. After you are done finding the bug and implementing a fix, you should have
    a test in place. This way at least you will not have to go through the hell of
    debugging again.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是那些没有人真正喜欢，但非常重要需要掌握的事情之一。它可能需要数小时，而且由于墨菲定律，您很可能没有那么多时间。因此，有系统性和熟悉您的工具非常重要。在您找到错误并实施修复后，您应该有一个测试。这样至少您将不必再次经历调试的地狱。
- en: PuDB is a visual full screen, console-based Python debugger that is easy to
    install. PuDB supports cursor keys and vi commands. The debugger can also be integrated
    with IPython, if required.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: PuDB 是一个易于安装的基于控制台的全屏 Python 调试器。PuDB 支持 cursor 键和 vi 命令。如果需要，调试器还可以与 IPython
    集成。
- en: Getting ready
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to install puDB, we only need to execute the following command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装 puDB，我们只需要执行以下命令：
- en: '[PRE68]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How to do it...
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To debug the collision demo code, type the following command on the command
    line:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试碰撞演示代码，请在命令行中输入以下命令：
- en: '[PRE69]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Tip
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The source code should be available for download from the Packt Publishing website.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以从 Packt Publishing 网站下载。
- en: 'The following screenshot shows the most important debugging commands at the
    top:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了最重要的调试命令在顶部：
- en: '![How to do it...](img/2865OS_13.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2865OS_13.jpg)'
- en: We can also see the code being debugged, variables, the stack, and the defined
    breakpoints. Typing `q` exits most menus. Typing `n` moves the debugger to the
    next line. We can also move with the cursor keys or vi *J* and *K* keys to, for
    instance, set a breakpoint by typing `b`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到正在调试的代码、变量、堆栈和定义的断点。输入 `q` 退出大多数菜单。输入 `n` 将调试器移动到下一行。我们还可以使用光标键或 vi 的
    *J* 和 *K* 键进行移动，例如，通过输入 `b` 来设置断点。
- en: Profiling your code (Intermediate)
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析您的代码（中级）
- en: Performance is important for games, luckily there are many Python profiling
    tools. Profiling is about building a profile of a software program in order to
    collect information about memory usage or time complexity.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 性能对游戏来说很重要，幸运的是，有很多Python性能分析工具。性能分析是关于构建一个软件程序的配置文件，以便收集有关内存使用或时间复杂度的信息。
- en: '`cProfile` is a C extension introduced in Python 2.5\. It can be used for **deterministic
    profiling**. Deterministic profiling means that the time measurements are precise
    and no sampling is used. Contrast this with statistical profiling, where measurements
    come from random samples.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile` 是 Python 2.5 中引入的一个 C 扩展。它可以用于 **确定性性能分析**。确定性性能分析意味着时间测量是精确的，没有使用采样。与统计性能分析相对比，后者来自随机样本。'
- en: How to do it...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps will help you profile your code:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您性能分析您的代码：
- en: '**Creating a profile file**: We will profile the collision demo code and store
    the profile output in a file as follows:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建配置文件**：我们将对碰撞演示代码进行性能分析，并将性能分析输出存储在以下文件中：'
- en: '[PRE70]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '**The pstats browser**: After creating the file, we can view and sort the data
    in a special command-line browser:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**pstats 浏览器**：创建文件后，我们可以在特殊的命令行浏览器中查看和排序数据：'
- en: '[PRE71]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '**Getting help**: Being able to get help is always a good thing, just type
    the following commands at the command line:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取帮助**：能够获取帮助总是一件好事，只需在命令行中输入以下命令：'
- en: '[PRE72]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**Sorting**: We can sort with the following `sort` command:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排序**：我们可以使用以下 `sort` 命令进行排序：'
- en: '[PRE73]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '**Top 3 called functions**: We can get the top 3 called functions by sorting
    and calling `stats`:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**前三个被调用的函数**：我们可以通过排序和调用 `stats` 来获取前三个被调用的函数：'
- en: '[PRE74]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We profiled the collision demo. The following table summarizes the profiler
    output:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对碰撞演示进行了性能分析。以下表格总结了性能分析器的输出：
- en: '| Column | Description |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 描述 |'
- en: '| --- | --- |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Ncalls` | Number of calls |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `Ncalls` | 调用次数 |'
- en: '| `Tottime` | Total time spent in a function |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `Tottime` | 函数中花费的总时间 |'
- en: '| `Percall` | Time per call, calculated by dividing the total time by the calls
    count |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `Percall` | 每次调用的耗时，通过将总耗时除以调用次数计算得出 |'
- en: '| `Cumtime` | Cumulative time spent in function and functions called by the
    function, including recursive calls |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `Cumtime` | 函数及其被调用的函数所花费的累积时间，包括递归调用 |'
- en: Puzzle game with Pygame (Advanced)
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pygame 的拼图游戏（高级）
- en: We will pick up where we left in the networking example. This time we will create
    a puzzle game that lets us guess a word. This is just a prototype mind you. It
    still needs a lot of polishing.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在网络示例中继续进行。这次我们将创建一个拼图游戏，允许我们猜测一个单词。请注意，这只是一个原型。它还需要很多润色。
- en: How to do it...
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps will help you to create the intended puzzle game:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您创建所需的拼图游戏：
- en: '**Server changes**: The changes in the server are pretty trivial. We just check
    whether we guessed the correct word:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器更改**：服务器中的更改相当简单。我们只是检查我们是否猜对了单词：'
- en: '[PRE75]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '**Client changes**: The most important changes are the handling of key presses
    in an input box and handling of the response from the server. The input box lets
    us type text, edit it with the *Backspace* key, and submit with the *Enter* key.
    A label above the textbox displays the number of attempts and the game status.
    We use a Twisted looping callback to update the GUI every 30 milliseconds:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端更改**：最重要的更改是处理输入框中的按键以及处理来自服务器的响应。输入框允许我们输入文本，使用 *退格* 键编辑它，并使用 *回车* 键提交。文本框上方的标签显示尝试次数和游戏状态。我们使用
    Twisted 循环回调每30毫秒更新GUI：'
- en: '[PRE76]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The following screenshot was taken after guessing the word:'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图是在猜出单词后的截图：
- en: '![How to do it...](img/2865OS_14.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2865OS_14.jpg)'
- en: How it works...
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Although this seems to be a pretty extensive recipe, only a few lines of the
    code might require some explanation:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这似乎是一个相当详尽的配方，但可能只有几行代码需要一些解释：
- en: '| Function | Description |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LoopingCall(handle_events, p)` | This creates a looping callback. A callback
    function that is called periodically. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `LoopingCall(handle_events, p)` | 这创建了一个循环回调。一个定期被调用的回调函数。 |'
- en: '| `tick.start(.03)` | This starts the looping callback with a period of 30
    milliseconds. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `tick.start(.03)` | 这以 30 毫秒的周期启动循环回调。 |'
- en: Simulating with Pygame (Advanced)
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pygame 模拟（高级）
- en: As the last example, we will simulate life with Conway's Game of Life. The original
    game of life is based on a few basic rules. We start out with a random configuration
    on a two-dimensional square grid. Each cell in the grid can be either dead or
    alive. This state depends on the eight neighbors of the cell. Convolution can
    be used to evaluate the basic rules of the game. We will need the SciPy package
    for the convolution bit.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个例子，我们将使用康威的生命游戏来模拟生命。原始的生命游戏基于一些基本规则。我们从二维正方形网格上的随机配置开始。网格中的每个单元格可以是死的或活的。这个状态取决于单元格的八个邻居。卷积可以用来评估游戏的基本规则。我们将需要
    SciPy 包来进行卷积部分。
- en: Getting ready
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install SciPy with either of the following two commands:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下任意一个命令安装 SciPy：
- en: '`sudo pip install scipy`'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo pip install scipy`'
- en: '`easy_install scipy`'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`easy_install scipy`'
- en: How to do it...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following code is an implementation of Game of Life with some modifications:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是带有一些修改的生命的游戏实现：
- en: Clicking once with the mouse draws a cross until we click again
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击鼠标一次会画一个十字直到再次点击
- en: The *R* key resets the grid to a random state
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按 *R* 键将网格重置为随机状态
- en: Pressing *B* creates blocks based on the mouse position
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按 *B* 键根据鼠标位置创建方块
- en: '*G* creates gliders'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*G* 创建滑翔机'
- en: 'The most important data structure in the code is a two-dimensional array holding
    the color values of the pixels on the game screen. This array is initialized with
    random values and then recalculated in the game loop. More information about the
    involved functions can be found in the next section. As previously mentioned,
    the following is the code:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最重要的数据结构是一个二维数组，它存储游戏屏幕上像素的颜色值。这个数组以随机值初始化，然后在游戏循环中重新计算。有关涉及函数的更多信息，请参阅下一节。如前所述，以下代码如下：
- en: '[PRE77]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should be able to view a screencast on YouTube at [https://www.youtube.com/watch?v=NNsU-yWTkXM](https://www.youtube.com/watch?v=NNsU-yWTkXM).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 YouTube 上观看一个屏幕录像，链接为 [https://www.youtube.com/watch?v=NNsU-yWTkXM](https://www.youtube.com/watch?v=NNsU-yWTkXM)。
- en: 'A screenshot of the game in action is shown as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏动作的截图如下所示：
- en: '![How to do it...](img/2865OS_15.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2865OS_15.jpg)'
- en: How it works...
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We used some NumPy and SciPy functions that need explaining:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些需要解释的 NumPy 和 SciPy 函数：
- en: '| Function | Description |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ndimage.convolve(arr, weights, mode=''wrap'')` | This applies the convolve
    operation on the given array, using weights in wrap mode. The mode has to do with
    the array borders. See [http://en.wikipedia.org/wiki/Convolution](http://en.wikipedia.org/wiki/Convolution)
    for the mathematical details. |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `ndimage.convolve(arr, weights, mode=''wrap'')` | 这在给定数组上应用卷积操作，使用 wrap 模式中的权重。模式与数组边界有关。有关数学细节，请参阅[http://en.wikipedia.org/wiki/Convolution](http://en.wikipedia.org/wiki/Convolution)。
    |'
- en: '| `bools.astype(int)` | This converts the array of Booleans to integers. |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `bools.astype(int)` | 这将布尔数组转换为整数。 |'
- en: '| `numpy.arange(0, pos[0], 10)` | This creates an array from `0` to `pos[0]`
    in steps of 10\. So if `pos[0]` is equal to 1000, we will get 0, 10, 20 … 990.
    |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.arange(0, pos[0], 10)` | 这创建了一个从 `0` 到 `pos[0]` 的数组，步长为 10。所以如果 `pos[0]`
    等于 1000，我们将得到 0, 10, 20 … 990。 |'
