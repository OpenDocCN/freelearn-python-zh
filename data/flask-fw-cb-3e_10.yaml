- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Debugging, Error Handling, and Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试、错误处理和测试
- en: So far in this book, we have concentrated on developing applications and adding
    features to them one at a time. It is very important to know how robust our application
    is and to keep track of how it has been working and performing. This, in turn,
    gives rise to the need to be informed when something goes wrong in the application.
    It is normal to miss out on certain edge cases while developing the application,
    and usually, even the test cases miss them out. It would be great to know about
    these edge cases whenever they occur so that they can be handled accordingly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们一直专注于开发和为它们逐个添加功能的应用程序。了解我们的应用程序有多稳健，以及跟踪它的运行和性能情况非常重要。这反过来又产生了在应用程序出现问题时得到通知的需求。在开发应用程序时，遗漏某些边缘情况是正常的，通常，测试用例也会遗漏它们。如果能在它们出现时了解这些边缘情况，以便相应地处理它们，那就太好了。
- en: Effective logging and the ability to debug quickly are a couple of the deciding
    factors when choosing a framework for application development. The better the
    logging and debugging support from the framework, the quicker the process of application
    development and maintenance is. A better level of logging and debugging support
    helps developers quickly find out the issues in the application, and on many occasions,
    logging points out issues even before they are identified by end users. Effective
    error handling plays an important role in end user satisfaction and eases the
    pain of debugging at the developer’s end. Even if its code is perfect, the application
    is bound to throw errors at times. Why? The answer is simple – the code might
    be perfect, but the world in which it works is not. There can be innumerable issues
    that can occur, and as developers, we always want to know the reason behind any
    anomaly. Writing test cases along with the application is one of the most important
    pillars of software writing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的日志记录和快速调试的能力是选择应用程序开发框架时的决定性因素之一。框架提供的日志记录和调试支持越好，应用程序开发和维护的过程就越快。更好的日志记录和调试支持水平有助于开发者快速发现应用程序中的问题，在许多情况下，日志记录甚至会在最终用户识别问题之前指出问题。有效的错误处理在最终用户满意度中起着重要作用，并减轻了开发者调试的痛苦。即使其代码完美无缺，应用程序也难免会在某些时候抛出错误。为什么？答案很简单——代码可能完美无缺，但它在其中运行的世界却不是。可能会有无数的问题发生，作为开发者，我们总是想知道任何异常背后的原因。与应用程序一起编写测试用例是软件编写最重要的支柱之一。
- en: Python’s built-in logging system works pretty well with Flask. We will work
    with this logging system in this chapter before moving on to an awesome service
    called **Sentry**, which eases the pain of debugging and error logging to a huge
    extent.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置日志系统与Flask配合得相当好。在本章中，我们将使用这个日志系统，然后再转向一个名为**Sentry**的出色服务，它极大地简化了调试和错误日志记录的痛苦。
- en: As we have already talked about the importance of testing for application development,
    we will now see how to write test cases for a Flask application. We will also
    see how we can measure code coverage and profile our application to tackle any
    bottlenecks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了测试对于应用程序开发的重要性，我们现在将看看如何为Flask应用程序编写测试用例。我们还将了解如何衡量代码覆盖率并分析我们的应用程序以解决任何瓶颈。
- en: Testing in itself is a huge topic and has several books attributed to it. Here,
    we will try to understand the basics of testing with Flask.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身是一个巨大的主题，与之相关的书籍有很多。在这里，我们将尝试理解使用Flask进行测试的基础知识。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting up basic file logging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基本的文件日志记录
- en: Sending emails on the occurrence of errors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发生错误时发送电子邮件
- en: Using Sentry to monitor exceptions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sentry监控异常
- en: Debugging with `pdb`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pdb` 调试
- en: Creating application factories
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建应用程序工厂
- en: Creating the first simple test
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建第一个简单的测试
- en: Writing more tests for views and logic
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为视图和逻辑编写更多测试
- en: Integrating the nose2 library
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成nose2库
- en: Using mocking to avoid external API access
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟来避免外部API访问
- en: Determining test coverage
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定测试覆盖率
- en: Using profiling to find bottlenecks
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分析来查找瓶颈
- en: Setting up basic file logging
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本的文件日志记录
- en: By default, Flask will not log anything for us anywhere, except for the errors
    with the stack traces, which are sent to the logger (we will see more of this
    in the rest of the chapter). It does create a lot of stack traces while we run
    the application in the development mode using `run.py`, but in production systems,
    we don’t have this luxury. Thankfully, the logging library provides a whole lot
    of log handlers, which can be used as per requirements. In this recipe, we will
    understand how the `logging` library can be leveraged to ensure that effective
    logs are being captured from Flask applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flask 不会为我们记录任何内容，除了带有堆栈跟踪的错误，这些错误被发送到记录器（我们将在本章的其余部分看到更多）。它在开发模式下使用 `run.py`
    运行应用程序时确实会创建大量的堆栈跟踪，但在生产系统中，我们没有这种奢侈。幸运的是，记录库提供了一系列的记录处理程序，可以根据需要使用。在本食谱中，我们将了解如何利用
    `logging` 库确保从 Flask 应用程序中捕获有效的日志。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: We will start with our catalog application from the previous chapter and add
    some basic logging to it using `FileHandler`, which logs messages to a specified
    file on the filesystem. We will start with a basic log format and then see how
    to format the log messages to be more informative.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一章的目录应用程序开始，并使用 `FileHandler` 向文件系统上的指定文件添加一些基本的记录，以对它进行记录。我们将从基本的日志格式开始，然后看看如何格式化日志消息以使其更具信息性。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to configure and set up the `logging` library to use with
    our application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置和设置 `logging` 库，以便与我们的应用程序一起使用：
- en: 'The first change is made to the `my_app/__init__.py` file, which serves as
    the application’s configuration file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个更改是对 `my_app/__init__.py` 文件进行的，该文件作为应用程序的配置文件：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we added a configuration parameter to specify the log file’s location.
    This takes the relative path from the application folder unless an absolute path
    is explicitly specified. Next, we will check whether the application is already
    in debug mode, and then we will add a handler logging to a file with the logging
    level as `INFO`. Now, `DEBUG` is the lowest logging level and will log everything
    at any level. For more details, refer to the `logging` library documentation (in
    the *See also* section).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个配置参数来指定日志文件的位置。这采用从应用程序文件夹的相对路径，除非显式指定了绝对路径。接下来，我们将检查应用程序是否已经在调试模式中，然后我们将添加一个记录级别为
    `INFO` 的文件记录处理程序。现在，`DEBUG` 是最低的记录级别，将记录任何级别的所有内容。有关更多详细信息，请参阅 `logging` 库文档（在
    *参见* 部分）。
- en: 'After this, add loggers to the application wherever they are needed, and the
    application will start logging to the deputed file. Now, let’s add a couple of
    loggers to `my_app/catalog/views.py` for demonstration:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，将记录器添加到应用程序所需的任何位置，应用程序将开始向指定的文件记录。现在，让我们向 `my_app/catalog/views.py` 添加几个记录器以供演示：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we have added loggers for a couple of our view handlers.
    Note that the first of the loggers in `home()` is at the `info` level, and the
    other in `product()` is `warning`. If we set our log level in `__init__.py` as
    `INFO`, then both will be logged, and if we set the level as `WARNING`, then only
    the warning logger will be logged.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为我们的几个视图处理程序添加了记录器。请注意，`home()` 中的第一个记录器处于 `info` 级别，而 `product()`
    中的另一个是 `warning`。如果我们将在 `__init__.py` 中设置的日志级别为 `INFO`，那么两者都将被记录，如果我们设置级别为 `WARNING`，那么只有警告记录器将被记录。
- en: Information
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Make sure to import `abort` from `Flask` if this has not already been done –
    `from flask` `import abort`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 确保如果尚未完成，从 `Flask` 中导入 `abort` – `from flask import abort`。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding steps will create a file called `application.log` in the root
    application folder. The logger statements as specified will be logged to `application.log`
    and will look something like the following snippet, depending on the handler called;
    the first one is from the home page, and the second is from requesting a product
    that does not exist:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤将在根应用程序文件夹中创建一个名为 `application.log` 的文件。根据指定的记录器，记录语句将被记录到 `application.log`，其内容可能类似于以下片段；第一个来自主页，第二个来自请求一个不存在的商品：
- en: '[PRE27]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Important
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: To enable logging, either run your application with a WSGI server (refer to
    [*Chapter 11*](B19111_11.xhtml#_idTextAnchor610)) or run using `flask run` on
    your terminal prompt (refer to [*Chapter 1*](B19111_01.xhtml#_idTextAnchor016)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用记录，要么使用 WSGI 服务器运行您的应用程序（请参阅[*第11章*](B19111_11.xhtml#_idTextAnchor610)）或使用终端提示中的
    `flask run` 运行（请参阅[*第1章*](B19111_01.xhtml#_idTextAnchor016)）。
- en: Running the application using `run.py` will always make it run with the `debug`
    flag as `True`, which will not allow logging to work as expected.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.py`运行应用程序将始终使其以`debug`标志为`True`的方式运行，这将不会允许日志按预期工作。
- en: 'The information logged does not help much. It would be great to know when the
    issue was logged, with what level, which file caused the issue at what line number,
    and so on. This can be achieved using advanced logging formats. For this, we need
    to add a couple of statements to the configuration file – that is, `my_app/__init__.py`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的信息帮助不大。知道问题何时被记录、以何种级别、哪个文件在什么行号引发了问题等会更好。这可以通过高级日志格式实现。为此，我们需要在配置文件中添加一些语句——即`my_app/__init__.py`：
- en: '[PRE28]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, we added a formatter to `file_handler`, which will log
    the time, log level, message, file path, and line number. After this, the logged
    message will look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们向`file_handler`添加了一个格式化器，这将记录时间、日志级别、消息、文件路径和行号。之后，记录的消息将看起来像这样：
- en: '[PRE29]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There’s more…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'We might also want to log all the errors when a page is not found (the `404`
    error). For this, we can just tweak the `errorhandler` method a bit:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能想要记录当页面未找到时（`404`错误）的所有错误。为此，我们只需稍微调整一下`errorhandler`方法：
- en: '[PRE30]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Go to Python’s `logging` library documentation about handlers at [https://docs.python.org/dev/library/logging.handlers.html](https://docs.python.org/dev/library/logging.handlers.html)
    to learn more about logging handlers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前往Python的`logging`库处理程序文档[https://docs.python.org/dev/library/logging.handlers.html](https://docs.python.org/dev/library/logging.handlers.html)，了解更多关于日志处理程序的信息。
- en: Sending emails on the occurrence of errors
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生错误时发送电子邮件
- en: It is a good idea to receive notifications when something unexpected happens
    with the application. Setting this up is pretty easy and adds a lot of convenience
    to the process of error handling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序出现意外情况时，收到通知是个好主意。设置这一点相当简单，并为错误处理过程增加了许多便利。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will take the application from the last recipe and add `mail_handler` to
    it to make our application send emails when an error occurs. Also, we will demonstrate
    the email setup using Gmail as the SMTP server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一个菜谱中的应用程序开始，向其中添加`mail_handler`，以便在发生错误时我们的应用程序能够发送电子邮件。此外，我们将演示使用Gmail作为SMTP服务器进行电子邮件设置。
- en: How to do it…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, add the handler to the configuration in `my_app/__init__.py`. This is
    similar to how we added `file_handler` in the previous recipe:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将处理程序添加到`my_app/__init__.py`中的配置中。这与我们在上一个菜谱中添加`file_handler`的方式类似：
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we have a list of email addresses to which the error notification email
    will be sent. Also, note that we have set the log level to `ERROR` in the case
    of `mail_handler`. This is because emails will be necessary only in the case of
    crucial matters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个电子邮件地址列表，错误通知电子邮件将发送到这些地址。另外，请注意，我们在`mail_handler`的情况下将日志级别设置为`ERROR`。这是因为只有在关键事项的情况下才需要电子邮件。
- en: For more details on the configuration of `SMTPHandler`, refer to the documentation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`SMTPHandler`配置的更多详细信息，请参阅文档。
- en: Important
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Always make sure that you run your application with the `debug` flag set to
    `off` to enable the application to log and send emails for internal application
    errors (the `500` error).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要确保以`debug`标志设置为`off`的方式运行您的应用程序，以启用应用程序记录和发送内部应用程序错误（`500`错误）的电子邮件。
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To cause an internal application error, just misspell some keyword in any of
    your handlers. You will receive an email in your mailbox, with the formatting
    as set in the configuration and a complete stack trace for your reference.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要引起内部应用程序错误，只需在任何处理程序中拼写一些关键字出错。您将在邮箱中收到一封电子邮件，格式与配置中设置的一样，并附有完整的堆栈跟踪供您参考。
- en: Using Sentry to monitor exceptions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sentry监控异常
- en: Sentry is a tool that eases the process of monitoring exceptions and also provides
    insights into the errors that users of the application face while using it. It
    is highly possible that there are errors in log files that get overlooked by the
    human eye. Sentry categorizes the errors under different categories and keeps
    a count of the recurrence of errors. This helps us to understand the severity
    of the errors on multiple criteria and how to handle them accordingly. It has
    a nice GUI that facilitates all of these features. In this recipe, we will set
    up Sentry and use it as an effective error-monitoring tool.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Sentry 是一个工具，它简化了监控异常的过程，同时也为应用程序用户在使用过程中遇到的错误提供了洞察。很可能日志文件中存在被人类眼睛忽视的错误。Sentry
    将错误分类到不同的类别，并记录错误的重复次数。这有助于我们根据多个标准了解错误的严重性以及如何相应地处理它们。它有一个很好的 GUI，便于实现所有这些功能。在本食谱中，我们将设置
    Sentry 并将其用作有效的错误监控工具。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Sentry is available as a cloud service, which is available free for developers
    and basic users. For the purposes of this recipe, this freely available cloud
    service will be enough. Head over to [https://sentry.io/signup/](https://sentry.io/signup/)
    and get started with the registration process. This being said, we need to install
    the Python SDK for Sentry:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Sentry 可作为云服务提供，对开发者和基本用户免费。在本食谱的目的上，这个免费提供的云服务将足够使用。请访问 [https://sentry.io/signup/](https://sentry.io/signup/)
    并开始注册过程。话虽如此，我们需要安装 Sentry 的 Python SDK：
- en: '[PRE32]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Once the Sentry registration is complete, a screen will be shown that will
    ask about the type of project that needs to be integrated with Sentry. See the
    following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Sentry 注册完成后，将显示一个屏幕，询问需要与 Sentry 集成的项目类型。以下是一个截图：
- en: '![Figure 10.1 – The Sentry project creation screen](img/B19111_10_1.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – Sentry 项目创建屏幕](img/B19111_10_1.jpg)'
- en: Figure 10.1 – The Sentry project creation screen
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Sentry 项目创建屏幕
- en: 'This will be followed by another screen that shows the steps on how to configure
    your Flask application to send events to the newly created and configured Sentry
    instance. This is shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将随后显示另一个屏幕，展示如何配置您的 Flask 应用程序以将事件发送到新创建和配置的 Sentry 实例。以下是一个截图：
- en: '![Figure 10.2 – The Sentry project configuration steps](img/B19111_10_2.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – Sentry 项目配置步骤](img/B19111_10_2.jpg)'
- en: Figure 10.2 – The Sentry project configuration steps
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – Sentry 项目配置步骤
- en: Information
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Sentry can also be downloaded for free and installed as an on-premises application.
    There are multiple ways of installing and configuring Sentry as per your needs.
    You are free to try this approach on your own, as it goes beyond the scope of
    this recipe.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Sentry 也可以免费下载并作为本地应用程序安装。根据您的需求，有多种安装和配置 Sentry 的方法。您可以自由尝试这种方法，因为它超出了本食谱的范围。
- en: 'After the previous setup is complete, add the following code to your Flask
    application in `my_app/__init__.py`, replacing `https://1234:5678@fake-sentry-server/1`
    with the Sentry project URI:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成之前的设置后，将以下代码添加到您的 Flask 应用程序中的 `my_app/__init__.py` 文件，将 `https://1234:5678@fake-sentry-server/1`
    替换为 Sentry 项目 URI：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'An error logged in Sentry will look like the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sentry 中记录的错误将类似于以下截图：
- en: '![Figure 10.3 – The Sentry error log screen](img/B19111_10_3.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – Sentry 错误日志屏幕](img/B19111_10_3.jpg)'
- en: Figure 10.3 – The Sentry error log screen
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – Sentry 错误日志屏幕
- en: It is also possible to log messages and user-defined exceptions in Sentry. I
    will leave this to you to figure out by yourself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在 Sentry 中记录消息和用户定义的异常。我将把这个留给你自己探索。
- en: Debugging with pdb
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pdb 进行调试
- en: Most of the Python developers reading this book might already be aware of the
    usage of `pdb` is an interactive source code debugger for Python programs. We
    can set breakpoints wherever needed, debug using single stepping at the source
    line level, and inspect the stack frames.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这本书的大部分 Python 开发者可能已经知道 `pdb` 是一个交互式源代码调试器，用于 Python 程序。我们可以在需要的地方设置断点，在源代码行级别进行单步调试，并检查堆栈帧。
- en: Many new developers might be of the opinion that the job of a debugger can be
    handled using a logger, but debuggers provide a much deeper insight into the flow
    of control, preserve the state at each step, and hence, potentially save a lot
    of development time. In this recipe, let’s have a look at what `pdb` brings to
    the table.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新开发者可能认为调试器的任务可以使用记录器来处理，但调试器提供了对控制流程的更深入洞察，保留每个步骤的状态，因此，可能节省大量开发时间。在这个菜谱中，让我们看看`pdb`能带来什么。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use Python’s built-in `pdb` module for this recipe and use it in our
    application from the last recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个菜谱中使用Python的内置`pdb`模块，并在上一个菜谱的应用程序中使用它。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Using `pdb` is pretty simple in most cases. We just need to insert the following
    statement wherever we want to insert a breakpoint to inspect a certain block of
    code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用`pdb`相当简单。我们只需要在我们想要插入断点以检查特定代码块的地方插入以下语句：
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will trigger the application to break execution at this point, and then
    we can step through the stack frames one by one using the debugger commands.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发应用程序在此处中断执行，然后我们可以使用调试器命令逐个遍历堆栈帧。
- en: 'So, let’s insert this statement in one of our methods – say, the handler for
    products:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在我们的某个方法中插入这个语句——比如说，产品的处理程序：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Whenever the control comes to this line, the debugger prompt will fire up;
    this will appear as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每当控制流到达这一行时，调试器提示将会启动；它将如下所示：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note `u` written against `(Pdb)`. This signifies that I am moving the current
    frame one level up in the stack trace. All the variables, parameters, and properties
    used in that statement will be available in the same context to help figure out
    the issue, or just understand the flow of code. There are other debugger commands
    that could prove helpful in your navigation of the debug logs. Check the following
    *See also* section for these.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`(Pdb)`旁边写有`u`。这表示我正在将当前帧在堆栈跟踪中向上移动一级。在该语句中使用的所有变量、参数和属性都将在此上下文中可用，以帮助解决问题或只是理解代码的流程。还有其他调试器命令可能在您的调试日志导航中很有帮助。请参阅以下*参见*部分以获取这些信息。
- en: See also
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Go to the `pdb` module documentation at [https://docs.python.org/3/library/pdb.html#debugger-commands](https://docs.python.org/3/library/pdb.html#debugger-commands)
    to get hold of the various debugger commands.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://docs.python.org/3/library/pdb.html#debugger-commands](https://docs.python.org/3/library/pdb.html#debugger-commands)模块文档，以获取各种调试器命令。
- en: Creating application factories
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序工厂
- en: Leveraging a factory pattern is a great way of organizing your application object,
    allowing for multiple application objects with different settings. As discussed
    in [*Chapter 1*](B19111_01.xhtml#_idTextAnchor016), it is always possible to create
    multiple application instances by using different configurations, but application
    factories allow you to have multiple application objects inside the same application
    process. It also aids in testing, as you can choose to have a fresh or different
    application object with different settings for each test case.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 利用工厂模式是组织应用程序对象的好方法，允许有多个具有不同设置的应用程序对象。如在第[*第1章*](B19111_01.xhtml#_idTextAnchor016)中讨论的，总是可以通过使用不同的配置来创建多个应用程序实例，但应用程序工厂允许您在同一个应用程序进程中拥有多个应用程序对象。它还有助于测试，因为您可以选择为每个测试案例选择一个全新的或不同的应用程序对象，并具有不同的设置。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use our application from the previous recipe and modify it to use the
    application factory pattern.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一个菜谱中的应用程序，并将其修改为使用应用程序工厂模式。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following are the changes that need to be made:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行的以下是一些更改：
- en: 'We will start by creating a function named `create_app()` in our `my_app/__init__.py`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`my_app/__init__.py`中创建一个名为`create_app()`的函数：
- en: '[PRE37]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this function, we have just rearranged all the application configurations
    inside a function named `create_app()`. This will allow us to create as many application
    objects as needed by simply calling this function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们只是在名为`create_app()`的函数内部重新排列了所有的应用程序配置。这将允许我们通过简单地调用这个函数来创建所需数量的应用程序对象。
- en: 'Next, we create a method named `create_db()`, which initializes the database
    and then creates tables:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`create_db()`的方法，它初始化数据库然后创建表：
- en: '[PRE72]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Again in this function, we have just moved the database-specific code to a function.
    This method has been kept separate because you might want to use different database
    configs with different application instances.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们只是将数据库特定的代码移动到了一个函数中。这个方法被保留为独立的，因为您可能希望使用不同的数据库配置与不同的应用程序实例一起使用。
- en: 'The final step in `my_app/__init__.py` would be to call/execute these methods
    and register the blueprints:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my_app/__init__.py`中的最后一步将是调用/执行这些方法并注册蓝图：
- en: '[PRE78]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We have created the objects for `app`, `db`, and `babel` by calling relevant
    methods and initializing the extensions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用相关方法并初始化扩展来创建了`app`、`db`和`babel`的对象。
- en: 'A downside of the application factory pattern is that you cannot use the application
    object in blueprints during import time. However, you can always utilize the `current_app`
    proxy to access the current application object. Let’s see how this is done in
    `my_app/catalog/views.py`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序工厂模式的缺点是在导入时不能在蓝图中使用应用程序对象。然而，您始终可以利用`current_app`代理来访问当前的应用程序对象。让我们看看在`my_app/catalog/views.py`中是如何做到这一点的：
- en: '[PRE86]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How it works…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The application will continue to work in the same way as it did in the last
    recipe. It’s just that the code has been rearranged to implement the application
    factory pattern.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将继续以与上一个配方相同的方式工作。只是代码已经被重新排列以实现应用程序工厂模式。
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next couple of recipes will help you understand how the factory pattern
    is used while writing test cases.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个配方将帮助您了解在编写测试用例时如何使用工厂模式。
- en: Creating the first simple test
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建第一个简单的测试
- en: Testing is one of the strongest pillars of any software during development and,
    later, during maintenance and expansion. Especially in the case of web applications,
    where the application will handle high traffic and be scrutinized by a large number
    of end users at all times, testing becomes pretty important, as the user feedback
    determines the fate of the application. In this recipe, we will see how to start
    with test writing and also see more complex tests in the recipes to follow.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何软件开发期间以及后续的维护和扩展期间最坚实的支柱之一。特别是在网络应用程序的情况下，应用程序将处理高流量，并且始终受到大量最终用户的审查，测试变得非常重要，因为用户反馈决定了应用程序的命运。在这个配方中，我们将看到如何从编写测试开始，并在接下来的配方中看到更复杂的测试。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start with the creation of a new test file named `app_tests.py` at the
    root application level – that is, alongside the `my_app` folder.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在根应用程序级别创建一个名为`app_tests.py`的新测试文件开始——即在`my_app`文件夹旁边。
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s write our first test case:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的第一个测试用例：
- en: 'To start with, the content of the `app_tests.py` test file will be as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`app_tests.py`测试文件的内容将如下所示：
- en: '[PRE87]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The preceding code describes the imports needed for this test suite. We will
    use `unittest` to write our tests. A `tempfile` instance is needed to create SQLite
    databases on the fly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码描述了此测试套件所需的导入。我们将使用`unittest`来编写我们的测试。需要一个`tempfile`实例来动态创建SQLite数据库。
- en: 'All the test cases need to subclass from `unittest.TestCase`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有测试用例都需要从`unittest.TestCase`派生：
- en: '[PRE91]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The preceding method is run before each test is run and creates a new test client.
    A test is represented by the methods in this class that start with the `test_`
    prefix. Here, we set a database name in the app configuration, which is a timestamp-based
    value that will always be unique. We also set the `TESTING` flag to `True`, which
    disables error catching to enable better testing. Do pay special attention to
    how the application factory is used to create an application object before initializing
    `db` and `babel`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次运行测试之前都会运行前面的方法，并创建一个新的测试客户端。一个测试由这个类中以`test_`前缀开始的方法表示。在这里，我们在应用程序配置中设置了一个数据库名称，它是一个基于时间戳的值，将始终是唯一的。我们还设置了`TESTING`标志为`True`，这禁用了错误捕获以启用更好的测试。请特别注意如何在使用`db`和`babel`初始化之前使用应用程序工厂创建应用程序对象。
- en: Finally, we run the `create_all()` method on `db` to create all the tables from
    our application in the test database created.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`db`上运行`create_all()`方法，在测试数据库中创建我们应用程序的所有表。
- en: 'Remove the temporary database created in the previous step after the test has
    executed:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试执行后删除之前步骤中创建的临时数据库：
- en: '[PRE106]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The preceding method is called after each test is run. Here, we will remove
    the current database file and use a fresh database file for each test.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次运行测试之后都会调用前面的方法。在这里，我们将删除当前的数据库文件，并为每个测试使用一个新的数据库文件。
- en: 'Finally, write the test case:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写测试用例：
- en: '[PRE108]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The preceding code is our first test, where we sent an HTTP `GET` request to
    our application at the `/` URL and tested the response for the status code, which
    should be `200`, representing a successful `GET` response.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是我们的第一个测试，其中我们向我们的应用程序在`/` URL发送了HTTP `GET`请求并测试了状态码，它应该是`200`，表示成功的`GET`响应。
- en: How it works…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To run the test file, just execute the following command in the terminal:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试文件，只需在终端中执行以下命令：
- en: '[PRE111]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The following screenshot shows the output that signifies the outcome of the
    tests:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了表示测试结果的输出：
- en: "![Figure 10.4 –\uFEFF The first test result](img/B19111_10_4.jpg)"
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 第一个测试结果](img/B19111_10_4.jpg)'
- en: Figure 10.4 – The first test result
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 第一个测试结果
- en: See also
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Refer to the next recipe, *Writing more tests for views and logic*, to see more
    on how to write complex tests.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 参考下一道菜谱，*为视图和逻辑编写更多测试*，以了解如何编写复杂测试的更多内容。
- en: Writing more tests for views and logic
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为视图和逻辑编写更多测试
- en: In the last recipe, we got started with writing tests for our Flask application.
    In this recipe, we will build upon the same test file and add more tests for our
    application; these tests will cover testing the views for behavior and logic.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一道菜谱中，我们开始了为我们的Flask应用程序编写测试。在这道菜谱中，我们将基于相同的测试文件添加更多测试到我们的应用程序中；这些测试将涵盖测试视图的行为和逻辑。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will build upon the test file named `app_tests.py` created in the last recipe.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于上一道菜谱中创建的名为`app_tests.py`的测试文件进行构建。
- en: How to do it…
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Before we write any tests, we need to add a small bit of configuration to `setUp()`
    to disable the CSRF tokens, as they are not generated by default for test environments:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何测试之前，我们需要向`setUp()`添加一小部分配置来禁用CSRF令牌，因为在测试环境中默认不会生成：
- en: '[PRE112]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The following are some tests that are created as a part of this recipe. Each
    test will be described as we go further:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些作为这道菜谱的一部分创建的测试。每个测试将在我们进一步进行时进行描述：
- en: 'Firstly, write a test to make a `GET` request to the products list:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编写一个测试来向产品列表发送`GET`请求：
- en: '[PRE113]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The preceding test sends a `GET` request to the `/products` endpoint and asserts
    that the status code of the response is `200`. It also asserts that there is no
    previous page and no next page (rendered as a part of the template logic).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试向`/products`端点发送`GET`请求并断言响应的状态码为`200`。它还断言没有上一页和下一页（作为模板逻辑的一部分渲染）。
- en: 'Next, create a category and verify that it has been created correctly:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个类别并验证它是否已正确创建：
- en: '[PRE121]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The preceding test creates a category and asserts for corresponding status messages.
    When a category is successfully created, we will be redirected to the newly created
    category page, and hence, the status code will be `302`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试创建了一个类别并断言相应的状态消息。当类别成功创建时，我们将被重定向到新创建的类别页面，因此状态码将是`302`。
- en: 'Now, similar to category creation, create a product and then verify its creation:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，类似于类别创建，创建一个产品然后验证其创建：
- en: '[PRE146]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The preceding test creates a product and asserts for corresponding status messages
    on each call/request.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试创建了一个产品并断言每个调用/请求的相应状态消息。
- en: Information
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: As a part of this test, we identified a small improvement in our `create_product()`
    method. We had not initiated the `filename` variable before the `if` condition
    to check for the allowed file type. The earlier code would work fine only when
    the `if` condition passed. Now, we have just adjusted the code to initiate `filename`
    as `filename = secure_filename(image.filename)` before the `if` condition, instead
    of doing it inside the condition.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个测试的一部分，我们在`create_product()`方法中识别了一个小的改进。我们在检查允许的文件类型之前没有初始化`filename`变量。早期的代码只有在`if`条件通过时才能正常工作。现在，我们只是调整了代码，在`if`条件之前将`filename`初始化为`filename
    = secure_filename(image.filename)`，而不是在条件内部做这件事。
- en: 'Finally, create multiple products and search for the products that were just
    created:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建多个产品并搜索刚刚创建的产品：
- en: '[PRE174]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: The preceding test first creates a category and two products. Then, it searches
    for one product and makes sure that only the searched product is returned in the
    result.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试首先创建一个类别和两个产品。然后，它搜索一个产品并确保只返回搜索到的产品在结果中。
- en: How it works…
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To run the test file, just execute the following command in the terminal:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试文件，只需在终端中执行以下命令：
- en: '[PRE216]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: What follows the command is the output that shows the outcome of the tests.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 命令之后是显示测试结果的输出。
- en: See also
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Another interesting and popular library that can be used for unit testing is
    **pytest**. It is similar to Python’s in-built **unittest** library but with more
    out-of-the-box features. Feel free to explore it: [https://docs.pytest.org/en/stable/](https://docs.pytest.org/en/stable/).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以用于单元测试的有趣且流行的库是 **pytest**。它与 Python 内置的 **unittest** 库类似，但具有更多开箱即用的功能。请随意探索它：[https://docs.pytest.org/en/stable/](https://docs.pytest.org/en/stable/)。
- en: Integrating the nose2 library
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 `nose2` 库
- en: '`nose2` can be used for multiple purposes, the most important usage remains
    that of a test collector and runner. `nose2` automatically collects tests from
    Python source files, directories, and packages found in the current working directory.
    In this recipe, we will focus on how to run individual tests using `nose2` rather
    than the whole bunch of tests every time.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose2` 可以用于多种用途，其中最重要的用途仍然是作为测试收集器和运行器。`nose2` 会自动从当前工作目录中的 Python 源文件、目录和包中收集测试。在本食谱中，我们将重点介绍如何使用
    `nose2` 运行单个测试，而不是每次都运行一整套测试。'
- en: Important
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: In earlier editions of this book, we used the `nose` library. It has since not
    been under active maintenance and can be deemed deprecated. A replacement for
    it has been created, with the name `nose2`. This library behaves similarly to
    `nose` but is not exactly the same. However, for the purpose of our demonstration,
    the major functionality remains similar.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期版本中，我们使用了 `nose` 库。自那时起，它已经没有在积极维护，并且可以被认为是过时的。已经创建了一个替代品，名为 `nose2`。这个库的行为与
    `nose` 类似，但并不完全相同。然而，为了我们的演示目的，主要功能仍然相似。
- en: Getting ready
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we need to install the `nose2` library:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 `nose2` 库：
- en: '[PRE217]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '`nose2` has a mechanism for test file discovery that mandates that a file should
    start with `test`. Since, in our case, the test file is named `app_tests.py`,
    we should now rename it `test_app.py`. On a terminal, you can simply run the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose2` 有一个测试文件发现机制，要求文件名应以 `test` 开头。由于在我们的情况下，测试文件名为 `app_tests.py`，我们现在应该将其重命名为
    `test_app.py`。在终端中，你可以简单地运行以下命令：'
- en: '[PRE218]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: How to do it…
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We can execute all the tests in our application using `nose2` by running the
    following command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令使用 `nose2` 执行我们应用程序中的所有测试：
- en: '[PRE219]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: This will pick out all the tests in our application and run them, even if we
    have multiple test files.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择我们应用程序中的所有测试并运行它们，即使我们有多个测试文件。
- en: 'To run a single test file, simply run the following command:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行单个测试文件，只需运行以下命令：
- en: '[PRE220]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Now, if you want to run a single test, simply run this command:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想运行单个测试，只需运行以下命令：
- en: '[PRE221]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: This becomes important when we have a memory-intensive application and a large
    number of test cases. In that instance, the tests themselves can take a long time
    to run, and doing so every time can be very frustrating for a developer. Instead,
    we will prefer to run only those tests that concern the change made, or the test
    that broke following a certain change.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个内存密集型应用程序和大量测试用例时，这一点变得很重要。在这种情况下，测试本身可能需要很长时间才能运行，并且每次都这样做可能会让开发者感到非常沮丧。相反，我们更愿意只运行那些与所做的更改相关的测试，或者是在某些更改之后破坏的测试。
- en: See also
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There are many other ways to configure `nose2` for optimal and effective usage
    as per requirements. Refer to the `nose2` documentation at [https://docs.nose2.io/en/latest/index.html](https://docs.nose2.io/en/latest/index.html)
    for more details.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需求，有许多其他方法可以配置 `nose2` 以实现最优和有效的使用。有关更多详细信息，请参阅 [https://docs.nose2.io/en/latest/index.html](https://docs.nose2.io/en/latest/index.html)
    上的 `nose2` 文档。
- en: Using mocking to avoid external API access
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟来避免外部 API 访问
- en: We are aware of how testing works, but now, let’s imagine we have a third-party
    application/service integrated via API calls with our application. It would not
    be a great idea to make calls to this application/service every time tests are
    run. Sometimes, these can be paid, too, and making calls during tests can not
    only be expensive but also affect the statistics of that service. `geoip2` library
    and then test it via mocking.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解测试是如何工作的，但现在，让我们想象我们有一个第三方应用程序/服务通过 API 调用与我们的应用程序集成。每次运行测试时都调用这个应用程序/服务并不是一个好主意。有时，这些调用也可能是付费的，并且在测试期间进行调用不仅可能很昂贵，还可能影响该服务的统计信息。我们可以使用
    `geoip2` 库并通过模拟来测试它。
- en: Getting ready
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In Python 3, `mock` has been included as a standard package in the `unittest`
    library.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，`mock` 已经被包含在 `unittest` 库的标准包中。
- en: 'For the purpose of this recipe, we first need to install the `geoip2` library
    and the corresponding database:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本食谱的目的，我们首先需要安装 `geoip2` 库和相应的数据库：
- en: '[PRE222]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: You also need to download the free `geoip` database from the MaxMind ([https://dev.maxmind.com/geoip/geolite2-free-geolocation-data](https://dev.maxmind.com/geoip/geolite2-free-geolocation-data))
    website to a location of your preference, and then unzip the file. For the sake
    of simplicity, I have downloaded it to the project folder itself. You will need
    to create a free account before you can download the `geoip` city database.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要从MaxMind的免费网站（[https://dev.maxmind.com/geoip/geolite2-free-geolocation-data](https://dev.maxmind.com/geoip/geolite2-free-geolocation-data)）下载免费的`geoip`数据库到您偏好的位置，然后解压文件。为了简化，我已经将其下载到项目文件夹本身。在您能够下载`geoip`城市数据库之前，您需要创建一个免费账户。
- en: After downloading the city database, you should have a folder with the `Geolite2-
    City-` prefix. This folder contains the `geoip` database with the `.mmdb` extension
    that we will use in this recipe.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载城市数据库后，您应该有一个以`Geolite2- City-`为前缀的文件夹。这个文件夹包含我们将在本食谱中使用的`.mmdb`扩展名的`geoip`数据库。
- en: Now, let’s say we want to store the location of a user who creates a product
    (imagine a scenario where the application is administered at multiple global locations).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要存储创建产品的用户的位置（想象一下应用程序在多个全球位置管理的场景）。
- en: We need to make some small changes to `my_app/catalog/models.py`, `my_app/catalog/views.py`,
    and `templates/product.html`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`my_app/catalog/models.py`、`my_app/catalog/views.py`和`templates/product.html`进行一些小的修改。
- en: 'For `my_app/catalog/models.py`, we will add a new field named `user_timezone`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`my_app/catalog/models.py`，我们将添加一个名为`user_timezone`的新字段：
- en: '[PRE223]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'For `my_app/catalog/views.py`, we will modify the `create_product()` method
    to include the time zone:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`my_app/catalog/views.py`，我们将修改`create_product()`方法以包含时区：
- en: '[PRE224]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Here, we fetched the geolocation data using an IP lookup and passed this during
    product creation. If no match is found, then the call is made from `localhost`,
    `127.0.0.1`, or `0.0.0.0`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用IP查找获取地理位置数据，并在创建产品时传递这些数据。如果没有找到匹配项，那么调用来自`localhost`、`127.0.0.1`或`0.0.0.0`。
- en: Also, we will add this new field in our product template so that it becomes
    easy to verify in the test. For this, just add `{{ product.user_timezone }}` somewhere
    in the `product.html` template.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在我们的产品模板中添加这个新字段，以便在测试中容易验证。为此，只需在`product.html`模板的某个位置添加`{{ product.user_timezone
    }}`。
- en: How to do it…
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Start by modifying `test_app.py` to accommodate the mocking of the `geoip`
    lookup:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改`test_app.py`以适应对`geoip`查找的模拟：
- en: 'First, configure the mocking of the `geoip` lookup by creating patchers:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过创建修补器来配置对`geoip`查找的模拟：
- en: '[PRE225]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: First, we imported `records` from `geoip2`, which we will use to create the
    mocked return value that we need to use for testing. Then, we patched `geoip2.models.City`
    with the `location` attribute on the `City` model preset to `geoip2.records.Location(time_zone
    = 'America/Los_Angeles')` and started the patcher. This means that whenever an
    instance of `geoip2.models.City` is created, it will be patched with the time
    zone on the `location` attribute set to `'America/Los_Angeles'`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`geoip2`中导入了`records`，这是我们用来创建测试所需模拟返回值的。然后，我们使用`location`属性在`City`模型上对`geoip2.models.City`进行了修补，并将其预设为`geoip2.records.Location(time_zone
    = 'America/Los_Angeles')`，然后启动了修补器。这意味着每当创建一个`geoip2.models.City`实例时，它都会被修补，其`location`属性上的时区设置为`'America/Los_Angeles'`。
- en: This is followed by the patching of `geoip2.database.Reader`, where we mock
    the return value of its `city()` method to the `PatchedGeoipCity` class that we
    created previously.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这随后是对`geoip2.database.Reader`的修补，我们模拟其`city()`方法的返回值为我们之前创建的`PatchedGeoipCity`类。
- en: 'Stop the patchers that were started in the `setUp` method:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止在`setUp`方法中启动的修补器：
- en: '[PRE248]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: We stopped the mock patchers in `tearDown` so that the actual calls are not
    affected.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`tearDown`中停止了模拟修补器，以确保实际的调用不受影响。
- en: 'Finally, modify the product test case created to assert the location:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改创建的产品测试用例以断言位置：
- en: '[PRE252]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Here, after the creation of the product, we asserted that the `America/Los_Angeles`
    value is present somewhere in the product template that is rendered.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在创建产品后，我们断言`America/Los_Angeles`值出现在渲染的产品模板的某个地方。
- en: How it works…
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Run the test and see whether it passes:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并查看是否通过：
- en: '[PRE270]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: See also
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There are multiple ways in which mocking can be done. I demonstrated just one
    of them. You can choose any method from the ones available. Refer to the documentation
    available at [https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以进行模拟。我演示了其中的一种。你可以从可用的方法中选择任何一种。请参阅[https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html)上的文档。
- en: Determining test coverage
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定测试覆盖率
- en: In the previous recipes, test case writing was covered, but there is an important
    aspect to measure the extent of testing, called coverage. Coverage refers to how
    much of our code has been covered by the tests. The higher the percentage of coverage,
    the better the testing (although high coverage is not the only criterion for good
    tests). In this recipe, we will check the code coverage of our application.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们涵盖了测试用例的编写，但有一个重要的方面可以衡量测试的范围，称为覆盖率。覆盖率指的是我们的代码有多少被测试覆盖。覆盖率百分比越高，测试就越好（尽管高覆盖率不是良好测试的唯一标准）。在这个菜谱中，我们将检查我们应用程序的代码覆盖率。
- en: Tip
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that 100% test coverage does not mean that code is flawless. However,
    in any case, it is better than having no tests or lower coverage. Remember that
    “*if it’s not tested,* *it’s broken.*”
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，100%的测试覆盖率并不意味着代码完美无缺。然而，在任何情况下，它都比没有测试或覆盖率低要好。记住，“*如果没有经过测试，* *它就是有缺陷的.*”
- en: Getting ready
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use a library called `coverage` for this recipe. The following is the
    installation command:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`coverage`的库来完成这个菜谱。以下是其安装命令：
- en: '[PRE271]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: How to do it…
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The simplest way of measuring code coverage is to use the command line:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 测量代码覆盖率的最简单方法是使用命令行：
- en: 'Simply run the following command:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地运行以下命令：
- en: '[PRE272]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Here, `--source` indicates the directories that are to be considered in coverage,
    and `--omit` indicates the files that need to be omitted in the process.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`--source`表示要考虑在覆盖率中的目录，而`--omit`表示在过程中需要排除的文件。
- en: 'Now, to print the report on the terminal itself, run the following command:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要直接在终端上打印报告，请运行以下命令：
- en: '[PRE273]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'The following screenshot shows the output:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![Figure 10.5 – The test coverage report](img/B19111_10_5.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 测试覆盖率报告](img/B19111_10_5.jpg)'
- en: Figure 10.5 – The test coverage report
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 测试覆盖率报告
- en: 'To get a nice HTML output of the coverage report, run the following command:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获得覆盖率报告的漂亮HTML输出，请运行以下命令：
- en: '[PRE274]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: This will create a new folder named `htmlcov` in your current working directory.
    Inside this, just open up `index.html` in a browser, and the full detailed view
    will be available.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的当前工作目录中创建一个名为`htmlcov`的新文件夹。在这个文件夹中，只需在浏览器中打开`index.html`，就可以看到完整的详细视图。
- en: '![Figure 10.6 – The test coverage report web view](img/B19111_10_6.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 测试覆盖率报告的网页视图](img/B19111_10_6.jpg)'
- en: Figure 10.6 – The test coverage report web view
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 测试覆盖率报告的网页视图
- en: 'Alternatively, we can include a piece of code in our test file and get the
    coverage report every time the tests are run. We just add the following code snippets
    to `test_app.py`:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在测试文件中包含一段代码，并在每次运行测试时获取覆盖率报告。我们只需将以下代码片段添加到`test_app.py`中：
- en: 'Before anything else, add the following code to start the coverage assessment
    process:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在做任何事情之前，添加以下代码以启动覆盖率评估过程：
- en: '[PRE275]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Here, we imported the `coverage` library and created an object for it. This
    tells the library to omit all `site-packages` instances (because we do not want
    to evaluate the code that we did not write) and the test file itself. Then, we
    started the process to determine the coverage.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们导入了`coverage`库并为它创建了一个对象。这告诉库忽略所有`site-packages`实例（因为我们不想评估我们没有编写的代码）以及测试文件本身。然后，我们启动了确定覆盖率的进程。
- en: 'At the end of the code, modify the last block to the following:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码的末尾，将最后一个块修改为以下内容：
- en: '[PRE284]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: In the preceding code, we first put `unittest.main()` inside a `try..finally`
    block. This is because `unittest.main()` exits after all the tests are executed.
    Now, the coverage-specific code is forced to run after this method completes.
    We stopped the coverage report, saved it, printed the report on the console, and
    then generated the HTML version of it before deleting the temporary `.coverage`
    file (this is created automatically as part of the process).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先将`unittest.main()`放在一个`try..finally`块中。这是因为`unittest.main()`在所有测试执行完毕后退出。现在，在执行完这个方法后，必须强制运行与覆盖率相关的代码。我们停止了覆盖率报告，保存了它，然后在控制台上打印了报告，并在删除临时`.coverage`文件（这是作为过程的一部分自动创建的）之前生成了它的HTML版本。
- en: How it works…
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'If we run our tests after including the coverage-specific code, then we can
    run the following command:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在包含覆盖率特定代码后运行测试，那么我们可以运行以下命令：
- en: '[PRE293]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: The output will be very similar to the one in *Figure 10**.5*.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将非常类似于*图10.5*中的那个。
- en: See also
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: It is also possible to determine coverage using the `nose2` library, which we
    discussed in the *Integrating the nose2 library* recipe. I will leave it to you
    to explore this by yourself. Refer to [https://docs.nose2.io/en/latest/plugins/coverage.html](https://docs.nose2.io/en/latest/plugins/coverage.html)
    for a head start.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`nose2`库来确定覆盖率，我们在*集成nose2库*菜谱中讨论了它。我将把它留给你自己探索。有关更多信息，请参阅[https://docs.nose2.io/en/latest/plugins/coverage.html](https://docs.nose2.io/en/latest/plugins/coverage.html)。
- en: Using profiling to find bottlenecks
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用性能分析来查找瓶颈
- en: Profiling is an important and handy tool to measure performance when we decide
    to scale an application. Before scaling, we want to know whether any process is
    a bottleneck and affects the overall performance. Python has a built-in profiler,
    `cProfile`, that can do the job for us, but to make life easier, `werkzeug` has
    `ProfilerMiddleware`, which is written over `cProfile`. In this recipe, we will
    use `ProfilerMiddleware` to determine whether there is anything that affects performance.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析是在我们决定扩展应用程序时测量性能的重要且方便的工具。在扩展之前，我们想知道是否有任何进程是瓶颈并影响整体性能。Python有一个内置的性能分析器`cProfile`，可以为我们完成这项工作，但为了使生活更简单，`werkzeug`有`ProfilerMiddleware`，它是基于`cProfile`编写的。在这个菜谱中，我们将使用`ProfilerMiddleware`来确定是否有任何影响性能的因素。
- en: Getting ready
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the application from the previous recipe and add `ProfilerMiddleware`
    to a new file named `generate_profile.py`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前一个菜谱中的应用程序，并将`ProfilerMiddleware`添加到一个名为`generate_profile.py`的新文件中。
- en: How to do it…
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new file, `generate_profile.py`, alongside `run.py`, which works like
    `run.py` itself but with `ProfilerMiddleware`:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`generate_profile.py`，与`run.py`并列，它的工作方式与`run.py`本身一样，但带有`ProfilerMiddleware`：
- en: '[PRE294]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Here, we imported `ProfilerMiddleware` from `werkzeug` and then modified `wsgi_app`
    on our Flask app to use it, with a restriction of the top 10 calls to be printed
    in the output.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`werkzeug`中导入了`ProfilerMiddleware`，然后修改了我们的Flask应用中的`wsgi_app`以使用它，限制输出中打印的前10个调用。
- en: How it works…
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Now, we can run our application using `generate_profile.py`:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`generate_profile.py`来运行我们的应用程序：
- en: '[PRE295]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'We can then create a new product. Then, the output for that specific call will
    be like the following screenshot:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个新的产品。然后，针对该特定调用的输出将类似于以下截图：
- en: '![Figure 10.7 – The profiler output](img/B19111_10_7.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 性能分析器输出](img/B19111_10_7.jpg)'
- en: Figure 10.7 – The profiler output
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 性能分析器输出
- en: It is evident from the preceding screenshot that the most intensive call in
    this process is the call made to the `geoip` database. Even though it is a single
    call, it takes the most amount of time. So, if we decide to improve performance
    sometime down the line, this is something that needs to be looked at first.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图可以看出，在这个过程中最密集的调用是对`geoip`数据库的调用。尽管它是一个单独的调用，但它花费了最多的时间。所以，如果我们决定在将来某个时候提高性能，这是需要首先查看的地方。
