- en: '*Chapter 17*: The Builder Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第17章*：构建器模式'
- en: In the previous chapter, we covered the first two creational patterns—the factory
    method and abstract factory, both of which offer approaches to improve the way
    we create objects in nontrivial cases. The builder design pattern, on the other
    hand, as we'll discuss in this chapter, is useful for managing objects that consist
    of multiple parts that need to be implemented sequentially. By decoupling the
    construction of an object and its representation, the builder pattern allows us
    to reuse a construction multiple times.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了前两个创建型模式——工厂方法和抽象工厂，它们都提供了在非平凡情况下改进对象创建方式的方法。另一方面，构建器设计模式，正如我们将在本章中讨论的，对于管理由多个部分组成且需要按顺序实现的对象非常有用。通过解耦对象的构建和其表示，构建器模式允许我们多次重用构建过程。
- en: Just as with the previous chapter, we will discuss real-life applications that
    use this design pattern as well as implementing a hands-on example ourselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上一章一样，我们将讨论使用此设计模式的实际应用，以及我们自己动手实现一个实例。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding the builder pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解构建器模式
- en: Real-world examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界例子
- en: Use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: Implementing an ordering application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个订单应用
- en: By the end of the chapter, we will understand how to use the builder pattern
    and its practical benefits.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将了解如何使用构建器模式及其实际益处。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过此链接访问：
- en: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17)'
- en: Understanding the builder pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解构建器模式
- en: Imagine that we want to create an object that is composed of multiple parts
    and the composition needs to be done step by step. The object is not complete
    unless all its parts are fully created. That's where the **builder-design pattern**
    can help us. The builder pattern separates the construction of a complex object
    from its representation. By keeping the construction separate from the representation,
    the same construction can be used to create several different representations
    ([j.mp/builderpat](http://j.mp/builderpat)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个由多个部分组成且需要逐步构建的对象。除非所有部分都完全创建，否则对象是不完整的。这就是**构建器设计模式**能帮到我们的地方。构建器模式将复杂对象的构建与其表示分离。通过将构建与表示分离，相同的构建过程可以用来创建多个不同的表示([j.mp/builderpat](http://j.mp/builderpat))。
- en: 'A practical example can help us understand what the purpose of the builder
    pattern is. Suppose that we want to create a `<html>` and finishes with `</html>`;
    inside the HTML section are the `<head>` and `</head>` elements; inside the head
    section are the `<title>` and `</title>` elements; and so forth. But the representation
    of the page can differ. Each page has its own title, its own headings, and different
    `<body>` contents. Moreover, the page is usually built in steps: one function
    adds the title, another adds the main heading, another the footer, and so on.
    Only after the whole structure of a page is complete can it be shown to the client
    using a final render function. We can take it even further and extend the HTML
    generator so that it can generate totally different HTML pages. One page might
    contain tables, another page might contain image galleries, yet another page contains
    the contact form, and so on.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际例子可以帮助我们理解构建器模式的目的。假设我们想要创建一个由`<html>`开始并以`</html>`结束的HTML文档；在HTML部分包含`<head>`和`</head>`元素；在头部部分包含`<title>`和`</title>`元素；等等。但页面的表示可能不同。每个页面都有自己的标题、自己的标题和不同的`<body>`内容。此外，页面通常分步骤构建：一个函数添加标题，另一个添加主要标题，另一个添加页脚，等等。只有当整个页面结构完成后，才能使用最终的渲染函数将其展示给客户端。我们可以更进一步，扩展HTML生成器，使其能够生成完全不同的HTML页面。一个页面可能包含表格，另一个页面可能包含图片画廊，另一个页面可能包含联系表单，等等。
- en: 'The HTML page-generation problem can be solved using the builder pattern. In
    this pattern, there are two main participants, outlined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建器模式可以解决HTML页面生成问题。在这个模式中，有两个主要参与者，如下所述：
- en: '**The builder**: The component responsible for creating the various parts of
    a complex object. In this example, these parts are the title, heading, body, and
    the footer of the page.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建者**：负责创建复杂对象各个部分的组件。在这个例子中，这些部分是页面的标题、标题、正文和页脚。'
- en: '`builder` instance. It calls the builder''s functions for setting the title,
    the heading, and so on, and using a different `builder` instance allows us to
    create a different HTML page without touching any of the code of the director.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builder` 实例。它调用构建器的函数来设置标题、标题等，使用不同的 `builder` 实例允许我们创建不同的 HTML 页面，而不需要触及导演的任何代码。'
- en: First, let's discuss in the next section some real-life examples where this
    pattern applies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在下一节中讨论一些真实生活中应用此模式的情况。
- en: Real-world examples
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界的例子
- en: In our everyday life, the *builder design pattern* is used in fast-food restaurants.
    The same procedure is always used to prepare a burger and the packaging (box and
    paper bag), even if there are many different kinds of burgers (classic, cheeseburger,
    and more) and different packages (small-sized box, medium-sized box, and so forth).
    The difference between a classic burger and a cheeseburger is in the representation,
    and not in the construction procedure. In this case, the **director** is the cashier
    who gives the crew instructions about what needs to be prepared, and the **builder**
    is the person from the crew that takes care of a specific order.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常生活中，*构建设计模式*在快餐店中被使用。制作汉堡和包装（盒子和平装袋）的相同程序总是被使用，即使有许多不同种类的汉堡（经典、芝士汉堡等）和不同的包装（小号盒子、中号盒子等等）。经典汉堡和芝士汉堡之间的区别在于表示，而不是构建程序。在这种情况下，**导演**是收银员，他向工作人员下达需要准备的指示，而**构建者**是负责特定订单的工作人员。
- en: 'We can also find software examples, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以找到软件示例，如下所示：
- en: The HTML example that was mentioned at the beginning of the chapter is actually
    used by `django-widgy` ([https://wid.gy/](https://wid.gy/)), a third-party tree
    editor for Django that can be used as a `django-widgy` editor contains a page
    builder that can be used for creating HTML pages with different layouts.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章开头提到的 HTML 示例实际上被 `django-widgy`（[https://wid.gy/](https://wid.gy/)）使用，这是一个第三方
    Django 树编辑器，可以用作 `django-widgy` 编辑器，其中包含一个页面构建器，可以用来创建具有不同布局的 HTML 页面。
- en: The `django-query-builder` library ([https://github.com/ambitioninc/django-query-builder](https://github.com/ambitioninc/django-query-builder))
    is another third-party Django library that relies on the builder pattern. This
    library can be used for building **Structured Query Language** (**SQL**) queries
    dynamically, allowing you to control all aspects of a query and create a different
    range of queries, from simple to very complex ones.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-query-builder` 库（[https://github.com/ambitioninc/django-query-builder](https://github.com/ambitioninc/django-query-builder)）是另一个依赖构建模式的第三方
    Django 库。这个库可以用来动态构建 **结构化查询语言**（**SQL**）查询，允许你控制查询的所有方面，并创建从简单到非常复杂的各种查询。'
- en: In the next section, we will see how this design pattern actually works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到这个设计模式是如何实际工作的。
- en: Use cases
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: We use the builder pattern when we know that an object must be created in multiple
    steps, and different representations of the same construction are required. These
    requirements exist in many applications, such as page generators (for example,
    the HTML page generator mentioned in this chapter), document converters, and **user
    interface** (**UI**) form creators ([j.mp/pipbuild](http://j.mp/pipbuild)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道一个对象必须通过多个步骤创建，并且需要相同构建的不同表示时，我们使用构建模式。这些需求存在于许多应用程序中，例如页面生成器（例如，本章中提到的
    HTML 页面生成器）、文档转换器和**用户界面**（**UI**）表单创建器（[j.mp/pipbuild](http://j.mp/pipbuild)）。
- en: 'Some online resources mention that the builder pattern can also be used as
    a solution to the telescopic constructor problem. The telescopic constructor problem
    occurs when we are forced to create a new constructor for supporting different
    ways of creating an object. The problem is that we end up with many constructors
    and long parameter lists that are hard to manage. An example of the telescopic
    constructor is listed on the Stack Overflow website ([j.mp/sobuilder](http://j.mp/sobuilder)).
    Fortunately, this problem does not exist in Python, because it can be solved in
    at least two ways, as outlined here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在线资源提到，建造者模式也可以作为解决望远镜构造器问题（telescopic constructor problem）的解决方案。望远镜构造器问题发生在我们被迫为支持不同的对象创建方式而创建新的构造器时。问题在于我们最终会有很多构造器，以及难以管理的长参数列表。Stack
    Overflow网站上列出了一个望远镜构造器的例子 ([j.mp/sobuilder](http://j.mp/sobuilder))。幸运的是，这个问题在Python中不存在，因为它可以通过至少两种方式解决，如下所述：
- en: With named parameters that define different behaviors in the constructor of
    the class ([j.mp/sobuipython](http://j.mp/sobuipython))
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在类构造函数中定义不同行为的命名参数 ([j.mp/sobuipython](http://j.mp/sobuipython))
- en: With argument list unpacking, which is similar in spirit to named parameters
    ([j.mp/arglistpy](http://j.mp/arglistpy))
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数列表解包，这在精神上类似于命名参数 ([j.mp/arglistpy](http://j.mp/arglistpy))
- en: These features that are specific to Python help us control the behavior of its
    code easily, thus avoiding the problem we described previously.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定于Python的特性帮助我们轻松控制其代码的行为，从而避免我们之前描述的问题。
- en: At this point, the distinction between the builder pattern and the factory pattern
    might not be very clear. The main difference is that the factory pattern creates
    an object in a single step, whereas the builder pattern creates an object in multiple
    steps, and almost always through the use of a director. Some targeted implementations
    of the builder pattern, such as Java's `StringBuilder`, bypass the use of a director,
    but that's the exception to the rule.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，建造者模式和工厂模式之间的区别可能不是很清楚。主要区别在于，工厂模式在单步中创建一个对象，而建造者模式在多个步骤中创建一个对象，通常通过使用一个导演（director）来实现。一些针对建造者模式的特定实现，如Java的`StringBuilder`，绕过了导演的使用，但这只是例外。
- en: Another difference is that while the factory pattern returns a created object
    immediately, in the builder pattern the client code explicitly asks the director
    to return the final object when it needs it ([j.mp/builderpat](http://j.mp/builderpat)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，虽然工厂模式立即返回创建的对象，但在建造者模式中，客户端代码明确要求导演在需要时返回最终对象 ([j.mp/builderpat](http://j.mp/builderpat))。
- en: 'The new computer analogy might help you to distinguish between the builder
    pattern and the factory pattern. Assume that you want to buy a new computer. If
    you decide to buy a specific, preconfigured computer model—for example, the latest
    Apple 1.4 `apple_factory.py`):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 新的计算机类比可能有助于您区分建造者模式（builder pattern）和工厂模式（factory pattern）。假设您想购买一台新电脑。如果您决定购买一款特定的、预配置的电脑型号——例如，最新的苹果1.4
    `apple_factory.py`）：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we add the main part of the program—the snippet that uses the `AppleFactory`
    class. The code is illustrated here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加程序的主要部分——使用`AppleFactory`类的代码片段。代码如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the nested `MacMini14` class. This is a neat way of forbidding the direct
    instantiation of a class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意嵌套的`MacMini14`类。这是一种禁止直接实例化类的巧妙方法。
- en: 'Another option would be to buy a custom PC. In this case, you use the builder
    pattern. You are the director who gives orders to the manufacturer (`builder`)
    about your ideal computer specifications. Code-wise, this is how it looks (`computer_builder.py`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是购买一台定制PC。在这种情况下，您使用建造者模式。您是导演，向制造商（`builder`）下达关于理想电脑规格的命令。代码上，看起来是这样的（`computer_builder.py`）：
- en: 'We define a `Computer` class, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个`Computer`类，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We define a `ComputerBuilder` class, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个`ComputerBuilder`类，如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We define a `HardwareEngineer` class, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个`HardwareEngineer`类，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We end our code with the `main()` function, followed by a trick to call it
    when the file is called from the command line, as illustrated in the following
    code snippet:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们以`main()`函数结束我们的代码，然后通过以下代码片段中的技巧在从命令行调用文件时调用它：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The basic changes are the introduction of a builder (`ComputerBuilder`), a director
    (`HardwareEngineer`), and the step-by-step construction of a computer, which now
    supports different configurations (notice that `memory`, `hdd`, and `gpu` are
    parameters and are not preconfigured). What do we need to do if we want to support
    the construction of tablets? Implement this as an exercise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的变化是引入了一个建造者（`ComputerBuilder`）、一个导演（`HardwareEngineer`）以及逐步构建一台电脑的过程，现在它支持不同的配置（注意`memory`、`hdd`和`gpu`是参数，而不是预先配置的）。如果我们想支持平板电脑的构建，我们应该如何操作？将此作为练习来实现。
- en: You might also want to change the computer's `serial_number` value into something
    different for each computer because as it is now, this means that all computers
    will have the same serial number (which is impractical).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想将电脑的`serial_number`值改为不同的值，因为现在，这意味着所有电脑都将有相同的序列号（这是不切实际的）。
- en: Implementing an ordering application
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现订购应用程序
- en: Let's see how we can use the builder design pattern to make a pizza-ordering
    application. The pizza example is particularly interesting because a pizza is
    prepared in steps that should follow a specific order. To add the sauce, you first
    need to prepare the dough. To add the topping, you first need to add the sauce.
    And you can't start baking the pizza unless both the sauce and the topping are
    placed on the dough. Moreover, each pizza usually requires a different baking
    time, depending on the thickness of its dough and the topping used.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用建造者设计模式来制作一个披萨订购应用程序。披萨的例子特别有趣，因为披萨的制备需要遵循特定的步骤顺序。要加酱料，你首先需要准备面团。要加配料，你首先需要加酱料。而且，除非酱料和配料都放在面团上，否则你不能开始烤披萨。此外，每种披萨通常需要不同的烘烤时间，这取决于面团厚度和使用的配料。
- en: 'We start by importing the required modules and declaring a few `Enum` parameters
    ([j.mp/pytenum](http://j.mp/pytenum)) plus a constant that is used many times
    in the application. The `STEP_DELAY` constant is used to add a time delay between
    the different steps of preparing a pizza (prepare the dough, add the sauce, and
    so on), as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入所需的模块，声明一些`Enum`参数（[j.mp/pytenum](http://j.mp/pytenum)）以及应用程序中多次使用的常量。`STEP_DELAY`常量用于在准备披萨的不同步骤之间添加时间延迟（如准备面团、加酱料等），如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our end product is a pizza, which is described by the `Pizza` class. When using
    the builder pattern, the end product does not have many responsibilities since
    it is not supposed to be instantiated directly. A builder creates an instance
    of the end product and makes sure that it is properly prepared. That's why the
    `Pizza` class is so minimal. It basically initializes all data to sane default
    values. An exception is the `prepare_dough()` method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的产品最终是披萨，它由`Pizza`类来描述。在使用建造者模式时，最终产品不需要承担太多责任，因为它不应该被直接实例化。建造者创建最终产品的实例并确保它被正确准备。这就是为什么`Pizza`类如此简洁。它基本上将所有数据初始化为合理的默认值。一个例外是`prepare_dough()`方法。
- en: The `prepare_dough()` method is defined in the `Pizza` class instead of a builder
    for two reasons—first, to clarify the fact that the end product is typically minimal,
    which does not mean that you should never assign it any responsibilities; second,
    to promote code reuse through composition.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepare_dough()`方法定义在`Pizza`类中而不是建造者中，有两个原因——首先，为了阐明最终产品通常是简洁的，这并不意味着你永远不应该给它分配任何责任；其次，为了通过组合来促进代码重用。'
- en: 'So, we define our `Pizza` class as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义我们的`Pizza`类如下：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are two builders: one for creating a margarita pizza (`MargaritaBuilder`)
    and another for creating a creamy bacon pizza (`CreamyBaconBuilder`). Each builder
    creates a `Pizza` instance and contains methods that follow the pizza-making procedure:
    `prepare_dough()`, `add_sauce()`, `add_topping()`, and `bake()`. To be precise,
    `prepare_dough()` is just a wrapper to the `prepare_dough()` method of the `Pizza`
    class.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个建造者：一个用于创建玛格丽塔披萨（`MargaritaBuilder`）和另一个用于创建奶油培根披萨（`CreamyBaconBuilder`）。每个建造者创建一个`Pizza`实例，并包含遵循披萨制作程序的各个方法：`prepare_dough()`、`add_sauce()`、`add_topping()`和`bake()`。更准确地说，`prepare_dough()`只是对`Pizza`类的`prepare_dough()`方法的包装。
- en: Notice how each builder takes care of all the pizza-specific details. For example,
    the topping of the margarita pizza is double mozzarella and oregano, while the
    topping of the creamy bacon pizza is mozzarella, bacon, ham, mushrooms, red onion,
    and oregano.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个建造者如何处理所有与披萨相关的细节。例如，玛格丽塔披萨的配料是双份马苏里拉奶酪和牛至，而奶油培根披萨的配料是马苏里拉奶酪、培根、火腿、蘑菇、红洋葱和牛至。
- en: 'This part of our code is laid out as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的这一部分布局如下：
- en: 'We define a `MargaritaBuilder` class, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`MargaritaBuilder`类，如下所示：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We define a `CreamyBaconBuilder` class, as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`CreamyBaconBuilder`类，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The director in this example is the waiter. The core of the `Waiter` class
    is the `construct_pizza()` method, which accepts a `builder` as a parameter and
    executes all the pizza-preparation steps in the right order. Choosing the appropriate
    builder, which can even be done at runtime, gives us the ability to create different
    pizza styles without modifying any of the code of the director (`Waiter`). The
    `Waiter` class also contains the `pizza()` method, which returns the end product
    (prepared pizza) as a variable to the caller, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，导演是服务员。`Waiter`类的核心是`construct_pizza()`方法，它接受一个`builder`作为参数，并按正确的顺序执行所有披萨准备步骤。选择合适的构建器，甚至可以在运行时完成，这使我们能够创建不同的披萨风格，而无需修改导演（`Waiter`）的任何代码。`Waiter`类还包含一个`pizza()`方法，该方法将最终产品（准备好的披萨）作为变量返回给调用者，如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `validate_style()` function is similar to the `validate_age()` function,
    as described in [*Chapter 16*](B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276),
    *The Factory Pattern*. It is used to make sure that the user gives valid input,
    which in this case is a character that is mapped to a pizza builder. The `m` character
    uses the `MargaritaBuilder` class, and the `c` character uses the `CreamyBaconBuilder`
    class. These mappings are in the builder parameter. A tuple is returned, with
    the first element set to `True` if the input is valid or `False` if it is invalid,
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_style()`函数与在[*第16章*](B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276)“工厂模式”中描述的`validate_age()`函数类似。它用于确保用户给出有效的输入，在这种情况下是一个映射到披萨构建器的字符。`m`字符使用`MargaritaBuilder`类，而`c`字符使用`CreamyBaconBuilder`类。这些映射在构建器参数中。返回一个元组，第一个元素如果输入有效则设置为`True`，如果无效则设置为`False`，如下所示：'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last part is the `main()` function. The `main()` function contains code
    for instantiating a pizza builder. The pizza builder is then used by the `Waiter`
    director for preparing the pizza. The created pizza can be delivered to the client
    at any later point. The code is illustrated in the following snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是`main()`函数。`main()`函数包含实例化披萨构建器的代码。然后，`Waiter`导演使用披萨构建器来准备披萨。制作的披萨可以在任何后续时间点交付给客户。代码在以下片段中展示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is a summary of the implementation (see the complete code in the `builder.py`
    file):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现总结（请参阅`builder.py`文件中的完整代码）：
- en: We start with a couple of imports we need, for the standard `Enum` class and
    the `time` module.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始于需要的一些导入，对于标准的`Enum`类和`time`模块。
- en: 'We declare variables for a few constants: `PizzaProgress`, `PizzaDough`, `PizzaSauce`,
    `PizzaTopping`, and `STEP_DELAY`.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一些常量的变量：`PizzaProgress`、`PizzaDough`、`PizzaSauce`、`PizzaTopping`和`STEP_DELAY`。
- en: We define our `Pizza` class.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了我们的`Pizza`类。
- en: We define classes for two builders, `MargaritaBuilder` and `CreamyBaconBuilder`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为两个构建器定义了类，`MargaritaBuilder`和`CreamyBaconBuilder`。
- en: We define our `Waiter` class.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了我们的`Waiter`类。
- en: We add the `validate_style()` function to improve things regarding exception
    handling.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了`validate_style()`函数来改进关于异常处理的事情。
- en: 'Finally, we have the `main()` function, followed by the snippet for calling
    it when the program is run. In the `main` function, the following happens:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`main()`函数，随后是程序运行时调用它的片段。在`main`函数中，以下操作会发生：
- en: We make it possible to choose the pizza builder based on the user's input, after
    validation via the `validate_style()` function.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过`validate_style()`函数的验证后，使根据用户的输入选择披萨构建器成为可能。
- en: The pizza builder is used by the waiter for preparing the pizza.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务员使用披萨构建器来准备披萨。
- en: The created pizza is then delivered.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后送出制作的披萨。
- en: 'Here is the output produced by calling the `python builder.py` command to execute
    this example program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`python builder.py`命令执行此示例程序时，产生了以下输出：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But…supporting only two pizza types is a shame. Feel like getting a Hawaiian
    pizza builder? Consider using inheritance after thinking about the advantages
    and disadvantages. Check the ingredients of a typical Hawaiian pizza and decide
    which class you need to extend: `MargaritaBuilder` or `CreamyBaconBuilder`? Perhaps
    both ([j.mp/pymulti](http://j.mp/pymulti))?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是……只支持两种披萨类型是件遗憾的事。想要一个夏威夷披萨构建器吗？考虑在考虑了优势和劣势之后使用继承。检查一下典型夏威夷披萨的配料，并决定你需要扩展哪个类：`MargaritaBuilder`还是`CreamyBaconBuilder`？也许两者都需要([j.mp/pymulti](http://j.mp/pymulti))？
- en: 'In his book, *Effective Java (Second Edition)*, Joshua Bloch describes an interesting
    variation of the builder pattern where calls to builder methods are chained. This
    is accomplished by defining the builder itself as an inner class and returning
    itself from each of the setter-like methods on it. The `build()` method returns
    the final object. This pattern is called the **fluent builder**. Here''s a Python
    implementation, which was kindly provided by a reviewer of the book:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《有效Java（第二版）》中，Joshua Bloch描述了一种有趣的构建器模式变体，其中构建器方法的调用是链式的。这是通过将构建器本身定义为内部类，并从其上的每个setter-like方法返回自身来实现的。`build()`方法返回最终对象。这种模式被称为**流畅构建器**。以下是一个Python实现，这是由本书的一位审稿人友好地提供的：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this fluent builder pattern, we see that we could quickly build the final
    `Pizza` object by chaining the `add_garlic()`, `add_extra_cheese()`, and `build()`
    methods on one line of code, which could come in handy in many situations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种流畅的构建器模式，我们可以看到，通过在一行代码中链式调用`add_garlic()`、`add_extra_cheese()`和`build()`方法，可以快速构建最终的`Pizza`对象，这在许多情况下都很有用。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to use the builder design pattern. We use
    the builder pattern for creating an object in situations where using the factory
    pattern (either a factory method or an abstract factory) is not a good option.
    The builder pattern is usually a better candidate than the factory pattern when
    we want to create a complex object, when different representations of an object
    are required, or when we want to create an object at one point in time but access
    it at a later point.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用构建器设计模式。当使用工厂模式（无论是工厂方法还是抽象工厂）不是一个好选择时，我们使用构建器模式来创建对象。当我们想要创建一个复杂对象，需要对象的不同表示，或者我们想要在某个时间点创建对象但在稍后访问它时，构建器模式通常比工厂模式是一个更好的选择。
- en: We saw how the builder pattern is used in fast-food restaurants for preparing
    meals, and how two third-party Django packages, `django-widgy` and `django-query-builder`,
    use it for generating HTML pages and dynamic SQL queries, respectively. We focused
    on the differences between the builder pattern and the factory pattern and provided
    a preconfigured (factory) and customer (builder) computer order analogy to clarify
    them. We also looked at how to create a pizza-ordering application with preparation
    dependencies. Throughout these examples, we have clearly seen the benefits and
    flexibility of the builder pattern, which will help you better approach future
    applications that require the design pattern.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了构建器模式如何在快餐店准备餐点时使用，以及两个第三方Django包`django-widgy`和`django-query-builder`如何分别用于生成HTML页面和动态SQL查询。我们关注了构建器模式和工厂模式之间的区别，并提供了预配置（工厂）和客户（构建器）计算机订单类比来澄清它们。我们还探讨了如何创建一个具有准备依赖关系的比萨订购应用程序。在这些示例中，我们清楚地看到了构建器模式的好处和灵活性，这将帮助你更好地处理未来需要设计模式的应用程序。
- en: In the next chapter, you will learn about other useful creational patterns.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习其他有用的创建型模式。
- en: Questions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the high-level applications of the builder pattern?
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建器模式有哪些高级应用？
- en: What are some common computer applications that require or benefit from the
    builder pattern?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些常见的计算机应用程序需要或从构建器模式中受益？
- en: How does the builder pattern create an object and how is that process different
    from what the factory pattern does?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建器模式是如何创建对象的，以及这个过程与工厂模式有何不同？
