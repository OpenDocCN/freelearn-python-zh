- en: Measuring Your Success with Test Coverage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过测试覆盖率来衡量您的成功
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Building a network management application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个网络管理应用程序
- en: Installing and running coverage on your test suite
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试套件上安装和运行覆盖率
- en: Generating an HTML report using coverage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用覆盖率生成HTML报告
- en: Generating an XML report using coverage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用覆盖率生成XML报告
- en: Getting nosy with coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用覆盖率工具进行测试
- en: Filtering out test noise from coverage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从覆盖率中过滤出测试噪音
- en: Letting Jenkins get nosy with coverage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让Jenkins使用覆盖率
- en: Updating the project-level script to provide coverage reports
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新项目级别的脚本以提供覆盖率报告
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '**Coverage** **analysis** is measuring which lines in a program are run and
    which lines aren''t. This type of analysis is also known as **code coverage**,
    or more simply **coverage**.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**覆盖率** **分析**是衡量程序中哪些行被执行，哪些行没有被执行。这种分析也被称为**代码覆盖率**，或更简单的**覆盖率**。'
- en: A coverage analyzer can be used while running a system in production, but what
    are the pros and cons of this? What about using a coverage analyzer when running
    test suites? What benefits would this approach provide compared to checking systems
    in production?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中运行时可以使用覆盖率分析器，但这样做有什么利弊呢？在运行测试套件时使用覆盖率分析器又有什么好处呢？与在生产环境中检查系统相比，这种方法会提供什么好处？
- en: Coverage helps us to see whether we are adequately testing our system. But it
    must be performed with a certain amount of skepticism. This is because, even if
    we achieve 100% coverage, meaning every line of our system was run, in no way
    does this guarantee us having no bugs. Testing can only uncover the presence of
    bugs. A quick example involves code we have written, and what it processes is
    the return value from a system call. What if there are three possible values,
    but we only handle two of them? We may write two test cases covering our handling
    of it, and this could certainly achieve 100% statement coverage. However, it doesn't
    mean we have handled the third possible return value, thus leaving us with a potentially
    undiscovered bug. 100% code coverage can also be obtained by condition coverage,
    but may not be achieved with statement coverage. The kind of coverage we are planning
    to target should be clear.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率帮助我们查看我们是否充分测试了我们的系统。但必须带着一定的怀疑心态进行。这是因为，即使我们实现了100%的覆盖率，也就是说我们的系统的每一行都被执行了，这绝不意味着我们没有错误。测试只能揭示错误的存在。一个快速的例子涉及到我们编写的代码，以及它处理的是系统调用的返回值。如果有三种可能的值，但我们只处理了其中的两种，我们可能编写了两个测试用例来覆盖我们对它的处理，这当然可以实现100%的语句覆盖。然而，这并不意味着我们已经处理了第三种可能的返回值，因此可能留下了一个潜在的未发现的错误。100%的代码覆盖率也可以通过条件覆盖率实现，但可能无法通过语句覆盖率实现。我们计划针对的覆盖类型应该是清楚的。
- en: Another key point is that not all testing is aimed at fixing bugs. Another key
    purpose is to make sure that the application meets our customer's needs. This
    means that, even if we have 100% code coverage, we can't guarantee that we are
    covering all the scenarios expected by our users. This is the difference between
    *building it right* and *building the right thing*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键点是，并非所有测试都旨在*修复*错误。另一个关键目的是确保应用程序满足我们客户的需求。这意味着，即使我们有100%的代码覆盖率，也不能保证我们覆盖了用户所期望的所有场景。这就是*正确构建*和*构建正确的东西*之间的区别。
- en: In this chapter, we will explore various recipes to build a network management
    application, run coverage tools, and harvest the results. We will discuss how
    coverage can introduce noise and show us more than we need to know, and we'll introduce
    performance issues when it implements our code. We will also see how to trim out
    information we don't need to get a concise, targeted view of things.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨各种示例，以构建网络管理应用程序，运行覆盖率工具，并收集结果。我们将讨论覆盖率如何引入噪音并向我们展示比我们需要了解的更多内容，并且在实现我们的代码时会引入性能问题。我们还将看到如何剔除我们不需要的信息，以获得简洁、有针对性的视图。
- en: 'This chapter uses several third-party tools in many recipes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在许多示例中使用了几个第三方工具：
- en: '**Spring Python** ([http://springpython.webfactional.com](http://springpython.webfactional.com))
    contains many useful abstractions. The one used in this chapter is its `DatabaseTemplate`,
    which provides easy ways to write SQL queries and updates without having to deal
    with Python''s verbose API. Install it by typing `pip install springpython`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Python** ([http://springpython.webfactional.com](http://springpython.webfactional.com))
    包含许多有用的抽象。本章中使用的是其`DatabaseTemplate`，它提供了一种简单的方法来编写SQL查询和更新，而无需处理Python冗长的API。通过输入`pip
    install springpython`来安装它。'
- en: Install the coverage tool by typing `pip install coverage`. This may fail because
    other plugins may install an older version of coverage. If so, uninstall coverage
    by typing `pip uninstall coverage`, and then install it again with `pip install
    coverage`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过输入`pip install coverage`来安装覆盖率工具。这可能会失败，因为其他插件可能会安装较旧版本的覆盖率。如果是这样，请通过输入`pip
    uninstall coverage`来卸载覆盖率，然后再次使用`pip install coverage`来安装。
- en: Nose, a useful test runner, is covered in [Chapter 2](part0083.html#2F4UM0-dd965cfd3480473da68e719fadb0727c),
    *Running Automated Test Suites with Nose*. Refer to that chapter to see how to
    install nose.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nose，一个有用的测试运行器，涵盖在[第2章](part0083.html#2F4UM0-dd965cfd3480473da68e719fadb0727c)中，*使用Nose运行自动化测试套件*。请参考该章节了解如何安装nose。
- en: Building a network management application
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个网络管理应用程序
- en: For this chapter, we will build a very simple network management application,
    write different types of test, and check their coverage. This network management
    application is focused on digesting alarms, also referred to as **network** **events**.
    This is different from certain other network management tools that focus on gathering
    SNMP alarms from devices.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将构建一个非常简单的网络管理应用程序，编写不同类型的测试，并检查它们的覆盖率。这个网络管理应用程序专注于处理警报，也称为**网络** **事件**。这与某些其他专注于从设备中收集SNMP警报的网络管理工具不同。
- en: For reasons of simplicity, this correlation engine doesn't contain complex rules,
    but instead contains a simple mapping of network events onto equipment and customer
    service inventory. We'll explore this in the next few paragraphs as we dig through
    the code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简单起见，这个相关引擎不包含复杂的规则，而是包含网络事件与设备和客户服务库存的简单映射。在接下来的几段中，我们将通过代码来探讨这一点。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will build a simple network management application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将构建一个简单的网络管理应用程序：
- en: Create a file called `network.py` to store the network application.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`network.py`的文件，用于存储网络应用程序。
- en: 'Create a class definition to represent a network event:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类定义来表示网络事件：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s have a look at few properties of `self`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`self`的一些属性：
- en: '`hostname`: It is assumed that all network alarms originate from pieces of
    equipment that have a hostname.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostname`：假设所有网络警报都来自具有主机名的设备。'
- en: '`condition`: This indicates the type of alarm being generated. Two different
    alarm conditions can come from the same device.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`condition`：这表示正在生成的警报类型。来自同一设备的两种不同的警报条件。 '
- en: '`severity`: `1` indicates a clear, green status, and `5` indicates a faulty,
    red status.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`severity`：`1`表示清晰的绿色状态，`5`表示故障的红色状态。'
- en: '`id`: This is the primary key value used when the event is stored in a database.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是事件存储在数据库中时使用的主键值。'
- en: Create a new file called `network.sql` to contain the SQL code.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`network.sql`的新文件，包含SQL代码。
- en: 'Create a SQL script that sets up the database and adds the definition for storing
    network events:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个SQL脚本，用于设置数据库并添加存储网络事件定义：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code a high-level algorithm where events are assessed for their impact on equipment
    and customer services, and add it to `network.py`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个高级算法，评估事件对设备和客户服务的影响，并将其添加到`network.py`中：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `init` method contains some setup code for creating a `DatabaseTemplate`.
    This is a Spring Python utility class used for database operations. See [https://docs.spring.io/spring-python/1.2.x/sphinx/html/dao.html](https://docs.spring.io/spring-python/1.2.x/sphinx/html/dao.html)
    for more details. We are also using *SQLite3* as our database engine, since it
    is a standard part of Python.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`方法包含一些用于创建`DatabaseTemplate`的设置代码。这是Spring Python的一个用于数据库操作的实用类。有关更多详细信息，请参阅[https://docs.spring.io/spring-python/1.2.x/sphinx/html/dao.html](https://docs.spring.io/spring-python/1.2.x/sphinx/html/dao.html)。我们还使用*SQLite3*作为我们的数据库引擎，因为它是Python的标准部分。'
- en: 'The process method contains some simple steps to process an incoming event:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: process方法包含一些简单的步骤来处理传入的事件：
- en: We first need to store the event in the `EVENTS` table. This includes evaluating
    whether or not it is an active event, meaning that it is actively impacting a
    piece of equipment.
  id: totrans-40
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先需要将事件存储在`EVENTS`表中。这包括评估它是否是一个活动事件，这意味着它正在积极影响一件设备。
- en: Then we determine what equipment and what services the event impacts.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们确定事件影响的设备和服务。
- en: Next, we update the affected service by determining whether it causes any service
    outages or restorations.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们通过确定它是否导致任何服务中断或恢复来更新受影响的服务。
- en: Then we update the affected equipment by determining whether it fails or clears
    a device.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们通过确定它是否失败或清除设备来更新受影响的设备。
- en: Finally, we return a tuple containing all the affected assets to support any
    screen interfaces that could be developed on top of this.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们返回一个包含所有受影响资产的元组，以支持可能在其上开发的任何屏幕界面。
- en: 'Implement the `store_event` algorithm:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`store_event`算法：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method stores every event that is processed. This supports many things,
    including data mining and the post-mortem analysis of outages. It is also the
    authoritative place where other event-related data can point back using a foreign
    key:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存储了每个被处理的事件。这支持许多事情，包括数据挖掘和故障的事后分析。这也是其他与事件相关的数据可以使用外键指向的权威位置：
- en: The `store_event` method looks up the maximum primary key value from the `EVENTS`
    table.
  id: totrans-48
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store_event`方法从`EVENTS`表中查找最大的主键值。'
- en: It increments it by `1`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其增加`1`。
- en: It assigns it to `event.id`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其分配给`event.id`。
- en: It then inserts it into the `EVENTS` table.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将其插入`EVENTS`表中。
- en: Next, it calls a method to evaluate whether or not the event should be added
    to the list of active events, or if it clears out existing active events. Active
    events are events that are actively causing a piece of equipment to be unclear.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，它调用一个方法来评估事件是否应该添加到活动事件列表，或者是否清除现有的活动事件。活动事件是指正在积极导致设备不清晰的事件。
- en: Finally, it returns a tuple containing the event and whether or not it was classified
    as an active event.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它返回一个包含事件以及是否被分类为活动事件的元组。
- en: For a more sophisticated system, some sort of partitioning solution needs to
    be implemented. Querying against a table containing millions of rows is very inefficient.
    However, this is for demonstration purposes only, so we will skip scaling as well
    as performance and security.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的系统，需要实现某种分区解决方案。针对包含数百万行的表进行查询非常低效。但是，这仅用于演示目的，因此我们将跳过扩展以及性能和安全性。
- en: 'Implement a method to evaluate whether to add or remove active events:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个方法来评估是否添加或删除活动事件：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When a device fails, it sends a `severity 5` event. This is an active event,
    and in this method a row is inserted into the `ACTIVE_EVENTS` table with a foreign
    key pointing back to the `EVENTS` table. Then we return `True`, indicating that
    this is an active event.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备故障时，它会发送一个`severity 5`事件。这是一个活动事件，在这种方法中，将一行插入`ACTIVE_EVENTS`表中，并使用外键指向`EVENTS`表。然后我们返回`True`，表示这是一个活动事件。
- en: 'Add the table definition for `ACTIVE_EVENTS` to the SQL script:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ACTIVE_EVENTS`的表定义添加到SQL脚本中：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This table makes it easy to query what events are currently causing equipment
    failures.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表使得查询当前导致设备故障的事件变得容易。
- en: Later, when the failing condition on the device clears, it sends a `severity
    1` event. This means that `severity 1` events are never active, since they aren't
    contributing  to a piece of equipment being down. In our previous method, we search
    for any active events that have the same hostname and condition, and delete them.
    Then we return `False`, indicating this is not an active event.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当设备上的故障条件消除时，它会发送一个`severity 1`事件。这意味着`severity 1`事件从不是活动的，因为它们不会导致设备停机。在我们之前的方法中，我们搜索具有相同主机名和条件的任何活动事件，并将其删除。然后我们返回`False`，表示这不是一个活动事件。
- en: 'Write a method that evaluates the services and pieces of equipment that are
    affected by the network event:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个评估受网络事件影响的服务和设备的方法：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We first query the `EQUIPMENT` table to see if `event.hostname` matches anything.
  id: totrans-64
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先查询`EQUIPMENT`表，看看`event.hostname`是否匹配任何内容。
- en: Next, we join the `SERVICE` table to the `EQUIPMENT` table through a many-to-many
    relationship tracked by the `SERVICE_MAPPING` table. Any service that is related
    to the equipment that the event was reported on is captured.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们通过`SERVICE_MAPPING`表跟踪的多对多关系将`SERVICE`表与`EQUIPMENT`表连接起来。捕获与报告事件相关的设备相关的任何服务。
- en: Finally, we return a tuple containing both the list of equipment and list of
    services that are potentially impacted.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们返回一个包含可能受到影响的设备列表和服务列表的元组。
- en: Spring Python provides a convenient query operation that returns a list of objects
    mapped to every row of the query. It also provides an out-of-the-box `DictionaryRowMapper`
    that converts each row into a Python dictionary, with the keys matching the column
    names.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Python提供了一个方便的查询操作，该操作返回映射到查询每一行的对象列表。它还提供了一个开箱即用的`DictionaryRowMapper`，将每一行转换为Python字典，其中键与列名匹配。
- en: 'Add the table definitions to the SQL script for `EQUIPMENT`, `SERVICE`, and `SERVICE_MAPPING`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`EQUIPMENT`，`SERVICE`和`SERVICE_MAPPING`的表定义添加到SQL脚本中：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Write the `update_service` method, which stores or clears service-related events
    and then updates the service''s status based on the remaining active events:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`update_service`方法，该方法存储或清除与服务相关的事件，然后根据剩余的活动事件更新服务的状态：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Service-related events are active events related to a service. A single event
    can be related to many services. For example, what if we were monitoring a wireless
    router that provided internet service to a lot of users, and it reported a critical
    error? This one event would be mapped as an impact to all the end users. When
    a new active event is processed, it is stored in `SERVICE_EVENTS` for each related
    service.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务相关的事件是与服务相关的活动事件。单个事件可以与多个服务相关联。例如，如果我们监视提供互联网服务给许多用户的无线路由器，并且它报告了严重错误，那么这一个事件将被映射为对所有最终用户的影响。当处理新的活动事件时，它将存储在`SERVICE_EVENTS`中，以供每个相关服务使用。
- en: Then, when a clearing event is processed, the previous service event must be
    deleted from the `SERVICE_EVENTS` table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当清除事件被处理时，必须从`SERVICE_EVENTS`表中删除先前的服务事件。
- en: 'Add the table definition for `SERVICE_EVENTS` to the SQL script:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SERVICE_EVENTS`的表定义添加到SQL脚本中：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is important to recognize that deleting an entry from `SERVICE_EVENTS` doesn't
    mean that we delete the original event from the `EVENTS` table. Instead, we are
    merely indicating that the original active event is no longer active and it does
    not impact the related service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，从`SERVICE_EVENTS`中删除条目并不意味着我们从`EVENTS`表中删除原始事件。相反，我们只是表明原始活动事件不再是活动的，它不会影响相关服务。
- en: 'Prepend the entire SQL script with `DROP` statements, making it possible to
    run the script for several recipes:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在整个SQL脚本之前加上`DROP`语句，使其可以运行多个配方：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Append the SQL script used to set up the database with inserts to pre-load
    some equipment and services:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加用于设置数据库的SQL脚本，其中包含用于预先加载一些设备和服务的插入操作：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, write a method that updates the equipment status based on the currently
    active events:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写一个根据当前活动事件更新设备状态的方法：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we need to find the maximum severity from the list of active events for
    a given host name. If there are no active events, then Spring Python raises a
    DataAccessException and we translate that to a severity of 1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要从给定主机名的活动事件列表中找到最大的严重性。如果没有活动事件，那么Spring Python会引发DataAccessException，我们将其转换为严重性为1。
- en: We check whether this is different from the existing device's status. If so,
    we issue a SQL update. Finally, we return the record for the device, with its
    status updated appropriately.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查这是否与现有设备的状态不同。如果是，我们发出SQL更新。最后，我们返回设备的记录，并适当更新其状态。
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This application uses a database-backed mechanism to process incoming network
    events, and checks them against the inventory of equipment and services to evaluate
    failures and restorations. Our application doesn't handle specialized devices
    or unusual types of service. This real-world complexity has been traded in for
    a relatively simple application that can be used to write various test recipes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序使用基于数据库的机制来处理传入的网络事件，并将其与设备和服务清单进行比对，以评估故障和恢复。我们的应用程序不处理专门的设备或不寻常的服务类型。这种现实世界的复杂性已被交换为一个相对简单的应用程序，可以用来编写各种测试配方。
- en: Events typically map to a single piece of equipment and to zero or more services.
    A service can be thought of as a string of equipment used to provide a type of
    service to the customer. New failing events are considered active until a clearing
    event arrives. Active events, when aggregated against a piece of equipment, define
    its current status. Active events, when aggregated against a service, define the
    service's current status.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通常映射到单个设备和零个或多个服务。可以将服务视为用于向客户提供某种类型服务的设备字符串。新的失败事件在清除事件到来之前被视为活动。活动事件在与设备聚合时定义其当前状态。活动事件在与服务聚合时定义服务的当前状态。
- en: Installing and running coverage on your test suite
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试套件上安装和运行覆盖率
- en: Install the coverage tool and run it against your test suite. Then you can view
    a report showing what lines were covered by the test suite.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 安装覆盖工具并运行它对测试套件进行测试。然后您可以查看报告，显示测试套件覆盖了哪些行。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will build some unittests and then run them through
    the coverage tool:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将构建一些unittests，然后通过覆盖工具运行它们：
- en: Create a new file called `recipe52.py` to contain our test code for this recipe.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe52.py`的新文件，包含本配方的测试代码。
- en: 'Write a simple unit test that injects a single, alarming event into the system:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个简单的单元测试，向系统注入一个警报事件：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Clear out any existing coverage report data using `coverage -e`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`coverage -e`清除任何现有的覆盖报告数据。
- en: 'Run the test suite using the coverage tool:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用覆盖工具运行测试套件：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Print out the report captured by the previous command by typing `coverage -r`.
    If the report shows several other modules listed from Python''s standard libraries,
    it''s a hint that you have an older version of the coverage tool installed. If
    so, uninstall the old version by typing `pip uninstall coverage` followed by reinstalling
    with `pip install coverage`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`coverage -r`打印出上一个命令捕获的报告。如果报告显示了Python标准库中列出的几个其他模块，这表明您安装了旧版本的覆盖工具。如果是这样，请通过输入`pip
    uninstall coverage`卸载旧版本，然后使用`pip install coverage`重新安装：
- en: '![](../images/00122.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00122.jpeg)'
- en: Create another file called `recipe52b.py` to contain a different test suite.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`recipe52b.py`的文件，包含不同的测试套件。
- en: 'Write another test suite that generates two faults and then clears them out:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写另一个测试套件，生成两个故障，然后清除它们：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run this test suite through the coverage tool using `coverage -x recipe52b.py`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`coverage -x recipe52b.py`使用覆盖工具运行此测试套件。
- en: 'Print out the report by typing `coverage -r`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`coverage -r`打印报告：
- en: '![](../images/00123.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00123.jpeg)'
- en: The first test suite only injects a single alarm. We expect it to cause a service
    outage and take its related piece of equipment down. Since this would *not* exercise
    any event clearing logic, we certainly don't expect 100% code coverage.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试套件只注入了一个警报。我们期望它会导致服务中断并使其相关的设备停机。由于这不会执行任何事件清除逻辑，我们当然不期望达到100%的代码覆盖率。
- en: In the report, we can see that it says `network.py` had 65 statements, and has
    executed 55 of them, resulting in 85% coverage. We also see that `recipe52.py`
    had 23 statements and executed all of them. This means all of our test code ran.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告中，我们可以看到它说`network.py`有65个语句，执行了其中的55个，覆盖率为85%。我们还看到`recipe52.py`有23个语句，全部执行了。这意味着我们的所有测试代码都运行了。
- en: At this point, we realize that we are only testing the alarming part of the
    event correlator. To make this more effective, we should inject another alarm,
    followed by a couple of clears to make sure that everything clears out and the
    services return to operational status. This should result in 100% coverage in
    our simple application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们意识到我们只测试了事件相关器的警报部分。为了使这更有效，我们应该注入另一个警报，然后进行一些清除操作，以确保一切都清除干净，服务返回到运行状态。这应该导致我们的简单应用程序实现100%的覆盖率。
- en: The second screenshot indeed shows that we have reached full coverage of `network.py`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个截图确实显示我们已经完全覆盖了`network.py`。
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We also see Spring Python reported as well. If we had used any other third-party
    libraries, then they would also appear. Is this right? It depends. The previous
    comments seem to indicate that we don't really care about coverage of Spring Python,
    but in other situations, we might be very interested. And how can the coverage
    tool know where to draw the line?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到Spring Python也被报告了。如果我们使用了其他第三方库，它们也会出现。这是正确的吗？这取决于情况。先前的评论似乎表明我们并不真的关心Spring
    Python的覆盖范围，但在其他情况下，我们可能会非常感兴趣。覆盖工具如何知道在哪里划定界限呢？
- en: In later recipes, we will look into how to be more selective of what to measure
    so we can filter out the noise.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的配方中，我们将研究如何更有选择性地进行测量，以便过滤掉噪音。
- en: Why are there no asserts in unittest?
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么unittest中没有断言？
- en: It is true that unittest isn't adequate with regard to testing outcomes. To
    draw up this recipe, I visually inspected the output to see whether the network
    management application was performing as expected. But this is incomplete. A real
    production grade unit test needs to finish this with a set of assertions so that
    visual scanning is not needed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，unittest在测试结果方面是不够的。为了制定这个配方，我目视检查输出，以查看网络管理应用程序是否按预期运行。但这是不完整的。一个真正的生产级单元测试需要以一组断言完成，这样就不需要进行视觉扫描了。
- en: So why didn't we code any? Because the focus of this recipe was on how to generate
    a coverage report and then use that information to enhance the testing. We covered
    both of these things. By thinking about what was and wasn't tested, we wrote a
    comprehensive test that shows services going into outage and back to operational
    status. We just didn't just confirm this automatically.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们没有编写任何代码呢？因为这个配方的重点是如何生成覆盖报告，然后利用这些信息来增强测试。我们涵盖了这两个方面。通过思考测试了什么和没有测试的内容，我们编写了一个全面的测试，显示了服务进入故障和恢复到运行状态。我们只是没有自动确认这一点。
- en: Generating an HTML report using coverage
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用覆盖生成HTML报告
- en: Using the coverage tool, generate an HTML visual coverage report. This is useful
    because we can drill into the source code and see what lines did not run in the
    test procedures.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用覆盖工具生成HTML可视化覆盖报告。这很有用，因为我们可以深入到源代码中，看看测试过程中没有运行的代码行。
- en: Reading a coverage report without reading the source code is not very useful.
    It may be tempting to compare two different projects based on the coverage percentages.
    But unless the actual code is analyzed, this type of comparison can lead to faulty
    conclusions about the quality of the software.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读覆盖报告而不阅读源代码是没有什么用的。根据覆盖百分比比较两个不同的项目可能很诱人。但是除非实际代码被分析，否则这种比较可能导致对软件质量的错误结论。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will explore creating a nicely viewable HTML coverage
    report:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将探讨如何创建一个可视化的HTML覆盖报告：
- en: Generate coverage metrics by following the steps in the *Installing and running
    coverage* *on your test suite* recipe and only running the first test suite (which
    resulted in less than 100% coverage).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按照*在您的测试套件上安装和运行覆盖*的步骤生成覆盖度指标，并且只运行第一个测试套件（覆盖率低于100%）。
- en: Generate an HTML report by typing `coverage.html`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`coverage.html`生成HTML报告。
- en: 'Open `htmlcov/index.html` using your favorite browser and inspect the overall
    report:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的浏览器打开`htmlcov/index.html`并检查整体报告：
- en: '![](../images/00124.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00124.jpeg)'
- en: 'Click on network, and scroll down to see where the event clearing logic didn''t
    run due to no clearing events being processed:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“network”，并向下滚动以查看由于未处理清除事件而未运行的事件清除逻辑：
- en: '![](../images/00125.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00125.jpeg)'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The coverage tool has a built-in feature to generate an HTML report. This provides
    a powerful way to visually inspect the source code and see which lines were not
    executed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖工具具有内置功能生成HTML报告。这提供了一种强大的方式来直观地检查源代码，并查看哪些行未被执行。
- en: By looking at this report, we can clearly see that the lines that were not executed
    relate to the lack of clearing network events that are being processed. This tips
    us off about another test case, which involves clearing events that need to be
    drafted.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这份报告，我们可以清楚地看到未执行的行与正在处理的网络事件清除相关。这提示我们另一个测试案例，涉及需要起草的事件清除。
- en: Generating an XML report using coverage
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用覆盖率生成XML报告
- en: The coverage tool can generate an XML coverage report in Cobertura format ([http://cobertura.sourceforge.net/](http://cobertura.sourceforge.net/)).
    This is useful if we want to process the coverage information in another tool.
    In this recipe, we will see how to use the coverage command-line tool, and then
    view the XML report by hand.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖工具可以以Cobertura格式（[http://cobertura.sourceforge.net/](http://cobertura.sourceforge.net/)）生成XML覆盖报告。如果我们想要在另一个工具中处理覆盖信息，这是很有用的。在这个配方中，我们将看到如何使用覆盖命令行工具，然后手动查看XML报告。
- en: It's important to understand that reading a coverage report without reading
    the source code   is not very useful. It may be tempting to compare two different
    projects based on the coverage percentages. But unless the actual code is analyzed,
    this type of comparison can lead to  faulty conclusions about the quality of the
    software.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，阅读覆盖率报告而不阅读源代码并不是很有用。可能会诱人根据覆盖率百分比比较两个不同的项目。但除非实际代码被分析，这种比较可能导致对软件质量的错误结论。
- en: For example, a project with 85% coverage may appear, on the surface, to be better
    tested than one with 60%. However, if the 60% application has much more thoroughly
    exhaustive scenarios—as they are only covering the core parts of the system that
    are in heavy use—then it may be much more stable than the 85% application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个覆盖率为85%的项目表面上看起来可能比一个60%的项目测试得更好。然而，如果60%的应用程序有更加彻底详尽的场景——因为它们只覆盖了系统中使用频繁的核心部分——那么它可能比85%的应用程序更加稳定。
- en: Coverage analysis serves a useful purpose when comparing test results between
    iterations, and when we use it to decide which scenarios need to be added to our
    testing repertoire.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较迭代之间的测试结果，并且用它来决定哪些场景需要添加到我们的测试库时，覆盖分析就发挥了作用。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will discover how to create an XML report that is consumable
    by other tools, using the coverage tool:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将发现如何创建一个可以被其他工具使用的XML报告，使用覆盖工具：
- en: Generate coverage metrics by following the steps in *Installing and running
    coverage* *on your test suite* recipe (mentioned in [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c),
    *Using Unittest to Develop Basic* *Tests*) and only running the first test suite
    (which resulted in less than 100% coverage).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按照*安装和运行覆盖* *在您的测试套件上*配方中的步骤生成覆盖度指标（在[第1章](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c)中提到，*使用Unittest开发基本*
    *测试*），并且只运行第一个测试套件（覆盖率低于100%）。
- en: Generate an XML report by typing `coverage xml`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`coverage xml`生成XML报告。
- en: 'Open `coverage.xml` using your favorite text or XML editor. The format of the
    XML is the same as Cobertura—a Java code coverage analyzer. This means that many
    tools, such as Jenkins, can parse the results:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本或XML编辑器打开`coverage.xml`。XML的格式与Cobertura一样——这是一个Java代码覆盖率分析器。这意味着许多工具，如Jenkins，可以解析结果：
- en: '![](../images/00126.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00126.jpeg)'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The coverage tool has a built-in feature that generates an XML report. This
    provides a powerful way to parse the output using some type of external tool.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖工具具有内置功能，可以生成XML报告。这提供了一种使用某种外部工具解析输出的强大方式。
- en: In the previous screenshot, I opened it using Spring Tool Suite (you can download
    it from [http://www.springsource.com/developer/sts)](http://www.springsource.com/developer/sts)),
    partly because I happen to use STS every day, but you can use any text or XML
    editor you like.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图中，我使用了Spring Tool Suite打开它（您可以从[http://www.springsource.com/developer/sts)](http://www.springsource.com/developer/sts)下载它），部分原因是因为我每天都在使用STS，但您可以使用任何您喜欢的文本或XML编辑器。
- en: What use is an XML report?
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML报告有什么用？
- en: XML is not the best way to communicate coverage information to users. *Generating
    an HTML* *report with coverage* is a more practical recipe when it comes to human
    users.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: XML不是向用户传达覆盖信息的最佳方式。*生成带覆盖的HTML* *报告*是在涉及人类用户时更实用的配方。
- en: What if we want to capture a coverage report and publish it inside a continuous
    integration system such as Jenkins? All we need to do is install the Cobertura
    plugin (refer to [https://wiki.jenkins-ci.org/display/JENKINS/Cobertura+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Cobertura+Plugin)),
    and this report becomes traceable. Jenkins can nicely monitor trends in coverage
    and give us more feedback as we develop our system.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想捕获覆盖率报告并将其发布到Jenkins等持续集成系统中，我们只需要安装Cobertura插件（参考[https://wiki.jenkins-ci.org/display/JENKINS/Cobertura+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Cobertura+Plugin)），这份报告就可以被追踪。Jenkins可以很好地监控覆盖率的趋势，并在我们开发系统时给予更多反馈。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Letting Jenkins get nosy with coverage*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*让Jenkins与覆盖一起多管闲事*'
- en: '*Generating an HTML report using coverage*'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用覆盖生成HTML报告*'
- en: Getting nosy with coverage
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与覆盖一起变得多管闲事
- en: Install the coverage nose plugin, and run your test suite using nose. This provides
    a quick and convenient report using the ubiquitous nosetests tool. This recipe
    assumes you have already created the network management application as described
    in the *Building a network* *management application* section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 安装覆盖鼻子插件，并使用鼻子运行测试套件。这提供了一个快速和方便的报告，使用无处不在的nosetests工具。本教程假设您已经按照*构建网络* *管理应用程序*部分的描述创建了网络管理应用程序。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'With these steps, we will see how to combine the coverage tool with nose:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将看到如何将覆盖工具与鼻子结合使用：
- en: Create a new file called `recipe55.py` to store our test code.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe55.py`的新文件来存储我们的测试代码。
- en: 'Create a test case that injects a faulty alarm:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试用例，注入一个有故障的警报：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the test module using the coverage plugin by typing `nosetests recipe55
    – with-coverage`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用覆盖插件运行测试模块，输入`nosetests recipe55 – with-coverage`：
- en: '![](../images/00127.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00127.jpeg)'
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The nose plugin for coverage invokes the coverage tool and provides a formatted
    report. For each module, it displays the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖鼻子插件调用覆盖工具并提供格式化的报告。对于每个模块，它显示以下内容：
- en: Total number of statements
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总语句数
- en: Number of missed statements
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错过的语句数量
- en: Percentage of covered statements
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖语句的百分比
- en: Line numbers for the missed statements
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错过语句的行号
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A common behavior of nose is to alter `stdout`, disabling the `print` statements
    embedded in the test case.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 鼻子的一个常见行为是改变`stdout`，禁用嵌入在测试用例中的`print`语句。
- en: Why use the nose plugin instead of the coverage tool directly?
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用鼻子插件而不是直接使用覆盖工具？
- en: The coverage tool works fine by itself, as was demonstrated in other recipes
    in this chapter. However, nose is a ubiquitous testing tool used by many developers.
    Providing a plugin makes it easy to support this vast community by empowering
    users to run the exact set of test plugins they want, with coverage being part
    of that test complement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖工具本身可以很好地工作，就像本章中的其他教程中所演示的那样。然而，鼻子是许多开发人员使用的无处不在的测试工具。提供一个插件可以轻松支持这个庞大的社区，使用户能够运行他们想要的确切的测试插件集，其中覆盖是其中的一部分。
- en: Why are SQLite3 and Spring Python included?
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么包括SQLite3和Spring Python？
- en: SQLite3 is a relational database library that is included with Python. It is
    file-based, which means that no separate processes are required to create and
    use a database. Details about Spring Python can be found in the earlier sections
    of this chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite3是Python附带的关系数据库库。它是基于文件的，这意味着不需要单独的进程来创建和使用数据库。有关Spring Python的详细信息可以在本章的早期部分找到。
- en: The purpose of this recipe was to measure the coverage of our network management
    application and the corresponding test case. So why are these third-party libraries
    included? The coverage tool has no way of automatically knowing what we want and
    the things we don't want to see from a coverage perspective. To delve into this,
    refer to the next section, *Filtering out* *test noise from coverage*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的目的是测量我们的网络管理应用程序和相应的测试用例的覆盖范围。那么为什么包括这些第三方库？覆盖工具无法自动知道我们想要的和我们不想从覆盖的角度看到的东西。要深入了解这一点，请参阅下一节，*过滤掉*
    *覆盖中的测试噪音*。
- en: Filtering out test noise from coverage
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从覆盖中过滤掉测试噪音
- en: Using command-line options, you can filter out counted lines. This recipe assumes
    you have already created the network management application as described in the
    *Building a network* *management application* section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行选项，可以过滤掉计算的行。本教程假设您已经按照*构建网络* *管理应用程序*部分的描述创建了网络管理应用程序。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'With these steps, we will see how to filter out certain modules from being
    counted in our coverage report:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将看到如何过滤掉某些模块在我们的覆盖报告中被计算。
- en: 'Create a test suite that exercises all the code functionality:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试套件，测试所有代码功能：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Clear out any previous coverage data by running `coverage -e`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`coverage -e`清除任何先前的覆盖数据。
- en: Run it using `coverage -x recipe56.py`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`coverage -x recipe56.py`运行它。
- en: 'Generate a console report using `coverage -r`. In the following screenshot,
    observe how Spring Python is included in the report and reduces the total metric
    to 73%:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`coverage -r`生成控制台报告。在下面的截图中，观察Spring Python如何包含在报告中，并将总度量减少到73%：
- en: '![](../images/00128.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00128.jpeg)'
- en: Clean out coverage data by running `coverage -e`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`coverage -e`清除覆盖数据。
- en: Run the test again using `coverage run –source network.py,recipe56.py,recipe56.py`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`coverage run –source network.py,recipe56.py,recipe56.py`运行测试。
- en: 'Generate another console report using `coverage -r`. Notice in the next screenshot
    how Spring Python is no longer listed, bringing our total coverage back up to
    100%:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`coverage -r`生成另一个控制台报告。请注意在下一个截图中，Spring Python不再列出，将我们的总覆盖范围提高到100%：
- en: '![](../images/00129.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00129.jpeg)'
- en: Clean out coverage data by running `coverage -e`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除覆盖数据，运行`coverage -e`。
- en: Run the test using `coverage -x recipe56.py`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`coverage -x recipe56.py`运行测试。
- en: 'Generate a console report using `coverage -r recipe56.py network.py`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`coverage -r recipe56.py network.py`生成控制台报告：
- en: '![](../images/00130.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00130.jpeg)'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Coverage provides the ability to decide which files will be analyzed and what
    files will be reported. The steps in the previous section gather metrics several
    times, either by running coverage with a restricted set of source files (in order
    to filter out Spring Python), or by requesting an explicit set of modules in the
    report.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖提供了决定分析哪些文件和报告哪些文件的能力。前一节中的步骤多次收集度量标准，要么通过使用一组受限的源文件运行覆盖（以过滤掉Spring Python），要么通过在报告中请求一组显式的模块。
- en: One question that arises from all this is, *What's the best choice?* For our
    test scenario, the two choices were equivalent. With approximately the same amount
    of typing, we filtered out Spring Python and got a report showing `network.py`
    and `recipe56.py` with 100% coverage either way. However, a real project with
    a lot of modules and possibly different teams working in different areas would
    probably do better by gathering all the metric data available and filtering at
    the report level.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切引发的一个问题是，“最好的选择是什么？”对于我们的测试场景，这两个选择是等效的。大约输入相同数量的内容，我们过滤掉了Spring Python，并得到了一个报告，显示`network.py`和`recipe56.py`的覆盖率都达到了100%。然而，一个真实的项目可能会更好地收集所有可用的度量数据，并在报告级别进行过滤，尤其是在有很多模块和可能不同团队在不同领域工作的情况下。
- en: This way, different reports on subsystems can be run as needed without having
    to keep recapturing metric data, and an overall report can still be run for the
    whole system coverage, all from the same gathered data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，可以根据需要运行子系统的不同报告，而无需不断重新捕获度量数据，并且仍然可以从相同的收集数据中运行整个系统覆盖率的总体报告。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The options used in the previous section were inclusive. We picked what was
    to be included. The coverage tool also comes with an `–omit` option. The challenge
    is that it's a file-based option, not module-based. It doesn't work to use `–omit
    springpython`. Instead, every file must be specified, and in this case that would
    have required four complete files to exclude it all.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中使用的选项是包容性的。我们选择了要包含的内容。覆盖工具还带有一个`-omit`选项。挑战在于它是一个基于文件的选项，而不是基于模块的选项。不能使用`-omit
    springpython`。相反，必须指定每个文件，而在这种情况下，这将需要排除四个完整的文件。
- en: To further complicate this, the full paths for the Spring Python files need
    to be included. This results in a very lengthy command, not providing much of
    a benefit over the ways we demonstrated.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，Spring Python文件的完整路径需要包含在内。这导致一个非常冗长的命令，与我们演示的方式相比并没有太多好处。
- en: In other situations, if the file to be excluded is local to where coverage is
    being run, then it might be more practical.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，如果要排除的文件是在运行覆盖率的地方，则可能更实际。
- en: The coverage tool has other options not covered in this chapter, such as measuring
    branch coverage instead of statement coverage, excluding lines, and the ability
    to run in parallel to manage collecting metrics from multiple processes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖工具还有其他在本章未涉及的选项，例如测量分支覆盖率而不是语句覆盖率，排除行，以及能够并行运行以管理从多个进程收集度量。
- en: As mentioned previously, the coverage tool has the ability to filter out individual
    lines. In my opinion, this sounds very much like trying to get the coverage report
    to meet some mandated percentage. The coverage tool is best used to work towards
    writing more comprehensive tests, fixing bugs, and improving development, and
    not towards building a better report.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，覆盖工具有能力过滤掉单独的行。在我看来，这听起来很像试图使覆盖率报告达到某个规定的百分比。覆盖工具最好用于努力编写更全面的测试、修复错误和改进开发，而不是用于构建更好的报告。
- en: See also
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Building a network management application* recipe earlier in the chapter
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的“构建网络管理应用程序”配方中
- en: Letting Jenkins get nosy with coverage
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让Jenkins与覆盖率挂钩
- en: Configure Jenkins to run a test suite using nose, generating a coverage report.
    This recipe assumes you have already created the network management application
    as described in the *Building a network management application* section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Jenkins运行一个使用nose的测试套件，生成一个覆盖率报告。本配方假设您已经按照“构建网络管理应用程序”部分的描述创建了网络管理应用程序。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let''s look at the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: If you have already downloaded Jenkins and used it for previous recipes, look
    for a `.jenkins` folder in your home directory and delete it, to avoid unexpected
    variances caused by this recipe.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经下载了Jenkins并在之前的配方中使用过它，请在您的主目录中查找一个`.jenkins`文件夹并将其删除，以避免此配方引起的意外差异。
- en: Install Jenkins.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Jenkins。
- en: Open the console to confirm that Jenkins is working:![](../images/00131.jpeg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台以确认Jenkins是否正常工作：![](../images/00131.jpeg)
- en: Click on Manage Jenkins.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“管理Jenkins”。
- en: Click on Manage Plugins.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“管理插件”。
- en: Click on the Available tab.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“可用”选项卡。
- en: Find the `Cobertura Plugin` and click the checkbox next to it.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到“Cobertura插件”并在其旁边点击复选框。
- en: Find the `Git Plugin` and click the checkbox next to it.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到“Git插件”并在其旁边点击复选框。
- en: At the bottom of the page, click on the Install button.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面底部，点击“安装”按钮。
- en: Navigate back to the dashboard screen.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回仪表板屏幕。
- en: Shut down Jenkins and start it again.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭Jenkins并重新启动它。
- en: Install Git source code control on your machine.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的计算机上安装Git源代码控制。
- en: 'Create an empty folder for this recipe:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个配方创建一个空文件夹：
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Initialize the folder for source code maintenance:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化源代码维护的文件夹：
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Copy the network application and SQL script into the folder, add it, and commit
    the changes:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将网络应用程序和SQL脚本复制到文件夹中，添加并提交更改：
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: With these steps, we will explore how to configure Jenkins to build a coverage
    report and serve it through Jenkins' interface.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将探讨如何配置Jenkins来构建覆盖率报告，并通过Jenkins的界面提供服务。
- en: Create a new file called `recipe57.py` to contain our test code for this recipe.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe57.py`的新文件，用于包含本配方的测试代码。
- en: 'Write a test case that partially exercises the network management application:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个部分执行网络管理应用程序的测试用例：
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Copy it into the source code repository. Add it and commit the changes:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其复制到源代码存储库中。添加并提交更改：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Open the Jenkins console.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Jenkins控制台。
- en: Click on New Job.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“新建任务”。
- en: Enter `recipe57` as the Job Name and pick Build a free-style software project.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入“recipe57”作为作业名称，并选择构建自由样式软件项目。
- en: Click on **Ok**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”。
- en: In the **Source Code Management** section, select **Git**. For **URL**, enter
    `/tmp/ recipe57/`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“源代码管理”部分，选择“Git”。对于“URL”，输入“/tmp/recipe57/”。
- en: In the Build Triggers section, pick **Poll** **SCM** and enter `* * * * *` into
    the schedule box in order to trigger a poll once a minute.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建触发器部分，选择**轮询** **SCM**并在计划框中输入`* * * * *`以触发每分钟轮询一次。
- en: 'In the Build section, select **Execute** **Shell** and enter the following
    script, which loads virtualenv and runs the test suite:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建部分，选择**执行** **Shell**并输入以下脚本，加载虚拟环境并运行测试套件：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You need to include the step to activate your virtualenv and then run the coverage
    tool, as shown in the following steps.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要包括激活虚拟环境并运行覆盖工具的步骤，如下所示。
- en: In the Post-build Actions section, pick **Publish Cobertura Coverage Report**.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后构建操作部分，选择**发布Cobertura覆盖率报告**。
- en: Enter `coverage.xml` for **Cobertura xml report pattern**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`coverage.xml`作为**Cobertura xml报告模式**。
- en: Click on **Save** to store all job settings.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**以保存所有作业设置。
- en: Navigate back to the dashboard.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航回仪表板。
- en: Click on **Enable Auto Refresh**.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**启用自动刷新**。
- en: 'Wait about a minute for the build job to run:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待约一分钟以运行构建作业：
- en: '![](../images/00132.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00132.jpeg)'
- en: Click on results (**#1** in the previous screenshot).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击结果（在上一个截图中的**#1**）。
- en: 'Click on **Coverage** **Report**. Observe the next screenshot where it reports
    89% coverage:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**覆盖率** **报告**。观察下一个截图，其中报告了89%的覆盖率：
- en: '![](../images/00133.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00133.jpeg)'
- en: Click on module `.` (dot) to see `network.py` and `recipe57.py`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击模块`.`（点）以查看`network.py`和`recipe57.py`。
- en: Click on `recipe57.py` to see which lines were covered and which ones were missed.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`recipe57.py`以查看哪些行被覆盖，哪些行被忽略。
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The coverage tool generates a useful XML file that the Jenkins Cobertura plugin
    can harvest. It's possible to just generate the HTML report and serve it up through
    Jenkins, but the XML file allows Jenkins to nicely chart the coverage trend. It
    also provides the means to drill-down and view the source code along with lines
    covered and missed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖工具生成一个有用的XML文件，Jenkins Cobertura插件可以收集。可以只生成HTML报告并通过Jenkins提供，但XML文件允许Jenkins很好地绘制覆盖率趋势。它还提供了查看源代码以及已覆盖和未覆盖行的手段。
- en: We also integrated it with source control so that, as changes are committed
    to the repository, new jobs will be run.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将其与源代码控制集成，因此，当更改提交到存储库时，将运行新的作业。
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's important not to get too wrapped up in coverage reports. The coverage tool
    is useful to track testing, but working purely to increase coverage doesn't guarantee
    building better code. It should be used as a tool to illuminate what test scenarios
    are missing instead of thinking about testing a missing line of code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于关注覆盖率报告很重要。覆盖工具对于跟踪测试很有用，但纯粹为了增加覆盖率而工作并不能保证构建更好的代码。它应该被用作一个工具来阐明缺少的测试场景，而不是考虑测试缺失的代码行。
- en: Nose doesn't directly support coverage's XML option
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nose不直接支持覆盖率的XML选项
- en: The nose plugin for the coverage tool doesn't include the ability to generate
    XML files. This is because the coverage plugin is part of nose and *not* part
    of the coverage project. It is not up to date with the latest features, including
    XML reports.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖工具的nose插件不包括生成XML文件的功能。这是因为覆盖插件是nose的一部分，*不是*覆盖项目的一部分。它没有更新到最新的功能，包括XML报告。
- en: I asked Ned Batchelder, the creator of the coverage project, about this lack
    of XML support from nose. He recommended that I run `nosetests` inside `coverage`,
    as shown previously in the Jenkins job. It generates the same `.coverage` trace
    data file. It is easy to then execute `coverage` `xml` with the required arguments
    in order to get our desired report. In fact, we can use any of coverage's reporting
    features at this stage. Unfortunately, the coverage tool needs the explicit path
    to `nosetests`, and running inside Jenkins requires the path to be spelled out.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我问过覆盖项目的创建者Ned Batchelder关于nose缺乏XML支持的问题。他建议我在`coverage`内运行`nosetests`，就像在Jenkins作业中之前展示的那样。它会生成相同的`.coverage`跟踪数据文件。然后很容易执行`coverage`
    `xml`并使用所需的参数来获得我们想要的报告。实际上，我们可以在这个阶段使用覆盖的任何报告功能。不幸的是，覆盖工具需要明确指定`nosetests`的路径，并且在Jenkins中运行需要明确指定路径。
- en: Updating the project-level script to provide coverage reports
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新项目级脚本以提供覆盖率报告
- en: Update the project-level script to generate HTML, XML, and console coverage
    reports as runnable options.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 更新项目级脚本以生成HTML、XML和控制台覆盖率报告作为可运行选项。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Install coverage by typing `pip install coverage`
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过输入`pip install coverage`安装覆盖率
- en: Create the network management application described in the *Building a network*
    *management application* recipe
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建*构建网络管理应用程序*配方中描述的网络管理应用程序
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will explore how to use coverage programmatically in a
    project management script:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将探讨如何在项目管理脚本中以编程方式使用覆盖率：
- en: Create a new file called `recipe58.py` to store this command-line script.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe58.py`的新文件来存储这个命令行脚本。
- en: 'Create a script that uses `getopt` to parse command-line arguments:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用`getopt`解析命令行参数的脚本：
- en: '[PRE24]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add a test function that uses coverage''s API to gather metrics and then generate
    a console report, an HTML report, and an XML report, while also using nose''s
    API to run the tests:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个使用覆盖率API收集指标并生成控制台报告、HTML报告和XML报告的测试函数，同时使用nose的API运行测试：
- en: '[PRE25]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add some other stubbed out functions to simulate packaging, publishing, and
    registering this project:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些其他的存根函数来模拟打包、发布和注册这个项目：
- en: '[PRE26]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add code that processes command-line arguments and calls the functions defined
    earlier:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理命令行参数并调用之前定义的函数的代码：
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the script using the `--test` option:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--test`选项运行脚本：
- en: '![](../images/00134.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00134.jpeg)'
- en: 'Open the HTML report using your favorite browser:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的浏览器打开HTML报告：
- en: '![](../images/00135.jpeg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00135.jpeg)'
- en: Inspect `recipe58.xml`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`recipe58.xml`。
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The coverage API is easy to use as shown in the following steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如下步骤所示，覆盖API易于使用：
- en: 'In the test method, we create a `coverage()` instance:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试方法中，我们创建了一个`coverage()`实例：
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We need to call the `start` method to begin tracing:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要调用`start`方法开始跟踪：
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to exercise the main code. In this case, we are using the nose
    API. We will use it to run the various recipes coded in this chapter:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行主要的代码。在这种情况下，我们正在使用nose API。我们将使用它来运行本章中编写的各种配方：
- en: '[PRE30]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then we need to stop coverage from tracing:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要停止覆盖跟踪：
- en: '[PRE31]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have gathered metrics, we can generate a console report, an HTML
    report, and an XML report:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经收集了指标，我们可以生成一个控制台报告，一个HTML报告和一个XML报告：
- en: '[PRE32]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first report is a console report. The second report is an HTML report written
    into the `recipe58` subdirectory. The third report is an XML report in Cobertura
    format written to `recipe58.xml`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个报告是一个控制台报告。第二个报告是写入到`recipe58`子目录的HTML报告。第三个报告是以Cobertura格式写入到`recipe58.xml`的XML报告。
- en: There's more...
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many more options to fine-tune gathering as well as reporting. Just
    visit the online documentation at [http://nedbatchelder.com/code/coverage/api.html](http://nedbatchelder.com/code/coverage/api.html)
    for more details.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他选项可以微调收集和报告。只需访问[http://nedbatchelder.com/code/coverage/api.html](http://nedbatchelder.com/code/coverage/api.html)上的在线文档获取更多详细信息。
- en: Can we only use getopt?
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们只能使用getopt吗？
- en: Python 2.7 introduced `argparse` as an alternative to `getopt`. The current
    documentation gives no indication that `getopt` is deprecated, so it's safe to
    use as we have just done. The `getopt` module is a nice, easy-to-use command-line
    parser.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.7引入了`argparse`作为`getopt`的替代方案。当前的文档没有指示`getopt`已被弃用，所以我们可以像刚才那样安全地使用。`getopt`模块是一个很好用的命令行解析器。
