- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Designing Graphical Interfaces
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计图形界面
- en: Many tools add their own elements to the graphical interface. In the previous
    chapters, we used existing menus, but we can also add new panels to the Blender
    window.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工具都会向图形界面添加自己的元素。在前几章中，我们使用了现有的菜单，但也可以向Blender窗口添加新的面板。
- en: To design an interface, we must decide which elements to show and how to reach
    them, what information should be provided, and which actions should be allowed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设计界面时，我们必须决定显示哪些元素以及如何访问它们，提供哪些信息，以及允许哪些操作。
- en: In this chapter, you will learn how to insert new panels into different regions
    of Blender, how to display information and icons, and how to add buttons that
    can invoke operators.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将新面板插入Blender的不同区域，如何显示信息和图标，以及如何添加可以调用操作员的按钮。
- en: 'This chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the Blender interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Blender界面
- en: Drawing a custom panel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制自定义面板
- en: Context and UI interaction
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文和UI交互
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will use Blender and Visual Studio Code in this chapter. The examples created
    in this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Blender和Visual Studio Code。本章创建的示例可以在[https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5)找到。
- en: The example files include 2D images to be used as icons. Optionally, any 2D
    software can be used to create custom `.png` images, and you can use them instead.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 示例文件包括用作图标的2D图像。可选地，任何2D软件都可以用来创建自定义的`.png`图像，并且你可以使用它们代替。
- en: To implement our interface, we will have to learn how Blender is structured.
    Let’s begin our journey into graphical interfaces with a deep dive into the Blender
    screen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的界面，我们必须了解Blender的结构。让我们从深入Blender屏幕开始，开始我们的图形界面之旅。
- en: Areas, regions, and panels
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区域、区域和面板
- en: 'The Blender window is split into **areas**. Each area can contain an **editor**
    of a different type, such as the *viewport* for 3D objects or the *sequencer*
    for editing videos. Each editor, or space, can contain one or more **regions**.
    The number and type of regions vary across different types of editors: for instance,
    some editors, such as the **Preferences** window, have a navigation sidebar, while
    others don’t.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Blender窗口被分为**区域**。每个区域可以包含不同类型的**编辑器**，例如3D对象的*视口*或视频编辑的*序列编辑器*。每个编辑器或空间可以包含一个或多个**区域**。区域的数量和类型因不同类型的编辑器而异：例如，一些编辑器，如**首选项**窗口，有一个导航侧边栏，而其他则没有。
- en: 'The Blender manual explains the interface in detail: [https://docs.blender.org/manual/en/3.1/interface/index.xhtml](https://docs.blender.org/manual/en/3.1/interface/index.xhtml).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Blender手册详细解释了界面：[https://docs.blender.org/manual/en/3.1/interface/index.xhtml](https://docs.blender.org/manual/en/3.1/interface/index.xhtml)。
- en: What we need to know for now is that regions can contain **panels**, and panels
    are the basic containers of graphical elements such as text, editable values,
    and buttons.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们需要知道的是，区域可以包含**面板**，面板是文本、可编辑值和按钮等图形元素的基本容器。
- en: 'We can create new panels with Python, which makes it possible to customize
    any region with ease. A panel must contain information about the area and region
    to which it belongs:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python创建新的面板，这使得轻松自定义任何区域成为可能。面板必须包含有关它所属的区域和区域的信息：
- en: '![Figure 5.1: Areas, regions, and the panel in the Blender interface](img/Figure_5.01_B18375.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：Blender界面中的区域、区域和面板](img/Figure_5.01_B18375.jpg)'
- en: 'Figure 5.1: Areas, regions, and the panel in the Blender interface'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：Blender界面中的区域、区域和面板
- en: Internally, panels can access information about Blender and the scene so that
    they can display the status and properties of the objects and execute operators.
    Now that we are more familiar with the anatomy of the screen, we are going to
    create a panel that helps us deal with 3D objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，面板可以访问Blender和场景的信息，以便它们可以显示对象的状态和属性并执行操作。现在我们更熟悉屏幕的结构，我们将创建一个帮助我们处理3D对象的面板。
- en: Creating a simple panel
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单面板
- en: We will start with a simple panel that contains some text and icons, and we
    will see how to expand this initial idea into a tool that can help manage the
    objects in the scene.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从包含一些文本和图标的简单面板开始，并了解如何将这个初始想法扩展成一个可以帮助管理场景中对象的工具。
- en: Our panel is a new class that derives from `bpy.types.Panel`. Like operators,
    panels require some static members to be set; otherwise, they will not work. Similar
    to operators, panels can have a `poll()` class method that states under which
    conditions the panel can be displayed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的面板是一个新的类，它从`bpy.types.Panel`派生。像操作符一样，面板需要设置一些静态成员；否则，它们将无法工作。与操作符类似，面板可以有一个`poll()`类方法，该方法声明在哪些条件下可以显示面板。
- en: Instead of using the `execute` function, panels set up and draw their content
    via the `draw(self,` `context)` function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`execute`函数不同，面板通过`draw(self, context)`函数设置和绘制其内容。
- en: Since we are adding a new piece to the Blender interface, we will do that inside
    a new add-on. It’s not mandatory, but it makes it easier to enable and disable
    our panel.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在向Blender界面添加新内容，因此我们将在一个新插件中完成这项工作。这不是强制性的，但它使得启用和禁用我们的面板变得更加容易。
- en: To keep our code orderly and clean, we will create a new folder for the scripts
    written for this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的代码整洁和清晰，我们将为这一章编写的脚本创建一个新文件夹。
- en: Setting the environment
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: Let’s create a folder for [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100) in
    our `ch5` folder as a **Scripts Folder** and restart Blender.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`ch5`文件夹中创建一个名为[*第5章*](B18375_05.xhtml#_idTextAnchor100)的文件夹作为**脚本文件夹**，并重新启动Blender。
- en: 'Our add-on script contains a panel, much like the ones in the previous chapters
    contained operators:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插件脚本包含一个面板，就像前几章包含操作符一样：
- en: Select `PythonScriptingBlender/ch5/addons` in **Visual** **Studio Code**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Visual Studio Code**中选择`PythonScriptingBlender/ch5/addons`。
- en: Create a new file by clicking the **New** **File** icon.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**新建文件**图标创建一个新文件。
- en: Name the new file `simple_panel.py`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`simple_panel.py`。
- en: Open the file by double-clicking on it.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击打开文件。
- en: We can now start writing the add-on for our panel.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写我们的面板插件了。
- en: Drafting our panel add-on
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计我们的面板插件
- en: 'As we know from [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), three elements
    are required:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从[*第3章*](B18375_03.xhtml#_idTextAnchor049)中了解到的，需要三个元素：
- en: A `bl_info` dictionary containing basic information
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含基本信息的`bl_info`字典
- en: An `import bpy` statement to access the Blender API
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`import bpy`语句来访问Blender API
- en: The `register()` and `unregister()` methods for enabling/disabling add-ons,
    respectively
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register()`和`unregister()`方法分别用于启用/禁用插件。'
- en: We also need a class for the graphical element that we want to add – in this
    case, a class that derives from `bpy.types.Panel`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们要添加的图形元素创建一个类——在这种情况下，一个从`bpy.types.Panel`派生的类。
- en: We will start with the information dictionary and add the stubs for the required
    elements to set a frame on which we can code a fully working UI add-on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从信息字典开始，并为设置框架所需的元素添加占位符，这样我们就可以编写一个完全工作的UI插件。
- en: Writing the info dictionary
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写信息字典
- en: 'The `bl_info` dictionary will provide the `name` property of the add-on, its
    `author` and `version`, and the required `blender` version, plus a short `description`.
    We can also add a `category` under which the add-on is listed. Here’s what the
    code will look like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`bl_info`字典将提供插件的`name`属性、其`author`和`version`、所需的`blender`版本，以及一个简短的`description`。我们还可以添加一个`category`，该插件将列在该类别下。以下是代码的示例：'
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we can proceed with the required `import` statements and the main `class`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续编写所需的`import`语句和主`class`。
- en: Drafting the Panel class
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计面板类
- en: Now that we’ve imported the `bpy` module, we can write a class based on `bpy.types.Panel`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了`bpy`模块，我们可以基于`bpy.types.Panel`编写一个类。
- en: 'We can use any name for our class, but Blender recommends some guidelines:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的类使用任何名称，但Blender推荐一些指导原则：
- en: Since our panel will be part of the object properties, the class name must begin
    with `OBJECT`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们的面板将是对象属性的一部分，类名必须以`OBJECT`开头。
- en: The name contains `_PT_` in the middle since this is a `Panel Type`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称中间包含`_PT_`，因为这是一个`Panel Type`。
- en: 'For now, our class will only contain a *docstring* and a `pass` statement:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的类将只包含一个*文档字符串*和一个`pass`语句：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before adding methods and attributes, we will handle the class activation and
    dismissal through the registration functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加方法和属性之前，我们将通过注册函数处理类的激活和关闭。
- en: Panel registration
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面板注册
- en: 'The `register` and `unregister` functions add and remove this class to/from
    Blender when the add-on is enabled and disabled, respectively:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`register`和`unregister`函数在插件启用和禁用时分别将此类添加到/从Blender中添加/删除：'
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With that, we have created the initial structure of our panel add-on. We will
    now add the elements and attributes for displaying some text.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经创建了面板插件的初始结构。现在我们将添加用于显示一些文本的元素和属性。
- en: Setting display attributes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置显示属性
- en: 'Blender looks for attributes that follow the `bl_*` pattern to determine where
    and how the panel is displayed. Panels have the same identification attributes
    as operators, as we saw in [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), when
    we introduced the `Operator` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Blender寻找遵循`bl_*`模式的属性以确定面板在哪里以及如何显示。面板具有与操作员相同的识别属性，正如我们在[第3章](B18375_03.xhtml#_idTextAnchor049)中介绍`Operator`类时所看到的：
- en: '`bl_label`: The display name of the panel'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bl_label`: 面板的显示名称'
- en: '`bl_idname`: The unique name of the panel for internal usage'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bl_idname`: 面板在内部使用的唯一名称'
- en: 'Then, there are attributes used only on classes that derive from `bpy.types.Panels`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有一些属性仅用于从`bpy.types.Panels`派生的类：
- en: '`bl_space_type`: The editor to which the panel belongs'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bl_space_type`: 面板所属的编辑器'
- en: '`bl_region_type`: The region of the editor to use'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bl_region_type`: 要使用的编辑器区域'
- en: '`bl_context`: The sub-region for specific objects/modes'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bl_context`: 特定对象/模式的子区域'
- en: '`bl_category`: The tab inside the region, when available'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bl_category`: 当可用时，区域内的标签'
- en: All of them are static strings, and `bl_space_type`, `bl_region_type`, and `bl_context`
    must match specific values known to Blender as regions of the screen.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是静态字符串，并且`bl_space_type`、`bl_region_type`和`bl_context`必须匹配Blender已知的屏幕区域的具体值。
- en: The possible values encompass all the available editors in Blender. That might
    seem overwhelming at first, but once we have an idea of where to place our panel,
    we can look that up in the online documentation at [https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml](https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的值包括Blender中所有可用的编辑器。一开始这可能会让人感到不知所措，但一旦我们有了放置面板的想法，我们就可以在在线文档[https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml](https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml)中查找相关信息。
- en: Since Blender contains many editors and each of them has its own sub-elements,
    we will have a look at the possible combinations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Blender包含许多编辑器，并且每个编辑器都有自己的子元素，我们将查看可能的组合。
- en: Choosing our editor view via bl_space_type
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过`bl_space_type`选择我们的编辑视图
- en: 'First, we must decide which Blender editor we are adding our panel to. That
    depends mainly on the purpose of our tool and where it will be more convenient
    to find it. For instance, if our panel helps make videos, it will be part of the
    `bl_space_type`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须决定将我们的面板添加到哪个Blender编辑器。这主要取决于我们工具的目的以及在哪里找到它更方便。例如，如果我们的面板有助于制作视频，它将是`bl_space_type`的一部分：
- en: '`EMPTY`: This value is not used in scripts'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMPTY`: 此值在脚本中不使用'
- en: '`VIEW_3D`: **3D Viewport** for manipulating *objects*'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIEW_3D`: 用于操纵*对象*的**3D视图**'
- en: '`IMAGE_EDITOR`: **UV/Image Editor** to view and edit *images* and UV Maps'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMAGE_EDITOR`: 用于查看和编辑*图像*和UV图的**UV/图像编辑器**'
- en: '`NODE_EDITOR`: **Node Editor** for node-based *shading* and *compositing* tools'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NODE_EDITOR`: 用于基于节点的*着色*和*合成*工具的**节点编辑器**'
- en: '`SEQUENCE_EDITOR`: **Video Sequencer** *editing* tools'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEQUENCE_EDITOR`: **视频序列编辑器**编辑工具'
- en: '`CLIP_EDITOR`: **Movie Clip Editor** for *motion tracking*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLIP_EDITOR`: 用于*运动追踪*的**剪辑编辑器**'
- en: '`DOPESHEET_EDITOR`: **Dope Sheet** for adjusting the timing of *keyframes*'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOPESHEET_EDITOR`: 用于调整*关键帧*时间的**Dope Sheet**'
- en: '`GRAPH_EDITOR`: **Graph Editor** for drivers and keyframe *interpolation*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GRAPH_EDITOR`: 用于驱动和关键帧*插值*的**图表编辑器**'
- en: '`NLA_EDITOR`: **Nonlinear Animation** to combine and layer *actions*'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NLA_EDITOR`: 用于组合和分层*动作*的**非线性动画编辑器**'
- en: '`TEXT_EDITOR` **Text Editor** to edit *scripts* and in-file *documentation*'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXT_EDITOR` **文本编辑器**用于编辑*脚本*和文件内的*文档*'
- en: '`CONSOLE`: **Python Console** for interactive script *development*'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSOLE`: 用于交互式脚本*开发*的**Python控制台**'
- en: '`INFO`: **Info** about operations, warnings, and error *messages*'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO`: 关于操作、警告和错误*消息*的**信息**'
- en: '`TOPBAR`: **Topbar** for global, *per-window settings*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TOPBAR`: 用于全局、*窗口级设置*的**顶部栏**'
- en: '`STATUSBAR`: **Status Bar** at the bottom of the screen for *general information*'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATUSBAR`: 屏幕底部的**状态栏**用于显示*一般信息*'
- en: '`OUTLINER`: **Outliner** overview of the *scene tree* and data blocks'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OUTLINER`: **大纲视图**的*场景树*和数据块概览'
- en: '`PROPERTIES`: **Properties** to edit the *attributes* of active objects and
    data blocks'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROPERTIES`: **属性**用于编辑活动对象和数据块的特征'
- en: '`FILE_BROWSER`: **File Browser** to scroll through *files* *and assets*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILE_BROWSER`: **文件浏览器**用于滚动查看*文件*和*资产*'
- en: '`SPREADSHEET`: **Spreadsheet** to explore *geometry data* in a table'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPREADSHEET`: 用于在表格中探索*几何数据*的**电子表格**'
- en: '`PREFERENCES`: **Preferences** to edit persistent *configuration* settings'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREFERENCES`: 用于编辑持久*配置*设置的**首选项**。'
- en: Once we have decided on the space type, we are ready to pick a region for it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定了空间类型，我们就可以为它选择一个区域。
- en: Selecting a region via bl_region_type
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过bl_region_type选择区域。
- en: 'The kind of region depends on the *space* we chose in the previous step. Different
    editors have different regions. So, only the default value is always available.
    Here is a description of all the options for `bl_region_type`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 区域的类型取决于我们在上一步中选择的*空间*。不同的编辑器有不同的区域。因此，默认值总是可用的。以下是`bl_region_type`的所有选项描述：
- en: '`WINDOW`: The *main* region of a space area. This is the default value.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW`: 空间区域的主*区域*。这是默认值。'
- en: '`HEADER`: A small horizontal strip for *menus* and buttons.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEADER`: 用于*菜单*和按钮的小型水平条。'
- en: '`CHANNELS`: Used in older versions of Blender, left for backward compatibility.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHANNELS`: 在Blender的旧版本中使用，为了向后兼容而保留。'
- en: '`TEMPORARY`: *Poupps* detached from the main window.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEMPORARY`: 从主窗口分离的*弹出窗口*。'
- en: '`UI`: Sidebar containing object settings (toggled with *N*).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UI`: 包含对象设置（通过*N*切换）的侧边栏。'
- en: '`TOOLS`: A toolbar containing a set of interactive tools (toggled with *T*).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TOOLS`: 包含一组交互式工具的*工具栏*（通过*T*切换）。'
- en: '`TOOL_PROPS`: Settings in *modal windows*, such as **File Browser**.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TOOL_PROPS`: 在*模式窗口*中的设置，例如**文件浏览器**。'
- en: '`PREVIEW`: The preview area of the **Video Sequencer**.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREVIEW`: **视频序列器**的预览区域。'
- en: '`HUD`: The operator’s **Redo** panel.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HUD`: 操作员的**重做**面板。'
- en: '`NAVIGATION_BAR`: *Sidebar* in the **Preferences** window.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAVIGATION_BAR`: **首选项**窗口中的*侧边栏*。'
- en: '`EXECUTE`: *Bottom bar* in modal windows.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXECUTE`: 模式窗口中的*底部栏*。'
- en: '`FOOTER`: A bar for displaying *information* about the current operation.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FOOTER`: 用于显示当前操作*信息*的栏。'
- en: '`TOOL_HEADER`: A small horizontal strip for *tool settings*.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TOOL_HEADER`: 用于*工具设置*的小型水平条。'
- en: '`XR`: The interface for *virtual* *reality* controllers.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XR`: 虚拟*现实*控制器的接口。'
- en: Picking a context via bl_context
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过bl_context选择上下文
- en: Some areas change according to the current selection, active tool, or interaction
    mode. In that case, the `bl_context` attribute is required.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一些区域会根据当前选择、活动工具或交互模式而变化。在这种情况下，需要`bl_context`属性。
- en: 'For instance, the `''SCENE''`, `''OBJECT''`, and `''CONSTRAINTS''`. If we are
    not sure about which one to use, we can just activate the tab we are interested
    in and check the `bpy.context.space_data.context =` `NAME_OF_CONTEXT`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`'SCENE'`、`'OBJECT'`和`'CONSTRAINTS'`。如果我们不确定使用哪一个，我们可以只是激活我们感兴趣的标签页，并检查`bpy.context.space_data.context
    =` `NAME_OF_CONTEXT`：
- en: '![Figure 5.2: UI context name in the Info Log area, after Object Properties
    have been selected](img/Figure_5.02_B18375.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：在选择了对象属性后，信息日志区域中的UI上下文名称](img/Figure_5.02_B18375.jpg)'
- en: 'Figure 5.2: UI context name in the Info Log area, after Object Properties have
    been selected'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：在选择了对象属性后，信息日志区域中的UI上下文名称
- en: Areas that do not follow the user context but still allow you to group their
    panels in tabs offer a *category* attribute instead.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不遵循用户上下文但仍然允许你在标签页中分组其面板的区域提供*类别*属性。
- en: Grouping in tabs using bl_category
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用bl_category在标签页中进行分组
- en: Regions with arbitrary tabs will look at the `bl_category` variable to look
    up the correct label. If no value is given, the new panel will be added to the
    **Miscellaneous** tab. If no tab is named after that value, a new one will be
    created.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 具有任意标签页的区域将查看`bl_category`变量以查找正确的标签。如果没有提供值，新面板将被添加到**杂项**标签页。如果没有以该值命名的标签页，将创建一个新的标签页。
- en: We are going to use the category attribute at the end of this chapter in conjunction
    with the `'VIEW_3D'` space type. We are going to start with the `'PROPERTIES'`
    editor, which does not have tabs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章末尾使用类别属性与`'VIEW_3D'`空间类型结合使用。我们将从没有标签的`'PROPERTIES'`编辑器开始。
- en: Adding a panel to the Object Properties area
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将面板添加到对象属性区域
- en: To add our panel to the `bl_space_type` to `'PROPERTIES'` and `bl_context` to
    `'object'`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的面板添加到`bl_space_type`为`'PROPERTIES'`和`bl_context`为`'object'`。
- en: '`Panel` needs a `draw` function where the actual design takes place. At this
    stage, we can leave it blank:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Panel`需要一个`draw`函数，实际设计就在这里进行。在这个阶段，我们可以将其留空：'
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like most runtime functions of Blender classes, `draw` takes the `self` and
    `context` arguments. As per Python convention, `self` is the running instance
    of the class, while `context` contains information about the current state of
    the Blender scene.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与Blender类的大多数运行时函数一样，`draw`函数接受`self`和`context`参数。根据Python惯例，`self`是类的运行实例，而`context`包含有关Blender场景当前状态的信息。
- en: Now, let’s learn how the `draw` method is used to add elements to the panel’s
    layout.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用`draw`方法向面板布局添加元素。
- en: Drawing the panel’s content
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制面板的内容
- en: The `draw` function is executed continuously whenever a panel is used or updated.
    For this reason, it should not perform any computationally expensive task and
    just take care of the elements to display.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`函数在每次面板被使用或更新时都会连续执行。因此，它不应执行任何计算密集型任务，只需负责显示的元素即可。'
- en: The elements of a panel are arranged according to its layout. Since the layout
    is a non-static member, it can be accessed inside the `draw` function using `self.layout`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 面板的元素根据其布局排列。由于布局是一个非静态成员，它可以在`draw`函数中使用`self.layout`来访问。
- en: By default, all elements are stacked vertically in a `column`, but different
    types of layouts will provide a different way to arrange the widgets in a `row`
    or inside a `grid`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有元素都垂直堆叠在一个`column`中，但不同类型的布局将提供不同的方式来排列`row`或网格中的小部件。
- en: Layouts can be also nested together for more complex arrangements. Let’s learn
    how to access the main layout and add elements to it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 布局也可以嵌套在一起，以实现更复杂的排列。让我们学习如何访问主布局并向其中添加元素。
- en: Working with layouts
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与布局一起工作
- en: All layout types derive from the `UILayout` class. They have methods to add
    child elements or sub-layouts. The full list of attributes and methods is reported
    in the API documentation at https://docs.blender.org/api/3.2/bpy.types.UILayout.xhtml.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所有布局类型都源自`UILayout`类。它们有添加子元素或子布局的方法。完整的属性和方法列表可以在 https://docs.blender.org/api/3.2/bpy.types.UILayout.xhtml
    的 API 文档中找到。
- en: 'So, to display text, we can use the `UILayout.label` method. Here are the first
    few lines of code for our `draw` function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要显示文本，我们可以使用`UILayout.label`方法。以下是我们的`draw`函数的前几行代码：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we enable this add-on and reach for the **Object Properties** area, we will
    be able to see our new panel displaying some text:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用此附加组件并到达**对象属性**区域，我们将能够看到我们的新面板显示一些文本：
- en: '![Figure 5.3: Our panel showing up in the Object Properties area](img/Figure_5.03_B18375.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：我们的面板在对象属性区域显示](img/Figure_5.03_B18375.jpg)'
- en: 'Figure 5.3: Our panel showing up in the Object Properties area'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：我们的面板在对象属性区域显示
- en: Displaying icons
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示图标
- en: 'Labels can display **icons** too. There are two types of icons:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 标签也可以显示**图标**。有两种类型的图标：
- en: '*Built-in* icons that come with Blender. The `label` method provides an `icon`
    keyword to use them.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置**图标，这些图标随 Blender 一起提供。`label`方法提供了一个`icon`关键词来使用它们。'
- en: '*External Images* can be used via the `icon_value` parameter.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`icon_value`参数使用**外部图像**。
- en: 'Blender’s native set of icons is used across the application. Each icon is
    identified with a keyword. For instance, `LIGHT` displays a lightbulb:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 的原生图标集在整个应用程序中使用。每个图标都通过一个关键词来标识。例如，`LIGHT`显示一个灯泡：
- en: '![Figure 5.4: Blender icon for the LIGHT keyword](img/Figure_5.04_B18375.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：Blender 为 LIGHT 关键字提供的图标](img/Figure_5.04_B18375.jpg)'
- en: 'Figure 5.4: Blender icon for the LIGHT keyword'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：Blender 为 LIGHT 关键字提供的图标
- en: There are more than 800 built-in icons, so Blender includes an add-on for searching
    through them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有超过 800 个内置图标，因此 Blender 包含一个用于搜索它们的附加组件。
- en: Looking for built-in icons with the Icon Viewer add-on
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用图标查看器附加组件查找内置图标
- en: 'The `icon` in the **Search** **Bar** area:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索栏**区域的`图标`：'
- en: '![Figure 5.5: Activating the Icon Viewer add-on](img/Figure_5.05_B18375.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：激活图标查看器附加组件](img/Figure_5.05_B18375.jpg)'
- en: 'Figure 5.5: Activating the Icon Viewer add-on'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：激活图标查看器附加组件
- en: 'Once the add-on has been enabled, the **Icon Viewer** button appears in the
    header of the **Python** **Console** header:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦附加组件被启用，**图标查看器**按钮就会出现在**Python**控制台标题中：
- en: '![Figure 5.6: The Icon Viewer button in the Python Console header](img/Figure_5.06_B18375.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：Python 控制台标题中的图标查看器按钮](img/Figure_5.06_B18375.jpg)'
- en: 'Figure 5.6: The Icon Viewer button in the Python Console header'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：Python 控制台标题中的图标查看器按钮
- en: 'Clicking this button opens a window that shows all native icons. We can select
    them by left-clicking:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮将打开一个窗口，显示所有原生图标。我们可以通过左键单击来选择它们：
- en: '![Figure 5.7: The Icon Viewer add-on window](img/Figure_5.07_B18375.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：图标查看器附加窗口](img/Figure_5.07_B18375.jpg)'
- en: 'Figure 5.7: The Icon Viewer add-on window'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：图标查看器附加窗口
- en: 'Selecting an icon displays the associated keyword in the top-right corner.
    The keyword is also copied to the clipboard. For example, if we select the *question
    mark* icon, which is the first icon on the top left at the time of writing, the
    `QUESTION` keyword will be displayed, as shown in the following figure:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个图标将在右上角显示相关的关键字。该关键字也将复制到剪贴板。例如，如果我们选择 *问号* 图标，这是在撰写本文时位于左上角的第一个图标，`QUESTION`
    关键字将被显示，如下面的图所示：
- en: '![Figure 5.8: The QUESTION keyword is displayed in the top-right corner](img/Figure_5.08_B18375.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：`QUESTION` 关键字显示在右上角](img/Figure_5.08_B18375.jpg)'
- en: 'Figure 5.8: The QUESTION keyword is displayed in the top-right corner'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：`QUESTION` 关键字显示在右上角
- en: We can type a search key in the filter field in the top middle, which is marked
    with a magnifier icon.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在顶部中间标记有放大镜图标的筛选字段中输入搜索关键字。
- en: 'For instance, we can type `“info”` to show the `''INFO''` icon only. Now that
    we know their keywords, we can display those icons in this way:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以输入 `“info”` 来仅显示 `'INFO'` 图标。现在我们知道了它们的关键字，我们可以这样显示这些图标：
- en: '[PRE5]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Label icons are displayed before the text and are a good way to make it stand
    out:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 标签图标显示在文本之前，是使其突出的一种好方法：
- en: '![Figure 5.9: The ‘INFO’ and ‘QUESTION’ icons displayed in our custom panel](img/Figure_5.09_B18375.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：在自定义面板中显示的‘INFO’和‘QUESTION’图标](img/Figure_5.09_B18375.jpg)'
- en: 'Figure 5.9: The ‘INFO’ and ‘QUESTION’ icons displayed in our custom panel'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：在自定义面板中显示的‘INFO’和‘QUESTION’图标
- en: Built-in icons are always available and don’t require external files to be distributed
    alongside our scripts. We can also use image files when needed. The `bpu.utils.previews`
    module can be used to load icons from image files and retrieve them using an index
    number.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 内置图标始终可用，并且不需要与我们的脚本一起分发外部文件。在需要时，我们也可以使用图像文件。`bpu.utils.previews` 模块可以用于从图像文件加载图标并使用索引号检索它们。
- en: Using custom image icons
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用自定义图像图标
- en: In this example, we will add the icon of a smiling face to our panel. The image
    file is named `icon_smile_64.png` and can be found in this chapter’s Git folder.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将添加笑脸图标到我们的面板。图像文件名为 `icon_smile_64.png`，可以在本章的 Git 文件夹中找到。
- en: Alternatively, any image stored in `.png` format alongside the add-on’s `.py`
    file will work. In that case, the image filename used in the script must be changed
    accordingly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，任何存储在 `.png` 格式并与附加程序的 `.py` 文件一起的图片都将有效。在这种情况下，脚本中使用的图片文件名必须相应更改。
- en: 'The resolution should not be too high: a 64-pixel-wide square picture is usually
    more than enough:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 分辨率不应过高：一个 64 像素宽的方形图片通常就足够了：
- en: '![Figure 5.10: A 64x64 smiley face](img/Figure_5.10_B18375.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10：一个 64x64 的笑脸](img/Figure_5.10_B18375.jpg)'
- en: 'Figure 5.10: A 64x64 smiley face'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：一个 64x64 的笑脸
- en: 'To add custom icons to Blender, our script needs to import the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 Blender 添加自定义图标，我们的脚本需要导入以下内容：
- en: The `os` Python module, to build the icon file path and make sure it will work
    on all platforms
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `os` 模块，用于构建图标文件路径并确保它在所有平台上都能工作
- en: The `bpy.utils.previews` Blender module, to generate a Blender identifier for
    our icon
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender 的 `bpy.utils.previews` 模块，用于为我们图标生成 Blender 标识符
- en: 'Here is what our `import` section will look like once we import them:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 导入这些内容后，我们的 `import` 部分将看起来如下：
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our icons must be accessible everywhere in the script. We can use a global variable,
    a static member, or a singleton for storage. In this example, we are using a global
    variable as it is the simpler option.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图标必须在脚本中的任何地方都可以访问。我们可以使用全局变量、静态成员或单例进行存储。在这个例子中，我们使用全局变量，因为它是一个更简单的选项。
- en: 'So, right after the `import` section, we must add the following lines:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，紧随 `import` 部分之后，我们必须添加以下行：
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We initialize the variable as `None` since we can load and clear it inside
    the `register`/`unregister` function. We can also add specific functions for that.
    This way, the code will be easier to follow:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量初始化为 `None`，因为我们可以在 `register`/`unregister` 函数内部加载和清除它。我们也可以为此添加特定的函数。这样，代码将更容易理解：
- en: '[PRE8]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we need a function that clears `custom_icons` when the add-on is unregistered:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个函数在附加程序注销时清除 `custom_icons`：
- en: '[PRE9]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These functions are then invoked in the registration section:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数随后在注册部分被调用：
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we read the image file, we used `"smile_face"` as the first argument of
    `custom_icons.load()`, so that is the keyword that will be used for retrieving
    its identifier. Here’s the code to use in a label:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们读取了图片文件，我们使用 `"smile_face"` 作为 `custom_icons.load()` 的第一个参数，因此这就是用于检索其标识符的关键字。以下是用于标签的代码：
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we look up and execute **Reload Scripts** from the *F3* search panel, we
    will see our custom icon in the panel:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从*F3*搜索面板查找并执行**重新加载脚本**，我们将在面板中看到我们的自定义图标：
- en: '![Figure 5.11: Smiley icon loaded from our file and displayed in our panel](img/Figure_5.11_B18375.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11：从我们的文件加载并显示在我们的面板中的笑脸图标](img/Figure_5.11_B18375.jpg)'
- en: 'Figure 5.11: Smiley icon loaded from our file and displayed in our panel'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11：从我们的文件加载并显示在我们的面板中的笑脸图标
- en: For now, we have used the default column layout. We will learn how to use a
    different arrangement in the next section.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经使用了默认的列布局。我们将在下一节中学习如何使用不同的排列。
- en: Where have my widgets gone?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我的部件去哪里了？
- en: Errors in the interface code fail “silently"; that is, Blender doesn’t complain
    visibly and instead just stops drawing the buggy panel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接口代码中的错误会“静默”失败；也就是说，Blender不会明显地抱怨，而是只是停止绘制有错误的面板。
- en: This prevents the UI from crashing but makes our code more difficult to debug;
    we will only notice that some of our widgets are not displayed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止UI崩溃，但会使我们的代码更难调试；我们只会注意到一些小部件没有显示。
- en: When that happens, the best thing to do is check the console output or the **Info
    Log** area in the **Scripting** workspace. It will contain *traceback* information
    about which line of code is failing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，最好的做法是检查控制台输出或**脚本**工作区的**信息日志**区域。它将包含有关哪个代码行失败的*跟踪信息*。
- en: Using layouts in our panels
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的面板中使用布局
- en: If we are not happy with the default stacking of the global layout, we can add
    a layout type of our choice to it and use that instead, and we’ll get a different
    arrangement.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对全局布局的默认堆叠方式不满意，我们可以添加我们选择的布局类型，并使用它，我们将得到不同的排列。
- en: 'For instance, we can put two labels on the same line using a `row`. Also, even
    if we are happy with stacking our elements one under the other, it is good practice
    to create a `column` sub-layout anyway. This practice has at least two advantages:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`row`将两个标签放在同一行上。此外，即使我们对我们元素堆叠的方式感到满意，创建一个`column`子布局也是良好的实践。这种做法至少有两个优点：
- en: We preserve the panel's look, even if the default arrangement should change
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们保留了面板的外观，即使默认排列应该改变
- en: We do not pollute the original layout
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不会污染原始布局
- en: Let’s see how we can change the way our widgets are stacked.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何改变小部件堆叠的方式。
- en: Arranging in columns and rows
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列和行的排列
- en: 'We can nest more layout types together inside our `draw` function. For instance,
    we can place the last two labels from the previous example side by side rather
    than arrange them vertically. To do that, we must do two things:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`draw`函数内部嵌套更多布局类型。例如，我们可以将上一个示例中的最后两个标签并排放置，而不是垂直排列。为此，我们必须做两件事：
- en: First, we must create a `column` and add the first label to it.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个`column`并将第一个标签添加到其中。
- en: 'Then, we must create a `row`. The two labels we will add to it will be next
    to each other:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须创建一个`row`。我们将添加到其中的两个标签将相邻：
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, our panel consists of only two lines:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的面板只包含两行：
- en: '![Figure 5.12: The second line consists of two labels](img/Figure_5.12_B18375.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12：第二行包含两个标签](img/Figure_5.12_B18375.jpg)'
- en: 'Figure 5.12: The second line consists of two labels'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：第二行包含两个标签
- en: Adding frames with box layouts
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加带有框布局的框架
- en: 'Other types of sub-layouts provide additional effects. For instance, a box
    layout is like a column, but it is framed in a smoothed rectangle. Let’s say we
    want to display some information from the add-on’s `bl_info`. Here, we can add
    these lines to the `draw` function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的子布局提供额外的效果。例如，框布局就像一列，但它被框在平滑的矩形中。假设我们想显示一些来自附加组件的`bl_info`的信息。在这里，我们可以将这些行添加到`draw`函数中：
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After we call **Reload Scripts**, we will see a frame around that information:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用**重新加载脚本**后，我们将看到围绕该信息的框架：
- en: '![Figure 5.13: A box layout surrounds the version information](img/Figure_5.13_B18375.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13：包围版本信息的框布局](img/Figure_5.13_B18375.jpg)'
- en: 'Figure 5.13: A box layout surrounds the version information'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：包围版本信息的框布局
- en: We have put a caption of `"version"` and some information stating `bl_info['version']`
    in a row. That gives the same space to each element. To have more control over
    how much space is taken by the first element, we can use a `split` layout.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在行中放置了标题`"version"`和表示`bl_info['version']`的一些信息。这样，每个元素都有相同的空间。为了更好地控制第一个元素占用的空间，我们可以使用`split`布局。
- en: Using composite layouts
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用复合布局
- en: Some layouts consist of more rows or columns. A `split` layout distributes the
    available space across different columns, while a `grid` layout creates rows and
    columns automatically.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一些布局由更多行或列组成。`split`布局将可用空间分配到不同的列，而`grid`布局会自动创建行和列。
- en: We are going to use them to build a more sophisticated panel.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用它们来构建一个更复杂的面板。
- en: Arranging in splits
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割排列
- en: We can use the `split` method to create a layout whose columns’ width can be
    tweaked. The `factor` argument is optional and accepts values between `0.0` and
    `1.0`. Leaving it to the default value of `0.0` computes the optimal width automatically;
    otherwise, it sets the percentage occupied by the first column.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`split`方法创建一个布局，其列宽可以调整。`factor`参数是可选的，接受`0.0`到`1.0`之间的值。将其保留为默认值`0.0`将自动计算最佳宽度；否则，它将设置第一列占用的百分比。
- en: In this example, we’ll use a factor of `0.33` to give less space to the first
    column. Here, we will also create two columns so that we can fill them later and
    arrange more elements like we would in a table.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`0.33`这个系数来减少第一列的空间。在这里，我们还将创建两列，以便我们稍后填充它们并排列更多元素，就像在表格中一样。
- en: 'The following snippet displays two entries per line. The first column takes
    about one-third of the space:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段每行显示两个条目。第一列大约占据三分之一的空間：
- en: '[PRE14]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Upon reloading the scripts, we will see our captions taking up one-third of
    the space, leaving the rest to the relevant information:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载脚本后，我们将看到我们的标题占据了三分之一的空间，其余空间留给相关信息：
- en: '![Figure 5.14: Author and version information taking one-third of the space](img/Figure_5.14_B18375.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14：作者和版本信息占据三分之一的空間](img/Figure_5.14_B18375.jpg)'
- en: 'Figure 5.14: Author and version information taking one-third of the space'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：作者和版本信息占据三分之一的空間
- en: We can take advantage of dictionary methods to add more information from `bl_info`.
    This way, we can populate our `split` layout using a `for` loop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用字典方法从`bl_info`中添加更多信息。这样，我们可以使用`for`循环来填充我们的`split`布局。
- en: Populating with dictionaries
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字典填充
- en: Since we have created the columns already, we can add more entries using a loop.
    This is ideal for displaying the entries in a dictionary.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经创建了列，我们可以使用循环添加更多条目。这对于在字典中显示条目非常理想。
- en: 'Let’s say that we want to show all the add-on information. In that case, we
    can iterate all the keyword/value pairs using the `items()` method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想显示所有插件信息。在这种情况下，我们可以使用`items()`方法迭代所有关键字/值对：
- en: '[PRE15]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we skip unset values of `bl_info` using `continue` when `v` is empty.
    In these few lines, we can display all the available add-on information:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`continue`跳过`bl_info`的未设置值，当`v`为空时。在这几行中，我们可以显示所有可用的插件信息：
- en: '![Figure 5.15: A box layout displaying bl_info](img/Figure_5.15_B18375.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图5.15：显示bl_info的框布局](img/Figure_5.15_B18375.jpg)'
- en: 'Figure 5.15: A box layout displaying bl_info'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15：显示bl_info的框布局
- en: If we are happy with leaving the column width to Blender, we can use a grid
    layout instead.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意让Blender决定列宽，我们可以使用网格布局。
- en: Arranging grids
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排列网格
- en: 'A `grid_flow` layout is very convenient for arranging our elements into tables
    as it creates rows and columns automatically. For instance, we can display the
    object names from the scene on two columns by using `grid_flow(columns=2)` and
    adding labels to a `for` loop:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid_flow`布局非常适合将我们的元素排列成表格，因为它会自动创建行和列。例如，我们可以通过使用`grid_flow(columns=2)`和将标签添加到`for`循环中来在两列中显示场景中的对象名称：'
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code will display the names of the objects in the current scene, arranged
    in a two-column grid:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将显示当前场景中对象的名称，以两列网格排列：
- en: '![Figure 5.16: Object names displayed in a grid](img/Figure_5.16_B18375.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图5.16：以网格显示的对象名称](img/Figure_5.16_B18375.jpg)'
- en: 'Figure 5.16: Object names displayed in a grid'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16：以网格显示的对象名称
- en: With that, we have seen that labels can display icons too. This means we can
    display an icon of the object’s type beside each name, just like the outliner
    does.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经看到标签也可以显示图标。这意味着我们可以在每个名称旁边显示对象的类型图标，就像大纲视图一样。
- en: Building icon keywords
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建图标关键词
- en: 'A quick search in the `OUTLINER_OB_MESH` and `OUTLINER_OB_CURVE`, follow this
    pattern:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OUTLINER_OB_MESH`和`OUTLINER_OB_CURVE`中进行快速搜索，遵循以下模式：
- en: '[PRE17]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is depicted in the following figure:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下图中表示：
- en: '![Figure 5.17: Object type icons as displayed in the Icon Viewer area](img/Figure_5.17_B18375.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图5.17：图标查看器区域中显示的对象类型图标](img/Figure_5.17_B18375.jpg)'
- en: 'Figure 5.17: Object type icons as displayed in the Icon Viewer area'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：在图标查看器区域显示的对象类型图标
- en: 'With that in mind, we can build those keywords using *string formatting*, a
    feature of Python 3 that makes combining strings and variables easier. To inform
    Python that we are using formatting, we must put an `f` character before the quote
    or apostrophe delimiters, then surround our variables with curly brackets inside
    the string. Here is an example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以使用 *字符串格式化*（Python 3 的一个特性，使得组合字符串和变量更容易）来构建这些关键字。为了通知 Python 我们正在使用格式化，我们必须在引号或撇号分隔符之前放置一个
    `f` 字符，然后在字符串内部用花括号包围我们的变量。以下是一个示例：
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With that in mind, we get the string for the object type – for example, `''MESH''`,
    `''CURVE''`, or `''ARMATURE''` – using the `ob.type` attribute, then build the
    icon keyword using the following line:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们使用 `ob.type` 属性获取对象类型的字符串 - 例如，`'MESH'`、`'CURVE'` 或 `'ARMATURE'` -
    然后使用以下行构建图标关键字：
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This result can be fed to the `icon` parameter inside our loop:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果可以馈送到循环内的 `icon` 参数：
- en: '[PRE20]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can reload the scripts and see how icons are displayed before names:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新加载脚本并查看图标在名称之前是如何显示的：
- en: '![Figure 5.18: A custom panel listing the scene objects and their icons](img/Figure_5.18_B18375.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18：一个自定义面板，列出场景对象及其图标](img/Figure_5.18_B18375.png)'
- en: 'Figure 5.18: A custom panel listing the scene objects and their icons'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：一个自定义面板，列出场景对象及其图标
- en: We don’t want this list to take up too much space on large scenes, so we will
    break the loop after a certain number of objects. For instance, we can stop listing
    objects and display an ellipsis after the fourth listed object.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望这个列表在大场景中占用太多空间，因此我们将在一定数量的对象后中断循环。例如，我们可以在列出第四个对象后停止列出对象并显示省略号。
- en: 'Leaving the ellipsis on the last line implies filling the grid row by row.
    To do that, we must set the `row_major` argument to `True` for our `grid_flow`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行留下省略号意味着按行填充网格。为了做到这一点，我们必须将 `row_major` 参数设置为 `True` 以用于 `grid_flow`：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A (bad) kind of magic
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一种（不好的）魔法
- en: Arbitrary digits appearing in the middle of the code, such as those in `i >
    3`, are called **magic numbers**, and using them is considered bad practice as
    it makes it very difficult to find and change those values at a later stage.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中间出现的任意数字，如 `i > 3` 中的那些，被称为**魔法数字**，使用它们被认为是不良做法，因为它使得在以后阶段找到和更改这些值变得非常困难。
- en: A better solution is to make those numbers members of the class and access them
    later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是将这些数字作为类的成员，并在以后访问它们。
- en: 'Storing `3` as a static member makes it easier to display the number of remaining
    objects. String formatting also works with numeric variables, so we can compute
    how many objects are left and use the result in curly brackets:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `3` 存储为静态成员使其更容易显示剩余对象的数量。字符串格式化也适用于数值变量，因此我们可以计算剩余对象的数量，并将结果用于花括号中：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since `max_objects` is an attribute of the class, it can be changed via Python.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `max_objects` 是类的属性，它可以通过 Python 进行更改。
- en: 'Blender considers these add-ons to be Python modules, so it is possible to
    execute these lines in the **Python Console** or **Text** **Editor** area:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 将这些插件视为 Python 模块，因此可以在 **Python 控制台** 或 **文本** **编辑器**区域执行这些行：
- en: '[PRE23]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The downside of this trick is that every reload of the add-on resets that value.
    A better way to change the settings in our add-on, which is by using `bpy.types.Preferences`,
    will be discussed in [*Chapter 6*](B18375_06.xhtml#_idTextAnchor129):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧的缺点是每次重新加载插件都会重置该值。在我们的插件中更改设置的一个更好的方法是使用 `bpy.types.Preferences`，这将在 [*第
    6 章*](B18375_06.xhtml#_idTextAnchor129) 中讨论：
- en: '![Figure 5.19: Changing the limit displays more than three objects](img/Figure_5.19_B18375.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19：更改限制显示超过三个对象](img/Figure_5.19_B18375.png)'
- en: 'Figure 5.19: Changing the limit displays more than three objects'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19：更改限制显示超过三个对象
- en: Using icons and informative text adds to the visual feedback of our UI. In the
    next section, we’ll take advantage of the colors from layout states to convey
    status information.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图标和说明性文本增加了我们 UI 的视觉反馈。在下一节中，我们将利用布局状态的颜色来传达状态信息。
- en: Providing color feedback
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供颜色反馈
- en: 'Our object list will be much more useful if we can highlight which objects
    are selected and which are active. For instance, to reflect the selection status
    of an object in the color of its name, our script must perform two actions:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以突出显示哪些对象被选中以及哪些是活动的，我们的对象列表将更有用。例如，为了在对象名称的颜色中反映选择状态，我们的脚本必须执行两个操作：
- en: Check whether an object is selected.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查一个对象是否被选中。
- en: If it’s selected or active, display its name in a different color.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它被选中或处于活跃状态，则以不同的颜色显示其名称。
- en: Let’s learn how to perform these tasks using Blender’s API.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用Blender的API来完成这些任务。
- en: Checking whether an object has been selected
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查对象是否被选中
- en: 'We can get the selection status of an object using its `select_get()` method.
    For instance, if the `''Cube''` object is selected, its `selected_get` method
    will return `True`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用对象的`select_get()`方法来获取对象的选中状态。例如，如果`'Cube'`对象被选中，其`selected_get`方法将返回`True`：
- en: '[PRE24]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We already know from [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033)*,* that,
    unlike the selection status, `active` is not a flag of the object, so how we retrieve
    this information is a bit different.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[*第二章*](B18375_02.xhtml#_idTextAnchor033)**中已经知道，与选择状态不同，`活跃`并不是对象的标志，因此我们获取这些信息的方式略有不同。
- en: Checking whether an object is active
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查对象是否活跃
- en: 'To check whether an object is active, we can test whether it matches the one
    stored in `context.object`. Here’s what happens when `''Cube''` is the active
    object:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个对象是否活跃，我们可以测试它是否与存储在`context.object`中的对象匹配。以下是当`'Cube'`是活跃对象时发生的情况：
- en: '[PRE25]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we know how to retrieve the activity status of an object, let’s look
    at ways we can alter the color of its labels.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何检索对象的活跃状态，接下来让我们看看如何改变其标签的颜色。
- en: Drawing layouts in red or gray
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用红色或灰色绘制布局
- en: 'Sometimes, painting text with a different color is useful to make an entry
    stand out. Blender doesn’t allow us to set the color of a piece of text explicitly,
    but we can take advantage of two specific attributes that alter the way a UI layout
    is displayed:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，用不同的颜色绘制文本可以使条目更加突出。Blender不允许我们显式设置文本的颜色，但我们可以利用两个特定的属性来改变UI布局的显示方式：
- en: '`UILayout.enabled = False` is meant to display an element without letting the
    user interact with it. This is very useful if we want to make the user aware that,
    even if an operation is not possible now, the interface for executing it is there
    to be found.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UILayout.enabled = False`的目的是在不让用户与之交互的情况下显示一个元素。如果我们想让用户意识到，即使现在无法执行某个操作，执行该操作的界面仍然存在，这将非常有用。'
- en: '`UILayout.alert = True` is useful for warning the user about something wrong,
    or potentially wrong.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UILayout.alert = True`对于警告用户有关某些错误或潜在错误的情况非常有用。'
- en: 'Those are very specific purposes, but we can take advantage of how they affect
    the displayed color:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用途非常具体，但我们可以利用它们对显示颜色的影响：
- en: UI layouts whose `enabled` attribute equals `False` are *gray*
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`属性等于`False`的UI布局是*灰色*'
- en: UI layouts whose `alert` attribute equals `True` are *red*
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alert`属性等于`True`的UI布局是*红色*'
- en: 'So, we can use that to change the color of an entire layout. Labels are not
    layouts, and the `label()` method returns a `None` type. Since we cannot set those
    attributes directly on the text labels, we need to create a new layout for each
    entry of the grid and use that when we create our text:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以利用这一点来改变整个布局的颜色。标签不是布局，`label()`方法返回`None`类型。由于我们无法直接在文本标签上设置这些属性，我们需要为网格的每个条目创建一个新的布局，并在创建文本时使用它：
- en: '[PRE26]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can set `item_layout.enabled` to `True` for selected objects and `False`
    for the unselected ones with this line:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这一行将`item_layout.enabled`设置为`True`以用于选中的对象，以及`False`用于未选中的对象：
- en: '[PRE27]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Likewise, we can set `item_layout.alert` by assigning the result of the equality
    test `(==`) directly:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过直接赋值等式测试的结果（`==`）来设置`item_layout.alert`：
- en: '[PRE28]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we can see, the list now provides information about which objects are active
    and/or selected:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，列表现在提供了有关哪些对象是活跃的或选中的信息：
- en: '![Figure 5.20: The active object is dark red, while unselected objects are
    gray](img/Figure_5.20_B18375.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图5.20：活跃对象为深红色，而未选中的对象为灰色](img/Figure_5.20_B18375.jpg)'
- en: 'Figure 5.20: The active object is dark red, while unselected objects are gray'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20：活跃对象为深红色，而未选中的对象为灰色
- en: We can also add buttons to perform some operations, as we’ll see in the next
    section.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加按钮来执行一些操作，正如我们将在下一节中看到的。
- en: Displaying buttons
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示按钮
- en: Intuitively, pushing a button performs a transformative action. Since buttons
    take up space, the default interface displays only the more generic operations.
    When we write custom interfaces, we can add more buttons based on our specific
    needs. This is made easier by how Blender translates operators into buttons. In
    this section, we’ll learn how buttons and operators are equivalent when it comes
    to the graphical interface.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地讲，按按钮执行转换动作。由于按钮占用空间，默认界面只显示更通用的操作。当我们编写自定义界面时，我们可以根据我们的具体需求添加更多按钮。这使得Blender将操作符转换为按钮变得更容易。在本节中，我们将学习按钮和操作符在图形界面中的等效性。
- en: Using the operator method
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用操作符方法
- en: We can use the `UILayout.operator` method to display a button. In Blender, a
    button executes an operator. This operator is found through its identifier – that
    is, the `bl_idname` attribute, which we encountered in [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049)
    – and every operator must have it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`UILayout.operator`方法来显示按钮。在Blender中，按钮执行操作符。这个操作符通过其标识符找到——即`bl_idname`属性，我们在[*第3章*](B18375_03.xhtml#_idTextAnchor049)中遇到过——每个操作符都必须有它。
- en: For instance, to add a button that deletes the selected objects, we must provide
    the identifier of the **Delete** operator.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要添加一个删除所选对象的按钮，我们必须提供**删除**操作符的标识符。
- en: 'If we use the **Delete** action from the **Object** menu or the *X* key and
    look into the **Scripting** workspace, we will find this new line in the **Info**
    **Log** area:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用**对象**菜单中的**删除**操作或*X*键，并查看**脚本**工作区，我们将在**信息** **日志**区域找到这条新行：
- en: '[PRE29]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The part before the parentheses, `bpy.ops.object.delete`, is the operator class.
    We must be careful as we must not use the class itself as the argument of the
    operator, but the identifier of that class. We can get the identifier using the
    `idname()` method:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 括号前的部分，`bpy.ops.object.delete`，是操作符类。我们必须小心，因为我们不能将类本身用作操作符的参数，而是该类的标识符。我们可以使用`idname()`方法来获取标识符：
- en: '[PRE30]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using the `'OBJECT_OT_delete'` string as the argument of `operator()` will create
    a **Delete** button.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`'OBJECT_OT_delete'`字符串作为`operator()`的参数将创建一个**删除**按钮。
- en: ID please
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入ID
- en: 'Using the `operator` class instead of an operator’s identifier with `operator`
    causes `TypeError`: the operator and all the elements that follow it will not
    be displayed.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`operator`类而不是操作符的标识符`operator`会导致`TypeError`：操作符及其后面的所有元素将不会显示。
- en: We can either use the `idname()` function or the identifier string directly.
    The function is preferred as it guarantees compatibility in case of future changes.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`idname()`函数或直接使用标识符字符串。函数是首选的，因为它保证了在将来更改时的兼容性。
- en: 'To display a `draw` function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示一个`draw`函数：
- en: '[PRE31]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here’s what we’ll see:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下内容：
- en: '![Figure 5.21: The Delete button has been added to the panel](img/Figure_5.21_B18375.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图5.21：删除按钮已添加到面板中](img/Figure_5.21_B18375.png)'
- en: 'Figure 5.21: The Delete button has been added to the panel'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21：已将删除按钮添加到面板中
- en: Pressing the **Delete** button deletes the selected object. It is equivalent
    to invoking **Object** | **Delete** from the menu.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**删除**按钮将删除所选对象。这相当于从菜单中调用**对象** | **删除**。
- en: Setting the operator’s text and visibility
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置操作符的文本和可见性
- en: 'We can customize the button text or toggle the button’s display. For instance,
    we can hide `context`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自定义按钮文本或切换按钮的显示。例如，我们可以隐藏`context`：
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can reflect this information in the button label. The following snippet
    changes the button’s text according to the number of objects that have been selected.
    It also adds an “s” to the word “object” at the end so that it can use the plural
    form when needed:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在按钮标签中反映此信息。以下代码片段根据已选对象的数量更改按钮的文本。它还在“object”一词的末尾添加了一个“s”，以便在需要时使用复数形式：
- en: '[PRE33]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Figure 5.22: The text of the button changes according to the selection](img/Figure_5.22_B18375.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图5.22：按钮的文本根据选择而改变](img/Figure_5.22_B18375.jpg)'
- en: 'Figure 5.22: The text of the button changes according to the selection'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22：按钮的文本根据选择而改变
- en: Nothing to hide (usually)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 没有要隐藏的内容（通常）
- en: It is often said that hiding pieces of the UI is generally wrong as it leaves
    the user with no knowledge of where a feature can be found once the conditions
    have been met. This is generally a valid point, even though for didactical purposes,
    a disappearing button was used in the preceding example.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，隐藏UI的一部分通常是错误的，因为它让用户在条件满足后无法知道功能在哪里。这通常是一个有效的观点，尽管为了教学目的，在先前的例子中使用了消失的按钮。
- en: 'If we want to abide by the “no-hiding” rule, we can add an `else` statement
    containing a disabled layout:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想遵守“不隐藏”规则，我们可以在 `else` 语句中添加一个禁用的布局：
- en: '[PRE34]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When coding, rules can be broken but not ignored!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时，规则可以被打破但不能被忽视！
- en: Overriding an operator’s settings
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖操作符的设置
- en: 'The `delete` operator prompts a confirm dialog before deleting an object. This
    is its default behavior, and it can be overridden:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 操作符在删除对象之前会提示确认对话框。这是它的默认行为，并且可以被覆盖：'
- en: '![Figure 5.23: Clicking Delete opens a confirmation menu](img/Figure_5.23_B18375.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图5.23：点击删除将打开确认菜单](img/Figure_5.23_B18375.jpg)'
- en: 'Figure 5.23: Clicking Delete opens a confirmation menu'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23：点击删除将打开确认菜单
- en: 'This is reflected in the documented docstring. If we type the operator’s address
    and press *Tab*, the autocomplete will display two optional arguments called `use_global`
    and `confirm`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这在文档化的docstring中得到了体现。如果我们输入操作符的地址并按下 *Tab* 键，自动完成将显示两个可选参数，称为 `use_global`
    和 `confirm`：
- en: '[PRE35]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can learn more about this by looking at the API documentation. Right-clicking
    on the **Delete** button will display a menu containing a direct link:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看API文档来了解更多信息。右键单击 **删除** 按钮将显示一个包含直接链接的菜单：
- en: '![Figure 5.24: The right-click menu of our Delete button can open the online
    documentation](img/Figure_5.24_B18375.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图5.24：我们的删除按钮的右键菜单可以打开在线文档](img/Figure_5.24_B18375.jpg)'
- en: 'Figure 5.24: The right-click menu of our Delete button can open the online
    documentation'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24：我们的删除按钮的右键菜单可以打开在线文档
- en: 'The documentation describes these Boolean arguments:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 文档描述了这些布尔参数：
- en: '`use_global` (Boolean, optional): Delete globally or remove the object from
    all scenes'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_global`（布尔值，可选）：全局删除或从所有场景中删除对象'
- en: '`confirm` (Boolean, optional): Confirm or prompt for confirmation'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`confirm`（布尔值，可选）：确认或提示确认'
- en: According to the documentation, setting `use_global` to `True` would remove
    the selected objects from all the currently opened scenes. We do not want that,
    so we are not changing the default value.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，将 `use_global` 设置为 `True` 将从所有当前打开的场景中删除选定的对象。我们不想这样做，所以我们没有更改默认值。
- en: The `confirm` parameter, on the other hand, is `True` by default. We need to
    change that to `False`, and since the button takes care of invoking the operator,
    we need to change that in the button’s properties.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`confirm` 参数默认为 `True`。我们需要将其更改为 `False`，并且由于按钮负责调用操作符，我们需要在按钮的属性中进行更改。
- en: Setting operator properties
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置操作符属性
- en: 'The `operator` function returns an `OperatorProperties` object, which is a
    class containing the attributes that can be set. Typically, we use the following
    code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator` 函数返回一个 `OperatorProperties` 对象，这是一个包含可以设置的属性的类。通常，我们使用以下代码：'
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead, we will store the properties returned by `operator` in the `props`
    variable so that we can change them later:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将存储 `operator` 返回的属性在 `props` 变量中，以便我们稍后可以更改它们：
- en: '[PRE37]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This button triggers the `delete` operator, which is native to Blender. Since
    the interface considers Python and built-in operators equivalent, we can display
    buttons for our operators too.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此按钮触发 `delete` 操作符，这是 Blender 的原生操作符。由于界面将 Python 和内置操作符视为等效，我们也可以为我们的操作符显示按钮。
- en: Adding buttons for our functions
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的函数添加按钮
- en: 'We will add a button for displacing each of the selected objects randomly.
    This can be done to give a more “natural” look to our scene. To do that, we must
    write a new operator. Blender’s operators transform all the selected objects in
    the same way. First, we must import the `random` module at the beginning of our
    script:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个选定的对象添加一个随机位移的按钮。这可以用来给我们的场景一个更“自然”的外观。为了做到这一点，我们必须编写一个新的操作符。Blender 的操作符会将所有选定的对象以相同的方式进行变换。首先，我们必须在脚本的开头导入
    `random` 模块：
- en: '[PRE38]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We proceed with our location function. It can be part of the operator class,
    but we can also write a function that stands on. The operator will call it inside
    its `execute` method. This function’s arguments are as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续进行位置函数。它可以作为操作符类的一部分，但我们也可以编写一个独立的功能。操作符将在其 `execute` 方法内部调用该功能。此函数的参数如下：
- en: The objects to dislocate
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要错位的对象
- en: The max number of units to add or subtract from each object’s location
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象位置添加或减去的最大单位数
- en: Which axis should be affected
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个轴应该受到影响
- en: 'We will feed the amount of displacement to the `randint` function, which will
    return a random integer number between a `min` and `max` range. We’ll do that
    for each of the three axes (*X*, *Y*, and *Z*), so long as their entries in `do_axis`
    are `True`. The `amount` and `do_axis` arguments are optional. We set their default
    values to `1` and `True, True, True` in the function’s declaration:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把位移量输入到 `randint` 函数中，该函数将返回一个介于 `min` 和 `max` 范围内的随机整数。我们将为三个轴（*X*、*Y* 和
    *Z*）中的每一个都这样做，只要它们的 `do_axis` 项为 `True`。`amount` 和 `do_axis` 参数是可选的。我们在函数声明中将它们的默认值设置为
    `1` 和 `True, True, True`：
- en: '[PRE39]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we need an operator to display in the interface. We will add properties
    for the `amount` and `do_axis` function arguments. To an operator, an integer
    and a tuple of Booleans are `IntProperty` and `BoolVectorProperty`, respectively:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个在界面中显示的操作符。我们将为 `amount` 和 `do_axis` 函数参数添加属性。对于操作符，整数和布尔值的元组分别是 `IntProperty`
    和 `BoolVectorProperty`：
- en: '[PRE40]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The operator methods are straightforward; `poll` only makes sure that there
    are objects selected, while `execute` runs `add_random_location`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符方法很简单；`poll` 只确保已选择对象，而 `execute` 执行 `add_random_location`：
- en: '[PRE41]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Adding this operator to the layout displays a new button. As stated earlier,
    native and scripted operators are the same to the interfacee. In both cases, it
    looks for the operator’s identifier when it comes to invoking it. Scripted operators
    offer one small advantage, though: we can refer to their `bl_idname` attribute
    directly since their classes and our graphical interface belong to the same module
    or package.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 将此操作符添加到布局中会显示一个新按钮。如前所述，原生和脚本操作符对界面来说是相同的。在两种情况下，它都会在调用时查找操作符的标识符。尽管如此，脚本操作符提供一个小优势：由于它们的类和我们的图形界面属于同一个模块或包，我们可以直接引用它们的
    `bl_idname` 属性。
- en: 'Here’s our line for displaying the **Add random** **Location** button:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这是显示 **添加随机** **位置** 按钮的代码行：
- en: '[PRE42]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And of course, we mustn’t neglect class registration and removal. Here’s the
    line we should add to `register()`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也不能忽视类注册和删除。以下是应添加到 `register()` 的代码行：
- en: '[PRE43]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Likewise, the add-on’s `unregister()` function should contain the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，附加组件的 `unregister()` 函数应包含以下内容：
- en: '[PRE44]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After invoking **Reload Scripts**, a new button will appear:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 **重新加载脚本** 后，将出现一个新按钮：
- en: '![Figure 5.25: Our panel now displays two buttons](img/Figure_5.25_B18375.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.25：我们的面板现在显示两个按钮](img/Figure_5.25_B18375.jpg)'
- en: 'Figure 5.25: Our panel now displays two buttons'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25：我们的面板现在显示两个按钮
- en: 'Pressing this button should add random variation to the positions of selected
    objects since the operator properties do not pop up at execution. Even adding
    the `bl_options = {''REGISTER'', ''UNDO''}` operator property, which we learned
    about in the *Writing the Elevator add-on* section in [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075),
    would not change that: operator properties must be displayed explicitly when they
    are not run from the **3D** **Viewport** area.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 按下此按钮应向所选对象的位置添加随机变化，因为操作符属性在执行时不会弹出。即使添加了我们在 [*第 4 章*](B18375_04.xhtml#_idTextAnchor075)
    的 *编写电梯插件* 部分中了解到的 `bl_options = {'REGISTER', 'UNDO'}` 操作符属性，也不会改变这一点：当操作符属性不是从
    **3D** **视口** 区域运行时，必须显式显示操作符属性。
- en: Displaying the operator properties
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示操作符属性
- en: Besides `poll` and `execute`, Blender operators involve another method, named
    `invoke`. The `invoke` method is run internally right before `execute`. Usually,
    we don’t need to define it, but in this case, we use it to tell Blender that we
    want to display and edit the operator properties – that is, our function arguments.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `poll` 和 `execute`，Blender 操作符还涉及另一个名为 `invoke` 的方法。`invoke` 方法在 `execute`
    之前内部运行。通常我们不需要定义它，但在这个例子中，我们使用它来告诉 Blender 我们想要显示和编辑操作符属性——即我们的函数参数。
- en: 'Besides `self` and `context`, `invoke` takes `event` as an argument. It contains
    information about what triggered the operator, but we don’t need that now. We
    only tell `window_manager` to display the properties dialog. So, we must add a
    few lines of code after the `poll` method:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `self` 和 `context`，`invoke` 还接受 `event` 作为参数。它包含有关触发操作符的信息，但我们现在不需要它。我们只告诉
    `window_manager` 显示属性对话框。因此，我们必须在 `poll` 方法之后添加几行代码：
- en: '[PRE45]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Reloading the scripts and pressing the `add_random_location` function:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载脚本并按下 `add_random_location` 函数：
- en: '![Figure 5.26: Using operator properties as function arguments](img/Figure_5.26_B18375.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.26：使用操作符属性作为函数参数](img/Figure_5.26_B18375.jpg)'
- en: 'Figure 5.26: Using operator properties as function arguments'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26：使用操作符属性作为函数参数
- en: With that, our object panel is finished. As a bonus, next, we will learn how
    to move it to a different part of the UI.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的对象面板就完成了。作为额外收获，接下来我们将学习如何将其移动到UI的不同部分。
- en: Using different regions
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的区域
- en: Usually, panels can be moved freely to another part of the interface. There
    are a few exceptions where repositioning a panel would not make much sense. For
    instance, a tool that helps select the controls of a character would be of little
    help in the Video Editor, and its `poll()` method might be looking for attributes,
    such as animation bones, outside of the animation’s `context`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，面板可以自由地移动到界面的另一部分。有一些例外，重新定位面板可能没有太多意义。例如，一个帮助选择角色控制器的工具在视频编辑器中几乎没有帮助，它的`poll()`方法可能正在寻找动画的`context`之外的属性，如动画骨骼。
- en: Outside of those cases, changing the `bl_*` attributes of a `Panel` class is
    enough to move our panel to a different place. Please refer to the *panel attributes*
    that we looked at in the *Creating a simple panel* section of this chapter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些情况下，更改`Panel`类的`bl_*`属性就足以将我们的面板移动到不同的位置。请参考本章“创建简单面板”部分中我们查看的*面板属性*。
- en: 'So, to display our panel in the `bl_space_type` and `bl_region_type` as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了在`bl_space_type`和`bl_region_type`中显示我们的面板，如下所示：
- en: '[PRE46]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![Figure 5.27: Our panel has been moved to the 3D Viewport area](img/Figure_5.27_B18375.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图5.27：我们的面板已移动到3D视口区域](img/Figure_5.27_B18375.jpg)'
- en: 'Figure 5.27: Our panel has been moved to the 3D Viewport area'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27：我们的面板已移动到3D视口区域
- en: 'By default, the `bl_category` attribute can be used to specify new or existing
    tabs:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可以使用`bl_category`属性来指定新标签或现有标签：
- en: '[PRE47]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If a Blender add-on contains more panels, putting them under the same tab is
    a good way to keep the interface neat:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Blender插件包含多个面板，将它们放在同一个标签下是一种保持界面整洁的好方法：
- en: '![Figure 5.28: A Viewport tab created from the bl_category attribute](img/Figure_5.28_B18375.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图5.28：从bl_category属性创建的视口标签](img/Figure_5.28_B18375.jpg)'
- en: 'Figure 5.28: A Viewport tab created from the bl_category attribute'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.28：从bl_category属性创建的视口标签
- en: We have reached the end of our interface overview. There will be more UI insights
    in the next few chapters when we introduce lists and thumbnails, but for now,
    we have built a solid understanding of how to use layouts in Blender.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了界面概述的结尾。在介绍列表和缩略图时，下一章将会有更多的UI见解，但到目前为止，我们已经对如何在Blender中使用布局有了稳固的理解。
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create and populate a custom `UIPanel` via
    Python and how to integrate that into our add-on. That gave us insight into how
    the Blender interface works in general and which steps we must take to add our
    widgets to it.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过Python创建和填充自定义`UIPanel`，以及如何将其集成到我们的插件中。这让我们了解了Blender界面的一般工作原理以及我们必须采取哪些步骤来向其中添加小部件。
- en: We also nested layouts together for a more complex appearance and displayed
    both native and external icons.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还嵌套了布局以获得更复杂的显示效果，并显示了原生和外部图标。
- en: Lastly, we learned how to change our panel’s look according to the context without
    too much increase in complexity, as well as how to add functions to the UI.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何根据上下文更改面板的外观，而不会增加太多的复杂性，以及如何向UI添加功能。
- en: This closes the first part of this book, where we gained an overall understanding
    of how Blender and Python work together and what Python scripts can do.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第一部分到此结束，我们获得了对Blender和Python如何协同工作以及Python脚本可以做什么的整体理解。
- en: The add-on we have written relies on an external file called `icon_smile_64.png`.
    If we were to distribute it to the public, we would have to package it as a ZIP
    file. This is something we are going to do in [*Chapter 6*](B18375_06.xhtml#_idTextAnchor129),
    which marks the beginning of *Part 2*, *Interactive Tools* *and Animation*.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的插件依赖于一个名为`icon_smile_64.png`的外部文件。如果我们将其公开分发，我们必须将其打包成ZIP文件。这是我们将在[*第6章*](B18375_06.xhtml#_idTextAnchor129)中要做的事情，这标志着*第二部分*，*交互式工具*和*动画*的开始。
- en: Questions
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is it possible for an area of the screen to host more than one editor?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 屏幕上的一个区域是否可以容纳多个编辑器？
- en: Do all the editors consist of the same regions?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有编辑器是否都由相同的区域组成？
- en: How do we set the editor, region, and context to which a panel belongs?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何设置编辑器、区域和上下文，以便面板属于它们？
- en: Must we always set a panel’s category?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否必须始终设置面板的类别？
- en: Are the elements of a panel static or can they change dynamically?
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面板的元素是静态的还是可以动态更改的？
- en: Can we alter the color of a piece of text?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否更改文本的颜色？
- en: How do we display buttons?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何显示按钮？
- en: 'Part 2: Interactive Tools and Animation'
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：交互式工具和动画
- en: This part exposes modular, structured add-ons that interact with the animation
    system. It also introduces modal tools that capture the user input and the different
    steps of an operator’s execution.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分介绍了与动画系统交互的模块化、结构化附加组件。它还介绍了捕获用户输入和操作员执行不同步骤的模式工具。
- en: 'This section comprises the following chapters:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 6*](B18375_06.xhtml#_idTextAnchor129), *Structuring Our Code and
    Add-Ons*'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18375_06.xhtml#_idTextAnchor129)，*结构化我们的代码和附加组件*'
- en: '[*Chapter 7*](B18375_07.xhtml#_idTextAnchor171), *The Animation System*'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18375_07.xhtml#_idTextAnchor171)，*动画系统*'
- en: '[*Chapter 8*](B18375_08.xhtml#_idTextAnchor206), *Animation Modifiers*'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18375_08.xhtml#_idTextAnchor206)，*动画修改器*'
- en: '[*Chapter 9*](B18375_09.xhtml#_idTextAnchor226), *Animation Drivers*'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18375_09.xhtml#_idTextAnchor226)，*动画驱动器*'
- en: '[*Chapter 10*](B18375_10.xhtml#_idTextAnchor247), *Advanced and Modal Operators*'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18375_10.xhtml#_idTextAnchor247)，*高级和模式操作员*'
