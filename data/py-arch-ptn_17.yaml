- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Metrics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标
- en: As well as logging, the other key element of observability is metrics. Metrics
    allow you to see the general state of the system and observe trends and situations
    that are mostly caused by multiple, perhaps even many, tasks being executed at
    the same time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日志记录之外，可观察性的另一个关键元素是指标。指标允许你看到系统的总体状态，并观察由多个任务，甚至可能是许多任务同时执行而引起的大多数趋势和情况。
- en: During this chapter, we will mostly use examples of web services, like request
    metrics. Do not feel restricted by them; you can generate metrics in all kinds
    of services!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要使用网络服务的示例，如请求指标。不要受它们的限制；你可以在各种服务中生成指标！
- en: When monitoring a live system, typically metrics are the main focus, as they
    allow you to see at a glance whether everything appears to be working correctly.
    Normally with metrics, it is possible to detect if a system is struggling, for
    example, for a sudden increase in the number of incoming requests, but also to
    foresee problems by showing trends, like a small but constant increase in the
    number of requests. This allows you to act preemptively, without waiting until
    a problem is serious.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 监控实时系统时，通常关注的是指标，因为它们能让你一眼看出是否一切看起来都在正常工作。通常，通过指标，你可以检测到系统是否在努力，例如，突然增加的请求数量，但也可以通过显示趋势来预见问题，比如请求数量的小幅但持续的上升。这让你能够主动行动，而无需等到问题变得严重。
- en: Generating a good metric system to monitor the life of a system is invaluable
    to be able to react quickly when problems arise. Metrics can also be used as a
    base for automatic alerts that can help warn about certain conditions taking place,
    typically something to investigate or correct.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个良好的指标系统来监控系统的生命周期对于在问题出现时能够快速反应至关重要。指标还可以用作自动告警的基础，这有助于警告某些条件的发生，通常是需要调查或纠正的事情。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Metrics versus logs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标与日志的比较
- en: Generating metrics with Prometheus
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Prometheus 生成指标
- en: Querying Prometheus
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 Prometheus
- en: Proactively working with metrics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积极地与指标合作
- en: Alerting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告警
- en: First, we will take a look at metrics compared with the other main tool for
    observability, logs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将比较指标与其他主要可观察性工具，即日志。
- en: Metrics versus logs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标与日志的比较
- en: As we saw in the previous chapter, logs are text messages produced as code is
    executed. They are good at giving visibility on each of the specific tasks that
    the system is performing, but they generate a huge amount of data, which is difficult
    to digest in bulk. Instead, only small groups of logs are able to be analyzed
    at any given time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，日志是在代码执行时产生的文本消息。它们擅长提供对系统执行的每个特定任务的可见性，但它们生成的大量数据难以批量处理。相反，在任何给定时间，只有少量日志组能够被分析。
- en: Normally, the logs analyzed will all be related to a single task. We saw in
    the previous chapter how to use a request ID for that. But on certain occasions,
    it may be necessary to check all logs happening in a particular time window to
    see crossing effects, like a problem in one server that affects all tasks during
    certain times.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，分析的日志都将与单个任务相关。我们在上一章中看到了如何使用请求 ID 来做到这一点。但在某些情况下，可能需要检查特定时间窗口内发生的所有日志，以查看交叉效应，比如一个服务器的问题在特定时间影响了所有任务。
- en: But sometimes the important information is not a specific request, but to understand
    the behavior of the system as a whole. Is the load of the system growing compared
    to yesterday's? How many errors are we returning? Is the time it takes to process
    tasks increasing? Or decreasing?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时重要的信息不是特定的请求，而是理解整个系统的行为。与昨天相比，系统的负载是否在增长？我们返回了多少错误？处理任务所需的时间是增加还是减少？
- en: All those questions are impossible to answer with logs, as they require a broader
    view, at a higher level. To be able to achieve that, the data needs to be aggregated
    to be able to understand the system as a whole.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都无法通过日志回答，因为它们需要更广泛的视角，在更高的层面上。为了能够实现这一点，数据需要汇总以便理解整个系统。
- en: The information to store in metrics is also different. While each recorded log
    is a text message, each produced metric is a number. These numbers will later
    be statistically processed to aggregate the information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 需要存储在指标中的信息也有所不同。虽然每条记录的日志都是一条文本消息，但每个生成的指标都是一个数字。这些数字将随后进行统计分析以汇总信息。
- en: We will talk later in the chapter about the different kinds of numbers that
    can be produced as a metric.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论可以作为指标产生的不同类型的数字。
- en: The difference between the amount of information produced in each record means
    that metrics are much more lightweight compared with logs. To further reduce the
    amount of data stored, the data is aggregated automatically.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个记录产生信息量的不同意味着与日志相比，指标要轻量得多。为了进一步减少存储的数据量，数据会自动进行聚合。
- en: The resolution of metrics may depend on the tool and set configuration. Keep
    in mind that a higher resolution will require more resources to store all the
    data. A typical resolution is one minute, which is small enough to present detailed
    information unless you have a very active system that routinely receives 10 tasks
    per second or more.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 指标解析的分辨率可能取决于工具和设置配置。请记住，更高的分辨率将需要更多的资源来存储所有数据。典型的分辨率是一分钟，除非您有一个非常活跃的系统，通常每秒接收10个或更多任务，否则这个分辨率足够小，可以呈现详细的信息。
- en: Metrics should capture and analyze information related to performance, such
    as the average time to process a task. That allows you to detect possible bottlenecks
    and act quickly in order to improve the performance of the system. This is easier
    to do in an aggregated way, as information for a single task, like generated logs,
    may not capture enough information to see the big picture. An important outcome
    of this is to be able to see trends and detect problems before they grow too big,
    remediating them early. Compared to this, logs are mostly used after the fact
    and are difficult to use as a way to take preventive action.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 指标应捕获和分析与性能相关的信息，例如处理任务的平均时间。这允许您检测可能的瓶颈并迅速采取行动以改善系统的性能。这以聚合方式更容易做到，因为单个任务的信息，如生成的日志，可能不足以捕捉到整体情况。这一结果的重要之处在于能够在问题变得太大之前看到趋势并检测到问题，及早进行修复。相比之下，日志通常在事后使用，并且难以用作预防措施的方式。
- en: Kinds of metrics
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标类型
- en: 'There are different kinds of metrics that can be produced. This can be different
    depending on the specific tool used to generate the metrics, but in general, there
    are a few that are common in most systems, like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以产生不同类型的指标。这取决于用于生成指标的特定工具，但一般来说，大多数系统中都有一些常见的指标，如下所示：
- en: '**Counter**: A trigger is generated each time something happens. This will
    be counted and aggregated as a total; for example, in a web service, the number
    of requests or the number of generated errors. Counters are useful for understanding
    how many times a certain action happens in the system.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**：每当发生某事时都会生成一个触发器。这将作为总数进行计数和聚合；例如，在Web服务中，请求的数量或生成的错误数量。计数器有助于理解在系统中某个特定动作发生的次数。'
- en: '**Gauge**: A single number across the system. A gauge number can go up or down,
    but the last value overwrites the previous, as it stores the general state of
    the system; for example, the number of elements in a queue, or the number of existing
    workers in the system.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表**：系统中的单个数字。仪表数字可以上升或下降，但最后一个值会覆盖之前的值，因为它存储了系统的总体状态；例如，队列中的元素数量或系统中现有工作者的数量。'
- en: '**Measure**: Events that have a numeric value associated with them. These numbers
    can be averaged, summed, or aggregated in a certain way. Compared with gauges,
    the difference is that previous measures are still independent; for example, when
    we emit a metric with a request time in milliseconds and request size in bytes.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测量**：与它们相关联的具有数值的事件。这些数字可以以某种方式平均、求和或聚合。与仪表相比，区别在于之前的测量仍然是独立的；例如，当我们以毫秒为单位发出请求时间和以字节为单位的请求大小的事件时。'
- en: Measures can also work as counters, since each emitted event is, in essence,
    a counter. For example, tracking the request time will also count the number of
    requests, as it will be generated once per request. Tools will normally create
    the associated counter automatically for every measure.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测量值也可以作为计数器使用，因为每个发出的事件本质上就是一个计数器。例如，跟踪请求时间也会计算请求的数量，因为每个请求都会生成一次。工具通常为每个测量值自动创建相关的计数器。
- en: Defining which metric is adequate for the specific value to measure is important.
    In most cases, they'll be *measures*, to allow storing a value produced by events.
    *Counters* are normally evident (they are *measures* without values), while *gauges*
    are normally the ones that are less obvious and can present more of a challenge
    on when to use them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义哪个指标适合测量特定值非常重要。在大多数情况下，它们将是*测量值*，以便存储由事件产生的一个值。*计数器*通常是明显的（它们是没有值的*测量值*），而*仪表*通常是那些不那么明显且在使用时可能更具挑战性的指标。
- en: Metrics can also be derived from other metrics to generate new ones. For example,
    we can divide the number of requests that return an error code by the total number
    of requests to produce an error percentage. Such derived metrics can help you
    understand information in a meaningful way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 指标也可以从其他指标中派生出来以生成新的指标。例如，我们可以通过将返回错误代码的请求数量除以总请求数量来生成错误百分比。这样的派生指标可以帮助你以有意义的方式理解信息。
- en: 'There are also two kinds of metric systems, depending on how the metrics are
    produced:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 根据指标的产生方式，也存在两种类型的指标系统：
- en: Every time there's a metric produced, an event gets *pushed* toward the metrics
    collector
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次生成指标时，都会将一个事件 *推送* 到指标收集器。
- en: Each system maintains its own metrics internally, which are periodically *pulled*
    from the metrics collector
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个系统内部维护自己的指标，这些指标会定期从指标收集器中 *拉取*。
- en: Each system has its own pros and cons. Pushing events produces higher traffic
    and activity, as every individual event is sent immediately, which can cause bottlenecks
    and delays. Pulling events will only sample the information, and produce lower-resolution
    data, as it can miss what happened between samples, but it's more stable as the
    number of requests is not increasing with the number of events.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都有其自身的优缺点。推送事件会产生更高的流量和活动，因为每个单独的事件都会立即发送，这可能导致瓶颈和延迟。拉取事件将仅采样信息，并产生较低分辨率的
    数据，因为它可能会错过样本之间的发生事件，但它更稳定，因为请求数量不会随着事件数量的增加而增加。
- en: Both approaches are used, but the current trend is moving toward pulling systems.
    They reduce the amount of maintenance that is required for pushing systems and
    are easier to scale.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都被使用，但当前的趋势是向拉取系统转变。它们减少了推送系统所需的维护量，并且更容易扩展。
- en: We will use some examples with Prometheus, a metrics system that uses the pulling
    approach. The most used exponent of the push approach is Graphite.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Prometheus 的示例，这是一个使用拉取方法的指标系统。推送方法最常用的例子是 Graphite。
- en: Generating metrics with Prometheus
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Prometheus 生成指标
- en: Prometheus is a popular metrics system that is well supported and easy to use.
    We will use it as an example during the chapter to show how to collect metrics
    and how it interconnects with other tools to display metrics.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 是一个流行的指标系统，它得到了良好的支持并且易于使用。我们将在本章中使用它作为示例，展示如何收集指标以及它如何与其他工具交互以显示指标。
- en: As we saw before, Prometheus uses the *pulling* approach to metrics generation.
    That means that any system that produces metrics will run its own internal Prometheus
    client that keeps track of metrics.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，Prometheus 使用 *拉取* 方法来生成指标。这意味着任何产生指标的系统都会运行自己的内部 Prometheus 客户端，以跟踪指标。
- en: For web services, this can be added as an extra endpoint that serves the metrics.
    This is the approach taken by the `django-prometheus` module, which will automatically
    collect a lot of common metrics for a Django web service.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络服务，这可以作为一个额外的端点来提供指标。这是 `django-prometheus` 模块采取的方法，该模块将自动收集许多常见的指标，用于 Django
    网络服务。
- en: We will build up from the Django application code presented in *Chapter 6*,
    *Web Server Structures*, to present a working application. Check the code in GitHub
    at [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_13_metrics/microposts](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_13_metrics/microposts).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 *第 6 章*，*Web 服务器结构* 中展示的 Django 应用程序代码开始构建，以展示一个工作应用程序。请检查 GitHub 上的代码
    [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_13_metrics/microposts](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_13_metrics/microposts)。
- en: Preparing the environment
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备环境
- en: We need to set up the environment to be sure to install all the required packages
    and dependencies of the code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置环境以确保安装代码所需的所有包和依赖项。
- en: 'Let''s start by creating a new virtual environment, as introduced in *Chapter
    11*, *Package Management*, to be sure to create our own isolated sandbox to install
    packages:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的虚拟环境开始，如 *第 11 章*，*包管理* 中介绍的那样，以确保创建我们自己的隔离沙盒来安装包：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now install the prepared list of requirements, stored in `requirements.txt`.
    This contains the Django and Django REST framework modules, as seen in *Chapter
    6*, *Web Server Structures*, but also the Prometheus dependency:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以安装存储在 `requirements.txt` 中的准备好的需求列表。这包括在 *第 6 章*，*Web 服务器结构* 中看到的 Django
    和 Django REST 框架模块，以及 Prometheus 依赖项：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To start the server, go to the `micropost` subdirectory and run the `runserver`
    command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务器，请转到 `micropost` 子目录并运行 `runserver` 命令：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The application is now accessible in the root address: `http://localhost:8000`,
    for example, `http://localhost:8000/api/users/jaime/collection`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在可通过根地址访问：`http://localhost:8000`，例如，`http://localhost:8000/api/users/jaime/collection`。
- en: Note that we started the server at address 0.0.0.0\. This opens Django to serve
    any IP address, and not only requests coming from `localhost`. This is an important
    detail that will be clarified later.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们是在地址 0.0.0.0 上启动服务器的。这使 Django 能够服务任何 IP 地址，而不仅仅是来自 `localhost` 的请求。这是一个重要的细节，稍后会进行说明。
- en: Note also that the root address will return a 404 error, as no endpoint is defined
    there.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，根地址将返回 404 错误，因为没有在那里定义端点。
- en: If you remember from *Chapter 3*, *Data Modeling*, we added some initial data,
    so you can access the URLs `http://localhost:8000/api/users/jaime/collection`
    and `http://localhost:8000/api/users/dana/collection` to see some data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得 *第 3 章*，*数据建模*，我们添加了一些初始数据，因此您可以访问 URL `http://localhost:8000/api/users/jaime/collection`
    和 `http://localhost:8000/api/users/dana/collection` 来查看一些数据。
- en: '![Graphical user interface, application'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序'
- en: Description automatically generated](img/B17580_13_1.png)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_13_1.png)
- en: 'Figure 13.1: Accessing an available URL in the application'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：访问应用程序中的可用 URL
- en: Access these pages a couple of times to produce metrics that we can later access.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 访问这些页面几次以生成我们可以稍后访问的指标。
- en: Configuring Django Prometheus
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Django Prometheus
- en: The configuration of the `django-prometheus` module is done in the `microposts/settings.py`
    file, where we need to do two things.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-prometheus` 模块的配置在 `microposts/settings.py` 文件中完成，我们需要做两件事。'
- en: 'First, add the `django-prometheus` application to the installed app list which
    enables the module:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `django-prometheus` 应用程序添加到已安装的应用程序列表中，这将启用该模块：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also need to include the proper middlewares to track requests. We need to
    put one middleware at the start of the request process and another at the end,
    to be sure to capture and measure the whole process:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要包含适当的中间件来跟踪请求。我们需要在请求处理过程的开始和结束时放置一个中间件，以确保能够捕获和测量整个过程：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Check the position of `django.prometheus.middleware.PrometheusBeforeMiddleware`
    and `django_prometheus.middleware.PrometheusAfterMiddleware`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `django.prometheus.middleware.PrometheusBeforeMiddleware` 和 `django_prometheus.middleware.PrometheusAfterMiddleware`
    的位置。
- en: We also changed the `ALLOWED_HOSTS` value to be `'*'` and allow requests from
    any hostname. This detail will be explained a bit later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 `ALLOWED_HOSTS` 的值更改为 `'*'` 并允许来自任何主机名的请求。这个细节稍后会解释。
- en: With this configuration, the Prometheus collection is now enabled. But we also
    need a way to access them. Remember, an important element for the Prometheus system
    is that each application serves its own metric collection.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，Prometheus 收集现在已启用。但我们还需要一种访问它们的方法。记住，Prometheus 系统的一个重要元素是每个应用程序都为其自己的指标收集提供服务。
- en: 'In this case, we can add an endpoint to the file `microposts/url.py`, which
    handles the top-level URLs for the system:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以在 `microposts/url.py` 文件中添加一个端点，该文件处理系统的顶级 URL：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `path('', include('django_prometheus.urls'))` line sets up a `/metrics`
    URL that we can now access.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`path('''', include(''django_prometheus.urls''))` 这一行设置了一个 `/metrics` URL，我们现在可以访问它。'
- en: Checking the metrics
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查指标
- en: 'The main URL root shows that there''s a new endpoint – `/metrics`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 主要 URL 根显示了一个新的端点 - `/metrics`：
- en: '![Graphical user interface, text, application'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，文本，应用程序'
- en: Description automatically generated](img/B17580_13_02.png)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_13_02.png)
- en: 'Figure 13.2: This page appears because the DEBUG mode is active. Remember to
    deactivate it before deploying in production'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：此页面出现是因为 DEBUG 模式处于活动状态。记住在部署到生产环境之前将其停用
- en: When accessing the `/metrics` endpoint, it shows all the collected metrics.
    Note that there are a lot of metrics that are collected. This is all in text format,
    and it's expected to be collected by a Prometheus metric server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问 `/metrics` 端点时，它显示了所有收集的指标。请注意，收集了大量的指标。这些都是文本格式，并且预期将由 Prometheus 指标服务器收集。
- en: Be sure to access a few times the endpoints `http://localhost:8000/api/users/jaime/collection`
    and `http://localhost:8000/api/users/dana/collection` to produce some metrics.
    You can check how some metrics, like `django_http_requests_total_by_view_transport_method_total{method="GET",transport="http",view="user-collection"}`,
    are increasing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要多次访问端点 `http://localhost:8000/api/users/jaime/collection` 和 `http://localhost:8000/api/users/dana/collection`
    以生成一些指标。您可以检查一些指标，如 `django_http_requests_total_by_view_transport_method_total{method="GET",transport="http",view="user-collection"}`，是如何增加的。
- en: '![Graphical user interface, text'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，文本'
- en: Description automatically generated](img/B17580_13_3.png)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_13_3.png)
- en: 'Figure 13.3: The raw Prometheus metrics, as collected by the application'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：由应用程序收集的原始 Prometheus 指标
- en: The next step is to start a Prometheus server that can pull the info and display
    it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是启动一个 Prometheus 服务器，它可以拉取信息并显示。
- en: Starting a Prometheus server
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 Prometheus 服务器
- en: The Prometheus server will pull periodically for metrics to all the configured
    applications that are collecting their metrics. These elements are called *targets*
    by Prometheus.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 服务器将定期从所有配置的应用程序中拉取指标，这些应用程序正在收集它们的指标。Prometheus 将这些元素称为 *目标*。
- en: The easiest way to start a Prometheus server is to start the official Docker
    image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Prometheus 服务器最简单的方法是启动官方 Docker 镜像。
- en: We introduced Docker in *Chapter 9*, *Microservices vs Monolith*. Refer to that
    chapter for more information.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第 9 章*，*微服务与单体* 中介绍了 Docker。请参阅该章节以获取更多信息。
- en: 'We need to start the server, but before that, we need to set up the configuration
    in the `prometheus.yml` file. You can check the example on GitHub: [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_13_metrics/prometheus.yml](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_13_metrics/prometheus.yml):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要启动服务器，但在那之前，我们需要在 `prometheus.yml` 文件中设置配置。你可以在 GitHub 上查看示例：[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_13_metrics/prometheus.yml](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_13_metrics/prometheus.yml)：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The config file has two main sections. The first with `global` indicates how
    often to scrape (to read information from the targets) and other general configuration
    values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件有两个主要部分。第一个部分是 `global`，它指示多久抓取一次（从目标读取信息）和其他一般配置值。
- en: The second, `scrape_config`, describes what to scrape from, and the main parameter
    is `targets`. Here, we need to configure all our targets. This one in particular
    needs to be described by its external IP, which will be the IP from your computer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，`scrape_config`，描述了要从哪里抓取，主要参数是 `targets`。在这里，我们需要配置所有我们的目标。特别是这个目标需要通过其外部
    IP 地址来描述，这将是从你的电脑来的 IP 地址。
- en: This address cannot be `localhost`, as inside the Prometheus Docker container
    it will resolve as the same container, which is not what you want. You'll need
    to find out your local IP address.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个地址不能是 `localhost`，因为在 Prometheus Docker 容器内部，它将解析为相同的容器，这并不是你想要的。你需要找出你自己的本地
    IP 地址。
- en: 'If you don''t know how to find it through ipconfig or ifconfig, you can check
    out this article on ways to find it: [https://lifehacker.com/how-to-find-your-local-and-external-ip-address-5833108](https://lifehacker.com/how-to-find-your-local-and-external-ip-address-5833108).
    Remember that it''s your **local address**, not the external one.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道如何通过 ipconfig 或 ifconfig 来查找它，你可以查看这篇文章了解查找方法：[https://lifehacker.com/how-to-find-your-local-and-external-ip-address-5833108](https://lifehacker.com/how-to-find-your-local-and-external-ip-address-5833108)。请记住，这是你的
    **本地地址**，而不是外部地址。
- en: This is to ensure that the Prometheus server can access the Django application
    that's running locally. As you remember, we opened the access allowing connections
    from any hostname with the option `0.0.0.0` when starting the server and allowing
    all hosts in the config parameter `ALLOWED_HOSTS`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了确保 Prometheus 服务器可以访问运行在本地的 Django 应用程序。正如你所记得的，我们在启动服务器时通过选项 `0.0.0.0`
    允许任何主机名进行连接，并在配置参数 `ALLOWED_HOSTS` 中允许所有主机。
- en: Double-check that you can access the metrics in the local IP.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保你可以通过本地 IP 访问指标。
- en: '![Text'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![文本'
- en: Description automatically generated with low confidence](img/B17580_13_4.png)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的低置信度描述](img/B17580_13_4.png)
- en: 'Figure 13.4: Note the IP used to access; remember that you should use your
    own local one'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：注意用于访问的 IP 地址；请记住你应该使用你自己的本地 IP 地址
- en: With all this information, you are now ready to start the Prometheus server
    in Docker, using your own config file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些信息的基础上，你现在可以准备在 Docker 中启动 Prometheus 服务器，使用你自己的配置文件。
- en: Please note that this command requires you to find the full path to the `prometheus.yml`
    file. If you are in the same directory, you can address it as `$(pwd)/prometheus.yml`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个命令要求你找到 `prometheus.yml` 文件的完整路径。如果你在同一目录下，你可以将其表示为 `$(pwd)/prometheus.yml`。
- en: 'For this, run the following `docker` command, adding the whole path to the
    config file to share it with the new container:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，运行以下 `docker` 命令，添加配置文件的完整路径以与新的容器共享：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `docker` command is structured in the following way:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker` 命令的结构如下：'
- en: '`-p 9090:9090` maps the local 9090 port to the 9090 port inside the container'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p 9090:9090` 将本地 9090 端口映射到容器内的 9090 端口'
- en: '`-v /full/path/to/file/prometheus.yml:/etc/prometheus/prometheus.yml` mounts
    the local file (remember to add the full path or use `$(pwd)/prometheus.yml`)
    in the expected configuration route for Prometheus'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v /full/path/to/file/prometheus.yml:/etc/prometheus/prometheus.yml` 将本地文件（请记住添加完整路径或使用
    `$(pwd)/prometheus.yml`）挂载到 Prometheus 预期的配置路径'
- en: '`docker run prom/Prometheus` is the command to run the `prom/Prometheus` image,
    which is the official Prometheus image'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run prom/Prometheus` 是运行 `prom/Prometheus` 镜像的命令，这是官方的 Prometheus 镜像'
- en: After the Prometheus server is up and running, the server is accessible at `http://localhost:9090`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Prometheus 服务器启动并运行后，服务器可通过 `http://localhost:9090` 访问。
- en: '![A picture containing text, screenshot, monitor, screen'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![包含文本的图片，截图，显示器，屏幕'
- en: Description automatically generated](img/B17580_13_5.png)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_13_5.png)
- en: 'Figure 13.5: The empty graph Prometheus page'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：Prometheus 空图页面
- en: From here, we can start querying the system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以开始查询系统。
- en: Querying Prometheus
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询 Prometheus
- en: Prometheus has its own query system, called PromQL, and ways of operating with
    metrics that, while powerful, can be a little confusing at the beginning. Part
    of it is its pull approach to metrics.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 有自己的查询系统，称为 PromQL，以及操作指标的方式，虽然功能强大，但一开始可能会有些令人困惑。其中一部分是其对指标的拉取方法。
- en: For example, requesting one useful metric, like `django_http_requests_latency_seconds_by_view_method_count`,
    will display how many times each view has been called for each method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，请求一个有用的指标，如 `django_http_requests_latency_seconds_by_view_method_count`，将显示每个方法被每个视图调用的次数。
- en: '![Graphical user interface, application, table, Excel'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序，表格，Excel'
- en: Description automatically generated](img/B17580_13_6.png)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_13_6.png)
- en: 'Figure 13.6: Notice how the prometheus-django-metrics view is called more often,
    as it is called automatically by Prometheus once every 15 seconds to scrape the
    results'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6：注意 prometheus-django-metrics 视图被调用得更频繁，因为它被 Prometheus 每 15 秒自动调用一次以抓取结果
- en: This is presented as an accumulated value that grows over time. This is not
    very useful, as it's difficult to make sense of what exactly it means.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这以累积值的形式呈现，随着时间的推移而增长。这并不很有用，因为很难理解它确切的意义。
- en: 'Instead, the value is more likely to be presented as a `rate`, representing
    how many requests have been detected per second. For example, with a resolution
    of 1 minute, `rate(django_http_requests_latency_seconds_by_view_method_count[1m])`
    shows the following graph instead:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，值更有可能以 `rate` 的形式呈现，表示每秒检测到的请求数量。例如，以 1 分钟的分辨率，`rate(django_http_requests_latency_seconds_by_view_method_count[1m])`
    会显示以下图表：
- en: '![Graphical user interface, application, table'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序，表格'
- en: Description automatically generated](img/B17580_13_7.png)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_13_7.png)
- en: 'Figure 13.7: Note that the different methods and views are displayed as different
    lines'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7：注意不同的方法和视图以不同的线条显示
- en: As you can see, there's a constant number of requests from `prometheus-django-metrics`,
    which is Prometheus requesting the metrics information. This happens once every
    15 seconds, or approximately 0.066 times per second.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，从 `prometheus-django-metrics` 来的请求数量是恒定的，这是 Prometheus 请求指标信息。这每 15 秒发生一次，或大约每秒
    0.066 次。
- en: In the graph, there's also another spike of the `user-collection` method happening
    at 15:55, at the time where we manually generated some requests to the service.
    As you can see, the resolution is per minute, as described in the rate.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中，还有 `user-collection` 方法在 15:55 发生的另一个峰值，这是我们手动生成对服务请求的时间。如您所见，分辨率是每分钟，正如速率所描述的。
- en: 'If we want to aggregate all of this in a single graph, we can use the sum operator,
    specifying what we want to aggregate from. To sum all `GET` requests, for example,
    with:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将这些内容聚合到单个图中，我们可以使用求和运算符，指定我们要聚合的内容。例如，要计算所有 `GET` 请求，可以使用以下命令：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This produces this other graph:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生另一个图表：
- en: '![Graphical user interface, application, table, Excel'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序，表格，Excel'
- en: Description automatically generated](img/B17580_13_8.png)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_13_8.png)
- en: 'Figure 13.8: Note the bottom value is based on the baseline created by the
    calls to prometheus-django-metrics'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8：注意底部值是基于 prometheus-django-metrics 调用创建的基线
- en: To plot times instead, the metric to use is the `django_http_requests_latency_seconds_by_view_method_bucket`
    one. The bucket metrics are generated in a way that can be combined with the `histogram_quantile`
    function to display a particular quantile, which is useful for giving a proper
    feeling of times.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制时间而不是分位数，应使用`django_http_requests_latency_seconds_by_view_method_bucket`指标。桶指标以可以与`histogram_quantile`函数结合的方式生成，以显示特定的分位数，这对于给出适当的时间感觉非常有用。
- en: For example, quantile 0.95 means that the time is the highest of 95% of the
    requests. This is more useful than creating averages as they can get skewed by
    high numbers. Instead, you can draw the quantile 0.50 (the maximum time it takes
    for half of the requests), the quantile 0.90 (the maximum time for most of the
    requests), and quantile 0.99 for the very top time it takes to return a request.
    This allows you to get a better picture, as it's different from the situation
    of growing quantile 0.50 (most requests take longer to return) with growing quantile
    0.99 (some slow queries are getting worse).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，0.95分位数意味着时间是95%请求中的最高值。这比创建平均值更有用，因为它们可能会被高数值所扭曲。相反，你可以绘制0.50分位数（一半请求的最大时间），0.90分位数（大多数请求的最大时间），以及0.99分位数，用于返回请求所需的最长时间。这让你能获得更好的视图，因为它与增长中的0.50分位数（大多数请求返回时间更长）和增长中的0.99分位数（一些慢查询变得更糟）的情况不同。
- en: 'To plot the 0.95 quantile over a period of 5 minutes, the following query can
    be generated:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制5分钟内的0.95分位数，可以使用以下查询：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run it, you should receive the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你应该收到以下内容：
- en: '![Table'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![表格'
- en: Description automatically generated](img/B17580_13_9.png)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_13_9.png)
- en: 'Figure 13.9: Note how the metrics collection is much faster than the user-collection
    requests'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：注意指标收集的速度比用户收集请求的速度快得多
- en: To plot times instead, the metric to use is the `django_http_requests_latency_seconds_by_view_method_bucket`
    one. The bucket metrics are generated in a way that can be combined with the `histogram_quantile`
    function to display a particular quantile, which is useful for giving a proper
    feeling of times.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制时间而不是分位数，应使用`django_http_requests_latency_seconds_by_view_method_bucket`指标。桶指标以可以与`histogram_quantile`函数结合的方式生成，以显示特定的分位数，这对于给出适当的时间感觉非常有用。
- en: Metrics can also be filtered to display only specific labels, and a good number
    of functions to multiply, divide, add, create averages, and all kinds of operations
    are available.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 指标也可以被过滤以仅显示特定的标签，并且有许多乘法、除法、加法、创建平均值以及各种操作的功能。
- en: Prometheus queries can be a bit long and complicated when trying to display
    the result of several metrics, such as the percentage of successful requests over
    the total. Be sure to test that the result is what you expect it to be and allocate
    time to tweak the queries later to keep improving them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试显示多个指标的结果，例如成功请求占总请求的百分比时，Prometheus查询可能会变得相当长且复杂。请确保测试结果是否符合预期，并留出时间稍后调整查询以持续改进。
- en: The interface has autocompleted, which can help you find certain metrics.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 界面具有自动完成功能，可以帮助你找到特定的指标。
- en: 'Prometheus is normally paired with Grafana. Grafana is an open source, interactive
    visualization tool that can be connected with Prometheus to create rich dashboards.
    This leverages the collection of metrics and helps visualize the state of the
    system in a much more understandable way. Describing how to use Grafana is out
    of scope for this book, but using it to display metrics is highly recommended:
    [https://grafana.com/](https://grafana.com/).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus通常与Grafana搭配使用。Grafana是一个开源的交互式可视化工具，可以与Prometheus连接以创建丰富的仪表板。这利用了指标收集，并有助于以更易于理解的方式可视化系统的状态。本书不涉及如何使用Grafana的描述，但强烈建议使用它来显示指标：[https://grafana.com/](https://grafana.com/).
- en: 'Check the Prometheus documentation about queries to find out more: [https://prometheus.io/docs/prometheus/latest/querying/basics/](https://prometheus.io/docs/prometheus/latest/querying/basics/).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Prometheus文档中的查询部分以获取更多信息：[https://prometheus.io/docs/prometheus/latest/querying/basics/](https://prometheus.io/docs/prometheus/latest/querying/basics/).
- en: Proactively working with metrics
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积极使用指标
- en: As we've seen, metrics show an aggregated point of view for the status of the
    whole cluster. They allow you to detect trending problems, but it's difficult
    to pinpoint a single spurious error.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，指标显示了整个集群状态的汇总视图。它们允许你检测趋势问题，但很难确定单个错误。
- en: This shouldn't stop us from considering them as a critical tool for successful
    monitoring because they can tell whether the whole system is healthy. In some
    companies, the most critical metrics are on permanent display on screens so the
    operations team can see them and react quickly to any sudden problem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该阻止我们将它们视为成功监控的关键工具，因为它们可以告诉我们整个系统是否健康。在一些公司中，最重要的指标会永久显示在屏幕上，以便运维团队能够看到它们，并快速对任何突发问题做出反应。
- en: Finding the proper balance of what metrics are the key ones for a service is
    not as straightforward as it seems, and it will require time and experience, perhaps
    even trial and error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 找到服务关键指标的正确平衡并不像看起来那么简单，这需要时间和经验，甚至可能需要试错。
- en: 'There are, though, four metrics for online services that are considered always
    important. They are:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于在线服务，有四个指标被认为是始终重要的。它们是：
- en: '**Latency**: How many milliseconds it takes for the system to respond to a
    request. Depending on the service, sometimes seconds can be used instead. In my
    experience, milliseconds are typically the adequate time scale, as most web applications
    take between 50 ms and 1 second to respond, depending on the request. Requests
    taking longer than 1 second are typically rarer, though there are always some,
    depending on the system.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：系统响应请求所需的毫秒数。根据服务不同，有时也可以使用秒。根据我的经验，毫秒通常是合适的时间尺度，因为大多数Web应用在50毫秒到1秒内响应，具体取决于请求。通常，超过1秒的请求较为罕见，尽管系统中总是有一些，这取决于系统本身。'
- en: '**Traffic**: The number of requests flowing through the system per unit of
    time, for example, the number of requests per minute.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量**：单位时间内通过系统的请求数量，例如，每分钟的请求数量。'
- en: '**Errors**: The percentage of requests received that return an error.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：收到并返回错误的请求数量百分比。'
- en: '**Saturation**: Describing whether the capacity of the cluster has enough headroom.
    This includes elements as available hard drive space, memory, and so on. For example,
    there''s 15% available RAM in the system.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**饱和度**：描述集群的容量是否有足够的余量。这包括可用硬盘空间、内存等元素。例如，系统中可用RAM为15%。'
- en: The main tool to check saturation is the multiple default exporters available
    to collect most of the hardware information automatically, like memory, CPU, and
    hard drive space. When using a cloud provider, normally they expose their own
    set of related metrics, like CloudWatch in AWS.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 检查饱和度的主要工具是可用的多个默认导出器，可以自动收集大多数硬件信息，如内存、CPU和硬盘空间。当使用云服务提供商时，通常他们会公开自己的相关指标集，例如AWS中的CloudWatch。
- en: These metrics can be found in the Google SRE book as *the four golden signals*
    and are recognized as the most important high-level elements for successful monitoring.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标可以在Google SRE书中找到，被称为*四个黄金信号*，并被认为是成功监控最重要的高级元素。
- en: Alerting
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警报
- en: When problems are detected through the metrics, an automatic alert should be
    triggered. Prometheus has an alert system that will raise when a defined metric
    fulfills the defined alert.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过指标检测到问题时，应触发自动警报。Prometheus有一个警报系统，当定义的指标满足定义的警报条件时，会触发警报。
- en: 'Check out the Prometheus documentation on alerting for more information: [https://prometheus.io/docs/alerting/latest/overview/](https://prometheus.io/docs/alerting/latest/overview/).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅Prometheus关于警报的文档以获取更多信息：[https://prometheus.io/docs/alerting/latest/overview/](https://prometheus.io/docs/alerting/latest/overview/)。
- en: Normally, alerts will be configured when the value of metrics is crossing some
    threshold. For example, the number of errors is higher than X, or the time to
    return a request is too high.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当指标值超过某个阈值时，会配置警报。例如，错误数量高于X，或者返回请求的时间太长。
- en: An alert could also be that some element is too low; for example, if the number
    of requests in a system falls to zero, that could be an indication that the system
    is down.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 警报也可能是一些元素太低；例如，如果系统中的请求数量降至零，这可能表明系统已关闭。
- en: The built-in Alertmanager can alert in some ways, like sending an email, but
    it can also be connected to other tools to perform more complex actions. For example,
    connecting to an integrated incident solution like Opsgenie ([https://www.atlassian.com/software/opsgenie](https://www.atlassian.com/software/opsgenie))
    allows you to create alert flows, such as sending emails and SMS, calls.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 Alertmanager 可以通过发送电子邮件等方式发出警报，但它也可以连接到其他工具以执行更复杂的行为。例如，连接到一个集成的故障解决方案，如
    Opsgenie ([https://www.atlassian.com/software/opsgenie](https://www.atlassian.com/software/opsgenie))，允许您创建警报流程，例如发送电子邮件和短信、电话。
- en: While alerts can be generated directly from metrics, there are tools that allow
    you also to generate alerts from logs directly. For example, Sentry ([https://sentry.io/](https://sentry.io/))
    will aggregate errors based on logs and can set up thresholds to escalate toward
    more active alerts, like sending emails.Another alternative is to derivate metrics
    from logs using external logging systems. This allows you, for example, to create
    a counter based on the number of `ERROR` logs, or more complicated metrics. These
    systems, once more, allow you to trigger alerts based on these derived metrics.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以直接从指标生成警报，但也有一些工具允许您直接从日志生成警报。例如，Sentry ([https://sentry.io/](https://sentry.io/))
    将根据日志汇总错误，并可以设置阈值以升级到更活跃的警报，如发送电子邮件。另一种选择是使用外部日志系统从日志中派生指标。这允许您，例如，根据 `ERROR`
    日志的数量创建一个计数器，或者更复杂的指标。这些系统再次允许您根据这些派生指标触发警报。
- en: Alerting, as with metrics, is an ongoing process. Some key thresholds won't
    be evident at the start of the system, and only experience will allow you to discover
    them. In the same way, it's very likely that some alerts are created that don't
    require active monitoring, and should be disconnected to ensure that the alerts
    in the system are on point and have a high signal-to-noise ratio.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 警报，与指标一样，是一个持续的过程。一些关键阈值在系统开始时可能不明显，只有经验才能让您发现它们。同样，很可能创建了一些不需要主动监控的警报，应该断开连接以确保系统中的警报准确且信号与噪声比高。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described what metrics are and how they compare with logs.
    We described how metrics are useful to analyze the general state of the system,
    while logs describe specific tasks, being more difficult to describe the aggregated
    situation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了指标是什么以及它们与日志的比较。我们描述了指标如何有助于分析系统的总体状态，而日志则描述具体任务，更难描述汇总情况。
- en: We enumerated different kinds of metrics that can be produced and described
    Prometheus, a common metrics system that uses the pull approach on how to capture
    metrics.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列举了可以生成和描述的指标类型，并介绍了 Prometheus，这是一个使用拉取方法捕获指标的通用指标系统。
- en: We set an example of how to generate metrics automatically in Django by installing
    and configuring the `django-prometheus` module, and how to start a Prometheus
    server that scrapes the generated metrics.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过安装和配置 `django-prometheus` 模块，以及如何启动一个抓取生成的指标的 Prometheus 服务器，设置了一个如何自动生成指标的
    Django 示例。
- en: 'Keep in mind that you can also generate your own custom metrics, not having
    to only rely on the ones in an external module. Check the Prometheus client to
    see how, for example, for Python: [https://github.com/prometheus/client_python](https://github.com/prometheus/client_python).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您还可以生成自己的自定义指标，而不仅仅依赖于外部模块中的那些。例如，查看 Prometheus 客户端了解如何操作，以 Python 为例：[https://github.com/prometheus/client_python](https://github.com/prometheus/client_python)。
- en: Next, we described how to query metrics in Prometheus, introducing PromQL, and
    showed some common examples of how to display metrics, plot `rate` to see clearly
    how the metrics are changing over time, and how to use the `histogram_quantile`
    function to work with times.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们描述了如何在 Prometheus 中查询指标，介绍了 PromQL，并展示了如何显示指标、绘制 `rate` 图以清楚地看到指标随时间的变化，以及如何使用
    `histogram_quantile` 函数处理时间。
- en: We also showed in the chapter how to work proactively to detect common problems
    as soon as possible and what the four golden signals are, as described by Google.
    Finally, we introduced alerts as a way to be notified when metrics are out of
    a normal margin. Using alerts is a smart way to be notified without having to
    manually look at metrics.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在本章中展示了如何积极工作以尽快检测常见问题，以及 Google 描述的四个黄金信号是什么。最后，我们介绍了警报作为一种在指标超出正常范围时通知的方式。使用警报是一种智能的通知方式，无需手动查看指标。
