- en: Chapter 2. Building a Paint App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：构建绘画应用程序
- en: 'In [Chapter 1](ch01.html "Chapter 1. Building a Clock App"), *Building a Clock
    App*, we built an application from Kivy''s standard components: layouts, text
    labels, and buttons. We were able to significantly customize the look of these
    components while retaining a very high level of abstraction—working with full-fledged
    widgets, as opposed to individual graphical primitives. This is convenient for
    certain types of applications but not always desirable, and as you will see shortly,
    the Kivy framework also provides tools to work with a lower level of abstraction:
    draw points and lines.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html "第一章：构建时钟应用程序")《构建时钟应用程序》中，我们使用 Kivy 的标准组件：布局、文本标签和按钮构建了一个应用程序。我们能够在保持非常高层次抽象的同时显著自定义这些组件的外观——使用完整的控件，而不是单个图形原语。这对于某些类型的应用程序来说很方便，但并不总是理想的，并且正如你很快就会看到的，Kivy
    框架还提供了用于较低层次抽象的工具：绘制点和线。
- en: I believe that the best way to play with free-form graphics is by building a
    painting app. Our application, when complete, will be somewhat similar to the
    MS Paint application that comes bundled with the Windows OS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，通过构建绘画应用程序来玩自由形式的图形是最好的方式。我们的应用程序完成时，将与 Windows 操作系统捆绑的 MS Paint 应用程序有些相似。
- en: Unlike Microsoft Paint, our Kivy Paint app will be fully cross-platform, including
    mobile devices running Android and iOS. Also, we will deliberately omit many features
    found in "real" software for image processing, such as rectangular selection,
    layers, and saving files to disk. Implementing them can be a good exercise for
    you.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Microsoft Paint 不同，我们的 Kivy Paint 应用程序将完全跨平台，包括运行 Android 和 iOS 的移动设备。此外，我们还将故意省略“真实”软件中常见的许多图像处理功能，例如矩形选择、图层和将文件保存到磁盘。实现它们可以成为你的一项良好练习。
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Regarding mobile devices: while building a fully functional iOS application
    with Kivy is of course possible, it''s still non-trivial if you have no experience
    with either iOS or Kivy development. Therefore, it''s recommended that you write
    for easy platforms first so that you can quickly update your code and run the
    application without building binaries and such. In this sense, Android development
    is much simpler, thanks to Kivy Launcher, a generic environment to run Kivy apps
    on Android. It is available on Google Play at [https://play.google.com/store/apps/details?id=org.kivy.pygame](https://play.google.com/store/apps/details?id=org.kivy.pygame).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于移动设备：虽然使用 Kivy 构建 iOS 应用程序当然可能，但如果你没有 iOS 或 Kivy 开发的经验，这仍然是非平凡的。因此，建议你首先为易于使用的平台编写代码，这样你可以快速更新你的代码并运行应用程序，而无需构建二进制文件等。在这方面，由于
    Kivy Launcher，Android 开发要简单得多，它是一个通用的环境，可以在 Android 上运行 Kivy 应用程序。它可在 Google Play
    上找到，网址为 [https://play.google.com/store/apps/details?id=org.kivy.pygame](https://play.google.com/store/apps/details?id=org.kivy.pygame)。
- en: The ability to immediately launch and test your app without compiling is an
    incredibly important aspect of Kivy development. This allows programmers to iterate
    quickly and evaluate possible solutions on the spot, which is crucial for **rapid
    application development** (**RAD**) and the agile methodology as a whole.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 能够立即启动和测试你的应用程序而不需要编译，这是 Kivy 开发中一个极其重要的方面。这使得程序员能够快速迭代并现场评估可能的解决方案，这对于**快速应用开发**（RAD）和整体敏捷方法至关重要。
- en: With the notable exception of window resizing, which isn't widely used on mobiles,
    Kivy apps behave in a similar way on various mobile and desktop platforms. So
    it's perfectly feasible to write and debug just the desktop or Android version
    of the program until much later in the release cycle and then fill the compatibility
    gaps, if any.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了窗口大小调整（这在移动设备上不太常用）之外，Kivy 应用程序在各种移动和桌面平台上表现相似。因此，在发布周期后期之前，完全有可能只编写和调试桌面或
    Android 版本的程序，然后填补任何兼容性差距。
- en: 'We will also explore two distinctive, almost mutually exclusive features available
    to Kivy apps: multitouch controls, useful on devices with a touch screen, and
    changing mouse pointers on a desktop computer.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨 Kivy 应用程序提供的两个独特且几乎相互排斥的功能：多指控制，适用于触摸屏设备，以及在桌面计算机上更改鼠标指针。
- en: Staying true to its mobile-first approach, Kivy provides an emulation layer
    for multitouch input, usable with the mouse. It can be triggered with a right-click.
    This multitouch emulation isn't, however, suitable for any real-world usage, except
    for debugging; it will be turned off in the production version of the application
    when running on a desktop.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持其以移动端为先的方法，Kivy提供了一个多触控输入的模拟层，可以用鼠标使用。它可以通过右键点击触发。然而，这种多触控模拟并不适合任何实际应用，除了调试；当在桌面运行时，它将在应用的生成版本中被关闭。
- en: 'This is what our application will look like at the end of the chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章结束时我们的应用将看起来像这样：
- en: '![Building a Paint App](img/B01620_02_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![构建绘画应用](img/B01620_02_01.jpg)'
- en: The Kivy Paint app, bad painting sold separately
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy绘画应用，绘画工具另行销售
- en: Setting the stage
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置舞台
- en: Initially, the entire surface of our app is occupied by the **root widget**,
    in this case, that's the canvas the user can paint upon. We won't devote any screen
    space to the instruments' area until later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们应用的全部表面都被**根小部件**占据，在这种情况下，那就是用户可以绘画的画布。我们不会在稍后为工具区域分配任何屏幕空间。
- en: As you probably know by now, the root widget is the outermost widget in the
    hierarchy. Every Kivy application has one, and it can be pretty much anything,
    depending on the desired behavior. As seen in [Chapter 1](ch01.html "Chapter 1. Building
    a Clock App"), *Building a Clock App*, `BoxLayout` is a suitable root widget;
    it was sufficient as we had no additional requirements for it, and layouts are
    designed to work as containers for other controls.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，根小部件是层次结构中最外层的小部件。每个Kivy应用都有一个，它可以基本上是任何东西，取决于期望的行为。如[第1章](ch01.html "第1章。构建时钟应用")中所示，*构建时钟应用*，`BoxLayout`是一个合适的选择作为根小部件；由于我们没有对它有额外的要求，布局被设计成作为其他控制容器的功能。
- en: In the case of a Paint app, we need its root widget to adhere to much more interesting
    requirements; the user should be able to draw lines, possibly utilizing multitouch
    functionality, if available. At the moment, Kivy has no built-in controls suitable
    for the task at hand, so we will need to create our own.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘画应用的情况下，我们需要其根小部件满足更多有趣的要求；用户应该能够画线，可能利用多触控功能，如果可用。目前，Kivy没有内置的控制适合这项任务，因此我们需要自己创建。
- en: 'Building new Kivy widgets is simple. As soon as our class inherits from Kivy''s
    `Widget` class, we''re good to go. So the simplest custom widget that does nothing
    special, together with the Kivy application that uses it, can be implemented like
    this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 构建新的Kivy小部件很简单。一旦我们的类从Kivy的`Widget`类继承，我们就可以开始了。所以，最简单的没有特殊功能的自定义小部件，以及使用它的小程序，可以像这样实现：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the full listing of our Paint app's starting point, `main.py`, complete
    with the `PaintApp` class. In future chapters, we will omit simple boilerplate
    like this; this one is provided for the sake of completeness.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的绘画应用起始点的完整列表，`main.py`，包括`PaintApp`类。在未来的章节中，我们将省略像这样的简单样板代码；这个例子提供是为了完整性。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `Widget` class usually serves as a base class, like `object` in Python or
    `Object` Java. While it's possible to use it "as is" in the application, `Widget`
    itself is of very limited utility. It has no visual appearance and no properties
    that would be immediately useful in the program. Subclassing `Widget`, on the
    other hand, is pretty straightforward and useful in many different scenarios.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Widget`类通常作为基类，就像Python中的`object`或Java中的`Object`。虽然可以在应用中使用它“原样”，但`Widget`本身非常有限。它没有视觉外观，也没有在程序中立即有用的属性。另一方面，继承`Widget`相当直接且在许多不同场景中很有用。'
- en: Fine-tuning the looks
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整外观
- en: First, let's tweak the appearance of our app. This isn't exactly a critical
    functionality, but bear with me here, as these customizations are commonly requested
    and also pretty easy to set up. I'll briefly describe the properties that we covered
    in the previous chapter, and we'll add a number of new tweaks, such as window
    size and change of the mouse cursor.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们调整我们应用的外观。这并不是一个关键的功能，但请耐心，因为这些定制通常被请求，而且设置起来也很容易。我将简要描述我们在上一章中覆盖的属性，并添加一些新的调整，例如窗口大小和鼠标光标的更改。
- en: Visual appearance
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉外观
- en: 'I strongly believe that the background color of any Paint app should initially
    be white. You''re probably already familiar with this setting from the first chapter.
    Here''s the line of code we add after the `__name__ == ''__main__''` line to achieve
    the desired effect:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我坚信，任何绘图应用程序的背景颜色最初应该是白色的。你可能已经从第一章中熟悉了这个设置。以下是我们在`__name__ == '__main__'`行之后添加的代码行，以实现所需的效果：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may want to put most of the `import` lines where they usually belong, near
    the beginning of a program file. As you will learn shortly, some imports in Kivy
    are actually order-dependent and have side effects, most notably the `Window`
    object. This is rarely the case in well-behaved Python programs, and the side
    effects of the import statement are generally considered bad application design.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望将大多数`import`行放在它们通常所在的位置，即在程序文件的开始附近。正如你很快就会学到的，Kivy中的某些导入实际上是顺序相关的，并且有副作用，最值得注意的是`Window`对象。在行为良好的Python程序中很少出现这种情况，导入语句的副作用通常被认为是不良的应用程序设计。
- en: Window size
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口大小
- en: Another commonly tweaked property of a desktop application is window size. The
    following changes will have absolutely no effect on mobile devices.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序的另一个常见调整属性是窗口大小。以下更改对移动设备将完全没有影响。
- en: It's also worth noting that by default, Kivy's window on a desktop can be resized
    by the end user. We will learn how to disable that shortly (only for the sake
    of completeness; usually, that's not such a great idea).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，默认情况下，桌面上的Kivy窗口可以被最终用户调整大小。我们将在稍后学习如何禁用此功能（仅为了完整性；通常这不是一个好主意）。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Setting the window size programmatically is also a handy thing to do when you're
    targeting a mobile device whose specifications are known in advance. This allows
    you to test the application on a desktop using the correct screen resolution of
    the target device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你针对已知规格的移动设备时，以编程方式设置窗口大小也是一个方便的做法。这允许你使用目标设备的正确屏幕分辨率在桌面上测试应用程序。
- en: 'To assign the initial window size, insert the next code snippet right above
    the line that reads `from kivy.core.window import Window`. It''s critical to apply
    these settings before the `Window` object is even imported; otherwise, they won''t
    have any effect:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配初始窗口大小，将下一代码片段插入到读取`from kivy.core.window import Window`的行之上。在`Window`对象导入之前应用这些设置至关重要；否则，它们将没有任何效果：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In addition, you may want to disable window resizing by adding this one line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能还想通过添加以下一行来禁用窗口调整大小：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Please don't do this unless you have a very good reason, since taking these
    trivial customizations away from the user is usually a bad idea and can easily
    ruin the overall user experience. Building a pixel-perfect app in just one resolution
    is tempting, but many of your customers (especially mobile users) won't be happy.
    Kivy layouts, on the other hand, make building scalable interfaces bearable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请除非你有非常充分的理由，否则不要这样做，因为从用户那里移除这些微不足道的定制通常是一个坏主意，并且很容易破坏整体用户体验。仅在一个分辨率下构建像素完美的应用程序很有吸引力，但许多客户（尤其是移动用户）可能不会满意。另一方面，Kivy布局使得构建可伸缩界面变得可行。
- en: Mouse cursor
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标光标
- en: The next customization that generally applies only to desktop apps is changing
    the mouse pointer. Kivy has no abstraction for this, so we will work at a lower
    level, importing and calling methods directly from Pygame, the SDL-based window
    and OpenGL context provider, which is commonly used by Kivy on desktop platforms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个通常仅适用于桌面应用程序的定制选项是更改鼠标指针。Kivy没有对此进行抽象，因此我们将在一个较低级别上工作，直接从Pygame导入和调用方法，Pygame是基于SDL的窗口和OpenGL上下文提供者，通常在桌面平台上被Kivy使用。
- en: This code, if you choose to implement it, should always be run conditionally.
    Most mobile and some desktop apps won't have a Pygame window, and we surely want
    to avoid crashing the program over a trivial and non-essential matter like the
    mouse cursor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择实现此代码，应始终有条件地运行。大多数移动设备和一些桌面应用程序不会有Pygame窗口，我们当然希望避免因为鼠标光标这样的琐碎且非必要的事情而导致程序崩溃。
- en: 'Long story short, this is the mouse pointer format that''s used by Pygame:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是Pygame使用的鼠标指针格式：
- en: '![Mouse cursor](img/B01620_02_11.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![鼠标光标](img/B01620_02_11.jpg)'
- en: The ASCII format used to describe a custom mouse pointer
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 用于描述自定义鼠标指针的ASCII格式
- en: 'Every character in this notation stands for one pixel: `''@''` is black and
    `''-''` is white; everything else is transparent. All lines have to be of equal
    width, divisible by eight (a restriction imposed by the underlying SDL implementation).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此记法中的每个字符代表一个像素：`'@'` 是黑色，`'-'` 是白色；其余的都是透明的。所有行都必须具有相同的宽度，且能被八整除（这是底层 SDL 实现强加的限制）。
- en: 'When used in an application, it should look as depicted in the next screenshot
    (the image is significantly zoomed in, obviously):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当在应用程序中使用时，它应该看起来像下一张截图所示（图像被显著放大，显然）：
- en: '![Mouse cursor](img/B01620_02_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![鼠标光标](img/B01620_02_02.jpg)'
- en: 'Mouse cursor for the Kivy Paint app: a crosshair'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy Paint 应用程序的鼠标光标：一个十字准星
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a caveat though. At the time of writing this, the version of Pygame
    that's commonly available in some operating systems has a bug in the `pygame.cursors.compile()`
    function that switches between white and black. Detecting the affected versions
    of Pygame is impractical, so we'll just include the correctly working function
    in our code and won't call the potentially buggy version of the same function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在撰写本文时，某些操作系统普遍可用的 Pygame 版本在 `pygame.cursors.compile()` 函数中存在一个在白色和黑色之间切换的漏洞。检测受影响的
    Pygame 版本是不切实际的，所以我们将在代码中包含正确工作的函数，而不会调用可能存在漏洞的同名函数版本。
- en: The correct function, `pygame_compile_cursor()`, that translates the Pygame's
    mouse cursor definition into something expected by **Simple DirectMedia Layer**
    (**SDL**), Pygame's backend library, is available online at [http://goo.gl/2KaepD](http://goo.gl/2KaepD).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的函数 `pygame_compile_cursor()`，它将 Pygame 的鼠标光标定义转换为 **Simple DirectMedia Layer**（**SDL**）所期望的，Pygame
    的后端库，可在网上找到：[http://goo.gl/2KaepD](http://goo.gl/2KaepD)。
- en: 'Now, to actually apply the resulting cursor to the application window, we''ll
    replace our `PaintApp.build` method with the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将生成的光标实际应用到应用程序窗口中，我们将用以下代码替换 `PaintApp.build` 方法：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code is pretty straightforward, but some aspects of it may need explanation.
    Here is a quick walk-through:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当直接，但其中的一些方面可能需要解释。以下是一个快速浏览：
- en: '`EventLoop.ensure_window()`: This function call blocks the execution until
    we have the application window (`EventLoop.window`) ready.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventLoop.ensure_window()`：此函数调用会阻塞执行，直到我们有了应用程序窗口（`EventLoop.window`）。'
- en: '`if EventLoop.window.__class__.__name__.endswith(''Pygame'')`: This condition
    checks the window class name (not the greatest way to make assertions about the
    code, but works in this case). We want to run our mouse cursor customization code
    only for a certain window provider, in this case, Pygame.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if EventLoop.window.__class__.__name__.endswith(''Pygame'')`：此条件检查窗口类名（不是对代码进行断言的最佳方式，但在这个情况下有效）。我们只想为特定的窗口提供者运行我们的鼠标光标定制代码，在这种情况下，是
    Pygame。'
- en: The remaining part of the code, enclosed in a `try ... except` block, is a Pygame-specific
    `mouse.set_cursor` call.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的剩余部分，包含在 `try ... except` 块中，是 Pygame 特定的 `mouse.set_cursor` 调用。
- en: Variables `a` and `b` constitute the internal representation of the cursor used
    by SDL, namely the XOR and AND mask. They are binary and should be considered
    an opaque implementation detail of the SDL.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `a` 和 `b` 构成了 SDL 使用的鼠标内部表示，即 XOR 和 AND 掩码。它们是二进制的，应被视为 SDL 的一个不透明的实现细节。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As usual, please refer to the official reference manual for the full API specification.
    Pygame documentation can be found at [http://www.pygame.org](http://www.pygame.org).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，请参阅官方参考手册以获取完整的 API 规范。Pygame 文档可在 [http://www.pygame.org](http://www.pygame.org)
    找到。
- en: This entire situation when we're working at a level of abstraction much lower
    than Kivy's isn't very common, but by all means, don't be afraid to dive into
    implementation details sometimes. There are many things that can be achieved only
    in the underlying library because Kivy does not provide meaningful abstractions
    for them. This especially applies to non-cross-platform functionality, such as
    OS-dependent app interoperability, notification services, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在比 Kivy 更低的抽象级别工作时，这种整个情况并不常见，但无论如何，不要害怕有时深入研究实现细节。因为 Kivy 不提供对这些事物的有意义的抽象，所以可以实现许多只有底层库才能实现的事情。这尤其适用于非跨平台功能，如操作系统依赖的应用程序互操作性、通知服务等等。
- en: 'To reiterate, this diagram summarizes the abstraction levels we traverse in
    this specific case to set the mouse pointer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此图总结了在此特定情况下设置鼠标指针时我们遍历的抽象级别：
- en: '![Mouse cursor](img/B01620_02_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![鼠标光标](img/B01620_02_03.jpg)'
- en: The relationship of Kivy, Pygame, SDL, and the underlying operating system abstractions
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy、Pygame、SDL和底层操作系统抽象之间的关系
- en: Thankfully, we didn't have to work directly with the operating system—cross-platform
    functionality can be surprisingly hard to get right. This is exactly what SDL
    does.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必直接与操作系统交互——跨平台功能可能很难正确实现。这正是SDL所做的事情。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While we don't work with the SDL directly, you might still want to take a look
    at the documentation found at [https://www.libsdl.org/](https://www.libsdl.org/)—this
    will give you a perspective on the underlying low-level API calls that Kivy ultimately
    relies on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不直接与SDL交互，但你可能仍然想查看位于[https://www.libsdl.org/](https://www.libsdl.org/)的文档——这将为你提供关于Kivy最终依赖的低级API调用的视角。
- en: Multitouch emulation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多指模拟
- en: By default, Kivy provides an emulation mode for multitouch operations when running
    on a desktop system. It is activated with a right-click and spawns permanent touches
    rendered as semi-transparent red dots; they can also be dragged while holding
    the right mouse button.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当在桌面系统上运行时，Kivy为多指操作提供了一种模拟模式。它通过右键点击激活，并生成永久触摸，以半透明的红色点形式渲染；同时也可以在按住右鼠标按钮的情况下拖动。
- en: 'This feature may be nice for debugging, especially when you don''t have a real
    multitouch device to test on; users, on the other hand, won''t be expecting this
    functionality bound to the right click. It''s probably a good idea to disable
    it so that our users don''t get confused by this not very useful or obvious emulation
    mode. For this, add the following to the initialization sequence:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能对于调试可能很有用，尤其是在你没有真实的多指触摸设备进行测试时；另一方面，用户不会期望将此功能绑定到右键点击。可能最好禁用此功能，以免我们的用户被这种不太有用或明显的模拟模式所困惑。为此，请在初始化序列中添加以下内容：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code can be made conditional (or just commented out temporarily) at the
    time of development if you're actually using this feature for debugging.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你在开发过程中实际上使用此功能进行调试，可以在此时将其条件化（或暂时注释掉）。 '
- en: Drawing touches
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图触摸
- en: To illustrate one possible scenario for reacting to the touch input, let's draw
    a circle every time the user touches (or clicks) the screen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个可能的触摸输入响应场景，让我们每次用户触摸（或点击）屏幕时都画一个圆。
- en: 'A `Widget` has an `on_touch_down` event that will come in handy for this task.
    We''re interested in just the coordinates of every touch for the time being, and
    they are accessible as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Widget`有一个`on_touch_down`事件，这对于这项任务非常有用。目前我们只对每个触摸的坐标感兴趣，它们可以通过以下方式访问：'
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example prints the position of touches as they occur. To draw something
    on the screen instead, we will use the `Widget.canvas` property. Kivy's `Canvas`
    is a logical drawable surface that abstracts away the underlying OpenGL renderer.
    Unlike the low-level graphical API, the canvas is stateful and preserves the drawing
    instructions that were added to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在触摸发生时打印触摸的位置。要在屏幕上绘制某些内容，我们将使用`Widget.canvas`属性。Kivy的`Canvas`是一个逻辑可绘制表面，它抽象化了底层的OpenGL渲染器。与低级图形API不同，画布是状态化的，并保留了添加到其中的绘图指令。
- en: Speaking of drawing primitives, many of those can be imported from the `kivy.graphics`
    package. Examples of drawing instructions are `Color`, `Line`, `Rectangle`, and
    `Bezier`, among others.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 谈及绘图原语，许多都可以从`kivy.graphics`包中导入。绘图指令的例子包括`Color`、`Line`、`Rectangle`和`Bezier`等。
- en: A very short introduction to the canvas
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对画布的简要介绍
- en: 'The `Canvas` API can be invoked directly or as a context handler using the
    `with` keyword. A simple (direct) invocation looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas` API可以直接调用，也可以使用`with`关键字作为上下文处理器。简单的（直接）调用如下所示：'
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This adds a `Line` primitive with arguments to a graphical instructions queue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将一个带有参数的`Line`原语添加到图形指令队列中。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to try out this code right off the bat, please see the next section,
    *Displaying touches on the screen*, for a more comprehensive example of using
    canvas instructions in the context of our Paint app.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要立即尝试这段代码，请参阅下一节，*在屏幕上显示触摸*，以获取在Paint应用上下文中使用画布指令的更全面的示例。
- en: 'Using the context handler generally looks nicer and less cluttered, especially
    when applying multiple instructions. It is shown in the following example, which
    is functionally equivalent to the previous code snippet with `self.canvas.add()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文处理器通常看起来更美观，也更简洁，尤其是在应用多个指令时。以下示例展示了这一点，其功能与之前的`self.canvas.add()`代码片段等效：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This may seem a bit harder to grasp than the direct approach. Choosing the code
    style to use is a matter of personal preference, as they achieve the same thing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比直接方法更难理解。选择要使用的代码风格是个人偏好的问题，因为它们达到相同的效果。
- en: 'Note that, as mentioned before, every subsequent call gets added to the canvas
    without affecting the instructions that were applied previously; at the core,
    the canvas is a growing array of instructions that are replayed every time the
    surface is rendered to the screen. Keep this in mind: as we aim for 60 fps refresh
    rate, we certainly don''t want this list to grow indefinitely.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如前所述，每个后续调用都会添加到画布中，而不会影响之前应用的指令；在核心上，画布是一个随着每次将表面渲染到屏幕上而增长的指令数组。请记住：我们旨在达到60
    fps的刷新率，我们当然不希望这个列表无限增长。
- en: 'For example, one of the coding practices that works correctly on the immediate-mode-rendering
    surface (like HTML5''s `<canvas>`) is erasing the previously drawn graphics from
    the view by overpainting it with background color. This is rather intuitive and
    works correctly in a browser:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一种在即时模式渲染表面（如HTML5的`<canvas>`）上正确工作的编码实践是通过用背景色覆盖来擦除之前绘制的图形。这在浏览器中相当直观且工作正常：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Kivy, on the other hand, this pattern still just adds drawing instructions;
    it first renders all of the pre-existing primitives and then paints them over
    with a rectangle. This looks just about right (the canvas is visually empty) but
    does the wrong thing:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在Kivy中，这种模式仍然只是添加绘图指令；它首先渲染所有现有的原语，然后用矩形覆盖它们。这看起来几乎正确（画布在视觉上是空的），但做的是错误的事情：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Just like a memory leak, this bug can go unnoticed for a long time, quietly
    accumulating rendering instructions and degrading performance. Thanks to powerful
    video cards found in today's devices, including smartphones, rendering is generally
    very fast. So it's hard to realize that the overhead is there when debugging.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就像内存泄漏一样，这个错误可能长时间不被注意，悄无声息地积累渲染指令并降低性能。多亏了今天设备中强大的显卡，包括智能手机，渲染通常非常快。所以在调试时很难意识到存在开销。
- en: In order to properly clear the canvas in Kivy (that is, remove all the drawing
    instructions), you should use the `canvas.clear()` method, shown later in this
    chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Kivy中正确清除画布（即移除所有绘图指令），你应该使用本章后面展示的`canvas.clear()`方法。
- en: Displaying touches on the screen
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示屏幕上的触摸
- en: 'We are going to implement a button to clear the screen shortly; in the meantime,
    let''s display touches on the screen. We remove the call to `print()` and add
    the following method to the `CanvasWidget` class definition:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快实现一个清除屏幕的按钮；在此期间，让我们显示屏幕上的触摸。我们移除了对`print()`的调用，并在`CanvasWidget`类定义中添加了以下方法：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This draws an empty circle around every touch that our widget receives. The
    `Color` instruction sets the color for the following `Line` primitive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在我们的小部件接收到的每个触摸周围绘制一个空心的圆。`Color`指令设置了以下`Line`原语的颜色。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the color format (here, `#RRGGBBAA`) isn't strictly CSS conformant,
    as it has the fourth component, namely the alpha channel (transparency). This
    syntax variation should be self-evident. It's akin to, for example, `rgb()` and
    `rgba()` notations commonly found elsewhere.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，颜色格式（此处为`#RRGGBBAA`）并不严格遵循CSS规范，因为它有第四个组成部分，即alpha通道（透明度）。这种语法变化应该是显而易见的。它类似于例如在别处常见的`rgb()`和`rgba()`表示法。
- en: You may have also noticed how we're using `Line` in quite an unorthodox way
    here, drawing circles instead of straight lines. Many Kivy graphical primitives
    are powerful like that. For example, any canvas instruction, such as the `Rectangle`
    or `Triangle` primitive, can render a background image, given a `source` parameter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了我们在这里如何非常不寻常地使用`Line`，绘制的是圆而不是直线。许多Kivy图形原语都像这样强大。例如，任何画布指令，如`Rectangle`或`Triangle`原语，都可以通过`source`参数渲染背景图像。
- en: 'If you''re following along, this is how the result should look so far:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随，到目前为止的结果应该如下所示：
- en: '![Displaying touches on the screen](img/B01620_02_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![显示屏幕上的触摸](img/B01620_02_04.jpg)'
- en: Displaying touches on the screen
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 显示屏幕上的触摸
- en: 'The full source code up to this point, which was used to produce the preceding
    demonstration, reads:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的完整源代码，用于生成前面的演示，如下所示：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This excludes the nonessential mouse cursor part for the sake of keeping the
    example code short and sweet. The accompanying Kivy language file, `paint.kv`,
    is missing altogether at this point—instead, the `build()` method of the app class
    returns the root widget.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例代码简洁，我们排除了非必要的鼠标光标部分。在此阶段，伴随的 Kivy 语言文件 `paint.kv` 完全缺失——相反，应用类中的 `build()`
    方法返回根小部件。
- en: Observe the unusual placement of the `import Window` line. This is due to the
    side effects of this specific module, already mentioned earlier. `Config.set()`
    calls should precede this `import` statement to have any effect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `import Window` 行的异常位置。这是由于前面已经提到的该特定模块的副作用。`Config.set()` 调用应在此 `import`
    语句之前进行，才能产生任何效果。
- en: Next, we are going to add more features to our little program, bringing it in
    line with the desired Paint app behavior.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的小程序添加更多功能，使其与期望的绘图应用行为保持一致。
- en: Clearing the screen
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除屏幕
- en: Right now, the only way to clear the screen in our little app is to restart
    it. Let's add a button for deleting everything from the canvas to our UI, which
    is very minimalistic at the moment. We'll reuse the button look from the previous
    app, so there will be nothing new about theming; the interesting part here is
    positioning.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，清除我们小程序屏幕的唯一方法是重新启动它。让我们向我们的 UI 添加一个按钮，用于从画布中删除所有内容，目前这个 UI 非常简约。我们将重用之前应用的按钮外观，因此在主题方面不会有任何新变化；有趣的部分在于定位。
- en: In our first program, the Clock app from [Chapter 1](ch01.html "Chapter 1. Building
    a Clock App"), *Building a Clock App*, we didn't work on any explicit positioning
    at all, as everything was being held in place by nested `BoxLayouts`. Now, however,
    we don't have any layout to our program as the root widget is our very own `CanvasWidget`,
    and we didn't implement any logic to position its children.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个程序中，[第1章](ch01.html "第1章. 构建时钟应用") 的时钟应用，*构建时钟应用*，我们没有进行任何显式的定位，因为所有内容都是由嵌套的
    `BoxLayouts` 维持位置的。然而，现在我们的程序没有布局，因为根小部件就是我们的 `CanvasWidget`，我们没有实现任何定位其子部件的逻辑。
- en: In Kivy, the absence of an explicit layout means that every widget has full
    control over its placement and size (this is pretty much the default state of
    affairs in many other UI toolkits, such as Delphi, Visual Basic, and so on).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kivy 中，没有显式布局意味着每个小部件都完全控制其位置和大小（这在许多其他 UI 工具包中几乎是默认状态，例如 Delphi、Visual Basic
    等）。
- en: 'To position the newly created delete button in the top-right corner, we do
    the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新创建的删除按钮定位到右上角，我们进行以下操作：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a property binding that says the button's `right` and `top` properties
    should be kept in sync with the root widget's properties accordingly. We could
    also do the math here, for example, `root.top – 20`. The rest is pretty straightforward,
    as `width` and `height` are absolute values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个属性绑定，表示按钮的 `right` 和 `top` 属性应与根小部件的属性相应地保持同步。我们也可以在这里进行数学运算，例如 `root.top
    – 20`。其余部分相当直接，因为 `width` 和 `height` 是绝对值。
- en: Also note that we've defined a class rule for `<CanvasWidget>` without specifying
    its superclass. This works because this time we are extending the existing class
    with the same name, defined earlier in Python code. Kivy allows us to augment
    all the existing widget classes, both built-ins, such as `<Button>` and `<Label>`,
    and custom ones.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们没有为 `<CanvasWidget>` 定义一个类规则，而没有指定其超类。这是因为这次我们正在扩展之前在 Python 代码中定义的具有相同名称的现有类。Kivy
    允许我们增强所有现有的小部件类，包括内置的，如 `<Button>` 和 `<Label>`，以及自定义的。
- en: This illustrates a common good practice to describe visual attributes of objects
    using the Kivy language. At the same time, it's better to keep all program flow
    constructs, such as event handlers, on the Python side of things. Such separation
    of concerns makes both the Python source code and its corresponding Kivy language
    counterpart more readable and easier to follow.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了使用 Kivy 语言描述对象视觉属性的一种常见良好实践。同时，最好将所有程序流程结构，如事件处理程序，保持在 Python 的一侧。这种关注点的分离使得
    Python 源代码及其相应的 Kivy 语言对应物都更容易阅读和跟踪。
- en: Passing events
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递事件
- en: If you have kept up with this tutorial and already tried clicking the button,
    you may have noticed (or even guessed) that it doesn't work. The fact that it
    doesn't do anything useful is obviously due to the missing click handler that
    we're going to implement shortly. What's more interesting is that the click just
    doesn't get through, as there is no visual feedback; instead, the usual semi-transparent
    circle gets painted on top of the button, and that's it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟随着这个教程并且已经尝试点击按钮，你可能已经注意到（甚至猜到）它不起作用。它没有做任何有用的事情显然是因为缺少即将要实现的点击处理器。更有趣的是，点击根本无法穿透，因为没有视觉反馈；相反，通常的半透明圆圈被画在按钮上，这就是全部。
- en: This strange effect happens because we're processing all the touches in the
    `CanvasWidget.on_touch_down` handler and don't pass them to the children, so they
    cannot react. Unlike HTML's **Document Object Model** (**DOM**), events in Kivy
    don't bubble up from the nested element up to its parent. They go the other way
    around, from the parent down to the children, that is, if the parent widget would
    pass them, which it doesn't.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种奇怪的效果发生是因为我们在 `CanvasWidget.on_touch_down` 处理器中处理了所有的触摸事件，而没有将它们传递给子元素，因此它们无法做出反应。与
    HTML 的 **文档对象模型** (**DOM**) 不同，Kivy 中的事件不是从嵌套元素向上冒泡到其父元素。它们是相反的方向，从父元素向下到子元素，也就是说，如果父元素将它们传递出去，而它没有这么做。
- en: 'This could be fixed by explicitly doing something along the lines of the following
    code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过明确执行以下类似代码来修复：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In reality, that''s pretty much what the default behavior (`Widget.on_touch_down`)
    already does, so we may as well call it and make the code much more concise, as
    follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这基本上就是默认行为 (`Widget.on_touch_down`) 已经做的事情，所以我们不妨调用它，使代码更加简洁，如下所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The default `on_touch_down` handler also returns `True` if the event was actually
    processed in a meaningful way. Touching a button will return `True` since the
    button reacts to it, and at the very least, changes its appearance. That's just
    what we need in order to cancel our own event processing, which amounts to drawing
    circles at this time, hence the `return` statement on the second line of the method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `on_touch_down` 处理器如果事件实际上以有意义的方式被处理，也会返回 `True`。触摸按钮会返回 `True`，因为按钮会对其做出反应，至少会改变其外观。这正是我们需要来取消我们自己的事件处理，这在当前情况下相当于绘制圆圈，因此方法中的第二行有
    `return` 语句。
- en: Clearing the canvas
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除画布
- en: 'Now we move on to the easiest and also the most useful part of the **Delete**
    button—a touch handler that erases everything. Clearing the canvas is quite simple,
    so everything we need to do in order to get this function to work is here. Yup,
    just two lines of code grand total:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向最简单也是最实用的 **删除** 按钮部分——一个触摸处理器，它可以擦除一切。清除画布相当简单，所以为了使这个功能工作，我们需要做的所有事情都在这里。是的，总共只有两行代码：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Don''t forget to add this method as an event handler to the `paint.kv` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将此方法作为事件处理器添加到 `paint.kv` 文件中：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It works, except that it also removes the **Delete** button itself! This happens
    because the button is a child of `CanvasWidget` (naturally, since `CanvasWidget`
    is a root widget, everything is its direct or indirect child). And while the button
    widget itself isn't deleted (and clicking it still clears the screen), its canvas
    (`Button.canvas`) gets removed from the `CanvasWidget.canvas.children` hierarchy
    and is thus no longer rendered.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以工作，但同时也移除了 **删除** 按钮本身！这是因为按钮是 `CanvasWidget` 的子元素（自然地，因为 `CanvasWidget`
    是根元素，所有元素都是它的直接或间接子元素）。虽然按钮本身没有被删除（点击它仍然会清除屏幕），但其画布（`Button.canvas`）从 `CanvasWidget.canvas.children`
    层级中移除，因此不再渲染。
- en: 'The very straightforward way of fixing it is like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题非常直接的方法如下：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, this isn''t nice because widgets may do their own initialization and
    arrange things differently. A better way to solve this issue is to do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做并不好，因为小部件可能会进行自己的初始化并按不同的方式排列。解决这个问题的更好方法是执行以下操作：
- en: Remove all the children from the "offending" widget (`CanvasWidget`, in this
    case).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“有罪”的元素（在这种情况下是 `CanvasWidget`）中移除所有子元素。
- en: Clear the canvas.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除画布。
- en: Finally, re-add child widgets back so that they can initialize their rendering
    properly.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，重新添加子元素，以便它们可以正确地初始化渲染。
- en: 'The revised version of the code is a bit longer but works properly and is more
    bulletproof:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的修订版本稍微长一些，但工作正常且更健壮：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One line that may need explanation is the `saved = self.children[:]`expression.
    The `[:]` operation is an array copy (literally, "create a new array with these
    same elements"). If we write `saved = self.children` instead, this means we're
    copying a pointer to an array; later, when we call `self.clear_widgets()`, it
    will remove everything from both `self.children` and `saved` since they're referring
    to the same object in the memory. This is why `self.children[:]` is required.
    (The behavior we just discussed is how Python works and is not related to Kivy.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一条可能需要解释的行是`saved = self.children[:]`表达式。`[:]`操作是一个数组复制（字面上，“创建一个包含这些相同元素的新数组”）。如果我们写成`saved
    = self.children`，这意味着我们正在复制一个数组的指针；稍后，当我们调用`self.clear_widgets()`时，它将从`self.children`和`saved`中删除所有内容，因为它们在内存中引用的是同一个对象。这就是为什么需要`self.children[:]`。（我们刚才讨论的行为是Python的工作方式，并且与Kivy无关。）
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're not familiar with the slicing syntax in Python, please see the StackOverflow
    thread at [http://stackoverflow.com/questions/509211](http://stackoverflow.com/questions/509211)
    for an example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Python中的切片语法不熟悉，请参阅StackOverflow论坛上的[http://stackoverflow.com/questions/509211](http://stackoverflow.com/questions/509211)以获取示例。
- en: At this stage, we can already kind of paint things with blue bubbles, as depicted
    in the following screenshot. This is clearly not the final behavior of our Paint
    app, so please read on to the next section in which we will make it draw actual
    lines.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经在某种程度上可以用蓝色气泡来绘画，如下面的截图所示。这显然不是我们绘画应用的最终行为，所以请继续阅读下一节，我们将使其能够绘制实际的线条。
- en: '![Clearing the canvas](img/B01620_02_05.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![清除画布](img/B01620_02_05.jpg)'
- en: The Delete button in all its dreadful glory. Also, painting with a circle "brush"
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 删除按钮的全貌及其令人敬畏的荣耀。还有，用圆形“画笔”绘画
- en: Connecting the dots
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接点
- en: Our app already has a clear screen function but still draws just circles. Let's
    change it so that we can draw lines instead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经有了清除屏幕的功能，但仍然只绘制圆圈。让我们改变它，以便我们可以绘制线条。
- en: To follow continuous touch events (click-and-drag), we'll need to add a new
    event listener, `on_touch_move`. Every time the callback is invoked, it receives
    the latest point where the event occurred.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪连续的触摸事件（点击并拖动），我们需要添加一个新的事件监听器，`on_touch_move`。每次回调被调用时，它都会收到事件发生的最新位置。
- en: If we only had a single line going at every moment (like typically done on a
    desktop, since there is only one mouse pointer anyway), we could save the line
    we're currently drawing in `self.current_line`. But since we're aiming at multitouch
    support from the very beginning, we'll take another approach and store every line
    being drawn in the corresponding `touch` variable itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们每一刻只有一条线（就像在桌面上的典型做法一样，因为无论如何只有一个鼠标指针），我们就可以在`self.current_line`中保存我们正在绘制的线。但由于我们从一开始就旨在支持多点触控，我们将采取另一种方法，并将每条正在绘制的线存储在相应的`touch`变量中。
- en: This works because for every continuous touch from start to end, all callbacks
    receive the same `touch` object. There is also a `touch.ud` property of the type
    `dict` (where `ud` is short for user data), which is specifically tailored to
    keep touch-specific attributes between event handler invocations. Initially, the
    `touch.ud` property is an empty Python dictionary, `{}`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为对于从开始到结束的每一次连续触摸，所有回调都接收相同的`touch`对象。还有一个`touch.ud`属性，其类型为`dict`（其中`ud`是用户数据的缩写），它专门用于在事件处理程序调用之间保持触摸特定的属性。最初，`touch.ud`属性是一个空的Python字典，`{}`。
- en: 'What we''re going to do next is:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的就是：
- en: In the `on_touch_down` handler, create a new line and store it in the `touch.ud`
    dictionary. This time, we will use regular straight lines instead of the fancy
    circular lines we employed earlier to illustrate where individual touches would
    land.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`on_touch_down`处理程序中，创建一条新线并将其存储在`touch.ud`字典中。这次，我们将使用普通的直线而不是我们之前用来说明单个触摸会落在何处的那种花哨的圆形线条。
- en: In `on_touch_move`, append a new point to the end of the corresponding line.
    We are adding a straight line segment, but since the event handler is going to
    be invoked many times per second, the end result will consist of a series of very
    short segments and will look rather smooth nevertheless.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`on_touch_move`中，将一个新的点添加到对应线的末尾。我们正在添加一条直线段，但由于事件处理程序每秒将被调用多次，最终结果将是一系列非常短的段，但看起来仍然相当平滑。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More advanced graphical programs are using sophisticated algorithms to make
    lines appear as if they were drawn on a real physical surface. This includes using
    Bezier curves to make lines seamless even at high resolution and extrapolating
    line thickness from the pointer movement's speed or pressure. We aren't going
    to implement these here as they bear no relation to Kivy, but adding these techniques
    to the resulting Paint app may constitute a nice exercise for the reader.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的图形程序正在使用复杂的算法来使线条看起来像是绘制在真实的物理表面上。这包括使用贝塞尔曲线使线条即使在高分辨率下也看起来无缝，以及从指针移动的速度或压力中推断线条的粗细。我们在这里不会实现这些，因为它们与Kivy无关，但将这些技术添加到最终的Paint应用程序中可能对读者来说是一项很好的练习。
- en: 'The code, as we just described, is listed as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码，正如我们刚才所描述的，列示如下：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This simple approach works, and we're able to draw boring blue lines on our
    canvas. Now let's give our users the ability to select color, then we'll be one
    step closer to a painting app that's actually somewhat useful.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的方法是有效的，我们能够在画布上绘制无聊的蓝色线条。现在让我们给用户选择颜色的能力，然后我们就更接近一个真正有用的绘画应用程序了。
- en: The color palette
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色调色板
- en: Every painting program comes with a palette to choose colors from, and ours
    will be no exception by the time we reach the end of this section, real soon.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绘画程序都附带一个调色板来选择颜色，在我们到达本节的结尾时，我们的也不例外，很快就会实现。
- en: 'Conceptually, a palette is just a list of available colors, presented in a
    way that makes choosing the right color easy. In a full-fledged image editor,
    it usually includes every color available on the system (commonly a full 24-bit
    true color or the 16,777,216 unique colors). The customary representation of this
    all-encompassing palette typically looks like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，调色板只是可用的颜色列表，以易于选择正确颜色的方式呈现。在一个完整的图像编辑器中，它通常包括系统上可用的所有颜色（通常是完整的24位真彩色或16777216种独特的颜色）。这种包含所有颜色的调色板的常规表示通常如下所示：
- en: '![The color palette](img/B01620_02_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![颜色调色板](img/B01620_02_06.jpg)'
- en: Illustration of a true color palette window
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 真彩色调色板窗口的插图
- en: On the other hand, if we aren't going to compete with popular proprietary image
    editing applications, we might as well ship a limited selection of colors. For
    a person with little to no background in graphics, this may even pose a competitive
    advantage—choosing fitting colors that look good together is hard. For this exact
    reason, there are palettes on the Internet that may be universally used for UI
    and graphic design.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们不想与流行的专有图像编辑应用程序竞争，我们不妨提供有限的调色板选择。对于在图形方面几乎没有背景的人来说，这甚至可能构成竞争优势——选择看起来搭配得当的颜色是困难的。正是出于这个原因，互联网上有一些调色板可以普遍用于UI和图形设计。
- en: In this tutorial, we are going to make use of the Flat UI style guide (available
    at [http://designmodo.github.io/Flat-UI/](http://designmodo.github.io/Flat-UI/)),
    which is based on a list of carefully chosen colors that work great together.
    Alternatively, feel free to choose any other palette you like, which is purely
    an aesthetic preference.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用Flat UI风格指南（可在[http://designmodo.github.io/Flat-UI/](http://designmodo.github.io/Flat-UI/)找到），它基于一组精心挑选的颜色，这些颜色搭配在一起效果很好。或者，你也可以自由选择你喜欢的任何其他调色板，这纯粹是审美偏好。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is much to learn in the area of colors, especially color compatibility
    and suitability for specific tasks. Low-contrast combinations may work great for
    decorative elements or big headlines, but they fall short for the main article's
    text; however, counterintuitively, very high contrast, like white on black, is
    not easy on the eyes and quickly strains them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在颜色领域有很多东西要学习，尤其是颜色兼容性和适合特定任务。低对比度的组合可能非常适合装饰元素或大标题，但对于主要文章的文字来说则不够；然而，出人意料的是，非常高的对比度，如白色与黑色，对眼睛来说并不容易，而且很快就会使眼睛疲劳。
- en: 'So, a good rule of thumb regarding colors is that unless you are absolutely
    confident in your artistic skills, preferably stick to well-established palettes
    that are successfully used by others. A great place to start is your favorite
    operating system''s or desktop environment''s guidelines. The following are some
    of the examples:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于颜色的一个很好的经验法则是，除非你对你的艺术技能绝对自信，否则最好坚持使用由他人成功使用的既定调色板。一个好的开始是从你最喜欢的操作系统或桌面环境的指南开始。以下是一些例子：
- en: Tango palette, which is widely used in open source environments such as desktop
    Linux, can be found at [http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines](http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛用于桌面Linux等开源环境中的Tango调色板可以在[http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines](http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines)找到。
- en: Google Material design principles, presented at the Google I/O conference in
    2014, is available at [https://www.google.com/design/material-design.pdf](https://www.google.com/design/material-design.pdf).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2014年Google I/O大会上提出的Google材料设计原则，可在[https://www.google.com/design/material-design.pdf](https://www.google.com/design/material-design.pdf)找到。
- en: The unofficial iOS 7 color swatches can be found at [http://ios7colors.com/](http://ios7colors.com/)
    (many people, including me, find these a bit exaggerated and too vibrant, thus
    best suited for games and maybe advertising, as opposed to a UI for daily use).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非官方的iOS 7颜色样本可以在[http://ios7colors.com/](http://ios7colors.com/)找到（包括我在内，许多人认为这些颜色有些夸张且过于鲜艳，因此最适合游戏和广告，而不是日常使用的UI）。
- en: There are many more color palettes for various tasks readily available—check
    Google if interested, or use a color picker on your favorite OS and programs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多更多适用于各种任务的调色板可供选择——如果您感兴趣，可以检查Google，或者在您最喜欢的操作系统和程序上使用颜色选择器。
- en: Subclassing the buttons
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类化按钮
- en: 'Since we''re going for a rather short fixed list of colors, the UI controls
    that are best suited to represent such a list are likely toggle or radio buttons.
    Kivy''s `ToggleButton` would be perfectly suitable for this task, but it has an
    unfortunate limitation: in a toggle group, all buttons may be deselected at once.
    This would mean that, in the context of the Paint app, there is no color selected.
    (One possible option in this case is to fall back to a default color, but this
    may be surprising to the user so we won''t take this approach.)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在寻找一个相对较短的固定颜色列表，因此最适合表示此类列表的用户界面控件可能是切换或单选按钮。Kivy的`ToggleButton`非常适合这项任务，但它有一个不幸的限制：在切换组中，所有按钮可能一次全部取消选中。这意味着在绘图应用程序的上下文中，没有选择任何颜色。（在这种情况下，一个可能的选项是回退到默认颜色，但这可能会让用户感到惊讶，所以我们不会采取这种方法。）
- en: The good news is that with Python's **OOP** (**object-oriented programming**)
    capabilities, we can easily subclass `ToggleButton` and alter its behavior to
    do what we need, that is, to forbid the deselection of the currently selected
    button. After this tweak, exactly one color will be selected at all times.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，凭借Python的**OOP**（面向对象编程）功能，我们可以轻松地子类化`ToggleButton`并修改其行为以完成我们需要的任务，即禁止取消选中当前选中的按钮。在此调整之后，将始终只选择一个颜色。
- en: 'Subclassing will also achieve another goal in this case: for a palette, we
    want to paint every button in its distinctive color. While we could certainly
    employ the previously used technique of assigning background images to buttons,
    this would require us to produce a whole lot of different background images. Instead,
    we are going to use the background color property, which can be assigned from
    the `paint.kv` file.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，子类化还将实现另一个目标：对于一个调色板，我们希望每个按钮都涂上其独特的颜色。虽然我们当然可以使用之前用于为按钮分配背景图像的技术，但这将需要我们制作大量的不同背景图像。相反，我们将使用背景颜色属性，该属性可以从`paint.kv`文件中分配。
- en: This architecture allows us to keep the definition of the palette itself in
    a very readable declarative form inside `paint.kv`, while the implementation details
    stay out of our way in a subclass—exactly how an OOP program should be.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构允许我们在`paint.kv`文件中保持调色板定义的非常可读的声明性形式，同时将实现细节从我们的方式中排除在子类中——这正是面向对象程序应有的样子。
- en: Taking away the ability to deselect
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消取消选择的能力
- en: First, let's make toggle buttons that cannot all be deselected simultaneously.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建不能同时全部取消选中的切换按钮。
- en: 'To illustrate the problem (and also create the bare-bones implementation that
    will serve as a starting point), let''s implement the desired UI using standard
    Kivy''s `ToggleButton` widgets. This part is purely declarative; let''s just add
    the following code to `paint.kv` to the bottom of the `<CanvasWidget>` section:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明问题（并创建将作为起点的基础实现），让我们使用标准的Kivy `ToggleButton`小部件实现所需的UI。这部分完全是声明性的；让我们只需将以下代码添加到`paint.kv`文件的`<CanvasWidget>`部分底部：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We use the familiar `BoxLayout` component here, acting as a toolbar for individual
    color buttons. The layout widget itself is positioned absolutely, with `x` and
    `y` both set to `0` (that is, the bottom-left corner), taking the full width of
    `CanvasWidget`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用熟悉的 `BoxLayout` 组件，作为单个颜色按钮的工具栏。布局小部件本身被绝对定位，`x` 和 `y` 都设置为 `0`（即左下角），占据
    `CanvasWidget` 的全部宽度。
- en: 'Each `ToggleButton` belongs to the same group, `''color''`, so that at most
    only one of these can be selected (`state: ''down''`) at the same time.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '每个 `ToggleButton` 都属于同一个组，`''color''`，这样最多只能同时选中其中一个（`state: ''down''`）。'
- en: Overriding the standard behavior
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖标准行为
- en: As mentioned previously, the built-in `ToggleButton` behavior isn't exactly
    the radio button that we need; if you click on the selected button, it will be
    deselected, leaving the whole toggle group without a selected element.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，内置的 `ToggleButton` 行为并不完全是我们需要的单选按钮；如果你点击已选中的按钮，它将被取消选中，整个切换组将没有选中的元素。
- en: 'To fix it, let''s subclass `ToggleButton` as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们按照以下方式子类化 `ToggleButton`：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's it. We allow the button to toggle like it normally would only if it wasn't
    already selected (its `state` is `'normal'`, as opposed to `'down'`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。只有当按钮未被选中时（其 `state` 为 `'normal'`，而不是 `'down'`），我们才允许按钮像平常一样切换。
- en: Now all that's left is to replace every instance of `ToggleButton` in the `paint.kv`
    file with `RadioButton`, the name of our custom class, and instantly see the difference
    in the behavior of buttons.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是将 `paint.kv` 文件中的每个 `ToggleButton` 实例替换为我们的自定义类 `RadioButton` 的名称，并立即看到按钮行为的变化。
- en: 'This is a major selling point of the Kivy framework: in only a few lines, you
    can override the built-in functions and methods, achieving practically unmatched
    flexibility.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Kivy 框架的一个主要卖点：仅用几行代码，你就可以覆盖内置的函数和方法，实现几乎无与伦比的灵活性。
- en: Tip
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To become usable in Kivy language, the `RadioButton` definition should reside
    in the `main.py` module or be imported into its scope. Since we have just one
    Python file now, that''s a non-issue, but as your application grows, do keep this
    in mind: custom Kivy widgets, like other Python classes or functions, have to
    be imported prior to their first use.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kivy 语言中使用，`RadioButton` 定义应位于 `main.py` 模块中或导入其作用域。由于我们目前只有一个 Python 文件，这不是问题，但随着你的应用程序的增长，请记住这一点：自定义
    Kivy 小部件，就像其他 Python 类或函数一样，在使用之前必须导入。
- en: Coloring buttons
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色按钮
- en: 'Now that our buttons behave properly, the next step is coloring. What we''re
    aiming for will look like the following image:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们按钮的行为已经正确，下一步是着色。我们想要达到的效果如下所示：
- en: '![Coloring buttons](img/B01620_02_07.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![着色按钮](img/B01620_02_07.jpg)'
- en: Paint app's color palette, vibrant and inviting
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图应用的颜色调色板，鲜艳且吸引人
- en: To achieve this, we are going to use the `background_color` property. The background
    color in Kivy acts as a tint and not just a solid color; we need to prepare a
    pure white background image first, which, when tinted, will give us the color
    we want. This way, we only need to prepare two button textures (normal and pressed
    state) for any number of arbitrary colored buttons.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用 `background_color` 属性。在 Kivy 中，背景色充当色调而不是纯色；我们首先需要准备一个纯白色的背景图像，当它被着色时，将给出我们想要的颜色。这样，我们只需要为任意数量的任意颜色按钮准备两个按钮纹理（正常状态和按下状态）。
- en: 'The images we use here aren''t very different from those we prepared previously
    for the Clock app in [Chapter 1](ch01.html "Chapter 1. Building a Clock App"),
    *Building a Clock App*, except that now the main area of a button is white to
    allow coloring, and the selected state features a black border:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的图像与我们之前为 [第 1 章](ch01.html "第 1 章。构建时钟应用") 中的时钟应用准备的图像没有太大区别，只是现在按钮的主要区域是白色，以便着色，而选中状态具有黑色边框：
- en: '![Coloring buttons](img/B01620_02_09.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![着色按钮](img/B01620_02_09.jpg)'
- en: The color button's texture, where the white area will be tinted using the background
    color property
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色按钮的纹理，其中白色区域将使用背景色属性进行着色
- en: A new kind of button
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种新的按钮类型
- en: 'This time, we can do most of the work, including creating a new button class,
    in the `paint.kv` file. The new class will be called `ColorButton`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们可以在 `paint.kv` 文件中完成大部分工作，包括创建一个新的按钮类。新类将被命名为 `ColorButton`：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, we''ve moved the `group` property here to avoid cluttering
    the palette definition with repetitive `group: ''color''` lines.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，我们将 `group` 属性移动到这里，以避免在调色板定义中重复 `group: ''color''` 行。'
- en: 'We''re also assigning an event handler, `on_release`, that will be called when
    a `ColorButton` is pressed. Every button passes its `background_color` property
    to the event handler, so all that''s left to do is assign this color to the canvas.
    This event will be handled by `CanvasWidget`, which needs to be exposed from the
    `PaintApp` class, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还分配了一个事件处理器`on_release`，当按下`ColorButton`时将被调用。每个按钮都将其`background_color`属性传递给事件处理器，所以剩下的只是将此颜色分配给画布。此事件将由`CanvasWidget`处理，它需要从`PaintApp`类中公开，如下所示：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The reason for this arrangement is that we cannot use the `root` shortcut in
    the preceding `paint.kv` class definition; it will point at the `ColorButton`
    itself (the root definition inside the class rule is indeed the class rule itself
    because it's defined at the top level in `paint.kv`). We can also set the default
    color here, as shown in the code snippet.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排的原因是我们不能在先前的`paint.kv`类定义中使用`root`快捷方式；它将指向`ColorButton`本身（类规则中的根定义确实就是类规则本身，因为它在`paint.kv`的顶层定义）。我们还可以在此设置默认颜色，如代码片段所示。
- en: 'While we''re in the `main.py` module, let''s also implement the `set_color()`
    method on `CanvasWidget`, which will serve as an event handler for `ColorButton`
    clicks. The method in question is very straightforward:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`main.py`模块中时，让我们也实现`CanvasWidget`上的`set_color()`方法，它将作为`ColorButton`点击的事件处理器。所涉及的方法非常直接：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Just set the color that was passed as an argument. That's it!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 只需设置传递给参数的颜色。就是这样！
- en: Defining the palette
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义调色板
- en: 'Here comes the creative part: defining the actual palette. With all the groundwork
    in place, let''s remove the old `RadioButton` definitions from `paint.kv` and
    start anew.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是创意部分：定义实际的调色板。在所有基础工作就绪后，让我们从`paint.kv`中删除旧的`RadioButton`定义，并重新开始。
- en: To use the familiar CSS notation for colors, we'll need to import the appropriate
    function into the `paint.kv` file. Yes, it can import functions, just like a regular
    Python module.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用熟悉的CSS颜色表示法，我们需要将适当的函数导入到`paint.kv`文件中。是的，它可以导入函数，就像常规Python模块一样。
- en: 'Add this line to the beginning of `paint.kv`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行添加到`paint.kv`的开头：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is exactly the same as the following code in Python (with shorter alias
    for brevity, since we''re going to use it a lot):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下Python代码（为了简洁，使用了较短的别名，因为我们将会大量使用它）完全相同：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As mentioned earlier, we will use Flat UI colors for this example, but feel
    free to choose whatever palette you like. The definition itself looks like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用Flat UI颜色为本例，但请随意选择您喜欢的调色板。定义本身看起来是这样的：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This notation is as clear as it can possibly get. There is just one property
    to define for every `ColorButton` widget, namely its `background_color` property.
    Everything else is inherited from the class definition, including the event handler.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法尽可能清晰。对于每个`ColorButton`小部件，只需定义一个属性，即其`background_color`属性。其他所有内容都继承自类定义，包括事件处理器。
- en: The beauty of this architecture is that now we can add any number of such buttons,
    and they will align and perform correctly.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的美丽之处在于，现在我们可以添加任意数量的此类按钮，并且它们将正确对齐并执行。
- en: Setting the line thickness
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置线宽
- en: The last and easiest feature that we are going to implement is a simple line
    thickness selector. As you can see in the following screenshot, we're reusing
    assets and styles from the previous part, the color palette.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的最后一个也是最简单的功能是一个简单的线宽选择器。如以下截图所示，我们正在重用之前部分的颜色调色板中的资产和样式。
- en: '![Setting the line thickness](img/B01620_02_10.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![设置线宽](img/B01620_02_10.jpg)'
- en: Line width selector
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 线宽选择器
- en: 'This UI uses yet another `RadioButton` subclass, unimaginatively named `LineWidthButton`.
    Append the following declaration to the `paint.kv` file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UI使用了另一个`RadioButton`子类，无创意地命名为`LineWidthButton`。将以下声明追加到`paint.kv`文件中：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Key differences from `ColorButton` are highlighted in the preceding code. These
    new buttons belong to another radio group and fire another event handler when
    interacted with. Other than this, they are very similar.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ColorButton`的关键区别在前面代码中已突出显示。这些新按钮属于另一个单选组，并且在交互时触发另一个事件处理器。除此之外，它们非常相似。
- en: 'The layout is equally simple, built in the same fashion as that of the color
    palette, except that it''s vertical:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 布局同样简单，以与调色板相同的方式构建，只是它是垂直的：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that our new event listener `CanvasWidget.set_line_width` will accept the
    `text` property of a pressed button. It is implemented like this for simplicity,
    as this allows us to define just one distinct property per widget.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们新的事件监听器 `CanvasWidget.set_line_width` 将接受被按下的按钮的 `text` 属性。为了简单起见，它是这样实现的，因为这允许我们为每个小部件定义一个独特的属性。
- en: 'In the real-world scenario, this approach isn''t strictly forbidden or particularly
    unheard of but, still a bit questionable: what happens with these text labels
    when we decide to translate our application to Chinese or Hebrew?'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，这种方法并不是严格禁止的，也不是特别不常见，但仍然有点可疑：当我们决定将应用程序翻译成中文或希伯来语时，这些文本标签会发生什么？
- en: Changing the line width
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变线宽
- en: 'With every part of the user interface in place, we can finally attach the event
    listener that''s going to apply the selected line thickness to the painting. We
    will store the numeric value of the line width in `CanvasWidget.line_width`, based
    on the button''s text mapping that''s provided inline, and use it in the `on_touch_down`
    handler when beginning a new line. Long story short, these are relevant parts
    of the revised `CanvasWidget` class:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户界面的每一部分都到位后，我们最终可以将事件监听器附加到将要应用所选线宽的绘画上。我们将基于提供的内联按钮文本映射，在 `CanvasWidget.line_width`
    中存储线宽的数值，并在开始绘制新线条时在 `on_touch_down` 处理程序中使用它。简而言之，这些是修订后的 `CanvasWidget` 类的相关部分：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This concludes the Kivy Paint app tutorial. If you start the program now, you
    can probably paint something beautiful. (I cannot, as you have probably noticed
    from the illustrations.)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了 Kivy Paint 应用程序的教程。如果你现在启动程序，你可能会画出一幅美丽的作品。（我做不到，正如你可能从插图中注意到的。）
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we highlighted a number of common practices for the development
    of Kivy-based apps, such as customization of the main window, changing the mouse
    cursor, window size, and background color, the use of canvas instructions to draw
    free-form graphics programmatically, and handling touch events correctly across
    all supported platforms, with regards to multitouch.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们强调了开发基于 Kivy 的应用程序的一些常见实践，例如自定义主窗口、更改鼠标光标、窗口大小和背景颜色、使用画布指令以编程方式绘制自由形式的图形，以及正确处理所有支持平台上的触摸事件，考虑到多点触控。
- en: 'One thing about Kivy that should be evident after building the Paint app is
    how open ended and versatile the framework is. Instead of providing a large number
    of rigid components, Kivy capitalizes on composability of simple building blocks:
    graphical primitives and behaviors. This means that while there are not many useful
    ready-made widgets bundled with Kivy, you can hack together anything you need
    in a few lines of highly readable Pythonic code.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Paint 应用程序之后，关于 Kivy 的一个明显的事实是它如何开放和多功能。Kivy 不是提供大量刚性的组件，而是利用简单构建块的组合性：图形原语和行为。这意味着虽然
    Kivy 没有捆绑很多有用的现成小部件，但你可以在几行高度可读的 Python 代码中组装出任何你需要的东西。
- en: The modular API design pays off nicely, thanks to its practically limitless
    flexibility. The end result meets your application's unique requirements perfectly.
    The customer wants something sensational, such as a triangular button—sure, you
    can also have a texture on it, all in a whopping three lines of code or so. (By
    comparison, try making a triangular button using **WinAPI**. That's like staring
    into the abyss, only less productive.)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化 API 设计因其几乎无限的灵活性而效果显著。最终结果完美地满足了应用程序的独特需求。客户想要一些令人惊叹的东西，比如一个三角形按钮——当然，你还可以在上面添加纹理，大约只需要三行代码左右。（相比之下，尝试使用
    **WinAPI** 创建一个三角形按钮。那就像凝视深渊，只是不那么富有成效。）
- en: These custom Kivy components also usually end up being reusable. In fact, you
    could easily import `CanvasWidget` from the `main.py` module and use it in another
    application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自定义 Kivy 组件通常也最终会变得可重用。实际上，你可以轻松地从 `main.py` 模块中导入 `CanvasWidget` 并在另一个应用程序中使用它。
- en: '**Natural user interface**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**自然用户界面**'
- en: 'It''s also worth mentioning that our second app is way more interactive than
    the first one: it responds not just to button clicks, but to arbitrary multitouch
    gestures as well.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，我们的第二个应用程序比第一个应用程序互动得多：它不仅对按钮点击做出响应，还对任意的多点触控手势也做出响应。
- en: All the available window surface reacts to touch, and as soon as it becomes
    evident to the end user, there is no cognitive overhead to painting, especially
    on a touch screen device. You just paint on a screen with your fingers, like it
    was a physical surface, and your fingers were sufficiently dirty to leave marks
    on it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的窗口表面都能响应触摸，一旦对最终用户来说变得明显，就没有认知上的负担去绘画，尤其是在触摸屏设备上。你只需用手指在屏幕上画画，就像是在一个物理表面上，而且你的手指足够脏，可以在上面留下痕迹。
- en: 'This kind of interface, or lack thereof, is called **NUI** (**natural user
    interface**). It has an interesting characteristic: a NUI application can be used
    by small kids and even pets—those capable of seeing and touching graphical objects
    on screen. This is literally a natural, intuitive interface, a "no-brainer" kind
    of thing, as opposed to the interface of, for example, Norton Commander, which
    was called intuitive back in the days. Let''s face it: that was a lie. Intuition
    is not applicable to blue-screen, two-panel ASCII art programs in any practical
    way.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种界面，或者说是没有这种界面，被称为**NUI**（**自然用户界面**）。它有一个有趣的特征：NUI应用程序可以被小孩子甚至宠物使用——那些能够看到和触摸屏幕上图形对象的存在。这实际上是一个自然、直观的界面，一种“无需思考”的事情，与例如Norton
    Commander的界面形成对比，后者在当年被称为直观。让我们面对现实：那是个谎言。直觉在以任何实际方式应用于蓝屏、双面板ASCII艺术程序方面是不适用的。
- en: In the next chapter, we will build yet another Kivy-based program, this time
    limited to Android devices. It will exemplify the interoperability between Python
    code and Java classes that comprise the Android API.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建另一个基于Kivy的程序，这次仅限于Android设备。它将展示Python代码和Java类之间的互操作性，这些Java类构成了Android
    API。
