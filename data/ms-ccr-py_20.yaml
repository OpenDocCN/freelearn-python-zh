- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: '**What is the idea behind concurrency, and why is it useful?**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发的背后是什么想法，为什么它有用？**'
- en: Concurrency is about designing and structuring program commands and instructions
    so that different sections of the program can be executed in an efficient order,
    while sharing the same resources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是关于设计和构造程序命令和指令，以便程序的不同部分可以以有效的顺序执行，同时共享相同的资源。
- en: '**What are the differences between concurrent programming and sequential programming?**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发编程和顺序编程之间有什么区别？**'
- en: In sequential programming, the commands and instructions are executed one at
    the time, in a sequential order. In concurrent programming, some sections might
    be executed in an efficient way for better execution time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺序编程中，命令和指令是按顺序一个接一个地执行的。在并发编程中，一些部分可能以更有效的方式执行，以获得更好的执行时间。
- en: '**What are the differences between concurrent programming and parallel programming?**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发编程和并行编程之间有什么区别？**'
- en: In parallel programming, the separate sections of a program are independent
    of one another; they do not interact with one another, and therefore, they can
    be executed simultaneously. In concurrent programming, the separate tasks share
    the same resources, and some form of coordination between them is therefore required.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行编程中，程序的各个部分彼此独立；它们不相互交互，因此可以同时执行。在并发编程中，各个任务共享相同的资源，因此需要它们之间的某种协调。
- en: '**Can every program be made concurrent or parallel?**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个程序都可以并发或并行吗？**'
- en: No.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不。
- en: '**What are embarrassingly parallel tasks?**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是尴尬并行任务？**'
- en: Embarrassingly parallel tasks can be divided into separate, independent sections,
    with little or no effort.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尴尬并行任务可以被分成独立的部分，几乎不需要任何努力。
- en: '**What are inherently sequential tasks?**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是固有顺序任务？**'
- en: Tasks wherein the order of execution of individual sections is crucial to the
    results of the tasks, which cannot be made concurrent or parallel to obtain better
    execution time, are called inherently sequential.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任务中，单个部分的执行顺序对任务结果至关重要，无法并发或并行以获得更好的执行时间的任务被称为固有顺序。
- en: '**What does I/O bound mean?**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**I/O绑定是什么意思？**'
- en: This is a condition in which the time it takes to complete a computation is
    determined mainly by the time spent waiting for input/output operations to be
    completed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种情况，其中完成计算所需的时间主要由等待输入/输出操作完成的时间决定。
- en: '**How is concurrent processing currently being used in the real world?**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发处理目前在现实世界中是如何使用的？**'
- en: 'Concurrency can be found almost everywhere: desktop and mobile applications,
    video games, web and internet development, artificial intelligence, and so on.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并发几乎无处不在：桌面和移动应用程序，视频游戏，Web和互联网开发，人工智能等等。
- en: Chapter 2
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: '**What is Amdahl''s law? What problem does Amdahl''s law look to solve?**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是阿姆达尔定律？阿姆达尔定律试图解决什么问题？**'
- en: Amdahl's law provides an estimate of the theoretical speedup in latency of the
    execution of a task at fixed workload that can be expected of a system whose resources
    are improved.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 阿姆达尔定律提供了一个估计，在固定工作负载下，可以预期系统资源改进后任务执行延迟的理论加速度。
- en: '**Explain the formula of Amdahl''s Law, along with its components.**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释阿姆达尔定律的公式及其组成部分。**'
- en: 'The formula for Amdahl''s Law is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 阿姆达尔定律的公式如下：
- en: '![](assets/cf7ccda6-88e4-4f0c-99b5-d8c344bf900e.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cf7ccda6-88e4-4f0c-99b5-d8c344bf900e.png)'
- en: 'In the preceding formula, the following applies:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，以下适用：
- en: '*S* is the theoretical speedup in consideration.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S*是考虑中的理论加速度。'
- en: '*B* is the portion of the whole task that is inherently sequential.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*是固有顺序的整个任务的部分。'
- en: '*j* is the number of processors being utilized.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*j*是正在利用的处理器数量。'
- en: '**According to Amdahl''s Law, would speedup increase indefinitely as resources
    in the system improved?**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**根据阿姆达尔定律，随着系统资源的改进，速度提升会无限增加吗？**'
- en: No; as the number of processors becomes larger, the efficiency gained through
    the improvement decreases.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不；随着处理器数量的增加，通过改进获得的效率减少。
- en: '**What is the relationship between Amdahl''s Law and the law of diminishing
    returns?**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**阿姆达尔定律和收益递减定律之间的关系是什么？**'
- en: You have seen that in specific situations (namely, when only the number of processors
    increases), Amdahl's Law resembles the law of diminishing returns. Specifically,
    as the number of processors becomes larger, the efficiency gained through the
    improvement decreases, and the speedup curve flattens out.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，在特定情况下（即只有处理器数量增加时），阿姆达尔定律类似于收益递减定律。具体来说，随着处理器数量的增加，通过改进获得的效率减少，加速曲线变平。
- en: Chapter 3
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: '**What is a thread? What are the core differences between a thread and a process?**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是线程？线程和进程之间的核心区别是什么？**'
- en: A thread of execution is the smallest unit of programming commands. More than
    one thread can be implemented within a same process, usually executing concurrently
    and accessing/sharing the same resources, such as memory, while separate processes
    do not do this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行线程是编程命令的最小单位。在同一个进程中可以实现多个线程，通常并发执行并访问/共享相同的资源，如内存，而单独的进程不会这样做。
- en: '**What are the API options provided by the `thread` module in Python?**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python中`thread`模块提供了哪些API选项？**'
- en: 'The main feature of the `thread` module is its fast and efficient method of
    creating new threads to execute functions: the `thread.start_new_thread()` function.
    Aside from this, the module only supports a number of low-level ways of working
    with multithreaded primitives and sharing their global data space. Additionally,
    simple lock objects (for example, mutexes and semaphores) are provided for synchronization
    purposes.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread`模块的主要特点是快速高效地创建新线程来执行函数：`thread.start_new_thread()`函数。除此之外，该模块仅支持一些低级的方式来处理多线程原语并共享它们的全局数据空间。此外，提供了简单的锁对象（例如互斥锁和信号量）用于同步目的。'
- en: '**What are the API options provided by the `threading`**** module in Python?**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**`threading`模块在Python中提供了哪些API选项？**'
- en: 'In addition to all of the functionalities for working with threads that the
    `thread` module provides, the `threading` module also supports a number of extra
    methods, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`thread`模块提供的所有与线程相关的功能外，`threading`模块还支持一些额外的方法，如下所示：
- en: '`threading.activeCount()`: This function returns the number of currently active
    thread objects in the program.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.activeCount()`: 此函数返回程序中当前活动线程对象的数量。'
- en: '`threading.currentThread()`: This function returns the number of thread objects
    in the current thread control from the caller.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.currentThread()`: 此函数返回调用者当前线程控制中的线程对象数量。'
- en: '`threading.enumerate()`: This function returns a list of all of the currently
    active thread objects in the program.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.enumerate()`: 此函数返回程序中当前活动线程对象的列表。'
- en: '**What are the processes of creating new threads via the `thread` and** `threading`
    **modules?**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过`thread`和`threading`模块创建新线程的过程是什么？**'
- en: 'The processes for creating new threads using the `thread` and `threading` module
    is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`thread`和`threading`模块创建新线程的过程如下：
- en: In the `thread` module, new threads are created to execute functions concurrently.
    The way to do this is by using the `thread.start_new_thread()` function: `thread.start_new_thread(function,
    args[, kwargs])`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`thread`模块中，创建新线程以并发执行函数。这样做的方法是使用`thread.start_new_thread()`函数：`thread.start_new_thread(function,
    args[, kwargs])`。
- en: 'To create and customize a new thread using the `threading` module, there are
    specific steps that need to be followed:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用`threading`模块创建和自定义新线程，需要遵循特定的步骤：
- en: Define a subclass of the `threading.Thread` class in our program
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的程序中定义`threading.Thread`类的子类
- en: Override the default `__init__(self [,args])` method inside the subclass to
    add custom arguments for the class
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子类中重写默认的`__init__(self [,args])`方法，以添加类的自定义参数
- en: Override the default `run(self [,args])` method inside the subclass to customize
    the behavior of the thread class when a new thread is initialized and started
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子类中重写默认的`run(self [,args])`方法，以自定义线程类在初始化和启动新线程时的行为
- en: '**What is the idea behind thread synchronization using locks?**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用锁进行线程同步的理念是什么？**'
- en: In a given program, when a thread is accessing/executing the critical section
    of the program, any other threads need to wait until that thread finishes executing.
    The typical goal of thread synchronization is to avoid any potential data discrepancies
    when multiple threads access their shared resource; allowing only one thread to
    execute the critical section at a time guarantees that no data conflicts can occur
    in our multithreaded applications. One of the most common ways to apply thread
    synchronization is through the implementation of a locking mechanism.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定程序中，当一个线程正在访问/执行程序的临界区时，任何其他线程都需要等待，直到该线程执行完毕。线程同步的典型目标是避免多个线程访问其共享资源时可能出现的任何潜在数据不一致；只允许一个线程一次执行临界区可以保证在我们的多线程应用程序中不会发生数据冲突。应用线程同步的最常见方法之一是通过实现锁定机制。
- en: '**What is the process of implementing thread synchronization using locks in
    Python?**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用锁在Python中实现线程同步的过程是什么？**'
- en: 'In our `threading` module, the `threading.Lock` class provides a simple and
    intuitive approach to creating and working with locks. Its main usage includes
    the following methods:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`threading`模块中，`threading.Lock`类提供了一种简单直观的方法来创建和使用锁。其主要用法包括以下方法：
- en: '`threading.Lock()`: This method initializes and returns a new lock object.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.Lock()`: 此方法初始化并返回一个新的锁对象。'
- en: '`acquire(blocking)`: When this method is called, all threads will run synchronously
    (that is, only one thread can execute the critical section at a time).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acquire(blocking)`: 当调用此方法时，所有线程将同步运行（即，一次只有一个线程可以执行临界区）。'
- en: '`release()`: When this method is called, the lock is released.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release()`: 当调用此方法时，锁被释放。'
- en: '**What is the idea behind the queue data structure?**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列数据结构的理念是什么？**'
- en: A queue is an abstract data structure that is a collection of different elements
    maintained in a specific order; these elements can be other objects in a program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一种抽象数据结构，是按特定顺序维护的不同元素的集合；这些元素可以是程序中的其他对象。
- en: '**What is the main application of queuing in concurrent programming?**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**排队在并发编程中的主要应用是什么？**'
- en: The concept of a queue is even more prevalent in the subfield of concurrent
    programming, as the order of elements maintained inside a queue plays an important
    role when a multithreaded program handles and manipulates its shared resources.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的概念在并发编程的子领域中更为普遍，因为队列中维护的元素顺序在多线程程序处理和操作其共享资源时起着重要作用。
- en: '**What are the core differences between a regular queue and a priority queue?**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规队列和优先级队列之间的核心区别是什么？**'
- en: 'The priority queue abstract data structure is similar to the queue data structure,
    but each of the elements of a priority queue, as the name suggests, has a priority
    associated with it; in other words, when an element is added to a priority queue,
    its priority needs to be specified. Unlike in regular queues, the dequeuing principle
    of a priority queue relies on the priority of the elements: the elements with
    higher priority are processed before those with lower priority.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级队列抽象数据结构类似于队列数据结构，但是优先级队列的每个元素，正如其名称所示，都有与之关联的优先级；换句话说，当元素被添加到优先级队列时，需要指定其优先级。与常规队列不同，优先级队列的出队原则依赖于元素的优先级：具有较高优先级的元素在具有较低优先级的元素之前被处理。
- en: Chapter 4
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: '**What is a file descriptor, and in what ways can it be handled in Python?**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件描述符是什么，以及在Python中可以如何处理它？**'
- en: 'A file descriptor is used as a handle on an opened external file in a program.
    In Python, a file descriptor is handled by either using `open()` and `close()`
    functions or using the `with` statement; for example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符用作程序中已打开外部文件的句柄。在Python中，可以通过使用`open()`和`close()`函数或使用`with`语句来处理文件描述符；例如：
- en: '`f = open(filename, ''r''); ... ; f.close()`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f = open(filename, ''r''); ... ; f.close()`'
- en: '`with open(filename, ''r'') as f: ...`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with open(filename, ''r'') as f: ...`'
- en: '**What problem arises when file descriptors are not handled carefully?**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件描述符没有小心处理时会出现什么问题？
- en: Systems can only handle a certain number of opened external files in one running
    process. When that limit is passed, the handles on the opened files will be compromised
    and file descriptor leakage will occur.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 系统只能在一个运行的进程中处理一定数量的已打开外部文件。当超过限制时，已打开文件的句柄将受到损害，并且会发生文件描述符泄漏。
- en: '**What is a lock, and in what ways can it be handled in Python?**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 锁是什么，以及在Python中如何处理它？
- en: 'A lock is a mechanism in concurrent and parallel programming that performs
    thread synchronization. In Python, a `threading.Lock` object can be handled by
    either using the `acquire()` and `release()` methods or using the `with` statement;
    for example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 锁是并发和并行编程中执行线程同步的机制。在Python中，可以通过使用`acquire()`和`release()`方法或使用`with`语句来处理`threading.Lock`对象；例如：
- en: '`my_lock.acquire(); ... ; my_lock.release()`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_lock.acquire(); ... ; my_lock.release()`'
- en: '`with my_lock: ...`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with my_lock: ...`'
- en: '**What problem arises when locks are not handled carefully?**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当锁没有被小心处理时会出现什么问题？
- en: When an exception occurs while a lock is acquired, the lock can never be released
    and acquired again if it is not handled carefully, causing a common problem in
    concurrent and parallel programming called deadlock.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取锁时发生异常时，如果不小心处理，锁将永远无法释放和重新获取，从而导致并发和并行编程中常见的死锁问题。
- en: '**What is the idea behind context managers?**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器背后的理念是什么？
- en: Context managers are in charge of the context of resources within a program;
    they define and handle the interaction of other entities with those resources,
    and perform cleanup tasks after the program exits the context.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器负责程序中资源的上下文；它们定义并处理其他实体与这些资源的交互，并在程序退出上下文后执行清理任务。
- en: '**What options does the** `with` **statement in Python provide, in terms of
    context management?**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句在Python中提供了哪些选项，就上下文管理而言？'
- en: The `with` statement in Python offers an intuitive and convenient way to manage
    resources while ensuring that errors and exceptions are handled correctly. Aside
    from better error handling and guaranteed cleanup tasks, the `with` statement
    also provides extra readability from your programs, which is one of the strongest
    features that Python offers to its developers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`with`语句提供了一种直观和方便的方式来管理资源，同时确保错误和异常被正确处理。除了更好的错误处理和保证的清理任务外，`with`语句还提供了程序的额外可读性，这是Python为其开发人员提供的最强大的功能之一。
- en: Chapter 5
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: '**What is HTML?**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: HTML是什么？
- en: '**HTML** stands for **Hypertext Markup Language**, which is the standard and
    most common markup language for developing web pages and web applications.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: HTML代表超文本标记语言，是开发网页和Web应用程序的标准和最常见的标记语言。
- en: '**What are HTTP requests?**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求是什么？
- en: Most of the communication done via the internet (more specifically, the World Wide
    Web) utilizes HTTP. In HTTP, request methods are used to convey information on
    what data is being requested and should be sent back from a server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过互联网进行的大部分通信（更具体地说，是万维网）都使用HTTP。在HTTP中，请求方法用于传达有关请求的数据以及应该从服务器返回的信息。
- en: '**What are HTTP response status codes?**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应状态码是什么？
- en: HTTP response status codes are three-digit numbers that signify the state of
    communication between a server and its client. They are sorted into five categories,
    each indicating a specific state of communication.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应状态码是三位数字，表示服务器和客户端之间通信状态。它们分为五类，每一类表示特定的通信状态。
- en: '**How does the **`requests`** module help with making web requests?**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests`模块如何帮助进行网络请求？'
- en: The `requests` module manages the communication between a Python program and
    a web server through HTTP requests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests`模块通过HTTP请求管理Python程序与Web服务器之间的通信。'
- en: '**What is a ping test and how is one typically designed?**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Ping测试是什么，通常如何设计？
- en: A ping test is a tool typically used by web administrators to make sure that
    their sites are still available to clients. A ping test does this by making requests
    to the websites under consideration and analyzes the returned response status
    codes
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ping测试是一个通常由Web管理员使用的工具，用于确保他们的网站对客户端仍然可用。Ping测试通过向考虑中的网站发出请求并分析返回的响应状态码来实现这一点
- en: '**Why is concurrency applicable in making web requests?**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么并发适用于进行网络请求？
- en: Both the process of making different requests to a web server and the process
    of parsing and processing downloaded HTML source code are independent across separate
    requests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 向Web服务器发出不同请求的过程以及解析和处理下载的HTML源代码的过程在不同请求之间是独立的。
- en: '**What are the considerations that need to be made when developing web scraping
    applications?**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发网络抓取应用程序时需要考虑哪些因素？
- en: 'The following considerations should be made when developing applications that
    make concurrent web requests:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发进行并发网络请求的应用程序时，应考虑以下因素：
- en: The terms of service and data-collecting policies
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务条款和数据收集政策
- en: Error handling
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Updating your program regularly
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期更新您的程序
- en: Avoiding over-scraping
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过度抓取
- en: Chapter 6
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: '**What is a process? What are the core differences between a process and a
    thread?**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是什么？进程和线程之间的核心区别是什么？
- en: A process is an instance of a specific computer program or software that is
    being executed by the operating system. A process contains both the program code
    and its current activities and interactions with other entities. More than one
    thread can be implemented within the same process to access and share memory or
    other resources, while different processes do not interact in this way.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是操作系统执行的特定计算机程序或软件的实例。进程包含程序代码及其当前的活动和与其他实体的交互。可以在同一个进程中实现多个线程以访问和共享内存或其他资源，而不同进程不以这种方式互动。
- en: '**What is multiprocessing? What are the core differences between multiprocessing
    and multithreading?**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 多进程是什么？多进程和多线程之间的核心区别是什么？
- en: Multiprocessing refers to the execution of multiple concurrent processes from
    an operating system, in which each process is executed on a separate CPU, as opposed
    to a single process at any given time. Multithreading, on the other hand, is the
    execution of multiple threads, which can be within the same process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中，多进程是指从操作系统中执行多个并发进程，其中每个进程在单独的CPU上执行，而不是在任何给定时间内执行单个进程。另一方面，多线程是指执行多个线程，这些线程可以在同一个进程内。
- en: '**What are the API options provided by the multiprocessing module?**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块提供了哪些API选项？'
- en: The `multiprocessing` module provides APIs to the `Process` class, which contains
    the implementation of a process while offering methods to spawn and interact with
    processes using an API similar to the `threading` module. The module also provides
    the `Pool` class, which is mainly used to implement a pool of processes, each
    of which will carry out the tasks submitted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块提供了对`Process`类的API，其中包含了进程的实现，同时提供了类似于`threading`模块的API来生成和与进程交互的方法。该模块还提供了`Pool`类，主要用于实现一组进程，每个进程将执行提交的任务。'
- en: '**What are the core differences between the **`Process`** class and the **`Pool` **class
    from the multiprocessing module?**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块的`Process`类和`Pool`类之间的核心区别是什么？'
- en: The `Pool` class implements a pool of processes, each of which will carry out
    tasks submitted to a `Pool` object. Generally, the `Pool` class is more convenient
    than the `Process` class, especially if the results returned from your concurrent
    application should be ordered.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool`类实现了一组进程，每个进程将执行提交给`Pool`对象的任务。一般来说，`Pool`类比`Process`类更方便，特别是如果并发应用程序返回的结果应该是有序的。'
- en: '**What are the options to determine the current process in a Python program?**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python程序中确定当前进程的选项是什么？
- en: The `multiprocessing` module provides the `current_process()` method, which
    will return the `Process` object that is currently running at any point of a program. Another
    way to keep track of running processes in your program is to look at the individual
    process IDs through the `os` module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块提供了`current_process()`方法，它将返回程序中当前正在运行的`Process`对象。在程序中跟踪运行的进程的另一种方法是通过`os`模块查看各个进程的进程ID。'
- en: '**What are daemon processes? What are their purposes, in terms of waiting for
    processes in a multiprocessing program?**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程是什么？在多进程程序中，它们的目的是什么？
- en: Daemon processes run in the background and do not block the main program from
    exiting. This specification is common when there is not an easy way for the main
    program to tell if it is appropriate to interrupt the process at any given time,
    or when exiting the main program without completing the worker does not affect
    the end result.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程在后台运行，不会阻止主程序退出。当主程序没有简单的方法告知何时中断进程，或者在不影响最终结果的情况下退出主程序而不完成工作时，这种规范是常见的。
- en: '**How can you terminate a process? Why is it sometimes acceptable to terminate
    processes?**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何终止一个进程？为什么有时终止进程是可以接受的？
- en: The `terminate()` method from the `multiprocessing.Process` class offers a way
    to quickly terminate a process. If the processes in your program never interact
    with the shared resources, the `terminate()` method is considerably useful, especially
    if a process appears to be unresponsive or deadlocked.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing.Process`类的`terminate()`方法提供了一种快速终止进程的方式。如果程序中的进程从不与共享资源交互，则`terminate()`方法非常有用，特别是如果进程看起来无响应或死锁。'
- en: '**What are the ways to facilitate interprocess communication in Python?**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，促进进程间通信的方式有哪些？
- en: 'While locks are one of the most common synchronization primitives used for
    communication among threads, pipes and queues are the main way to communicate
    between different processes. Specifically, they provide message passing options
    to facilitate communication between processes: pipes for connections between two
    processes, and queues for multiple producers and consumers.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然锁是用于线程间通信的最常见的同步原语之一，但管道和队列是不同进程之间通信的主要方式。具体来说，它们提供了消息传递选项，以促进进程之间的通信：管道用于两个进程之间的连接，队列用于多个生产者和消费者。
- en: Chapter 7
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: '**What is a reduction operator? What conditions must be satisfied so that an
    operator can be a reduction operator?**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 缩减运算符是什么？必须满足什么条件，使操作符成为缩减运算符？
- en: 'An operator is a reduction operator if it satisfies the following conditions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作符满足以下条件，则为缩减操作符：
- en: The operator can reduce an array of elements into one scalar value
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符可以将一组元素缩减为一个标量值
- en: The end result (the scalar value) is obtained through creating and computing
    partial tasks
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建和计算部分任务来获得最终结果（标量值）
- en: '**What properties do reduction operators have that are equivalent to the required
    conditions?**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 具有与所需条件等效的缩减运算符的属性是什么？
- en: The communicative and associative properties are considered to be equivalent
    to the requirements for a reduction operator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 交换和结合性属性被认为等效于缩减运算符的要求。
- en: '**What is the connection between reduction operators and concurrent programming?**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 缩减运算符与并发编程之间有什么联系？
- en: Reduction operators require communicative and associative properties. Consequently,
    their sub-tasks have to be able to be processed independently, which makes concurrency
    and parallelism applicable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 减少运算符需要交换和结合属性。因此，它们的子任务必须能够独立处理，这使并发和并行性适用。
- en: '**What are some of the considerations that must be made when working with multiprocessing
    programs that facilitate interprocess communication in Python?**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**在使用Python中促进进程间通信的多进程程序时，必须考虑的一些因素是什么？**'
- en: Some considerations include implementing the poison-pill technique, so that
    sub-tasks are distributed across all consumer processes; calling `task_done()`
    on the task queue each time the `get()` function is called, to ensure that the
    `join()` function will not block indefinitely; and avoiding using the `qsize()`
    method, which is unreliable and is not implemented on Unix operating systems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些考虑包括实施毒丸技术，以便将子任务分布到所有消费者进程；每次调用`get()`函数时，在任务队列上调用`task_done()`，以确保`join()`函数不会无限期地阻塞；避免使用`qsize()`方法，该方法不可靠，并且在Unix操作系统上未实现。
- en: '**What are some real-life applications of concurrent reduction operators?**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发减少运算符的一些现实应用是什么？**'
- en: Some real-life applications include heavy number-crunching operators and complex
    programs that utilize logic operators.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些现实应用包括重型数值运算符和利用逻辑运算符的复杂程序。
- en: Chapter 8
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: '**What is an image processing task?**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是图像处理任务？**'
- en: Image processing is the task of analyzing and manipulating digital image files
    to create new versions of the images, or to extract important data from them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理是分析和操作数字图像文件以创建图像的新版本，或从中提取重要数据的任务。
- en: '**What is the smallest unit of digital imaging? How is it represented in computers?**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字成像的最小单位是什么？它在计算机中是如何表示的？**'
- en: 'The smallest unit of digital imaging is a pixel, which typically contains an
    RGB value: a tuple of integers between 0 and 255.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数字成像的最小单位是像素，通常包含RGB值：0到255之间的整数元组。
- en: '**What is grayscaling? What purpose does the technique serve?**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是灰度化？这种技术有什么作用？**'
- en: Grayscaling is the process of converting an image to gray colors by considering
    only the intensity information of each pixel, represented by the amount of light
    available. It reduces the dimensionality of the image pixel matrix by mapping
    traditional three-dimensional color data to one-dimensional gray data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度化是将图像转换为灰色的过程，只考虑每个像素的强度信息，表示为可用光的数量。它通过将传统的三维颜色数据映射到一维灰色数据，减少了图像像素矩阵的维度。
- en: '**What is thresholding? What purpose does the technique serve?**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是阈值处理？这种技术有什么作用？**'
- en: Thresholding replaces each pixel in an image with a white pixel if the pixel's
    intensity is greater than a previously specified threshold, and with a black pixel
    if the pixel's intensity is less than that threshold. After performing thresholding
    on an image, each pixel of that image can only hold two possible values, significantly
    reducing the complexity of image data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值处理将图像中的每个像素替换为白色像素，如果像素的强度大于先前指定的阈值，则替换为黑色像素，如果像素的强度小于该阈值。在图像上执行阈值处理后，该图像的每个像素只能容纳两个可能的值，大大降低了图像数据的复杂性。
- en: '**Why should image processing be made concurrent?**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么应该使图像处理并发？**'
- en: Heavy computational number-crunching processes are typically involved when it
    comes to image processing, as each image is a matrix of integer tuples. However,
    these processes can be executed independently, which suggests that the whole task
    should be made concurrent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到图像处理时，通常涉及到大量的计算数值过程，因为每个图像都是一个整数元组的矩阵。然而，这些过程可以独立执行，这表明整个任务应该是并发的。
- en: '**What are some good practices for concurrent image processing?**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些并发图像处理的良好实践是什么？**'
- en: 'Some good practices for concurrent image processing are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一些并发图像处理的良好实践如下：
- en: Choosing the correct method (out of many)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的方法（众多方法中的一种）
- en: Spawning an appropriate amount of processes
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成适当数量的进程
- en: Processing input/output concurrently
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时处理输入/输出
- en: Chapter 9
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: '**What is the idea behind asynchronous programming?**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步编程背后的理念是什么？**'
- en: Asynchronous programming is a model of programming that focuses on coordinating
    different tasks in an application with the goal that the application will use
    the least amount of time to finish executing those tasks. An asynchronous program
    switches from one task to another when it is appropriate to create overlap between
    the waiting and processing time, and therefore shorten the total time taken to
    finish the whole program.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是一种编程模型，专注于协调应用程序中的不同任务，以便应用程序使用最少的时间来完成执行这些任务。异步程序在等待和处理时间之间创建重叠，从而缩短完成整个程序所需的总时间。
- en: '**How is asynchronous programming different from synchronous programming?**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步编程与同步编程有何不同？**'
- en: 'In synchronous programming, the instructions of a program are executed sequentially:
    a task has to finished executing before the next task in the program starts processing.
    With asynchronous programming, if the current task takes a significant amount
    of time to finish, you have the option to specify at one time during the task
    to switch the execution to another task.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步编程中，程序的指令是顺序执行的：在程序中的下一个任务开始处理之前，必须完成当前任务的执行。使用异步编程，如果当前任务需要较长时间才能完成，您可以在任务执行期间的某个时间指定切换到另一个任务。
- en: '**How is asynchronous programming different from threading and multiprocessing?**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步编程与线程和多进程有何不同？**'
- en: Asynchronous programming keeps all of the instructions of a program in the same
    thread and process. The main idea behind asynchronous programming is to have a
    single executor switch from one task to another if it is more efficient (in terms
    of execution time) to simply wait for the first task for a while, while processing
    the second.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程将程序的所有指令保持在同一个线程和进程中。异步编程的主要思想是，如果单个执行程序从一个任务切换到另一个任务更有效（就执行时间而言），那么只需等待第一个任务一段时间，同时处理第二个任务。
- en: Chapter 10
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: '**What is asynchronous programming? What advantages does it provide?**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是异步编程？它提供了哪些优势？**'
- en: Asynchronous programming is a model of programming that takes advantage of coordinating
    computing tasks to overlap the waiting and processing times. If successfully implemented,
    asynchronous programming provides both responsiveness and an improvement in speed,
    as compared to synchronous programming.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是一种利用协调计算任务以重叠等待和处理时间的编程模型。如果成功实现，异步编程既提供了响应性，又提高了速度，与同步编程相比。
- en: '**What are the main elements in an asynchronous program? How do they interact
    with each other?**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步程序的主要元素是什么？它们如何相互交互？**'
- en: 'There are three main components of an asynchronous program: the event loop,
    the coroutines, and the futures. The event loop is in charge of scheduling and
    managing coroutines by using its task queue; the coroutines are computing tasks
    that are to be executed asynchronously, and each coroutine has to specify, inside
    its function, exactly where it will give the execution flow back to the event
    loop (that is, the task-switching event); the futures are placeholder objects
    that contain the results obtained from the coroutines.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 异步程序有三个主要组件：事件循环、协程和期货。事件循环负责通过使用其任务队列调度和管理协程；协程是要异步执行的计算任务，每个协程都必须在其函数内部指定在哪里将执行流程返回给事件循环（即任务切换事件）；期货是包含从协程获得的结果的占位符对象。
- en: '**What are the **`async`** and **`await`** keywords? What purposes do they
    serve?**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**`async`**和**`await`**关键字是什么？它们有什么作用？'
- en: The `async` and `await` keywords are provided by the Python language as a way
    to implement asynchronous programming on a low level. The `async` keyword is placed
    in front of a function, in order to declare it as a coroutine, while the `await`
    keyword specifies the task-switching events.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言提供了**`async`**和**`await`**关键字，用于在低级别实现异步编程。**`async`**关键字放在函数前面，以声明它为协程，而**`await`**关键字指定任务切换事件。
- en: '**What options does the **`asyncio`** module provide, in terms of the implementation
    of asynchronous programming?**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**`asyncio`**模块在实现异步编程方面提供了哪些选项？'
- en: The `asyncio` module provides an easy-to-use API and an intuitive framework
    to implement asynchronous programs; additionally, this framework makes the asynchronous
    code just as readable as synchronous code, which is generally quite rare in asynchronous
    programming.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**`asyncio`**模块提供了易于使用的API和直观的框架来实现异步程序；此外，该框架使异步代码与同步代码一样易读，这在异步编程中通常是相当罕见的。'
- en: '**What are the improvements, in regards to asynchronous programming, provided
    in Python 3.7?**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 3.7中提供的有关异步编程的改进是什么？**'
- en: Python 3.7 comes with improvements in the API that initiates and runs the main
    event loop of asynchronous programs, while reserving `async` and `await` as official
    Python keywords.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.7改进了启动和运行异步程序的主要事件循环的API，同时将**`async`**和**`await`**保留为官方Python关键字。
- en: '**What are blocking functions? Why do they pose a problem for traditional asynchronous
    programming?**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是阻塞函数？为什么它们对传统的异步编程构成问题？**'
- en: Blocking functions have non-stop execution, and therefore, they prevent any
    attempts to cooperatively switch tasks in an asynchronous program. If forced to
    release the execution flow back to the event loop, blocking functions will simply
    halt their execution until it is their turn to run again. While still achieving
    better responsiveness, in this case, asynchronous programming fails to improve
    the speed of the program; in fact, the asynchronous version of the program takes
    longer to finish executing than the synchronous version, most of the time, due
    to various overheads.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞函数具有不间断的执行，因此阻止任何尝试在异步程序中协作切换任务。如果被迫释放执行流程返回到事件循环，阻塞函数将简单地暂停执行，直到轮到它们再次运行。虽然在这种情况下仍然实现了更好的响应性，但异步编程未能提高程序的速度；事实上，由于各种开销，异步版本的程序通常需要更长的时间来完成执行。
- en: '**How does** `concurrent.futures`** provide a solution to blocking functions
    for asynchronous programming? What options does it provide?**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**`concurrent.futures`**如何为异步编程中的阻塞函数提供解决方案？它提供了哪些选项？'
- en: The `concurrent.futures` module implements threading and multiprocessing for
    the execution of coroutines in an asynchronous program. It provides the `ThreadPoolExecutor`
    and `ProcessPoolExecutor` for asynchronous programming in separate threads and
    separate processes, respectively.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**`concurrent.futures`**模块实现了线程和多进程，用于在异步程序中执行协程。它为异步编程提供了**`ThreadPoolExecutor`**和**`ProcessPoolExecutor`**，分别在单独的线程和单独的进程中执行。'
- en: Chapter 11
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: '**What is a communication channel? What is its connection to asynchronous programming?**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是通信通道？它与异步编程有什么关系？**'
- en: Communication channels are used to denote both the physical wiring connection
    between different systems and the logical communication of data that facilitates
    computer networks. The latter is related to computing, and is more relevant to
    the idea of asynchronous programming. Asynchronous programming can provide functionalities
    that complement the process of facilitating communication channels efficiently.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通信通道用于表示不同系统之间的物理连接以及促进计算机网络的数据逻辑通信。后者与计算有关，与异步编程的概念更相关。异步编程可以提供补充过程，以有效地促进通信通道的功能。
- en: '**What are the two main parts of the ****Open Systems Interconnection (OSI)
    model protocol layers? What purposes do each of them serve?**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放系统互联（OSI）模型协议层有哪两个主要部分？它们各自的目的是什么？**'
- en: The media layers contain fairly low-level operations that interact with the
    underlying process of the communication channel, while the host layers deals with
    high-level data communication and manipulation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体层包含与通信通道的基础过程进行交互的相当低级别的操作，而主机层处理高级数据通信和操作。
- en: '**What is the transport layer? Why is it crucial to communication channels?**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输层是什么？为什么它对通信通道至关重要？**'
- en: The transport layer is often viewed as the conceptual transition between the
    media layers and the host layers, responsible for sending data along end-to-end
    connections between different systems.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层通常被视为媒体层和主机层之间的概念性过渡，负责在不同系统之间的端到端连接中发送数据。
- en: '**How does **`asyncio`** facilitate the implementation of server-side communication
    channels?**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**`asyncio`如何促进服务器端通信通道的实现？**'
- en: Server-wise, the `asyncio` module combines the abstraction of transport with
    the implementation of an asynchronous program. Specifically, via its `BaseTransport`
    and `BaseProtocol` classes, `asyncio` provides different ways to customize the
    underlying architecture of a communication channel.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，`asyncio`模块将传输的抽象与异步程序的实现结合在一起。具体而言，通过其`BaseTransport`和`BaseProtocol`类，`asyncio`提供了不同的方式来定制通信通道的底层架构。
- en: '**How does** `asyncio` **facilitate the implementation of client-side communication
    channels?**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**`asyncio`如何促进客户端通信通道的实现？**'
- en: Together with the `aiohttp` module and, specifically, `aiohttp.ClientSession`,
    `asyncio` also offers efficiency and flexibility regarding client-side communication
    processes, via asynchronously making requests and reading the returned responses.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`aiohttp`模块以及特别是`aiohttp.ClientSession`与`asyncio`一起，也提供了关于客户端通信过程的效率和灵活性，通过异步请求和读取返回的响应。'
- en: '**What is** `aiofiles`**?**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**`aiofiles`是什么？**'
- en: The `aiofiles` module, which can work in conjunction with `asyncio` and `aiohttp`,
    helps to facilitate asynchronous file reading/writing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`aiofiles`模块可以与`asyncio`和`aiohttp`一起使用，有助于促进异步文件读取/写入。'
- en: Chapter 12
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: '**What can lead to a deadlock situation, and why is it undesirable?**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么会导致死锁情况，为什么这是不可取的？**'
- en: A lack of (or mishandled) coordination between different lock objects can cause
    deadlock, in which no progress can be made and the program is locked in its current
    state.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不同锁对象之间缺乏（或处理不当的）协调可能导致死锁，其中无法取得任何进展，程序被锁定在当前状态。
- en: '**How is the dining philosophers problem related to the problem of deadlock?**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 哲学家就餐问题与死锁问题有何关联？
- en: In the dining philosophers problem, as each philosopher is holding only one
    fork with their left hand, they cannot proceed to eat or put down the fork they
    are holding. The only way a philosopher gets to eat their food is for their neighbor
    philosopher to put their fork down, which is only possible if they can eat their
    own food; this creates a never-ending circle of conditions that can never be satisfied.
    This situation is, in essence, the nature of a deadlock, in which all elements
    of a system are stuck in place and no progress can be made.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在哲学家就餐问题中，每个哲学家只用左手拿着一把叉子，因此他们无法继续进食或放下他们手中的叉子。哲学家得以进食的唯一方式是邻座的哲学家放下叉子，而这只有在他们自己能够进食时才可能发生；这造成了一种永无止境的条件循环，永远无法满足。这种情况本质上就是死锁的本质，其中系统的所有元素都被困在原地，无法取得任何进展。
- en: '**What are the four Coffman conditions?**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**科夫曼条件有哪四个？**'
- en: 'Deadlock is also defined by the necessary conditions that a concurrent program
    needs to have at the same time, in order for deadlock to occur. These conditions
    were first proposed by the computer scientist Edward G. Coffman, Jr., and are
    therefore known as the Coffman conditions. The conditions are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁还由并发程序需要同时具备的必要条件来定义，以便发生死锁。这些条件最初由计算机科学家爱德华·G·科夫曼（Edward G. Coffman, Jr.）提出，因此被称为科夫曼条件。这些条件如下：
- en: At least one resource has to be in a non-shareable state. This means that that
    resource is being held by an individual process (or thread) and cannot be accessed
    by others; the resource can only be accessed and held by a single process (or
    thread) at any given time. This condition is also known as **mutual exclusion**.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少有一个资源必须处于不可共享的状态。这意味着该资源由一个单独的进程（或线程）持有，并且不能被其他进程访问；该资源在任何给定时间只能被一个进程（或线程）访问和持有。这种条件也被称为**互斥**。
- en: There exists one process (or thread) that is simultaneously accessing a resource
    and waiting for another held by other processes (or threads). In other words,
    this process (or thread) needs access to two resources in order to execute its
    instructions, one of which it is already holding, and the other of which it is
    waiting for from other processes (or threads). This condition is called **hold
    and wait**.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个同时访问资源并等待其他进程（或线程）持有的资源的进程（或线程）。换句话说，这个进程（或线程）需要访问两个资源才能执行其指令，其中一个它已经持有，另一个是它正在等待其他进程（或线程）提供的。这个条件被称为**持有和等待**。
- en: Resources can only be released by a process (or a thread) holding them if there
    are specific instructions for the process (or thread) to do so. This is to say
    that unless the process (or thread) voluntarily and actively releases the resource,
    that resource remains in a non-shareable state. This is the **no preemption**
    condition.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当进程（或线程）持有资源的特定指令时，资源才能被释放。这意味着，除非进程（或线程）自愿并积极地释放资源，否则资源将保持在不可共享的状态。这就是**无抢占**条件。
- en: The final condition is called **circular wait**. As suggested by the name, this
    condition specifies that there exists a set of processes (or threads) such that
    the first process (or thread) in the set is in a waiting state for a resource
    to be released by the second process (or thread), which, in turn, needs to be
    waiting for the third process (or thread); finally, the last process (or thread)
    in the set is waiting for the first one.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个条件称为**循环等待**。正如其名称所示，该条件指定存在一组进程（或线程），使得该组中的第一个进程（或线程）处于等待状态，等待第二个进程（或线程）释放资源，而第二个进程（或线程）又需要等待第三个进程（或线程）；最后，该组中的最后一个进程（或线程）又在等待第一个进程。
- en: '**How can resource ranking solve the problem of deadlock? What other problems
    occur when this is implemented?**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源排序如何解决死锁问题？实施这一方法可能会导致哪些其他问题？**'
- en: Instead of accessing the resources arbitrarily, if the processes (or threads)
    are to access them in a predetermined, static order, the circular nature of the
    way that they acquire and wait for the resources will be eliminated. However, if
    you place enough locks on the resources of your concurrent program, it will become
    entirely sequential in its execution, and, combined with the overhead of concurrent
    programming functionalities, it will have an even worse speed than the purely
    sequential version of the program.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程（或线程）按照预定的静态顺序访问资源，而不是任意访问资源，它们获取和等待资源的循环性质将被消除。然而，如果在并发程序的资源上放置足够的锁，它将在执行上变得完全顺序，并且与并发编程功能的开销结合起来，其速度甚至比程序的纯顺序版本更差。
- en: '**How can ignoring locks solve the problem of deadlock? What other problems
    can occur when this is implemented?**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**忽略锁如何解决死锁问题？实施这一方法可能会导致哪些其他问题？**'
- en: By ignoring locks, our program resources effectively become shareable among
    different processes/threads in a concurrent program, thus eliminating the first
    of the four Coffman conditions, **mutual exclusion**. Doing this, however, can
    be seen as misunderstanding the problem completely. We know that locks are utilized
    so that processes and threads can access the shared resources in a program in
    a systematic, coordinated way, to avoid mishandling the data. Removing any locking
    mechanisms in a concurrent program means that the likelihood of the shared resources,
    which are now free from accessing limitations, being manipulated in an uncoordinated
    way (and therefore becoming corrupted) increases significantly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过忽略锁，我们的程序资源有效地在并发程序中的不同进程/线程之间共享，从而消除了Coffman条件中的第一个条件，**互斥**。然而，这样做可能被视为完全误解了问题。我们知道锁被利用是为了让进程和线程可以以有系统、协调的方式访问程序中的共享资源，以避免对数据的错误处理。在并发程序中移除任何锁定机制意味着共享资源的可能性，这些资源现在不受访问限制，被以不协调的方式操纵（因此变得损坏）的可能性显著增加。
- en: '**How is livelock related to deadlock?**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**活锁与死锁有什么关系？**'
- en: In a livelock situation, the processes (or threads) in the concurrent program
    are able to switch their states, yet they simply switch back and forth infinitely,
    and no progress can be made.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在活锁情况下，并发程序中的进程（或线程）能够切换它们的状态，但它们只是无限地来回切换，无法取得任何进展。
- en: Chapter 13
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: '**What is starvation, and why is it undesirable in a concurrent program?**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是饥饿，为什么在并发程序中是不可取的？**'
- en: Starvation is a problem in concurrent systems in which a process (or a thread)
    cannot gain access to the necessary resources to proceed with its execution, and
    therefore, cannot make any progress.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 饥饿是并发系统中的一个问题，其中一个进程（或线程）无法获得必要的资源来继续执行，因此无法取得任何进展。
- en: '**What are the underlying causes of starvation? What are the common superficial
    causes of starvation that can manifest from the underlying cause?**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**饥饿的根本原因是什么？可以从根本原因中产生哪些常见的表面原因？**'
- en: 'Most of the time, a poorly coordinated set of scheduling instructions is the
    main cause of starvation. Some high-level causes for starvation might include
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，一组调度指令的协调不佳是饥饿的主要原因。一些导致饥饿的高级原因可能包括以下内容：
- en: Processes (or threads) with high priorities dominate the execution flow in the
    CPU, and thus, low-priority processes (or threads) are not given the opportunity
    to execute their own instructions.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有高优先级的进程（或线程）主导CPU中的执行流程，因此，低优先级的进程（或线程）没有机会执行自己的指令。
- en: Processes (or threads) with high priorities dominate the usage of non-shareable
    resources, and thus, low-priority processes (or threads) are not given the opportunity
    to execute their own instructions. This situation is similar to the first one,
    but addresses the priority of accessing resources, instead of the priority of
    execution itself.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有高优先级的进程（或线程）主导使用不可共享的资源，因此，低优先级的进程（或线程）没有机会执行自己的指令。这种情况类似于第一种情况，但是涉及到访问资源的优先级，而不是执行本身的优先级。
- en: Processes (or threads) with low priorities are waiting for resources to execute
    their instructions, but as soon as the resources become available, other processes
    (or threads) with higher priorities are immediately given access to them, so the
    low-priority processes (or threads) wait infinitely.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有低优先级的进程（或线程）正在等待资源来执行它们的指令，但是一旦资源变得可用，具有更高优先级的其他进程（或线程）立即获得了访问权限，因此低优先级的进程（或线程）无限等待。
- en: '**What is the connection between deadlock and starvation?**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁和饥饿之间有什么联系？**'
- en: Deadlock situations can also lead to starvation, as the definition of starvation
    states that if there exists a process (or a thread) that is unable to make any
    progress because it cannot gain access to the necessary process, the process (or
    thread) is experiencing starvation. This is also illustrated in the dining philosophers
    problem.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁情况也可能导致饥饿，因为饥饿的定义表明，如果存在一个进程（或线程）由于无法获得必要的进程而无法取得任何进展，那么该进程（或线程）正在经历饥饿。这也在哲学家就餐问题中有所体现。
- en: '**What is the readers-writers problem?**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**读者写者问题是什么？**'
- en: The readers-writers problem asks for a scheduling algorithm so that readers
    and writers can access the text file appropriately and efficiently, without mishandling/corrupting
    the data included.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 读者写者问题要求一个调度算法，使读者和写者可以适当和高效地访问文本文件，而不会错误处理/损坏其中包含的数据。
- en: '**What is the first approach to the readers-writers problem? Why does starvation
    arise in that situation?**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 读者写者问题的第一种方法是什么？为什么在这种情况下会出现饥饿现象？
- en: The first approach allows for multiple readers to access the text file simultaneously, since
    readers simply read in the text file and do not alter the data in it. The problem
    with the first approach is that when a reader is accessing the text file and a
    writer is waiting for the file to be unlocked, if another reader starts its execution
    and wants to access the file, it will be given priority over the writer that has
    already been waiting. Additionally, if more and more readers keep requesting access
    to the file, the writer will be waiting infinitely.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法允许多个读者同时访问文本文件，因为读者只是读取文本文件，不会更改其中的数据。第一种方法的问题在于，当一个读者正在访问文本文件并且一个写者正在等待文件解锁时，如果另一个读者开始执行并且想要访问文件，它将优先于已经等待的写者。此外，如果越来越多的读者继续请求访问文件，写者将无限等待。
- en: '**What is the second approach to the readers-writers problem? Why does starvation
    arise in that situation?**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是什么？为什么在这种情况下会出现饥饿现象？
- en: This approach implements the specification that once a writer makes a request
    to access the file, no reader should be able to jump in line and access the file
    before that writer. As opposed to what we see in the first solution to the readers-writers
    problem, this solution is giving priority to writers and, as a consequence, the
    readers are starved.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法实现了一旦写者请求访问文件，就不应该有读者能够插队并在该写者之前访问文件。与读者写者问题的第一种解决方案相反，这种解决方案给予了写者优先权，因此读者会饥饿。
- en: '**What is the third approach to the readers-writers problem? Why does it successfully
    address starvation?**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 读者写者问题的第三种方法是什么？为什么它成功地解决了饥饿问题？
- en: This approach implements a lock on both readers and writers. All threads will
    then be subject to the constants of the lock, and equal priority will thus be
    achieved among separate threads.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对读者和写者都实施了锁。然后，所有线程将受到锁的限制，并且不同线程之间将实现相同的优先级。
- en: '**What are some common solutions to starvation?**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的解决饥饿问题的方法是什么？
- en: 'Some common solutions to starvation include the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的解决饥饿问题的方法包括以下：
- en: Increasing the priority of low-priority threads
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高低优先级线程的优先级
- en: Implementing a first-in-first-out thread queue
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施先进先出的线程队列
- en: A priority queue that also gives gradually increasing priority to threads that
    have been waiting in the queue for a long time
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个优先级队列，还逐渐增加了长时间等待在队列中的线程的优先级
- en: Or if a thread has been able to access the shared resource for many times, it
    will be given less priority
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者如果一个线程已经多次能够访问共享资源，它将被给予较低的优先级
- en: Chapter 14
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: '**What is a critical section?**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是临界区？**'
- en: Critical sections indicate shared resources that are accessed by multiple processes
    or threads in a concurrent application, which can lead to unexpected, and even
    erroneous, behaviors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 临界区指示在并发应用程序中由多个进程或线程访问的共享资源，这可能导致意外甚至错误的行为。
- en: '**What is a race condition, and why is it undesirable in a concurrent program?**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是竞争条件，为什么在并发程序中是不可取的？**'
- en: A race condition occurs when two or more threads/processes access and alter
    a shared resource simultaneously, resulting in mishandled and corrupted data.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程/进程同时访问和更改共享资源时，就会发生竞争条件，导致数据错误和损坏。
- en: '**What is the underlying cause of a race condition?**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件的根本原因是什么？
- en: The root cause of a race condition is multiple threads/process reading in and
    altering a shared resource simultaneously; and, when all of the threads/processes
    finish their execution, only the result of the last thread/process is registered.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件的根本原因是多个线程/进程同时读取和更改共享资源；当所有线程/进程完成执行时，只有最后一个线程/进程的结果被注册。
- en: '**How can locks solve the problem of a race condition?**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 锁如何解决竞争条件的问题？
- en: Since the race conditions arise when multiple threads or processes access and
    write to a shared resource simultaneously, the solution is to isolate the execution
    of different threads/processes, especially when interacting with the shared resource.
    With locks, we can turn a shared resource in a concurrent program into a critical
    section, whose integrity of data is guaranteed to be protected.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于竞争条件是由多个线程或进程同时访问和写入共享资源引起的，因此解决方案是隔离不同线程/进程的执行，特别是在与共享资源交互时。通过锁，我们可以将并发程序中的共享资源转换为临界区，保证其数据的完整性得到保护。
- en: '**Why are locks sometimes undesirable in a concurrent program?**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么锁有时在并发程序中是不可取的？
- en: 'There are a number of disadvantages to using locks: with enough locks implemented
    in a concurrent program, the whole program might become entirely sequential; locks
    don''t lock anything.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用锁存在一些缺点：在并发程序中实现足够多的锁，整个程序可能变得完全顺序化；锁并不锁定任何东西。
- en: '**What are the problems race conditions raise in real-life systems and applications?**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**竞争条件在现实生活系统和应用中引发了什么问题？**'
- en: 'The problems race conditions raise in real-life systems and applications are
    as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活系统和应用中竞争条件引发的问题如下：
- en: '**Security**: A race condition can be both exploited as a security vulnerability
    (to give external agents illegal access to a system) and used as random key generation,
    for security processes.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：竞争条件既可以被利用作为安全漏洞（给外部代理非法访问系统），也可以用作随机密钥生成，用于安全流程。'
- en: '**Operating systems**: A race condition occurring when two agents (users and
    applications) interact with the same memory space can lead to unpredictable behaviors.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：当两个代理（用户和应用程序）与相同的内存空间交互时，竞争条件可能导致不可预测的行为。'
- en: '**Networking**: In networking, a race condition can lead to giving multiple
    users powerful privileges in a network.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：在网络中，竞争条件可能导致多个用户在网络中拥有强大的特权。'
- en: Chapter 15
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: '**What is the difference in memory management between Python and C++?**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python和C++之间的内存管理有何不同？**'
- en: C++ associates a variable to its value by simply writing the value to the memory
    location of the variable; Python has its variables reference point to the memory
    location of the values that they hold. For this reason, Python needs to maintain
    a reference count for every value in its memory space.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: C++通过简单地将值写入变量的内存位置来将变量与其值关联起来；Python的变量引用指向它们所持有的值的内存位置。因此，Python需要维护其内存空间中每个值的引用计数。
- en: '**What problem does the GIL solve for Python?**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**GIL为Python解决了什么问题？**'
- en: To avoid race conditions, and consequently, the corruption of value reference
    counts, the GIL is implemented so that only one thread can access and mutate the
    counts at any given time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免竞争条件，因此避免值引用计数的损坏，GIL被实现为只有一个线程可以在任何给定时间访问和改变计数。
- en: '**What problem does the GIL create for Python?**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**GIL为Python创建了什么问题？**'
- en: The GIL effectively prevents multiple threads from taking advantage of the CPU
    and executing CPU-bound instructions at the same time. This means that if multiple
    threads that are meant to be executed concurrently are CPU-bound, they will actually
    be executed sequentially.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: GIL有效地阻止多个线程利用CPU并同时执行CPU绑定的指令。这意味着如果多个线程被设计为并发执行且CPU绑定，它们实际上将被顺序执行。
- en: '**What are some of the approaches to circumventing the GIL in Python programs?**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**有哪些绕过Python程序中的GIL的方法？**'
- en: There are a few ways to deal with the GIL in your Python applications; namely,
    implementing multiprocessing instead of multithreading, and utilizing other, alternative
    Python interpreters.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以处理Python应用程序中的GIL；即，实现多进程而不是多线程，并利用其他替代Python解释器。
- en: Chapter 16
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: '**What is the main approach to solving the problem that locks don''t lock anything?**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决锁不锁任何东西的问题的主要方法是什么？**'
- en: The main approach is to have the locks internally implemented within the data
    structure's class attributes and methods, so that external functions and programs
    cannot bypass those locks and access a shared concurrent object simultaneously.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 主要方法是在数据结构的类属性和方法内部实现锁定，以便外部函数和程序无法绕过这些锁定并同时访问共享的并发对象。
- en: '**Describe the concept of scalability, in the context of concurrent programming.**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述并发编程中的可伸缩性概念。**'
- en: By the scalability of a program, we mean the changes in performance when the
    amount of tasks to be processed by the program increases. Andre B. Bondi defines
    the term scalability as, *"the capability of a system, network, or process to
    handle a growing amount of work, or its potential to be enlarged to accommodate
    that growth."*
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过程序的可伸缩性，我们指的是当程序需要处理的任务数量增加时，性能的变化。Andre B. Bondi将可伸缩性定义为“系统、网络或进程处理不断增长的工作量的能力，或者它扩大以适应这种增长的潜力。”
- en: '**How does a naive locking mechanism affect the scalability of a concurrent
    program?**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**天真的锁定机制如何影响并发程序的可伸缩性？**'
- en: 'The scalability of a simple lock-based data structure is highly undesirable:
    as more threads are added to the program to execute more tasks, the performance
    of the program decreases somewhat linearly. Since only one thread can access and
    increment the shared counter at any given time, the more increments the program
    has to execute, the longer it will take to finish all of the incremented tasks.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 简单基于锁的数据结构的可伸缩性是非常不理想的：随着程序添加更多线程来执行更多任务，程序的性能会线性下降。由于在任何给定时间只有一个线程可以访问和增加共享计数器，程序需要执行的增量越多，完成所有增量任务所需的时间就越长。
- en: '**What are approximate counters, and how do they help with the problem of scalability
    in concurrent programming?**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是近似计数器，它如何帮助解决并发编程中的可伸缩性问题？**'
- en: The basic idea behind approximate counters is to distribute the work (incrementing
    the shared global counter) across other low-level counters. When an active thread
    executes and wants to increment the global counter; first, it has to increment
    its corresponding local counter. With one separate counter object for each thread,
    the threads can update their corresponding local counters independently and simultaneously,
    creating overlaps that will result in a better performance in speed for the programs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 近似计数器的基本思想是将工作（增加共享全局计数器）分布到其他低级计数器中。当活动线程执行并想要增加全局计数器时，首先必须增加其对应的本地计数器。通过为每个线程设置一个单独的计数器对象，线程可以独立和同时更新其对应的本地计数器，从而创建重叠，从而提高程序的速度性能。
- en: '**Are lock-free data structures possible in Python? Why, or why not?**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python中是否可能存在无锁数据结构？为什么？**'
- en: The characteristic of being lock-free is impossible to implement in CPython,
    due to the existence of the **Global Interpreter Lock** **(GIL)**, which prevents
    more than one thread from executing in the CPU at any given time.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在**全局解释器锁（GIL）**，在CPython中实现无锁特性是不可能的，它阻止多个线程在任何给定时间执行CPU。
- en: '**What is a mutex-free concurrent data structure, and how is it different from
    a concurrent lock-based one?**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是无互斥锁并发数据结构，它与基于锁的并发数据结构有何不同？**'
- en: The term mutex-free concurrent data structures indicates a lack of a locking
    mechanism and the use of other synchronization mechanisms to protect the data.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 无互斥锁并发数据结构这个术语表示缺乏锁定机制，并使用其他同步机制来保护数据。
- en: '**What is the RCU technique, and what problem does it solve for mutex-free
    concurrent data structures?**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**RCU技术是什么，它解决了无互斥并发数据结构的什么问题？**'
- en: To protect the integrity of concurrent data structures, the RCU technique creates
    and maintains another version of the data structure when a thread or process is
    requesting reading or writing access to it. By isolating the interaction between
    the data structure and the threads/processes within a separate copy, RCU ensures
    that no conflicting data can occur.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护并发数据结构的完整性，RCU技术在线程或进程请求读取或写入访问时创建和维护数据结构的另一个版本。通过在单独的副本中隔离数据结构和线程/进程之间的交互，RCU确保不会发生冲突的数据。
- en: Chapter 17
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章
- en: '**What are the main components of the Python memory manager?**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python内存管理器的主要组件是什么？**'
- en: 'The main components of the Python memory manager are as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Python内存管理器的主要组件如下：
- en: The raw memory allocator handles the allocation of memory at a low level by
    interacting with the memory manager of the operating system.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始内存分配器通过与操作系统的内存管理器交互，处理低级内存分配。
- en: Object-specific memory allocators interact with the private heap of objects
    and values in Python. These allocators execute memory operations that are specific
    to given data and object types.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定对象的内存分配器与Python中的对象和值的私有堆交互。这些分配器执行特定于给定数据和对象类型的内存操作。
- en: The system allocators from the standard C library are responsible for helping
    the raw memory allocator interact with the memory manager of the operating system.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准C库的系统分配器负责帮助原始内存分配器与操作系统的内存管理器交互。
- en: '**How does the Python memory model resemble a labeled directed graph?**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python内存模型如何类似于带标签的有向图？**'
- en: 'The memory model keeps track of its data and variables via nothing but pointers:
    the value of every variable is a pointer, and this point can be pointing to a
    symbol, a number, or a subroutine. So, these pointers are the directed edges in
    the object graph, and the actual values (symbols, numbers, and subroutines) are
    the nodes in the graph.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 内存模型仅通过指针跟踪其数据和变量：每个变量的值都是一个指针，这个指针可以指向符号、数字或子程序。因此，这些指针是对象图中的有向边，而实际值（符号、数字和子程序）是图中的节点。
- en: '**What are the advantages and disadvantages of the Python memory model, in
    terms of developing concurrent applications in Python?**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**就Python内存模型而言，开发Python并发应用程序的优缺点是什么？**'
- en: Reasoning about the behaviors of a concurrent program can be significantly easier
    than doing the same in another programming language. However, the ease of understanding
    and debugging concurrent programs in Python also comes with a decrease in performance.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 推理并发程序的行为可能比在其他编程语言中更容易。然而，在Python中理解和调试并发程序的便利性也伴随着性能的降低。
- en: '**What is an atomic operation, and why is it desirable in concurrent programming?**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是原子操作，为什么在并发编程中它是可取的？**'
- en: Atomic operations are instructions that cannot be interrupted during their execution.
    Atomicity is a desirable characteristic of concurrent operations, as it guarantees
    the safety of data shared across different threads.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作是在执行过程中不能被中断的指令。原子性是并发操作的一个理想特征，因为它保证了在不同线程之间共享的数据的安全性。
- en: '**Give three examples of innately atomic operations in Python.**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**给出Python中三个固有的原子操作的例子。**'
- en: 'Some examples are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子如下：
- en: Appending a predefined object to a list
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将预定义对象附加到列表
- en: Extending a list with another list
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用另一个列表扩展列表
- en: Fetching an element from a list
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中获取元素
- en: Popping from a list
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中弹出
- en: Sorting a list
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对列表进行排序
- en: Assigning a variable to another variable
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量分配给另一个变量
- en: Assigning a variable to an attribute of an object
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量分配给对象的属性
- en: Creating a new entry for a dictionary
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为字典创建一个新条目
- en: Updating a dictionary with another dictionary
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用另一个字典更新字典
- en: Chapter 18
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章
- en: '**What is a socket? How is it relevant in network programming?**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是套接字？在网络编程中它有什么作用？**'
- en: Low-level network programming, more often than not, involves the manipulation
    and handling of sockets, which are defined as theoretical endpoints within the
    nodes of a specific computer network, responsible for receiving or sending data
    from the nodes that they are in.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 低级网络编程往往涉及套接字的操作和处理，套接字被定义为特定计算机网络节点内的理论端点，负责从它们所在的节点接收或发送数据。
- en: '**What is the procedure of server-side communication when a potential client
    makes a request to connect?**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**潜在客户端发出连接请求时，服务器端通信的程序是什么？**'
- en: To open a communication channel from the server side, a network programmer must
    first create a socket and bind it to a specific address. The server then begins
    to listen to any potential communication requests created by the clients in the
    network. Upon receiving a request to connect from a potential client, the server
    can now decide whether to accept that request. A connection is then established
    between the two systems in the network, which means that they can start to communicate
    and share data with each other. As the client sends a message to the server via
    the communication channel, the server then processes the message, and eventually
    sends a response back to the client through the same channel; this process continues
    until the connection between them ends, either by one of them quitting the connection
    channel or through some external factors.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要从服务器端打开通信通道，网络程序员必须首先创建套接字并将其绑定到特定地址。然后服务器开始监听网络中由客户端创建的任何潜在通信请求。在收到来自潜在客户端的连接请求后，服务器现在可以决定是否接受该请求。然后在网络中建立两个系统之间的连接，这意味着它们可以开始相互通信和共享数据。当客户端通过通信通道向服务器发送消息时，服务器会处理消息，最终通过相同的通道向客户端发送响应；这个过程会一直持续，直到它们之间的连接结束，要么是其中一个退出连接通道，要么是通过一些外部因素。
- en: '**What are some methods provided by the socket module to facilitate low-level
    network programming on the server side?**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**套接字模块提供了哪些方法来方便服务器端的低级网络编程？**'
- en: 'Some of the important methods are as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要方法：
- en: '`socket.bind()` binds the calling socket to the address that is passed to the
    method'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.bind()`将调用套接字绑定到传递给该方法的地址'
- en: '`socket.listen()` allows the server that we create to accept connections from
    potential clients'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.listen()`允许我们创建的服务器接受潜在客户端的连接'
- en: '`socket.accept()` accepts a specific connection that the calling socket object
    has'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.accept()`接受调用套接字对象具有的特定连接'
- en: '`socket.makefile()` returns a file object that is associated with the calling
    socket object'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.makefile()`返回一个与调用套接字对象关联的文件对象'
- en: '`socket.sendall()` sends the data passed as a parameter to the calling socket
    object'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.sendall()`将传递的数据作为参数发送到调用套接字对象'
- en: '`socket.close()` marks the calling socket object as closed'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.close()`标记调用套接字对象为关闭状态'
- en: '**What are generators? What is their advantage over Python lists?**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器是什么？它们相对于Python列表的优势是什么？**'
- en: Generators are functions that return iterators and are able to be paused and
    resumed dynamically. Generator iterators are lazy, and only produce results when
    specifically asked. For this reason, generator iterators are more efficient in
    terms of memory management, and are therefore often preferred over lists when
    large amounts of data are involved.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是返回迭代器并能够动态暂停和恢复的函数。生成器迭代器是惰性的，只有在特别要求时才产生结果。因此，生成器迭代器在内存管理方面更有效，并且通常在涉及大量数据时更受青睐。
- en: '**What are asynchronous generators? How can they be applied in order to build
    a non-blocking server?**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是异步生成器？如何应用它们以构建非阻塞服务器？**'
- en: Asynchronous generators allow for the execution flow to switch between generating
    tasks. Combined with using callbacks that can be run at a later time, a server
    can read and handle data coming in from multiple clients at the same time.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器允许执行流在生成任务之间切换。结合可以在以后运行的回调，服务器可以同时读取和处理来自多个客户端的数据。
- en: Chapter 19
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章
- en: '**What is APScheduler? Why isn''t it a scheduling service?**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**APScheduler是什么？为什么它不是一个调度服务？**'
- en: APScheduler is an external Python library that supports scheduling Python code
    to be executed later. APScheduler is not, in itself, a scheduling service that
    has a built-in GUI or command-line interface. It is still a Python library that
    has to be imported and utilized inside existing applications. However, APScheduler
    comes with numerous functionalities that can be leveraged in order to build an
    actual scheduling service.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: APScheduler是一个外部Python库，支持安排Python代码以后执行。APScheduler本身不是一个具有内置GUI或命令行界面的调度服务。它仍然是一个必须在现有应用程序中导入和利用的Python库。但是，APScheduler具有许多功能，可以利用这些功能来构建实际的调度服务。
- en: '**What are the main scheduling functionalities of APScheduler?**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**APScheduler的主要调度功能是什么？**'
- en: 'It offers three different scheduling mechanisms: cron-style scheduling, interval-based
    execution, and delayed execution. Furthermore, APScheduler allows for storing
    the jobs to be executed in various backend systems, and working with common Python
    concurrency frameworks, such as AsyncIO, Gevent, Tornado, and Twisted. Finally,
    APScheduler provides different options to actually execute the scheduled code,
    by specifying the appropriate executor(s).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供三种不同的调度机制：类似cron的调度、基于间隔的执行和延迟执行。此外，APScheduler允许将要执行的作业存储在各种后端系统中，并与常见的Python并发框架一起使用，如AsyncIO、Gevent、Tornado和Twisted。最后，APScheduler提供了不同的选项来实际执行调度的代码，通过指定适当的执行者。
- en: '**What are the differences between APScheduler and another scheduling tool
    in Python, Celery?**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python中APScheduler和另一个调度工具Celery之间有什么区别？**'
- en: 'While Celery is a distributed task queue with basic scheduling capabilities,
    APScheduler is quite the opposite: a scheduler with basic task queuing options
    and advanced scheduling functionalities. Users have reported that APScheduler
    is easier to set up and implement than Celery.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Celery是一个具有基本调度功能的分布式任务队列，但APScheduler恰恰相反：一个具有基本任务排队选项和高级调度功能的调度程序。用户报告称APScheduler比Celery更容易设置和实现。
- en: '**What is the purpose of testing in programming? How is it different in concurrent
    programming?**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程中测试的目的是什么？在并发编程中有什么不同？**'
- en: Testing evokes errors that indicate the existence of bugs in our programs. Testing
    concurrent programs is typically difficult, as non-determinism allows for a concurrency
    bug to be detected in one run of the test and become invisible in another. We
    call the concurrency bugs that might become invisible from test to test non-reproducible,
    and they are the main reason why we cannot reply on testing to detect all concurrency
    bugs consistently.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 测试引发错误，表明程序中存在错误。测试并发程序通常很困难，因为非确定性允许在测试的一个运行中检测到并在另一个运行中变得不可见。我们称可能在测试之间变得不可见的并发错误为不可重现的，并且它们是我们不能依靠测试一致地检测所有并发错误的主要原因。
- en: '**What are the methods of testing that were discussed in this chapter?**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本章中讨论了哪些测试方法？**'
- en: Unit testing is applied to individual units of the program under consideration,
    where a unit is the smallest testable part of the program. Static code analysis,
    on the other hand, looks at the actual code itself without executing it. Static
    code analysis scans for visual errors in the code structure and usage of variables
    and functions.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应用于考虑中的程序的各个单元，其中单元是程序的最小可测试部分。另一方面，静态代码分析查看实际的代码本身而不执行它。静态代码分析扫描代码结构和变量和函数使用中的可视错误。
- en: '**What is the purpose of debugging in programming? How is it different in concurrent
    programming?**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程中调试的目的是什么？在并发编程中有什么不同？**'
- en: Debugging is the process by which programmers attempt to identify and resolve
    problems or defects that would otherwise cause the computer applications that
    they reside in to produce incorrect results, or even stop functioning. Similar
    to the problem of testing concurrent programs, debugging, when applied to concurrency,
    can become increasingly complex and difficult, as shared resources can interact
    with (and be altered by) multiple agents simultaneously.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是程序员试图识别和解决问题或缺陷的过程，否则这些问题或缺陷会导致计算机应用程序产生不正确的结果，甚至停止运行。与测试并发程序的问题类似，调试并发程序时可能变得越来越复杂和困难，因为共享资源可以与（并且可以被）多个代理同时交互。
- en: '**What are the methods of debugging that were discussed in this chapter?**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了哪些调试方法？
- en: General debugging methods include print debugging, logging, tracing, and using
    a debugger. The process of debugging concurrent programs can utilize minimization,
    single-threading/processing, and manipulating scheduling in order to amplify potential
    bugs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的调试方法包括打印调试、日志记录、跟踪和使用调试器。调试并发程序的过程可以利用最小化、单线程/处理和操纵调度来放大潜在的错误。
