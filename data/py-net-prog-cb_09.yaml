- en: Chapter 9. Network Monitoring and Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：网络监控和安全
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Sniffing packets on your network
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的网络上嗅探数据包
- en: Saving packets in the pcap format using the pcap dumper
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pcap dumper 将数据包保存到 pcap 格式
- en: Adding an extra header in HTTP packets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 HTTP 数据包中添加额外的头部
- en: Scanning the ports of a remote host
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描远程主机的端口
- en: Customizing the IP address of a packet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义数据包的 IP 地址
- en: Replaying traffic by reading from a saved pcap file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过读取保存的 pcap 文件来回放流量
- en: Scanning the broadcast of packets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描数据包的广播
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter presents some interesting Python recipes for network security monitoring
    and vulnerability scanning. We begin by sniffing packets on a network using the
    `pcap` library. Then, we start using `Scapy`, which is a Swiss knife type of library
    that can do many similar tasks. Some common tasks in packet analysis are presented
    using `Scapy`, such as saving a packet in the `pcap` format, adding an extra header,
    and modifying the IP address of a packet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了关于网络安全监控和漏洞扫描的一些有趣的 Python 菜谱。我们首先使用 `pcap` 库在网络中嗅探数据包。然后，我们开始使用 `Scapy`，这是一个瑞士军刀式的库，可以执行许多类似任务。使用
    `Scapy` 展示了一些常见的包分析任务，例如将数据包保存到 `pcap` 格式、添加额外的头部和修改数据包的 IP 地址。
- en: Some other advanced tasks on network intrusion detection are also included in
    this chapter, for example, replaying traffic from a saved `pcap` file and broadcast
    scanning.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还包括一些关于网络入侵检测的高级任务，例如，从保存的 `pcap` 文件中回放流量和广播扫描。
- en: Sniffing packets on your network
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的网络上嗅探数据包
- en: If you are interested in sniffing packets on your local network, this recipe
    can be used as the starting point. Remember that you may not be able to sniff
    packets other than what is destined to your machine, as decent network switches
    will only forward traffic that is designated to your machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对你本地网络上的数据包嗅探感兴趣，这个菜谱可以作为起点。记住，你可能无法嗅探除目标机器之外的数据包，因为良好的网络交换机只会转发指定给机器的流量。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install the `pylibpcap` library (Version 0.6.4 or greater) for this
    recipe to work. It's available at SourceForge ([http://sourceforge.net/projects/pylibpcap/](http://sourceforge.net/projects/pylibpcap/)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个菜谱工作，你需要安装 `pylibpcap` 库（版本 0.6.4 或更高版本）。它可以在 SourceForge 上找到（[http://sourceforge.net/projects/pylibpcap/](http://sourceforge.net/projects/pylibpcap/))。
- en: 'You also need to install the `construct` library, which can be installed from
    PyPI via `pip` or `easy_install`, as shown in the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装 `construct` 库，这个库可以通过 PyPI 中的 `pip` 或 `easy_install` 安装，如下命令所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We can supply command-line arguments, for example, the network interface name
    and TCP port number, for sniffing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供命令行参数，例如网络接口名称和 TCP 端口号，以进行嗅探。
- en: 'Listing 9.1 gives the code for sniffing packets on your network, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 给出了在网络上嗅探数据包的代码，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you run this script passing the command-line arguments, `--iface=eth0` and
    `--port=80`, this script will sniff all the HTTP packets from your web browser.
    So, after running this script, if you access [http://www.google.com](http://www.google.com)
    on your browser, you can then see a raw packet output like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本并传递命令行参数，`--iface=eth0` 和 `--port=80`，此脚本将嗅探来自你网页浏览器的所有 HTTP 数据包。因此，在运行此脚本后，如果你在浏览器中访问
    [http://www.google.com](http://www.google.com)，你可以看到如下所示的原始数据包输出：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe relies on the `pcapObject()` class from the `pcap` library to create
    an instance of sniffer. In the `main()` method, an instance of this class is created,
    and a filter is set using the `setfilter()` method so that only the HTTP packets
    are captured. Finally, the `dispatch()` method starts sniffing and sends the sniffed
    packet to the `print_packet()` function for postprocessing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱依赖于 `pcap` 库中的 `pcapObject()` 类来创建嗅探器的实例。在 `main()` 方法中，创建了这个类的实例，并使用 `setfilter()`
    方法设置了一个过滤器，以便只捕获 HTTP 数据包。最后，`dispatch()` 方法开始嗅探并将嗅探到的数据包发送到 `print_packet()`
    函数进行后处理。
- en: In the `print_packet()` function, if a packet has data, the payload is extracted
    using the `ip_stack.parse()` method from the `construct` library. This library
    is useful for low-level data processing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `print_packet()` 函数中，如果数据包包含数据，则使用 `construct` 库的 `ip_stack.parse()` 方法提取有效载荷。这个库对于低级数据处理很有用。
- en: Saving packets in the pcap format using the pcap dumper
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pcap dumper 将数据包保存到 pcap 格式
- en: The **pcap** format, abbreviated from **packet capture**, is a common file format
    for saving network data. More details on the pcap format can be found at [http://wiki.wireshark.org/Development/LibpcapFileFormat](http://wiki.wireshark.org/Development/LibpcapFileFormat).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**pcap**格式，缩写自**数据包捕获**，是保存网络数据的常见文件格式。有关pcap格式的更多详细信息，请参阅[http://wiki.wireshark.org/Development/LibpcapFileFormat](http://wiki.wireshark.org/Development/LibpcapFileFormat)。'
- en: If you want to save your captured network packets to a file and later re-use
    them for further processing, this recipe can be a working example for you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将捕获到的网络数据包保存到文件，并在以后重新使用它们进行进一步处理，这个菜谱可以为你提供一个工作示例。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we use the `Scapy` library to sniff packets and write to a
    file. All utility functions and definitions of `Scapy` can be imported using the
    wild card import, as shown in the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用`Scapy`库来嗅探数据包并将其写入文件。所有`Scapy`的实用函数和定义都可以通过通配符导入来导入，如下面的命令所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is only for demonstration purposes and not recommended for production code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了演示目的，不推荐用于生产代码。
- en: The `sniff()` function of `Scapy` takes the name of a callback function. Let's
    write a callback function that will write the packets onto a file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scapy`的`sniff()`函数接受一个回调函数的名称。让我们编写一个回调函数，该函数将数据包写入文件。'
- en: 'Listing 9.2 gives the code for saving packets in the pcap format using the
    pcap dumper, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2给出了使用pcap dumper将数据包保存为pcap格式的代码，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run this script, you will see an output similar to the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本，你将看到类似以下输出的输出：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe uses the `sniff()` and `wrpacp()` utility functions of the `Scapy`
    library to capture all the network packets and dump them onto a file. After capturing
    a packet via `sniff()`, the `write_cap()` function is called on that packet. Some
    global variables are used to work on packets one after another. For example, packets
    are stored in a `pkts[]`list and packet and variable counts are used. When the
    value of the count is 3, the `pkts` list is dumped onto a file named `pcap1.pcap`,
    the count variable is reset so that we can continue capturing another three packets
    and dumped onto `pcap2.pcap`, and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用`Scapy`库的`sniff()`和`wrpacp()`实用函数来捕获所有网络数据包并将它们写入文件。通过`sniff()`捕获数据包后，将调用该数据包的`write_cap()`函数。一些全局变量用于逐个处理数据包。例如，数据包存储在`pkts[]`列表中，并使用数据包和变量计数。当计数值为3时，将`pkts`列表写入名为`pcap1.pcap`的文件，将计数变量重置，以便我们可以继续捕获另外三个数据包并将它们写入`pcap2.pcap`，依此类推。
- en: In the `test_dump_file()` function, assume the presence of the first dump file,
    `pcap1.dump`, in the working directory. Now, `sniff()` is used with an offline
    parameter, which captured packets from the file instead of network. Here, the
    packets are decoded one after another using the `hexdump()` function. The contents
    of the packets are then printed on the screen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test_dump_file()`函数中，假设在当前工作目录中存在第一个转储文件，`pcap1.dump`。现在，使用带有离线参数的`sniff()`，从文件中捕获数据包而不是从网络中捕获。在这里，使用`hexdump()`函数逐个解码数据包。然后，将数据包的内容打印到屏幕上。
- en: Adding an extra header in HTTP packets
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HTTP数据包中添加额外头
- en: Sometimes, you would like to manipulate an application by supplying a custom
    HTTP header that contains custom information. For example, adding an authorization
    header can be useful to implement the HTTP basic authentication in your packet
    capture code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望通过提供包含自定义信息的自定义HTTP头来操纵应用程序。例如，添加一个授权头对于在数据包捕获代码中实现HTTP基本认证非常有用。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let us sniff the packets using the `sniff()` function of `Scapy` and define
    a callback function, `modify_packet_header()`, which adds an extra header of certain
    packets.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Scapy`的`sniff()`函数嗅探数据包，并定义一个回调函数`modify_packet_header()`，该函数为某些数据包添加额外的头。
- en: 'Listing 9.3 gives the code for adding an extra header in HTTP packets, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3给出了在HTTP数据包中添加额外头的代码，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you run this script, it will show a captured packet; print the modified
    version of it and send it to the network, as shown in the following output. This
    can be verified by other packet capturing tools such as `tcpdump` or `wireshark`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本，它将显示捕获到的数据包；打印其修改后的版本并将其发送到网络，如下面的输出所示。这可以通过其他数据包捕获工具如`tcpdump`或`wireshark`进行验证：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we set up the packet sniffing using the `sniff()` function of **Scapy**,
    specifying `modify_packet_header()` as the callback function for each packet.
    All TCP packets having TCP and a raw layer that are destined to port `80` (HTTP)
    are considered for modification. So, the current packet header is extracted from
    the packet's payload data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `Scapy` 的 `sniff()` 函数设置数据包嗅探，指定 `modify_packet_header()` 作为每个数据包的回调函数。所有目标端口为
    `80`（HTTP）且具有 TCP 和原始层的 TCP 数据包都被认为是修改对象。因此，当前数据包头部是从数据包的有效负载数据中提取出来的。
- en: The extra header is then appended to the existing header dictionary. The packet
    is then printed on screen using the `show()` method, and for avoiding the correctness
    checking failure, the packet checksum data is removed from the packet. Finally,
    the packet is sent over the network.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将额外的头部添加到现有的头部字典中。然后使用 `show()` 方法在屏幕上打印数据包，为了避免正确性检查失败，从数据包中移除数据包校验和。最后，数据包通过网络发送。
- en: Scanning the ports of a remote host
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描远程主机的端口
- en: If you are trying to connect to a remote host using a particular port, sometimes
    you get the message saying that `Connection is refused`. The reason for this is
    that, most likely, the server is down on the remote host. In such a situation,
    you can try to see whether the port is open or in the listening state. You can
    scan multiple ports to identify the available services in a machine.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过特定端口连接到远程主机，有时你会收到“连接被拒绝”的消息。这可能是由于远程主机上的服务器可能已经关闭。在这种情况下，你可以尝试查看端口是否开放或处于监听状态。你可以扫描多个端口以识别机器上的可用服务。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Using Python''s standard socket library, we can accomplish this port-scanning
    task. We can take three command-line arguments: target host, and start and end
    port numbers.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 的标准套接字库，我们可以完成这个端口扫描任务。我们可以接受三个命令行参数：目标主机和起始端口和结束端口。
- en: 'Listing 9.4 gives the code for scanning the ports of a remote host, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 提供了扫描远程主机端口的代码，如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run this recipe to scan your local machine''s port `1` to `100` to detect
    open ports, you will get an output similar to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此方法来扫描本地机器的端口 `1` 到 `100` 以检测开放端口，你将得到类似以下的结果：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe demonstrates how to scan open ports of a machine using Python''s
    standard socket library. The `scan_port()` function takes three arguments: hostname,
    start port, and end port. Then, it scans the entire port range in three steps.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法演示了如何使用 Python 的标准套接字库扫描机器的开放端口。`scan_port()` 函数接受三个参数：主机名、起始端口和结束端口。然后，它分三步扫描整个端口范围。
- en: Create a TCP socket using the `socket()` function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `socket()` 函数创建一个 TCP 套接字。
- en: If the socket is created successfully, then resolve the IP address of the remote
    host using the `gethostbyname()` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果套接字创建成功，则使用 `gethostbyname()` 函数解析远程主机的 IP 地址。
- en: If the target host's IP address is found, try to connect to the IP using the
    `connect()` function. If that's successful, then it implies that the port is open.
    Now, close the port with the `close()` function and repeat the first step for
    the next port.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了目标主机的 IP 地址，尝试使用 `connect()` 函数连接到该 IP。如果成功，则意味着端口是开放的。现在，使用 `close()`
    函数关闭端口，并重复第一步以检查下一个端口。
- en: Customizing the IP address of a packet
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义数据包的 IP 地址
- en: If you ever need to create a network packet and customize the source and destination
    IP or ports, this recipe can serve as the starting point.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建一个网络数据包并自定义源和目标 IP 或端口，这个方法可以作为起点。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We can take all the useful command-line arguments such as network interface
    name, protocol name, source IP, source port, destination IP, destination port,
    and optional TCP flags.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取所有有用的命令行参数，例如网络接口名称、协议名称、源 IP、源端口、目标 IP、目标端口以及可选的 TCP 标志。
- en: We can use the `Scapy` library to create a custom TCP or UDP packet and send
    it over the network.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Scapy` 库创建自定义 TCP 或 UDP 数据包并将其发送到网络上。
- en: 'Listing 9.5 gives the code for customizing the IP address of a packet, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 提供了自定义数据包 IP 地址的代码，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to run this script, enter the following commands:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此脚本，请输入以下命令：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This script defines a `send_packet()` function to construct the IP packet using
    `Scapy`. The source and destination addresses and ports are supplied to it. Depending
    on the protocol, for example, TCP or UDP, it constructs the correct type of packet.
    If the packet is TCP, the flags argument is used; if not, an exception is raised.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本定义了一个`send_packet()`函数，用于使用`Scapy`构建IP数据包。它将源地址和目标地址以及端口号提供给它。根据协议，例如TCP或UDP，它构建正确的数据包类型。如果是TCP，则使用标志参数；如果不是，则引发异常。
- en: In order to construct a TCP packet, `Sacpy` supplies the `IP()`/`TCP()` function.
    Similarly, in order to create a UDP packet, the `IP()`/`UDP()` function is used.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建TCP数据包，`Sacpy`提供了`IP()`/`TCP()`函数。同样，为了创建UDP数据包，使用`IP()`/`UDP()`函数。
- en: Finally, the modified packet is sent using the `send()` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`send()`函数发送修改后的数据包。
- en: Replaying traffic by reading from a saved pcap file
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过读取保存的pcap文件重放流量
- en: While playing with network packets, you may need to replay traffic by reading
    from a previously saved `pcap` file. In that case, you'd like to read the `pcap`
    file and modify the source or destination IP addresses before sending them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩网络数据包时，您可能需要通过从之前保存的`pcap`文件中读取来重放流量。在这种情况下，您希望在发送之前读取`pcap`文件并修改源或目标IP地址。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us use `Scapy` to read a previously saved `pcap` file. If you don't have
    a `pcap` file, you can use the *Saving packets in the pcap format using pcap dumper*
    recipe of this chapter to do that.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Scapy`读取之前保存的`pcap`文件。如果您没有`pcap`文件，可以使用本章的*使用pcap dumper保存数据包到pcap格式*方法来创建一个。
- en: Then, parse the arguments from the command line and pass them to a `send_packet()`function
    along with the parsed raw packets.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从命令行解析参数，并将解析后的原始数据包传递给`send_packet()`函数。
- en: 'Listing 9.6 gives the code for replaying traffic by reading from a saved `pcap`
    file, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6给出了通过从保存的`pcap`文件中读取来重放流量的代码，如下所示：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you run this script, it will read the saved `pcap` file, `pcap1.pcap`, by
    default and send the packet after modifying the source and destination IP addresses
    to `1.1.1.1` and `2.2.2.2` respectively, as shown in the following output. If
    you use the `tcpdump` utility, you can see these packet transmissions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此脚本，它将默认读取保存的`pcap`文件`pcap1.pcap`，并在修改源和目标IP地址为`1.1.1.1`和`2.2.2.2`后发送数据包，如下所示。如果您使用`tcpdump`实用程序，您可以看到这些数据包传输。
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe reads a saved `pcap` file, `pcap1.pcap`, from the disk using the
    `PcapReader()` function of `Scapy` that returns an iterator of packets. The command-line
    arguments are parsed if they are supplied. Otherwise, the default value is used
    as shown in the preceding output.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`Scapy`的`PcapReader()`函数从磁盘读取保存的`pcap`文件`pcap1.pcap`，该函数返回一个数据包迭代器。如果提供了命令行参数，则解析它们。否则，使用前述输出中所示默认值。
- en: The command-line arguments and the packet list are passed to the `send_packet()`
    function. This function places the new packets in the `p_out` list and keeps track
    of the processed packets. In each packet, the payload is modified, thus changing
    the source and destination IPs. In addition to this, the `checksum` packet is
    deleted as it was based on the original IP address.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将命令行参数和数据包列表传递给`send_packet()`函数。此函数将新数据包放入`p_out`列表中，并跟踪处理过的数据包。在每个数据包中，有效载荷被修改，从而改变了源和目标IP地址。此外，删除了`checksum`数据包，因为它基于原始IP地址。
- en: After processing one of the packets, it is sent over the network immediately.
    After that, the remaining packets are sent in one go.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完一个数据包后，它立即通过网络发送。之后，剩余的数据包一次性发送。
- en: Scanning the broadcast of packets
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描数据包广播
- en: If you encounter the issue of detecting a network broadcast, this recipe is
    for you. We can learn how to find the information from the broadcast packets.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到检测网络广播的问题，这个方法就是为您准备的。我们可以学习如何从广播数据包中找到信息。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We can use `Scapy` to sniff the packets arriving to a network interface. After
    each packet is captured, they can be processed by a callback function to get the
    useful information from it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Scapy`嗅探到达网络接口的数据包。在捕获每个数据包后，可以通过回调函数处理它们以获取有用的信息。
- en: 'Listing 9.7 gives the code for scanning the broadcast of packets, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7给出了扫描数据包广播的代码，如下所示：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you run this script, you can list the broadcast traffic''s source IP and
    ports. The following is a sample output from which the first octet of the IP is
    replaced:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个脚本，你可以列出广播流量的源IP和端口。以下是一个示例输出，其中IP的第一个八位字节已被替换：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe sniffs packets in a network using the `sniff()` function of `Scapy`.
    It has a `monitor_packet()`callback function that does the postprocessing of packets.
    Depending on the protocol, for example, IP or TCP, it sorts the packets in a dictionary
    called `captured_data`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用`Scapy`的`sniff()`函数在网络中嗅探数据包。它有一个`monitor_packet()`回调函数，用于处理数据包的后处理。根据协议，例如IP或TCP，它将数据包排序到一个名为`captured_data`的字典中。
- en: If an individual IP is not already present in the dictionary, it creates a new
    entry; otherwise, it updates the dictionary with the port number for that specific
    IP. Finally, it prints the IP addresses and ports in each line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字典中尚未存在单个IP，它将创建一个新的条目；否则，它将更新该特定IP的端口号。最后，它按行打印IP地址和端口。
