- en: '*Chapter 1*: Undertaking a Colossal Project'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：承担一个庞大的项目'
- en: Considering the increasing complexity of applications and websites these days,
    this chapter will introduce you to what it takes to tackle a colossal project
    of your own. We will explore the concepts of enterprise-level development, and
    then take a peek at the many different paths we could take. We will discuss methods
    and tools that help us to draft plans for a project, essentially building the
    blueprints that we will need to get started. Every project also needs hardware
    for its software to live on, so we will be exploring what service options are
    available to provide the hardware we need. Of the options provided, we will settle
    upon one choice for a hosting provider and demonstrate working with that provider
    throughout this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到如今应用程序和网站日益增加的复杂性，本章将向您介绍应对自己庞大项目所需的因素。我们将探讨企业级开发的概念，然后窥视我们可能采取的许多不同路径。我们将讨论帮助我们为项目制定计划的方法和工具，本质上是在构建我们开始所需的蓝图。每个项目也需要硬件来运行其软件，因此我们将探讨提供所需硬件的服务选项。在提供的选项中，我们将选择一个托管提供商，并在本书中展示如何与该提供商合作。
- en: The project itself can be used with any hosting provider or even run on a self-built
    server; however, keep in mind that certain settings may be configured specifically
    for the host that we will be using. By the end of this chapter, we will have created
    a hosting account with the provider chosen and picked the simplest, free plan
    for use with this book. We will also be creating and configuring multiple working
    environments on that hosting plan for the code to run in. We will also connect
    each environment in that hosting plan to a remote repository, keeping the code
    in a safe place.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 项目本身可以与任何托管提供商一起使用，甚至可以在自建的服务器上运行；然而，请注意，某些设置可能需要针对我们将要使用的托管服务器进行特定配置。在本章结束时，我们将为所选提供商创建一个托管账户，并选择最简单、免费的计划用于本书。我们还将创建和配置多个工作环境，以便代码可以在这些环境中运行。我们还将将该托管计划中的每个环境连接到一个远程仓库，以确保代码的安全存储。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building an enterprise
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立企业
- en: Designing and planning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和规划
- en: Hosting and deployment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管和部署
- en: Most people would suggest using a UNIX- or Linux-based operating system, such
    as Ubuntu or macOS, when working with **Django**. Django is built to be so versatile
    that the concepts and code examples that will be demonstrated throughout the course
    of this book can run on all three major platforms (Windows, Mac, and Linux) and
    beyond. Personally, I have been using Django on a Windows-based machine ever since
    I started to learn and work directly with this framework. I did so because I came
    from a Windows background; about half of my jobs provided the equipment or mandated
    the use of certain software on a Windows-based machine. Later on, more and more
    companies started to give developers the choice to work on whatever machine they
    were most comfortable with. I continued to choose Windows because I was already
    familiar with it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人建议在处理 **Django** 时使用基于 UNIX 或 Linux 的操作系统，例如 Ubuntu 或 macOS。Django 被构建得非常灵活，本书中将要展示的概念和代码示例可以在所有三个主要平台（Windows、Mac
    和 Linux）以及更多平台上运行。我个人自从开始学习和直接使用这个框架以来，一直在 Windows 系统上使用 Django。我这样做是因为我来自 Windows
    背景；大约一半的工作提供了设备或要求在基于 Windows 的机器上使用某些软件。后来，越来越多的公司开始让开发者选择在他们最舒适的机器上工作。我继续选择
    Windows，因为我已经熟悉它了。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Whether you are using a Windows, Mac, or Ubuntu system, **Python** will need
    to be installed. Python version 3.9.0 is the latest version available at the time
    of writing this book. It is highly likely that this code will still work with
    future versions of Python but there is no guarantee that all of the code will
    continue to work and there could be some hiccups in future versions. You can find
    the Python installation files for all platforms on their website here: [https://www.python.org/downloads/](https://www.python.org/downloads/).
    For non-Windows users, the most straightforward way of installing Python is with
    **Homebrew**, which creates for you a symlink to the package that you installed.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用的是Windows、Mac还是Ubuntu系统，**Python**都需要安装。Python 3.9.0是本书编写时的最新版本。很可能此代码将仍然与Python的未来版本兼容，但无法保证所有代码都将继续工作，并且未来版本可能会有一些小问题。您可以在他们的网站上找到所有平台的Python安装文件：[https://www.python.org/downloads/](https://www.python.org/downloads/)。对于非Windows用户，使用**Homebrew**安装Python是最直接的方法，它会为您创建一个指向已安装包的符号链接。
- en: For Windows users, an easy way to install Python is through the Microsoft Store.
    Search for `Python` and select **3.9** from the list. During installation, if
    you see the **Add Python to Environment Variables** option, select the checkbox
    to include it! This sets a path to your global library of Python packages/libraries
    on your development machine. These are different from the packages that are included
    in your project, which we will discuss in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户来说，通过Microsoft Store安装Python是一种简单的方法。在列表中搜索`Python`并选择**3.9**。在安装过程中，如果您看到**将Python添加到环境变量**选项，请选中复选框以包含它！这将在您的开发机器上设置一个指向Python包/库的全局库的路径。这些与包含在您的项目中的包不同，我们将在[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)
    *项目配置*中讨论。
- en: A command-line tool is needed to execute commands that interact with and use
    Django. **PowerShell** is a common command-line shell that comes standard in Windows
    today. This command-line utility comes packed with some of the coolest features
    from an assortment of other existing shells, all merged into one. It is also available
    on the Mac and Linux operating systems. However, **iTerm2**, or the built-in **Terminal
    app**, is what most developers tend to gravitate toward using. Regardless, PowerShell
    has become a popular tool used by many developers for automating the management
    of various systems today.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个命令行工具来执行与Django交互和使用的命令。**PowerShell**是Windows今天标准提供的常见命令行外壳。这个命令行实用程序集成了来自其他现有外壳的一些最酷的功能，全部合并为一个。它也适用于Mac和Linux操作系统。然而，**iTerm2**或内置的**终端应用**是大多数开发者倾向于使用的。无论如何，PowerShell已经成为许多开发者今天用于自动化管理各种系统的流行工具。
- en: You will also need to install the `pip` in the future will continue to work
    with the rest of the code and concepts discussed in this book. However, not every
    third-party package discussed in this book is guaranteed to be supported in the
    future by that provider. Regardless, the concepts of using a third-party package
    and how they would be configured and used in a project are taught in this book
    and can be used to find a package of your own.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，您还需要安装`pip`，以便继续使用本书中讨论的其余代码和概念。然而，本书中讨论的并非每个第三方包都保证未来会得到该供应商的支持。无论如何，本书教授了如何使用第三方包以及如何在项目中配置和使用它们，这些知识可以帮助您找到适合自己的包。
- en: Tip
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Whatever operating system you are working on, if you get an error message while
    working with any command throughout this book, such as **pip/python is not recognized
    as an internal or external command**, it means that you need to configure environment
    variables on your system to point to the corresponding file directories. To manually
    configure your environment variables in any of the three major platforms, visit
    these links:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您在哪个操作系统上工作，如果在本书的任何命令中遇到错误消息，例如**pip/python不是内部或外部命令**，这意味着您需要在系统上配置环境变量以指向相应的文件目录。要手动配置任何三大平台上的环境变量，请访问以下链接：
- en: '• Windows: [https://phoenixnap.com/kb/windows-set-environment-variable](https://phoenixnap.com/kb/windows-set-environment-variable)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '• Windows: [https://phoenixnap.com/kb/windows-set-environment-variable](https://phoenixnap.com/kb/windows-set-environment-variable)'
- en: '• macOS: [https://phoenixnap.com/kb/set-environment-variable-mac](https://phoenixnap.com/kb/set-environment-variable-mac)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '• macOS: [https://phoenixnap.com/kb/set-environment-variable-mac](https://phoenixnap.com/kb/set-environment-variable-mac)'
- en: '• Ubuntu: [https://help.ubuntu.com/community/EnvironmentVariables](https://help.ubuntu.com/community/EnvironmentVariables)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '• Ubuntu: [https://help.ubuntu.com/community/EnvironmentVariables](https://help.ubuntu.com/community/EnvironmentVariables)'
- en: If a command is not recognized as an internal or external command, you may need
    to add the path to where that item was installed on your machine. In Windows,
    this is commonly the `Path` variable. For example, if `python` is not recognized
    as a command, add the path to where Python was installed on your machine to your
    global `Path` variable in Windows. The same applies to Linux or Mac but is most
    commonly a problem on Windows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个命令不被识别为内部或外部命令，你可能需要添加该项目安装在你机器上的路径。在Windows中，这通常是`Path`变量。例如，如果`python`不被识别为命令，请将Python安装在你机器上的路径添加到Windows的全局`Path`变量中。同样的情况也适用于Linux或Mac，但最常见的问题是在Windows上。
- en: 'All of the code created and used in this book can be found here: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    This chapter doesn''t actually dive into any code at this time. However, for those
    of you who are already familiar with Django or are new to Django who have already
    read through [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*,
    and come back to this chapter, an app called `chapter_1` is included with the
    code of this book to demonstrate a diagramming package introduced in the subsection
    titled *Entity relationship diagrams* of this chapter.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书创建和使用的所有代码都可以在这里找到：[https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer)。本章实际上并没有深入到任何代码中。然而，对于那些已经熟悉Django或者对于Django新手来说，已经阅读过[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)、“项目配置”，并返回本章，本书附带了一个名为`chapter_1`的应用程序，以展示本章标题为“实体关系图”的子节中引入的绘图包。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3OfagBj](https://bit.ly/3OfagBj).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看*代码的实际应用*：[https://bit.ly/3OfagBj](https://bit.ly/3OfagBj)。
- en: Building an enterprise
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建企业
- en: Building an **Enterprise Application Software** (**EAS**) is not an easy task
    to tackle. The task requires many different technical specialists all working
    together with a high level of collaboration and preplanning to complete. Failure
    to perform adequate planning can result in the project taking far more time and
    money than anticipated. Important features that your business model relies on
    could be left out of the equation, resulting in disruptions in everyday flow when
    a new system turns on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 构建**企业级应用软件**（**EAS**）不是一项容易的任务。这项任务需要许多不同的技术专家共同协作，进行高度的合作和预先规划才能完成。未能进行充分的规划可能导致项目花费的时间远超过预期，花费的金钱也更多。你的商业模式所依赖的重要功能可能会被忽略，当新系统启动时，这可能导致日常流程的中断。
- en: Enterprise-level software is geared toward satisfying the needs of a business
    as a whole. EAS takes all of the business logic of an organization and encompasses
    that into one system, thought of as a collection of many smaller subsystems. The
    software eliminates the need for paperwork, reduces the steps involved in completing
    a task, and provides self-automated or even artificially intelligent solutions
    to all kinds of problems in the world today. The website itself is only a small
    fraction of what the entire system actually comprises.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 企业级软件旨在满足整个企业的需求。EAS将组织的所有业务逻辑整合到一个系统中，这个系统被视为由许多较小的子系统组成的集合。该软件消除了纸质文件的需求，减少了完成任务所需的步骤，并为当今世界各种问题提供自我自动化甚至人工智能解决方案。网站本身只是整个系统实际组成部分的一小部分。
- en: Reasons to choose enterprise-level applications
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择企业级应用的理由
- en: Enterprise-level software is usually thought of as a solution for organizations
    that already have a system in place and need to improve upon that. Whether or
    not that system is something digital or a manual process, as in paper in filing
    cabinets, companies are always searching for ways to simplify everyday tasks.
    Thus, enterprise-level software can consist of one or a collection of many different
    consumer-level applications. If you need more than just a website and need a system
    that also takes on your business management tasks, you will likely need to scale
    up to the enterprise level. However, Django can still be used for the simplest
    of websites as well as large-scale projects beyond your wildest dreams. Applications
    can also be broken down into individual Django projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 企业级软件通常被认为是针对已经建立系统并需要改进的组织的一种解决方案。无论该系统是数字化的还是手工的，例如在文件柜中的纸张，公司总是在寻找简化日常任务的方法。因此，企业级软件可以由一个或多个不同的消费级应用程序组成。如果你需要的不仅仅是网站，还需要一个同时承担你的业务管理任务的系统，你可能会需要升级到企业级。然而，Django仍然可以用于最简单的网站以及超出你想象的大型项目。应用程序也可以分解为单个Django项目。
- en: Let's say you have an organization with many departments and many users, all
    consisting of different permission roles. You need a way to connect them all so
    that they may generate and share reports, send notifications, store and manage
    customer/user data, create invoices, and work with other systems. Maybe you found
    that your organization needs to connect employees working remotely from home to
    be more productive and efficient at their job. The idea is that each user type
    will interact with the system in a completely different way and even have different
    permission levels granting them access to different parts of your system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个拥有许多部门和许多用户的组织，所有这些部门和用户都由不同的权限角色组成。你需要一种方式将他们全部连接起来，以便他们可以生成和共享报告，发送通知，存储和管理客户/用户数据，创建发票，并与其他系统协同工作。也许你发现你的组织需要连接在家远程工作的员工，以便他们在工作中更加高效和高效。想法是每种用户类型将以完全不同的方式与系统交互，甚至拥有不同的权限级别，使他们能够访问你系统的不同部分。
- en: Generally speaking, when someone thinks enterprise level, they also think of
    something that is unique and custom crafted. Such software is termed **proprietary**
    or **closed-source software** and is not intended to be redistributed to the public
    by any means. However, not all EAS has to be proprietary; the distribution license
    can be set to anything you desire it to be. For example, the main system may be
    branded for one parent company and yet parts of the system may be branded for
    its subsidiaries, or copies can be distributed and rebranded per your license
    agreement. It may also be a good idea to speak with a technical lawyer to help
    write your software license agreement should your project(s) be extremely complex.
    Inviting the help of a technical lawyer at the beginning is a good way to prevent
    lawsuits later on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，当人们想到企业级时，他们也会想到一些独特且定制的产品。这类软件被称为**专有软件**或**闭源软件**，并且不打算以任何方式向公众重新分发。然而，并非所有EAS都必须是专有的；分发许可证可以设置为任何你希望的方式。例如，主系统可能为一家母公司品牌化，而系统的某些部分可能为其子公司品牌化，或者可以根据你的许可协议分发和重新品牌化副本。如果您的项目（s）极其复杂，与技术律师交谈以帮助编写您的软件许可协议也是一个好主意。在项目开始时邀请技术律师的帮助是预防诉讼的好方法。
- en: Next, we will discuss some of the major types of enterprise systems.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论一些主要的企业系统类型。
- en: Types of enterprise systems
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 企业系统类型
- en: 'There are many different kinds of enterprise-level systems but we can consolidate
    them into six major categories, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 企业级系统有很多不同的种类，但我们可以将它们归纳为以下六个主要类别：
- en: '**Customer Relationship Management** (**CRM**)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户关系管理** (**CRM**)'
- en: '**Enterprise Content Management** (**ECM**)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业内容管理** (**ECM**)'
- en: '**Enterprise Asset Management** (**EAM**)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业资产管理** (**EAM**)'
- en: '**Enterprise Resource Planning** (**ERP**)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业资源计划** (**ERP**)'
- en: '**Supply Chain Management** (**SCM**)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应链管理** (**SCM**)'
- en: '**Enterprise Information System** (**EIS**)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业信息系统** (**EIS**)'
- en: In this book, we will not actually be building any of these systems in their
    entirety. Instead, we will touch on the key Django programming concepts that,
    when combined, will get you part of the way to the end zone. Not every concept
    can fit into this book but Django is fully capable of handling all of the features
    that each of these types of systems includes. It is really up to your team to
    take on each of the rest of the concepts discussed in this book and use them as
    another tool in your toolbox when building your system. Let's discuss briefly
    what each of these six major types of enterprise-level systems is and what they
    are primarily used for.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们实际上不会完整地构建这些系统。相反，我们将涉及关键的 Django 编程概念，当它们结合在一起时，将帮助您走向终点。并非每个概念都能融入这本书，但
    Django 完全能够处理这些系统类型所包含的所有功能。真正取决于您的团队去承担这本书中讨论的其余概念，并在构建系统时将它们作为工具箱中的另一个工具使用。让我们简要地讨论一下这六种主要的企业级系统类型及其主要用途。
- en: Customer Relationship Management
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户关系管理
- en: CRM systems can typically be thought of as lead management, marketing communications,
    sales and inventory control, retail management, and so much more. The systems
    can be thought of as everything but the actual selling of products and services.
    They can even go further to include customer support and data analytics. These
    systems are designed to develop better relationships with your business partners,
    customers and potential customers, and anyone else in the equation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: CRM 系统通常可以被视为潜在客户管理、市场营销沟通、销售和库存控制、零售管理以及更多。这些系统可以被视为除了实际销售产品和服务的所有事物。它们甚至可以进一步包括客户支持和数据分析。这些系统旨在与您的商业伙伴、客户、潜在客户以及方程中的任何其他人建立更好的关系。
- en: Enterprise Content Management
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业内容管理
- en: An ECM system can best be described as a system for people working in fields
    that deal with creative and other intellectual property in some kind of way. Newspapers,
    magazines, and other news companies today have a great deal of content that they
    make available to the internet on a daily basis. A **Content Management System**
    (**CMS**) provides a less technical and rapid way to build new pages and enter
    that content onto the web. Enterprise level just means you are adding more and
    more tools to your toolbox for your organization to use.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ECM 系统最好被描述为为在处理创意和其他知识产权的领域中工作的人提供的一个系统。今天的报纸、杂志和其他新闻公司每天都会在互联网上提供大量内容。一个**内容管理系统**（**CMS**）提供了一种更不技术化和快速的方式来构建新页面并将内容上传到网络。企业级只是意味着您正在为您的组织添加越来越多的工具到工具箱中。
- en: Enterprise Asset Management
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业资产管理
- en: In an EAM system, products and inventory of all kinds can be entered into a
    system in the same way as a CMS. This is often known as an e-commerce or shopping
    cart website. It's where you make your physical goods and assets available online.
    These systems allow the tracking of inventory, project management, and document
    control, such as contracts and other legal documents. These systems may even consist
    of physical assets, such as real estate, automobiles, and music records.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 EAM 系统中，各种产品和库存可以像 CMS 一样输入到系统中。这通常被称为电子商务或购物车网站。这是您使您的实体商品和资产在网上可用的地方。这些系统允许跟踪库存、项目管理以及文档控制，如合同和其他法律文件。这些系统甚至可能包括物理资产，如房地产、汽车和音乐唱片。
- en: Enterprise Resource Planning
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业资源规划
- en: An ERP system is typically thought of as a way to manage people, the employees
    of the company, or what is commonly known as the **Human Resources** (**HR**)
    department. The system can handle on-boarding and off-boarding procedures and
    store all personnel records. It could serve as a tool for project management,
    risk assessment, and record keeping. It can even serve as a knowledge base such
    as in the form of the **Frequently Asked Questions** (**FAQs**) area. A knowledge
    base is often used to point people to and have them find common questions and
    answers in order to reduce the workload on your staff. These can also be used
    for training purposes, such as generating quizzes or asking trivia questions and
    playing tutorials.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 企业资源规划（ERP）系统通常被认为是管理公司员工，即通常所说的 **人力资源**（**HR**）部门的一种方式。该系统可以处理入职和离职程序，并存储所有人员记录。它可以作为项目管理、风险评估和记录保存的工具。它甚至可以作为一个知识库，例如以
    **常见问题解答**（**FAQs**）区域的形式。知识库通常用于引导人们找到常见的问题和答案，以减轻员工的工作负担。这些也可以用于培训目的，例如生成测验或提出趣味问题，并播放教程。
- en: Supply Chain Management
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 供应链管理
- en: SCM systems are similar to CRM and EAM systems. These are systems that manage
    inventory in every aspect of its development in the supply chain. These systems
    manage inventory on a national or even a global scale. They communicate with suppliers,
    connect to buyers, track packages, predict future supply orders, and may even
    automatically place those orders. One way to look at the difference between a
    CRM and SCM system is that a CRM is mostly used for sales and marketing while
    an SCM is mostly used for production and distribution. Both deal with products
    but in different ways and a large company or a conglomerate would need both.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 供应链管理（SCM）系统类似于客户关系管理（CRM）和企业资产管理（EAM）系统。这些系统管理供应链中其开发的各个方面。这些系统在国家级甚至全球范围内管理库存。它们与供应商沟通，连接到买家，跟踪包裹，预测未来的供应订单，甚至可以自动下订单。看待
    CRM 和 SCM 系统之间差异的一种方式是，CRM 主要用于销售和营销，而 SCM 主要用于生产和分销。两者都涉及产品，但以不同的方式，大型公司或企业集团都需要两者。
- en: Enterprise Information System
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业信息系统
- en: An EIS is a system that generally combines a CRM and SCM system to handle a
    wider range of business needs. An EIS may even integrate some or all of an ERP
    system and act as one giant central nervous system. Depending on the needs, this
    may consist of numerous databases and even numerous development projects all working
    together, comprising the brains of everything. These systems are known for storing
    and processing large volumes of data and connecting many different systems all
    together into one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 企业信息系统（EIS）是一种通常将客户关系管理（CRM）和供应链管理（SCM）系统结合起来以处理更广泛业务需求的系统。EIS 甚至可能集成 ERP 系统的一部分或全部，并作为一个巨大的中枢神经系统。根据需求，这可能会包括多个数据库甚至多个开发项目，共同工作，构成了整个系统的“大脑”。这些系统以其存储和处理大量数据以及将许多不同的系统连接在一起形成一个整体而闻名。
- en: We will now take a look at why people gravitate toward using Python and Django
    when they are building any of these enterprise-level systems. We'll see why it
    suits a variety of projects and what features it is best known for.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨为什么人们在构建这些企业级系统时倾向于使用 Python 和 Django。我们将看到为什么它适合各种项目，以及它最著名的特性是什么。
- en: Why Python/Django?
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 Python/Django？
- en: Python was created in 1991 by Guido van Rossum. He came up with the name Python
    after reading the script for *Monty Python's Flying Circus*. The language was
    created primarily for the purpose of code readability and reliability. Python
    has been growing in popularity as the preferred backend framework for several
    years now. Python plays an important role in some very popular websites today,
    such as Google, NASA, Netflix, Spotify, Uber, and Dropbox, just to name a few.
    The Python language has become desirable among many developers for its ease of
    use, quickness to learn, and overall adaptability of the code written.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言是在 1991 年由吉多·范罗苏姆（Guido van Rossum）创建的。他在阅读了 *《蒙提·派森飞行马戏团》* 的剧本后想出了
    Python 这个名字。这种语言主要是为了代码的可读性和可靠性而创建的。Python 作为首选的后端框架已经越来越受欢迎好几年了。Python 在今天的一些非常流行的网站上扮演着重要角色，例如
    Google、NASA、Netflix、Spotify、Uber 和 Dropbox，仅举几例。Python 语言因其易用性、学习速度快以及代码的整体适应性，受到了许多开发者的青睐。
- en: 'Django came into existence in late 2003 by the newspaper publisher Lawrence
    Journal-World in Lawrence, Kansas. Similar to Python, it had one goal in mind:
    to create complex database-driven websites in a simple and easy-to-read way. Along
    with readability, it was designed with rapid development and a **Don''t Repeat
    Yourself** (**DRY**) code structure in mind. Readability is why Python was chosen
    as Django''s foundation for the framework. Django is best referred to as a backend
    framework because of how it works to build and manage databases. It comes with
    many concepts built in surrounding the architecture of websites, which makes it
    appealing to most web developers.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Django于2003年底在堪萨斯州劳伦斯市的《劳伦斯日报-世界报》出版商的推动下诞生。与Python类似，它有一个目标：以简单易读的方式创建复杂的数据库驱动网站。除了可读性，它还考虑了快速开发和**不要重复自己**（**DRY**）的代码结构。可读性是选择Python作为Django框架基础的原因。由于Django在构建和管理数据库方面的作用，它最好被称为后端框架。Django内置了许多关于网站架构的概念，这使得它对大多数Web开发者都有吸引力。
- en: Many people use Django today for their backend; but the framework can also serve
    as your frontend. If you have ever used Shopify's Liquid template language, otherwise
    known as Liquid syntax, or even ASP.NET's Razor syntax and how that is used in
    conjunction with C# .NET or Visual Basic .NET, you will notice commonalities with
    the **Django template language**, which is Django's method of using Python to
    build HTML files. Django uses context when the page is rendered to serve up user-generated
    content or database-driven data onto that page. The template language syntax is
    fairly easy to read and quick to learn. Some examples of sites that use Django
    are Bitbucket, Instagram, National Geographic, Spotify, The Washington Post, and
    YouTube.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，许多人使用Django作为他们的后端；但这个框架也可以作为您的前端。如果您曾经使用过Shopify的Liquid模板语言，也称为Liquid语法，或者甚至ASP.NET的Razor语法，以及它是如何与C#
    .NET或Visual Basic .NET结合使用的，您会注意到与**Django模板语言**的相似之处，这是Django使用Python构建HTML文件的方法。Django在页面渲染时使用上下文来提供用户生成的内容或数据库驱动的数据到页面上。模板语言语法相对容易阅读且易于学习。一些使用Django的网站示例包括Bitbucket、Instagram、国家地理、Spotify、《华盛顿邮报》和YouTube。
- en: 'Django''s features include the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Django的特性包括以下内容：
- en: Caching framework
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存框架
- en: Data serialization
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据序列化
- en: Extensibility
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Form handling and validation
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单处理和验证
- en: Scalability
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Security
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Template language
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板语言
- en: Testing framework
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试框架
- en: Of these features, extensibility means that Django is built to allow easy integration
    of other third-party services. Your developers can spend more time focusing on
    the specific needs of the project versus trying to figure out how to connect your
    project to a third-party servicer's system. Django makes it easy to connect to
    virtually anything that exists today. If a functionality doesn't already come
    built in, there is usually a pip package for it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些特性中，可扩展性意味着Django被构建成允许轻松集成其他第三方服务。您的开发者可以花更多的时间专注于项目的具体需求，而不是试图弄清楚如何将项目连接到第三方服务提供商的系统。Django使得连接到今天几乎任何存在的东西变得容易。如果一个功能还没有内置，通常有一个pip包可以提供。
- en: Django does not need to be used to build only websites. It can be used to build
    an API that stands as the central hub for anything, communicating with a **REpresentational
    State Transfer** (**REST**) framework, which is a common architecture for standardizing
    communication between computer systems on the internet. From here, you can use
    any variety of common existing tools to build an iOS app for iPhones or even Android
    apps. Depending on your particular business requirements, deciding to tap into
    smartphones can be beneficial in many ways. With somewhere around 85% of Americans
    owning a smartphone today, some companies might want to build an app where a user
    can install that app on their personal phone ([https://www.pewresearch.org/internet/fact-sheet/mobile/](https://www.pewresearch.org/internet/fact-sheet/mobile/)),
    versus the company having to purchase additional hardware to distribute devices
    to all of their employees. APIs can be used for many other things as well, from
    microservices to large-scale external web systems and databases.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Django 不需要仅用于构建网站。它可以用来构建一个作为任何事物中心枢纽的 API，与 **表示状态转移**（**REST**）框架进行通信，这是一个在互联网上计算机系统间标准化通信的常见架构。从这里，你可以使用各种常见的现有工具来构建适用于
    iPhone 的 iOS 应用或 Android 应用。根据你特定的业务需求，决定利用智能手机可以以多种方式带来好处。如今，大约有 85% 的美国人拥有智能手机（[https://www.pewresearch.org/internet/fact-sheet/mobile/](https://www.pewresearch.org/internet/fact-sheet/mobile/)），一些公司可能希望构建一个用户可以在他们的个人手机上安装的应用程序，而不是公司需要购买额外的硬件来分发给所有员工。API
    还可以用于许多其他事情，从微服务到大规模的外部网络系统和数据库。
- en: Personally, when it comes to using the Django template language and a JavaScript-based
    framework such as React or Angular together, I would recommend against doing that
    as it can get far too complex to work with. If you are using React, Angular, Vue.js,
    or Handlebars.js, to name a few, to work as your frontend, then Django would just
    serve as your backend where context is served up through your API. You can still
    keep your frontend and backend files in the same Django project folder.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，当涉及到同时使用 Django 模板语言和基于 JavaScript 的框架，如 React 或 Angular 时，我建议不要这样做，因为这可能会变得过于复杂而难以处理。如果你使用
    React、Angular、Vue.js 或 Handlebars.js 等作为你的前端，那么 Django 就只是作为你的后端，通过你的 API 提供上下文。你仍然可以将你的前端和后端文件放在同一个
    Django 项目文件夹中。
- en: I have a few recommendations to help you choose. If you want to build an Android
    or iOS app or a `.html` file with jQuery, which I will discuss how to do in [*Chapter
    4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views, and Templates*. Many
    people prefer to use vanilla JavaScript so that they can write simple tasks without
    loading the entire jQuery library. When it comes to adding bells and whistles
    on the frontend of things, in all of the projects that I have worked on, I find
    that I can pretty much do everything that I need to do with just the Django template
    language and jQuery. I may be biased on this one but it is really simple to use.
    However, there are a lot of benefits of using **ECMAScript**, which is actually
    a set of international standards for building and compiling JavaScript, such as
    ES8, ES9, or ES10\. Using ECMAScript is something I should be focusing on more
    in my projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一些推荐可以帮助你选择。如果你想构建 Android 或 iOS 应用或带有 jQuery 的 `.html` 文件，我将在 [*第 4 章*](B17243_04_ePub.xhtml#_idTextAnchor116)
    “URLs、视图和模板”中讨论如何做。许多人更喜欢使用纯 JavaScript，这样他们就可以编写简单的任务而无需加载整个 jQuery 库。当涉及到在事物的前端添加装饰时，在我所参与的所有项目中，我发现我几乎可以用
    Django 模板语言和 jQuery 完成我需要做的所有事情。我可能在这方面有所偏见，但使用它确实非常简单。然而，使用 **ECMAScript** 的好处很多，实际上它是一套用于构建和编译
    JavaScript 的国际标准，如 ES8、ES9 或 ES10。在项目中更多地关注使用 ECMAScript 是我应该关注的。
- en: Tip
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'When working with Django and Python, ask your developers to adopt the **Python
    Enhancement Proposal 8** (**PEP-8**) style guide for Python code. This is an officially
    adopted formatting guide to keep code consistent among developers. This can be
    strict or relaxed. Personally, I like to choose a more relaxed version where I
    can make things a bit more broken down and readable. If you are building something
    proprietary, for internal use, it is not necessary to follow this exactly and
    you may prefer to choose a style that your team will be happy with. If you are
    building a package that will be shared publicly with anyone, I would recommend
    you follow the PEP-8 format exactly. It may actually be a requirement for submitting
    a package to the **Python Package Index** (**PyPI**) library. You can find out
    more about the official style guide here: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Django 和 Python 进行工作时，请要求您的开发人员采用 **Python 增强提案 8** (**PEP-8**) 风格指南来编写
    Python 代码。这是一份官方采用的格式化指南，用于保持开发者之间代码的一致性。这可以是严格的或宽松的。我个人喜欢选择一个更宽松的版本，这样可以使事物更加细化且易于阅读。如果您正在构建专有产品，用于内部使用，则不一定需要完全遵循此指南，您可能更喜欢选择一个团队会喜欢的风格。如果您正在构建一个将公开与任何人共享的包，我建议您严格遵循
    PEP-8 格式。实际上，这可能是在 **Python 包索引** (**PyPI**) 库中提交包的要求之一。您可以在以下链接中了解更多关于官方风格指南的信息：[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)。
- en: 'PyPI is the official repository for third-party Python package libraries both
    public and private. It''s a wonderful resource when looking for new packages to
    play around with and it provides information on how to work with the code as well:
    [https://pypi.org/](https://pypi.org/).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI 是第三方 Python 包库的官方仓库，无论是公开的还是私有的。当寻找可以尝试的新包时，它是一个极好的资源，并且还提供了如何与代码一起工作的信息：[https://pypi.org/](https://pypi.org/)。
- en: 'A package called Black can be used as a code linter to help developers make
    sure they are following PEP-8 style formatting. You can learn about Black here:
    [https://pypi.org/project/black/](https://pypi.org/project/black/).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 Black 的包可以用作代码检查器，帮助开发者确保他们遵循 PEP-8 风格格式。您可以在以下链接中了解更多关于 Black 的信息：[https://pypi.org/project/black/](https://pypi.org/project/black/)。
- en: Next, let's explore what the different types of **Application Programming Interface**
    (**API**) are and why we might need to know about these when planning for a project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探讨不同类型的 **应用程序编程接口** (**API**) 是什么，以及为什么在规划项目时我们可能需要了解这些信息。
- en: Types of APIs
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 类型
- en: An API is a means for two systems to communicate with each other through what
    are known as endpoints or a URL.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: API 是两个系统通过所谓的端点或 URL 进行相互通信的一种方式。
- en: 'We can categorize APIs into three main categories:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 API 分为三个主要类别：
- en: '![Figure 1.1 – Types of APIs'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – API 类型'
- en: '](img/Figure_1.01_B17243.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.01_B17243.jpg)'
- en: Figure 1.1 – Types of APIs
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – API 类型
- en: In the following sections, we will discuss what each of these API types is and
    what they are used for. Depending on the requirements of the project, we may need
    to choose one or the other as a type of system that we want to build.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论每种 API 类型是什么，以及它们用于什么。根据项目的需求，我们可能需要选择其中一种作为我们想要构建的系统类型。
- en: Open APIs
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开放 API
- en: '`GET`, `POST`, `PUT`, `PATCH`, and `DELETE` requests coming to and from your
    system.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 来自和前往您系统的 `GET`、`POST`、`PUT`、`PATCH` 和 `DELETE` 请求。
- en: Partner APIs
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合作 API
- en: '**Partner APIs** are commonly found in business-to-business relationships.
    The general public cannot gain access and permission is only granted to strategic
    partners who need to use your API in order to do business with you. Limitations
    can be defined depending on your agreements with each party. These are fairly
    common in the world today when business mergers occur and your team is tasked
    with making two external systems communicate with each other. Sometimes, you have
    to build a central database in between the two existing systems for various reasons,
    such as your business model is based on granting access to your API in order for
    companies to sell their goods on your platform. A common example of this is the
    Amazon **Selling Partner API** (**SP-API**), which is used for selling goods on
    the Amazon Marketplace.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**合作伙伴API**通常在商业对商业关系中找到。公众无法获得访问权限，只有需要使用你的API与你进行业务往来的战略合作伙伴才会被授予许可。可以根据与每一方的协议定义限制。在当今世界，当发生企业合并并且你的团队被要求使两个外部系统相互通信时，这些相当常见。有时，你可能需要出于各种原因（例如，你的商业模式基于授予公司访问你的API以便在平台上销售商品）在两个现有系统之间建立一个中央数据库。一个常见的例子是亚马逊的**销售合作伙伴API**（**SP-API**），它用于在亚马逊市场上销售商品。'
- en: Private APIs
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有API
- en: '**Private APIs** are the most secure; these APIs are locked down because they
    are intended to be used internally by that company or organization only. Large
    financial institutions or corporate retail entities may use these to manage any
    aspect of their internal functions. The public and any other external sources
    may not be granted access unless a specific need for it is warranted. Common examples
    are government organizations using APIs to connect to systems that keep legal
    records and documents. Another example could be a university granting an educational
    department access to student and class records.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有API**是最安全的；这些API被锁定，因为它们仅打算由该公司或组织内部使用。大型金融机构或企业零售实体可能使用这些API来管理其内部功能的任何方面。除非有特定的需求，否则公众和其他外部来源可能无法获得访问权限。常见的例子是政府机构使用API连接到保存法律记录和文件的系统。另一个例子可能是大学授予教育部门访问学生和课程记录的权限。'
- en: By now, we have brushed up on what enterprise-level software is, in terms of
    what types of enterprise-level systems exist today and how we can classify them.
    We also discussed how Python and Django play a role in enterprise-level software.
    Now that we have learned about these various concepts, let's begin designing and
    planning for a project of our own.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经了解了企业级软件是什么，包括目前存在哪些类型的企业级系统以及我们如何对它们进行分类。我们还讨论了Python和Django在企业级软件中的作用。现在我们已经学习了这些各种概念，让我们开始设计和规划我们自己的项目。
- en: Designing and planning
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和规划
- en: Every project, however big or small, needs a clear plan for what it is and how
    it will be built. The larger the project, the more work should be put into the
    beginning phase of preparing for development. It is no surprise that enterprise-level
    development should also require a great deal of preliminary work before actual
    development begins. Whether you are working for a company or are a company providing
    a solution to a client, you should have a clear plan of what needs to be done.
    There is a lot of flexibility here based on factors such as cost, lack of developers,
    and deadlines. Prepare as much as possible and try to stick to the timelines that
    are set to keep you on track to completion. Remember that too little planning
    could come back to haunt you later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 任何项目，无论大小，都需要一个清晰的计划来明确其目标和构建方式。项目越大，在开发准备阶段投入的工作就越多。企业级开发在真正开始之前也需要大量的前期工作，这并不奇怪。无论你是为公司工作还是作为公司向客户提供解决方案，都应该有一个明确的行动计划。这取决于诸如成本、开发者短缺和截止日期等因素，有很大的灵活性。尽可能做好准备，并尽量遵守设定的时间表，以确保你能够按计划完成。记住，规划不足可能会在以后给你带来麻烦。
- en: Developers should be given as much information as possible to help them understand
    what they are building. If your developers are not provided with enough documentation,
    blueprints, and other materials, then they will be left to make assumptions on
    their own, assumptions that later on are found in the testing and **Quality Assurance**
    (**QA**) phases of development as bugs in your application. When this happens,
    you may discover that a particular feature needs to be rebuilt, requiring major
    foundational changes that will take a great deal of time to refactor. If we think
    about something other than programming for a moment, such as building a house,
    we all know a foundation needs to be built before a team can frame the house.
    In turn, that foundation needs to be completed before a team can build the roof,
    wire up the electrics, install plumbing, and so on. You can't start building a
    roof without a frame, and you can't build a frame without a foundation to put
    it on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应该尽可能多地获得信息，以帮助他们理解他们正在构建的内容。如果你的开发者没有提供足够的文档、蓝图和其他材料，那么他们就会自己做出假设，这些假设后来在开发和**质量保证**（**QA**）阶段的测试中作为应用程序中的错误被发现。当这种情况发生时，你可能会发现某个特定功能需要重新构建，这需要重大的基础性变更，这将花费大量时间进行重构。如果我们暂时不考虑编程以外的其他事情，比如建造房屋，我们都知道在团队可以建造房屋框架之前，需要先建造地基。相应地，这个地基需要完成，然后团队才能建造屋顶，安装电线，安装管道等等。没有框架，你不能开始建造屋顶，没有可以放置框架的地基，你不能建造框架。
- en: Let's discuss how to gather requirements for your project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何收集你们项目的需求。
- en: Requirements gathering
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求收集
- en: Gathering requirements is important to help document the build process and to
    allow both parties, the developer and the owner of the software, to reference
    it at any time during development. This ability is essential in order to ensure
    things stay on track until completion and are also completed on time. There should
    be an initial brainstorming phase to get a feel for the scope of the project.
    One good trick is to have all the stakeholders get together and debate the needs
    of the system, while you record any key points raised during the debate and include
    them in your requirements findings. You should always start by asking questions,
    and you should ask alternate questions for different sets of people. After you
    have spoken to stakeholders, move on to directors, project managers, developers,
    and employees, known as end users. Interview as many different types of users
    as possible. For extremely large entities, you could create a questionnaire, distribute
    that questionnaire to a number of users, and then come to a conclusion based on
    the results.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 收集需求对于帮助记录构建过程以及允许双方，即软件开发者和软件所有者，在开发过程中随时参考它来说非常重要。这种能力对于确保事情按计划进行直到完成，并且按时完成也是必不可少的。应该有一个初步的头脑风暴阶段，以了解项目的范围。一个很好的技巧是让所有利益相关者聚集在一起，辩论系统的需求，同时记录辩论中提出的任何关键点，并将它们纳入你的需求发现中。你应该始终从提问开始，并且你应该为不同的人群提出不同的问题。在与利益相关者交谈之后，继续与总监、项目经理、开发人员和员工，即最终用户交谈。尽可能多地采访不同类型的用户。对于极其庞大的实体，你可以创建一份问卷，将问卷分发给许多用户，然后根据结果得出结论。
- en: If there is a legacy system currently in place, even if it's a manual versus
    digital process of some kind, you should try and get a feel for how it works and
    identify any pain points within that process. My favorite tactic is **User Observation**,
    where I watch a user as they go through the flow of an everyday task and then
    try to identify things that may slow them down. The next thing I would do is try
    **Role Playing** , which is a method where you jump in and use the system as a
    user would perform a task. You could also ask two different kinds of users to
    swap positions and ask them what was easy or hard about doing the other person's
    task or what they think could improve the workflow. There must be bottlenecks
    of some kind or else there wouldn't be a need to build something better. These
    are things that bog down your everyday tasks and end up costing the company a
    lot of money in terms of time and resources. You need to keep an eye open and
    identify the pain points that your client could not identify themselves or they
    will have a difficult time communicating with you. Your client won't always know
    the best solution to a problem, and they may not even know a particular problem
    is even a problem until you reveal a way to improve that process for them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目前有一个遗留系统正在运行，即使它是一种手动与数字流程相结合的过程，你也应该尝试了解它是如何工作的，并确定该流程中的任何痛点。我最喜欢的策略是**用户观察**，即我观察用户完成日常任务的流程，然后尝试识别可能使他们减速的事情。接下来，我会尝试**角色扮演**，这是一种你跳入并像用户一样执行任务的策略。你也可以让两种不同类型的用户交换位置，询问他们完成对方任务容易或困难的地方，或者他们认为可以改进工作流程的地方。肯定存在某种类型的瓶颈，否则就没有必要构建更好的东西。这些都是拖慢你日常任务的事情，最终导致公司在时间和资源上花费大量金钱。你需要保持警觉，并识别出你的客户自己无法识别的痛点，或者他们将与你的沟通困难。你的客户不一定知道问题的最佳解决方案，他们甚至可能不知道某个特定问题是一个问题，直到你揭示了一种改善该流程的方法。
- en: Research and discovery
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 研究和发现
- en: 'Find out whether this will be an internal, partner, or public project. If it
    is a partner project, you may have certain limitations based on the partner''s
    specific needs. This is when we get into the difference between **business requirements**
    and **functional requirements**. Functional requirements are things such as determining
    what hosting plan and server to live on, a backend framework, a frontend framework,
    and a set of pages. Business requirements, on the other hand, encompass the vision,
    goals, and objectives of the business as a whole. They are specific to the needs
    of the organization or the partners they are working with. The structure of a
    set of web pages or API endpoints may be defined by the business model of that
    company versus some other logical reason that may otherwise be chosen. Do your
    stakeholders have any goals, suggestions, or requests that you need to consider?
    Here are 15 common questions that can help you formulate your set of questions.
    You shouldn''t limit yourself to just these questions alone; use them for brainstorming:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 查找这将是一个内部、合作伙伴还是公开项目。如果是合作伙伴项目，你可能会有基于合作伙伴特定需求的某些限制。这时，我们就进入了**业务需求**和**功能需求**之间的差异。功能需求包括确定要居住在哪个托管计划和服务器的服务器，后端框架，前端框架和一组页面。另一方面，业务需求涵盖了整个企业的愿景、目标和目标。它们是特定于组织或他们与之合作的合作伙伴的需求。一组网页或API端点的结构可能是由该公司的商业模式定义的，而不是其他可能被选择的某些逻辑原因。你的利益相关者是否有任何目标、建议或请求需要你考虑？以下是一些可以帮助你制定问题集的常见问题。你不应该仅限于这些问题本身；用于头脑风暴：
- en: Do you have business-specific requirements?
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有特定的业务需求？
- en: Why do you need a new system?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你为什么需要一个新系统？
- en: What does your current system prevent you from doing; are there any bottlenecks?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的当前系统阻止了你做什么；是否存在任何瓶颈？
- en: What new features would you like to add; do you need any improvements?
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想添加哪些新功能；你需要任何改进吗？
- en: What old features would you like to keep or remove?
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想保留哪些旧功能，或者要移除哪些？
- en: Who will you interact with in the system; what types of users and roles?
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将在系统中与谁互动；有哪些类型的用户和角色？
- en: Will you need reporting, email messaging, or any other kind of notification
    system?
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要报告、电子邮件消息或其他类型的通知系统吗？
- en: Will the system connect with any third-party or partner systems in any way?
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统将以任何方式与任何第三方或合作伙伴系统连接吗？
- en: What kind of traffic or load on the server are we predicting?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们预测的服务器上的流量或负载是什么样的？
- en: When does this new system need to be operational?
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个新系统何时需要投入运行？
- en: What kind of budget have you allocated toward completing this project?
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您为完成此项目分配了多少预算？
- en: Will data need to be migrated from the old system to the new system?
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要将数据从旧系统迁移到新系统？
- en: How will development be divided up among the development team members?
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队成员之间的发展如何分配？
- en: What skills does the development team have; what are the team's strengths and
    weaknesses?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队有哪些技能；团队的优势和劣势是什么？
- en: How should the **User Interface** (**UI**) flow work; should it be multipage
    or single page?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面（**UI**）的流程应该如何工作；应该是多页还是单页？
- en: Decision making
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决策
- en: From the common questions listed previously, you can formulate dozens, if not
    hundreds, of other questions to fit your unique set of needs. Then, these questions
    can be grouped into several categories of development, each category with a unique
    set of requirements and guidelines. You will want to focus heavily on usability,
    data migration, performance, security, scalability, and reliability. It's good
    to know this information beforehand so that you can choose the best direction
    that your development should move forward with.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前列出的常见问题中，您可以制定数十个甚至数百个其他问题来满足您独特的需求集。然后，这些问题可以分组到几个开发类别中，每个类别都有独特的一套要求和指南。您将非常重视可用性、数据迁移、性能、安全性、可扩展性和可靠性。提前了解这些信息是很好的，这样您就可以选择最佳的方向，让您的开发继续前进。
- en: These will be decisions such as what frontend framework you will choose, who
    you will go to for hosting, whether you will be building your own servers or renting
    space at a data center in the cloud, and how your server will be configured. There
    are countless possibilities to consider. When it comes to the UI, there is a number
    of questions that need to be asked regarding form field layout, form field validation
    (server side and client side or both), placeholders, labeling placement, and the
    flow from start to finish. Flow here refers to whether the user should complete
    part or all of a form before proceeding and/or whether those parts should be included
    in a separate form.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决策可能包括您将选择哪个前端框架，您将向谁寻求托管服务，您是构建自己的服务器还是在云数据中心租用空间，以及您的服务器将如何配置。有无数的可能性需要考虑。当涉及到UI时，有许多关于表单字段布局、表单字段验证（服务器端、客户端或两者都进行）、占位符、标签位置以及从开始到结束的流程的问题需要询问。这里的流程指的是用户在继续之前是否应该完成部分或全部表单，以及这些部分是否应该包含在单独的表单中。
- en: Keep in mind that when it comes to form field validation, Django will only validate
    your data on the server side. Your project does not need both server- and client-side
    form field validation. However, a healthy website will implement both. So, when
    a postback error occurs, anomalies will emerge, such as not displaying your form
    or the field errors that are present, if your form is not visible when the page
    first loads, for example, when a user needs to scroll down really far on the page
    or perform several actions before the form becomes visible to the user. Client-side
    form field validation solves this problem by checking for data to be valid before
    it is sent to the server, known as **data integrity**. This validation also reduces
    work for the server to process and provides for event handling, letting you write
    functions to help you format HTML and CSS on your page. When it comes to decision
    making, you can choose whether or not field validation will take place on the
    client side or the server side, or both. If client-side validation will take place,
    then you can choose what tools will be used, which are usually JavaScript based.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当涉及到表单字段验证时，Django 只会在服务器端验证您的数据。您的项目不需要同时进行服务器端和客户端的表单字段验证。然而，一个健康的网站将实施两者。因此，当发生回发错误时，会出现异常，例如，如果您的表单在页面首次加载时不可见，例如，当用户需要向下滚动很远或执行几个操作才能使表单对用户可见时，您的表单可能不会显示或出现字段错误。客户端表单字段验证通过在将数据发送到服务器之前检查数据是否有效来解决此问题，这被称为**数据完整性**。这种验证还可以减少服务器处理的工作量，并提供了事件处理，让您可以编写函数来帮助您在页面上格式化HTML和CSS。在决策方面，您可以选择是否在客户端或服务器端进行字段验证，或者两者都进行。如果将在客户端进行验证，那么您可以选择使用哪些工具，这些工具通常基于JavaScript。
- en: 'For example, take input attributes such as `required`, `minlength`, and `maxlength`,
    which can exist in your HTML. These are usually generated by Django when rendering
    form fields that have specific field arguments set, such as the following example.
    We will discuss rendering forms in detail in [*Chapter 5*](B17243_05_ePub.xhtml#_idTextAnchor152),
    *Django Forms*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑输入属性，如`required`、`minlength`和`maxlength`，这些可以在你的HTML中存在。这些通常是由Django在渲染具有特定字段参数的表单字段时生成的，如下面的示例所示。我们将在[*第5章*](B17243_05_ePub.xhtml#_idTextAnchor152)中详细讨论渲染表单，*Django表单*：
- en: '[PRE0]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most browsers will natively restrict a user from submitting a form if these
    attributes are present and the data does not satisfy them. All browsers will handle
    and style these error states differently from one another as well, like Mac versus
    Windows or Chrome versus Safari. The reason for this is that they are developed
    by separate entities competing against each other in the market and as a result
    have different branding. This difference hinders the ability of Django to serve
    up a postback displaying the error message that was defined in your code for that
    field. If for some reason the user is able to submit a form with invalid data,
    the postback may not display the form if, as I mentioned previously, the form
    is hidden from sight on page load. This is why your project may require both client-
    and server-side form validation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器会默认限制用户提交表单，如果这些属性存在且数据不满足它们的要求。所有浏览器也会以不同的方式处理和样式化这些错误状态，比如Mac与Windows或Chrome与Safari之间的差异。这是因为它们是由不同的实体开发的，它们在市场上相互竞争，因此有不同的品牌。这种差异阻碍了Django显示你代码中为该字段定义的错误消息的postback功能。如果由于某种原因，用户能够提交包含无效数据的表单，那么如果，正如我之前提到的，表单在页面加载时被隐藏，那么postback可能不会显示表单。这就是为什么你的项目可能需要客户端和服务器端表单验证的原因。
- en: 'Handling error state messages between your server-side code where you define
    your form fields and your client-side implementation can be tricky as well, meaning
    you have to store the same error message in two different locations within your
    source code: one for server-side validation and one for client-side validation.
    Over time, and with many different developers, this will get very messy, especially
    when someone remembers to change one but not the other when edits, additions,
    or deletions are made to these messages. If you have a strict need to make sure
    they are both worded exactly the same, it might be necessary to create a data
    dictionary that your source files could access, allowing you to put all your error
    messages in one spot. How you do that will take some thinking. This file will
    also need to be accessible via both Python and JavaScript.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的服务器端代码（你定义表单字段的地方）和客户端实现之间处理错误状态消息可能也很棘手，这意味着你必须在源代码中的两个不同位置存储相同的错误消息：一个用于服务器端验证，一个用于客户端验证。随着时间的推移和许多不同的开发者，这会变得非常混乱，尤其是在有人记得更改其中一个但忘记更改另一个时，这些消息被编辑、添加或删除。如果你有严格的必要性确保它们措辞完全相同，可能需要创建一个数据字典，你的源文件可以访问它，这样你就可以把所有的错误消息放在一个地方。如何做到这一点需要一些思考。这个文件也需要通过Python和JavaScript都可以访问。
- en: Visualization and interpretation
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化和解释
- en: When it comes to the actual design of how the UI will look, there is a number
    of factors involved. Large corporations may have specific branding guidelines
    that they mandate for marketing and other legal reasons that can restrict the
    overall design of your frontend. Sometimes, these corporations will have an in-house
    creative and marketing department or they may outsource to a third-party creative
    company to mock up a set of Illustrator or Photoshop documents to assist your
    frontend developers in doing their jobs. For smaller projects, you are free to
    design something yourself, but that often takes up time and developers often experience
    a type of writer's block when tasked with actually designing something versus
    building something.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到UI的实际设计时，涉及的因素有很多。大型企业可能有一些特定的品牌指南，它们出于营销和其他法律原因强制执行，这可能限制了你的前端整体设计。有时，这些公司可能有一个内部创意和营销部门，或者他们可能外包给第三方创意公司，以制作一系列Illustrator或Photoshop文档，以帮助你的前端开发者完成工作。对于较小的项目，你可以自由地设计一些东西，但这通常需要时间，开发者们在被要求设计某物而不是构建某物时，经常会遇到一种写作障碍。
- en: One big misconception about frontend developers is that everyone automatically
    assumes they are designers, which is not always the case. Similar to how a construction
    worker reads blueprints to build a house, someone else usually drafts the blueprints
    for them. For this reason, you can use open source templates and boilerplates
    in the form of HTML, CSS/SCSS, or even JavaScript from online suppliers such as
    Envato Market, formerly known as ThemeForest ([https://themeforest.net/](https://themeforest.net/)),
    or Nicepage ([https://nicepage.com/html-templates](https://nicepage.com/html-templates)).
    I have resorted to using design templates from sources such as these in my own
    Django projects before. Each of these templates and template providers is different.
    Some are free, while others can be used for a price, and usage licenses vary.
    Independent research will have to be done on your part before deciding whether
    any of these sources can work for you. These design templates may also require
    a bit of digging around in order to make sure they fit in your project nicely,
    but they can still save a lot of time and provide a stylish-looking site that
    may be far better than what someone who lacks a creative eye for designing something
    from nothing could create for you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前端开发者的一大误解是，人们普遍认为他们都是设计师，这并不总是事实。就像建筑工人阅读蓝图来建造房屋一样，其他人通常为他们绘制蓝图。因此，您可以使用来自在线供应商（如Envato
    Market，原名ThemeForest ([https://themeforest.net/](https://themeforest.net/))）或Nicepage
    ([https://nicepage.com/html-templates](https://nicepage.com/html-templates)）等处的开源模板和脚手架，这些模板可以是HTML、CSS/SCSS，甚至是JavaScript。在我自己的Django项目中，我之前也求助于这些来源的设计模板。这些模板和模板提供商各不相同。有些是免费的，而有些则需要付费使用，并且使用许可证各不相同。在决定这些来源中的任何一个是否适合您之前，您需要进行独立研究。这些设计模板可能还需要一些挖掘，以确保它们与您的项目很好地配合，但它们仍然可以节省大量时间，并提供一个看起来很时尚的网站，这可能比那些缺乏从无到有设计创意的人为您创造的更好。
- en: Many of these HTML, CSS, and JavaScript templates may resort to the use of the
    **Node Package Manager** (**NPM**) for you to build source files into production-ready
    files. Similar to PyPI, NPM is used to store and distribute JavaScript libraries
    that are used in development. They rely on Node.js to run them. There are even
    pip packages that you can use within your Django project to help you build source
    files using an NPM package. I will discuss managing pip packages and dependencies
    further in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*.
    There is a number of Python packages that can help you transpile SCSS, auto-prefix,
    bundle, and minify files. I have played around with a lot of different Python
    packages and out of them, I have found only a select few resorting to the use
    of NPM to do the heavy lifting at the end of the day. This means, as a requirement
    for your project, your developers may need to have NPM installed on their machine
    or even on their server depending on how you want to use Node.js. For the examples
    in this book, I will gravitate toward Python packages as much as possible and
    you are free to integrate these into your project as you see fit. I'll try to
    avoid going into code examples pertaining to NPM packages, but I encourage you
    to use the packages in your development environments.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些HTML、CSS和JavaScript模板可能会使用**Node包管理器**（**NPM**）来将源文件构建成生产就绪文件。类似于PyPI，NPM用于存储和分发开发中使用的JavaScript库。它们依赖于Node.js来运行。甚至还有可以在您的Django项目中使用的pip包，以帮助您使用NPM包构建源文件。我将在[*第二章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*中进一步讨论管理pip包和依赖关系。有许多Python包可以帮助您转换SCSS、自动添加前缀、打包和压缩文件。我尝试过很多不同的Python包，最终只发现少数几个在最后阶段会使用NPM来完成繁重的工作。这意味着，作为您项目的要求，您的开发人员可能需要在他们的机器上甚至服务器上安装NPM，具体取决于您如何使用Node.js。对于本书中的示例，我将尽可能使用Python包，您可以根据自己的需要将这些包集成到您的项目中。我会尽量避免涉及NPM包的代码示例，但我鼓励您在开发环境中使用这些包。
- en: Tip
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The latest and most stable version of Node.js and NPM can be found here: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    For Windows users, there is an easy-to-use installer file that will install both
    Node.js and NPM for you.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和NPM的最新和最稳定版本可以在这里找到：[https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    对于Windows用户，有一个易于使用的安装文件，可以为您安装Node.js和NPM。
- en: 'You can find the Gulp installation guide here: [https://gulpjs.com/docs/en/getting-started/quick-start/](https://gulpjs.com/docs/en/getting-started/quick-start/).
    Gulp requires that the Gulp **Command-Line Utility** (**CLI**) is installed first,
    then install Gulp itself. Gulp is considered a task runner and helps to automate
    a vast majority of development tasks, such as SCSS transpiling, CSS linting, vendor
    prefixing, minification, and bundling; ECMAScript compiling; and other code linting.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到Gulp安装指南：[https://gulpjs.com/docs/en/getting-started/quick-start/](https://gulpjs.com/docs/en/getting-started/quick-start/)。Gulp要求首先安装Gulp
    **命令行工具**（**CLI**），然后安装Gulp本身。Gulp被认为是一个任务运行器，有助于自动化大多数开发任务，如SCSS转译、CSS代码检查、供应商前缀、压缩和打包；ECMAScript编译；以及其他代码检查。
- en: 'Designing doesn''t mean how the project should look; the process should also
    focus on how it will work or rather the nuts and bolts of the engine. When it
    comes to designing a project, use as many diagrams as possible to visualize each
    process. Visualization can be broken down into two main categories: **Behavioral
    Diagraming** and **Structural Diagraming**. Once you have created a set of diagrams,
    those can be used for collaboration with your stakeholders to ensure that you
    have everything needed. Your developers will also use these as blueprints for
    what they will be building.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 设计并不意味着项目应该如何看起来；过程也应该关注它将如何工作，或者更确切地说，是引擎的螺丝和螺母。在设计项目时，尽可能多地使用图表来可视化每个过程。可视化可以分为两大类：**行为图表**和**结构图表**。一旦你创建了一套图表，就可以用来与利益相关者协作，确保你拥有所需的一切。你的开发者也会将这些作为他们将要构建的蓝图。
- en: 'There are many different diagram types in the **Unified Modeling Language**
    (**UML**), as listed here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在**统一建模语言**（**UML**）中有很多不同的图表类型，如以下所示：
- en: Activity diagram
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动图表
- en: Class diagram
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类图表
- en: Communication diagram
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信图表
- en: Component diagram
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件图表
- en: Composite diagram
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合图表
- en: Deployment diagram
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署图表
- en: Entity relationship diagram
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体关系图表
- en: Flowchart
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程图
- en: Interaction diagram
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互图表
- en: Object diagram
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象图表
- en: Package diagram
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包图表
- en: Profile diagram
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置图表
- en: Sequence diagram
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列图表
- en: State diagram
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态图表
- en: Timing diagram
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间图表
- en: Use case diagram
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例图表
- en: Discussing each of these diagrams in depth can be rather lengthy. In the following
    subsections, we will discuss only six of the most commonly used diagrams today
    and how they can help you build a project of any size and type.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 深入讨论这些图表可能会相当冗长。在以下小节中，我们将仅讨论目前最常用的六种图表以及它们如何帮助你构建任何规模和类型的项目。
- en: Class diagrams
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类图表
- en: A class diagram is used to illustrate the different classes or components of
    a system and how they relate to each other. A class is best known as a group of
    objects with shared or similar roles within your system. Similar to an **Entity
    Relationship Diagram** (**ERD**), class diagrams depict the objects that would
    be tables in a database, the interactions that could take place, and any other
    main elements of your system. This diagram is usually structured in a way where
    the top compartment is the class name, the middle compartment contains all the
    attributes, also known as the fields, and the bottom compartment shows any functions
    or actions that could take place.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类图表用于说明系统中的不同类或组件以及它们之间的关系。类最著名的是在系统中具有共享或相似角色的对象集合。类似于**实体关系图**（**ERD**），类图表描绘了在数据库中将是表的对象，可能发生的交互，以及系统中的任何其他主要元素。此图表通常以这样的方式构建，即顶部部分是类名，中间部分包含所有属性，也称为字段，底部部分显示可能发生的任何函数或操作。
- en: 'The following figure shows the relationship between a user, team, and award.
    The class diagram shows how a team can have a collection of users and a team may
    also have a collection of awards issued to them. In this example, awards are given
    to teams and not individual users themselves. A `Team` model object can have a
    function called `getAwards()`, where it will get a collection of all the awards
    that the team has earned:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了用户、团队和奖项之间的关系。类图表显示了团队可以拥有用户集合，一个团队也可能拥有授予他们的奖项集合。在这个例子中，奖项是授予团队的，而不是授予个人用户。`Team`模型对象可以有一个名为`getAwards()`的函数，它将获取团队所赢得所有奖项的集合：
- en: '![Figure 1.2 – Class diagram'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – 类图表'
- en: '](img/Figure_1.02_B17243.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.02_B17243.jpg)'
- en: Figure 1.2 – Class diagram
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 类图表
- en: Deployment diagrams
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署图表
- en: 'A deployment diagram is used for high-level planning. This is how developers
    will collaborate and code will be updated between different environments. Network
    engineers will use the diagram to map out physical nodes that will be used within
    their configuration. Developers will use it to have a better understanding of
    how code will update between different environments and where they may need to
    push or pull that code to and from when updates need to be made. The primary components
    of a deployment diagram include artifacts, devices, and nodes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 部署图用于高级规划。这是开发者之间如何协作以及代码将在不同环境之间更新的方式。网络工程师将使用该图来绘制其配置中将使用的物理节点。开发者将使用它来更好地理解代码如何在不同的环境之间更新，以及当需要更新时，他们可能需要将代码推送到或从何处拉取。部署图的主要组件包括工件、设备和节点：
- en: An artifact is a digital asset, such as a file or an executable script of some
    kind.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工件是一种数字资产，如文件或某种可执行脚本的类型。
- en: A device is a node that represents a computational resource, such as the application
    server or the domain server.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备是一个代表计算资源（如应用服务器或域名服务器）的节点。
- en: A node is a physical entity that executes a component, subsystem, or process.
    Nodes can comprise a physical hardware component or a virtual, cloud-based component.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点是一个执行组件、子系统或过程的物理实体。节点可以包括物理硬件组件或基于虚拟云的组件。
- en: Entity relationship diagrams
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体关系图
- en: An ERD visualizes the relationships between objects within your system. It's
    best used for mapping how different tables are linked within a database and is
    sometimes called an entity relationship model after modeling relationships in
    a database. These are used by your backend to help create the structure of the
    database and what fields should be included. On the other hand, these can be created
    by accessing existing databases to help map the current structure of a system
    and help you to see how best to rebuild it. It's like accessing blueprints of
    an existing building. Auto-generating these can mean they are so accurate that
    they even tell you about renovations done to that building after those initial
    blueprints were first drafted.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ERD可视化系统内对象之间的关系。它最适合映射数据库中不同表之间的链接，有时在数据库中建模关系后被称为实体关系模型。这些由您的后端用于帮助创建数据库的结构以及应包含哪些字段。另一方面，这些可以通过访问现有数据库来创建，以帮助映射系统的当前结构，并帮助您看到如何最好地重建它。这就像访问现有建筑的蓝图。自动生成这些可以意味着它们非常准确，甚至可以告诉您在那些初始蓝图首次起草之后对那座建筑进行的翻新。
- en: There are many ways to automatically generate an ERD. I'll share with you two
    of my favorite ways to go about doing that, assuming you already have a Django
    project up and running when reading and following along with this chapter. If
    not, I explain how to start a Django project from scratch as well as how to install
    the pgAdmin tool in the next chapter, [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. The first way is with pgAdmin, which is a popular database
    tool used by Django developers today for working with PostgreSQL databases. This
    is very easy if you are using the most recent version of pgAdmin; older versions
    do not have this feature. The current version of pgAdmin, as of the time of writing
    this book, is v5.6\. Just right-click on the database for which you want to generate
    a diagram and click **Generate ERD**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成实体关系图（ERD）有许多方法。当您阅读并跟随本章内容时，我将与您分享我最喜欢的两种方法，假设您已经有一个Django项目正在运行。如果没有，我将在下一章解释如何从头开始创建Django项目，以及如何安装pgAdmin工具，[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*。第一种方法是使用pgAdmin，这是Django开发者今天用于与PostgreSQL数据库一起工作的流行数据库工具。如果您使用的是pgAdmin的最新版本，这将非常简单；旧版本没有这个功能。截至本书编写时，pgAdmin的当前版本是v5.6。只需右键单击您想要生成图例的数据库，然后点击**生成ERD**。
- en: '![Figure 1.3 – Generate ERD with pgAdmin'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 使用pgAdmin生成ERD'
- en: '](img/Figure_1.03_B17243.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.03_B17243.jpg)'
- en: Figure 1.3 – Generate ERD with pgAdmin
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 使用pgAdmin生成ERD
- en: The second way is using a popular command-line tool called `django-extensions`.
    This is the example where I have provided a Django app called `chapter_1` with
    the code provided with this book for people who are already familiar with Django.
    You can run these examples in your existing project. For people new to Django,
    it is recommended to skip to the next subsection of this chapter, titled *Flowcharts*,
    and then come back and practice using this package after you have worked through
    the examples provided in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*, to configure your project for the very first time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用一个流行的命令行工具，名为 `django-extensions`。这是一个例子，我为已经熟悉 Django 的人提供了一个名为 `chapter_1`
    的 Django 应用程序，并附上了本书提供的代码。你可以在现有的项目中运行这些示例。对于 Django 新手，建议跳到本章的下一小节，标题为 *流程图*，然后在完成
    [*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037) 中提供的示例后，再回来练习使用这个包来首次配置你的项目。
- en: 'To install the `django-extensions` package on an existing Django project, follow
    these steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要在现有的 Django 项目上安装 `django-extensions` 包，请按照以下步骤操作：
- en: 'Run the following command:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE2]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In your `settings.py` file, add this app to your `INSTALLED_APPS` variable:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `settings.py` 文件中，将此应用程序添加到你的 `INSTALLED_APPS` 变量中：
- en: '[PRE3]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will also need to install a diagram generator that will draw the diagram
    for you. This is done using the `pydotplus` pip package:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要安装一个图表生成器，它会为你绘制图表。这是通过 `pydotplus` pip 包完成的：
- en: '[PRE4]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, you can run the following command to generate all of the tables:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以运行以下命令来生成所有表格：
- en: '[PRE5]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Specific models can be targeted, or a set of models can be targeted, separated
    by a comma with no spaces. In the following example, we are targeting the `User`,
    `Team`, and `Award` models:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可以针对特定的模型，或者可以针对一组模型，通过逗号分隔，没有空格。在以下示例中，我们针对的是 `User`、`Team` 和 `Award` 模型：
- en: '[PRE6]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following diagram was auto-generated by running the last command, generating
    the `User`, `Team`, and `Award` models and their relationships with one another:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是通过运行最后一个命令自动生成的，生成了 `User`、`Team` 和 `Award` 模型及其相互关系：
- en: '![Figure 1.4 – ERD from Graph Models'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 来自图模型的 ERD'
- en: '](img/Figure_1.04_B17243.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.04_B17243.jpg)'
- en: Figure 1.4 – ERD from Graph Models
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 来自图模型的 ERD
- en: For a complete breakdown of how to use the Graph Models plugin, go to [https://django-extensions.readthedocs.io/en/latest/graph_models.html](https://django-extensions.readthedocs.io/en/latest/graph_models.html).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解如何使用 Graph Models 插件，请访问 [https://django-extensions.readthedocs.io/en/latest/graph_models.html](https://django-extensions.readthedocs.io/en/latest/graph_models.html)。
- en: Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For Windows users, you will also need to install the GraphViz application on
    your computer for the `graph_models` command to work. Also, select **Add Graphviz
    to the system PATH** for all or current users when performing the install: [https://graphviz.org/download/](https://graphviz.org/download/).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，你还需要在你的计算机上安装 GraphViz 应用程序，以便 `graph_models` 命令能够工作。在安装过程中，请选择
    **将 Graphviz 添加到系统 PATH** 以供所有或当前用户使用：[https://graphviz.org/download/](https://graphviz.org/download/)。
- en: There is also an installer for Linux, Mac, and Solaris operating systems. GraphViz
    may also be required to generate these diagrams on those operating systems. If
    you are experiencing errors running the preceding commands on Linux, Mac, or Solaris,
    try installing GraphViz on your system.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 还有适用于 Linux、Mac 和 Solaris 操作系统的安装程序。在这些操作系统上生成这些图表可能也需要 GraphViz。如果你在 Linux、Mac
    或 Solaris 上运行前面的命令时遇到错误，请尝试在你的系统上安装 GraphViz。
- en: Next, let's discuss flowcharts and what they are used for.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论流程图及其用途。
- en: Flowcharts
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流程图
- en: Flowcharts represent the flow of data within the system. They provide a step-by-step
    approach to solving a particular problem or task. These diagrams are used by developers
    to gain an understanding of what rules apply when writing code. Rules can include
    logic such as data validation scenarios before proceeding to the next step. Flowcharts
    can be simple to fairly complex, and often provide decisions the user can make
    along the way. This diagram type depicts a user's possible interactions within
    a particular flow or set of flows.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图表示系统内部的数据流。它们提供了一种逐步解决问题的方法。这些图表被开发者用来理解在编写代码时适用哪些规则。规则可以包括在进入下一步之前的数据验证场景等逻辑。流程图可以是简单的，也可以相当复杂，通常还会提供用户可以在途中做出的决策。这种图表类型描述了用户在特定流程或一系列流程中的可能交互。
- en: If you have a single page that has a form broken down into many parts that the
    user must complete before navigating to a new page, a flowchart can be a handy
    tool for your frontend developer or even your designer to understand how a user
    will proceed from one step to another within the form and one page to another
    within the larger flow of the site. The diagrams can be broken down into smaller,
    more granular or defined flows as needed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个单页表单，该表单被分成多个部分，用户必须完成这些部分才能导航到新页面，那么流程图可以是前端开发者或甚至设计师理解用户如何在表单中从一步到另一步，以及如何在网站的更大流程中从一个页面到另一个页面的有用工具。根据需要，这些图可以分解成更小、更细粒度或更明确的流程。
- en: 'The following diagram is a small example to show the flow of a user as they
    log into a system. Does a page require a user to be logged in? If so, a decision
    must be made: is the user logged in? If no, prompt the login screen; if yes, a
    new decision must be made: does the user have permission to view the page?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是一个小示例，展示了用户登录系统的流程。页面是否需要用户登录？如果是，必须做出决定：用户是否已登录？如果没有，提示登录界面；如果是，则必须做出新的决定：用户是否有权限查看页面？
- en: '![Figure 1.5 – Flowchart'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 流程图'
- en: '](img/Figure_1.05_B17243.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.05](img/Figure_1.05_B17243.jpg)'
- en: Figure 1.5 – Flowchart
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 流程图
- en: State diagrams
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态图
- en: A state diagram shows the behavior of objects within a system. The diagram shows
    possible conditions or states that something can be in at any given time, such
    as depicting whether a user is either logged in or logged out; an order is either
    received, processing, or out for delivery, or an order is fulfilled or returned.
    These are great for showing a particular shift in behavior versus decisions that
    can be made. They may even depict certain triggers that cause a state to change
    as an operation moves through its life cycle toward completion.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 状态图显示了系统内对象的行为。该图显示了某个特定时间点可能的状态或条件，例如，用户是登录还是注销；订单是已接收、正在处理还是待发货，或者订单是已履行或已退货。这些图非常适合展示特定行为的变化与可做出的决策。它们甚至可能描绘出某些触发器，这些触发器会在操作通过生命周期向完成移动时导致状态变化。
- en: Use case diagrams
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例图
- en: A use case diagram represents the behavior of a user and the system. These are
    fairly similar to a flowchart but often focus on the bigger picture. These are
    used by teams such as the creative department, stakeholders, project managers,
    and directors, to help understand the concept of what this particular flow or
    use case will do.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 用例图表示用户和系统的行为。这些图与流程图相似，但通常更关注整体情况。这些图被创意部门、利益相关者、项目经理和导演等团队使用，以帮助理解特定流程或用例将执行的概念。
- en: '![Figure 1.6 – Use case diagram'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – 用例图'
- en: '](img/Figure_1.06_B17243.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.06](img/Figure_1.06_B17243.jpg)'
- en: Figure 1.6 – Use case diagram
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 用例图
- en: At this point, we have gone over common ways people plan for and design web
    applications today. Use these concepts to plan for your project the best that
    you can. In the next section, we'll discuss hosting your application as well as
    different deployment methodologies.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了今天人们规划和管理网络应用的一些常见方法。使用这些概念尽可能好地规划您的项目。在下一节中，我们将讨论托管您的应用程序以及不同的部署方法。
- en: Hosting and deployment
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域名托管和部署
- en: All websites and apps need a physical location for all of their files to live
    in; this is also known as web hosting. Web hosting is a service that provides
    the physical hardware for files to live in and where information is processed.
    A hosting plan provides a solution consisting of an operating system, such as
    Linux, and includes the actual hardware of the networking system. Servers will
    come with a web server of some kind installed for you, such as NGINX or the Apache
    web server.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网站和应用程序都需要一个物理位置来存放所有文件；这也被称为域名托管。域名托管是一种服务，它为文件提供物理硬件，并处理信息。托管计划提供由操作系统（如Linux）组成的解决方案，并包括网络系统的实际硬件。服务器将为您安装某种类型的网络服务器，例如NGINX或Apache网络服务器。
- en: A web server, otherwise known as a **Hypertext Transfer Protocol** (**HTTP**)
    server, is software that will send and receive HTTP requests, which are basically
    messages sent over the internet. Web servers can be thought of as software that
    runs on the operating system using HTTP, which is a standard network protocol
    used to distribute your website or application over the internet. With the HTTP
    that all browsers use today, a user can access your site when they navigate to
    your domain through the browser's address bar. Web servers help you with load
    balancing and caching and serve as your reverse proxy server, which makes your
    files available to the rest of the world via the internet. Hosting services will
    often provide you with options to scale up when your site experiences an increase
    in user traffic and data access, where you need more processing power or storage
    space.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器，也称为 **超文本传输协议** (**HTTP**) 服务器，是一种软件，可以发送和接收 HTTP 请求，这些请求基本上是通过互联网发送的消息。网络服务器可以被视为在操作系统上使用
    HTTP 运行的软件，HTTP 是一种用于在互联网上分发您的网站或应用程序的标准网络协议。随着今天所有浏览器使用的 HTTP，用户可以通过在浏览器的地址栏中导航到您的域名来访问您的网站。网络服务器可以帮助您进行负载均衡和缓存，并作为您的反向代理服务器，使您的文件通过互联网对全世界可用。托管服务通常会为您提供选项，在您的网站经历用户流量和数据访问增加时进行扩展，此时您需要更多的处理能力或存储空间。
- en: 'Huge projects tend to gravitate toward services such as **Amazon Web Services**
    (**AWS**) or Microsoft Azure and even Heroku. These are cloud-based hosting services,
    meaning your sites'' files will live on physical hardware that is likely shared
    with other clients. However, options to have a dedicated and far more secure server
    space are available for a price from any of these providers. Hosting plans also
    provide advanced options that give you the ability to install and configure your
    own operating system and/or your own web server. NGINX is the preferred choice
    when working with Django projects because the web server has a reputation for
    performing far better than an Apache installation and can handle far more HTTP
    requests per second. When thinking of performance, it is of no surprise that many
    Django projects use NGINX for their web server. If you do need to configure your
    very own web server, you can start with the official NGINX installation manual,
    found here: [https://www.nginx.com/resources/wiki/start/topics/tutorials/install/](https://www.nginx.com/resources/wiki/start/topics/tutorials/install/).
    The Apache web server will also work with Django and is desirable because it is
    far easier to install than an NGINX installation. If Apache is the route you need
    to go down, start by reading the official Django documentation on working with
    the Apache web server here: [https://docs.djangoproject.com/en/4.0/howto/deployment/wsgi/modwsgi/](https://docs.djangoproject.com/en/4.0/howto/deployment/wsgi/modwsgi/).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大型项目往往会倾向于使用像 **Amazon Web Services** (**AWS**) 或 Microsoft Azure 以及甚至 Heroku
    这样的服务。这些是云基础托管服务，意味着您的网站文件将存储在物理硬件上，这些硬件可能与其他客户共享。然而，从这些提供商中的任何一个都可以以一定的价格获得拥有专用且更安全的服务器空间的选择。托管计划还提供了高级选项，使您能够安装和配置自己的操作系统和/或自己的网络服务器。当与
    Django 项目一起工作时，NGINX 是首选选择，因为网络服务器以其比 Apache 安装表现更好的声誉，并且每秒可以处理更多的 HTTP 请求。当考虑到性能时，许多
    Django 项目使用 NGINX 作为其网络服务器并不令人惊讶。如果您确实需要配置自己的网络服务器，可以从官方 NGINX 安装手册开始，该手册可在以下位置找到：[https://www.nginx.com/resources/wiki/start/topics/tutorials/install/](https://www.nginx.com/resources/wiki/start/topics/tutorials/install/)。Apache
    网络服务器也可以与 Django 一起使用，并且是可取的，因为它比 NGINX 安装更容易安装。如果您需要走 Apache 的路线，请从阅读官方 Django
    文档开始，该文档介绍了如何与 Apache 网络服务器一起工作，可在以下位置找到：[https://docs.djangoproject.com/en/4.0/howto/deployment/wsgi/modwsgi/](https://docs.djangoproject.com/en/4.0/howto/deployment/wsgi/modwsgi/)。
- en: Creating and configuring a Heroku plan
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和配置 Heroku 计划
- en: 'For the examples provided in this book, I will be using the free plans that
    Heroku offers because of the service''s ease of use, zero-cost features, and growing
    popularity. Heroku is known as a **Platform as a Service** (**PaaS**), meaning
    that it enables developers to build, run, and deploy websites and apps entirely
    in the cloud. You can be up and running in a matter of minutes with this option,
    which can cut down the cost of hiring teams of network engineers to run a system
    for you. To follow along with this exercise, go to the Heroku website and sign
    up for a free account at [https://www.heroku.com/](https://www.heroku.com/). Then,
    once you have verified your email address and logged into your account, navigate
    to your dashboard at [https://dashboard.heroku.com/apps](https://dashboard.heroku.com/apps)
    and click on **New** | **Create New App**, then fill in the page, as depicted
    here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书提供的示例，我将使用Heroku提供的免费计划，因为该服务的易用性、零成本功能和日益增长的受欢迎程度。Heroku被称为**平台即服务**（**PaaS**），这意味着它使开发者能够在云中完全构建、运行和部署网站和应用。使用此选项，您可以在几分钟内启动并运行，这可以减少雇佣网络工程师团队为您运行系统的成本。为了跟随这个练习，请访问Heroku网站，并在[https://www.heroku.com/](https://www.heroku.com/)上注册一个免费账户。然后，一旦您验证了您的电子邮件地址并登录到您的账户，导航到您的仪表板[https://dashboard.heroku.com/apps](https://dashboard.heroku.com/apps)，然后点击**新建**
    | **创建新应用**，然后填写页面，如图所示：
- en: '![Figure 1.7 – Creating a new Heroku app'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.7 – 创建新的Heroku应用'
- en: '](img/Figure_1.07_B17243.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.07_B17243.jpg]'
- en: Figure 1.7 – Creating a new Heroku app
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 创建新的Heroku应用
- en: Enter a name for this app. The name is for internal use only and does not need
    to be exact. Keep in mind that since the app name must be unique within all Heroku
    apps, you will need to choose a different name from the name provided in this
    demonstration, `becoming-an-entdev`. Also, don't worry about pipelines just yet.
    We can always add them later if we need or want to. We will go over pipelines
    later, in the *Advanced deployment* subsection of this chapter. You may want to
    change your region to one closer to you if the United States is not your closest
    region.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为此应用输入一个名称。名称仅用于内部使用，不需要非常精确。请注意，由于应用名称必须在所有Heroku应用中是唯一的，因此您需要选择与演示中提供的名称`becoming-an-entdev`不同的名称。另外，目前不必担心流水线。如果我们需要或想要的话，我们可以在本章的*高级部署*子节中稍后讨论。如果您不在美国，可能需要将您的区域更改为更靠近您的区域。
- en: 'Since we are building a Django project, we will need to select the Python buildpack.
    A **buildpack** is Heroku''s way of using scripts to automatically build and compile
    various kinds of apps on Heroku. From the dashboard of your Heroku app that you
    just created, scroll down to the **Buildpacks** section and select **Add Buildpack**.
    The following screenshot depicts the popup that should appear next:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建一个Django项目，我们需要选择Python构建包。**构建包**是Heroku使用脚本来自动在Heroku上构建和编译各种类型应用的方式。从您刚刚创建的Heroku应用的仪表板向下滚动到**构建包**部分，并选择**添加构建包**。以下截图展示了接下来应该出现的弹出窗口：
- en: '![Figure 1.8 – Heroku buildpack choices'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.8 – Heroku构建包选择'
- en: '](img/Figure_1.08_B17243.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.08_B17243.jpg]'
- en: Figure 1.8 – Heroku buildpack choices
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – Heroku构建包选择
- en: You may add any buildpack that is relevant to the needs of your project, but
    for anything related to this book, **python** is the only buildpack needed. If
    you choose any other buildpack, additional configuration steps may be required
    that have not been provided in this book, so use with caution.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加任何与项目需求相关的构建包，但对于与本书相关的内容，**python**是唯一需要的构建包。如果您选择其他构建包，可能需要额外的配置步骤，这些步骤在本书中未提供，因此请谨慎使用。
- en: Next, we'll discuss environments, which in this context refers to the testing
    and development stages, where we will present code running in action at different
    stages of development. Environments can be used in other contexts, such as a web
    server or operating system. *Environment* can have many meanings in the world
    of programming and generally refers to a configuration, setup, or structure of
    something that you are working with, on, or in.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论环境，在这个上下文中，环境指的是测试和开发阶段，我们将展示代码在不同开发阶段的运行情况。环境也可以用于其他上下文，例如网络服务器或操作系统。在编程的世界里，“环境”可能有多种含义，通常指的是你正在使用、在或其中的某种配置、设置或结构。
- en: Configuring Heroku environments
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Heroku环境
- en: 'A Heroku app, in its most basic form, will consist of at least two environments,
    the first being a production environment, where your site or app will be accessed
    by the public and its users, and the second being your local machine, which is
    the computer where you and your development team will do all of your coding and
    where you will run the site locally. Heroku will default to using **Heroku Git**
    when an app is created, where it uses the Heroku CLI to commit changes from your
    local machine to your production environment. On your Heroku accounts dashboard
    at [https://dashboard.heroku.com/apps](https://dashboard.heroku.com/apps), click
    the **Deploy** tab to see the choices shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，一个 Heroku 应用程序将至少包含两个环境，第一个是生产环境，您的网站或应用程序将在这里被公众和用户访问，第二个是您的本地机器，这是您和您的开发团队进行所有编码以及本地运行网站的地方。当创建应用程序时，Heroku
    将默认使用 **Heroku Git**，它使用 Heroku CLI 将您本地机器上的更改提交到生产环境。在您的 Heroku 账户仪表板 [https://dashboard.heroku.com/apps](https://dashboard.heroku.com/apps)
    上，点击 **部署** 选项卡，您将看到以下截图所示的选项：
- en: '![Figure 1.9 – Heroku deployment methods'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – Heroku 部署方法'
- en: '](img/Figure_1.09_B17243.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.09](img/Figure_1.09_B17243.jpg)'
- en: Figure 1.9 – Heroku deployment methods
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – Heroku 部署方法
- en: Using the Heroku CLI
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Heroku CLI
- en: 'You will need to install the Heroku CLI on Mac, Windows, or Linux, by downloading
    the appropriate installer found here: [https://devcenter.heroku.com/articles/heroku-cli#download-and-install](https://devcenter.heroku.com/articles/heroku-cli#download-and-install).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在 Mac、Windows 或 Linux 上安装 Heroku CLI，通过在此处下载适当的安装程序来完成：[https://devcenter.heroku.com/articles/heroku-cli#download-and-install](https://devcenter.heroku.com/articles/heroku-cli#download-and-install)。
- en: For Windows users, remember to select the checkbox labeled **Set PATH to heroku**
    when you are prompted to do so during your install.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，当您在安装过程中被提示时，请记住选择标记为 **将 PATH 设置为 heroku** 的复选框。
- en: 'Next, navigate to the folder where you want your project to live on your local
    machine, and then open a new terminal or command-line window within that directory.
    You will need to log into Heroku using the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导航到您想在本地机器上存放项目的文件夹，然后在那个目录内打开一个新的终端或命令行窗口。您需要使用以下命令登录 Heroku：
- en: '[PRE7]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember, you will need to log in any time you open a new terminal or command-line
    window and perform tasks. It will prompt you to open a new browser tab to log
    in. Once you have done so, you should see a message such as the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每次您打开一个新的终端或命令行窗口并执行任务时，都需要登录。它将提示您打开一个新的浏览器标签页进行登录。一旦完成，您应该会看到如下消息：
- en: '[PRE8]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you see the preceding message, then you have successfully logged into your
    account and may begin using the Heroku commands.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到前面的消息，那么您已成功登录您的账户，可以开始使用 Heroku 命令。
- en: Tip
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Windows, an easy way to run PowerShell as an administrator is to navigate
    to the folder that you wish to run commands from within the File Explorer window
    and then click **File** | **Open Windows PowerShell** | **Open Windows PowerShell
    as administrator**. This will start the command line in that directory, reducing
    the steps needed to navigate to it by typing a series of change directory commands.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，以管理员身份运行 PowerShell 的简单方法是在文件资源管理器窗口中导航到您希望在其中运行命令的文件夹，然后点击 **文件**
    | **打开 Windows PowerShell** | **以管理员身份打开 Windows PowerShell**。这将在此目录中启动命令行，减少了通过输入一系列更改目录命令来导航到该目录的步骤。
- en: 'Clicking the options in *Figure 1.10* will open the command line in the following
    directory:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 *图 1.10* 中的选项将在以下目录中打开命令行：
- en: '**PS C:\Projects\Packt\Repo>**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**PS C:\Projects\Packt\Repo>**'
- en: '![Figure 1.10 – Open Windows PowerShell as administrator'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – 以管理员身份打开 Windows PowerShell'
- en: '](img/Figure_1.10_B17243.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.10](img/Figure_1.10_B17243.jpg)'
- en: Figure 1.10 – Open Windows PowerShell as administrator
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 以管理员身份打开 Windows PowerShell
- en: Next, let's initialize our local Git repository for the first time.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们首次初始化我们的本地 Git 仓库。
- en: Initializing a Git repository and commiting changes
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化 Git 仓库并提交更改
- en: To say you are initializing a Git repository on your local machine means that
    you are generating a `.git` folder in the directory of your choice. The configuration
    files found in the `.git` folder are responsible for establishing a line of communication
    between your local repository and the remote repository. The remote repository
    we are going to link to is the location of the Heroku app.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要说您正在初始化本地机器上的 Git 仓库，这意味着您正在选择目录中生成一个 `.git` 文件夹。`.git` 文件夹中的配置文件负责在您的本地仓库和远程仓库之间建立通信线路。我们将要链接的远程仓库是
    Heroku 应用的位置。
- en: 'Follow these steps to configure your Git settings:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您的 Git 设置：
- en: 'Execute the following commands to first log into your Heroku account and then
    initialize a local Git repository linking your local repository with your Heroku
    app:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令，首先登录您的 Heroku 账户，然后初始化一个本地 Git 仓库，将您的本地仓库与 Heroku 应用程序链接起来：
- en: '[PRE9]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This directory is where your Django project's source code files will live. In
    [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*,
    we will explain how to create your first Django project. For now, we just need
    to perform our first commit in order to establish a proper line of communication
    with each remote environment. In order for Heroku to accept a commit, the Heroku
    system needs to detect that it is a valid app that is being committed. Certain
    files must exist in order to pass this test. The first file is not necessarily
    required but I am suggesting you include it anyway; this is a `README.md` file
    uses **Markdown language**, which is a lightweight **markup language** used to
    store information such as your build processes or instructions for how a developer
    can get up and running for the first time. It's commonly used on the web to allow
    for the quick and easy formatting of plain text to keep important notes that can
    be viewed with many different web-based text editors today. When this file is
    viewed in the web browser, it is viewed, formatted, and styled in an easy-to-read
    format.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录是您的 Django 项目源代码文件所在的位置。在 [*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037)
    *项目配置* 中，我们将解释如何创建您的第一个 Django 项目。现在，我们只需要执行我们的第一个提交，以便与每个远程环境建立适当的通信线路。为了 Heroku
    能够接受提交，Heroku 系统需要检测到它是一个有效的应用程序正在被提交。某些文件必须存在才能通过此测试。第一个文件不一定必需，但我建议您仍然包含它；这是一个使用
    **Markdown 语言** 的 `README.md` 文件，Markdown 语言是一种轻量级的 **标记语言**，用于存储诸如构建过程或开发者如何首次启动的说明等信息。它通常用于网页上，以便快速轻松地格式化纯文本，以保留今天可以通过许多不同的基于网页的文本编辑器查看的重要笔记。当此文件在网页浏览器中查看时，它将以易于阅读的格式进行查看、格式化和样式化。
- en: 'To do this, create a file by running the following `touch` command from the
    root of your local repository:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请从本地仓库的根目录运行以下 `touch` 命令创建一个文件：
- en: '[PRE10]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For a complete guide on how to use Markdown language to style your README documents,
    visit [https://guides.github.com/features/mastering-markdown/](https://guides.github.com/features/mastering-markdown/).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 Markdown 语言来格式化您的 README 文档的完整指南，请访问 [https://guides.github.com/features/mastering-markdown/](https://guides.github.com/features/mastering-markdown/)。
- en: Tip
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Windows users will likely have to install touch-cli via NPM, if you haven't
    already done so. You need to do this before you can use the preceding `touch`
    command. Alternatively, you can right-click and select **New** | **Text Document**
    within your File Explorer, using your mouse instead.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装，Windows 用户可能需要通过 NPM 安装 touch-cli。您需要在使用前面的 `touch` 命令之前完成此操作。或者，您可以在文件资源管理器中右键单击并选择
    **新建** | **文本文档**，使用鼠标代替。
- en: 'To install touch-cli, run the following command using the `-g` attribute to
    denote that this is a global package for your development machine and not local
    to this project only:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 touch-cli，请使用 `-g` 参数运行以下命令，表示这是一个全局包，用于您的开发机器，而不是仅限于本项目：
- en: '**PS C:\Projects\Packt\Repo> npm install touch-cli -g**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**PS C:\Projects\Packt\Repo> npm install touch-cli -g**'
- en: Go ahead and add what you like to your README file and get ready to make your
    first commit to your Heroku Git repository.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请将您喜欢的内容添加到 README 文件中，并准备好将您的第一个提交到 Heroku Git 仓库。
- en: We will also need to create one more file in order to perform a successful commit
    on Heroku, that being a `requirements.txt` file. Otherwise, Heroku will give you
    an error when it sees that this file does not exist. The error message will read
    `requirements.txt` file does not exist in the root of your repository. These files
    can both remain blank for now if you desire, but the `requirements.txt` file must
    at least exist.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个额外的文件，以便在Heroku上成功提交，那就是一个`requirements.txt`文件。否则，当Heroku看到这个文件不存在时，会给出错误。错误信息将显示为“在您的仓库根目录中不存在`requirements.txt`文件”。如果您愿意，这些文件现在都可以保持空白，但`requirements.txt`文件至少必须存在。
- en: 'Run the following command to create your `requirements.txt` file from the root
    of your local repository:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令从本地仓库的根目录创建您的`requirements.txt`文件：
- en: '[PRE11]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To perform your commit, just run these commands:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行您的提交，只需运行以下命令：
- en: '[PRE12]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `-am` option performs the action of staging all modified files that are
    being tracked and allows us to add a personal commit message at the same time.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`-am`选项执行将所有被跟踪的已修改文件暂存的操作，并允许我们同时添加一个个人提交信息。'
- en: Next, we will clone an existing Heroku repository.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将克隆现有的Heroku仓库。
- en: Cloning an existing Heroku Git repository
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 克隆现有的Heroku Git仓库
- en: 'If you have already performed the steps in the previous subsection, where you
    have an existing repository for your project, you now need another developer to
    clone a copy of it to begin working. The next two commands will be needed. Don''t
    forget to log in first if you have not already done so:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经完成了前一小节中的步骤，即您已经有了项目的现有仓库，那么现在您需要另一位开发者克隆其副本以开始工作。接下来需要两个命令。如果您还没有登录，请不要忘记先登录：
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, run this command to clone the repository:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令来克隆仓库：
- en: '[PRE14]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To run any standard Git command, such as `push` or `pull`, use the following
    command, changing `pull` to `push` as needed:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行任何标准Git命令，例如`push`或`pull`，请使用以下命令，根据需要将`pull`更改为`push`：
- en: '[PRE15]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Managing environments in Heroku
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Heroku中管理环境
- en: 'It''s generally unwise to manage large projects with only two basic environments:
    standard production and local environments. The purpose of having many environments
    in your **Software Development Life Cycle** (**SDLC**) is to provide an application
    to your client with as few bugs as possible at the time of delivery. Use those
    environments to filter out as many bugs as possible in the process. Each environment
    or team that tests the application from beginning to end acts as a filter, weeding
    out different problems along the way.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，只用两个基本环境（标准生产和本地环境）来管理大型项目是不明智的。在您的**软件开发生命周期**（**SDLC**）中拥有许多环境的目的，是为了在交付时尽可能减少提供给客户的应用程序中的错误。利用这些环境在过程中尽可能过滤掉尽可能多的错误。每个从开始到结束测试应用程序的环境或团队都充当一个过滤器，沿途清除不同的问题。
- en: 'You can implement as many or as few environments in your deployment strategies
    as you see fit. Most projects include at least a development and staging environment
    in addition to the first two baseline environments: production and local. Development
    would be used by your developers as a way to do their own testing, just for the
    sake of running their project on something other than their own computer for the
    first time to see what the project does. Common build problems are spotted here
    that would otherwise just waste the time of a team testing for data and flow bugs.
    Then, when the developer is happy with how the code runs in the development environment,
    it can be pushed to a staging environment. Here, a different testing team can
    review the app, going through the flow and searching for ways to intentionally
    break the system. Then, when they are happy, the code can get pushed to your production
    environment. Theoretically, no bugs should exist in this environment; however,
    this is not a perfect world and so we just want our primary goal to be having
    as few bugs as possible when the project gets to production.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的部署策略中实施尽可能多或尽可能少的 环境，根据您的需要。大多数项目除了前两个基线环境（生产环境和本地环境）外，至少还包括一个开发和测试环境。开发环境将由您的开发者使用，作为他们自己的测试方式，只是为了第一次在其他计算机上运行他们的项目，看看项目会做什么。在这里可以发现常见的构建问题，否则这些问题只会浪费团队测试数据和流程错误的时间。然后，当开发者对开发环境中的代码运行满意时，它可以被推送到测试环境。在这里，不同的测试团队可以审查应用程序，通过流程并寻找故意破坏系统的方法。然后，当他们满意时，代码可以被推送到您的生产环境。理论上，这个环境中不应该存在任何错误；然而，这不是一个完美的世界，所以我们只想确保当项目进入生产环境时，错误尽可能少。
- en: 'Open your terminal or command-line window and navigate to the directory of
    your repository on your local machine. You can run the two commands shown in the
    following code block to create a development and staging environment for your
    app. If you haven''t already done so, make sure you are logged into your Heroku
    account:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的终端或命令行窗口，导航到你的本地机器上仓库的目录。你可以运行以下代码块中显示的两个命令，为你的应用创建开发和预发布环境。如果你还没有这样做，请确保你已经登录到你的Heroku账户：
- en: '[PRE16]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see the following message, indicating the operation was a success:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下消息，表明操作成功：
- en: '[PRE17]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Basically, what you are doing in this process is creating a new Heroku app that
    this environment lives in. That is done automatically for you.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你基本上是在创建一个新的Heroku应用，这个环境将生活在这个应用中。这会自动为你完成。
- en: 'Now, we can take the same two files we created earlier, `README.md` and `requirements.txt`,
    which should still be in your folder, and push them to development and staging.
    We can rest assured at this point of the SDLC that all three environments are
    exactly the same. We ensure this by executing the following two commands, pushing
    our code to those environments:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用之前创建的两个文件，`README.md`和`requirements.txt`，这些文件应该仍然在你的文件夹中，并将它们推送到开发和预发布环境。在这个SDLC（软件开发生命周期）的阶段，我们可以确信所有三个环境都是完全相同的。我们通过执行以下两个命令，将我们的代码推送到这些环境来确保这一点：
- en: '[PRE18]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's discuss using custom third-party repositories, such as GitHub, next.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论使用自定义第三方仓库，例如GitHub。
- en: Custom repositories
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义仓库
- en: You are not limited to using just Heroku to store your files; you are welcome
    to use a cloud-based repository hosting service, such as GitHub or Bitbucket,
    to store them. There are a lot of reasons to decide on using a custom repository
    in addition to the repository location Heroku offers you. Many people just like
    to keep things organized and since they already have an account with another repository,
    they may want to keep all of their projects together. If you do make the decision
    to use something such as GitHub to store your project files, you would choose
    the **GitHub** | **Connect to GitHub** button, as shown in *Figure 1.9*, found
    earlier under the *Configuring Heroku environments* subsection of this chapter.
    Keep in mind that if you want to create additional environments, you should still
    have performed all of the steps prior to this section first. Each environment
    will be linked to a Git remote of that repository within your GitHub account.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于使用Heroku来存储你的文件；你欢迎使用基于云的仓库托管服务，例如GitHub或Bitbucket，来存储它们。有许多原因决定使用自定义仓库，除了Heroku提供的仓库位置之外。许多人只是喜欢保持事物有序，因为他们已经在另一个仓库中有一个账户，他们可能希望将所有项目放在一起。如果你决定使用GitHub来存储你的项目文件，你将选择**GitHub**
    | **连接到GitHub**按钮，如图*图1.9*所示，该图在本书的*配置Heroku环境*子节中较早出现。请记住，如果你想创建额外的环境，你应该首先完成本节之前的所有步骤。每个环境都将链接到GitHub账户中该仓库的Git远程。
- en: When you choose to connect through GitHub, you will be prompted with a pop-up
    window in your browser that will ask you to log into your GitHub account. In this
    example, from within my GitHub account, I created a private repository named `becoming-an-entdev`.
    In your Heroku account, link your GitHub repository to this Heroku app by searching
    for the name of the repository that you created. Click **Connect** and if everything
    was a success, you should see this section change, containing a message reading
    **Connected to Your Repo Location**.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择通过GitHub连接时，你的浏览器将弹出一个窗口，要求你登录你的GitHub账户。在这个例子中，从我自己的GitHub账户中，我创建了一个名为`becoming-an-entdev`的私有仓库。在你的Heroku账户中，通过搜索你创建的仓库名称，将你的GitHub仓库链接到这个Heroku应用。点击**连接**，如果一切顺利，你应该会看到这个部分发生变化，显示一条消息**已连接到您的仓库位置**。
- en: '![Figure 1.11 – Linking an external GitHub repository to Heroku'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11 – 将外部GitHub仓库链接到Heroku'
- en: '](img/Figure_1.11_B17243.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.11_B17243.jpg)'
- en: Figure 1.11 – Linking an external GitHub repository to Heroku
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – 将外部GitHub仓库链接到Heroku
- en: Automatic deployment
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动部署
- en: 'Next, you can choose to enable automatic deployment every time a change has
    been detected to a specific branch of the repository you linked to your Heroku
    app. In the following section, on the same page in your Heroku dashboard, select
    the branch from the following dropdown and click **Enable Automatic Deploys**:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以选择在检测到链接到你的Heroku应用的仓库的特定分支有更改时启用自动部署。在以下部分，在你的Heroku仪表板上同一页面上，从以下下拉菜单中选择分支，然后点击**启用自动部署**：
- en: '![Figure 1.12 – Automatic deployment'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12 – 自动部署'
- en: '](img/Figure_1.12_B17243.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12_B17243.jpg](img/Figure_1.12_B17243.jpg)'
- en: Figure 1.12 – Automatic deployment
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 自动部署
- en: There is an option to work with **Continuous Integration** (**CI**) tools, which
    are also helpful for large-scale projects. Simply enable the checkbox labeled
    **Wait for CI to pass before deploy** if you need your CI tools to pass their
    tests before allowing deployment. CI and delivery can get inherently complex to
    talk about, but they are used to automate the integration of all contributors'
    work, such as running test scripts or build processes. Heroku's CI does this in
    regular intervals, sometimes multiple times a day.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个选项可以与 **持续集成**（**CI**）工具一起工作，这对于大型项目也很有帮助。如果您需要您的 CI 工具在允许部署之前通过测试，请简单地勾选标记为
    **在部署前等待 CI 通过** 的复选框。CI 和交付可能会变得非常复杂，但它们用于自动化所有贡献者工作的集成，例如运行测试脚本或构建过程。Heroku
    的 CI 会定期执行此操作，有时一天内会多次执行。
- en: If your automatic deployment was successfully linked to your GitHub repository,
    you will see a new **webhook** for that repo. A webhook is a fancy term in web
    development used to describe a signal that is sent to a listener on another system
    when some kind of event or trigger occurs. For example, when you push changes
    to your GitHub repository, a signal is sent to Heroku triggering a script to grab
    all the latest changes and merge them into the Heroku app automatically. Webhooks
    are sometimes referred to as **reverse APIs** because they just send a signal;
    there is no request to send the signal followed by a response, as is the default
    behavior of any standard API request. You can find webhooks in your settings for
    your repository within your GitHub account. If you are using a different service,
    just look for something similar to a webhook or reverse API.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的自动部署已成功链接到您的 GitHub 仓库，您将看到该仓库的新 **webhook**。webhook 是网络开发中的一个术语，用来描述当某个事件或触发器发生时，向另一个系统上的监听器发送的信号。例如，当您将更改推送到
    GitHub 仓库时，会发送一个信号到 Heroku，触发一个脚本自动抓取所有最新更改并将其合并到 Heroku 应用程序中。Webhooks 有时被称为
    **反向 API**，因为它们只是发送信号；没有请求发送信号然后响应，这是任何标准 API 请求的默认行为。您可以在 GitHub 账户中仓库的设置中找到
    webhooks。如果您使用的是不同的服务，只需寻找类似 webhook 或反向 API 的东西。
- en: '![Figure 1.13 – GitHub Heroku webhook'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.13 – GitHub Heroku webhook'
- en: '](img/Figure_1.13_B17243.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.13_B17243.jpg](img/Figure_1.13_B17243.jpg)'
- en: Figure 1.13 – GitHub Heroku webhook
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – GitHub Heroku webhook
- en: Configuring remotes
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置远程仓库
- en: Now that you have a GitHub repository that is created and linked to your production
    Heroku app and you have also wired up automatic deployments, you will need to
    specify in your local Git repository your remotes for linking your local repository
    to the production environment. Start by creating a `git-production` remote linked
    to your GitHub repository by using the Git URL provided in your account. You may
    name this anything you want.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经创建了一个 GitHub 仓库并将其链接到您的生产 Heroku 应用程序，您也已经设置了自动部署，您需要在您的本地 Git 仓库中指定您的远程仓库以将您的本地仓库链接到生产环境。首先，通过使用您账户中提供的
    Git URL 创建一个链接到您的 GitHub 仓库的 `git-production` 远程仓库。您可以将其命名为任何您想要的名称。
- en: 'Follow these steps to configure your remotes:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您的远程仓库：
- en: 'Run this command to create your remotes:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建您的远程仓库：
- en: '[PRE19]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding command is run only if you have already run the `git init` command
    to create your local repository first.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令仅在您已经运行了 `git init` 命令以首先创建您的本地仓库的情况下才会运行。
- en: 'Next, create a `main` branch for this remote:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为这个远程仓库创建一个 `main` 分支：
- en: '[PRE20]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I am naming the branch `main` to remain consistent with the branches on the
    Heroku apps.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我将分支命名为 `main`，以保持与 Heroku 应用程序上的分支的一致性。
- en: 'Now, you can push your first two files to this remote branch by running the
    following command. If you have made new changes to these files, remember to stage
    and commit them before the push:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过运行以下命令将您的前两个文件推送到这个远程分支。如果您对这些文件进行了新的更改，请记住在推送之前将它们暂存和提交：
- en: '[PRE21]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have the main repository to work with in production, we need to
    include the other environments, called development and staging. While Heroku separates
    environments into completely separate apps, you can either create new branches
    on `git-production` and call them development and staging or go into your GitHub
    account and create completely new repositories to link these to. For this book,
    we will separate them into completely new repositories for demonstration and practice.
    I went ahead and created two new repositories in my personal GitHub account called
    `becoming-an-entdev-dev` and `becoming-an-entdev-staging`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了在生产环境中工作的主仓库，我们需要包括其他环境，称为开发和预发布。虽然Heroku将环境完全分开为不同的应用程序，但你可以在`git-production`上创建新的分支并称它们为开发和预发布，或者进入你的GitHub账户创建全新的仓库并将它们链接起来。对于这本书，我们将为了演示和实践将它们分开到全新的仓库中。我提前在我的个人GitHub账户中创建了两个新的仓库，分别命名为`becoming-an-entdev-dev`和`becoming-an-entdev-staging`。
- en: 'We will link them using the following example commands:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下示例命令将它们链接起来：
- en: 'For the development environment, use the following:'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于开发环境，使用以下命令：
- en: '[PRE22]'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the staging environment, use the following:'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于预发布环境，使用以下命令：
- en: '[PRE23]'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, we will configure our Git branches.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置我们的Git分支。
- en: Configuring branches
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置分支
- en: All of the remotes in the examples provided have a branch named `main` that
    serves as the parent to all of the children branches and forks created when moving
    forward; some people also call this `master`. For working locally, you'll want
    to create local branches that are set up to track one of your remote branches.
    **Tracking**, in Git terminology, simply means a local branch is mapped to a remote
    repository or branch located somewhere else.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的示例中所有的远程都包含一个名为`main`的分支，它作为在向前移动时创建的所有子分支和分叉的父分支；有些人也称其为`master`。对于本地工作，你需要创建设置为跟踪你的远程分支之一的本地分支。在Git术语中，**跟踪**简单意味着一个本地分支被映射到位于某处的远程仓库或分支。
- en: 'Similar to how we ran the `git branch -M main` command previously, which we
    did for the sake of creating the `main` branch to be used for the remote version
    only, locally, we will run the following command to add a new local branch to
    our Git config file that helps track or map it to the environment we set:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们之前运行的`git branch -M main`命令，我们这样做是为了创建一个仅用于远程版本的`main`分支，在本地上，我们将运行以下命令以向我们的Git配置文件中添加一个新的本地分支，这有助于跟踪或将其映射到我们设置的环境：
- en: '[PRE24]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you are using something such as Sourcetree as a GUI for interacting with
    Git repositories, you should see something as in the following screenshot on the
    left sidebar of the app:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Sourcetree等图形用户界面与Git仓库进行交互，你应该在应用程序的左侧侧边栏中看到如下截图所示的内容：
- en: '![Figure 1.14 – Sourcetree sidebar – branches and remotes'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.14 – Sourcetree侧边栏 – 分支和远程]'
- en: '](img/Figure_1.14_B17243.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.14_B17243.jpg]'
- en: Figure 1.14 – Sourcetree sidebar – branches and remotes
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – Sourcetree侧边栏 – 分支和远程
- en: The default name given by Heroku to reference the production environment of
    the app that you are working with is `heroku`. If you were to expand all of the
    remote repositories in the list, you would see that they all have a `main` branch,
    as depicted in the preceding screenshot under the repository named `development`.
    Now, from one single folder on your hard drive, you can navigate to and from all
    of these environments, also known as versions of your app, to work as needed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku为你要工作的应用程序的生产环境提供的默认名称是`heroku`。如果你展开列表中的所有远程仓库，你会看到它们都有一个`main`分支，如前一个截图所示，位于名为`development`的仓库下。现在，从你硬盘上的一个单独文件夹中，你可以导航到并从所有这些环境，也称为你的应用程序的版本，进行所需的工作。
- en: 'Some simple and helpful commands are provided here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提供了一些简单且有用的命令：
- en: 'Switch branches with the following:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令切换分支：
- en: '[PRE25]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command switches to the `development` remote.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令切换到`development`远程。
- en: 'Stage everything and include a message to commit changes with the following:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令暂存所有内容并包含一条提交更改的消息：
- en: '[PRE26]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Push code specifying a **HEAD** location with the following:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令指定**HEAD**位置推送代码：
- en: '[PRE27]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you run into an error stating **error: src refspec main does not match any**
    when you try to run the preceding command, try the following command instead:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你尝试运行前面的命令时遇到错误，显示**error: src refspec main does not match any**，请尝试以下命令：'
- en: '[PRE28]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Up to now, each remote repository we created only consisted of one branch.
    Your team will need other branches, which for the most part will branch off of
    the `main` branch when they are created. Other times, you may want to branch off
    a child branch for a number of reasons. Many people may even prefer one repository
    where each environment is a different branch. I won''t go into all the different
    methodologies for organizing and using a specific Git workflow because this subject
    is so complex. You would have to adopt something that best fits your needs, but
    a good start would be to review this guide or anything on the subject of Git workflows:
    [https://backlog.com/git-tutorial/branching-workflows/](https://backlog.com/git-tutorial/branching-workflows/).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的每个远程仓库只包含一个分支。你的团队将需要其他分支，这些分支在创建时大部分会从`main`分支分叉出来。有时，出于各种原因，你可能还想从子分支分叉出来。许多人甚至可能更喜欢一个仓库，其中每个环境都是一个不同的分支。我不会深入探讨所有不同的组织和使用特定Git工作流程的方法，因为这个主题非常复杂。你必须采用最适合你需求的方法，但一个好的开始是回顾这个指南或关于Git工作流程的任何内容：[https://backlog.com/git-tutorial/branching-workflows/](https://backlog.com/git-tutorial/branching-workflows/)。
- en: You may need to separate branches by feature. My favorite approach is to give
    each developer their own branch named after themselves, which they can use to
    commit all of their daily work to at the end of each day. Later, a designated
    person can then merge all `pull` requests into the `main` branch at designated
    intervals throughout the SDLC. One option can be to store all these branches in
    your development environment and then, in your staging and production environments,
    you can leave just one branch, called the `main` branch. Then, when it comes time
    to push or pull something from development into staging, just push those changes
    into the `main` branch on staging. The choices are nearly infinite and there is
    no definitive right or wrong way to go about this.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要按功能分离分支。我最喜欢的做法是为每个开发者提供一个以他们名字命名的分支，他们可以在每天结束时将他们所有的日常工作提交到这个分支上。稍后，指定的人可以在整个软件开发生命周期（SDLC）中指定的时间间隔内将所有的`pull`请求合并到`main`分支。一个选项是将所有这些分支存储在你的开发环境中，然后在你的预发布和生产环境中，你只需保留一个分支，称为`main`分支。然后，当需要从开发中将某些内容推送到预发布时，只需将这些更改推送到预发布的`main`分支。选择几乎是无限的，而且没有绝对正确或错误的方法来做这件事。
- en: You could create branches on your other environments if you wanted to. Just
    keep an eye on versions of your app getting out of sync with one another. The
    idea is that as long as it makes sense and it doesn't create a lot of wasted time
    and headaches when merging, you are on the right path. In any strategy, it's usually
    wise to pull the `main` branch into a current working branch as often as possible
    while a developer works, in order to keep code in sync with other developers who
    have already merged their code into `main`. That developer could work out conflicts
    they know are specific to them on their machine, saving time later when working
    on other merge conflicts that could arise when it comes time to push this working
    branch into `main`. It's very easy to fall behind the changes that other developers
    are contributing, and merging your code into `main` later could prove to be difficult
    with the number of code conflicts that can result.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想的话，可以在其他环境中创建分支。只需注意确保你的应用程序版本之间不要出现不一致。想法是，只要这样做有意义，并且在合并时不会造成大量浪费的时间和头疼，你就走在正确的道路上。在任何策略中，当开发者工作时，通常明智的做法是尽可能频繁地将`main`分支拉入当前的工作分支，以保持代码与其他已经将代码合并到`main`的开发者同步。这样，开发者可以在自己的机器上解决他们知道是特定于自己的冲突，从而在稍后处理可能出现在将这个工作分支推送到`main`时的其他合并冲突时节省时间。很容易落后于其他开发者所做的更改，而且如果代码冲突的数量很多，稍后合并代码到`main`可能会变得困难。
- en: Advanced deployment
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级部署
- en: Of course, not everything has to be fully automated. A much smaller team or
    project can get by when they dedicate a single person to merge branches manually,
    edit code conflicts, and perform a final build of all the asset files before pushing
    to a test or production environment. If your team is building enterprise-level
    software, then you most certainly have the need to automate this step of production
    as much as possible. Since there are so many ways this can be done, the rest of
    this lies beyond the scope of this book. You may even hire a dedicated person
    or team of people whose only job is to build and manage deployment strategies,
    write build scripts, process pull requests, work through code conflicts, and test
    for bugs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有事情都必须完全自动化。一个较小的团队或项目可以通过指派一个人手动合并分支、编辑代码冲突以及在推送到测试或生产环境之前构建所有资产文件来完成任务。如果您的团队正在构建企业级软件，那么您肯定需要尽可能自动化这一生产步骤。由于有这么多方法可以实现这一点，本书的其余部分将超出范围。您甚至可以雇佣一个专门的人或团队，他们的唯一工作就是构建和管理部署策略、编写构建脚本、处理拉取请求、解决代码冲突以及测试错误。
- en: Build scripts can be used to compile ES6 to JavaScript or even transpile SCSS
    to CSS, where a smaller team may do this manually when merging branches. Test
    scripts can help you run test cases. You can test every method or class and even
    get to a granular level by testing specific data that is inputted into the system.
    Look into writing and running Node.js and Python build scripts on deployment based
    on your project's own needs.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 构建脚本可以用来编译ES6到JavaScript，甚至可以将SCSS转换为CSS，在一个较小的团队中，当合并分支时可能会手动完成这些操作。测试脚本可以帮助您运行测试用例。您可以测试每个方法或类，甚至可以通过测试输入到系统中的特定数据达到细粒度级别。根据您项目的需求，考虑在部署时编写和运行基于Node.js和Python的构建脚本。
- en: Two more things for you to explore are **pipelines** and **containers**, which
    add additional layers of enhancements to a project. We will discuss them next.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 值得您探索的两个更多主题是**流水线**和**容器**，它们为项目增加了额外的增强层。我们将在下一节讨论它们。
- en: Pipelines
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流水线
- en: A pipeline in software development is commonly known as a series of objects
    that are linked together where the output of one functions as the input of the
    other. This is best described as linking your development environment to your
    staging environment and then linking your staging environment to your production
    environment. There are a lot of tools that can be inserted here that can help
    with reviewing your code every step of the way. Services such as Heroku and GitHub
    offer ways to allow your developers to create **pull requests**, which comprise
    a method of submitting your code to a shared development project. The method even
    provides ways to create **tickets**, which are used to track and manage bugs or
    issues found in your application. They can be assigned to one or many people,
    and a status can be assigned to them providing team leaders or project managers
    with a method of knowing what is done and what is being worked on.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的流水线通常是指一系列相互连接的对象，其中前一个对象的输出作为后一个对象的输入。这最好描述为将您的开发环境与预发布环境连接起来，然后再将预发布环境与生产环境连接起来。这里可以插入许多工具，以帮助您在每一步审查您的代码。像Heroku和GitHub这样的服务提供了一种方式，允许您的开发人员创建**拉取请求**，这是一种将您的代码提交到共享开发项目的方法。该方法甚至提供了创建**工单**的方式，这些工单用于跟踪和管理在您的应用程序中发现的错误或问题。它们可以被分配给一个人或多人，并且可以分配状态，为团队领导或项目经理提供一种了解已完成的工作和正在处理的工作的方法。
- en: If you did decide to follow along with this chapter and use Heroku, their service
    offers many different ways to work with and configure pipelines. They can get
    very complex if you need them to be. One really cool feature of how Heroku manages
    pipelines is that a brand-new review app will automatically be created when a
    developer creates a **pull request**. A pull request is a way of submitting a
    request to merge code into a shared project. The request is sent to a reviewer
    who will merge the code and approve or deny the changes. If the reviewer has trouble
    resolving conflicts found in the merging of the code, they may reject the code
    and send it back to the developer to revise. This gives the reviewer a very easy
    way to launch the app with the code contained in the pull request to see whether
    it works or not.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定跟随本章内容并使用Heroku，他们的服务提供了许多不同的方式来工作和配置管道。如果需要，它们可以变得非常复杂。Heroku管理管道的一个非常酷的功能是，当开发者创建一个**拉取请求**时，会自动创建一个新的审查应用程序。拉取请求是一种提交请求将代码合并到共享项目中的方式。请求被发送给审查者，他们将合并代码并批准或拒绝更改。如果审查者在合并代码时遇到冲突，他们可能会拒绝代码并将其退回给开发者进行修改。这为审查者提供了一个非常简单的方式来启动包含在拉取请求中的代码的应用程序，以查看它是否正常工作。
- en: In other words, you can run whatever version, or whatever state the app is in,
    with that pull request without affecting your current development, staging, or
    production environments in any way. When a new app is created via a Pull request,
    that new app does not show up on your main dashboard, but instead is considered
    a *review app* of the environment or Heroku app that you are reviewing. Heroku
    will also automatically deploy changes to the `main` branch of the environment
    that is next in line in your pipeline queue, whenever a reviewer has approved
    changes included in a particular pull request.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '换句话说，你可以运行任何版本或任何状态的应用程序，而不会以任何方式影响你的当前开发、预发布或生产环境。当通过拉取请求创建新应用程序时，该新应用程序不会出现在你的主仪表板上，而是被视为你正在审查的环境或Heroku应用程序的*审查应用程序*。Heroku还会在审查者批准特定拉取请求中包含的更改时，自动将更改部署到管道队列中下一个的环境的`main`分支。 '
- en: Containers
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器
- en: A virtual environment in Python is best described as a way to encapsulate all
    of the packages or dependencies that your project relies on. What is known as
    a container, or **containerization**, is a step above, in that it encapsulates
    the entire operating system, your Django project, its own virtual environment,
    and all of its packages and dependencies. **Docker containers** are used to create
    images that are exact replicas of their production environments and are used by
    developers in every stage of development during the app's development life cycle.
    The benefit of doing this is that no matter what operating system your developers
    are working on, they will all virtually be running the same setup and should face
    little to no issues.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的虚拟环境最好描述为一种封装所有项目所依赖的包或依赖项的方式。通常所说的容器，或称为**容器化**，则是一个更高级的步骤，因为它封装了整个操作系统、你的Django项目、它自己的虚拟环境以及所有其包和依赖项。**Docker容器**用于创建与生产环境完全相同的镜像，并在应用程序的开发生命周期中的每个阶段被开发者使用。这样做的好处是，无论你的开发者正在使用什么操作系统，他们都将虚拟地运行相同的设置，并且应该面临很少或没有问题。
- en: In my experience, the phrase "*it works on my computer*" is often used among
    developers. This isn't a genuine issue often, but it does happen where a project
    on a Windows machine will act differently from the same project running on a Mac
    or Linux machine and vice versa. Containers let your developers continue to use
    the operating systems that they have become the most comfortable and familiar
    with during their careers. They ensure consistency among every moving part in
    development.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，开发者之间经常使用“*在我的电脑上运行正常*”这个短语。这通常不是一个真正的问题，但确实存在这样的情况，即在一个Windows机器上运行的项目与在Mac或Linux机器上运行的相同项目表现不同，反之亦然。容器允许你的开发者继续使用他们在职业生涯中变得最舒适和熟悉的操作系统的环境。它们确保开发中的每个移动部分的一致性。
- en: Another benefit of using containers is that they can help to get a brand-new
    developer or new hire to the team to get their project to run locally for the
    first time in as little time as possible. A container repository is similar to
    a traditional repository but is used to store a collection of container images.
    These can be completely different projects or a collection of different versions
    or environments of the same app. Either way, a container repository is used to
    store and distribute these images to developers who need them. If you predict
    many developers will come and go throughout the life cycle of your project, I
    highly recommend taking the time to build a container image for your team.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器的一个好处是，它们可以帮助新加入的开发者或新员工在尽可能短的时间内将项目本地运行起来。容器仓库类似于传统的仓库，但用于存储容器镜像的集合。这些可以是完全不同的项目，或者同一应用程序的不同版本或环境的集合。无论哪种方式，容器仓库都用于存储和分发这些镜像给需要它们的开发者。如果你预测在项目生命周期中会有许多开发者加入和离开，我强烈建议花时间为你的团队构建一个容器镜像。
- en: If you are using Heroku along with this book, choose the **Container Registry**
    | **Use Heroku CLI** button, as shown in *Figure 1.9*, found earlier in the *Configuring
    Heroku environments* section of this chapter. From here, you can integrate your
    container image into your deployment. The image can include any add-ons and app
    variables and even work with your pipelines and review apps. Heroku and Docker
    also work together with third-party CI services, such as Codefresh, CodeShip,
    and CircleCI. There is quite a bit more configuration that will need to be done
    to use these third-party services, but you can review their documentation to help
    you get started.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Heroku配合这本书，请选择如图1.9所示的**容器注册库** | **使用Heroku CLI**按钮，该图在本书的*配置Heroku环境*部分中较早出现。从这里，你可以将你的容器镜像集成到部署中。该镜像可以包括任何附加组件和应用程序变量，甚至可以与你的管道和审查应用程序一起工作。Heroku和Docker还与第三方CI服务（如Codefresh、CodeShip和CircleCI）合作。为了使用这些第三方服务，还需要进行相当多的配置，但你可以通过查看它们的文档来帮助您开始。
- en: Domain Name System
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域名系统
- en: When an environment or a review app is created, Heroku will generate a new URL
    based on the name of the app that you created. Since Heroku's system is set up
    to use the name of your app as a subdomain of its URL structure, the name of your
    app must be unique. For example, the main project on Heroku for this book is named
    `becoming-an-entdev` and generates the URL [https://becoming-an-entdev.herokuapp.com/](https://becoming-an-entdev.herokuapp.com/).
    The development app created for this book automatically generates the URL [https://mighty-sea-09431.herokuapp.com/](https://mighty-sea-09431.herokuapp.com/),
    and the staging environment generates the URL [https://pure-atoll-19670.herokuapp.com/](https://pure-atoll-19670.herokuapp.com/).
    `mighty-sea-09431` and `pure-atoll-19670` are the names of the apps that were
    automatically created by Heroku when those environments were created.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个环境或审查应用程序时，Heroku会根据你创建的应用程序名称生成一个新的URL。由于Heroku的系统设置为将你的应用程序名称用作其URL结构的子域名，因此你的应用程序名称必须是唯一的。例如，这本书在Heroku上的主要项目名为`becoming-an-entdev`，生成的URL为[https://becoming-an-entdev.herokuapp.com/](https://becoming-an-entdev.herokuapp.com/)。为这本书创建的开发应用程序自动生成URL
    [https://mighty-sea-09431.herokuapp.com/](https://mighty-sea-09431.herokuapp.com/)，而预发布环境生成的URL为[https://pure-atoll-19670.herokuapp.com/](https://pure-atoll-19670.herokuapp.com/)。`mighty-sea-09431`和`pure-atoll-19670`是Heroku在创建这些环境时自动创建的应用程序名称。
- en: The final step in the app configuration is to link the Heroku URL to a `www.your-domain.com`.
    You will have to link your app to this phone book registry so that the public
    can get to your website or API using your domain name and not the URL provided
    by Heroku.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序配置的最后一步是将Heroku URL链接到`www.your-domain.com`。你必须将你的应用程序链接到这个电话簿注册库，这样公众就可以通过你的域名而不是Heroku提供的URL来访问你的网站或API。
- en: Popular registrars, such as Domain.com, Bluehost, GoDaddy, and Namecheap, allow
    you to register a domain name, which will look like `www.your-domain.com` or [http://www.your-domain.custom.tld/](http://www.your-domain.custom.tld/),
    where `.tld` refers to any of the over 1,500 `.edu`, `.gov`, or `.food`, to name
    a few. Some TLDs are restricted to certain entities and may not be available to
    everyone. There are two ways you can link your Heroku app to a DNS. The first
    way is to use `www.your-domain.com` to your Heroku app location where the user
    will no longer see your domain in the browser's address bar. Instead, they will
    see `becoming-an-entdev.herokuapp.com` in the address bar. If you want the user
    to continue to see `www.your-domain.com` in their browser's address bar, along
    with your site as the body content, you'll need to set up forwarding with `<head>`
    of your document.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍的注册商，如Domain.com、Bluehost、GoDaddy和Namecheap，允许你注册一个域名，它看起来像`www.your-domain.com`或[http://www.your-domain.custom.tld/](http://www.your-domain.custom.tld/)，其中`.tld`指的是1500多个`.edu`、`.gov`或`.food`等顶级域名中的任何一个。一些顶级域名仅限于特定实体，可能不是每个人都可用。你可以通过两种方式将你的Heroku应用链接到DNS。第一种方式是使用`www.your-domain.com`指向你的Heroku应用位置，这样用户在浏览器的地址栏将不再看到你的域名。相反，他们将在地址栏看到`becoming-an-entdev.herokuapp.com`。如果你想用户在他们的浏览器地址栏中继续看到`www.your-domain.com`，同时你的网站作为正文内容，你需要设置使用文档的`<head>`部分的转发。
- en: Forwarding with masking is generally considered bad in terms of SEO, which is
    ways to improve the visibility of your site in search results on search engines
    such as Google, Bing, and Yahoo. It's usually difficult or more complex for a
    search engine to link information from one site via an IP address and map it to
    your physical domain, and generally, you will get a lower search rating because
    of that. It may be that search engines are working to improve upon this in the
    future or at least working to not penalize websites for using forwards and redirects.
    For now, you should not consider this if SEO is a big requirement for your project.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遮罩的转发通常在SEO方面被认为是不好的，SEO是提高网站在搜索引擎如Google、Bing和Yahoo等搜索结果中可见性的方法。通常，搜索引擎很难或更复杂地将来自一个站点的信息通过IP地址链接并映射到你的物理域名，因此，你可能会因为这一点而得到更低的搜索排名。可能搜索引擎正在努力改进这一点，或者至少正在努力不惩罚使用转发和重定向的网站。目前，如果你的项目对SEO有很高的要求，你不应该考虑这一点。
- en: 'The alternative to using domain forwarding would be to map your domain to the
    system''s nameservers that deliver your app. Whichever you are using, you need
    to first make your Heroku app available to the domain of your choice if it is
    anything other than the standard Heroku domain. Start by adding your domain to
    your app in Heroku by running the following command. Make sure to log in first
    if you haven''t already done so:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用域名转发之外的替代方案是将你的域名映射到提供你的应用的系统DNS服务器。无论你使用哪种方法，如果你使用的不是标准Heroku域名，你首先需要让你的Heroku应用对你的选择域名可用。首先，通过运行以下命令将你的域名添加到Heroku应用中。如果你还没有登录，请先登录：
- en: '[PRE29]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To use subdomains to act as your different environments, run the next two commands:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用子域名来作为你的不同环境，请运行以下两个命令：
- en: '[PRE30]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we append the `--app` attribute setting and specify the app we want to
    link to. Since we created different environments, we need to include this specification
    or we will get an error. The `dev` and `staging` subdomains are used in the preceding
    commands as the environment-specific domains of our site. If the command is successful,
    it will print out your DNS target, but you can always run this command to list
    all of the domains, and it will also print out your DNS target for you:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`--app`属性设置，并指定了我们想要链接的应用。由于我们创建了不同的环境，我们需要包含这个指定，否则我们会得到错误。`dev`和`staging`子域名在先前的命令中用作我们网站的环境特定域名。如果命令成功执行，它将打印出你的DNS目标，但你始终可以运行此命令来列出所有域名，它也会为你打印出DNS目标：
- en: '[PRE31]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You will then need to use the DNS target that was provided to configure your
    DNS records within your registrar's account for your domain. If you're using domain
    forwarding, many registrars have an option to create a forward and will ask you
    a few questions. For manually mapping your domain to your nameserver, this is
    usually done by editing `A-Record` in your DNS settings by providing a name of
    `@` and giving it a value of the DNS target that was provided previously.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要使用提供的DNS目标来配置你的域名注册商账户中的DNS记录。如果你使用域名转发，许多注册商都有一个创建转发的选项，并会问你几个问题。对于手动将域名映射到你的域名服务器，这通常是通过编辑DNS设置中的`A-Record`来完成的，提供一个名为`@`的名称，并给它一个之前提供的DNS目标值。
- en: You can even set up a custom subdomain for different projects, departments,
    and versions of your app or environments, such as `dev.your-domain.com` or `staging.your-domain.com`.
    Subdomains can be linked by creating a new `CNAME-Record` with the names `dev`
    or `staging` and giving the records the value of the DNS target that was provided
    in the examples previously for their respective apps. For registrars that won't
    accept a value that is not a numeric IP address, you will have to use something
    such as Cloudflare, which is a web infrastructure and security company, to sit
    in the middle and act as your nameserver. It acts as a content delivery network
    and your nameserver, which you can then configure in your registrar using the
    nameserver settings provided by Cloudflare. Nameserver records are known as `NS-Record`
    within the DNS settings of your registrar.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以为不同的项目、部门、你的应用程序或环境的版本设置自定义子域名，例如`dev.your-domain.com`或`staging.your-domain.com`。可以通过创建一个新的`CNAME-Record`，使用名称`dev`或`staging`，并给记录提供之前为相应应用程序提供的DNS目标值来链接子域名。对于不接受非数字IP地址值的注册商，你必须使用像Cloudflare这样的网络基础设施和安全公司，它会在中间充当你的域名服务器。它充当内容分发网络和你的域名服务器，然后你可以使用Cloudflare提供的域名服务器设置在你的注册商那里配置它。域名服务器记录在注册商的DNS设置中被称为`NS-Record`。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It can be very easy for someone to get caught up in how to do something versus
    actually doing something. Overthinking is a very common thing among programmers.
    Sometimes, it's wise to just accept a certain level of work is needed for your
    workflow and then scale up and extend as much as needed later on as the need arises.
    While gathering requirements is important to obtain a clear understanding of what
    it is you are trying to achieve, many of the steps and concepts discussed in this
    chapter can be thought of as just another tool in your toolbox, or in other words,
    the right tool for the right job.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易有人陷入如何做某事而不是真正去做某事的困境。过度思考在程序员中是非常常见的事情。有时，接受一定水平的工作量以满足你的工作流程，然后在需要时根据需求扩展和扩展，这是一种明智的做法。虽然收集需求对于获得对你试图实现的事情的清晰理解很重要，但本章中讨论的许多步骤和概念可以被视为你工具箱中的另一个工具，或者换句话说，适合的工具有助于完成合适的工作。
- en: Things such as containerizing your project with Docker can be easily added to
    your workflow and deployment routines later on. The same can be said if you need
    to add additional environments to your workflow later on. New developers could
    easily be given a new branch as the need also arises. Teams who dedicate one person
    to manually run, build, and test tasks can always automate their tasks later on
    when work begins to pile up. Pipelines can be created even after you have been
    developing a project for a while. However, other decisions, such as choosing what
    framework to use on your frontend, can prove to be disastrous if you decide to
    change the technology halfway through the development life cycle.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目容器化（例如使用Docker）等事情可以很容易地添加到你的工作流程和部署常规中。同样，如果你后来需要添加额外的环境到你的工作流程中，也是如此。新开发者可以很容易地分配一个新的分支，因为需求也会随之产生。那些指派一个人手动运行、构建和测试任务的团队，当工作开始堆积时，总是可以在之后自动化他们的任务。即使你已经开发了一段时间的项目，也可以创建管道。然而，其他决策，比如在开发生命周期的中途决定使用哪个前端框架，如果改变技术，可能会证明是灾难性的。
- en: What is known as **agile development** is the process of an ever-changing and
    always fluid development environment. This is where many different collaborators
    share ideas and those ideas often change over time, meaning that the scope of
    the project will also change. A lot of projects today are built in an agile setting.
    Use your initial requirements gathering to probe for possible changes in the future
    and then align yourself with as many open doors as possible. Remember that a strong
    home always needs a strong foundation to rest upon; a weak foundation will result
    in your home crumbling to the ground.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为**敏捷开发**的是一种不断变化且始终流动的开发环境的过程。这就是许多不同的合作者分享想法，而这些想法通常会随着时间的推移而改变，这意味着项目的范围也会发生变化。如今，许多项目都是在敏捷环境中构建的。利用你的初始需求收集来探索未来可能的变化，并尽可能与尽可能多的开放机会保持一致。记住，一个强大的房屋总是需要一个强大的地基来支撑；一个薄弱的地基会导致你的房屋倒塌到地上。
- en: This chapter focused on pouring the foundation of a home. In the next chapter,
    [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*,
    we will be building what can be considered the frame of the house that sits upon
    that foundation. The frame of that house will consist of building a project, virtual
    environment and database needed for development.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了如何为房屋打地基。在下一章，[*第二章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*中，我们将构建可以被认为是坐落在地基上的房屋框架。这个房屋的框架将包括建立一个项目、虚拟环境和开发所需的数据库。
