- en: Chapter 9. Tiny Tennis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。迷你网球
- en: In the previous chapter, you learned about the basic modules, classes, and functions
    in pygame. You learned about these functions so that you can build a new game
    called **Tiny Tennis**. Tiny Tennis will be a two-player game that uses the keys
    on a keyboard to control two paddles, which hit a ball back and forth. While this
    game seems simple when you watch it, there are many different parts needed to
    make the game playable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了pygame中的基本模块、类和函数。你学习这些函数是为了能够构建一个名为**迷你网球**的新游戏。迷你网球将是一款双人游戏，使用键盘上的按键来控制两个挡板，挡板来回击球。虽然当你观看这个游戏时，它看起来很简单，但制作一个可玩的游戏需要很多不同的部分。
- en: Introduction to game programming principles
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏编程原则简介
- en: There are many principles of game programming that apply to our project in this
    chapter. First, remember that the movement of objects in space is an illusion
    that we create. Unlike reality, objects that we create will appear to move because
    we will regularly draw and then redraw the objects in different places.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有很多游戏编程原则适用于我们的项目。首先，记住空间中对象的运动是我们创造的幻觉。与现实不同，我们创建的对象看起来会移动，因为我们会在不同的地方定期绘制和重绘对象。
- en: Another principle that we have discussed is a game loop. The game loop is important
    as it controls all of the things that need to happen in the game, including the
    moving and redrawing of objects. The timing of the game loop is important as this
    will tell the computer how many times to run the game loop. Each time a game loop
    runs is also known as a **frame**, and the speed at which the game loop runs is
    known as the **frame rate**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的另一个原则是游戏循环。游戏循环非常重要，因为它控制着游戏中需要发生的所有事情，包括对象的移动和重绘。游戏循环的时间安排很重要，因为这会告诉计算机游戏循环需要运行多少次。每次游戏循环的运行也被称为**帧**，游戏循环运行的速率被称为**帧率**。
- en: Finally, considering how the player interacts with the game is an important
    part of the game design. This means that we will consider how the player uses
    keys and has their score stored in the program's memory and displayed somewhere
    on the screen.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑到玩家如何与游戏互动是游戏设计的一个重要部分。这意味着我们将考虑玩家如何使用键盘，以及他们的分数如何存储在程序的内存中并在屏幕的某个位置显示。
- en: The game plan
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏计划
- en: Before we start to write any lines of code, we need to have our Python shell,
    terminal, and text editor open. We will be switching back and forth between these
    tools as we write and test lines of code throughout the chapter. Set up your monitor
    so that you are comfortable switching between each window.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写任何代码行之前，我们需要打开我们的Python壳、终端和文本编辑器。在我们编写和测试本章中的代码行时，我们将在这三个工具之间来回切换。调整你的显示器，以便你可以在每个窗口之间舒适地切换。
- en: Once you set up your workspace, go to the text editor window. We are going to
    outline our game in the text editor window using comments so that we can better
    organize our work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好你的工作区后，转到文本编辑器窗口。我们将使用注释在文本编辑器窗口中概述我们的游戏，这样我们可以更好地组织我们的工作。
- en: Creating an outline of game parts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏部分的概述
- en: 'We are going to work on this game in four sections. The sections of the game
    are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分四个部分来制作这个游戏。游戏的部分如下：
- en: 'Section 1: imports, globals, and drawings'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1节：导入、全局变量和绘图
- en: 'Section 2: moving the paddles'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2节：移动挡板
- en: 'Section 3: moving the ball'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3节：移动球
- en: 'Section 4: draw screen and track the score'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4节：绘制屏幕和跟踪分数
- en: 'Create a file called `tiny.py` in your text editor. Then, type the following
    lines into your `tiny.py` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中创建一个名为`tiny.py`的文件。然后，将以下行输入到你的`tiny.py`文件中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you are done typing the preceding lines, save your file. This file now
    provides a general outline of the work that needs to be done to create your game.
    Here is how your file will look:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入前面的行之后，保存你的文件。现在这个文件提供了一个创建游戏所需工作的概述。你的文件看起来会是这样：
- en: '![Creating an outline of game parts](img/B04681_09_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏部分的概述](img/B04681_09_01.jpg)'
- en: We are following one particular approach to making this game of Tiny Tennis.
    It is important to note that there are *MANY* possible ways to write this game
    code. The way we are doing it here allows us to review all of the concepts that
    we learned along the way in this book. At the end of this chapter as well as in
    the next chapter, we will discuss some more advanced (and more streamlined) coding
    techniques that you can use to make this game do more things and do them more
    efficiently. Right now, though, let's start this game!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在遵循一种特定的方法来制作这款迷你网球游戏。需要注意的是，编写这款游戏代码有*许多*可能的方式。我们在这里所采用的方法使我们能够回顾在这本书中学到的所有概念。在本章的结尾以及下一章中，我们将讨论一些更高级（且更简洁）的编码技术，这些技术可以帮助你使这款游戏执行更多操作，并且更有效率。不过，现在，让我们开始这款游戏吧！
- en: Section 1 – imports, globals, and drawings
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1节 – 导入、全局变量和绘图
- en: In this first section, we will write all of the code to set up the different
    parts of our game. This includes importing libraries, defining all of our global
    variables, and telling the computer how to draw the screen, ball, and paddles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写所有代码来设置游戏的不同部分。这包括导入库、定义所有全局变量，以及告诉计算机如何绘制屏幕、球和挡板。
- en: Importing libraries
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入库
- en: 'The first lines of code we write will be used to import the necessary libraries
    into the game, including pygame. We will be using three libraries in the game:
    pygame, math, and random. pygame, as we discussed in the previous chapter, allows
    us to have visual elements in our game. The random library, included with Python,
    gives us the ability to select and use random numbers in our game. The math library,
    also included with Python, allows for mathematics with floating point numbers.
    To use these modules and libraries in your code, type the following lines into
    your `tiny.py` file underneath the #imports, globals, and drawing comment:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的第一行代码将用于将必要的库导入到游戏中，包括pygame。在游戏中，我们将使用三个库：pygame、math和random。正如我们在上一章所讨论的，pygame使我们能够在游戏中添加视觉元素。Python附带的标准库random，使我们能够在游戏中选择和使用随机数。Python附带的math库允许进行浮点数运算。要在你的代码中使用这些模块和库，请在`tiny.py`文件中#导入、全局变量和绘图注释下面输入以下几行代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure to save your `tiny.py` file now that you have added some new lines.
    Be in the habit of saving your code as *OFTEN* as you can.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 确保现在你已经添加了一些新行，保存你的`tiny.py`文件。养成尽可能频繁保存代码的习惯。
- en: 'You can make comments in your code if it helps you to organize your thoughts.
    Now, we will also initialize pygame so that we are able to use all of the capabilities,
    including starting our screen, drawing graphics, and running our game loop. To
    initialize pygame, we use the `init()` function. To initialize it, type these
    two lines of code below your imports:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码中的注释有助于你组织思路，你可以添加注释。现在，我们还将初始化pygame，以便我们能够使用所有功能，包括启动屏幕、绘制图形和运行游戏循环。要初始化pygame，我们使用`init()`函数。要初始化它，在你的导入下面输入以下两行代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using `pygame.init()` starts the pygame process, and the pygame process will
    keep running until the program stops running when the player quits pygame. This
    allows us to access everything inside of pygame throughout the game. You will
    see how important this is as we continue to write our game. Right now, save your
    `tiny.py` file again:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pygame.init()`启动pygame进程，pygame进程将持续运行，直到玩家退出pygame时程序停止运行。这使我们能够在整个游戏中访问pygame内部的所有内容。随着我们继续编写游戏，你会看到这一点有多么重要。现在，再次保存你的`tiny.py`文件：
- en: '![Importing libraries](img/B04681_09_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![导入库](img/B04681_09_02.jpg)'
- en: Introducing globals
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入全局变量
- en: Now that we have imported the libraries that we need, we will be making globals
    for some parts of the game. As a reminder, globals, or global variables, are variables
    that we can use throughout the entire file. We will set global variables for all
    of the colors that we wish to use. We also set global variables for the screen,
    paddles, and ball.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所需的库，我们将为游戏的一些部分创建全局变量。提醒一下，全局变量，或称全局变量，是我们可以在整个文件中使用的变量。我们将为所有希望使用的颜色设置全局变量。我们还为屏幕、挡板和球设置了全局变量。
- en: Defining a color
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义颜色
- en: First, we will make globals for each color. Colors, as we learned in [Chapter
    8](ch08.html "Chapter 8. pygame"), *pygame*, are represented by three different
    numbers listed in parentheses, also called a tuple. Instead of having to write
    these numbers repeatedly, we will make a global variable for each color so that
    we can use the names of all of the colors throughout the game.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为每种颜色创建全局变量。正如我们在[第8章](ch08.html "第8章。pygame")中学习的，颜色，在*pygame*中，由括号内列出的三个不同的数字表示，也称为元组。为了避免重复编写这些数字，我们将为每种颜色创建一个全局变量，这样我们就可以在整个游戏中使用所有颜色的名称。
- en: 'Depending on what colors you like, you might want to make global variables
    for all the colors or only for a few. It is really up to you to decide what colors
    to add to your code. Here is a list of common colors that you may wish to use
    in your game. You should add the code for each color exactly as it appears here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您喜欢的颜色，您可能希望为所有颜色或仅为一小部分创建全局变量。实际上，决定添加哪些颜色到您的代码中完全取决于您。以下是一份您可能在游戏中希望使用的常见颜色列表。您应该将每种颜色的代码添加得与这里显示的完全一致：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding list shows the basic colors that you can include in your game
    code. If you want to include more advanced colors, you can search for `rgb color
    codes chart` in an Internet search engine, such as Google, and you will find that
    there are different variations for each color that you can change to your liking,
    such as light blue or dark blue. Once you have changed all the colors to your
    liking, make sure that you save your work:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表显示了您可以在游戏代码中包含的基本颜色。如果您想包含更高级的颜色，您可以在搜索引擎中搜索`rgb颜色代码表`，例如Google，您会发现每种颜色都有不同的变化，您可以根据自己的喜好进行更改，例如浅蓝色或深蓝色。一旦您将所有颜色更改到您喜欢的样子，请确保保存您的作品：
- en: '![Defining a color](img/B04681_09_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![定义颜色](img/B04681_09_03.jpg)'
- en: Adjusting the screen size
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整屏幕大小
- en: 'We will also use globals to define the parts of our screen display. This lets
    us show the size, color, and text for the main screen. Here are the color globals;
    we will add these lines of code for the width and height of the screen:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用全局变量来定义屏幕显示的部分。这使我们能够显示主屏幕的大小、颜色和文本。以下是颜色全局变量；我们将添加以下代码行以定义屏幕的宽度和高度：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have made the `screen_width` and `screen_height` variables, we can
    use these variables throughout our code, which makes our code easier to read.
    Also, if we do decide to change the screen width or screen height, we can change
    it one at a time in this global variable, and all of our code will still run properly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`screen_width`和`screen_height`变量，我们可以在整个代码中使用这些变量，这使得我们的代码更容易阅读。此外，如果我们决定更改屏幕宽度或高度，我们可以在这个全局变量中逐个更改，而我们的所有代码仍然可以正常运行。
- en: Drawing the screen
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制屏幕
- en: 'So, the `screen_width` and `screen_height` variables are the basic information
    that pygame needs so that it can set up the actual game screen. pygame has a function
    called `pygame.display.set_mode()` that takes the variables of `screen_width`
    and `screen_height` to make the screen display. Now, writing `pygame.display.set_mode
    ((screen_width, screen_height))` is really long, especially if we keep doing it.
    Instead, we are going to set this to a global variable called `game_screen`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`screen_width`和`screen_height`变量是pygame设置实际游戏屏幕所需的基本信息。pygame有一个名为`pygame.display.set_mode()`的函数，它接受`screen_width`和`screen_height`变量来设置屏幕显示。现在，编写`pygame.display.set_mode
    ((screen_width, screen_height))`确实很长，尤其是如果我们一直这样做的话。相反，我们将将其设置为名为`game_screen`的全局变量：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating screen labels
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建屏幕标签
- en: 'The next set of functions that we use will set the text for the top of the
    screen and the font for the game screen. The first line of code defines what string
    of text we want to see, and in the following line, we define the font and size.
    If the font and the size are not available, the font will, by default, use whatever
    is originally set on your system. This is true for Windows, Mac, and Linux systems:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来使用的函数集将设置屏幕顶部的文本和游戏屏幕的字体。第一行代码定义了我们想要看到的文本字符串，在下一行中，我们定义了字体和大小。如果字体和大小不可用，字体将默认使用系统上最初设置的字体。这对于Windows、Mac和Linux系统都是正确的：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, we have now set all of the basic variables needed to create a game screen.
    Save your work and, when you are ready, move on to making the global variables
    that we will need for the ball, paddles, and scoring. Your screen code should
    look like this code sample:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经设置了创建游戏屏幕所需的所有基本变量。保存您的作品，当您准备好时，继续创建我们需要的球、挡板和计分的全局变量。您的屏幕代码应该看起来像以下代码示例：
- en: '![Creating screen labels](img/B04681_09_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![创建屏幕标签](img/B04681_09_04.jpg)'
- en: Ball – the starting location
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球 - 起始位置
- en: In Tiny Tennis, the ball is one of the most important parts of the game. We
    have a lot to do to make it work. First, we need to give the ball some global
    characteristics so that it can be drawn and redrawn to create the illusion of
    movement.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在“迷你网球”游戏中，球是游戏最重要的部分之一。我们需要做很多事情来让它工作。首先，我们需要给球一些全局特性，以便它可以被绘制和重绘，从而产生运动的错觉。
- en: 'First, we need to set the *x*, *y* coordinates of the ball. By making a global
    variable for this, we can tell the computer where to redraw the ball without having
    to write special code for each movement of the ball. We will set the default value
    of `x` and `y` so that the ball starts in the center of the screen. Write the
    next lines into your `tiny.py` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置球的 *x*，*y* 坐标。通过为这个坐标创建一个全局变量，我们可以告诉计算机在哪里重绘球，而无需为球的每次移动编写特殊的代码。我们将设置
    `x` 和 `y` 的默认值，使球从屏幕中心开始。将以下几行代码写入你的 `tiny.py` 文件：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ball – setting the speed and direction
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球 - 设置速度和方向
- en: 'Now that we have told the ball to start in the center of the screen as default,
    we need to tell the ball how far to move by giving it `x` and `y` coordinates
    for movement:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经告诉球默认从屏幕中心开始，我们需要通过给出移动的 `x` 和 `y` 坐标来告诉球移动多远：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `ball_xv = 3` means that the ball will move `3` pixels along the *x* axis
    each time it is redrawn. The `ball_yv = 3` means that the ball will move `3` pixels
    along the *y* axis each time the screen redraws. This is great as it will help
    us keep the ball going in the speed and direction that we like. Here*, v = velocity*
    which is the magnitude (speed) and direction (*x,y*) of the ball. So, when we
    say `ball_xv = 3`, we are really saying that *the ball moves along the x axis
    at a speed of 3 pixels each time the screen is redrawn*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ball_xv = 3` 表示球每次重绘时将在 *x* 轴上移动 `3` 像素。`ball_yv = 3` 表示球每次屏幕重绘时将在 *y* 轴上移动
    `3` 像素。这很好，因为它将帮助我们保持球以我们喜欢的速度和方向移动。在这里，*v = 速度*，这是速度（大小）和方向（*x,y*）的量。所以当我们说 `ball_xv
    = 3` 时，我们实际上是在说 *球每次屏幕重绘时沿 x 轴以 3 像素的速度移动*。'
- en: Ball – setting the size
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球 - 设置大小
- en: 'The final thing that we will define about the ball is its radius. The radius
    is half of the total width of the ball, as represented in pixels. By setting the
    radius, we set the size. Write the following line of code into your `tiny.py`
    file to represent the ball radius:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要定义的关于球最后的东西是它的半径。半径是球总宽度的二分之一，如像素所示。通过设置半径，我们设置了大小。将以下代码行写入你的 `tiny.py`
    文件以表示球半径：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have defined the characteristics of the ball, make sure to save
    the file. Nobody wants to rewrite lines of working code! Take a look at an example
    of this section of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了球的特点，请确保保存文件。没有人愿意重写正在工作的代码行！看看这个代码段的例子：
- en: '![Ball – setting the size](img/B04681_09_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![球 - 设置大小](img/B04681_09_05.jpg)'
- en: Paddles – starting location and size
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球拍 - 起始位置和大小
- en: In our game, we will have two paddles. Recall that in the beginning of this
    chapter, it was said that there is more than one way to do some of the things
    that we are doing. There are more advanced ways to make the paddles, but it is
    important that you understand each part of the paddle, so we are going to break
    our code down very simply. Later, once you have completed this game, you can do
    some research on creating objects and try creating paddles as objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将有两个球拍。回想一下，在本章的开头，提到我们做某些事情的方式不止一种。有更高级的方法来制作球拍，但了解球拍的每个部分非常重要，因此我们将非常简单地分解我们的代码。一旦你完成了这个游戏，你可以做一些关于创建对象的研究，并尝试将球拍作为对象创建。
- en: 'We will give our paddle four qualities: a starting location on the *x* axis,
    a starting location on the *y* axis, a width, and a height. Each of these numbers
    is a representation in pixels. Below the ball globals, on line 34, add the next
    five lines to your `tiny.py` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给我们的球拍四个特性：*x* 轴上的起始位置，*y* 轴上的起始位置，宽度和高度。这些数字都是像素表示。在球的全局变量下方，在第 34 行，将以下五行代码添加到你的
    `tiny.py` 文件中：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You probably noticed that the code we wrote is for `paddle1`. There are two
    paddles required for Tiny Tennis. We want to give each player a fair start, so
    we will create `paddle2` so that it is equal in size, but it''s located opposite
    `paddle1`. To make the second paddle, start on line 40 and write the next five
    lines of code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们编写的代码是针对`paddle1`的。Tiny网球需要两个挡板。我们希望给每个玩家一个公平的开始，所以我们将创建`paddle2`，使其大小相等，但位于`paddle1`的对侧。为了创建第二个挡板，从第40行开始，写下以下五行代码：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will notice that the `x` coordinate for paddle 2 combines `the screen_width`
    variable, which is the maximum `x` coordinate number (`600`) and then subtracts
    the width of the paddle (`25`) + the `x` coordinate value of paddle 1 (`10`) as
    well. This math allows us to make sure that the paddle is the same distance from
    the right-hand side of the screen as it is from the left-hand side of the screen.
    If you are confused, copy the code into your file and save it. You can play with
    the numbers and see how your paddles change based on each value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到挡板2的`x`坐标结合了`screen_width`变量，这是最大的`x`坐标数（`600`），然后减去挡板的宽度（`25`）加上挡板1的`x`坐标值（`10`）。这种数学运算使我们能够确保挡板与屏幕右侧的距离与屏幕左侧的距离相同。如果你感到困惑，将代码复制到你的文件中并保存。你可以调整数字并查看挡板如何根据每个值变化：
- en: '![Paddles – starting location and size](img/B04681_09_06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Paddles – starting location and size](img/B04681_09_06.jpg)'
- en: Initializing the score
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化分数
- en: 'In order to have a score, we are going to create a variable for each player
    that begins at the default score, zero. As this is a global variable, like the
    other integers, it will change as the game loop runs. For now, we just need to
    have placeholders for each player. So, starting on line 46, add these lines of
    code to your game:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个分数，我们将为每个玩家创建一个变量，该变量从默认分数零开始。由于这是一个全局变量，就像其他整数一样，它将在游戏循环运行时改变。现在，我们只需要为每个玩家提供占位符。因此，从第46行开始，将以下代码行添加到你的游戏中：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have now created all of the global variables that we need to write code
    that is easier to understand. Remember, these are called global variables because
    they can be used throughout the entire code file. Save your file. Then, compare
    your code with the completed code in this screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了所有必要的全局变量，以便编写易于理解的代码。记住，这些被称为全局变量，因为它们可以在整个代码文件中使用。保存你的文件。然后，将你的代码与这个截图中的完成代码进行比较：
- en: '![Initializing the score](img/B04681_09_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Initializing the score](img/B04681_09_07.jpg)'
- en: Testing section 1
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试部分1
- en: 'Now that we have imported libraries, initialized pygame, and created globals
    for colors, the screen, ball, and the paddles, we can run our first tests to check
    how things are going. To test the game, you will need to locate the directory
    where you saved your `tiny.py` file in your terminal/command prompt. In earlier
    games, we made this directory on the desktop. Once you navigate to the directory
    where `tiny.py` is saved, you can run the following commands from the terminal/command
    prompt to see your game so far:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了库，初始化了pygame，并为颜色、屏幕、球和挡板创建了全局变量，我们可以运行我们的第一个测试来检查一切是否正常。为了测试游戏，你需要在终端/命令提示符中找到你保存`tiny.py`文件的目录。在早期的游戏中，我们在桌面上创建了此目录。一旦你导航到保存`tiny.py`的目录，你就可以从终端/命令提示符中运行以下命令来查看你的游戏进度：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you run this command, you should see a window pop up and then close. The
    window will not stay open because we have not written any of the code that runs
    the game; however, if the code runs and there are *NO ERRORS* in your terminal/command
    prompt, then you can keep moving forward with confidence.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，你应该会看到一个窗口弹出然后关闭。窗口不会保持打开，因为我们还没有编写运行游戏的任何代码；然而，如果代码运行且终端/命令提示符中没有错误，那么你可以有信心继续前进。
- en: If there are errors in your code, now is a good time to fix them. Some common
    errors that can take place include syntax errors (using the wrong symbols), typos
    (spelling something incorrectly, such as a Python keyword), or trying to run your
    file from the wrong directory. If you have errors, check for these common errors,
    and fix the mistakes in your code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码中有错误，现在是修复它们的好时机。一些可能发生的常见错误包括语法错误（使用错误的符号）、拼写错误（如拼写Python关键字错误）或尝试从错误的目录运行你的文件。如果你有错误，检查这些常见错误，并修复代码中的错误。
- en: If you get an error that is not one of the aforementioned common errors, you
    can always perform an Internet search to ask a question about the problem you
    are having. It is very common for even experienced developers to use Internet
    searches to find help to fix errors, and there are many websites and blogs that
    people maintain in order to help others learn.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到的不是上述常见错误之一，你总是可以通过进行网络搜索来提问，了解你遇到的问题。即使是经验丰富的开发者也很常见，他们会使用网络搜索来寻找帮助以修复错误，而且有许多网站和博客是由人们维护的，以帮助他人学习。
- en: Section 2 – moving the paddles
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 部分 – 移动球拍
- en: Now we finally get to write the code that will make our paddles appear on the
    screen and allow us to control the paddle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于可以编写将使我们的球拍出现在屏幕上并允许我们控制球拍的代码了。
- en: 'This is where we get the chance to use the logic and loops that we learned
    about in earlier chapters. In a game such as Tiny Tennis, many decisions are made
    very quickly. Computers are great at making fast decisions based on our instructions.
    Here are the parts of the code that will be in the next section:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们有机会使用我们在前面章节中学到的逻辑和循环的地方。在像 Tiny Tennis 这样的游戏中，许多决策都非常快地做出。计算机擅长根据我们的指令做出快速决策。以下是下一节中将包含的代码部分：
- en: Creating the `while` loop
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `while` 循环
- en: Key events
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘事件
- en: We will code these next pieces step by step, and then test the code by running
    it to check whether there are any errors. It is suggested that you read through
    this whole section before you start coding so that you know what to expect. Once
    you have read through everything, the fun starts!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步编写这些代码，然后通过运行代码来测试是否有任何错误。建议你在开始编码之前阅读整个部分，以便知道可以期待什么。一旦你阅读完所有内容，乐趣就开始了！
- en: Pre-loop actions
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环前动作
- en: 'Before we actually create the `while` loop, there are two actions that we will
    code. The first is to ensure that the cursor disappears when it goes over the
    game screen, so it is not an interruption. There is a special function for this
    behavior in pygame:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际创建 `while` 循环之前，我们将编写两个动作。第一个是确保当光标移过游戏屏幕时，光标消失，这样就不会造成干扰。在 pygame 中有一个特殊的功能来实现这种行为：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By setting the visibility to `0`, we make the mouse/cursor invisible to the
    game. Since we do not need the mouse in the game, it is okay for us to do this.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将可见性设置为 `0`，我们使鼠标/光标对游戏不可见。由于我们不需要在游戏中使用鼠标，这样做对我们来说是可以接受的。
- en: 'The second action is to set the global variable for our `while` loop. We are
    going to call our main game loop variable `do_main`. We will set `do_main = True`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个动作是设置我们的 `while` 循环的全局变量。我们将把我们的主游戏循环变量命名为 `do_main`。我们将设置 `do_main = True`：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that syntax and case (uppercase or lowercase) are important. Notice
    the *CAPITAL* letter *T*, and make sure to copy it exactly as it is. Remember,
    *True* is a Boolean that needs to be written with a capital *T*. Now, we are ready
    to write our `while` loop.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，语法和大小写（大写或小写）很重要。注意 *大写* 字母 *T*，并确保完全按照它复制。记住，*True* 是一个布尔值，需要用大写 *T* 来书写。现在，我们已经准备好编写我们的
    `while` 循环了。
- en: Creating the while loop
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 `while` 循环
- en: 'Our game loop will be a `while` loop. We will use `do_main` as our `True` statement.
    So, you will have another line of code that looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏循环将是一个 `while` 循环。我们将使用 `do_main` 作为我们的 `True` 语句。因此，你将会有另一行代码看起来像这样：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make sure you place a colon (`:`) at the end of the line. Also, all of the
    other lines of code in the game loop will be indented at least once because they
    all need to be *INSIDE* of the loop to run. Here is a screenshot of the `while`
    loop:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在行的末尾放置一个冒号 (`:`)。此外，游戏循环中的所有其他代码行至少缩进一次，因为它们都需要在循环内运行才能执行。以下是 `while` 循环的截图：
- en: '![Creating the while loop](img/B04681_09_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![创建 `while` 循环](img/B04681_09_08.jpg)'
- en: Moving the paddles – keyboard events
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动球拍 – 键盘事件
- en: The first set of events in the `while` loop are keyboard events. These events
    take place when a key or set of keys get pressed. The events use the `if`/`elif`
    logic. All of them are indented on at least one tab, and some are indented on
    two tabs or more. Remember that indents are an organizational tool in Python and
    help us keep track of when certain code should be run.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环中的第一组事件是键盘事件。这些事件发生在按键或一组按键被按下时。这些事件使用 `if`/`elif` 逻辑。所有这些事件至少缩进一个制表符，有些则缩进两个或更多制表符。记住，在
    Python 中缩进是一种组织工具，有助于我们跟踪某些代码应该在何时运行。'
- en: 'Notice the code on line 54 of the screenshot. In line 54, we will create the
    pressed variable, which we will set equal to the `pygame.key.get_pressed()` function.
    This will give us a shorter reference to the function. Type this code in line
    54:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意截图中的第54行代码。在第54行，我们将创建一个名为pressed的变量，并将其设置为`pygame.key.get_pressed()`函数。这将给我们一个更短的函数引用。将此代码输入到第54行：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In line 55, we use the `pygame.key.set_repeat()` function. This tells the computer
    that once a key is pressed, the action that the key performs should continue until
    the user lets the key go. Type the next line of code into line 55 of your `tiny.py`
    file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第55行，我们使用`pygame.key.set_repeat()`函数。这告诉计算机，一旦按下某个键，该键执行的动作应继续，直到用户松开该键。将下一行代码输入到你的`tiny.py`文件的第55行：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have set the variable and characteristics for the keyboard events,
    we will create our first loop, a `for` loop that looks for the player to quit.
    Using a `for` loop, we will loop over each event that is found using the `pygame.event.get()`
    function. If the event is a *QUIT* event, then the `while` loop will automatically
    end. You will notice that we also use our `if` logic here so that we can tell
    the computer to make a decision if it finds the quit event. To make this `for`
    loop, you will write the following lines of code, starting on line 56 of your
    code file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了键盘事件的变量和特性，我们将创建第一个循环，一个用于查找玩家是否退出的`for`循环。使用`for`循环，我们将遍历使用`pygame.event.get()`函数找到的每个事件。如果事件是*QUIT*事件，则`while`循环将自动结束。你会注意到我们在这里也使用了我们的`if`逻辑，以便告诉计算机在找到退出事件时做出决定。为了创建这个`for`循环，你将编写以下代码行，从你的代码文件的第56行开始：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have told the computer how and when to end the `while` loop, we
    can tell the computer what to do when certain keys are pressed. For our Tiny Tennis
    game, we need to assign keys to exit the game as well as ones to control paddle
    1 and paddle 2.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经告诉计算机如何以及何时结束`while`循环，我们可以告诉计算机在按下某些键时应该做什么。对于我们的Tiny Tennis游戏，我们需要分配键来退出游戏，以及控制1号和2号橡皮球的键。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Want to choose different keys than the ones we use in this book? You can find
    an entire list of how to use every keyboard key on the pygame website at [http://www.pygame.org/docs/ref/key.html](http://www.pygame.org/docs/ref/key.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 想要选择不同于本书中使用的键？你可以在pygame网站上找到如何使用每个键盘键的完整列表，网址为[http://www.pygame.org/docs/ref/key.html](http://www.pygame.org/docs/ref/key.html)。
- en: Exiting the game – escape key
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出游戏 – Esc键
- en: 'To exit the game, we will use the *Esc* key. You will notice that we use our
    pressed variable followed by the key code for the *Esc* key. Starting from line
    60, type these two lines of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出游戏，我们将使用*Esc*键。你会注意到我们使用了pressed变量，后面跟着*Esc*键的键码。从第60行开始，输入以下两行代码：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The lines of code tell the computer that if the *Esc* key is pressed, then the
    `do_main` global variable should be set to `False`. When `do_main` is set to Boolean
    `False`, then the `while` loop stops. We will write the code that ends the game
    a bit later.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行数告诉计算机，如果按下*Esc*键，则`do_main`全局变量应设置为`False`。当`do_main`设置为布尔值`False`时，`while`循环将停止。我们将在稍后编写结束游戏的代码。
- en: Paddle control – player 1
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 橡皮球控制 – 玩家1
- en: 'For player 1''s paddle to go up, we will use the *W* key. For player 1''s paddle
    to go down, we will use the *S* key. These are very typical keys to use for computer
    game controls. Notice which letters are uppercase and which are lowercase, and
    be sure to copy them exactly, starting from line 63:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家1的橡皮球向上移动，我们将使用*W*键。为了让玩家1的橡皮球向下移动，我们将使用*S*键。这些是非常典型的用于电脑游戏控制的键。注意哪些字母是大写，哪些是小写，并确保从第63行开始完全复制它们：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Paddle control – player 2
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 橡皮球控制 – 玩家2
- en: 'Player 2 also needs to have keyboard controls that work to move his/her paddle
    up and down at the same time as player 1\. This means that we must assign different
    keys for the second paddle. For this game, we are using the up arrow key to move
    paddle 2 up and the down arrow key to move paddle 2 down. Type the following lines
    of code into your `tiny.py` file, starting from line 68:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2也需要有键盘控制，以便在玩家1同时上下移动橡皮球时移动他的/她的橡皮球。这意味着我们必须为第二个橡皮球分配不同的键。对于这个游戏，我们使用上箭头键来移动2号橡皮球向上，使用下箭头键来移动2号橡皮球向下。将以下代码行输入到你的`tiny.py`文件中，从第68行开始：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Save your work!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的工作！
- en: The increase and decrease value (-= and +=)
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加和减少值（-= 和 +=）
- en: You will notice the **-=** and **+=** symbols in this code. These symbols are
    used as shortcuts to increase or decrease the value of something. In the code
    for moving the paddles, we use these symbols to add or subtract values when the
    paddle keys are pressed. Both the -= and += symbols are very important for setting
    the proper paddle position each time the paddles are moved by the user.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到代码中的**-**= 和 **+**= 符号。这些符号用作增加或减少某个值值的快捷方式。在移动挡板的代码中，我们使用这些符号在按下挡板键时添加或减去值。
    -= 和 += 符号对于每次用户移动挡板时设置正确的挡板位置都非常重要。
- en: Testing section 2
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试部分 2
- en: 'Time to test our code again. In your terminal/command prompt, locate the directory
    where you saved your `tiny.py` file. In earlier games, we made this directory
    on the desktop. Once you navigate to the directory where `tiny.py` is saved, you
    can run the following command from the terminal/command prompt to see your game
    so far:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候再次测试我们的代码了。在你的终端/命令提示符中，找到你保存`tiny.py`文件的目录。在早期的游戏中，我们在桌面上创建了此目录。一旦你导航到保存`tiny.py`的目录，你可以在终端/命令提示符中运行以下命令来查看你的游戏进度：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'During this test, you will see a window open that says **Tiny Tennis** at the
    top and is totally blank otherwise. See this screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次测试中，你将看到一个窗口打开，顶部写着**Tiny Tennis**，其他部分完全空白。请看以下截图：
- en: '![Testing section 2](img/B04681_09_09.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![测试部分 2](img/B04681_09_09.jpg)'
- en: If you are getting errors, remember to check your code for typos, syntax errors,
    and case errors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到了错误，请记住检查你的代码是否有拼写错误、语法错误和大小写错误。
- en: Section 3 – moving the ball
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3节 – 移动球
- en: Now that we have written and tested the code for the paddles, we need to write
    code to move the ball. We will be changing the location of the ball with some
    of our code, and we will create something called collision detection.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写并测试了挡板的代码，我们需要编写移动球的代码。我们将通过一些代码更改球的位置，并创建一个称为碰撞检测的东西。
- en: Moving the ball – updating the location
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动球 – 更新位置
- en: 'First, we need to be constantly calculating the `x` and `y` coordinates of
    the ball based on the velocity of the ball that we set in the global variables.
    This allows us to make constant updates as long as we are playing the game. To
    make sure that the `x` and `y` coordinates of the ball update as the ball moves,
    you will type the following lines of code, starting from line 74:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要根据我们在全局变量中设置的球的速度，不断计算球的`x`和`y`坐标。这允许我们在玩游戏的过程中不断更新。为了确保球的`x`和`y`坐标随着球的运动而更新，你将输入以下代码行，从第74行开始：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Collision detection
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: 'Our next job is to code something called **collision detection**. This means
    that we can program the computer to know when two objects are hitting one another.
    We can also tell the computer what we want it to do when the objects collide.
    In Tiny Tennis, we have three kinds of collisions that we want to detect:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是编写一个称为**碰撞检测**的代码。这意味着我们可以编程让计算机知道两个物体何时相互碰撞。我们还可以告诉计算机当物体碰撞时我们希望它做什么。在Tiny
    Tennis中，我们想要检测三种类型的碰撞：
- en: Collision of the ball with the top and bottom of the screen
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球与屏幕顶部和底部的碰撞
- en: Collision of the paddle with the top and bottom of the screen
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挡板与屏幕顶部和底部的碰撞
- en: Collision of the ball with the paddle
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球与挡板的碰撞
- en: Collision of the ball with the top and the bottom of the screen
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 球与屏幕顶部和底部的碰撞
- en: 'Next, we will use our `if` statement to define what happens if the ball hits
    the top or the bottom of the screen. Basically, we want the ball to bounce back
    if it hits the top or bottom of the screen. Type the following code starting from
    line 77 of your `tiny.py` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们的`if`语句来定义如果球击中屏幕的顶部或底部会发生什么。基本上，我们希望球在击中屏幕的顶部或底部时弹回。从你的`tiny.py`文件的第77行开始输入以下代码：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line, beginning with `if`, basically says *If the radius is subtracted
    from the y coordinate and that is less than or equal to zero OR if the radius
    is added to the y coordinate and it is greater than the number of the screen height
    (400), then do something about it*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，以`if`开头，基本上表示*如果从y坐标减去半径且结果小于或等于零，或者如果将半径加到y坐标且结果大于屏幕高度数（400），那么就对此采取行动*。
- en: 'The second line of the code that comes after the colon tells us what to do:
    *the velocity of the y coordinate of the ball should be in the reverse direction*.
    The second line of code, `ball_yv *= -1`, means that the velocity of the `y` coordinate
    gets reversed because it is multiplied by `-1`. Any number multiplied by `-1`
    becomes opposite to its original sign, and, in this case, reversing the sign means
    reversing the direction of the ball.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号之后的代码的第二行告诉我们该做什么：*球的y坐标速度应反向*。代码的第二行`ball_yv *= -1`意味着`y`坐标的速度被反转，因为它乘以了`-1`。任何数乘以`-1`都会变成其原始符号的相反数，在这种情况下，反转符号意味着反转球的方向。
- en: So, why does this code work? Let's think about it. The top `y` coordinate is
    zero. If the ball tries to move past the top, its `y` value will be less than
    zero, which means that it will be out of the screen. To make the ball stay on
    the screen, we change its direction when the `y` coordinate value is less than
    zero.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这段代码能工作呢？让我们来思考一下。顶部的`y`坐标是零。如果球试图穿过顶部，它的`y`值将小于零，这意味着它将超出屏幕。为了使球保持在屏幕上，我们在`y`坐标值小于零时改变球的方向。
- en: The bottom `y` coordinate is `400`. So, if the ball's `y` value is greater than
    `400`, then we change the direction of the ball to go back up. We make these directional
    changes by multiplying the velocity of the ball by `-1`, resulting in a directional
    change.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的`y`坐标是`400`。因此，如果球的`y`值大于`400`，那么我们就改变球的方向，让它向上移动。我们通过将球的速度乘以`-1`来实现这些方向变化，从而改变方向。
- en: 'Before moving on, compare your code to this code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，比较你的代码与以下代码：
- en: '![Collision of the ball with the top and the bottom of the screen](img/B04681_09_10.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![球与屏幕上下方的碰撞](img/B04681_09_10.jpg)'
- en: Collision of the paddle with the top and the bottom of screen
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 球拍与屏幕上下方的碰撞
- en: 'We want the paddle to stop when it reaches the top or bottom of the screen.
    To make this happen, we need to create a code that will recognize the `y` value
    of the paddle and then stop the paddle from moving beyond the two `y` values that
    create the screen borders. These two values are `0` for the top of the screen,
    and `400` for the bottom. Copy the following lines of code into your program,
    starting from line 81\. Check to make sure that your indent level is correct:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望球拍在达到屏幕的顶部或底部时停止。为了实现这一点，我们需要创建一个代码，它可以识别球拍的`y`值，然后阻止球拍移动超过创建屏幕边界的两个`y`值。这两个值是屏幕顶部的`0`和屏幕底部的`400`。将以下代码行复制到你的程序中，从第81行开始。确保你的缩进级别是正确的：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code works differently from the ball code because we do not want the paddles
    to bounce around! Instead, we want the paddles to stop when they hit the top or
    bottom of the screen. So, you will notice that whenever paddle 1 or paddle 2 goes
    beyond the barriers of the screen (`0` and `400`), the value of the paddle is
    reset to *EQUAL* the boundary values of `0` or `400`, depending on *WHERE* the
    paddle is located (is it at the top of the screen or the bottom?). Save your work
    once you are done with adding this code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与球代码的工作方式不同，因为我们不希望球拍在屏幕周围弹跳！相反，我们希望球拍在碰到屏幕的上下方时停止。所以，你会注意到，每当球拍1或球拍2超出屏幕的障碍（`0`和`400`），球拍值就会重置为*等于*边界值`0`或`400`，具体取决于*球拍的位置在哪里*（是在屏幕顶部还是底部？）。完成添加此代码后，保存你的工作。
- en: Collision of the ball with the paddles
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 球与球拍的碰撞
- en: The collision of the ball with the paddles will determine what happens when
    the ball hits the paddle. There are two paddles, and it will be helpful if you
    add some comment code using a hashtag to keep track of the code for the left-hand
    side paddle (paddle 1) and the right-hand side paddle (paddle 2).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 球与球拍的碰撞将决定球击中球拍时会发生什么。有两个球拍，如果你能添加一些使用井号`#`作为注释的代码来跟踪左侧球拍（球拍1）和右侧球拍（球拍2）的代码，这将很有帮助。
- en: 'Now that we have done some collision detection, let''s think about the ball
    and paddle. When the ball hits the paddle, we want the ball to appear as though
    it has bounced off of the paddle. Therefore, we need to make sure that the result
    of the collision between the ball and the paddle is that the ball reverses itself
    and goes in the opposite direction. This is actually the same behavior that we
    used to make the ball bounce off the edges of the screen, except now we need to
    outline all the pieces of paddle 1 and paddle 2\. Copy these lines of code into
    your file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进行了一些碰撞检测，让我们考虑球和挡板。当球击中挡板时，我们想让球看起来像是从挡板弹回的。因此，我们需要确保球和挡板碰撞的结果是球反转并朝相反方向移动。这实际上是我们用来让球从屏幕边缘弹回的行为，但现在我们需要概述挡板1和挡板2的所有部分。将这些代码行复制到你的文件中：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Take a look at this screenshot, and compare your code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这张截图，比较一下你的代码：
- en: '![Collision of the ball with the paddles](img/B04681_09_11.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![球与挡板的碰撞](img/B04681_09_11.jpg)'
- en: Testing – section 3
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 – 第3节
- en: 'You are almost done writing the game! Now it''s time to test our code again.
    In your terminal/command prompt, locate the directory where you saved your `tiny.py`
    file. You can run the following command from the terminal/command prompt to check
    the progress of your game so far:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎完成了游戏的编写！现在是我们再次测试代码的时候了。在你的终端/命令提示符中，找到你保存`tiny.py`文件的目录。你可以从终端/命令提示符中运行以下命令来检查游戏到目前为止的进度：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: During this test, if everything is working correctly, your results will be the
    same as the test from Section 2\. A blank screen will open and will be called
    Tiny Tennis. Congratulations!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次测试中，如果一切正常，你的结果将与第2节的测试相同。将打开一个空白屏幕，并被称为Tiny Tennis。恭喜你！
- en: If your program has some errors while running, look at the error messages to
    check whether you can figure out what is going wrong. Look for syntax mistakes,
    spelling mistakes, indentation mistakes, or any other errors in your code. Make
    sure that you are using spaces for your indentations, not tabs, or else you might
    have problems as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序在运行时出现一些错误，查看错误信息以检查你是否能找出问题所在。寻找语法错误、拼写错误、缩进错误或代码中的任何其他错误。确保你使用空格进行缩进，而不是制表符，否则你也可能会遇到问题。
- en: Section 4 – draw screen and track the score
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4节 – 绘制屏幕并跟踪得分
- en: So, we know that the ball bounces off the top and bottom of the screen as well
    as off the paddles. However, if the user misses the ball with the paddle, what
    happens to the ball? What happens to the player and their score?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道球会从屏幕的顶部和底部以及挡板弹回。然而，如果用户用挡板没有接住球，球会发生什么？玩家和他们的得分会发生什么变化？
- en: 'In this section of the game, we use the location of the `x` coordinates to
    determine whether the ball is on the screen or it has gone past the paddles and
    is outside the screen. We use our `if` statement to tell the computer what to
    do. The *x* axis `0` coordinate is the left-most side of the screen. If the ball''s
    `x` value is less than `0`, then the player on the other side (player 2) has scored
    a point because player 1 failed to block the ball. If you read the lines of code,
    you will notice that we reset the `ball_x` and `ball_y` coordinates to the center
    of the screen so that a new game can start. Copy the next four lines of code to
    place this logic into the game:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏部分，我们使用`x`坐标的位置来判断球是否在屏幕上，或者它是否已经过了挡板，现在在屏幕外。我们使用`if`语句告诉计算机该做什么。`x`轴的`0`坐标是屏幕的最左侧。如果球的`x`值小于`0`，那么另一边的玩家（玩家2）得了一分，因为玩家1没有挡住球。如果你阅读代码行，你会注意到我们将`ball_x`和`ball_y`坐标重置为屏幕中心，以便新游戏可以开始。将以下四行代码复制到游戏中以放置此逻辑：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will notice that the next four lines of code are almost identical, with
    only two changes. The ball''s `x` value is now being compared to the maximum screen
    width, which is `600`. If the ball''s `x` value becomes greater than `600`, it
    means that the player has missed the ball and the ball is now outside of the screen.
    Now, player 1 has scored because player 2 did not block the ball. To make sure
    that this logic is also in the game, copy the next four lines of code into your
    file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到接下来的四行代码几乎完全相同，只有两个变化。球的`x`值现在正在与最大屏幕宽度`600`进行比较。如果球的`x`值大于`600`，这意味着玩家没有接住球，球现在在屏幕外。现在，玩家1得分了，因为玩家2没有挡住球。为了确保这个逻辑也在游戏中，将以下四行代码复制到你的文件中：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Section 4 – draw screen and track the score](img/B04681_09_12.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![第4节 – 绘制屏幕和跟踪分数](img/B04681_09_12.jpg)'
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Ensure that you save your work!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你保存了你的工作！
- en: The render screen – show what's happened
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染屏幕 – 显示发生了什么
- en: 'The final code that we need to write is the code that redraws the screen and
    all of the objects so that the movements appear to happen. The next lines of code
    draw the five objects that are a part of our game. There is no need to use variable
    names to draw the paddles, net, or the balls, except that it does make them easier
    to find if you want to fix or change that part of the code. Again, these lines
    of code are indented so that they are inside of the `while` loop:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写的最后一部分代码是重绘屏幕和所有对象的代码，这样运动的画面就会看起来像真的发生了。接下来的几行代码绘制了我们游戏中的五个对象。没有必要使用变量名来绘制挡板、网或球，除非这样做确实使它们更容易找到，如果你想要修复或更改代码的这一部分。同样，这些代码行是缩进的，这样它们就位于
    `while` 循环内部：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `game_screen.fill(black)` code uses our `game_screen` variable and tells
    the `fill()` function to make our screen black by putting the color `black` in
    parentheses. Did you notice that we used two global variables, `game_screen` and
    `black`, in this line of code? Imagine how much longer the code would be without
    these variables. Imagine that it might be more difficult to read and to change.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`game_screen.fill(black)` 代码使用我们的 `game_screen` 变量，并告诉 `fill()` 函数通过在括号中放入颜色
    `black` 来使我们的屏幕变黑。你注意到我们在这一行代码中使用了两个全局变量 `game_screen` 和 `black` 吗？想象一下，如果没有这些变量，代码会变得多长。想象一下，它可能更难阅读和修改。'
- en: 'You will notice that the `pygame.draw.rect()` function is used to draw the
    paddles, since they are just rectangles. The paddles have the following characteristics:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 `pygame.draw.rect()` 函数被用来绘制挡板，因为它们只是矩形。挡板有以下特性：
- en: Game screen (tells you where they should go)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏屏幕（告诉它们应该去哪里）
- en: Color
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色
- en: An `x` coordinate
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `x` 坐标
- en: A `y` coordinate (to provide a starting location)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `y` 坐标（提供起始位置）
- en: A width
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽度
- en: A height
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度
- en: If you look at the `line()` and `circle()` objects, you will notice that they
    are not too different from the rectangle. Both have a `game_screen` and color
    property. The line object accepts arguments that define a length, width, and *x*
    value for the line. The circle object accepts arguments that define `game_screen`,
    color, and ball characteristics. Since we defined the ball characteristics early
    in the chapter with global variables, we can use them in the `circle()` code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `line()` 和 `circle()` 对象，你会注意到它们与矩形并没有太大的区别。它们都有 `game_screen` 和颜色属性。线对象接受定义线长、宽度和
    *x* 值的参数。圆对象接受定义 `game_screen`、颜色和球特性的参数。由于我们在本章早期使用全局变量定义了球特性，因此我们可以在 `circle()`
    代码中使用它们。
- en: Displaying player scores
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示玩家分数
- en: 'Our next few lines of code will draw the player scores on the screen:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的几行代码将在屏幕上绘制玩家分数：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The top line of our game score code provides the definition for the `score_text`
    variable, which is used in the second line of this code that we just added. The
    `game_screen.blit()` function copies our score text each time our screen is redrawn,
    since the score text may not change for a long time if neither player misses the
    ball.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏分数代码的最上面一行提供了 `score_text` 变量的定义，该变量用于我们刚刚添加的代码的第二行。每次我们的屏幕重绘时，`game_screen.blit()`
    函数都会复制我们的分数文本，因为如果两个玩家都没有错过球，分数文本可能长时间不会改变。
- en: 'Finally, the `pygame.display.update()` function updates the image with the
    new information stored by our program. Because a computer can move at speeds infinitely
    faster than a human, we have added a `sleep` option, allowing for the update to
    occur at an interval that we can now control:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`pygame.display.update()` 函数更新了程序存储的新信息所显示的图像。因为计算机的速度可以无限快于人类，所以我们添加了一个
    `sleep` 选项，允许我们控制更新的间隔：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Ending the program
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束程序
- en: 'The final line of code will be to end the initialization of pygame, which we
    performed at the start of the code. To end this, we will type `pygame.quit()`
    at the outermost level of indentation in our code. This goes outside of the `while`
    loop so that it only happens when the `while` loop stops running:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行将是结束 pygame 的初始化，这是我们代码开始时执行的。为了结束这个，我们将在代码的最外层缩进级别输入 `pygame.quit()`。这将放在
    `while` 循环之外，这样它只会在 `while` 循环停止运行时发生：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once you have typed this, your final game code lines should look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入了这些，你的最终游戏代码行应该看起来像这样：
- en: '![Ending the program](img/B04681_09_13.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![结束程序](img/B04681_09_13.jpg)'
- en: Once you have double-checked your code against the screenshots in the chapter,
    make sure that you save your `tiny.py` file. Now you are ready to truly give your
    game a test!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将你的代码与章节中的截图进行双重检查，确保保存你的`tiny.py`文件。现在你准备好真正对你的游戏进行测试了！
- en: Play Tiny Tennis!
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩Tiny网球！
- en: 'The best part about Tiny Tennis is that you can play it against yourself, making
    it easy to test the game and experiment with different parts of the game. Now,
    when you run the file from your terminal, a window that looks like this should
    pop up:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Tiny网球最好的部分是你可以自己玩，这使得测试游戏和实验游戏的各个部分变得容易。现在，当你从你的终端运行文件时，应该会弹出一个看起来像这样的窗口：
- en: '![Play Tiny Tennis!](img/B04681_09_14.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![玩Tiny网球！](img/B04681_09_14.jpg)'
- en: The ball should start moving immediately toward one side or the other of the
    screen. You can test the game by making sure that the paddles on each side of
    the screen are able to hit the ball and that they do not go outside of the screen
    space. You can test the scoring mechanism to make sure that the appropriate player
    is getting the points for each shot that they make past the other player. Then,
    you can invite others to play the game with you.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 球应该立即向屏幕的一侧或另一侧移动。你可以通过确保屏幕两侧的球拍能够击中球并且它们不会超出屏幕空间来测试游戏。你可以测试得分机制，确保适当的玩家在越过对方玩家时获得每击的分数。然后，你可以邀请其他人和你一起玩游戏。
- en: If you are not happy with parts of the game, you can change them. For example,
    you might choose a different color for the ball, paddles, and the screen. Maybe
    you want the paddles to be longer or shorter or, perhaps, thinner. Maybe you want
    to make the ball bigger or smaller by changing the radius.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对游戏的部分不满意，你可以更改它们。例如，你可能会为球、球拍和屏幕选择不同的颜色。也许你希望球拍更长或更短，或者更薄。也许你想要通过改变半径来使球更大或更小。
- en: You might decide that you want the ball and paddles to move faster so that the
    game is more challenging, or maybe you want the ball and paddles to move slower
    if you are designing the game to be played by younger children. Design choices
    are made for many reasons, and now that you have a playable game, you might decide
    to make some different design decisions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会决定想要球拍移动得更快，以便游戏更具挑战性，或者如果你正在为年幼的孩子设计游戏，你可能希望球拍移动得更慢。设计选择是出于许多原因，现在你有一个可玩的游戏，你可能会决定做出一些不同的设计决策。
- en: You can test your decisions by making a copy of your game code and then testing
    any modifications in your copy. It is a good idea to keep a backup of your working
    code so that if you write broken code, you have a place to return to and start
    again.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过复制你的游戏代码并测试你的副本中的任何修改来测试你的决策。保留你工作代码的备份是个好主意，这样如果你编写了有错误的代码，你就有了一个可以返回并重新开始的地方。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on building your first game! There are so many things that you
    learned to do. The greatest thing about code, though, is that there are many ways
    to do everything. Some ways are easier to understand but not as efficient as other
    ways. Some code is very efficient but might not be easily understood by another
    programmer. The best code is both easy to understand and written in the most efficient
    way possible.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你构建了你的第一个游戏！你学到了很多可以做的事情。然而，代码最伟大的地方在于，做任何事情都有很多种方法。有些方法更容易理解，但可能没有其他方法那么高效。有些代码非常高效，但可能不容易被其他程序员理解。最好的代码既容易理解，又以尽可能高效的方式编写。
- en: Throughout the previous chapter, we used a combination of code that was easy
    to understand, but may not have been as efficient as possible. This is because
    we were learning many new principles in pygame, and things, such as collision
    detection, can be challenging to code. You may decide to do things differently
    after you have a few games under your belt!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了一种易于理解但可能不是最有效率的代码组合。这是因为我们在学习pygame中的许多新原则，而且像碰撞检测这样的东西可能很难编写。在你玩了几款游戏之后，你可能会决定以不同的方式做事！
- en: In the next chapter, we will review all that we have learned in this book, and
    we will also take a look at some other ways that Python is used out in the world,
    as Python is a very useful language to know. See you in the last chapter!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾这本书中学到的所有内容，我们还将看看Python在世界上的一些其他用途，因为Python是一种非常有用的语言。最后一章见！
