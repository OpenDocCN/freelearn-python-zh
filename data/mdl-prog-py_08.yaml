- en: Chapter 8. Testing and Deploying Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。测试和部署模块
- en: 'In this chapter, we will delve further into the concept of sharing modules.
    Before you can share a module or package, you need to test it to ensure that it
    is working properly. You also need to prepare your code and know how to deploy
    it. To learn these things, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步探讨共享模块的概念。在您共享模块或包之前，您需要对其进行测试，以确保其正常工作。您还需要准备您的代码并了解如何部署它。为了学习这些内容，我们将涵盖以下主题：
- en: See how unit tests can be used to ensure that your module or package is working
    properly
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解单元测试如何用于确保您的模块或包正常工作
- en: Learn how to prepare a module or package for publication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何准备模块或包以供发布
- en: Find out how GitHub can be used to share your code with others
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解GitHub如何用于与他人共享您的代码
- en: Examine the steps involved in submitting your code to the Python Package Index
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查提交代码到Python包索引所涉及的步骤
- en: Discover how to use pip to install and use packages written by other people
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用pip安装和使用其他人编写的包
- en: Testing modules and packages
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模块和包
- en: 'Testing is a normal part of programming: you test your code to verify that
    it works and identify any bugs or other problems, which you can then fix. Then,
    you test some more, until you are happy that your code is working correctly.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是编程的正常部分：您测试代码以验证其是否正常工作并识别任何错误或其他问题，然后您可以修复。然后，您继续测试，直到您满意您的代码正常工作为止。
- en: 'All too often, however, programmers just do **ad hoc testing**: they fire up
    the Python interactive interpreter, import their module or package, and make various
    calls to see what happens. In the previous chapter, we looked at a form of ad
    hoc testing using the `importlib.reload()` function to support RAD development
    of your code.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，程序员经常只进行**临时测试**：他们启动Python交互解释器，导入他们的模块或包，并进行各种调用以查看发生了什么。在上一章中，我们使用`importlib.reload()`函数进行了一种临时测试形式，以支持您的代码的RAD开发。
- en: Ad hoc testing is useful, but it isn't the only form of testing. If you are
    sharing your modules and packages with others, you will want your code to be bug-free,
    and ad-hoc testing can't guarantee this. A much better and more systematic approach
    is to create a series of **unit tests** for your module or package. Unit tests
    are snippets of Python code which test various aspects of your code. Because the
    testing is done by a Python program, you can simply run the program whenever you
    want to test your code, and you can be sure that everything is being tested each
    time you run the test. Unit tests are a great way of making sure bugs don't creep
    into your code as you make changes, and you can run them whenever you want to
    share your code to make sure it's working as you expect.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 临时测试很有用，但并不是唯一的测试形式。如果您与他人共享您的模块和包，您将希望您的代码没有错误，并临时测试无法保证这一点。一个更好和更系统的方法是为您的模块或包创建一系列**单元测试**。单元测试是Python代码片段，用于测试代码的各个方面。由于测试是由Python程序完成的，因此您可以在需要测试代码时运行程序，并确保每次运行测试时都会测试所有内容。单元测试是确保在进行更改时错误不会进入您的代码的绝佳方法，并且您可以在需要共享代码时运行它们，以确保其正常工作。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unit tests aren't the only sort of programmatic testing you can do. **Integration
    tests** combine various modules and systems to make sure they work together correctly,
    and **GUI tests** are used to ensure that a program's user interface is working
    as it should.Unit tests are, however, the most useful for testing modules and
    packages, and this is the type of testing we will focus on in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试并不是您可以进行的唯一一种程序化测试。**集成测试**结合各种模块和系统，以确保它们正确地一起工作，**GUI测试**用于确保程序的用户界面正常工作。然而，单元测试对于测试模块和包是最有用的，这也是我们将在本章中重点关注的测试类型。
- en: 'The following is a very simple example of a unit test:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个非常简单的单元测试示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `assert` statement checks the expression that follows it. If this expression
    does not evaluate to `True`, then an `AssertionError` will be raised. This makes
    it easy for you to check that a given function is returning the results you expect;
    in this example, we are checking that the `math.floor()` function is correctly
    returning the largest integer less than or equal to the given floating-point number.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`语句检查其后的表达式。如果此表达式不计算为`True`，则会引发`AssertionError`。这使您可以轻松检查给定函数是否返回您期望的结果；在此示例中，我们正在检查`math.floor()`函数是否正确返回小于或等于给定浮点数的最大整数。'
- en: Because a module or package is ultimately just a collection of Python functions
    (or methods, which are just functions grouped into classes), it is quite possible
    to write a series of `assert` statements that call your functions and check that
    the returned values are what you would expect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模块或包最终只是一组Python函数（或方法，它们只是分组到类中的函数），因此很可能编写一系列调用您的函数并检查返回值是否符合预期的“assert”语句。
- en: 'Of course, this is a simplification: often the results of calling one function
    will affect the output of another function, and your functions can sometimes perform
    quite complex actions such as communicating with a remote API or storing data
    into a file on disk. In many cases, though, you can still use a series of `assert`
    statements to verify that your modules and packages are working the way you would
    expect.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个简化：通常调用一个函数的结果会影响另一个函数的输出，并且您的函数有时可以执行诸如与远程API通信或将数据存储到磁盘文件中等相当复杂的操作。然而，在许多情况下，您仍然可以使用一系列“assert”语句来验证您的模块和包是否按您的预期工作。
- en: Testing with the unittest Standard Library module
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用unittest标准库模块进行测试
- en: While you could put your `assert` statements into a Python script and run them,
    a better approach is to use the `unittest` module from the Python Standard Library.
    This module allows you to group your unit tests into **test cases**, run additional
    code before and after the tests are run, and access a whole raft of different
    types of `assert` statements to make your testing easier.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以将您的`assert`语句放入Python脚本中并运行它们，但更好的方法是使用Python标准库中的`unittest`模块。该模块允许您将单元测试分组为**测试用例**，在运行测试之前和之后运行额外的代码，并访问各种不同类型的`assert`语句，以使您的测试更加容易。
- en: 'Let''s see how we can use the `unittest` module to implement a series of unit
    tests for the `quantities` package we implemented in [Chapter 6](ch06.html "Chapter 6. Creating
    Reusable Modules"), *Creating Reusable Modules*. Place a copy of this package
    into a convenient directory and create a new Python source file named `test_quantities.py`
    in the same directory. Then, add the following code to this file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`unittest`模块为我们在[第6章](ch06.html "第6章. 创建可重用模块")中实现的`quantities`包实施一系列单元测试。将此包的副本放入一个方便的目录中，并在同一目录中创建一个名为`test_quantities.py`的新的Python源文件。然后，将以下代码添加到此文件中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that you don't need to type this program in by hand. All of these source
    files, including a complete copy of the `quantities` package, are available as
    part of the sample code which can be downloaded for this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您不需要手动输入此程序。所有这些源文件，包括`quantities`包的完整副本，都作为本章的示例代码的一部分可供下载。
- en: Let's take a closer look at what this code does. First off, the `TestQuantities`
    class is used to hold a number of related unit tests. You would normally define
    a separate `unittest.TestCase` subclass for each of the major groups of unit tests
    that you need to perform. Within our `TestQuantities` class, we define a `setUp()`
    method which contains code that needs to be executed before our tests are run.
    If we wanted to, we could also define a `tearDown()` method that would be executed
    after the tests have been completed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这段代码做了什么。首先，`TestQuantities`类用于保存多个相关的单元测试。通常，您会为需要执行的每个主要单元测试组定义一个单独的`unittest.TestCase`子类。在我们的`TestQuantities`类中，我们定义了一个`setUp()`方法，其中包含需要在运行测试之前执行的代码。如果需要，我们还可以定义一个`tearDown()`方法，在测试完成后执行。
- en: We then define two unit tests, which we have called `test_new()` and `test_convert()`.
    These test the `quantities.new()` and `quantities.convert()` functions, respectively.
    You would typically have a separate unit test for each piece of functionality
    that you need to test. You can call your unit tests anything you like, so long
    as the method name starts with `test`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了两个单元测试，我们称之为`test_new()`和`test_convert()`。它们分别测试`quantities.new()`和`quantities.convert()`函数。您通常会为需要测试的每个功能单独创建一个单元测试。您可以随意命名您的单元测试，只要方法名以`test`开头即可。
- en: Within our `test_new()` unit test, we create a new quantity and then call the
    `self.assertEqual()` method to ensure that the expected quantity was created.
    As you can see, we're not just limited to using the built-in `assert` statement;
    there are dozens of different `assertXXX()` methods that you can call to test
    your code in various ways. All of these will raise an `AssertionError` if the
    assertion fails.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`test_new()`单元测试中，我们创建一个新的数量，然后调用`self.assertEqual()`方法来确保已创建预期的数量。正如您所见，我们不仅仅局限于使用内置的`assert`语句；您可以调用几十种不同的`assertXXX()`方法来以各种方式测试您的代码。如果断言失败，所有这些方法都会引发`AssertionError`。
- en: The last part of our testing script calls `unittest.main()` when the script
    is executed. This function looks for any `unittest.TestCase` sub-classes that
    you have defined and runs each test case in turn. For each test case, the `setUp()`
    method is called if it exists, followed by the various `testXXX()` methods that
    you have defined, and finally, the `teardown()` method is called if it exists.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试脚本的最后部分在脚本执行时调用`unittest.main()`。这个函数会查找您定义的任何`unittest.TestCase`子类，并依次运行每个测试用例。对于每个测试用例，如果存在，将调用`setUp()`方法，然后调用您定义的各种`testXXX()`方法，最后，如果存在，将调用`teardown()`方法。
- en: 'Let''s try running our unit test. Open up a terminal or command-line window,
    use the `cd` command to set the current directory to the directory holding your
    `test_quantities.py` script, and try typing the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行我们的单元测试。打开一个终端或命令行窗口，使用`cd`命令将当前目录设置为包含您的`test_quantities.py`脚本的目录，并尝试输入以下内容：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All going well, you should see the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利的话，您应该会看到以下输出：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By default, the `unittest` module doesn''t show you much about the tests that
    have been run, other than that it ran your unit tests without any problems. If
    you want more detail, you can increase the **verbosity** of your tests, for example
    by adding a parameter to the `unittest.main()` statement in your test script:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`unittest`模块不会显示有关已运行的测试的详细信息，除了它已经无问题地运行了您的单元测试。如果您需要更多细节，您可以增加测试的**详细程度**，例如通过在测试脚本中的`unittest.main()`语句中添加参数：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, you can use the `-v` command-line option to achieve the same
    result:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`-v`命令行选项来实现相同的结果：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Designing your unit tests
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计您的单元测试
- en: The aim of unit testing is to check that your code is working. A good rule of
    thumb is to have a separate test case for each publicly accessible module within
    your package and a separate unit test for each feature provided by that module.
    The unit test code should aim to test at least the usual operation of the feature
    to make sure it works. If you wish, you can also choose to write additional testing
    code within your unit tests, or even additional unit tests, to check for particular
    **edge cases** in your code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的目的是检查您的代码是否正常工作。一个很好的经验法则是为包中的每个公共可访问模块单独编写一个测试用例，并为该模块提供的每个功能单独编写一个单元测试。单元测试代码应该至少测试功能的通常操作，以确保其正常工作。如果需要，您还可以选择在单元测试中编写额外的测试代码，甚至额外的单元测试，以检查代码中特定的**边缘情况**。
- en: 'To use a concrete example, in the `test_convert()` method we wrote in the previous
    section, you might want to add code to check that a suitable exception is raised
    if the user tries to convert a distance into a weight. For example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 举个具体的例子，在我们在前一节中编写的`test_convert()`方法中，您可能希望添加代码来检查如果用户尝试将距离转换为重量，则是否会引发适当的异常。例如：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The question is: how many edge cases should you test for? There are potentially
    hundreds of different ways in which someone can use your module incorrectly. Should
    you write unit tests for each of these?'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：您应该为多少边缘情况进行测试？有数百种不同的方式可以使用您的模块不正确。您应该为这些每一种编写单元测试吗？
- en: In general, no. It isn't worth your while trying to test every possible edge
    case. Certainly, you may wish to test a few of the main possibilities, just to
    make sure your module is able to handle the most obvious errors, but beyond this,
    writing additional tests probably isn't worth the effort.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，不值得尝试测试每种可能的边缘情况。当然，您可能希望测试一些主要可能性，只是为了确保您的模块能够处理最明显的错误，但除此之外，编写额外的测试可能不值得努力。
- en: Code coverage
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖
- en: '**Coverage** is a measure of how much of your code is being tested by your
    unit tests. To understand how this works, consider the following Python function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**覆盖率**是您的单元测试测试了您的代码多少的度量。要理解这是如何工作的，请考虑以下Python函数：'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have added line numbers to the start of each line to help us calculate the
    code coverage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在每一行的开头添加了行号，以帮助我们计算代码覆盖率。
- en: 'Now, imagine that we create the following unit test code for our `calc_score()`
    function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们为我们的`calc_score()`函数创建以下单元测试代码：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How much of the `calc_score()` function has our unit test covered? Our first
    `assert` statement is calling `calc_score()` with `x` `as` `1` and `y` `as` `5`.
    If you follow the line numbers, you'll see that calling this function with this
    set of parameters will cause lines 1, 2, 3, and 9 to be executed. Similarly, the
    second `assert` statement calls `calc_score()` with `x` `as` `2` and `y` `as`
    `10`, causing lines 1, 4, 5, and 9 to be executed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试覆盖了`calc_score()`函数的多少？我们的第一个`assert`语句调用`calc_score()`，`x`为`1`，`y`为`5`。如果您按照行号，您会发现使用这组参数调用此函数将导致执行第1、2、3和9行。类似地，第二个`assert`语句调用`calc_score()`，`x`为`2`，`y`为`10`，导致执行第1、4、5和9行。
- en: In total, these two assert statements caused lines 1, 2, 3, 4, 5, and 9 to be
    executed. Ignoring the blank line, our test did not include lines 6 and 7\. Thus,
    our unit test has covered six of the eight lines in our function, giving us a
    code coverage value of 6/8 = 75%.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这两个assert语句导致执行第1、2、3、4、5和9行。忽略空行，我们的测试没有包括第6和第7行。因此，我们的单元测试覆盖了函数中的八行中的六行，给我们一个代码覆盖率值为6/8
    = 75%。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are looking at **statement coverage** here. There are other, more complicated,
    ways of measuring code coverage which we won't get into here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看的是**语句覆盖率**。还有其他更复杂的衡量代码覆盖率的方法，我们在这里不会深入讨论。
- en: Obviously, you won't calculate code coverage by hand. There are some excellent
    tools that will calculate code coverage for your Python testing code. Take a look,
    for example, at the `coverage` package ([https://pypi.python.org/pypi/coverage](https://pypi.python.org/pypi/coverage)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您不会手动计算代码覆盖率。有一些出色的工具可以计算Python测试代码的代码覆盖率。例如，看看`coverage`包（[https://pypi.python.org/pypi/coverage](https://pypi.python.org/pypi/coverage)）。
- en: The basic concept of code coverage is that you want your tests to cover *all*
    your code. Whether or not you use a tool such as `coverage` to measure code coverage,
    it's a good idea to write your unit tests to include as close to 100% of your
    code as possible.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖的基本概念是，您希望您的测试覆盖*所有*您的代码。无论您是否使用诸如`coverage`之类的工具来衡量代码覆盖率，编写单元测试以尽可能包含接近100%的代码是一个好主意。
- en: Test-driven development
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: While we are looking at the idea of testing Python code, it is worth mentioning
    the concept of **test-driven development**. Using test-driven development, you
    first choose what you want your module or package to do, and then you write unit
    tests to ensure that the module or package works the way you want it to—*before
    you write it*. In this way, the unit tests act as a kind of specification for
    the module or package; they tell you what your code should do, and your task is
    then to write the code so that it passes all the tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑测试Python代码的想法时，值得提到**测试驱动开发**的概念。使用测试驱动开发，您首先选择您希望您的模块或包执行的操作，然后编写单元测试以确保模块或包按照您的期望工作—*在您编写它之前*。这样，单元测试充当了模块或包的一种规范；它们告诉您您的代码应该做什么，然后您的任务是编写代码以使其通过所有测试。
- en: Test-driven development can be a useful way of implementing your modules and
    packages. Whether or not you use it, of course, is up to you—but if you have the
    discipline to write the unit tests first, test-driven development can be a great
    way of making sure you've implemented your code correctly, and your modules continue
    to do what you expect them to as your code grows and changes over time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发可以是实现模块和包的有用方式。当然，您是否使用它取决于您，但是如果您有纪律写单元测试，测试驱动开发可以是确保您正确实现了代码的一个很好的方式，并且您的模块在代码增长和变化的过程中继续按照您的期望工作。
- en: Mocking
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mocking
- en: If your module or package calls an external API or performs some other complex,
    expensive, or time-consuming operation, you may want to investigate the `unittest.mock`
    package in the Python Standard Library. **Mocking** is the process of replacing
    some functionality in your program with a dummy function that immediately returns
    suitable data for testing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的模块或包调用外部API或执行其他复杂、昂贵或耗时的操作，您可能希望在Python标准库中调查`unittest.mock`包。**Mocking**是用程序中的虚拟函数替换某些功能的过程，该虚拟函数立即返回适合测试的数据。
- en: Mocking is a complicated process, and it can take some doing to get it right,
    but the technique is absolutely worthwhile if you want to run unit tests over
    code that would otherwise be too slow, cost money each time you ran it, or depends
    on external systems to operate.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是一个复杂的过程，要做对可能需要一些时间，但如果您想要对本来会太慢、每次运行都会花费金钱或依赖外部系统运行的代码运行单元测试，这种技术绝对是值得的。
- en: Writing unit tests for your modules and packages
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的模块和包编写单元测试
- en: Now that we have been introduced to the concept of unit testing, taken a look
    at how the `unittest` standard library module works, and looked at some of the
    more complicated but important aspects of writing unit tests, let's now see how
    unit tests can be used to assist with the development and testing of your modules
    and packages.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了单元测试的概念，看了一下`unittest`标准库模块的工作原理，并研究了编写单元测试的一些更复杂但重要的方面，现在让我们看看单元测试如何可以用来辅助开发和测试您的模块和包。
- en: First off, you should aim to write unit tests for at least the main functions
    defined by your module or package. Start by testing the most important functions,
    and add tests for the more obvious error conditions to make sure errors are being
    handled correctly. You can always add extra tests for the more obscure parts of
    your code later.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该至少为您的模块或包定义的主要函数编写单元测试。从测试最重要的函数开始，并为更明显的错误条件添加测试，以确保错误被正确处理。您可以随时为代码中更隐晦的部分添加额外的测试。
- en: 'If you are writing unit tests for a single module, you should place your test
    code in a separate Python script, named, for example, `tests.py`, and place this
    in the same directory as your module. The following image shows a good way of
    organizing your code when writing a single module:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为单个模块编写单元测试，您应该将测试代码放在一个单独的Python脚本中，例如命名为`tests.py`，并将其放在与您的模块相同的目录中。下面的图片展示了在编写单个模块时组织代码的好方法：
- en: '![Writing unit tests for your modules and packages](graphics/B05012_8_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![为您的模块和包编写单元测试](graphics/B05012_8_01.jpg)'
- en: If you have multiple modules in the same directory, you can either combine the
    unit tests for all the modules into the `tests.py` script, or else rename it to
    something like `test_my_module.py` to make it clear which module is being tested.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在同一个目录中有多个模块，您可以将所有模块的单元测试合并到`tests.py`脚本中，或者将其重命名为类似`test_my_module.py`的名称，以明确测试的是哪个模块。
- en: 'For a package, make sure you place the `tests.py` script in the directory that
    contains the package, not inside the package itself:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个包，确保将`tests.py`脚本放在包所在的目录中，而不是包内部：
- en: '![Writing unit tests for your modules and packages](graphics/B05012_8_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![为您的模块和包编写单元测试](graphics/B05012_8_02.jpg)'
- en: If you place the `test.py` script inside the package directory, you are likely
    to encounter problems when your unit tests attempt to import the package.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`test.py`脚本放在包目录中，当您的单元测试尝试导入包时，您可能会遇到问题。
- en: Your `tests.py` script should define a `unittest.TestCase` object for each publicly
    accessible module in your package, and each of these objects should have a `testXXX()`
    method for each function or major piece of functionality defined within the module.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`tests.py`脚本应该为包中每个公开可访问的模块定义一个`unittest.TestCase`对象，并且这些对象中的每一个都应该有一个`testXXX()`方法，用于定义模块中的每个函数或主要功能。
- en: 'Doing this allows you to test your module or package simply by executing the
    following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以通过执行以下命令简单地测试您的模块或包：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You should run your unit tests whenever you want to check that your module is
    working, and in particular before uploading or sharing your module or package
    with other people.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想要检查您的模块是否工作时，特别是在上传或与其他人分享您的模块或包之前，您应该运行单元测试。
- en: Preparing a module or package for publication
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备模块或包以供发布
- en: 'In [Chapter 6](ch06.html "Chapter 6. Creating Reusable Modules"), *Creating
    Reusable Modules*, we looked at a number of things that make a module or package
    suitable for reuse:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。创建可重用模块")*创建可重用模块*中，我们看了一些使模块或包适合重用的东西：
- en: It must function as a standalone unit
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须作为一个独立的单元运行
- en: A package should ideally use relative imports
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包应该理想地使用相对导入
- en: Any external dependencies in your module or package must be clearly noted
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的模块或包中的任何外部依赖关系必须清楚地注明
- en: 'We also identified three things that help to create an excellent reusable module
    or package:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还确定了三个有助于创建优秀可重用模块或包的东西：
- en: It should solve a general problem
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该解决一个普遍的问题
- en: Your code should follow standard coding conventions
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的代码应该遵循标准的编码约定
- en: Your module or package should be clearly documented
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的模块或包应该有清晰的文档
- en: The first step in preparing your module or package for publication is to ensure
    that you've followed at least the first three of these, and, ideally, all six
    of these guidelines.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 准备您的模块或包以供发布的第一步是确保您至少遵循了这些准则中的前三条，最好是所有六条。
- en: The second step is to make sure that you've written at least a few unit tests
    and your module or package passes all of these. Finally, you will need to decide
    *how* you want to publish your code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是确保您至少编写了一些单元测试，并且您的模块或包通过了所有这些测试。最后，您需要决定*如何*发布您的代码。
- en: If you want to share your code with friends or work colleagues or write a blog
    post along with a link to your code, then the easiest way to do so is to upload
    it to a source code repository such as GitHub. We will take a look at how this
    is done in the next section. Unless you make it private, your code can be accessed
    by anyone who has the correct link. People can view your source code (including
    the documentation) online, download your module or package for use in their own
    programs, and "fork" your code, creating their own private copy which they can
    then modify.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想与朋友或同事分享你的代码，或者写一篇博客文章并附上你的代码链接，那么最简单的方法就是将其上传到GitHub等源代码仓库中。我们将在下一节中看看如何做到这一点。除非你将其设为私有，否则任何拥有正确链接的人都可以访问你的代码。人们可以在线查看你的源代码（包括文档），下载你的模块或包用于他们自己的程序，并且“fork”你的代码，创建他们自己的私人副本，然后进行修改。
- en: If you want to share your code with a wider audience, the best approach is to
    submit it to the **Python Package Index** (**PyPI**). This will mean that others
    can find your module or package by searching through the PyPI index and anyone
    can install it using **pip**, the Python Package Manager. Later sections of this
    chapter will describe how to submit your module or package to PyPI and how pip
    can be used to download and work with modules and packages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想与更广泛的受众分享你的代码，最好的方法是将其提交到**Python Package Index**（**PyPI**）。这意味着其他人可以通过在PyPI索引中搜索来找到你的模块或包，并且任何人都可以使用**pip**，Python包管理器来安装它。本章的后续部分将描述如何将你的模块或包提交到PyPI，以及如何使用pip来下载和使用模块和包。
- en: Uploading your work to GitHub
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的工作上传到GitHub。
- en: GitHub ([https://github.com/](https://github.com/)) is a popular web-based system
    for storing and managing source code. While there are several alternatives, GitHub
    is particularly popular with people writing and sharing open source Python code,
    and this is the source code management system that we will use in this book.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub（[https://github.com/](https://github.com/)）是一个流行的基于Web的存储和管理源代码的系统。虽然有几种替代方案，但GitHub在编写和分享开源Python代码的人中特别受欢迎，这也是我们在本书中将使用的源代码管理系统。
- en: Before delving into the specifics of GitHub, let's start by looking at how source
    code management systems work in general and why you might want to use one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论GitHub的具体内容之前，让我们先看看源代码管理系统是如何工作的，以及为什么你可能想要使用它。
- en: 'Imagine that you are writing a complex module and have opened your module in
    a text editor to make a few changes. While making these changes, you accidentally
    select 100 lines of code and press the *Delete* key. Before you realize what you''ve
    done, you save and close the file. Too late: those 100 lines of text are gone.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在编写一个复杂的模块，并在文本编辑器中打开了你的模块进行一些更改。在进行这些更改的过程中，你不小心选择了100行代码，然后按下了*删除*键。在意识到自己做了什么之前，你保存并关闭了文件。太迟了：那100行文本已经消失了。
- en: Of course, you might (and hopefully will) have a backup system in place which
    keeps regular backups of your source files. But if you had made changes to some
    of the missing code in the past few minutes, you are likely to have lost those
    changes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能（并且希望）有一个备份系统，定期备份你的源文件。但如果你在过去几分钟内对一些丢失的代码进行了更改，那么你很可能已经丢失了这些更改。
- en: Now consider a situation where you've shared a module or package with a colleague,
    and they decide to make a few changes. Perhaps there's a bug that needed fixing
    or a new feature they wanted to add. They change your code and send it back to
    you with a note describing what they've done. Unfortunately, unless you compare
    each line in the original and modified versions of your source files, you can't
    be sure exactly what your colleague has done to your files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑这样一种情况：你与同事分享了一个模块或包，他们决定做一些更改。也许有一个需要修复的错误，或者他们想要添加一个新功能。他们改变了你的代码，并在附有说明的情况下将其发送回给你。不幸的是，除非你比较原始版本和修改后的源文件中的每一行，否则你无法确定你的同事对你的文件做了什么。
- en: A source code management system solves these types of problems. Instead of just
    having a copy of your module or package sitting in a directory on your hard disk,
    you create a **repository** within a source code management system such as GitHub,
    and **commit** your source code to this repository. Then, as you make changes
    to your files, fixing bugs and adding features, you commit each change that you
    make back to the repository. The source code repository keeps track of every change
    you have made, allowing you to see exactly what has been changed over time and,
    where necessary, undoing changes that were made previously.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理系统解决了这些问题。你不仅仅是在硬盘上的一个目录中拥有你的模块或包的副本，而是在像GitHub这样的源代码管理系统中创建一个**仓库**，并将你的源代码**提交**到这个仓库中。然后，当你对文件进行更改，修复错误和添加功能时，你将每个更改都提交回仓库。源代码仓库跟踪了你所做的每一次更改，允许你准确地查看随时间发生的变化，并在必要时撤消先前所做的更改。
- en: You aren't limited to having just one person work on a module or package. People
    can **fork** your source code repository, creating their own private copy of it,
    and then use this private copy to fix bugs and add new features. Once they've
    done this, they can send you a **pull request** which includes the changes they
    have made. You can then decide whether or not to merge those changes into your
    project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅仅局限于让一个人来工作在一个模块或包上。人们可以**fork**你的源代码仓库，创建他们自己的私人副本，然后使用这个私人副本来修复错误和添加新功能。一旦他们这样做了，他们可以向你发送一个**pull
    request**，其中包括他们所做的更改。然后你可以决定是否将这些更改合并到你的项目中。
- en: 'Don''t worry too much about these details, though—source code management is
    a complex topic, and there are lots of sophisticated tricks you can perform using
    tools such as GitHub to manage your source code. The important thing to remember
    is that you create a repository to hold the master copy of the source code for
    your module or package, commit your code into this repository, and then continue
    to commit each time you fix a bug or add a new feature. The following illustration
    summarizes this process:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太担心这些细节，源代码管理是一个复杂的话题，使用GitHub等工具可以执行许多复杂的技巧来管理源代码。要记住的重要事情是，创建一个存储库来保存模块或软件包的源代码的主要副本，将代码提交到这个存储库中，然后每次修复错误或添加新功能时都要继续提交。以下插图总结了这个过程：
- en: '![Uploading your work to GitHub](graphics/B05012_8_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![将您的工作上传到GitHub](graphics/B05012_8_03.jpg)'
- en: The trick with a source management system is to commit regularly—every time
    you add a new feature or fix a bug, you should immediately commit your changes.
    This way, the difference between one version and the next in the repository is
    only the code which adds that one feature or fixes that one problem. If you make
    a number of changes to your source code before committing, the repository will
    be a lot less useful.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理系统的诀窍是定期提交 - 每次添加新功能或修复错误时，您都应立即提交更改。这样，存储库中一个版本和下一个版本之间的差异只是添加了一个功能或修复了一个问题的代码。如果在提交之前对源代码进行了多次更改，存储库将变得不那么有用。
- en: Now that we've seen how source code management systems work, let's implement
    a real example to see how to use GitHub for managing your source code. First off,
    go to the main GitHub site ([https://github.com/](https://github.com/)). If you
    don't have an account with GitHub, you will need to sign up, choosing a unique
    username, as well as supplying a contact e-mail address and password. If you have
    used GitHub before, you can sign in with the username and password you have already
    set up.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了源代码管理系统的工作原理，让我们实施一个真实的示例，看看如何使用GitHub来管理您的源代码。首先，转到GitHub的主要网站（[https://github.com/](https://github.com/)）。如果您没有GitHub帐户，您需要注册，选择一个唯一的用户名，并提供联系电子邮件地址和密码。如果您以前使用过GitHub，可以使用已设置的用户名和密码登录。
- en: Note that it's free to sign up and use GitHub; the only limitation is that every
    repository you create will be public, so anyone who wishes to can see your source
    code. You can set up private repositories if you want, but these do incur a monthly
    charge. However, since we are using GitHub to share our code with others, having
    a private repository doesn't make any sense. You'd only need a private (paid)
    repository if you wanted to share your code with a select group of people while
    preventing anyone else from accessing it. If you're in the position of having
    to do this, though, paying for a private repository is the least of your concerns.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，注册和使用GitHub是免费的；唯一的限制是您创建的每个存储库都将是公开的，因此任何希望的人都可以查看您的源代码。如果您想要，您可以设置私有存储库，但这些会产生月费。但是，由于我们使用GitHub与他人分享我们的代码，拥有私有存储库是没有意义的。只有在您想要与一组特定的人分享代码并阻止其他人访问时，才需要私有（付费）存储库。如果您处于必须这样做的位置，支付私有存储库是您最不用担心的事情。
- en: Once you have signed in to GitHub, your next task is to install the command-line
    tools for **Git**. Git is the underlying source code management toolkit used by
    GitHub; you'll use the `git` command to work with your GitHub repository from
    the command line.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 登录GitHub后，您的下一个任务是安装**Git**的命令行工具。Git是GitHub使用的基础源代码管理工具包；您将使用`git`命令从命令行处理您的GitHub存储库。
- en: 'To install the required software, go to [https://git-scm.com/downloads](https://git-scm.com/downloads)
    and download an installer for your particular operating system. Once this has
    finished downloading, run the installer and follow the instructions as it installs
    the `git` command-line tools. When this is finished, open a terminal or command-line
    window, and try typing the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装所需的软件，请转到[https://git-scm.com/downloads](https://git-scm.com/downloads)并下载适用于您特定操作系统的安装程序。下载完成后，运行安装程序，并按照安装`git`命令行工具的说明进行操作。完成后，打开终端或命令行窗口，尝试输入以下命令：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All going well, you should see the version number of the `git` command-line
    tools you have installed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利的话，您应该看到已安装的`git`命令行工具的版本号。
- en: 'With these prerequisites out of the way, let''s use GitHub to create an example
    repository. Go back to the [https://github.com/](https://github.com/) web page
    and click on the **+ New Repository** button highlighted in green. You will be
    asked to enter the details of the repository you want to create:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些先决条件后，让我们使用GitHub创建一个示例存储库。返回[https://github.com/](https://github.com/)网页，点击绿色高亮显示的**+新存储库**按钮。您将被要求输入要创建的存储库的详细信息：
- en: '![Uploading your work to GitHub](graphics/B05012_8_04.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![将您的工作上传到GitHub](graphics/B05012_8_04.jpg)'
- en: To set up your repository, enter `test-package` for the repository's name, and
    choose **Python** from the **Add .gitignore** drop-down menu. A `.gitignore` file
    is used to exclude certain files from the repository; using a `.gitignore` file
    for Python means that the temporary files Python creates won't be included in
    the repository.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置存储库，请输入`test-package`作为存储库的名称，并从**添加.gitignore**下拉菜单中选择**Python**。`.gitignore`文件用于从存储库中排除某些文件；为Python使用`.gitignore`文件意味着Python创建的临时文件不会包含在存储库中。
- en: Finally, click on the **Create repository** button to create the new repository.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击**创建存储库**按钮创建新存储库。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure you don't select the **Initialize this repository with a README**
    option. You don't want a README file created at this stage; the reason for this
    will become clear shortly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要选择**使用README初始化此存储库**选项。您不希望在此阶段创建一个README文件；很快就会清楚原因。
- en: 'Now that the repository has been created on GitHub, our next task is to **clone**
    a copy of that repository onto your computer''s hard disk. To do this, create
    a new directory named `test-package` to hold your local copy of the repository,
    open up a terminal or command-line window, and use the `cd` command to move to
    your new `test-package` directory. Then, type the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在GitHub上已经创建了存储库，我们的下一个任务是**克隆**该存储库的副本到您计算机的硬盘上。为此，创建一个名为`test-package`的新目录来保存存储库的本地副本，打开终端或命令行窗口，并使用`cd`命令移动到您的新`test-package`目录。然后，输入以下命令：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Make sure you replace both instances of `<username>` in the preceding command
    with your GitHub username. You will be prompted to enter your GitHub password
    to authenticate yourself, and a copy of the repository will be saved into your
    new directory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在上述命令中替换`<username>`的两个实例为您的GitHub用户名。您将被提示输入GitHub密码以进行身份验证，并且存储库的副本将保存到您的新目录中。
- en: 'Because the repository is currently empty, you won''t see anything in your
    directory. However, there are some hidden files that `git` uses to keep track
    of your local copy of the repository. To see these hidden files, you can use the
    `ls` command from a terminal window:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因为存储库目前是空的，您在目录中看不到任何内容。但是，有一些隐藏文件`git`用来跟踪您对存储库的本地副本。要查看这些隐藏文件，您可以从终端窗口使用`ls`命令：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `.git` directory holds information about your new GitHub repository, while
    the `.gitignore` file contains the instructions you asked GitHub to set up for
    you to ignore the Python temporary files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`.git`目录包含有关您的新GitHub存储库的信息，而`.gitignore`文件包含您要求GitHub为您设置的忽略Python临时文件的指令。'
- en: 'Now that we have an (initially empty) repository, let''s create some files
    in it. The first thing we need to do is choose a unique name for our package.
    Because our package is going to be submitted to the Python Package Index, the
    name must be truly unique. To achieve this, we''ll use your GitHub username as
    the basis for our package name, like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个（最初为空的）存储库，让我们在其中创建一些文件。我们需要做的第一件事是为我们的包选择一个唯一的名称。因为我们的包将被提交到Python包索引，所以名称必须是真正唯一的。为了实现这一点，我们将使用您的GitHub用户名作为我们包名称的基础，就像这样：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For example, since my GitHub username is "erikwestra", the name I would use
    for this package would be `erikwestra-test-package`. Make sure you select a name
    based on your GitHub username, to make sure that the package name is truly unique.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于我的GitHub用户名是"erikwestra"，我将为这个包使用`erikwestra-test-package`。确保您根据您的GitHub用户名选择一个名称，以确保包名称是真正唯一的。
- en: 'Now that we have a name for our package, let''s create a README file describing
    this package. Create a new text file named `README.rst` in your `test-package`
    directory, and place the following into this file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个包的名称，让我们创建一个描述这个包的README文件。在您的`test-package`目录中创建一个名为`README.rst`的新文本文件，并将以下内容放入此文件中：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Make sure you replace each occurrence of `<username>` with your GitHub username.
    This text file is in **reStructuredText format**. reStructuredText is a formatting
    language used by PyPI to display formatted text.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您用您的GitHub用户名替换每个`<username>`的出现。这个文本文件是以**reStructuredText格式**。reStructuredText是PyPI用来显示格式化文本的格式语言。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While GitHub can support reStructuredText, by default it uses a different text
    format called **Markdown**. Markdown and reStructuredText are two competing formats,
    and unfortunately, PyPI requires reStructuredText, while GitHub by default uses
    Markdown. This is why we told GitHub not to create a README file when we set up
    the repository; if we had done this, it would have been in the wrong format.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然GitHub可以支持reStructuredText，但默认情况下它使用一种名为**Markdown**的不同文本格式。Markdown和reStructuredText是两种竞争格式，不幸的是，PyPI需要reStructuredText，而GitHub默认使用Markdown。这就是为什么我们告诉GitHub在设置存储库时不要创建README文件的原因；如果我们这样做了，它将以错误的格式存在。
- en: 'When the user views your repository on GitHub, they will see the contents of
    this file neatly formatted according to the reStructuredText rules:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在GitHub上查看您的存储库时，他们将看到此文件的内容按照reStructuredText规则整齐地格式化：
- en: '![Uploading your work to GitHub](graphics/B05012_8_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![将您的工作上传到GitHub](graphics/B05012_8_05.jpg)'
- en: If you want to learn more about reStructuredText, you can read all about it
    at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于reStructuredText的信息，您可以在[http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html)上阅读所有相关内容。
- en: 'Now that we have set up the README file for our package, let''s create the
    package itself. Create another directory inside `test-package` named `<username>_test_package`,
    replacing `<username>` with your GitHub username, and place an empty package initialization
    file (`__init__.py`) inside this directory. Then, create another file inside the
    `<username>_test_package` directory named `test.py`, and enter the following into
    this file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的包设置了README文件，让我们创建包本身。在`test-package`内创建另一个名为`<username>_test_package`的目录，将空的包初始化文件（`__init__.py`）放入此目录。然后，在`<username>_test_package`目录内创建另一个名为`test.py`的文件，并将以下内容放入此文件：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is just an example, of course. Calling the `test.run()` function will cause
    ten random names to be displayed. More interesting is the fact that we have now
    defined the initial contents for our test package. However, all we've done is
    created some files on our local computer; this doesn't affect GitHub at all, and
    if you reload your repository page in GitHub, none of your new files will show
    up.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子，当然。调用`test.run()`函数将导致显示十个随机名称。更有趣的是，我们现在已经为我们的测试包定义了初始内容。但是，我们所做的只是在我们的本地计算机上创建了一些文件；这并不会影响GitHub，如果您在GitHub中重新加载存储库页面，您的新文件将不会显示出来。
- en: 'To have our changes take effect, we need to **commit** our changes to the repository.
    We''ll start by taking a look at how our local copy differs from the one in the
    repository. To do this, go back to your terminal window, `cd` into the `test-package`
    directory, and type the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的更改生效，我们需要**提交**更改到存储库。我们将首先查看我们的本地副本与存储库中的副本有何不同。为此，请返回到您的终端窗口，`cd`进入`test-package`目录，并键入以下命令：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see the following output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The description can be a bit confusing, but it''s not too tricky. Basically,
    GitHub is telling you that there''s a new file, `README.rst`, and a new directory,
    named `<username>_test_package`, which it doesn''t know about (or, in GitHub parlance,
    is "untracked"). Let''s add these new entries to our repository:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 描述可能有点令人困惑，但并不太复杂。基本上，GitHub告诉您有一个新文件`README.rst`和一个新目录，名为`<username>_test_package`，它不知道（或者在GitHub的说法中是“未跟踪”）。让我们将这些新条目添加到我们的存储库中：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Make sure you replace `<username>` with your GitHub username. If you now type
    `git status`, you''ll see that the files we created have been added to our local
    copy of the repository:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您将`<username>`替换为您的GitHub用户名。如果您现在键入`git status`，您将看到我们创建的文件已添加到存储库的本地副本中：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Whenever you add a new directory or file to your project, you will need to use
    the `git add` command to add it to the repository. At any time, you can see if
    you've missed any files by typing the `git status` command and looking for "untracked"
    files.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您向项目添加新目录或文件时，您需要使用`git add`命令将其添加到存储库中。随时可以通过键入`git status`命令并查找“未跟踪”文件来查看是否漏掉了任何文件。
- en: 'Now that we''ve included our new files, let''s commit our changes to the repository.
    Type the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经包含了我们的新文件，让我们将更改提交到存储库。键入以下命令：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This commits a new change to your local copy of the repository. The `-a` option
    tells GitHub to automatically include any changed files, and the `-m` option lets
    you enter a brief message, describing the changes you have made. In this case,
    our commit message is set to the value "`Initial commit.`".
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向您的存储库的本地副本提交一个新更改。`-a`选项告诉GitHub自动包括任何更改的文件，`-m`选项允许您输入一个简短的消息，描述您所做的更改。在这种情况下，我们的提交消息设置为值"`Initial
    commit.`"。
- en: 'Now that we''ve committed our change, we need to upload from our local computer
    to the GitHub repository. To do this, type the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提交了更改，我们需要从本地计算机上传到GitHub存储库。为此，请键入以下命令：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will be prompted to enter your GitHub password to authenticate yourself,
    and the changes you have committed will be stored into your repository on GitHub.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示输入您的GitHub密码以进行身份验证，并且您提交的更改将存储到GitHub上的存储库中。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: GitHub separates the `commit` command from the `push` command because you might
    need to make several commits as you make changes to your program, without necessarily
    being online at the time. For example, if you are on a long plane trip, you could
    work on your code locally, committing each change as you went along and then pushing
    all your changes at once when you land and have Internet access again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub将`commit`命令与`push`命令分开，因为您可能需要在更改程序时进行多次提交，而不一定在线上。例如，如果您在长途飞行中，可以在本地工作，每次更改时进行提交，然后在降落并再次拥有互联网访问时一次性推送所有更改。
- en: 'Now that your changes have been pushed to the server, you can reload the page
    on GitHub, and your newly created package will appear in the repository:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的更改已推送到服务器，您可以在GitHub上重新加载页面，您新创建的软件包将出现在存储库中：
- en: '![Uploading your work to GitHub](graphics/B05012_8_06.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![将您的工作上传到GitHub](graphics/B05012_8_06.jpg)'
- en: You will also see the contents of your `README.rst` file displayed below the
    list of files, describing your new package and how to use it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将看到您的`README.rst`文件的内容显示在文件列表下面，描述了您的新软件包及其使用方法。
- en: 'Whenever you make changes to your package, make sure you run through the following
    steps to save your changes into the repository:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您对软件包进行更改时，请确保按照以下步骤保存更改到存储库中：
- en: Use the `git status` command to see what's changed. If you've added any files
    that need to be included in the repository, use `git add` to add them.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git status`命令查看发生了什么变化。如果您添加了需要包含在存储库中的任何文件，请使用`git add`将它们添加进去。
- en: Use the `git commit -a -m '<commit message>'` command to commit your changes
    to your local copy of the GitHub repository. Make sure you enter a suitable commit
    message to describe the change you have made.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git commit -a -m '<commit message>'`命令将更改提交到您的GitHub存储库的本地副本。确保输入适当的提交消息来描述您所做的更改。
- en: When you are ready to do so, use the `git push` command to send your committed
    changes to GitHub.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您准备好这样做时，请使用`git push`命令将提交的更改发送到GitHub。
- en: There's a lot more to using GitHub, of course, and a great many commands and
    options that you will no doubt want to explore once you get into it—but this is
    enough to get you started.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用GitHub还有很多内容，还有许多命令和选项，一旦您开始使用，您无疑会想要探索，但这已经足够让您开始了。
- en: Once you've set up a GitHub repository for your Python module or package, it
    will be easy to share your code with someone else. All you need to do is share
    a link to your GitHub repository, and the other person can download the files
    they want.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为您的Python模块或软件包设置了GitHub存储库，就可以轻松地与其他人共享您的代码。您只需要分享您的GitHub存储库的链接，其他人就可以下载他们想要的文件。
- en: To make this process even easier and make your packages searchable so that they
    can be found by a wider audience, you should consider submitting your package
    to the Python Package Index. We'll look at the steps involved in doing this next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过程更加简单，并使您的软件包可以被更广泛的用户搜索到，您应该考虑将您的软件包提交到Python软件包索引。接下来我们将看看涉及到这样做的步骤。
- en: Submitting to the Python Package Index
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交到Python软件包索引
- en: 'To submit your Python package to the Python Package Index, you first have to
    sign up for a free account at [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
    Click on the **Register** link in the box in the upper-right hand corner of the
    page:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的Python软件包提交到Python软件包索引，您首先必须在[https://pypi.python.org/pypi](https://pypi.python.org/pypi)免费注册一个帐户。单击页面右上角框中的**注册**链接：
- en: '![Submitting to the Python Package Index](graphics/B05012_8_07.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![提交到Python软件包索引](graphics/B05012_8_07.jpg)'
- en: You will need to choose a username and password, as well as supply an e-mail
    address. Remember the username and password you enter as you'll need it shortly.
    When you submit the form, you'll be sent an e-mail with a link which you need
    to click on to complete your registration.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要选择一个用户名和密码，并提供一个电子邮件地址。记住您输入的用户名和密码，因为您很快就会需要它。当您提交表单时，您将收到一封包含链接的电子邮件，您需要点击该链接以完成注册。
- en: There are two files you will need to add to your project before you can submit
    it to PyPI, a `setup.py` script, which is used to bundle and upload your package,
    and a `LICENSE.txt` file, which describes the license under which your package
    can be used. Let's add these two files now.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在将项目提交到PyPI之前，您需要添加两个文件，一个是`setup.py`脚本，用于打包和上传您的软件包，另一个是`LICENSE.txt`文件，用于描述您的软件包可以使用的许可证。现在让我们添加这两个文件。
- en: 'Create a file inside your `test-package` directory named `setup.py`, and enter
    the following into this file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`test-package`目录中创建一个名为`setup.py`的文件，并输入以下内容：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Make sure you replace each occurrence of `<username>` with your GitHub username,
    and also replace `<your name>` and `<your email address>` with the relevant values.
    Because this is just a test, we are using the name `<username>-test-package` for
    this package; for a real project, we would use a much more meaningful (but still
    unique) name for our package.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将每个`<username>`替换为您的GitHub用户名，并将`<your name>`和`<your email address>`替换为相关值。因为这只是一个测试，我们为此软件包使用名称`<username>-test-package`；对于真实项目，我们将为我们的软件包使用一个更有意义（但仍然是唯一的）名称。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that this version of the `setup.py` script is using the **Distutils**
    package. Distutils is part of the Python Standard Library and is a straightforward
    way of creating and distributing your code. There is an alternative library called
    **Setuptools**, which many people prefer as it is a more modern library with more
    features and is often seen as the successor to Distutils. However, Setuptools
    is not currently part of the Python Standard Library. Since it is easier to use
    and has all the features we need, we are using Distutils here to keep this process
    as simple as possible. If you are familiar with using it, feel free to use Setuptools
    instead of Distutils as the two are identical for what we are doing here.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此版本的`setup.py`脚本使用了**Distutils**软件包。Distutils是Python标准库的一部分，是创建和分发代码的简单方法。还有一个名为**Setuptools**的替代库，许多人更喜欢它，因为它是一个功能更多、更现代的库，并且通常被视为Distutils的继任者。但是，Setuptools目前不是Python标准库的一部分。由于它更容易使用并且具有我们需要的所有功能，我们在这里使用Distutils来尽可能简化这个过程。如果您熟悉使用它，请随时使用Setuptools而不是Distutils，因为对于我们在这里所做的事情，两者是相同的。
- en: Finally, we need to create a new text file named `LICENSE.txt`. This file will
    hold the software license under which you are releasing your package. It is important
    to include a license so that people know exactly what they can and can't do with
    your code; you can't submit a package without supplying a license.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个名为`LICENSE.txt`的新文本文件。该文件将保存您发布软件包的软件许可证。包含许可证非常重要，以便人们准确知道他们可以和不能做什么，您不能提交一个没有提供许可证的软件包。
- en: While you can put anything you like into the `LICENSE.txt` file, you should
    generally use one of the existing software licenses. For example, you might like
    to use the MIT license available at [https://opensource.org/licenses/MIT](https://opensource.org/licenses/MIT)—this
    license makes your code available for others to use for any purpose, while ensuring
    that you can't be held liable for any problems that may occur from its use.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在`LICENSE.txt`文件中放入任何您喜欢的内容，但通常应使用现有的软件许可证之一。例如，您可能想使用[https://opensource.org/licenses/MIT](https://opensource.org/licenses/MIT)提供的MIT许可证——该许可证使您的代码可供他人任何目的使用，同时确保您不会对其使用中可能出现的任何问题负责。
- en: 'With these two files in place, you can finally submit your new package to the
    Python Package Index. To do this, type the following command into your terminal
    or command-line window:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个文件，您最终可以将您的新软件包提交到Python软件包索引。要做到这一点，请在您的终端或命令行窗口中键入以下命令：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This command will attempt to register your new package with the Python Package
    Index. You''ll be asked to enter your PyPI username and password, and given the
    opportunity to store these so you don''t have to re-enter them each time. Once
    the package has been successfully registered, you can upload the package contents
    by typing the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将尝试使用Python软件包索引注册您的新软件包。您将被要求输入您的PyPI用户名和密码，并有机会存储这些信息，以便您不必每次都重新输入。一旦软件包成功注册，您可以通过输入以下命令上传软件包内容：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will see a couple of warnings, which you can safely ignore, before your
    package is uploaded to PyPI. If you then go to the PyPI web site, you will see
    your new package listed:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在将您的软件包上传到PyPI之前，您会看到一些警告，您可以安全地忽略这些警告。然后，您可以转到PyPI网站，您将看到您的新软件包已列出：
- en: '![Submitting to the Python Package Index](graphics/B05012_8_08.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![提交到Python软件包索引](graphics/B05012_8_08.jpg)'
- en: As you can see, the **Home Page** link points to your project's page on GitHub,
    and there is a direct download link for version 1.0 of your package. Unfortunately,
    however, this download link doesn't work yet because you haven't told GitHub what
    version 1.0 of your package looks like. To do this, you have to create a **tag**
    in GitHub which corresponds to version 1.0 of your system; GitHub will then create
    a downloadable version of your package that matches that tag.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**Home Page**链接指向你在GitHub上的项目页面，并且有一个直接下载链接，用于你的包的1.0版本。然而，不幸的是，这个下载链接还不起作用，因为你还没有告诉GitHub你的包的1.0版本是什么样子。为了做到这一点，你必须在GitHub中创建一个与你的系统版本1.0相对应的**标签**；GitHub将会创建一个与该标签匹配的可下载版本的你的包。
- en: 'Before you create your 1.0 release, you should commit the changes you have
    made to the repository. This is good practice anyway, so let''s see how this is
    done: start by typing `git status` to see which files have been added or changed,
    then use `git add` to add each of the untracked files in turn. Once this has been
    done, type `git commit -a -m ''Preparing for PyPI submission''` to commit your
    changes to the repository. Finally, type `git push` to send your committed changes
    to GitHub.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建1.0版本之前，你应该提交你对仓库所做的更改。这本来就是一个好习惯，所以让我们看看如何做：首先输入`git status`，查看已添加或更改的文件，然后使用`git
    add`逐个添加每个未跟踪的文件。完成后，输入`git commit -a -m 'Preparing for PyPI submission'`将你的更改提交到仓库。最后，输入`git
    push`将你提交的更改发送到GitHub。
- en: 'Once all this has been done, you can create the tag that corresponds to version
    1.0 of your package by typing the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，你可以通过输入以下命令创建与你的包的1.0版本相对应的标签：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Make sure you replace `<username>` with your GitHub username so that the package
    name is correct. Finally, use the following variant of the `git push` command
    to copy the newly-created tag to the GitHub server:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你用你的GitHub用户名替换`<username>`，以便包名正确。最后，使用以下`git push`命令的变体将新创建的标签复制到GitHub服务器：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once again, you will be asked to enter your GitHub password. When this command
    finishes, you will have a version 1.0 release of your package available for download
    at `https://github.com/<username>/test-package/tarball/1.0`, where `<username>`
    is your GitHub username. If you now go to PyPI and look for your test package,
    you will be able to click on the **Download URL** link to download a copy of your
    1.0 package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你将被要求输入你的GitHub密码。当这个命令完成时，你将在`https://github.com/<username>/test-package/tarball/1.0`上找到你的包的1.0版本可供下载，其中`<username>`是你的GitHub用户名。如果你现在去PyPI寻找你的测试包，你将能够点击**Download
    URL**链接下载你的1.0包的副本。
- en: If your new package appears in the Python Package Index, and you can successfully
    download the 1.0 version of your package by following the **Download** link, then
    you deserve a pat on the back. Congratulations! This is a complex process, but
    one that will give you the largest audience possible for your reusable modules
    and packages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的新包出现在Python包索引中，并且你可以通过**Download**链接成功下载你的包的1.0版本，那么你应该得到表扬。恭喜！这是一个复杂的过程，但它将为你的可重用模块和包提供尽可能多的受众。
- en: Using pip to download and install modules and packages
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pip下载和安装模块和包
- en: In chapters 4 and 5 of this book, we used **pip**, the Python Package Manager,
    to install various libraries that we wanted to work with. As we learned in [Chapter
    7](ch07.html "Chapter 7. Advanced Module Techniques"), *Advanced Module Techniques*,
    pip normally installs a package into Python's `site-packages` directory. Since
    this directory is listed in the module search path, your newly installed module
    or package can then be imported and used in your code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第4章和第5章中，我们使用了**pip**，Python包管理器，来安装我们想要使用的各种库。正如我们在[第7章](ch07.html "第7章.高级模块技术")中所学到的，pip通常会将一个包安装到Python的`site-packages`目录中。由于这个目录在模块搜索路径中列出，你新安装的模块或包就可以被导入和在你的代码中使用。
- en: 'Let''s now use pip to install the test package we created in the previous section.
    Since we know that our package has been given the name `<username>_test_package`,
    where `<username>` is your GitHub username, you can install this package directly
    into your `site-packages` directory by typing the following command into a terminal
    or command-line window:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用pip来安装我们在上一节中创建的测试包。由于我们知道我们的包已经被命名为`<username>_test_package`，其中`<username>`是你的GitHub用户名，你可以通过在终端或命令行窗口中输入以下命令，直接将这个包安装到你的`site-packages`目录中：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Make sure you replace `<username>` with your GitHub username. Note that if
    you do not have permission to write to your Python installation''s `site-packages`
    directory, you may need to add `sudo` to the start of this command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你用你的GitHub用户名替换`<username>`。请注意，如果你没有权限写入Python安装的`site-packages`目录，你可能需要在这个命令的开头添加`sudo`：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you do this, you will be prompted to enter your administrator password before
    the `pip` command is run.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，你将被提示在运行`pip`命令之前输入你的管理员密码。
- en: 'All going well, you should see various commands being run as your newly created
    package is downloaded and installed. Assuming this works successfully, you can
    then start your Python interpreter and access your new package just as if it were
    part of the Python Standard Library. For example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利的话，你应该看到各种命令被运行，因为你新创建的包被下载和安装。假设这成功了，你可以开始你的Python解释器，并访问你的新包，就像它是Python标准库的一部分一样。例如：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Of course, it's not just you who can do this. Other Python developers can also
    access your new package in exactly the same way. This makes it extremely easy
    for developers to download and use your package.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不仅你可以做到这一点。其他Python开发人员也可以以完全相同的方式访问你的新包。这使得开发人员非常容易地下载和使用你的包。
- en: 'With a few exceptions, you can use pip to install any package you want from
    the Python Package Index. By default, pip will install the latest available version
    of a package; to specify a particular version, you can supply a version number
    when you install the package, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些例外情况，您可以使用pip从Python软件包索引安装任何软件包。默认情况下，pip将安装软件包的最新可用版本；要指定特定版本，您可以在安装软件包时提供版本号，就像这样：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will install version 1.0 of your test package. If you have already installed
    a package and a newer version becomes available, you can upgrade your package
    to the newer version using the `--upgrade` command-line option:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装您的测试软件包的1.0版本。如果您已经安装了一个软件包，并且有一个更新的版本可用，您可以使用`--upgrade`命令行选项将软件包升级到更新的版本：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also obtain a list of the packages you have installed using the `list`
    command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`list`命令获取已安装的软件包列表：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There is one more feature of pip that you should be aware of. Instead of installing
    each package individually, you can create a **requirements file** that lists all
    the packages you want, and have them installed all at once. A typical requirements
    file would look something like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个pip的功能需要注意。您可以创建一个**要求文件**，列出您想要的所有软件包，并一次性安装它们。典型的要求文件看起来可能是这样的：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The requirements file lists the various packages you want to have installed
    and their associated version number.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要求文件列出了您想要安装的各种软件包及其关联的版本号。
- en: 'By convention, a requirements file is named `requirements.txt`, and is placed
    in your project''s top-level directory. Requirements files are extremely useful
    because they make it easy to recreate a Python development environment, including
    all the packages that your program depends upon, with just a single command. This
    is done in the following way:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，要求文件的名称为`requirements.txt`，并放置在项目的顶层目录中。要求文件非常有用，因为它们使得通过一个命令轻松地重新创建Python开发环境成为可能，包括程序所依赖的所有软件包。这是通过以下方式完成的：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since the requirements file is stored alongside the program's source code, you
    would normally include the `requirements.txt` file in your source code repository.
    This means you can clone your repository to a new computer and, with a single
    command, reinstall all the modules and packages your program depends upon.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于要求文件存储在程序源代码旁边，通常会在源代码存储库中包含`requirements.txt`文件。这意味着您可以克隆存储库到新计算机，并且只需一个命令，重新安装程序所依赖的所有模块和包。
- en: 'While you can create a requirements file by hand, you would normally use pip
    to create this file for you. After installing the required modules and packages,
    you can use the following command to create the `requirements.txt` file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以手动创建一个要求文件，但通常会使用pip为您创建此文件。安装所需的模块和软件包后，您可以使用以下命令创建`requirements.txt`文件：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The wonderful thing about this command is that you can re-run it any time your
    requirements change. If you find that your program needs to use a new module or
    package, you use `pip install` to install the new module or package, and then
    immediately call `pip freeze` to create an updated requirements file which includes
    the new dependency.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的好处是，您可以在任何时候重新运行它，以满足您的要求变化。如果您发现您的程序需要使用一个新的模块或软件包，您可以使用`pip install`来安装新的模块或软件包，然后立即调用`pip
    freeze`来创建一个包含新依赖项的更新要求文件。
- en: 'There is one more thing to be aware of when installing and working with modules
    and packages: sometimes, you will need to have *different* versions of a module
    or package installed. For example, perhaps you want to run a particular program
    that requires version 1.6 of the Django package but you only have version 1.4
    installed. If you update your copy of Django to version 1.6, you may break other
    programs that depend upon it.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装和使用模块和软件包时，还有一件事需要注意：有时，您需要安装*不同*版本的模块或软件包。例如，也许您想运行一个需要Django软件包1.6版本的特定程序，但您只安装了1.4版本。如果您更新Django到1.6版本，可能会破坏依赖于它的其他程序。
- en: To avoid this situation, you may find it useful to set up a **virtual environment**
    on your computer. A virtual environment is like a separate Python installation
    with its own set of installed modules and packages. You can create a separate
    virtual environment for each project that you work on so that each project can
    have its own set of dependencies without interfering with the requirements of
    other projects you might install on your computer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，您可能会发现在您的计算机上设置一个**虚拟环境**非常有用。虚拟环境就像一个单独的Python安装，拥有自己安装的模块和软件包。您可以为每个项目创建一个单独的虚拟环境，这样每个项目都可以有自己的依赖关系，而不会干扰您可能在计算机上安装的其他项目的要求。
- en: When you want to use a particular virtual environment, you have to **activate**
    it. You can then use `pip install` to install the various packages you need into
    that environment, and run your program using the packages you have installed.
    When you want to finish working with that environment, you **deactivate** it.
    This lets you swap between virtual environments as necessary to work on your different
    projects.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要使用特定的虚拟环境时，您必须**激活**它。然后，您可以使用`pip install`将各种软件包安装到该环境中，并使用您安装的软件包运行程序。当您想要完成对该环境的工作时，您可以**停用**它。这样，您可以根据需要在不同项目上工作时在虚拟环境之间切换。
- en: Virtual environments are a very powerful tool for working on projects with different,
    and possibly incompatible, package requirements. You can find out more about virtual
    environments at [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境是处理不同且可能不兼容的软件包要求的项目的非常强大的工具。您可以在[http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/)找到有关虚拟环境的更多信息。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the various ways in which you can test your
    Python modules and packages. We learned about unit testing and how the `unittest`
    package in the Python Standard Library makes it easier to write and use unit tests
    for the modules and packages that you develop. We saw how unit tests use the `assert`
    statement (or the various `assertXXX()` methods if you are using the `unittest.TestCase`
    class) to raise an `AssertionError` if a particular condition has not been met.
    By writing various unit tests, you can ensure that your modules and packages are
    working the way you expect them to.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了各种测试Python模块和包的方法。我们了解了单元测试以及Python标准库中的`unittest`包如何更容易地编写和使用你开发的模块和包的单元测试。我们看到单元测试如何使用`assert`语句（或者如果你使用`unittest.TestCase`类，则使用各种`assertXXX()`方法）来在特定条件未满足时引发`AssertionError`。通过编写各种单元测试，你可以确保你的模块和包按照你的期望工作。
- en: We then looked at the process of preparing a module or package for publication,
    and saw how GitHub provides an excellent repository for storing and managing the
    source code for your modules and packages.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着看了准备模块或包进行发布的过程，并了解了GitHub如何提供一个优秀的存储库来存储和管理你的模块和包的源代码。
- en: After creating our own test package, we worked through the process of submitting
    this package to the Python Package Index. Finally, we learned how to use pip,
    the Python Package Manager, to install a package from PyPI into your system's
    `site-packages` directory, before looking at the ways in which a requirements
    file or a virtual environment can be used to help manage your program's dependencies.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了我们自己的测试包之后，我们通过了将该包提交到Python Package Index的过程。最后，我们学会了如何使用pip，Python包管理器，将一个包从PyPI安装到系统的`site-packages`目录中，然后看了一下使用要求文件或虚拟环境来帮助管理程序依赖的方法。
- en: In the final chapter of this book, we will see how modular programming acts
    more generally as the foundation for good programming techniques.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们将看到模块化编程如何更普遍地作为良好编程技术的基础。
