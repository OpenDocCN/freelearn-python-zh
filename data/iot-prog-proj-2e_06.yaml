- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building an IoT Alarm Module
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建物联网警报模块
- en: In the previous chapter, we explored the Raspberry Pi’s GPIO port and built
    a basic alarm system. We learned about different communication protocols and worked
    with a set of sensors, which we accessed using the GPIO port. In this chapter,
    we will enhance our basic alarm system using a Raspberry Pi Pico W, a public **Message
    Queuing Telemetry Transport** (**MQTT**) server, and the MQTTHQ web client (*Figure
    6**.1*).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了Raspberry Pi的GPIO端口并构建了一个基本的警报系统。我们学习了不同的通信协议，并使用GPIO端口与一组传感器一起工作。在本章中，我们将使用Raspberry
    Pi Pico W、公共**消息队列遥测传输**（**MQTT**）服务器和MQTTHQ网页客户端（*图6**.1*）来增强我们的基本警报系统。
- en: 'We will use a Raspberry Pi Pico W to host a `motion` message is sent to the
    MQTT server and viewed using the MQTTHQ web client:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Raspberry Pi Pico W来托管当`运动`消息发送到MQTT服务器并通过MQTTHQ网页客户端查看时：
- en: '![Figure 6.1 – IoT-powered alarm module using MQTT](img/B21282_06_1.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 使用MQTT的物联网警报模块](img/B21282_06_1.jpg)'
- en: Figure 6.1 – IoT-powered alarm module using MQTT
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 使用MQTT的物联网警报模块
- en: We will send a `buzzer` message to the Raspberry Pi Pico W from the MQTTHQ web
    client to activate the buzzer. This Raspberry Pi Pico W and MQTTHQ web client
    setup forms the foundation of our IoT home security system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从MQTTHQ网页客户端向Raspberry Pi Pico W发送`蜂鸣器`消息以激活蜂鸣器。这个Raspberry Pi Pico W和MQTTHQ网页客户端设置构成了我们物联网家庭安全系统的基础。
- en: We’ll begin this chapter with an exploration of MQTT, using a public server
    as our development platform. Then, we’ll familiarize ourselves with the Raspberry
    Pi Pico W, highlighting its strengths in IoT applications. Finally, we’ll conclude
    by installing the components of our IoT alarm module into a custom 3D-printed
    case.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节的开始，通过使用公共服务器作为我们的开发平台来探索MQTT。然后，我们将熟悉Raspberry Pi Pico W，突出其在物联网应用中的优势。最后，我们将通过将我们的物联网警报模块组件安装到定制的3D打印机箱中结束。
- en: 'As such, we will cover the following main topics in the chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主要主题：
- en: Investigating MQTT
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索MQTT
- en: Using a Raspberry Pi Pico W with MQTT
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Raspberry Pi Pico W和MQTT
- en: Building an IoT alarm module case
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个物联网警报模块机箱
- en: Let’s begin!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the requirements for completing this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章所需的以下要求：
- en: Intermediate knowledge of Python programming.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python编程的中级知识。
- en: 1 x Raspberry Pi Pico WH (with headers) to use with breadboard or Raspberry
    Pi Pico GPIO expander.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x Raspberry Pi Pico WH（带引脚）用于与面包板或Raspberry Pi Pico GPIO扩展器一起使用。
- en: 1 x Raspberry Pi Pico W (no headers) to be installed in an optional 3D-printed
    case.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x Raspberry Pi Pico W（不带引脚）用于安装到可选的3D打印机箱中。
- en: 1 x HC-SR501 PIR sensor.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x HC-SR501 PIR传感器。
- en: 1 x LED connected with a 220 Ohm resistor (refer to [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048)
    for construction).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x LED，通过220欧姆电阻连接（请参阅[*第3章*](B21282_03.xhtml#_idTextAnchor048)以了解构造）。
- en: 1 x SFM-27 active buzzer.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x SFM-27 激活蜂鸣器。
- en: Access to a 3D printer or 3D printing service to print an optional case.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有访问3D打印机或3D打印服务的权限以打印可选的机箱。
- en: 'The code for this chapter can be found here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：
- en: https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter6
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter6
- en: Investigating MQTT
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索MQTT
- en: '**MQTT** is a pivotal component in IoT, enabling lightweight and efficient
    communication among connected devices. In *Figure 6**.1*, we illustrate MQTT within
    the ubiquitous cloud symbolizing the internet. MQTT operates on a **publish-subscribe**
    model, allowing devices to publish messages to specific topics while subscribing
    to relevant topics. This framework ensures efficient and selective communication,
    enabling devices to receive only messages relevant to their functions. MQTT’s
    lightweight design minimizes resource overhead, making it an ideal choice for
    devices with constrained capabilities.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**MQTT**是物联网的关键组件，它使得连接设备之间实现轻量级和高效的通信成为可能。在*图6**.1*中，我们展示了MQTT在普遍的云符号中，象征着互联网。MQTT基于**发布-订阅**模型，允许设备向特定主题发布消息，同时订阅相关主题。这个框架确保了高效和选择性的通信，使得设备只能接收与其功能相关的消息。MQTT的轻量级设计最小化了资源开销，使其成为能力受限设备的理想选择。'
- en: We start our investigation into MQTT by looking at how the publish-subscribe
    model in MQTT works.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看MQTT中的发布-订阅模型是如何工作的来开始我们对MQTT的调查。
- en: Understanding the publish-subscribe model in MQTT
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解MQTT中的发布-订阅模型
- en: The effectiveness of MQTT in enabling communication among IoT devices is due
    to its publish-subscribe model. This model provides a flexible and scalable way
    for devices to communicate with each other.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT在使物联网设备之间通信方面有效，归功于其发布/订阅模型。该模型为设备之间提供了一种灵活且可扩展的通信方式。
- en: 'In MQTT, devices are categorized into two roles – publishers and subscribers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在MQTT中，设备被分为两个角色——发布者和订阅者：
- en: '`motion` message under the `IoTAlarm` topic, while the temperature sensor communicates
    a `25 C` message under the `temp` topic.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`IoTAlarm`主题下的`motion`消息，而温度传感器在`temp`主题下通信一个`25 C`的消息。
- en: '`IoTAlarm` and `temp` topics, while the phone is only subscribed to the `IoTAlarm`
    topic.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IoTAlarm`和`temp`主题，而手机仅订阅了`IoTAlarm`主题。'
- en: Topics in MQTT serve as channels or communication pathways. We may think of
    topics as labels or categories that messages fall under, such as the `IoTAlarm`
    and `temp` topics marked with black boxes with white lettering in *Figure 6**.2*.
    When a publisher sends a message to a specific topic, the MQTT broker (server)
    manages the message.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT中的主题充当通道或通信路径。我们可以将主题视为标签或类别，消息属于这些类别，例如在*图6*.2中用黑色框和白色文字标记的`IoTAlarm`和`temp`主题。当发布者向特定主题发送消息时，MQTT代理（服务器）管理该消息。
- en: 'The broker maintains a list of all subscribers to that topic, guaranteeing
    message delivery to each. This mechanism allows for efficient and selective communication
    because devices only receive messages from topics they have subscribed to. In
    *Figure 6**.2*, we see our PC subscribing to the `IoTAlarm` and `temp` topics
    and our phone subscribing to only the `IoTAlarm` topic:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代理维护一个所有订阅该主题的订阅者列表，保证消息发送给每个订阅者。这种机制允许高效且具有选择性的通信，因为设备只接收它们已订阅的主题的消息。在*图6*.2中，我们看到我们的PC订阅了`IoTAlarm`和`temp`主题，而我们的手机仅订阅了`IoTAlarm`主题：
- en: '![Figure 6.2 – MQTT communications illustrated](img/B21282_06_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – MQTT通信示意图](img/B21282_06_2.jpg)'
- en: Figure 6.2 – MQTT communications illustrated
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – MQTT通信示意图
- en: Before we try some hands-on experience with MQTT, we will look at **Quality-of-Service**
    (**QoS**) levels in MQTT. Understanding QoS levels is crucial as they determine
    the reliability and delivery assurance of messages in MQTT.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试一些MQTT的动手经验之前，我们将探讨MQTT中的**服务质量**（**QoS**）级别。理解QoS级别至关重要，因为它们决定了MQTT中消息的可靠性和交付保证。
- en: Understanding QoS in MQTT
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解MQTT中的QoS
- en: '**QoS** is an important aspect of MQTT that determines the level of guarantee
    for message delivery between the MQTT broker (server) and MQTT clients (devices
    or applications).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**QoS**是MQTT的一个重要方面，它决定了MQTT代理（服务器）和MQTT客户端（设备或应用程序）之间消息传递的保证级别。'
- en: 'MQTT offers three levels of QoS:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT提供了三个QoS级别：
- en: '**QoS 0 (At Most Once)**: In this mode, the message is delivered at most once,
    meaning that the message may not be delivered to the recipient, and it may get
    lost without any acknowledgment or guarantee of receipt. This level of QoS is
    suitable for scenarios where message loss is acceptable and message delivery is
    not critical.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QoS 0 (最多一次)**: 在此模式下，消息最多只发送一次，这意味着消息可能不会被发送到接收者，也可能在没有确认或收件保证的情况下丢失。这种QoS级别适用于消息丢失可以接受且消息传递不是关键的场景。'
- en: '`ACK`) that the message was received, it will resend the message. This level
    of QoS guarantees that the message is received by the recipient but may result
    in duplicate messages.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发送者收到（ACK）消息已被接收的确认，它将重新发送消息。这种QoS级别保证了消息被接收者接收，但可能导致重复消息。
- en: '**QoS 2 (Exactly Once)**: QoS 2 provides the highest level of guarantee. It
    ensures that the message is delivered exactly once to the recipient. This level
    of QoS involves a more complex handshake between the sender and receiver to ensure
    no duplicates or message loss occur.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QoS 2 (精确一次)**: QoS 2提供了最高级别的保证。它确保消息恰好一次被发送到接收者。这种QoS级别涉及发送者和接收者之间更复杂的握手，以确保没有重复或消息丢失。'
- en: For our development purposes, QoS 0 is adequate, as it offers reasonable message
    delivery without the need for the more intricate message tracking and acknowledgment
    mechanisms required by QoS 1 and QoS 2\. QoS 0 simplifies message handling in
    code, making it a practical choice for development scenarios.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的开发目的，QoS 0是足够的，因为它提供了合理的消息传递，无需QoS 1和QoS 2所需的更复杂的消息跟踪和确认机制。QoS 0简化了代码中的消息处理，使其成为开发场景中的实际选择。
- en: Exploring MQTT fundamentals with the MQTTHQ web client
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MQTTHQ网页客户端探索MQTT基础知识
- en: To acquire practical knowledge of MQTT, we’ll utilize the **MQTTHQ web client**.
    This web-based service streamlines the process of learning MQTT, eliminating the
    need for complex installations or extensive programming. As a public resource
    aimed at development and testing, it provides an accessible environment for us
    to explore and understand the features of MQTT.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取 MQTT 的实际知识，我们将使用 **MQTTHQ 网页客户端**。这个基于网页的服务简化了学习 MQTT 的过程，消除了复杂安装或大量编程的需求。作为一个面向开发和测试的公共资源，它为我们提供了一个可访问的环境来探索和理解
    MQTT 的功能。
- en: 'We begin by opening the web client in a web browser:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在网页浏览器中打开网页客户端：
- en: 'In our browser, we navigate to the client using the following URL: [https://mqtthq.com/client](https://mqtthq.com/client).'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的浏览器中，我们使用以下 URL 导航到客户端：[https://mqtthq.com/client](https://mqtthq.com/client)。
- en: 'To ensure that we can use the client for our testing, we verify that we are
    connected to [public.mqtthq.com](https://public.mqtthq.com/) from the message
    at the top right of the screen:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们可以使用客户端进行测试，我们验证从屏幕右上角的消息中我们是否连接到了 [public.mqtthq.com](https://public.mqtthq.com/)：
- en: '![Figure 6.3 – Connected to the mqtthq.com client](img/B21282_06_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 连接到 mqtthq.com 客户端](img/B21282_06_3.jpg)'
- en: Figure 6.3 – Connected to the mqtthq.com client
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 连接到 mqtthq.com 客户端
- en: If the message indicating *connected* does not appear, we continue refreshing
    the page until it does.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现表示 *已连接* 的消息，我们继续刷新页面，直到出现为止。
- en: In the `IoTAlarm`, keep the `0`, and click on the **Subscribe** button.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `IoTAlarm` 中保留 `0`，并点击 **订阅** 按钮。
- en: 'We should notice that the text under **Received payloads** updates to display
    **Waiting for data…** and the **Subscribe** button has turned into an **Unsubscribe**
    button:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该注意到，**接收到的有效载荷** 下的文本更新为显示 **等待数据…**，并且 **订阅** 按钮已变为 **取消订阅** 按钮：
- en: '![Figure 6.4 – Subscribing to the IoTAlarm topic](img/B21282_06_4.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 订阅 IoTAlarm 主题](img/B21282_06_4.jpg)'
- en: Figure 6.4 – Subscribing to the IoTAlarm topic
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 订阅 IoTAlarm 主题
- en: 'In the `IoTAlarm`, keep the `0`, replace the `Hello World!` message with `motion`,
    and then click on the **Publish** button:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `IoTAlarm` 中保留 `0`，将 `Hello World!` 消息替换为 `motion`，然后点击 **发布** 按钮：
- en: '![Figure 6.5 – Publishing a message to the IoTAlarm topic](img/B21282_06_5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 向 IoTAlarm 主题发布消息](img/B21282_06_5.jpg)'
- en: Figure 6.5 – Publishing a message to the IoTAlarm topic
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 向 IoTAlarm 主题发布消息
- en: 'We should notice that our `motion` message has now appeared under the **Received
    payloads** box in the **Subscribe to** **topic** section:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该注意到，我们的 `motion` 消息现在已出现在 **订阅主题** 部分的 **接收到的有效载荷** 框下：
- en: '![Figure 6.6 – MQTT message received](img/B21282_06_6.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 接收到的 MQTT 消息](img/B21282_06_6.jpg)'
- en: Figure 6.6 – MQTT message received
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 接收到的 MQTT 消息
- en: 'To confirm that we are successfully sending MQTT messages from a publisher
    to a subscriber, we can use two separate computers: one to publish messages and
    the other to subscribe and receive them.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认我们已成功从发布者向订阅者发送 MQTT 消息，我们可以使用两台不同的计算机：一台用于发布消息，另一台用于订阅并接收它们。
- en: Through this exercise, we have effectively demonstrated the process of publishing
    and subscribing to MQTT messages using the MQTTHQ web client. In the next section,
    we will start building our IoT alarm module by leveraging the capabilities of
    the Raspberry Pi Pico W.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次练习，我们有效地展示了使用 MQTTHQ 网页客户端发布和订阅 MQTT 消息的过程。在下一节中，我们将利用 Raspberry Pi Pico
    W 的功能开始构建我们的物联网警报模块。
- en: Using a Raspberry Pi Pico W with MQTT
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Raspberry Pi Pico W 和 MQTT
- en: In this section, we will build the physical alarm part of our application using
    a **Raspberry Pi Pico W**. This microcontroller not only is affordable but also
    brings a range of capabilities to our project, allowing us to execute tasks efficiently
    without the full power of a **Single-Board Computer** (**SBC**) such as the Raspberry
    Pi.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 **Raspberry Pi Pico W** 构建我们应用程序的物理警报部分。这个微控制器不仅价格低廉，而且为我们的项目带来了一系列功能，使我们能够高效地执行任务，而无需使用像
    Raspberry Pi 这样的 **单板计算机**（**SBC**）的全部功能。
- en: The Raspberry Pi Pico W doesn’t replace our Raspberry Pi; it complements it,
    adding unique strengths to our toolkit. Being a microcontroller, the Pico W is
    substantially more cost-effective compared to the Raspberry Pi, and it typically
    doesn’t heat up as much due to its simpler architecture and lower power consumption.
    This distinction is pivotal for projects such as our IoT alarm module, where the
    primary task is to capture sensory data – a function that does not require the
    computational power of an SBC. This allows us to reserve our Raspberry Pi for
    tasks that demand more computational resources.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico W并不取代我们的Raspberry Pi；它补充了它，为我们的工具箱增添了独特的优势。作为一个微控制器，Pico W与Raspberry
    Pi相比，成本效益更高，并且由于其更简单的架构和较低的功耗，通常不会过热。这种区别对于我们的物联网报警模块等项目至关重要，其主要任务是捕捉感官数据——这不需要SBC的计算能力。这使我们能够将Raspberry
    Pi保留用于需要更多计算资源的任务。
- en: Being a microcontroller, our Raspberry Pi Pico W boots up quickly, providing
    a rapid start for our program. We do not need to load a heavy operating system.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为微控制器，我们的Raspberry Pi Pico W启动迅速，为我们的程序提供快速启动。我们不需要加载一个沉重的操作系统。
- en: Introducing the RP2040 chip
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍RP2040芯片
- en: The Raspberry Pi Pico W utilizes the dual-core ARM Cortex-M0+ processor RP2040
    chip created by the Raspberry Pi Foundation. This chip was designed as a bridge
    between microcontrollers and microcomputers by merging the streamlined operation
    typical of microcontrollers with the capacity to undertake more demanding microcomputer-type
    tasks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico W使用的是Raspberry Pi Foundation创建的双核ARM Cortex-M0+处理器RP2040芯片。该芯片通过将微控制器典型的简化操作与执行更复杂微计算机类型任务的能力相结合，被设计为微控制器和微计算机之间的桥梁。
- en: The *W* in our Raspberry Pi Pico W denotes that our microcontroller supports
    Wi-Fi. Besides the Raspberry Pi Pico W, there is the standard Pico (without Wi-Fi),
    the Pico H (without Wi-Fi and with soldered headers), and the Pico WH (with Wi-Fi
    and soldered headers).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Raspberry Pi Pico W中的 *W* 表示我们的微控制器支持Wi-Fi。除了Raspberry Pi Pico W，还有标准Pico（不带Wi-Fi）、Pico
    H（不带Wi-Fi且带有焊接引脚）和Pico WH（带有Wi-Fi和焊接引脚）。
- en: 'The RP2040 chip our Raspberry Pi Pico W is based on may also be found on other
    microcontrollers such as the *Arduino Nano RP2040 Connect*, *Pimoroni Tiny 2040*,
    and *Adafruit Feather RP2040*. In *Figure 6**.7*, we see a Waveshare RP2040-Zero-M
    (*A*) a Raspberry Pi Pico (*B*), and a Raspberry Pi Pico W (*C*):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico W所基于的RP2040芯片也存在于其他微控制器上，如 *Arduino Nano RP2040 Connect*、*Pimoroni
    Tiny 2040* 和 *Adafruit Feather RP2040*。在 *图6**.7* 中，我们看到Waveshare RP2040-Zero-M
    (*A*)、Raspberry Pi Pico (*B*) 和 Raspberry Pi Pico W (*C*)：
- en: '![Figure 6.7 – RP2040-based microcontrollers](img/B21282_06_7.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 基于RP2040的微控制器](img/B21282_06_7.jpg)'
- en: Figure 6.7 – RP2040-based microcontrollers
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 基于RP2040的微控制器
- en: To construct our alarm circuit on a breadboard, we need headers on our Raspberry
    Pi Pico W. We can either solder them on ourselves or choose to purchase the Pico
    WH version.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要在面包板上构建我们的报警电路，我们需要在Raspberry Pi Pico W上安装引脚。我们可以自己焊接它们，或者选择购买Pico WH版本。
- en: We will start the construction of our IoT alarm module by building out the circuit
    on a breadboard.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始构建我们的物联网报警模块，首先在面包板上构建电路。
- en: Configuring our alarm circuit
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的报警电路
- en: In this section, we’ll build our alarm circuit using an SFM-27 active buzzer,
    an LED with a resistor, and an HC-SR501 PIR sensor. We will configure our circuit
    on a breadboard before moving our components to a 3D-printed case. We may use
    a Raspberry Pi Pico GPIO expander in place of a breadboard. For the breadboard,
    we use male jumpers soldered to our components for connection to the breadboard.
    For the GPIO expander, we use female jumper wires soldered to our components for
    connections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用SFM-27主动蜂鸣器、一个带有电阻的LED和一个HC-SR501 PIR传感器来构建我们的报警电路。在将组件移动到3D打印的盒子之前，我们将在面包板上配置我们的电路。我们可以用Raspberry
    Pi Pico GPIO扩展器代替面包板。对于面包板，我们使用焊接到我们的组件上的公跳线连接到面包板。对于GPIO扩展器，我们使用焊接到我们的组件上的母跳线进行连接。
- en: 'In *Figure 6**.8*, we can see our circuit illustrated in a Fritzing diagram.
    To create our circuit, we wire our components to our Raspberry Pi Pico W with
    the connections outlined in *Figure 6**.8*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图6**.8* 中，我们可以看到我们的电路在一个Fritzing图中展示。为了创建我们的电路，我们使用 *图6**.8* 中概述的连接将我们的组件连接到Raspberry
    Pi Pico W：
- en: '![Figure 6.8 – Raspberry Pi Pico W alarm circuit](img/B21282_06_8.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – Raspberry Pi Pico W报警电路](img/B21282_06_8.jpg)'
- en: Figure 6.8 – Raspberry Pi Pico W alarm circuit
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – Raspberry Pi Pico W报警电路
- en: It’s important to note our connection to the VBUS port on the Raspberry Pi Pico
    W. When the Pico is powered via USB, components connected to the VBUS port will
    receive approximately 5V, which is the standard USB voltage. We will be powering
    our IoT alarm module through the USB port.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们与 Raspberry Pi Pico W 上的 VBUS 端口的连接。当 Pico 通过 USB 供电时，连接到 VBUS 端口的组件将接收大约
    5V 的电压，这是标准的 USB 电压。我们将通过 USB 端口为我们的物联网报警模块供电。
- en: 'The following table outlines the power ports on the Raspberry Pi Pico W and
    provides insights into how we might utilize them in future projects:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下表概述了 Raspberry Pi Pico W 上的电源端口，并提供了关于我们如何在未来的项目中利用它们的见解：
- en: '| **Port** | **Input** **Voltage Use** | **Output** **Voltage Use** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **端口** | **输入** **电压用途** | **输出** **电压用途** |'
- en: '| --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| VBUS | Used to supply power from a 5V USB source. | Can be used to supply
    5V to external components when the Pico is USB-powered. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| VBUS | 用于从 5V USB 源供电。 | 当 Pico 通过 USB 供电时，可用于为外部组件供电 5V。|'
- en: '| VSYS | Accepts an external power supply ranging from 1.8V to 5.5V. | Not
    typically used to supply power to external components. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| VSYS | 接受 1.8V 至 5.5V 的外部电源。 | 通常不用于为外部组件供电。|'
- en: '| 3V3(OUT) | Not commonly used for input. | Provides a regulated 3.3V supply
    to power external 3.3V components. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 3V3(OUT) | 不常用于输入。 | 为外部 3.3V 组件提供稳定的 3.3V 供电。|'
- en: '| 3V3_EN | Not a power supply port, but a control pin to enable/disable the
    3.3V supply. | Not applicable. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 3V3_EN | 不是一个电源端口，但是一个控制引脚，用于启用/禁用 3.3V 供电。 | 不适用。|'
- en: Table 6.1 – Power ports on the Raspberry Pi Pico (W)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – Raspberry Pi Pico (W) 上的电源端口
- en: With our circuit wired up, we are ready to start coding. We will start by setting
    up Thonny for microcontroller development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电路连接好之后，我们就可以开始编码了。我们将首先设置 Thonny 以进行微控制器开发。
- en: Setting up our development environment
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: As with all the software development we have done so far, we will use Thonny
    as our **Integrated Development Environment** (**IDE**). The choice of Thonny’s
    OS version (Windows, macOS, Linux, Raspberry Pi OS, and so on) is flexible since
    our focus is on writing code for a connected microcontroller rather than the computer
    used for coding.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们迄今为止所做的一切软件开发一样，我们将使用 Thonny 作为我们的 **集成开发环境**（**IDE**）。Thonny 的操作系统版本（Windows、macOS、Linux、Raspberry
    Pi OS 等）的选择是灵活的，因为我们的重点是编写用于连接微控制器的代码，而不是用于编码的计算机。
- en: Important note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It’s important to note that different OS versions of Thonny may exhibit varying
    levels of functionality necessary for this chapter. The content in this section
    is based on the Windows version of Thonny, and the screenshots provided reflect
    this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Thonny 的不同操作系统版本可能表现出不同水平的功能，这对于本章是必要的。本节的内容基于 Thonny 的 Windows 版本，提供的截图反映了这一点。
- en: We’ll develop our code using **MicroPython**, a lightweight version of Python
    optimized for microcontrollers. MicroPython shares core syntax and functionality
    with Python, but it’s important to note that due to its focus on resource-constrained
    environments, it may lack some of the extensive libraries and features available
    in standard Python. These differences, however, are a trade-off for the efficiencies
    of MicroPython when used for microcontroller programming.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **MicroPython**，Python 的轻量级版本，针对微控制器进行了优化，来开发我们的代码。MicroPython 与 Python
    共享核心语法和功能，但需要注意的是，由于其专注于资源受限的环境，它可能缺少标准 Python 中可用的某些广泛库和功能。然而，这些差异是 MicroPython
    在微控制器编程中使用的效率权衡。
- en: 'To install MicroPython on our Raspberry Pi Pico W, we do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的 Raspberry Pi Pico W 上安装 MicroPython，我们执行以下操作：
- en: If Thonny is not available on our operating system, we visit the Thonny website
    and download an appropriate version ([https://thonny.org](https://thonny.org)).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的操作系统上没有 Thonny，我们将访问 Thonny 网站，并下载一个合适的版本（[https://thonny.org](https://thonny.org)）。
- en: We then launch Thonny using the appropriate method for our operating system.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后使用适合我们操作系统的适当方法启动 Thonny。
- en: While holding the *BOOTSEL* button on the Pico W (the small white button near
    the USB port), we insert it into an available USB port and disregard any pop-up
    windows that may appear.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住 Pico W 上的 *BOOTSEL* 按钮（USB 端口附近的小白按钮）的同时，我们将它插入一个可用的 USB 端口，并忽略可能出现的任何弹出窗口。
- en: 'We then click on the interpreter information at the bottom right-hand side
    of the screen and select **Install MicroPython…**:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们点击屏幕右下角的解释器信息，并选择 **安装 MicroPython…**：
- en: '![Figure 6.9 – Install MicroPython… option](img/B21282_06_9.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 安装 MicroPython… 选项](img/B21282_06_9.jpg)'
- en: Figure 6.9 – Install MicroPython… option
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 安装MicroPython…选项
- en: 'For the **MicroPython variant**, we select **Raspberry Pi • Pico W /** **Pico
    WH**:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**MicroPython变体**，我们选择**Raspberry Pi • Pico W/** **Pico WH**：
- en: '![Figure 6.10 – Installing MicroPython on the Raspberry Pi Pico W](img/B21282_06_10.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – 在Raspberry Pi Pico W上安装MicroPython](img/B21282_06_10.jpg)'
- en: Figure 6.10 – Installing MicroPython on the Raspberry Pi Pico W
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 在Raspberry Pi Pico W上安装MicroPython
- en: We click on the **Install** button and then the **Close** button once the installation
    has been completed.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击**安装**按钮，安装完成后点击**关闭**按钮。
- en: 'To have Thonny configured to run the MicroPython interpreter on our Pico W,
    we select it from the bottom right-hand side of the screen:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使Thonny配置为在我们的Pico W上运行MicroPython解释器，我们从屏幕的右下角选择它：
- en: '![Figure 6.11 – Selecting the MicroPython interpreter from our Pico W](img/B21282_06_11.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 – 从我们的Pico W中选择MicroPython解释器](img/B21282_06_11.jpg)'
- en: Figure 6.11 – Selecting the MicroPython interpreter from our Pico W
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 从我们的Pico W中选择MicroPython解释器
- en: 'We confirm that Thonny is using the MicroPython interpreter on our Raspberry
    Pi Pico W by checking the **Shell**:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过检查**Shell**来确认Thonny正在使用我们的Raspberry Pi Pico W上的MicroPython解释器：
- en: '![Figure 6.12 – MicroPython prompt in Thonny](img/B21282_06_12.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 – Thonny中的MicroPython提示](img/B21282_06_12.jpg)'
- en: Figure 6.12 – MicroPython prompt in Thonny
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – Thonny中的MicroPython提示
- en: 'To run the MQTT code, we will require an MQTT library to be installed. To do
    so, we select `umqtt` in the search box, and click on **Search** **on PyPI**:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行MQTT代码，我们需要安装MQTT库。为此，我们在搜索框中输入`umqtt`，并点击**在PyPI上搜索**：
- en: '![Figure 6.13 – Installing an MQTT library onto our Pico W](img/B21282_06_13.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13 – 在我们的Pico W上安装MQTT库](img/B21282_06_13.jpg)'
- en: Figure 6.13 – Installing an MQTT library onto our Pico W
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – 在我们的Pico W上安装MQTT库
- en: We select the `micropython-umqtt.simple` package and click on the **Install**
    button.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择`micropython-umqtt.simple`包，并点击**安装**按钮。
- en: We then close the dialog by clicking on the **Close** button.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们点击**关闭**按钮关闭对话框。
- en: Now that we have MicroPython and an MQTT library installed on our Raspberry
    Pi Pico W, we’re prepared to begin coding. Our initial focus will be on connecting
    the components, followed by the implementation of MQTT-related code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的Raspberry Pi Pico W上安装了MicroPython和MQTT库，我们准备开始编码。我们的初步重点将是连接组件，然后是实现MQTT相关代码。
- en: Writing the alarm module client code
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写报警模块客户端代码
- en: By now, we should be well acquainted with the Thonny IDE. Connecting to the
    MicroPython interpreter on the Raspberry Pi Pico W doesn’t significantly alter
    our interaction with Thonny.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们应该已经非常熟悉Thonny IDE了。连接到Raspberry Pi Pico W上的MicroPython解释器不会显著改变我们与Thonny的交互。
- en: Nonetheless, it’s advantageous for our development process to have visibility
    into files stored on both the Pico W and our computer. This visibility allows
    us to easily verify file locations and manage our project effectively.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在我们的开发过程中能够查看存储在Pico W和我们的计算机上的文件是有益的。这种可见性使我们能够轻松验证文件位置并有效地管理我们的项目。
- en: 'To open the **Files** view in Thonny, we click on the **View** menu at the
    top and select **Files**:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Thonny中打开**文件**视图，我们点击顶部的**视图**菜单并选择**文件**：
- en: '![Figure 6.14 – Enabling Files view in Thonny](img/B21282_06_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14 – 在Thonny中启用文件视图](img/B21282_06_14.jpg)'
- en: Figure 6.14 – Enabling Files view in Thonny
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 在Thonny中启用文件视图
- en: We should see a view of our project files on both the Raspberry Pi Pico W and
    our computer on the left-hand side of Thonny.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在Thonny的左侧看到我们的Raspberry Pi Pico W和我们的计算机上的项目文件视图。
- en: We are now ready to start writing code. We will start with the buzzer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好开始编写代码了。我们将从蜂鸣器开始。
- en: Activating the buzzer through code
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过代码激活蜂鸣器
- en: '*Figure 6**.1* illustrates an `IoTAlarm` type message sent from the MQTT broker
    to our Raspberry Pi Pico W. This message serves the purpose of activating the
    buzzer in our alarm module. To handle this task, we’ll create a separate program.
    Activating the buzzer involves a slightly more complex process compared to monitoring
    the PIR sensor or LED components in our circuit, and thus a desire to separate
    its code.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1* 展示了从MQTT代理发送到我们的Raspberry Pi Pico W的`IoTAlarm`类型消息。此消息的目的是激活我们的报警模块中的蜂鸣器。为了处理这个任务，我们将创建一个单独的程序。与监控我们电路中的PIR传感器或LED组件相比，激活蜂鸣器涉及一个稍微复杂的过程，因此我们希望将其代码分离。'
- en: 'To do this, we do the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use
    our Raspberry Pi or another operating system for this.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 Raspberry Pi Pico W 连接到 USB 端口并启动 Thonny。我们可以使用 Raspberry Pi 或其他操作系统来完成此操作。
- en: We then activate the MicroPython environment on our Pico W by selecting it from
    the bottom right-hand side of the screen.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着通过从屏幕右下角选择它来在我们的 Pico W 上激活 MicroPython 环境。
- en: 'In a new editor tab, we enter the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的编辑标签中，我们输入以下代码：
- en: '[PRE0]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To save the file, we click on **File** | **Save as...** from the drop-down
    menu. This will open the following dialog:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们从下拉菜单中选择 **文件** | **另存为...**。这将打开以下对话框：
- en: '![Figure 6.15 – Saving a file to our Raspberry Pi Pico W](img/B21282_06_15.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 将文件保存到我们的 Raspberry Pi Pico W](img/B21282_06_15.jpg)'
- en: Figure 6.15 – Saving a file to our Raspberry Pi Pico W
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 将文件保存到我们的 Raspberry Pi Pico W
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico W, we click on the corresponding button.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此对话框中，我们被提供选择存储文件位置的机会。要将文件保存在我们的 Raspberry Pi Pico W 上，我们点击相应的按钮。
- en: We then name the file `buzzer.py` and click `Pin` and `PWM` (for `machine` module.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将文件命名为 `buzzer.py` 并点击 `Pin` 和 `PWM`（用于 `machine` 模块）。
- en: We import the `utime` class for timer functionality.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入 `utime` 类以实现计时功能。
- en: We set the `BUZZER_PIN` constant to 16\. This corresponds to our wiring diagram
    for the buzzer.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `BUZZER_PIN` 常量设置为 16。这对应于我们的蜂鸣器接线图。
- en: We create a `buzzer` object by initializing the `PWM` class on the specified
    `BUZZER_PIN` constant. This PWM-based approach allows us to vary the voltage supplied
    to the buzzer rapidly, enabling control over the sound’s tone and volume.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在指定的 `BUZZER_PIN` 常量上初始化 `PWM` 类来创建一个 `buzzer` 对象。这种基于 PWM 的方法允许我们快速改变提供给蜂鸣器的电压，从而控制声音的音调和音量。
- en: We then set the `BUZZER_FREQ` constant to `4000`, representing the frequency
    of the PWM signal used for the buzzer.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着将 `BUZZER_FREQ` 常量设置为 `4000`，表示用于蜂鸣器的 PWM 信号的频率。
- en: We then define an `activate_buzzer()` function. This function takes an optional
    `duration` parameter (default is 5 seconds).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着定义一个 `activate_buzzer()` 函数。此函数接受一个可选的 `duration` 参数（默认为 5 秒）。
- en: 'Inside the `activate_buzzer()` function, we do the following:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `activate_buzzer()` 函数内部，我们执行以下操作：
- en: We set the frequency of the `buzzer` object to the specified `BUZZER_FREQ` constant.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `buzzer` 对象的频率设置为指定的 `BUZZER_FREQ` 常量。
- en: We set the buzzer’s duty cycle to 50% (32768 out of the full 16-bit range of
    65536), creating a balanced tone, with the buzzer active for half of the signal’s
    16-bit cycle and inactive for the other half.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将蜂鸣器的占空比设置为 50%（32768 出自 65536 的完整 16 位范围），创建一个平衡的音调，蜂鸣器在信号的 16 位周期中活跃一半，另一半不活跃。
- en: Our code then pauses the program for the specified duration in seconds using
    the `utime.sleep()` function.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们的代码使用 `utime.sleep()` 函数暂停程序指定的秒数。
- en: After the specified duration, set the duty cycle of the `buzzer` object back
    to `0`, turning off the buzzer.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定的时间后，将 `buzzer` 对象的占空比设置为 `0`，关闭蜂鸣器。
- en: 'We can test our code using the Shell in Thonny. To do so, we do the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Thonny 中的 Shell 来测试我们的代码。为此，我们执行以下操作：
- en: 'In the Shell, we import the `activate_buzzer()` function from the buzzer file:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Shell 中，我们从蜂鸣器文件中导入 `activate_buzzer()` 函数：
- en: '![Figure 6.16 – Importing the activate_buzzer() function](img/B21282_06_16.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 导入 activate_buzzer() 函数](img/B21282_06_16.jpg)'
- en: Figure 6.16 – Importing the activate_buzzer() function
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 导入 activate_buzzer() 函数
- en: 'With the function imported, we can run it by simply calling it and hitting
    *Enter* on the keyboard:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数导入后，我们可以通过简单地调用它并按键盘上的 *Enter* 键来运行它：
- en: '![Figure 6.17 – Activating the buzzer](img/B21282_06_17.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.17 – 激活蜂鸣器](img/B21282_06_17.jpg)'
- en: Figure 6.17 – Activating the buzzer
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 激活蜂鸣器
- en: With our buzzer wired correctly, we should hear it sound for 5 seconds. To adjust
    the duration, we simply pass another value into the `activate_buzzer()` function.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蜂鸣器正确接线后，我们应该听到它响 5 秒。要调整持续时间，我们只需将另一个值传递给 `activate_buzzer()` 函数。
- en: We must congratulate ourselves as we have just written and executed our first
    MicroPython program! With the buzzer code done, it is time to create the main
    program for our alarm module.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为自己鼓掌，因为我们刚刚编写并执行了我们的第一个 MicroPython 程序！蜂鸣器代码完成后，是时候为我们的报警模块创建主程序了。
- en: Creating the main code
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建主代码
- en: In this section, we will write the code to power our IoT alarm module. In this
    code, we will connect to the PIR sensor and LED, as well as the Wi-Fi and MQTT
    broker.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写代码来为我们的物联网警报模块供电。在这段代码中，我们将连接PIR传感器、LED、Wi-Fi和MQTT代理。
- en: 'In MicroPython, two files control Pico W’s startup and code execution: `boot.py`
    handles essential initialization during boot, while `main.py` contains the primary
    user code for custom logic and functions.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在MicroPython中，两个文件控制Pico W的启动和代码执行：`boot.py`在启动时处理必要的初始化，而`main.py`包含主要的用户代码，用于自定义逻辑和函数。
- en: For our code, we won’t concern ourselves with `boot.py`. We will, however, concentrate
    on `main.py`, the program responsible for launching our application on Pico W
    when it is first powered.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的代码，我们不会关注`boot.py`。然而，我们将专注于`main.py`，这是当Pico W首次通电时负责启动应用程序的程序。
- en: 'To write our IoT alarm module code, we do the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写我们的物联网警报模块代码，我们执行以下操作：
- en: 'In a new tab in Thonny, we start by entering our code for imports:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Thonny的新标签页中，我们首先输入我们的导入代码：
- en: '[PRE1]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In our preceding code, we have the following:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们前面的代码中，我们有以下内容：
- en: '`machine`: Provides access to hardware-related functions and classes for our
    microcontroller.'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`machine`: 提供对微控制器相关的函数和类的访问。'
- en: '`utime`: Offers time-related functions and timing control for managing delays
    and timestamps.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`utime`: 提供与时间相关的函数和定时控制，用于管理延迟和时间戳。'
- en: '`network`: Provides network-related functions for configuring and managing
    network connections.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`network`: 提供与配置和管理网络连接相关的网络功能。'
- en: '`_thread`: Allows creating and managing threads for concurrent execution of
    code.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_thread`: 允许创建和管理线程，以实现代码的并发执行。'
- en: '`MQTTClient` (from `umqtt.simple`): Provides MQTT client functionality for
    communication over MQTT.'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MQTTClient`（来自`umqtt.simple`）：提供通过MQTT进行通信的MQTT客户端功能。'
- en: '`activate_buzzer` (from `buzzer`): Our custom function for activating a buzzer.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activate_buzzer`（来自`buzzer`）：用于激活蜂鸣器的自定义函数。'
- en: 'We then set our variables:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们设置我们的变量：
- en: '[PRE2]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we have the following variables:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有以下变量：
- en: '`SSID`: Variable storing the name (SSID) of the Wi-Fi network our program connects
    to'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSID`: 存储程序连接的Wi-Fi网络名称（SSID）的变量'
- en: '`PASSWORD`: Variable storing the password for the Wi-Fi network'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PASSWORD`: 存储Wi-Fi网络密码的变量'
- en: '`MQTT_SERVER`: Variable storing the MQTT broker’s/server’s address (we will
    be using `broker.mqtt.com`)'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MQTT_SERVER`: 存储MQTT代理/服务器的地址（我们将使用`broker.mqtt.com`）'
- en: '`MQTT_PORT`: Variable storing the MQTT port number'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MQTT_PORT`: 存储MQTT端口号的变量'
- en: '`pir`: Configures a GPIO pin 26 as an input pin for our PIR sensor'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pir`: 将GPIO引脚26配置为我们的PIR传感器的输入引脚'
- en: '`led`: Configures a GPIO pin 21 as an output pin to control our LED'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`led`: 将GPIO引脚21配置为输出引脚，以控制我们的LED'
- en: '`wlan`: Initializes a WLAN (Wi-Fi) interface for connecting to a Wi-Fi network
    in the station (client) mode, allowing our MicroPython device to act as a client
    and join an existing wireless network. This initialization is essential, as it
    allows our Pico W to connect to an existing Wi-Fi network, enabling networked
    communication'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wlan`: 初始化一个WLAN（Wi-Fi）接口，用于以站（客户端）模式连接到Wi-Fi网络，允许我们的MicroPython设备充当客户端并加入现有的无线网络。此初始化是必需的，因为它允许我们的Pico
    W连接到现有的Wi-Fi网络，从而实现网络通信'
- en: 'After defining our variables, we create a function to connect our Raspberry
    Pi Pico W to our Wi-Fi network:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义我们的变量之后，我们创建一个函数来将我们的Raspberry Pi Pico W连接到我们的Wi-Fi网络：
- en: '[PRE3]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our code, we have the following:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`wlan.active(True)`: Activates the Wi-Fi interface'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wlan.active(True)`: 激活Wi-Fi接口'
- en: '`wlan.connect(SSID, PASSWORD)`: Initiates the connection to the Wi-Fi network
    using the specified SSID (network name) and password (network password)'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wlan.connect(SSID, PASSWORD)`: 使用指定的SSID（网络名称）和密码（网络密码）启动连接到Wi-Fi网络的操作'
- en: '`while not wlan.isconnected():`: This loop continuously checks whether the
    device is connected to the Wi-Fi network:'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while not wlan.isconnected():`: 此循环持续检查设备是否连接到Wi-Fi网络：'
- en: '`print(''Trying to connect to WiFi...'')`: If not connected, it prints a message
    indicating the ongoing connection attempt'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print(''Trying to connect to WiFi...'')`: 如果未连接，它将打印一条消息，指示正在进行的连接尝试'
- en: '`utime.sleep(5)`: It pauses for 5 seconds before checking the connection status
    again'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`utime.sleep(5)`: 它暂停5秒钟，然后再检查连接状态'
- en: '`print(''WIFI connection established'')`: Once connected, our code prints a
    message confirming the successful connection to the Wi-Fi network'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print(''WIFI connection established'')`: 一旦连接，我们的代码将打印一条消息，确认已成功连接到Wi-Fi网络'
- en: 'With our Wi-Fi connection function in place, we then add a function responsible
    for handling the `buzzer` message received from our MQTT broker:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Wi-Fi连接功能到位后，我们添加了一个处理从我们的MQTT代理接收到的`buzzer`消息的功能：
- en: '[PRE4]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our code, the following happens:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下情况发生：
- en: Our `sub_iotalarm()` function handles incoming MQTT messages by first printing
    the topic and message received
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`sub_iotalarm()`函数通过首先打印接收到的主题和消息来处理传入的MQTT消息
- en: If the topic is `IoTAlarm` and the message is `buzzer`, it calls the `activate_buzzer()`
    function to trigger the buzzer
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果主题是`IoTAlarm`且消息是`buzzer`，它将调用`activate_buzzer()`函数来触发蜂鸣器
- en: 'The `motion_handler()` function is responsible for handling motion detection
    events, printing notifications, and, if the MQTT client is connected, publishing
    a `motion` message to the `IoTAlarm` topic:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`motion_handler()`函数负责处理运动检测事件，打印通知，如果MQTT客户端已连接，则将`motion`消息发布到`IoTAlarm`主题：'
- en: '[PRE5]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our code, the following happens:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下情况发生：
- en: Our `motion_handler()` function takes in a parameter called `pin`. This parameter
    is needed as a placeholder for the interrupt handler’s expected argument; even
    though we don’t use it within the function, it is required to maintain compatibility
    with the interrupt system.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`motion_handler()`函数接受一个名为`pin`的参数。这个参数作为中断处理程序预期参数的占位符是必需的；尽管我们在函数内部没有使用它，但它对于与中断系统保持兼容性是必要的。
- en: We use the `b` prefix to denote that the string (`IoTAlarm` and `motion`) should
    be treated as a byte object rather than a text (Unicode) string, which is required
    for sending binary data in protocols such as MQTT.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`b`前缀来表示字符串（`IoTAlarm`和`motion`）应该被当作字节对象处理，而不是文本（Unicode）字符串，这在发送二进制数据（如MQTT协议）时是必需的。
- en: 'The `connect_mqtt()` function establishes a connection between our code and
    the MQTT broker:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect_mqtt()`函数在代码和MQTT代理之间建立连接：'
- en: '[PRE6]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our code, the following happens:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下情况发生：
- en: 'The `connect_mqtt()` function establishes a connection between our code and
    the MQTT server, taking two parameters: `device_id` for device identification
    and `callback` for specifying a function that processes incoming messages (known
    as a callback function). The `device_id` parameter is a unique identifier assigned
    to each MQTT client, allowing our MQTT broker to distinguish specific devices
    on the network.'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect_mqtt()`函数在代码和MQTT服务器之间建立连接，接受两个参数：`device_id`用于设备识别和`callback`用于指定处理传入消息的函数（称为回调函数）。`device_id`参数是分配给每个MQTT客户端的唯一标识符，允许我们的MQTT代理在网络中区分特定的设备。'
- en: Within the `while` loop, our code attempts to connect to the MQTT server using
    the given device ID, configures the `callback` function to handle messages, and
    successfully establishes an MQTT connection. If the connection encounters any
    issues, our function retries after a 5-second pause.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中，我们的代码尝试使用给定的设备ID连接到MQTT服务器，配置`callback`函数以处理消息，并成功建立MQTT连接。如果连接遇到任何问题，我们的函数将在5秒暂停后重试。
- en: What is a callback function?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是回调函数？
- en: In the context of our IoT alarm system, a callback function is used as part
    of the MQTT communication process. In our code, we use the `sub_iotalarm()` function
    as the callback, which means that when relevant MQTT messages are received from
    the MQTT broker, the `sub_iotalarm()` function is automatically invoked. Inside
    our callback function, we have defined specific actions to be taken based on the
    received messages, such as activating the buzzer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的物联网报警系统背景下，回调函数被用作MQTT通信过程的一部分。在我们的代码中，我们使用`sub_iotalarm()`函数作为回调，这意味着当从MQTT代理接收到相关MQTT消息时，`sub_iotalarm()`函数会自动被调用。在我们的回调函数内部，我们根据接收到的消息定义了特定的操作，例如激活蜂鸣器。
- en: 'The final method controls the LED’s blinking pattern, indicating the application’s
    connection status, and enables troubleshooting when the Raspberry Pi Pico W is
    running independently from a computer:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一种方法控制LED的闪烁模式，指示应用程序的连接状态，并在Raspberry Pi Pico W独立于计算机运行时启用故障排除：
- en: '[PRE7]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In our code, we have the following:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`Steady On`: The LED remains constantly on when both Wi-Fi and MQTT are connected.
    This occurs when Wi-Fi is connected (`wlan.isconnected()` is `True`) and there
    is a value for `mqtt_client`.'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Steady On`：当Wi-Fi和MQTT都连接时，LED保持常亮。这发生在Wi-Fi连接时（`wlan.isconnected()`为`True`）并且存在`mqtt_client`的值。'
- en: '`Fast Blink`: When only Wi-Fi is connected (MQTT client is `None`), the LED
    blinks rapidly every half-second.'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fast Blink`：当只有Wi-Fi连接时（MQTT客户端为`None`），LED每半秒快速闪烁一次。'
- en: '`Slow Blink`: When neither Wi-Fi nor MQTT is connected, the LED blinks more
    slowly, with a 1-second interval for on and off states.'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`慢闪`：当Wi-Fi和MQTT都没有连接时，LED灯以1秒的间隔缓慢闪烁。'
- en: 'To enable independent execution of the `connection_status()` function, our
    code starts a new thread. Threading enables concurrent execution of multiple tasks
    or functions, making efficient use of the RP2040’s dual-core processor to run
    distinct operations simultaneously:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`connection_status()`函数能够独立执行，我们的代码启动了一个新的线程。多线程允许多个任务或函数的并发执行，从而有效地利用RP2040的双核处理器同时运行不同的操作：
- en: '[PRE8]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our code then calls functions to connect to the Wi-Fi and MQTT broker using
    a unique client ID, `IoTAlarmSystem`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码随后调用函数，使用唯一的客户端ID`IoTAlarmSystem`连接到Wi-Fi和MQTT代理：
- en: '[PRE9]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then subscribe to the `IoTAlarm` message:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们订阅`IoTAlarm`消息：
- en: '[PRE10]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To enable our PIR sensor, we set its `irq()` method with the following:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启用我们的PIR传感器，我们使用以下方式设置其`irq()`方法：
- en: '[PRE11]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our code, the following happens:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下情况会发生：
- en: An `motion_handler()` function is invoked to publish a `motion` message to the
    MQTT broker.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会调用`motion_handler()`函数，向MQTT代理发布`motion`消息。
- en: 'In an infinite loop, we wait for a message:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个无限循环中，我们等待消息：
- en: '[PRE12]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once a message is received it is processed by the callback function, which we
    defined as `sub_iotalarm()` earlier in the code.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦收到消息，它就会被我们之前在代码中定义的回调函数`sub_iotalarm()`处理。
- en: We save the code as `main.py` onto our Raspberry Pi Pico W to ensure that when
    we power it on or reset it, our code runs automatically. This is standard with
    MicroPython.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码保存为`main.py`到我们的Raspberry Pi Pico W上，以确保当我们打开电源或重置它时，我们的代码会自动运行。这是MicroPython的标准做法。
- en: With the code written, it is time to test it out with the MQTTHQ web client.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编写完成后，是时候用MQTTHQ网络客户端测试它了。
- en: Running our alarm module application
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行我们的警报模块应用程序
- en: 'We have two options for running the code on our Raspberry Pi Pico W. One is
    to power up the Pico W with a standard USB power cable, which is suitable for
    use after testing, but it won’t provide access to debug print messages. The second
    option is to run our code in Thonny. This will allow us to troubleshoot any issues
    we encounter. To do this, we follow these steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Raspberry Pi Pico W上运行代码有两种选择。一种是用标准USB电源线给Pico W供电，这在测试后使用是合适的，但它不会提供访问调试打印消息的功能。第二种选择是在Thonny中运行我们的代码。这将使我们能够排除我们遇到的任何问题。为此，我们遵循以下步骤：
- en: We select the `main.py` tab in Thonny, ensuring that we pick the version installed
    on our Pico W rather than our operating system.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Thonny中选择`main.py`标签，确保我们选择的是安装在Pico W上的版本，而不是我们的操作系统上的版本。
- en: We click on the green run button, hit *F5* on the keyboard, or click on the
    **Run** menu option at the top and then **Run** **current script**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击绿色的运行按钮，在键盘上按*F5*，或者点击顶部的**运行**菜单选项，然后点击**运行** **当前脚本**。
- en: We should observe messages in the Shell that our code is connecting first to
    the Wi-Fi network and then to the MQTT server.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在Shell中观察到的消息是，我们的代码首先连接到Wi-Fi网络，然后连接到MQTT服务器。
- en: We should also observe that our LED blinks accordingly, slowly before connecting
    to the Wi-Fi network, faster after connecting to the Wi-Fi network but before
    connecting to the MQTT server, and steady once both connections are made.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也应该观察到我们的LED灯相应地闪烁，在连接到Wi-Fi网络之前缓慢闪烁，在连接到Wi-Fi网络但在连接到MQTT服务器之前快速闪烁，一旦建立两个连接，则稳定闪烁。
- en: 'Moving our hand in front of the PIR sensor, we should observe a `Motion detected!!`
    message followed by a message coming back from the MQTT server:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把手放在PIR传感器前面，我们应该观察到一条`Motion detected!!`消息，然后是一条来自MQTT服务器的消息：
- en: '![Figure 6.18 – Detecting motion with the PIR sensor](img/B21282_06_18.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18 – 使用PIR传感器检测运动](img/B21282_06_18.jpg)'
- en: Figure 6.18 – Detecting motion with the PIR sensor
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 使用PIR传感器检测运动
- en: If we only receive a `Motion detected!!` message but not a message coming back
    from the MQTT server (broker), then our application has lost connection to the
    server. This should also be indicated by our LED flashing slowly. To fix this,
    we stop and restart our program using the **Stop** and **Run** buttons respectively.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只收到`Motion detected!!`消息，但没有收到来自MQTT服务器（代理）的消息，那么我们的应用程序已经失去了与服务器的连接。这也应该通过我们的LED灯缓慢闪烁来指示。为了解决这个问题，我们分别使用**停止**和**运行**按钮停止并重新启动我们的程序。
- en: 'To verify that our code is sending MQTT messages, we follow the steps from
    the previous section, *Exploring MQTT fundamentals with the MQTTHQ web client*.
    After subscribing to the `IoTAlarm` topic, the web client should receive a `motion`
    message whenever our PIR sensor is triggered:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证我们的代码正在发送MQTT消息，我们遵循上一节中*使用MQTTHQ网络客户端探索MQTT基础*的步骤。在订阅`IoTAlarm`主题后，网络客户端应该在我们的PIR传感器被触发时接收到一个`motion`消息：
- en: '![Figure 6.19 – Receiving motion messages](img/B21282_06_19.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图6.19 – 接收运动消息](img/B21282_06_19.jpg)'
- en: Figure 6.19 – Receiving motion messages
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – 接收运动消息
- en: 'To test out our buzzer, we publish a `buzzer` message using the MQTTHQ web
    client:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的蜂鸣器，我们使用MQTTHQ网络客户端发布一个`buzzer`消息：
- en: '![Figure 6.20 – Publishing a buzzer message](img/B21282_06_20.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图6.20 – 发布蜂鸣器消息](img/B21282_06_20.jpg)'
- en: Figure 6.20 – Publishing a buzzer message
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 – 发布蜂鸣器消息
- en: After clicking the **Publish** button, we should hear our alarm sound for 5
    seconds.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发布**按钮后，我们应该听到我们的警报声持续5秒钟。
- en: We have now created our first MQTT application! We have sent MQTT messages from
    our Raspberry Pi Pico W to and from the internet. As we can imagine, the possibilities
    of our application are vast. For instance, we can extend our IoT alarm system
    by adding more sensors such as a door/window contact sensor for security, or a
    temperature and humidity sensor for home climate monitoring. In the next chapter,
    we will add monitoring and remote arming of our alarm module as we continue to
    build our IoT home security system.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的第一个MQTT应用程序！我们已经从我们的Raspberry Pi Pico W向互联网发送了MQTT消息。正如我们可以想象的那样，我们应用程序的可能性是巨大的。例如，我们可以通过添加更多传感器来扩展我们的物联网警报系统，例如用于安全的门/窗户接触传感器，或用于家庭气候监测的温度和湿度传感器。在下一章中，我们将添加对警报模块的监控和远程布防，因为我们继续构建我们的物联网家庭安全系统。
- en: To finish off our IoT alarm module, we will now install our components into
    a custom 3D-printed case.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的物联网警报模块，我们现在将我们的组件安装到一个定制的3D打印外壳中。
- en: Building an IoT alarm module case
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建物联网警报模块外壳
- en: As we have done previously, we will install our components into a custom-designed
    3D-printed case. *Figure 6**.21* features a rendering of our alarm module case,
    designed to accommodate the PIR sensor, buzzer, LED with a resistor, and the Raspberry
    Pi Pico W.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们将把我们的组件安装到一个定制设计的3D打印外壳中。*图6**.21*展示了我们的警报模块外壳的渲染图，该外壳设计用于容纳PIR传感器、蜂鸣器、带有电阻的LED和Raspberry
    Pi Pico W。
- en: 'In the interest of compactness, we’ve opted for the Raspberry Pi Pico W without
    headers, simplifying component fitting and wire soldering. It’s important to note
    that this choice is optional, and we can use the header-equipped Raspberry Pi
    Pico WH:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了紧凑性，我们选择了不带引脚的Raspberry Pi Pico W，简化了组件安装和焊接。需要注意的是，这个选择是可选的，我们也可以使用带引脚的Raspberry
    Pi Pico WH：
- en: '![Figure 6.21 – Alarm module custom case](img/B21282_06_21.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图6.21 – 警报模块定制外壳](img/B21282_06_21.jpg)'
- en: Figure 6.21 – Alarm module custom case
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 – 警报模块定制外壳
- en: We will start by identifying the parts before we move on to constructing and
    then testing our IoT alarm module.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续构建和测试我们的物联网警报模块之前，我们将首先识别部件。
- en: Identifying the parts of the custom case
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别定制外壳的部件
- en: 'In *Figure 6**.22*, we can see the parts required to assemble the custom case
    for our IoT alarm module:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6**.22*中，我们可以看到组装我们的物联网警报模块定制外壳所需的部件：
- en: '![Figure 6.22 – Parts for the alarm module](img/B21282_06_22.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图6.22 – 警报模块部件](img/B21282_06_22.jpg)'
- en: Figure 6.22 – Parts for the alarm module
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 – 警报模块部件
- en: 'Let’s break down each part:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析每个部分：
- en: '**Raspberry Pi Pico W** (*A*): Header version (shown here), or header-less
    version (preferred).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Raspberry Pi Pico W** (*A*): 带引脚版本（如上图所示），或无引脚版本（推荐）。'
- en: '**Backplate** (*B*): 3D printed using **Polylactic Acid** (**PLA**), **Acrylonitrile
    Butadiene Styrene** (**ABS**), or **Polyethylene Terephthalate** **Glycol** (**PETG**).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背板** (*B*): 使用**聚乳酸** (**PLA**), **丙烯腈丁二烯苯乙烯** (**ABS**), 或**聚对苯二甲酸乙二醇酯**
    **Glycol** (**PETG**) 3D打印而成。'
- en: '**Hook** (*C*): 3D printed using PLA, ABS, PETG, or engineering-grade resin
    using a liquid resin printer (as shown here). For **Fused Deposition Modeling**
    (**FDM**) printers, the part should be printed on its side with supports for strength.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**钩子** (*C*): 使用PLA、ABS、PETG或工程级树脂（如上图所示）3D打印而成。对于**熔融沉积建模** (**FDM**)打印机，部件应侧向打印，并带有支撑以增强强度。'
- en: '**SFM-27 active buzzer** (*D*): Case designed to fit this buzzer.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SFM-27主动蜂鸣器** (*D*): 设计用于安装此蜂鸣器的外壳。'
- en: '**Side mount stand** (*E*): 3D-printed optional stand for mounting alarm module
    on a wall. May be printed in PLA, ABS, PETG, or engineering-grade resin using
    a liquid resin printer (as shown here).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**侧装支架** (*E*): 用于将报警模块安装在墙上的 3D 打印可选支架。可以使用液体树脂打印机（如图所示）打印 PLA、ABS、PETG 或工程级树脂。'
- en: Printing the split stand with FDM printers
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FDM 打印机打印分体支架
- en: The split stand in the SenseHAT case files (`Build Files` folder, [*Chapter
    1*](B21282_01.xhtml#_idTextAnchor014) repository) is ideal for FDM printing. By
    splitting and printing each half on its side, the stand gains significant strength.
    An accompanying base is also provided.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: SenseHAT 外壳文件中的分体支架（`Build Files` 文件夹，[*第 1 章*](B21282_01.xhtml#_idTextAnchor014)
    仓库）非常适合 FDM 打印。通过分割并打印每个半部分在其侧面，支架获得了显著强度。还提供了一个配套底座。
- en: '**LED with resistor** (*F*): Refer to [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048)
    for construction.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带电阻的 LED** (*F*): 请参阅 [*第 3 章*](B21282_03.xhtml#_idTextAnchor048) 了解构造方法。'
- en: '**LED holder** (*G*): To hold LED into the case.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LED 座** (*G*): 用于将 LED 固定在外壳中。'
- en: '**Front shell** (*H*): 3D printed using PLA, ABS, or PETG.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前壳** (*H*): 使用 PLA、ABS 或 PETG 3D 打印。'
- en: '**HC-SR501 PIR sensor** (*I*): Case designed to fit this PIR sensor.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HC-SR501 PIR 传感器** (*I*): 设计用于适配此 PIR 传感器的外壳。'
- en: 6 x M2 5 mm screws (not shown).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6 个 M2 5 毫米螺丝（未显示）。
- en: 2 x M4 10 mm bolts (not shown).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个 M4 10 毫米螺栓（未显示）。
- en: 2 x M4 nuts (not shown).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个 M4 螺母（未显示）。
- en: 4 x M3 10 mm bolts (not shown).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 个 M3 10 毫米螺栓（未显示）。
- en: Glue gun with a glue stick (not shown).
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带胶棒的胶枪（未显示）。
- en: What is an engineering-grade resin?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是工程级树脂？
- en: Liquid resin 3D printers function by creating shapes layer by layer using UV
    light to solidify liquid resin. Standard resins are typically used for small artistic
    prints, offering excellent detail but often resulting in brittle parts. Engineering
    resins such as Siraya Tech Blu, on the other hand, provide superior strength,
    making them suitable for functional components. Parts *C* and *E* in *Figure 6**.22*
    were printed with an 80–20 mix of standard resin and Siraya Tech Tenacious, giving
    the parts more flexibility and reducing their brittleness.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 液体树脂 3D 打印机通过使用紫外线将液体树脂逐层固化来创建形状。标准树脂通常用于小型艺术打印，提供出色的细节，但往往会导致部件脆弱。另一方面，工程树脂（如
    Siraya Tech Blu）提供优异的强度，使其适合功能性组件。图 6.22 中的部件 *C* 和 *E* 使用标准树脂和 Siraya Tech Tenacious
    的 80-20 混合打印，使部件更具柔韧性并减少其脆弱性。
- en: Files for the 3D-printed parts are in the `Build Files` directory of this chapter’s
    GitHub repository.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 打印部件的文件位于本章 GitHub 仓库的 `Build Files` 目录中。
- en: Now that we have identified the parts needed to construct the case for our alarm
    module, let’s put it together.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了构建报警模块外壳所需的部件，让我们将其组装起来。
- en: Building the alarm module case
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建报警模块外壳
- en: '*Figure 6**.23* illustrates the steps to build the IoT alarm module case:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.23* 展示了构建物联网报警模块外壳的步骤：'
- en: '![Figure 6.23 – Steps to build the alarm module case](img/B21282_06_23.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.23 – 构建报警模块外壳的步骤](img/B21282_06_23.jpg)'
- en: Figure 6.23 – Steps to build the alarm module case
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – 构建报警模块外壳的步骤
- en: 'To build the case, we do the following (the letters representing the different
    components in *Figure 6**.23* are mentioned beside the respective component’s
    name in the following steps):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建外壳，我们执行以下操作（*图 6.23* 中表示不同组件的字母在以下步骤中分别提及各自组件的名称）：
- en: Using two M2 5 mm screws, we screw the hook (*C*) onto the backplate (*B*) (*Figure
    6**.23*, *Step 1*). We may also use epoxy glue for this.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个 M2 5 毫米螺丝，我们将钩子 (*C*) 螺旋到背板 (*B*) 上 (*图 6.23*，步骤 1*)。我们也可以使用环氧树脂胶水来完成这项工作。
- en: Using four M2 5 mm screws, we secure the Raspberry Pi Pico W to the backplate
    (*B*) such that the USB port is facing down and toward the opening (*Figure 6**.23*,
    *Step 2*).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用四个 M2 5 毫米螺丝，我们将 Raspberry Pi Pico W 固定在背板 (*B*) 上，使 USB 端口向下并朝向开口 (*图 6.23*，步骤
    2*)。
- en: We secure the buzzer (*D*) to the front shell (*H*) with two M4 10 mm bolts
    and M4 nuts (*Figure 6**.23*, *Step 3*).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用两个 M4 10 毫米螺栓和 M4 螺母将蜂鸣器 (*D*) 固定在前壳 (*H*) 上 (*图 6.23*，步骤 3*)。
- en: We then install the LED with the resistor (*F*) into the front shell (*H*) using
    the LED holder (*G*) (*Figure 6**.23*, *Step 4*).
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用 LED 座 (*G*) 将带有电阻 (*F*) 的 LED 安装在前壳 (*H*) 中 (*图 6.23*，步骤 4*)。
- en: Using the glue gun, we secure the PIR sensor (*I*) to the front shell (*H*).
    Ensure that the PIR controls face the opening. We may also use the glue gun to
    reinforce the placement of the LED (*Figure 6**.23*, *Step 5*).
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用胶枪，我们将 PIR 传感器 (*I*) 固定在前壳 (*H*) 上。确保 PIR 控制器面向开口。我们还可以使用胶枪加强 LED 的放置 (*图
    6.23*，步骤 5*)。
- en: Using a soldering iron, we solder the components to the Raspberry Pi Pico W
    using the wiring diagram from *Figure 6**.8* as a reference (*Figure 6**.23*,
    *Step 6*).
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用电烙铁，我们根据*图6.8*中的布线图将组件焊接到Raspberry Pi Pico W上（*图6.23*，*步骤6*）。
- en: Using four M3 10 mm bolts, we secure the backplate (*B*) to the front shell
    (*H*) (*Figure 6**.23*, *Step 7*).
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用四个M3 10毫米螺栓，我们将背板（*B*）固定到前面板（*H*）上（*图6.23*，*步骤7*）。
- en: If not already installed, we install MicroPython and our client code onto our
    Raspberry Pi Pico W using Thonny.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未安装，我们使用Thonny在Raspberry Pi Pico W上安装MicroPython和我们的客户端代码。
- en: For our design, we use the micro-USB port for both power and access to the installed
    programs on our Raspberry Pi Pico W. This allows us to easily update our client
    software, such as changing the Wi-Fi network and password or the MQTT topic used.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的设计，我们使用micro-USB端口为我们的Raspberry Pi Pico W供电并访问安装的程序。这使我们能够轻松更新我们的客户端软件，例如更改Wi-Fi网络和密码或使用的MQTT主题。
- en: Also, our case provides access to the controls on our PIR sensor so that we
    may control the sensitivity and off time.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的外壳还提供了对PIR传感器上控制器的访问，以便我们可以控制灵敏度和关闭时间。
- en: What are the controls on the HC-SR501 PIR sensor?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: HC-SR501 PIR传感器上的控制是什么？
- en: 'The HC-SR501 PIR sensor is equipped with two adjustable controls: the sensitivity
    control, which fine-tunes the sensor’s responsiveness to motion by increasing
    sensitivity when turned clockwise and decreasing it when turned counterclockwise,
    and the time delay control, which regulates the duration of the output signal
    after detecting motion, with clockwise rotation extending the signal duration
    and counterclockwise rotation shortening it. These controls sit beside each other
    and may be adjusted using a small screwdriver.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: HC-SR501 PIR传感器配备了两个可调节的控制：灵敏度控制，通过顺时针旋转增加灵敏度以微调传感器对运动的响应，逆时针旋转则降低灵敏度；时间延迟控制，调节检测到运动后输出信号持续的时间，顺时针旋转延长信号持续时间，逆时针旋转缩短信号持续时间。这些控制并排放置，可以使用小螺丝刀进行调整。
- en: 'To operate our IoT alarm module, we simply connect a micro-USB cable from our
    Raspberry Pi Pico W to a standard USB charger. The LED should blink quickly at
    first as a Wi-Fi connection is established, followed by a slow blink while our
    program connects to the MQTT broker, and finally, a solid light indicating our
    module is ready for use. If we decide not to print the stand from *Figure 6**.22
    E*, we may mount our module onto a GoPro camera mount of our choice:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要操作我们的物联网报警模块，我们只需将一根micro-USB线从我们的Raspberry Pi Pico W连接到标准USB充电器。LED灯最初应该快速闪烁，表示正在建立Wi-Fi连接，然后程序连接到MQTT代理时，LED灯会慢速闪烁，最后，LED灯会保持常亮，表示我们的模块已准备好使用。如果我们决定不打印*图6.22
    E*中的支架，我们可以将我们的模块安装在我们选择的GoPro相机支架上：
- en: '![Figure 6.24 – Alarm module installed on a GoPro camera mount](img/B21282_06_24.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图6.24 – 安装在GoPro相机支架上的报警模块](img/B21282_06_24.jpg)'
- en: Figure 6.24 – Alarm module installed on a GoPro camera mount
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24 – 安装在GoPro相机支架上的报警模块
- en: To test our IoT alarm module, we connect to the `mqtthq.com` web client and
    subscribe to the `IoTAlarm` topic. Passing our hands over the PIR sensor, we should
    see `motion` messages appear in the client. Publishing the `IoTAlarm` topic and
    sending `buzzer` messages should activate our buzzer for 5 seconds.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的物联网报警模块，我们连接到`mqtthq.com`网络客户端并订阅`IoTAlarm`主题。将手放在PIR传感器上，我们应该在客户端看到`motion`消息出现。发布`IoTAlarm`主题并发送`buzzer`消息应该激活我们的蜂鸣器5秒钟。
- en: We have just built our first MQTT-based IoT alarm module, enclosed in a physical
    case, capable of sensing motion and activating an alarm remotely through MQTT
    messages. With its built-in GoPro hook, we can easily install our IoT alarm module
    anywhere there is a Wi-Fi connection.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了我们第一个基于MQTT的物联网报警模块，封装在一个物理外壳中，能够通过MQTT消息远程感应运动并激活报警。凭借其内置的GoPro挂钩，我们可以在任何有Wi-Fi连接的地方轻松安装我们的物联网报警模块。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored MQTT and used it to create an MQTT-based IoT alarm
    module. We introduced the amazing Raspberry Pi Pico W, a microcontroller that
    complements our Raspberry Pi. We began by understanding MQTT’s publish-subscribe
    model, which enables efficient and selective communication among connected devices.
    Additionally, we examined the significance of threading in maximizing the utilization
    of the Raspberry Pi Pico’s dual-core processor.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了MQTT并使用它创建了一个基于MQTT的物联网报警模块。我们介绍了令人惊叹的Raspberry Pi Pico W，这是一个补充我们的Raspberry
    Pi的微控制器。我们首先理解了MQTT的发布-订阅模型，它使得连接设备之间的高效和选择性通信成为可能。此外，我们还考察了在最大化Raspberry Pi Pico双核处理器利用率方面线程的重要性。
- en: We created code for connecting to Wi-Fi and MQTT servers, handling motion detection,
    and activating alarm components. We learned how to use callback functions to process
    MQTT messages.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了连接到Wi-Fi和MQTT服务器的代码，处理运动检测和激活报警组件。我们学习了如何使用回调函数来处理MQTT消息。
- en: Furthermore, we covered saving and running our code on the Raspberry Pi Pico
    W, making it a standalone IoT alarm system. We also 3D printed a custom case to
    house the PIR sensor, LED, buzzer, and Raspberry Pi Pico W.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还涵盖了在 Raspberry Pi Pico W 上保存和运行我们的代码，使其成为一个独立的物联网报警系统。我们还3D打印了一个定制的盒子来容纳PIR传感器、LED灯、蜂鸣器和Raspberry
    Pi Pico W。
- en: With our MQTT-based IoT alarm module now complete, we are ready to explore further
    enhancements as we expand the capabilities of our IoT home security system. In
    the next chapter, we will build an IoT button that we will use to control our
    alarm module.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基于MQTT的物联网报警模块现在已经完成，我们准备在扩展我们的物联网家庭安全系统功能的同时，探索进一步的增强。在下一章中，我们将构建一个物联网按钮，我们将使用它来控制我们的报警模块。
