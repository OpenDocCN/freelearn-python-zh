- en: Chapter 5. The Proxy Pattern – Controlling Object Access
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 代理模式 – 控制对象访问
- en: In the previous chapter, we started with a brief introduction to Structural
    patterns and went ahead to discuss about the Façade design pattern. We understood
    the concept of Façade with a UML diagram and also learned how it's applied in
    the real world with the help of Python implementations. You learned about the
    upsides and downsides of the Façade pattern in the FAQs section.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了结构模式，并继续讨论了外观设计模式。我们通过UML图理解了外观模式的概念，并借助Python实现学习了它在现实世界中的应用。在常见问题解答部分，你了解了外观模式的优缺点。
- en: In this chapter, we take a step forward and deal with the Proxy pattern that
    falls under the hood of the Structural design patterns. We will get introduced
    to the Proxy pattern as a concept and go ahead with a discussion on the design
    pattern and see how it is used in software application development. We will work
    with a sample use case and implement it in Python v3.5.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向前迈进一步，处理属于结构设计模式范畴下的代理模式。我们将首先了解代理模式作为一个概念，然后讨论设计模式并探讨其在软件开发中的应用。我们将通过一个示例用例并使用Python
    3.5来实现它。
- en: 'In this chapter, we will cover the following topics in brief:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍以下内容：
- en: An introduction to proxy and Proxy design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理和代理设计模式简介
- en: A UML diagram for the Proxy pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式的UML图
- en: Variations of Proxy patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式的变体
- en: A real-world use case with the Python v3.5 code implementation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python 3.5代码实现的现实世界用例
- en: Advantages of the Proxy pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式的优点
- en: Comparison - Façade and the Proxy pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较 - 外观模式和代理模式
- en: Frequently asked questions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题
- en: Understanding the Proxy design pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代理设计模式
- en: Proxy, in general terms, is a system that intermediates between the seeker and
    provider. Seeker is the one that makes the request, and provider delivers the
    resources in response to the request. In the web world, we can relate this to
    a proxy server. The clients (users in the World Wide Web), when they make a request
    to the website, first connect to a proxy server asking for resources such as a
    web page. The proxy server internally evaluates this request, sends it to an appropriate
    server, and gets back the response, which is then delivered to the client. Thus,
    a proxy server encapsulates requests, enables privacy, and works well in distributed
    architectures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代理，从一般意义上讲，是一个在寻求者和提供者之间进行中介的系统。寻求者是提出请求的一方，而提供者则根据请求提供资源。在互联网世界中，我们可以将此与代理服务器联系起来。当客户端（万维网中的用户）向网站提出请求时，首先连接到代理服务器，请求资源，如网页。代理服务器内部评估这个请求，将其发送到适当的服务器，并获取响应，然后将响应传递给客户端。因此，代理服务器封装了请求，提供了隐私保护，并在分布式架构中运行良好。
- en: In the context of design patterns, `Proxy` is a class that acts as an interface
    to real objects. Objects can be of several types such as network connections,
    large objects in memory and file, among others. In short, `Proxy` is a wrapper
    or agent object that wraps the real serving object. Proxy could provide additional
    functionality to the object that it wraps and doesn't change the object's code.
    The main intention of the Proxy pattern is to provide a surrogate or placeholder
    for another object in order to control access to a real object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模式语境中，`Proxy`是一个充当真实对象接口的类。对象可以是多种类型，如网络连接、内存中的大对象和文件等。简而言之，`Proxy`是一个包装器或代理对象，它包装了真实的服务对象。代理可以为它包装的对象提供额外的功能，而不改变对象的代码。代理模式的主要目的是提供一个替代或占位符对象，以便控制对真实对象的访问。
- en: 'The Proxy pattern is used in multiple scenarios such as the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式在以下多个场景中被使用：
- en: It represents a complex system in a simpler way. For example, a system that
    involves multiple complex calculations or procedures should have a simpler interface
    that can act as a proxy for the benefit of the client.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以更简单的方式表示复杂系统。例如，涉及多个复杂计算或程序的系统应该有一个更简单的接口，可以作为代理为客户端提供便利。
- en: It adds security to the existing real objects. In many cases, the client is
    not allowed to access the real object directly. This is because the real object
    can get compromised with malicious activities. This way proxies act as a shield
    against malicious intentions and protect the real object.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为现有的真实对象增加了安全性。在许多情况下，客户端不允许直接访问真实对象。这是因为真实对象可能会受到恶意活动的损害。这样，代理就充当了恶意意图的盾牌，保护了真实对象。
- en: It provides a local interface for remote objects on different servers. A clear
    example of this is with the distributed systems where the client wants to run
    certain commands on the remote system, but the client may not have direct permissions
    to make this happen. So it contacts a local object (proxy) with the request, which
    is then executed by the proxy on the remote machine.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为不同服务器上的远程对象提供了一个本地接口。一个明显的例子是与分布式系统一起使用时，客户端希望在远程系统上运行某些命令，但客户端可能没有直接权限来实现这一点。因此，它联系一个本地对象（代理）来提出请求，然后代理在远程机器上执行该请求。
- en: It provides a light handle for a higher memory-consuming object. Sometimes,
    you may not want to load the main objects unless they're really necessary. This
    is because real objects are really heavy and may need high resource utilization.
    A classic example is that of profile pictures of users on a website. You're much
    better off showing smaller profile images in the list view, but of course, you'll
    need to load the actual image to show the detailed view of the user profile.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为高内存消耗的对象提供了一个轻量级的处理方式。有时，你可能不希望在不必要的情况下加载主要对象。这是因为真实对象非常重，可能需要高资源利用率。一个经典的例子是网站上用户的个人资料图片。在列表视图中显示较小的个人资料图片会更好，但当然，你需要加载实际图片来显示用户个人资料的详细视图。
- en: Let's understand the pattern with a simple example. Consider the example of
    an `Actor` and his `Agent`. When production houses want to approach an `Actor`
    for a movie, typically, they talk to the `Agent` and not to the `Actor` directly.
    Based on the schedule of the `Actor` and other engagements, the `Agent` gets back
    to the production house on the availability and interest in working in the movie.
    Now, in this scenario, instead of production houses directly talking to the `Actor`,
    the `Agent` acts as a `Proxy` that handles all the scheduling & payments for the
    `Actor`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来理解这个模式。考虑一个`Actor`和他的`Agent`的例子。当制片厂想要与一个`Actor`合作拍电影时，通常，他们会与`Agent`交谈，而不是直接与`Actor`交谈。根据`Actor`的日程和其他活动，`Agent`会向制片厂反馈`Actor`的可用性和对参与电影工作的兴趣。现在，在这种情况下，制片厂不是直接与`Actor`交谈，而是`Agent`作为`Proxy`来处理所有关于`Actor`的调度和支付。
- en: The following Python code implements this scenario where the `Actor` is the
    `Proxy`. The `Agent` object is used to find out if the `Actor` is busy. If the
    `Actor` is busy, the `Actor().occupied()` method is called and if the `Actor`
    is not busy, the `Actor().available()` method gets returned.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码实现了这个场景，其中`Actor`是`Proxy`。使用`Agent`对象来找出`Actor`是否忙碌。如果`Actor`忙碌，则调用`Actor().occupied()`方法；如果`Actor`不忙碌，则返回`Actor().available()`方法。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Proxy design pattern essentially does the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式本质上执行以下操作：
- en: It provides a surrogate for another object so that you can control access to
    the original object
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为另一个对象提供了一个替代品，以便你可以控制对原始对象的访问
- en: It is used as a layer or interface to support distributed access
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用作层或接口以支持分布式访问
- en: It adds delegation and protects the real component from undesired impact
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加了委派并保护真实组件免受不期望的影响
- en: A UML class diagram for the Proxy pattern
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式的UML类图
- en: 'We will now discuss the Proxy pattern with the help of the following UML diagram.
    As we discussed in the previous paragraph, the Proxy pattern has three main actors:
    the production house, `Agent`, and the `Actor`. Let''s put these in a UML diagram
    and see how the classes look:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将借助以下UML图来讨论代理模式。正如我们在上一段中讨论的，代理模式有三个主要参与者：制片厂、`Agent`和`Actor`。让我们将这些放入UML图中，看看类是如何表现的：
- en: '![A UML class diagram for the Proxy pattern](img/00017.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![UML类图表示代理模式](img/00017.jpeg)'
- en: 'As we observe the UML diagram, you''ll realize that there are three main participants
    in this pattern:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们观察UML图，你会意识到这个模式有三个主要参与者：
- en: '`Proxy`: This maintains a reference that lets the `Proxy` access the real object.
    It provides an interface identical to the `Subject` so that `Proxy` can substitute
    the real subject. Proxies are also responsible for creating and deleting the `RealSubject`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`代理`：它维护一个引用，允许`Proxy`访问真实对象。它提供了一个与`Subject`相同的接口，以便`Proxy`可以替代真实主题。代理还负责创建和删除`RealSubject`。'
- en: '`Subject`: It provides a representation for both, the `RealSubject` and `Proxy`.
    As `Proxy` and `RealSubject` implement `Subject`, `Proxy` can be used wherever
    `RealSubject` is expected.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`主题`：它为`RealSubject`和`Proxy`都提供了表示。由于`Proxy`和`RealSubject`实现了`Subject`，因此`Proxy`可以在期望`RealSubject`的地方使用。'
- en: '`RealSubject`: It defines the real object that the `Proxy` represents.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RealSubject`: 它定义了`Proxy`所代表的真实对象。'
- en: 'From the data structure''s perspective, the UML diagram can be represented
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据结构的角度来看，UML图可以表示如下：
- en: '`Proxy`: It is a class that controls access to the `RealSubject` class. It
    handles the client''s requests and is responsible for creating or deleting `RealSubject`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`代理`: 这是一个控制对`RealSubject`类访问的类。它处理客户端的请求，并负责创建或删除`RealSubject`。'
- en: '`Subject`/`RealSubject`: `Subject` is an interface that defines what `RealSubject`
    and `Proxy` should look like. `RealSubject` is an actual implementation of the
    `Subject` interface. It provides the real functionality that is then used by the
    client.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subject`/`RealSubject`: `Subject`是一个接口，定义了`RealSubject`和`Proxy`的外观。`RealSubject`是`Subject`接口的实际实现。它提供了客户端使用的真实功能。'
- en: '`Client`: It accesses the `Proxy` class for the work to be accomplished. The
    `Proxy` class internally controls access to `RealSubject` and directs the work
    requested by `Client`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`客户端`: 它访问`Proxy`类以完成工作。`Proxy`类内部控制对`RealSubject`的访问，并指导`客户端`请求的工作。'
- en: Understanding different types of Proxies
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同类型的代理
- en: There are multiple common situations where Proxies are used. We talked about
    some of them in the beginning of this chapter. Based on how the Proxies are used,
    we can categorize them as virtual proxy, remote proxy, protective proxy, and smart
    proxy. Let's learn a little more about them in this section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多常见情况下使用代理。我们在本章的开头讨论了一些。根据代理的使用方式，我们可以将它们分类为虚拟代理、远程代理、保护代理和智能代理。在本节中，让我们更深入地了解它们。
- en: A virtual proxy
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个虚拟代理
- en: Here, you'll learn in detail about the virtual proxy. It is a placeholder for
    objects that are very heavy to instantiate. For example, you want to load a large
    image on your website. Now this request will take a long time to load. Typically,
    developers will create a placeholder icon on the web page suggesting that there's
    an image. However, the image will only be loaded when the user actually clicks
    on the icon thus saving the cost of loading a heavy image in memory. Thus, in
    virtual proxies, the real object is created when the client first requests or
    accesses the object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将详细了解虚拟代理。它是为那些非常难以实例化的对象提供的占位符。例如，你希望在网站上加载一个大型图像。现在这个请求将需要很长时间才能加载。通常，开发者会在网页上创建一个占位图标，提示有图像存在。然而，图像只有在用户实际点击图标时才会加载，从而节省在内存中加载大型图像的成本。因此，在虚拟代理中，实际对象是在客户端首次请求或访问对象时创建的。
- en: A remote proxy
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个远程代理
- en: A remote proxy can be defined in the following terms. It provides a local representation
    of a real object that resides on a remote server or different address space. For
    example, you want to build a monitoring system for your application that has multiple
    web servers, DB servers, celery task servers, caching servers, among others. If
    we want to monitor the CPU and disk utilization of these servers, we need to have
    an object that is available in the context of where the monitoring application
    runs but can perform remote commands to get the actual parameter values. In such
    cases, having a remote proxy object that is a local representation of the remote
    object would help.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 远程代理可以按以下术语定义。它提供了一个位于远程服务器或不同地址空间上的实际对象的本地表示。例如，你想要为你的应用程序构建一个监控系统，该系统具有多个Web服务器、数据库服务器、Celery任务服务器、缓存服务器等。如果我们想要监控这些服务器的CPU和磁盘利用率，我们需要一个在监控应用程序运行上下文中可用的对象，但可以执行远程命令以获取实际参数值。在这种情况下，拥有一个远程代理对象，它是远程对象的本地表示，将有所帮助。
- en: A protective proxy
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个保护代理
- en: You'll understand more about the protective proxy with the following points.
    This proxy controls access to the sensitive matter object of `RealSubject`. For
    example, in today's world of distributed systems, web applications have multiple
    services that work together to provide functionality. Now, in such systems, an
    authentication service acts as a protective proxy server that is responsible for
    authentication and authorization. In this case, Proxy internally helps in protecting
    the core functionality of the website for unrecognized or unauthorized agents.
    Thus, the surrogate object checks that the caller has access permissions required
    to forward the request.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过以下要点更深入地了解保护代理。这个代理控制对 `RealSubject` 的敏感对象访问。例如，在当今的分布式系统世界中，Web 应用程序有多个服务协同工作以提供功能。现在，在这样的系统中，一个身份验证服务充当保护代理服务器，负责身份验证和授权。在这种情况下，代理内部帮助保护网站的核心功能，防止未识别或未经授权的代理。因此，代理对象检查调用者是否有转发请求所需的访问权限。
- en: A smart proxy
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个智能代理。
- en: Smart proxies interpose additional actions when an object is accessed. For example,
    consider that there's a core component in the system that stores states in a centralized
    location. Typically, such a component gets called by multiple different services
    to complete their tasks and can result in issues with shared resources. Instead
    of services directly invoking the core component, a smart proxy is built-in and
    checks whether the real object is locked before it is accessed in order to ensure
    that no other object can change it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 智能代理在访问对象时执行额外的操作。例如，考虑系统中有一个核心组件，它在集中位置存储状态。通常，这样的组件会被多个不同的服务调用以完成它们的工作，这可能导致共享资源的问题。而不是让服务直接调用核心组件，内置了一个智能代理，在访问之前检查真实对象是否被锁定，以确保没有其他对象可以更改它。
- en: The Proxy pattern in the real world
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式在现实世界中的应用。
- en: We will take up a payment use case to demonstrate a real-world scenario for
    the Proxy pattern. Let's say that you go to shop at a mall and like a nice denim
    shirt there. You would like to purchase the shirt but you don't have enough cash
    to do so.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用支付用例来展示代理模式在现实世界中的应用场景。假设你去了商场购物，看中了一件漂亮的牛仔衬衫。你想购买这件衬衫，但你没有足够的现金。
- en: In yesteryears, you'd go to an ATM, take out the money, then come to the mall,
    and pay for it. Even earlier, you had a bank check for which you had to go to
    the bank, withdraw money, and then come back to pay for your expense.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，你会去自动柜员机取钱，然后去商场支付，甚至更早的时候，你有一张银行支票，你必须去银行取款，然后回来支付你的费用。
- en: Thanks to the banks, we now have something called a debit card. So now, when
    you want to purchase something, you present your debit card to the merchant. When
    you punch in your card details, the money is debited in the merchant's account
    for your expense.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢银行，我们现在有一种叫做借记卡的东西。所以现在，当你想购买某样东西时，你向商家出示你的借记卡。当你输入你的卡信息时，钱就会从商家的账户中扣除以支付你的费用。
- en: 'Let''s develop an application in Python v3.5 and implement the above use case.
    We start with the client first. You went to the shopping mall and now would like
    to purchase a nice denim shirt. Lets see how `Client` code is written:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Python 3.5 中开发一个应用程序并实现上述用例。我们首先从客户端开始。你去了购物中心，现在想买一件漂亮的牛仔衬衫。让我们看看 `Client`
    代码是如何编写的：
- en: Your behavior is represented by the `You` class—the client
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的行为由 `You` 类（客户端）表示。
- en: To buy the shirt, the `make_payment()` method is provided by the class
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了购买衬衫，类提供了 `make_payment()` 方法。
- en: The special `__init__()` method calls the Proxy and instantiates it
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊的 `__init__()` 方法调用代理并实例化它。
- en: The `make_payment()` method invokes the Proxy's method internally to make the
    payment
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_payment()` 方法在内部调用代理的方法以完成支付。'
- en: The `__del__()` method returns in case the payment is successful
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果支付成功，`__del__()` 方法会返回。
- en: 'Thus, the code example is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码示例如下：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let's talk about the `Subject` class. As we know, the `Subject` class is
    an interface that is implemented by the `Proxy` and `RealSubject`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈 `Subject` 类。众所周知，`Subject` 类是一个接口，由 `Proxy` 和 `RealSubject` 实现。
- en: In this example, the subject is the `Payment` class. It is an abstract base
    class and represents an interface.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，主题是 `Payment` 类。它是一个抽象基类，代表一个接口。
- en: '`Payment` has the `do_pay()` method that needs to be implemented by the `Proxy`
    and `RealSubject`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Payment` 类有一个需要由 `Proxy` 和 `RealSubject` 实现的 `do_pay()` 方法。'
- en: 'Let''s see these methods in action in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码中这些方法是如何发挥作用的：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also developed the `Bank` class that represents `RealSubject` in this scenario:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还开发了代表此场景中的`RealSubject`的`Bank`类：
- en: '`Bank` will actually make the payment from your account in the merchant''s
    account.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bank`实际上会从商家的账户中从你的账户中支付。'
- en: '`Bank` has multiple methods to process the payment. The `setCard()` method
    is used by the `Proxy` to send the debit card details to the bank.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bank`有多个方法来处理支付。`Proxy`使用`setCard()`方法将借记卡详情发送到银行。'
- en: The `__getAccount()` method is a private method of `Bank` that is used to get
    the account details of the debit card holder. For simplicity, we have enforced
    the debit card number to be the same as the account number.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__getAccount()`方法是`Bank`的私有方法，用于获取借记卡持有人的账户详情。为了简单起见，我们强制借记卡号与账户号相同。'
- en: '`Bank` also has the `__hasFunds()` method to see if the account holder has
    enough funds in the account to pay for the shirt.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bank`也有`__hasFunds()`方法来查看账户持有人是否有足够的资金支付衬衫。'
- en: 'The `do_pay()` method that is implemented by the `Bank` class (from the Payment
    interface) is actually responsible for making the payment to the merchant based
    on available funds:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`Bank`类（从支付接口）实现的`do_pay()`方法实际上负责根据可用资金向商家支付：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now understand the last piece, which is the `Proxy`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来理解最后一部分，即`Proxy`：
- en: The `DebitCard` class is the `Proxy` here. When `You` wants to make a payment,
    it calls the `do_pay()` method. This is because `You` doesn't want go to the bank
    to withdraw money and pay the merchant.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebitCard`类在这里是`Proxy`。当`You`想要进行支付时，它会调用`do_pay()`方法。这是因为`You`不想去银行取款然后支付商家。'
- en: The `DebitCard` class acts as a surrogate for the `RealSubject`, `Bank`.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebitCard`类作为`RealSubject`、`Bank`的代理。'
- en: The `payWithCard()` method internally controls the object creation of `RealSubject`,
    the `Bank` class, and presents the card details to `Bank`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payWithCard()`方法内部控制`RealSubject`、`Bank`类对象的创建，并将卡详情展示给`Bank`。'
- en: '`Bank` goes through the internal checks on the account and does the payment,
    as described in previous code snippet:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bank`将执行之前代码片段中描述的内部账户检查和支付：'
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For a positive case, when funds are enough, the output is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个正面案例，当资金充足时，输出如下：
- en: '![The Proxy pattern in the real world](img/00018.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![现实世界中的代理模式](img/00018.jpeg)'
- en: 'For a negative case—insufficient funds—the output is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个负面案例——资金不足，输出如下：
- en: '![The Proxy pattern in the real world](img/00019.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![现实世界中的代理模式](img/00019.jpeg)'
- en: Advantages of the Proxy pattern
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式的优点
- en: 'As we''ve seen how the Proxy pattern works in the real world, let''s browse
    through the advantages of the Proxy pattern:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代理模式在现实世界中的工作方式，让我们浏览一下代理模式的优点：
- en: Proxies can help improve the performance of the application by caching heavy
    objects or, typically, the frequently accessed objects
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理可以通过缓存重对象或通常频繁访问的对象来帮助提高应用程序的性能
- en: Proxies also authorize the access to `RealSubject`; thus, this pattern helps
    in delegation only if the permissions are right
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理还授权对`RealSubject`的访问；因此，只有当权限正确时，此模式才有助于委托
- en: Remote proxies also facilitate interaction with remote servers that can work
    as network connections and database connections and can be used to monitor systems
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程代理也便于与远程服务器交互，这些服务器可以作为网络连接和数据库连接使用，并可用于监控系统
- en: Comparing the Façade and Proxy patterns
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较外观模式和代理模式
- en: 'Both the façade and proxy patterns are structural design patterns. They are
    similar in the sense that they both have a proxy/façade object in front of the
    real objects. Differences are really in the intent or purpose of the patterns,
    as shown in the following table:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式和代理模式都是结构型设计模式。它们在某种意义上是相似的，因为它们都在真实对象前面有一个代理/外观对象。不同之处实际上在于模式的意图或目的，如下表所示：
- en: '| Proxy pattern | Façade pattern |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 代理模式 | 外观模式 |'
- en: '| --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| It provides you with a surrogate or placeholder for another object to control
    access to it | It provides you with an interface to large subsystems of classes
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 它为你提供了一个代理或占位符来控制对另一个对象的访问 | 它为你提供了一个接口，用于访问大型类子系统 |'
- en: '| A Proxy object has the same interface as that of the target object and holds
    references to target objects | It minimizes the communication and dependencies
    between subsystems |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 代理对象具有与目标对象相同的接口，并持有对目标对象的引用 | 它最小化了子系统之间的通信和依赖关系 |'
- en: '| It acts as an intermediary between the client and object that is wrapped
    | A Façade object provides a single, simplified interface |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 它充当客户端和被包装对象之间的中介 | 门面（Façade）对象提供了一个单一、简化的接口 |'
- en: Frequently asked questions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Q1\. What is the difference between the Decorator pattern and Proxy pattern?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 装饰器模式（Decorator pattern）和代理模式（Proxy pattern）之间的区别是什么？
- en: 'A: A Decorator adds behavior to the object that it decorates at runtime, while
    a Proxy controls access to an object. The relationship between Proxy and `RealSubject`
    is at compile time and not dynamic.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: 装饰器在运行时向被装饰的对象添加行为，而代理控制对对象的访问。代理和 `RealSubject` 之间的关系是在编译时而非动态的。'
- en: Q2\. What are the disadvantages of the Proxy pattern?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 代理模式的缺点是什么？
- en: 'A: The Proxy pattern can increase the response time. For instance, if the Proxy
    is not well-architectured or has some performance issues, it can add to the response
    time of `RealSubject`. Generally, it all depends on how well a Proxy is written.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: 代理模式可以增加响应时间。例如，如果代理架构不佳或存在一些性能问题，它可能会增加 `RealSubject` 的响应时间。通常，这都取决于代理编写的好坏。'
- en: Q3\. Can the client access `RealSubject` independently?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 客户能否独立访问 `RealSubject`？
- en: 'A: Yes, but there are certain advantages that Proxies provide such as virtual,
    remote, and others, so it''s advantageous to use the Proxy pattern.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: 是的，但代理提供了一些特定的优势，如虚拟、远程等，因此使用代理模式是有利的。'
- en: Q4\. Does the Proxy add any functionality of its own?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 代理是否添加了它自己的任何功能？
- en: 'A: A Proxy can add additional functionality to `RealSubject` without changing
    the object''s code. Proxy and `RealSubject` would implement the same interface.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: 代理可以在不改变对象代码的情况下为 `RealSubject` 添加额外的功能。代理和 `RealSubject` 将实现相同的接口。'
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We began the chapter by understanding what Proxies are. We understood the basics
    of a Proxy and how it is used effectively in software architecture. You then learned
    about the Proxy design pattern and the context in which it's used. We looked at
    how the Proxy design patterns control access to the real object that provides
    the required functionality.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从理解代理（Proxies）是什么开始本章。我们了解了代理的基本概念以及它在软件架构中的有效使用。然后，你学习了代理设计模式及其使用场景。我们探讨了代理设计模式如何控制对提供所需功能的真实对象的访问。
- en: We also saw the pattern with a UML diagram and sample code implementation in
    Python v3.5.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过 UML 图和 Python 3.5 的示例代码实现了该模式。
- en: 'Proxy patterns are implemented in four different ways: virtual proxy, remote
    proxy, protective proxy, and smart proxy. You learned about each of these with
    a real-world scenario.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式有四种不同的实现方式：虚拟代理、远程代理、保护代理和智能代理。你通过实际场景学习了这些内容。
- en: We compared the Façade and Proxy design patterns so that the difference between
    their use cases and intentions are clear to you.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较了门面和代理设计模式，以便让你清楚地了解它们的使用场景和意图。
- en: We also covered a section on FAQs that would help you get more ideas on the
    pattern and its possible advantages/disadvantages.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了一个关于常见问题的部分，这将帮助你获得更多关于该模式和其可能的优势/劣势的灵感。
- en: At the end of this chapter, we're now geared up to learn more Structural patterns
    in the chapters to come.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们现在准备在接下来的章节中学习更多的结构化模式。
