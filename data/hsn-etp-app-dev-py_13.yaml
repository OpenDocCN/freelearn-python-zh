- en: Going Serverless
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器
- en: As we have explored so far, Microservices offer a great alternative architecture
    with which we can approach the application development scenario. With the advantages
    of having faster release cycles, easy-to-launch new features and high scalability,
    the Microservices are a compelling choice for developers. But all of these Microservices
    still run in a server-based environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们迄今所探讨的，微服务提供了一种很好的替代架构，我们可以通过它来处理应用程序开发场景。具有更快的发布周期、易于启动新功能和高可伸缩性的优势，微服务对开发人员来说是一个引人注目的选择。但所有这些微服务仍然在基于服务器的环境中运行。
- en: 'Running in a server-based environment is useful in terms of the response times
    of the applications because there is always a service that is ready to accept
    an incoming request. But there is one disadvantage: If there are no users, the
    applications keep on consuming system resources.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于服务器的环境中运行对于应用程序的响应时间是有用的，因为总是有一个准备接受传入请求的服务。但有一个缺点：如果没有用户，应用程序将继续消耗系统资源。
- en: Recently, application developers have started to make a move toward a new approach
    of application development. This approach of development focuses on the applications
    being event-driven and launches an action based on the occurrence of some event.
    These kinds of applications are known as serverless applications because they
    do not keep on running when there is no user and an instance of them launches
    only when there has been some event that has occurred.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，应用程序开发人员开始转向一种新的应用程序开发方法。这种开发方法侧重于应用程序是事件驱动的，并且根据某些事件的发生启动操作。这种类型的应用程序被称为无服务器应用程序，因为当没有用户时它们不会继续运行，它们的实例只有在发生了某些事件时才会启动。
- en: As we move through this chapter, we will take a look at this serverless approach
    of application development and how it is changing the development scenario.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本章中的深入，我们将看看这种无服务器应用程序开发方法以及它如何改变开发场景。
- en: 'As a reader of this chapter, you will get to learn about the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的读者，您将学习以下内容：
- en: The serverless approach to application development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序开发的无服务器方法
- en: The process that powers the serverless architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动无服务器架构的流程
- en: Building a serverless application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建无服务器应用程序
- en: Benefits of the serverless approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器方法的好处
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code listings in this book can be found under `chapter13` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)[.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码清单可以在[https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)的`chapter13`目录下找到[.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
- en: 'The code samples can be cloned by running the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下命令克隆代码示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Additionally, for the code to execute successfully, some additional software
    will be required:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了成功执行代码，还需要一些额外的软件：
- en: '**Docker**: Docker is required as a dependency to run the OpenWhisk software
    platform for the deployment of the serverless applications. To install `docker`
    on your platform, please take a look at [https://docs.docker.com/install/](https://docs.docker.com/install/).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：Docker是运行OpenWhisk软件平台以部署无服务器应用程序所需的依赖项。要在您的平台上安装`docker`，请查看[https://docs.docker.com/install/](https://docs.docker.com/install/)。'
- en: '**Apache OpenWhisk**: Apache OpenWhisk provides an open source platform for
    ...'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache OpenWhisk**：Apache OpenWhisk提供了一个开源平台，用于...'
- en: The serverless approach to application development
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器应用程序开发方法
- en: In recent years, as developers, we have grown accustomed to the traditional
    ways of building applications and handling their deployments on the production
    infrastructure. In this traditional architecture, we developed applications where
    the application takes in a request from the **Client**, checks whether the **Client**
    is authorized to perform that action, and then moves on to executing that action.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，作为开发人员，我们已经习惯了以传统方式构建应用程序并在生产基础设施上处理它们的部署。在这种传统架构中，我们开发了应用程序，其中应用程序接收来自**客户端**的请求，检查**客户端**是否被授权执行该操作，然后继续执行该操作。
- en: 'Once the application was developed, we deployed it over a platform that would
    be compatible with our application. This involves the choice of the operating
    system, the kind of the infrastructure where this platform will be running, for
    example a bare-metal server, a VM, or a container, and then we maintained the
    infrastructure by handling its scalability and fixing any issues that may arise.
    For example, a simple system that manages employee payroll inside an organization
    will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序开发完成，我们将其部署到与我们的应用程序兼容的平台上。这涉及选择操作系统、平台运行的基础设施类型，例如裸金属服务器、虚拟机或容器，然后通过处理其可伸缩性和解决可能出现的任何问题来维护基础设施。例如，一个管理组织内员工工资的简单系统将如下所示：
- en: '![](Images/b9a3bf94-69b6-4b8e-ae0d-61a80b4794e3.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b9a3bf94-69b6-4b8e-ae0d-61a80b4794e3.png)'
- en: In this case, the application keeps running on a server, waiting for the requests
    to come, and acting on them as they arrive.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应用程序在服务器上持续运行，等待请求到来，并在请求到达时执行操作。
- en: This kind of approach, though highly useful, usually pulls the developers from
    their main task of writing the logic to achieve a particular outcome from the
    system, and makes them focus on a lot of areas that involve tasks related to the
    infrastructure management and scalability.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法虽然非常有用，但通常会使开发人员从编写实现系统特定结果的逻辑的主要任务中分心，并使他们专注于涉及基础设施管理和可伸缩性的许多领域。
- en: Now imagine an architecture that would allow developers to focus on just writing
    the logic behind a particular business process without worrying about where that
    logic will be executed and how it will scale.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一种架构，它允许开发人员专注于只编写特定业务流程背后的逻辑，而不必担心这些逻辑将在何处执行以及如何扩展。
- en: 'The serverless approach to building applications provides these features. The
    way this works in serverless is through the introduction of two new techniques
    to application development:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序的无服务器方法提供了这些功能。在无服务器中，这是通过引入两种新的应用程序开发技术来实现的：
- en: '**Backend as a service** (**BaaS**): BaaS is a new cloud computing offering
    that provides the application developers with the functionality of linking their
    applications with the backend services through the use of APIs, so as to provide
    some common feature sets, such as user authentication and data storage. It differs
    from the general architecture of application development in that these services
    provided by the backend may not need to be developed by the application developers
    themselves, but access to these services is enabled through the use of APIs exposed
    by these services.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后端即服务**（**BaaS**）：BaaS是一种新的云计算服务，为应用程序开发人员提供了通过API将其应用程序与后端服务链接的功能，以提供一些常见的功能集，如用户认证和数据存储。它与应用程序开发的一般架构不同，因为后端提供的这些服务可能不需要由应用程序开发人员自己开发，而是通过这些服务提供的API来访问这些服务。'
- en: '**Function as a service** (**FaaS**): FaaS is another category of cloud computing
    that allows developers to focus on writing the application logic without worrying
    about where this logic will execute. In FaaS, the applications run in a stateless
    and ephemeral manner where the infrastructure they might be executing in may be
    valid only for a few invocations, which may be as little as a single invocation.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数即服务**（**FaaS**）：FaaS是云计算的另一类别，允许开发人员专注于编写应用程序逻辑，而不必担心这些逻辑将在何处执行。在FaaS中，应用程序以无状态和短暂的方式运行，它们可能在执行的基础设施仅适用于少数调用，甚至可能只有一个调用。'
- en: 'In the serverless architecture of application development, the applications
    are usually developed as functions that are executed as a response to a certain
    event. These functions execute in their own stateless containers, which may exist
    in the infrastructure for only a few invocations. We will take a look at how the
    serverless applications work in the later sections of this chapter. For a quick
    reference, if we had to implement the Payroll system as a serverless application;
    the following diagram shows how the architecture of the system would look:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发的无服务器架构中，应用程序通常被开发为作为对某个事件的响应而执行的函数。这些函数在它们自己的无状态容器中执行，这些容器可能仅在基础设施中存在几次调用。我们将在本章的后面部分看一下无服务器应用程序是如何工作的。作为一个快速参考，如果我们必须将工资系统实现为无服务器应用程序；以下图表显示了系统架构的样子：
- en: '![](Images/2ae4e988-e8d6-4deb-8780-16aebbe431cb.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2ae4e988-e8d6-4deb-8780-16aebbe431cb.png)'
- en: As we can see, our serverless payroll application contains both the features
    of a BaaS offering where the **Client** directly interacts with the **Auth DB**
    through the APIs exposed by the **Auth DB** and the **Payslip** generation, and
    employee search runs in a FaaS offering where they are stored as functions and
    executed only when a particular event happens.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的无服务器工资单应用程序包含了BaaS提供的功能，其中**客户**直接通过**Auth DB**暴露的API与**Auth DB**进行交互，并且**工资单**生成和员工搜索在FaaS提供的功能中运行，它们被存储为函数，并且只在特定事件发生时执行。
- en: Both of these functions do not maintain any kind of state, such that they can
    run in ephemeral containers that may only last for a short amount of time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个功能都不维护任何状态，因此它们可以在短暂的容器中运行，这些容器可能只存在很短的时间。
- en: So now, let's take a look at the components that power the serverless architecture
    and how the serverless architecture works to have a better understanding of how
    we can develop applications that best utilize the serverless architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看驱动无服务器架构的组件以及无服务器架构如何工作，以更好地理解我们如何开发最好利用无服务器架构的应用程序。
- en: Components of serverless architecture
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器架构的组件
- en: As we have seen, the serverless architecture provides us a way to develop applications
    where we are only responsible for writing the logic behind the applications, and
    relieves us of the worry of how the infrastructure will be managed for running
    the application and how the application will scale up and down based on the number
    of requests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，无服务器架构为我们提供了一种开发应用程序的方式，我们只需要负责编写应用程序背后的逻辑，而不用担心如何管理运行应用程序的基础设施，以及应用程序如何根据请求的数量进行扩展或缩减。
- en: But what powers this architecture? Let's try to spend some time taking a look
    at how the different components inside the architecture work to provide a serverless
    development approach toward application development.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是是什么驱动了这种架构？让我们花点时间来看看架构内部的不同组件是如何工作的，以提供一种无服务器开发方法来进行应用开发。
- en: As discussed earlier, the serverless approach to application development is
    made possible through the use of two technologies that have came into existence
    ...
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的，应用程序开发的无服务器方法是通过使用两种技术来实现的...
- en: Backend as a service
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端即服务
- en: Most of the applications that we develop share a common set of functionalities.
    These functionalities may include the implementation of a user authentication
    database, providing a way for storage and retrieval of files, or sending notifications
    either through the use of emails or push notifications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的大多数应用程序共享一组常见的功能。这些功能可能包括实现用户认证数据库，提供存储和检索文件的方式，或者通过电子邮件或推送通知发送通知。
- en: Most of the time, these functionalities are built into the application by introducing
    new components inside the application with which the other components can interact.
    The same is true for the Microservices-based applications, where these features
    are implemented, as different Microservices and the other Microservices interact
    with these services to achieve a certain outcome.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些功能是通过在应用程序中引入新组件来构建的，其他组件可以与这些组件进行交互。对于基于微服务的应用程序也是如此，这些功能被实现为不同的微服务，其他微服务与这些服务进行交互以实现特定的结果。
- en: In the BaaS approach, we decouple these functionalities from the application
    by integrating these functionalities through the use of third-party cloud providers.
    When this happens, our applications usually integrate these functionalities through
    the use of the APIs that are provided by the third-party providers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在BaaS方法中，我们通过使用第三方云提供商来解耦这些功能，通过使用第三方提供商提供的API，我们的应用程序通常集成这些功能。
- en: To understand this better, let's take a look at the serverless payroll-management
    system we introduced earlier. In this system, we have made the user authentication
    a disjointed part of our application by leveraging the BaaS offering provided
    by a third-party.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们来看一下我们之前介绍的无服务器工资管理系统。在这个系统中，我们通过利用第三方提供的BaaS服务，将用户认证作为我们应用程序的一个不相关的部分。
- en: In this approach, our user authentication system and any of the data associated
    with it is managed by a third-party provider. This provider exposes some of the
    APIs for the service, which we can use to integrate the service with our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们的用户认证系统及其相关的任何数据都由第三方提供商管理。该提供商公开了一些服务的API，我们可以使用这些API将服务与我们的应用程序集成。
- en: In our example, we exposed part of the user authentication service to the client
    through the use of the APIs exposed by the service. This allows the client to
    perform the user authentication directly with the service without going through
    the whole backend of the application. The second place where we used the BaaS
    offering was when we linked the employee search function with the user authentication
    service to retrieve a particular employee based on some criteria.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们通过使用服务提供的API来向客户端公开部分用户认证服务。这允许客户端直接与服务进行用户认证，而无需通过整个应用程序的后端。我们使用BaaS服务的第二个地方是当我们将员工搜索功能与用户认证服务链接起来，根据某些标准检索特定的员工。
- en: 'This concept of BaaS provides us with several advantages, such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: BaaS的这一概念为我们提供了几个优势，例如：
- en: '**Reduced development time:** With BaaS, the developers of an application need
    not worry about the development for the common set of functionalities that they
    can consume directly from the third-party service providers by using the APIs
    provided by the service provider.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少开发时间：**通过BaaS，应用程序的开发人员无需担心开发可以直接从第三方服务提供商那里获取的常见功能集，而是使用服务提供商提供的API。'
- en: '**Ease of operations:** Since the service and the infrastructure related to
    the service is managed by the cloud computing provider only, this reduced the
    complexity of managing the service and the operations it provides, allowing for
    reduced operational headaches.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作的便利性：**由于服务和与服务相关的基础设施仅由云计算提供商管理，这减少了管理服务和其提供的操作的复杂性，从而减少了操作上的麻烦。'
- en: '**Ease of scalability:** The services provided by the cloud computing provider
    are managed directly by them, allowing for easy scalability, which is now done
    by the provider only.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于扩展性：**云计算提供商提供的服务直接由他们管理，可以轻松扩展，现在只由提供商完成。'
- en: '**Flexibility of integration:** The services provided by the provider are usually
    integrated through the use of APIs. If the necessary API for the service integration
    is available for a provided platform, the platform can easily integrate with the
    service without worrying about the complexities behind the integration and hence
    allowing for support in different kinds of applications.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成的灵活性：**提供商提供的服务通常通过API进行集成。如果提供的平台有所需的服务集成API，平台可以轻松地与服务集成，而不必担心集成背后的复杂性，从而支持不同类型的应用程序。'
- en: Function as a service
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数即服务
- en: FaaS is an interesting concept and one of the main technologies that powers
    the serverless architecture. Inside this approach, we develop the backend code
    without worrying about how that code will be deployed and where it will be executed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS是一个有趣的概念，也是支持无服务器架构的主要技术之一。在这种方法中，我们开发后端代码，而不用担心代码将如何部署以及在哪里执行。
- en: The applications aimed for FaaS are just like any other application that does
    not require any kind of special framework for their development and execution.
    The only difference that comes between an FaaS application and a regular application
    that is deployed on the servers is the fact that FaaS applications have a severe
    limitation in terms of maintaining their state and the amount of time they can
    execute for. So, let's take a deeper dive into these two main aspects of having
    your ...
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 针对FaaS的应用程序就像任何其他不需要任何特殊框架进行开发和执行的应用程序一样。FaaS应用程序与部署在服务器上的常规应用程序之间唯一的区别在于，FaaS应用程序在维护其状态和执行的时间方面有严格的限制。因此，让我们深入探讨这两个主要方面...
- en: The restrictions on state management
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国家管理的限制
- en: In the FaaS model, the different parts of the application are built as separate
    functions where each function is executed on the occurrence of a certain event.
    When the application is supposed to be deployed, the cloud provider automatically
    manages the infrastructure where the application will run and how the application
    will scale up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在FaaS模型中，应用程序的不同部分被构建为单独的函数，每个函数在发生某个事件时被执行。当应用程序应该被部署时，云提供商会自动管理应用程序将在哪里运行以及应用程序如何扩展。
- en: In comparison to the traditional applications that, once deployed, start a server
    process and are ready to accept the incoming connections, the FaaS-based applications
    are started dynamically as a response to a certain input. Once the event occurs,
    the function starts and executes, waits for some time, and then the instance in
    which the function is executing is terminated. Now, this makes the process a bit
    interesting because the time for which the function is present in the infrastructure
    is limited and there is no guarantee that the same instance of the function will
    also handle the next call.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统应用程序相比，一旦部署，就会启动服务器进程并准备接受传入连接，基于FaaS的应用程序是动态启动作为对某个输入的响应。一旦事件发生，函数开始执行，等待一段时间，然后包含函数的实例被终止。现在，这使得这个过程变得有趣，因为函数在基础设施中存在的时间是有限的，而且不能保证同一个函数实例也会处理下一个调用。
- en: This makes the state management, that is, the management of local data for a
    currently-executing operation, a challenging task inside FaaS-based offerings,
    which severely limits what local data we can store inside a function instance
    while it is executing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得状态管理，也就是当前执行操作的本地数据管理，在基于FaaS的服务中成为一个具有挑战性的任务，严重限制了我们可以在函数实例中存储的本地数据。
- en: For dealing with such a scenario, we depend upon an external offering that can
    store the state data for us. This may include the use of an external database
    or a caching server where the data can be persisted for future reference.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种情况，我们依赖于一个可以为我们存储状态数据的外部服务。这可能包括使用外部数据库或缓存服务器，其中数据可以被持久化以供将来参考。
- en: Restrictions on execution times
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行时间限制
- en: Once a function starts executing inside an FaaS offering, it has only a limited
    amount of time in which it needs to complete its execution. Most of the famous
    cloud service providers have a limit set on their infrastructure for how long
    a function inside an FaaS offering can execute. For example, if we choose the
    most renowned FaaS offering by AWS, the AWS Lambda, the maximum duration for which
    a function can execute is limited to five minutes. This limit may vary marginally
    on the other providers but won't be too high.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数在FaaS服务中开始执行，它只有有限的时间来完成执行。大多数知名的云服务提供商都对FaaS服务中的函数执行时间设置了限制。例如，如果我们选择AWS最著名的FaaS服务AWS
    Lambda，函数的最大执行时间限制为五分钟。其他提供商的限制可能略有不同，但不会太高。
- en: Now this makes an interesting case for us as application developers. If one
    of the application components that we are trying to implement as a function may
    take a significantly long time to ...
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这对我们作为应用程序开发人员来说是一个有趣的案例。如果我们试图将一个应用程序组件实现为一个函数，可能需要花费相当长的时间...
- en: Executing functions inside FaaS
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在FaaS中执行函数
- en: Once we have developed our applications in the form of functions, we need a
    place to host and run it. This hosting place for the functions is provided by
    the cloud service provider. Now, once we have successfully hosted these functions
    and implemented rules when a particular function should execute, it is the duty
    of the cloud provider to handle the correct execution of these functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将应用程序开发为函数形式，我们需要一个地方来托管和运行它。这些函数的托管地点由云服务提供商提供。一旦我们成功托管了这些函数并实施了特定函数执行的规则，云服务提供商就有责任处理这些函数的正确执行。
- en: Now, when these functions have to execute, the cloud provider determines the
    correct environment that will be required to execute a particular function. Once
    this environment has been determined, the cloud provider launches an ephemeral
    container inside which the function code resides. This container provides the
    function a complete isolation from the other functions that might be executing
    in the environment. Now, once the container has launched successfully, this function
    executes, and provides a response back.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当这些函数需要执行时，云服务提供商确定执行特定函数所需的正确环境。一旦确定了这个环境，云服务提供商就会启动一个临时容器，函数代码就驻留在这个容器内。这个容器为函数提供了完全隔离，使其与可能在环境中执行的其他函数隔离开来。一旦容器成功启动，函数就会执行，并返回响应。
- en: The interesting part happens once the function has completed its execution.
    Once the function has completed execution, the cloud provider can either terminate
    the container instance in which the function was running or it can keep it alive
    to handle newer requests. Most of the time, the decision is taken based on the
    frequency of the requests that are arriving and the kind of policies that have
    been set by the user.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分发生在函数完成执行后。一旦函数完成执行，云服务提供商可以终止包含函数的容器实例，也可以保持其活动以处理新的请求。大多数情况下，决定是基于到达的请求频率和用户设置的策略来做出的。
- en: If a function instance is still running and waiting, a new incoming request
    might be redirected to that instance only, whereas if there are no ideal instances
    of a function running, the cloud provider will launch a new instance and redirect
    the request to that instance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数实例仍在运行并等待，新的请求可能会被重定向到该实例，而如果没有正在运行的函数实例，云服务提供商将启动一个新实例并将请求重定向到该实例。
- en: With this, we have a good idea of how FaaS works inside the serverless architecture
    and how it enables us to develop serverless applications. But how are these functions
    actually triggered? This brings us to another important component that comprises
    the serverless offerings. Let's take a look at what it is.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们对FaaS在无服务器架构中的工作原理以及它如何使我们能够开发无服务器应用程序有了一个很好的了解。但是这些函数实际上是如何触发的呢？这就引出了构成无服务器服务的另一个重要组件。让我们看看它是什么。
- en: API gateways in the serverless architecture
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器架构中的API网关
- en: In [Chapter 11](34b7ccb4-5bbc-474e-a70c-13ef8c1ae237.xhtml), *Taking the Microservices
    Approac*h, when we went through the concept of Microservices, we got introduced
    to API Gateways and how they help in the development of Microservices. These API
    gateways also play an important role in the development of the applications based
    upon the serverless architectures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](34b7ccb4-5bbc-474e-a70c-13ef8c1ae237.xhtml) *采用微服务方法*中，当我们了解了微服务的概念时，我们介绍了API网关以及它们如何帮助开发微服务。这些API网关在基于无服务器架构的应用程序开发中也起着重要作用。
- en: The API gateways are nothing but HTTP servers that embed the information about
    certain API endpoints of an application and associate these endpoints with some
    handlers. Once a request is made to a certain API endpoint, the handler associated
    with the API endpoint is called to handle the request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: API网关只是嵌入有关应用程序的某些API端点的信息并将这些端点与某些处理程序相关联的HTTP服务器。一旦向某个API端点发出请求，就会调用与API端点相关联的处理程序来处理请求。
- en: In the serverless architecture, the handlers that are associated with a particular
    API endpoint ...
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器架构中，与特定API端点相关联的处理程序...
- en: Understanding the execution of a serverless application
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解无服务器应用程序的执行
- en: So far, we've learned that a serverless application is built in the form of
    functions that execute based on the occurrence of some event. Also, these functions
    do not stay alive forever. Instead, these functions are brought into execution
    as requirements arise. So, how does the provider handle the execution of these
    functions when a request comes in? Let's take a look.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到无服务器应用程序是以函数的形式构建的，这些函数基于某些事件的发生而执行。此外，这些函数并不永远保持活动状态。相反，这些函数在需要时被执行。那么，当请求到来时，提供者如何处理这些函数的执行呢？让我们来看一下。
- en: Cold-starting a function
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冷启动函数
- en: When the application has been freshly deployed, it is pretty easy to imagine
    that there will be no instances of the function that will be executing currently.
    When a new request comes in that asks for the functionality provided by the function
    we have just deployed on the infrastructure. Now, the cloud provider systems are
    notified that there are no running instances of the function that can handle the
    incoming request.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序刚刚部署时，很容易想象当前不会有任何正在执行的函数实例。当新请求到来并要求由我们刚刚部署在基础设施上的函数提供的功能时。现在，云提供者系统被通知说没有正在运行的函数实例可以处理传入的请求。
- en: Once the provider system is made aware of the situation, it spawns up a new
    instance with the function code inside it. This instance now starts to execute
    the function based on the parameters provided in the request and a response is
    generated by the function and sent back to the requesting client. ...
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提供者系统意识到情况，它就会生成一个包含函数代码的新实例。这个实例现在开始根据请求中提供的参数执行函数，并且函数生成响应并发送回请求的客户端。
- en: Hot-starting a function
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热启动函数
- en: Completely opposite to the cold start, where a new instance of the function
    needs to be created and brought up to the execution, the hot start of the function
    utilizes the existing instance of the function that is already running in the
    infrastructure of the provider. When this happens, an incoming request does not
    have to spend time waiting for a new instance to spawn up before the request can
    be handled. This allows for the request to be processed quickly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与冷启动完全相反，热启动函数利用已经在提供者基础设施中运行的函数的现有实例。当这种情况发生时，传入的请求不必等待新实例生成才能处理请求。这允许请求快速处理。
- en: 'There is one thing that needs to be noted here: even in the case of a hot start
    of a function, the state from the previous execution of the function is not stored.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意一点：即使在函数的热启动情况下，也不会存储函数先前执行的状态。
- en: Now we know about one of the major factors on which the performance of a function
    may depend. Let's now move forward and build our first serverless application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了函数性能可能取决于的一个主要因素。现在让我们继续构建我们的第一个无服务器应用程序。
- en: Building our first serverless application
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个无服务器应用程序
- en: With our basic knowledge of the serverless architecture and how it works, it's
    now time for us to develop our first serverless application. For this tutorial,
    we are going to use the Apache OpenWhisk project, which will help us run our demo
    application on our local development system. So, let's take a look at what Apache
    OpenWhisk has to offer us and how we can utilize the platform for our benefit.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们对无服务器架构及其工作原理的基本了解，现在是时候开发我们的第一个无服务器应用程序了。在本教程中，我们将使用Apache OpenWhisk项目，在本地开发系统上运行我们的演示应用程序。因此，让我们看看Apache
    OpenWhisk为我们提供了什么，以及我们如何利用该平台来获益。
- en: A quick introduction to Apache OpenWhisk
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache OpenWhisk的快速介绍
- en: The Apache OpenWhisk platform provides us with the features and functionality
    that allow us to set up our own platform for running serverless applications.
    The project provides the functionality for executing functions based on the triggering
    of certain events in the environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Apache OpenWhisk平台为我们提供了功能和功能，使我们能够设置自己的平台来运行无服务器应用程序。该项目提供了根据环境中某些事件的触发执行函数的功能。
- en: The execution of these functions happens inside the docker containers, and the
    OpenWhisk platform manages the deployment and scaling of these functions inside
    it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的执行发生在docker容器内，OpenWhisk平台管理其中的函数的部署和扩展。
- en: 'Here are some of the features provided by the platform:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是平台提供的一些功能：
- en: '**Easy-to-use tools:** The platform provides a number of tools that allow us
    to easily package and port the application to run on the OpenWhisk platform, with
    the exception of having the application follow a set of conventions as defined
    by the platform.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用的工具：** 该平台提供了许多工具，使我们能够轻松打包和移植应用程序以在OpenWhisk平台上运行，除了应用程序遵循平台定义的一组约定。'
- en: '**Isolation using containers:** The platform isolates the different functions
    through the use of docker containers, such that every function runs inside its
    own isolated environment so as to avoid any kind of environmental-dependency conflicts.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用容器进行隔离：** 该平台通过使用Docker容器来隔离不同的功能，使得每个功能都在自己独立的环境中运行，以避免任何环境依赖冲突。'
- en: '**Support for a wide variety of languages:** The OpenWhisk platform provides
    us with a number of supported language platforms that we can use to build our
    serverless application. This also includes the use of binary executables built
    using Go, C++, and Rust.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持多种语言：** OpenWhisk平台为我们提供了许多支持的语言平台，我们可以使用这些平台来构建我们的无服务器应用程序。这还包括使用Go、C++和Rust构建的二进制可执行文件。'
- en: '**Built-in API Gateway:** The OpenWhisk package comes with its own built-in
    API gateway, allowing us to easily integrate the applications through the use
    of RESTful API endpoints.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置API网关：** OpenWhisk软件包配备了自己的内置API网关，使我们能够通过RESTful API端点轻松集成应用程序。'
- en: All of these functionalities make OpenWhisk a great platform for running the
    serverless applications, be it on the cloud or in your local development environment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能使OpenWhisk成为在云端或本地开发环境中运行无服务器应用程序的绝佳平台。
- en: But, before we start building the application, we need to have OpenWhisk deployed
    on our system. To deploy the project, please follow the steps in the *Technical
    requirements* section at the beginning of this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始构建应用程序之前，我们需要在系统上部署OpenWhisk。要部署项目，请按照本章开头的*技术要求*部分中的步骤进行操作。
- en: For the demo, we are going to build an application that queries the GitHub API
    for us and retrieves the repositories that are associated with our user account.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于演示，我们将构建一个应用程序，该应用程序会查询GitHub API，并检索与我们的用户帐户关联的存储库。
- en: Setting up the development environment
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Before we start writing the code for our application, we need to have some dependencies
    in place. So, let's build the environment and then move on to writing the code
    that will power our application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写应用程序的代码之前，我们需要先安装一些依赖项。因此，让我们先构建环境，然后开始编写将驱动我们应用程序的代码。
- en: 'As a first step, let''s create a directory that will contain all the files
    related to our project. Let''s call this folder `github_demo`. The following command
    gets the folder in place for us:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们创建一个目录，其中包含与我们项目相关的所有文件。让我们将这个文件夹命名为`github_demo`。以下命令可以帮助我们创建这个文件夹：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we have the directory setup done, let''s move into the directory and set
    up a few things:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置好目录，让我们进入目录并设置一些东西：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once this is done, we can now set up our project. Before we start writing the
    code, let's get the virtual environment setup done, which will help us to keep
    our project dependencies segregated. ...
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们现在可以设置我们的项目了。在我们开始编写代码之前，让我们完成虚拟环境的设置，这将帮助我们保持项目依赖项的隔离。...
- en: Building our configuration file
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的配置文件
- en: 'For the purpose of this application, we are going to use a configuration file
    to store our user-account-related data, which will allow us to authenticate to
    the `Github` API. For this, inside our project directory, create a new file named
    `config.ini` with the following contents:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个应用程序，我们将使用一个配置文件来存储与我们用户帐户相关的数据，这将允许我们对`Github` API进行身份验证。为此，在我们的项目目录中，创建一个名为`config.ini`的新文件，其中包含以下内容：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once we have the configuration file setup complete, let's move on to writing
    our application code, which will interact with `Github` to get our `repos`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了配置文件的设置，让我们继续编写我们的应用程序代码，这将与`Github`交互以获取我们的`repos`。
- en: Integrating with the GitHub API
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GitHub API集成
- en: 'Now that we''re coming to the actual part of our application, let''s get started
    with writing the code. The following code snippet describes the code we use to
    query the `Github` API:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们即将开始我们应用程序的实际部分，让我们开始编写代码。以下代码片段描述了我们用来查询`Github` API的代码：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting the code ready to run with OpenWhisk
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好与OpenWhisk一起运行的代码
- en: With the code ready, it's now time to get it into a format that OpenWhisk can
    execute.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码就绪后，现在是时候将其转换为OpenWhisk可以执行的格式了。
- en: 'For any function to execute inside OpenWhisk, the code should be called from
    the `__main__.py` file. So, let''s create the file and add the following contents
    to it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OpenWhisk内执行任何功能，代码应该从`__main__.py`文件中调用。因此，让我们创建该文件并添加以下内容：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the code in place, let''s try to understand what we did here. First, we
    imported the `get_repos` function that we created in the `github_demo.py` file,
    which helps to retrieve the contents from the `Github` API:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码就位后，让我们试着理解我们在这里做了什么。首先，我们导入了在`github_demo.py`文件中创建的`get_repos`函数，该函数有助于从`Github`
    API中检索内容：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we define the `main()` function, which is called by the OpenWhisk, to
    execute the code. Any code that is present inside the main function is directly
    executed by the OpenWhisk. So, we use this method to call our `get_repos()` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义`main()`函数，OpenWhisk将调用该函数来执行代码。任何存在于主函数中的代码都将由OpenWhisk直接执行。因此，我们使用这种方法来调用我们的`get_repos()`函数：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once this is done, we are on the verge of getting our application ready for
    the deployment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这一步，我们就快要准备好部署我们的应用程序了。
- en: Taking the final steps toward deployment
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 朝着部署的最后步骤迈进
- en: 'We have just a few more steps before we can deploy our application. For the
    successful installation of the app, let''s create a file that stores the dependencies
    required for running our project. The following command helps us get the dependencies
    in place:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署应用程序之前，我们还有一些步骤要完成。为了成功安装应用程序，让我们创建一个文件，用于存储运行我们项目所需的依赖项。以下命令可帮助我们安装所需的依赖项：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the requirements packaged, now let''s package our project so that it can
    be deployed to OpenWhisk. For this, running the following command helps in creating
    a package of different project components:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些要求打包好后，现在让我们打包我们的项目，以便可以部署到OpenWhisk。为此，运行以下命令可以帮助我们创建不同项目组件的包：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this, we are now all set to deploy our application to OpenWhisk.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在已经准备好将我们的应用程序部署到OpenWhisk了。
- en: Deploying to OpenWhisk
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到OpenWhisk
- en: Once we have the package ready for deployment, we need to run a few commands
    provided by OpenWhisk to get the package up and running on the platform.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好部署包，我们需要运行OpenWhisk提供的一些命令，以便在平台上启动并运行包。
- en: 'As a first step, we have to execute the following command to get the package
    uploaded on the OpenWhisk:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们必须执行以下命令，将包上传到OpenWhisk：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once this command is executed, the package will be uploaded to the OpenWhisk
    platform and will be ready to run.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了这个命令，包将被上传到OpenWhisk平台，并准备好运行。
- en: 'Now, to invoke the application, we can run the following command, which will
    execute the application in an asynchronous manner:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要调用应用程序，我们可以运行以下命令，以异步方式执行应用程序：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once this is done, our application starts executing in an asynchronous manner.
    By running asynchronously, we mean that the execution of the command won't wait
    until the end of the execution of the function, but rather will provide an action
    activation ID that can be used to track the results of the invocation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的应用程序开始以异步方式执行。通过异步运行，我们的意思是命令的执行不会等到函数执行结束，而是会提供一个可以用来跟踪调用结果的操作激活ID。
- en: Now, let's take a look at how OpenWhisk handles the execution of this application
    after the application has been deployed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看应用程序部署后OpenWhisk如何处理这个应用程序的执行。
- en: Understanding the execution of application Inside Openwhisk
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Openwhisk内应用程序的执行
- en: With the demo application in place, it's time for us to understand how the execution
    of this application works behind the scenes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了演示应用程序，现在是时候了解这个应用程序在幕后是如何执行的了。
- en: 'Behind the successful execution of the application, there are several steps
    involved which start from the `wsk action invoke` command that we ran to execute
    our application. So, let''s take a look at the steps that happened behind the
    scenes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序成功执行的背后，有几个步骤涉及，从我们运行`wsk action invoke`命令开始执行我们的应用程序。因此，让我们看看幕后发生的步骤：
- en: '**Making the API call:** Every action that we build to deploy on OpenWhisk
    is mapped as an API endpoint that will invoke the action. When we run `wsk action
    invoke`*,* the command makes a call to the API endpoint that has been mapped for
    the provided function. This call is then intercepted by Nginx inside OpenWhisk,
    which acts ...'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发出API调用：** 我们构建的每个要部署到OpenWhisk的操作都被映射为将调用该操作的API端点。当我们运行`wsk action invoke`时，该命令会调用为所提供的函数映射的API端点。然后，这个调用被OpenWhisk内的Nginx拦截，起到...'
- en: Advantages of going serverless
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器的优势
- en: 'With an understanding of how serverless applications work, now it''s time for
    us to take a look at the advantages provided by this development approach:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了无服务器应用程序的工作原理后，现在是时候看看这种开发方法提供的优势了：
- en: '**Reduced development efforts:** By using the services provided by the third-party
    cloud providers, we can reduce the development efforts for some of the common
    functionalities that are found inside an application, such as user authentication,
    notification, and file storage. All of these functionalities can be implemented
    through the use of the APIs provided by the cloud providers.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少开发工作量：** 通过使用第三方云提供商提供的服务，我们可以减少一些在应用程序中找到的常见功能的开发工作量，例如用户身份验证、通知和文件存储。所有这些功能都可以通过云提供商提供的API来实现。'
- en: '**Less operational complexity:** The execution and scaling of a serverless
    application is managed by the cloud service provider, which takes away the operational
    complexities of managing our own infrastructure to handle the execution of the
    application.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作复杂性较低：** 无服务器应用程序的执行和扩展由云服务提供商管理，这消除了管理我们自己的基础设施以处理应用程序执行的操作复杂性。'
- en: '**High availability:** The applications built in the serverless manner provide
    high availability due to the fact that the infrastructure is managed by the cloud
    provider, which can have the application run in different data centers across
    the world, hence reducing the chance that the application''s uptime will be affected
    in case one of the data centers is experiencing some issues.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性：** 以无服务器方式构建的应用程序由于基础设施由云提供商管理，因此可以在世界各地的不同数据中心运行应用程序，从而降低了应用程序的可用性受影响的机会。'
- en: '**Optimized resource allocation:** Since a function is executed only when a
    certain event occurs, the allocation of resources happens only when a particular
    function is being executed, which optimizes the usage of resources across the
    infrastructure.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化资源分配：** 由于只有在发生某个事件时才执行函数，因此只有在执行特定函数时才分配资源，这优化了跨基础设施的资源使用。'
- en: '**Choice of programming languages:** Most of the serverless solutions provide
    a wide support for the different types of programming languages that are available,
    which allows us to implement our solutions with the best-possible technology stack
    that will work with the application.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程语言的选择：** 大多数无服务器解决方案都支持各种类型的编程语言，这使我们能够使用最佳的技术栈来实现我们的解决方案。'
- en: With this, we now have enough points that can convince us to choose the serverless
    development approach in case our needs align with the development methodology
    that needs to be followed for building a serverless application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有足够的理由选择无服务器开发方法，以便我们的需求与构建无服务器应用程序所需遵循的开发方法论相一致。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we moved through this chapter, we took a look at how the serverless architecture
    is becoming the new trend in the development of the applications, and how this
    architecture works. We covered the different components of the serverless architecture
    and went through the concepts of Backend as a Service and Function as a Service,
    which power the serverless architecture. We then looked at the role of API Gateways
    in the architecture and how the API Gateway in serverless applications differs
    from the one we used in Microservices.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们阅读本章的过程中，我们看到了无服务器架构如何成为应用程序开发的新趋势，以及这种架构的工作原理。我们涵盖了无服务器架构的不同组件，并介绍了后端即服务和函数即服务的概念，它们支持无服务器架构。然后，我们看了一下API网关在架构中的作用，以及无服务器应用程序中的API网关与微服务中使用的API网关有何不同。
- en: After that, we took a tour of building our first serverless application and
    ran it through Apache OpenWhisk, which provides an open source platform for running
    serverless applications. Here, we also took a deep ...
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始构建我们的第一个无服务器应用程序，并通过Apache OpenWhisk运行它，该平台提供了一个运行无服务器应用程序的开源平台。在这里，我们也深入探讨了...
- en: Questions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the advantages provided by the serverless architecture?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无服务器架构提供了哪些优势？
- en: How does BaaS help is the development of applications?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BaaS如何帮助应用程序开发？
- en: How does an API Gateway help in the execution of serverless applications?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关如何帮助执行无服务器应用程序？
- en: What are some of the things that make it hard to port an application into a
    serverless format?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些因素使将应用程序转换为无服务器格式变得困难？
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Did you find the idea of serverless architecture interesting? Take a look at
    *Building Serverless Applications with Python* by *Jalem Raj Rohit*, *Packt Publishing*,
    and dive deeper into the serverless architecture.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得无服务器架构的理念有趣吗？看看*Jalem Raj Rohit*的*Packt Publishing*出版的*使用Python构建无服务器应用程序*，深入了解无服务器架构。
