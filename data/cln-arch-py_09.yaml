- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: 'The Frameworks and Drivers Layer: External Interfaces'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架和驱动层：外部接口
- en: The **Frameworks and Drivers layer** represents the outermost ring of Clean
    Architecture, where our application meets the real world. In previous chapters,
    we built the core of our task management system from domain entities to use cases,
    and the Interface Adapters that coordinate between them. Now we’ll see how Clean
    Architecture helps us integrate with external frameworks, databases, and services
    while keeping our core business logic pristine and protected.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架和驱动层**代表了清洁架构的最外层环，在这里我们的应用程序与真实世界相遇。在前面的章节中，我们从领域实体到用例，再到协调它们之间的接口适配器，构建了我们任务管理系统的核心。现在我们将看到清洁架构如何帮助我们与外部框架、数据库和服务集成，同时保持我们的核心业务逻辑纯净和安全。'
- en: Through practical implementation, we’ll explore how Clean Architecture’s careful
    attention to boundaries enables our application to work with various frameworks
    and external services without becoming dependent on them. We’ll see how our task
    management system can leverage external capabilities—from user interfaces to data
    storage and notifications. This chapter demonstrates how Clean Architecture’s
    principles translate into real-world implementations. Through hands-on examples,
    you’ll see how Clean Architecture helps manage the complexities of external integrations
    while keeping your core business logic focused and maintainable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实际实施，我们将探讨清洁架构对边界的细致关注如何使我们的应用程序能够与各种框架和外部服务协同工作，而不会对其产生依赖。我们将看到我们的任务管理系统如何利用外部能力——从用户界面到数据存储和通知。本章展示了清洁架构的原则如何转化为现实世界的实施。通过实际示例，您将看到清洁架构如何帮助管理外部集成的复杂性，同时保持您的核心业务逻辑集中和可维护。
- en: By the end of this chapter, you’ll understand how to implement the Frameworks
    and Drivers layer effectively, integrating external dependencies while maintaining
    architectural integrity. You’ll be able to adapt these patterns to your own projects,
    ensuring your applications remain flexible and maintainable as external requirements
    evolve.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何有效地实现框架和驱动层，在集成外部依赖的同时保持架构的完整性。您将能够将这些模式应用到自己的项目中，确保随着外部需求的变化，您的应用程序保持灵活和可维护。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the Frameworks and Drivers layer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解框架和驱动层
- en: Creating UI framework adapters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UI框架适配器
- en: Component organization and boundaries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件组织和边界
- en: Implementing database adapters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据库适配器
- en: Integrating external services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成外部服务
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. For brevity, code examples in the chapter may be
    partially implemented. Complete versions of all examples can be found in the book’s
    accompanying GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
    If you choose to run the email driver example in the Integrating external services
    section, you will need to register for a free SendGrid developer account at [https://app.sendgrid.com](https://app.sendgrid.com).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章及本书其余部分展示的代码示例均使用Python 3.13进行测试。为了简洁，章节中的代码示例可能只部分实现。所有示例的完整版本可以在本书配套的GitHub仓库[https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)中找到。如果你选择在集成外部服务部分运行电子邮件驱动程序示例，你需要在[https://app.sendgrid.com](https://app.sendgrid.com)注册一个免费的SendGrid开发者账户。
- en: Understanding the Frameworks and Drivers layer
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解框架和驱动层
- en: Every significant software application must eventually interact with the real
    world. Databases need querying, files need reading, and users need interfaces.
    In Clean Architecture, these essential but volatile interactions are managed through
    the Frameworks and Drivers layer. This layer’s unique position and responsibilities
    make it both powerful and potentially dangerous to our architectural goals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个重要的软件应用程序最终都必须与真实世界交互。数据库需要查询，文件需要读取，用户需要接口。在清洁架构中，这些基本但易变的交互通过框架和驱动层进行管理。这一层的独特位置和责任使其既强大又可能对我们的架构目标构成潜在危险。
- en: Position in Clean Architecture
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在清洁架构中的位置
- en: '![Figure 7.1: Frameworks and Drivers layer with the primary components](img/B31577_07_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：框架和驱动层及其主要组件](img/B31577_07_01.png)'
- en: 'Figure 7.1: Frameworks and Drivers layer with the primary components'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：框架和驱动层的主要组件
- en: The Frameworks and Drivers layer’s position at the architecture’s edge is no
    accident; it represents what Clean Architecture calls the details of our system.
    These details, while essential for a functioning application, should remain disconnected
    from our core business logic. This separation creates a protective boundary that
    typically contains changes to just the outer layer. However, when new requirements
    do necessitate modifications to core business rules, Clean Architecture provides
    clear paths for implementing these changes systematically through each layer,
    ensuring our system evolves gracefully without compromising its architectural
    integrity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 框架和驱动层在架构边缘的位置并非偶然；它代表了Clean Architecture所说的我们系统的细节。这些细节虽然对于应用程序的正常运行至关重要，但应该与我们的核心业务逻辑保持分离。这种分离创建了一个保护边界，通常只包含对最外层的更改。然而，当新的需求确实需要修改核心业务规则时，Clean
    Architecture提供了明确的路径，通过每一层系统地实施这些更改，确保我们的系统优雅地进化，而不损害其架构完整性。
- en: 'Let’s examine several key principles about the Frameworks and Drivers layer
    position in Clean Architecture:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察关于框架和驱动层在Clean Architecture中位置的几个关键原则：
- en: '**External boundary**: As the outermost layer, it handles all interactions
    with the outside world:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部边界**：作为最外层，它处理与外部世界的所有交互：'
- en: User interfaces (command line interface (CLI), web, API endpoints)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面（命令行界面（CLI）、网页、API端点）
- en: Database systems (drivers such as SQLite, or frameworks such as SQLAlchemy)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库系统（如SQLite的驱动程序或如SQLAlchemy的框架）
- en: External services and APIs
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部服务和API
- en: File systems and device interactions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统和设备交互
- en: '**Dependency direction**: Following Clean Architecture’s fundamental rule,
    all dependencies point inward. Our frameworks and drivers depend on inner layer
    interfaces but never the reverse:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖方向**：遵循Clean Architecture的基本规则，所有依赖都指向内部。我们的框架和驱动依赖于内部层接口，但从不反过来：'
- en: A database adapter implements a repository interface defined by the Application
    layer
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库适配器实现了由应用层定义的存储库接口
- en: A web controller uses interfaces from the Interface Adapters layer
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页控制器使用接口适配器层的接口
- en: External service clients adapt to our internal abstractions from the Application
    layer
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部服务客户端适应来自应用层的内部抽象
- en: '**Implementation details**: This layer contains what Clean Architecture considers
    details, specific technical choices that should be interchangeable:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现细节**：此层包含Clean Architecture认为的细节，即特定技术选择，这些选择应该是可互换的：'
- en: The choice between SQLite or PostgreSQL
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite或PostgreSQL之间的选择
- en: Using Click versus Typer for CLI implementation
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Click与Typer进行CLI实现
- en: Selecting SendGrid or AWS SES for email notifications
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择SendGrid或AWS SES进行电子邮件通知
- en: 'This strategic positioning provides several key benefits:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种战略定位提供了几个关键好处：
- en: '**Framework independence**: Core business logic remains unaware of specific
    framework choices'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架独立性**：核心业务逻辑对特定的框架选择一无所知'
- en: '**Easy testing**: External dependencies can be replaced with test doubles'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于测试**：外部依赖可以被测试替身替换'
- en: '**Flexible evolution**: Implementation details can change without affecting
    inner layers'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的进化**：实现细节可以更改，而不会影响内部层'
- en: '**Clear boundaries**: Explicit interfaces define how external concerns interact
    with our system'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的边界**：显式接口定义了外部关注点如何与我们的系统交互'
- en: For our task management system, this means that whether we’re implementing a
    command-line interface, storing tasks in files, or sending notifications through
    email services, all these implementation details live in this outermost layer
    while respecting the interfaces defined by inner layers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的任务管理系统，这意味着无论我们是在实现命令行界面、将任务存储在文件中，还是通过电子邮件服务发送通知，所有这些实现细节都生活在这个最外层，同时尊重内部层定义的接口。
- en: Next, we will explore the distinction between frameworks and drivers, helping
    us understand how to effectively implement each type of external dependency.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨框架和驱动之间的区别，帮助我们理解如何有效地实现每种类型的外部依赖。
- en: 'Frameworks versus drivers: understanding the distinction'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架与驱动：理解区别
- en: While both frameworks and drivers reside in the outermost layer of Clean Architecture,
    they differ significantly in their integration complexity. This distinction stems
    from how they interact with the layers we explored in *Chapters 5 and 6*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 framework 和 drivers 都位于 Clean Architecture 的最外层，但它们在集成复杂性方面存在显著差异。这种区别源于它们与我们探索的
    *第 5 章和第 6 章* 中的层如何交互。
- en: '**Frameworks** are comprehensive software platforms that impose their own architecture
    and control flow:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架**是全面的软件平台，它们强加自己的架构和控制流程：'
- en: Web frameworks like Flask or FastAPI
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似 Flask 或 FastAPI 的 Web 框架
- en: CLI frameworks like Click or Typer
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似 Click 或 Typer 的 CLI 框架
- en: Object relational modeling (ORM) frameworks like SQLAlchemy
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象关系建模（ORM）框架，如 SQLAlchemy
- en: 'Frameworks like Click (which we’ll implement for our CLI) require the full
    complement of Interface Adapters layer components to maintain clean architectural
    boundaries:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 Click（我们将为我们的 CLI 实现它）这样的框架需要完整的接口适配器层组件，以保持清晰的架构边界：
- en: Controllers that transform framework-specific requests into use case inputs
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将框架特定的请求转换为用例输入的控制器
- en: Presenters that format domain data for framework consumption
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为框架消费格式化领域数据的演示者
- en: View models that structure data appropriately for framework display
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为框架显示结构数据的视图模型
- en: '**Drivers**, in contrast, are simpler components that provide low-level services
    without imposing their own structure or flow. Examples include database drivers,
    file system access components, and external API clients. Unlike frameworks, drivers
    don’t dictate how your application works, they simply provide capabilities that
    you adapt to your needs.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，**驱动程序**是更简单的组件，它们提供低级服务而不强加自己的结构或流程。例如，包括数据库驱动程序、文件系统访问组件和外部 API 客户端。与框架不同，驱动程序不规定你的应用程序如何工作，它们只是提供你根据需要适应的能力。
- en: 'These drivers interact with our application through ports—the abstract interfaces
    we first introduced in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123). We saw
    two key examples of ports in that chapter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些驱动程序通过端口与我们的应用程序交互——这是我们首次在第[*第 5 章*](Chapter_05.xhtml#_idTextAnchor123)中介绍的抽象接口。我们在那一章中看到了两个关键端口示例：
- en: Repository interfaces like `TaskRepository` for persistence operations
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于持久化操作的存储库接口，如`TaskRepository`
- en: Service interfaces like `NotificationPort` for external notifications
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于外部通知的服务接口，如`NotificationPort`
- en: 'Following the patterns established in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123),
    drivers typically need only two components:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[*第 5 章*](Chapter_05.xhtml#_idTextAnchor123)中建立的模式，驱动程序通常只需要两个组件：
- en: A port defined in the Application layer (like `TaskRepository`)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用层定义的端口（如`TaskRepository`）
- en: A concrete implementation in the Frameworks and Drivers layer
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在框架和驱动程序层的一个具体实现
- en: 'In the following examples we can see the distinction in code. First, we look
    at a framework example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到代码中的区别。首先，我们来看一个框架示例：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how the framework example requires both a controller to transform the
    request and a presenter to format the response.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意框架示例需要控制器来转换请求和演示者来格式化响应。
- en: 'Next, we look at a driver example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一个驱动程序的示例：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we see that the SQLite driver simply implements the repository interface
    directly with a basic save operation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到 SQLite 驱动程序直接通过基本的保存操作实现了存储库接口。
- en: 'This architectural distinction helps us implement appropriate integration strategies
    for each type of external dependency while maintaining Clean Architecture’s Dependency
    Rule. These separations provide immediate practical benefits: when a security
    vulnerability emerges in your database driver, the fix involves only updating
    the outer layer implementation. When business requirements change how tasks are
    prioritized, those changes remain isolated in your domain logic. These aren’t
    theoretical benefits, they’re daily advantages that compound as systems grow.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构区分帮助我们为每种外部依赖实现适当的集成策略，同时保持 Clean Architecture 的依赖规则。这些分离提供了即时的实际好处：当你的数据库驱动程序出现安全漏洞时，修复只需要更新外层实现。当业务需求改变任务优先级时，这些变化仍然被隔离在你的领域逻辑中。这些不是理论上的好处，而是随着系统增长而累积的日常优势。
- en: Application composition
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序组合
- en: 'Having explored the distinction between frameworks and drivers, we now turn
    to a crucial question: how do these components come together into a cohesive application
    while maintaining clean architectural boundaries? This brings us to the concept
    of **application composition** which is the systematic assembly of our system’s
    components.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了框架和驱动程序之间的区别之后，我们现在转向一个关键问题：这些组件是如何组合成一个统一的应用程序，同时保持清晰的架构边界的？这引出了**应用程序组合**的概念，即我们系统组件的系统组装。
- en: In Clean Architecture, application composition serves as the orchestration point
    where our carefully separated components unite to form a working system. Think
    of it like assembling a complex machine. Each part must fit together precisely,
    but the assembly process itself shouldn’t change how the individual components
    work.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clean Architecture 中，应用程序组合作为协调点，我们的精心分离的组件联合起来形成一个工作系统。想想看，就像组装一个复杂的机器。每个部分都必须精确地配合在一起，但组装过程本身不应改变单个组件的工作方式。
- en: 'The composition of a Clean Architecture application involves three key aspects
    working together:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Clean Architecture 应用程序的组合涉及三个关键方面共同工作：
- en: '**Configuration management:**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置管理：**'
- en: Manages environment-specific settings
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理特定环境的设置
- en: Controls framework and driver selection
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制框架和驱动程序选择
- en: Maintains separation between settings and business logic
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持设置和业务逻辑之间的分离
- en: Enables different configurations for development, testing, and production
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许开发、测试和生产使用不同的配置
- en: '**Component factories:**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件工厂：**'
- en: Create properly configured implementations of interfaces
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建正确配置的接口实现
- en: Manage dependency lifecycles
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理依赖生命周期
- en: Handle initialization sequences
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理初始化序列
- en: Maintain Clean Architecture’s Dependency Rule during object creation
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象创建过程中保持 Clean Architecture 的依赖规则
- en: '**Main application entry point:**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**主应用程序入口点：**'
- en: Orchestrates startup sequence
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调启动序列
- en: Handles top-level error conditions
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理顶级错误条件
- en: Maintains clean separation between startup and business operations
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持启动和业务操作之间的清晰分离
- en: Serves as the composition root where dependencies are assembled
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为依赖组装的组合根
- en: 'Let’s see how these aspects work together in practice:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些方面在实际中是如何协同工作的：
- en: '![Figure 7.2: Clean Architecture composition flow showing configuration, composition
    root, and framework adapters](img/B31577_07_02.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：Clean Architecture 组合流程图，显示配置、组合根和框架适配器](img/B31577_07_02.png)'
- en: 'Figure 7.2: Clean Architecture composition flow showing configuration, composition
    root, and framework adapters'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：Clean Architecture 组合流程图，显示配置、组合根和框架适配器
- en: 'Our task management system implements these composition patterns in specific
    ways that demonstrate their practical value:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务管理系统以特定方式实现了这些组合模式，以展示其实际价值：
- en: The Configuration mechanism provides environment-aware settings that drive implementation
    choices, like selecting between in-memory or file-based storage
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置机制提供环境感知设置，驱动实现选择，例如在内存存储或基于文件的存储之间进行选择
- en: The **Composition root**, through `main.py` and the `Application` class, coordinates
    the assembly of our components while maintaining clean architectural boundaries
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合根**通过 `main.py` 和 `Application` 类协调组件的组装，同时保持清晰的架构边界'
- en: '**Framework Adapters** connect our user interfaces to the core application
    through:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架适配器**通过以下方式将我们的用户界面连接到核心应用程序：'
- en: Controllers that translate UI requests into use case inputs
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 UI 请求转换为用例输入的控制器
- en: Presenters that format domain data for display
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将领域数据格式化为显示的演示者
- en: A clean separation that allows multiple interfaces to share core components
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的分离，允许多个接口共享核心组件
- en: 'This architectural approach delivers several key benefits:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构方法提供了几个关键好处：
- en: Implementation flexibility through factory-based component creation
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过基于工厂的组件创建实现实施灵活性
- en: Clean separation of concerns through well-defined boundaries
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过明确定义的边界实现关注点的清晰分离
- en: Easy testing through component isolation
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组件隔离实现易于测试
- en: Simple addition of new features without disrupting existing code
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单添加新功能，而不会破坏现有代码
- en: These benefits manifest throughout our implementation. In the following sections,
    we’ll examine each infrastructure component from *Figure 7.2* in detail.  We’ll
    cover everything from configuration management to framework adapters, showing
    how they work together in practice through concrete patterns and code examples.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势贯穿于我们的实现之中。在接下来的章节中，我们将详细检查从*图7.2*中的每个基础设施组件。我们将从配置管理到框架适配器进行覆盖，展示它们如何通过具体的模式和代码示例在实际中协同工作。
- en: Clean Architecture patterns in the outer layer
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外层Clean Architecture模式
- en: The patterns we’ve explored establish clear strategies for integrating external
    concerns while protecting our core business logic. As we move into implementing
    specific components of our task management system, these patterns will work together
    in distinct ways to maintain architectural boundaries.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所探讨的模式为整合外部关注点提供了明确的策略，同时保护我们的核心业务逻辑。当我们开始实现任务管理系统中的特定组件时，这些模式将以独特的方式协同工作，以维持架构边界。
- en: 'Consider how these patterns combine in practice: A web request arrives at our
    system’s edge, triggering a cascade of clean architectural interactions. Framework
    adapters translate the request into our internal format, while ports enable database
    and notification operations without exposing their implementation details. All
    of this orchestration happens through our composition root, which ensures each
    component receives its properly configured dependencies.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这些模式在实际中的组合：一个网络请求到达我们系统的边缘，触发一系列清晰的架构交互。框架适配器将请求转换为我们的内部格式，而端口允许数据库和通知操作，而不暴露其实现细节。所有这些编排都通过我们的组合根发生，确保每个组件都接收到其正确配置的依赖项。
- en: As we dive deeper into these topics in the remainder of this chapter, we’ll
    implement portions of our task management system to see these patterns in action—from
    CLI adapters translating user commands to repository implementations managing
    persistence. Each implementation will demonstrate not just the individual patterns,
    but how they cooperate to maintain Clean Architecture’s core principles while
    delivering practical functionality.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余部分深入探讨这些主题时，我们将实现任务管理系统的部分功能，以看到这些模式在实际中的应用——从CLI适配器转换用户命令到存储库实现管理持久性。每个实现不仅展示了单个模式，还展示了它们如何合作以维持Clean
    Architecture的核心原则，同时提供实用的功能。
- en: Creating UI framework adapters
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建UI框架适配器
- en: When integrating user interface frameworks, Clean Architecture’s separation
    of concerns becomes particularly valuable. UI frameworks tend to be both volatile
    and opinionated, making it crucial to isolate their influence from our core business
    logic. In this section, we’ll explore how to implement framework adapters that
    maintain clean boundaries while delivering practical user interfaces.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当集成用户界面框架时，Clean Architecture的关注点分离变得特别有价值。UI框架往往既易变又有偏见，因此隔离它们对我们核心业务逻辑的影响至关重要。在本节中，我们将探讨如何实现框架适配器，在保持清晰的边界的同时提供实用的用户界面。
- en: Framework adapters in practice
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际中的框架适配器
- en: 'Let’s begin by examining what we’re building. Our task management system needs
    a user interface that allows users to manage projects and tasks effectively. *Figure
    7.3* shows a typical interaction screen from our command-line interface:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们正在构建的内容。我们的任务管理系统需要一个用户界面，使用户能够有效地管理项目和任务。*图7.3*展示了我们的命令行界面中的一个典型交互屏幕：
- en: '![Figure 7.3: Task editing interface in the CLI application](img/B31577_07_03.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：CLI应用程序中的任务编辑界面](img/B31577_07_03.png)'
- en: 'Figure 7.3: Task editing interface in the CLI application'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：CLI应用程序中的任务编辑界面
- en: 'This interface demonstrates several key aspects of our system:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此界面展示了我们系统的一些关键方面：
- en: Clear display of task details and status
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰显示任务详情和状态
- en: Simple, numbered menu for common operations
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的编号菜单用于常见操作
- en: Consistent formatting of domain concepts (status, priority)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域概念的格式一致（状态、优先级）
- en: Intuitive navigation between different views
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同视图之间直观导航
- en: 'While this interface appears straightforward to users, its implementation requires
    careful orchestration across architectural boundaries. Each piece of information
    displayed and every action available represents data flowing through our Clean
    Architecture layers. *Figure 7.4* illustrates how a single operation—creating
    a project—flows through these boundaries:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个界面对用户来说看起来很简单，但其实现需要在架构边界之间进行仔细的协调。显示的每一项信息和可用的每一个操作都代表着通过我们清洁架构层的数据流。*图
    7.4* 展示了单个操作——创建项目——如何穿过这些边界：
- en: '![Figure 7.4: The entire request/response flow for creating a project](img/B31577_07_04.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：创建项目的整个请求/响应流程](img/B31577_07_04.png)'
- en: 'Figure 7.4: The entire request/response flow for creating a project'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：创建项目的整个请求/响应流程
- en: 'This sequence diagram reveals several important patterns:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列图揭示了几个重要的模式：
- en: The CLI adapter translates user input into properly structured requests
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLI 适配器将用户输入转换为正确结构的请求
- en: These requests flow through our architectural layers via well-defined boundaries
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些请求通过我们定义良好的架构边界流过
- en: Each layer performs its specific responsibilities (validation, business logic,
    etc.)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一层执行其特定的职责（验证、业务逻辑等）
- en: Responses flow back through the layers, being transformed appropriately for
    display
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应通过层流回，并适当地转换为显示
- en: With this understanding of how data flows through our architectural boundaries,
    let’s examine how we organize the components that implement this flow.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解数据如何通过我们的架构边界流动，让我们检查我们如何组织实现此流程的组件。
- en: Component organization and boundaries
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件组织和边界
- en: As we saw in *Figure 7.2*, our application composition establishes a clear structure
    where each component has specific responsibilities. At the edges of this system,
    framework adapters must handle the transformation of data between external frameworks
    and our Clean Architecture while coordinating user interactions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *图 7.2* 中看到的，我们的应用程序组合建立了一个清晰的架构，其中每个组件都有特定的职责。在这个系统的边缘，框架适配器必须处理外部框架和我们的清洁架构之间的数据转换，同时协调用户交互。
- en: Looking at *Figure 7.4*, we can see that our CLI adapter sits at a crucial architectural
    boundary. We’ve chosen **Click**, a popular Python framework for building command-line
    interfaces, for our CLI implementation. The adapter must translate between Click’s
    framework-specific patterns and our application’s clean interfaces, managing both
    user input and the display of results.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *图 7.4*，我们可以看到我们的 CLI 适配器位于一个关键架构边界上。我们选择了 **Click**，这是一个流行的 Python 框架，用于构建命令行界面，用于我们的
    CLI 实现。适配器必须在 Click 的框架特定模式和我们的应用程序的清洁接口之间进行转换，同时管理用户输入和结果的显示。
- en: 'Let’s examine the core adapter structure:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查核心适配器结构：
- en: '[PRE2]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This high-level structure demonstrates several key Clean Architecture principles:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高级结构展示了几个关键的清洁架构原则：
- en: '**Dependency injection:**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入：**'
- en: The adapter receives its Application instance through constructor injection
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器通过构造函数注入接收其应用实例
- en: This maintains the Dependency Rule by keeping the adapter dependent on inner
    layers
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这通过保持适配器对内部层的依赖来维护依赖规则
- en: No direct instantiation of application components occurs in the adapter
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器中不直接实例化应用程序组件
- en: '**Framework isolation:**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架隔离：**'
- en: Click-specific code remains contained within the adapter
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Click 特定的代码保留在适配器内
- en: The Application instance provides a clean interface to our core business logic
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用实例为我们提供了核心业务逻辑的清洁接口
- en: Framework concerns like user interaction and display caching stay at the edge
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架相关的问题，如用户交互和显示缓存，保持在边缘
- en: 'Let’s examine a handler method of `ClickCli` to see how these components work
    together to create the interface shown in *Figure 7.3*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `ClickCli` 的一个处理器方法，看看这些组件是如何一起工作以创建 *图 7.3* 中显示的界面：
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `task` menu handler shows our architectural boundaries at work:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`task` 菜单处理器显示了我们的架构边界在工作：'
- en: Business operations flow through controllers as shown in *Figure 7.4*
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务操作如图 7.4 所示通过控制器流过
- en: The Application instance shields our adapter from core business logic details
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用实例屏蔽了适配器对核心业务逻辑细节的了解
- en: Framework-specific code (Click commands) stays at the edges
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架特定的代码（Click 命令）保持在边缘
- en: Error handling maintains clean separation between layers
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理保持了层之间的清洁分离
- en: Through this implementation style we maintain clear boundaries while delivering
    a practical user interface. This foundation enables us to implement specific functionality
    that handles both user interaction and business operations cleanly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种实现风格，我们在提供实用的用户界面的同时保持清晰的边界。这个基础使我们能够干净地实现处理用户交互和业务操作的具体功能。
- en: Now let’s explore how the adapter processes specific user commands and interactions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索适配器如何处理特定的用户命令和交互。
- en: Implementing user interactions
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现用户交互
- en: As we build out the CLI, we need to translate user actions into business operations
    while maintaining clean architectural boundaries. This includes handling command
    input, displaying results, and managing the user’s navigation through the system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建CLI时，我们需要将用户操作转换为业务操作，同时保持干净的架构边界。这包括处理命令输入、显示结果和管理用户在系统中的导航。
- en: 'Let’s examine how the `ClickCli` adapter class handles a typical interaction
    flow:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察`ClickCli`适配器类如何处理典型的交互流程：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `selection` handler demonstrates several key patterns for managing user
    interaction while respecting clean architectural boundaries:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`selection`处理程序展示了在尊重干净架构边界的同时管理用户交互的几个关键模式：
- en: '**Input parsing:**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入解析：**'
- en: Validates and normalizes user input before processing
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理之前验证和标准化用户输入
- en: Provides clear feedback for invalid selections
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为无效选择提供清晰的反馈
- en: Keeps input handling concerns at the framework boundary
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入处理关注点保持在框架边界
- en: '**Command routing:**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令路由：**'
- en: Maps user selections to appropriate handler methods
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户选择映射到适当的处理方法
- en: Maintains clean separation between input handling and business logic
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入处理和业务逻辑之间保持干净的分离
- en: Uses consistent patterns for different types of selection
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一致的模式处理不同类型的选择
- en: 'If we follow the `_create_new_project` handle, we see interaction with the
    Application layer:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们跟随`_create_new_project`处理程序，我们看到与应用层之间的交互：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This implementation shows the clean transformation between the Framework and
    Drivers, and Application layers:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现展示了框架和驱动器、应用层之间的干净转换：
- en: Framework-specific input gathering using Click’s prompt
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Click的提示进行框架特定的输入收集
- en: Direct delegation to application controllers for business operations
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接将业务操作委托给应用程序控制器
- en: Clean error handling that respects architectural boundaries
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尊重架构边界的干净错误处理
- en: This careful attention to architectural boundaries helps us maintain a clean
    separation between our user interface and business logic while still delivering
    a cohesive user experience. Whether handling input or displaying output, each
    component maintains its specific responsibilities within Clean Architecture’s
    concentric layering.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对架构边界的细致关注帮助我们保持用户界面和业务逻辑之间的清晰分离，同时仍然提供一致的用户体验。无论是处理输入还是显示输出，每个组件都在Clean Architecture的同心层中保持其特定的职责。
- en: Domain insights through implementation
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过实现获得领域洞察
- en: As we implement the CLI interface, we begin to discover insights about our domain
    model through actual user interaction patterns. Initially, our domain model treated
    project assignment as optional for tasks, providing flexibility in how users could
    organize their work. However, as we implemented the user interface, this flexibility
    revealed itself as a source of friction.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现CLI界面时，我们开始通过实际的用户交互模式发现关于我们的领域模型的洞察。最初，我们的领域模型将项目分配视为任务的可选属性，为用户组织工作提供了灵活性。然而，在我们实现了用户界面后，这种灵活性暴露出摩擦的来源。
- en: It should be called out that clean architectural boundaries protect us from
    implementation detail changes rippling through our system, such as swapping databases
    or UI frameworks. However, this discovery represents something different.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出的是，干净的架构边界保护我们免受实现细节变化的影响，这些变化会通过我们的系统传播，例如交换数据库或UI框架。然而，这个发现代表的是不同的事情。
- en: What we’ve uncovered is a fundamental insight about our domain model, requiring
    systematic change through our layers. This demonstrates how Clean Architecture
    guides us in handling both types of change appropriately—isolating technical implementations
    at the edges while providing clear paths for evolving our core domain model when
    needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现的是关于我们的领域模型的基本洞察，需要通过我们的层进行系统性的改变。这展示了Clean Architecture如何引导我们适当地处理这两种类型的改变——在边缘隔离技术实现，同时在需要时提供清晰的核心领域模型演变的路径。
- en: The UI implementation showed that requiring users to choose between working
    with projects or standalone tasks created unnecessary complexity. Users had to
    make explicit decisions about project assignment for every task, and the interface
    needed special handling for both project-associated and independent tasks. This
    added cognitive load for users and implementation complexity for developers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: UI实现表明，要求用户在处理项目或独立任务之间进行选择，造成了不必要的复杂性。用户必须为每个任务明确决定项目分配，界面需要为与项目关联的独立任务进行特殊处理。这增加了用户的认知负担和开发者的实现复杂性。
- en: 'This realization leads us to an important domain insight: tasks inherently
    belong to projects in our users’ mental model. Rather than treating project assignment
    as optional, we can simplify both our domain model and user interface by ensuring
    all tasks belong to a project, with an *Inbox* project serving as the default
    container for tasks that haven’t been explicitly organized.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这一认识使我们得出一个重要的领域洞察：在我们的用户心智模型中，任务本质上属于项目。与其将项目分配视为可选的，我们通过确保所有任务都属于一个项目，以一个*邮箱*项目作为默认容器来组织未明确组织的任务，可以简化我们的领域模型和用户界面。
- en: The development of user interfaces often serves as a crucial testing ground
    for our domain model, surfacing insights that might not be obvious during initial
    design.  Let’s take this opportunity to demonstrate how our clean architectural
    boundaries ensure we can implement these discoveries systematically while maintaining
    separation between framework concerns and core business logic.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面的开发通常是我们领域模型的关键测试场，揭示了在初始设计期间可能不明显的信息。让我们借此机会展示我们的清洁架构边界如何确保我们能够系统地实施这些发现，同时保持框架关注点与核心业务逻辑之间的分离。
- en: 'Implementing domain insights: the task–project relationship'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施领域洞察：任务-项目关系
- en: 'Let’s examine the key code changes needed to reflect our refined understanding
    that tasks naturally belong to projects in our domain. We’ll implement this insight
    starting from the Domain layer and working outward, using an *Inbox* project as
    a practical mechanism to support this natural organization:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查反映我们在领域中对任务自然属于项目的理解所需的关键代码更改。我们将从领域层开始实施这一洞察，向外扩展，使用一个*邮箱*项目作为支持这种自然组织的实用机制：
- en: '[PRE6]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These Domain layer changes establish the foundation of our Inbox pattern. By
    introducing `ProjectType` and updating our entities, we enforce the business rule
    that all tasks must belong to a project, while the `create_inbox` factory method
    ensures consistent Inbox project creation. Note that the `Task` entity now requires
    a `project_id`, reflecting our refined domain model.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些领域层的变化为我们邮箱模式奠定了基础。通过引入`ProjectType`并更新我们的实体，我们强制执行了业务规则，即所有任务都必须属于一个项目，而`create_inbox`工厂方法确保了邮箱项目的创建一致性。请注意，`Task`实体现在需要一个`project_id`，这反映了我们精炼的领域模型。
- en: 'The changes then flow through to our Application layer:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这些变化会传递到我们的应用层：
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Application layer changes demonstrate how Clean Architecture handles cross-layer
    requirements. The `ProjectRepository` interface gains Inbox-specific capabilities
    while the `CreateTaskUseCase` enforces our new business rule by automatically
    assigning tasks to the inbox project when no explicit project is specified. This
    keeps our business rules centralized and consistent. Additionally, the `ProjectResponse`
    model will have the `project_type` field added and the `TaskResponse` model will
    make the `project_id` field required.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层的变化展示了Clean Architecture如何处理跨层需求。`ProjectRepository`接口获得了邮箱特定的功能，而`CreateTaskUseCase`通过在未指定明确项目时自动将任务分配给邮箱项目来强制执行我们新的业务规则。这保持了我们的业务规则集中和一致。此外，`ProjectResponse`模型将添加`project_type`字段，而`TaskResponse`模型将使`project_id`字段成为必需。
- en: 'As a result of these changes our framework adapter simplifies:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些变化，我们的框架适配器简化了：
- en: '[PRE8]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Rather than managing complex conditional logic for tasks with and without projects,
    the adapter focuses purely on user interaction. The business rule of ensuring
    task–project association is handled by the use case, demonstrating how Clean Architecture’s
    separation of concerns can lead to simpler, more focused components. View models
    likewise simplify, no longer needing to handle cases of tasks without projects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，适配器专注于用户交互，而不是管理带有或没有项目的任务的复杂条件逻辑。确保任务-项目关联的业务规则由用例处理，展示了Clean Architecture如何通过关注点的分离导致更简单、更专注的组件。视图模型同样简化，不再需要处理没有项目的任务的情况。
- en: 'This implementation demonstrates Clean Architecture’s systematic approach to
    change:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现展示了Clean Architecture对变化的系统化方法：
- en: Domain changes establish new invariant business rules
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域变化建立新的不变业务规则
- en: Application layer adapts to enforce these rules
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序层适应以强制执行这些规则
- en: Framework adapters simplify to reflect the cleaner model
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架适配器简化为反映更清晰的模型
- en: Each layer maintains its specific responsibilities
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一层保持其特定的责任
- en: By following Clean Architecture’s boundaries, we implement our domain insight
    while maintaining separation of concerns and improving both user experience and
    code organization. In a less structured codebase, where business rules might be
    scattered across UI components and data access code, such a fundamental change
    would require hunting through multiple components to ensure consistent behavior.
    Clean Architecture’s clear boundaries help us avoid these refactoring challenges.
    As we’ll see in the next section, these same principles guide our implementation
    of database adapters, another crucial component of our Frameworks and Drivers
    layer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循Clean Architecture的边界，我们在保持关注点分离的同时，实现了我们的领域洞察，并提高了用户体验和代码组织。在一个结构较松散的代码库中，业务规则可能散布在UI组件和数据访问代码中，这样的基本变化可能需要搜索多个组件以确保行为一致。Clean
    Architecture的清晰边界帮助我们避免这些重构挑战。正如我们将在下一节中看到的，这些相同的原理指导我们的数据库适配器实现，这是我们的框架和驱动器层中的另一个关键组件。
- en: Implementing database adapters
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据库适配器
- en: The implementation of database adapters in Clean Architecture provides a clear
    example of how driver integration differs from framework integration. As discussed
    earlier, drivers require simpler adaptation patterns than frameworks, typically
    needing only an interface in the Application layer and a concrete implementation
    in this outer layer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clean Architecture中实现数据库适配器提供了一个清晰的例子，说明了驱动器集成与框架集成之间的差异。如前所述，驱动器需要比框架更简单的适配模式，通常只需要在应用程序层中有一个接口，在这个最外层有一个具体实现。
- en: Repository interface implementation
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储库接口实现
- en: 'Recall from [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123) that our Application
    layer defines repository interfaces which establish clear contracts for any concrete
    implementation. These interfaces ensure our core business logic remains independent
    of storage details:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[*第五章*](Chapter_05.xhtml#_idTextAnchor123)，我们的应用程序层定义了存储库接口，这些接口为任何具体实现建立了明确的合同。这些接口确保我们的核心业务逻辑保持独立于存储细节：
- en: '[PRE9]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s implement this interface with an in-memory repository. While storing data
    in memory might seem impractical for a production system, this implementation
    offers several advantages. Most notably, it provides a lightweight, fast implementation
    ideal for testing—a benefit we’ll explore more fully in [*Chapter 8*](Chapter_08.xhtml#_idTextAnchor192)
    when we discuss Clean Architecture’s testing patterns.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个内存存储库来实现这个接口。虽然将数据存储在内存中对于生产系统来说可能看起来不切实际，但这种实现提供了几个优点。最值得注意的是，它提供了一个轻量级、快速的实现，非常适合测试——我们将在[*第八章*](Chapter_08.xhtml#_idTextAnchor192)中更全面地探讨这一点，当我们讨论Clean
    Architecture的测试模式时。
- en: '[PRE10]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This implementation demonstrates several key Clean Architecture principles.
    Note how it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现展示了几个关键的Clean Architecture原则。注意它：
- en: Implements the interface defined by our Application layer
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现由我们的应用程序层定义的接口
- en: Maintains clean separation between storage and business logic
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持存储和业务逻辑之间的清晰分离
- en: Handles domain-specific errors (`TaskNotFoundError`)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理特定领域的错误（`TaskNotFoundError`）
- en: Keeps implementation details (the dictionary storage) completely hidden from
    clients
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全隐藏实现细节（字典存储）供客户端使用
- en: While simple, this pattern provides the foundation for all our repository implementations.
    Whether storing data in memory, files, or a database, the core interaction patterns
    remain consistent thanks to our clean architectural boundaries.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单，但这种模式为我们所有存储库实现提供了基础。无论是在内存中存储数据、文件还是数据库，由于我们清晰的架构边界，核心交互模式始终保持一致。
- en: 'For example, here’s how we might implement file-based storage:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是如何实现基于文件的存储：
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This implementation demonstrates the power of Clean Architecture’s interface-based
    approach:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现展示了Clean Architecture基于接口方法的强大之处：
- en: The same interface accommodates very different storage strategies
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的接口适应了非常不同的存储策略
- en: Core business logic remains completely unaware of storage details
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心业务逻辑完全不了解存储细节
- en: Implementation complexity (like JSON serialization) stays isolated in the outer
    layer
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现复杂性（如JSON序列化）保持在最外层隔离
- en: Error handling remains consistent across implementations
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理在所有实现中保持一致
- en: 'Our domain code can work with either implementation transparently:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域代码可以透明地与任何实现一起工作：
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This flexibility extends beyond just these two implementations. Whether we later
    add SQLite, PostgreSQL, or cloud storage, our clean interfaces ensure that core
    business logic never changes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性不仅限于这两种实现。无论我们后来添加SQLite、PostgreSQL还是云存储，我们干净的接口都能确保核心业务逻辑不会改变。
- en: Managing repository instantiation
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理存储库实例化
- en: 'As shown in *Figure 7.2*, configuration management plays a key role in our
    application composition. One of its primary responsibilities is directing the
    selection and creation of appropriate repository implementations. Our `Config`
    class provides a clean way to manage these decisions:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.2*所示，配置管理在我们的应用程序组合中扮演着关键角色。其主要职责之一是指导选择和创建适当的存储库实现。我们的`Config`类提供了一种管理这些决策的干净方式：
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now utilize this configuration capability within the implementation of a
    factory that handles the actual instantiation of our repositories. This **factory
    pattern**, which we saw referenced in our application composition discussion,
    provides a clean way to create properly configured repository instances:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在处理实际实例化我们存储库的工厂实现中利用这种配置能力。这种我们在应用程序组合讨论中看到的**工厂模式**，提供了一种创建正确配置的存储库实例的干净方式：
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This factory demonstrates several key Clean Architecture patterns in action.
    Configuration drives implementation choice through `Config.get_repository_type()`,
    while creation complexity is encapsulated in type-specific initialization blocks.
    Note how `project_repo.set_task_repository(task_repo)` handles dependency injection
    consistently across implementations. The factory returns abstract repository interfaces,
    keeping implementation details hidden from clients. These patterns come together
    to create a robust system for managing repository lifecycles while maintaining
    clean architectural boundaries.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工厂展示了几个关键的清洁架构模式在实际操作中的运用。配置通过`Config.get_repository_type()`驱动实现选择，而创建复杂性被封装在特定类型的初始化块中。注意`project_repo.set_task_repository(task_repo)`如何一致地处理实现中的依赖注入。工厂返回抽象存储库接口，将实现细节隐藏于客户端。这些模式结合在一起，创建了一个强大的系统来管理存储库的生命周期，同时保持清晰的架构边界。
- en: With our repository creation patterns established, let’s examine how these components
    orchestrate across our architectural boundaries to form a complete system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们建立了存储库创建模式之后，让我们来审视这些组件如何在我们架构边界之间进行编排，形成一个完整的系统。
- en: Component orchestration overview
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件编排概述
- en: We’ve covered configuration classes, factory patterns, and composition principles—all
    working together to manage repository creation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了配置类、工厂模式和组合原则——所有这些共同工作来管理存储库的创建。
- en: 'Let’s step back and examine the complete picture. *Figure 7.5* focuses on our
    architectural overview from *Figure 7.2*, showing in detail how configuration
    and composition root components interact across our architectural boundaries:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退后一步，审视整个画面。*图7.5*关注于我们从*图7.2*中看到的架构概述，详细展示了配置和组合根组件如何跨越我们的架构边界进行交互：
- en: '![Figure 7.5: Component interactions between Frameworks and Drivers layer and
    the Interface Adapters layer](img/B31577_07_05.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：框架和驱动层与接口适配层之间的组件交互](img/B31577_07_05.png)'
- en: 'Figure 7.5: Component interactions between Frameworks and Drivers layer and
    the Interface Adapters layer'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：框架和驱动层与接口适配层之间的组件交互
- en: 'As shown in *Figure 7.5*, our composition flow starts with `main.py`, which
    initiates the application creation process. The `create_application` function
    serves as our primary factory, coordinating with configuration management and
    component factories to assemble a fully configured `Application` class instance.
    Each component maintains clean boundaries while working together to create a cohesive
    system:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.5*所示，我们的组合流程从`main.py`开始，它启动应用程序创建过程。`create_application`函数作为我们的主要工厂，与配置管理和组件工厂协调，组装一个完全配置的`Application`类实例。每个组件在协同创建一个统一系统的同时，保持清晰的边界：
- en: '`Config` provides environment-aware settings that drive implementation choices'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Config`提供环境感知的设置，驱动实现选择'
- en: Component factory methods (`create_repositories`) handle the complexities of
    ports instantiation and relationships
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件工厂方法（`create_repositories`）处理端口实例化和关系的复杂性
- en: '`create_application` orchestrates the overall component assembly'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_application` 协调整体组件组装'
- en: '`Application` lives in our Frameworks and Drivers layer, coordinating with
    controllers in the Interface Adapters layer to provide framework adapters with
    access to our core business logic'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application`位于我们的框架和驱动层，与接口适配器层的控制器协调，为框架适配器提供访问核心业务逻辑的权限'
- en: This careful orchestration demonstrates Clean Architecture’s power in managing
    complex system composition. While each component has clear, focused responsibilities,
    they work together to create a flexible, maintainable system that respects architectural
    boundaries. In the next section, we’ll examine external service integration, taking
    a closer look at how the `Application` class and `main.py` bring these components
    together at runtime.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种谨慎的编排展示了Clean Architecture在管理复杂系统组成方面的力量。虽然每个组件都有明确、集中的职责，但它们共同工作，创建一个灵活、可维护的系统，同时尊重架构边界。在下一节中，我们将检查外部服务集成，更详细地了解`Application`类和`main.py`如何在运行时将这些组件组合在一起。
- en: Integrating external services
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成外部服务
- en: While databases store our application state, external services enable our application
    to interact with the wider world by sending notifications, processing payments,
    or integrating with third-party APIs. Like databases, these services represent
    essential but volatile dependencies that must be managed carefully to maintain
    clean architectural boundaries.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据库存储我们的应用程序状态，但外部服务通过发送通知、处理支付或集成第三方API，使我们的应用程序能够与更广泛的世界交互。像数据库一样，这些服务代表必要但易变的依赖关系，必须谨慎管理以保持干净的架构边界。
- en: External services in Clean Architecture
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clean Architecture中的外部服务
- en: 'Recall from [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123) that our Application
    layer defines ports which are interfaces that specify how our core application
    interacts with external services. The `NotificationPort` interface exemplifies
    this approach:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[*第5章*](Chapter_05.xhtml#_idTextAnchor123)，我们的应用层定义了端口，这些端口指定了我们的核心应用如何与外部服务交互。`NotificationPort`接口展示了这种方法：
- en: '[PRE15]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This interface, defined in our Application layer, demonstrates several key
    Clean Architecture principles:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口，定义在我们的应用层，展示了几个关键的Clean Architecture原则：
- en: The core application specifies exactly what notification capabilities it needs
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心应用指定了它需要的确切通知能力
- en: No implementation details leak into the interface
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有实现细节泄漏到接口中
- en: The interface focuses purely on business operations
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口纯粹关注业务操作
- en: Error handling remains abstract at this level
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理在此级别保持抽象
- en: 'Let’s examine how a task completion notification flows through our architectural
    boundaries:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看任务完成通知是如何穿过我们的架构边界的：
- en: '![Figure 7.6: Notification flow through architectural layers](img/B31577_07_06.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：通过架构层的通知流程](img/B31577_07_06.png)'
- en: 'Figure 7.6: Notification flow through architectural layers'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：通过架构层的通知流程
- en: 'This sequence demonstrates Clean Architecture’s careful management of dependencies:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此序列展示了Clean Architecture对依赖关系的谨慎管理：
- en: The use case knows only about the abstract `NotificationPort`
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例只知道抽象的`NotificationPort`
- en: The concrete SendGrid implementation lives at our system’s edge
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体的SendGrid实现位于我们系统的边缘
- en: Business logic remains completely unaware of email implementation details
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑完全不了解电子邮件实现细节
- en: Specific service integration (SendGrid) happens cleanly at architectural boundaries
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定服务集成（SendGrid）在架构边界处干净利落地发生
- en: SendGrid integration
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SendGrid集成
- en: 'With our notification port interface defined, let’s implement email notifications
    using **SendGrid**—a cloud-based email service that provides APIs for sending
    transactional emails. By implementing our notification port with SendGrid, we’ll
    demonstrate how Clean Architecture helps us integrate with third-party services
    while maintaining clean architectural boundaries:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的通知端口接口后，让我们使用**SendGrid**实现电子邮件通知——这是一个基于云的电子邮件服务，提供发送交易性电子邮件的API。通过使用SendGrid实现我们的通知端口，我们将展示Clean
    Architecture如何帮助我们集成第三方服务，同时保持干净的架构边界：
- en: '[PRE16]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our SendGrid implementation, like our repository implementations earlier, relies
    on configuration management to handle service-specific settings. Building on the
    patterns established in our repository configuration, our `Config` class grows
    to support notification settings:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的SendGrid实现，就像我们之前的存储库实现一样，依赖于配置管理来处理特定服务的设置。基于我们在存储库配置中建立的模式，我们的`Config`类扩展以支持通知设置：
- en: '[PRE17]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s see how this fits into our task completion workflow. Recall from [*Chapter
    5*](Chapter_05.xhtml#_idTextAnchor123) our `CompleteTaskUseCase` that coordinates
    task completion with notifications:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何适应我们的任务完成工作流程。回想一下[*第五章*](Chapter_05.xhtml#_idTextAnchor123)中的`CompleteTaskUseCase`，它协调任务完成与通知：
- en: '[PRE18]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By implementing the `NotificationPort` with SendGrid, we demonstrate a key
    benefit of clean architectural boundaries: adding email notifications requires
    changes only at the system’s edge. Since our Application layer defined the `NotificationPort`
    interface, and our use cases depend only on this abstraction, implementing SendGrid
    notifications requires no changes to our core business logic. Only the `SendGridNotifier`
    implementation and its associated composition root wiring need to be added. This
    illustrates how Clean Architecture enables us to integrate powerful external services
    while keeping our core application completely unchanged.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用SendGrid实现`NotificationPort`，我们展示了清晰架构边界的关键好处：添加电子邮件通知只需在系统的边缘进行更改。由于我们的应用程序层定义了`NotificationPort`接口，并且我们的用例只依赖于这个抽象，实现SendGrid通知不需要更改我们的核心业务逻辑。只需添加`SendGridNotifier`实现及其相关的组合根连接即可。这说明了清晰架构如何使我们能够集成强大的外部服务，同时保持我们的核心应用程序完全不变。
- en: Application bootstrapping
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序引导
- en: As we saw in our discussion of component orchestration, the composition root
    brings together all our Frameworks and Drivers layer components while maintaining
    clean architectural boundaries. Let’s further examine the implementation of this
    composition, starting with our `Application`  container class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在组件编排讨论中看到的，组合根汇集了我们所有的框架和驱动层组件，同时保持了清晰的架构边界。让我们进一步检查这种组合的实现，从我们的`Application`容器类开始。
- en: 'The `Application` container class holds all the required application components
    as fields:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`容器类持有所有必需的应用程序组件作为字段：'
- en: '[PRE19]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then in our implementation we utilize the `__post_init__` method to construct
    these components:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的实现中，我们利用`__post_init__`方法构建这些组件：
- en: '[PRE20]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The Application class provides the structure for our component relationships,
    but we still need a way to create properly configured instances to inject into
    the `Application` container class. This is handled by our `create_application`
    factory method:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`类为我们组件之间的关系提供了结构，但我们仍然需要一个方法来创建正确配置的实例以注入到`Application`容器类中。这由我们的`create_application`工厂方法处理：'
- en: '[PRE21]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This factory function demonstrates Clean Architecture’s dependency management
    in action:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工厂函数展示了清晰架构的依赖管理在实际中的应用：
- en: Method parameters (`notification_service`, `task_presenter`, `project_presenter`)
    accept abstract interfaces rather than concrete implementations
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数（`notification_service`、`task_presenter`、`project_presenter`）接受抽象接口而不是具体实现
- en: 'The port components are created through factories: `create_repositories`  and
    `create_notification_service` methods'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口组件是通过工厂方法创建的：`create_repositories`和`create_notification_service`方法
- en: All these components come together in the final `Application` class instantiation,
    where each dependency is properly configured and injected
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些组件都在最终的`Application`类实例化过程中汇集在一起，其中每个依赖项都得到了适当的配置和注入
- en: The separation between the `create_application` factory method and the `Application`
    class demonstrates Clean Architecture’s attention to separation of concerns. The
    container focuses on component relationships while the factory handles creation
    details.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_application`工厂方法和`Application`类之间的分离展示了清晰架构对关注点分离的重视。容器专注于组件关系，而工厂处理创建细节。'
- en: 'Finally, our `main.py` script serves as the tip of our composition root which
    is the single place where all components are instantiated and wired together at
    application startup:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`main.py`脚本作为我们的组合根的顶端，这是所有组件在应用程序启动时实例化和连接在一起的唯一位置：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This bootstrap process demonstrates how Clean Architecture brings together
    all the components we’ve explored throughout this chapter. Notice how the `create_application`
    call assembles our core components, while `ClickCli(app)` initializes our framework
    adapter. This separation is significant: we could replace this CLI-specific main
    with a web application entry point that uses the same `create_application` factory
    but initializes a different framework adapter like FastAPI or Flask instead of
    a Click CLI.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个引导过程展示了如何通过Clean Architecture将本章中我们探索的所有组件整合在一起。注意`create_application`调用如何组装我们的核心组件，而`ClickCli(app)`初始化我们的框架适配器。这种分离是重要的：我们可以用使用相同`create_application`工厂但初始化不同框架适配器（如FastAPI或Flask）而不是Click
    CLI的Web应用程序入口点来替换这个特定于CLI的主程序。
- en: 'The error-handling strategy is also worth noting. The top-level `try`/`except`
    blocks manage both graceful shutdown (`KeyboardInterrupt`) and unexpected errors
    at the system boundary, providing a clean exit strategy through the return codes.
    Throughout this composition, clean architectural boundaries remain intact: the
    business logic assembled by `create_application` knows nothing about our CLI implementation,
    and the `ClickCli` adapter interacts only with the abstractions provided by our
    `Application` container.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理策略也值得注意。顶级`try`/`except`块管理系统边界的优雅关闭（`KeyboardInterrupt`）和意外错误，通过返回码提供了一种干净的退出策略。在整个创作过程中，清晰的架构边界保持完好：由`create_application`组装的业务逻辑对我们的CLI实现一无所知，而`ClickCli`适配器仅与我们的`Application`容器提供的抽象进行交互。
- en: The composition patterns we established with repositories extend naturally to
    all our Frameworks and Drivers layer components, creating a cohesive system that
    respects clean architectural boundaries while delivering practical functionality.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与存储库一起建立的组合模式自然扩展到所有我们的框架和驱动器层组件，创建了一个尊重清晰架构边界的统一系统，同时提供实用的功能。
- en: 'Let’s close the section by acknowledging the end result: a functional CLI that
    brings together all the components we’ve explored throughout this chapter.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过承认最终结果来结束本节：一个集成了本章中我们探索的所有组件的功能性CLI。
- en: '![Figure 7.7: The starting CLI for the task management app](img/B31577_07_07.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：任务管理应用程序的起始CLI](img/B31577_07_07.png)'
- en: 'Figure 7.7: The starting CLI for the task management app'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：任务管理应用程序的起始CLI
- en: As shown in *Fi**gure 7.7*, our Clean Architecture implementation enables users
    to manage projects and tasks through an intuitive interface, with the inbox project
    demonstrating how our architectural choices support natural workflow patterns.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.7*所示，我们的Clean Architecture实现使用户能够通过直观的界面管理项目和任务，收件箱项目展示了我们的架构选择如何支持自然的工作流程模式。
- en: The UI’s ability to display projects, tasks, their statuses, and priorities
    while handling user interactions seamlessly demonstrates how Clean Architecture
    enables us to create practical, user-friendly applications without compromising
    architectural integrity. Each piece of information displayed, from project names
    to task priorities, flows through our carefully defined architectural boundaries,
    proving that Clean Architecture’s principles translate into real-world functionality.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: UI能够无缝地显示项目、任务、其状态和优先级，同时处理用户交互，这展示了Clean Architecture如何使我们能够创建实用、用户友好的应用程序，同时不牺牲架构完整性。从项目名称到任务优先级，每条显示的信息都通过我们精心定义的架构边界流动，证明了Clean
    Architecture的原则可以转化为现实世界的功能。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the Frameworks and Drivers layer of Clean Architecture,
    demonstrating how to integrate external concerns while maintaining clean architectural
    boundaries. Through our task management system implementation, we saw how to effectively
    manage frameworks, databases, and external services while keeping our core business
    logic pristine and protected.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Clean Architecture的框架和驱动器层，展示了如何在保持清晰架构边界的同时整合外部关注点。通过我们的任务管理系统实现，我们看到了如何有效地管理框架、数据库和外部服务，同时保持我们的核心业务逻辑纯净和安全。
- en: 'We implemented several key patterns that showcase Clean Architecture’s practical
    benefits:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了几个关键模式，展示了Clean Architecture的实用好处：
- en: Framework adapters that cleanly separate UI concerns from business logic
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰地将UI关注点与业务逻辑分离的框架适配器
- en: Database implementations demonstrating interface flexibility
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示接口灵活性的数据库实现
- en: External service integration maintaining core independence
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持核心独立性的外部服务集成
- en: Configuration management that evolves with our system’s needs
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着系统需求演变的配置管理
- en: 'These implementations demonstrated Clean Architecture’s dual strengths: isolating
    implementation details at the edges while providing clear paths for domain model
    evolution. We saw this in action twice. First, when implementing external services
    like SendGrid without touching our core business logic. Second, when evolving
    our domain model’s task–project relationship, which required systematic change
    across layers. From repositories to framework adapters, careful attention to architectural
    boundaries helped us create a maintainable system that can adapt to both types
    of change.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现展示了清洁架构的双重优势：在边缘隔离实现细节，同时为领域模型演进提供清晰的路径。我们两次看到了这一点。首先，在实现像SendGrid这样的外部服务时，我们没有触及我们的核心业务逻辑。其次，在演进我们的领域模型的任务-项目关系时，这需要在各个层级上进行系统性的变更。从存储库到框架适配器，对架构边界的细致关注帮助我们创建了一个可维护的系统，该系统可以适应这两种类型的变更。
- en: In [*Chapter 8*](Chapter_08.xhtml#_idTextAnchor192) we’ll explore how these
    clean boundaries enable comprehensive testing strategies across all layers of
    our system.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](Chapter_08.xhtml#_idTextAnchor192)中，我们将探讨这些清晰的边界如何使我们的系统所有层级的全面测试策略成为可能。
- en: Further reading
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Dependency Injector—Dependency Injection Framework for Python* ([https://python-dependency-injector.ets-labs.org/](https://python-dependency-injector.ets-labs.org/)).
    For more complex projects, you can consider a dependency injection framework to
    manage what we’ve done here with the `Application` class.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*依赖注入器——Python的依赖注入框架* ([https://python-dependency-injector.ets-labs.org/](https://python-dependency-injector.ets-labs.org/))。对于更复杂的项目，你可以考虑使用依赖注入框架来管理我们在`Application`类中完成的工作。'
