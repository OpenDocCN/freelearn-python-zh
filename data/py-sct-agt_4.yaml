- en: Chapter 4. Drops, Hideouts, Meetups, and Lairs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 降落点、藏身之处、会面和巢穴
- en: We'll extend some of the techniques introduced in [Chapter 2](ch02.html "Chapter 2. Acquiring
    Intelligence Data"), *Acquiring Intelligence Data*, to make RESTful web service
    requests for geocoding. This will allow us to pinpoint various kinds of secret
    locations. This will also build on image location processing from [Chapter 3](ch03.html
    "Chapter 3. Encoding Secret Messages with Steganography"), *Encoding Secret Messages
    with Steganography*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展在[第二章](ch02.html "第二章. 获取情报数据")中介绍的一些技术，*获取情报数据*，用于进行RESTful网络服务请求进行地理编码。这将使我们能够精确地定位各种秘密地点。这还将基于[第三章](ch03.html
    "第三章. 使用隐写术编码秘密信息")中的图像位置处理，*使用隐写术编码秘密信息*。
- en: We will look at some online datasets that will lead us to more techniques in
    data gathering. In order to work with a wide variety of data, we will need to
    add an HTML parser to our toolkit. We'll download BeautifulSoup, since it's very
    good at tracking down the information buried in HTML pages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一些在线数据集，这将引导我们了解更多数据收集技术。为了处理各种类型的数据，我们需要将HTML解析器添加到我们的工具包中。我们将下载BeautifulSoup，因为它非常擅长追踪HTML页面中隐藏的信息。
- en: In this chapter, we'll also look at some more sophisticated Python algorithms.
    We'll start with geocoding services to translate address and latitude-longitude
    coordinates.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将探讨一些更复杂的Python算法。我们将从地理编码服务开始，这些服务可以将地址和经纬度坐标进行转换。
- en: We'll look at the **haversine** formula to compute distances between locations.
    This will mean using the `math` library to access trigonometric functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究**哈弗辛公式**来计算地点之间的距离。这意味着使用`math`库来访问三角函数。
- en: We'll learn about the various kinds of grid coding schemes, which will help
    us reduce the complexity of latitude and longitude. These coding schemes will
    show us a number of data representation techniques. This chapter will show ways
    to compress numbers via a change in representation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解各种类型的网格编码方案，这将帮助我们简化纬度和经度的复杂性。这些编码方案将向我们展示多种数据表示技术。本章将展示通过改变表示来压缩数字的方法。
- en: We'll see ways to parse HTML `<table>` tags and create Python collections that
    we can work with. We'll also look at online data sources that provide clean data
    in the JSON format. This can be easier to gather and work with.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何解析HTML `<table>` 标签，并创建我们可以与之工作的Python集合。我们还将查看提供干净JSON格式数据的在线数据源。这可以更容易地收集和处理。
- en: Our goal is to use Python to combine multiple online services. This will allow
    us to integrate geocoding and data analysis. With that information, we can locate
    the best place to meet our contacts without traveling too far from our secret
    base of operations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是使用Python结合多个在线服务。这将使我们能够集成地理编码和数据分析。有了这些信息，我们可以在不远离我们的秘密行动基地的情况下找到与我们的联系人会面的最佳地点。
- en: Background briefing – latitude, longitude, and GPS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景简报 – 纬度、经度和GPS
- en: Before we can get geographic information, we'll need to review some essential
    terminology. One powerful piece of modern technology that helps civilians as well
    as secret agents is the **Global Positioning System** (**GPS**), a satellite-based
    system to determine location. The GPS allows a terrestrial device to pinpoint
    its location in both space and time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够获取地理信息之前，我们需要回顾一些基本术语。一项帮助平民和秘密特工的现代技术是**全球定位系统**（**GPS**），这是一个基于卫星的系统，用于确定位置。GPS允许地面设备在空间和时间上精确地确定其位置。
- en: The idea underlying GPS is quite elegant. Each satellite produces a stream of
    data that includes position and super accurate timestamps. A receiver with multiple
    streams of data can plug the positions and timestamps into a matrix of simultaneous
    equations to determine the receiver's position with respect to the various satellites.
    Given enough satellites, a receiver can precisely calculate latitude, longitude,
    elevation, and even the current time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GPS背后的理念非常优雅。每个卫星产生一个包含位置和超级精确时间戳的数据流。具有多个数据流的接收器可以将位置和时间戳插入到一个矩阵中，以确定接收器相对于各个卫星的位置。如果有足够的卫星，接收器可以精确地计算出纬度、经度、海拔高度，甚至当前时间。
- en: For more information see [http://en.wikipedia.org/wiki/Global_Positioning_System#Navigation_equations](http://en.wikipedia.org/wiki/Global_Positioning_System#Navigation_equations).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅[http://en.wikipedia.org/wiki/Global_Positioning_System#Navigation_equations](http://en.wikipedia.org/wiki/Global_Positioning_System#Navigation_equations)。
- en: 'A position''s latitude is an angle measured relative to the equator and poles.
    We must provide the direction for this angle: N or S for latitude. For example,
    36°50′40.12″N is given in degrees (°), minutes (′), and seconds (″) with the all-important
    N to show which side of the equator the position is on.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 位置纬度是相对于赤道和极地的角度测量。我们必须提供这个角度的方向：纬度的N（北）或S（南）。例如，36°50′40.12″N是以度（°）、分（′）和秒（″）给出的，其中至关重要的N表示位置位于赤道的哪一侧。
- en: We can also state latitude as 36°50.6687′N using degrees and minutes; or, we
    could use 36.844478, known as using decimal degrees. Directions toward the north
    are written in positive angles. Directions to the south are negative. The underlying
    `math` library works in radians, but radians are not widely used to display positions
    to humans.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用度和分来表示纬度，例如36°50.6687′N；或者，我们可以使用36.844478，这被称为使用十进制度数。指向北方的方向用正角度表示。指向南方的方向用负角度表示。底层的`math`库以弧度为单位工作，但弧度并不广泛用于向人类显示位置。
- en: Longitude is an angle east of the **prime meridian** or the **Greenwich meridian**.
    Angles to the west of Greenwich are stated as negative numbers. Consequently,
    76°17′35.21″W can also be stated as -76.293114.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 经度是相对于**本初子午线**或**格林威治子午线**的东向角度。格林威治以西的角度用负数表示。因此，76°17′35.21″W也可以表示为-76.293114。
- en: When we look at a globe, we notice that the latitude lines are all parallel
    with the equator. Each degree of latitude is about 60 nautical miles in the north-south
    direction.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们观察地球仪时，我们会注意到纬线都与赤道平行。每个纬度大约是南北方向60海里。
- en: The longitude lines, however, all intersect at the north and south pole. Those
    north-south lines are not parallel. On a map or a nautical chart, however, a distortion
    (actually known as a **projection**) is used so that the longitude lines are parallel
    to each other. With our usual experience of driving short distances on land, the
    distortion doesn't matter much, since we're often constrained to driving on highways
    that wander around rivers and mountains. What's important is that the rectangular
    grid of a map is handy, but misleading. Simple analytical plane geometry isn't
    appropriate. Hence, we have to switch to spherical geometry.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，经线却在南北极相交。这些南北线并不平行。在地图或海图上，却使用了一种扭曲（实际上称为**投影**），使得经线相互平行。根据我们通常在陆地上驾驶短距离的经验，这种扭曲并不重要，因为我们通常被限制在蜿蜒于河流和山脉之间的公路上驾驶。重要的是，地图的矩形网格很方便，但具有误导性。简单的平面几何分析并不适用。因此，我们必须转向球面几何。
- en: Coping with GPS device limitations
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应对GPS设备限制
- en: A GPS receiver needs to receive data from a number of satellites concurrently;
    a minimum of three satellites can be used for triangulation. There may be interference
    with microwave signals indoors, and even outdoors in urban environments, making
    it difficult (or impossible) to get enough data to properly compute the receiver's
    location. Tall buildings and other obstructions such as walls, prevent the direct
    signal access needed for accuracy. It may take a long time to acquire enough high-quality
    satellite signals to compute a position.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: GPS接收器需要同时接收来自多个卫星的数据；至少可以使用三个卫星进行三角测量。室内可能有微波信号的干扰，甚至在城市环境中，也可能难以（或不可能）获得足够的数据来正确计算接收器的位置。高楼大厦和其他障碍物，如墙壁，阻止了直接信号访问，这对于准确性是必要的。可能需要很长时间才能获得足够的高质量卫星信号来计算位置。
- en: A common workaround to the satellite visibility problem is to rely on cellular
    telephone towers as a way to compute a position very quickly even without GPS
    satellite data. A phone which is in contact with several cell towers can have
    the position triangulated based on the overlapping transmission patterns. In many
    telephone devices, the GPS calculation requires local cellphone towers before
    it can calculate a GPS position.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于卫星可见性问题的一个常见解决方案是依靠蜂窝电话塔作为计算位置的一种方法，即使没有GPS卫星数据也能非常快速地计算位置。一部与多个蜂窝电话塔保持联系的手机可以根据重叠的传输模式进行位置三角测量。在许多电话设备中，在计算GPS位置之前，需要使用本地蜂窝电话塔。
- en: There are many non-phone GPS devices that can be directly connected to a computer
    to get accurate GPS fixes without relying on cellular data. Navigation computers
    (mariners call them **chart plotters**) work without the need to connect to a
    cellular network. In many cases, we can use modules such as `pyserial` to extract
    data from these devices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多非手机GPS设备可以直接连接到计算机，以获取准确的GPS定位，而不依赖于蜂窝数据。导航计算机（航海员称之为**海图定位仪**）无需连接到蜂窝网络即可工作。在许多情况下，我们可以使用如`pyserial`之类的模块从这些设备中提取数据。
- en: See [http://pyserial.sourceforge.net](http://pyserial.sourceforge.net) for more
    information on the pySerial project and how we can use this read data from a GPS
    device via a serial to a USB adapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有关pySerial项目和如何通过串行到USB适配器从GPS设备读取数据的更多信息，请参阅[http://pyserial.sourceforge.net](http://pyserial.sourceforge.net)。
- en: Handling politics – borders, precincts, jurisdictions, and neighborhoods
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理政治——边界、选区、司法管辖区和社区
- en: Borders create endless problems—some profound, some subtle. The entire sweep
    of human history seems to center on borders and wars. The edges of neighborhoods
    are often subjective. In an urban environment, a block or two may not matter much
    when discussing the difference between Los Feliz and East Hollywood. On the other
    hand, this kind of knowledge is what defines the *local* restaurants as recognized
    by people who live there.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 边界造成了无数的问题——有些是深刻的，有些是微妙的。整个人类历史似乎都围绕着边界和战争展开。社区边缘往往是主观的。在城市环境中，在讨论洛斯菲利斯和东好莱坞之间的差异时，一个或两个街区可能并不重要。另一方面，这种知识正是定义当地被居住者认可的**当地**餐馆的因素。
- en: When it comes to more formal definitions—such as election districts at city,
    state, and federal levels—the side of the street may have profound implications.
    In some cities, this political division information is readily available via RESTful
    web service requests. In other locales, this information is buried in a drawer
    somewhere, or published in some kind of hard-to-process PDF document.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到更正式的定义时——例如城市、州和联邦层面的选举区——街道的一侧可能具有深远的影响。在一些城市，这种政治划分信息可以通过RESTful网络服务请求轻松获取。在其他地区，此类信息可能被埋藏在某个抽屉里，或者以某种难以处理的PDF文档形式发布。
- en: Some media companies provide neighborhood information. The LA Times Data Desk,
    for example, has a fairly rigorous definition of the various neighborhoods around
    the greater Los Angeles area. For excellent background information on how to work
    with this kind of information, see [http://www.latimes.com/local/datadesk/](http://www.latimes.com/local/datadesk/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些媒体公司提供社区信息。例如，《洛杉矶时报》数据部门对洛杉矶大都会区周围的各个社区有一个相当严格的定义。有关如何处理此类信息的详细信息，请参阅[http://www.latimes.com/local/datadesk/](http://www.latimes.com/local/datadesk/)。
- en: Finding out where we are with geocoding services
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地理编码服务确定我们的位置
- en: 'We''ll use some geocoding services to get answers to the following questions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些地理编码服务来回答以下问题：
- en: What's the latitude and longitude of a given street address? This is called
    address geocoding or simply geocoding.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定街道地址的纬度和经度是什么？这被称为地址地理编码，或者简单地称为地理编码。
- en: Which street address is closest to a given latitude and longitude? This is called
    reverse geocoding.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个街道地址与给定的纬度和经度最接近？这被称为反向地理编码。
- en: There are, of course, many more questions we could ask. We might want to know
    a route to navigate between two addresses. We might want to know what public transportation
    choices we have to get from one place to another. For now, we'll limit ourselves
    to these two essential geocoding questions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以提出更多的问题。我们可能想知道在两个地址之间导航的路线。我们可能想知道从一地到另一地有哪些公共交通选择。目前，我们将限制自己只关注这两个基本的地理编码问题。
- en: There are many geocoding services available on the World wide web (WWW). There
    are a number of terms related to geocoding, including geomarketing, geo targeting,
    geolocation, and geotagging. They're all essentially similar; they depict location-based
    information. It can take a fair amount of espionage to track down a service with
    the features we want.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上（WWW）有许多可用的地理编码服务。有许多与地理编码相关的术语，包括地理营销、地理定位、地理位置和地理标记。它们本质上都是相似的；它们描述基于位置的信息。追踪具有我们所需功能的服务的间谍活动可能需要相当多的努力。
- en: 'The following link gives a list of services:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接提供了一个服务列表：
- en: '[http://geoservices.tamu.edu/Services/Geocode/OtherGeocoders/](http://geoservices.tamu.edu/Services/Geocode/OtherGeocoders/)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://geoservices.tamu.edu/Services/Geocode/OtherGeocoders/](http://geoservices.tamu.edu/Services/Geocode/OtherGeocoders/)'
- en: This list is far from definitive. Some of the services listed here don't work
    very well. Some large companies aren't listed; for example, MapQuest appears to
    be missing. See [http://mapquest.com](http://mapquest.com) for more information.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表远非详尽无遗。这里列出的某些服务可能效果不佳。一些大型公司并未列出；例如，MapQuest似乎缺失。更多信息请见[http://mapquest.com](http://mapquest.com)。
- en: Most geocoding services want to track usage. For large batches of requests,
    they want to be paid for the services they offer. Consequently, they issue credentials
    (a key) that must be part of every request. The procedure to get a key varies
    from service to service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数地理编码服务都希望跟踪使用情况。对于大量请求，他们希望为他们提供的服务付费。因此，他们发放凭证（一个密钥），这个密钥必须包含在每一个请求中。获取密钥的流程因服务而异。
- en: We'll look closely at the services offered by Google. They offer a limited service
    without the overhead of requesting credentials. Instead of asking us to get a
    key, they'll throttle our requests if we make too much use of their service.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仔细研究Google提供的服务。他们提供了一种有限的服务，无需请求凭证。他们不会要求我们获取密钥，如果我们过度使用他们的服务，他们会限制我们的请求。
- en: Geocoding an address
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理编码地址
- en: The forward geocoding service from address to latitude and longitude can be
    accessed via Python's `urllib.request` module. For a quick review, see the *Using
    a REST API in Python* section of [Chapter 2](ch02.html "Chapter 2. Acquiring Intelligence
    Data"), *Acquiring Intelligence Data*. This is usually a three-step process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从地址到经纬度的正向地理编码服务可以通过Python的`urllib.request`模块访问。为了快速回顾，请参阅[第2章](ch02.html "第2章。获取情报数据")中关于*在Python中使用REST
    API*的部分，*获取情报数据*。这通常是一个三步过程。
- en: Define the parts of the URL. It helps to separate the static portions from the
    dynamic query portion. We need to use the `urllib.parse.urlencode()` function
    to encode the query string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 定义URL的各个部分。这有助于将静态部分与动态查询部分分开。我们需要使用`urllib.parse.urlencode()`函数来编码查询字符串。
- en: Open the URL using a `with` statement context. This will send the request and
    get the response. The JSON document must be parsed in this `with` context.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with`语句上下文打开URL。这将发送请求并获取响应。JSON文档必须在`with`上下文中解析。
- en: 'Process the object that was received. This is done outside the `with` context.
    Here''s what it looks like:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 处理接收到的对象。这是在`with`上下文之外完成的。它看起来是这样的：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have created a dictionary with the two required fields: `address` and `sensor`.
    If you want to sign up with Google for additional support and higher-volume requests,
    you can get an API key. It will become a third field in the request dictionary.
    We used a `#` comment to include a reminder about the use of the key item.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含两个必需字段的字典：`address`和`sensor`。如果你想通过Google注册以获得额外的支持和更高频率的请求，你可以获取一个API密钥。它将成为请求字典中的第三个字段。我们使用`#`注释来包含关于使用密钥项的提醒。
- en: An HTML web page form is essentially this kind of dictionary with names and
    values. When the browser makes a request, the form is encoded before it is transmitted
    to the web server. Our Python program does this using `urllib.parse.urlencode()`
    to encode the form data into something that a web server can use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个HTML网页表单本质上是一种包含名称和值的字典。当浏览器发起请求时，表单在传输到Web服务器之前会被编码。我们的Python程序使用`urllib.parse.urlencode()`函数来将表单数据编码成Web服务器可以使用的格式。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Google requires us to use the `safe=","` parameter. This assures us that the
    `","` characters in the address will be preserved instead of being rewritten as
    `"%2C"`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Google要求我们使用`safe=","`参数。这确保了地址中的`","`字符将被保留，而不是被重写为`"%2C"`。
- en: A complete URL has a scheme, location, path, and an optional query. The scheme,
    location, and path tend to remain fixed. We assembled a complete URL from the
    fixed portions and the dynamic query content, printed it, and also used it as
    an argument to the `urllib.request.urlopen()` function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的URL包含一个方案、位置、路径和一个可选的查询。方案、位置和路径通常保持不变。我们通过固定部分和动态查询内容组装了一个完整的URL，打印出来，并将其用作`urllib.request.urlopen()`函数的参数。
- en: In the `with` statement, we created a processing context. This will send the
    request and read the response. Inside the `with` context, we printed the headers
    to confirm that the request worked. More importantly, we loaded the JSON response,
    which will create a Python object. We saved that object in the `response` variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`语句中，我们创建了一个处理上下文。这将发送请求并读取响应。在`with`上下文中，我们打印了头部信息以确认请求成功。更重要的是，我们加载了JSON响应，这将创建一个Python对象。我们将该对象保存在`response`变量中。
- en: After creating the Python object, we can release the resources tied up in making
    the geocoding request. Leaving the indented block of the `with` statement assures
    that all the resources are released and the file-like response is closed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Python对象后，我们可以释放与地理编码请求相关的资源。保留`with`语句的缩进块确保所有资源都得到释放，并且文件响应被关闭。
- en: After the `with` context, we can work with the response. In this case, we merely
    print the object. Later, we'll do more with the response.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`上下文之后，我们可以处理响应。在这种情况下，我们只是打印对象。稍后，我们将对响应进行更多操作。
- en: 'We''ll see three things, as shown in the following snippet—the URL that we
    built, headers from the HTTP response, and finally the geocoding output as a JSON-formatted
    document:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下片段中的三件事——我们构建的URL、HTTP响应的头部信息，以及最终以JSON格式文档表示的地理编码输出：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The JSON document can be loaded using the `json` module. This will create a
    dictionary with two keys: `results` and `status`. In our example, we loaded the
    dictionary into a variable named `response`. The value of `response[''results'']`
    is a list of dictionaries. Since we only requested one address, we only expect
    one element in this list. Most of what we want, then, is in `response[''results''][0]`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`json`模块加载JSON文档。这将创建一个包含两个键的字典：`results`和`status`。在我们的例子中，我们将字典加载到名为`response`的变量中。`response['results']`的值是一个字典列表。由于我们只请求了一个地址，我们只期望这个列表中有一个元素。因此，我们想要的绝大部分信息都在`response['results'][0]`中。
- en: When we examine that structure, we find a subdictionary with four keys. Of those,
    the `'geometry'` key has the geocoding latitude and longitude information.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查这个结构时，我们发现一个包含四个键的子字典。其中，`'geometry'`键包含地理编码的经纬度信息。
- en: 'We can extend this script to access the location details using the following
    code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此脚本扩展以使用以下代码访问位置详情：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This provides us with a small dictionary that looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个看起来像这样的小字典：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is what we wanted to know about the street address.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要了解的街道地址信息。
- en: Also, as a purely technical note on the Python language, we included `#` comments
    to show the important steps in our algorithm. A comment starts with `#` and goes
    to the end of the line. In this example, the comments are on the lines by themselves.
    In general, they can be placed at the end of any line of code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为一个关于Python语言的纯技术说明，我们包含了`#`注释来显示算法中的重要步骤。注释以`#`开头，直到行尾。在这个例子中，注释单独一行。通常，它们可以放在任何代码行的末尾。
- en: 'Specifically, we called this out with a comment:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们用注释指出了这一点：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The form dictionary has two keys. A third key can be added by removing the `#`
    comment indicator and filling in the API key that Google has supplied.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字典有两个键。可以通过删除`#`注释指示符并填写Google提供的API密钥来添加第三个键。
- en: Reverse geocoding a latitude-longitude point
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向地理编码经纬度点
- en: 'The reverse geocoding service locates nearby addresses from a latitude and
    longitude position. This kind of query involves a certain amount of inherent ambiguity.
    A point that''s midway between two large buildings, for example, could be associated
    with either or both buildings. Also, we might be interested in different levels
    of details: rather than a street address, we may only wish to know the state or
    country for a particular position.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 反向地理编码服务从经纬度位置定位附近的地址。这类查询涉及一定程度的固有歧义。例如，位于两座大型建筑之间的点可能与其中一座或两座建筑相关联。此外，我们可能对不同的细节级别感兴趣：而不是街道地址，我们可能只想知道特定位置所在的州或国家。
- en: 'Here''s what this web service request looks like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个网络服务请求看起来像什么：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The form has two required fields: `latlng` and `sensor`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表单有两个必填字段：`latlng`和`sensor`。
- en: Signing up with Google for additional support and higher-volume requests requires
    an API key. It would become a third field in the request form; we have left a
    `#` comment in the code as a reminder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Google进行注册以获得额外支持和更高频率的请求需要一个API密钥。它将成为请求表单中的第三个字段；我们在代码中留下了一个`#`注释作为提醒。
- en: We encoded the form data and assigned it to the `query` variable. The `safe=","`
    parameter assures us that the `","` characters in the latitude-longitude pair
    will be preserved instead of being rewritten into a `%2C` escape code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表单数据编码并分配给`query`变量。`safe=","`参数确保纬度-经度对中的`","`字符将被保留，而不是被重写为`%2C`转义代码。
- en: We assembled a complete address from the fixed portions of the URL (the scheme,
    net location, and path) plus the dynamic query content. The scheme, location,
    and path are generally fixed. The query is encoded from the form data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从URL的固定部分（方案、网络位置和路径）以及动态查询内容组装了一个完整的地址。方案、位置和路径通常是固定的。查询是从表单数据编码的。
- en: In the `with` statement, we created a processing context to send the request
    and read the response. Inside the `with` context, we displayed the headers and
    loaded the resulting JSON document, creating a Python object. Once we have the
    Python object, we can exit the processing context and release the resources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`语句中，我们创建了一个处理上下文来发送请求并读取响应。在`with`上下文中，我们显示了头信息并加载了生成的JSON文档，创建了一个Python对象。一旦我们有了Python对象，我们就可以退出处理上下文并释放资源。
- en: 'The response is a Python dictionary. There are two keys: `''results''` and
    `''status''`. The value of `response[''results'']` is a list of dictionaries.
    There are a number of alternative addresses in the `results` list. Each result
    is a dictionary with two interesting keys: the `''types''` key, which shows the
    type of address and the `''formatted_address''` key, which is a well-formatted
    address close to the given location.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是一个Python字典。有两个键：`'results'`和`'status'`。`response['results']`的值是一个字典列表。`results`列表中有多个替代地址。每个结果都是一个字典，包含两个有趣的键：`'types'`键，显示地址类型，以及`'formatted_address'`键，这是一个接近给定位置的格式化地址。
- en: 'The output looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each of the alternatives shows a hierarchy of nested political containers for
    the address: postal code, locality, state (called `administrative_area_level_1`),
    and country.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都显示了地址嵌套的政治容器层次结构：邮政编码、地区、州（称为`administrative_area_level_1`）和国家。
- en: How close? What direction?
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多近？什么方向？
- en: In order to calculate the distance between two points, we'll need to use some
    spherical geometry calculations. The problem we will have to overcome is that
    our charts and maps are flat. But the actual planet is very close to being spherical.
    While the spherical geometry may be a bit advanced, the programming is pretty
    simple. It will show us several features of the Python `math` library.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算两点之间的距离，我们需要使用一些球面几何计算。我们必须克服的问题是我们的图表和地图是平的。但实际行星非常接近球形。虽然球面几何可能有点复杂，但编程相当简单。它将展示Python
    `math`库的几个特性。
- en: 'The distance between two latitude and longitude points on a sphere is defined
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在球体上两点之间的距离定义为以下：
- en: '![How close? What direction?](img/0420OS_04_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![多近？什么方向？](img/0420OS_04_01.jpg)'
- en: This formula determines the cosine between the two positions; the angle with
    that cosine is multiplied by the radius of the earth, R, to get the distance along
    the surface. We can use R = 3,440 NM, R = 3,959 mi, or R = 6,371 km; we get reasonably
    accurate distances in nautical miles, statute miles, or kilometers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式确定了两个位置之间的余弦值；与该余弦值相对应的角度乘以地球半径R，以得到沿表面的距离。我们可以使用R = 3,440 NM，R = 3,959英里，或R
    = 6,371公里；我们得到合理准确的海里、英里或公里距离。
- en: This formula doesn't work well with small distances. The haversine formula is
    preferred to compute distances more accurately. Here is some background information
    [http://en.wikipedia.org/wiki/Haversine_formula](http://en.wikipedia.org/wiki/Haversine_formula).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式在小距离上效果不佳。水平距离公式更适合更精确地计算距离。以下是一些背景信息[http://en.wikipedia.org/wiki/Haversine_formula](http://en.wikipedia.org/wiki/Haversine_formula)。
- en: According to the OED, the term "haversine" was coined in 1835 by Prof. James
    Inman. The term refers to the way the sine function is used.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据OED，术语“haversine”是在1835年由詹姆斯·英曼教授创造的。这个术语指的是正弦函数的使用方式。
- en: 'The haversine calculation is often shown as a sequence of five steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 水平距离计算通常表示为五个步骤：
- en: '![How close? What direction?](img/0420OS_04_02.jpg)'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_IMG
  zh: '![多近？什么方向？](img/0420OS_04_02.jpg)'
- en: '![How close? What direction?](img/0420OS_04_03.jpg)'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_IMG
  zh: '![多近？什么方向？](img/0420OS_04_03.jpg)'
- en: '![How close? What direction?](img/0420OS_04_04.jpg)'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_IMG
  zh: '![多近？什么方向？](img/0420OS_04_04.jpg)'
- en: '![How close? What direction?](img/0420OS_04_05.jpg)'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_IMG
  zh: '![多近？什么方向？](img/0420OS_04_05.jpg)'
- en: '![How close? What direction?](img/0420OS_04_06.jpg)'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_IMG
  zh: '![多近？什么方向？](img/0420OS_04_06.jpg)'
- en: The required sine, cosine, and square root portions of this are part of Python's
    `math` library. When we look at the definitions of sine and cosine, we see that
    they work in radians. We'll need to convert our latitude and longitude values
    from degrees to radians. The rule is simple (![How close? What direction?](img/0420OS_04_07.jpg)),
    but the `math` library includes a function, `radians()`, which will do this for
    us.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式所需的正弦、余弦和平方根部分是Python的`math`库的一部分。当我们查看正弦和余弦的定义时，我们看到它们是以弧度为单位的。我们需要将我们的纬度和经度值从度转换为弧度。规则很简单
    (![多近？什么方向？](img/0420OS_04_07.jpg))，但`math`库包括一个函数`radians()`，它将为我们完成这个转换。
- en: We can look at [http://rosettacode.org/wiki/Haversine_formula#Python](http://rosettacode.org/wiki/Haversine_formula#Python)
    to learn from the example already there.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看[http://rosettacode.org/wiki/Haversine_formula#Python](http://rosettacode.org/wiki/Haversine_formula#Python)来从已有的示例中学习。
- en: 'We''ll use this as the distance between two points:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个作为两点之间的距离：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've imported the five functions from the `math` library that we require for
    this calculation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了进行此计算所需的`math`库中的五个函数。
- en: We've defined three constants with the earth's radius in various units. We can
    plug any of these into our `haversine()` function as the `R` parameter to compute
    distances in different units. These values are approximations, but they'll work
    to determine how far apart two points are. We can plug in more accurate values
    if we want more precise answers. Since the earth isn't perfectly spherical, we
    have to be sure to use mean radius values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了三个常数，它们以不同的单位表示地球的半径。我们可以将这些中的任何一个插入到我们的`haversine()`函数中作为`R`参数，以计算不同单位下的距离。这些值是近似值，但它们可以用来确定两点之间的距离。如果我们想要更精确的答案，我们可以插入更精确的值。由于地球不是完美的球形，我们必须确保使用平均半径值。
- en: 'The `haversine()` function will accept two required positional parameters and
    an optional parameter. The two positional parameters will be two-tuples of latitude
    and longitude. We''d like to use a syntax like `(36.12, -86.67)` to keep the two
    coordinates bound in a single Python value. The `R` parameter is optional because
    we''ve provided a default value for it. We can use this function to get distances
    in kilometers instead of in miles: `haversine( (36.12, -86.67), (33.94, -118.40),
    R=KM)`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`haversine()`函数将接受两个必需的位置参数和一个可选参数。两个位置参数将是纬度和经度的两个元组。我们希望使用类似于`(36.12, -86.67)`的语法来将两个坐标绑定在单个Python值中。`R`参数是可选的，因为我们已经为它提供了一个默认值。我们可以使用这个函数以千米为单位而不是英里来获取距离：`haversine(
    (36.12, -86.67), (33.94, -118.40), R=KM)`。'
- en: The body of our function breaks down the two-tuples into their component latitude
    and longitude values. We compute the `Δ_lat` variable by subtracting and converting
    the result to radians. Similarly, we compute the `Δ_lon` variable by subtracting
    and converting the result to radians. And yes variable names which begin with
    the Greek Δ character are perfectly valid in Python. After this, we can also convert
    the other two latitudes to radians. We can then plug these values to other formulae
    to compute `a`, `c`, and finally the distance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数的主体将两个元组分解为其纬度和经度值。我们通过减去并转换结果来计算`Δ_lat`变量。同样，我们通过减去并转换结果来计算`Δ_lon`变量。是的，以希腊字母Δ开头的变量名在Python中是完全有效的。在这之后，我们还可以将其他两个纬度转换为弧度。然后我们可以将这些值插入到其他公式中，以计算`a`、`c`，最后计算距离。
- en: 'We have a test case based on the example from the Rosetta Code website:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个基于Rosetta Code网站示例的测试用例：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we rounded the answer to five decimal places. Floating-point numbers
    are an approximation; it's possible to see some variations between hardware and
    OS in precisely how floating-point numbers work. By limiting ourselves to five
    decimal places, we're confident that variations in hardware won't upset the test
    case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将答案四舍五入到小数点后五位。浮点数是近似值；在硬件和操作系统上，精确地工作可能会有所不同。通过限制自己到小数点后五位，我们确信硬件的变化不会影响测试用例。
- en: We can use this `haversine()` function with our geocode results to compute distances
    between locations; this will help us find the closest locations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个`haversine()`函数与我们的地理编码结果来计算地点之间的距离；这将帮助我们找到最近的地点。
- en: Combining geocoding and haversine
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合地理编码和haversine
- en: Between geocoding and the `haversine()` function, we have the tools to compute
    the approximate distance between addresses.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在地理编码和`haversine()`函数之间，我们有计算地址之间近似距离的工具。
- en: Let's take 333 Waterside, Norfolk, Virginia, as our current base of operations.
    Let's say our informant wants to meet either at 456 Granby or 111 W Tazewell.
    Which one is closer?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把333 Waterside，Norfolk，Virginia作为我们的当前作战基地。假设我们的信息提供者想要在456 Granby或111 W
    Tazewell见面。哪一个更近？
- en: First, we'll need to clean up our geocoding script to make it a usable function.
    Rather than simply printing a result, we'll need to get the values out of the
    results dictionary to make a sequence of the two-tuples of the latitude and longitude
    responses.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要清理我们的地理编码脚本，使其成为一个可用的函数。而不仅仅是打印一个结果，我们需要从结果字典中获取值，以形成一个包含纬度和经度响应二元组的序列。
- en: 'Here''s what we''ll need to add:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要添加的内容：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've used two generator expressions to dismantle the results. The first generator
    expression took the location information from each alternative in the `response['results']`
    sequence. For geocoding, there should only be one expression, but it's simpler
    if we pretend we'll get multiple responses.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两个生成器表达式来分解结果。第一个生成器表达式从`response['results']`序列中的每个替代方案中提取位置信息。对于地理编码，应该只有一个表达式，但如果假设我们会得到多个响应，那么会更简单。
- en: The second generator expression turned the `'lat'` and `'lng'` elements of the
    location dictionary into a two-tuple. Having latitude and longitude two-tuples
    will play well with our `havesine()` function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个生成器表达式将位置字典中的`'lat'`和`'lng'`元素转换为一个二元组。拥有纬度和经度二元组将很好地与我们的`haversine()`函数配合使用。
- en: 'Here''s how we can get three latitude-longitude pairs:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们可以获取三个经纬度对：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've applied our `geocode()` function to get a list of two-tuples and then
    used `[0]` to pick the first element from each response list.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经应用了我们的`geocode()`函数来获取一个包含两个元组的列表，然后使用`[0]`从每个响应列表中选取第一个元素。
- en: 'Here''s how we can report the distances from the base to each location:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以报告从基地到每个位置的距离的方法：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We applied our `haversine()` function to compute distances. By default, the
    distances are in miles, not that the units matter to carry out a relative comparison
    of closer versus further away.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用了我们的`haversine()`函数来计算距离。默认情况下，距离是以英里为单位，不过对于进行相对比较来说，单位并不重要。
- en: 'Here are the results:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结果：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can see that the second location (`Loc2`), the Tazewell address, is much
    closer to our base than the Granby street address.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，第二个位置（`Loc2`），Tazewell地址，比Granby街地址更接近我们的基地。
- en: Also, we can see that we need to format these numbers to make them look better.
    Since we're only working with an approximate mean earth radius in miles, most
    of those decimal places are just visual noise.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以看到，我们需要格式化这些数字，使它们看起来更好。因为我们只使用大约的平均地球半径（以英里为单位），所以大部分的这些小数位只是视觉噪音。
- en: Compressing data to make grid codes
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩数据以生成网格代码
- en: Latitudes and longitudes are bulky to transmit. They have a lot of digits and
    some peculiar punctuation. Over the years, some alternatives have risen that abbreviate
    a location using a simpler notation. The essential idea is to convert latitude
    and longitude numbers from their degree-minute-second numbers into a sequence
    of letters and digits that represent the same information.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度和经度在传输时体积较大。它们有很多数字和一些特殊的标点符号。多年来，一些替代方案已经出现，它们使用更简单的符号来缩写位置。基本思想是将纬度和经度数字从度-分-秒数字转换为表示相同信息的字母和数字序列。
- en: 'We''ll look at three compression schemes: the GeoRef system, the Maindenhead
    Locator, and NAC. Each of these encodings involves doing some arithmetic calculations
    to convert numbers from decimal (base 10) to another base. We''ll also use a number
    of string operations to translate numbers to characters and characters to numbers.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨三种压缩方案：GeoRef系统、Maindenhead定位器和NAC。这些编码中的每一个都涉及到进行一些算术计算，将数字从十进制（基数10）转换为另一个基数。我们还将使用一系列字符串操作来将数字转换为字符，以及将字符转换为数字。
- en: 'Another interesting programming issue is that these encodings don''t work directly
    with latitudes and longitudes. The problem with simply using latitudes and longitudes
    is that they''re signed numbers: -90 (S) to +90 (N) and -180 (W) to +180 (E).
    Also, longitudes have a bigger range (360 values), whereas latitudes have a smaller
    range (180 values). To simplify the encoding, we''ll apply a common programming
    hack: we''ll offset and scale the values. We''ll see a number of ways to apply
    this clever technique.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的编程问题是，这些编码不能直接与纬度和经度一起使用。简单地使用纬度和经度的问题在于它们是有符号的数字：-90（S）到+90（N）和-180（W）到+180（E）。此外，经度有更大的范围（360个值），而纬度有较小的范围（180个值）。为了简化编码，我们将应用一个常见的编程技巧：我们将偏移和缩放值。我们将看到应用这种巧妙技术的方法。
- en: 'In effect, the scaling and offsetting moves the map''s (0, 0) origin to somewhere
    in Antarctica: at the south pole and right on 180° longitude. The center of these
    grid maps is somewhere off the coast of West Africa, and the upper-right corner
    will wind up in the Bering Sea, right at the north pole and next to the 180° longitude.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，缩放和偏移将地图的(0, 0)原点移动到南极洲的某个地方：在南极和180°经度上。这些网格地图的中心位于西非海岸线附近，而上右角最终会在白令海，正好在北极和180°经度旁边。
- en: Creating GeoRef codes
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建GeoRef代码
- en: The GeoRef system compresses a latitude-longitude position using four letters
    and as many as eight digits. This system can also be used to encode descriptions
    of regions as well as altitudes. We'll stick with locations on the surface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: GeoRef系统使用四个字母和多达八个数字来压缩经纬度位置。此系统还可以用于编码区域描述以及海拔。我们将坚持使用地表位置。
- en: For some background information, see [http://en.wikipedia.org/wiki/Georef](http://en.wikipedia.org/wiki/Georef).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些背景信息，请参阅[http://en.wikipedia.org/wiki/Georef](http://en.wikipedia.org/wiki/Georef)。
- en: 'This system encodes decimal numbers using 24-letter codes chosen from A to
    Z, omitting I and O. This means that we can''t simply rely on a handy copy of
    the alphabet such as `string.ascii_uppercase` to provide the letter codes. We''ll
    have to define our own GeoRef letters. We can compute the letters with an expression
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统使用从A到Z的24个字母代码（省略I和O）来编码十进制数。这意味着我们不能简单地依赖像`string.ascii_uppercase`这样的字母表来提供字母代码。我们将不得不定义我们自己的GeoRef字母。我们可以用以下表达式来计算字母：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The GeoRef codes slice the world map into a 12 x 24 grid of 15° x 15° quadrangles.
    The latitude is measured in positive numbers from the South Pole. The longitude
    is measured in positive numbers from the International Date Line. When we divide
    180° of latitude into 15° steps, we can encode a part of this three-digit number
    using 12 letters from A to M (omitting I). When we divide 360° of longitude into
    15° steps, we can encode a part of this three-digit number using 24 letters from
    A to Z (omitting I and O).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: GeoRef代码将世界地图切割成12 x 24的15° x 15°网格。纬度从南极开始以正数测量。经度从国际日期线开始以正数测量。当我们把180°的纬度分成15°的步长时，我们可以使用从A到M的12个字母（省略I）来编码这个三位数的一部分。当我们把360°的经度分成15°的步长时，我们可以使用从A到Z的24个字母（省略I和O）来编码这个三位数的一部分。
- en: We can then divide each 15° quadrangles into 15 bands using letters A to Q (again,
    skipping I and O). This creates a four- character code for the entire degrees
    portion of a latitude and longitude position.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用字母A到Q（再次省略I和O）将每个15°的网格分成15个波段。这为纬度和经度的整个度数部分创建了一个四字符代码。
- en: 'If we had a latitude of 38°17′10″N, we''d offset this to be 128° north of the
    south pole and divide it by 15°:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有38°17′10″N的纬度，我们将将其偏移到南极以北128°，然后除以15°：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These values are encoded as J and J.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值被编码为J和J。
- en: 'A longitude of 76°24′42″W is encoded as shown in the following code. This is
    -76.41167°, which we offset by 180° before using `divmod` to calculate the two
    characters:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 76°24′42″W的经度被编码，如下所示代码所示。这是-76.41167°，我们在使用`divmod`计算两个字符之前，将其偏移180°：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This gives us letters G and P. We interleave longitude and latitude characters
    so that the whole string is GJPJ. We've encoded six digits of latitude and longitude
    into four characters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们字母G和P。我们交错经度和纬度字符，使整个字符串为GJPJ。我们已经将纬度和经度的六位数字编码为四个字符。
- en: The leftover minutes and seconds can be encoded as two, three, or four digits.
    For the latitude, 17′10″ can be encoded as 17.16 minutes. This is 17, an intermediate
    171, or a detailed 1716.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的分钟和秒可以编码为两位、三位或四位数字。对于纬度，17′10″可以编码为17.16分钟。这是17，一个中间值171，或一个详细值1716。
- en: 'Here''s the entire encoder the for GeoRef codes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是GeoRef代码的整个编码器：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We offset the latitudes and longitudes so that we don't have to deal with signed
    numbers. We used the `divmod()` function to divide by 15° and get both a quotient
    and a remainder. We can then use our `georef_uppercase` letters to translate the
    numeric quotients and remainders into expected character codes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对纬度和经度进行了偏移，这样我们就不必处理有符号的数字。我们使用了 `divmod()` 函数来除以15°，并得到一个商和一个余数。然后我们可以使用我们的
    `georef_uppercase` 字母来将数值商和余数转换为预期的字符代码。
- en: The fractional values, for example, `f_lat-int(f_lat)`, are scaled by 6000 to
    create a number between 0000 and 5999, which is simply the number of minutes in
    100ths.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，分数值 `f_lat-int(f_lat)` 被缩放为6000，以创建一个介于0000和5999之间的数字，这仅仅是100分之分钟的数字。
- en: We've used the string `format()` method to assemble the four-character codes
    and four-digit numeric codes into a single string. The first two letters are longitude
    and latitude to provide a position to the nearest 15°. The next two letters have
    more longitude and latitude details to refine this to the nearest 1°. The digits
    are in two blocks of four to provide the detailed minutes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `format()` 字符串方法将四字符代码和四数字代码组合成一个单一的字符串。前两个字母是经度和纬度，以提供最接近15°的位置。接下来的两个字母有更多的经度和纬度细节，以将精度细化到最接近的1°。数字分为两个四位数块，以提供详细的分钟数。
- en: 'Here''s a more complete example of the output. We''ll encode 36°50.63′N 076°17.49′W:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更完整的输出示例。我们将编码 36°50.63′N 076°17.49′W：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ve converted degrees and minutes to degrees. Then, we applied our GeoRef
    conversion to the values in degrees. Here''s what the output looks like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将度和分钟转换为度。然后，我们将 GeoRef 转换应用于度数中的值。以下是输出结果：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code `GJPG` is an approximation of the given location; it could be off by
    almost 80 nautical miles at the equator. The error gets smaller toward the poles.
    The code `GJPG4250` uses the two-digit encoding of whole minutes to get within
    a few miles of the coordinates.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 `GJPG` 是给定位置的近似值；在赤道附近可能会偏差高达80海里。误差随着接近两极而减小。代码 `GJPG4250` 使用两位数的整分钟编码，以将坐标误差缩小到几英里以内。
- en: Decoding a GeoRef code
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码 GeoRef 代码
- en: 'When we decode a GeoRef code, we have to separate the two parts: the four characters
    at the beginning and the numeric details at the end. Once we''ve split off the
    first four characters, we can divide the number of remaining characters in half.
    One half of the digits will be longitude and the rest will be latitude.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解码 GeoRef 代码时，我们必须将两部分分开：前四个字符和末尾的数字细节。一旦我们分离出前四个字符，我们可以将剩余字符的数量除以二。一半的数字将是经度，其余的是纬度。
- en: 'The first four characters must be looked up in our special GeoRef alphabet.
    We''ll find each character''s position in the `ABCDEFGHJKLMNPQRSTUVWXYZ` string
    to get a numeric value. An expression such as `georef_uppercase.find(''Q'')` gives
    us 14: the position of Q in that alphabet. We can then multiply one position by
    15° and add the other position number to translate two characters to the degrees
    portion of GeoRef.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前四位必须在我们的特殊 GeoRef 字母表中查找。我们将找到每个字符在 `ABCDEFGHJKLMNPQRSTUVWXYZ` 字符串中的位置以获得一个数值。例如，`georef_uppercase.find('Q')`
    给出14：Q 在该字母表中的位置。然后我们可以将一个位置乘以15°，将另一个位置数字加到一起，将两个字符转换为 GeoRef 的度数部分。
- en: The remaining digits are simply minutes, which are 1/60 of a degree. During
    conversion there is a matter of creating a number and possibly dividing it by
    10 or 100\. The final step is to take out the offsets that were used to avoid
    signed arithmetic.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的数字仅仅是分钟，它们是1/60度。在转换过程中，涉及到创建一个数字，可能还需要将其除以10或100。最后一步是移除用于避免有符号算术的偏移量。
- en: 'The whole thing looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程看起来是这样的：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This works by separating the first four positions of the code into four longitude
    and latitude characters. Note that the positions are interleaved: longitude first,
    latitude second.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过将代码的前四位分成四个经度和纬度字符来实现。请注意，位置是交错排列的：经度先，纬度后。
- en: The rest of the string is divided in half. If there are any characters in the
    second half, then the first half (two, three, or four characters) will be longitude
    minutes; the second half will be latitude minutes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的其余部分被分成两半。如果有任何字符在第二半，那么第一半（两个、三个或四个字符）将是经度分钟；第二半将是纬度分钟。
- en: 'We''ve used a simple literal mapping from the length (two, three, or four)
    to the scaling values (1, 10, and 100). We defined a dictionary with the mapping
    from the position to scale factor and applied the number of positions, `pos`,
    to that dictionary. We could have done this using an arithmetic calculation, too:
    `10**(pos-1)`; this calculation also works to convert `pos` to a power of 10.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个简单的从长度（两个、三个或四个）到缩放值（1、10和100）的映射。我们定义了一个从位置到缩放因子的映射字典，并将位置数`pos`应用于该字典。我们也可以使用算术计算来完成这个操作：`10**(pos-1)`；这个计算也可以将`pos`转换为10的幂。
- en: 'We will take the string of characters, convert them to float and then scale
    them to create a proper value for minutes. Here is an example of what the scaling
    looks like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将字符字符串转换为浮点数，然后缩放以创建分钟的适当值。以下是一个缩放示例：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `else` condition handles the case where there are only four positions in
    the grid code. If this is true, then the letters are all we have and the minutes
    will be zero.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`条件处理只有四个位置的网格代码的情况。如果这是真的，那么我们只有字母，分钟将为零。'
- en: We can calculate the offset values using one letter scaled by 15°, the next
    letter scaled by 1°, and the minutes by the 60th of a degree. The final step,
    of course, is to remove the offsets to create the expected signed numbers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个字母乘以15°，下一个字母乘以1°，以及分钟乘以度的60分来计算偏移值。当然，最后一步是移除偏移值以创建预期的有符号数字。
- en: 'Consider that we use this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们使用以下内容：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll see an output like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如下输出：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We chopped the longer GeoRef down to a 10-digit code. This has two 3-digit encodings
    of the minutes. We have elected to lose some accuracy, but this can also simplify
    the transmission of secret information.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将较长的GeoRef代码缩短为10位代码。这有两个3位分钟的编码。我们选择牺牲一些精度，但这也可以简化秘密信息的传输。
- en: Creating Maidenhead grid codes
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建梅登黑德网格代码
- en: As compared to relatively simple grid codes covered previously, we have an alternative
    notation called the **Maidenhead system**. This is used by Ham radio operators
    to exchange information about the locations of their stations. Maidenhead is a
    town in England; the Maidenhead code is **IO91PM**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前提到的相对简单的网格代码相比，我们有一个称为**梅登黑德系统**的替代表示法。这是由业余无线电操作员用来交换他们站点位置信息的。梅登黑德是英格兰的一个城镇；梅登黑德代码是**IO91PM**。
- en: For more information, see [http://en.wikipedia.org/wiki/Maidenhead_Locator_System](http://en.wikipedia.org/wiki/Maidenhead_Locator_System).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[http://en.wikipedia.org/wiki/Maidenhead_Locator_System](http://en.wikipedia.org/wiki/Maidenhead_Locator_System)。
- en: The Maidenhead algorithms involve somewhat more sophisticated math based on
    creating a base 240 representation of the latitude and longitude numbers. We can
    encode each *digit* of a base 240 number using a letter-digit combination. We'll
    show a common technique to convert a floating-point number to an integer using
    a series of steps.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 梅登黑德算法涉及一些更复杂的数学，基于创建纬度和经度数字的基数为240的表示。我们可以使用字母-数字组合来编码基数240数字的每一位。我们将展示一个将浮点数转换为整数的常用技术，通过一系列步骤进行。
- en: The Maidenhead system slices the world map into a 180 × 180 grid of quadrangles;
    each quadrangle has 1° in the N-S direction and 2° in the E-W direction. We can
    encode these quadrangles using a base 240 numbering system where a letter and
    digit are used to denote each of the digits of the base 240 system. Since the
    grid is only 180×180, we don't need the full range of our base 240 numbers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 梅登黑德系统将世界地图切割成180 × 180的网格四边形；每个四边形在南北方向上有1°，在东西方向上有2°。我们可以使用基数为240的数字系统来编码这些四边形，其中字母和数字用于表示基数240系统中的每一位。由于网格只有180×180，我们不需要基数240的全部范围。
- en: To specify a position more accurately, we can slice each cell of the grid into
    240 x 240 smaller cells. This means that an eight-position code gets us within
    .25 nautical miles in the N-S direction and .5 nautical miles in the E-W direction.
    For Ham radio purposes, this may be sufficient. For our address-level geocoding,
    we'll need more accuracy.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精确地指定位置，我们可以将网格的每个单元格切割成240 x 240更小的单元格。这意味着一个八位代码可以使我们在南北方向上达到0.25海里，在东西方向上达到0.5海里。对于业余无线电的目的，这可能是足够的。对于我们的地址级地理编码，我们需要更高的精度。
- en: We can apply the same letter-number operation a third time, dividing each tiny
    rectangle into 240 even smaller pieces. This gets us more than the accuracy we
    need.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相同的字母-数字操作进行第三次，将每个小矩形分割成240个更小的部分。这使我们达到了所需的精度以上。
- en: 'We are creating a three-digit number in a 240-number system where each base
    240 digit is represented by a letter-number pair. We''re performing the following
    calculation to create the three digits ![Creating Maidenhead grid codes](img/0420OS_04_08.jpg)
    that encode a number, ![Creating Maidenhead grid codes](img/0420OS_04_09.jpg):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在240进制系统中创建一个三位数，其中每个240的基数位由一个字母-数字对表示。我们执行以下计算来创建编码数字的三位数字![创建梅登黑德网格代码](img/0420OS_04_08.jpg)，![创建梅登黑德网格代码](img/0420OS_04_09.jpg)：
- en: '![Creating Maidenhead grid codes](img/0420OS_04_10.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![创建梅登黑德网格代码](img/0420OS_04_10.jpg)'
- en: 'Here''s the whole process:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个整个过程的示例：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've defined an internal function, `let_num()`, inside our `ll_2_mh()` function.
    The internal `let_num()` function translates a number in the 0 to 240 range into
    a letter and a digit. It uses the `divmod()` function to decompose the number
    into a quotient from 0 to 24 and a remainder from 0 to 9\. This function then
    uses these two numeric values as indices in the `string.ascii_uppercase` and `string.digits`
    strings to return two characters. Each letter-number pair is a representation
    for a single digit of the base 240 number system. Rather than invent 240-digit
    symbols, we've repurposed a letter-digit pair to write the 240 distinct values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ll_2_mh()`函数内部定义了一个内部函数`let_num()`。内部`let_num()`函数将0到240范围内的数字转换为一个字母和一个数字。它使用`divmod()`函数将数字分解为0到24的商和0到9的余数。然后，这个函数使用这两个数值作为`string.ascii_uppercase`和`string.digits`字符串的索引来返回两个字符。每个字母-数字对是240进制系统中单个数字的表示。我们不是发明240个数字符号，而是重新利用字母-数字对来写出240个不同的值。
- en: 'The first real step is to convert the raw, signed latitude and longitude to
    our maidenhead grid version. The `f_lat` variable is the original latitude with
    an offset of 90 to make it strictly positive, in the range 0 to 180\. The `f_lon`
    variable is the original longitude offset by 180 and divided by 2 to make it strictly
    positive, in the range 0 to 180\. We created the initial letter-number pairs from
    these initial values of degrees: `f_lat` and `f_lon`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将原始的、有符号的纬度和经度转换为我们的梅登黑德网格版本。`f_lat`变量是原始纬度，偏移90度使其严格为正，范围在0到180度之间。`f_lon`变量是原始经度偏移180度然后除以2，使其严格为正，范围在0到180度之间。我们从这些初始的度数值：`f_lat`和`f_lon`中创建了初始的字母-数字配对。
- en: This works nicely for degrees. What about the fractions of a degree? Here's
    a common technique to work with representations of floating-point values.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于度数来说工作得很好。那么，对于度数的分数部分呢？这里有一个处理浮点值表示的常见技术。
- en: 'If we use something like `lat-int(lat)`, we''ll compute the fractional portion
    of the latitude. If we scale that by 240, we''ll get a number that we can use
    with `divmod()` to get one of the 240-letter positions and a digit. The expression
    `240*(f_lat-int(f_lat))` will expand the fractional part of `f_lat` to a scale
    of 0 to 240\. Here''s an example of how this scaling works:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用类似`lat-int(lat)`的方法，我们将计算纬度的分数部分。如果我们将其乘以240，我们将得到一个可以用`divmod()`函数来获取240个字母位置和一个数字的数字。表达式`240*(f_lat-int(f_lat))`将`f_lat`的分数部分扩展到0到240的范围内。以下是如何进行这种缩放的示例：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The original latitude is `36.84383`. The value of `f_lat-int(f_lat)` will be
    the fractional portion of that value, which is `.84383`. We multiply this by `240`
    to get the value, with an approximate result of `202.5192`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 原始纬度是`36.84383`。`f_lat-int(f_lat)`的值将是该值的分数部分，即`.84383`。我们将其乘以`240`来得到值，大约的结果是`202.5192`。
- en: We used the `let_num()` function to create a letter-and-digit pair. The remaining
    fractional value (`0.5192`) can be scaled again by 240 to get yet another letter-and-digit
    pair.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`let_num()`函数创建了一个字母和数字的配对。剩余的分数值（`0.5192`）可以通过240倍缩放来得到另一个字母和数字的配对。
- en: At this point, the details have reached the limit of relevance. 1/240/240 of
    a degree is about 6 feet. Most civilian GPS instruments are only accurate to about
    16 feet.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，细节已经达到了相关性的极限。1/240/240度的精度大约是6英尺。大多数民用GPS仪器只能精确到大约16英尺。
- en: The final step is to interleave longitude and latitude characters. We've done
    this by creating a list of characters in the desired order. The `string.join()`
    method uses the given string as a separator when assembling a list of strings.
    It's common to use `", ".join(some_list)` to create comma-separated items. We
    have used `"".join()` to assemble the final string with no separator characters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将经度和纬度字符交织在一起。我们通过创建一个字符列表来实现这一点，字符的顺序是预定的。`string.join()` 方法在将字符串列表组装成一个字符串时使用给定的字符串作为分隔符。通常使用
    `", ".join(some_list)` 来创建以逗号分隔的项目。我们使用了 `"".join()` 来组装没有分隔符的最终字符串。
- en: 'Here''s a more complete example of the output. We''ll encode 36°50.63′N 076°17.49′W:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更完整的输出示例。我们将编码 36°50.63′N 076°17.49′W：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We converted degrees and minutes to degrees. Then, we applied our Maidenhead
    conversion to the values in degrees. The output looks like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将度和分转换成了度。然后，我们将 Maidenhead 转换应用于度数值。输出看起来是这样的：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can use portions of this to encode with varying degrees of accuracy. `FM16`
    is pretty coarse, whereas `FM16UU` is more accurate.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些部分以不同的精度进行编码。`FM16` 比较粗糙，而 `FM16UU` 则更精确。
- en: Decoding the Maidenhead grid codes
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码 Maidenhead 网格代码
- en: To decode the Maidenhead codes, we need to reverse the procedure we used to
    create the codes from latitudes and longitudes. We'll need to take all the even
    positions as a sequence of digits to create the longitude and all the odd positions
    as a sequence of digits to create the latitude. By looking up against `string.ascii_uppercase`
    and `string.digits`, we can transform characters into numbers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码 Maidenhead 代码，我们需要反转我们用来从纬度和经度创建代码的程序。我们需要将所有偶数位置作为数字序列来创建经度，将所有奇数位置作为数字序列来创建纬度。通过对照
    `string.ascii_uppercase` 和 `string.digits` 进行查找，我们可以将字符转换成数字。
- en: 'Once we have a sequence of numbers, we can apply a sequence of weighing factors
    and add up the results. The whole thing looks like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个数字序列，我们可以应用一系列的权重因子并将结果相加。整个过程看起来是这样的：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We used Python's very elegant slice notation to take the string apart into even
    and odd positions. The expression `grid[0::2]` specifies a slice of the `grid`
    string. The `[0::2]` slice starts at position `0`, extends to the very end, and
    increments by `2`. The `[1::2]` slice starts at position `1`, extends to the very
    end, and also increments by `2`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 Python 非常优雅的切片表示法来将字符串拆分成偶数和奇数位置。表达式 `grid[0::2]` 指定了一个 `grid` 字符串的切片。`[0::2]`
    切片从位置 `0` 开始，扩展到非常末尾，并增加 `2`。`[1::2]` 切片从位置 `1` 开始，扩展到非常末尾，也增加 `2`。
- en: The `decode` list contains six strings that will be used to translate each character
    into a numeric value. The first character will be found in `string.ascii_uppercase`
    and the second character will be found in `string.digits`. The positions at which
    the characters are found in these strings will become the numeric values that
    we can use to compute latitudes and longitudes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`decode` 列表包含六个字符串，这些字符串将被用来将每个字符转换成数值。第一个字符将在 `string.ascii_uppercase` 中找到，第二个字符将在
    `string.digits` 中找到。这些字符串中字符的位置将变成我们可以用来计算经纬度的数值。'
- en: For example, the value of `'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.find('M')` is `12`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.find('M')` 的值是 `12`。
- en: We've used a generator expression and the `zip()` function to do the real work
    of the translation. The `zip()` function will produce a sequence of pairs; each
    pair will have one character chosen from the input grid code and one lookup string
    chosen from the `decode` lists. We can then use `lookup.find(char.upper())` to
    locate the given character in the given lookup string. The result will be a sequence
    of integer positions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用生成器表达式和 `zip()` 函数来完成翻译的实际工作。`zip()` 函数将产生一系列的配对；每个配对将包含从输入网格代码中选择的一个字符和从
    `decode` 列表中选择的一个查找字符串。然后我们可以使用 `lookup.find(char.upper())` 来在给定的查找字符串中定位给定的字符。结果将是一个整数位置序列。
- en: Once we have a sequence of the numeric values, we can apply the sequence of
    weightings to convert each position to a degree or a fraction of a degree. Again,
    we used `zip()` to create two-tuples from the digits and the weights. The generator
    then multiplied the numeric value by the weight. The built-in `sum()` function
    created the final value from the numbers and weights.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个数值序列，我们可以应用一系列的权重来将每个位置转换为度或度的分数。同样，我们使用 `zip()` 来从数字和权重中创建双元组。然后生成器将数值乘以权重。内置的
    `sum()` 函数从数字和权重中创建最终值。
- en: 'For example, we might have a value in the `lons` variable of `[5, 1, 20, 6,
    0, 0]`. The weights are `[10.0, 1.0, 0.0416, 0.00416, 0.00017361, 1.7361e-05]`.
    When we use `zip()` to zip these two sequences, we''ll get pairs like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能在`lons`变量中有`[5, 1, 20, 6, 0, 0]`这样的值。权重是`[10.0, 1.0, 0.0416, 0.00416,
    0.00017361, 1.7361e-05]`。当我们使用`zip()`将这些两个序列压缩在一起时，我们会得到这样的配对：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The products look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些乘积看起来是这样的：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The sum is `51.85696`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 总和是`51.85696`。
- en: The final step is to undo the offsets we used to force the latitudes to be positive
    and the longitudes to have values between 0 and 180 instead of -180 to +180\.
    The intermediate longitude result `51.85696` becomes `-76.28608`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是撤销我们用来强制纬度为正值以及经度在0到180之间而不是-180到+180之间的偏移量。中间经度结果`51.85696`变为`-76.28608`。
- en: 'Consider that we evaluate this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们评估以下内容：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We get the following decoded positions:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下解码的位置：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This nicely decodes the values we encoded in the previous section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地解码了我们之前章节中编码的值。
- en: Creating natural area codes
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自然区域代码
- en: The **Natural Area Code** (**NAC**) is yet another way to encode geographic
    position information into a short character string. The whole NAC system can include
    altitude information along with the surface position. We'll focus on the latitude
    and longitude conversions for NAC.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**自然区域代码**（**NAC**）是将地理位置信息编码为短字符字符串的另一种方式。整个NAC系统可以包括海拔信息以及表面位置。我们将重点关注NAC的纬度和经度转换。'
- en: See [http://www.nacgeo.com/nacsite/documents/nac.asp](http://www.nacgeo.com/nacsite/documents/nac.asp),
    for more information
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅[http://www.nacgeo.com/nacsite/documents/nac.asp](http://www.nacgeo.com/nacsite/documents/nac.asp)。
- en: This uses base 30 instead of base 240; we can use most of the alphabets plus
    some digits to represent a single base 30 digit. This implementation will show
    a different approach to convert floating-point numbers to an integer approximation.
    This will combine multiple calculation steps into longer expressions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用的是30进制而不是240进制；我们可以使用大部分的字母和一些数字来表示一个30进制的数字。这个实现将展示一种将浮点数转换为整数近似的方法。这将把多个计算步骤组合成更长的表达式。
- en: 'NAC uses a 30-character encoding that employs digits and consonants. The string
    used for encoding and decoding is this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: NAC使用30字符编码，该编码使用数字和辅音字母。用于编码和解码的字符串是：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can take a longitude (-180 to +180), and add an offset to put it in the range
    of 0 to 360\. If we scale this by `(30**4)/360`, we'll get a number in the range
    0 to 810000\. This can be converted to a four-digit base 30 number.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以取一个经度（-180到+180），并添加一个偏移量将其放入0到360的范围内。如果我们将其乘以`(30**4)/360`，我们将得到一个介于0到810000之间的数字。这可以转换为四位数30进制数。
- en: Similarly, we can take a latitude (-90 to +90), and add an offset to put it
    in the range of 0 to 180\. If we scale this by `(30**4)/180`, similarly, we'll
    get a number that can be converted to a four-digit base 30 number. The big win
    here is that we've replaced long strings of base 10 digits with shorter strings
    of base 30 digits.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以取一个纬度（-90到+90），并添加一个偏移量将其放入0到180的范围内。如果我们将其乘以`(30**4)/180`，同样，我们将得到一个可以转换为四位数30进制数的数字。这里的重大优势是我们用较短的30进制数字字符串替换了长串的10进制数字。
- en: 'The suggested algorithm to encode this is:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 建议用于编码此信息的算法是：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We've scaled the longitude by adding an offset and dividing it by 360\. This
    creates a number between `0` and `1.0`. We can then encode this into base 30 using
    a large number of multiplications and subtractions. There are a number of ways
    to optimize this.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加偏移量并除以360来缩放经度。这创建了一个介于`0`和`1.0`之间的数字。然后我们可以通过大量的乘法和减法将这个数字编码为30进制。有几种方法可以优化这个过程。
- en: 'Each step follows a similar pattern. We''ll step through the longitude calculation.
    Here''s the first character calculation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步都遵循类似的模式。我们将逐步进行经度计算。以下是第一个字符的计算：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first step computes `f_lon`, the fraction of 360 for this longitude (151.3947W).
    When we multiply `f_lon` by `30`, we get `2.383775`. The integer portion, `2`,
    will become the first character. The fraction will be encoded in the remaining
    three characters.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步计算`f_lon`，即该经度（151.3947W）相对于360度的分数。当我们把`f_lon`乘以30时，得到`2.383775`。整数部分`2`将成为第一个字符。剩余的三个字符将用于编码分数。
- en: 'Here''s the next character, based on the first:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于第一个字符的下一个字符：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The calculation of `(f_lon*30-x0)` computes the fraction, `.383775`. We then
    scale this by `30` to get `11.51325`. The integer portion, `11`, will become the
    second character. The fraction will be encoded in the remaining two characters.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`(f_lon*30-x0)`的计算得到分数，`.383775`。然后我们将其乘以`30`得到`11.51325`。整数部分`11`将成为第二个字符。分数将编码在剩余的两个字符中。'
- en: 'At each step, we take all of the previous digits to compute the remaining fractional
    components. Here are the last two characters:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，我们将所有之前的数字用于计算剩余的分数部分。以下是最后两个字符：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Each of these character, takes the difference between the original number (`f_lon`)
    and the previously computed digits to get the remaining fraction. The final step
    involves a lot of multiplication. Previously, in the *Creating Maidenhead grid
    codes* section, we showed a variation on this theme that didn't use quite so many
    multiplication operations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符都通过将原始数字（`f_lon`）与之前计算的数字之间的差来获取剩余的分数。最后一步涉及大量的乘法。在之前的*创建梅登黑德网格码*部分，我们展示了这个主题的一个变体，它没有使用那么多乘法操作。
- en: 'As an example, we may perform the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能执行以下操作：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of this is:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果是：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a pretty tidy summary of a latitude and longitude.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对纬度和经度的一个相当整洁的总结。
- en: Decoding natural area codes
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码自然区域码
- en: 'Decoding natural area codes is actually a conversion from a base 30 number
    to a value between 0 and 810,000\. This is then scaled into a proper latitude
    or longitude value. Although base 30 numbers don''t seem simple, the programming
    is actually pretty succinct. Here''s the suggested algorithm:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 解码自然区域码实际上是将30进制数转换为0到810,000之间的值。然后将其缩放为适当的纬度或经度值。尽管30进制数看起来并不简单，但编程实际上相当简洁。以下是建议的算法：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We've decomposed each part of the nine-character NAC grid code into a longitude
    substring and a latitude substring. We used a generator function to lookup each
    character in our `nac_uppercase` alphabet. This will map each character to a numeric
    position between 0 and 29.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将九字符NAC网格码的每一部分分解为经度子串和纬度子串。我们使用生成器函数在我们的`nac_uppercase`字母表中查找每个字符。这将每个字符映射到0到29之间的数字位置。
- en: 'Once we have the sequence of the four base 30 digits, we can compute a number
    from the digits. The following expression does the essential work:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了四个30进制数字的序列，我们就可以从数字中计算出一个数。以下表达式完成了基本的工作：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding expression is an optimization of the polynomial, ![Decoding natural
    area codes](img/0420OS_04_11.jpg). The Python code simplifies the constants in
    each term—rather than computing `x[0]*30**3/30**4`; this is reduced to `x[0]/30`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式是对多项式的优化，![解码自然区域码](img/0420OS_04_11.jpg)。Python代码简化了每个项中的常数——而不是计算`x[0]*30**3/30**4`；这被简化为`x[0]/30`。
- en: The intermediate results are scaled by 360 or 180 and offset to get the expected
    signed values for the final result.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 中间结果通过360或180进行缩放并偏移，以获得最终结果的预期有符号值。
- en: 'Consider that we evaluate the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下评估：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We get the following as a result:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下结果：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This shows how we decode an NAC to recover the latitude and longitude of a position.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何解码NAC以恢复位置的纬度和经度。
- en: Solving problems – closest good restaurant
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决问题——最近的良好餐馆
- en: We want to meet our secret informant at a good restaurant that's a reasonable
    distance from our base. In order to locate a good restaurant, we need to gather
    some additional information. In this case, good means a passing grade from the
    health inspectors.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在离基地合理距离的好餐馆与我们的秘密线人见面。为了定位好餐馆，我们需要收集一些额外的信息。在这种情况下，好意味着来自卫生检查员的好成绩。
- en: Before we can even have a meeting, we'll need to use basic espionage skills
    to locate the health code survey results for local restaurants.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们甚至能够开会之前，我们需要使用基本的间谍技巧来定位当地餐馆的健康码调查结果。
- en: 'We''ll create a Python application to combine many things to sort through the
    results. We''ll perform the following steps:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Python应用程序来结合许多东西以筛选结果。我们将执行以下步骤：
- en: We'll start with the restaurant health score information.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从餐馆健康评分信息开始。
- en: We need to geocode the restaurant addresses if it hasn't been done already.
    In some cases, geocoding is done for us. In other cases, we'll be using a web
    service for this.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未完成，我们需要对餐馆地址进行地理编码。在某些情况下，地理编码已经为我们完成。在其他情况下，我们将使用网络服务来完成这项工作。
- en: We need to filter and organize restaurants by good scores. We'll also need to
    use our `haversine()` function to compute the distance from our base.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要根据良好的评分过滤和组织餐厅。我们还需要使用我们的`haversine()`函数来计算我们基地的距离。
- en: Finally, we need to communicate this to our network, ideally using a short NAC
    code embedded within an image that we post to a social media site. See [Chapter
    3](ch03.html "Chapter 3. Encoding Secret Messages with Steganography"), *Encoding
    Secret Messages with Steganography*, for details on this final step.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将这一点传达给我们的网络，理想情况下是使用嵌入在我们发布到社交媒体网站上的图片中的简短NAC代码。参见[第3章](ch03.html "第3章。使用隐写术编码秘密信息")，*使用隐写术编码秘密信息*，了解这一最终步骤的详细信息。
- en: In many cities, the health code data is available online. A careful search will
    reveal a useful dataset. In other cities, the health inspection data isn't readily
    available online. We might have to dig considerably deep to track down even a
    few restaurants near our base of operations.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多城市，健康代码数据可在网上找到。仔细搜索将揭示一个有用的数据集。在其他城市，健康检查数据可能不容易在网上找到。我们可能需要深入挖掘以追踪我们运营基地附近的一些餐厅。
- en: 'Some cities use **Yelp** to publicize restaurant health code inspection data.
    We can read about the YELP API to search for restaurants on the following link:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一些城市使用**Yelp**来公布餐厅健康代码检查数据。我们可以在以下链接上阅读关于YELP API的内容以搜索餐厅：
- en: '[http://www.yelp.com/developers/documentation](http://www.yelp.com/developers/documentation)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.yelp.com/developers/documentation](http://www.yelp.com/developers/documentation)'
- en: We might also find some useful data on InfoChimps at [http://www.infochimps.com/tags/restaurant](http://www.infochimps.com/tags/restaurant).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能在InfoChimps上找到一些有用的数据，[http://www.infochimps.com/tags/restaurant](http://www.infochimps.com/tags/restaurant)。
- en: One complexity we often encounter is the use of HTML-based APIs for this kind
    of information. This is not intentional obfuscation, but the use of HTML complicates
    analysis of the data. Parsing HTML to extract meaningful information isn't easy;
    we'll need an extra library to handle this.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常遇到的一个复杂性是使用基于HTML的API来处理这类信息。这并非有意混淆，但HTML的使用使得数据分析变得复杂。解析HTML以提取有意义的信息并不容易；我们需要额外的库来处理这一点。
- en: 'We''ll look at two approaches: good, clean data and more complex HTML data
    parsing. In both cases, we need to create a Python object that acts as a container
    for a collection of attributes. First, we''ll divert to look at the `SimpleNamespace`
    class. Then, we''ll use this to collect information.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨两种方法：良好的、干净的数据和更复杂的HTML数据解析。在两种情况下，我们需要创建一个Python对象，作为属性集合的容器。首先，我们将转向查看`SimpleNamespace`类。然后，我们将使用这个类来收集信息。
- en: Creating simple Python objects
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建简单的Python对象
- en: 'We have a wide variety of ways to define our own Python objects. We can use
    the central built-in types such as dict to define an object that has a collection
    of attribute values. When looking at information for a restaurant, we could use
    something like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种方式来定义自己的Python对象。我们可以使用内置的中心类型，如dict，来定义一个具有属性值的集合的对象。在查看餐厅信息时，我们可以使用类似以下的方式：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since this is a mutable object, we can add attribute values and change the
    values of the existing attributes. The syntax is a bit *clunky*, though. Here''s
    what an update to this object looks like:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个可变对象，我们可以添加属性值并更改现有属性值。虽然语法有点笨拙，但以下是更新此对象的方式：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The extra `[]` brackets and `''` characters seem needless. We'd like to have
    a notation that's a little cleaner than this very general key-value syntax used
    for dictionaries.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的`[]`方括号和`''`引号似乎是不必要的。我们希望有一个比这种非常通用的字典键值语法稍微干净一点的符号。
- en: 'One common solution is to use a proper class definition. The syntax looks like
    this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的解决方案是使用合适的类定义。其语法看起来像这样：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We've defined a class with an initialization method, `__init__()`. The name
    of the initialization method is special, and only this name can be used. When
    the object is built, the initialization method is evaluated to assign initial
    values to the attributes of the object.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个具有初始化方法`__init__()`的类。初始化方法的名字是特殊的，只能使用这个名字。当对象被创建时，初始化方法会被评估以分配初始值给对象的属性。
- en: 'This allows us to create an object more succinctly:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够更简洁地创建对象：
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We've used explicit keyword arguments. The use of `name=` and `address=` isn't
    *required*. However, as class definitions become more complex, it's often more
    flexible and more clear to use keyword argument values.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了显式的关键字参数。使用`name=`和`address=`不是*必需的*。然而，随着类定义变得更加复杂，使用关键字参数值通常更加灵活和清晰。
- en: 'We can update the object nicely too, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以很好地更新对象，如下所示：
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This works out best when we have a lot of unique processing that is bound to
    each object. In this case, we don't actually have any processing to associate
    with the attributes; we just want to collect those attributes in a tidy capsule.
    The formal class definition is too much overhead for such a simple problem.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有很多与每个对象绑定的独特处理时，这效果最好。在这种情况下，我们实际上没有与属性关联的处理；我们只是想将这些属性收集在一个整洁的胶囊中。对于这样一个简单的问题，正式的类定义是过多的开销。
- en: 'Python also gives us a very flexible structure called a **namespace**. This
    is a mutable object that we can access using simple attribute names, as shown
    in the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Python还给我们提供了一个非常灵活的结构，称为**命名空间**。这是一个可变对象，我们可以使用简单的属性名称来访问它，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The syntax to create a namespace *must* use keyword arguments (`name=''The
    Name''`). Once we''ve created this object, we can update it using a pleasant attribute
    access, as shown in the following snippet:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命名空间时*必须*使用关键字参数（`name='The Name'`）。一旦我们创建了此对象，我们可以使用以下代码片段中所示愉快的方法来更新它：
- en: '[PRE49]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `SimpleNamespace` class gives us a way to build an object that contains
    a number of individual attribute values.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleNamespace`类给我们提供了一个构建包含多个单独属性值的对象的方法。'
- en: 'We can also create a namespace from a dictionary using Python''s `**` notation.
    Here''s an example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Python的`**`符号从字典创建命名空间。以下是一个示例：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `**` notation tells Python that a dictionary object contains keyword arguments
    for the function. The dictionary keys are the parameter names. This allows us
    to build a dictionary object and then use it as the arguments to a function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`**`符号告诉Python字典对象包含函数的关键字参数。字典键是参数名称。这允许我们构建一个字典对象，然后将其用作函数的参数。'
- en: Recall that JSON tends to encode complex data structures as a dictionary. Using
    this `**` technique, we can transform a JSON dictionary into `SimpleNamespace`,
    and replace the clunky `object['key']` notation with a cleaner `object.key` notation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，JSON倾向于将复杂的数据结构编码为字典。使用这个`**`技术，我们可以将JSON字典转换为`SimpleNamespace`，并用更干净的`object.key`表示法替换笨拙的`object['key']`表示法。
- en: Working with HTML web services – tools
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与HTML网络服务一起工作 – 工具
- en: In some cases, the data we want is tied up in HTML websites. The City of Norfolk,
    for example, relies on the State of Virginia's VDH health portal to store its
    restaurant health code inspection data.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们想要的数据绑定在HTML网站上。例如，诺福克市依赖弗吉尼亚州的VDH健康门户来存储其餐馆健康代码检查数据。
- en: In order to make sense of the intelligence encoded in the HTML notation on the
    WWW, we need to be able to parse the HTML markup that surrounds the data. Our
    job is greatly simplified by the use of special higher-powered weaponry; in this
    case, BeautifulSoup.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解在万维网上的HTML表示法中编码的智能，我们需要能够解析围绕数据的HTML标记。使用特殊的高能武器，在这个案例中是BeautifulSoup，我们的工作大大简化了。
- en: Start with [https://pypi.python.org/pypi/beautifulsoup4/4.3.2](https://pypi.python.org/pypi/beautifulsoup4/4.3.2)
    or [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://pypi.python.org/pypi/beautifulsoup4/4.3.2](https://pypi.python.org/pypi/beautifulsoup4/4.3.2)或[http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/)开始。
- en: If we have Easy Install (or PIP), we can use these tools to install BeautifulSoup.
    Back in [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our Espionage
    Toolkit*, we should have installed one (or both) of these tools to install more
    tools.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有Easy Install（或PIP），我们可以使用这些工具来安装BeautifulSoup。在[第1章](ch01.html "第1章。我们的间谍工具包")
    *我们的间谍工具包*中，我们应该已经安装了其中一个（或两个）这些工具来安装更多工具。
- en: 'We can use Easy Install to install BeautifulSoup like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Easy Install来安装BeautifulSoup，如下所示：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Mac OS X and GNU/Linux users will need to use the `sudo` command. Windows users
    won't use the `sudo` command.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Mac OS X和GNU/Linux用户需要使用`sudo`命令。Windows用户不需要使用`sudo`命令。
- en: Once we have BeautifulSoup, we can use it to parse the HTML code looking for
    specific facts buried in an otherwise cryptic jumble of HTML tags.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了BeautifulSoup，我们就可以用它来解析HTML代码，寻找隐藏在复杂的HTML标签混乱中的特定事实。
- en: Before we can go on, you'll need to read the quickstart documentation and bring
    yourself up to speed on BeautifulSoup. Once you've done that, we'll move to extracting
    data from HTML web pages.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你需要阅读快速入门文档，并熟悉 BeautifulSoup。一旦你完成了这些，我们将转向从 HTML 网页中提取数据。
- en: 'Start with [http://www.crummy.com/software/BeautifulSoup/bs4/doc/#quick-start](http://www.crummy.com/software/BeautifulSoup/bs4/doc/     #quick-start).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '从 [http://www.crummy.com/software/BeautifulSoup/bs4/doc/#quick-start](http://www.crummy.com/software/BeautifulSoup/bs4/doc/     #quick-start) 开始。'
- en: An alternative tool is **scrapy**. For information see [http://scrapy.org](http://scrapy.org).
    Also, read *Instant Scrapy Web Mining and Scraping*, *Travis Briggs*, *Packt Publishing*,
    for details on using this tool. Unfortunately, as of this writing, scrapy is focused
    on Python 2, not Python 3.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个工具是 **scrapy**。更多信息请参阅 [http://scrapy.org](http://scrapy.org)。此外，阅读 *Instant
    Scrapy Web Mining and Scraping*，作者 *Travis Briggs*，由 *Packt Publishing* 出版，以了解使用此工具的详细信息。不幸的是，截至本文撰写时，scrapy
    专注于 Python 2，而不是 Python 3。
- en: Working with HTML web services – getting the page
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 HTML 网络服务一起工作 – 获取页面
- en: In the case of VDH health data for the City of Norfolk, the HTML scraping is
    reasonably simple. We can leverage the strengths of BeautifulSoup to dig into
    the HTML page very nicely.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在诺福克市 VDH 健康数据的情况下，HTML 抓取相对简单。我们可以利用 BeautifulSoup 的优势，非常优雅地深入 HTML 页面。
- en: Once we've created a BeautifulSoup object from the HTML page, we will have an
    elegant technique to navigate down through the hierarchy of the HTML tags. Each
    HTML tag name (`html`, `body`, and so on) is also a BeautifulSoup query that locates
    the first instance of that tag.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从 HTML 页面创建了 BeautifulSoup 对象，我们将拥有一种优雅的技术来遍历 HTML 标签的层次结构。每个 HTML 标签名（`html`、`body`
    等）也是 BeautifulSoup 查询，用于定位该标签的第一个实例。
- en: An expression such as `soup.html.body.table` can locate the first `<table>`
    in the HTML `<body>` tag. In the case of the VDH restaurant data, that's precisely
    the data we want.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`soup.html.body.table` 这样的表达式可以定位 HTML `<body>` 标签中的第一个 `<table>`。在 VDH 餐厅数据的情况下，这正是我们想要的数据。
- en: Once we've found the table, we need to extract the rows. The HTML tag for each
    row is `<tr>` and we can use the BeautifulSoup `table.find_all("tr")` expression
    to locate all rows within a given `<table>` tag. Each tag's text is an attribute,
    `.text`. If the tag has attributes, we can treat the tag as if it's a dictionary
    to extract the attribute values.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了表格，我们需要提取行。每行的 HTML 标签是 `<tr>`，我们可以使用 BeautifulSoup 的 `table.find_all("tr")`
    表达式来定位给定 `<table>` 标签内的所有行。每个标签的文本是一个属性，`.text`。如果标签有属性，我们可以将标签视为一个字典来提取属性值。
- en: 'We''ll break down the processing of the VDH restaurant data into two parts:
    the web services query that builds Soup from HTML and the HTML parsing to gather
    restaurant information.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 VDH 餐厅数据的处理分解为两部分：构建 Soup 的网络服务查询和 HTML 解析以收集餐厅信息。
- en: 'Here''s the first part, which is getting the raw BeautifulSoup object:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是第一部分，即获取原始 BeautifulSoup 对象：
- en: '[PRE52]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This repeats the web services queries we''ve seen before. We''ve separated
    three things here: the `scheme_host` string, the `path` string, and `query`. The
    reason for this is that our overall script will be using the `scheme_host` with
    other paths. And we''ll be plugging in lots of different query data.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这重复了我们之前看到的网络服务查询。在这里，我们区分了三件事：`scheme_host` 字符串、`path` 字符串和 `query`。这样做的原因是，我们的整体脚本将使用
    `scheme_host` 与其他路径一起使用。我们还将插入大量不同的查询数据。
- en: 'For this basic `food_list_by_name` query, we''ve built a form that will get
    400 restaurant inspections. The `RestrictToCategory` field in the form has a magical
    key that we must provide to get the Norfolk restaurants. We found this via a basic
    web espionage technique: we poked around on the website and checked the URLs used
    when we clicked on each of the links. We also used the Developer mode of Safari
    to explore the page source.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个基本的 `food_list_by_name` 查询，我们构建了一个表单，将获取 400 家餐厅的检查结果。表单中的 `RestrictToCategory`
    字段有一个神奇的关键字，我们必须提供这个关键字才能获取诺福克餐厅。我们通过基本的网络间谍技术找到了这个关键字：我们在网站上四处浏览，并检查了我们点击每个链接时使用的
    URL。我们还使用了 Safari 的开发者模式来探索页面源代码。
- en: In the long run, we want all of the inspections. To get started, we've limited
    ourselves to 400 so that we don't spend too long waiting to run a test of our
    script.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，我们想要所有检查结果。为了开始，我们限制了自己只获取 400 条，这样我们就不需要花费太多时间等待脚本测试。
- en: The response object was used by BeautifulSoup to create an internal representation
    of the web page. We assigned this to the `soup` variable and returned it as the
    result of the function.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象被BeautifulSoup用于创建网页的内部表示。我们将它分配给`soup`变量，并将其作为函数的结果返回。
- en: In addition to returning the `soup` object, it can also be instructive to print
    it. It's quite a big pile of HTML. We'll need to parse this to get the interesting
    details away from the markup.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回`soup`对象外，打印它也可能很有帮助。这是一大堆HTML。我们需要解析它以从标记中提取有趣的细节。
- en: Working with HTML web services – parsing a table
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与HTML网络服务一起工作 - 解析表格
- en: Once we have a page of HTML information parsed into a BeautifulSoup object,
    we can examine the details of that page. Here's a function that will locate the
    table of restaurant inspection details buried inside the page.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将一页HTML信息解析成BeautifulSoup对象，我们就可以检查该页的细节。这里有一个函数，可以找到页面中隐藏的餐厅检查详情表。
- en: 'We''ll use a generator function to yield each individual row of the table,
    as shown in the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用生成器函数来逐行生成表格中的每一行，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that this function begins with a triple-quoted string. This is a *docstring*
    and it provides documentation about the function. Good Python style insists on
    a docstring in every function. The Python help system will display the docstrings
    for functions, modules, and classes. We've omitted them to save space. Here, we
    included it because the results of this particular iterator can be quite confusing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个函数以三引号字符串开始。这是一个*文档字符串*，它提供了关于函数的文档。良好的Python风格要求每个函数都有一个文档字符串。Python帮助系统将显示函数、模块和类的文档字符串。我们省略了它们以节省空间。在这里，我们包括了它，因为这个特定迭代器的结果可能相当令人困惑。
- en: This function requires a parsed Soup object. The function uses simple tag navigation
    to locate the first `<table>` tag in the HTML `<body>` tag. It then uses the table's
    `find_all()` method to locate all of the rows within that table.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要一个解析后的Soup对象。该函数使用简单的标签导航来定位HTML `<body>` 标签中的第一个`<table>`标签。然后它使用表的`find_all()`方法来定位该表中的所有行。
- en: For each row, there are two pieces of processing. First, a generator expression
    is used to find all the `<td>` tags within that row. Each `<td>` tag's text is
    stripped of excess white space and the collection forms a list of cell values.
    In some cases, this kind of processing is sufficient.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行，有两个处理步骤。首先，使用生成器表达式找到该行内的所有`<td>`标签。每个`<td>`标签的文本去除了多余的空白字符，并形成一个单元格值的列表。在某些情况下，这种处理就足够了。
- en: In this case, however, we also need to decode an HTML `<a>` tag, which has a
    reference to the details for a given restaurant. We use a second `find_all("td")`
    expression to examine each column again. Within each column, we check for the
    presence of an `<a>` tag using a simple `if td.a:` loop. If there is an `<a>`
    tag, we can get the value of the `href` attribute on that tag. When looking at
    the source HTML, this is the value inside the quotes of `<a href="">`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，我们还需要解码一个HTML `<a>` 标签，该标签包含对给定餐厅详细信息的引用。我们使用第二个`find_all("td")`表达式再次检查每一列。在每一列中，我们使用简单的`if
    td.a:`循环检查是否存在`<a>`标签。如果存在`<a>`标签，我们可以获取该标签上`href`属性的值。当查看源HTML时，这是`<a href="">`引号内的值。
- en: This value of an HTML `href` attribute is a URL. We don't actually need the
    whole URL. We only need the query string within the URL. We've used the `urllib.parse.urlparse()`
    function to extract the various bits and pieces of the URL. The value of the `url.query`
    attribute is just the query string, after the `?`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: HTML `href` 属性的此值是一个URL。我们实际上不需要整个URL。我们只需要URL中的查询字符串。我们使用了`urllib.parse.urlparse()`函数来提取URL的各个部分。`url.query`属性的值只是`?`之后的查询字符串。
- en: It turns out, we don't even want the entire query string; we only want the value
    for the key `RestrictToCategory`. We can parse the query string with `urllib.parse.parse_qs()`
    to get a form-like dictionary, which we assigned to the variable `form`. This
    function is the inverse of `urllib.parse.urlencode()`. The dictionary built by
    the `parse_qs()` function associates each key with a list of values. We only want
    the first value, so we use `form['RestrictToCategory'][0]` to get the key required
    for a restaurant.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们甚至不需要整个查询字符串；我们只需要`RestrictToCategory`键的值。我们可以使用`urllib.parse.parse_qs()`来解析查询字符串，以获取类似表单的字典，并将其分配给变量`form`。这个函数是`urllib.parse.urlencode()`的逆函数。`parse_qs()`函数构建的字典将每个键与一个值列表关联。我们只想获取第一个值，因此使用`form['RestrictToCategory'][0]`来获取所需的餐厅键。
- en: 'Since this `food_table_iter ()` function is a generator, it must be used with
    a `for` statement or another generator function. We can use this function with
    a `for` statement as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个 `food_table_iter()` 函数是一个生成器，所以必须使用 `for` 语句或另一个生成器函数来使用它。我们可以使用 `for`
    语句如下：
- en: '[PRE54]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This prints each row of data from the HTML table. It starts like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印 HTML 表格中的每一行数据。它开始如下：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This goes on for 400 locations.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这将继续进行 400 个位置。
- en: The results are unsatisfying because each row is a flat list of attributes.
    The name is in `row[0]` and the address in `row[2]`. This kind of reference to
    columns by position can be obscure. It would be much nicer to have named attributes.
    If we convert the results to a `SimpleNamespace` object, we can then use the `row.name`
    and `row.address` syntax.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并不令人满意，因为每一行都是一个属性的单层列表。名称在 `row[0]` 中，地址在 `row[2]` 中。这种通过位置引用列的方式可能很模糊。如果我们将结果转换为
    `SimpleNamespace` 对象，我们就可以使用 `row.name` 和 `row.address` 语法。
- en: Making a simple Python object from columns of data
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据列创建一个简单的 Python 对象
- en: 'We really want to work with an object that has easy-to-remember attribute names
    and not a sequence of anonymous column names. Here''s a generator function that
    will build a `SimpleNamespace` object from a sequence of values produced by a
    function such as the `food_table_iter()` function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是一个具有易于记忆的属性名的对象，而不是一系列匿名的列名。这里有一个生成器函数，它将从函数（如 `food_table_iter()` 函数）产生的值序列中构建
    `SimpleNamespace` 对象：
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This function's argument must be an iterator like `food_table_iter(get_food_list_by_name())`.
    The function uses `next(table_iter)` to grab the first row, since that's only
    going to be a bunch of column titles. We'll assert that the column titles really
    are the standard column titles in the VDH data. If the assertion ever fails, it's
    a hint that VDH web data has changed.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的参数必须是一个迭代器，如 `food_table_iter(get_food_list_by_name())`。该函数使用 `next(table_iter)`
    来获取第一行，因为那将只是一堆列标题。我们将断言这些列标题确实是 VDH 数据中的标准列标题。如果断言失败，这可能意味着 VDH 网络数据已更改。
- en: For every row after the first row, we build a `SimpleNamespace` object by taking
    the specific columns from each row and assigning them nice names.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一行之后的每一行，我们通过从每一行中获取特定列并将它们分配给好的名称来构建一个 `SimpleNamespace` 对象。
- en: 'We can use this function as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用这个函数：
- en: '[PRE57]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The processing can now use nice attribute names, for example, `business.name`,
    to refer to the data we extracted from the HTML page. This makes the rest of the
    programming meaningful and clear.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 处理现在可以使用好的属性名，例如，`business.name`，来引用我们从 HTML 页面提取的数据。这使得其余的编程更有意义和清晰。
- en: What's also important is that we've combined two generator functions. The `food_table_iter()`
    function will yield small lists built from HTML table rows. The `food_row_iter()`
    function expects a sequence of lists that can be iterated, and will build `SimpleNamespace`
    objects from that sequence of lists. This defines a kind of composite processing
    pipeline built from smaller steps. Each row of the HTML table that starts in `food_table_iter()`
    is touched by `food_row_iter()` and winds up being processed by the `print()`
    function.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 也很重要的是，我们已经结合了两个生成器函数。`food_table_iter()` 函数将生成由 HTML 表格行构建的小列表。`food_row_iter()`
    函数期望一个可迭代的列表序列，并将从该列表序列中构建 `SimpleNamespace` 对象。这定义了一种由较小步骤构建的复合处理管道。从 `food_table_iter()`
    开始的 HTML 表格的每一行都会被 `food_row_iter()` 触及，并最终由 `print()` 函数处理。
- en: Enriching Python objects with geocodes
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用地理编码丰富 Python 对象
- en: The Norfolk data we've gotten so far is only a list of restaurants. We still
    neither have inspection scores, nor do we have useful geocodes. We need to add
    these details to each business that we found in the initial list. This means making
    two more RESTful web services requests for each individual business.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止得到的诺福克数据只是一个餐馆列表。我们还没有检查分数，也没有有用的地理编码。我们需要将这些详细信息添加到我们在初始列表中找到的每个企业。这意味着为每个企业再进行两次
    RESTful 网络服务请求。
- en: 'The geocoding is relatively easy. We can use a simple request and update the
    `SimpleNamespace` object that we''re using to model each business. The function
    looks like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 地理编码相对简单。我们可以使用一个简单的请求并更新我们用来模拟每个企业的 `SimpleNamespace` 对象。函数看起来像这样：
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We're using the Google geocoding API that we used earlier. We've made a few
    modifications. First, the data in the `form` variable has the `business.address`
    attribute from the `SimpleNamespace` object. We've had to add the city and state
    information, since that's not provided in the VDH address.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用之前使用过的 Google 地理编码 API。我们进行了一些修改。首先，`form` 变量中的数据包含来自 `SimpleNamespace`
    对象的 `business.address` 属性。由于 VDH 地址中没有提供城市和州信息，我们不得不添加这些信息。
- en: 'As with previous examples, we took only the first location of the response
    list with `response[''results''][0][''geometry''][''location'']`, which is a small
    dictionary object with two keys: `lat` and `lon`. We''ve updated the namespace
    that represents our business by setting two more attributes, `business.latitude`
    and `business.longitude` from the values in this small dictionary.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们只取了响应列表中的第一个位置，即 `response['results'][0]['geometry']['location']`，这是一个包含两个键的字典对象：`lat`
    和 `lon`。我们通过设置这个小型字典中的值来更新代表我们业务的命名空间，添加了两个更多属性，`business.latitude` 和 `business.longitude`。
- en: The namespace object is mutable, so this function will update the object referred
    to by the variable `business`. We also returned the object. The `return` statement
    is not necessary, but sometimes it's handy because it allows us to create a fluent
    API for a sequence of functions.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间对象是可变的，因此这个函数将更新由变量 `business` 指向的对象。我们还返回了这个对象。`return` 语句不是必需的，但有时它很有用，因为它允许我们为一系列函数创建流畅的
    API。
- en: Enriching Python objects with health scores
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用健康评分丰富 Python 对象
- en: 'The bad news is that getting health scoring details requires yet more HTML
    parsing. The good news is that the details are placed in an easy-to-locate HTML
    `<table>` tag. We''ll break this process into two functions: a web service request
    to get the BeautifulSoup object and more HTML parsing to explore that Soup.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是获取健康评分详情还需要更多的 HTML 解析。好消息是这些详情被放置在一个易于定位的 HTML `<table>` 标签中。我们将这个过程分为两个函数：一个用于获取
    BeautifulSoup 对象的 Web 服务请求和更多的 HTML 解析来探索这个 Soup。
- en: 'Here''s the URL request. This requires the category key that we parsed from
    the `<a>` tag in the `food_table_iter()` function shown previously:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 URL 请求。这需要我们从之前显示的 `food_table_iter()` 函数中的 `<a>` 标签解析出的类别键：
- en: '[PRE59]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This request, like other HTML requests, builds a query string, opens the URL
    response object, and parses it to create a `BeautifulSoup` object. We're only
    interested in the `soup` instance. We return this value for use with HTML processing.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求，就像其他 HTML 请求一样，构建一个查询字符串，打开 URL 响应对象，并解析它以创建一个 `BeautifulSoup` 对象。我们只对
    `soup` 实例感兴趣。我们返回这个值以用于 HTML 处理。
- en: Also, note that part of the path, `Norolk_Website.nsf`, has a spelling error.
    Secret agents in the field are responsible for finding information in spite of
    these kind of problems.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意路径的一部分 `Norolk_Website.nsf` 存在拼写错误。现场的秘密特工负责在存在这类问题的前提下寻找信息。
- en: 'We''ll use this in a function that updates the `SimpleNamespace` object that
    we''re using to model each business. The data extraction function looks like this:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个函数来更新我们用来模拟每个业务的 `SimpleNamespace` 对象。数据提取函数看起来像这样：
- en: '[PRE60]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This function gets the `BeautifulSoup` object for a specific business. Given
    that Soup, it navigates to the first `<h2>` tag within the `<body>` tag. This
    should repeat the business name. We've updated the `business` object with this
    second copy of the name.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数获取特定业务的 `BeautifulSoup` 对象。鉴于 Soup，它导航到 `<body>` 标签内的第一个 `<h2>` 标签。这应该重复业务名称。我们使用这个名称的第二个副本更新了
    `business` 对象。
- en: 'This function also navigates to the first `<table>` tag within the `<body>`
    tag via the `soup.body.table` expression. The HTML table has two columns: the
    left column contains a label and the right column contains the value.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数还通过 `soup.body.table` 表达式导航到 `<body>` 标签内的第一个 `<table>` 标签。HTML 表格有两列：左列包含标签，右列包含值。
- en: To parse this kind of table, we stepped through each row using `table.find_all("tr")`.
    For each row, we built a list from `row.find_all( "td" )`. The first item in this
    list is the `<td>` tag that contains a name. The second item is the `<td>` tag
    that contains a value.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析这种表格，我们使用 `table.find_all("tr")` 遍历每一行。对于每一行，我们从一个 `row.find_all( "td" )`
    构建一个列表。这个列表中的第一个项目是包含名称的 `<td>` 标签。第二个项目是包含值的 `<td>` 标签。
- en: 'We can use a dictionary, `vdh_detail_translate`, to translate the names in
    the left column to a better looking Python attribute name, as shown in the following
    code:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个字典 `vdh_detail_translate` 来将左列中的名称翻译成更好的 Python 属性名称，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Using a dictionary like this allows us to use the expression `vdh_detail_translate[name]`
    to locate a pleasant attribute name (such as `core_item`) instead of the long
    string that's displayed in the original HTML.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的字典，我们可以使用表达式`vdh_detail_translate[name]`来定位一个愉快的属性名（如`core_item`），而不是在原始HTML中显示的长字符串。
- en: 'We need to look closely at the use of the `setattr()` function that''s used
    to update the `business` namespace:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要仔细查看用于更新`business`命名空间的`setattr()`函数的使用：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In other functions, we've used a simple assignment statement such as `business.attribute=
    value` to set an attribute of the namespace object. Implicitly, the simple assignment
    statement actually means `setattr( business, 'attribute', value )`. We can think
    of `setattr(object, attribute_string, value)` as the reason why Python implements
    the simple `variable.attribute= value` assignment statement.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他函数中，我们使用了一个简单的赋值语句，如`business.attribute= value`来设置命名空间对象的属性。隐式地，简单的赋值语句实际上意味着`setattr(business,
    'attribute', value)`。我们可以将`setattr(object, attribute_string, value)`视为Python实现简单的`variable.attribute=
    value`赋值语句的原因。
- en: In this function, we can't use a simple assignment statement, because the attribute
    name is a string that's looked up via a translation. We can use the `setattr()`
    function to update the business object using the attribute name string computed
    from `vdh_detail_translate[name]`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们不能使用简单的赋值语句，因为属性名是通过翻译查找的字符串。我们可以使用`setattr()`函数，通过从`vdh_detail_translate[name]`计算出的属性名字符串来更新业务对象。
- en: Combining the pieces and parts
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合各个部分
- en: 'We can now look at the real question: finding high-quality restaurants. We
    can build a composite function that combines our previous functions. This can
    become a generator function that yields all of the details in a sequence of namespace
    objects, as shown in the following code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看真正的问题：寻找高质量的餐厅。我们可以构建一个组合函数，结合我们之前的功能。这可以成为一个生成器函数，按顺序生成命名空间对象的详细信息，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This will build a small object, `base`, to describe our base. The object will
    start with just the `address` attribute. After we apply the `geocode_detail()`
    function, it will also have a latitude and longitude.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建一个小的对象`base`来描述我们的基地。该对象最初只有`address`属性。在应用`geocode_detail()`函数后，它还将具有纬度和经度。
- en: 'The `print()` function will produce a line that looks like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`函数将生成如下所示的行：'
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `get_food_list_by_name()` function will get a batch of restaurants. We use
    `food_table_iter()` to get the HTML table, and `food_row_iter()` to build individual
    `SimpleNamespace` objects from the HTML table. We then do some updates on each
    of those `SimpleNamespace` objects to provide restaurant inspection results and
    geocode information. We update the object yet again to add the distance from our
    base to the restaurant.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_food_list_by_name()`函数将获取一批餐厅。我们使用`food_table_iter()`获取HTML表格，并使用`food_row_iter()`从HTML表格构建单个`SimpleNamespace`对象。然后我们对这些`SimpleNamespace`对象进行一些更新，以提供餐厅检查结果和地理编码信息。我们再次更新对象，以添加从我们的基地到餐厅的距离。'
- en: Finally, we yield the richly detailed namespace object that represents everything
    we need to know about a business.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回一个详细丰富的命名空间对象，它代表了我们了解一个企业所需知道的一切。
- en: 'Given this sequence of objects, we can apply some filters to exclude places
    over .75 miles away or with more than one problem reported:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个对象序列，我们可以应用一些过滤器来排除距离超过0.75英里或报告问题超过一个的地方：
- en: '[PRE65]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This script will apply four different filters to each response. If the business,
    for example, is too far away, the `continue` statement will end the processing
    of this item: the `for` statement will advance to the next. If the business has
    too many items, the `continue` statements will reject this business and advance
    to the next item. Only a business that passes all four tests will be printed.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将对每个响应应用四个不同的过滤器。例如，如果业务太远，`continue`语句将结束此项目的处理：`for`语句将前进到下一个。如果业务有太多项目，`continue`语句将拒绝此业务并前进到下一个项目。只有通过所有四个测试的业务才会被打印。
- en: Note that we've inefficiently processed each business through the `geocode_detail()`
    and `inspection_detail()` functions. A more efficient algorithm would apply the
    distance filter early in the processing. If we immediately reject places that
    are too far away, we will only need to get detailed restaurant health data for
    places that are close enough.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过 `geocode_detail()` 和 `inspection_detail()` 函数低效地处理了每个商业。一个更有效的算法会在处理早期应用距离过滤器。如果我们立即拒绝距离太远的地方，我们只需要为足够近的地方获取详细的餐厅健康数据。
- en: The important thing about this sequence of examples is that we integrated data
    from two different web services and folded them in our own value-added intelligence
    processing.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子序列的重要之处在于，我们集成了来自两个不同网络服务的数据，并将它们整合到我们自己的增值智能处理中。
- en: Working with clean data portals
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与干净的数据门户合作
- en: 'A good example of a clean data portal is the City of Chicago. We can get the
    restaurant inspection data with a simple URL:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁数据门户的一个好例子是芝加哥市。我们可以通过简单的 URL 获取餐厅检查数据：
- en: '[https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.json?accessType=DOWNLOAD](https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.json?accessType=DOWNLOAD)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.json?accessType=DOWNLOAD](https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.json?accessType=DOWNLOAD)'
- en: This will download all the restaurant inspection information in a tidy, easy-to-parse,
    JSON document. The only problem is the size. It has over 83,000 inspections and
    takes a very long time to download. If we apply a filter (for instance, only inspects
    done this year), we can cut the document down to a manageable size. More details
    on the various kinds of filters supported can be found at [http://dev.socrata.com/docs/queries.html](http://dev.socrata.com/docs/queries.html).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载所有餐厅检查信息，以整洁、易于解析的 JSON 文档形式。唯一的问题是大小。它包含超过 83,000 次检查，下载时间非常长。如果我们应用过滤器（例如，只检查今年完成的），我们可以将文档缩减到可管理的尺寸。有关支持的各类过滤器的更多详细信息，请参阅[http://dev.socrata.com/docs/queries.html](http://dev.socrata.com/docs/queries.html)。
- en: There's a lot of sophistication available. We'll define a simple filter based
    on the inspection date to limit ourselves to a subset of the available restaurant
    inspections.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的复杂性相当多。我们将基于检查日期定义一个简单的过滤器，以限制自己只查看可用的餐厅检查子集。
- en: 'A function to get the data looks like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据的函数看起来是这样的：
- en: '[PRE66]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `schem_netloc_path` variable includes two interesting details in path. `4ijn-s7e5`
    is the internal identity of the dataset we're looking for and `rows.json` specifies
    the format we want the data in.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`schem_netloc_path` 变量在路径中包含两个有趣的细节。`4ijn-s7e5` 是我们正在寻找的数据集的内部标识符，而 `rows.json`
    指定了我们想要的数据格式。'
- en: The form we built includes a `$where` clause that will cut down on the volume
    of data to just the recent inspection reports. The Socrata API pages show us that
    we have a great deal of flexibility here.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的表单包括一个 `$where` 子句，这将减少数据量，仅保留最近的检查报告。Socrata API 页面显示我们在这里有很大的灵活性。
- en: As with other web services requests, we created a query and made the request
    using the `urllib.request.urlopen()` function. We opened an output file named
    `chicago_data.json` and wrote the document to that file for further processing.
    This saves us from having to retrieve the data repeatedly since it doesn't change
    too quickly.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他网络服务请求一样，我们创建了一个查询，并使用 `urllib.request.urlopen()` 函数发出请求。我们打开了一个名为 `chicago_data.json`
    的输出文件，并将文档写入该文件以进行进一步处理。这样我们就无需反复检索数据，因为它变化并不快。
- en: We've done the processing via nested `with` statements to be assured that the
    files are closed and the network resources are properly released.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过嵌套的 `with` 语句进行处理，以确保文件被关闭并且网络资源得到适当释放。
- en: Making a simple Python object from a JSON document
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 JSON 文档创建简单的 Python 对象
- en: The JSON document contains lots of individual dict objects. While a dict is
    a handy general-purpose structure, the syntax is a bit clunky. Having to use `object['some_key']`
    is awkward. It's nicer to work with `SimpleNamespace` objects and use pleasant
    attribute names. Using `object.some_key` is nicer.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 文档包含大量的单个字典对象。虽然字典是一个方便的通用结构，但其语法有点笨拙。必须使用 `object['some_key']` 是尴尬的。使用
    `SimpleNamespace` 对象和愉快的属性名称会更方便。使用 `object.some_key` 会更愉快。
- en: 'Here''s a function that will iterate through the massive JSON document with
    all of the inspection details:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个函数，它将遍历包含所有检查详细信息的庞大 JSON 文档：
- en: '[PRE67]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We've built a `SimpleNamespace` object from each individual row that was in
    the source data. The JSON document's data, in `inspections["data"]`, is a list
    of lists. It's rather hard to interpret because we need to know the position of
    each relevant field.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从源数据中的每一行构建了一个`SimpleNamespace`对象。JSON文档的数据，在`inspections["data"]`中，是一个列表的列表。它很难解释，因为我们需要知道每个相关字段的定位。
- en: We created a list of headings based on the field names we found in `inspections["meta"]["view"]["columns"]`.
    The field names seem to all be valid Python variable names and will make good
    Python attribute names in a `SimpleNamespace` object.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据在`inspections["meta"]["view"]["columns"]`中找到的字段名称创建了一个标题列表。字段名称似乎都是有效的Python变量名称，并且将作为`SimpleNamespace`对象中的良好Python属性名称。
- en: Given this list of headings, we can then use the `zip()` function to interleave
    headings and data from each row that we find. This sequence of two-tuples can
    be used to create a dictionary by employing `dict( zip( headings, row ) )`. The
    dictionary can then be used to build the `SimpleNamespace` object.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个标题列表，我们然后可以使用`zip()`函数来交错标题和每行找到的数据。这个由两个元组组成的序列可以通过使用`dict(zip(headings,
    row))`来创建一个字典。然后可以使用这个字典来构建`SimpleNamespace`对象。
- en: 'The `**` syntax specifies that the items in the dictionary will become individual
    keyword parameters for `SimpleNamespace`. This will elegantly transform a dictionary
    such as `{''zip'': ''60608'', ''results'': ''Fail'', ''city'': ''CHICAGO'', ...
    }` to a `SimpleNamespace` object as if we had written `SimpleNamespace( zip=''60608'',
    results=''Fail'', city=''CHICAGO'', ... )`.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`**`语法指定字典中的项将成为`SimpleNamespace`的单独关键字参数。这将优雅地将如`{''zip'': ''60608'', ''results'':
    ''Fail'', ''city'': ''CHICAGO'', ... }`这样的字典转换为`SimpleNamespace`对象，就像我们写了`SimpleNamespace(zip=''60608'',
    results=''Fail'', city=''CHICAGO'', ... )`一样。'
- en: 'Once we have a sequence of `SimpleNamespace` objects, we can do some minor
    updates to make them easier to work with. Here''s a function that makes a few
    tweaks to each object:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个`SimpleNamespace`对象的序列，我们可以进行一些小的更新，使它们更容易处理。这里有一个函数，它对每个对象进行了一些调整：
- en: '[PRE68]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We've converted the longitude and latitude values from strings to float numbers.
    We need to do this in order to properly use the `haversine()` function to compute
    distance from our secret base. We've also split the `business.violations` value
    to a list of individual detailed violations. It's not clear what we'd do with
    this, but it might be helpful in understanding the `business.res` `ults` value.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将经度和纬度值从字符串转换为浮点数。我们需要这样做才能正确使用`haversine()`函数来计算从我们的保密基地的距离。我们还已将`business.violations`值拆分为详细违规的列表。我们不清楚我们会做什么，但这可能有助于理解`business.res`
    `ults`值。
- en: Combining different pieces and parts
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合不同的部分
- en: We can combine the processing into a function that's very similar to the `choice_iter()`
    function shown previously in the *Combining the pieces and parts* section. The
    idea is to create code that looks similar but starts with different source data.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将处理组合成一个与之前在*组合各个部分*部分中显示的`choice_iter()`函数非常相似的功能。想法是创建看起来相似但以不同的源数据开始的代码。
- en: 'This will iterate through the restaurant choices, depending on having `SimpleNamespace`
    objects that have been updated:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历餐厅选择，取决于是否有更新过的`SimpleNamespace`对象：
- en: '[PRE69]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This function defines our secret base at 3420 W Grace St. We've already worked
    out the latitude and longitude, and don't need to make a geocoding request for
    the location.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数定义了我们在3420 W Grace St的保密基地。我们已经计算出了纬度和经度，因此不需要为该位置进行地理编码请求。
- en: 'For each row produced by `food_row_iter()`, we''ve used `parse_details()` to
    update the row. We needed to use a `try:` block because some of the rows have
    invalid (or missing) latitude and longitude information. When we try to compute
    `float(None)`, we get a `TypeError` exception. We just skipped those locations.
    We can geocode them separately, but this is Chicago: there''s another restaurant
    down the block that''s probably better.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`food_row_iter()`产生的每一行，我们使用了`parse_details()`来更新该行。我们需要使用`try:`块，因为一些行有无效的（或缺失的）纬度和经度信息。当我们尝试计算`float(None)`时，我们得到一个`TypeError`异常。我们只是跳过了这些位置。我们可以单独对它们进行地理编码，但这是芝加哥：街对面可能还有一家更好的餐厅。
- en: 'The result of this function is a sequence of objects that include the distance
    from our base and health code inspection details. We might, for example, apply
    some filters to exclude places over .25 miles away or those that got a status
    of `Fail`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的结果是一系列包含从我们的基地到距离和健康代码检查详情的对象。例如，我们可能应用一些过滤器来排除超过0.25英里远的地点或那些状态为`Fail`的地点：
- en: '[PRE70]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The important thing about this sequence of examples is that we leveraged data
    from a web source, adding value to the raw data by doing our own intelligence
    processing. We also combined several individual steps into a more sophisticated
    composite function.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子的重要之处在于，我们利用了网络来源的数据，通过自己的智能处理增加了原始数据的价值。我们还把几个单独的步骤组合成一个更复杂的复合函数。
- en: Final steps
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终步骤
- en: Now that we've located places where we can meet, we have two more things to
    do. First, we need to create a proper grid code for our chosen locations. The
    NAC codes are pretty terse. We simply need to agree with our informant about what
    code we're going to use.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了可以见面的地方，我们还有两件事要做。首先，我们需要为我们选择的位置创建一个合适的网格代码。NAC代码相当简洁。我们只需要与我们的信息提供者就我们将使用哪个代码达成一致。
- en: Second, we need to use our steganography script from [Chapter 3](ch03.html "Chapter 3. Encoding
    Secret Messages with Steganography"), *Encoding Secret Messages with Steganography*,
    to conceal the message in an image. Again, we'll need to be sure that our informant
    can locate the encoded message in the image.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要使用我们来自[第3章](ch03.html "第3章。使用隐写术编码秘密信息")的隐写术脚本，*使用隐写术编码秘密信息*，在图像中隐藏信息。同样，我们需要确保我们的信息提供者能够找到图像中的编码信息。
- en: We'll leave the design of these final processing steps as a mission for you
    to tackle on your own.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些最终处理步骤的设计留给你自己来完成。
- en: Understanding the data – schema and metadata
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解数据 - 模式和元数据
- en: Data is described by additional data that we often call metadata. A basic datum
    might be 6371\. Without some metadata, we have no idea what this means. Minimally,
    metadata has to include the unit of measurement (kilometers in this case) as well
    as the thing being measured (mean radius of the earth).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 数据由额外的数据描述，我们通常称之为元数据。一个基本的数据可能为6371。如果没有一些元数据，我们无法知道这代表什么。至少，元数据必须包括测量单位（在这种情况下为千米）以及被测量的对象（地球的平均半径）。
- en: In the case of less objective data, there may be no units, but rather a domain
    of possible values. For restaurants, it may be an A-B-C score or a pass-fail outcome.
    It's important to track down the metadata in order to interpret the actual data.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在不太客观的数据情况下，可能没有单位，而是一个可能的值域。对于餐馆来说，可能是一个A-B-C评分或通过-不通过的结果。追踪元数据以解释实际数据是很重要的。
- en: An additional consideration is the schema problem. A set of data should consist
    of multiple instances of some essential entity. In our case, the entity is the
    recent health inspection results for a given restaurant. If each instance has
    a consistent collection of attributes, we can call that set of attributes the
    schema for the set of data.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是模式问题。一组数据应由一些基本实体的多个实例组成。在我们的案例中，实体是特定餐馆的最新健康检查结果。如果每个实例都有一个一致的属性集合，我们可以称这些属性集合为该数据集的模式。
- en: In some cases, the data isn't consistent. Perhaps there are multiple schemata
    or perhaps the schema is quite complex with options and alternatives. If there's
    good metadata, it should explain the schema.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，数据可能不一致。可能存在多个模式，或者模式可能非常复杂，具有选项和替代方案。如果有良好的元数据，它应该解释模式。
- en: The City of Chicago data has a very tidy and complete metadata description for
    the restaurant health inspection information. We can read it at [https://data.cityofchicago.org/api/assets/BAD5301B-681A-4202-9D25-51B2CAE672FF?download=true](https://data.cityofchicago.org/api/assets/BAD5301B-681A-4202-9D25-51B2CAE672FF?download=true).
    It explains the risk category assigned to the facility and the ultimate result
    (pass, pass with conditions, fail). Note the long ugly URL; opaque paths like
    this are often a bad idea.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 芝加哥市的数据为餐馆健康检查信息提供了非常整洁和完整的元数据描述。我们可以在[https://data.cityofchicago.org/api/assets/BAD5301B-681A-4202-9D25-51B2CAE672FF?download=true](https://data.cityofchicago.org/api/assets/BAD5301B-681A-4202-9D25-51B2CAE672FF?download=true)上阅读它。它解释了分配给设施的风险类别和最终结果（通过、有条件通过、不通过）。注意这个长而丑陋的URL；像这样的不透明路径通常不是一个好主意。
- en: The Virginia Department of Health data isn't quite so tidy or complete. We can
    eventually work out what the data appears to mean. To be completely sure, we'd
    need to contact the curator of the data to find out precisely what each attribute
    means. This would involve an e-mail exchange with the department of health at
    the state level. A field agent might find this extra effort necessary in the case
    of ambiguous data names.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 弗吉尼亚州卫生部门的数据并不那么整洁或完整。我们最终可以弄清楚数据似乎意味着什么。要完全确定，我们需要联系数据管理员，以确切了解每个属性的含义。这涉及到与州级卫生部门的电子邮件交流。在数据名称模糊的情况下，现场代理可能觉得这种额外的工作是必要的。
- en: Summary
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use web services to perform geocoding and
    reverse geocoding. We also used web services to get large sets of publicly available
    information.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用网络服务执行地理编码和反向地理编码。我们还使用了网络服务来获取大量公开可用的信息。
- en: We used the `math` library to implement the haversine formula to compute distances
    between locations. We saw some sophisticated processing, encoding, and decoding
    techniques and used them to abbreviate grid locations.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`math`库实现了哈弗辛公式来计算地点之间的距离。我们看到了一些复杂的处理、编码和解码技术，并使用它们来缩写网格位置。
- en: We saw more techniques in data gathering using the BeautifulSoup HTML parser.
    We combined multiple web services to create really sophisticated applications
    that integrate geocoding and data analysis.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数据收集方面看到了更多使用BeautifulSoup HTML解析器的技术。我们结合了多个网络服务，创建了真正复杂的应用程序，这些应用程序集成了地理编码和数据分析。
- en: In the next chapter, we'll turn up the sensitivity by performing more sophisticated
    data analysis using deeper statistical techniques. We'll compute means, modes,
    and medians and look at correlations among data items.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过执行更复杂的数据分析来提高灵敏度，使用更深入的统计技术。我们将计算平均值、众数和中位数，并查看数据项之间的相关性。
