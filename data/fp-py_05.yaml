- en: Chapter 5. Higher-order Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。高阶函数
- en: A very important feature of the functional programming paradigm is higher-order
    functions. These are functions that accept functions as arguments or return functions
    as results. Python offers several of these kinds of functions. We'll look at them
    and some logical extensions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程范式的一个非常重要的特性是高阶函数。这些是接受函数作为参数或返回函数作为结果的函数。Python提供了几种这种类型的函数。我们将看看它们和一些逻辑扩展。
- en: 'As we can see, there are three varieties of higher-order functions, which are
    as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，有三种高阶函数，它们如下：
- en: Functions that accept a function as one of its arguments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受函数作为其参数之一的函数
- en: Functions that return a function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回函数的函数
- en: Functions that accept a function and return a function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受函数并返回函数的函数
- en: Python offers several higher-order functions of the first variety. We'll look
    at these built-in higher-order functions in this chapter. We'll look at a few
    of the library modules that offer higher-order functions in later chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几种第一种高阶函数。我们将在本章中查看这些内置的高阶函数。我们将在后面的章节中查看一些提供高阶函数的库模块。
- en: The idea of a function that emits functions can seem a bit odd. However, when
    we look at a Callable class object, we see a function that returns a Callable
    object. This is one example of a function that creates another function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个发出函数的函数的概念可能看起来有点奇怪。然而，当我们看一个Callable类对象时，我们看到一个返回Callable对象的函数。这是一个创建另一个函数的函数的例子。
- en: Functions that accept functions and create functions include complex Callable
    classes as well as function decorators. We'll introduce decorators in this chapter,
    but defer deeper consideration of decorators until [Chapter 11](ch11.html "Chapter 11. Decorator
    Design Techniques"), *Decorator Design Techniques*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接受函数并创建函数的函数包括复杂的Callable类以及函数装饰器。我们将在本章介绍装饰器，但将深入考虑装饰器直到[第11章](ch11.html "第11章。装饰器设计技术")*装饰器设计技术*。
- en: Sometimes we wish that Python had higher-order versions of the collection functions
    from the previous chapter. In this chapter, we'll show the reduce`(extract())`
    design pattern to perform a reduction on specific fields extracted from a larger
    tuple. We'll also look at defining our own version of these common collection-processing
    functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望Python具有前一章中集合函数的高阶版本。在本章中，我们将展示使用reduce`(extract())`设计模式从较大的元组中提取特定字段执行缩减。我们还将看看如何定义我们自己版本的这些常见的集合处理函数。
- en: 'In this chapter, we''ll look at the following functions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将看一下以下函数：
- en: '`max()` and `min()`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max()`和`min()`'
- en: '`Lambda` forms that we can use to simplify using higher-order functions'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用的`Lambda`形式来简化使用高阶函数
- en: '`map()`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`'
- en: '`filter()`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`'
- en: '`iter()`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iter()`'
- en: '`sorted()`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted()`'
- en: There are a number of higher-order functions in the `itertools` module. We'll
    look at this module in [Chapter 8](ch08.html "Chapter 8. The Itertools Module"),
    *The Itertools Module* and [Chapter 9](ch09.html "Chapter 9. More Itertools Techniques"),
    *More Itertools Techniques*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块中有许多高阶函数。我们将在[第8章](ch08.html "第8章。Itertools模块")*Itertools模块*和[第9章](ch09.html
    "第9章。更多Itertools技术")*更多Itertools技术*中查看这个模块。'
- en: Additionally, the `functools` module provides a general-purpose `reduce()` function.
    We'll look at this in [Chapter 10](ch10.html "Chapter 10. The Functools Module"),
    *The Functools Module*. We'll defer this because it's not as generally applicable
    as the other higher-order functions in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`functools`模块提供了一个通用的`reduce()`函数。我们将在[第10章](ch10.html "第10章。Functools模块")*Functools模块*中看到这一点。我们将推迟这个问题，因为它不像本章中的其他高阶函数那样普遍适用。
- en: The `max()` and `min()` functions are reductions; they create a single value
    from a collection. The other functions are mappings. They don't reduce the input
    to a single value.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`和`min()`函数是缩减函数；它们从集合中创建一个单个值。其他函数是映射函数。它们不会将输入减少到单个值。'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `max()`, `min()`, and `sorted()` functions have a default behavior as well
    as a higher-order function behavior. The function is provided via the `key=` argument.
    The `map()` and `filter()` functions take the function as the first positional
    argument.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`、`min()`和`sorted()`函数也有默认行为和高阶函数行为。函数是通过`key=`参数提供的。`map()`和`filter()`函数将函数作为第一个位置参数。'
- en: Using max() and min() to find extrema
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用max()和min()查找极值
- en: 'The `max()` and `min()` functions have a dual life. They are simple functions
    that apply to collections. They are also higher-order functions. We can see their
    default behavior as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`和`min()`函数有双重作用。它们是应用于集合的简单函数。它们也是高阶函数。我们可以看到它们的默认行为如下：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both functions will accept an indefinite number of arguments. The functions
    are designed to also accept a sequence or an iterable as the only argument and
    locate the max (or min) of that iterable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都将接受无限数量的参数。这些函数也被设计为接受序列或可迭代对象作为唯一参数，并定位该可迭代对象的最大值（或最小值）。
- en: 'They also do something more sophisticated. Let''s say we have our trip data
    from the examples in [Chapter 4](ch04.html "Chapter 4. Working with Collections"),
    *Working with Collections*. We have a function that will generate a sequence of
    tuples that looks as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还做一些更复杂的事情。假设我们有来自[第4章](ch04.html "第4章。与集合一起工作")*与集合一起工作*示例中的旅行数据。我们有一个将生成元组序列的函数，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each `tuple` has three values: a starting location, an ending location, and
    a distance. The locations are given in latitude and longitude pairs. The East
    latitude is positive, so these are points along the US East Coast, about 76° West.
    The distances are in nautical miles.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`tuple`有三个值：起始位置、结束位置和距离。位置以纬度和经度对的形式给出。东纬是正数，所以这些点位于美国东海岸，大约西经76°。距离以海里为单位。
- en: 'We have three ways of getting the maximum and minimum distances from this sequence
    of values. They are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方法可以从这个值序列中获取最大和最小距离。它们如下：
- en: Extract the distance with a generator function. This will give us only the distances,
    as we've discarded the other two attributes of each leg. This won't work out well
    if we have any additional processing requirements.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器函数提取距离。这将只给我们距离，因为我们丢弃了每个leg的其他两个属性。如果我们有任何额外的处理要求，这不会很好地工作。
- en: Use the `unwrap(process(wrap()))` pattern. This will give us the legs with the
    longest and shortest distances. From these, we can extract just the distance,
    if that's all that's needed. The other two will give us the leg that contains
    the maximum and minimum distances.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`unwrap(process(wrap()))`模式。这将给我们具有最长和最短距离的legs。从这些中，我们可以提取距离，如果那是所有需要的话。其他两个将给我们包含最大和最小距离的leg。
- en: Use the `max()` and `min()` functions as higher-order functions.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`max()`和`min()`函数作为高阶函数。
- en: 'To provide context, we''ll show the first two solutions. The following is a
    script that builds the trip and then uses the first two approaches to locate the
    longest and shortest distances traveled:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供上下文，我们将展示前两种解决方案。以下是一个构建旅程并使用前两种方法来找到最长和最短距离的脚本：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This section creates the `trip` object as a `tuple` based on `haversine` distances
    of each `leg` built from a `path` read from a KML file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分根据从KML文件中读取的`path`构建的每个`leg`的`haversine`距离创建了`trip`对象作为`tuple`。
- en: 'Once we have the `trip` object, we can extract distances and compute the maximum
    and minimum of those distances. The code looks as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`trip`对象，我们就可以提取距离并计算这些距离的最大值和最小值。代码如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've used a generator function to extract the relevant item from each leg of
    the `trip` tuple. We've had to repeat the generator function because each generator
    expression can be consumed only once.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个生成器函数来从`trip`元组的每个`leg`中提取相关项目。我们不得不重复生成器函数，因为每个生成器表达式只能被消耗一次。
- en: 'The following are the results:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is a version with the `unwrap(process(wrap()))` pattern. We''ve
    actually declared functions with the names `wrap()` and `unwrap()` to make it
    clear how this pattern works:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有`unwrap(process(wrap()))`模式的版本。我们实际上声明了名为`wrap()`和`unwrap()`的函数，以清楚地说明这种模式的工作原理：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unlike the previous version, this locates all attributes of the `legs` with
    the longest and shortest distances. Rather than simply extracting the distances,
    we put the distances first in each wrapped tuple. We can then use the default
    forms of the `min()` and `max()` functions to process the two tuples that contain
    the distance and leg details. After processing, we can strip the first element,
    leaving just the `leg` details.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的版本不同，这个版本定位了具有最长和最短距离的`legs`的所有属性。而不仅仅是提取距离，我们首先将距离放在每个包装的元组中。然后，我们可以使用`min()`和`max()`函数的默认形式来处理包含距离和leg详情的两个元组。处理后，我们可以剥离第一个元素，只留下`leg`详情。
- en: 'The results look as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The final and most important form uses the higher-order function feature of
    the `max()` and `min()` functions. We''ll define a `helper` function first and
    then use it to reduce the collection of legs to the desired summaries by executing
    the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最终且最重要的形式使用了`max()`和`min()`函数的高阶函数特性。我们将首先定义一个`helper`函数，然后使用它来通过执行以下代码片段来将legs的集合减少到所需的摘要：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `by_dist()` function picks apart the three items in each `leg` tuple and
    returns the distance item. We'll use this with the `max()` and `min()` functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`by_dist()`函数拆分了每个`leg`元组中的三个项目，并返回距离项目。我们将在`max()`和`min()`函数中使用这个函数。'
- en: The `max()` and `min()` functions both accept an iterable and a function as
    arguments. The keyword parameter `key=` is used by all of Python's higher-order
    functions to provide a function that will be used to extract the necessary key
    value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`和`min()`函数都接受一个可迭代对象和一个函数作为参数。关键字参数`key=`被Python所有高阶函数使用，以提供一个用于提取必要键值的函数。'
- en: 'We can use the following to help conceptualize how the `max()` function uses
    the `key` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下内容来帮助概念化`max()`函数如何使用`key`函数：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `max()` and `min()` functions behave as if the given `key` function is being
    used to wrap each item in the sequence into a two tuple, process the two tuple,
    and then decompose the two tuple to return the original value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`和`min()`函数的行为就好像给定的`key`函数被用来将序列中的每个项目包装成一个两元组，处理两元组，然后解构两元组以返回原始值。'
- en: Using Python lambda forms
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python的lambda形式
- en: In many cases, the definition of a `helper` function requires too much code.
    Often, we can digest the `key` function to a single expression. It can seem wasteful
    to have to write both `def` and `return` statements to wrap a single expression.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，定义一个`helper`函数需要太多的代码。通常，我们可以将`key`函数简化为一个单一表达式。必须编写`def`和`return`语句来包装一个单一表达式似乎是浪费的。
- en: Python offers the lambda form as a way to simplify using higher-order functions.
    A lambda form allows us to define a small, anonymous function. The function's
    body is limited to a single expression.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了lambda形式作为简化使用高阶函数的一种方式。lambda形式允许我们定义一个小的匿名函数。函数的主体限制在一个单一表达式中。
- en: 'The following is an example of using a simple `lambda` expression as the key:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用简单的`lambda`表达式作为key的示例：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `lambda` we've used will be given an item from the sequence; in this case,
    each leg three tuple will be given to the `lambda`. The `lambda` argument variable,
    `leg`, is assigned and the expression, `leg[2]`, is evaluated, plucking the distance
    from the three tuple.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的`lambda`将从序列中获得一个项目；在这种情况下，每个leg三元组将被传递给`lambda`。`lambda`参数变量`leg`被赋值，表达式`leg[2]`被评估，从三元组中取出距离。
- en: In the rare case that a `lambda` is never reused, this form is ideal. It's common,
    however, to need to reuse the `lambda` objects. Since copy-and-paste is such a
    bad idea, what's the alternative?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，`lambda`从未被重复使用，这种形式是理想的。然而，通常需要重复使用`lambda`对象。由于复制粘贴是一个坏主意，那么有什么替代方案呢？
- en: We can always define a function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以定义一个函数。
- en: 'We can also assign lambdas to variables, by doing something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将lambda分配给变量，做法如下：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A `lambda` is a `callable` object and can be used like a function. The following
    is an example at the interactive prompt:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`是一个`callable`对象，可以像函数一样使用。以下是一个交互提示的示例：'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Python offers us two ways to assign meaningful names to elements of tuples:
    namedtuples and a collection of lambdas. Both are equivalent.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python为元组的元素分配有意义的名称提供了两种方法：命名元组和一组lambda。两者是等效的。
- en: To extend this example, we'll look at how we get the `latitude` or `longitude`
    value of the starting or ending point. This is done by defining some additional
    lambdas.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这个例子，我们将看看如何获取起点或终点的`纬度`或`经度`值。这是通过定义一些额外的lambda来完成的。
- en: 'The following is a continuation of the interactive session:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互会话的继续：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's no clear advantage to lambdas over namedtuples. A set of `lambdas` to
    extract fields requires more lines of code to define than a namedtuple. On the
    other hand, we can use a prefix function notation, which might be easier to read
    in a functional programing context. More importantly, as we'll see in the `sorted()`
    example later, the `lambdas` can be used more effectively than `namedtuple` attribute
    names by `sorted()`, `min()`, and `max()`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: lambda与命名元组相比没有明显的优势。一组`lambda`用于提取字段需要更多的代码行来定义比一个命名元组。另一方面，我们可以使用前缀函数表示法，在函数编程上下文中可能更容易阅读。更重要的是，正如我们将在稍后的`sorted()`示例中看到的，`lambdas`可以比`namedtuple`属性名称更有效地被`sorted()`、`min()`和`max()`使用。
- en: Lambdas and the lambda calculus
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda和lambda演算
- en: In a book on a purely functional programming language, it would be necessary
    to explain lambda calculus, and the technique invented by Haskell Curry that we
    call **currying**. Python, however, doesn't stick closely to this kind of `lambda`
    `calculus`. Functions are not curried to reduce them to single-argument `lambda`
    `forms`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在一本纯函数式编程语言的书中，有必要解释lambda演算和Haskell Curry发明的我们称之为**柯里化**的技术。然而，Python并没有严格遵循这种类型的`lambda`
    `演算`。函数不是柯里化的，以将它们减少为单参数`lambda` `形式`。
- en: We can, using the `functools.partial` function, implement currying. We'll save
    this for [Chapter 10](ch10.html "Chapter 10. The Functools Module"), *The Functools
    Module*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`functools.partial`函数实现柯里化。我们将在[第10章](ch10.html "第10章。Functools模块")*Functools模块*中保存这个。
- en: Using the map() function to apply a function to a collection
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用map()函数将函数应用于集合
- en: A scalar function maps values from a domain to a range. When we look at the
    `math.sqrt()` function, as an example, we're looking at a mapping from the `float`
    value, *x*, to another `float` value, *y = sqrt(x)* such that ![Using the map()
    function to apply a function to a collection](graphics/B03652_05_01.jpg). The
    domain is limited to positive values. The mapping can be done via a calculation
    or table interpolation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 标量函数将域中的值映射到范围中。当我们看`math.sqrt()`函数时，例如，我们正在看一个从`float`值*x*到另一个`float`值*y =
    sqrt(x)*的映射，使得![使用map()函数将函数应用于集合](graphics/B03652_05_01.jpg)。域限制为正值。映射可以通过计算或表插值来完成。
- en: The `map()` function expresses a similar concept; it maps one collection to
    another collection. It assures that a given function is used to map each individual
    item from the domain collection to the range collection—the ideal way to apply
    a built-in function to a collection of data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数表达了一个类似的概念；它将一个集合映射到另一个集合。它确保给定的函数被用来将域集合中的每个单独项映射到范围集合——这是将内置函数应用于数据集合的理想方式。'
- en: 'Our first example involves parsing a block of text to get the sequence of numbers.
    Let''s say we have the following chunk of text:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子涉及解析一块文本以获取数字序列。假设我们有以下文本块：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can restructure this text using the following generator function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下生成器函数重新构造这个文本：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will split the text into lines. For each line, it will split the line
    into space-delimited words and iterate through each of the resulting strings.
    The results look as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将文本分割成行。对于每一行，它将行分割成以空格分隔的单词，并迭代每个结果字符串。结果如下所示：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We still need to apply the `int()` function to each of the `string` values.
    This is where the `map()` function excels. Take a look at the following code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要将`int()`函数应用于每个`string`值。这就是`map()`函数的优势所在。看一下以下代码片段：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `map()` function applied the `int()` function to each value in the collection.
    The result is a sequence of numbers instead of a sequence of strings.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数将`int()`函数应用于集合中的每个值。结果是一系列数字而不是一系列字符串。'
- en: The `map()` function's results are iterable. The `map()` function can process
    any type of iterable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数的结果是可迭代的。`map()`函数可以处理任何类型的可迭代对象。'
- en: The idea here is that any Python function can be applied to the items of a collection
    using the `map()` function. There are a lot of built-in functions that can be
    used in this map-processing context.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，任何Python函数都可以使用`map()`函数应用于集合的项。有很多内置函数可以在这种map处理上下文中使用。
- en: Working with lambda forms and map()
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用lambda表达式和map()
- en: Let's say we want to convert our trip distances from nautical miles to statute
    miles. We want to multiply each leg's distance by 6076.12/5280, which is 1.150780.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将我们的航程距离从海里转换为英里。我们想要将每个航段的距离乘以6076.12/5280，即1.150780。
- en: 'We can do this calculation with the `map()` function as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`map()`函数进行这个计算：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've defined a `lambda` that will be applied to each leg in the trip by the
    `map()` function. The `lambda` will use other `lambdas` to separate the start,
    end, and distance values from each leg. It will compute a revised distance and
    assemble a new leg tuple from the start, end, and statute mile distance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个`lambda`，它将被`map()`函数应用于航程中的每个航段。`lambda`将使用其他`lambdas`从每个航段中分离起点、终点和英里距离值。它将计算修订后的距离，并从起点、终点和英里距离组装一个新的航段元组。
- en: 'This is precisely like the following generator expression:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下生成器表达式完全相同：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've done the same processing on each item in the generator expression.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对生成器表达式中的每个项目进行了相同的处理。
- en: The important difference between the `map()` function and a generator expression
    is that the `map()` function tends to be faster than the generator expression.
    The speedup is in the order of 20 percent less time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数和生成器表达式之间的重要区别在于，`map()`函数往往比生成器表达式更快。加速大约减少了20%的时间。'
- en: Using map() with multiple sequences
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个序列进行map()处理
- en: 'Sometimes, we''ll have two collections of data that need to parallel each other.
    In [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with
    Collections*, we saw how the `zip()` function can interleave two sequences to
    create a sequence of pairs. In many cases, we''re really trying to do something
    like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会有两个需要相互对应的数据集合。在[第4章](ch04.html "第4章。处理集合")，*处理集合*中，我们看到`zip()`函数如何交错两个序列以创建一系列成对。在许多情况下，我们真的想做这样的事情：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''re creating argument tuples from two (or more) parallel iterables and applying
    a function to the argument `tuple`. We can also look at it like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从两个（或更多）并行可迭代对象创建参数元组，并将函数应用于参数`tuple`。我们也可以这样看待：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we've replaced the `map()` function with an equivalent generator expression.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用等效的生成器表达式替换了`map()`函数。
- en: 'We might have the idea of generalizing the whole thing to this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会有将整个事情概括到这样的想法：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is a better approach that is already available to us. We don't actually
    need these techniques. Let's look at a concrete example of the alternate approach.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更好的方法已经可用于我们。实际上我们并不需要这些技术。让我们看一个替代方法的具体例子。
- en: In [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with
    Collections*, we looked at trip data that we extracted from an XML file as a series
    of waypoints. We needed to create legs from this list of waypoints that show the
    start and end of each leg.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。处理集合")，*处理集合*中，我们看到了我们从XML文件中提取的一系列航路点的行程数据。我们需要从这些航路点列表中创建腿，显示每条腿的起点和终点。
- en: 'The following is a simplified version that uses the `zip()` function applied
    to a special kind of iterable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简化版本，使用了`zip()`函数应用于一种特殊类型的可迭代对象：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've created a sequence of pairs drawn from a single flat list. Each pair will
    have two adjacent values. The `zip()` function properly stops when the shorter
    list is exhausted. This `zip( x, x[1:])` pattern only works for materialized sequences
    and the iterable created by the `range()` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个从单个平面列表中提取的成对序列。每对将有两个相邻的值。`zip()`函数在较短的列表用尽时会正确停止。这种`zip( x, x[1:])`模式只适用于实现的序列和`range()`函数创建的可迭代对象。
- en: 'We created pairs so that we can apply the `haversine()` function to each pair
    to compute the distance between the two points on the path. The following is how
    it looks in one sequence of steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了成对，以便我们可以对每对应用`haversine()`函数来计算路径上两点之间的距离。以下是它在一个步骤序列中的样子：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've loaded the essential sequence of waypoints into the `path` variable. This
    is an ordered sequence of latitude-longitude pairs. As we're going to use the
    `zip(path, path[1:])` design pattern, we must have a materialized sequence and
    not a simple iterable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将关键的航路点序列加载到`path`变量中。这是一个有序的纬度-经度对序列。由于我们将使用`zip(path, path[1:])`设计模式，我们必须有一个实现的序列而不是一个简单的可迭代对象。
- en: The results of the `zip()` function will be pairs that have a start and end.
    We want our output to be a triple with the start, end, and distance. The `lambda`
    we're using will decompose the original two tuple and create a new three tuple
    from the start, end, and distance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数的结果将是具有起点和终点的对。我们希望我们的输出是具有起点、终点和距离的三元组。我们正在使用的`lambda`将分解原始的两元组，并从起点、终点和距离创建一个新的三元组。'
- en: 'As noted previously, we can simplify this by using a clever feature of the
    `map()` function, which is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以通过使用`map()`函数的一个巧妙特性来简化这个过程，如下所示：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we've provided a function and two iterables to the `map()` function.
    The `map()` function will take the next item from each iterable and apply those
    two values as the arguments to the given function. In this case, the given function
    is a `lambda` that creates the desired three tuple from the start, end, and distance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经向`map()`函数提供了一个函数和两个可迭代对象。`map()`函数将从每个可迭代对象中取出下一个项目，并将这两个值作为给定函数的参数应用。在这种情况下，给定函数是一个`lambda`，它从起点、终点和距离创建所需的三元组。
- en: The formal definition for the `map()` function states that it will do **star-map**
    processing with an indefinite number of iterables. It will take items from each
    iterable to create a tuple of argument values for the given function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数的正式定义规定，它将使用无限数量的可迭代对象进行**星图**处理。它将从每个可迭代对象中取出项目，以创建给定函数的参数值元组。'
- en: Using the filter() function to pass or reject data
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用filter()函数来传递或拒绝数据
- en: The job of the `filter()` function is to use and apply a decision function called
    a predicate to each value in a collection. A decision of `True` means that the
    value is passed; otherwise, the value is rejected. The `itertools` module includes
    `filterfalse()` as variations on this theme. Refer to [Chapter 8](ch08.html "Chapter 8. The
    Itertools Module"), *The Itertools Module* to understand the usage of the `itertools`
    module's `filterfalse()` function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数的作用是使用并应用称为谓词的决策函数到集合中的每个值。`True`的决策意味着该值被传递；否则，该值被拒绝。`itertools`模块包括`filterfalse()`作为这一主题的变体。参考[第8章](ch08.html
    "第8章。迭代工具模块")，*迭代工具模块*，了解`itertools`模块的`filterfalse()`函数的用法。'
- en: 'We might apply this to our trip data to create a subset of legs that are over
    50 nautical miles long, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个应用到我们的行程数据中，以创建超过50海里长的腿的子集，如下所示：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The predicate `lambda` will be `True` for long legs, which will be passed. Short
    legs will be rejected. The output is the 14 legs that pass this distance test.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`谓词对长腿将为`True`，将被传递。短腿将被拒绝。输出是通过这个距离测试的14条腿。'
- en: 'This kind of processing clearly segregates the filter rule (`lambda leg: dist(leg)
    >= 50`) from any other processing that creates the `trip` object or analyzes the
    long legs.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '这种处理清楚地将`filter`规则(`lambda leg: dist(leg) >= 50`)与创建`trip`对象或分析长腿的任何其他处理分开。'
- en: 'For another simple example, look at the following code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个简单的例子，看下面的代码片段：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've defined a simple `lambda` to check whether a number is a multiple of three
    or a multiple of five. We've applied that function to an iterable, `range(10)`.
    The result is an iterable sequence of numbers that are passed by the decision
    rule.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个简单的`lambda`来检查一个数字是否是3的倍数或5的倍数。我们将这个函数应用到一个可迭代对象`range(10)`上。结果是一个可迭代的数字序列，通过决策规则传递。
- en: The numbers for which the `lambda` is `True` are `[0, 3, 5, 6, 9]`, so these
    values are passed. As the `lambda` is `False` for all other numbers, they are
    rejected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`为`True`的数字是`[0, 3, 5, 6, 9]`，所以这些值被传递。由于`lambda`对所有其他数字都为`False`，它们被拒绝。'
- en: 'This can also be done with a generator expression by executing the following
    code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过执行以下代码来使用生成器表达式来完成：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can formalize this using the following set comprehension notation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下集合推导符号来形式化这个过程：
- en: '![Using the filter() function to pass or reject data](graphics/B03652_05_02.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![使用filter()函数来传递或拒绝数据](graphics/B03652_05_02.jpg)'
- en: This says that we're building a collection of *x* values such that *x* is in
    `range(10)` and `x%3==0 or x%5==0`. There's a very elegant symmetry between the
    `filter()` function and formal mathematical set comprehensions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们正在构建一个*x*值的集合，使得*x*在`range(10)`中，且`x%3==0 or x%5==0`。`filter()`函数和正式的数学集合推导之间有非常优雅的对称性。
- en: 'We often want to use the `filter()` function with defined functions instead
    of `lambda` `forms`. The following is an example of reusing a predicate defined
    earlier:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望使用已定义的函数而不是`lambda` `forms`来使用`filter()`函数。以下是重用先前定义的谓词的示例：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we imported a function from another module called `isprimeg()`.
    We then applied this function to a collection of values to pass the prime numbers
    and reject any non-prime numbers from the collection.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从另一个模块中导入了一个名为`isprimeg()`的函数。然后我们将这个函数应用到一组值上，以传递素数并拒绝集合中的非素数。
- en: This can be a remarkably inefficient way to generate a table of prime numbers.
    The superficial simplicity of this is the kind of thing lawyers call an *attractive
    nuisance*. It looks like it might be fun, but it doesn't scale well at all. A
    better algorithm is the **Sieve of Eratosthenes**; this algorithm retains the
    previously located prime numbers and uses them to prevent a lot of inefficient
    recalculation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是生成素数表的一种非常低效的方法。这种表面上的简单性是律师所说的一种*有吸引力的危险物*。看起来可能很有趣，但它的扩展性非常差。更好的算法是**埃拉托斯特尼筛法**；这个算法保留了先前找到的素数，并使用它们来防止大量低效的重新计算。
- en: Using filter() to identify outliers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用filter()来识别异常值
- en: In the previous chapter, we defined some useful statistical functions to compute
    mean and standard deviation and normalize a value. We can use these functions
    to locate outliers in our trip data. What we can do is apply the `mean()` and
    `stdev()` functions to the distance value in each `leg` of a trip to get the population
    mean and standard deviation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们定义了一些有用的统计函数来计算平均值和标准偏差，并对值进行标准化。我们可以使用这些函数来定位我们旅行数据中的异常值。我们可以将`mean()`和`stdev()`函数应用到旅行中每个`leg`的距离值上，以获得人口平均值和标准偏差。
- en: We can then use the `z()` function to compute a normalized value for each `leg`.
    If the normalized value is more than 3, the data is extremely far from the mean.
    If we reject this outliers, we have a more uniform set of data that's less likely
    to harbor reporting or measurement errors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`z()`函数来计算每个`leg`的标准化值。如果标准化值大于3，数据就远离了平均值。如果我们拒绝这些异常值，我们就有了一个更统一的数据集，不太可能存在报告或测量错误。
- en: 'The following is how we can tackle this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以解决这个问题的方法：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We've mapped the distance function to each `leg` in the `trip` collection. As
    we'll do several things with the result, we must materialize a `list` object.
    We can't rely on the iterator as the first function will consume it. We can then
    use this extraction to compute population statistics `μ_d` and `σ_d` with the
    mean and standard deviation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将距离函数映射到`trip`集合中的每个`leg`。由于我们将对结果进行几项操作，因此必须实现一个`list`对象。我们不能依赖迭代器，因为第一个函数会消耗它。然后我们可以使用这个提取来计算人口统计学`μ_d`和`σ_d`，即平均值和标准偏差。
- en: Given the statistics, we used the outlier lambda to `filter` our data. If the
    normalized value is too large, the data is an outlier.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据统计数据，我们使用异常值lambda来`filter`我们的数据。如果标准化值太大，数据就是异常值。
- en: The result of `list(filter(outlier, trip))` is a list of two legs that are quite
    long compared to the rest of the legs in the population. The average distance
    is about 34 nm, with a standard deviation of 24 nm. No trip can have a normalized
    distance of less than -1.407.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`list(filter(outlier, trip))`的结果是两条腿的列表，与人群中其他腿相比相当长。平均距离约为34纳米，标准偏差为24纳米。没有一次旅行的标准化距离可以小于-1.407。'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We're able to decompose a fairly complex problem into a number of independent
    functions, each one of which can be easily tested in isolation. Our processing
    is a composition of simpler functions. This can lead to succinct, expressive functional
    programming.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够将一个相当复杂的问题分解为许多独立的函数，每个函数都可以很容易地独立测试。我们的处理是由更简单的函数组成的。这可以导致简洁、表达力强的函数式编程。
- en: The iter() function with a sentinel value
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有哨兵值的iter()函数
- en: The built-in `iter()` function creates an iterator over a `collection` object.
    We can use this to wrap an `iterator` object around a `collection`. In many cases,
    we'll allow the `for` statement to handle this implicitly. In a few cases, we
    might want to create an iterator explicitly so that we can separate the head from
    the tail of a `collection`. This function can also iterate through the values
    created by a callable `or` function until a `sentinel` value is found. This feature
    is sometimes used with the `read()` function of a file to consume rows until some
    `sentinel` value is found. In this case, the given function might be some file's
    `readline()` method. Providing a `callable` function to `iter()` is a bit hard
    for us because this function must maintain state internally. This hidden state
    is a feature of an open file, for example, each `read()` or `readline()` function
    advances some internal state to the next character or next line.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`iter()`函数在`collection`对象上创建一个迭代器。我们可以使用这个来在`collection`周围包装一个`iterator`对象。在许多情况下，我们将允许`for`语句隐式处理这一点。在一些情况下，我们可能希望显式地创建一个迭代器，以便我们可以将`collection`的头部与尾部分开。这个函数还可以通过可调用的`or`函数迭代直到找到一个`sentinel`值。这个特性有时与文件的`read()`函数一起使用，以消耗行直到找到某个`sentinel`值。在这种情况下，给定的函数可能是某个文件的`readline()`方法。向`iter()`提供一个`callable`函数对我们来说有点困难，因为这个函数必须在内部维护状态。这个隐藏的状态是一个开放文件的特性，例如，每个`read()`或`readline()`函数都会将一些内部状态推进到下一个字符或下一行。
- en: 'Another example of this is the way that a mutable collection object''s `pop()`
    method makes a stateful change in the object. The following is an example of using
    the `pop()` method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是可变集合对象的`pop()`方法如何对对象进行有状态的更改。以下是使用`pop()`方法的示例：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `tail` variable was set to an iterator over the list `[1, 2, 3, None, 4,
    5, 6]` that will be traversed by the `pop()` function. The default behavior of
    `pop()` is `pop(-1)`, that is, the elements are popped in the reverse order. When
    the `sentinel` value is found, the `iterator` stops returning values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`变量设置为一个迭代器，该迭代器在列表`[1, 2, 3, None, 4, 5, 6]`上进行遍历，该列表将由`pop()`函数遍历。`pop()`的默认行为是`pop(-1)`，即元素以相反顺序弹出。当找到`sentinel`值时，`iterator`停止返回值。'
- en: This kind of internal state is something we'd like to avoid as much as possible.
    Consequently, we won't try to contrive a use for this feature.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽可能地想要避免这种内部状态。因此，我们不会试图创造这个特性的用途。
- en: Using sorted() to put data in order
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sorted()对数据进行排序
- en: When we need to produce results in a defined order, Python gives us two choices.
    We can create a `list` object and use the `list.sort()` method to put items in
    an order. An alternative is to use the `sorted()` function. This function works
    with any iterable, but it creates a final `list` object as part of the sorting
    operation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要按照定义的顺序产生结果时，Python给了我们两种选择。我们可以创建一个`list`对象，并使用`list.sort()`方法对项目进行排序。另一种选择是使用`sorted()`函数。该函数适用于任何可迭代对象，但它会创建一个最终的`list`对象作为排序操作的一部分。
- en: The `sorted()` function can be used in two ways. It can be simply applied to
    collections. It can also be used as a higher-order function using the `key=` argument.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`函数可以以两种方式使用。它可以简单地应用于集合。它也可以作为一个高阶函数使用`key=`参数。'
- en: 'Let''s say we have our trip data from the examples in [Chapter 4](ch04.html
    "Chapter 4. Working with Collections"), *Working with Collections*. We have a
    function that will generate a sequence of tuples with start, end, and distance
    for each `leg` of a `trip`. The data looks as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有来自[第4章](ch04.html "第4章。与集合一起工作")示例中的旅行数据，*与集合一起工作*。我们有一个函数，它将为`trip`的每个`leg`生成一个包含起点、终点和距离的元组序列。数据如下：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see the default behavior of the `sorted()` function using the following
    interaction:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`sorted()`函数的默认行为，使用以下交互：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We used a generator expression (`dist(x) for x in trip`) to extract the distances
    from our trip data. We then sorted this iterable collection of numbers to get
    the distances from 0.17 nm to 129.77 nm.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个生成器表达式（`dist(x) for x in trip`）从我们的旅行数据中提取距离。然后对这个可迭代的数字集合进行排序，以获得从0.17
    nm到129.77 nm的距离。
- en: 'If we want to keep the legs and distances together in their original three
    tuples, we can have the `sorted()` function apply a `key()` function to determine
    how to sort the tuples, as shown in the following code snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要保持原始的三个元组中的`leg`和距离在一起，我们可以让`sorted()`函数应用一个`key()`函数来确定如何对元组进行排序，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ve sorted the trip data, using a `dist lambda` to extract the distance
    from each tuple. The `dist` function is simply as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对旅行数据进行了排序，使用了一个`dist lambda`来从每个元组中提取距离。`dist`函数如下：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This shows the power of using simple `lambda` to decompose a complex tuple into
    constituent elements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了使用简单的`lambda`将复杂的元组分解为组成元素的能力。
- en: Writing higher-order functions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高阶函数
- en: 'We can identify three varieties of higher-order functions; they are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别三种高阶函数；它们如下：
- en: Functions that accept a function as one of its arguments.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受函数作为其参数的函数。
- en: Functions that return a function. A `Callable` class is a common example of
    this. A function that returns a generator expression can be thought of as a higher-order
    function.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回函数的函数。`Callable`类是一个常见的例子。返回生成器表达式的函数可以被认为是一个高阶函数。
- en: Functions that accept and return a function. The `functools.partial()` function
    is a common example of this. We'll save this for [Chapter 10](ch10.html "Chapter 10. The
    Functools Module"), *The Functools Module*. A decorator is different; we'll save
    this for [Chapter 11](ch11.html "Chapter 11. Decorator Design Techniques"), *Decorator
    Design Techinques*.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受并返回函数的函数。`functools.partial()`函数是一个常见的例子。我们将这个保存在[第10章](ch10.html "第10章。Functools模块")中，*Functools模块*。装饰器是不同的；我们将这个保存在[第11章](ch11.html
    "第11章。装饰器设计技术")中，*装饰器设计技术*。
- en: 'We''ll expand on these simple patterns using a higher-order function to also
    transform the structure of the data. We can do several common transformations
    such as the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个高阶函数来扩展这些简单的模式，以转换数据的结构。我们可以进行一些常见的转换，比如以下几种：
- en: Wrap objects to create more complex objects
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装对象以创建更复杂的对象
- en: Unwrap complex objects into their components
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复杂对象解包成其组件
- en: Flatten a structure
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扁平化结构
- en: Structure a flat sequence
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化一个扁平序列
- en: A `Callable` class object is a commonly used example of a function that returns
    a `callable` object. We'll look at this as a way to write flexible functions into
    which configuration parameters can be injected.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable`类对象是一个常用的函数返回`callable`对象的示例。我们将把它看作一种编写灵活函数的方式，可以向其中注入配置参数。'
- en: We'll also introduce simple decorators in this chapter. We'll defer deeper consideration
    of decorators until [Chapter 11](ch11.html "Chapter 11. Decorator Design Techniques"),
    *Decorator Design Techniques*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将介绍简单的装饰器。我们将把对装饰器的更深入考虑推迟到[第11章](ch11.html "第11章 装饰器设计技术")，“装饰器设计技术”中。
- en: Writing higher-order mappings and filters
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高阶映射和过滤
- en: Python's two built-in higher-order functions, `map()` and `filter(),` generally
    handle almost everything we might want to throw at them. It's difficult to optimize
    them in a general way to achieve higher performance. We'll look at functions of
    Python 3.4, such as `imap()`, `ifilter()`, and `ifilterfalse()`, in [Chapter 8](ch08.html
    "Chapter 8. The Itertools Module"), *The Itertools Module*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Python的两个内置高阶函数`map()`和`filter()`通常可以处理几乎我们想要处理的所有内容。很难以一般方式优化它们以实现更高的性能。我们将在Python
    3.4的函数中查看这些函数，比如`imap()`、`ifilter()`和`ifilterfalse()`，在[第8章](ch08.html "第8章 itertools模块")，“itertools模块”中。
- en: 'We have three largely equivalent ways to express a mapping. Assume that we
    have some function, `f(x)`, and some collection of objects, `C`. We have three
    entirely equivalent ways to express a mapping; they are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种基本等效的表达映射的方式。假设我们有一些函数`f(x)`和一些对象集合`C`。我们有三种完全等效的表达映射的方式，它们如下：
- en: 'The `map()` function:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`函数：'
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The generator expression:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器表达式：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The generator function:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Similarly, we have three ways to apply a `filter` function to a `collection`,
    all of which are equivalent:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有三种将`filter`函数应用于`collection`的方式，它们都是等效的：
- en: 'The `filter()` function:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`函数：'
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The generator expression:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器表达式：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The generator function:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There are some performance differences; the `map()` and `filter()` functions
    are fastest. More importantly, there are different kinds of extensions that fit
    these mapping and filtering designs, which are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些性能差异；`map()`和`filter()`函数最快。更重要的是，有不同类型的扩展适用于这些映射和过滤设计，它们如下：
- en: We can create a more sophisticated function, `g(x)`, that is applied to each
    element, or we can apply a function to the collection, `C`, prior to processing.
    This is the most general approach and applies to all three designs. This is where
    the bulk of our functional design energy is invested.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个更复杂的函数`g(x)`，它应用于每个元素，或者我们可以在处理之前将函数应用于集合`C`。这是最一般的方法，适用于所有三种设计。这是我们的函数式设计能量的主要投入点。
- en: We can tweak the `for` loop. One obvious tweak is to combine mapping and filtering
    into a single operation by extending the generator expression with an `if` clause.
    We can also merge the `mymap()` and `myfilter()` functions to combine mapping
    and filtering.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以微调`for`循环。一个明显的调整是通过在生成器表达式中添加`if`子句来将映射和过滤合并为单个操作。我们还可以合并`mymap()`和`myfilter()`函数，以合并映射和过滤。
- en: The profound change we can make is to alter the structure of the data handled
    by the loop. We have a number of design patterns, including wrapping, unwrapping
    (or extracting), flattening, and structuring. We've looked at a few of these techniques
    in previous chapters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做出的深刻改变是改变循环处理的数据结构。我们有许多设计模式，包括包装、解包（或提取）、扁平化和结构化。我们在之前的章节中已经看过了其中一些技术。
- en: We need to exercise some caution when designing mappings that combine too many
    transformations in a single function. As far as possible, we want to avoid creating
    functions that fail to be succinct or expressive of a single idea. As Python doesn't
    have an optimizing compiler, we might be forced to manually optimize slow applications
    by combining functions. We need to do this kind of optimization reluctantly, only
    after profiling a poorly performing program.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计结合太多转换的映射时，我们需要谨慎行事。尽可能地，我们希望避免创建不够简洁或表达单一思想的函数。由于Python没有优化编译器，我们可能被迫通过组合函数来手动优化慢应用程序。我们需要在对性能表现不佳的程序进行分析后，才会不情愿地进行这种优化。
- en: Unwrapping data while mapping
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在映射时解包数据
- en: When we use a construct such as `(f(x) for x, y in C)`, we've used multiple
    assignment in the `for` statement to unwrap a multi-valued tuple and then apply
    a function. The whole expression is a mapping. This is a common Python optimization
    to change the structure and apply a function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这样的构造`(f(x) for x, y in C)`时，我们在`for`语句中使用了多重赋值来解包一个多值元组，然后应用一个函数。整个表达式是一个映射。这是一种常见的Python优化，用于改变结构并应用函数。
- en: 'We''ll use our trip data from [Chapter 4](ch04.html "Chapter 4. Working with
    Collections"), *Working with Collections*. The following is a concrete example
    of unwrapping while mapping:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自[第4章](ch04.html "第4章 处理集合")，“处理集合”的旅行数据。以下是一个解包映射的具体示例：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This higher-order function would be supported by conversion functions that
    we can apply to our raw data as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高阶函数将由我们可以应用于原始数据的转换函数支持，如下所示：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This function would then be used as follows to extract distance and apply a
    conversion function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以如下使用该函数提取距离并应用转换函数：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As we''re unwrapping, the result will be a sequence of `floating-point` values.
    The results are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解包时，结果将是一系列浮点值。结果如下：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This `convert()` function is highly specific to our start-end-distance trip
    data structure, as the `for` loop decomposes that three tuple.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`convert()`函数对我们的起点-终点-距离行程数据结构非常具体，因为`for`循环分解了那个三元组。
- en: 'We can build a more general solution for this kind of unwrapping while mapping
    a design pattern. It suffers from being a bit more complex. First, we need general-purpose
    decomposition functions like the following code snippet:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建一个更一般的解决方案，用于在映射设计模式中进行解包。它有点复杂。首先，我们需要像下面的代码片段一样的通用分解函数：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''d like to be able to express `f(sel2(s_e_d)) for s_e_d in trip`. This involves
    functional composition; we''re combining a function like `to_miles()` and a selector
    like `sel2()`. We can express functional composition in Python using yet another
    lambda, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够表示`f(sel2(s_e_d)) for s_e_d in trip`。这涉及到函数组合；我们正在组合一个像`to_miles()`这样的函数和一个像`sel2()`这样的选择器。我们可以使用另一个lambda在Python中表示函数组合，如下所示：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This gives us a longer but more general version of unwrapping, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个更长但更一般的解包版本，如下所示：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: While this second version is somewhat more general, it doesn't seem wonderfully
    helpful. When used with particularly complex tuples, however, it can be handy.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个第二个版本有点更一般化，但似乎并不是特别有用。然而，当与特别复杂的元组一起使用时，它可能会很方便。
- en: What's important to note about our higher-order `convert()` function is that
    we're accepting a function as an argument and returning a function as a result.
    The `convert()` function is not a generator function; it doesn't `yield` anything.
    The result of the `convert()` function is a generator expression that must be
    evaluated to accumulate the individual values.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的高阶`convert()`函数需要注意的是，我们接受一个函数作为参数，并返回一个函数作为结果。`convert()`函数不是一个生成器函数；它不会`yield`任何东西。`convert()`函数的结果是一个必须进行评估以累积个别值的生成器表达式。
- en: The same design principle works to create hybrid filters instead of mappings.
    We'd apply the filter in an `if` clause of the generator expression that was returned.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的设计原则适用于创建混合过滤器而不是映射。我们会在返回的生成器表达式的`if`子句中应用过滤器。
- en: Of course, we can combine mapping and filtering to create yet more complex functions.
    It might seem like a good idea to create more complex functions to limit the amount
    of processing. This isn't always true; a complex function might not beat the performance
    of a nested use of simple `map()` and `filter()` functions. Generally, we only
    want to create a more complex function if it encapsulates a concept and makes
    the software easier to understand.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以结合映射和过滤来创建更复杂的函数。创建更复杂的函数来限制处理的数量似乎是个好主意。但这并不总是正确的；一个复杂的函数可能无法超越简单的`map()`和`filter()`函数的嵌套使用性能。通常，我们只想创建一个更复杂的函数，如果它封装了一个概念，并且使软件更容易理解。
- en: Wrapping additional data while mapping
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在映射时包装额外的数据
- en: When we use a construct such as `((f(x), x) for x in C)`, we've done a wrapping
    to create a multi-valued tuple while also applying a mapping. This is a common
    technique to save derived results to create constructs that have the benefits
    of avoiding recalculation without the liability of complex state-changing objects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这样的结构`((f(x), x) for x in C)`时，我们进行了包装以创建一个多值元组，同时应用了映射。这是一种常见的技术，可以保存派生结果以创建具有避免重新计算的好处的构造，而不会产生复杂的状态更改对象的责任。
- en: 'This is part of the example shown in [Chapter 4](ch04.html "Chapter 4. Working
    with Collections"), *Working with Collections*, to create the trip data from the
    path of points. The code looks like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[第4章](ch04.html "第4章。处理集合")*处理集合*中显示的示例的一部分，用于从点的路径创建行程数据。代码如下：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can revise this slightly to create a higher-order function that separates
    the `wrapping` from the other functions. We can define a function like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微修改这个来创建一个将`wrapping`与其他函数分离的高阶函数。我们可以定义一个这样的函数：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This function will decompose each leg into two variables, `start` and `end`.
    These will be used with the given `distance()` function to compute the distance
    between the points. The result will build a more complex three tuple that includes
    the original two legs and also the calculated result.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将每个`leg`分解为两个变量，`start`和`end`。这些将与给定的`distance()`函数一起用于计算点之间的距离。结果将构建一个更复杂的三元组，其中包括原始的两个`leg`，以及计算出的结果。
- en: 'We can then rewrite our trip assignment to apply the `haversine()` function
    to compute distances as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以重写我们的行程分配，应用`haversine()`函数来计算距离，如下所示：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've replaced a generator expression with a higher-order function, `cons_distance()`.
    The function not only accepts a function as an argument, but it also returns a
    generator expression.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用高阶函数`cons_distance()`替换了一个生成器表达式。这个函数不仅接受一个函数作为参数，还返回一个生成器表达式。
- en: 'A slightly different formulation of this is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个稍微不同的表述如下：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This version makes the construction of a new object built up from an old object
    a bit clearer. We're iterating through legs of a trip. We're computing the distance
    along a `leg`. We're building new structures with the `leg` and the distance concatenated.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本使得从旧对象构建新对象的过程更加清晰。我们正在迭代行程的各个部分。我们正在计算`leg`上的距离。我们正在用`leg`和距离连接起来构建新的结构。
- en: As both of these `cons_distance()` functions accept a function as an argument,
    we can use this feature to provide an alternative distance formula. For example,
    we can use the `math.hypot(lat(start)-lat(end), lon(start)-lon(end))` method to
    compute a less-correct plane distance along each `leg`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个`cons_distance()`函数都接受一个函数作为参数，我们可以利用这个特性来提供另一种距离公式。例如，我们可以使用`math.hypot(lat(start)-lat(end),
    lon(start)-lon(end))`方法来计算每个`leg`上的不太准确的平面距离。
- en: In [Chapter 10](ch10.html "Chapter 10. The Functools Module"), *The Functools
    Module*, we'll show how to use the `partial()` function to set a value for the
    `R` parameter of the `haversine()` function, which changes the units in which
    the distance is calculated.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html“第10章。Functools模块”)，“Functools模块”中，我们将展示如何使用`partial（）`函数为`haversine（）`函数的`R`参数设置一个值，从而改变计算距离的单位。
- en: Flattening data while mapping
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在映射时扁平化数据
- en: In [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with
    Collections*, we looked at algorithms that flattened a nested tuple-of-tuples
    structure into single iterable. Our goal at the time was simply to restructure
    some data, without doing any real processing. We can create hybrid solutions that
    combine a function with a flattening operation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html“第4章。处理集合”)，“处理集合”中，我们看了将嵌套的元组结构扁平化为单个可迭代对象的算法。当时我们的目标只是重新构造一些数据，而不进行任何真正的处理。我们可以创建混合解决方案，将函数与扁平化操作结合起来。
- en: 'Let''s assume that we have a block of text that we want to convert to a flat
    sequence of numbers. The text looks as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一块文本，我们想将其转换为数字的平面序列。文本如下所示：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each line is a block of 10 numbers. We need to unblock the rows to create a
    flat sequence of numbers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每行是一个10个数字的块。我们需要解除行以创建数字的平面序列。
- en: 'This is done with a two part generator function as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个两部分生成器函数，如下所示：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will split the text into lines and iterate through each line. It will
    split each line into words and iterate through each word. The output from this
    is a list of strings, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把文本分割成行，并遍历每一行。它将把每一行分割成单词，并遍历每一个单词。这样的输出是一个字符串列表，如下所示：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To convert the strings to numbers, we must apply a conversion function as well
    as unwind the blocked structure from its original format, using the following
    code snippet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串转换为数字，我们必须应用转换函数，并解开其原始格式的阻塞结构，使用以下代码片段：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This function has a `conversion` argument, which is a function that is applied
    to each value that will be emitted. The values are created by flattening using
    the algorithm shown above.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数具有`conversion`参数，该参数是应用于将被发出的每个值的函数。这些值是通过使用上面显示的算法进行扁平化而创建的。
- en: 'We can use this `numbers_from_rows()` function in the following kind of expression:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下类型的表达式中使用`numbers_from_rows（）`函数：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here we've used the built-in `float()` to create a list of `floating-point`
    values from the block of text.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用内置的`float（）`从文本块中创建一个`浮点数`值列表。
- en: 'We have many alternatives using mixtures of higher-order functions and generator
    expressions. For example, we might express this as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有许多选择，可以使用混合高阶函数和生成器表达式。例如，我们可以将其表示如下：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This might be helpful if it helps us understand the overall structure of the
    algorithm. The principle is called **chunking**; the details of a function with
    a meaningful name can be abstracted and we can work with the function in a new
    context. While we often use higher-order functions, there are times when a generator
    expression can be more clear.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这有助于我们理解算法的整体结构，那可能会有所帮助。这个原则被称为**分块**；具有有意义名称的函数的细节可以被抽象化，我们可以在新的上下文中使用该函数。虽然我们经常使用高阶函数，但有时生成器表达式可能更清晰。
- en: Structuring data while filtering
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在过滤数据的同时构造数据
- en: The previous three examples combined additional processing with mapping. Combining
    processing with filtering doesn't seem to be quite as expressive as combining
    with mapping. We'll look at an example in detail to show that, although it is
    useful, it doesn't seem to have as compelling a use case as combining mapping
    and processing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个示例将额外处理与映射结合在一起。将处理与过滤结合起来似乎不像与映射结合那样具有表现力。我们将详细查看一个示例，以表明，尽管它很有用，但似乎没有与映射和处理结合的用例那么引人注目。
- en: 'In [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with
    Collections*, we looked at structuring algorithms. We can easily combine a filter
    with the structuring algorithm into a single, complex function. The following
    is a version of our preferred function to group the output from an iterable:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html“第4章。处理集合”)，“处理集合”中，我们看了算法的结构。我们可以将过滤器与结构算法轻松地合并为单个复杂函数。以下是我们首选函数的版本，用于对可迭代对象的输出进行分组：
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will try to assemble a tuple of `n` items taken from an iterable. If there
    are any items in the tuple, they are yielded as part of the resulting iterable.
    In principle, the function then operates recursively on the remaining items from
    the original iterable. As the recursion is relatively inefficient in Python, we've
    optimized it into an explicit `while` loop.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尝试从可迭代对象中获取`n`个项目的元组。如果元组中有任何项目，则它们将作为结果可迭代对象的一部分产生。原则上，该函数然后对原始可迭代对象中剩余的项目进行递归操作。由于递归在Python中相对低效，我们已将其优化为显式的`while`循环。
- en: 'We can use this function as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式使用此函数：
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will group the results of applying a `filter()` function to an iterable
    created by the `range()` function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对由`range（）`函数创建的可迭代对象应用`filter（）`函数的结果进行分组。
- en: 'We can merge grouping and filtering into a single function that does both operations
    in a single function body. The modification to `group_by_iter()` looks as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将分组和过滤合并为一个单一函数，在单个函数体中执行这两个操作。对`group_by_iter（）`的修改如下：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This function applies the filter predicate function to the source iterable.
    As the filter output is itself a non-strict iterable, the `data` variable isn't
    computed in advance; the values for data are created as needed. The bulk of this
    function is identical to the version shown above.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将过滤谓词函数应用于源可迭代对象。由于过滤器输出本身是非严格可迭代对象，因此`data`变量不会提前计算；数据的值将根据需要创建。这个函数的大部分与上面显示的版本相同。
- en: 'We can slightly simplify the context in which we use this function as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微简化我们使用此函数的上下文，如下所示：
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we've applied the filter predicate and grouped the results in a single
    function invocation. In the case of the `filter()` function, it's rarely a clear
    advantage to apply the filter in conjunction with other processing. It seems as
    if a separate, visible `filter()` function is more helpful than a combined function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应用了过滤谓词，并将结果分组在一个函数调用中。在`filter()`函数的情况下，将过滤器与其他处理一起应用很少是一个明显的优势。似乎一个单独的、可见的`filter()`函数比一个组合函数更有帮助。
- en: Writing generator functions
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写生成器函数
- en: 'Many functions can be expressed neatly as generator expressions. Indeed, we''ve
    seen that almost any kind of mapping or filtering can be done as a generator expression.
    They can also be done with a built-in higher-order function such as `map()` or
    `filter()` or as a generator function. When considering multiple statement generator
    functions, we need to be cautious that we don''t stray from the guiding principles
    of functional programming: stateless function evaluation.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数可以被表达为生成器表达式。事实上，我们已经看到几乎任何一种映射或过滤都可以作为生成器表达式来完成。它们也可以使用内置的高阶函数，比如`map()`或`filter()`，或者作为生成器函数来完成。在考虑多语句生成器函数时，我们需要小心，不要偏离函数式编程的指导原则：无状态函数评估。
- en: Using Python for functional programming means walking on a knife edge between
    purely functional programming and imperative programming. We need to identify
    and isolate the places where we must resort to imperative Python code because
    there isn't a purely functional alternative available.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中进行函数式编程意味着在纯函数式编程和命令式编程之间走一条很窄的路。我们需要确定并隔离必须诉诸命令式Python代码的地方，因为没有纯函数式的替代方案可用。
- en: 'We''re obligated to write generator functions when we need statement features
    of Python. Features like the following aren''t available in generator expressions:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要Python的语句特性时，我们有义务编写生成器函数。像下面这样的特性在生成器表达式中是不可用的：
- en: A `with` context to work with external resources. We'll look at this in [Chapter
    6](ch06.html "Chapter 6. Recursions and Reductions"), *Recursions and Reductions*,
    where we address file parsing.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`with`上下文来处理外部资源。我们将在[第6章](ch06.html "第6章。递归和归约")*递归和归约*中讨论文件解析时看到这一点。
- en: A `while` statement to iterate somewhat more flexibly than a `for` statement.
    The example of this is shown previously in the *Flattening data while mapping*
    section.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`语句可以比`for`语句更灵活地进行迭代。这个例子在*在映射时展开数据*部分中已经展示过。'
- en: A `break` or `return` statement to implement a search that terminates a loop
    early.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`break`或`return`语句来实现提前终止循环的搜索。
- en: The `try-except` construct to handle exceptions.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`try-except`结构来处理异常。
- en: An internal function definition. We've looked at this in several examples in
    [Chapter 1](ch01.html "Chapter 1. Introducing Functional Programming"), *Introducing
    Functional Programming* and [Chapter 2](ch02.html "Chapter 2. Introducing Some
    Functional Features"), *Introducing Some Functional Features*. We'll also revisit
    it in [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"), *Recursions
    and Reductions*.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部函数定义。我们在[第1章](ch01.html "第1章。介绍函数式编程")*介绍函数式编程*和[第2章](ch02.html "第2章。介绍一些函数式特性")*介绍一些函数式特性*中已经看过了这一点。我们还将在[第6章](ch06.html
    "第6章。递归和归约")*递归和归约*中重新讨论它。
- en: A really complex `if-elif` sequence. Trying to express more than one alternatives
    via `if-else` conditional expressions can become complex-looking.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非常复杂的`if-elif`序列。试图通过`if-else`条件表达式来表达多个选择可能会变得复杂。
- en: At the edge of the envelope, we have less-used features of Python such as `for-else`,
    `while-else`, `try-else`, and `try-else-finally`. These are all statement-level
    features that aren't available in generator expressions.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python的边缘，我们有一些不常用的特性，比如`for-else`、`while-else`、`try-else`和`try-else-finally`。这些都是语句级别的特性，不适用于生成器表达式。
- en: The `break` statement is most commonly used to end processing of a collection
    early. We can end processing after the first item that satisfies some criteria.
    This is a version of the `any()` function we're looking at to find the existence
    of a value with a given property. We can also end after processing some larger
    numbers of items, but not all of them.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句最常用于提前结束集合的处理。我们可以在满足某些条件的第一项后结束处理。这是我们正在查看的`any()`函数的一个版本，用于查找具有给定属性的值的存在。我们也可以在处理一些较大的项目后结束，但不是全部。'
- en: Finding a single value can be expressed succinctly as `min(some-big-expression)`
    or `max(something big)`. In these cases, we're committed to examining all of the
    values to assure that we've properly found the minimum or the maximum.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 找到单个值可以简洁地表示为`min(some-big-expression)`或`max(something big)`。在这些情况下，我们承诺要检查所有的值，以确保我们已经正确地找到了最小值或最大值。
- en: In a few cases, we can stand to have a `first(function, collection)` function
    where the first value that is `True` is sufficient. We'd like the processing to
    terminate as early as possible, saving needless calculation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些情况下，我们可以使用`first(function, collection)`函数，其中第一个值为`True`就足够了。我们希望尽早终止处理，节省不必要的计算。
- en: 'We can define a function as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个函数如下：
- en: '[PRE62]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We've iterated through the `collection`, applying the given predicate function.
    If the predicate is `True`, we'll return the associated value. If we exhaust the
    `collection`, the default value of `None` will be returned.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遍历了`collection`，应用了给定的谓词函数。如果谓词为`True`，我们将返回相关的值。如果我们耗尽了`collection`，将返回`None`的默认值。
- en: 'We can also download a version of this from `PyPi`. The first module contains
    a variation on this idea. For more details visit: [https://pypi.python.org/pypi/first](https://pypi.python.org/pypi/first).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从`PyPi`下载这个版本。第一个模块包含了这个想法的一个变种。更多详情请访问：[https://pypi.python.org/pypi/first](https://pypi.python.org/pypi/first)。
- en: 'This can act as a helper when trying to determine whether a number is a prime
    number or not. The following is a function that tests a number for being prime:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以作为一个辅助函数，用于确定一个数字是否是质数。以下是一个测试数字是否为质数的函数：
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This function handles a few of the edge cases regarding the number 2 being a
    prime number and every other even number being composite. Then, it uses the `first()`
    function defined above to locate the first factor in the given collection.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数处理了关于数字2是质数以及每个其他偶数是合数的一些边缘情况。然后，它使用上面定义的`first()`函数来定位给定集合中的第一个因子。
- en: When the `first()` function will return the factor, the actual number doesn't
    matter. Its existence is all that matters for this particular example. Therefore,
    the `isprimeh()` function returns `True` if no factor was found.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当`first()`函数返回因子时，实际数字并不重要。对于这个特定的例子来说，它的存在才是重要的。因此，如果没有找到因子，`isprimeh()`函数将返回`True`。
- en: 'We can do something similar to handle data exceptions. The following is a version
    of the `map()` function that also filters bad data:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做类似的事情来处理数据异常。以下是`map()`函数的一个版本，它还过滤了不良数据：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This function steps through the items in the iterable. It attempts to apply
    the function to the item; if no exception is raised, this new value is yielded.
    If an exception is raised, the offending value is silently dropped.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数遍历可迭代对象中的项目。它尝试将函数应用于项目；如果没有引发异常，则产生新值。如果引发异常，则默默地丢弃有问题的值。
- en: This can be handy when dealing with data that include values that are not applicable
    or missing. Rather than working out complex filters to exclude these values, we
    attempt to process them and drop the ones that aren't valid.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理包含不适用或缺失值的数据时，这可能很方便。我们尝试处理它们并丢弃无效的值，而不是制定复杂的过滤器来排除这些值。
- en: 'We might use the `map()` function for mapping `not-None` values as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`map()`函数将`非None`值映射为以下形式：
- en: '[PRE65]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We'll apply the `int()` function to each value in `some_source`. When the `some_source`
    parameter is an iterable collection of strings, this can be a handy way to reject
    `strings` that don't represent a number.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`int()`函数应用于`some_source`中的每个值。当`some_source`参数是一个字符串的可迭代集合时，这可以是一个拒绝不表示数字的`字符串`的方便方法。
- en: Building higher-order functions with Callables
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可调用对象构建高阶函数
- en: We can define higher-order functions as instances of the `Callable` class. This
    builds on the idea of writing generator functions; we'll write callables because
    we need statement features of Python. In addition to using statements, we can
    also apply a static configuration when creating the higher-order function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将高阶函数定义为`Callable`类的实例。这建立在编写生成器函数的想法上；我们将编写可调用对象，因为我们需要Python的语句特性。除了使用语句外，我们在创建高阶函数时还可以应用静态配置。
- en: What's important about a `Callable` class definition is that the class object,
    created by the `class` statement, defines essentially a function that emits a
    function. Commonly, we'll use a `callable` object to create a composite function
    that combines two other functions into something relatively complex.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable`类定义的重要之处在于，由`class`语句创建的类对象本质上定义了一个发出函数的函数。通常，我们将使用`callable`对象来创建一个复合函数，将两个其他函数组合成相对复杂的东西。'
- en: 'To emphasize this, consider the following class:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调这一点，考虑以下类：
- en: '[PRE66]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This class creates a function named `NullAware()` that is a higher-order function
    that is used to create a new function. When we evaluate the `NullAware(math.log)`
    expression, we're creating a new function that can be applied to argument values.
    The `__init__()` method will save the given function in the resulting object.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类创建了一个名为`NullAware()`的函数，它是一个高阶函数，用于创建一个新的函数。当我们评估`NullAware(math.log)`表达式时，我们正在创建一个可以应用于参数值的新函数。`__init__()`方法将保存给定的函数在结果对象中。
- en: The `__call__()` method is how the resulting function is evaluated. In this
    case, the function that was created will gracefully tolerate `None` values without
    raising exceptions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call__()`方法是对结果函数进行评估的方法。在这种情况下，创建的函数将优雅地容忍`None`值而不会引发异常。'
- en: 'The common approach is to create the new function and save it for future use
    by assigning it a name as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的方法是创建新函数并将其保存以备将来使用，方法是给它分配一个名称，如下所示：
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This creates a new function and assigns the name `null_log_scale()`. We can
    then use the function in another context. Take a look at the following example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的函数并分配名称`null_log_scale()`。然后我们可以在另一个上下文中使用该函数。看一下以下示例：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A less common approach is to create and use the emitted function in one expression
    as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不太常见的方法是在一个表达式中创建并使用发出的函数，如下所示：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The evaluation of `NullAware( math.log )` created a function. This anonymous
    function was then used by the `map()` function to process an iterable, `some_data`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对`NullAware( math.log )`的评估创建了一个函数。然后，这个匿名函数被`map()`函数用于处理一个可迭代的`some_data`。
- en: This example's `__call__()` method relies entirely on expression evaluation.
    It's an elegant and tidy way to define composite functions built up from lower-level
    component functions. When working with `scalar` functions, there are a few complex
    design considerations. When we work with iterable collections, we have to be a
    bit more careful.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的`__call__()`方法完全依赖于表达式评估。这是一种优雅而整洁的方式，用于定义由低级组件函数构建而成的复合函数。在处理`标量`函数时，有一些复杂的设计考虑。当我们处理可迭代集合时，我们必须更加小心。
- en: Assuring good functional design
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保良好的函数设计
- en: The idea of stateless functional programming requires some care when using Python
    objects. Objects are typically stateful. Indeed, one can argue that the entire
    purpose of object-oriented programming is to encapsulate state change into class
    definition. Because of this, we find ourselves pulled in opposing directions between
    functional programming and imperative programming when using Python class definitions
    to process collections.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态函数式编程的概念在使用Python对象时需要一些小心。对象通常是有状态的。事实上，可以说，面向对象编程的整个目的是将状态变化封装到类定义中。因此，当使用Python类定义来处理集合时，我们发现自己在函数式编程和命令式编程之间被拉向相反的方向。
- en: The benefit of using a `Callable` to create a composite function gives us slightly
    simpler syntax when the resulting composite function is used. When we start working
    with iterable mappings or reductions, we have to be aware of how and why we introduce
    stateful objects.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Callable`创建复合函数的好处在于，当使用生成的复合函数时，语法会稍微简单一些。当我们开始使用可迭代的映射或缩减时，我们必须意识到我们如何以及为什么引入有状态的对象。
- en: 'We''ll return to our `sum_filter_f()` composite function shown above. Here
    is a version built from a `Callable` class definition:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回到上面显示的`sum_filter_f()`复合函数。这是一个基于`Callable`类定义构建的版本：
- en: '[PRE70]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We've imported the abstract superclass `Callable` and used this as the basis
    for our class. We've defined precisely two slots in this object; this puts a few
    constraints on our ability to use the function as a stateful object. It doesn't
    prevent all modifications to the resulting object, but it limits us to just two
    attributes. Attempting to add attributes results in an exception.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了抽象超类`Callable`，并将其用作我们类的基础。我们在这个对象中定义了确切的两个插槽；这对我们使用函数作为有状态对象施加了一些限制。这并不会阻止对生成的对象进行所有修改，但它限制了我们只能使用两个属性。尝试添加属性会导致异常。
- en: The initialization method, `__init__()`, stows the two function names, `filter`
    and `function`, in the object's instance variables. The `__call__()` method returns
    a value based on a generator expression that uses the two internal function definitions.
    The `self.filter()` function is used to pass or reject items. The `self.function()`
    function is used to transform objects that are passed by the `filter()` function.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化方法`__init__()`将两个函数名`filter`和`function`存储在对象的实例变量中。`__call__()`方法返回一个基于使用两个内部函数定义的生成器表达式的值。`self.filter()`函数用于传递或拒绝项目。`self.function()`函数用于转换由`filter()`函数传递的对象。
- en: 'An instance of this class is a function that has two strategy functions built
    into it. We create an instance as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的一个实例是一个具有两个策略函数的函数。我们可以按照以下方式创建一个实例：
- en: '[PRE71]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We've built a function named `count_not_none()` that counts the `non-None` values
    in a sequence. It does this by using a `lambda` to pass `non-None` values and
    a function that uses a constant 1 instead of the actual values present.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个名为`count_not_none()`的函数，用于计算序列中的`non-None`值。它通过使用`lambda`传递`non-None`值和一个使用常量1而不是实际值的函数来实现这一点。
- en: Generally, this `count_not_none()` object will behave like any other Python
    function. The use is somewhat simpler than our previous example of `sum_filter_f()`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个`count_not_none()`对象会像任何其他Python函数一样行为。使用起来比我们之前的`sum_filter_f()`例子要简单一些。
- en: 'We can use the `count_not_None()` function as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用`count_not_None()`函数：
- en: '[PRE72]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Instead of using `sum_filter_f()` funtion:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用`sum_filter_f()`函数：
- en: '[PRE73]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `count_not_none()` function, based on a `Callable`, doesn''t require quite
    so many arguments as a conventional function. This makes it superficially simpler
    to use. However, it can also make it somewhat more obscure because the details
    of how the function works are in two places in the source code: where the function
    was created as an instance of the `Callable` class and where the function was
    used.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`Callable`的`count_not_none()`函数不需要像传统函数那样多的参数。这使得它表面上更容易使用。然而，这也可能使它有些更加晦涩，因为函数工作的细节在源代码的两个地方：一个是函数作为`Callable`类的实例创建的地方，另一个是函数被使用的地方。
- en: Looking at some of the design patterns
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看一些设计模式
- en: The `max()`, `min()`, and `sorted()` functions have a default behavior without
    a `key=` function. They can be customized by providing a function that defines
    how to compute a key from the available data. For many of our examples, the `key()`
    function has been a simple extraction of available data. This isn't a requirement;
    the `key()` function can do anything.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`、`min()`和`sorted()`函数在没有`key=`函数的情况下有默认行为。它们可以通过提供一个定义如何从可用数据计算键的函数来进行自定义。在我们的许多例子中，`key()`函数是对可用数据的简单提取。这不是必须的；`key()`函数可以做任何事情。'
- en: 'Imagine the following method: `max(trip, key=random.randint())`. Generally,
    we try not to have have `key()` functions that do something obscure.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下以下方法：`max(trip, key=random.randint())`。通常，我们尽量不要使用做一些晦涩操作的`key()`函数。
- en: The use of a `key=` function is a common design pattern. Our functions can easily
    follow this pattern.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`key=`函数是一种常见的设计模式。我们的函数可以轻松地遵循这种模式。
- en: We've also looked at `lambda` `forms` that we can use to simplify using higher-order
    functions. One significant advantage of using `lambda` `forms` is that it follows
    the functional paradigm very closely. When writing more conventional functions,
    we can create imperative programs that might clutter an otherwise succinct and
    expressive functional design.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看过可以用来简化使用高阶函数的`lambda` `forms`。使用`lambda` `forms`的一个重要优势是它非常贴近函数式范式。当编写更传统的函数时，我们可能会创建命令式程序，这可能会使本来简洁和表达力强的函数式设计变得混乱。
- en: 'We''ve looked at several kinds of higher-order functions that work with a collection
    of values. Throughout the previous chapters, we''ve hinted around at several different
    design patterns for higher-order `collection` and `scalar` functions. The following
    is a broad classification:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过几种与值集合一起工作的高阶函数。在前几章中，我们已经暗示了几种不同的高阶`collection`和`scalar`函数的设计模式。以下是一个广泛的分类：
- en: Return a Generator. A higher-order function can return a generator expression.
    We consider the function higher-order because it didn't return `scalar` values
    or `collections` of values. Some of these higher-order functions also accept functions
    as arguments.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个生成器。高阶函数可以返回一个生成器表达式。我们认为这个函数是高阶的，因为它没有返回`scalar`值或值的`collections`。其中一些高阶函数也接受函数作为参数。
- en: Act as a Generator. Some function examples use the `yield` statement to make
    them first-class generator functions. The value of a generator function is an
    iterable collection of values that are evaluated lazily. We suggest that a generator
    function is essentially indistinguishable from a function that returns a generator
    expression. Both are non-strict. Both can yield a sequence of values. For this
    reason, we'll also consider generator functions as higher order. Built-in functions
    such as `map()` and `filter()` fall into this category.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充当生成器。一些函数示例使用`yield`语句使它们成为一流的生成器函数。生成器函数的值是一个惰性评估的可迭代值集合。我们认为生成器函数本质上与返回生成器表达式的函数没有区别。两者都是非严格的。两者都可以产生一系列值。因此，我们也将考虑生成器函数为高阶函数。内置函数如`map()`和`filter()`属于这一类。
- en: 'Materialize a Collection. Some functions must return a materialized collection
    object: `list`, `tuple`, `set`, or `mapping`. These kinds of functions can be
    of a higher order if they have a function as part of the arguments. Otherwise,
    they''re ordinary functions that happen to work with `collections`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个集合。一些函数必须返回一个实例化的集合对象：`list`、`tuple`、`set`或`mapping`。如果这些函数的参数中包含一个函数，那么这些函数可以是高阶函数。否则，它们只是普通的函数，恰好可以与`collections`一起使用。
- en: Reduce a Collection. Some functions work with an iterable (or a `collection`
    object) and create a `scalar` result. The `len()` and `sum()` functions are examples
    of this. We can create higher-order reductions when we accept a function as an
    argument. We'll return to this in the next chapter.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少集合。一些函数与可迭代对象（或`collection`对象）一起工作，并创建一个`scalar`结果。`len()`和`sum()`函数就是这样的例子。当我们接受一个函数作为参数时，我们可以创建高阶减少。我们将在下一章中回顾这一点。
- en: Scalar. Some functions act on individual data items. These can be higher-order
    functions if they accept another function as an argument.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量。一些函数作用于单个数据项。如果它们接受另一个函数作为参数，那么它们可以是高阶函数。
- en: As we design our own software, we can pick and choose among these established
    design patterns.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计我们自己的软件时，我们可以在这些已建立的设计模式中进行选择。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have seen two reductions that are higher-order functions:
    `max()` and `min()`. We also looked at the two central higher-order functions,
    `map()` and `filter()`. We also looked at `sorted()`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了两个高阶函数：`max()`和`min()`。我们还研究了两个核心的高阶函数，`map()`和`filter()`。我们还看了`sorted()`。
- en: We also looked at how to use a higher-order function to also transform the structure
    of data. We can perform several common transformations, including wrapping, unwrapping,
    flattening, and structure sequences of different kinds.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了如何使用高阶函数来转换数据的结构。我们可以执行几种常见的转换，包括包装、解包、扁平化和不同类型的结构序列。
- en: 'We looked at three ways to define our own higher-order functions, which are
    as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了三种定义自己的高阶函数的方法，如下所示：
- en: The `def` statement. Similar to this is a `lambda` `form` that we assign to
    a variable.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def`语句。类似的是将`lambda` `form`分配给一个变量。'
- en: Defining a `Callable` class as a kind of function that emits composite functions.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Callable`类定义为一种发出复合函数的函数。
- en: We can also use decorators to emit composite functions. We'll return to this
    in [Chapter 11](ch11.html "Chapter 11. Decorator Design Techniques"), *Decorator
    Design Techniques*.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用装饰器来发出复合函数。我们将在[第11章](ch11.html "第11章。装饰器设计技术")*装饰器设计技术*中回顾这一点。
- en: In the next chapter, we'll look at the idea of purely functional iteration via
    recursion. We'll use Pythonic structures to make several common improvements over
    purely functional techniques. We'll also look at the associated problem of performing
    reductions from collections to individual values.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨通过递归实现纯函数迭代的概念。我们将使用Python结构对纯函数技术进行几种常见的改进。我们还将探讨将集合减少到单个值的相关问题。
