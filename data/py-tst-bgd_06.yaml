- en: 'Chapter 6. Running Your Tests: Follow Your Nose'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：运行您的测试：跟随Nose
- en: '*So far, we''ve talked a lot about how to write tests, but we haven''t said
    much about how to run them. We''ve had to explicitly tell Python which tests to
    run, and we''ve had the either worry about which version of Python we were using
    (in the case of doctest) or put an `if __name__ == ''__main__''` inside every
    module (for unittest). Clearly, there''s room for improvement, when it comes to
    running tests.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们已经讨论了很多关于如何编写测试的内容，但我们还没有详细说明如何运行它们。我们不得不明确告诉Python要运行哪些测试，我们要么担心我们使用的Python版本（在doctest的情况下），要么在每个模块中放置一个`if
    __name__ == ''__main__''`。显然，在运行测试方面还有改进的空间。*'
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about a Python tool called Nose, which automatically finds and executes
    tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解一个名为Nose的Python工具，它可以自动找到并执行测试
- en: Learn how to make Nose find and execute doctest tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何让Nose找到并执行doctest测试
- en: Learn how to make Nose find and execute unittest tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何让Nose找到并执行unittest测试
- en: Learn how to use Nose's internal test framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Nose的内部测试框架
- en: So let's get on with it!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始吧！
- en: What is Nose?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Nose？
- en: Nose is a tool for finding and running all of your tests, in one easy step.
    It finds tests in multiple files, organizes them, runs them, and presents you
    with a nice report at the end. You don't have to put any special code in your
    files to make the tests runnable and you don't have to worry about which Python
    version you're running, unless your tests make use of recently added features
    to the language. Nose understands doctest and unittest tests; it even adds a few
    features to both.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Nose是一个工具，可以一步找到并运行您所有的测试。它可以在多个文件中找到测试，组织它们，运行它们，并在最后向您展示一份漂亮的报告。您不需要在文件中添加任何特殊代码来使测试可运行，也不必担心您正在运行的Python版本，除非您的测试使用了语言中最近添加的新特性。Nose理解doctest和unittest测试；它甚至为两者添加了一些功能。
- en: Installing Nose
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Nose
- en: At the time of this writing, Nose's home page is [http://code.google.com/p/python-nose/](http://code.google.com/p/python-nose/),
    with downloads available at [http://code.google.com/p/python-nose/downloads/list](http://code.google.com/p/python-nose/downloads/list).
    Go ahead and download the latest version, and uncompress it into a temporary directory.
    If you're using Windows, you'll need a program such as 7-Zip ([http://7-zip.org/](http://7-zip.org/))
    to uncompress the file; Linux and Mac users won't need any special software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Nose的主页是[http://code.google.com/p/python-nose/](http://code.google.com/p/python-nose/)，您可以在[http://code.google.com/p/python-nose/downloads/list](http://code.google.com/p/python-nose/downloads/list)找到可用的下载。请下载最新版本，并将其解压缩到临时目录中。如果您使用的是Windows，您需要像7-Zip([http://7-zip.org/](http://7-zip.org/))这样的程序来解压缩文件；Linux和Mac用户不需要任何特殊软件。
- en: 'After uncompressing Nose, we need to install it. Everything we had to consider
    when installing Mocker applies here too: If you installed Python, you can just
    change to the Nose directory and type:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解压缩Nose后，我们需要安装它。在安装Mocker时需要考虑的所有事情在这里同样适用：如果您安装了Python，您只需切换到Nose目录并输入：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you didn''t install Python, but you''re using version 2.6 or higher, you
    can instead type:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装Python，但正在使用2.6或更高版本，您可以输入以下命令：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you go for the `--user` installation, you might need to add a directory
    to the search path of your operating system. You''ll know you need to if you can''t
    run the `nosetests` program after installing it. On Linux or Mac, the directory
    that you need to add is `~/.local/bin`, while on Windows it''s `%APPDATA%\Python\Scripts`.
    Additionally, on Windows you may need to create a file called `nosetests.bat`
    in the `%APPDATA%\Python\Scripts directory`, containing the line: `@python %APPDATA%\Python\Scripts\nosetests.`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择`--user`安装，您可能需要将一个目录添加到操作系统的搜索路径中。如果您在安装后无法运行`nosetests`程序，您就会知道需要这样做。在Linux或Mac上，您需要添加的目录是`~/.local/bin`，而在Windows上则是`%APPDATA%\Python\Scripts`。另外，在Windows上，您可能需要在`%APPDATA%\Python\Scripts`目录中创建一个名为`nosetests.bat`的文件，其中包含以下行：`@python
    %APPDATA%\Python\Scripts\nosetests.`。
- en: Sometimes, a tool called `easy_install` can simplify the installation process
    of Python modules and packages. If you want to give it a try, download and install
    setuptools from [http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools),
    and then run the command easy_install nose. Once that command is executed, you
    should be ready to use Nose.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个名为`easy_install`的工具可以简化Python模块和包的安装过程。如果您想尝试一下，请从[http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools)下载并安装setuptools，然后运行命令easy_install
    nose。一旦执行了这个命令，您就应该可以使用Nose了。
- en: 'After installing it, you should be able to run `nosetests` by typing its name
    on the command line. If you run it in an empty directory, you should see output
    similar to this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您应该能够在命令行中键入其名称来运行`nosetests`。如果您在空目录中运行它，您应该看到类似以下输出：
- en: '![Installing Nose](img/8846_06_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![安装Nose](img/8846_06_01.jpg)'
- en: Organizing tests
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织测试
- en: All right, we've got Nose installed, so what's it good for? Nose looks through
    a directory's structure, finds the test files, sorts out the tests that they contain,
    runs the tests, and reports the results back to you. That's a lot of work that
    it saves you from having to do each time you want to run your tests (which should
    be often).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经安装了Nose，那么它有什么好处呢？Nose会遍历目录结构，找到测试文件，整理出它们包含的测试，运行测试，并将结果反馈给您。这节省了您每次运行测试时（您应该经常这样做）需要做的很多工作。
- en: Nose recognizes test files based on their names. Any file whose name contains
    `test` or `Test` either at the beginning or following any of the characters `_`,
    `.`, or `–` (this is often referred to as "underscore", dot, or dash) is recognized
    as a file that contains unittest `TestCase`s (or Nose's own test functions, which
    we'll talk about later) which should be executed. Any directory whose name matches
    the same pattern is recognized as a directory that might contain tests, and so
    should be searched for test files. Nose can find and execute doctest tests as
    well, either embedded in docstrings or written in separate test files. By default,
    it won't look for doctest tests unless we tell it to. We'll see how to change
    the default shortly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Nose根据文件名识别测试文件。任何文件名包含`test`或`Test`，无论是位于开头还是跟在任意字符`_`、`.`或`–`（通常称为下划线、点或破折号）之后，都被识别为包含unittest
    `TestCase`s（或Nose自己的测试函数，我们稍后会讨论）的文件，应该执行。任何名称符合相同模式的目录都被识别为可能包含测试的目录，因此应该搜索测试文件。Nose还可以找到并执行doctest测试，无论是嵌入在docstrings中还是单独编写在测试文件中。默认情况下，它不会寻找doctest测试，除非我们告诉它。我们很快就会看到如何更改默认设置。
- en: 'Since Nose is so willing to go looking for our tests, we have a lot of freedom
    with respect to how we organize them. It often turns out to be a good idea to
    separate all of the tests into their own directory, or for larger projects into
    a whole tree of directories. A big project can end up having thousands of tests,
    so organizing them for easy navigation is a big benefit. If doctests are being
    used as documentation, as well as testing, it''s probably a good idea to store
    them in yet another separate directory, with a name that communicates that they
    are documentary. For a moderately-sized project, the recommended structure might
    look like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Nose非常愿意寻找我们的测试，我们在组织测试方面有很大的自由度。通常，将所有测试分离到它们自己的目录中，或者对于更大的项目，分离到整个目录树中，都是一个很好的主意。大型项目可能最终会有数千个测试，因此为了便于导航而组织它们是一个很大的好处。如果doctests被用作文档以及测试，那么将它们存储在另一个单独的目录中，并使用一个传达它们是文档的名称，可能是一个好主意。对于中等规模的项目，建议的结构可能如下所示：
- en: '![Organizing tests](img/8846_06_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![组织测试](img/8846_06_02.jpg)'
- en: That structure is only a recommendation (it's for your benefit, not for Nose's).
    If a different structure would make things easier for you, go ahead and use it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构仅作为一个建议（这是为了您的利益，而不是为了Nose）。如果不同的结构能让您更容易操作，请随意使用。
- en: Time for action – organizing tests from previous chapters
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 组织前几章的测试
- en: We're going to take our tests from the previous chapters and organize them all
    into a tree of directories. Then we'll use Nose to run them all.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从前几章的测试中提取出来，将它们全部组织成一个目录树。然后我们将使用Nose来运行它们。
- en: Create a directory to hold our code and tests; you can choose any name for it,
    but I'll refer to it as `project` here.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录来存放我们的代码和测试；您可以为它选择任何名称，但在这里我将称它为`project`。
- en: Put `pid.py`, `operations.py` and `testable.py` inside of `project`. When we
    run `nosetests` in the `project` directory, modules (and packages) stored in `project`
    will be accessible to all of the tests, no matter where the test is stored in
    the directory tree.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`pid.py`、`operations.py`和`testable.py`放入`project`目录中。当我们运行`nosetests`在`project`目录下时，存储在`project`中的模块（和包）将可供所有测试访问，无论测试存储在目录树中的哪个位置。
- en: Create a subdirectory called `test_chapter2`, and place the `test.txt` and `test.py`
    files from Chapter 2 in it.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test_chapter2`的子目录，并将第2章的`test.txt`和`test.py`文件放入其中。
- en: Create a subdirectory called `test_chapter3`, and place the final `pid.txt`
    file from Chapter 3 in it.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test_chapter3`的子目录，并将第3章的最终`pid.txt`文件放入其中。
- en: Create a subdirectory called `test_chapter4`, and place the code from the Chapter
    4 examples (if you have them) and *Time for action* sections in it.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test_chapter4`的子目录，并将第4章示例（如果你有）和*执行动作*部分中的代码放入其中。
- en: 'Create a subdirectory called `test_chapter5`, and place the code from the Chapter
    5 examples (if you have them) and *Time for action* sections into it. Because
    Chapter 5 uses unittest tests, we also need to rename each of the files so that
    Nose will recognize them as test files. Good names for the files are:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test_chapter5`的子目录，并将第5章示例（如果你有）和*执行动作*部分中的代码放入其中。因为第5章使用了unittest测试，我们还需要重命名每个文件，以便Nose能识别它们为测试文件。文件的好名字可以是：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that you have the tests all put together and organized, let''s run them.
    To do that, change to the `project` directory and type:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经将所有测试整理并组织好了，让我们来运行它们。为此，切换到`project`目录并输入以下命令：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can leave off the `-v` if you want. All it does is to tell Nose to give
    a more detailed report of what it's doing.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不想使用`-v`选项，也可以。它只是告诉Nose提供更详细的操作报告。
- en: All of the tests should run. We expect to see a few failures, since some of
    the tests from previous chapters were intended to fail, for illustrative purposes.
    There's one failure though, that we need to consider:![Time for action – organizing
    tests from previous chapters](img/8846_06_03.jpg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有测试都应该运行。我们预计会看到一些失败，因为一些来自前几章的测试是为了说明目的而故意设计的。不过，有一个失败需要我们考虑：![执行动作时间 - 组织前几章的测试](img/8846_06_03.jpg)
- en: 'The first part of that error report can be safely ignored: it just means that
    the whole doctest file is being treated as a failing test by Nose. The useful
    information comes in the second part of the report. It''s telling us that where
    we expected to get a previous time of 1.0, we''re instead getting a very large
    number (which will be different, and larger, when you run the test for yourself,
    since it happens to represent the time in seconds since a point several decades
    in the past). What''s going on? Didn''t we replace `time.time` for that test with
    a mock? Let''s take a look at the relevant part of `pid.txt`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误报告的第一部分可以安全忽略：它只是意味着整个doctest文件被Nose当作一个失败的测试处理。有用的信息在报告的第二部分。它告诉我们，我们期望得到一个1.0的先前时间，但我们得到的是一个非常大的数字（当你自己运行测试时，这个数字会不同，并且更大，因为它实际上代表了几十年前的某个时间点以来的秒数）。发生了什么？我们没有为那个测试替换`time.time`吗？让我们看看`pid.txt`的相关部分：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We mocked `time.time`, but we did it the ad hoc way instead of by using Mocker''s
    `replace` method. This means that modules which did a `from` `time` `import` `time`
    and were imported before the test file is executed will have imported the real
    `time` function, and won''t know about our mock. So, was `pid.py` imported by
    some other thing, before `pid.txt` imported it? As it happens, it was: Nose itself
    imported it when it was scanning for tests to execute. If we''re using Nose, we
    can''t count on our import statements actually being the first to import any given
    module. We can fix the problem easily, though, by using Mocker (Note that we''re
    only looking at the first test in the file here. There is another test that also
    needs to be fixed in the same way):'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们模拟了`time.time`，但我们使用的是临时方法，而不是通过Mocker的`replace`方法。这意味着在测试文件执行之前导入的模块，如果使用了`from
    time import time`，将会导入真实的`time`函数，而不知道我们的模拟。那么，`pid.py`是在`pid.txt`导入之前被其他东西导入的吗？实际上，是的：Nose在扫描要执行的测试时将其导入。如果我们使用Nose，我们不能指望我们的导入语句是导入任何给定模块的第一个。不过，我们可以通过使用Mocker轻松解决这个问题（注意，我们在这里只查看文件中的第一个测试。还有一个测试也需要以同样的方式修复）：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now when we use nosetests to run the tests again, the only failures are the
    expected ones. Here's the overview that Nose prints because we passed the `-v`
    command line option:![Time for action – organizing tests from previous chapters](img/8846_06_04.jpg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们再次使用nosetests运行测试时，唯一的失败是预期的。这是Nose打印的概述，因为我们传递了`-v`命令行选项：![执行动作时间 - 组织前几章的测试](img/8846_06_04.jpg)
- en: '*What just happened?*'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We ran all of those tests, with a single command. Pretty good, right? We're
    getting to the point now where testing is becoming broadly useful.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一条命令运行了所有这些测试。相当不错，对吧？我们现在正达到测试变得广泛有用的地步。
- en: Thanks to Nose, we don't need those goofy `if` `__name__ == '__main__'` blocks
    at the end of each unittest file, and we don't need to memorize any arcane commands
    to execute the doctest files. We can store our tests in a separate and well-organized
    directory structure, and run them all with a single, quick, and simple command.
    We can also easily run a subset of our tests, by passing the filenames, module
    names, or directories containing the tests that we want to run as command line
    parameters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Nose，我们不需要在每个unittest文件末尾的愚蠢的`if __name__ == '__main__'`块，也不需要记住任何神秘的命令来执行doctest文件。我们可以将我们的测试存储在单独且井然有序的目录结构中，并通过一个简单、快速、单一的命令运行它们。我们还可以通过传递包含我们想要运行的测试的文件名、模块名或目录作为命令行参数，轻松地运行测试的子集。
- en: We also saw how hidden assumptions can break tests, just as they can break the
    code being tested. Until now, we've been assuming that when one of our tests imports
    a module, that's the first time the module has been imported. Some of our tests
    relied on that assumption to replace library objects with mocks. Now that we're
    dealing with running many tests aggregated together, with no guaranteed order
    of execution, that assumption wasn't reliable. On top of that, the module we had
    trouble with actually had to be imported to search it for tests, before any of
    our tests were run. That would have been a problem, except we already have a tool
    for replacing library objects, regardless of the order of imports. A quick switch
    of the affected tests to use Mocker and we're good to go.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了隐藏的假设如何破坏测试，就像它们可以破坏被测试的代码一样。到目前为止，我们一直假设当我们的测试导入一个模块时，这是模块第一次被导入。一些测试依赖于这个假设来用模拟对象替换库对象。现在我们正在处理运行许多聚合在一起的测试，没有保证执行顺序的情况，这个假设并不可靠。更不用说，我们遇到麻烦的模块实际上必须被导入以在运行任何测试之前搜索它。那会是一个问题，但我们已经有一个工具可以替换库对象，无论导入顺序如何。只需快速切换受影响的测试使用Mocker，我们就可以继续前进。
- en: Finding doctests
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找doctests
- en: 'The `nosetests` command that we used in the previous section was fairly easy
    to understand, but it was still a bit long to type in all of the time. Instead
    of:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中使用的`nosetests`命令相当容易理解，但每次输入时仍然有点长。而不是：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''d really like to be able to just type:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的很希望能够直接输入：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or even:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To execute our tests, and still have it find and execute all of our doctests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行我们的测试，并且仍然能够找到并执行所有的doctests。
- en: 'Fortunately, it''s a simple matter to tell Nose that we want it to use different
    defaults for the values of those command line switches. To do this, just create
    a configuration file called `nose.cfg` or `.noserc` (either name will work) in
    your home directory, and placing the following inside of it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，告诉Nose我们想要它为那些命令行开关的值使用不同的默认值是一件简单的事情。为此，只需在你的主目录中创建一个名为`nose.cfg`或`.noserc`（任一名称都行）的配置文件，并在其中放置以下内容：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From now on, whenever you run `nosetests`, it will assume those options, unless
    you tell it otherwise. You don't have to type them on the command line any more.
    You can use the same trick for any option that Nose can accept on the command
    line.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次你运行`nosetests`，它都会假设那些选项，除非你告诉它否则。你不再需要在命令行上输入它们。你可以为Nose可以接受的所有命令行选项使用同样的技巧。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're a Windows user, you might not be sure what the phrase 'home directory'
    is supposed to refer to in this context. As far as Python is concerned, your home
    directory is defined by your environment variables. If `HOME` is defined, that's
    your home directory. Otherwise, if `USERPROFILE` is defined (it usually is, pointing
    at `C:\Documents and Settings\USERNAME`) then that's what is considered to be
    your home directory. Otherwise, the directory described by `HOMEDRIVE` and `HOMEPATH`
    (often `C:\`)is your home directory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个Windows用户，你可能不确定在这个上下文中短语“主目录”指的是什么。就Python而言，你的主目录由你的环境变量定义。如果`HOME`被定义，那就是你的主目录。否则，如果`USERPROFILE`被定义（通常是这样，指向`C:\Documents
    and Settings\USERNAME`），那么那被认为是你的主目录。否则，由`HOMEDRIVE`和`HOMEPATH`（通常是`C:\`）描述的目录是你的主目录。
- en: Customizing Nose's search
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义Nose的搜索
- en: We've said before that Nose looks for tests in directories and modules whose
    names start with `test` or `Test`, or contain a '`_`','`.`'`,` or '`-`' followed
    by `test` or `Test`. That's the default, but it's not actually the whole story.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，Nose会在以`test`或`Test`开头的目录和模块中查找测试，或者包含一个`'_'`、`'.'`、`'-'`后跟`test`或`Test`的字符。这是默认设置，但并不是全部故事。
- en: If you know regular expressions, you can customize the pattern that Nose uses
    to look for tests. You do this by passing the `--include=REGEX` command line option
    or by putting `include=REGEX` in your `nose.cfg` or `.noserc`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解正则表达式，你可以自定义Nose用来查找测试的模板。你可以通过传递`--include=REGEX`命令行选项或在你的`nose.cfg`或`.noserc`文件中放入`include=REGEX`来实现这一点。
- en: 'For example, if you do this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你这样做：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Nose will (in addition to looking for names as described above) also look for
    names that start with `doc` or `Doc`. That means you can call the directory containing
    your doctest files `docs`, `Documentation`, `doctests`, and so on, and Nose will
    still find it and run the tests. If you use this option often, you'll almost certainly
    want to add it to your configuration file, as described under the previous heading.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述描述的查找名称外，Nose还会查找以`doc`或`Doc`开头的名称。这意味着你可以将包含你的doctest文件的目录命名为`docs`、`Documentation`、`doctests`等，Nose仍然会找到它并运行测试。如果你经常使用此选项，你几乎肯定希望将其添加到你的配置文件中，如前一个标题下所述。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full syntax and use of regular expressions is a subject in itself, and has
    been the topic of many books. However, you can find everything you need, to do
    this sort of thing in the Python documentation at [http://docs.python.org/library/re.html](http://docs.python.org/library/re.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的完整语法和使用是一个主题本身，并且已经成为了许多书籍的主题。然而，你可以在Python文档中找到你需要的一切，以在[http://docs.python.org/library/re.html](http://docs.python.org/library/re.html)中做这类事情。
- en: Pop quiz – testing with Nose
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——使用Nose进行测试
- en: By running `nosetests --processes=4`, Nose can be made to launch four testing
    processes, which can provide a big performance gain if you're running the tests
    on a quad-core system. How would you make Nose always launch four testing processes,
    without being told on the command line?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`nosetests --processes=4`，Nose可以启动四个测试进程，如果你在一个四核系统上运行测试，这将提供很大的性能提升。你将如何让Nose始终启动四个测试进程，而无需在命令行中指定？
- en: If some of your tests were stored in a directory called `specs`, how would you
    tell Nose that it should search that directory for tests?
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一些测试存储在一个名为`specs`的目录中，你将如何告诉Nose它应该在该目录中搜索测试？
- en: 'Which of the following will by default be recognized by Nose as possibly containing
    tests: `UnitTests`, `unit_tests`, `TestFiles`, `test_files`, `doctests`?'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个默认情况下会被Nose识别为可能包含测试的：`UnitTests`、`unit_tests`、`TestFiles`、`test_files`、`doctests`？
- en: Have a go hero – nosing around
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——Nose探索
- en: Write some `doctest` and `unittest` tests for the following specification, and
    create a directory tree to contain them and the code that they describe. Write
    the code using the test-driven methodology, and use Nose to run the tests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为以下规范编写一些`doctest`和`unittest`测试，并创建一个目录树来包含它们以及它们描述的代码。使用测试驱动的方法编写代码，并使用Nose运行测试。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Nose and doctest
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nose和doctest
- en: doesn't just support doctest, it actually enhances it. When you're using Nose,
    you can write test fixtures for your doctest files.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不只是支持doctest，它实际上增强了它。当你使用Nose时，你可以为你的doctest文件编写测试固定值。
- en: If you pass `--doctest-fixtures=_fixture` on the command line, Nose will go
    looking for a fixture file whenever it finds a doctest file. The name of the fixture
    file is based on the name of the doctest file and is calculated by appending the
    doctest fixture suffix (in other words, the value of `doctest-fixtures`) to the
    main part of the doctest file name, and then adding `.py` to the end. For example,
    if Nose found a doctest file called `pid.txt`, and had been told that `doctest-fixtures=_fixture`,
    it would try to find the test fixture in a file called `pid_fixture.py`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过命令行传递`--doctest-fixtures=_fixture`，Nose将在找到doctest文件时寻找一个固定值文件。固定值文件的名字基于doctest文件的名字，通过在doctest文件名的主要部分后添加doctest固定值后缀（换句话说，`doctest-fixtures`的值）并添加`.py`到末尾来计算。例如，如果Nose找到一个名为`pid.txt`的doctest文件，并且被告知`doctest-fixtures=_fixture`，它将尝试在一个名为`pid_fixture.py`的文件中找到测试固定值。
- en: 'The test fixture file for a doctest is very simple: it''s just a Python module
    that contains a `setup()` or `setUp()` function and a `teardown()` or `tearDown()`
    function. The setup function is executed before the doctest file, and the teardown
    function is executed after.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: doctest的测试固定值文件非常简单：它只是一个包含`setup()`或`setUp()`函数和`teardown()`或`tearDown()`函数的Python模块。设置函数在doctest文件之前执行，而清理函数在之后执行。
- en: The fixture operates in a different namespace to the doctest file, so none of
    the variables that get defined in the fixture module are visible in the actual
    tests. If you want to share variables between the fixture and the test, you'll
    probably want to do it by making a simple little module to hold the variables,
    which you can import into both the fixture and the test.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 装置在doctest文件的不同命名空间中运行，因此固定装置模块中定义的任何变量在实际测试中都是不可见的。如果你想在装置和测试之间共享变量，你可能需要创建一个简单的模块来保存这些变量，你可以将其导入到装置和测试中。
- en: Mocker replacements work fine when done in a doctest fixture. As long as you
    don't `restore()` them during the setup (and why would you do a silly thing like
    that?) then they'll still be in place when the test uses the replaced object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在doctest装置中进行的模拟替换工作得很好。只要你在设置期间不调用`restore()`（你为什么要做这样愚蠢的事情？），那么当测试使用替换的对象时，它们仍然会保留。
- en: Time for action – creating a fixture for a doctest
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 为doctest创建固定装置
- en: We'll provide a mock `time.time()` in our test fixture and use it in our doctest.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试装置中提供一个模拟的`time.time()`并在我们的doctest中使用它。
- en: 'Create a file called `times.txt` containing the following doctest code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`times.txt`的文件，包含以下doctest代码：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the doctest file using Nose, and the following screen gets displayed:![Time
    for action – creating a fixture for a doctest](img/8846_06_05.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Nose运行doctest文件，以下屏幕会显示：![行动时间 – 为doctest创建固定装置](img/8846_06_05.jpg)
- en: 'Unless your computer''s clock was reset to the beginning of the epoch at just
    the right moment, the doctest failed. We need a mock to replace `time.time()`
    if we want these tests to pass reliably. Create a file called `times_fixture.py`
    and insert the following Python code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非你的计算机时钟恰好重置到纪元的开始，否则doctest会失败。如果我们想这些测试能够可靠地通过，我们需要一个模拟来替换`time.time()`。创建一个名为`times_fixture.py`的文件，并插入以下Python代码：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now when we run Nose and tell it how to find doctest fixtures, the doctest passes,
    because it's using the mock that we set up in the fixture:![Time for action –
    creating a fixture for a doctest](img/8846_06_06.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们运行Nose并告诉它如何找到doctest固定装置，doctest通过，因为它使用了我们在装置中设置的模拟：![行动时间 – 为doctest创建固定装置](img/8846_06_06.jpg)
- en: If you use this facility often, it makes sense to add `doctest-fixtures=_fixture`
    to your Nose configuration file.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你经常使用这个功能，将`doctest-fixtures=_fixture`添加到你的Nose配置文件中是有意义的。
- en: Nose and unittest
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nose和unittest
- en: Nose enhances unittest, by providing test fixtures at the package and module
    levels. The package setup function is run before any of the tests in any of the
    modules in a package, while the teardown function is run after all of the tests
    in all of the modules in the package have completed. Similarly, the module setup
    is run before any of the tests in a given module execute, and the module teardown
    is executed after all of the tests in the module have been executed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Nose通过在包和模块级别提供测试装置来增强unittest。包设置函数在包中任何模块的任何测试之前运行，而清理函数在包中所有模块的所有测试完成后运行。同样，模块设置在给定模块的任何测试执行之前运行，模块清理在模块中所有测试执行之后执行。
- en: Time for action – creating a module fixture
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建模块固定装置
- en: We'll build a test module with a module-level fixture. In the fixture, we'll
    replace the `datetime.date.today` function, which normally returns an object representing
    the current date. We want it to return a specific value, so that our tests can
    know what to expect.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用模块级别的固定装置来构建一个测试模块。在这个装置中，我们将替换`datetime.date.today`函数，它通常返回一个表示当前日期的对象。我们希望它返回一个特定的值，这样我们的测试就可以知道期望什么。
- en: Create a directory called `tests`. We'll use this directory in this *Time for
    action*, as well as in the next one.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`tests`的目录。在这个*行动时间*以及下一个中，我们将使用这个目录。
- en: 'Within the `tests` directory, create a file called `module_fixture_tests.py`
    containing the following code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests`目录中，创建一个名为`module_fixture_tests.py`的文件，包含以下代码：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that there are two `TestCase` classes in this module. Using pure unittest,
    we'd have to duplicate the fixture code in each of those classes.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在这个模块中有两个`TestCase`类。使用纯unittest，我们不得不在每个类中复制固定装置代码。
- en: 'Go ahead and run the tests by moving to the directory that contains the `tests`
    directory and typing:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往包含`tests`目录的目录，并输入以下命令来运行测试：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Nose will recognize tests as a directory that may contain tests (because of
    the directory name), find the `module_fixtures_tests.py` file, run the `setup`
    function, run all of the tests, and then run the `teardown` function. There won't
    be much to see though, aside from a simple report of how many tests passed.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nose会将测试识别为可能包含测试的目录（因为目录名），找到`module_fixtures_tests.py`文件，运行`setup`函数，运行所有测试，然后运行`teardown`函数。不过，除了一个简单的测试通过报告外，你不会看到太多内容。
- en: '*What just happened?*'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We saved ourselves some time and effort by using a second 'layer' of test fixtures,
    which wrap around entire test modules instead of single test methods. By doing
    this, we saved ourselves from duplicating the fixture code inside every test class
    in the module, but this savings comes with a cost. The setup and teardown aren't
    run before and after each test, as normal test fixtures are. Instead, all of the
    tests in the module happen between a single module-level setup/teardown pair,
    which means that if a test does something that affects the environment created
    by the setup function, it won't be undone before the next test runs. In other
    words, isolation of tests is not guaranteed with respect to the environment created
    by a module-level fixture.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个额外的“层”测试固定件，我们将整个测试模块而不是单个测试方法封装起来，从而节省了一些时间和精力。通过这样做，我们避免了在每个测试类中重复固定件代码，但这种节省是有代价的。与正常的测试固定件不同，设置和清理不是在每个测试前后运行。相反，模块中的所有测试都在单个模块级设置/清理对之间发生，这意味着如果测试执行了影响设置函数创建的环境的操作，它不会在下一个测试运行之前被撤销。换句话说，测试的环境隔离性不能保证。
- en: Now we'll expand on the previous *Time for action* by including a package-level
    test fixture. Like the module-level test fixture, this is a labor-saving feature
    of Nose.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过包括包级测试固定件来扩展之前的*行动时间*。与模块级测试固定件一样，这也是Nose的一个节省劳动力的特性。
- en: Time for action – creating a package fixture
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建包固定件
- en: Now we'll create a fixture that wraps around all the test modules in an entire
    package.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个封装整个包中所有测试模块的测试固定件。
- en: 'Add a new file called `__init__.py` in the `tests` directory that we created
    in the last *Time for action* section. (That''s two underbars, the word ''init,
    and two more underbars). The presence of this file tells Python that the directory
    is a package. Place the following code inside of `__init__.py` in the `tests`
    directory:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一节*行动时间*中创建的`tests`目录中添加一个名为`__init__.py`的新文件。（这是两个下划线，单词'init'，还有两个下划线）。此文件的存在告诉Python该目录是一个包。将以下代码放置在`tests`目录下的`__init__.py`文件中：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's fairly common that `__init__.py` files are completely empty, but they're
    a perfect place for code that is general to an entire package, so that's where
    Nose looks for a package-level fixture.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`__init__.py`文件通常是空的，但它们是放置适用于整个包的通用代码的完美地方，因此Nose就在那里寻找包级固定件。'
- en: 'Add a new file called `package_fixtures_tests.py` to the `tests` directory,
    with the following contents:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests`目录下添加一个名为`package_fixtures_tests.py`的新文件，其内容如下：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following code to the already-existing `module_fixtures_tests.py` (We
    could place it in its own file too. The point is placing it in a separate module
    from the tests in step 2, for you to see that the package test fixture is in place):'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到已存在的`module_fixtures_tests.py`文件中（我们也可以将其放在自己的文件中。重点是将其放置在与步骤2中的测试分开的模块中，以便你能看到包测试固定件已经就位）：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Go ahead an run the tests again. (You won''t see much output, but that means
    everything worked) Go to the directory containing `tests` and run the following:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续再次运行测试。（你不会看到太多输出，但这意味着一切正常）转到包含`tests`的目录，并运行以下命令：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*What just happened?*'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We worked with yet another layer of test fixture, this time wrapping around
    all of the test modules in the `tests` directory. As you can see from looking
    at the code that we just wrote, the environment created by the package-level test
    fixture is available in every test in every module in the package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与另一个测试固定件层合作，这次是封装了`tests`目录中的所有测试模块。从我们刚刚编写的代码中可以看出，包级测试固定件创建的环境在包中每个模块的每个测试中都是可用的。
- en: Like module-level test fixtures, package-level test fixtures can be a big labor-saving
    shortcut. However, they don't provide you with the protection against communication
    between tests that *real* test-level fixtures do.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与模块级测试固定件一样，包级测试固定件可以是一个节省大量劳动的快捷方式。然而，它们并不提供与真实测试级固定件相同的保护，以防止测试之间的通信。
- en: Nose's own testing framework
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nose的自身测试框架
- en: 'Nose supports two new kinds of tests: stand-alone test functions and non-TestCase
    test classes. It finds these tests by using the same pattern matching that it
    uses to find test modules. When looking through a module whose name matches the
    pattern, any functions or classes whose names also match the pattern, are assumed
    to be tests.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Nose支持两种新的测试类型：独立的测试函数和非TestCase测试类。它通过使用与查找测试模块相同的模式匹配来找到这些测试。当遍历一个名称与模式匹配的模块时，任何名称也匹配该模式的函数或类都被假定是测试。
- en: Time for action – using Nose-specific tests
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用Nose特定的测试
- en: We'll write a few tests that demonstrate Nose's support for test functions and
    non-TestCase test classes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一些测试来展示Nose对测试函数和非TestCase测试类的支持。
- en: 'Create a file called `nose_specific_tests.py` with the following contents:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nose_specific_tests.py`的文件，并包含以下内容：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now add the following text to the same file, outside of the `grouped_tests`
    class:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将以下文本添加到同一文件中，在`grouped_tests`类之外：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the tests, although as usual you don''t want to see any output beyond a
    report of how many tests were executed:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试，尽管像往常一样，你不想看到除测试执行报告之外的任何输出：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*What just happened?*'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `grouped_tests` class contains a test fixture (the `setup` and `teardown`
    methods) and two tests, but it's not a unittest `TestCase` class. Nose recognized
    it as a test class because its name follows the same pattern that Nose looks for,
    when it checks module names to find test modules. It then looks through the class
    for a test fixture (and any test methods), and runs them appropriately.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`grouped_tests`类包含一个测试固定装置（`setup`和`teardown`方法）和两个测试，但它不是一个unittest的`TestCase`类。Nose将其识别为测试类，因为其名称遵循Nose在检查模块名称以查找测试模块时寻找的相同模式。然后它遍历该类以查找测试固定装置（以及任何测试方法），并适当地运行它们。'
- en: Since the class isn't a `TestCase`, the tests don't have access to any of unittest's
    `assert` methods; Nose considers such a test to pass unless it raises an exception.
    Python has an `assert` statement that raises an exception if its expression is
    false, which is helpful for this sort of thing. It's not as nice as `assertEqual`,
    but it does the job in many cases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该类不是`TestCase`，测试无法访问unittest的任何`assert`方法；Nose认为这种测试通过，除非它引发异常。Python有一个`assert`语句，如果其表达式为假，则会引发异常，这对于这种情况很有帮助。它不如`assertEqual`那样优雅，但在许多情况下可以完成任务。
- en: We wrote another test in the function `standalone_test`. Like `grouped_tests`,
    `standalone_test` is recognized as a test by Nose because its name matches the
    same pattern that Nose uses to search for test modules. Nose runs `standalone_test`
    as a test, and reports a failure if it raises an exception.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`standalone_test`函数中编写了另一个测试。像`grouped_tests`一样，`standalone_test`被Nose识别为测试，因为其名称与Nose用于搜索测试模块的相同模式匹配。Nose将`standalone_test`作为测试运行，如果它引发异常，则报告失败。
- en: We were able to attach a test fixture to `standalone_test`, by setting its `setup`
    and `teardown` attributes to a pair of functions that we defined for that purpose.
    As usual, the setup function gets executed before the test function and the teardown
    function gets run after.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够通过将`standalone_test`的`setup`和`teardown`属性设置为定义的函数对来将其附加到`standalone_test`上。像往常一样，设置函数在测试函数之前执行，而清理函数在测试函数之后执行。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about the Nose testing meta-framework.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关于Nose测试元框架学到了很多。
- en: 'Specifically, we covered:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How Nose finds the files that contain tests, and how you can adapt the process
    to fit into your organization scheme
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nose如何找到包含测试的文件，以及如何将此过程适应到你的组织方案中
- en: How to run all of your tests with Nose, whether they are doctest, unittest,
    or nose-specific tests
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Nose运行所有测试，无论它们是doctest、unittest还是Nose特定的测试
- en: How Nose enhances the other frameworks with additional support for test fixtures
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过额外的测试固定装置支持增强其他框架
- en: How to use Nose's test functions and non-TestCase test classes
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Nose的测试函数和非TestCase测试类
- en: Now that we've learned about Nose and running all of our tests easily, we're
    ready to tackle a complete test-driven project—which is the topic of the next
    chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Nose和轻松运行所有测试，我们准备着手一个完整的测试驱动型项目——这是下一章的主题。
