- en: GUIs and Scripts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI和脚本
- en: '"A user interface is like a joke. If you have to explain it, it''s not that
    good."– Martin LeBlanc'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “用户界面就像一个笑话。如果你不得不解释它，那就不是那么好。”– Martin LeBlanc
- en: 'In this chapter, we''re going to work on a project together. We are going to
    write a simple scraper that finds and saves images from a web page. We''ll focus
    on three parts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一起开展一个项目。我们将编写一个简单的抓取器，用于查找和保存网页中的图像。我们将专注于三个部分：
- en: A simple HTTP webserver in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的简单HTTP网络服务器
- en: A script that scrapes a given URL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于抓取给定URL的脚本
- en: A GUI application that scrapes a given URL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个GUI应用程序，用于抓取给定URL
- en: A **graphical user interface** (**GUI**) is a type of interface that allows
    the user to interact with an electronic device through graphical icons, buttons,
    and widgets, as opposed to text-based or command-line interfaces, which require
    commands or text to be typed on the keyboard. In a nutshell, any browser, any
    office suite such as LibreOffice, and, in general, anything that pops up when
    you click on an icon, is a GUI application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面**（**GUI**）是一种允许用户通过图形图标、按钮和小部件与电子设备进行交互的界面类型，与需要在键盘上键入命令或文本的基于文本或命令行的界面相对。简而言之，任何浏览器，任何办公套件（如LibreOffice）以及一般情况下，任何在单击图标时弹出的东西都是GUI应用程序。'
- en: 'So, if you haven''t already done so, this would be the perfect time to start
    a console and position yourself in a folder called `ch12` in the root of your
    project for this book. Within that folder, we''ll create two Python modules (`scrape.py`
    and `guiscrape.py`) and a folder (`simple_server`). Within `simple_server`, we''ll
    write our HTML page: `index.html`. Images will be stored in `simple_server/img`.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您还没有这样做，现在是在名为`ch12`的文件夹中的项目根目录中启动控制台并定位的绝佳时机。在该文件夹中，我们将创建两个Python模块（`scrape.py`和`guiscrape.py`）和一个文件夹（`simple_server`）。在`simple_server`中，我们将编写我们的HTML页面：`index.html`。图像将存储在`simple_server/img`中。
- en: 'The structure in `ch12` should look like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch12`中的结构应该是这样的：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you're using either Linux or macOS, you can do what I do and put the code
    to start the HTTP server in a `serve.sh` file. On Windows, you'll probably want
    to use a batch file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Linux或macOS，您可以像我一样将启动HTTP服务器的代码放在一个名为`serve.sh`的文件中。在Windows上，您可能想使用批处理文件。
- en: 'The HTML page we''re going to scrape has the following structure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要抓取的HTML页面具有以下结构：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's an extremely simple page, so let's just note that we have five images,
    three of which are PNGs and two of which are JPGs (note that even though they
    are both JPGs, one ends with `.jpg` and the other with `.jpeg`, which are both
    valid extensions for this format).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的页面，所以我们只需要注意一下，我们有五张图片，其中三张是PNG格式，两张是JPG格式（请注意，尽管它们都是JPG格式，但一张以`.jpg`结尾，另一张以`.jpeg`结尾，这两种都是此格式的有效扩展名）。
- en: 'So, Python gives you a very simple HTTP server for free that you can start
    with the following command (in the `simple_server` folder):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python为您提供了一个非常简单的免费HTTP服务器，您可以使用以下命令启动它（在`simple_server`文件夹中）：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last line is the log you get when you access `http://localhost:8000`, where
    our beautiful page will be served. Alternatively, you can put that command in
    a file called `serve.sh`, and just run that with this command (make sure it''s
    executable):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是当您访问`http://localhost:8000`时得到的日志，我们美丽的页面将在那里提供。或者，您可以将该命令放在一个名为`serve.sh`的文件中，并使用以下命令运行它（确保它是可执行的）：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It will have the same effect. If you have the code for this book, your page
    should look something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它将产生相同的效果。如果您有本书的代码，您的页面应该看起来像这样：
- en: '![](../images/00012.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00012.jpeg)'
- en: Feel free to use any other set of images, as long as you use at least one PNG
    and one JPG, and that in the `src` tag you use relative paths, not absolute ones.
    I got these lovely owls from [https://openclipart.org/](https://openclipart.org/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用任何其他图像集，只要您至少使用一个PNG和一个JPG，并且在`src`标签中使用相对路径而不是绝对路径。我从[https://openclipart.org/](https://openclipart.org/)获取了这些可爱的猫头鹰。
- en: First approach – scripting
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一种方法 - 脚本
- en: 'Now, let''s start writing the script. I''ll go through the source in three
    steps: imports, arguments parsing, and business logic.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写脚本。我将分三步讲解源代码：导入、解析参数和业务逻辑。
- en: The imports
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: 'Here''s how the script starts:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的开始部分如下：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Going through them from the top, you can see that we'll need to parse the arguments,
    which we'll feed to the script itself (`argparse`). We will need the `base64`
    library to save the images within a JSON file (`json`), and we'll need to open
    files for writing (`os`). Finally, we'll need `BeautifulSoup` for scraping the
    web page easily, and `requests` to fetch its content. I assume you're familiar
    with `requests` as we have used it in previous chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始浏览它们，您会发现我们需要解析参数，然后将其提供给脚本本身（`argparse`）。我们将需要`base64`库来将图像保存在JSON文件中（`json`），并且我们需要打开文件进行写入（`os`）。最后，我们需要`BeautifulSoup`来轻松抓取网页，以及`requests`来获取其内容。我假设您熟悉`requests`，因为我们在之前的章节中使用过它。
- en: We will explore the HTTP protocol and the `requests` mechanism in [Chapter 14](part0341.html#A56FQ0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Web Development*, so for now, let's just (simplistically) say that we perform
    an HTTP request to fetch the content of a web page. We can do it programmatically
    using a library, such as `requests`, and it's more or less the equivalent of typing
    a URL in your browser and pressing *Enter* (the browser then fetches the content
    of a web page and displays it to you).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第14章》*Web Development*中探讨HTTP协议和`requests`机制，所以现在，让我们简单地说，我们执行一个HTTP请求来获取网页的内容。我们可以使用库（如`requests`）以编程方式执行此操作，这更或多是相当于在浏览器中输入URL并按下*Enter*（然后浏览器获取网页内容并将其显示给您）。
- en: 'Of all these imports, only the last two don''t belong to the Python standard
    library, so make sure you have them installed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些导入中，只有最后两个不属于Python标准库，所以请确保您已经安装了它们：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Of course, the version numbers might be different for you. If they''re not
    installed, use this command to do so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，版本号可能对您来说是不同的。如果它们没有安装，请使用此命令进行安装：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, the only thing that I reckon might confuse you is the `base64/json`
    couple, so allow me to spend a few words on that.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我认为可能会让您困惑的唯一事情是`base64/json`对，所以请允许我花几句话来解释。
- en: As we saw in the previous chapter, JSON is one of the most popular formats for
    data exchange between applications. It's also widely used for other purposes too,
    for example, to save data in a file. In our script, we're going to offer the user
    the ability to save images as image files, or as a JSON single file. Within the
    JSON, we'll put a dictionary with keys as the image names and values as their
    content. The only issue is that saving images in the binary format is tricky,
    and this is where the `base64` library comes to the rescue.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，JSON是应用程序之间数据交换的最流行格式之一。它也被广泛用于其他目的，例如在文件中保存数据。在我们的脚本中，我们将为用户提供将图像保存为图像文件或JSON单个文件的功能。在JSON中，我们将放置一个字典，其中键是图像名称，值是它们的内容。唯一的问题是以二进制格式保存图像很棘手，这就是`base64`库发挥作用的地方。
- en: The `base64` library is actually quite useful. For example, every time you send
    an email with an image attached to it, the image gets encoded with `base64` before
    the email is sent. On the recipient side, images are automatically decoded into
    their original binary format so that the email client can display them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`base64`库实际上非常有用。例如，每次您发送带有附加图像的电子邮件时，图像在发送电子邮件之前都会使用`base64`进行编码。在接收方端，图像会自动解码为其原始二进制格式，以便电子邮件客户端可以显示它们。'
- en: Parsing arguments
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析参数
- en: 'Now that the technicalities are out of the way, let''s see the second section
    of our script (it should be at the end of the `scrape.py` module):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 既然技术问题已经解决，让我们看看我们脚本的第二部分（应该在`scrape.py`模块的末尾）：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Look at that first line; it is a very common idiom when it comes to scripting.
    According to the official Python documentation, the `'__main__'` string is the
    name of the scope in which top-level code executes. A module's `__name__` is set
    equal to `'__main__'` when read from standard input, a script, or from an interactive
    prompt.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 看看第一行；这是脚本编写时非常常见的习语。根据官方Python文档，`'__main__'`字符串是顶层代码执行的范围名称。当从标准输入、脚本或交互式提示中读取时，模块的`__name__`被设置为`'__main__'`。
- en: Therefore, if you put the execution logic under that `if`, it will be run only
    when you run the script directly, as its `__name__` will be `'__main__'`. On the
    other hand, should you import from this module, then its name will be set to something
    else, so the logic under the `if` won't run.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您将执行逻辑放在`if`下面，它将仅在直接运行脚本时运行，因为其`__name__`将为`'__main__'`。另一方面，如果您从此模块导入，则其名称将设置为其他内容，因此`if`下的逻辑将不会运行。
- en: The first thing we do is define our parser. I would recommend using the standard
    library module, `argparse`, which is simple enough and quite powerful. There are
    other options out there, but in this case, `argparse` will provide us with all
    we need.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是定义我们的解析器。我建议使用标准库模块`argparse`，它足够简单且功能强大。还有其他选择，但在这种情况下，`argparse`将为我们提供所需的一切。
- en: 'We want to feed our script three different pieces of data: the types of images
    we want to save, the format in which we want to save them, and the URL for the
    page to be scraped.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望向我们的脚本提供三种不同的数据：我们要保存的图像类型，我们要保存它们的格式以及要抓取的页面的URL。
- en: The types can be PNGs, JPGs, or both (default), while the format can be either
    image or JSON, image being the default. URL is the only mandatory argument.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以是PNG、JPG或两者（默认），而格式可以是图像或JSON，图像是默认值。URL是唯一的强制参数。
- en: So, we add the `-t` option, allowing also the long version, `--type`. The choices
    are `'all'`, `'png'`, and `'jpg'`. We set the default to `'all'` and we add a
    `help` message.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们添加了`-t`选项，还允许长版本`--type`。选择是`'all'`，`'png'`和`'jpg'`。我们将默认设置为`'all'`并添加一个`help`消息。
- en: We do a similar procedure for the `format` argument, allowing both the short
    and long syntax (`-f` and `--format`), and finally we add the `url` argument,
    which is the only one that is specified differently so that it won't be treated
    as an option, but rather as a positional argument.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`format`参数执行类似的过程，允许使用短语法和长语法（`-f`和`--format`），最后我们添加`url`参数，这是唯一一个以不同方式指定的参数，因此它不会被视为选项，而是作为位置参数。
- en: In order to parse all the arguments, all we need is `parser.parse_args()`. Very
    simple, isn't it?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析所有参数，我们只需要`parser.parse_args()`。非常简单，不是吗？
- en: 'The last line is where we trigger the actual logic, by calling the `scrape`
    function, passing all the arguments we just parsed. We will see its definition
    shortly. The nice thing about `argparse` is that if you call the script by passing
    `-h`, it will print a nice usage text for you automatically. Let''s try it out:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是我们触发实际逻辑的地方，通过调用`scrape`函数，传递我们刚刚解析的所有参数。我们很快将看到它的定义。`argparse`的好处是，如果通过传递`-h`调用脚本，它将自动为您打印一个漂亮的使用文本。让我们试一试：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you think about it, the one true advantage of this is that we just need to
    specify the arguments and we don't have to worry about the usage text, which means
    we won't have to keep it in sync with the arguments' definition every time we
    change something. This is precious.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细考虑一下，这样做的真正优势在于我们只需要指定参数，而不必担心使用文本，这意味着我们不必在每次更改内容时保持与参数定义同步。这是非常宝贵的。
- en: 'Here are a few different ways to call our `scrape.py` script, which demonstrate
    that `type` and `format` are optional, and how you can use the short and long
    syntaxes to employ them:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调用我们的`scrape.py`脚本的几种不同方式，演示了`type`和`format`是可选的，以及如何使用短语法和长语法来使用它们：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first one is using default values for `type` and `format`. The second one
    will save only PNG images, and the third one will save only JPGs, but in JSON
    format.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是使用`type`和`format`的默认值。第二个将仅保存PNG图像，第三个将仅保存JPG图像，但以JSON格式保存。
- en: The business logic
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: 'Now that we''ve seen the scaffolding, let''s deep dive into the actual logic
    (if it looks intimidating, don''t worry; we''ll go through it together). Within
    the script, this logic lies after the imports and before the parsing (before the
    `if __name__` clause):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了脚手架，让我们深入到实际的逻辑中（如果看起来令人生畏，不要担心；我们会一起学习）。在脚本中，这个逻辑位于导入之后和解析之前（在`if
    __name__`子句之前）。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's start with the `scrape` function. The first thing it does is fetch the
    page at the given `url` argument. Whatever error may happen while doing this,
    we trap it in `RequestException` (`err`) and print it. `RequestException` is the
    base exception class for all the exceptions in the `requests` library.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`scrape`函数开始。它所做的第一件事就是获取给定`url`参数的页面。无论在此过程中可能发生的任何错误，我们都会将其捕获在`RequestException`（`err`）中并打印出来。`RequestException`是`requests`库中所有异常的基本异常类。
- en: However, if things go well, and we have a page back from the `GET` request,
    then we can proceed (`else` branch) and feed its content to the `BeautifulSoup`
    parser. The `BeautifulSoup` library allows us to parse a web page in no time,
    without having to write all the logic that would be needed to find all the images
    in a page, which we really don't want to do. It's not as easy as it seems, and
    reinventing the wheel is never good. To fetch images, we use the `_fetch_images`
    function and we filter them with `_filter_images`. Finally, we call `_save` with
    the result.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一切顺利，我们从`GET`请求中得到了一个页面，那么我们可以继续（`else`分支），并将其内容提供给`BeautifulSoup`解析器。`BeautifulSoup`库允许我们在很短的时间内解析网页，而不必编写查找页面上所有图像所需的所有逻辑，这是我们真的不想做的。这并不像看起来那么容易，重新发明轮子从来都不是好事。为了获取图像，我们使用`_fetch_images`函数，并用`_filter_images`对它们进行过滤。最后，我们调用`_save`来保存结果。
- en: 'Splitting the code into different functions with meaningful names allows us
    to read it more easily. Even if you haven''t seen the logic of the `_fetch_images`,
    `_filter_images`, and `_save` functions, it''s not hard to predict what they do,
    right? Check out the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分割成不同的函数并赋予有意义的名称，使我们更容易阅读它。即使你没有看到`_fetch_images`、`_filter_images`和`_save`函数的逻辑，也不难预测它们的功能，对吧？看看下面的内容：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`_fetch_images` takes a `BeautifulSoup` object and a base URL. All it does
    is loop through all of the images found on the page and fill in the `name` and
    `url` information about them in a dictionary (one per image). All dictionaries
    are added to the `images` list, which is returned at the end.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`_fetch_images`接受一个`BeautifulSoup`对象和一个基本URL。它所做的就是循环遍历页面上找到的所有图像，并在一个字典中填写关于它们的`name`和`url`信息（每个图像一个字典）。所有字典都添加到`images`列表中，并在最后返回。'
- en: There is some trickery going on when we get the name of an image. We split the
    `img_url` (`http://localhost:8000/img/my_image_name.png`) string using `'/'` as
    a separator, and we take the last item as the image name. There is a more robust
    way of doing this, but for this example it would be overkill. If you want to see
    the details of each step, try to break this logic down into smaller steps, and
    print the result of each of them to help yourself understand. Toward the end of
    the book, I'll show you another technique for debugging in a much more efficient
    way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取图像的名称时，有一些技巧。我们使用`'/'`作为分隔符来分割`img_url`（`http://localhost:8000/img/my_image_name.png`）字符串，并将最后一项作为图像名称。有一种更健壮的方法来做到这一点，但对于这个例子来说，这将是杀鸡用牛刀。如果你想看到每个步骤的细节，请尝试将这个逻辑分解为更小的步骤，并打印每个步骤的结果来帮助你理解。在本书的末尾，我会向你展示另一种更有效的调试技术。
- en: 'Anyway, by just adding `print(images)` at the end of the `_fetch_images` function,
    we get this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，只需在`_fetch_images`函数的末尾添加`print(images)`，我们就得到了这个：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I truncated the result for brevity. You can see each dictionary has a `url` and
    `name` key/value pair, which we can use to fetch, identify, and save our images
    as we like. At this point, I hear you asking what would happen if the images on
    the page were specified with an absolute path instead of a relative one, right?
    Good question!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我为了简洁起见截断了结果。你可以看到每个字典都有一个`url`和`name`键/值对，我们可以用它们来获取、识别和保存我们喜欢的图像。此时，我听到你在问，如果页面上的图像是用绝对路径而不是相对路径指定的，会发生什么，对吧？好问题！
- en: The answer is that the script will fail to download them because this logic
    expects relative paths. I was about to add a bit of logic to solve this issue
    when I thought that, at this stage, it would be a nice exercise for you to do
    it, so I'll leave it up to you to fix it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是脚本将无法下载它们，因为这个逻辑期望相对路径。当我想要添加一点逻辑来解决这个问题时，我想在这个阶段，这将是一个很好的练习，所以我会留给你来解决它。
- en: 'Hint: Inspect the start of that `src` variable. If it starts with `''http''`,
    it''s probably an absolute path. You might also want to checkout `urllib.parse`
    to do that.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：检查`src`变量的开头。如果以`'http'`开头，那么它可能是一个绝对路径。你可能还想查看`urllib.parse`来做到这一点。
- en: 'I hope the body of the `_filter_images` function is interesting to you. I wanted
    to show you how to check on multiple extensions using a mapping technique:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望`_filter_images`函数的主体对你有趣。我想向你展示如何使用映射技术来检查多个扩展名：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this function, if `type_` is `all`, then no filtering is required, so we
    just return all the images. On the other hand, when `type_` is not `all`, we get
    the allowed extensions from the `ext_map` dictionary, and use it to filter the
    images in the list comprehension that ends the function body. You can see that
    by using another helper function, `_matches_extension`, I have made the list comprehension
    simpler and more readable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，如果`type_`是`all`，那么不需要进行过滤，所以我们只返回所有的图像。另一方面，当`type_`不是`all`时，我们从`ext_map`字典中获取允许的扩展名，并用它来过滤函数体结束的列表推导式中的图像。你可以看到，通过使用另一个辅助函数`_matches_extension`，我使列表推导式更简单、更易读。
- en: All `_matches_extension` does is split the name of the image getting its extension
    and check whether it is within the list of allowed ones. Can you find one micro-improvement
    (speed-wise) that could be made to this function?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`_matches_extension`函数所做的就是分割获取图像扩展名的名称，并检查它是否在允许的列表中。你能找到一个微小的改进（速度方面）可以应用到这个函数吗？'
- en: 'I''m sure you''re wondering why I have collected all the images in the list
    and then removed them, instead of checking whether I wanted to save them before
    adding them to the list. The first reason is that I needed `_fetch_images` in
    the GUI application as it is now. The second reason is that combining, fetching,
    and filtering would produce a longer and more complicated function, and I''m trying
    to keep the complexity level down. The third reason is that this could be a nice
    exercise for you to do:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你一定想知道为什么我要将所有图像收集到列表中，然后再删除它们，而不是在将它们添加到列表之前检查是否要保存它们。第一个原因是我现在需要在GUI应用程序中使用`_fetch_images`。第二个原因是合并、获取和过滤会产生一个更长更复杂的函数，而我正在尽量降低复杂性。第三个原因是这可能是一个很好的练习给你做：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's keep going through the code and inspect the `_save` function. You can
    see that, when `images` isn't empty, this basically acts as a dispatcher. We either
    call `_save_images` or `_save_json`, depending on what information is stored in
    the `format_` variable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续阅读代码并检查`_save`函数。你可以看到，当`images`不为空时，这基本上充当一个调度程序。我们要么调用`_save_images`，要么调用`_save_json`，这取决于`format_`变量中存储的信息。
- en: We are almost done. Let's jump to `_save_images`. We loop on the `images` list
    and for each dictionary we find there, we perform a `GET` request on the image
    URL and save its content in a file, which we name as the image itself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了。让我们跳到`_save_images`。我们循环遍历`images`列表，对于我们在那里找到的每个字典，我们对图像URL执行一个`GET`请求，并将其内容保存在一个文件中，我们将其命名为图像本身。
- en: 'Finally, let''s now step into the `_save_json` function. It''s very similar
    to the previous one. We basically fill in the `data` dictionary. The image name
    is the *key*, and the Base64 representation of its binary content is the *value*.
    When we''re done populating our dictionary, we use the `json` library to dump
    it in the `images.json` file. I''ll give you a small preview of that:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在让我们进入`_save_json`函数。它与之前的函数非常相似。我们基本上填充了`data`字典。图像名称是*键*，其二进制内容的Base64表示是*值*。当我们完成填充字典时，我们使用`json`库将其转储到`images.json`文件中。我会给你一个小预览：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And that's it! Now, before proceeding to the next section, make sure you play
    with this script and understand how it works. Try to modify something, print out
    intermediate results, add a new argument or functionality, or scramble the logic.
    We're going to migrate it into a GUI application now, which will add a layer of
    complexity simply because we'll have to build the GUI interface, so it's important
    that you're well acquainted with the business logic—it will allow you to concentrate
    on the rest of the code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，在继续下一部分之前，请确保你玩过这个脚本并了解它是如何工作的。尝试修改一些东西，打印出中间结果，添加一个新的参数或功能，或者打乱逻辑。我们现在将把它迁移到一个GUI应用程序中，这将增加一层复杂性，因为我们将不得不构建GUI界面，所以熟悉业务逻辑非常重要——这将使你能够集中精力处理代码的其余部分。
- en: Second approach – a GUI application
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二种方法-一个GUI应用程序
- en: There are several libraries that write GUI applications in Python. The most
    famous ones are **Tkinter**, **wxPython**, **PyGTK**, and **PyQt**. They all offer
    a wide range of tools and widgets that you can use to compose a GUI application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个库可以用Python编写GUI应用程序。最著名的是**Tkinter**、**wxPython**、**PyGTK**和**PyQt**。它们都提供了各种工具和小部件，可以用来组成GUI应用程序。
- en: The one I'm going to use for the rest of this chapter is Tkinter. **Tkinter**
    stands for **Tk interface** and it is the standard Python interface to the Tk
    GUI toolkit. Both Tk and Tkinter are available on most Unix platforms, macOS X,
    as well as on Windows systems.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章的其余部分中使用Tkinter。**Tkinter**代表**Tk界面**，它是Python与Tk GUI工具包的标准接口。Tk和Tkinter都可以在大多数Unix平台、macOS
    X以及Windows系统上使用。
- en: 'Let''s make sure that `tkinter` is installed properly on your system by running
    this command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行这个命令来确保`tkinter`在你的系统上安装正确：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It should open a dialog window, demonstrating a simple `Tk` interface. If you
    can see that, we're good to go. However, if it doesn't work, please search for
    `tkinter` in the Python official documentation ([https://docs.python.org/3.7/library/tkinter.html](https://docs.python.org/3.7/library/tkinter.html)).
    You will find several links to resources that will help you get up and running
    with it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该打开一个对话框窗口，展示一个简单的`Tk`界面。如果你能看到它，那就没问题。但是，如果它不起作用，请在Python官方文档中搜索`tkinter`（[https://docs.python.org/3.7/library/tkinter.html](https://docs.python.org/3.7/library/tkinter.html)）。你会找到一些资源的链接，这些资源将帮助你快速上手。
- en: We're going to make a very simple GUI application that basically mimics the
    behavior of the script we saw in the first part of this chapter. We won't add
    the ability to save JPGs or PNGs singularly, but after you've gone through this
    chapter, you should be able to play with the code and put that feature back in
    by yourself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个非常简单的GUI应用程序，基本上模仿本章第一部分中所见的脚本的行为。我们不会添加单独保存JPG或PNG的功能，但在你完成本章后，你应该能够玩转代码，并自己加入该功能。
- en: 'So, this is what we''re aiming for:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是我们的目标：
- en: '![](../images/00013.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00013.jpeg)'
- en: Gorgeous, isn't it? As you can see, it's a very simple interface (this is how
    it should look on a mac). There is a frame (that is, a container) for the URL
    field and the Fetch info button, another frame for the **Listbox** (Content) to
    hold the image names and the radio button to control the way we save them, and
    finally there is a Scrape! button at the bottom. We also have a status bar, which
    shows us some information.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 华丽，不是吗？正如你所看到的，这是一个非常简单的界面（这是在Mac上的样子）。有一个框架（即容器）用于URL字段和获取信息按钮，另一个框架用于**Listbox**（内容）来保存图像名称和控制保存方式的单选按钮，最后底部有一个抓取按钮。我们还有一个状态栏，它会向我们显示一些信息。
- en: 'In order to get this layout, we could just place all the widgets on a root
    window, but that would make the layout logic quite messy and unnecessarily complicated.
    So, instead, we will divide the space using frames and place the widgets in those
    frames. This way we will achieve a much nicer result. So, this is the draft for
    the layout:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这种布局，我们可以将所有小部件放在根窗口上，但那样会使布局逻辑变得非常混乱和不必要地复杂。因此，我们将使用框架来划分空间，并将小部件放在这些框架中。这样我们将获得一个更好的结果。所以，这是布局的草案：
- en: '![](../images/00014.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: We have a **Root Window**, which is the main window of the application. We divide
    it into two rows, the first one in which we place the **Main Frame**, and the
    second one in which we place the **Status Frame** (which will hold the status
    bar text). The **Main Frame** is subsequently divided into three rows. In the
    first one, we place the **URL Frame**, which holds the **URL** widgets. In the
    second one, we place the **Img Frame**, which will hold the **Listbox** and the
    **Radio Frame**, which will host a label and the radio button widgets. And finally
    we have the third one, which will just hold the **Scrape** button.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个**根窗口**，它是应用程序的主窗口。我们将它分成两行，第一行放置**主框架**，第二行放置**状态框架**（用于保存状态栏文本）。**主框架**随后被分成三行。在第一行，我们放置**URL框架**，其中包含**URL**小部件。在第二行，我们放置**Img框架**，它将包含**Listbox**和**Radio框架**，后者将承载一个标签和单选按钮小部件。最后我们有第三行，它将只包含**Scrape**按钮。
- en: In order to lay out frames and widgets, we will use a layout manager, called
    **grid**, that simply divides up the space into rows and columns, as in a matrix.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了布局框架和小部件，我们将使用一个布局管理器，称为**grid**，它简单地将空间分成行和列，就像矩阵一样。
- en: 'Now, all the code I''m going to write comes from the `guiscrape.py` module,
    so I won''t repeat its name for each snippet, to save space. The module is logically
    divided into three sections, not unlike the script version: imports, layout logic,
    and business logic. We''re going to analyze them line by line, in three chunks.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我要写的所有代码都来自`guiscrape.py`模块，所以我不会为每个片段重复它的名称，以节省空间。该模块在逻辑上分为三个部分，与脚本版本类似：导入、布局逻辑和业务逻辑。我们将逐行分析它们，分为三个部分。
- en: The imports
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: 'Imports are like in the script version, except we''ve lost `argparse`, which
    is no longer needed, and we have added two lines:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 导入与脚本版本类似，只是我们失去了`argparse`，它不再需要，并且添加了两行：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first line is quite common practice when dealing with `tkinter`, although
    in general it is bad practice to import using the `*` syntax*.* You can incur
    in name collisions and, if the module is too big, importing everything would be
    expensive.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在处理`tkinter`时是相当常见的做法，尽管通常使用`*`语法进行导入是不好的做法*.*你可能会遇到名称冲突，而且如果模块太大，导入所有内容将会很昂贵。
- en: After that, we import `ttk`, `filedialog`, and `messagebox` explicitly, following
    the conventional approach used with this library. `ttk` is the new set of styled
    widgets. They behave basically like the old ones, but are capable of drawing themselves
    correctly according to the style your OS is set on, which is nice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们明确导入了`ttk`，`filedialog`和`messagebox`，遵循了这个库的常规方法。`ttk`是一组新的样式化小部件。它们基本上的行为与旧的小部件相同，但能够根据操作系统的样式正确地绘制自己，这很好。
- en: The rest of the imports (omitted) is what we need in order to carry out the
    task you know well by now. Note that there is nothing we need to install with
    `pip` in this second part; we already have everything we need.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的导入（已省略）是我们现在所熟知的任务所需的。请注意，在这第二部分中，我们不需要使用`pip`安装任何东西；我们已经拥有了我们需要的一切。
- en: The layout logic
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局逻辑
- en: 'I''m going to paste it chunk by chunk so that I can explain it easily to you.
    You''ll see how all those pieces we talked about in the layout draft are arranged
    and glued together. What I''m about to paste, as we did in the script before,
    is the final part of the `guiscrape.py` module. We''ll leave the middle part,
    the business logic, for last:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我将逐块粘贴它，这样我可以更容易地向你解释。你会看到我们在布局草案中讨论的所有那些部分是如何排列和粘合在一起的。我将要粘贴的内容，就像我们之前在脚本中所做的那样，是`guiscrape.py`模块的最后部分。我们将最后留下中间部分，也就是业务逻辑：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you know by now, we only want to execute the logic when the module is run
    directly, so that first line shouldn't surprise you.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在所知，我们只想在模块直接运行时执行逻辑，所以第一行不应该让你感到惊讶。
- en: 'In the last two lines, we set up the main window, which is an instance of the
    `Tk` class. We instantiate it and give it a title. Note that I use the prepending
    underscore technique for all the names of the `tkinter` objects, in order to avoid
    potential collisions with names in the business logic. I just find it cleaner
    like this, but you''re allowed to disagree:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两行，我们设置了主窗口，它是`Tk`类的一个实例。我们实例化它并给它一个标题。请注意，我使用了`tkinter`对象的所有名称的前置下划线技术，以避免与业务逻辑中的名称潜在冲突。我觉得这样更清晰，但你可以不同意：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we set up the **Main Frame**. It's a `ttk.Frame` instance. We set `_root`
    as its parent, and give it some `padding`. The `padding` is a measure in pixels
    of how much space should be inserted between the inner content and the borders
    in order to let our layout breathe a little, otherwise we have a *sardine effect*,
    where widgets are packed too tightly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了**主框架**。它是一个`ttk.Frame`实例。我们将`_root`设置为它的父级，并给它一些`padding`。`padding`是以像素为单位的度量，用于在内部内容和边框之间插入多少空间，以便让我们的布局有一点空间，否则我们会有一个*沙丁鱼效应*，小部件被过紧地打包在一起。
- en: 'The second line is more interesting. We place this `_mainframe` on the first
    `row` (`0`) and first `column` (`0`) of the parent object (`_root`). We also say
    that this frame needs to extend itself in each direction by using the `sticky`
    argument with all four cardinal directions. If you''re wondering where they came
    from, it''s the `from tkinter import *` magic that brought them to us:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行更有趣。我们将这个`_mainframe`放在父对象`_root`的第一行（`0`）和第一列（`0`）。我们还说这个框架需要在每个方向上扩展自己，使用`sticky`参数和所有四个基本方向。如果你想知道它们是从哪里来的，那就是`from
    tkinter import *`魔法给我们带来的：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we start by placing the **URL Frame** down. This time, the parent object
    is `_mainframe`, as you will recall from our draft. This is not just a simple
    `Frame`, it's actually a `LabelFrame`, which means we can set the text argument
    and expect a rectangle to be drawn around it, with the content of the text argument
    written in the top-left part of it (check out the previous picture if it helps).
    We position this frame at (`0`, `0`), and say that it should expand to the left
    and to the right. We don't need the other two directions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们首先放置**URL Frame**。这次，父对象是`_mainframe`，正如您从我们的草图中记得的那样。这不仅仅是一个简单的`Frame`，它实际上是一个`LabelFrame`，这意味着我们可以设置文本参数，并期望在其周围绘制一个矩形，并在其左上部分写入文本参数的内容（如果有必要，请查看上一张图片）。我们将此框架定位在（`0`，`0`），并说它应该向左和向右扩展。我们不需要其他两个方向。
- en: 'Finally, we use `rowconfigure` and `columnconfigure` to make sure it behaves
    correctly, should it need to resize. This is just a formality in our present layout:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`rowconfigure`和`columnconfigure`来确保它在需要调整大小时能够正确运行。这只是我们当前布局中的一种形式：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we have the code to lay out the URL textbox and the `_fetch` button. A
    textbox in this environment is called `Entry`. We instantiate it as usual, setting
    `_url_frame` as its parent and giving it a width. Also, and this is the most interesting
    part, we set the `textvariable` argument to be `_url`. `_url` is a `StringVar`,
    which is an object that is now connected to `Entry` and will be used to manipulate
    its content. Therefore, we don't modify the text in the `_url_entry` instance
    directly, but by accessing `_url`. In this case, we call the `set` method on it
    to set the initial value to the URL of our local web page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有布局URL文本框和`_fetch`按钮的代码。在这种环境中，文本框称为`Entry`。我们像往常一样实例化它，将`_url_frame`设置为其父级并为其设置宽度。而且，这是最有趣的部分，我们将`textvariable`参数设置为`_url`。`_url`是`StringVar`，它是一个现在连接到`Entry`并将用于操作其内容的对象。因此，我们不直接修改`_url_entry`实例中的文本，而是通过访问`_url`。在这种情况下，我们调用其`set`方法将初始值设置为我们本地网页的URL。
- en: We position `_url_entry` at (`0`, `0`), setting all four cardinal directions
    for it to stick to, and we also set a bit of extra padding on the left and right
    edges using `padx`, which adds padding on the *x*-axis (horizontal). On the other
    hand, `pady` takes care of the vertical direction.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`_url_entry`定位在（`0`，`0`），为其设置了四个基本方向，使其粘附，并且还使用`padx`在左右边缘设置了一些额外的填充，该参数在*x*轴（水平）上添加填充。另一方面，`pady`负责垂直方向。
- en: By now, you should get that every time you call the `.grid` method on an object,
    we're basically telling the grid layout manager to place that object somewhere,
    according to rules that we specify as arguments in the `grid()` call.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该知道每次在对象上调用`.grid`方法时，我们基本上都在告诉网格布局管理器根据我们在`grid()`调用中指定的规则将该对象放置在某个地方。
- en: 'Similarly, we set up and place the `_fetch` button. The only interesting parameter
    is `command=fetch_url`. This means that when we click this button, we call the
    `fetch_url` function. This technique is called **callback**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们设置并放置了`_fetch`按钮。唯一有趣的参数是`command=fetch_url`。这意味着当我们单击此按钮时，我们调用`fetch_url`函数。这种技术称为**回调**：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is what we called **Img Frame** in the layout draft. It is placed on the
    second row of its parent `_mainframe`. It will hold the **Listbox** and the **Radio
    Frame**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在布局草图中称为**Img Frame**的东西。它放置在其父级`_mainframe`的第二行。它将容纳**Listbox**和**Radio
    Frame**：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is probably the most interesting bit of the whole layout logic. As we did
    with `_url_entry`, we need to drive the contents of `Listbox` by tying it to an `_images` variable.
    We set up `Listbox` so that `_img_frame` is its parent, and `_images` is the variable
    it's tied to. We also pass some dimensions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是整个布局逻辑中最有趣的部分。与`_url_entry`一样，我们需要通过将其绑定到`_images`变量来驱动`Listbox`的内容。我们设置`Listbox`，使`_img_frame`成为其父级，并且`_images`是其绑定的变量。我们还传递了一些尺寸。
- en: The interesting bit comes from the `_scrollbar` instance. Note that, when we
    instantiate it, we set its command to `_img_listbox.yview`. This is the first
    half of the contract between `Listbox` and `Scrollbar`. The other half is provided
    by the `_img_listbox.configure` method, which sets `yscrollcommand=_scrollbar.set`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分来自`_scrollbar`实例。请注意，当我们实例化它时，我们将其命令设置为`_img_listbox.yview`。这是`Listbox`和`Scrollbar`之间的合同的第一部分。另一半由`_img_listbox.configure`方法提供，该方法设置`yscrollcommand=_scrollbar.set`。
- en: 'By providing this reciprocal bond, when we scroll on `Listbox`, `Scrollbar`
    will move accordingly and vice versa, when we operate `Scrollbar`, `Listbox` will
    scroll accordingly:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供这种相互关系，当我们在`Listbox`上滚动时，`Scrollbar`将相应移动，反之亦然，当我们操作`Scrollbar`时，`Listbox`将相应滚动：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We place the **Radio Frame**, ready to be populated. Note that `Listbox` is
    occupying (`0`, `0`) on `_img_frame`, `Scrollbar` (`0`, `1`), and therefore `_radio_frame`
    will go in (`0`, `2`):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放置**Radio Frame**，准备填充。请注意，`Listbox`占据了`_img_frame`的（`0`，`0`），`Scrollbar`占据了（`0`，`1`），因此`_radio_frame`将放在（`0`，`2`）：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Firstly, we place the label, and we give it some padding. Note that the label
    and radio buttons are children of `_radio_frame`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们放置标签，并为其添加一些填充。请注意，标签和单选按钮都是`_radio_frame`的子级。
- en: As for the `Entry` and `Listbox` objects, `Radiobutton` is also driven by a
    bond to an external variable, which I called `_save_method`. Each `Radiobutton`
    instance sets a value argument, and by checking the value on `_save_method`, we
    know
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`Entry`和`Listbox`对象，`Radiobutton`也受到与外部变量的绑定的影响，我称之为`_save_method`。每个`Radiobutton`实例都设置了一个值参数，通过检查`_save_method`上的值，我们知道
- en: 'which button is selected:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪个按钮：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On the third row of `_mainframe` we place the **Scrape** button. Its `command`
    is `save`, which saves the images to be listed in `Listbox`, after we have successfully
    parsed a web page:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_mainframe`的第三行放置**Scrape**按钮。其`command`是`save`，在成功解析网页后，将图像保存到`Listbox`中：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We end the layout section by placing down the status frame, which is a simple
    `ttk.Frame`. To give it a little status bar effect, we set its `relief` property
    to `'sunken'` and give it a uniform padding of two pixels. It needs to stick to
    the left, right, and bottom parts of the `_root` window, so we set its `sticky`
    attribute to `(E, W, S)`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过放置状态框架来结束布局部分，这是一个简单的`ttk.Frame`。为了给它一个小小的状态栏效果，我们将其`relief`属性设置为`'sunken'`，并给它统一的两像素填充。它需要粘附在`_root`窗口的左侧、右侧和底部，因此我们将其`sticky`属性设置为`(E,
    W, S)`。
- en: We then place a label in it and, this time, we tie it to a `StringVar` object,
    because we will have to modify it every time we want to update the status bar
    text. You should be acquainted with this technique by now.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在其中放置一个标签，并且这次我们将其绑定到`StringVar`对象，因为我们每次想要更新状态栏文本时都必须修改它。您现在应该熟悉这种技术了。
- en: 'Finally, on the last line, we run the application by calling the `mainloop`
    method on the `Tk` instance:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一行，我们通过在`Tk`实例上调用`mainloop`方法来运行应用程序：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Please remember that all these instructions are placed under the `if __name__
    == "__main__":` clause in the original script.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有这些指令都放在原始脚本中的`if __name__ == "__main__":`子句下。
- en: As you can see, the code to design our GUI application is not hard. Granted,
    at the beginning, you have to play around a little bit. Not everything will work
    out perfectly at the first attempt, but I promise you it's very easy and you can
    find plenty of tutorials on the web. Let's now get to the interesting bit, the
    business logic.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，设计我们的GUI应用程序的代码并不难。当然，在开始时，您必须稍微尝试一下。并不是每件事情都会在第一次尝试时完美无缺，但我向您保证，这非常容易，您可以在网上找到大量的教程。现在让我们来到有趣的部分，业务逻辑。
- en: The business logic
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: We'll analyze the business logic of the GUI application in three chunks. There
    is the fetching logic, the saving logic, and the alerting logic.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分析GUI应用程序的业务逻辑分为三个部分。有获取逻辑、保存逻辑和警报逻辑。
- en: Fetching the web page
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取网页
- en: 'Let''s start with the code to fetch the page and images:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从获取页面和图片的代码开始：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First of all, let me explain that `config` dictionary. We need some way of passing
    data between the GUI application and the business logic. Now, instead of polluting
    the global namespace with many different variables, my personal preference is
    to have a single dictionary that holds all the objects we need to pass back and
    forth, so that the global namespace isn't clogged up with all those names, and
    we have a single, clean, easy way of knowing where all the objects that are needed
    by our application are.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我解释一下`config`字典。我们需要一种在GUI应用程序和业务逻辑之间传递数据的方式。现在，我个人偏好的做法是，不是用许多不同的变量污染全局命名空间，而是使用一个单一的字典，其中包含我们需要来回传递的所有对象，这样全局命名空间就不会被所有这些名称弄得混乱，我们有一个单一、清晰、简单的方式来知道我们应用程序所需的所有对象在哪里。
- en: In this simple example, we'll just populate the `config` dictionary with the
    images we fetch from the page, but I wanted to show you the technique so that
    you have at least one example. This technique comes from my experience with JavaScript.
    When you code a web page, you often import several different libraries. If each
    of these cluttered the global namespace with all sorts of variables, there might
    be issues in making everything work, because of name clashes and variable overriding.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们将`config`字典填充了我们从页面获取的图片，但我想向您展示这种技术，这样您至少有一个例子。这种技术来自于我的JavaScript经验。当您编写网页时，通常会导入几种不同的库。如果每个库都用各种变量弄乱了全局命名空间，可能会出现问题，因为名称冲突和变量覆盖的问题。
- en: So, it's much better to leave the global namespace as clean as we can. In this
    case, I find that using one `config` variable is more than acceptable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好尽量保持全局命名空间的清洁。在这种情况下，我发现使用一个`config`变量是完全可以接受的。
- en: The `fetch_url` function is quite similar to what we did in the script. First,
    we get the `url` value by calling `_url.get()`. Remember that the `_url` object
    is a `StringVar` instance that is tied to the `_url_entry` object, which is an
    `Entry`. The text field you see on the GUI is the `Entry`, but the text behind
    the scenes is the value of the `StringVar` object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch_url`函数与我们在脚本中所做的非常相似。首先，我们通过调用`_url.get()`来获取`url`的值。请记住，`_url`对象是一个绑定到`_url_entry`对象的`StringVar`实例，后者是一个`Entry`。您在GUI上看到的文本字段是`Entry`，但在幕后的文本是`StringVar`对象的值。'
- en: By calling `get()` on `_url`, we get the value of the text, which is displayed
    in `_url_entry`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`_url`上调用`get()`，我们可以获得文本的值，该值显示在`_url_entry`中。
- en: The next step is to prepare `config['images']` to be an empty list, and to empty
    the `_images` variable, which is tied to `_img_listbox`. This, of course, has
    the effect of cleaning up all the items in `_img_listbox`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是准备`config['images']`为空列表，并清空与`_img_listbox`绑定的`_images`变量。当然，这会清理`_img_listbox`中的所有项目。
- en: After this preparation step, we can try to fetch the page, using the same `try`/`except`
    logic we adopted in the script at the beginning of the chapter. The one difference
    is the action we take if things go wrong. We call `_sb(str(err))`. `_sb` is a
    helper function whose code we'll see shortly. Basically, it sets the text in the
    status bar for us. Not a good name, right? I had to explain its behavior to you–food
    for thought.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作完成后，我们可以尝试获取页面，使用与本章开头的脚本中采用的相同的`try`/`except`逻辑。唯一的区别是如果出现问题，我们会调用`_sb(str(err))`。`_sb`是一个帮助函数，我们很快就会看到它的代码。基本上，它为我们设置状态栏中的文本。不是一个好名字，对吧？我不得不向您解释它的行为-值得思考。
- en: If we can fetch the page, then we create the `soup` instance, and fetch the
    images from it. The logic of `fetch_images` is exactly the same as the one explained
    before, so I won't repeat myself here.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以获取页面，那么我们就创建`soup`实例，并从中获取图片。`fetch_images`的逻辑与之前解释的逻辑完全相同，因此我就不在这里重复了。
- en: If we have images, using a quick tuple comprehension (which is actually a generator
    expression fed to a tuple constructor) we feed the `_images` as `StringVar` and
    this has the effect of populating our `_img_listbox` with all the image names.
    Finally, we update the status bar.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有图像，我们使用一个快速的元组推导式（实际上是一个生成器表达式馈送到一个元组构造函数），将`_images`作为`StringVar`，这会使我们的`_img_listbox`填充所有图像名称。最后，我们更新状态栏。
- en: If there were no images, we still update the status bar, and at the end of the
    function, regardless of how many images were found, we update `config['images']`
    to hold the `images` list. In this way, we'll be able to access the images from
    other functions by inspecting `config['images']` without having to pass that list
    around.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有图像，我们仍然更新状态栏，并且在函数结束时，无论找到了多少图像，我们都会更新`config['images']`以保存`images`列表。这样，我们就能够通过检查`config['images']`而无需传递该列表来从其他函数中访问图像。
- en: Saving the images
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存图像
- en: 'The logic to save the images is pretty straightforward. Here it is:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 保存图像的逻辑非常简单。如下所示：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When the user clicks the Scrape! button, the `save` function is called using
    the callback mechanism.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击抓取按钮时，使用回调机制调用`save`函数。
- en: The first thing that this function does is check whether there are actually
    any images to be saved. If not, it alerts the user about it, using another helper
    function, `_alert`, whose code we'll see shortly. No further action is performed
    if there are no images.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一件事就是检查是否有要保存的图像。如果没有，它会使用另一个辅助函数`_alert`来提醒用户，我们很快就会看到它的代码。如果没有图像，就不会执行进一步的操作。
- en: On the other hand, if the `config['images']` list is not empty, `save` acts
    as a dispatcher, and it calls `_save_images` or `_save_json`, according to which
    value is held by `_same_method`. Remember, this variable is tied to the radio
    buttons, therefore we expect its value to be either `'img'` or `'json'`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果`config['images']`列表不为空，`save`充当一个调度程序，并根据`_same_method`持有的值调用`_save_images`或`_save_json`。请记住，这个变量与单选按钮相关联，因此我们期望它的值要么是`'img'`，要么是`'json'`。
- en: This dispatcher is a bit different from the one in the script. According to
    which method we have selected, a different action must be taken.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调度程序与脚本中的不同。根据我们选择的方法，必须采取不同的操作。
- en: If we want to save the images as images, we need to ask the user to choose a
    directory. We do this by calling `filedialog.askdirectory` and assigning the result
    of the call to the `dirname` variable. This opens up a nice dialog window that
    asks us to choose a directory. The directory we choose must exist, as specified
    by the way we call the method. This is done so that we don't have to write code
    to deal with a potentially missing directory when saving the files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将图像保存为图像，我们需要要求用户选择一个目录。我们通过调用`filedialog.askdirectory`并将调用的结果分配给`dirname`变量来实现这一点。这将打开一个漂亮的对话框窗口，询问我们选择一个目录。我们选择的目录必须存在，如我们调用该方法的方式所指定的。这样做是为了在保存文件时不必编写处理可能缺少的目录的代码。
- en: 'Here''s how this dialog should look on a mac:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对话框在mac上应该是这样的：
- en: '![](../images/00015.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00015.jpeg)'
- en: If we cancel the operation, `dirname` will be set to `None`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取消操作，`dirname`将被设置为`None`。
- en: Before finishing analyzing the logic in `save`, let's quickly go through `_save_images`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成对`save`中的逻辑分析之前，让我们快速浏览一下`_save_images`。
- en: It's very similar to the version we had in the script so just note that, at
    the beginning, in order to be sure that we actually have something to do, we check
    on both `dirname` and the presence of at least one image in `config['images']`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它与脚本中的版本非常相似，因此请注意，在开始时，为了确保我们确实有事情要做，我们检查`dirname`和`config['images']`中至少有一张图像的存在。
- en: If that's the case, it means we have at least one image to save and the path
    for it, so we can proceed. The logic to save the images has already been explained.
    The one thing we do differently this time is join the directory (which means the
    complete path) to the image name, by means of `os.path.join`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，这意味着我们至少有一个要保存的图像和它的路径，所以我们可以继续。保存图像的逻辑已经解释过了。这一次我们做的不同的一件事是，通过`os.path.join`将目录（即完整路径）与图像名称连接起来。
- en: At the end of `_save_images`, if we saved at least one image, we alert the user
    that we're done.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_save_images`结束时，如果我们至少保存了一张图像，我们会提醒用户我们已经完成了。
- en: 'Let''s go back now to the other branch in `save`. This branch is executed when
    the user selects the As JSON radio button before pressing the Scrape button. In
    this case, we want to save a file; therefore, we cannot just ask for a directory.
    We want to give the user the ability to choose a filename as well. Hence, we fire
    up a different dialog: `filedialog.asksaveasfilename`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到`save`中的另一个分支。当用户在按下抓取按钮之前选择了作为JSON的单选按钮时，将执行此分支。在这种情况下，我们想要保存一个文件；因此，我们不能只要求一个目录。我们还希望让用户有能力选择一个文件名。因此，我们启动了一个不同的对话框：`filedialog.asksaveasfilename`。
- en: We pass an initial filename, which is proposed to the user–they have the ability
    to change it if they don't like it. Moreover, because we're saving a JSON file,
    we're forcing the user to use the correct extension by passing the `filetypes`
    argument. It is a list, with any number of two-tuples *(description, extension),*
    that runs the logic of the dialog.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个初始文件名，该文件名建议给用户-如果他们不喜欢它，他们有能力更改它。此外，因为我们正在保存一个JSON文件，我们通过传递`filetypes`参数来强制用户使用正确的扩展名。这是一个列表，其中包含任意数量的两元组*(描述，扩展名)*，用于运行对话框的逻辑。
- en: 'Here''s how this dialog should look on a macOS:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对话框在macOS上应该是这样的：
- en: '![](../images/00016.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00016.jpeg)'
- en: Once we have chosen a place and a filename, we can proceed with the saving logic,
    which is the same as it was in the previous script. We create a JSON object from
    a Python dictionary (`data`) that we populate with key/value pairs made by the
    `images` name and Base64-encoded content.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了一个位置和一个文件名，我们就可以继续进行保存逻辑，这与之前的脚本中的逻辑相同。我们从一个Python字典（`data`）创建一个JSON对象，该字典由`images`名称和Base64编码内容组成的键值对。
- en: In `_save_json` as well, we have a little check at the beginning that makes
    sure that we don't proceed unless we have a filename and at least one image to
    save. This ensures that if the user presses the Cancel button, nothing bad happens.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_save_json`中，我们还有一个小检查，确保我们没有文件名和至少一个要保存的图像时不会继续。这确保了如果用户按下取消按钮，不会发生任何不好的事情。
- en: Alerting the user
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警告用户
- en: 'Finally, let''s see the alerting logic. It''s extremely simple:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看警报逻辑。这非常简单：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That's it! To change the status bar message all we need to do is to access `_status_msg`
    `StringVar`, as it's tied to the `_status` label.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就改变状态栏消息而言，我们所需要做的就是访问`_status_msg` `StringVar`，因为它与`_status`标签相关联。
- en: 'On the other hand, if we want to show the user a more visible message, we can
    fire up a message box. Here''s how it should look on a mac:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想向用户显示更明显的消息，我们可以弹出一个消息框。在Mac上应该是这样的：
- en: '![](../images/00017.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00017.jpeg)'
- en: The `messagebox` object can also be used to warn the user (`messagebox.showwarning`)
    or to signal an error (`messagebox.showerror`). But it can also be used to provide
    dialogs that ask us whether we're sure we want to proceed or if we really want
    to delete that file, and so on.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`messagebox`对象还可以用于警告用户（`messagebox.showwarning`）或者表示错误（`messagebox.showerror`）。但它也可以用于提供询问我们是否确定要继续或者是否真的要删除那个文件等对话框。'
- en: If you inspect `messagebox` by simply printing out what `dir(messagebox)` returns,
    you'll find methods such as `askokcancel`, `askquestion`, `askretrycancel`, `askyesno`,
    and `askyesnocancel`, as well as a set of constants to verify the response of
    the user, such as `CANCEL`, `NO`, `OK`, `OKCANCEL`, `YES`, and `YESNOCANCEL`.
    You can compare these to the user's choice so that you know the next action to
    execute when the dialog closes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过简单地打印`dir(messagebox)`的返回值来检查`messagebox`，你会发现诸如`askokcancel`、`askquestion`、`askretrycancel`、`askyesno`和`askyesnocancel`等方法，以及一组常量来验证用户的响应，如`CANCEL`、`NO`、`OK`、`OKCANCEL`、`YES`和`YESNOCANCEL`。你可以将这些与用户的选择进行比较，以便知道对话框关闭时执行的下一个操作。
- en: How can we improve the application?
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何改进应用程序？
- en: Now that you're accustomed to the fundamentals of designing a GUI application,
    I'd like to give you some suggestions on how to make ours better.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经习惯了设计GUI应用程序的基础知识，我想给你一些建议，如何使我们的应用程序更好。
- en: We can start with the code quality. Do you think this code is good enough, or
    would you improve it? If so, how? I would test it, and make sure it's robust and
    caters for all the various scenarios that a user might create by clicking around
    on the application. I would also make sure the behavior is what I would expect
    when the website we're scraping is down for any reason.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从代码质量开始。你认为这段代码足够好，还是你会改进它？如果是的话，你会怎么做？我会测试它，并确保它是健壮的，并且考虑到用户可能通过点击应用程序而创建的各种情况。我还会确保当我们正在抓取的网站因任何原因而关闭时，行为是我所期望的。
- en: Another thing that we could improve is the naming. I have prudently named all
    the components with a leading underscore, both to highlight their somewhat *private*
    nature, and to avoid having name clashes with the underlying objects they are
    linked to. But in retrospect, many of those components could use a better name,
    so it's really up to you to refactor until you find the form that suits you best.
    You could start by giving a better name to the `_sb` function!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改进的另一件事是命名。我谨慎地用下划线作为前缀命名了所有组件，既突出了它们的*私有*性质，又避免了与它们链接的底层对象发生名称冲突。但回想起来，许多这些组件可能需要更好的名称，因此真的取决于你重构，直到找到最适合你的形式。你可以从给`_sb`函数一个更好的名称开始！
- en: For what concerns the user interface, you could try to resize the main application.
    See what happens? The whole content stays exactly where it is. Empty space is
    added if you expand, or the whole widgets set disappears gradually if you shrink.
    This behavior isn't exactly nice, therefore one quick solution could be to make
    the root window fixed (that is, unable to resize).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就用户界面而言，你可以尝试调整主应用程序的大小。看看会发生什么？整个内容保持不变。如果你扩展，会添加空白空间，如果你缩小，整个小部件集会逐渐消失。这种行为并不是很好，因此一个快速的解决方案可能是使根窗口固定（即无法调整大小）。
- en: 'Another thing that you could do to improve the application is to add the same
    functionality we had in the script, to save only PNGs or JPGs. In order to do
    this, you could place a combo box somewhere, with three values: All, PNGs, JPGs,
    or something similar. The user should be able to select one of those options before
    saving the files.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的另一件事是改进应用程序，使其具有与脚本中相同的功能，只保存PNG或JPG。为了做到这一点，你可以在某个地方放置一个组合框，有三个值：全部、PNG、JPG，或类似的东西。用户在保存文件之前应该能够选择其中一个选项。
- en: Even better, you could change the declaration of `Listbox` so that it's possible
    to select multiple images at the same time, and only the selected ones will be
    saved. If you manage to do this (it's not as hard as it seems, believe me), then
    you should consider presenting the `Listbox` a bit better, maybe providing alternating
    background colors for the rows.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，你可以更改`Listbox`的声明，以便可以同时选择多个图像，并且只保存所选的图像。如果你成功做到这一点（相信我，这并不像看起来那么难），那么你应该考虑更好地呈现`Listbox`，也许为行提供交替的背景颜色。
- en: 'Another nice thing you could add is a button that opens up a dialog to select
    a file. The file must be one of the JSON files the application can produce. Once
    selected, you could run some logic to reconstruct the images from their Base64-encoded
    version. The logic to do this is very simple, so here''s an example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加的另一件好事是添加一个按钮，打开一个对话框来选择一个文件。文件必须是应用程序可以生成的JSON文件之一。一旦选择，你可以运行一些逻辑来从它们的Base64编码版本重建图像。这样做的逻辑非常简单，所以这里有一个例子：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we need to open `images.json` in read mode, and grab the `data`
    dictionary. Once we have it, we can loop through its items, and save each image
    with the Base64-decoded content. I'll leave it up to you to tie this logic to
    a button in the application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们需要以读模式打开`images.json`，并获取`data`字典。一旦我们有了它，我们就可以循环遍历它的项目，并保存每个图像的Base64解码内容。我会把这个逻辑留给你，让你把它与应用程序中的一个按钮联系起来。
- en: Another cool feature that you could add is the ability to open up a preview
    pane that shows any image you select from `Listbox`, so that the user can take
    a peek at the images before deciding to save them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加的另一个很酷的功能是能够打开一个预览窗格，显示从`Listbox`中选择的任何图像，这样用户就可以在决定保存它们之前先看一眼这些图像。
- en: Finally, one last suggestion for this application is to add a menu. Maybe even
    a simple menu with File and ? to provide the usual Help or About. Just for fun.
    Adding menus is not that complicated; you can add text, keyboard shortcuts, images,
    and so on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于这个应用的最后一个建议是添加一个菜单。甚至可以添加一个简单的菜单，包括文件和？来提供通常的帮助或关于。只是为了好玩。添加菜单并不复杂；你可以添加文本、键盘快捷键、图像等等。
- en: Where do we go from here?
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们从这里去哪里？
- en: If you are interested in digging deeper into the world of GUIs, then I'd like
    to offer you the following suggestions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对深入了解GUI的世界感兴趣，那么我想给你提几个建议。
- en: The turtle module
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乌龟模块
- en: The `turtle` module is an extended reimplementation of the eponymous module
    from the Python standard distribution up to version Python 2.5\. It's a very popular
    way to introduce children to programming.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: “turtle”模块是Python标准发行版中自Python 2.5版本以来的同名模块的扩展重新实现。这是向孩子介绍编程的一种非常受欢迎的方式。
- en: It's based on the idea of an imaginary turtle starting at (0, 0) in the Cartesian
    plane. You can programmatically command the turtle to move forward and backward,
    rotate, and so on; by combining all the possible moves, all sorts of intricate
    shapes and images can be drawn.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于一个想象中的乌龟从笛卡尔平面的(0, 0)开始的想法。你可以通过编程命令乌龟向前和向后移动，旋转等等；通过组合所有可能的移动，可以绘制各种复杂的形状和图像。
- en: It's definitely worth checking out, if only to see something different.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它绝对值得一看，即使只是为了看到一些不同的东西。
- en: wxPython, PyQt, and PyGTK
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: wxPython，PyQt和PyGTK
- en: 'After you have explored the vastness of the `tkinter` realm, I''d suggest you
    explore other GUI libraries: wxPython ([https://www.wxpython.org/](https://www.wxpython.org/)),
    PyQt ([https://riverbankcomputing.com/software/pyqt/intro](https://riverbankcomputing.com/software/pyqt/intro)),
    and PyGTK ([https://pygobject.readthedocs.io/en/latest/](https://pygobject.readthedocs.io/en/latest/)).
    You may find out one of these works better for you, or it makes it easier for
    you to code the application you need.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在你探索了tkinter的广阔领域之后，我建议你探索其他GUI库：wxPython（https://www.wxpython.org/），PyQt（https://riverbankcomputing.com/software/pyqt/intro），和PyGTK（https://pygobject.readthedocs.io/en/latest/）。你可能会发现其中一个更适合你，或者它会让你更容易编写你需要的应用程序。
- en: I believe that coders can realize their ideas only when they are conscious of
    what tools they have available. If your toolset is too narrow, your ideas may
    seem impossible or extremely hard to realize, and they risk remaining exactly
    what they are, just ideas.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信只有当编码人员意识到他们可以使用的工具时，他们才能实现他们的想法。如果你的工具集太狭窄，你的想法可能看起来是不可能的，或者非常难以实现，它们可能会保持原样，只是想法。
- en: Of course, the technological spectrum today is humongous, so knowing everything
    is not possible; therefore, when you are about to learn a new technology or a
    new subject, my suggestion is to grow your knowledge by exploring breadth first.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，今天的技术范围是巨大的，所以不可能了解一切；因此，当你要学习新技术或新主题时，我的建议是通过广度优先探索来增加你的知识。
- en: Investigate several things, and then go deep with the one or the few that looked
    most promising. This way you'll be able to be productive with at least one tool,
    and when the tool no longer fits your needs, you'll know where to dig deeper,
    thanks to your previous exploration.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 调查几件事情，然后深入研究看起来最有希望的一个或几个。这样你就能至少用一种工具高效地工作，当这个工具不再满足你的需求时，你会知道在哪里深入挖掘，感谢你之前的探索。
- en: The principle of least astonishment
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最少惊讶法则
- en: When designing an interface, there are many different things to bear in mind.
    One of them, which for me is the most important, is the law or **principle of
    least astonishment**. It basically states that if in your design a necessary feature
    has a high astonishing factor, it may be necessary to redesign your application.
    To give you one example, when you're used to working with Windows, where the buttons
    to minimize, maximize, and close a window are on the top-right corner, it's quite
    hard to work on Linux, where they are at the top-left corner. You'll find yourself
    constantly going to the top-right corner only to discover once more that the buttons
    are on the other side.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计界面时，有许多不同的事情需要牢记。其中一个对我来说最重要的是最少惊讶法则。它基本上是说，如果在你的设计中一个必要的功能具有很高的惊讶因素，可能需要重新设计你的应用程序。举个例子，当你习惯于在Windows上工作时，最小化、最大化和关闭窗口的按钮在右上角，但在Linux上工作时，它们在左上角，这是相当困难的。你会发现自己不断地去右上角，只发现按钮在另一边。
- en: If a certain button has become so important in applications that it's now placed
    in a precise location by designers, please don't innovate. Just follow the convention.
    Users will only become frustrated when they have to waste time looking for a button
    that is not where it's supposed to be.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个按钮在应用程序中变得如此重要，以至于设计师现在将其放在一个精确的位置，请不要创新。只需遵循惯例。用户只会在不得不花时间寻找不在预期位置的按钮时感到沮丧。
- en: The disregard for this rule is the reason why I cannot work with products such
    as Jira. It takes me minutes to do simple things that should require seconds.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个规则的忽视是我无法使用Jira等产品的原因。做简单的事情花费了我几分钟的时间，本应该只需要几秒钟。
- en: Threading considerations
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程考虑
- en: This topic is outside the scope of this book, but I do want to mention it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题超出了本书的范围，但我还是想提一下。
- en: If you are coding a GUI application that needs to perform a long-running operation
    when a button is clicked, you will see that your application will probably freeze
    until the operation has been carried out. In order to avoid this, and maintain
    the application's responsiveness, you may need to run that time-expensive operation
    in a different thread (or even a different process) so that the OS will be able
    to dedicate a little bit of time to the GUI every now and then, to keep it responsive.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个GUI应用程序，需要在点击按钮时执行一个长时间运行的操作，你会发现你的应用程序可能会在操作完成之前冻结。为了避免这种情况，并保持应用程序的响应性，你可能需要在不同的线程（甚至是不同的进程）中运行那个耗时的操作，这样操作系统就能够不时地为GUI分配一点时间，以保持其响应性。
- en: Gain a good grasp of the fundamentals first, and then have fun exploring them!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要对基本原理有很好的掌握，然后再去享受探索的乐趣！
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we worked on a project together. We have written a script that
    scrapes a very simple web page and accepts optional commands that alter its behavior
    in doing so. We also coded a GUI application to do the same thing by clicking
    buttons instead of typing on a console. I hope you enjoyed reading it and following
    along as much as I enjoyed writing it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一起完成了一个项目。我们编写了一个脚本，可以抓取一个非常简单的网页，并接受可选命令来改变其行为。我们还编写了一个GUI应用程序，通过点击按钮而不是在控制台上输入来完成相同的操作。我希望你阅读和跟随的过程和我写作的过程一样愉快。
- en: We saw many different concepts, such as working with files and performing HTTP
    requests, and we talked about guidelines for usability and design.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了许多不同的概念，比如处理文件和执行HTTP请求，并讨论了可用性和设计的指导方针。
- en: I have only been able to scratch the surface, but hopefully you have a good
    starting point from which to expand your exploration.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我只能触及皮毛，但希望你有一个很好的起点，可以从中扩展你的探索。
- en: Throughout the chapter, I have pointed out several different ways you could
    improve the application, and I have challenged you with a few exercises and questions.
    I hope you have taken the time to play with those ideas. You can learn a lot just
    by playing around with fun applications like the one we've coded together.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个章节中，我指出了几种不同的改进应用程序的方法，并向你提出了一些练习和问题。我希望你花时间去尝试这些想法。你可以通过玩弄像我们一起编写的这个应用程序一样有趣的应用程序来学到很多东西。
- en: In the next chapter, we're going to talk about data science, or at least about
    the tools that a Python programmer has when it comes to facing this subject.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论数据科学，或者至少讨论一下当涉及这个主题时，Python程序员所拥有的工具。
