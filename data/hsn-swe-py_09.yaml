- en: Testing Business Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试业务对象
- en: 'Once the core business objects have been defined and tested, they can be used
    in other packages as foundations for classes to provide concrete class functionality.
    There are at least two advantages to taking this approach:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义和测试了核心业务对象，它们可以作为其他包中的基础类使用，以提供具体的类功能。采用这种方法至少有两个优点：
- en: The core classes keep all of the code that deals with data types, data structure,
    and data validation in a single place, which reduces the complexity of the other
    code bases that rely upon them
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心类将处理数据类型、数据结构和数据验证的所有代码放在一个地方，这减少了依赖它们的其他代码库的复杂性
- en: Once unit tests have been created that pass for the core objects, none of the
    functionality that they provide will have to be tested elsewhere
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦为核心对象创建了通过的单元测试，它们提供的所有功能就不需要在其他地方进行测试
- en: Those tests, written so that they can be executed on demand, can be integrated
    into a final build process, providing a complete set of regression tests that
    ensure that changes made in the future don't break existing functionality before
    executing a build
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些测试可以按需执行，并集成到最终构建过程中，提供一套完整的回归测试，以确保未来的更改不会在执行构建之前破坏现有功能
- en: The process of building out those unit tests, using the test extensions noted
    earlier, while not difficult, will be time consuming at first. The entire process
    will be examined in this chapter, establishing some testing patterns that we'll
    reuse in later chapters, before integrating them into the package build process.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前提到的测试扩展来构建这些单元测试的过程虽然不难，但一开始会很耗时。在本章中将审查整个过程，建立一些测试模式，我们将在后面的章节中重复使用这些模式，然后将它们整合到包构建过程中。
- en: 'This chapter covers the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Testing business objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试业务对象
- en: Distribution and installation considerations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发和安装考虑
- en: Quality assurance and acceptance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量保证和验收
- en: Operation/use, maintenance, and decommissioning considerations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作/使用、维护和停用考虑
- en: Starting the unit testing process
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始单元测试过程
- en: 'Using the standard unit testing structure/framework that we defined in the
    chapter before last allows us to start the unit testing of any code base very
    quickly and easily. It also lends itself well to an iterative test development
    process. The starting point test module, once the configuration items have been
    set within it by the couple of search and replace operations, immediately starts
    reporting on what test cases and methods are reporting. Our initial test module
    is little more than the following (with some comments removed to keep the listing
    short):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在上一章中定义的标准单元测试结构/框架，可以让我们快速、轻松地开始对任何代码库进行单元测试。它也非常适合迭代测试开发过程。一旦配置项在其中被一对搜索和替换操作设置好，起始点测试模块立即开始报告测试用例和方法的情况。我们的初始测试模块只是以下内容（为了保持列表的简洁，删除了一些注释）：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Executing the test module yields the following results:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试模块产生以下结果：
- en: '![](assets/fdda75b1-6beb-4c27-b077-a5e6635de534.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fdda75b1-6beb-4c27-b077-a5e6635de534.png)'
- en: That test run output informs us, then, that we need to generate test case classes
    for each of the six classes defined in the module being tested; specifically,
    we need to create `testAddress`, `testBaseArtisan`, `testBaseCustomer`, `testBaseOrder`, `testBaseProduct`,
    and `testHasProducts` test case classes. 3
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试运行输出告诉我们，我们需要为被测试模块中定义的六个类生成测试用例类；具体来说，我们需要创建`testAddress`、`testBaseArtisan`、`testBaseCustomer`、`testBaseOrder`、`testBaseProduct`和`testHasProducts`测试用例类。3
- en: 'Each of those should, in order to leverage the property and method coverage
    tests that the standard unit testing structure provides, be decorated with the `AddMethodTesting` and `AddPropertyTesting` decorators
    that `testhms_coreCodeCoverage` provides:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用标准单元测试结构提供的属性和方法覆盖测试，每个测试方法都应该使用`testhms_coreCodeCoverage`提供的`AddMethodTesting`和`AddPropertyTesting`装饰器进行装饰：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once those are in place, rerunning the test module will generate a (long!)
    list of items that need to be addressed before the test policy tests will pass. The
    full list of requirements was long enough that including it in the book directly
    would''ve just ended up with 2-3 pages of a bulleted list. The full results, however,
    are included in the `hms_core` code base, in `miscellany/initial-test-run.txt`.
    The entire initial output was far too long to reproduce in its entirety here,
    but the start and end of the output is reproduced as follows, and specifies a
    total of 105 test methods that need to be implemented across the six test case
    classes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些测试就位，重新运行测试模块将生成一个（很长的！）需要在测试策略测试通过之前解决的项目清单。需求的完整清单足够长，直接包含在书中只会导致2-3页的项目符号列表。然而，完整的结果包含在`hms_core`代码库的`miscellany/initial-test-run.txt`中。整个初始输出太长，无法在此处完整重现，但输出的开头和结尾如下，并指定了需要在六个测试用例类中实现的总共105个测试方法：
- en: '![](assets/0b23808a-ce7e-43e8-bae3-fb0017a96bf4.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0b23808a-ce7e-43e8-bae3-fb0017a96bf4.png)'
- en: 'From that point on, the test writing process is just a matter of repeating
    the following cycle until all tests pass:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，测试编写过程只是重复以下循环，直到所有测试通过为止：
- en: Pick a missing test method or set of test methods that need to be written
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择需要编写的缺失测试方法或一组测试方法
- en: Add the test method(s) to the applicable test case class, set up to fail because
    they aren't implemented
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试方法添加到适用的测试用例类中，并设置为失败，因为它们尚未实现
- en: Run the test module to verify that the tests fail as expected
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试模块以验证测试是否按预期失败
- en: 'For each test method:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个测试方法：
- en: Write real test code in the method
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法中编写真实的测试代码
- en: Execute the test module and ensure that the only failure in that method is the
    explicit one added, correcting any issues that arise
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行测试模块，并确保该方法中唯一的失败是添加的显式失败，纠正任何出现的问题
- en: Remove the explicit failures
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除显式失败
- en: Even with the guidance that is provided by the standard unit testing process,
    there is no denying that writing out all of the unit tests for a module, even
    one as relatively short as `hms_core`, can be incredibly tedious. There are a
    few things that can be done to make the process go at least somewhat faster, though—especially
    since we know that there are some common value types and formats that we're expecting.
    We'll start by writing out tests for the `Address` class, which has one of the
    largest collections of properties that we're going to be dealing with. As many
    of those tests get built out, some common (and re usable) test values will start
    to surface.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有标准单元测试过程提供的指导，也不可否认为编写模块的所有单元测试，即使是相对较短的`hms_core`模块，可能会非常乏味。然而，有一些方法可以使这个过程至少变得更快一些，因为我们知道有一些我们期望的常见值类型和格式。我们将首先为`Address`类编写测试，该类具有我们将要处理的最大属性集合之一。随着这些测试的建立，一些常见的（可重复使用的）测试值将开始出现。
- en: This run through of the unit testing process will also yield a test case class
    template file (`test-case-class.py`) that will be included in the book's code
    in the code templates directory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这次单元测试过程还将产生一个测试用例类模板文件（`test-case-class.py`），该文件将包含在书籍的代码模板目录中。
- en: Unit testing the Address class
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Address类进行单元测试
- en: 'The `Address` class tests initially report that the following test methods
    need to be written:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`类的测试最初报告需要编写以下测试方法：'
- en: '**Methods:** `test__init__`, `test_del_building_address`, `test_del_city`, `test_del_country`, `test_del_postal_code`, `test_del_region`, `test_del_street_address`, `test_get_building_address`, `test_get_city`, `test_get_country`, `test_get_postal_code`, `test_get_region`, `test_get_street_address`, `test_set_building_address`, `test_set_city`, `test_set_country`, `test_set_postal_code`, `test_set_region`, `test_set_street_address`,
    and `test_standard_address`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法：** `test__init__`，`test_del_building_address`，`test_del_city`，`test_del_country`，`test_del_postal_code`，`test_del_region`，`test_del_street_address`，`test_get_building_address`，`test_get_city`，`test_get_country`，`test_get_postal_code`，`test_get_region`，`test_get_street_address`，`test_set_building_address`，`test_set_city`，`test_set_country`，`test_set_postal_code`，`test_set_region`，`test_set_street_address`和`test_standard_address`'
- en: '**Properties:** `testbuilding_address`, `testcity`, `testcountry`, `testpostal_code`, `testregion`,
    and `teststreet_address`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性：** `testbuilding_address`，`testcity`，`testcountry`，`testpostal_code`，`testregion`和`teststreet_address`'
- en: 'The primary concern of the test methods for the properties of the class being
    tested are, arguably, to make sure that the properties use the appropriate methods
    for their getter, setter, and deleter functionalities. If that is established
    as being correct, then the actual processes for handling the properties and their
    values can be tested solely in the test methods for those methods. With that in
    mind, the bulk of the property tests for `Address` will look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对被测试类的属性的测试方法的主要关注点可以说是确保属性使用适当的方法进行其getter、setter和deleter功能。如果这一点被确认为正确，那么处理属性及其值的实际过程可以仅在这些方法的测试方法中进行测试。考虑到这一点，`Address`的大部分属性测试将如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By switching the templated `property_name` in that code block out for the actual property
    name, the individual property tests can be created quite quickly, for example,
    implementing `testbuilding_address`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在代码块中切换模板化的`property_name`为实际的属性名称，可以相当快速地创建单个属性测试，例如，实现`testbuilding_address`：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The getter and deleter method tests will usually also be quite simple—all they
    need to do, ultimately, is ensure that they are retrieving data from the correct
    internal storage attribute and setting the value of that attribute to the expected
    default value, respectively. The `test_del_building_address` test method serves
    as an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器和删除器方法的测试通常也会非常简单 - 它们最终只需要确保它们从正确的内部存储属性中检索数据，并将该属性的值设置为预期的默认值。`test_del_building_address`测试方法作为一个例子：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's worth noting that in order to test the deleter method (as well as the getter
    and setter methods later on), we actually have to create an instance of the object
    being tested—that's what the third line of the test method is doing (`test_object
    = Address…`). Once that instance is created, if the property whose deleter method
    is being tested isn't required or supplied as part of that test object's creation,
    we can (and should) also test the default/deleted value of the instance. Even
    if there is a value supplied for the test object, testing the deletion process
    by setting a value in the underlying storage attribute, calling the deleter method,
    and verifying the results afterwards will remain constant in almost all cases.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，为了测试删除器方法（以及后来的获取器和设置器方法），我们实际上必须创建被测试对象的实例 - 这就是测试方法的第三行所做的事情（`test_object
    = Address…`）。一旦创建了该实例，如果正在测试的属性在测试对象的创建中不是必需的或作为其一部分提供，我们还可以（并且应该）测试实例的默认/删除值。即使为测试对象提供了一个值，通过设置底层存储属性中的值，调用删除器方法，并在之后验证结果，删除过程的测试在几乎所有情况下都将保持不变。
- en: 'Testing the corresponding getter method is going to be similar; again, all
    it really has to do is provide that the property is retrieving data from the correct
    storage attribute:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 测试相应的getter方法将是类似的；它实际上只需要提供属性是否从正确的存储属性中检索数据：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It's often useful to set `expected` and `actual` values that can be passed to
    the core assertion of the test, particularly if retrieving those values involves
    using a method or function. It won't make a functional difference, but it can
    be a lot easier to read later on, and keeping things easily understood and readable
    is, if anything, more important than keeping the code being tested readable and
    understandable—test code is a quality assurance effort, after all, and would not
    be well served by having errors creep in because of a cryptic structure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有用的是设置可以传递给测试的核心断言的`expected`和`actual`值，特别是如果检索这些值涉及使用方法或函数。这不会产生功能上的差异，但以后阅读起来会更容易，保持易于理解和可读性是非常重要的，比保持被测试代码可读和可理解更重要——毕竟，测试代码是质量保证工作，不应该因为加密结构而出现错误。
- en: 'It''s also worth noting that the test methods for `city` and `street_address` properties
    vary slightly, because they are both properties that are set during the creation
    of an instance:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`city`和`street_address`属性的测试方法略有不同，因为它们都是在实例创建期间设置的属性。
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference is that since the test object being created is expected to provide
    a value because it was initialized with one, we're setting up the expected value
    to test against before the test object is created, creating it using that expected value,
    then testing to ensure that the deleter doesn't delete that initially set value
    during object creation. The test that it does getting deleted when explicitly
    told to is essentially the same, though.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，由于预期创建的测试对象将提供一个值，因此我们在创建测试对象之前设置了预期值进行测试，然后使用该预期值创建测试对象，然后测试以确保删除器在对象创建期间不会删除最初设置的值。尽管如此，明确告知时它被删除的测试本质上是相同的。
- en: 'Once all of the getter and deleter method tests have been established using
    those patterns, the test module run starts to show progress. One of the 29 tests
    being run (and that is one of the failures) is the code coverage test that is
    picking up the missing test case classes for `BaseArtisan` and the other `hms_core` classes,
    which have been commented out to make working with the results output of the `testAddress` test
    methods easier. Of the remaining eight failures, six are the setter method tests
    for `testAddress`, which we''ll implement next, and the other two are `test__init__` and `teststandard_address`,
    which we''ll look at last:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用这些模式建立了所有getter和deleter方法的测试，测试模块运行开始显示进展。正在运行的29个测试之一（也是失败的一个）是代码覆盖测试，它正在捕捉`BaseArtisan`和其他`hms_core`类的缺失测试用例类，这些类已经被注释掉，以便更轻松地处理`testAddress`测试方法的结果输出。剩下的八个失败中，有六个是`testAddress`的设置方法测试，我们将在下一步实现，另外两个是`test__init__`和`teststandard_address`，我们将最后看一下：
- en: '![](assets/d7ceabc3-6f66-44b3-a371-19e7187bb245.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d7ceabc3-6f66-44b3-a371-19e7187bb245.png)'
- en: The test methods corresponding to the getter and deleter methods are simple
    because the methods being tested are, themselves, quite simple. They (thus far)
    make no decisions, and neither do they do any manipulation of the values themselves;
    they simply return the current value, or replace it without having to make any
    decisions about what it's being replaced with. On top of that, they also have
    no arguments to contend with.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与getter和deleter方法对应的测试方法很简单，因为被测试的方法本身相当简单。它们（到目前为止）不做任何决定，也不对值进行任何操作；它们只是返回当前值，或者在不需要对替换值做任何决定的情况下进行替换。此外，它们也没有参数需要处理。
- en: The setter methods are more complicated; they will make decisions, will have
    arguments (if only one), and might be expected to behave differently depending
    on the types and values of those arguments. Their corresponding test methods,
    then, might be expected to be more complex too as a result, and that expectation
    would be well founded. Test complexity will grow as the complexity of the input
    grows for well designed tests, because those tests must check all of the logical
    variants of the input. That will start to become apparent as we test the setter
    methods of our properties, starting with `Address.building_address` again.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设置方法更复杂；它们会做出决策，会有参数（即使只有一个），并且可能预期根据这些参数的类型和值而表现出不同的行为。因此，相应的测试方法可能也会因此而变得更复杂，这种期望是有根据的。对于良好设计的测试来说，测试复杂性将随着输入复杂性的增加而增长，因为这些测试必须检查输入的所有逻辑变体。当我们测试属性的设置方法时，这将开始变得明显，首先从`Address.building_address`开始。
- en: 'Well designed unit tests need to do several things, not all of which may be
    obvious at first. The most obvious item is probably testing all of the happy path
    input possibilities: inputs that are of expected types and with expected and valid
    values, which should execute without errors and yield the expected results, whatever
    those results may be. Less obviously perhaps, unit tests should also test with
    a representative sample set of known bad values—values that are expected to raise
    errors and prevent the process being tested from completing with erroneous data.
    Let''s take another look at the `_set_building_address` method of `Address` with
    that in mind:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 良好设计的单元测试需要做几件事情，其中并非所有事情一开始就显而易见。最明显的事项可能是测试所有快乐路径输入可能性：预期类型和预期有效值的输入，应该在没有错误的情况下执行并产生预期的结果，无论这些结果是什么。也许不那么明显的是，单元测试还应该使用一组已知的坏值进行代表性样本集的测试，这些值预计会引发错误并阻止被测试的过程完成错误数据。让我们再次以此为基础来看一下`Address`的`_set_building_address`方法：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The good values that can be reasonably tested include the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以合理测试的良好值包括以下内容：
- en: '`None`—If `None` is passed as the value, then it simply passes through and
    is set in the inner storage attribute.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`——如果将`None`作为值传递，则它将简单地通过并设置在内部存储属性中。'
- en: Any single line, non-empty string that doesn't contain tabs or other whitespace
    characters other than spaces.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何单行非空字符串，不包含制表符或空格字符以外的其他空白字符。
- en: 'Viable bad values would include the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可行的坏值包括以下内容：
- en: Any value that isn't a string.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何不是字符串的值。
- en: An empty string.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串。
- en: A string that contains any line breaking characters, or any whitespace that
    isn't a space.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含任何换行字符或任何不是空格的空白的字符串。
- en: A string that is nothing but space characters; this item is less obvious, but
    the code will raise a `ValueError` because such an input would be caught by the
    `if not value.strip()` that's part of the value checking code. The results of
    a `.strip()` called against a string that is nothing but whitespace is an empty
    string, and that would evaluate as `False` (-ish), thus raising the error.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个什么都不是的空格字符的字符串；这个项目不太明显，但是代码会引发`ValueError`，因为这样的输入会被值检查代码中的`if not value.strip()`捕获。对仅包含空格的字符串调用`.strip()`的结果是一个空字符串，这将被评估为`False`（-ish），从而引发错误。
- en: The `_set_building_address` method doesn't try to do any content validation,
    so we don't currently have to worry about that; we're implicitly assuming that
    if someone took the effort to enter a well formed `building_address` value then
    the value entered is going to be accurate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`_set_building_address`方法不会尝试进行任何内容验证，因此我们目前不必担心；我们默认假设，如果有人费心输入一个格式良好的`building_address`值，那么输入的值将是准确的。'
- en: 'Earlier, the `business_address` property was classified as a standard optional
    text line property. If that classification holds true, then it would be both possible
    and advantageous to generate a single list of good standard optional text line
    property values, so that those values can be reused for all of the property tests
    that they''d logically apply to. That list, set up as a constant in the test module,
    might look something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，`business_address`属性被归类为标准可选文本行属性。如果这个分类是正确的，那么生成一个好的标准可选文本行属性值的单一列表将是可能的，也是有利的，这样这些值就可以被用于逻辑上适用于所有属性测试的所有属性。这个列表，作为测试模块中的一个常量，可能会像这样：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Testing the good values in `test_set_business_address` then becomes a simple
    matter of iterating over that list of values, calling the setter method, and asserting
    that the results of the getter method after the value''s been set match the expected
    value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试`test_set_business_address`中的好值就变得很简单，只需要遍历该值列表，调用setter方法，并断言在设置值后getter方法的结果与预期值匹配：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It would also be valid to perform the assertion against the property instead
    of the getter method, since we've tested that the property is associated with
    the getter method elsewhere.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经在其他地方测试了属性与getter方法相关联，那么也可以对属性进行断言，而不是对getter方法进行断言。
- en: 'A corresponding bad values list would have to include all of the bad items
    listed previously, and would look something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的坏值列表将包括之前列出的所有坏项，并且看起来会像这样：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The corresponding bad value tests are a similar iteration to the good value
    iteration shown previously, except that they will specifically look for cases
    where the execution is expected to fail, and fail if those don''t happen or happen
    in an unexpected fashion:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的坏值测试与之前显示的好值迭代类似，只是它们将专门寻找执行预期失败的情况，并且如果这些情况没有发生或以意外的方式发生，则会失败：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This test process, by using the `try` … `except` blocks, will do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`try`...`except`块，这个测试过程将执行以下操作：
- en: Explicitly fail if the setter method allows a bad value to be set without raising
    an error
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果setter方法允许设置坏值而不引发错误，则明确失败
- en: Pass if a bad value raises an expected error (`TypeError` or `ValueError` in
    most cases) while trying to set a bad value in the test object
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果坏值在测试对象中设置时引发预期的错误（在大多数情况下是`TypeError`或`ValueError`），则通过
- en: Fail if any error other than the two types expected is raised by the setter
    method during execution
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在执行期间setter方法引发了除了预期的两种类型之外的任何错误，则失败
- en: This same test method structure can be used for all of the `Address` properties
    that are also standard optional text line values/types with no more effort than
    changing the setter method names. Basically, all of the property setters of an `Address`, except
    the ones for `city` and `street_address`, which are standard required text line
    items, are identical, except for those names.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的测试方法结构可以用于`Address`的所有标准可选文本行值/类型的属性，而不需要更改setter方法名称。基本上，`Address`的所有属性setter，除了标准必需文本行项目`city`和`street_address`之外，都是相同的，只是名称不同。
- en: 'The only difference between the optional and required text line properties,
    though, is that optional items can allow `None` as a valid argument, while required
    ones cannot. If we create separate test value lists that account for those differences,
    and change which list the test method is using, the same structure, just with
    different good and bad values, will still work:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可选文本行属性和必需文本行属性之间唯一的区别是，可选项可以允许`None`作为有效参数，而必需项则不行。如果我们为这些差异创建单独的测试值列表，并更改测试方法使用的列表，那么相同的结构，只是具有不同的好和坏值，仍然可以工作：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With all of the setter method tests in place, rerunning the test module shows
    that there are only three tests failing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有setter方法测试就位后，重新运行测试模块显示只有三个测试失败：
- en: '![](assets/edd082df-d88b-4ac3-bd39-5d47d0818650.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/edd082df-d88b-4ac3-bd39-5d47d0818650.png)'
- en: Discounting the coverage test for the other test case classes, that leaves only
    the `__init__` and `standard_address` methods to test.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他测试用例类的覆盖测试之外，只剩下`__init__`和`standard_address`方法需要测试。
- en: 'Testing the `__init__` method is not going to be difficult. All it really needs
    to establish is that the initialization process that is part of creating a new
    object instance is calling the various property setters in an appropriate fashion.
    Other tests have already established that the properties connect to their intended
    getter/setter/deleter methods, and that those methods are doing what they''re
    supposed to. Since we have predefined lists of good values that we can iterate
    over, it''s a simple matter to set up a (large) set of nested loops to check all the
    possible combinations of those values as they apply to each property. The nesting
    level of the loops gets pretty deep (enough so that the following code is indented
    only two spaces per line in order to fit on the page), but it works:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`__init__`方法并不困难。它真正需要建立的是在创建新对象实例的初始化过程中，适当调用各种属性设置器。其他测试已经证实了属性连接到它们预期的getter/setter/deleter方法，并且这些方法正在按照预期进行。由于我们有预定义的良好值列表，可以迭代这些值，所以可以简单地设置一个（大）嵌套循环集来检查这些值的所有可能组合，因为它们适用于每个属性。循环的嵌套级别非常深（足够深，以至于以下代码每行只缩进两个空格以适应页面），但它有效：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same approach works just as well in implementing `teststandard_address`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法在实现`teststandard_address`时同样有效：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That, then, completes the tests for the `Address` class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`Address`类的测试就完成了：
- en: '![](assets/c8386b3e-09ed-4860-a4fd-a8cfb1a261fe.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c8386b3e-09ed-4860-a4fd-a8cfb1a261fe.png)'
- en: The balance of the unit testing process for the module really consists of reactivating
    the other test case classes, creating the baseline failing test methods for all
    of them and then just running the test module and writing and correcting tests,
    as noted earlier. Because of the way that the test process executes, the output
    generated will be for each test method of each test case class, in alphabetical
    order. So, the test case class for `HasProducts` will execute last, and within,
    that the `testproducts` method, preceded by `test_del_products`, `test_get_products`, and `test_set_products`.
    It takes less time to simply deal with the last failing test case(s) in the output,
    rather than scrolling through the entire output looking for a single, specific
    test method that's being worked on, so the remaining tests will be worked on and
    discussed in that order.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的单元测试过程的平衡实际上包括重新激活其他测试用例类，为它们创建基线失败的测试方法，然后运行测试模块并编写和纠正测试，正如前面所述。由于测试过程的执行方式，生成的输出将按照每个测试用例类的每个测试方法按字母顺序排列。因此，`HasProducts`的测试用例类将最后执行，在其中，`testproducts`方法之后是`test_del_products`，`test_get_products`和`test_set_products`。在输出中，处理最后失败的测试用例所需的时间比滚动整个输出查找正在处理的单个特定测试方法要少，因此剩下的测试将按照这个顺序进行处理和讨论。
- en: Unit testing HasProducts
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试HasProducts
- en: 'The test method for the `products` property, `testproducts`, has to account
    for the read only nature of the property—remember that the products property is
    set up to prevent, or at least minimize, the possibility of casual manipulation
    of the underlying list value. Apart from the changes to the tests of setter and
    deleter method assignment, it''s pretty much the same as previous property test
    methods, though:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`products`属性的测试方法`testproducts`必须考虑属性的只读性质——记住`products`属性设置为防止或至少最小化对底层`list`值的随意操作的可能性。除了对setter和deleter方法分配的测试的更改之外，它基本上与以前的属性测试方法相同：'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Testing the methods of an ABC like `HasProducts` is, at one level, the same
    sort of process as for a concrete class like `Address`: a test object that is
    an instance of the ABC has to be created, then relevant test values are passed
    to the methods and their results asserted. An ABC, if it has abstract members,
    cannot be instantiated, however, so a throwaway derived class that has minimal
    implementations of the abstract members has to be defined and used in place of
    the concrete class to create test objects. For the purposes of testing the member
    methods of `HasProducts` , that class is `HasProductsDerived`, and it looks like
    this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`HasProducts`这样的ABC的方法进行测试，在某种程度上，与像`Address`这样的具体类的过程相同：必须创建一个作为ABC实例的测试对象，然后将相关的测试值传递给方法并断言它们的结果。但是，如果ABC具有抽象成员，则无法实例化，因此必须定义并使用一个具有抽象成员最小实现的一次性派生类来代替具体类来创建测试对象。为了测试`HasProducts`的成员方法，该类是`HasProductsDerived`，它看起来像这样：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With that class defined, the tests for `_get_products`, `_set_products`, and `_del_products` can
    be created as straightforward variations of the test strategies used so far, though
    they require `GoodProducts` and `BadProducts` definitions that make use of the
    `throwaway` class first:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了该类后，可以创建`_get_products`，`_set_products`和`_del_products`的测试，这些测试是迄今为止使用的测试策略的直接变体，尽管它们首先需要使用`throwaway`类定义`GoodProducts`和`BadProducts`。
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once those are also in place, the test methods are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些也就位了，测试方法如下：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The test method for `HasProducts.__init__` uses much the same sort of approach
    as `test_set_products`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasProducts.__init__`的测试方法使用了与`test_set_products`相同类型的方法：'
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since `HasProducts` has concrete functionality hidden behind its `add_product` and `remove_product` methods,
    it would also be possible to test that functionality in the same fashion, but
    any derived class methods that call those methods would still have to be individually
    tested anyway, according to our test policy, so there's not much point in making
    the additional effort at this time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`HasProducts`在其`add_product`和`remove_product`方法背后隐藏了具体功能，因此也可以以同样的方式测试该功能，但是根据我们的测试策略，任何调用这些方法的派生类方法仍然必须单独进行测试，因此在这个时候额外的努力并没有太大意义。
- en: Unit testing BaseProduct
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试BaseProduct
- en: The test methods for the properties of `BaseProduct` don't require anything
    new; they follow the same approaches shown for properties with full get/set/delete
    capabilities, except for the test of the metadata property, which tests as a read-only
    property like the test for `HasProducts.products` we have just shown.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseProduct`的属性测试方法不需要任何新的东西；它们遵循与具有完整get/set/delete功能的属性相同的方法，除了对`metadata`属性的测试，它测试为只读属性，就像我们刚刚展示的对`HasProducts.products`的测试一样。'
- en: Many of the test methods for `BaseProduct` will also follow previously established
    patterns—testing for good and bad value variants of standard required and optional
    text lines—but there are a few that require new, or at least variant, approaches
    as well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseProduct`的许多测试方法也将遵循先前建立的模式——测试标准必需和可选文本行的好值和坏值变体，但也有一些需要新的或至少是变体的方法。'
- en: 'The `set_metadata` and `remove_metadata` method tests are just different enough
    from previous tests that they are worth a closer examination. In order to test
    the addition of new metadata key/value items, it''s necessary to keep track of
    an expected value that the same addition of keys and values can be performed against.
    That is achieved in the test method by creating an empty dictionary (`expected
    = {}`) that is modified in the iteration that calls the `set_metadata` method
    on the test object. As each iteration progresses, the expected value is altered
    accordingly, and is compared to the actual value:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_metadata`和`remove_metadata`方法的测试与以前的测试有足够的不同，值得更仔细地检查。为了测试新的元数据键/值项的添加，有必要跟踪一个预期值，以便可以执行相同的键和值的添加。测试方法中通过创建一个空字典(`expected
    = {}`)来实现这一点，在调用测试对象的`set_metadata`方法的迭代中对其进行修改。随着每次迭代的进行，预期值相应地被改变，并与实际值进行比较：'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Tests for bad key and value sets use a single good value for whichever item
    is not being tested, and iterate over the bad values, making sure that appropriate
    errors are raised:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对坏键和值集的测试使用一个好值，用于未被测试的任何项，并迭代坏值，确保适当的错误被引发：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The test method for the `remove_metadata` method of `BaseProduct` uses a similar
    strategy for keeping track of an expected value to compare test results against.
    The only significant difference is that the expected value (and the test object''s metadata too)
    need to be populated before trying to remove any `metadata` values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseProduct`的`remove_metadata`方法的测试方法使用了类似的策略来跟踪预期值，以便将测试结果与之进行比较。唯一的显著区别是，预期值（以及测试对象的`metadata`）需要在尝试删除任何`metadata`值之前进行填充：'
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The tests for the setter methods of the Boolean value properties of `BaseProduct`, `available`, and `store_available` still
    use the same good and bad value iteration approach that''s been used elsewhere,
    they just need a different list of good and bad values to test with:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseProduct`的布尔值属性`available`和`store_available`的setter方法的测试仍然使用了在其他地方使用的相同的好值和坏值迭代方法，只是它们需要一个不同的好值和坏值列表来进行测试：'
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, the test method for `_set_shipping_weight` needs yet another set
    of value lists, as does the test method for `_set_metadata`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对`_set_shipping_weight`的测试方法需要另一组值列表，对`_set_metadata`的测试方法也是如此：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The initial test run against `_set_shipping_weight` also prompted a review of
    the assumptions around what constitutes a valid shipping weight. On reflection,
    and without knowing what the measurement units are at this point, it's quite possible
    that those values will need to allow floating point values, especially if the
    units of measure need to eventually allow for pounds, kilograms, or even tons
    of shipping, as unlikely as that might be.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对`_set_shipping_weight`的初始测试运行也促使对构成有效运输重量的假设进行审查。经过反思，而且在这一点上并不知道测量单位是什么，这些值很可能需要允许浮点值，特别是如果最终需要允许磅、千克甚至吨的运输，尽管这可能是不太可能的。
- en: The system shouldn't place any constraints on what a valid shipping weight is,
    other than ensuring that it's a number (because it always will be) and isn't negative.
    Products might, after all, include something like a piece of calligraphy, or an
    illustration on a single sheet of paper, and that's not going to weigh much at
    all. On the other end of the spectrum, a marble bust or even a large metal sculpture
    in the dozens of pounds to one or more tons weight range is just as possible.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 系统不应该对有效的运输重量设置任何限制，除了确保它是一个数字（因为它总是会是）并且不是负数。毕竟，产品可能包括像一张书法作品或一张纸上的插图这样的东西，这些东西重量都不会很重。另一方面，几十磅到一吨或更多的重量范围内的大理石半身像甚至大型金属雕塑也同样可能。
- en: 'With all of these considerations in mind, `_set_shipping_weight` was altered
    to allow a broader range of value types, and to allow a zero value as well:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些因素，`_set_shipping_weight`被修改为允许更广泛的值类型，并且还允许零值：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Testing `_set_description` also requires one additional new value list to test
    bad values with; a description can be any string value, as it''s currently implemented,
    and there are no bad value lists that adequately capture bad values for that yet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对`_set_description`的测试还需要一个额外的新值列表来测试坏值；描述可以是任何字符串值，因为它目前是这样实现的，目前还没有适当捕捉坏值的坏值列表：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unit testing BaseOrder
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对BaseOrder进行单元测试
- en: 'Unit testing `BaseOrder`, according to the coverage test, is only going to
    be concerned with testing the `customer` property and whatever methods interact
    with that property. This is because `BaseOrder` inherits from `HasProducts`. Since
    none of the members of `HasProducts` have been overridden in `BaseOrder`, they
    are still owned by `HasProducts`, and have been tested accordingly already:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据覆盖测试，对`BaseOrder`进行单元测试只关注测试`customer`属性以及与该属性交互的任何方法。这是因为`BaseOrder`继承自`HasProducts`。由于`HasProducts`的成员没有在`BaseOrder`中被覆盖，它们仍然属于`HasProducts`，并且已经进行了相应的测试：
- en: '![](assets/7178970e-6fc8-45a0-8238-871b45c6975d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7178970e-6fc8-45a0-8238-871b45c6975d.png)'
- en: 'Like the testing processes for `BaseProduct` and `HasProducts`, testing `BaseOrder` requires
    the creation of a throwaway derived class that can be used to test method members.
    Since `BaseOrder` also expects a customer instance to be provided during object
    construction, we''ll also need to create a `BaseCustomer` derived class to provide
    such an object, and good and bad customer values to test with:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 像`BaseProduct`和`HasProducts`的测试过程一样，测试`BaseOrder`需要创建一个一次性的派生类，用于测试方法成员。由于`BaseOrder`还期望在对象构造期间提供客户实例，因此我们还需要创建一个`BaseCustomer`派生类来提供这样的对象，并且需要良好和不良的客户值进行测试：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `BaseCustomerDerived` class doesn''t have to implement anything, since `BaseCustomer` itself
    has no abstract members, which raises an interesting thought: if it doesn''t have
    any abstract members, why did we define it as an abstract class to begin with?
    The original thought behind that decision was that Customer objects are expected
    to vary significantly in what they can do, and perhaps what data access is allowed
    across the different components of the system.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseCustomerDerived`类不需要实现任何内容，因为`BaseCustomer`本身没有抽象成员，这引发了一个有趣的想法：如果它没有任何抽象成员，为什么我们一开始就将其定义为抽象类呢？这一决定背后的最初想法是，预计客户对象在系统的不同组件之间可以做的事情以及允许的数据访问可能会有很大的变化。'
- en: 'That expectation hasn''t changed since our initial implementation, so it still
    feels valid. At the same time, it would be possible to create an actual instance
    of `BaseCustomer`, simply because it has no abstract members defined, and that
    has at least some potential to introduce bugs somewhere down the line; if we believe
    that `BaseCustomer` really is abstract, even though it provides no abstract members,
    creating a concrete instance of it shouldn''t be allowed. That, at least, can
    be managed, though doing so may feel a bit awkward, by adding a few lines to the `__init__` method
    of `BaseCustomer`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 自我们最初的实现以来，这种期望没有改变，因此仍然有效。与此同时，可以创建一个`BaseCustomer`的实际实例，因为它没有定义抽象成员，这至少有可能在某个地方引入错误；如果我们相信`BaseCustomer`确实是抽象的，即使它没有提供抽象成员，创建它的具体实例也不应该被允许。至少可以通过在`BaseCustomer`的`__init__`方法中添加几行代码来管理，尽管这样做可能会感觉有些尴尬：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That, essentially, checks the class type of the object being created, and raises
    a `NotImplementedError` if the object being created is an instance of the abstract
    class itself. We''ll have to remember to test that when we write the `test__init__` method
    for that class, so it''s worth noting that in the test method now, so that it
    doesn''t get lost later on:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上检查了正在创建的对象的类类型，并且如果正在创建的对象是抽象类本身的实例，则引发`NotImplementedError`。当我们为该类编写`test__init__`方法时，我们将不得不记住测试这一点，因此现在在测试方法中值得注意一下，以免以后遗失：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That aside, the creation of a `BaseCustomerDerived` class and `GoodCustomers` and `BadCustomers` value
    lists to test with allows the test-structures for all of the `testBaseOrder` test
    case class to follow the usual patterns that have been in play so far.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，创建`BaseCustomerDerived`类和`GoodCustomers`和`BadCustomers`值列表以进行测试，允许所有`testBaseOrder`测试用例类的测试结构遵循到目前为止一直在使用的通常模式。
- en: Unit-testing BaseCustomer
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对BaseCustomer进行单元测试
- en: 'All of the property getter, setter, and deleter method tests for `BaseCustomer` follow
    the typical pattern, though the `test_object` created is usually better handled
    by creating individual instances in each test. Doing otherwise leads, pretty quickly,
    to one test making changes to a common object that made other tests fail, and
    creating individual test objects for each test solves that neatly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseCustomer`的所有属性getter、setter和deleter方法测试都遵循典型的模式，尽管通常最好在每个测试中创建单独的实例来处理`test_object`。否则，很快就会导致一个测试对共同对象进行更改，从而使其他测试失败，并且为每个测试创建单独的测试对象可以很好地解决这个问题：'
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The test for `__init__`, which needed to explicitly test whether a `BaseCustomer` object
    could be created, as noted earlier, is still pretty typical of the test structure
    established in previous test case classes, even with that addition:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`的测试需要明确测试是否可以创建`BaseCustomer`对象，正如前面所述，这仍然是以前测试用例类中建立的测试结构的典型代表：'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The balance of the test method is what would be expected from previous tests,
    iterating over a relevant set of good values and asserting that they carry through
    to the properties as expected upon instantiation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法的其余部分符合以前测试的预期，对一组相关的良好值进行迭代，并断言它们在实例化时按预期传递到属性中：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Unit testing BaseArtisan
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对BaseArtisan进行单元测试
- en: 'At this point, we''ve got established patterns that should be used for all
    of the tests to execute against `BaseArtisan`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经建立了应该用于所有针对`BaseArtisan`的测试的模式：
- en: It's an abstract class, so we need to create a derived class for testing purposes
    (`BaseArtisanDerived`)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个抽象类，因此我们需要为测试目的创建一个派生类（`BaseArtisanDerived`）
- en: 'All of the property getter, setter, and deleter methods follow one of the patterns
    already established:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的属性getter、setter和deleter方法都遵循已经建立的模式之一：
- en: All of the getter and deleter method tests are standard
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的getter和deleter方法测试都是标准的
- en: '`address` is almost a direct copy of the tests for billing and shipping address
    properties in `BaseCustomer`, and uses the same `GoodAddresses`/`BadAddresses` value
    lists'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`几乎是对`BaseCustomer`中的账单和送货地址属性的测试的直接复制，并且使用相同的`GoodAddresses`/`BadAddresses`值列表'
- en: '`company_name` is a standard optional text line test, like many of the other
    properties we''ve tested already'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`company_name`是一个标准的可选文本行测试，就像我们已经测试过的许多其他属性一样'
- en: The `contact_email` and `website` setter methods are also follow the standard
    pattern, though they need new good and bad value lists to test against
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact_email`和`website`的setter方法也遵循标准模式，尽管它们需要新的良好和不良值列表进行测试'
- en: '`contact_name` is a standard required text line property, and is tested like
    all of the other such properties'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact_name`是一个标准的必需文本行属性，并且像所有其他这样的属性一样进行测试'
- en: 'The following demonstrates examples of good and bad value lists:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了良好和不良值列表的示例：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The testing of `BaseArtisan`, however, revealed that there was no `website` argument
    provided in the `__init__` method, nor any support for passing a `website` along
    to an object during construction, so that was altered accordingly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对`BaseArtisan`的测试揭示了在`__init__`方法中没有提供`website`参数，也没有在构造对象期间支持传递`website`，因此相应地进行了修改：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And that, finally, completes all of the 118 tests for the first module of the
    system:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这样就完成了系统的第一个模块的118个测试：
- en: '![](assets/a273aadd-b13d-40ea-ba1b-3dbfd0afa0ca.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a273aadd-b13d-40ea-ba1b-3dbfd0afa0ca.png)'
- en: Unit testing patterns established so far
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到目前为止已经建立的单元测试模式
- en: There's been a lot of exploration of the unit testing of the first module in
    the system, and that exploration has established some patterns that will appear
    frequently in unit testing of the other system code as it is written, so they
    will not be re-examined in any significant detail from this point on unless there's
    a significant new aspect to them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对系统中第一个模块的单元测试进行了大量探索，这种探索已经建立了一些模式，这些模式将经常出现在编写的其他系统代码的单元测试中，因此除非它们有重大的新方面，否则从这一点开始它们将不会被重新审查。
- en: 'Those patterns are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式如下：
- en: 'Iteration over good and bad value lists that are meaningful as values for the
    member being tested:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代好和坏的值列表，这些值对于正在测试的成员是有意义的：
- en: Standard optional text line values
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准可选文本行值
- en: Standard required text line values
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准必需的文本行值
- en: Boolean (and numeric equivalent) values
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值（及其数值等价物）
- en: Metadata values
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据值
- en: Non-negative numeric values (for weight values, in this case)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非负数值（例如重量值）
- en: Verifying property method associations—getter methods in every case so far,
    and setter and deleter methods where they are expected
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证属性方法关联——到目前为止，在每种情况下都是getter方法，以及在预期的地方是setter和deleter方法
- en: Verifying that getter methods retrieve their underlying storage attribute values
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证getter方法是否检索其底层存储属性值
- en: Verifying that deleter methods reset their underlying storage attribute values
    as expected
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证deleter方法是否按预期重置其底层存储属性值
- en: Verifying that setter methods enforce type and value checks as expected
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证setter方法是否按预期强制执行类型和值检查
- en: Verifying that initialization methods (`__init__`) call all of the deleter and
    setter methods as expected
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证初始化方法（`__init__`）是否按预期调用所有的deleter和setter方法
- en: Distribution and installation considerations
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发和安装考虑因素
- en: 'The default `setup.py`, with the package name for `hms_core` added and comments
    removed, is very basic but still provides all that''s needed to build a deployable
    Python package of the `hms_core` code base so far. It also provides the ability
    to execute all of the unit tests that''ve been created for the package, given
    the path that they reside in, and the ability to find the unit testing extensions
    that were put in play:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`setup.py`，添加了`hms_core`的包名称并删除了注释，非常基本，但仍然提供了构建可部署的Python包所需的一切`hms_core`代码库。它还提供了执行为包创建的所有单元测试的能力，给定它们所在的路径，并且能够找到已经使用的单元测试扩展：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Execute the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will execute the entire test suite living in the `tests/test_hms_core` directory
    of the project:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行项目的`tests/test_hms_core`目录中的整个测试套件：
- en: '![](assets/59708536-a496-4faa-a9b3-f0e4d73c5b74.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/59708536-a496-4faa-a9b3-f0e4d73c5b74.png)'
- en: 'Executing the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will create a source distribution of the package, which can then be installed
    with the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建包的源分发，然后可以使用以下命令安装：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This can be done from a Terminal session in the directory that the package file
    lives in.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在包文件所在的目录的终端会话中完成。
- en: 'The `setup.py` build process will, at this point, raise a few errors, but none
    of them will prevent the package from being built, or from being installed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`setup.py`构建过程将引发一些错误，但这些错误都不会阻止包的构建或安装：
- en: '`warning: sdist: standard file not found: should have one of README, README.rst,
    README.txt`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`警告：sdist：未找到标准文件：应该有README、README.rst、README.txt之一`'
- en: '`warning: check: missing required meta-data: url`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`警告：检查：缺少必需的元数据：url`'
- en: '`warning: check: missing meta-data: if ''author'' supplied, ''author_email''
    must be supplied too`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`警告：检查：缺少元数据：如果提供了''author''，则必须同时提供''author_email''`'
- en: 'Once installed, the `hms_core` package can be used just like any other Python
    package:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，`hms_core`包可以像任何其他Python包一样使用：
- en: '![](assets/64790796-2e0b-4549-afa9-b5147ba1816d.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/64790796-2e0b-4549-afa9-b5147ba1816d.png)'
- en: 'Three of the original stories in this iteration, focused on how the build and
    deploy processes would interact between `hms_core` and the other component project
    libraries, have not yet been addressed:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代中，最初的三个故事集中在`hms_core`和其他组件项目库之间的构建和部署过程如何交互，目前尚未解决：
- en: As an Artisan, I need the business objects library to be installed with my application
    so that the application will work as needed without me having to install dependent
    components of it
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠，我需要业务对象库与我的应用程序一起安装，以便应用程序能够按需工作，而无需我安装其依赖组件
- en: As a Central Office user, I need the business objects library to be installed
    with my application so that the application will work as needed without me having
    to install dependent components of it
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为中央办公室用户，我需要业务对象库与我的应用程序一起安装，以便应用程序能够按需工作，而无需我安装其依赖组件
- en: As a System Administrator I need the business objects library to be installed
    with the Artisan gateway service so that it will work as needed without me having
    to install dependent components of it
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为系统管理员，我需要业务对象库与工匠网关服务一起安装，以便它能够按需工作，而无需我安装其依赖组件
- en: At this point, because we don't have any other libraries to test with, they
    realistically cannot be executed against—we'll have to wait for the actual implementation
    of at least one of the installables' packages before these can be addressed, so
    they'll go back into the backlog and be picked up when they can actually be worked
    on.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，因为我们没有其他库可以进行测试，实际上不能对其进行执行——我们将不得不等待至少一个可安装软件包的实际实现，然后才能处理这些问题，因此它们将被放回待办事项，并在实际可以处理时再次处理。
- en: Quality assurance and acceptance
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 质量保证和验收
- en: Since the functionality this library provides is foundational—intended to be
    consumed by other libraries—there isn't really much in the way of public facing
    capabilities that could be usefully tested in a formal **Quality Assurance** (**QA**)
    process. If such a formal QA process were involved in this iteration, about the
    most that could be done would be to execute the unit test suite and verify that
    those tests execute without failures or errors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该库提供的功能是基础性的，旨在被其他库使用，因此在正式的质量保证（QA）过程中，实际上没有太多公共功能可以进行有意义的测试。如果这个迭代中涉及到正式的QA过程，最多只能执行单元测试套件，并验证这些测试是否能够正常执行而没有失败或错误。
- en: 'Similarly, since the bulk of the stories involved in the iteration were for
    the benefit of developers, there would be little external acceptance needed; the
    fact that the various classes in the library exist and function as expected should
    be sufficient for acceptance of those stories:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于迭代中涉及的大部分故事都是为了开发人员的利益，因此几乎不需要外部验收；库中各种类存在并按预期运行应该足以接受这些故事。
- en: As a developer, I need a common definition and functional structure to represent
    addresses in the system, so that I can incorporate them into the parts of the
    system that need them
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要系统中表示地址的通用定义和功能结构，以便我可以将它们纳入需要它们的系统部分。
- en: As a developer, I need a common definition and functional structure to represent
    artisans in the system, so that I can incorporate them into the parts of the system
    that need them
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要系统中表示工匠的通用定义和功能结构，以便我可以将它们纳入需要它们的系统部分。
- en: As a developer, I need a common definition and functional structure to represent
    customers in the system, so that I can incorporate them into the parts of the
    system that need them
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要系统中表示客户的通用定义和功能结构，以便我可以将它们纳入需要它们的系统部分。
- en: As a developer, I need a common definition and functional structure to represent
    orders in the system, so that I can incorporate them into the parts of the system
    that need them
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要系统中表示订单的通用定义和功能结构，以便我可以将它们纳入需要它们的系统部分。
- en: As a developer, I need a common definition and functional structure to represent
    products in the system, so that I can incorporate them into the parts of the system
    that need them
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要系统中表示产品的通用定义和功能结构，以便我可以将它们纳入需要它们的系统部分。
- en: 'The stories focused on installation are in something of an odd state at this
    point—they were specifically concerned with a single installable package for all
    the various end users, which is currently the case, but there will be more functionality
    in other libraries as development progresses. As things stand right now, an argument
    could be made that these stories meet all the stated requirements, if only because
    there is only one component installation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，安装方面的故事有点奇怪——它们特别关注各种最终用户的单个可安装软件包，这目前是这样，但随着开发的进展，其他库中将会有更多功能。就目前情况而言，可以说这些故事满足了所有陈述的要求，只因为只有一个组件安装：
- en: As an Artisan, I need the business objects library to be installed with my application
    so that the application will work as needed without me having to install dependent
    components of it
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要将业务对象库与我的应用程序一起安装，以便应用程序能够按需工作，而无需我安装其依赖组件。
- en: As a Central Office user, I need the business objects library to be installed
    with my application so that the application will work as needed without me having
    to install dependent components of it
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为中央办公室用户，我需要将业务对象库与我的应用程序一起安装，以便应用程序能够按需工作，而无需我安装其依赖组件。
- en: As a System Administrator, I need the business objects library to be installed
    with the Artisan Gateway service so that it will work as needed without me having
    to install the dependent components of it
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为系统管理员，我需要将业务对象库与Artisan Gateway服务一起安装，以便它能够按需工作，而无需我安装其依赖组件。
- en: It could also be argued that these stories, though they are complete here and
    now, will have to be repeated in the development cycles for the various application
    and service components that are still to be built. Until those components have
    their own code, builds, and packages, there are no dependencies that need to be
    dealt with.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以说，尽管这些故事在此时此刻是完整的，但它们将不得不在尚未构建的各种应用程序和服务组件的开发周期中重复。在这些组件有自己的代码、构建和包之前，就没有需要处理的依赖关系。
- en: Operation/use, maintenance, and decommissioning considerations
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作/使用、维护和停用考虑
- en: Given how simple this package is, and that it has no external dependencies,
    there are no obvious considerations or items of even potential concern with regards
    to the operation and use of the package, or of decommissioning it. In the latter
    case, decommissioning would be nothing more than uninstalling the package (`pip
    uninstall HMS-Core`). Maintenance considerations would be similarly limited to
    updates of the package itself, which would be managed by simply rerunning the
    original installation process with a new package file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个软件包的简单性，以及它没有外部依赖，对于软件包的操作和使用，或者停用它，都没有明显的考虑或潜在的关注点。在后一种情况下，停用将只是卸载软件包（`pip
    uninstall HMS-Core`）。维护考虑也将同样限制在更新软件包本身，只需通过重新运行原始安装过程并使用新的软件包文件来管理。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This iteration has defined basic business objects representing significant functional
    aspects of the system, which represent the data elements of the final system.
    None of them do any more than provide the basic structure and some business rules around
    what constitutes a valid structure of those elements, though—There is, as yet,
    no mechanism for storing those elements, retrieving them or interacting with them,
    except through their properties, directly in code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这次迭代已经定义了代表系统重要功能方面的基本业务对象，这些对象代表了最终系统的数据元素。然而，它们都只提供了基本的结构和一些关于构成这些元素有效结构的业务规则，除此之外，还没有存储这些元素、检索它们或与它们进行交互的机制，除了直接在代码中通过它们的属性。
- en: The next iteration chapter will start looking in depth at what is required to
    provide the storage and state data persistence that the system's applications
    and service layer will require.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次迭代章节将深入研究系统应用程序和服务层所需的存储和状态数据持久性。
