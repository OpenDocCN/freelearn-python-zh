- en: '*Chapter 7*: Understanding Generics and Typing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第七章*：理解泛型和类型化'
- en: In this chapter, we will look at what generics are and how to perform type checking
    in Python 3 and understand how it is useful in metaprogramming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨泛型是什么，如何在Python 3中执行类型检查，以及它在元编程中的有用性。
- en: Python is a programming language where variables are declared as generics and
    they don’t get a data type assigned to them on the declaration. Python resolves
    the data types dynamically during runtime depending on the values assigned to
    variables. In other programming languages such as C++, generics need to be programmatically
    designed to make the variables generic, whereas in Python, generics are how the
    variables are defined. In such cases, how we would declare a variable with typing
    and restrict the behavior of the variables is what we will be focusing on in detail
    in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种编程语言，变量被声明为泛型，它们在声明时不会分配数据类型。Python在运行时根据分配给变量的值动态地解决数据类型。在其他编程语言，如C++中，泛型需要通过编程设计来使变量泛型，而在Python中，泛型是变量的定义方式。在这种情况下，我们将详细关注如何使用类型声明变量并限制变量的行为。
- en: Throughout this chapter, we will look at understanding how generics work in
    Python and how to define type checks so that we can apply metaprogramming on variables
    to statically type them so that we don’t have to wait for the complete program
    to run to determine that we have unintentionally used incorrect typing in our
    code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解泛型在Python中的工作方式以及如何定义类型检查，以便我们可以对变量应用元编程，以静态类型化它们，这样我们就不必等待整个程序运行来确定我们在代码中无意中使用了不正确的类型。
- en: 'In this chapter, we will be covering the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What are generics?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型是什么？
- en: What happens when data types are specified?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定数据类型时会发生什么？
- en: Typing with explicit type checks – approach 1
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显式类型检查进行类型化 – 方法1
- en: Typing with explicit type checks – approach 2
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显式类型检查进行类型化 – 方法2
- en: Adding data types with constraints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加具有约束的数据类型
- en: Creating a simple custom data type
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的自定义数据类型
- en: Creating a domain-specific data type
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个领域特定数据类型
- en: By the end of this chapter, you should be able to apply generics and type checking
    on Python variables. You should also be able to create your own domain-specific
    data types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够将泛型和类型检查应用于Python变量。你还应该能够创建自己的领域特定数据类型。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在GitHub上找到，地址为：[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07)。
- en: What are generics?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型是什么？
- en: '**Generics** are a programming paradigm where any attribute or variable is
    a function in a language that is not assigned to any specific type. When we speak
    of type, it is either the variable data type or the function return type.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型**是一种编程范式，在这种范式中，任何属性或变量都是一种在语言中未分配给任何特定类型的函数。当我们谈论类型时，它要么是变量数据类型，要么是函数返回类型。'
- en: How are generics connected to metaprogramming?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型如何与元编程相关联？
- en: '**Metaprogramming** deals with the concepts of Python 3 and above, where we
    can develop scripts or programs that manipulate the objects of Python externally
    without actually impacting the definition of classes, methods, or functions in
    a program. Generics are the way in which Python has built the handling of data
    types for its objects. If we need to change the data type handling in Python from
    generics to specific types, we can perform it through metaprogramming. To understand
    how to make specifics work, we need to understand generics with examples. Let’s
    look at generics in the following section.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**元编程**处理Python 3及以上版本的概念，其中我们可以开发脚本或程序，在外部操作Python对象，而不会实际影响程序中类、方法或函数的定义。泛型是Python构建其对象数据类型处理的方式。如果我们需要将Python中的数据类型处理从泛型更改为特定类型，我们可以通过元编程来实现。为了理解如何使具体实现工作，我们需要通过示例理解泛型。让我们在下一节中看看泛型。'
- en: How are generics handled in Python?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中如何处理泛型？
- en: Here, we can investigate generics with an example. Throughout this chapter,
    we will look into another interesting section of our core example, *ABC Megamart*.
    In this chapter, we will be covering our examples using the clothing and fashion
    department of *ABC Megamart*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过一个例子来研究泛型。在本章中，我们将探讨核心示例的另一个有趣部分，*ABC Megamart*。在本章中，我们将使用*ABC Megamart*的服装和时尚部门来介绍我们的示例。
- en: 'Let’s consider the fashion department of *ABC Megamart* in this example. This
    department covers various clothing products. To examine generics, we will first
    define a class named `Fashion` with attributes such as `clothing_category`, `gender`,
    `model`, `design`, `dress_type`, `size`, and `color`. We will also add a method
    named `get_item` to return the preceding attributes. The code is defined as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以*ABC Megamart*的时尚部门为例。这个部门涵盖了各种服装产品。为了检验泛型，我们首先定义一个名为`Fashion`的类，具有`clothing_category`、`gender`、`model`、`design`、`dress_type`、`size`和`color`等属性。我们还将添加一个名为`get_item`的方法来返回前面的属性。代码定义如下：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code handles generics. Let’s explain this statement by assigning values
    of any data types to the attributes of `Fashion`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码处理泛型。让我们通过将任何数据类型的值分配给`Fashion`类的属性来解释这个声明：
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have added string values to `clothing_category`, `gender`, `model`, `design`,
    `dress_type`, and `color`, while we added an integer value to the `size` attribute.
    Since the language handles generics by default, we did not have to declare the
    data types and the values are accepted without throwing any errors. We can call
    the `get_item` method to display these generic values:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`clothing_category`、`gender`、`model`、`design`、`dress_type`和`color`添加了字符串值，而将整数值添加到`size`属性中。由于语言默认处理泛型，我们不必声明数据类型，值被接受而没有抛出任何错误。我们可以调用`get_item`方法来显示这些泛型值：
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Examining the data types of `clothing_category` and `size` results as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`clothing_category`和`size`的数据类型结果如下：
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s double-check our statement on generics now. What happens when we change
    the data types of input variables? Will they be accepted by Python? To test this,
    let’s change the data types of `clothing_category` and `size`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来双重检查关于泛型的声明。当我们改变输入变量的数据类型时会发生什么？Python会接受它们吗？为了测试这一点，让我们改变`clothing_category`和`size`的数据类型：
- en: '[PRE18]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The change in data types is accepted and processed by Python and can be viewed
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的改变被Python接受并处理，可以如下查看：
- en: '[PRE21]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, no matter which data type the input value belongs
    to, they are processed successfully. In the following section, let’s explicitly
    assign data types and check further.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，无论输入值属于哪种数据类型，它们都能被成功处理。在下一节中，我们将显式地分配数据类型并进一步检查。
- en: What happens when data types are specified?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定数据类型会发生什么？
- en: Annotations in Python are added to code to provide additional information or
    help to end users with a piece of code while creating libraries. Annotations can
    be used to add data types to a specific code so that the information on data types
    can later be retrieved using the annotations by developers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的注解被添加到代码中以提供额外的信息或帮助最终用户在创建库时理解一段代码。注解可以用来向特定代码添加数据类型，以便开发人员可以通过注解检索数据类型的信息。
- en: Type hints as annotations
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型注解
- en: In the context of typing, which is the topic of this chapter, let’s look at
    type hints in this section. Data types of a function or method can be defined
    in Python using a functionality of annotations called `Fashion` class by declaring
    type hints on the methods of the class. To implement this, we can explicitly assign
    a data type and its return type to a variable while declaring a variable and adding
    it to a method in Python. We will also add a type hint for the return type of
    a method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的主题——类型注解的上下文中，让我们在本节中看看类型注解。在Python中，可以使用注解的功能来定义函数或方法的数据类型，通过在类的属性上声明类型注解来实现。为了实现这一点，我们可以在声明变量时显式地分配一个数据类型及其返回类型，并将其添加到Python中的方法中。我们还将为方法的返回类型添加类型注解。
- en: 'Let’s declare the `Fashion` class initialized with its attributes or variables
    along with the data types, which we would expect the variables to be on:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明一个`Fashion`类，它初始化了其属性或变量以及我们期望变量具有的数据类型：
- en: '[PRE25]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we have specifically tagged a data type to each variable.
    In this class, we will also add a `get_item` method and add annotation with a
    type hint specifying that this method returns a `list` item.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已为每个变量特别标记了一个数据类型。在这个类中，我们也将添加一个`get_item`方法，并添加带有类型提示的注释，指定该方法返回一个`list`项。
- en: 'Let’s now check what happens when these data types are not followed while creating
    an object and assigning values to these variables:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查在创建对象时未遵循这些数据类型，并将值分配给这些变量时会发生什么：
- en: '[PRE36]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have declared `clothingCategory_c` as a string and `size` as an integer in
    the preceding class definition but we have assigned an integer to `clothing_category`
    and a string to the `size` variables. The program still ran successfully without
    throwing any type error, while there should, ideally, have been a type error in
    this case. This example again proves that types are handled as generics in Python
    when we assign a data type during variable declaration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们将`clothingCategory_c`声明为字符串，将`size`声明为整数，但我们为`clothing_category`变量分配了整数，为`size`变量分配了字符串。程序仍然成功运行，没有抛出任何类型错误，而理想情况下应该出现类型错误。这个例子再次证明，当我们变量声明时分配数据类型时，Python将类型处理为泛型。
- en: 'Let’s also look at the annotation for the `get_item` method in the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码中`get_item`方法的注释：
- en: '[PRE39]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Calling `__annotations__` on the method provides the list data type annotated
    as the return type for the method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法上调用`__annotations__`提供了作为方法返回类型注解的列表数据类型：
- en: '[PRE40]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let’s look further into the concept of typing, in which we can look at how to
    deal with specific types instead of generics.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨类型的概念，我们可以看看如何处理特定类型而不是泛型。
- en: Typing with explicit type checks – approach 1
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式类型检查进行类型检查 – 方法1
- en: In the preceding section, we looked at Python’s ability to handle data types
    as generics. While building an application, there can be scenarios where a variable
    will need a specific data type, and we might expect metaprogramming to have the
    ability to handle such specific data types. In this section, let’s look at creating
    a class to perform type checking.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们探讨了Python处理数据类型作为泛型的能力。在构建应用程序时，可能会有需要特定数据类型的场景，我们可能期望元编程具有处理此类特定数据类型的能力。在本节中，让我们看看创建一个执行类型检查的类。
- en: Creating a class to implement type checking
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个类以实现类型检查
- en: 'In this example, we will be creating a class named `typecheck` and adding methods
    to check each data type specifically. If a data type, for instance, an integer
    type, is provided as input to the method, it returns the input and, if the condition
    fails, it returns a message to provide the input value as an integer. Similarly,
    we will add various methods to check string, float, list, tuple, and dictionary
    objects:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个名为`typecheck`的类，并添加方法以特定地检查每种数据类型。例如，如果将整数类型作为输入提供给方法，它将返回输入值，如果条件失败，它将返回一条消息，提供输入值作为整数。类似地，我们将添加各种方法来检查字符串、浮点数、列表、元组和字典对象：
- en: '[PRE41]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s now define a method named `intcheck`. The purpose of this method is to
    perform an integer type check of any input explicitly. In this method, a value
    will be provided as input and the method will verify whether the input value is
    an integer. If the input value is an integer, we will return the input value.
    If the value is not an integer, we will return a message that says `"value should
    be an integer"`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义一个名为`intcheck`的方法。这个方法的目的是对任何输入进行显式的整数类型检查。在这个方法中，将提供一个值作为输入，并且该方法将验证输入值是否为整数。如果输入值是整数，我们将返回输入值。如果值不是整数，我们将返回一条消息，表示`"value
    should be an integer"`：
- en: '[PRE42]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the following method, let’s check that the input variable is not a string
    (for example, `Orangesexample`) and return an error message when the condition
    is `true` and return the input value when the condition is `false`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方法中，让我们检查输入变量是否不是字符串（例如，`Orangesexample`），当条件为`true`时返回错误消息，当条件为`false`时返回输入值：
- en: '[PRE47]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the following method, let’s check that the input variable is not a floating-point
    value (for example, `example, 2335.2434`) and return an error message when the
    condition is `true` and return the input value when the condition is `false`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方法中，让我们检查输入变量是否不是浮点值（例如，`example, 2335.2434`），当条件为`true`时返回错误消息，当条件为`false`时返回输入值：
- en: '[PRE52]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the following method, let’s check that the input variable is not a list
    of variables (for example, `[''fruits'',''flowers'',1990]`) and return an error
    message when the condition is `true` and return the input value when the condition
    is `false`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方法中，让我们检查输入变量不是一个包含变量的列表（例如，`['fruits','flowers',1990]`），当条件为`true`时返回错误信息，当条件为`false`时返回输入值：
- en: '[PRE57]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the following method, let’s check that the input variable is not a tuple
    of variables (for example, `example, (''fruits'',''flowers'',1990)`) and return
    an error message when the condition is `true` and return the input value when
    the condition is `false`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方法中，让我们检查输入变量不是一个包含变量的元组（例如，`example, ('fruits','flowers',1990)`），当条件为`true`时返回错误信息，当条件为`false`时返回输入值：
- en: '[PRE62]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the following method, let’s check that the input variable is not a dictionary
    with key/value pairs (for example, `example: {''one'': 1, ''two'': 2}`) and return
    an error message when the condition is `true` and return the input value when
    the condition is `false`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '在以下方法中，让我们检查输入变量不是一个包含键/值对的字典（例如，`example: {''one'': 1, ''two'': 2}`），当条件为`true`时返回错误信息，当条件为`false`时返回输入值：'
- en: '[PRE67]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now let’s , we will proceed further to create the `Fashion` class to perform
    type checks using the `typecheck` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进一步创建`Fashion`类，使用`typecheck`类执行类型检查。
- en: Creating a class to test type checking
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个类来测试类型检查
- en: 'Let’s now create the `Fashion` class with the same set of variables, that is,
    `clothing_category`, `gender`, `model`, `design`, `dress_type`, `size`, and `color`.
    In this example too, we will assign a specific data type to each variable. In
    the following class definition, let’s create an object for the `typecheck` class
    and call type-specific methods to store the variables of each type. For instance,
    a `price` variable will be declared as `float`, and the `floatcheck` method from
    `typecheck` will be used to store the variable instead of using generics:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个具有相同变量集的`Fashion`类，即`clothing_category`、`gender`、`model`、`design`、`dress_type`、`size`和`color`。在这个例子中，我们也将为每个变量分配一个特定的数据类型。在以下类定义中，让我们创建一个`typecheck`类的对象，并调用特定类型的方法来存储每种类型的变量。例如，`price`变量将被声明为`float`，我们将使用`typecheck`中的`floatcheck`方法来存储变量，而不是使用泛型：
- en: '[PRE72]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the following method, let’s initialize the variables for the `Fashion` class
    along with their specific data types defined using the type checking methods of
    the `typecheck` class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方法中，让我们使用`typecheck`类的类型检查方法初始化`Fashion`类的变量及其特定的数据类型：
- en: '[PRE73]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the following method, let’s return all the variables initialized in the
    `Fashion` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方法中，让我们返回在`Fashion`类中初始化的所有变量：
- en: '[PRE82]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Calling the `floatcheck` method on the `price` variable acts as a typing mechanism
    for the variable declaration, and if the input provided is not a float, then an
    error will be displayed in the variable declaration phase itself:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`price`变量上调用`floatcheck`方法作为变量声明的类型机制，如果提供的输入不是浮点数，那么在变量声明阶段本身就会显示错误：
- en: '[PRE84]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the preceding example, we have declared four variables with incorrect data
    types; `clothing_category` should be a string, `price` should be a float, `size`
    should be an integer, and `color` should be a list. All these incorrect variables
    were not accepted by the code and hence we have received corresponding variable
    type errors:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了四个具有错误数据类型的变量；`clothing_category`应该是字符串，`price`应该是浮点数，`size`应该是整数，`color`应该是列表。所有这些错误的变量都没有被代码接受，因此我们收到了相应的变量类型错误：
- en: '[PRE89]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'While we get the items from the fashion object, all incorrect type variables
    have no values assigned to them. Let’s now look at the correct values and how
    they are accepted by the `fashion` object:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从时尚对象中获取项目时，所有错误类型的变量都没有分配值。现在让我们看看正确的值以及它们是如何被`fashion`对象接受的：
- en: '[PRE91]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the preceding code, we have corrected the input values by assigning values
    of specific data types and the error is now resolved. By developing such explicit
    typing libraries, we can convert Python’s generics into specifics.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过分配特定数据类型的值来纠正输入值，错误现在已解决。通过开发这样的显式类型库，我们可以将Python的泛型转换为具体类型。
- en: Typing with explicit type checks – approach 2
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式类型检查进行类型化 – 方法2
- en: In this section, we will look at another approach for applying specific data
    types to variables. In the first approach, we developed a `typecheck` class and
    used the type checking methods themselves to create new data types. In this example,
    we will be creating the `typecheck` class with each type checking method to check
    that the input value belongs to the expected type and returns a Boolean value
    based on the condition’s result. This method of type checking gives us the flexibility
    of modifying the `Fashion` class to provide variable-specific error messages when
    the condition is not met.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨另一种将特定数据类型应用于变量的方法。在第一种方法中，我们开发了一个 `typecheck` 类，并使用类型检查方法本身来创建新的数据类型。在本例中，我们将为每个类型检查方法创建
    `typecheck` 类，以检查输入值是否属于预期的类型，并根据条件的结果返回一个布尔值。这种类型检查方法使我们能够修改 `Fashion` 类，以便在条件不满足时提供特定变量的错误消息。
- en: Creating a class to implement type checking
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个类以实现类型检查
- en: In this example, let’s begin by creating the `typecheck` class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，让我们首先创建 `typecheck` 类。
- en: The `typecheck` class is created here to make all the methods in this class
    reusable just in case all the methods in the type check code need to be exported
    into a different file for later use.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里创建 `typecheck` 类是为了使本类中的所有方法可重用，以防类型检查代码中的所有方法需要导出到不同的文件以供以后使用。
- en: 'All the methods in this example can be created with or without a class and
    used throughout this chapter:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的所有方法都可以有或没有类创建，并在本章中使用：
- en: '[PRE94]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In the following method, let’s check that the input variable is not an integer
    (for example, `23348`) and return `False` when the condition is true and return
    `True` when the condition is false:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面的方法中，让我们检查输入变量不是一个整数（例如，`23348`），当条件为真时返回 `False`，当条件为假时返回 `True`：
- en: '[PRE95]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In the following method, let’s check that the input variable is not a string
    (for example, `Orangesexample`) and return `False` when the condition is true
    and return `True` when the condition is false:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面的方法中，让我们检查输入变量不是一个字符串（例如，`Orangesexample`），当条件为真时返回 `False`，当条件为假时返回 `True`：
- en: '[PRE96]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In the following method, let’s check that the input variable is not a floating
    point value (for example, `2335.2434`) and return `False` when the condition is
    true and return `True` when the condition is false:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下方法中，让我们检查输入变量不是一个浮点数值（例如，`2335.2434`），当条件为真时返回 `False`，当条件为假时返回 `True`：
- en: '[PRE97]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In the following method, let’s check that the input variable is not a list
    of variables (for example, `[''fruits'',''flowers'',1990]`) and return `False`
    when the condition is true and return `True` when the condition is false:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面的方法中，让我们检查输入变量不是一个变量列表（例如，`['fruits','flowers',1990]`），当条件为真时返回 `False`，当条件为假时返回
    `True`：
- en: '[PRE98]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In the following method, let’s check that the input variable is not a tuple
    of variables (for example, `(''fruits'',''flowers'',1990)`) and return `False`
    when the condition is true and return `True` when the condition is false:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下方法中，让我们检查输入变量不是一个变量元组（例如，`('fruits','flowers',1990)`），当条件为真时返回 `False`，当条件为假时返回
    `True`：
- en: '[PRE99]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In the following method, let’s check that the input variable is not a dictionary
    with key/value pairs (for example, `{''one'': 1, ''two'': 2}`) and return `False`
    when the condition is true and return `True` when the condition is false:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在以下方法中，让我们检查输入变量不是一个包含键/值对的字典（例如，`{''one'': 1, ''two'': 2}`），当条件为真时返回 `False`，当条件为假时返回
    `True`：'
- en: '[PRE100]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Now, we can proceed further to create the `Fashion` class to perform type checks
    using the `typecheck` class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进一步创建一个名为 `Fashion` 的类，使用 `typecheck` 类来进行类型检查。
- en: Creating a class to test type checking
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个类以测试类型检查
- en: 'In this section, let’s look at creating a `Fashion` class with a different
    variable type definition as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看看如何创建一个具有不同变量类型定义的 `Fashion` 类，如下所示：
- en: '[PRE101]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Let’s initialize the variables along with the specific data types for each:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们初始化变量以及每个变量的具体数据类型：
- en: '[PRE102]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In the following code, let’s check whether the `clothing_category` input is
    a string and return the value if it is true, and return an error specific to `clothing_category`
    if it is false:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们检查 `clothing_category` 输入是否为字符串，如果是，则返回值；如果不是，则返回针对 `clothing_category`
    的特定错误：
- en: '[PRE103]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In the following code, let‘s check whether the `gender` input is a string and
    return the value if it is true and return an error specific to the `gender` variable
    if it is false:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们检查 `gender` 输入是否为字符串，如果是，则返回值；如果不是，则返回针对 `gender` 变量的特定错误：
- en: '[PRE104]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In the following code, let’s check whether the `model` input is a tuple and
    return the value if it is true and return an error specific to the `model` variable
    if it is false:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们检查`model`输入是否为元组，如果是，则返回值；如果不是，则返回针对`model`变量的特定错误：
- en: '[PRE105]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'In the following code, let’s check whether the `design` input is an integer
    and return the value if it is true and return an error specific to the `design`
    variable if it is false:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们检查`design`输入是否为整数，如果是，则返回值；如果不是，则返回针对`design`变量的特定错误：
- en: '[PRE106]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In the following code, let’s check whether the `price` input is a floating
    point value and return the value if it is true and return an error specific to
    the `price` variable if it is false:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们检查`price`输入是否为浮点值，如果是，则返回值；如果不是，则返回针对`price`变量的特定错误：
- en: '[PRE107]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In the following code, let’s check whether the `size` input is a dictionary
    object and return the value if it is true and return an error specific to the
    `size` variable if it is false:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们检查`size`输入是否为字典对象，如果是，则返回值；如果不是，则返回针对`size`变量的特定错误：
- en: '[PRE108]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In the following code, let’s check whether the `color` input is a list object
    and return the value if it is true and return an error specific to the `color`
    variable if it is false:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们检查`color`输入是否为列表对象，如果是，则返回值；如果不是，则返回针对`color`变量的特定错误：
- en: '[PRE109]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In the following code, let’s create a method to return all the variables listed
    in the preceding code:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们创建一个方法来返回先前代码中列出的所有变量：
- en: '[PRE110]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'To test this approach of type checking, let’s pass some incorrect values as
    input for some of these variables and check:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这种类型检查方法，让我们将这些变量的一些不正确值作为输入传递并检查：
- en: '[PRE111]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Executing the preceding code results in the following list of errors:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生以下错误列表：
- en: '[PRE112]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Further, calling the `get_item` method on the preceding `fashion` object results
    in the following error:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在先前的`fashion`对象上调用`get_item`方法会导致以下错误：
- en: '[PRE117]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The graphical representation of the error message is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息的图形表示如下：
- en: '![Figure 7.1 – Error on calling the get_item method ](img/Figure_7.1_B13426.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 调用get_item方法时的错误](img/Figure_7.1_B13426.jpg)'
- en: Figure 7.1 – Error on calling the get_item method
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 调用get_item方法时的错误
- en: In the preceding error, the first variable, `clothing-category`, was not accepted
    by the method since type expectations were not met by this variable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的错误中，第一个变量`clothing-category`没有被方法接受，因为该变量的类型期望没有得到满足。
- en: 'We can check further by providing the right input types as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供正确的输入类型来进一步检查，如下所示：
- en: '[PRE118]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'There were no errors from the preceding value assignments. Calling the `get_item`
    method on the `fashion` object now results in the following output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的值赋值中没有错误。现在在`fashion`对象上调用`get_item`方法会产生以下输出：
- en: '[PRE119]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The preceding output meets all the type requirements and the end goal of type
    checking is achieved successfully through this approach. Now that you understand
    this, let’s look further into the concept of data types with constraints.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出满足所有类型要求，并且通过这种方法成功实现了类型检查的最终目标。现在你理解了这个，让我们进一步探讨具有约束的数据类型的概念。
- en: Adding data types with constraints
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加具有约束的数据类型
- en: In this section, we will look at an example of adding constraints to data types
    and checking constraints along with type checking. There might be scenarios where
    we would like to create an integer variable and restrict its length to two digits
    or to create a string and restrict its length to 10 characters and more. With
    this example, let’s explore how to add such constraints or restricts during the
    static type checking.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一个向数据类型添加约束并在类型检查的同时检查约束的示例。可能会有这样的场景，我们想要创建一个整数变量并限制其长度为两位数，或者创建一个字符串并限制其长度为10个字符以上。通过这个例子，让我们探索如何在静态类型检查期间添加这样的约束或限制。
- en: 'In this example, let’s create a `typecheck` class with only two methods to
    check an integer and a string. While checking these data types, let’s also add
    a few more constraints within the method definition:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们创建一个只包含两个方法的`typecheck`类来检查整数和字符串。在检查这些数据类型的同时，我们也在方法定义中添加了一些额外的约束：
- en: '[PRE127]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'In the following method, let’s check that the input variable is not an integer
    or its length is greater than two, and return `False` when the condition is true,
    and return `True` when the condition is false:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下方法中，让我们检查输入变量不是整数或其长度大于两个，当条件为真时返回`False`，当条件为假时返回`True`：
- en: '[PRE128]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'In the following method, let’s check that the input variable is not a string
    or its length is greater than 10, and return `False` when the condition is true,
    and return `True` when the condition is false:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面的方法中，让我们检查输入变量不是字符串或其长度大于10，当条件为真时返回`False`，当条件为假时返回`True`：
- en: '[PRE129]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'With just two methods with type checks and constraints, we can look into creating
    a `Fashion` class with two variables and one method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 只需两个带有类型检查和约束的方法，我们就可以创建一个具有两个变量和一个方法的`Fashion`类：
- en: '[PRE130]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Let’s initialize the class with `clothing_category` as a string and `size`
    as an integer:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们用字符串`clothing_category`和整型`size`初始化类：
- en: '[PRE131]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'In the following code, let’s declare `clothing_category` using the `stringcheck`
    method:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面的代码中，让我们使用`stringcheck`方法声明`clothing_category`：
- en: '[PRE132]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'In the following code, let’s declare `size` using the `intcheck` method:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面的代码中，让我们使用`intcheck`方法声明`size`：
- en: '[PRE133]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'In the following code, let’s add the method to get the items and return them:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面的代码中，让我们添加一个方法来获取项目并返回它们：
- en: '[PRE134]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Let’s further create an object for the `fashion` class and assign two variables
    that do not match the type-checking conditions:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步创建一个`fashion`类的对象，并分配两个不满足类型检查条件的变量：
- en: '[PRE135]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The preceding error messages indicate that both the type checks and constraints
    are not met for the string as well as integer data types. Let’s now provide the
    right type of input values and perform static type checking:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的错误信息表明，字符串类型以及整型数据类型都没有满足类型检查和约束条件。现在，让我们提供正确的输入值并执行静态类型检查：
- en: '[PRE138]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The value assignments are now working as expected in the preceding code. With
    this understanding, let’s proceed further to create simple custom data types.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，值赋值现在按预期工作。有了这个理解，让我们进一步创建简单的自定义数据类型。
- en: Creating a simple custom data type
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的自定义数据类型
- en: Until the preceding section, we looked at adding explicit type checks and converting
    generic type variables into specific types to handle specific data needs we might
    get while programming an application, and we also added errors to help debug incorrect
    data types assigned to variables.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节之前，我们探讨了添加显式类型检查以及将泛型类型变量转换为特定类型来处理在编写应用程序时可能遇到的具体数据需求，我们还添加了错误信息来帮助调试分配给变量的不正确数据类型。
- en: In this section, let’s look at creating our own simple data types and what will
    be required to do so. First of all, let’s answer the question of why we need our
    own data types. Any custom data type is a derivation of basic data types in Python
    along with certain variations to fulfill the purpose of our data needs in an application.
    Any data type will have its own set of operations that can be performed on top
    of the data of that specific type. For instance, an integer data type will support
    arithmetic operations such as addition, subtraction, multiplication, and division.
    Similarly, a string supports concatenation in the place of addition, and so on.
    So, when we create our own data type, we can override these basic operations to
    fulfill the need of our custom data type.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨创建我们自己的简单数据类型以及这样做需要满足什么条件。首先，让我们回答为什么我们需要自己的数据类型。任何自定义数据类型都是Python基本数据类型的一个派生，并伴随一些变化以满足我们在应用程序中的数据需求。任何数据类型都将有一组可以在该特定类型数据上执行的操作。例如，整型数据类型将支持加法、减法、乘法和除法等算术操作。同样，字符串支持使用连接代替加法，等等。因此，当我们创建自己的数据类型时，我们可以覆盖这些基本操作以满足我们自定义数据类型的需求。
- en: 'To demonstrate this, let‘s first create our own data type and override the
    basic operators to perform the operations that we expect. Please note that custom
    data types may be required only in situations where we would like to make it domain-specific
    or application-specific. We can always use default data types and avoid creating
    custom data types where there is no requirement:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们首先创建我们自己的数据类型并覆盖基本运算符以执行我们期望的操作。请注意，自定义数据类型可能只在以下情况下需要：我们希望使其具有领域特定性或应用特定性。我们始终可以使用默认数据类型，并在没有要求的情况下避免创建自定义数据类型：
- en: 'We will create a class named `DressSize` and initialize it with the `size`
    variable of the integer type. If the input value for `size` is not an integer
    and the input values do not follow a specific list of dress sizes, type checking
    returns an error message in red (as shown in *Figure 7.2*):'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`DressSize`的类，并用整型变量`size`初始化它。如果`size`的输入值不是整数，或者输入值不遵循特定的服装尺寸列表，类型检查将返回一个红色的错误信息（如图*7.2*所示）：
- en: '[PRE141]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Next, let’s override the default `str` method of a class to return the string
    version of the `size` variable:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们重写一个类的默认 `str` 方法，使其返回 `size` 变量的字符串版本：
- en: '[PRE142]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Then, let’s add a new method named `value` to return the value of the `size`
    attribute:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们添加一个名为 `value` 的新方法，用于返回 `size` 属性的值：
- en: '[PRE143]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Now, let’s override the addition (`+`) operator of the integer method to increase
    `size` values from one dress size object created for the `DressSize` class:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重写整数方法的加法（`+`）运算符，以增加为 `DressSize` 类创建的一个服装尺寸对象中的 `size` 值：
- en: '[PRE144]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Then, let’s override the subtraction (`-`) operator of the integer method to
    decrease `size` values from one size object created for the `DressSize` class:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们重写整数方法的减法（`-`）运算符，以减少为 `DressSize` 类创建的一个尺寸对象中的 `size` 值：
- en: '[PRE145]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'We will then create an object for the class, in this case, our new custom data
    type, `DressSize`, and initialize it with a string instead of an integer, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将为该类创建一个对象，在这种情况下，我们的新自定义数据类型 `DressSize`，并用字符串而不是整数来初始化它，如下所示：
- en: '[PRE146]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Incorrect input type results in an error with a red font similar to how error
    messages are usually displayed while debugging:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 不正确的输入类型会导致出现类似调试时通常显示的错误信息的红色字体错误：
- en: '![Figure 7.2 – Error message for DressSize  ](img/Figure_7.2_B13426.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – DressSize 的错误信息](img/Figure_7.2_B13426.jpg)'
- en: Figure 7.2 – Error message for DressSize
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – DressSize 的错误信息
- en: 'Calling the `value` method would also result in an error since the type checking
    failed for the `DressSize` data type:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `value` 方法也会导致错误，因为 `DressSize` 数据类型的类型检查失败了：
- en: '[PRE147]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The value error is displayed as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 值错误显示如下：
- en: '![Figure 7.3 – Value error due to incorrect DressSize input type ](img/Figure_7.3_B13426.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 由于输入类型不正确导致的值错误](img/Figure_7.3_B13426.jpg)'
- en: Figure 7.3 – Value error due to incorrect DressSize input type
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 由于输入类型不正确导致的值错误
- en: 'Let’s correct this error by providing the correct input type while creating
    a `DressSize` object:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在创建 `DressSize` 对象时提供正确的输入类型来纠正这个错误：
- en: '[PRE148]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'In the following code, we can look at how the addition operation (`+`) works
    on the objects of `DressSize`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们可以看看加法操作（`+`）是如何在 `DressSize` 对象上工作的：
- en: '[PRE149]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The addition of two objects works like a regular addition since we have overloaded
    the addition operator (`+`) to add the initialized variables of two objects. Similarly,
    we can check the results of subtraction, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个对象的加法操作与常规加法类似，因为我们已经重载了加法运算符（`+`）来添加两个对象的初始化变量。同样，我们可以检查减法的结果，如下所示：
- en: '[PRE150]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The subtraction of two objects works like a regular subtraction since we have
    overloaded the subtraction operator (`-`) to subtract the initialized variables
    of two objects. Similarly, printing the object results in printing the string
    format of the `size` variable since we have overloaded the `str` method to do
    this:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个对象的减法操作与常规减法类似，因为我们已经重载了减法运算符（`-`）来从两个对象的初始化变量中减去。同样，打印对象会打印 `size` 变量的字符串格式，因为我们已经重载了
    `str` 方法来完成这项工作：
- en: '[PRE151]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'We have also added a `value` method to display the value of the `size` variable,
    and it works as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了一个 `value` 方法来显示 `size` 变量的值，它的工作方式如下：
- en: '[PRE152]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Calling the `type` method on the variable or the `s` object displays the class
    name, `DressSize`, which is the data type of `s` in this case:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在变量或 `s` 对象上调用 `type` 方法会显示类名 `DressSize`，这是在这种情况下 `s` 的数据类型：
- en: '[PRE153]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Now, we can consider creating a more detailed data type of our own in the next
    section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以考虑在下一节创建一个更详细的自定义数据类型。
- en: Creating a domain-specific data type
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个特定领域的数据类型
- en: In this section, let’s create an even more customized data type to deal with
    the dress size of the fashion department of *ABC Megamart*. The `DressSize` data
    type we defined in the preceding section handles any integer as input and performs
    the operations we overloaded. When we look at the domain of the fashion industry
    and consider the dress size as a domain-specific variable, the `DressSize` data
    type should ideally be considering only specific values for `size` and not accept
    all integers. The dress size will be based on the size of dresses held in the
    inventory of *ABC Megamart*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们创建一个更定制的数据类型来处理 *ABC Megamart* 时尚部门的服装尺寸。我们在前一节中定义的 `DressSize` 数据类型可以处理任何整数作为输入并执行我们重载的操作。当我们查看时尚行业的领域并考虑服装尺寸作为特定领域的变量时，`DressSize`
    数据类型理想情况下应该只考虑 `size` 的特定值，而不是接受所有整数。服装尺寸将基于 *ABC Megamart* 库存中持有的服装尺寸：
- en: 'The accepted input for dress size in this example should be the list of integers,
    `[36,38,40,42,44,46,48]`, or the list of strings that indicates the equivalent
    text values for dress size such as `[XS,S,M,L,XL,XXL,XXXL]`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，接受服装尺寸的输入应该是整数列表`[36,38,40,42,44,46,48]`，或者表示服装尺寸等效文本值的字符串列表，例如`[XS,S,M,L,XL,XXL,XXXL]`：
- en: 'Let’s begin by creating the `DressSize` class along with its methods to work
    as a domain-specific data type, and initialize `size` as its only input value:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建`DressSize`类及其方法开始，使其作为特定领域的数据类型工作，并将`size`初始化为其唯一的输入值：
- en: '[PRE154]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Let’s further define two domain-specific lists that holds the valid set of
    values for dress size in text and integer formats, respectively:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步定义两个特定领域的列表，分别用于存储服装尺寸的有效值集合，一个是文本格式，另一个是整数格式：
- en: '[PRE155]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'In the following code, we will be creating a dictionary object that holds the
    integer and text format of `size` as key/value pairs. The reason behind adding
    this dictionary object is to use it further in the data type-specific methods
    created for this data type:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将创建一个字典对象，它包含`size`的整数和文本格式的键/值对。添加这个字典对象的原因是将其用于为该数据类型创建的特定数据类型方法中：
- en: '[PRE156]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Let’s now add the condition that accepts the input value as `size` if it meets
    the data type criteria and then rejects the input value with an error if it does
    not meet the criteria:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个条件，如果输入值符合数据类型标准，则接受该输入值作为`size`，如果不满足标准，则使用错误信息拒绝输入值：
- en: '[PRE157]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'In the preceding code, the input value will be accepted if it is present in
    the `romanchart` list variable or if it is present in the `sizenum` list variable.
    If both the criteria are not met, the value will be rejected by the `DressSize`
    data type and an error message will be displayed in a red-colored font. Why do
    we need to set these strict constraints in this particular domain-specific data
    type? If we look at the `size` values of a dress, the size usually is an even
    number and there are no odd-numbered dress sizes in a shopping cart or in a clothing
    store. Also, the size of the clothing in most of the generic clothing stores falls
    between 36 and 48 in general. If the store holds clothes of lesser or greater
    sizes, we can adjust the lists accordingly and redefine the data type. In this
    specific scenario, let’s consider the dress sizes between 36 and 48 and their
    corresponding text codes between XS and XXXL as acceptable values. Now, we have
    added the acceptance criteria for the data type:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果输入值存在于`romanchart`列表变量中，或者存在于`sizenum`列表变量中，则将接受该输入值。如果这两个条件都不满足，`DressSize`数据类型将拒绝该值，并在红色字体中显示错误信息。为什么我们需要在这个特定领域的特定数据类型中设置这些严格的约束？如果我们看看服装的`size`值，尺寸通常是一个偶数，购物车或服装店中没有奇数尺寸的服装。此外，大多数通用服装店的服装尺寸通常在36到48之间。如果商店持有较小或较大的尺寸的服装，我们可以相应地调整列表并重新定义数据类型。在这个特定场景中，让我们考虑36到48之间的服装尺寸及其对应的文本代码XS到XXXL作为可接受值。现在，我们已经添加了数据类型的接受标准：
- en: 'Let’s add specific methods that can be processed on the data type. In the following
    method, let’s override the default `str` method of a class to return the string
    version of the `size` variable:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加可以在此数据类型上处理的具体方法。在以下方法中，让我们重写类的默认`str`方法，以返回`size`变量的字符串版本：
- en: '[PRE158]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'In the following code, let’s add a new method named `value` to return the value
    of the `size` attribute:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的代码中，让我们添加一个名为`value`的新方法来返回`size`属性的值：
- en: '[PRE159]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'In the following code, let’s add a method to increment the `size` value. The
    `size` value should increment by `2` since dress size is always measured in even
    numbers:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的代码中，让我们添加一个方法来增加`size`值。由于服装尺寸总是以偶数测量，`size`值应该增加`2`：
- en: '[PRE160]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In the preceding code, we have added a logic to look up the value of a dress
    size such as `XL` if `DressSize` is a text input to the data type, and then increment
    the value by `2`. We have also added a logic to check the integer value of the
    dress size and increment by `2` if the dress size input is an integer.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个查找服装尺寸值（如`XL`）的逻辑，如果`DressSize`是数据类型的文本输入，然后增加该值`2`。我们还添加了一个检查服装尺寸整数值的逻辑，如果服装尺寸输入是整数，则增加`2`。
- en: 'Let’s add one more method to decrement the `DressSize` attribute:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再添加一个方法来减少`DressSize`属性：
- en: '[PRE161]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: In the preceding code, we have added a logic to look up the value of a dress
    size such as `XL` if `DressSize` is a text input to the data type, and then decrement
    the value by `2`. We have also added a logic to check the integer value of `DressSize`
    and decrement by `2` if the dress size input is an integer. This defines the overall
    creation of a domain-specific data type named `DressSize`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们添加了一个查找连衣裙尺寸值（如`XL`）的逻辑，如果`DressSize`是数据类型的文本输入，然后减去`2`。我们还添加了一个检查`DressSize`的整数值的逻辑，如果连衣裙尺寸输入是整数，则减去`2`。这定义了名为`DressSize`的特定领域数据类型的整体创建。
- en: 'The next step is to test this data type by creating an object:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是通过创建一个对象来测试这种数据类型：
- en: '[PRE162]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'In the preceding code, we have created an object named `s`, so let’s look at
    how various methods and attributes work on this object:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个名为`s`的对象，因此让我们看看各种方法和属性在这个对象上的工作方式：
- en: '![Figure 7.4 – Attributes of DressSize ](img/Figure_7.4_B13426.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – DressSize的属性](img/Figure_7.4_B13426.jpg)'
- en: Figure 7.4 – Attributes of DressSize
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – DressSize的属性
- en: 'In the following code, let’s call `chart` from the `s` object:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们从`s`对象中调用`chart`：
- en: '[PRE163]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Printing the object results in the string format representation of the value
    of the `s` object:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印对象会产生`s`对象值的字符串格式表示：
- en: '[PRE164]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Calling the value method results as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用值方法的结果如下：
- en: '[PRE165]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Calling the increment method results as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用增量方法的结果如下：
- en: '[PRE166]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Calling the decrement method results as follows:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用减量方法的结果如下：
- en: '[PRE167]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Let’s now create the `Fashion` class and initialize variables out of which
    the `size` variable will be initialized as the `DressSize` type:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在创建`Fashion`类并初始化变量，其中`size`变量将被初始化为`DressSize`类型：
- en: '[PRE168]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'In the following code, let’s define the type checking condition for `DressSize`.
    If `size` is an instance of `DressSize`, then it returns the instance, and if
    it is not an instance, an appropriate error message will be displayed:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，让我们定义`DressSize`的类型检查条件。如果`size`是`DressSize`的实例，则返回该实例；如果不是实例，将显示适当的错误消息：
- en: '[PRE169]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Let’s further add the `get_item` method to return the attributes of the `Fashion`
    class:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步添加`get_item`方法来返回`Fashion`类的属性：
- en: '[PRE170]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Creating the object further results as follows:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建对象进一步的结果如下：
- en: '[PRE171]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: In the preceding code, we did not assign the correct data type for the size
    variable.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们没有为`size`变量分配正确的数据类型。
- en: 'To correct it, let’s create an instance of `DressSize` and provide it as input
    to the `Fashion` class:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了纠正它，让我们创建一个`DressSize`的实例并将其作为输入提供给`Fashion`类：
- en: '[PRE172]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The preceding code did not result in any error and is accepted as input by
    the `Fashion` class. Calling the `get_item` method would result in the following
    output:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码没有产生任何错误，并且被`Fashion`类接受为输入。调用`get_item`方法会产生以下输出：
- en: '[PRE173]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'If we want to look at the specific value of the `M` object, we can call the
    `value` method as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看`M`对象的特定值，可以按照以下方式调用`value`方法：
- en: '[PRE174]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: In this section, we looked at how to create a domain-specific custom data type
    and how to use it on another class as a type variable.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何创建特定领域的自定义数据类型，以及如何将其用作另一个类的类型变量。
- en: These are some of the examples of how generics work in Python and how specifics
    can be applied to Python objects using user-defined functions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些Python中泛型工作方式的示例，以及如何使用用户定义的函数将具体内容应用于Python对象。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have learned the concepts of generics and type checking.
    We also looked at creating user-defined data types with specific constraints and
    we’ve also seen how to apply them to our core example. We created our own domain-specific
    data type and overloaded operators and methods to work according to the data type.
    Similar to other chapters covered in this book, this chapter is also used to change
    the behavior of Python objects externally using the concept of metaprogramming.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了泛型和类型检查的概念。我们还探讨了创建具有特定约束的用户定义数据类型，并看到了如何将它们应用于我们的核心示例。我们创建了自己的特定领域数据类型，并重载了运算符和方法以根据数据类型工作。类似于本书中涵盖的其他章节，本章也用于使用元编程的概念在外部更改Python对象的行为。
- en: In the next chapter, we will be looking at the concept of templates with some
    interesting examples.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过一些有趣的示例来探讨模板的概念。
