- en: Building a Practical Decentralized Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个实用的去中心化应用程序
- en: In this chapter, we are going to write a popular application on the blockchain,
    which will be a secure voting application powered by the blockchain. You have
    all the tools to develop this application, namely, populus and `web3.py`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在区块链上编写一个流行的应用程序，这将是一个由区块链驱动的安全投票应用程序。您有所有开发此应用程序的工具，即populus和`web3.py`。
- en: 'Here are the topics that we are going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的主题：
- en: Developing a simple voting application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个简单的投票应用
- en: Learning about an event in a smart contract
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解智能合约中的事件
- en: Developing a commercial voting application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个商业投票应用程序
- en: Developing a token-based voting application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发基于令牌的投票应用
- en: Discussing another type of voting application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论另一种类型的投票应用程序
- en: Developing a simple voting application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个简单的投票应用
- en: 'First, we are going to build the simplest voting application, simpler than
    the voting application example that comes with the Vyper software source code.
    Let''s set up our Populus project directory:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建最简单的投票应用程序，比Vyper软件源代码中提供的投票应用程序示例还要简单。让我们设置我们的Populus项目目录：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, add Vyper support to `project.json` by changing the value of the key
    compilation to the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过将键编译的值更改为以下内容，将Vyper支持添加到`project.json`中：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The latest version of Vyper is 0.1.0b6 which, breaks Populus. The developer
    needs some time to fix this problem. If the bug has still not been fixed by the
    time you are reading this book, you can patch Populus yourself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper的最新版本是0.1.0b6，这破坏了Populus。开发人员需要一些时间来解决这个问题。如果到您阅读本书时错误仍未被修复，您可以自行修补Populus。
- en: 'First, check whether the bug has been fixed by using the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令检查错误是否已修复：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our case here, the bug has not been fixed. So, let''s patch Populus to fix
    the bug. Make sure you are still in the same directory (`voting-venv/src/populus`):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，错误尚未被修复。因此，让我们修补Populus以修复错误。确保您仍然在相同的目录（`voting-venv/src/populus`）中：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, create a simple voting smart contract inside the `contracts` directory.
    Name it `SimpleVoting.vy`*. *Refer to the following GitLab link for the full code
    – [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/SimpleVoting.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/SimpleVoting.vy):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`contracts`目录中创建一个简单的投票智能合约。命名为`SimpleVoting.vy`。*请参考以下GitLab链接获取完整代码 -
    [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/SimpleVoting.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/SimpleVoting.vy)：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s discuss this simple voting smart contract. It is inspired by the voting
    example in the Vyper source code, but this example is simplified even further.
    The original example has a delegation feature that would make things hard to understand.
    We start with the struct data type variable declaration:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这个简单的投票智能合约。它受到Vyper源代码中投票示例的启发，但这个示例甚至更简化。原始示例具有委托功能，这将使事情难以理解。我们从结构数据类型变量声明开始：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The data structure is a variable that has a composite data type that holds the
    name of the proposal and the amount that the proposal has. The `vote_count` in
    the `Proposal` struct has a data type of `int128`, while `name` in the `Proposal`
    struct has a data type of `bytes32`. You could also use `uint256` instead of the `int128`
    data type for `vote_count` in the `Proposal` struct. It would not make any difference,
    though. However, `bytes32` is a new data type. As you may recall from [Chapter
    3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml)*, Implementing Smart Contracts
    With Vyper*, if you want to use the string (or array of bytes) data type in Vyper,
    you use `bytes[20]` if the length of that string is less than 20.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是一个具有复合数据类型的变量，其中包含提案的名称和提案的金额。`Proposal`结构中的`vote_count`数据类型为`int128`，而`Proposal`结构中的`name`数据类型为`bytes32`。您也可以使用`uint256`而不是`int128`数据类型来表示`Proposal`结构中的`vote_count`。不过，这不会有任何区别。但是，`bytes32`是一个新的数据类型。正如您可能还记得的那样，如果要在Vyper中使用字符串（或字节数组）数据类型，如果该字符串的长度小于20，则使用`bytes[20]`。
- en: 'bytes32 is another string data type similar to `bytes[32]`, but with one peculiarity;
    if you set the `b''messi''` string to a variable with the `bytes[32]` type and retrieve
    it with `web3`, you would get `b''messi''`. However, if you set the `b''messi''`
    string to a variable with the `bytes32`type and retrieve it with `web3`, you would
    get `b''messi\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00''`.
    This string would be padded until we reach 32 bytes. By default, you should use
    `bytes[20]` or `bytes[256]` as the string data type, as opposed to using `bytes32`.
    Then why am I using `bytes32` in this smart contract? I have a good reason for
    doing so, but we need to move on to the constructor function first to understand
    the reason why I use `bytes32`  to keep the name of proposals:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: bytes32是另一种类似于`bytes[32]`的字符串数据类型，但有一个特殊之处；如果您将`b'messi'`字符串设置为具有`bytes[32]`类型的变量，并使用`web3`检索它，您将得到`b'messi'`。但是，如果您将`b'messi'`字符串设置为具有`bytes32`类型的变量，并使用`web3`检索它，您将得到`b'messi\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'`。此字符串将填充直到达到32字节。默认情况下，您应该使用`bytes[20]`或`bytes[256]`作为字符串数据类型，而不是使用`bytes32`。那么为什么我在这个智能合约中使用`bytes32`？我有一个很好的理由这样做，但我们需要先继续到构造函数以了解我为什么使用`bytes32`来保存提案的名称：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the first time we are using an event in a smart contract. `event` is
    a keyword in Vyper that is designed to create an event. An event is something
    that happens inside smart contract that our client (the `web3` program) wants
    to subscribe to. In this statement, `Voting` is the name of the event and it has
    two parameters. The first parameter is `_from`, which has the type of `address`.
    `indexed` is used to make filtering events possible using `_from` as a filter.
    The second parameter is `_proposal`, which is of the type `int128`. Remember,
    `int128` is a 128-bit integer. This event will become clearer when we subscribe
    to it in our client program. For now, let''s move on to the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次在智能合约中使用事件。`event`是Vyper中的一个关键字，用于创建事件。事件是智能合约内发生的事情，我们的客户端（`web3`程序）希望订阅。在这个语句中，`Voting`是事件的名称，有两个参数。第一个参数是`_from`，类型为`address`。`indexed`用于使用`_from`作为过滤器进行事件过滤。第二个参数是`_proposal`，类型为`int128`。记住，`int128`是一个128位整数。当我们在客户端程序中订阅它时，这个事件将变得更清晰。现在，让我们继续下一个：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This variable is a mapping data type variable that maps an `int128` data type
    variable to a `Proposal` struct variable. Basically, it''s a list of proposals:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量是一个映射数据类型变量，将一个`int128`数据类型变量映射到一个`Proposal`结构变量。基本上，这是一个提案列表：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a helper variable to count how many proposals are in this smart contract:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个辅助变量，用来计算这个智能合约中有多少提案：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is used to check whether an account has already voted or not. We don''t
    want an account to vote for the same proposal more than once. Remember, this is
    a mapping data type. By default, a non-existent value points to a null value.
    Null in the context of `int128` is `0`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于检查一个账户是否已经投票。我们不希望一个账户对同一个提案投票多次。记住，这是一个映射数据类型。默认情况下，不存在的值指向一个空值。在`int128`的上下文中，空值是`0`：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This constructor got an argument, which is an array of `bytes32`. Inside the
    constructor, it will iterate twice (we hardcoded the number of proposals into
    two). Each iteration will set a new member into the `proposals` mapping variable.
    `name` is set from the argument, and `vote_count` is initialized as 0\. Then,
    the `proposals_count` is increased by one for each iteration.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数有一个参数，是一个`bytes32`数组。在构造函数内部，它将迭代两次（我们将提案的数量硬编码为两个）。每次迭代都会将一个新成员设置到`proposals`映射变量中。`name`是从参数中设置的，`vote_count`初始化为0。然后，对于每次迭代，`proposals_count`都会增加1。
- en: 'Here''s why I use `bytes32` as a data type for a proposal name: If I used `bytes[128]` as
    a data type for a proposal name, I could not send it as an argument.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以使用`bytes32`作为提案名称的数据类型，是因为如果我使用`bytes[128]`作为提案名称的数据类型，我无法将其作为参数发送。
- en: 'The method in a smart contract in the Vyper programming language cannot accept
    nested arrays such as `bytes[128][2]` as an argument (at least at the moment in
    the latest version of Vyper):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper编程语言中的智能合约方法不能接受嵌套数组，比如`bytes[128][2]`作为参数（至少在Vyper的最新版本中是这样）：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the function to vote. It accepts an argument named `proposal`. Here,
    the user votes for a proposal with an integer. So, if the user calls the `vote`
    method with an argument of `0`, such as `vote(0)`, it means the user votes for
    the first proposal. Of course, you could use the string to vote, as in `vote(b'proposal1')`
    when you design your own voting smart contract. Here, I use an integer to make
    things simpler.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是投票的函数。它接受一个名为`proposal`的参数。在这里，用户用一个整数为提案投票。所以，如果用户使用`0`这样的参数调用`vote`方法，比如`vote(0)`，这意味着用户为第一个提案投票。当你设计自己的投票智能合约时，当然你也可以使用字符串来投票，比如`vote(b'proposal1')`。在这里，我使用整数来简化事情。
- en: 'In this function, we assert that the voter has not yet voted with this statement:
    `assert self.voters_voted[msg.sender] == 0`. After voting, we set the value of
    `voters_voted` with the voter''s address as the key to `1`: `self.voters_voted[msg.sender]
    = 1`. We also verify that the voting is valid by checking that the value of the
    voting is less than the number of proposals, which is `2`. The nitty-gritty of
    this function is the following statement: `self.proposals[proposal].vote_count
    += 1`. At the end of this function, our `Voting` event is used in this statement:
    `log.Voting(msg.sender, proposal)`. This is similar to broadcasting that something
    important has happened—Hey, world! There is a `Voting` event that has two parameters,
    `msg.sender` as the `address` parameter, and `proposal` as the `int128` parameter.
    Then, anyone who subscribes to this event will be notified. The subscription of
    the event happens on the client side, using the `web3` library, as demonstrated
    in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们断言选民还没有使用这个语句投票：`assert self.voters_voted[msg.sender] == 0`。投票后，我们将`voters_voted`的值设置为选民的地址作为键的`1`：`self.voters_voted[msg.sender]
    = 1`。我们还通过检查投票的值是否小于提案的数量（即`2`）来验证投票是否有效。这个函数的关键是以下语句：`self.proposals[proposal].vote_count
    += 1`。在这个函数的结尾，我们的`Voting`事件在这个语句中被使用：`log.Voting(msg.sender, proposal)`。这类似于广播发生了重要的事情——嘿，世界！有一个`Voting`事件，有两个参数，`msg.sender`作为`address`参数，`proposal`作为`int128`参数。然后，任何订阅了这个事件的人都会收到通知。事件的订阅发生在客户端，使用`web3`库，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This private function is designed to check which proposal has the most votes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个私有函数设计用来检查哪个提案获得了最多的投票：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `public` function is designed to get the name of the proposal that has
    the most votes. This function uses the private function described previously.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`public`函数设计用来获取获得最多票数的提案的名称。这个函数使用了前面描述的私有函数。
- en: This smart contract is simple but not perfect, as there is a bug present. For
    example, in the `vote` function, we did not handle the negative value of voting.
    On top of that, the number of proposals is hardcoded into 2\. However, it will
    get the job done.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个智能合约很简单，但并不完美，因为存在一个错误。例如，在`vote`函数中，我们没有处理投票的负值。此外，提案的数量是硬编码为2。但是，它可以完成工作。
- en: 'Then, you can compile the smart contract''s code in the usual manner:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像通常一样编译智能合约的代码：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As a good citizen, let''s write a test for this smart contract. Create a file
    named `test_simple_voting_app.py` in the `tests` directory. Refer to the following
    GitLab link for the full code of the following code block: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_simple_voting_app.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_simple_voting_app.py):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个好公民，让我们为这个智能合约编写一个测试。在`tests`目录中创建一个名为`test_simple_voting_app.py`的文件。参考以下GitLab链接获取以下代码块的完整代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_simple_voting_app.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_simple_voting_app.py)：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s discuss this test one function at a time:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个讨论这个测试：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because our simple voting smart contract''s constructor requires an argument,
    we need to use a fixture in the test, as discussed in [Chapter 5](b87b0052-d66e-43ff-afc4-cf26bac23728.xhtml)
    *, Populus Development Framework*. Then, our fixture can be used as an argument
    in the test method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们简单的投票智能合约的构造函数需要一个参数，所以我们需要在测试中使用一个fixture，如[第5章](b87b0052-d66e-43ff-afc4-cf26bac23728.xhtml)*Populus开发框架*中所讨论的那样。然后，我们的fixture可以作为测试方法的参数使用：
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is to check the state of the smart contract after it is deployed. One
    thing is very unique here; the length of the name''s variable in the struct data
    inside the proposals variable is `32`, even if we set it with the value `b''messi''`,
    such is the peculiarity of the `bytes32` data type. This is why we slice the variable
    to get what we want. Then, for the next test method, we use the `chain` parameter
    in addition to the `voting` parameter:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了检查部署后智能合约的状态。这里有一件非常独特的事情；在提案变量内的结构数据的名称变量的长度是`32`，即使我们将其设置为值`b'messi'`，这就是`bytes32`数据类型的特殊之处。这就是为什么我们要切片变量以获取我们想要的内容。然后，对于下一个测试方法，我们使用`chain`参数以及`voting`参数：
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is used to test the `vote` function. We test whether the `vote` function
    indeed changes the `vote_count` property of the `proposals` variable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于测试`vote`函数。我们测试`vote`函数是否确实改变了`proposals`变量的`vote_count`属性：
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This ensures that we cannot vote more than once using the same account. As
    we learned in `Chapter 5`, *Populus Development Framework*, you wrap the fail
    case with the `pytest.raises with` statement. The last test case is to check the
    winning proposal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了我们不能使用同一个账户投票超过一次。正如我们在`第5章`*Populus开发框架*中学到的那样，您可以使用`pytest.raises with`语句将失败的情况包装起来。最后一个测试用例是检查获胜的提案：
- en: '[PRE20]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this test, you use three accounts with the `t.get_accounts` helper methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，您可以使用`t.get_accounts`辅助方法使用三个账户。
- en: Deploying a smart contract that has arguments in its constructor
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署一个构造函数中带有参数的智能合约
- en: Let's deploy this smart contract to the Ethereum blockchain. However, we must
    first be aware that there are some things that complicate the situation. First,
    the `event` does not work in Ganache, so we have to deploy it to the Rinkeby network
    or the private Ethereum blockchain. Second, our smart contract has an argument
    in the constructor. To deploy a smart contract with arguments, we need to use
    a different method; we cannot use the normal method as demonstrated in `Chapter
    5`*, Populus Development Framework*. In [Chapter 5](https://cdp.packtpub.com/hands_on_blockchain_for_python_developers/wp-admin/_wp_link_placeholder)*,
    Populus Development Framework*, we deployed a smart contract using Populus this
    way[: ](https://cdp.packtpub.com/hands_on_blockchain_for_python_developers/wp-admin/post.php?post=29&action=edit#post_28)[`populus
    deploy --chain localblock Donation`.](https://cdp.packtpub.com/hands_on_blockchain_for_python_developers/wp-admin/post.php?post=29&action=edit#post_28)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个智能合约部署到以太坊区块链。然而，我们首先需要意识到有一些事情会使情况复杂化。首先，`event`在Ganache中不起作用，因此我们必须将其部署到Rinkeby网络或私有以太坊区块链。其次，我们的智能合约在构造函数中有一个参数。要部署带有参数的智能合约，我们需要使用不同的方法；我们不能像在`第5章`*Populus开发框架*中演示的那样使用普通方法。在[第5章](https://cdp.packtpub.com/hands_on_blockchain_for_python_developers/wp-admin/_wp_link_placeholder)*Populus开发框架*中，我们使用Populus以这种方式部署了一个智能合约[:](https://cdp.packtpub.com/hands_on_blockchain_for_python_developers/wp-admin/post.php?post=29&action=edit#post_28)[`populus
    deploy --chain localblock Donation`.](https://cdp.packtpub.com/hands_on_blockchain_for_python_developers/wp-admin/post.php?post=29&action=edit#post_28)
- en: 'The Populus method can only deploy a smart contract with a constructor without
    arguments. Let''s overcome these obstacles one by one. The first thing we need
    to do is deploy it to the private Ethereum blockchain, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Populus方法只能部署一个没有参数的构造函数的智能合约。让我们一一克服这些障碍。我们需要做的第一件事是将其部署到私有以太坊区块链，如下所示：
- en: 'Inside the `voting_project` directory, run the following command:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`voting_project`目录中，运行以下命令：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, initialize the private chain using the `init_chain.sh` script:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`init_chain.sh`脚本初始化私有链：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Edit `chains/localblock/run_chain.sh`and change the value of the `--ipcpath`
    flag to `/tmp/geth.ipc`. Then, run the blockchain:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`chains/localblock/run_chain.sh`并将`--ipcpath`标志的值更改为`/tmp/geth.ipc`。然后，运行区块链：
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, edit the `project.json` file. The `chains` key has one object that has
    4 keys: `tester`, `temp`, `ropsten`, and `mainnet`. Add one key named `localblock`
    with its value to this object:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`project.json`文件。`chains`键有一个对象，其中有4个键：`tester`，`temp`，`ropsten`和`mainnet`。在这个对象中添加一个名为`localblock`的键及其值：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running a blockchain requires a dedicated terminal. So open a new terminal,
    execute a virtual environment script, and then go inside the `voting_project`
    directory. Create this file and name it `deploy_SmartVoting.py`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行区块链需要一个专用的终端。因此，打开一个新的终端，执行一个虚拟环境脚本，然后进入`voting_project`目录。创建这个文件并命名为`deploy_SmartVoting.py`：
- en: '[PRE25]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s discuss what this program does:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下这个程序的作用：
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We import tools from the `populus` library, and `Project` represents the `project.json`
    configuration file. `wait_for_transaction_receipt` is a function that waits until
    our transaction has been confirmed in the Ethereum blockchain:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`populus`库中导入工具，`Project`代表`project.json`配置文件。`wait_for_transaction_receipt`是一个等待我们的交易在以太坊区块链中确认的函数：
- en: '[PRE27]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inside the `main` function, we initialize a `Project` instance and then we
    get the `localblock` chain:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们初始化了一个`Project`实例，然后获取了`localblock`链：
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `chain` object is now representing this `json` object in the `project.json` file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`chain`对象现在代表`project.json`文件中的这个`json`对象。'
- en: 'We get the `SimpleVoting` smart contract factory from `build/contracts.json`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`build/contracts.json`中获取`SimpleVoting`智能合约工厂：
- en: '[PRE29]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we deploy our smart contract to the private Ethereum blockchain:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将我们的智能合约部署到私有以太坊区块链上：
- en: '[PRE30]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It receives two keyword arguments, `transaction` and `args`. The transaction
    argument is a dictionary of transactions. Here, we set the `from` parameter. `chain.web3.eth.coinbase`
    is our default account, which is common in a `testing/development` scenario. Here,
    we use the default account without the private key. In this transaction object,
    we can also set `gas`, gasPrice, and other transaction parameters. The `args`
    keyword argument allows us to send an argument to the constructor of a smart contract.
    It is a nested array, `[[b'Messi', b'Ronaldo']]`, because the inner array is the
    `_proposalNames` argument in the constructor of the smart contract.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收两个关键字参数，`transaction`和`args`。`transaction`参数是一个交易字典。在这里，我们设置了`from`参数。`chain.web3.eth.coinbase`是我们的默认账户，在`testing/development`场景中很常见。在这里，我们使用默认账户而不使用私钥。在这个交易对象中，我们还可以设置`gas`、`gasPrice`和其他交易参数。`args`关键字参数允许我们向智能合约的构造函数发送参数。它是一个嵌套数组，`[[b'Messi',
    b'Ronaldo']]`，因为内部数组是智能合约构造函数中的`_proposalNames`参数。
- en: 'The outer array is designed to encapsulate other parameters in the constructor,
    but we only have one argument in this case:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 外部数组被设计用来封装构造函数中的其他参数，但在这种情况下我们只有一个参数：
- en: '[PRE31]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We wait for the transaction to be confirmed. Then, we get the address of the
    smart contract from the deployment process:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待交易确认。然后，我们从部署过程中获取智能合约的地址：
- en: '[PRE32]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `receipt` object is an object from the blockchain that describes the confirmation
    of the transaction. What we are concerned with in this context is the address,
    that is, the `contractAddress` key in the receipt object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`receipt`对象是区块链中描述交易确认的对象。在这种情况下，我们关心的是地址，也就是`receipt`对象中的`contractAddress`键：'
- en: '[PRE33]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is designed to execute the `main` function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了执行`main`函数而设计的。
- en: 'Unlike Ganache, where you are given 10 accounts (each equipped with 100 ethers),
    in this private Ethereum blockchain with default settings from Populus, you only have one
    account equipped with 1 trillion ethers! The following script allows you to find
    out how many ethers the default account has:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不像Ganache，那里有10个账户（每个账户都有100个以太币），在Populus的默认设置下的私有以太坊区块链中，你只有一个账户，配备了1万亿以太币！以下脚本允许你查看默认账户有多少以太币：
- en: '[PRE34]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this smart contract, we want to play with our smart contract with more than
    1 account. So let''s create 10 accounts in this Ethereum private blockchain. Creating
    a new account is possibly not the appropriate term here because all accounts are
    already created in the Ethereum blockchain, so perhaps **finding new accounts**
    is more appropriate. Create a new file inside the `voting_project` directory and
    name it `create_10_accounts_on_private_chain.py`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个智能合约中，我们想要使用多个账户来玩我们的智能合约。所以让我们在这个以太坊私有区块链中创建10个账户。在`voting_project`目录中创建一个新文件，命名为`create_10_accounts_on_private_chain.py`。
- en: '[PRE35]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We will write our new accounts' addresses in the file so we can reuse them later.
    The function that you need to notice is `w3.personal.newAccount('password123')`.
    This will give you the public address. The private key will be encrypted with
    `password123`. This will be saved in the `chains/localblock/chain_data/keystore`
    directory. The name of the encrypted file is something like this—`UTC—2018-10-26T13-13-25.731124692Z—36461a003a03f857d60f5bd0b8e8a64aab4e4535`.
    The end part of the name of the file is the `public` address. In that filename
    example, the `public` address is `36461a003a03f857d60f5bd0b8e8a64aab4e4535`. Execute
    this script. The `public` address of the 10 accounts will be written in the `10_accounts.txt`
    file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新账户的地址写入文件，以便以后重复使用。你需要注意的函数是`w3.personal.newAccount('password123')`。这将给你公共地址。私钥将使用`password123`进行加密。这将保存在`chains/localblock/chain_data/keystore`目录中。加密文件的名称类似于`UTC—2018-10-26T13-13-25.731124692Z—36461a003a03f857d60f5bd0b8e8a64aab4e4535`。文件名的结尾部分是`public`地址。在这个文件名的示例中，`public`地址是`36461a003a03f857d60f5bd0b8e8a64aab4e4535`。执行这个脚本。10个账户的`public`地址将被写入`10_accounts.txt`文件。
- en: If you take a look at the `chains/localblock/chain_data/keystore` directory,
    you will see at least 11 files.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`chains/localblock/chain_data/keystore`目录，你会看到至少11个文件。
- en: 'Each of these new 10 accounts are equipped with 0 ethers. To vote in our smart
    contract, you should not have an empty balance. So, why don''t we distribute our
    money from the default account to these 10 accounts? Create a file inside `voting_project`,
    and name it `distribute_money.py`*.* Refer to the code file in the following GitLab
    link for the full code – [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/distribute_money.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/distribute_money.py):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这10个新账户中的每一个都配备了0个以太币。要在我们的智能合约中投票，你不能有空余的余额。那么，为什么我们不把默认账户的钱分发给这10个账户呢？在`voting_project`目录下创建一个文件，命名为`distribute_money.py`。参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/distribute_money.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/distribute_money.py)：
- en: '[PRE36]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s discuss this script line by line:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐行讨论这个脚本：
- en: '[PRE37]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You already know about `Web3`, `IPCProvider`*, *and `wait``_for_transaction_receipt`.
    `glob` is from the Python standard library. Its purpose is to filter files from
    the directory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了`Web3`，`IPCProvider`*，*和`wait_for_transaction_receipt`。`glob`来自Python标准库。它的目的是从目录中过滤文件：
- en: '[PRE38]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We connect to the Ethereum node using a socket:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用套接字连接到以太坊节点：
- en: '[PRE39]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is our default account''s address. How do you know? You can find it with
    `w3.eth.coinbase` in a script connecting to this private Ethereum blockchain,
    or you can take a look at the filename inside the `chains/localblock/chain_data/keystore`
    directory. There is only one filename after you initialize and run the private
    Ethereum blockchain. Now, after you initialize another 10 accounts, naturally,
    the number of files will be 11:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们默认账户的地址。您怎么知道？您可以在连接到这个私有以太坊区块链的脚本中使用`w3.eth.coinbase`找到它，或者您可以查看`chains/localblock/chain_data/keystore`目录中的文件名。在初始化和运行私有以太坊区块链后，只有一个文件名。现在，在您初始化另外10个账户后，文件的数量自然会变成11：
- en: '[PRE40]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The password to unlock the default account is stored in a plain text file in
    `chains/localblock/password`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁默认账户的密码存储在`chains/localblock/password`的纯文本文件中：
- en: '[PRE41]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After finding this, we decrypt the encrypted file using the `w3.eth.account.decrypt`
    method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 找到这个之后，我们使用`w3.eth.account.decrypt`方法解密加密文件：
- en: '[PRE42]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is to avoid the obligation of providing the `from` parameter to a method
    when creating a transaction:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了避免在创建交易时提供`from`参数的义务：
- en: '[PRE43]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We opened `10_accounts.txt`, containing all the new accounts that we have,
    and then we iterated these one by one:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了`10_accounts.txt`，里面包含了我们拥有的所有新账户，然后我们一个一个地迭代这些账户：
- en: '[PRE44]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We check the latest nonce value with `w3.eth.getTransactionCount` before feeding
    it to transaction object. The transaction object has `to`, `value`, `gas`, and `gasPrice`,
    as well as the `nonce` key. Here, we want to send 10 ethers to each account:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其提供给交易对象之前，我们使用`w3.eth.getTransactionCount`检查最新的nonce值。交易对象有`to`，`value`，`gas`和`gasPrice`，以及`nonce`键。在这里，我们想给每个账户发送10个以太币：
- en: '[PRE45]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We sign the transaction with our private key, and then we broadcast the transaction
    to the miners using the `w3.eth.sendRawTransaction` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用我们的私钥对交易进行签名，然后使用`w3.eth.sendRawTransaction`方法将交易广播给矿工：
- en: '[PRE46]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is very important. If you only send money to one account, you could skip
    it. However, since we broadcast 10 transactions in a sequential manner, you must
    wait for each transaction to be confirmed first before broadcasting the next transaction.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要。如果您只向一个账户发送资金，您可以跳过它。但是，由于我们按顺序广播了10笔交易，您必须在广播下一笔交易之前等待每笔交易先确认。
- en: 'Think of it this way: you broadcast a transaction of sending 10 ethers with
    nonce 3, and then miners will need time to confirm this transaction. But, in a
    short space of time, you broadcast a new transaction with nonce 4\. Miners who
    get this transaction will complain to you because you tried to skip from nonce
    2 to nonce 4\. Remember, the transaction with nonce 3 takes time to be confirmed.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想：您广播了一个nonce为3的发送10个以太币的交易，然后矿工需要时间来确认这笔交易。但是，在短时间内，您广播了一个新的nonce为4的交易。得到这笔交易的矿工会向您抱怨，因为您试图从nonce
    2跳到nonce 4。请记住，nonce 3的交易需要时间来确认。
- en: After executing the file, you can check that your 10 accounts have 10 ethers
    each.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行文件后，您可以检查您的10个账户每个都有10个以太币。
- en: 'Let''s create our simple decentralized voting application based on the smart
    contract. Go outside `voting_project` and create a new directory to contain our
    application. After creating the directory, enter the following inside it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于智能合约创建我们的简单去中心化投票应用。离开`voting_project`，创建一个新目录来包含我们的应用。创建目录后，输入以下内容：
- en: '[PRE47]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s create a program to subscribe to a `Voting` event. Name this file `watch_simple_voting.py`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个订阅`Voting`事件的程序。将此文件命名为`watch_simple_voting.py`：
- en: '[PRE48]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let''s discuss this program line by line:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐行讨论这个程序：
- en: '[PRE49]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We need `abi` to connect to a smart contract. You can get this from the smart
    contract''s complication. Since `abi` is a `json` object that has a Boolean set
    as `true` and `false`, while Python''s Boolean values are `True` and `False` (notice
    the capitalization), we need to adjust it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`abi`来连接到一个智能合约。您可以从智能合约的编译中获得这个。由于`abi`是一个`json`对象，其中有一个布尔值设置为`true`和`false`，而Python的布尔值是`True`和`False`（注意大写），我们需要调整它：
- en: '[PRE50]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To connect to a smart contract, you need an address. This is the address from
    the deployment script. You can also set the address to the one hardcoded in the
    code, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到一个智能合约，您需要一个地址。这是部署脚本中的地址。您也可以将地址设置为代码中硬编码的地址，如下所示：
- en: '[PRE51]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, I prefer to put it in an external file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我更喜欢把它放在一个外部文件中：
- en: '[PRE52]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is designed to create a subscription to the `Voting` event of the `SimpleVoting`
    smart contract. The syntax is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了创建一个订阅`SimpleVoting`智能合约的`Voting`事件。语法如下：
- en: '[PRE53]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`fromBlock` is the historical pointer. The lower the block, the earlier the
    history:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromBlock`是历史指针。块越低，历史越早：'
- en: '[PRE54]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we subscribe to the voting event. You would get something like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们订阅投票事件。您会得到类似于这样的东西：
- en: '[PRE55]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let this script run. Don''t exit the application. Open a new Terminal, execute
    our virtual environment script, and go inside the `voting_dapp` project. After
    doing so, create a new script and name it `simple_voting_client.py`. Refer to
    the code file in the following GitLab link for the full cod: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_dapp/simple_voting_client.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_dapp/simple_voting_client.py):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让这个脚本运行。不要退出应用程序。打开一个新的终端，执行我们的虚拟环境脚本，并进入`voting_dapp`项目。这样做后，创建一个新的脚本，并将其命名为`simple_voting_client.py`。参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_dapp/simple_voting_client.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_dapp/simple_voting_client.py)：
- en: '[PRE56]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s discuss this line by line. We start from the top part of the script:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐行讨论这个。我们从脚本的顶部开始：
- en: '[PRE57]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The logic here is the same as the previous script. You started by opening the
    encrypted file using `password123`. You then set the voter''s account address
    in the `client_address.txt` file to make this script flexible. You are welcome
    to hardcode the voter''s account address in the script:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的逻辑与之前的脚本相同。您首先使用`password123`打开加密文件。然后在`client_address.txt`文件中设置选民的账户地址，以使此脚本灵活。您可以在脚本中硬编码选民的账户地址：
- en: '[PRE58]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, you set the `abi` from the smart contract compilation in the usual manner:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您以通常的方式从智能合约编译中设置`abi`：
- en: '[PRE59]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Remember, in this script, there are two addresses. The first is the address
    of the voter or the client. The second is the address of the smart contract. Then,
    you need to get the nonce:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在这个脚本中有两个地址。第一个是选民或客户的地址。第二个是智能合约的地址。然后，您需要获取nonce：
- en: '[PRE60]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You use this nonce when building a transaction:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建交易时，您使用此nonce：
- en: '[PRE61]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This is the `vote` function. Here, we vote for the proposal with the index
    `0`, which is `b''messi''`. You submit `gas`, `gasPrice`, and `nonce`, and you
    omit `from` because you already set `w3.eth.defaultAccount`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`vote`函数。在这里，我们为索引为`0`的提案投票，即`b'messi'`。您提交`gas`、`gasPrice`和`nonce`，并且省略`from`，因为您已经设置了`w3.eth.defaultAccount`：
- en: '[PRE62]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The last lines are dedicated to signing and broadcasting transactions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行是用于签名和广播交易的。
- en: 'Execute the script, and then go to the Terminal in which you ran the `watch_simple_voting.py`
    script. You would then get something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本，然后转到您运行`watch_simple_voting.py`脚本的终端。然后您会得到类似于这样的东西：
- en: '[PRE63]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There you have it. In a real-world application, this event can be used to give
    a notification in a decentralized application. Then, you could update the standings
    of the voting or whatever you like.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。在实际应用中，此事件可用于在分散式应用程序中提供通知。然后，您可以更新投票的排名或其他任何您喜欢的内容。
- en: 'You can also get all events from the beginning. Remember the code to get the
    event? This is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从一开始获取所有事件。还记得获取事件的代码吗？如下所示：
- en: '[PRE64]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Instead of using `get_new_entries`, you could use `get_all_entries` to retrieve
    all events from the beginning, demonstrated as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`get_all_entries`而不是`get_new_entries`来检索从一开始的所有事件，如下所示：
- en: '[PRE65]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Developing a commercial voting application
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发商业投票应用程序
- en: Let's upgrade our smart contract to a commercial one. To vote, the voter needs
    to pay a small amount of money. This is similar to American Idol, in which people
    vote for who they want to win by text-messaging their choice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的智能合约升级为商业智能合约。为了投票，选民需要支付一小笔钱。这类似于美国偶像，人们通过短信投票来决定谁获胜。
- en: 'Go back to the `voting_project` directory and open a new file in the `contracts`
    directory and name this `CommercialVoting.vy`. Refer to the code file in the following
    GitLab link for the full code of this code block: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/CommercialVoting.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/CommercialVoting.vy):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`voting_project`目录，打开`contracts`目录中的新文件，命名为`CommercialVoting.vy`。有关此代码块的完整代码，请参考以下GitLab链接中的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/CommercialVoting.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/CommercialVoting.vy)：
- en: '[PRE66]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This smart contract is similar to `SimpleVoting.vy`, but with an additional
    payment feature. We won''t discuss it line by line, but we will look at the differences
    between the previous smart contract and this one:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个智能合约类似于`SimpleVoting.vy`，但具有额外的支付功能。我们不会逐行讨论它，但我们将看一下之前的智能合约和这个之间的区别：
- en: '[PRE67]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In this constructor function, we save the address of the account that launched
    the smart contract:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构造函数中，我们保存了启动智能合约的账户的地址：
- en: '[PRE68]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this `vote` function, we added the `@payable` decorator so people can send
    money when they want to vote. As well as that, we require the minimum payment
    to be `0.01` ether using this statement: `assert msg.value >= as_wei_value(0.01,
    "ether")`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`vote`函数中，我们添加了`@payable`装饰器，以便人们在想要投票时可以发送资金。除此之外，我们要求最低支付为`0.01`以太币，使用此语句：`assert
    msg.value >= as_wei_value(0.01, "ether")`：
- en: '[PRE69]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Naturally, we have to create a function to withdraw ethers from the smart contract.
    Here, we send ethers to the manager account.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须创建一个从智能合约中提取以太币的函数。在这里，我们将以太币发送到经理账户。
- en: 'Now, let''s move on to testing the smart contract. Create the test file inside
    the `tests` directory and name it `test_commercial_voting.py`. Refer to the code
    file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_commercial_voting.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_commercial_voting.py):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续测试智能合约。在`tests`目录中创建测试文件，命名为`test_commercial_voting.py`。有关完整代码，请参考以下GitLab链接中的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_commercial_voting.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_commercial_voting.py)：
- en: '[PRE70]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s discuss the test functions one by one:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个讨论测试函数：
- en: '[PRE71]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This is designed to test the manager variable points to the account that launched
    the smart contract. Remember that `web3.eth.coinbase` is the default account.
    Testing whether to vote requires a number of ethers and accounts, which we can
    get from `t.get_accounts()`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了测试经理变量是否指向启动智能合约的账户。请记住，`web3.eth.coinbase`是默认账户。测试投票是否需要一定数量的以太币和账户，我们可以从`t.get_accounts()`中获取：
- en: '[PRE72]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is to test that you can send ethers in the `vote` function. You also test
    the balance of the ethers that are accumulated in the smart contract:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了测试您可以在`vote`函数中发送以太币。您还测试了在智能合约中累积的以太币的余额：
- en: '[PRE73]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is to test that you need to send a minimum of `0.01` ether when you want
    to vote:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了测试在您想要投票时，您需要发送至少`0.01`以太币：
- en: '[PRE74]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is one of the most important tests in this smart contract. It is designed
    to test whether or not you can correctly withdraw ethers from the smart contract.
    You can check the balance before and after withdrawal, and make sure that the
    difference is roughly around 1 ether (because you have to pay for gas).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个智能合约中最重要的测试之一。它旨在测试您是否可以正确地从智能合约中提取以太币。您可以在提取前后检查余额，并确保差额大约为1个以太币（因为您需要支付燃气费）。
- en: Developing a token-based voting application
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发基于代币的投票应用
- en: 'Now, let''s develop a token-based voting application on the blockchain. What
    I mean by token-based voting is that in order to vote, you must have a token that
    is created in the smart contract. If you vote with this token, then the token
    is burnt, meaning that you cannot vote twice. In this smart contract, the number
    of tokens are also limited, unlike previous voting applications where unlimited
    accounts can vote. Let''s write a smart contract in the `contracts` directory
    and name the file `TokenBasedVoting.vy`. Refer to the code file in the following
    GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/TokenBasedVoting.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/TokenBasedVoting.vy):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在区块链上开发一个基于代币的投票应用。我所说的基于代币的投票是指，为了投票，您必须拥有在智能合约中创建的代币。如果您用这个代币投票，那么这个代币就会被销毁，这意味着您不能投两次票。在这个智能合约中，代币的数量也是有限的，不像之前的投票应用程序，无限的账户可以投票。让我们在`contracts`目录中编写一个智能合约，并将文件命名为`TokenBasedVoting.vy`。请参考以下GitLab链接中的代码文件获取完整代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/TokenBasedVoting.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/TokenBasedVoting.vy)：
- en: '[PRE75]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let''s discuss this script line by line:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行讨论这个脚本：
- en: '[PRE76]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You have familiarized yourself with the `proposals` variable, which has the
    same purpose as the previous voting application. `token` is a new variable that
    is intended to track the token''s owner. `index` and `maximum_token` are variables
    to count how many tokens we have assigned. Remember, we want to limit the number
    of tokens. The manager is the one who launched the smart contract:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了`proposals`变量，它与之前的投票应用具有相同的目的。`token`是一个新变量，旨在跟踪代币的所有者。`index`和`maximum_token`是用来计算我们分配了多少个代币的变量。请记住，我们希望限制代币的数量。`manager`是启动智能合约的人：
- en: '[PRE77]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the constructor, after setting up the `proposals` variable, we initialize
    the `index` to be `0`, and `maximum_token` to be `8`. Only `8` tokens are available
    in this smart contract, meaning that only `8` vote attempts can be attempted.
    The `manager` variable is initialized to the one that launched the smart contract:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，在设置`proposals`变量之后，我们将`index`初始化为`0`，`maximum_token`初始化为`8`。在这个智能合约中只有`8`个代币可用，这意味着只能尝试`8`次投票。`manager`变量初始化为启动智能合约的变量：
- en: '[PRE78]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In this function, the owner can assign the token to any account. To indicate
    the owner of the token, we set the `true` value to the `token` variable, with
    its key points to `target`. The `index` is increasing by one, so later, we cannot
    create more than the `maximum_token` variable:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，所有者可以将代币分配给任何账户。为了指示代币的所有者，我们将`true`值设置给`token`变量，并将其键指向`target`。`index`增加了一，所以以后我们不能创建超过`maximum_token`变量的代币：
- en: '[PRE79]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In this `vote` function, we burn the token by setting the `token` mapping variable
    with the voter''s address key to `false`. But first, we must ensure that the voter
    is the valid owner of the token using this statement: `assert self.token[msg.sender]`.
    We must also ensure that people can vote after all tokens have been assigned.
    Of course, just like the previous voting application, we increase the vote count
    of the proposal that the voter votes for.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`vote`函数中，我们通过将`token`映射变量设置为投票者的地址键的`false`来销毁代币。但首先，我们必须确保投票者是代币的有效所有者，使用这个语句：`assert
    self.token[msg.sender]`。我们还必须确保在分配了所有代币之后人们可以投票。当然，就像之前的投票应用程序一样，我们增加了投票者投票的提案的计数。
- en: 'Let''s create a test for the token-based voting application. To do this, create
    a file named `test_token_based_voting.py` in the `tests` directory. Refer to the
    code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_token_based_voting.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_token_based_voting.py). Add
    the following code into the new file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为基于代币的投票应用创建一个测试。为此，在`tests`目录中创建一个名为`test_token_based_voting.py`的文件。请参考以下GitLab链接中的代码文件获取完整代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_token_based_voting.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_token_based_voting.py)。将以下代码添加到新文件中：
- en: '[PRE80]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let''s discuss this script line by line. We start from the `fixture` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行讨论这个脚本。我们从`fixture`函数开始：
- en: '[PRE81]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As usual, we create a `fixture` of this smart contract by deploying the smart
    contract manually:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们通过手动部署智能合约来创建这个智能合约的`fixture`：
- en: '[PRE82]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is a `helper` function for assigning `8` tokens to different accounts:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个为不同账户分配`8`个代币的`helper`函数：
- en: '[PRE83]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This `test` function is designed to check that the `assign_token` function
    can assign a token to the target''s address:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`test`函数旨在检查`assign_token`函数是否可以将代币分配给目标地址：
- en: '[PRE84]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This `test` function is designed to ensure that only the owner of the token
    can vote in this smart contract:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`test`函数旨在确保只有代币的所有者可以在这个智能合约中投票：
- en: '[PRE85]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This `test` function is intended to ensure that the owner of the token can vote
    for the proposal successfully.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`test`函数旨在确保代币的所有者可以成功为提案投票。
- en: 'Let me explain why this token-based voting is quite amazing. There are only
    `8` tokens that are available, and these can be used to vote in this smart contract.
    The programmer who wrote and deployed this smart contract cannot even change the
    rule after this smart contract goes live. The voter can verify that the rule is
    fair by demanding the source code of the smart contract from the programmer, and
    verifying that the bytecode from the compilation is indeed the same as the bytecode
    in the smart contract''s address. To get the bytecode from the smart contract''s
    address, you could do something like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下为什么基于代币的投票非常了不起。只有`8`个可用的代币，这些代币可以用来在这个智能合约中投票。编写和部署这个智能合约的程序员甚至在这个智能合约上线后也无法改变规则。选民可以通过要求从程序员那里获取智能合约的源代码，并验证编译的字节码是否与智能合约地址中的字节码相同来验证规则是否公平。要从智能合约地址获取字节码，你可以这样做：
- en: '[PRE86]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Then, you compile the smart contract's source code from the author and compare
    them. Are they the same? If they are, then you can audit the smart contract to
    make sure there is no cheating. If not, then you can complain to the author or
    decide not to participate in their smart contract.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你编译作者的智能合约源代码并进行比较。它们一样吗？如果是，那么你可以审计智能合约，确保没有作弊。如果不是，那么你可以向作者投诉或决定不参与他们的智能合约。
- en: Achieving this transparency in traditional web applications is no small feat.
    Verifying code in GitHub/GitLab does not mean much, because the developer could
    deploy different code in their server. You could be granted a guest session on
    their server to verify the transparency of the code but, again, the developer
    could deploy a sophisticated way to trick you. You could monitor the web application
    from the frontend every second and deploy a surveillance strategy either manually,
    or with the help of MLto detect suspicious activity. For example, you suddenly
    notice that a comment has been suddenly modified, but there is no indication of
    it being edited afterward, so you can be certain that the cheating happened inside
    the application. However, accusing the developer is not easy, because it's your
    word against theirs. You could be accused of creating false evidence.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的网络应用程序中实现这种透明度并不容易。在GitHub/GitLab中验证代码并不意味着太多，因为开发者可能在他们的服务器上部署不同的代码。你可以被授予在他们服务器上的访客会话来验证代码的透明性，但是，开发者可能会部署一种复杂的方式来欺骗你。你可以每秒监视前端的网络应用程序，并部署一种监视策略，无论是手动还是借助ML来检测可疑活动。例如，你突然注意到一个评论突然被修改了，但后来没有被编辑的迹象，所以你可以肯定作弊发生在应用程序内部。然而，指责开发者并不容易，因为这是你的话对他们的话。你可能会被指控制造虚假证据。
- en: What works is a credible and competent auditor being hired to do the job. The
    auditor gains access to their web application and has sufficient permission to
    read database logs and server logs to make sure there is no cheating taking place.
    This only works if the auditor cannot be bribed and is competent enough to avoid
    being tricked by the developer. Alternatively, you could use blockchain.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的方法是雇佣一个可信赖和称职的审计员来做这项工作。审计员可以访问他们的网络应用程序，并有足够的权限读取数据库日志和服务器日志，以确保没有作弊发生。这只有在审计员无法被贿赂并且足够称职以避免被开发者欺骗的情况下才能实现。或者，你可以使用区块链。
- en: Voting is a vast subject. We haven't implemented the delegation feature in this
    voting application. What I mean by delegation is similar to democracy in many
    countries. In some democratic countries, people don't choose their prime minister
    or president directly. They choose the members of the House of Representatives.
    After these are elected, the members will choose the prime minister. You can create
    a voting smart contract that implements a delegation system. Refer to the *Further
    reading* section if you want to study this further.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 投票是一个广泛的主题。我们在这个投票应用程序中还没有实现委托功能。我所说的委托类似于许多国家的民主制度。在一些民主国家，人们不直接选择他们的总理或总统。他们选择众议院的成员。在这些成员当选后，他们将选择总理。你可以创建一个实现委托系统的投票智能合约。如果你想进一步研究这个问题，请参考*进一步阅读*部分。
- en: On a final note, our voting smart contract is pretty transparent. This can be
    good or bad depending on the situation. Transparency is good, especially in financial
    transactions, because you can audit logs to find money laundering cases. However,
    when it comes to voting, especially in politics, secrecy is a desirable property.
    If voters don't have secrecy, they may fear being persecuted by others. Secrecy
    in voting on a smart contract is still at the research stage.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的投票智能合约非常透明。这可能是好事，也可能是坏事，这取决于情况。透明度是好的，特别是在金融交易中，因为你可以审计日志以发现洗钱案件。然而，当涉及到投票，特别是在政治方面，保密性是一个可取的特性。如果选民没有保密性，他们可能会害怕被其他人迫害。智能合约中的投票保密性仍处于研究阶段。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to create a real-world application where
    blockchain technology can shine. This real-world application is a voting application.
    From a simple voting smart contract where every account can vote, we gradually
    created a voting application in which only certain accounts can vote using a token
    system. When building this voting smart contract, we also learned about how to
    write a script to deploy a smart contract with constructors. After deploying a
    smart contract, we also learned a feature from smart contracts, which is an event.
    In a `web3` script, we subscribe to this event to learn about things that interest
    us. Finally, we created helper scripts to create many accounts and send money
    to other accounts for development purposes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学会了如何创建一个区块链技术可以发挥作用的真实应用程序。这个真实应用程序是一个投票应用程序。从每个账户都可以投票的简单投票智能合约开始，我们逐渐创建了一个只有特定账户可以使用代币系统投票的投票应用程序。在构建这个投票智能合约时，我们还学习了如何编写一个脚本来部署带有构造函数的智能合约。在部署智能合约后，我们还学习了智能合约的一个特性，即事件。在`web3`脚本中，我们订阅这个事件来了解我们感兴趣的事情。最后，我们创建了辅助脚本来创建许多账户，并向其他账户发送资金以进行开发目的。
- en: In the next chapter, you are going to create a frontend for your `web3` script.
    You are going to build a proper decentralized application in the form of a desktop
    application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将为您的`web3`脚本创建一个前端。您将构建一个适当的去中心化应用程序，以桌面应用程序的形式。
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多阅读
- en: '[https://www.ethereum.org/dao](https://www.ethereum.org/dao)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.ethereum.org/dao](https://www.ethereum.org/dao)'
