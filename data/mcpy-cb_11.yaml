- en: Interacting with the Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件系统交互
- en: In this chapter, we will cover a number of recipes, all relating to interacting
    with the filesystem. The first recipe will touch on how to remount the filesystem
    on devices that require this before you can modify any files using your Python
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖许多与文件系统交互相关的教程。第一个教程将涉及如何在使用Python代码修改任何文件之前，对需要这样做的设备重新挂载文件系统。
- en: Then, recipes on listing, removing, and creating files will be covered. Also,
    more advanced topics, such as calculating disk usage, will be covered. The recipes
    in this chapter will give you the tools you need to add filesystem interaction
    to your embedded projects. This can come in handy when you want to log sensor
    data to a file, or when you want your code to read and load a set of files into
    a data structure. It can also be helpful when you have to list a set of images
    to be displayed in your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将涵盖列出、删除和创建文件的教程。还将涵盖更高级的主题，如计算磁盘使用量。本章的教程将为你提供将文件系统交互添加到嵌入式项目中所需的工具。当你想要将传感器数据记录到文件中，或者当你希望你的代码读取并加载一组文件到数据结构中时，这将非常有用。当你必须列出一组要在你的应用程序中显示的图像时，这也会很有帮助。
- en: 'In this chapter, we will be covering the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下教程：
- en: Remounting the filesystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新挂载文件系统
- en: Listing files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出文件
- en: Removing files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件
- en: Creating a directory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个目录
- en: Reading a file's contents
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件的内容
- en: Writing a file's contents
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入文件的内容
- en: Calculating disk usage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算磁盘使用量
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found in the `Chapter11` folder in this
    book's GitHub repository, available at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在本书的GitHub存储库的`Chapter11`文件夹中找到，网址为[https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook)。
- en: CircuitPython 3.1.2 was used for all the recipes in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有教程都使用了CircuitPython 3.1.2。
- en: Remounting the filesystem
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新挂载文件系统
- en: This recipe will show you how to remount the filesystem so that it can have
    data written to it from your Python scripts. Some boards, such as Circuit Playground
    Express, will expose the connected device as a USB drive by default to make it
    easy to edit and save your code. The trade-off of this approach, however, is that
    your Python code cannot write or change any of the contents on the board's storage. On
    these boards, you must remount the filesystem to allow your script to write data
    to its filesystem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将向你展示如何重新挂载文件系统，以便可以从你的Python脚本中写入数据。一些开发板，比如Circuit Playground Express，默认情况下会将连接的设备显示为USB驱动器，以便轻松编辑和保存你的代码。然而，这种方法的折衷是，你的Python代码无法写入或更改开发板存储中的任何内容。在这些开发板上，你必须重新挂载文件系统，以允许你的脚本向其文件系统写入数据。
- en: By the end of this recipe, you'll know how to allow data to be written to the
    filesystem, and how to revert changes, which will become essential for certain
    projects. If, for example, you wanted to use Circuit Playground Express to record
    temperature readings to a log file, you would need to utilize this type of approach.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个教程的最后，你将知道如何允许数据写入文件系统，以及如何恢复更改，这对于某些项目将变得至关重要。例如，如果你想要使用Circuit Playground
    Express来记录温度读数到日志文件，你将需要利用这种方法。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要访问Circuit Playground Express上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to remount the filesystem:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何重新挂载文件系统：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Python code was able to open a file for reading. However, if you try and
    open a file to write, as shown in the following code block, you will get an `OSError` instance
    because the filesystem is in read-only mode:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python代码可以打开一个文件进行读取。但是，如果你尝试打开一个文件进行写入，就像下面的代码块中所示，你将会得到一个`OSError`实例，因为文件系统处于只读模式：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will now create a script that will remount the filesystem to allow the reading
    and writing of data.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个脚本，用于重新挂载文件系统以允许读写数据。
- en: 'The following code should be saved into the `boot.py` file. If the file doesn''t
    exist, then you will have to create it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该保存到`boot.py`文件中。如果文件不存在，那么你将需要创建它：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Eject the `CIRCUITPY` drive from your computer.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从计算机上弹出`CIRCUITPY`驱动器。
- en: Unplug the board from your computer.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从计算机上拔下开发板。
- en: Reconnect the board to your computer.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新连接开发板到计算机。
- en: 'Run the following lines of code in the REPL to confirm that your code can write
    data to a file on the board''s storage:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行，确认你的代码可以将数据写入到开发板的存储中：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following block of code, when run in the REPL, will remove the `boot.py`
    file:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在REPL中运行以下代码块时，将删除`boot.py`文件：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To apply these changes to the boot process, eject the `CIRCUITPY` drive from
    your computer again.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将这些更改应用到启动过程中，再次从计算机中弹出`CIRCUITPY`驱动器。
- en: Unplug the board from your computer.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从计算机上拔下开发板。
- en: Reconnect the board to your computer.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新连接开发板到计算机。
- en: You should be able to edit and save the contents of the `main.py` file, just
    like you did previously.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能够编辑并保存`main.py`文件的内容，就像之前做的那样。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Circuit Playground Express provides you with a way to enable reading and writing
    to the storage from your Python scripts. We put the code in the `boot.py` file
    as this script will be run early on in the boot process, before the `main.py` file
    (which will include our main code base).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Circuit Playground Express为你提供了一种从Python脚本中启用对存储的读写的方法。我们将代码放在`boot.py`文件中，因为这个脚本将在启动过程的早期运行，在`main.py`文件（其中包含我们的主要代码库）之前运行。
- en: In the `boot.py` script, we import the `storage` module and then calls its `remount`
    function with the second argument set as `False`, indicating that the filesystem
    should be mounted in read and write mode. Whenever we make changes to the `boot.py`
    file, whether it is creating or removing the file, we must do a hard reset on
    the board by unplugging and reconnecting the board for the changes to take effect.
    As shown in this recipe, the simplest way to revert this change is to delete the
    `boot.py` file from the REPL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`boot.py`脚本中，我们导入`storage`模块，然后调用它的`remount`函数，第二个参数设置为`False`，表示文件系统应该以读写模式挂载。无论是创建还是删除文件，每当我们对`boot.py`文件进行更改，都必须对板子进行硬重置，即拔下并重新连接板子，更改才能生效。如本教程所示，恢复此更改的最简单方法是从REPL中删除`boot.py`文件。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Generally speaking, only boards that offer the USB-drive editing feature will
    require this extra step of remounting the filesystem. For example, the ESP8266
    does not have the USB drive feature, and so it doesn't require this step. It's
    also important to note that once you enable writing to the filesystem from your
    code, you won't be able to edit your `main.py` file in your text editor. Whenever
    you want to go back to editing your code, you will have to remove the `boot.py`
    file. If your project only needs read-only access to the filesystem, to do things
    such as listing files and reading a file's contents, then you can run it safely
    in either mode.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，只有提供USB驱动器编辑功能的板子才需要这个额外的重新挂载文件系统的步骤。例如，ESP8266没有USB驱动器功能，因此不需要这一步。还需要注意的是，一旦你在代码中启用了对文件系统的写入，你就无法在文本编辑器中编辑`main.py`文件。每当你想要回到编辑代码时，你都需要删除`boot.py`文件。如果你的项目只需要对文件系统进行只读访问，比如列出文件和读取文件内容，那么你可以在任何模式下安全运行。
- en: See also
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个教程的一些参考资料：
- en: Documentation on the `mount` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/storage/__init__.html#storage.mount](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/storage/__init__.html#storage.mount).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`mount`函数的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/storage/__init__.html#storage.mount](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/storage/__init__.html#storage.mount)找到。
- en: Documentation on writing to the filesystem can be found at [https://learn.adafruit.com/cpu-temperature-logging-with-circuit-python/writing-to-the-filesystem](https://learn.adafruit.com/cpu-temperature-logging-with-circuit-python/writing-to-the-filesystem).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关写入文件系统的文档可以在[https://learn.adafruit.com/cpu-temperature-logging-with-circuit-python/writing-to-the-filesystem](https://learn.adafruit.com/cpu-temperature-logging-with-circuit-python/writing-to-the-filesystem)找到。
- en: Listing files
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出文件
- en: This recipe will show you how you can list files and directories in MicroPython.
    We will also show the techniques that you can use to filter a listing so that
    it only includes files or only includes directories. Once you have the ability
    to interact with the filesystem in this way, you can use it in your own projects,
    where your code will accept a dynamic list of files on the board that doesn't
    need to be hardcoded in your program. In this way, the files might represent a
    set of configurable audio files that you want to play, or a collection of images
    that you will display on an attached screen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将向你展示如何在MicroPython中列出文件和目录。我们还将展示你可以使用的技术，以便对列表进行过滤，使其只包括文件或只包括目录。一旦你有了以这种方式与文件系统交互的能力，你就可以在自己的项目中使用它，你的代码将接受一个动态的文件列表，这个列表不需要在程序中硬编码。这样，这些文件可能代表一组可配置的音频文件，你想要播放，或者一组图像，你将在连接的屏幕上显示。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要访问Circuit Playground Express上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to list files:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何列出文件：
- en: 'Execute the following block of code in the REPL:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行以下代码块：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A listing of all the files and directories in the top-level folder will have
    been generated. The following block of code will generate the same listing, but
    a sorted one:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成顶级文件夹中所有文件和目录的列表。下面的代码块将生成相同的列表，但是是排序后的。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also list files in a specific directory, as shown in the following block
    of code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以列出特定目录中的文件，如下面的代码块所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following block of code will check and show that the `lib` path is not
    a file:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码块将检查并显示`lib`路径不是一个文件：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will now confirm that `main.py` is detected as a file:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将确认`main.py`被检测为一个文件：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following block of code defines and calls the `isfile` function on two
    paths to verify their type:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码块定义并调用`isfile`函数来验证两个路径的类型：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following block of code will list all the files in the root path:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码块将列出根路径中的所有文件：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we will list all the directories in the root path:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将列出根路径中的所有目录：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When executed, this script will print out the sorted listing of files and directories
    in the root path.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，此脚本将打印出根路径中文件和目录的排序列表。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After importing the `os` module, a function called `isfile` is defined that
    will return `True` or `False`, depending on whether the provided path is a file
    or a directory. The `main` function is defined and called, after which it will
    generate a list of path names. The first list will retrieve the sorted list of
    paths and then filter the list so that only files are retained. This list is then
    printed. The same approach is then taken to get a list of directories and print
    them out.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`os`模块后，定义了一个名为`isfile`的函数，它将根据提供的路径是文件还是目录返回`True`或`False`。定义并调用了`main`函数，之后它将生成一个路径名列表。第一个列表将检索排序后的路径列表，然后过滤列表，只保留文件。然后打印出这个列表。然后采取同样的方法来获取目录列表并打印出来。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe has introduced a number of techniques that can come in handy when
    dealing with files. It showed that file listings are not returned in alphabetical
    order by default, so if this is needed, the built-in `sorted` function can be
    used to sort the list of files. It also defines a function called `isfile` to
    inspect whether a specific path is a file. You could create an equivalent `isdir`
    function if so desired. This recipe also showed a simple approach of using list
    comprehensions to filter out the default listing to generate filtered lists of
    paths that contain only certain types of entries, such as files or directories.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍了处理文件时可以派上用场的一些技术。它表明，默认情况下，文件列表不会按字母顺序返回，因此如果需要，可以使用内置的`sorted`函数对文件列表进行排序。它还定义了一个名为`isfile`的函数，用于检查特定路径是否为文件。如果需要，您可以创建一个等效的`isdir`函数。本文还展示了使用列表推导的简单方法，以过滤默认列表以生成仅包含特定类型条目的路径的过滤列表，例如文件或目录。
- en: See also
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本文的一些参考资料：
- en: Documentation on the `listdir` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.listdir](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.listdir).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`listdir`函数的文档可在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.listdir](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.listdir)找到。
- en: Documentation on the `stat` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.stat](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.stat).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`stat`函数的文档可在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.stat](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.stat)找到。
- en: Documentation on the `isfile` function can be found at [https://docs.python.org/3/library/os.path.html#os.path.isfile](https://docs.python.org/3/library/os.path.html#os.path.isfile).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`isfile`函数的文档可在[https://docs.python.org/3/library/os.path.html#os.path.isfile](https://docs.python.org/3/library/os.path.html#os.path.isfile)找到。
- en: Removing files
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文件
- en: This recipe will show you how you can remove files and directories in MicroPython.
    There are separate functions for deleting a file and deleting a directory. We
    will show you how to call these different functions for each type of path. Then,
    we will show you how you can create a generic function that can automatically
    remove either type of path.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本文将向您展示如何在MicroPython中删除文件和目录。有专门的函数用于删除文件和删除目录。我们将向您展示如何为每种类型的路径调用这些不同的函数。然后，我们将向您展示如何创建一个通用函数，可以自动删除任一类型的路径。
- en: There are many situations in the projects that you create where you need to
    resort to deleting files. You might create a project that logs data to a file.
    Log rotation is a mechanism that lets you create new log files periodically and
    remove old ones automatically. You will need functions that delete files in order
    to implement log rotation. The issue of removing files to conserve space becomes
    even more important in many MicroPython-embedded projects because you are often
    dealing with limited storage capacity on these boards.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在您创建的项目中，有许多情况需要删除文件。您可能创建一个将数据记录到文件中的项目。日志轮换是一种机制，可以让您定期创建新的日志文件并自动删除旧文件。您将需要删除文件的功能来实现日志轮换。在许多MicroPython嵌入式项目中，由于这些板上的存储容量有限，删除文件以节省空间的问题变得更加重要。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe. Make sure that you've completed the *Remounting the
    filesystem* recipe of this chapter, as you'll need write access to the storage
    system in order to remove files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL来运行本文中提供的代码。确保您已经完成了本章的*重新挂载文件系统*配方，因为您需要对存储系统具有写访问权限才能删除文件。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to remove files:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何删除文件：
- en: Create a file called `hi.txt` in the root path.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根路径下创建一个名为`hi.txt`的文件。
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `hi.txt` file has now been deleted from the board''s filesystem. Run the
    following block of code. It should go through an exception because the file does
    not exist anymore:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hi.txt`文件现在已从板的文件系统中删除。运行以下代码块。它应该会出现异常，因为文件不再存在：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a directory called `mydir` in the root path.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根路径下创建一个名为`mydir`的目录。
- en: 'The following block of code will delete the `mydir` directory:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将删除`mydir`目录：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following block of code defines the `isfile` function:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块定义了`isfile`函数：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now define a function called `any_remove` that will remove any type
    of path:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义一个名为`any_remove`的函数，它将删除任何类型的路径：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a file called `hi.txt` and a directory called `mydir`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根路径下创建一个名为`hi.txt`和一个名为`mydir`的目录。
- en: 'Run the following block of code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码块：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding block of code has now deleted this file and directory using the
    same function call.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块现在使用相同的函数调用删除了此文件和目录。
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `any_remove` function that is defined first takes the path and sets a variable
    called `func`. This variable will store the callable that needs to be called to
    delete the provided path. The type of the path is checked and `func` is set as
    either `os.remove` or `os.rmdir`, depending on the type of path that's provided.
    This function is then called with the provided path to perform the actual deletion.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义的`any_remove`函数接受路径并设置一个名为`func`的变量。此变量将存储需要调用以删除提供的路径的可调用对象。检查路径的类型，并根据提供的路径类型设置`func`为`os.remove`或`os.rmdir`。然后使用提供的路径调用此函数以执行实际的删除。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息...
- en: This recipe has introduced a technique that you can use to create a convenience
    function that accepts any type of path and will call the correct underlying function
    to remove it. One thing to keep in mind is that you can only delete a directory
    that is empty. The functions and examples in this recipe support deleting directories
    that are empty, but will fail if called with a directory that has files inside
    it. You could extend the `delete` function to do recursive directory listings
    and then delete all the subfolders and directories.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程介绍了一种您可以使用的技术，用于创建一个方便的函数，该函数接受任何类型的路径，并调用正确的底层函数来删除它。需要记住的一件事是，您只能删除空目录。本教程中的函数和示例支持删除空目录，但如果使用具有文件的目录调用，则会失败。您可以扩展`delete`函数以执行递归目录列表，然后删除所有子文件夹和目录。
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于本教程的一些参考资料：
- en: Documentation on the `remove` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.remove](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.remove).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`remove`函数的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.remove](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.remove)找到。
- en: Documentation on the `rmdir` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.rmdir](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.rmdir).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`rmdir`函数的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.rmdir](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.rmdir)找到。
- en: Creating a directory
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目录
- en: This recipe will show you how to create a directory in MicroPython. We will
    also show you how to create a function that can be called multiple times with
    the same path and will only create a directory if the directory doesn't exist
    yet. Then, we will define a function to behave just like the `makedirs` function,
    which is a part of the Python standard library but is not included in MicroPython.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将向您展示如何在MicroPython中创建一个目录。我们还将向您展示如何创建一个可以多次调用相同路径的函数，只有在目录尚不存在时才会创建目录。然后，我们将定义一个函数，其行为与Python标准库中的`makedirs`函数相同，但在MicroPython中没有包含。
- en: These set of features can be useful whenever you need to create a project that
    might necessitate the creation a specific directory tree and then populate it
    with a certain set of files. It also helps to have access to these functions when
    you are working on a board such as the ESP8266, which will only let you create
    the directories you need through the REPL and your Python code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这组功能在您需要创建一个可能需要创建特定目录树并用一组特定文件填充的项目时非常有用。当您在像ESP8266这样的开发板上工作时，也有必要访问这些功能，因为它只能让您通过REPL和Python代码创建所需的目录。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe. Make sure that you've completed the *Remounting the
    filesystem* recipe in this chapter since write access to the storage system is
    needed for this recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本教程中提供的代码。确保您已经完成了本章中的*重新挂载文件系统*教程，因为本教程需要对存储系统进行写访问。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to learn how to create a directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何创建目录：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A directory called `mydir` has now been created. When you run the following
    block of code, an exception will be raised because the directory already exists:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经创建了一个名为`mydir`的目录。当您运行以下代码块时，将引发异常，因为该目录已经存在：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following block of code will define a function that returns `True` or `False`,
    depending on whether a path exists or not:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将定义一个根据路径是否存在返回`True`或`False`的函数：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following block of code will call the `exists` function on two different
    paths to verify it is working correctly:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将在两个不同的路径上调用`exists`函数，以验证其是否正常工作：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now define a function called `mkdir_safe`, which will only make directories
    when they don''t exist:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义一个名为`mkdir_safe`的函数，它只在目录不存在时才创建目录：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following block of code will call the `mkdir_safe` function multiple times
    on the same path, with no exceptions being thrown:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将在相同路径上多次调用`mkdir_safe`函数，不会引发异常：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will now define a function that will recursively create directories:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将定义一个可以递归创建目录的函数：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the following block of code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码块：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding block of code, when executed, will create three directories in
    the correct order, from top to bottom.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码块将按正确顺序从上到下创建三个目录。
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, three different functions were defined and used, each one performing
    a specific function. The `exists` function checks whether a path exists and returns
    `True` or `False`. This check attempted to call the `stat` function on a path
    and catches any `OSError` that might be raised. If the path exists, this exception
    won't be raised and a `True` value is returned; otherwise, a `False` value is
    returned.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，定义并使用了三个不同的函数，每个函数执行特定的功能。`exists`函数检查路径是否存在，并返回`True`或`False`。此检查尝试在路径上调用`stat`函数，并捕获可能引发的任何`OSError`。如果路径存在，则不会引发此异常，并返回`True`值；否则返回`False`值。
- en: The next function, `mkdir_safe`, simply checks if a path exists and only calls
    the `mkdir` function on paths that don't exist. Finally, the `makedirs` function
    is defined, which receives a path with multiple levels. The path is split into
    its separate pieces, and then the list of paths to be created is saved in a list
    in the correct order, from the highest path to the lowest path. Each path is looped
    through and created by calling the `mkdir` function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数`mkdir_safe`只是检查路径是否存在，并且仅在不存在路径时调用`mkdir`函数。最后，定义了`makedirs`函数，该函数接收具有多个级别的路径。路径被拆分为其各个部分，然后将要创建的路径列表按正确顺序保存在列表中，从最高路径到最低路径。通过循环遍历每个路径，并通过调用`mkdir`函数来创建每个路径。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe introduced three generic functions, each of which serve a specific
    purpose. By creating pieces of code in this fashion, it makes it easier to take
    pieces of one project and incorporate them into others. Two of the defined functions—`exists`
    and `makedirs`—are a part of the Python standard library, but are not found in
    MicroPython. This recipe demonstrates that, in many cases, even when there is
    some function in the Python standard library that you miss, you can frequently
    create your own implementation in MicroPython.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程介绍了三个通用函数，每个函数都有特定的目的。通过以这种方式创建代码片段，可以更容易地将一个项目的片段并入其他项目中。其中两个定义的函数——`exists`和`makedirs`——是Python标准库的一部分，但在MicroPython中找不到。这个教程演示了在许多情况下，即使在Python标准库中缺少某个函数，您也经常可以在MicroPython中创建自己的实现。
- en: See also
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个教程的一些参考资料：
- en: Documentation on the `mkdir` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.mkdir](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.mkdir).
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir`函数的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.mkdir](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.mkdir)找到。'
- en: Documentation on the `makedirs` function can be found at [https://docs.python.org/3/library/os.html#os.makedirs](https://docs.python.org/3/library/os.html#os.makedirs).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makedirs`函数的文档可以在[https://docs.python.org/3/library/os.html#os.makedirs](https://docs.python.org/3/library/os.html#os.makedirs)找到。'
- en: Documentation on the `exists` function can be found at [https://docs.python.org/3/library/os.path.html#os.path.exists](https://docs.python.org/3/library/os.path.html#os.path.exists).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists`函数的文档可以在[https://docs.python.org/3/library/os.path.html#os.path.exists](https://docs.python.org/3/library/os.path.html#os.path.exists)找到。'
- en: Reading a file's contents
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文件的内容
- en: This recipe will show you how to read the contents of a file into variables
    in your scripts. This recipe will cover ways of reading in file contents as a
    string, as well as reading it in as a byte object. Many projects that you create
    will often need to open different data files, such as audio files, images, and
    text files. This recipe will provide you with the basic building blocks so that
    you can facilitate these interactions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将向您展示如何将文件内容读入脚本中的变量。这个教程将涵盖将文件内容作为字符串读取的方法，以及将其作为字节对象读取的方法。您创建的许多项目通常需要打开不同的数据文件，如音频文件、图像和文本文件。这个教程将为您提供基本的构建模块，以便您可以促进这些交互。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to read a file''s contents:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何读取文件的内容：
- en: 'Create a file called `hi.txt` in the root path with the following contents:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根路径下创建一个名为`hi.txt`的文件，其中包含以下内容：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Execute the following block of code in the REPL:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行以下代码块：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The contents of the file called `hi.txt` are read into a variable called `data`,
    which is then displayed as output. The following block of code also reads the
    file''s contents into a variable, but uses the `with` statement:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名为`hi.txt`的文件的内容被读入一个名为`data`的变量中，然后作为输出显示。下面的代码块也将文件的内容读入一个变量中，但使用`with`语句：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It is possible to read the file''s contents into a variable with a single line
    of code, as shown in the following example:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过一行代码将文件的内容读入一个变量中，如下例所示：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Execute the following block of code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下代码块：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding block of code, when executed, will read the file's contents as
    a `bytes` object instead of a string.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块在执行时，将以`bytes`对象而不是字符串读取文件内容。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have explored four different ways of reading data from a
    file. The first method uses the `open` function to get a file object. Then, data
    is read from this file object and closed. We can then improve upon this older
    style of file handling, as shown in the second example, by using the `with` statement,
    which will automatically close the file once we exit the `with` block. The third
    example opens and reads the contents all in one line. The `open` function accepts
    the file mode since it's the second argument. If we pass it the `rb` value, then
    it will open the file for reading in binary mode. This will then result in a bytes
    object being returned, instead of a string.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们探讨了从文件中读取数据的四种不同方法。第一种方法使用`open`函数获取文件对象。然后，从这个文件对象中读取数据并关闭。然后，我们可以改进这种较旧的文件处理方式，如第二个例子所示，使用`with`语句，它将在退出`with`块时自动关闭文件。第三个例子在一行中打开并读取所有内容。`open`函数接受文件模式作为第二个参数。如果我们传递`rb`值，那么它将以二进制模式打开文件。这将导致返回一个字节对象，而不是一个字符串。
- en: There's more...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You will need to choose the correct method of reading file data, depending on
    the data you expect to interact with. If your data files are plain text files,
    then the default text mode will suffice. However, if you're reading raw audio
    data in the `.wav` file format, which you will need to do to read in the data
    as binary data, exceptions may occur because the data might not be able to be
    decoded into strings.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要根据您希望与之交互的数据选择正确的读取文件数据的方法。如果您的数据文件是纯文本文件，那么默认的文本模式就足够了。但是，如果您要读取`.wav`文件格式的原始音频数据，您需要将数据读取为二进制数据，可能会出现异常，因为数据可能无法解码为字符串。
- en: See also
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个教程的一些参考资料：
- en: Documentation on the `open` function can be found at [https://docs.python.org/3/library/functions.html#open](https://docs.python.org/3/library/functions.html#open).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`函数的文档可以在[https://docs.python.org/3/library/functions.html#open](https://docs.python.org/3/library/functions.html#open)找到。'
- en: Documentation on the `with` statement can be found at [https://docs.python.org/3/reference/compound_stmts.html#with](https://docs.python.org/3/reference/compound_stmts.html#with).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`with`语句的文档可以在[https://docs.python.org/3/reference/compound_stmts.html#with](https://docs.python.org/3/reference/compound_stmts.html#with)找到。
- en: Writing a file's contents
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件的内容
- en: This recipe will show you how to write data to an output file. We will cover
    how to write strings, as well as bytes, to a file. We will then define a type
    of object to make it easier to perform these common operations of writing text
    and binary data to files. If you want to create a project that saves sensor data
    to a log file or records some user-generated data to the board's storage, then
    you will need to use many of the techniques we'll describe in this recipe.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向您展示如何将数据写入输出文件。我们将介绍如何将字符串以及字节写入文件。然后，我们将定义一种对象类型，以便更容易执行这些常见的操作，将文本和二进制数据写入文件。如果您想创建一个将传感器数据保存到日志文件或将一些用户生成的数据记录到板的存储器中的项目，那么您将需要使用我们在这个配方中描述的许多技术。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe. Make sure that you've completed the *Remounting the
    filesystem* recipe in this chapter as this recipe needs write access to the storage
    system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Circuit Playground Express上访问REPL以运行本配方中提供的代码。确保您已经完成了本章中的*重新挂载文件系统*配方，因为这个配方需要对存储系统进行写访问。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to write a file''s contents:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何写入文件的内容：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The text reading `hi there` has been written to a file called `hi.txt` using
    the file object''s `write` method. The number of bytes written is then returned
    and displayed. The following block of code will take a bytes object and give it
    to the `write` method so that it can write the data to the provided file:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本读取`hi there`已经使用文件对象的`write`方法写入到名为`hi.txt`的文件中。然后返回并显示写入的字节数。以下代码块将获取一个字节对象并将其传递给`write`方法，以便它可以将数据写入提供的文件中：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following block of code will define a `Path` class with two methods. One
    method will initialize new objects, while the other will generate a representation
    of the object:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将定义一个`Path`类，其中包含两个方法。一个方法将初始化新对象，而另一个方法将生成对象的表示：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After executing the following block, we will have a `Path` class with two additional
    methods so that we can write text and binary data to a file:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下代码块后，我们将得到一个`Path`类，其中包含两个额外的方法，以便我们可以将文本和二进制数据写入文件：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Save the following block of code into a file called `pathlib.py` so that it
    can be imported:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将以下代码块保存到名为`pathlib.py`的文件中，以便可以导入： '
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When this script gets executed, it will write the text `hi there` message into
    the `hi.txt` file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将把文本`hi there`消息写入到`hi.txt`文件中。
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we started off by showing the two most straightforward ways
    of writing bytes and text data to files. Then, we created a class called `Path`,
    which we build in two stages. The first version lets us create `Path` objects
    that keep track of their path and return a human-readable representation when
    requested.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们首先展示了写入字节和文本数据到文件的两种最直接的方法。然后，我们创建了一个名为`Path`的类，这个类分为两个阶段构建。第一个版本让我们创建`Path`对象，这些对象可以跟踪它们的路径，并在请求时返回一个人类可读的表示。
- en: Then, we added helper methods to assist in writing text data or binary data.
    The name of the class and its methods follow the same naming and functionality
    as the `Path` object in the Python `pathlib` module, which comes with the standard
    library. The final code block shows a simple example of importing the `pathlib`
    module and calling its `write_text` method to save some text to a file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了辅助方法来帮助写入文本数据或二进制数据。类的名称和方法与Python的`pathlib`模块中的`Path`对象具有相同的命名和功能。最终的代码块展示了一个简单的示例，导入`pathlib`模块并调用其`write_text`方法将一些文本保存到文件中。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might find yourself in a situation in some projects where you have to interact
    with files, their paths, and have to write and read data frequently. In these
    situations, it can be very helpful to be equipped with a class that simplifies
    your access to files. The `Path` object that was defined in this recipe is great
    for this purpose. We have also followed the same naming and functionality of a
    module that is part of Python's standard library. This will make our code more
    readable and portable when we want to run it on a computer that has a full Python
    installation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些项目中，您可能会发现自己处于一种情况中，需要与文件、它们的路径进行交互，并经常需要写入和读取数据。在这些情况下，拥有一个简化文件访问的类将非常有帮助。在这个配方中定义的`Path`对象非常适合这个目的。我们还遵循了Python标准库中的一个模块的相同命名和功能。这将使我们的代码在想要在具有完整Python安装的计算机上运行时更具可读性和可移植性。
- en: See also
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个配方的一些参考资料：
- en: Documentation on the `write_bytes` method can be found at [https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes](https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`write_bytes`方法的文档可以在[https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes](https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes)找到。
- en: Documentation on the `write_text` method can be found at [https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text](https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`write_text`方法的文档可以在[https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text](https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text)找到。
- en: Calculating disk usage
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算磁盘使用量
- en: This recipe will show you how to check a number of figures related to the storage
    system. We will retrieve the filesystem's block size, the total number of blocks,
    and the number of free blocks. We can then use these figures to calculate a number
    of useful figures, such as the total disk capacity and how much space is used
    and free on the disk.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向您展示如何检查与存储系统相关的一些数字。我们将检索文件系统的块大小、总块数和空闲块数。然后我们可以使用这些数字来计算一些有用的数字，比如总磁盘容量以及磁盘上已使用和空闲的空间。
- en: We'll then package all this code into a function to make it easier to call whenever
    we need access to this information. You can use the techniques shown in this recipe
    to achieve a number of things in your projects. For example, you could use it
    to find out how much total storage is available on the device since this varies
    between different boards. You can even use it to decide if the disk is getting
    too full and whether your script should delete some old log files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将所有这些代码打包到一个函数中，以便在需要访问这些信息时更容易调用。您可以使用本配方中展示的技术来实现项目中的许多事情。例如，您可以使用它来查找设备上可用的总存储空间，因为这在不同的板之间有所不同。您甚至可以使用它来判断磁盘是否变得太满，以及您的脚本是否应该删除一些旧的日志文件。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行此配方中提供的代码。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to calculate disk usage:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何计算磁盘使用情况：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have now retrieved all the key filesystem information, but it is presented
    as a tuple, which makes it difficult to know which figure relates to what. In
    the following block of code, we will assign the values we care about to more human-readable
    variable names:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经检索到了所有关键的文件系统信息，但它以元组的形式呈现，这使得很难知道哪个数字与什么相关。在以下代码块中，我们将把我们关心的值赋给更易读的变量名：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have this key information in human-readable variables, we can proceed
    with the following block of code to calculate the main values we are interested
    in:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将这些关键信息存储在易读的变量中，我们可以继续以下代码块来计算我们感兴趣的主要值：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following block of code will wrap all this logic into a single function:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将所有这些逻辑封装到一个单独的函数中：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following function will format the values, represented as bytes, in a more
    human-readable fashion:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数将以更易读的方式格式化以字节表示的值：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now create a function that prints a number of key figures related to
    total disk size and usage:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个函数，打印与总磁盘大小和使用情况相关的一些关键数字：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When this script gets executed, it will print out details on the free, used,
    and total disk space.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将打印有关磁盘空间的空闲、已使用和总空间的详细信息。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `statvfs` function returns a number of key figures relating to the filesystem
    that is on the board. We care about three values in this tuple, which map to the
    `block_size`, `total_blocks`, and `free_blocks` variables. We can multiply these
    values together to calculate the amount of free, used, and total disk space in
    terms of bytes. Then, the `format_size` function is defined to convert bytes values
    into `KiB`, add a thousand separator, and right-align the values. The `print_stats`
    function simply combines all this code by getting the filesystem's `stats` and
    calling the `format_size` function on each value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`statvfs`函数返回与板上的文件系统相关的一些关键数字。在这个元组中，我们关心三个值，它们分别对应`block_size`、`total_blocks`和`free_blocks`变量。我们可以将这些值相乘，以字节为单位计算出空闲、已使用和总磁盘空间的数量。然后，`format_size`函数被定义为将字节值转换为`KiB`，添加千位分隔符，并右对齐这些值。`print_stats`函数简单地通过获取文件系统的`stats`并在每个值上调用`format_size`函数来组合所有这些代码。'
- en: There's more...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Circuit Playground Express comes with 2 MB of flash storage, which can be seen
    in the output of this recipe. MicroPython uses the FAT format for its filesystem.
    One thing that you can experiment with is adding a number of files on the board
    and then rerunning the script to see the changes in filesystem usage. Keep in
    mind that for you to see these changes reflected on a number of boards, you will
    have to eject the USB device and plug it back in to get the latest filesystem
    usage figures.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Circuit Playground Express配备了2MB的闪存，可以在此配方的输出中看到。MicroPython使用FAT格式进行文件系统。您可以尝试在板上添加一些文件，然后重新运行脚本以查看文件系统使用情况的变化。请记住，要看到这些变化反映在多个板上，您必须弹出USB设备并重新插入以获取最新的文件系统使用情况。
- en: See also
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于此配方的一些参考资料：
- en: Documentation on the `statvfs` function can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.statvfs](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.statvfs).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`statvfs`函数的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.statvfs](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/os/__init__.html#os.statvfs)找到。
- en: Details on the information returned by `statvfs` can be found at [http://man7.org/linux/man-pages/man3/statvfs.3.html](http://man7.org/linux/man-pages/man3/statvfs.3.html).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`statvfs`返回的信息的详细信息可以在[http://man7.org/linux/man-pages/man3/statvfs.3.html](http://man7.org/linux/man-pages/man3/statvfs.3.html)找到。
