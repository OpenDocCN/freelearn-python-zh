- en: Chapter 5. Multilingual Movie Database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。多语言电影数据库
- en: The Internet might be the fastest growing phenomenon the world has seen. Cheap
    Internet-enabled mobile phones have accelerated this growth even further, and
    by some estimates, 40% of the world today has access to the Internet. Any web
    applications that we develop can truly be global. However, English users make
    up only around 30% of the Internet population. If your website is in English only,
    you are missing out on a huge audience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网可能是世界上增长最快的现象。廉价的互联网手机进一步加速了这种增长，据一些估计，今天世界上有40%的人口可以接入互联网。我们开发的任何网络应用都可以真正成为全球性的。然而，英语用户只占互联网用户的大约30%。如果你的网站只有英文，你就错过了一个巨大的受众。
- en: To fix this, many efforts have been made in recent years to make websites accessible
    to non-English users as well. Django itself includes reliable methods to translate
    the content of your site into multiple languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，近年来已经做出了许多努力，使网站也能够为非英语用户提供访问。Django本身包括可靠的方法，将网站内容翻译成多种语言。
- en: However, translating the content is just the first part of the process. Language
    is not the only thing that is different between different parts of the world.
    Currency codes, time zones, and number formats are just a few examples. Adapting
    these to the location of your user is called **localization**. You will often
    see this abbreviated as **l10n**. That's the first `l` of localization, then a
    numeric `10`, followed by the last `n`. The `10` refers to the number of characters
    between the two! You may also come across the term internationalization (**i18n**).
    Internationalization is making sure that your application works across multiple
    regions without errors. For instance, making sure any inputs that you accept from
    the user can be in a variety of languages, and not just the one you developed
    the app in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，翻译内容只是过程的第一部分。语言并不是世界各地不同之间唯一的不同之处。货币代码、时区和数字格式只是一些例子。将这些适应到用户所在地的过程称为**本地化**。你经常会看到这个缩写为**l10n**。这是本地化的第一个`l`，然后是一个数字`10`，后面是最后一个`n`。`10`指的是两者之间的字符数！你可能也会遇到国际化（**i18n**）这个术语。国际化是确保你的应用在多个地区都能正常运行，不会出现错误。例如，确保你从用户那里接受的任何输入可以是多种语言，而不仅仅是你开发应用的那种语言。
- en: In this chapter, we will make an application inspired by the amazingly useful
    **IMDB** (**Internet Movie Database**) website. If you have never heard of it,
    it's a web application that provides a lot of information about movies, both old
    and new. We will be creating an application that provides some very basic features
    similar to IMDB. As our application is multilingual (which IMDB is as well by
    the way), I will refer to it as the **Multilingual Movie Database** (**MMDB**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将制作一个受到非常有用的**IMDB**（**互联网电影数据库**）网站启发的应用程序。如果你从未听说过它，它是一个提供有关电影的大量信息的网络应用程序，无论是新的还是旧的。我们将创建一个类似于IMDB的应用程序，提供一些非常基本的功能。由于我们的应用程序是多语言的（顺便说一句，IMDB也是），我将把它称为**多语言电影数据库**（**MMDB**）。
- en: The code pack for this chapter includes a working non-localized copy of the
    application. Our job is to add localization and internationalization to it so
    that it works well for our users in France.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包含了一个工作的非本地化应用程序副本。我们的工作是为法国用户添加本地化和国际化，以便其能够正常使用。
- en: Requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'Let''s take a look at what we want to achieve by the end of this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本章结束时我们想要实现的目标：
- en: Getting an overview of all the features provided by Django to allow localization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Django提供的所有功能，以允许本地化
- en: Translating the contents of the site into French
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将网站内容翻译成法语
- en: Giving users the ability to choose which language they want to use the site
    in
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给用户选择他们想要在网站中使用的语言的能力
- en: Persisting the language preference of the user across multiple visits
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多次访问中保持用户的语言偏好
- en: Translating the content of models
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译模型的内容
- en: Before we start, there is one thing I'd like to mention. As we are learning
    this stuff for the first time, we will start with an already existing Django application.
    However, our application is very small compared to most real-world projects. For
    larger applications, it is usually more difficult to add localization after finishing
    the project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，有一件事我想提一下。由于我们是第一次学习这些东西，我们将从一个已经存在的Django应用程序开始。然而，与大多数真实项目相比，我们的应用程序非常小。对于更大的应用程序，在完成项目后添加本地化通常更加困难。
- en: It is always a good idea to think about localization requirements when starting
    the project and then incorporating those features while developing the application
    for the first time, rather than doing so at a later stage when the application
    has been developed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始项目时考虑本地化需求并在首次开发应用程序时将这些功能纳入其中总是一个好主意，而不是在应用程序开发后的后期阶段这样做。
- en: Getting the project up and running
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动项目
- en: 'As always, once you have downloaded the code drop, unzip it. Then, create a
    new virtual environment for this project and install Django. Finally, activate
    it and run the migrate command from in the project root. This should set up the
    database for the project and get you to a point where you can start the application.
    Now you need to create a new super user so that you can add some test data. From
    within the project root (with the virtual environment active), run the following
    command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，一旦你下载了代码包，解压它。然后，为这个项目创建一个新的虚拟环境并安装Django。最后，激活它并在项目根目录中运行迁移命令。这应该为项目设置数据库，并让你可以启动应用程序。现在你需要创建一个新的超级用户，这样你就可以添加一些测试数据。在项目根目录中（虚拟环境处于活动状态），运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Answer the questions and you''ll have a new user. Now, run the application
    with the `runserver` command, then visit `http://127.0.0.1:8000/admin/`, and add
    a few movie detail objects to the database. Once you have added some test data,
    visit the home page for the application, and you should see something similar
    to the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 回答问题，您将获得一个新用户。现在，使用`runserver`命令运行应用程序，然后访问`http://127.0.0.1:8000/admin/`，并向数据库添加一些电影详细对象。一旦您添加了一些测试数据，访问应用程序的主页，您应该看到类似以下屏幕截图的内容：
- en: '![Getting the project up and running](img/00698_05_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![启动项目](img/00698_05_01.jpg)'
- en: 'You should take some time to explore the app. You can view details for a particular
    movie on a page, as shown in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该花一些时间来探索这个应用程序。您可以在页面上查看特定电影的详细信息，如下面的屏幕截图所示：
- en: '![Getting the project up and running](img/00698_05_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![启动项目](img/00698_05_02.jpg)'
- en: 'Finally, you can click on the **Submit New Review** link to get to the following
    page and create a new review for the movie, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以点击**提交新评论**链接，转到下一页，并为电影创建一个新的评论，如下面的屏幕截图所示：
- en: '![Getting the project up and running](img/00698_05_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![启动项目](img/00698_05_03.jpg)'
- en: That's our entire application. For the rest of the chapter, we'll be looking
    into how to add l10n and i18n to this project. We'll be making very few, if any,
    changes to the core product features.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们整个应用程序。在本章的其余部分，我们将探讨如何向这个项目添加l10n和i18n。我们对核心产品功能几乎没有或没有做任何更改。
- en: Translating our static content
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译我们的静态内容
- en: The first thing that we want to do is translate all the static content on our
    site. This includes all the headlines, links, and form labels that you have seen
    in the preceding three screens. To translate strings that are used in templates,
    Django provides us with a `trans` template tag. Let's take a look at how to use
    it first in a simple context, and then I'll go into the details of how it works.
    This is a slightly long section as we will do a lot of things here that make up
    the foundation of the translation feature of Django.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是翻译网站上的所有静态内容。这包括在前面三个屏幕中看到的所有标题、链接和表单标签。为了翻译模板中使用的字符串，Django为我们提供了一个`trans`模板标签。让我们先看看如何在简单的上下文中使用它，然后我会详细介绍它的工作原理。这是一个稍微长一点的部分，因为我们将在这里做很多构成Django翻译功能基础的事情。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't be alarmed if you don't understand something. Just keep following the
    instructions. I'll go into a lot of depth about each step, but first I want to
    show you exactly how translations are done.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解某些内容，请不要惊慌。只需按照说明进行。我将深入介绍每一步，但首先我想向您展示翻译是如何完成的。
- en: 'Open up `main/templates/movies_list.html`, and replace `Movies List` in the
    `h2` tag with the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`main/templates/movies_list.html`，并将`h2`标签中的`Movies List`替换为以下内容：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following `load` tag to the second line of the file, right after the
    `extends` tag:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的第二行后面的`extends`标签之后，添加以下`load`标签：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's all the changes that we need to make to the template for now. I'll be
    explaining what these two lines do in just a little bit, but first I want to complete
    the whole translation process so that you can look at the whole thing instead
    of just smaller parts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们现在需要对模板进行的所有更改。我将在稍后解释这两行的作用，但首先我想完成整个翻译过程，这样您就可以看到整个过程而不仅仅是一小部分。
- en: 'Next, let''s run this command from the project root:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从项目根目录运行以下命令：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you run this command, you should also see the same error as I did, something
    being unable to find a locale path. We''ll explain what the locale path is after
    we''re done with the demo. For now, create a new folder called `locale` in the
    `main` folder and run the command again:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行这个命令，您也应该看到与我一样的错误，即找不到区域设置路径。我们会在演示结束后解释区域设置路径是什么。现在，在`main`文件夹中创建一个名为`locale`的新文件夹，然后再次运行该命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This time the command succeeds. If you look in the locale folder that you created,
    you should see that a whole new hierarchy of folders has been created underneath
    it. What the `makemessages` command did was create a `django.po` at `main/locale/fr/
    LC_MESSAGES/django.po` file. If you open this file, you should be able to figure
    out a bit about its purpose. The last three lines of the file should be as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这次命令成功了。如果您查看您创建的`locale`文件夹，您会看到它下面创建了一个全新的文件夹层次结构。`makemessages`命令所做的是在`main/locale/fr/LC_MESSAGES/django.po`文件中创建了一个`django.po`文件。如果您打开这个文件，您应该能够了解一些关于它的目的。文件的最后三行应该如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Together with the path of this file (`locale/fr/LC_MESSAGES/django.po`) and
    these three lines, you should be getting the idea that this file will contain
    the translated French text for the string that we marked earlier with the `trans`
    tag. Anything you put in quotes next to `msgstr` is what will replace the original
    string in the French translation of the site.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 加上这个文件的路径(`locale/fr/LC_MESSAGES/django.po`)和这三行，您应该能够理解这个文件将包含我们之前用`trans`标签标记的字符串的法语翻译。在`msgstr`旁边放在引号中的任何内容都将替换网站的法语翻译中的原始字符串。
- en: 'I used Google Translate to translate the `Movies List` string, and it gave
    me the translation as Liste des films. Put this translation in the quotes next
    to `msgstr`. The last three lines of the `django.po` file should now match the
    following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用Google翻译来翻译`Movies List`字符串，它给了我翻译为Liste des films。将这个翻译放在`msgstr`旁边的引号中。现在，`django.po`文件的最后三行应该与以下内容匹配：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, run this command from the project root:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从项目根目录运行以下命令：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you were to look in the `LC_MESSAGES` folder now, you should see that a new
    `django.mo` file has been created. This is the compiled version of our `django.po`
    file, the one that we put the translated strings into. For performance, Django
    translations require the file to be compiled into a binary format before it can
    pick up translations for strings.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看`LC_MESSAGES`文件夹，您会看到一个新的`django.mo`文件已经被创建。这是我们的`django.po`文件的编译版本，我们将翻译的字符串放入其中。出于性能考虑，Django翻译需要将文件编译成二进制格式，然后才能获取字符串的翻译。
- en: 'Next, open up `mmdb/settings.py` and find the `MIDDLEWARE_CLASSES` list. Edit
    it so that the `django.middleware.locale.LocaleMiddleware` string appears between
    the already installed `SessionMiddleware` and `CommonMiddleware`. The position
    is important. The list should now look as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`mmdb/settings.py`并找到`MIDDLEWARE_CLASSES`列表。编辑它，使得`django.middleware.locale.LocaleMiddleware`字符串出现在已安装的`SessionMiddleware`和`CommonMiddleware`之间。位置很重要。列表现在应该如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, add a `LANGUAGES` variable to the settings file and give it the following
    value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在设置文件中添加一个`LANGUAGES`变量，并给它以下值：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By default, Django supports a much longer list of languages. For our project,
    we want to restrict the user to only these two options. That is what the `LANGUAGES`
    list does.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Django支持更多的语言列表。对于我们的项目，我们希望将用户限制在这两个选项中。这就是`LANGUAGES`列表的作用。
- en: 'The last step is to modify the `mmdb/urls.py` file. First, import `i18n_patterns`
    from `django.conf.urls.i18n`. Next, change the `urlpatterns` variable so that
    the `i18n_patterns` function wraps all our URL definitions, as shown in the following
    code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是修改`mmdb/urls.py`文件。首先，从`django.conf.urls.i18n`导入`i18n_patterns`。接下来，更改`urlpatterns`变量，以便`i18n_patterns`函数包装所有我们的URL定义，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this done, let's test and see what our hard work got us. First, open up
    `http://127.0.0.1:8000`. You should see the same home page as before, but if you
    pay attention to the address bar, you will notice that the browser is at `http://127.0.0.1:8000/en/`
    instead of what we entered. We will look at the details of why this happens next,
    but in a nutshell, we opened the home page without specifying a language and Django
    redirected us to the default language for the site, which we specified earlier
    as English.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，让我们测试一下，看看我们的辛勤工作得到了什么。首先，打开`http://127.0.0.1:8000`。您应该会看到与之前相同的主页，但是如果您注意地址栏，您会注意到浏览器位于`http://127.0.0.1:8000/en/`而不是我们输入的内容。我们将在下一步详细了解为什么会发生这种情况，但简而言之，我们打开了主页而没有指定语言，Django将我们重定向到了站点的默认语言，我们之前指定为英语。
- en: 'Change the URL to `http://127.0.0.1:8000/fr/` and you should see the same home
    page again, but this time, the `Movies List` text should be replaced by what we
    said was its French translation, as shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将URL更改为`http://127.0.0.1:8000/fr/`，您应该会再次看到相同的主页，但是这次，“Movies List”文本应该被我们说的法语翻译所替换，如下面的截图所示：
- en: '![Translating our static content](img/00698_05_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![翻译我们的静态内容](img/00698_05_04.jpg)'
- en: 'While all of this probably seems like a lot of work to translate a single sentence,
    remember that you only need to do this once. Let''s see how easy it is to translate
    something else now that the foundation is there. Let''s translate the word `Stars`
    to its French translation, `Etoiles`. Open up `main/templates/movies_list.html`
    and replace the word `Stars` with the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一切可能看起来像是为了翻译一个句子而做了很多工作，但请记住，您只需要做一次。既然基础已经建立，让我们看看现在翻译其他内容有多容易。让我们将单词`Stars`翻译成法语，`Etoiles`。打开`main/templates/movies_list.html`，并将单词`Stars`替换为以下内容：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, run the `makemessages` command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行`makemessages`命令：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open the `main/locale/fr/LC_MESSAGES/django.po` file. You should see a new
    section for the `Stars` string that we marked for translation. Add the translation
    (`Étoile`) and save the file. Finally, run the `compilemessages` command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`main/locale/fr/LC_MESSAGES/django.po`文件。您应该会看到一个新的部分，用于我们标记为翻译的`Stars`字符串。添加翻译（`Étoile`）并保存文件。最后，运行`compilemessages`命令：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open the French language home page again by visiting `http://127.0.0.1:8000/fr/`.
    You will see that the word `Stars` has been replaced by its French translation.
    The effort involved was minimal. The workflow that you just followed: marking
    one or more strings for translation, making messages, translating the new strings,
    and finally running `compilemessages` is one followed by most Django developers
    when they are translating a project. Most of the effort involved with getting
    a site translation ready is all the work that we did beforehand. Let''s take a
    closer look at what exactly we have done to get our web application translatable.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次访问`http://127.0.0.1:8000/fr/`，打开法语语言主页。您会看到单词`Stars`已被其法语翻译所替换。所需的工作量很小。您刚刚遵循的工作流程：标记一个或多个字符串进行翻译，制作消息，翻译新字符串，最后运行`compilemessages`，是大多数Django开发人员在翻译项目时遵循的工作流程。准备网站翻译所涉及的大部分工作都是我们之前所做的。让我们更仔细地看看我们到底做了什么来使我们的Web应用程序可翻译。
- en: How did all that work?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有这些是如何工作的？
- en: As I promised at the start of the previous section, after seeing Django translations
    in action, we will now take a deeper look into all the steps we followed to get
    to this point and what each of these steps did.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在上一节开始时所承诺的那样，在看到Django翻译实际操作后，我们现在将更深入地了解我们所遵循的所有步骤以及每个步骤所做的事情。
- en: The first thing that we did was load the i18n template tags library, which provides
    us with a variety of template tags to translate content in the template. The most
    important, and probably the one that you will use the most, is the `trans` tag.
    The `trans` tag accepts a string argument and, depending on the language that
    is active, outputs the correct translation for that string. If the translation
    cannot be found, the original string is output instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是加载i18n模板标签库，它为我们提供了各种模板标签来翻译模板中的内容。最重要的，也可能是您最常使用的，是`trans`标签。`trans`标签接受一个字符串参数，并根据活动的语言输出该字符串的正确翻译。如果找不到翻译，将输出原始字符串。
- en: Almost any string that you write in your templates will end up being wrapped
    by the `trans` tag and then later translated to the various languages that your
    web application is available in. There are certain situations in which the `trans`
    tag is not usable. For instance, if you have to add the value of some context
    variable to the translated string, the `trans` tag can't do this. For these cases,
    we need to use the block translation tag, `blocktrans`. We won't be needing it
    in our application, but you can read about it in the Django documentation at [https://docs.djangoproject.com/es/stable/topics/i18n/translation/#blocktrans-template-tag](https://docs.djangoproject.com/es/stable/topics/i18n/translation/#blocktrans-template-tag).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您在模板中编写的几乎任何字符串最终都将被`trans`标签包装，然后在您的Web应用程序可用的各种语言中进行翻译。有某些情况下`trans`标签无法使用。例如，如果您必须将某些上下文变量的值添加到已翻译的字符串中，则`trans`标签无法做到这一点。对于这些情况，我们需要使用块翻译标签`blocktrans`。我们的应用程序不需要它，但您可以在Django文档中了解有关它的信息[https://docs.djangoproject.com/es/stable/topics/i18n/translation/#blocktrans-template-tag](https://docs.djangoproject.com/es/stable/topics/i18n/translation/#blocktrans-template-tag)。
- en: Our next step was to run the `make messages` command. Our first attempt didn't
    succeed, so we had to create a `locale` directory in our `application` folder.
    Having done that, we ran the command and it created a message file with the `.po`
    extension. What the command does is it goes over every file in your project and
    extracts strings that you have marked for translation. One way to mark a string
    is to use the `trans` tag to wrap it. There are other ways as well that we will
    look at later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是运行`make messages`命令。我们的第一次尝试没有成功，所以我们不得不在我们的`application`文件夹中创建一个`locale`目录。做完这些后，我们运行了该命令，并创建了一个带有`.po`扩展名的消息文件。该命令的作用是遍历项目中的每个文件，并提取您标记为翻译的字符串。标记字符串的一种方法是使用`trans`标签进行包装。还有其他方法，我们稍后会看到。
- en: After the `make messages` command has extracted the strings, it needs to create
    files and store the extracted strings in these files. There is a set of rules
    that Django follows when figuring out which file each extracted string goes to.
    For strings extracted from the files of an app, Django first tries to find a `locale`
    directory in the folder for that app. If it finds the folder, it creates the appropriate
    hierarchy underneath it (the `fr/LC_MESSAGES` directories) and places the messages
    file there.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`make messages`命令提取字符串后，需要创建文件并将提取的字符串存储在这些文件中。Django在确定每个提取的字符串应放入哪个文件时遵循一组规则。对于从应用程序文件中提取的字符串，Django首先尝试在该应用程序的文件夹中找到`locale`目录。如果找到该文件夹，它将在其中创建适当的层次结构（`fr/LC_MESSAGES`目录）并将消息文件放在那里。'
- en: If the `locale` folder is not found, Django looks at the value of the `LOCALE_PATHS`
    settings variable. This should be a list of directory locations. Django selects
    the first directory from this list of paths and puts the messages file there.
    In our case, we didn't have the `LOCALE_PATHS` setup, which is why Django raised
    an error, not finding a locale directory in our main application folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到`locale`文件夹，Django将查看`LOCALE_PATHS`设置变量的值。这应该是一个目录位置列表。Django从此路径列表中选择第一个目录，并将消息文件放在那里。在我们的情况下，我们没有设置`LOCALE_PATHS`，这就是为什么Django会引发错误，找不到我们主要应用程序文件夹中的locale目录。
- en: 'Let''s talk a bit about the format of the messages file. Here is what our messages
    file looks like right now:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微谈谈消息文件的格式。这是我们当前消息文件的样子：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Lines starting with `#` are comments. Then, there is an empty pair of `msgid`
    and `msgstr`. This is followed by some metadata about this messages file. After
    that, we get the main part of the time. A messages file, ignoring the metadata
    and first pair (the one preceded by the fuzzy comment), is just a list of `msgid`
    and `msgstr` pairs. The `msgid` pairs is the string that you have marked for translation,
    and `msgstr` is the translation for that string. The usual method of translating
    an app is by first marking all the strings for translation, then generating the
    messages file, and finally providing it to the translator. The translator then
    returns the file to you with the translations filled in. The benefit of using
    a simple text file is that the translator doesn't need to use any special software.
    If he has access to a simple text editor, he can translate the messages file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以`#`开头的行是注释。然后是一对空的`msgid`和`msgstr`。然后是关于此消息文件的一些元数据。之后，我们得到了主要部分。消息文件，忽略元数据和第一对（在模糊注释之前的那一对），只是一系列`msgid`和`msgstr`对。`msgid`对是您标记为翻译的字符串，`msgstr`是该字符串的翻译。翻译应用程序的常规方法是首先标记所有字符串以进行翻译，然后生成消息文件，最后将其提供给翻译人员。然后翻译人员将带有填充翻译的文件返回给您。使用简单文本文件的好处是，翻译人员不需要使用任何特殊软件。如果他可以访问简单的文本编辑器，他就可以翻译消息文件。
- en: Once we have translated the strings in the messages file, we need to run the
    compile messages command before Django is able to use the translations. The compile
    command, as mentioned earlier, converts the text messages file to a binary file.
    The binary file format is much quicker to read from for Django, and in projects
    with hundreds or thousands of translatable strings, these performance benefits
    add up very quickly. The output of the compile messages file is a `.mo` file in
    the same folder as the `.po` file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们翻译了消息文件中的字符串，我们需要在Django能够使用这些翻译之前运行编译消息命令。如前所述，编译命令将文本消息文件转换为二进制文件。二进制文件格式对Django来说读取速度更快，在具有数百或数千个可翻译字符串的项目中，这些性能优势会非常快速地累积起来。编译消息文件的输出是一个`.mo`文件，与`.po`文件在同一个文件夹中。
- en: Once we have our translations done and compiled, we need to set up a few Django
    configurations. The first thing we do is add `LocaleMiddleware` to the list of
    middlewares that our application uses. The job of `LocaleMiddleware` is to allow
    users to select the language of the site based on a couple of request parameters.
    You can read the details of how the language is determined in the documentation
    at [https://docs.djangoproject.com/es/stable/topics/i18n/translation/#how-django-discovers-language-preference](https://docs.djangoproject.com/es/stable/topics/i18n/translation/#how-django-discovers-language-preference).
    We will come back to it in a bit, discussing how it determines the language with
    an example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成并编译了翻译，我们需要设置一些Django配置。我们首先要做的是将`LocaleMiddleware`添加到应用程序使用的中间件列表中。`LocaleMiddleware`的工作是允许用户根据一些请求参数选择站点的语言。您可以在文档中阅读有关语言确定方式的详细信息[https://docs.djangoproject.com/es/stable/topics/i18n/translation/#how-django-discovers-language-preference](https://docs.djangoproject.com/es/stable/topics/i18n/translation/#how-django-discovers-language-preference)。我们稍后会回到这个问题，讨论它如何通过示例确定语言。
- en: We then needed to defined two settings variables, `LANGUAGES` and `LANGUAGE`.
    `LANGUAGE` was already defined in the code pack, so we only set the `LANGUAGES`
    variable. `LANGUAGES` is a list of language choices that Django can provide translations
    for the site in. By default, this is a huge list that includes all languages that
    Django can be translated into. However, for most projects, you want the user limited
    to a few languages to use the site in. By providing our own value for the `LANGUAGES`
    list, we ensure that Django doesn't serve pages for any languages other than the
    ones defined.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要定义两个设置变量，`LANGUAGES`和`LANGUAGE`。`LANGUAGE`已经在代码包中定义了，所以我们只设置了`LANGUAGES`变量。`LANGUAGES`是Django可以为站点提供翻译的语言选择列表。默认情况下，这是一个包含Django可以翻译的所有语言的巨大列表。然而，对于大多数项目，您希望用户仅限于使用站点的少数语言。通过为`LANGUAGES`列表提供我们自己的值，我们确保Django不会为除定义的语言之外的任何语言提供页面。
- en: The `LANGAUGE` variable defines the default language to use. If you remember,
    when we opened the home page without any language code (`http://127.0.0.1:8000/`),
    the **English** language was selected by default. The `LANGUAGE` variable decides
    what the default language for the site is.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`LANGAUGE`变量定义了要使用的默认语言。如果您记得，当我们打开主页时没有任何语言代码（`http://127.0.0.1:8000/`），**英语**语言会被默认选择。`LANGUAGE`变量决定了站点的默认语言是什么。'
- en: The next part of making the app translatable was to modify the `url.py` file.
    In place of the simple list of URL configuration elements, we wrapped our URL
    configurations inside of an `i18n_patterns` function. This function allows us
    to match URLs that have a language code prepended to them. For every request that
    comes in, this function tries to match the patterns that we wrapped in it after
    removing the language code from the URL path. It's a bit complicated to explain,
    so let's look at an example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使应用程序可翻译的下一步是修改`url.py`文件。我们将URL配置的简单列表替换为`i18n_patterns`函数。这个函数允许我们匹配在URL前面加上语言代码的URL。对于每个进来的请求，这个函数会尝试匹配我们在其中包装的模式，然后从URL路径中移除语言代码。这有点复杂，所以让我们看一个例子。
- en: 'Let''s say that we have the following URL pattern:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下的URL模式：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This would match `DOMAIN.COM/example/`, but if we tried `DOMAIN.com/en/example/`,
    the pattern would not result in a match as the `/en/` part is not part of the
    regex. However, once we wrap it in `i18n_patterns`, it will match the second example.
    This is because the `i18n_patterns` function removes the language code and then
    tries to match the patterns that we wrapped in it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配`DOMAIN.COM/example/`，但如果我们尝试`DOMAIN.com/en/example/`，模式将不会匹配，因为`/en/`部分不是正则表达式的一部分。然而，一旦我们将其包装在`i18n_patterns`中，它将匹配第二个示例。这是因为`i18n_patterns`函数会移除语言代码，然后尝试匹配我们在其中包装的模式。
- en: 'In some applications, you don''t want to have all the URLs matching with language
    prefixes. Some URLs, such as an API endpoint, don''t change based on the language.
    In these cases, you can add together `i18n_patterns` and the normal list of URL
    patterns:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些应用程序中，您不希望所有的URL都匹配语言前缀。一些URL，比如API端点，不会根据语言而改变。在这种情况下，您可以将`i18n_patterns`和普通的URL模式列表结合在一起：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This way, you can create applications that are a mix of translated and non-translated
    views.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以创建一些混合了翻译和非翻译视图的应用程序。
- en: Having added `i18n_urlpatterns`, we are done with all the configuration that
    Django needs for basic internationalization, and we can visit the pages that we
    have in the French language and see the translated versions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了`i18n_urlpatterns`后，我们已经完成了Django需要的基本国际化配置，我们可以访问我们用法语编写的页面并查看翻译版本。
- en: 'The last thing that I have left to explain is `LocaleMiddleware`. The locale
    middleware is the part of Django that allows users to use the language code in
    the url to decide which language to use. Thus, even though it''s `i18n_patterns`
    that matches patterns based on language codes, it''s the middleware that activates
    the correct language for each request. Other than using the language prefix in
    the URL path, `LocaleMiddleware` provides you with a few other ways to select
    the language as well:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我要解释的最后一件事是`LocaleMiddleware`。区域设置中间件是Django的一部分，允许用户使用URL中的语言代码来决定使用哪种语言。因此，即使是`i18n_patterns`根据语言代码匹配模式，中间件也会为每个请求激活正确的语言。除了在URL路径中使用语言前缀之外，`LocaleMiddleware`还提供了其他几种选择语言的方式：
- en: A session variable
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个会话变量
- en: A cookie value
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个cookie值
- en: The `Accept-Language` header that the user's browser sends
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户浏览器发送的`Accept-Language`头
- en: If all else fails, the default language from the `LANGUAGE` setting variable
    is used
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一切都失败了，就会使用`LANGUAGE`设置变量的默认语言
- en: This is an overview of how we adapted our application to be translatable. However,
    we're not done yet.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使我们的应用程序适应可翻译的概述。然而，我们还没有完成。
- en: Letting the user decide which language to use
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让用户决定使用哪种语言
- en: 'While it''s not a part of Django, almost all projects that are internationalized
    use this pattern; thus I think it''s important that you are aware of it. Most
    sites that have multiple language options present the user with a menu to select
    which language they want to view the site in. Let''s create that. Modify the `templates/base.html`
    template to match the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是Django的一部分，但几乎所有国际化的项目都使用这种模式；因此我认为您了解这一点很重要。大多数具有多种语言选项的网站都会向用户提供一个菜单，让他们选择要以哪种语言查看网站。让我们创建一个。修改`templates/base.html`模板以匹配以下内容：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The new parts are highlighted. We first import the i18n template library. Then,
    we create a new `div` element to hold our list of language choices. Next, to get
    the language choices as part of the template, we use the `get_available_languages`
    template tag and assign the choices to the `available_languages` variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 新部分已经突出显示。我们首先导入i18n模板库。然后，我们创建一个新的`div`元素来保存我们的语言选择列表。接下来，为了将语言选择作为模板的一部分，我们使用`get_available_languages`模板标签，并将选择分配给`available_languages`变量。
- en: Next, we create a list of links based on the language choices. The return value
    of `get_available_languages` is the tuple that we set in the settings file for
    the `LANGUAGES` variable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据语言选择创建一个链接列表。`get_available_languages`的返回值是我们在`LANGUAGES`变量的设置文件中设置的元组。
- en: In our list of links, we need some way to get URLs for each language. Again,
    Django shines here, with deep integration between the internationalization features
    and the rest of the framework. If you have internationalization active and reverse
    a URL, it automatically gets the correct language prefix.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的链接列表中，我们需要一种方法来获取每种语言的URL。Django在这方面表现出色，它与国际化功能和框架的其他部分深度集成。如果您启用了国际化并反转URL，它会自动获取正确的语言前缀。
- en: However, we can't just do a reverse for the URL here because that would create
    URLs for the language that is currently active. Thus, our list of links to switch
    language would actually just point to the current language. Instead, we have to
    temporarily switch to the language we want to create a link for and then generate
    the URL. We do this using the `language` tag. Between the `language` tag, the
    language that we pass as a parameter is activated. Thus, our reversed URLs turn
    out exactly like we want them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能在这里对URL进行反转，因为那样会创建当前活动语言的URL。因此，我们的语言切换链接列表实际上只会指向当前语言。相反，我们必须暂时切换到我们想要创建链接的语言，然后生成URL。我们使用`language`标签来实现这一点。在`language`标签之间，我们传递的语言参数会被激活。因此，我们反转的URL正好符合我们的要求。
- en: One last thing to note is the URL that we reverse. For our application, the
    `movies-list` URL is the home page, thus we reverse that. For most applications,
    you'll do the same and reverse the home page URL so that switching the language
    takes the user to the home page in the specified language.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是我们反转的URL。对于我们的应用程序，`movies-list` URL是主页，因此我们反转它。对于大多数应用程序，您将做同样的事情，并反转主页URL，以便切换语言时将用户带到指定语言的主页。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are advanced ways by which you can keep the user on the current page and
    still switch the language. One is to generate the link on each page instead of
    `base.html`, as we have done here. This way, as you know which URL the template
    will be rendered for, you can reverse the appropriate URL. However, this has the
    drawback of requiring you to repeat yourself a lot. You can search on Google for
    `Django reverse current URL in another language` and get some other suggestions.
    I still haven't found a good one to use, but you can decide if you think one of
    the suggested options fits your needs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种高级的方法可以让用户保持在当前页面并切换语言。一种方法是在每个页面上生成链接，而不是在`base.html`中，就像我们在这里做的一样。这样，由于您知道模板将呈现的URL，您可以反转适当的URL。然而，这样做的缺点是需要重复很多次。您可以在Google上搜索`Django
    reverse current URL in another language`，并获得一些其他建议。我还没有找到一个好的方法来使用，但您可以决定是否认为其中一个建议的选项符合您的需求。
- en: 'Once you have made the changes, open the movies list page again by visiting
    `http://127.0.0.1:8000/en/`, and you should now see the language switcher links
    at the top. Refer to the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进行了更改，通过访问`http://127.0.0.1:8000/en/`再次打开电影列表页面，您现在应该在顶部看到语言切换链接。参考以下截图：
- en: '![Letting the user decide which language to use](img/00698_05_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![让用户决定使用哪种语言](img/00698_05_05.jpg)'
- en: You can try switching the languages and see the change reflect immediately in
    the strings on the page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试切换语言，看到页面上的字符串立即反映出变化。
- en: Persisting the user choice
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持用户选择
- en: Let's try an experiment. Switch the language to French, and then close the browser
    window. Open the browser again and visit `http://127.0.0.1:8000/`. Note the absence
    of a language prefix in the URL. You will be redirected to the English language
    of the site. Wouldn't it be nice if, once you selected which language to use,
    it would persist across visits?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个实验。将语言切换为法语，然后关闭浏览器窗口。再次打开浏览器并访问`http://127.0.0.1:8000/`。注意URL中没有语言前缀。您将被重定向到该网站的英语版本。如果一旦您选择了要使用的语言，它能够在访问时保持不变，那不是很好吗？
- en: Django provides such a feature out of the box; you just have to add a few bits
    of code to use it. If you remember the list of steps that `LocaleMiddleware` takes
    to determine the language for the current request, the second step—after looking
    at the URL for a prefix—was to look at the session. If we can put the language
    choice in the session dictionary, Django will automatically choose the correct
    language for the user on subsequent visits.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了这样一个功能，您只需添加一些代码来使用它。如果您记得`LocaleMiddleware`确定当前请求的语言所采取的步骤列表，那么在查看URL前缀之后的第二步是查看会话。如果我们可以将语言选择放入会话字典中，Django将在随后的访问中自动为用户选择正确的语言。
- en: 'What is the correct place to put the piece of code that updates the session
    dictionary? If you think about it, every time the user changes their language
    selection, we redirect them to the home page. As they will always visit the home
    page when their language preference changes, let''s put our code there. Modify
    `MoviesListView` to match the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里放置更新会话字典的代码是正确的位置？如果您考虑一下，每当用户更改其语言选择时，我们都会将其重定向到主页。因为他们在语言偏好更改时总是访问主页，让我们把我们的代码放在那里。修改`MoviesListView`以匹配以下代码：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will also need to import `get_language` and `LANGUAGE_SESSION_KEY`. Put
    this at the top of `main/views.py`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要导入`get_language`和`LANGUAGE_SESSION_KEY`。将其放在`main/views.py`的顶部：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, visit the site again and change your language to French. Next, close the
    browser window and open it up again. Open `http://127.0.0.1:8000/` and be careful
    not to put the language prefix in the URL, and you should be redirected to the
    French language page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次访问网站并将语言更改为法语。接下来，关闭浏览器窗口，然后再次打开。打开`http://127.0.0.1:8000/`，并注意不要在URL中添加语言前缀，您应该被重定向到法语页面。
- en: Let's look at what's happening here. In the absence of a language code in the
    URL, `LocaleMiddleware` looks at the session to see if the key that holds the
    language selection has any value. If it does, the middleware sets that as the
    language for the request. We put the language selection of the user in the session
    by first getting the language that is currently active using the `get_language`
    method and then putting it in the session. The key name used by the middleware
    is stored in the `LANGUAGE_SESSION_KEY` constant, so we use this to set the language
    selection.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。在URL中没有语言代码的情况下，`LocaleMiddleware`会查看会话，看看保存语言选择的键是否有任何值。如果有，中间件会将其设置为请求的语言。我们通过首先使用`get_language`方法获取当前活动的语言，然后将其放入会话中，将用户的语言选择放入会话中。中间件使用的键名称存储在`LANGUAGE_SESSION_KEY`常量中，因此我们使用它来设置语言选择。
- en: With the session set properly, the next time your user visits the site without
    a language prefix, the middleware finds their choice in the session and uses that.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设置会话后，用户下次访问网站时，如果没有语言前缀，中间件会在会话中找到他们的选择并使用它。
- en: Translating our models
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译我们的模型
- en: 'The last thing that we want to look at is how to translate our model data.
    Open the site and change to the French language. Your home page should be similar
    to the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的最后一件事是如何翻译我们的模型数据。打开网站并切换到法语。您的主页应该类似于以下截图：
- en: '![Translating our models](img/00698_05_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![翻译我们的模型](img/00698_05_06.jpg)'
- en: You will notice that even though the static content—the one that we put in the
    template ourselves—is translated, the dynamic names of the movies are not. While
    this is acceptable for some sites, your model data should be translated as well
    in order to be truly internationalized. Django by default does not have any built-in
    method to achieve this, but it's pretty easy.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，即使静态内容——我们自己放在模板中的内容——已被翻译，电影的动态名称却没有被翻译。虽然这对一些网站来说是可以接受的，但您的模型数据也应该被翻译，以便真正国际化。Django默认没有任何内置方法来实现这一点，但这很容易。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What I'm about to show you is something that the Django `modeltranslation` library
    already provides. I have used it in a large scale project and it works pretty
    well, so if you want to skip this section, you can just go ahead and use the library.
    However, it's nice to have an overview of how you can achieve it without any external
    help.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要向您展示的是Django `modeltranslation`库已经提供的内容。我在一个大型项目中使用过它，效果非常好，所以如果您想跳过这一部分，可以直接使用该库。但是，了解如何在没有任何外部帮助的情况下实现它也是很好的。
- en: You can find the library at [https://github.com/deschler/django-modeltranslation](https://github.com/deschler/django-modeltranslation).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/deschler/django-modeltranslation](https://github.com/deschler/django-modeltranslation)找到该库。
- en: What we need is some way to store more than one language for each of the text
    fields in our models. You could come up with a scheme where you store both the
    English and French translation of the string in the same field using some separator,
    and then separate the two when displaying the model.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种方法来为我们模型中的每个文本字段存储多种语言。您可以想出一种方案，在其中使用某种分隔符将字符串的英文和法文翻译存储在同一个字段中，然后在显示模型时将两者分开。
- en: Another way to achieve the same result would be to add an extra field for each
    language. For our current example, that would mean adding an extra field for each
    field that we want to translate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现相同结果的方法是为每种语言添加一个额外的字段。对于我们当前的示例，这意味着为每个要翻译的字段添加一个额外的字段。
- en: Both approaches have their pros and cons. The first one is difficult to maintain;
    as you add more than just one language to translate to, the data format becomes
    difficult to maintain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有其利弊。第一种方法难以维护；随着需要翻译的语言不止一种，数据格式变得难以维护。
- en: The second approach adds database fields, something that may not always be possible.
    Plus, it requires a fundamental change in how to access the data. However, if
    you have the option, I always advice going with the option that results in cleaner
    and easy-to-understand code, which in this case means adding extra fields per
    language.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法添加了数据库字段，这可能并非总是可能的。此外，它需要根本性地改变数据访问方式。但是，如果您有选择，我总是建议选择结果更清晰易懂的代码，这种情况下意味着为每种语言添加额外字段。
- en: 'For our `MovieDetails` model, this means having an extra field each for the
    title and description fields to store the French translation. Edit your `main/models.py`
    file so that the `MovieDetails` model matches the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`MovieDetails`模型，这意味着为标题和描述字段各添加一个额外的字段来存储法语翻译。编辑您的`main/models.py`文件，使`MovieDetails`模型与以下代码匹配：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, create and run the migrations to add these new fields to the database:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建并运行迁移以将这些新字段添加到数据库中：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see in the preceding CLI session, when I created the migrations,
    I was asked to provided a default value for the new fields. I just entered the
    empty string. We can fix the value later from the admin.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的CLI会话中所看到的，当我创建迁移时，我被要求为新字段提供默认值。我只输入了空字符串。我们可以稍后从管理员中修复这个值。
- en: 'Finally, run the new migration:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行新的迁移：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once this is done, open up the admin and see the edit page for one of the objects
    you have in your database. It should seem similar to the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，打开管理员，查看数据库中一个对象的编辑页面。它应该看起来类似于以下截图：
- en: '![Translating our models](img/00698_05_07.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![翻译我们的模型](img/00698_05_07.jpg)'
- en: In the preceding screenshot, you can see that two new fields have been added
    to the admin. I translated the English value for these fields using Google Translate
    and filled in the French language field values. Click on **Save**. Now, our models
    have the French language data alongside the English values; but how to display
    them?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到管理员添加了两个新字段。我使用Google翻译翻译了这些字段的英文值，并填写了法语语言字段的值。点击**保存**。现在，我们的模型在英语值旁边有了法语语言数据；但如何显示它们呢？
- en: You could put a couple of `if/else` conditions in your template code to decide
    which language field to use. However, that gets messy quickly. Right now, our
    model only has two fields that are translated, but imagine a model with 10 such
    fields. How many conditions would you have? We're only talking about supporting
    one language. Finally, we only have two templates that need to be modified, the
    list view and detail view. In a real-world, more complicated application, your
    models could be used from a hundred different places. The `if/else` approach gets
    too difficult to maintain very quickly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模板代码中放置一些 `if/else` 条件来决定使用哪种语言字段。然而，这很快就会变得混乱。现在，我们的模型只有两个被翻译的字段，但想象一下一个有10个这样字段的模型。你会有多少条件？我们只讨论支持一种语言。最后，我们只需要修改两个模板，列表视图和详细视图。在一个真实的、更复杂的应用程序中，你的模型可能会被用在一百个不同的地方。`if/else`
    方法很快就变得难以维护。
- en: 'Instead, what we will do is give our model methods to intelligently return
    to us the correct value for a field, depending on the current language. Let''s
    modify our `main/models.py` file again. First, import the `get_language` method
    at the top:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将给我们的模型方法，以智能地返回正确的字段值，取决于当前的语言。让我们再次修改我们的 `main/models.py` 文件。首先，在顶部导入
    `get_language` 方法：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, modify the `MovieDetails` model again and add these three new methods
    (highlighted in the code):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次修改 `MovieDetails` 模型，并添加这三个新方法（在代码中突出显示）：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's nothing Django-specific in the new methods. The main work-horse is the
    `_get_translated_field` method. Given a field name, it looks at the current language,
    and if the language is something other than English, appends the language code
    to the field name. It then gets the value for the new field name from the object.
    If the value is empty because we didn't translate the field, it follows the Django
    convention and just returns the value of the original non-translated field.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法中没有任何Django特定的内容。主要的工作是 `_get_translated_field` 方法。给定一个字段名，它查看当前的语言，如果语言不是英语，就将语言代码附加到字段名。然后从对象中获取新字段名的值。如果值为空，因为我们没有翻译该字段，它遵循Django的约定，只返回原始未翻译字段的值。
- en: 'Now, modify `main/templates/movies_list.html` to use these new methods:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改 `main/templates/movies_list.html` 来使用这些新方法：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only change here is that instead of using the value of `movie.title` directly,
    we use `movie.get_title`. This is the one major drawback of this approach. Now
    everywhere in your project where you need the `title` or `description` values,
    you'll have to use the `get_title` and `get_description` methods instead of just
    using the field values directly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是，现在不再直接使用 `movie.title` 的值，而是使用 `movie.get_title`。这是这种方法的一个主要缺点。现在在你的项目中，无论何处你需要
    `title` 或 `description` 的值，你都必须使用 `get_title` 和 `get_description` 方法，而不是直接使用字段值。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The same goes for saving the fields. You'll have to figure out which field name
    to write to, depending on the active language. While neither of these are complicated,
    they do add some discomfort to the whole process. However, that's the price you
    pay for this power.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 保存字段也是一样的。你必须弄清楚要写入哪个字段名，这取决于激活的语言。虽然这两者都不复杂，但它们确实给整个过程增加了一些不便。然而，这就是你为这种功能付出的代价。
- en: The `django-modeltranslation` package that I mentioned before has a good solution
    to this problem. It uses code in the model to automatically decides which language
    to return whenever you access any field. So, instead of using `obj.get_title()`,
    you would write `obj.title` and get the correct field for the currently activated
    language. For your projects, you might want to look into this. I didn't use this
    in this chapter because I wanted to give you a way to work with basic Django and
    show you one possible way to do things yourself instead of relying on third-party
    libraries.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到的 `django-modeltranslation` 包对这个问题有一个很好的解决方案。它使用模型中的代码来自动决定每当你访问任何字段时应该返回哪种语言。所以，你不再使用
    `obj.get_title()`，而是直接写 `obj.title`，就可以得到当前激活语言的正确字段。对于你的项目，你可能需要研究一下这个。我在本章中没有使用这个，因为我想给你一个使用基本的Django的方法，并向你展示一种自己处理事情的可能方式，而不是依赖第三方库。
- en: 'Open up the French version of the site again and you should see that the one
    object we translated should have the translated version of the title, whereas
    the others will just show the non-translated versions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开网站的法语版本，你会看到我们翻译的一个对象应该有标题的翻译版本，而其他的则只显示未翻译的版本：
- en: '![Translating our models](img/00698_05_08.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![翻译我们的模型](img/00698_05_08.jpg)'
- en: Doing the same for the details template should be simple and is left up to you!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于详情模板做同样的事情应该很简单，留给你来完成！
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While this was a somewhat small chapter, we looked at information that will
    come in handy throughout your web development career. While not all of the sites
    that you develop will need to be translated into multiple languages, some of the
    most important ones will. When you get a chance to work on such a project, you
    will have the information on how to go about creating a truly internationalized
    web application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个相对较小的章节，但我们看到的信息将在您的网络开发职业生涯中派上用场。虽然并非您开发的所有网站都需要被翻译成多种语言，但一些最重要的网站会需要。当您有机会参与这样的项目时，您将拥有如何创建一个真正国际化的网络应用程序的信息。
- en: We have only scratched the surface of what is possible with Django internationalization
    and localization. When you start a project that requires these, be sure to check
    out the documentation as well.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是初步了解了Django国际化和本地化的可能性。当您开始一个需要这些功能的项目时，请务必查阅文档。
- en: We are now done with simple Django-only applications. Having learnt the basics
    of Django, the next chapter will have us working on a more complicated web application—one
    that involves search using the amazingly powerful Elasticsearch!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了简单的仅使用Django的应用程序。在学习了Django的基础知识之后，下一章将让我们开始开发一个更复杂的网络应用程序——一个涉及使用强大的Elasticsearch进行搜索的应用程序！
