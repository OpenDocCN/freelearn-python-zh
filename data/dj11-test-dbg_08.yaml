- en: 'Chapter 8. When Problems Hide: Getting More Information'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。当问题隐藏时：获取更多信息
- en: Sometimes code does not trigger a debug page to be displayed, but it also does
    not produce the correct results. In fact even when code does seem to be working
    correctly, at least in terms of the visible results shown in the browser, behind
    the scenes it may be doing unexpected things that could lead to trouble down the
    road. For example, if a page requires many (or very time-consuming) SQL queries,
    then it may seem to be working fine during development but then quickly cause
    server overload in a production environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时代码不会触发显示调试页面，但也不会产生正确的结果。事实上，即使代码似乎在浏览器中显示的可见结果方面工作正常，幕后它可能也在做一些意想不到的事情，这可能会在以后引起麻烦。例如，如果一个页面需要许多（或非常耗时的）SQL查询，那么在开发过程中它可能看起来运行正常，但在生产环境中很快就会导致服务器超载。
- en: It's good practice, then, to get into the habit of checking up on how code is
    behaving, even when external results are not showing any problems. First, this
    practice can reveal hidden problems that are best known about sooner rather than
    later. Second, knowing what the normal code path looks like is very valuable when
    tracking down where things have gone wrong when a problem does crop up.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，养成检查代码行为的习惯是很好的做法，即使外部结果没有显示任何问题。首先，这种做法可以揭示最好尽早知道的隐藏问题。其次，当问题确实出现时，了解正常的代码路径是非常有价值的。
- en: 'This chapter focuses on ways to get more information about what Django application
    code is doing. Specifically, in this chapter we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了获取有关Django应用程序代码正在执行的更多信息的方法。具体来说，在本章中我们将：
- en: Develop template code that can be used to include information about all of the
    SQL queries needed to render a page in the page itself
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模板代码，用于在页面本身包含有关渲染页面所需的所有SQL查询的信息
- en: Learn how to use the Django Debug Toolbar for gathering similar information,
    and more
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Django调试工具栏收集类似信息，以及更多
- en: Discuss techniques for adding logging to Django application code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论向Django应用程序代码添加日志记录的技术
- en: Tracking SQL queries for a request
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪请求的SQL查询
- en: For a typical Django application, database interactions are of key importance.
    Ensuring that the database queries being made are correct helps to ensure that
    the application results are correct. Further, ensuring that the database queries
    produced for the application are efficient helps to make sure that the application
    will be able to support the desired number of concurrent users.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的Django应用程序，数据库交互非常重要。确保所做的数据库查询是正确的有助于确保应用程序的结果是正确的。此外，确保为应用程序生成的数据库查询是高效的有助于确保应用程序能够支持所需数量的并发用户。
- en: Django provides support in this area by making the database query history available
    for examination. [Chapter 6](ch06.html "Chapter 6. Django Debugging Overview"),
    *Django Debugging Overview*, introduced this history and showed how it could be
    accessed from a Python shell session. This type of access is useful to see the
    SQL that is issued as a result of calling a particular model method. However,
    it is not helpful in learning about the bigger picture of what SQL queries are
    made during the processing of a particular request.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Django通过使数据库查询历史可供检查来支持这一领域。[第6章](ch06.html "第6章。Django调试概述")，“Django调试概述”介绍了这一历史，并展示了如何从Python
    shell会话中访问它。这种访问对于查看由于调用特定模型方法而发出的SQL非常有用。然而，它对于了解在处理特定请求期间进行了哪些SQL查询并不有用。
- en: This section will show how to include information about the SQL queries needed
    for production of a page in the page itself. We will alter our existing survey
    application templates to include query information, and examine the query history
    for some of the existing survey application views. Though we are not aware of
    any problems with the existing views, we may learn something in the process of
    verifying that they issue the queries we expect.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示如何在页面本身包含有关生产页面所需的SQL查询的信息。我们将修改现有的调查应用程序模板以包含查询信息，并检查一些现有调查应用程序视图的查询历史。虽然我们不知道现有视图存在任何问题，但在验证它们是否发出我们期望的查询时，我们可能会学到一些东西。
- en: Settings for accessing query history in templates
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中访问查询历史的设置
- en: Before the query history can be accessed from a template, we need to ensure
    some required settings are configured properly. Three settings are needed in order
    for the SQL query information to be available in a template. First, the debug
    context processor, `django.core.context_processors.debug`, must be included in
    the `TEMPLATE_CONTEXT_PROCESSORS` setting. This context processor is included
    in the default value for `TEMPLATE_CONTEXT_PROCESSORS`. We have not changed that
    setting; therefore we do not need to do anything to enable this context processor
    in our project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以从模板中访问查询历史之前，我们需要确保一些必需的设置被正确配置。为了使SQL查询信息在模板中可用，需要三个设置。首先，必须在`TEMPLATE_CONTEXT_PROCESSORS`设置中包含调试上下文处理器`django.core.context_processors.debug`。这个上下文处理器包含在`TEMPLATE_CONTEXT_PROCESSORS`的默认值中。我们没有更改该设置；因此，我们不需要在项目中做任何事情来启用这个上下文处理器。
- en: 'Second, the IP address of the machine sending the request must be listed in
    the `INTERNAL_IPS` setting. This is not a setting we have used before, and it
    is empty by default, so we will need to add it to the settings file. When testing
    using the same machine as where the development server runs, setting `INTERNAL_IPS`
    to include the loopback address is sufficient:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，发送请求的机器的IP地址必须列在`INTERNAL_IPS`设置中。这不是我们以前使用过的设置，默认情况下为空，因此我们需要将其添加到设置文件中。在使用与开发服务器运行的相同机器进行测试时，将`INTERNAL_IPS`设置为包括环回地址就足够了：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you also test from other machines, you will need to include their IP addresses
    in this setting as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还从其他机器进行测试，您还需要在此设置中包含它们的IP地址。
- en: Third and finally, `DEBUG` must be `True` in order for the SQL query history
    to be available in templates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，最后，`DEBUG`必须为`True`，才能在模板中使用SQL查询历史。
- en: 'When those three settings conditions are met, the SQL query history may be
    available in templates via a template variable named `sql_queries`. This variable
    contains a list of dictionaries. Each dictionary contains two keys: `sql` and
    `time`. The value for `sql` is the SQL query itself, and the value for `time`
    is the number of seconds the query took to execute.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足这三个设置条件时，SQL查询历史可能可以通过名为`sql_queries`的模板变量在模板中使用。这个变量包含一个字典列表。每个字典包含两个键：`sql`和`time`。`sql`的值是SQL查询本身，`time`的值是查询执行所花费的秒数。
- en: Note that the `sql_queries` context variable is set by the debug context processor.
    Context processors are only called during template rendering when a `RequestContext`
    is used to render the template. Up until now, we have not used `RequestContexts`
    in our survey application views, since they were not necessary for the code so
    far. But in order to access the query history from the template, we will need
    to start using `RequestContexts`. Therefore, in addition to modifying the templates,
    we will need to change the view code slightly in order to include query history
    in the generated pages for the survey application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sql_queries`上下文变量是由调试上下文处理器设置的。只有在使用`RequestContext`来渲染模板时，上下文处理器才会被调用。到目前为止，我们在调查应用程序视图中没有使用`RequestContexts`，因为到目前为止代码还不需要。但是为了从模板中访问查询历史，我们需要开始使用`RequestContexts`。因此，除了修改模板，我们还需要稍微修改视图代码，以便在调查应用程序的生成页面中包含查询历史。
- en: SQL queries for the home page
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主页的SQL查询
- en: 'Let''s start by seeing what queries are issued in order to generate the `survey`
    application home page. Recall that the home page view code is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看为了生成`survey`应用程序主页而发出了哪些查询。回想一下主页视图代码是：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are three `QuerySets` rendered in the template, so we would expect to
    see that this view generates three SQL queries. In order to check that, we must
    first change the view to use a `RequestContext`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中呈现了三个`QuerySets`，所以我们期望看到这个视图生成三个SQL查询。为了检查这一点，我们必须首先更改视图以使用`RequestContext`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only change here is to add the `RequestContext(request)` as a third parameter
    to `render_to_response`, after adding an `import` for it earlier in the file.
    When we make this change, we may as well also change the `render_to_response`
    lines for the other views to use `RequestContexts` as well. That way when we get
    to the point of examining the SQL queries for each, we will not get tripped up
    by having forgotten to make this small change.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的变化是在文件中添加了`import`后，将`RequestContext(request)`作为`render_to_response`的第三个参数添加进去。当我们做出这个改变时，我们可能也会改变其他视图的`render_to_response`行，以便也使用`RequestContexts`。这样，当我们到达检查每个查询的SQL查询的时候，我们不会因为忘记做出这个小改变而被绊倒。
- en: Second, we'll need to display the information from `sql_queries` somewhere in
    our `survey/home.html` template. But where? We don't necessarily want this information
    displayed in the browser along with the genuine application data, since that could
    get confusing. One way to include it in the response but not have it be automatically
    visible on the browser page is to put it in an HTML comment. Then the browser
    will not display it on the page, but it can be seen by viewing the HTML source
    for the displayed page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要在我们的`survey/home.html`模板中的某个地方显示来自`sql_queries`的信息。但是在哪里？我们不一定希望这些信息与真实应用程序数据一起显示在浏览器中，因为那可能会让人困惑。将其包含在响应中但不自动显示在浏览器页面上的一种方法是将其放在HTML注释中。然后浏览器不会在页面上显示它，但可以通过查看显示页面的HTML源代码来看到它。
- en: 'As a first attempt at implementing this, we might change the top of `survey/home.html`
    to look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实现这一点的第一次尝试，我们可能会改变`survey/home.html`的顶部，看起来像这样：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This template code prints out the contents of `sql_queries` within an HTML comment
    at the very beginning of the `content` block supplied by `survey/home.html`. First,
    the number of queries is noted by filtering the list through the `length` filter.
    Then the code iterates through each dictionary in the `sql_queries` list and displays
    `sql`, followed by a note in parentheses about the `time` taken for each query.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板代码在`survey/home.html`提供的`content`块的开头以HTML注释的形式打印出`sql_queries`的内容。首先，通过`length`过滤器过滤列表来记录查询的数量。然后代码遍历`sql_queries`列表中的每个字典，并显示`sql`，然后跟着每个查询所花费的`time`的括号注释。
- en: 'How well does that work? If we try it out by retrieving the survey home page
    (after ensuring the development server is running), and use the browser''s menu
    item for viewing the HTML source for the page, we might see that the comment block
    contains something like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法效果如何？如果我们尝试通过检索调查主页（确保开发服务器正在运行），并使用浏览器菜单项查看页面的HTML源代码，我们可能会看到评论块包含类似以下内容：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the exact number of queries displayed here will depend on the version
    of Django you are running. This result is from Django 1.1.1; later versions of
    Django may not show any queries displayed here. Furthermore, the history of the
    browser's interaction with the site will affect the queries issued. This result
    is from a browser that had been used to access the admin application, and the
    last interaction with the admin application was to log out. You may see additional
    queries if the browser had been used to access the admin application but the user
    had not logged out. Finally, the database in use can also affect the specific
    queries issued and their exact formatting. This result is from a MySQL database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里显示的查询数量取决于您正在运行的Django版本。这个结果来自Django 1.1.1；Django的后续版本可能不会显示任何查询。此外，浏览器与网站的交互历史将影响发出的查询。这个结果来自一个曾用于访问管理应用程序的浏览器，最后一次与管理应用程序的交互是退出登录。如果浏览器曾用于访问管理应用程序但用户未注销，则可能会看到其他查询。最后，使用的数据库也会影响发出的具体查询和其确切格式。这个结果来自一个MySQL数据库。
- en: 'That''s not exactly what we expected. First, a minor annoyance, but `1 queries`
    is wrong, it should be `1 query`. Perhaps that wouldn''t annoy you, particularly
    just in internal or debug information, but it would annoy me. I would change the
    template code that displays the query count to use correct pluralization:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们预期的。首先，一个小小的烦恼，但是`1 queries`是错误的，应该是`1 query`。也许这不会让你烦恼，特别是在内部或调试信息中，但对我来说会让我烦恼。我会更改显示查询计数的模板代码，以使用正确的复数形式：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, since the template needs to use the `length` result multiple times, it
    is first cached in the `qcount` variable by using a `{% with %}` block. Then it
    is displayed, and it is used as the variable input to the `pluralize` filter that
    will put the correct letters on the end of `quer` depending on the `qcount` value.
    Now the comment block will show `0 queries`, `1 query`, `2 queries`, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于模板需要多次使用`length`结果，首先通过使用`{% with %}`块将其缓存在`qcount`变量中。然后它被显示，并且它被用作`pluralize`过滤器的变量输入，该过滤器将根据`qcount`值在`quer`的末尾放置正确的字母。现在注释块将显示`0
    queries`，`1 query`，`2 queries`等等。
- en: With that minor annoyance out of the way, we can concentrate on the next, larger,
    issue, which is that the displayed query is not a query we were expecting. Furthermore,
    the three queries we were expecting, to retrieve the lists of completed, active,
    and upcoming surveys, are nowhere to be seen. What's going on? We'll take each
    of these in turn.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这个小小的烦恼后，我们可以集中精力解决下一个更大的问题，那就是显示的查询不是我们预期的查询。此外，我们预期的三个查询，用于检索已完成、活动和即将进行的调查列表，都不见了。发生了什么？我们将依次处理每一个。
- en: The query that is shown is accessing the `django_session` table. This table
    is used by the `django.contrib.sessions` application. Even though the survey application
    does not use this application, it is listed in our `INSTALLED_APPS`, since it
    is included in the `settings.py` file that `startproject` generates. Also, the
    middleware that the `sessions` application uses is listed in `MIDDLEWARE_CLASSES`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的查询正在访问`django_session`表。这个表被`django.contrib.sessions`应用程序使用。尽管调查应用程序不使用这个应用程序，但它在我们的`INSTALLED_APPS`中列出，因为它包含在`settings.py`文件中，`startproject`生成。此外，`sessions`应用程序使用的中间件在`MIDDLEWARE_CLASSES`中列出。
- en: 'The `sessions` application stores the session identifier in a cookie, named
    `sessionid` by default, that is sent to the browser as soon as any application
    uses a session. The browser will return the cookie in all requests to the same
    server. If the cookie is present in a request, the session middleware will use
    it to retrieve the session data. This is the query we see previously listed: the
    session middleware is retrieving the data for the session identified by the session
    cookie sent by the browser.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessions`应用程序默认将会话标识符存储在名为`sessionid`的cookie中，一旦任何应用程序使用会话，它就会立即发送到浏览器。浏览器将在所有请求中返回该cookie给同一服务器。如果请求中存在该cookie，会话中间件将使用它来检索会话数据。这就是我们之前看到的查询：会话中间件正在检索由浏览器发送的会话cookie标识的会话数据。'
- en: But the survey application does not use sessions, so how did the browser get
    a session cookie in the first place? The answer is that the admin application
    uses sessions, and this browser had previously been used to access the admin application.
    At that time, the `sessionid` cookie was set in a response, and the browser faithfully
    returns it on all subsequent requests. Thus, it seems likely that this `django_session`
    table query is due to a `sessionid` cookie set as a side-effect of using the admin
    application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是调查应用程序不使用sessions，那么浏览器是如何首先获得会话cookie的呢？答案是管理员应用程序使用sessions，并且此浏览器先前曾用于访问管理员应用程序。那时，`sessionid`
    cookie在响应中设置，并且浏览器忠实地在所有后续请求中返回它。因此，似乎很可能这个`django_session`表查询是由于使用管理员应用程序的副作用设置了`sessionid`
    cookie。
- en: 'Can we confirm that? If we find and delete the cookie from the browser and
    reload the page, we should see that this SQL query is no longer listed. Without
    the cookie in the request, whatever code was triggering access to the session
    data won''t have anything to look up. And since the survey application does not
    use sessions, none of its responses should include a new session cookie, which
    would cause subsequent requests to include a session lookup. Is this reasoning
    correct? If we try it, we will see that the comment block changes to:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能确认吗？如果我们找到并删除浏览器中的cookie，然后重新加载页面，我们应该会看到这个SQL查询不再列出。没有请求中的cookie，触发对会话数据的访问的任何代码都不会有任何东西可以查找。而且由于调查应用程序不使用sessions，它的任何响应都不应包含新的会话cookie，这将导致后续请求包含会话查找。这种推理正确吗？如果我们尝试一下，我们会看到注释块变成：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Thus, we seem to have confirmed, to some extent, what happened to cause a `django_session`
    table query during processing of a survey application response. We did not track
    down what exact code accessed the session identified by the cookie—it could have
    been middleware or a context processor, but we probably don't need to know the
    details. It's enough to keep in mind that there are other applications running
    in our project besides the one we are working on, and they may cause database
    interactions independent of our own code. If we observe behavior which looks like
    it might cause a problem for our code, we can investigate further, but for this
    particular case we will just avoid using the admin application for now, as we
    would like to focus attention on the queries our own code is generating.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们似乎在一定程度上确认了在处理调查应用程序响应期间导致`django_session`表查询的原因。我们没有追踪到哪些确切的代码访问了由cookie标识的会话——可能是中间件或上下文处理器，但我们可能不需要知道细节。记住我们的项目中运行的除了我们正在工作的应用程序之外还有其他应用程序，它们可能会导致与我们自己的代码无关的数据库交互就足够了。如果我们观察到的行为看起来可能会对我们的代码造成问题，我们可以进一步调查，但对于这种特殊情况，我们现在将避免使用管理员应用程序，因为我们希望将注意力集中在我们自己的代码生成的查询上。
- en: Now that we understand the query that was listed, what about the expected ones
    that were not listed? The missing queries are due to a combination of the lazy
    evaluation property of `QuerySets` and the exact placement of the `comment` block
    that lists the contents of `sql_queries`. We put the `comment` block at the top
    of the `content` block in the home page, to make it easy to find the SQL query
    information when looking at the page source. The template is rendered after the
    three `QuerySets` are created by the view, so it might seem that the comment placed
    at the top should show the SQL queries for the three `QuerySets`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了列出的查询，那么没有列出的预期查询呢？缺少的查询是由于`QuerySets`的惰性评估属性和列出`sql_queries`内容的`comment`块的确切放置位置的组合。我们将`comment`块放在主页的`content`块顶部，以便在查看页面源时轻松找到SQL查询信息。模板在视图创建三个`QuerySets`之后呈现，因此似乎放在顶部的注释应该显示三个`QuerySets`的SQL查询。
- en: However, `QuerySets` are lazy; simply creating a `QuerySet` does not immediately
    cause interaction with the database. Rather, sending the SQL to the database is
    delayed until the `QuerySet` results are actually accessed. For the survey home
    page, that does not happen until the parts of the template that loop through each
    `QuerySet` are rendered. Those parts are all below where we placed the `sql_queries`
    information, so the corresponding SQL queries had not yet been issued. The fix
    for this is to move the placement of the `comment` block to the very bottom of
    the `content` block.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`QuerySets`是惰性的；仅创建`QuerySet`并不会立即导致与数据库的交互。相反，直到实际访问`QuerySet`结果之前，将SQL发送到数据库是延迟的。对于调查主页，直到循环遍历每个`QuerySet`的模板部分被渲染之前，这并不会发生。这些部分都在我们放置`sql_queries`信息的下面，因此相应的SQL查询尚未发出。解决此问题的方法是将`comment`块的放置位置移动到`content`块的最底部。
- en: When we do that we should also fix two other issues with the query display.
    First, notice that the query displayed above has `&gt;` shown instead of the `>`
    symbol that would actually have been in the query sent to the database. Furthermore,
    if the database in use is one (such as PostgreSQL) that uses straight quotes instead
    of back quotes for quoting, all of the back quotes in the query would be shown
    as `&quot;`. This is due to Django's automatic escaping of HTML markup characters.
    This is unnecessary and hard to read in our HTML comment, so we can suppress it
    by sending the `sql` query value through the `safe` filter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们还应该修复查询显示的另外两个问题。首先，请注意上面显示的查询中显示的是`&gt;`而不是实际发送到数据库的`>`符号。此外，如果使用的数据库是使用直引号而不是反引号进行引用的数据库（例如PostgreSQL），查询中的所有反引号都将显示为`&quot;`。这是由于Django自动转义HTML标记字符造成的。这在我们的HTML注释中是不必要且难以阅读的，因此我们可以通过将`sql`查询值通过`safe`过滤器发送来抑制它。
- en: Second, the query is very long. In order to avoid needing to scroll to the right
    in order to see the entire query, we can also filter the `sql` value through `wordwrap`
    to introduce some line breaks and make the output more readable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，查询非常长。为了避免需要向右滚动才能看到整个查询，我们还可以通过`wordwrap`过滤器过滤`sql`值，引入一些换行，使输出更易读。
- en: 'To make these changes, remove the added comment block from the top of the `content`
    block in the `survey/home.html` template and instead change the bottom of this
    template to be:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行这些更改，请从`survey/home.html`模板的`content`块顶部删除添加的注释块，而是将此模板的底部更改为：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if we again reload the survey home page and view the source for the returned
    page, we will see the queries listed in a comment at the bottom:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次重新加载调查主页并查看返回页面的源代码，我们将在底部的注释中看到列出的查询：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That is good, those look like exactly what we expect to see for queries for
    the home page. Now that we seem to have some working template code to show queries,
    we will consider packaging up this snippet so that it can easily be reused elsewhere.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，看起来正是我们期望在主页查询中看到的内容。现在我们似乎有一些可以显示查询的工作模板代码，我们将考虑打包这个片段，以便可以轻松地在其他地方重用。
- en: Packaging the template query display for reuse
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包模板查询显示以便重用
- en: We've now got a small block of template code that we can put in any template
    to easily see what SQL queries were needed to produce a page. However, it is not
    so small that it can be easily re-typed whenever it might come in handy. Therefore,
    it would be good to package it up in a form where it can be conveniently included
    wherever and whenever it might be needed. The Django template `{% include %}`
    tag makes this easy to do.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一小块模板代码，可以将其放在任何模板中，以便轻松查看生成页面所需的SQL查询。但是，它并不小到可以在需要时轻松重新输入。因此，最好将其打包成一种形式，可以在需要时方便地包含在任何地方。Django模板`{%
    include %}`标签使这一点变得很容易。
- en: Where should the snippet go? Note that this template snippet is completely general
    and not in any way tied to the survey application. While it would be easy to simply
    include it among the survey templates, putting it there will make it harder to
    reuse for future projects. A better approach is to put it in an independent application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段应该放在哪里？请注意，这个模板片段是完全通用的，与调查应用程序没有任何关联。虽然将其简单地包含在调查模板中很容易，但将其放在那里将使其在将来的项目中更难以重用。更好的方法是将其放在一个独立的应用程序中。
- en: Creating an entirely new application just for this one snippet may seem a bit
    extreme. However, it is common during development to create small utility functions
    or template snippets that don't really belong in the main application. So it is
    likely during development of a real project that there would be other such things
    that should logically be placed somewhere besides the main application. It's helpful
    to have someplace else to put them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个片段创建一个全新的应用程序可能看起来有点极端。然而，在开发过程中创建一些不真正属于主应用程序的小型实用函数或模板片段是很常见的。因此，在实际项目的开发过程中，可能会有其他类似的东西，它们在逻辑上应该放在主应用程序之外的某个地方。有一个地方可以放它们是很有帮助的。
- en: 'Let''s create a new Django application, then, to hold any general utility code
    that does not logically belong within the survey application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Django应用程序，用来保存一些通用的实用代码，这些代码在调查应用程序中并不合乎逻辑：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since its purpose is to hold general utility code, we've named the new application
    `gen_utils`. It can serve as a place to put any non-survey-specific code that
    seems like it might be potentially re-usable elsewhere. Note that as time goes
    on and more and more stuff accumulates in an application like this, it may become
    apparent that some subset of it would be useful to package into its own independent,
    self-contained application with a more descriptive name than `gen_utils`. But
    for now it is enough to start with one place to put utility code that is not really
    tied to the survey application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它的目的是保存通用实用代码，我们将新应用程序命名为`gen_utils`。它可以作为一个放置任何非调查特定代码的地方，看起来可能在其他地方有重复使用的潜力。请注意，随着时间的推移，如果在这样的应用程序中积累了越来越多的东西，可能会变得明显，其中的一些子集将有用，可以打包成一个独立的、自包含的应用程序，其名称比`gen_utils`更具描述性。但是现在，开始一个地方放置与调查应用程序没有真正关联的实用代码就足够了。
- en: 'Next, we can create a `templates` directory within `gen_utils`, and a `gen_utils`
    directory under `templates`, and create a file, `showqueries.html`, to hold the
    template snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`gen_utils`中创建一个`templates`目录，然后在`templates`下创建一个`gen_utils`目录，并创建一个文件`showqueries.html`来保存模板片段：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've made one change here from the previous code placed directly in the `survey/home.html`
    template, which is to place the entire HTML `comment` block inside an `{% if sql_qureies
    %}` block. If the `sql_queries` variable has not been included in the template
    context, then there is no reason to produce the comment at all.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对之前直接放在`survey/home.html`模板中的代码进行了一个改变，就是将整个HTML `comment`块放在了`{% if sql_qureies
    %}`块中。如果`sql_queries`变量没有包含在模板上下文中，那么就没有理由生成注释。
- en: As part of packaging code for reuse, it's also good practice to double-check
    and make sure that the code is truly reusable and not going to fail in odd ways
    if given unexpected or unusual input. Taking a look at that snippet, is there
    anything that might be found in an arbitrary `sql_queries` input that could cause
    a problem?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为代码重用的一部分，检查并确保代码确实可重用，并且不会在给定意外或异常输入时以奇怪的方式失败也是一个好习惯。看看那个片段，有没有什么可能在任意的`sql_queries`输入中引起问题的东西？
- en: The answer is yes. If a SQL query value contains the HTML end-of-comment delimiter,
    then the comment block will be terminated early. This could result in the browser
    rendering what was intended to be a comment as part of the page content displayed
    to the user. To see this, we can try inserting a model `filter` call that includes
    the HTML end-of-comment delimiter into the home page view code, and see what the
    browser shows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的。如果SQL查询值包含HTML注释结束符，则注释块将被提前终止。这可能导致浏览器将本来应该是注释的内容作为用户显示的页面内容的一部分。为了验证这一点，我们可以尝试在主页视图代码中插入一个包含HTML注释结束符的模型`filter`调用，然后查看浏览器显示的内容。
- en: 'But what is the HTML end-of-comment delimiter? You might guess that it is `-->`,
    but in fact it is just the two dashes in a row. Technically, the `<!` and `>`
    are defined as the beginning and end of markup declaration, while the dashes mark
    the beginning and end of the comment. Thus, a query that contains two dashes in
    a row should trigger the behavior we are worried about here. To test this, add
    this line of code to the `home` view:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是HTML注释结束符是什么？你可能会猜想是`-->`，但实际上它只是连续的两个破折号。从技术上讲，`<!`和`>`被定义为标记声明的开始和结束，而破折号标记注释的开始和结束。因此，包含连续两个破折号的查询应该触发我们在这里担心的行为。为了测试这一点，将这行代码添加到`home`视图中：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note nothing has to be done with the results of the call; the added code must
    simply ensure that the query containing the two dashes is actually sent to the
    database. This added line does that by retrieving the count of results matching
    the pattern containing two dashes. With that added line in the `home` view, Firefox
    will display the survey home page like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不需要对调用的结果做任何处理；添加的代码只需确保包含两个破折号的查询实际上被发送到数据库。通过检索匹配包含两个破折号的模式的结果计数，添加的代码实现了这一点。有了`home`视图中的这一行，Firefox将显示调查主页如下：
- en: '![Packaging the template query display for reuse](img/7566_08_01(revised).jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![打包模板查询以便重用](img/7566_08_01(revised).jpg)'
- en: The two dashes in a row in a SQL query value caused Firefox to prematurely terminate
    the comment block, and data we had intended to be still inside the comment has
    appeared in the browser page. In order to avoid this, we need to ensure that two
    dashes in a row never appear in the SQL query values included in the comment block.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL查询值中连续出现的两个破折号导致Firefox过早终止了注释块，我们本打算仍然在注释中的数据出现在了浏览器页面上。为了避免这种情况，我们需要确保SQL查询值中不会连续出现两个破折号。
- en: A quick glance through the built-in Django filters doesn't reveal any that could
    be used to replace a string of two dashes with something else. The `cut` filter
    could be used to remove them, but simply removing them would make the `sql` value
    misleading as there would be no indication that the characters had been removed
    from the string. Therefore, it seems we will need to develop a custom filter for
    this.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览内置的Django过滤器并没有发现可以用来替换两个破折号的字符串的过滤器。`cut`过滤器可以用来移除它们，但仅仅移除它们会使`sql`值具有误导性，因为没有指示这些字符已从字符串中移除。因此，似乎我们需要为此开发一个自定义过滤器。
- en: 'We will put the custom filter in the `gen_utils` application. Filters and template
    tags must be placed in a `templatetags` module in an application, so we must first
    create the `templatetags` directory. Then, we can put an implementation for a
    `replace_dashes` filter into a file named `gentags.py` within `gen_utils/templatetags`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将自定义过滤器放在`gen_utils`应用程序中。过滤器和模板标签必须放在应用程序的`templatetags`模块中，因此我们首先需要创建`templatetags`目录。然后，我们可以将`replace_dashes`过滤器的实现放入`gen_utils/templatetags`目录中的名为`gentags.py`的文件中：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The bulk of this code is the standard boilerplate `import`, `register` assignment,
    and `@register.filter` decoration needed to register the `replace_dashes` function
    so that it is available for use as a filter. The function itself simply replaces
    any occurrences of a pair of dashes in a string with `~~double-dash~~` instead.
    Since there is no way to escape the dashes so that they will not be interpreted
    as the end of the comment yet still appear as dashes, we replace them with a string
    describing what had been there. The last line marks the `replace_dashes` filter
    as safe, meaning it does not introduce any HTML markup characters that would need
    to be escaped in its output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的主要部分是标准的样板`import`，`register`赋值和`@register.filter`装饰，需要注册`replace_dashes`函数，以便它可以作为过滤器使用。函数本身只是用`~~double-dash~~`替换字符串中一对破折号的任何出现。由于没有办法转义破折号，以便它们不被解释为注释的结束，但仍然显示为破折号，我们用描述原内容的字符串替换它们。最后一行将`replace_dashes`过滤器标记为安全，这意味着它不会引入任何需要在输出中转义的HTML标记字符。
- en: 'We also need to change the template snippet in `gen_utils/showqueries.html`
    to load and use this filter for display of the SQL query values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改`gen_utils/showqueries.html`中的模板片段，以加载和使用此过滤器来显示SQL查询的值：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only changes here are the addition of the `{% load gentags %}` line and
    the addition of `replace_dashes` in the sequence of filters applied to `qdict.sql`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的变化是添加了`{% load gentags %}`一行，并在应用于`qdict.sql`的过滤器序列中添加了`replace_dashes`。
- en: 'Finally, we can remove the comment snippet from the `survey/home.html` template.
    Instead, we will put the new general snippet in the `survey/base.html` template,
    so this becomes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以从`survey/home.html`模板中删除注释片段。相反，我们将把新的通用片段放在`survey/base.html`模板中，因此变成：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Placing `{% include %}` in the base template will cause every template that
    inherits from base to automatically have the comment block added, assuming that
    the other conditions of `DEBUG` being turned on, the requesting IP address being
    listed in `INTERNAL_IPS`, and the response being rendered with a `RequestContext`,
    are met. We'd likely want to remove this before putting the application in a production
    environment, but during development it can come in handy to have easy automatic
    access to the SQL queries used to generate any page.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础模板中放置`{% include %}`将导致每个从基础模板继承的模板自动添加注释块，假设`DEBUG`被打开，请求的IP地址被列在`INTERNAL_IPS`中，并且响应被使用`RequestContext`渲染。在将应用程序放入生产环境之前，我们可能想要删除这个功能，但在开发过程中，可以方便地自动访问用于生成任何页面的SQL查询。
- en: Testing the repackaged template code
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试重新打包的模板代码
- en: 'How well does the repackaged version of the code work? If we try to reload
    our survey home page now, we will find that we have forgotten a couple of things.
    The first attempt brings up a Django debug page:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的重新打包版本效果如何？如果我们现在尝试重新加载调查主页，我们会发现我们忘记了一些东西。第一次尝试会弹出一个Django调试页面：
- en: '![Testing the repackaged template code](img/7566_08_02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![测试重新打包的模板代码](img/7566_08_02.jpg)'
- en: This is an instance of one of the special debug pages mentioned in the last
    chapter. It is a `TemplateSyntaxError` resulting from an exception being raised
    during rendering. The original exception was caught and turned into a `TemplateSyntaxError`,
    and the original traceback is shown as part of the exception value. Looking at
    that, we can see that the original exception was `TemplateDoesNotExist`. For some
    reason, the `gen_utils/showqueries.html` template file was not found by the template
    loader.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一章提到的特殊调试页面的一个实例。这是由于在渲染过程中引发了异常而导致的`TemplateSyntaxError`。原始异常被捕获并转换为`TemplateSyntaxError`，原始回溯作为异常值的一部分显示出来。通过查看原始回溯，我们可以看到原始异常是`TemplateDoesNotExist`。由于某种原因，模板加载器没有找到`gen_utils/showqueries.html`模板文件。
- en: Paging further down on the debug page received here, we learn why the template
    engine behavior of wrapping original exceptions in a `TemplateSyntaxError` can
    sometimes be aggravating. Because the exception that was ultimately raised was
    a `TemplateSyntaxError`, not a `TemplateDoesNotExist`, this debug page does not
    have the template loader postmortem that would detail exactly what template loaders
    were tried, and what files they attempted to load while searching for `gen_utils/showqueries.html`.
    So, we've lost some helpful debug information due to the way `TemplateSyntaxError`
    exceptions are used to wrap others.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里接收到的调试页面中进一步翻页，我们了解到模板引擎将原始异常包装在`TemplateSyntaxError`中的行为有时会令人恼火。因为最终引发的异常是`TemplateSyntaxError`而不是`TemplateDoesNotExist`，这个调试页面没有模板加载器事后报告，该报告将详细说明尝试了哪些模板加载器，以及它们在搜索`gen_utils/showqueries.html`时尝试加载了哪些文件。因此，由于`TemplateSyntaxError`异常用于包装其他异常的方式，我们丢失了一些有用的调试信息。
- en: If we needed to, we could force production of the template loader postmortem
    for this template file by attempting to render it directly from a view, instead
    of by including it in another template. So we could, with a little work, get the
    information that has unfortunately not been included in this particular debug
    page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要的话，我们可以通过尝试直接从视图中渲染它，而不是将其包含在另一个模板中，来强制生成此模板文件的模板加载器事后报告。因此，通过一点工作，我们可以获得这个特定调试页面中不幸未包含的信息。
- en: 'But in this case it is not necessary, since the reason for the exception is
    not particularly obscure: we didn''t do anything to ensure that the templates
    in the new `gen_utils` application would be found. We did not include `gen_utils`
    in `INSTALLED_APPS` so that its `templates` directory would be searched by the
    application template loader, nor did we put the path to the `gen_utils templates`
    directory into the `TEMPLATE_DIRS` setting. We need to do one of these things
    in order to have the new template file found. Since `gen_utils` also now has a
    filter, and in order for that to be loaded `gen_utils` will need to be in `INSTALLED_APPS`,
    we will fix the `TemplateDoesNotExist` exception by including `gen_utils` in `INSTALLED_APPS`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下并不需要，因为异常的原因并不特别隐晦：我们没有采取任何措施确保新的`gen_utils`应用程序中的模板能够被找到。我们没有将`gen_utils`包含在`INSTALLED_APPS`中，以便应用程序模板加载程序可以搜索其`templates`目录，也没有将`gen_utils模板`目录的路径放入`TEMPLATE_DIRS`设置中。我们需要做这些事情中的一件，以便找到新的模板文件。由于`gen_utils`现在也有一个过滤器，并且为了加载该过滤器，`gen_utils`需要被包含在`INSTALLED_APPS`中，我们将通过将`gen_utils`包含在`INSTALLED_APPS`中来修复`TemplateDoesNotExist`异常。
- en: 'Once we make that change, does the new code work? Not quite. Attempting to
    reload the page now brings up a different debug page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做出了这个改变，新的代码工作了吗？并没有。尝试重新加载页面现在会出现不同的调试页面：
- en: '![Testing the repackaged template code](img/7566_08_03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![测试重新打包的模板代码](img/7566_08_03.jpg)'
- en: 'This one is a little more mysterious. The displayed template is `gen_utils/showqueries.html`,
    so we have gotten farther than in the previous case. But for some reason, the
    attempt to `{% load gentags %}` is failing. The error message states:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点神秘。显示的模板是`gen_utils/showqueries.html`，所以我们比之前的情况更进一步了。但出于某种原因，尝试`{% load
    gentags %}`失败了。错误信息显示：
- en: '**''gentags'' is not a valid tag library: Could not load template library from
    django.templatetags.gentags, No module named gentags**.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**''gentags''不是有效的标签库：无法从django.templatetags.gentags加载模板库，没有名为gentags的模块**。'
- en: This is one of the rare cases where you do not want to entirely believe what
    the error message seems to be saying. It seems to be implying that the problem
    is that there is no `gentags.py` file in `django.templatetags`. A natural next
    thought may be that it is required to place custom template tag and filter libraries
    inside Django's own source tree. However, that would be a very odd requirement
    and the documentation clearly contradicts it, since it states that custom tags
    and filters should be placed in the application's `templatetags` directory. Are
    we supposed to use something other than a plain `{% load %}` tag to force Django
    to search beyond its own `templatetags` directory for a tag library?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个罕见的情况，你不希望完全相信错误消息似乎在说什么。它似乎在暗示问题是`django.templatetags`中没有`gentags.py`文件。一个自然的下一个想法可能是，需要将自定义模板标签和过滤器库放在Django自己的源树中。然而，这将是一个非常奇怪的要求，而且文档明确地与之相矛盾，因为它指出自定义标签和过滤器应该放在应用程序的`templatetags`目录中。我们应该使用除了普通的`{%
    load %}`标签以外的东西来强制Django搜索其自己的`templatetags`目录之外的标签库吗？
- en: No, in this case the error is just misleading. Although `django.templatetags`
    is the only module named in the error message, in fact the Django code attempted
    to load `gentags` from a `templatetags` directory under each application listed
    in `INSTALLED_APPS`. So the question is not why did Django fail to look for `gentags`
    under the `gen_utils/templatetags` directory, but why did an attempt to load `gentags`
    from `genutils.templatetags` fail?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这种情况下错误只是误导。尽管错误消息中只命名了`django.templatetags`模块，但实际上Django代码尝试从`INSTALLED_APPS`中列出的每个应用程序的`templatetags`目录中加载`gentags`。因此问题不在于Django为什么未能在`gen_utils/templatetags`目录下查找`gentags`，而是为什么从`genutils.templatetags`加载`gentags`失败？
- en: 'We can attempt to answer that question by trying the same code that Django
    is running during `{% load %}` from a Python shell session:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试回答这个问题，尝试在Python shell会话中运行与`{% load %}`相同的Django代码：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sure enough, an attempt to import `gentags` from `gen_utils.templatetags` is
    failing. Python claims the `templatetags` module does not exist. But the directory
    certainly exists, and `gentags.py` exists, so what is missing? The answer is an
    `__init__.py` file in that directory to make Python recognize it as a module.
    Creating that file and re-trying the import from the shell shows that the import
    will now work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，尝试从`gen_utils.templatetags`导入`gentags`失败了。Python声称`templatetags`模块不存在。但这个目录肯定是存在的，`gentags.py`也存在，那么缺少什么呢？答案是在该目录中创建一个`__init__.py`文件，使Python将其识别为一个模块。创建该文件并从shell重新尝试导入将会显示导入现在可以工作。
- en: 'However, attempting to simply reload the page in a browser causes the same
    debug page to be re-displayed. This is also one of the rare cases where the development
    server needs to be manually stopped and re-started in order for it to pick up
    on the changes made. That done, we can finally re-load the survey home page and
    see:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试在浏览器中简单地重新加载页面会导致相同的调试页面重新显示。这也是开发服务器需要手动停止和重新启动才能接受更改的罕见情况之一。完成这些操作后，我们最终可以重新加载调查首页并看到：
- en: '![Testing the repackaged template code](img/7566_08_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![测试重新打包的模板代码](img/7566_08_04.jpg)'
- en: 'We''re back to the page being served without an exception being raised, and
    there is no more stray debug information from the `sql_queries` being included
    in an HTML comment. If we look further, at the HTML source for the page, we will
    see something like the following at the bottom:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到了页面被提供而没有引发异常的情况，也不再有`sql_queries`的杂散调试信息包含在HTML注释中。如果我们进一步查看页面的HTML源代码，底部会看到类似以下内容：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That looks good. The `replace_dashes` filter successfully got rid of the two
    dashes in a row, so the browser no longer thinks the comment block was terminated
    before it was intended to be. Now we can move on to checking the SQL queries needed
    to produce the other survey pages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。`replace_dashes`过滤器成功地去掉了两个连字符，因此浏览器不再认为注释块在预期之前被终止。现在我们可以继续检查生成其他调查页面所需的SQL查询。
- en: SQL queries for the active Survey form display page
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于活动调查表单显示页面的SQL查询
- en: 'Clicking on the link to the one active survey brings up the active survey page
    for that survey:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单击链接到一个活动调查会显示该调查的活动调查页面：
- en: '![SQL queries for the active Survey form display page](img/7566_08_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![用于活动调查表单显示页面的SQL查询](img/7566_08_05.jpg)'
- en: 'Looking at the source for this page, we see that six SQL queries were needed
    to produce it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此页面的源代码，我们看到需要六个SQL查询才能生成它：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Can we match up those queries to the code used to produce the page? Yes, in
    this case it is reasonably straightforward to see where each query comes from.
    The very first query is looking up a survey based on its primary key, and corresponds
    to the `get_object_or_404` call in the very first line in the `survey_detail`
    view:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将这些查询与用于生成页面的代码进行匹配？是的，在这种情况下，可以相对容易地看到每个查询来自哪里。第一个查询是根据其主键查找调查，并对应于`survey_detail`视图中第一行中的`get_object_or_404`调用：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since this is an active survey, the thread of control then proceeds to the
    `display_active_survey` function, which contains the following code to build the
    forms for the page:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个活动调查，控制线程随后转到`display_active_survey`函数，其中包含以下代码来构建页面的表单：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The call to `enumerate(survey.question_set.all())` is responsible for the second
    SQL query for this page, which retrieves all of the questions for the survey being
    displayed. The call to `q.answer_set.count()` within the `for` loop explains the
    third and fourth SQL queries, which retrieve the count of answers for each question
    in the survey.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`enumerate(survey.question_set.all())`负责此页面的第二个SQL查询，它检索显示的调查的所有问题。`for`循环中的`q.answer_set.count()`解释了第三和第四个SQL查询，它们检索了调查中每个问题的答案计数。
- en: 'The last two queries, then, retrieve the set of answers for each question in
    the survey. We might first think that these queries are issued when the `QuestionVoteForm`
    for each question in the survey is created. The `__init__` routine for a `QuestionVoteForm`
    contains this line, to initialize the set of answers for the question:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后两个查询检索了调查中每个问题的答案集。我们可能首先认为这些查询是在创建调查中每个问题的“QuestionVoteForm”时发出的。 “QuestionVoteForm”的`__init__`例程包含此行，以初始化问题的答案集：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, that line of code does not result in a call to the database. It simply
    sets the `queryset` attribute for the form's `answer` field to a `QuerySet` value.
    Since `QuerySets` are lazy, this does not cause a database hit. This is confirmed
    by the fact that both queries that request `COUNT(*)` are issued before the queries
    that retrieve the actual answer information. If the creation of `QuestionVoteForm`
    caused the retrieval of the answer information, then the last two queries would
    not be last, but rather would be interleaved with the `COUNT(*)` queries. The
    trigger for issuing the queries that retrieve the answer information, then, is
    the rendering of the answer values in the `survey/active_survey.html` template.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该行代码并不会导致对数据库的调用。它只是将表单的`answer`字段的`queryset`属性设置为`QuerySet`值。由于`QuerySets`是惰性的，这不会导致数据库访问。这得到了证实，即请求`COUNT(*)`的两个查询是在检索实际答案信息的查询之前发出的。如果创建`QuestionVoteForm`导致检索答案信息，那么最后两个查询将不会是最后的，而是将与`COUNT(*)`查询交错。然后，触发检索答案信息的查询是在`survey/active_survey.html`模板中呈现答案值时。
- en: If we were focused on optimization, at this point we might try to see if we
    could reduce the number of queries needed for this page. Retrieving the count
    of answers and then the answer information itself in two separate queries seems
    inefficient compared to simply retrieving the answer information and deriving
    the count based on the returned information. It seems like we could produce this
    page with four queries instead of six.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们专注于优化，此时我们可能会尝试看看是否可以减少此页面所需的查询数量。在两个单独的查询中检索答案的计数，然后检索答案信息本身似乎效率低下，与仅检索答案信息并根据返回的信息推导计数相比。看起来我们可以用四个查询而不是六个查询来生成此页面。
- en: However, since we are focused on understanding the current behavior as an aid
    to debugging, we are not going to divert into an optimization discussion here.
    Even if we were developing a real project, at this point in development it would
    not be a good time to work on such optimizations. The inefficiency here is not
    so bad as to be termed a bug, so it is best just to note it as a possible thing
    to look at in the future, when a full picture of the overall performance of the
    application can be determined. At that point the inefficiencies that are the most
    expensive are the ones that will be worth taking the time to investigate improving.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们专注于理解当前行为以帮助调试，我们不会在这里转向优化讨论。即使我们正在开发一个真正的项目，在开发的这个阶段，现在不是进行此类优化的好时机。这里的低效并不糟糕到被称为错误，所以最好只是将其记录为将来可能要查看的可能事项，当可以确定应用程序的整体性能的全貌时。在那时，最昂贵的低效将值得花时间进行改进的。
- en: SQL queries for posting survey answers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布调查答案的SQL查询
- en: 'If we now choose some answers for the survey questions and press the **Submit**
    button, we get the **Thanks** page in response:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在为调查问题选择了一些答案并按下**提交**按钮，我们会收到**感谢**页面的响应：
- en: '![SQL queries for posting survey answers](img/7566_08_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![用于发布调查答案的SQL查询](img/7566_08_06.jpg)'
- en: 'Looking at the source for this page, we find a single SQL query, to retrieve
    a `survey` given the primary key:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此页面的源代码，我们发现了一个单独的SQL查询，以检索给定主键的`survey`：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The line of code associated with that query is obvious; it is the `get_object_or_404`
    in the `survey_thanks` view:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与该查询相关的代码行是显而易见的；它是`survey_thanks`视图中的`get_object_or_404`：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But what about all the SQL queries involved in processing the form data when
    it was submitted? Long before the `survey_thanks` view was called, `display_active_survey`
    must have run in order to receive the posted form data and update the database
    for the selected answers. Yet we don't see any of the SQL queries needed for that
    among the queries shown for the thanks page.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当表单数据被提交时，处理表单数据所涉及的所有SQL查询呢？在调用`survey_thanks`视图之前很久，必须运行`display_active_survey`以接收提交的表单数据并更新所选答案的数据库。然而，我们在感谢页面显示的查询中没有看到其中任何需要的SQL查询。
- en: The reason for this is because the `display_active_survey` function, in the
    case where the form processing is successful and the database is updated, does
    not render a template directly but rather returns an `HttpResponseRedirect`. The
    web browser, on receiving the HTTP redirect response, automatically fetches the
    location identified in the redirect.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是因为`display_active_survey`函数在表单处理成功并更新数据库时，不直接呈现模板，而是返回一个`HttpResponseRedirect`。Web浏览器在接收到HTTP重定向响应后，会自动获取重定向中标识的位置。
- en: Thus, there are two full request/response cycles that take place in between
    pressing the **Submit** button on the browser and seeing the thanks page appear.
    The thanks page itself can show the SQL queries that were executed during its
    (the second) request/response cycle, but it cannot show any of the ones that happened
    in the first request/response cycle.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在浏览器上按下“提交”按钮和看到感谢页面出现之间，会发生两个完整的请求/响应周期。感谢页面本身可以显示在其（第二个）请求/响应周期期间执行的SQL查询，但不能显示在第一个请求/响应周期中发生的任何查询。
- en: That's disappointing. At this point, we've gone to a fair amount of trouble
    developing what seemed at first like it was going to be a quite simple little
    bit of utility code. Now, we find that it is not going to work for some of the
    most interesting views in an application—the ones that actually update the database.
    What do we do?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这令人失望。此时，我们已经花了相当多的精力开发了一开始看起来似乎会是一个非常简单的实用程序代码。现在，我们发现它对于应用程序中一些最有趣的视图——实际上更新数据库的视图——不起作用。我们该怎么办？
- en: We certainly don't want to just give up on seeing the SQL queries for pages
    that successfully process posted data. But nor do we want to spend much more development
    effort on this utility code. Although we have learned a few things along the way,
    we've started to stray a bit too much from our main application. Fortunately,
    we don't need to do either of these. Instead, we can simply install and start
    using an already-developed general debugging tool for Django applications, the
    Django Debug Toolbar. This tool is the focus of the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然不希望放弃查看成功处理提交的数据页面的SQL查询。但我们也不希望在这个实用程序代码上花费更多的开发工作。虽然我们在这个过程中学到了一些东西，但我们开始偏离我们的主要应用程序。幸运的是，我们不需要做这两件事。相反，我们可以简单地安装并开始使用一个已经开发好的Django应用程序的通用调试工具，即Django
    Debug Toolbar。这个工具是下一节的重点。
- en: The Django Debug Toolbar
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django Debug Toolbar
- en: Rob Hudson's Django Debug Toolbar is a very useful general purpose debugging
    tool for Django applications. As with the code we developed earlier in this chapter,
    it lets you see the SQL queries that were needed to produce a page. However, as
    we will see, it also goes far beyond that, providing easy access to much more
    information about the SQL queries and other aspects of request processing. Furthermore,
    the debug toolbar has a far more advanced way of displaying the information than
    simply embedding it in HTML comments. The capabilities are best shown by example,
    so we will immediately proceed with installing the toolbar.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Rob Hudson的Django Debug Toolbar是Django应用程序的非常有用的通用调试工具。与我们在本章早些时候开发的代码一样，它可以让您看到生成页面所需的SQL查询。然而，正如我们将看到的，它远不止于此，还提供了更多关于SQL查询和请求处理的信息的简便访问。此外，调试工具栏有一种更高级的显示信息的方式，而不仅仅是将其嵌入到HTML注释中。最好通过示例来展示其功能，因此我们将立即开始安装工具栏。
- en: Installing the Django Debug Toolbar
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Django Debug Toolbar
- en: 'The toolbar can be found on the Python package index site: [http://pypi.python.org/pypi/django-debug-toolbar](http://pypi.python.org/pypi/django-debug-toolbar).
    Once installed, activating the debug toolbar in a Django project is accomplished
    with the addition of just a couple of settings.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏可以在Python软件包索引网站上找到：[http://pypi.python.org/pypi/django-debug-toolbar](http://pypi.python.org/pypi/django-debug-toolbar)。安装后，通过添加几个设置即可在Django项目中激活调试工具栏。
- en: First, the debug toolbar middleware, `debug_toolbar.middleware.DebugToolbarMiddleware`,
    must be added to the `MIDDLEWARE_CLASSES` setting. The documentation for the toolbar
    notes that it should be placed after any other middleware that encodes the response
    content, so it is best to place it last in the middleware sequence.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须将调试工具栏中间件`debug_toolbar.middleware.DebugToolbarMiddleware`添加到`MIDDLEWARE_CLASSES`设置中。工具栏的文档指出，它应该放在任何其他编码响应内容的中间件之后，因此最好将其放在中间件序列的最后。
- en: Second, the `debug_toolbar` application needs to be added to `INSTALLED_APPS`.
    The `debug_toolbar` application uses Django templates to render its information,
    thus it needs to be listed in `INSTALLED_APPS` so that its templates will be found
    by the application template loader.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，需要将`debug_toolbar`应用程序添加到`INSTALLED_APPS`中。`debug_toolbar`应用程序使用Django模板来呈现其信息，因此需要在`INSTALLED_APPS`中列出，以便应用程序模板加载程序找到它的模板。
- en: Third, the debug toolbar requires that the requesting IP address be listed in
    `INTERNAL_IPS`. Since we already made this settings change earlier in the chapter,
    nothing needs to be done now for this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，调试工具栏要求将请求的IP地址列在`INTERNAL_IPS`中。由于我们在本章早些时候已经进行了此设置更改，因此现在不需要做任何操作。
- en: Finally, the debug toolbar is displayed only when `DEBUG` is `True`. We've been
    running with debug turned on, so again we don't have to make any changes here.
    Note also that the debug toolbar allows you to customize under what conditions
    the debug toolbar is displayed. It's possible, then, to set things up so that
    the toolbar will be displayed for requesting IP addresses not in `INTERNAL_IPS`
    or when debug is not turned on, but for our purposes the default configuration
    is fine so we will not change anything.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，只有在`DEBUG`为`True`时才会显示调试工具栏。我们一直在调试模式下运行，所以这里也不需要做任何更改。还要注意调试工具栏允许您自定义调试工具栏显示的条件。因此，可以设置工具栏在请求IP地址不在`INTERNAL_IPS`中或调试未打开时显示，但对于我们的目的，默认配置就可以了，所以我们不会做任何更改。
- en: One thing that is not required is for the application itself to use a `RequestContext`
    in order for things such as the SQL query information to be available in the toolbar.
    The debug toolbar runs as middleware, and thus is not dependent on the application
    using a `RequestContext` in order for it to generate its information. Thus, the
    changes made to the survey views to specify `RequestContexts` on `render_to_response`
    calls would not have been needed if we started off first with the Django Debug
    Toolbar.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要的一件事是应用程序本身使用`RequestContext`以便在工具栏中提供SQL查询信息等。调试工具栏作为中间件运行，因此不依赖于应用程序使用`RequestContext`来生成信息。因此，如果我们一开始就使用Django调试工具栏，就不需要对调查视图进行更改以在`render_to_response`调用上指定`RequestContext`。
- en: Debug toolbar appearance
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试工具栏外观
- en: 'Once the debug toolbar is added to the middleware and installed applications
    settings, we can see what it looks like by simply visiting any page in the survey
    application. Let''s start with the home page. The returned page should now look
    something like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调试工具栏添加到中间件和已安装应用程序设置中，我们可以通过简单地访问调查应用程序中的任何页面来看看它的外观。让我们从主页开始。返回的页面现在应该看起来像这样：
- en: '![Debug toolbar appearance](img/7566_08_07.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![调试工具栏外观](img/7566_08_07.jpg)'
- en: Note this screenshot shows the appearance of the 0.8.0 version of the debug
    toolbar. Earlier versions looked considerably different, so if your results do
    not look like this you may be using a different version than 0.8.0\. The version
    that you have will most likely be newer than what was available when this was
    written, and there may be additional toolbar panels or functions that are not
    covered here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此截图显示了调试工具栏0.8.0版本的外观。早期版本看起来会有很大不同，所以如果您的结果不像这样，您可能使用的是不同于0.8.0版本的版本。您拥有的版本很可能比写作时可用的版本更新，可能有其他工具栏面板或功能没有在这里介绍。
- en: As you can see, the debug toolbar appears on the right-hand side of the browser
    window. It consists of a series of panels that can be individually enabled or
    disabled by changing the toolbar configuration. The ones shown here are the ones
    that are enabled by default.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调试工具栏出现在浏览器窗口的右侧。它由一系列面板组成，可以通过更改工具栏配置单独启用或禁用。这里显示的是默认启用的面板。
- en: 'Before taking a closer look at some of the individual panels, notice that the
    toolbar contains an option to hide it at the top. If **Hide** is selected, the
    toolbar reduces itself to a small tab-like indication to show that it is present:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在更仔细地查看一些单独面板之前，请注意工具栏顶部包含一个隐藏选项。如果选择**隐藏**，工具栏会缩小到一个类似标签的指示，以显示其存在：
- en: '![Debug toolbar appearance](img/7566_08_08.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![调试工具栏外观](img/7566_08_08.jpg)'
- en: This can be very useful for cases where the expanded version of the toolbar
    obscures application content on the page. All of the information provided by the
    toolbar is still accessible, after clicking again on the **DjDT** tab; it is just
    out of the way for the moment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于工具栏的扩展版本遮挡页面上的应用程序内容的情况非常有用。单击**DjDT**标签后，工具栏提供的所有信息仍然可以访问；它只是暂时不可见。
- en: Most of the panels will provide detailed information when they are clicked.
    A few also provide summary information in the main toolbar display. As of debug
    toolbar version 0.8.0, the first panel listed, **Django Version**, only provides
    summary information. There is no more detailed information available by clicking
    on it. As you can see in the screenshot, Django 1.1.1 is the version in use here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面板在单击时会提供详细信息。一些还会在主工具栏显示中提供摘要信息。从调试工具栏版本0.8.0开始，列出的第一个面板**Django版本**只提供摘要信息。单击它不会提供更详细的信息。如您在截图中所见，这里使用的是Django
    1.1.1版本。
- en: Note that the current latest source version of the debug toolbar already provides
    more information for this panel than the 0.8.0 release. Since 0.8.0, this panel
    has been renamed to **Versions**, and can be clicked to provide more details.
    These additional details include version information for the toolbar itself and
    for any other installed Django applications that provide version information.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，调试工具栏的当前最新源版本已经为此面板提供了比0.8.0版本更多的信息。自0.8.0以来，此面板已更名为**版本**，可以单击以提供更多详细信息。这些额外的详细信息包括工具栏本身的版本信息以及为提供版本信息的任何其他已安装的Django应用程序的版本信息。
- en: The other three panels that show summary information are the **Time**, **SQL**,
    and **Logging** panels. Thus, we can see at a glance from the first appearance
    of the page that 60 milliseconds of CPU time were used to produce this page (111
    milliseconds total elapsed time), that the page required four queries, which took
    1.95 milliseconds, and that zero messages were logged during the request.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显示摘要信息的另外三个面板是**时间**、**SQL**和**日志**面板。因此，我们可以一眼看出页面的第一次出现使用了60毫秒的CPU时间（总共用了111毫秒的时间），页面需要了四个查询，花费了1.95毫秒，请求期间没有记录任何消息。
- en: In the following sections, we will dig into exactly what information is provided
    by each of the panels when clicked. We'll start first with the SQL panel, since
    it is one of the most interesting and provides the same information (in addition
    to a lot more) that we worked earlier in this chapter to access on our own.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入研究每个面板在点击时提供的具体信息。我们将首先从SQL面板开始，因为它是最有趣的之一，并且提供了我们在本章前面努力自己获取的相同信息（以及更多信息）。
- en: The SQL panel
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL面板
- en: 'If we click on the **SQL** section of the debug toolbar, the page will change
    to:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击调试工具栏的**SQL**部分，页面将会变成：
- en: '![The SQL panel](img/7566_08_09.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![SQL面板](img/7566_08_09.jpg)'
- en: At a glance, this is a much nicer display of the SQL queries for the page than
    what we came up with earlier. The queries themselves are highlighted so that SQL
    keywords stand out, making them easier to read. Also, since they are not embedded
    inside an HTML comment, their content does not need to be altered in any way—there
    was no need to change the content of the query containing the double dash in order
    to avoid it causing display problems. (Now would probably be a good time to remove
    that added query, before we forget why we added it.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个SQL查询页面比我们之前想出的要好得多。查询本身被突出显示，使SQL关键字更容易阅读。而且，由于它们不是嵌入在HTML注释中，它们的内容不需要以任何方式进行修改——没有必要改变包含双破折号的查询内容，以避免它引起显示问题。（现在可能是一个好时机，在我们忘记为什么添加它之前，删除那个额外的查询。）
- en: Notice also that the times listed for each query are more specific than what
    was available in Django's default query history. The debug toolbar replaces Django's
    query recording with its own, and provides timings in units of milliseconds instead
    of seconds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，每个查询所列的时间比Django默认查询历史中提供的更具体。调试工具栏用自己的查询记录替换了Django的查询记录，并以毫秒为单位提供时间，而不是秒。
- en: The display also includes a graphical representation of how long each query
    took, in the form of horizontal bars that appear above each query. This representation
    makes it easy to see when there are one or more queries that are much more expensive
    than the others. In fact, if a query takes an excessive amount of time, its bar
    will be colored red. In this case, there is not a great deal of difference in
    the query times, and none took particularly long, so all the bars are of similar
    length, and are colored gray.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显示还包括了每个查询所花费时间的图形表示，以水平条形图的形式出现在每个查询的上方。这种表示使人们很容易看出是否有一个或多个查询比其他查询要昂贵得多。实际上，如果一个查询花费的时间过长，它的条形图将会变成红色。在这种情况下，查询时间没有太大的差异，没有一个特别长，所以所有的条形图长度都差不多，并且呈灰色。
- en: 'Digging deeper, some of the information we had to manually figure out earlier
    in this chapter is just a click away on this SQL query display. Specifically,
    the answer to the question of what line of our code triggered a particular SQL
    query to be issued. Each of the displayed queries has a **Toggle Stacktrace**
    option, which when clicked will show the stack trace associated with the query:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入地挖掘，我们在本章前面手动找出的一些信息在这个SQL查询显示中只需点击一下就可以得到。具体来说，我们可以得到我们的代码中触发特定SQL查询的行号。每个显示的查询都有一个**切换堆栈跟踪**选项，点击后将显示与查询相关联的堆栈跟踪：
- en: '![The SQL panel](img/7566_08_10.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![SQL面板](img/7566_08_10.jpg)'
- en: Here we can see that all queries are made by the `home` method in the survey
    `views.py` file. Note that the toolbar filters out levels in the stack trace that
    are within Django itself, which explains why each of these has only one level
    shown. The first query is triggered by **Line 61**, which contains the `filter`
    call added to test what will happen if a query containing two dashes in a row
    was logged. The remaining queries are all attributed to **Line 66**, which is
    the last line of the `render_to_response` call in the `home` view. These queries,
    as we figured out earlier, are all made during the rendering of the template.
    (Your line numbers may vary from those shown here, depending on where in the file
    various functions were placed.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到所有的查询都是由调查`views.py`文件中的`home`方法发起的。请注意，工具栏会过滤掉Django本身的堆栈跟踪级别，这就解释了为什么每个查询只显示了一个级别。第一个查询是由**第61行**触发的，其中包含了添加的`filter`调用，用于测试如果记录了一个包含两个连字符的查询会发生什么。其余的查询都归因于**第66行**，这是`home`视图中`render_to_response`调用的最后一行。正如我们之前发现的那样，这些查询都是在模板渲染期间进行的。（您的行号可能与此处显示的行号不同，这取决于文件中各种函数的放置位置。）
- en: 'Finally, this SQL query display makes available information that we had not
    even gotten around to wanting yet. Under the **Action** column are links to **SELECT**,
    **EXPLAIN**, and **PROFILE** each query. Clicking on the **SELECT** link shows
    what the database returns when the query is actually executed. For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个SQL查询显示提供了一些我们甚至还没有想到要的信息。在**操作**列下面是每个查询的**SELECT**，**EXPLAIN**和**PROFILE**链接。点击**SELECT**链接会显示数据库在实际执行查询时返回的内容。例如：
- en: '![The SQL panel](img/7566_08_11.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![SQL面板](img/7566_08_11.jpg)'
- en: Similarly, clicking on **EXPLAIN** and **PROFILE** displays what the database
    reports when asked to explain or profile the selected query, respectively. The
    exact display, and how to interpret the results, will differ from database to
    database. (In fact, the **PROFILE** option is not available with all databases—it
    happens to be supported by the database in use here, MySQL.) Interpreting the
    results from **EXPLAIN** and **PROFILE** is beyond the scope of what's covered
    here, but it is useful to know that if you ever need to dig deep into the performance
    characteristics of a query, the debug toolbar makes it easy to do so.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，点击**EXPLAIN**和**PROFILE**会显示数据库在被要求解释或分析所选查询时的报告。确切的显示和结果解释将因数据库而异。（事实上，**PROFILE**选项并不适用于所有数据库——它恰好受到了这里使用的数据库，MySQL的支持。）解释**EXPLAIN**和**PROFILE**的结果超出了本文所涵盖的范围，但值得知道的是，如果您需要深入了解查询的性能特征，调试工具栏可以轻松实现这一点。
- en: We've now gotten a couple of pages deep into the SQL query display. How do we
    get back to the actual application page? Clicking on the circled **>>** at the
    upper-right of the main page display will return to the previous SQL query page,
    and the circled **>>** will turn into a circled **X**. Clicking the circled **X**
    on any panel detail page closes the details and returns to displaying the application
    data. Alternatively, clicking again on the panel area on the toolbar for the currently
    displayed panel will have the same effect as clicking on the circled symbol in
    the display area. Finally, if you prefer using the keyboard to the mouse, pressing
    *Esc* has the same effect as clicking the circled symbol.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经深入了几页SQL查询显示。我们如何返回到实际应用程序页面？单击主页显示右上角的圈起来的“>>”将返回到上一个SQL查询页面，并且圈起来的“>>”将变成圈起来的“X”。单击任何面板详细信息页面上的圈起来的“X”将关闭详细信息并返回到显示应用程序数据。或者，再次单击工具栏上当前显示面板的面板区域将产生与在显示区域上单击圈起来的符号相同的效果。最后，如果您更喜欢使用键盘而不是鼠标，按下*Esc*将产生与单击圈起来的符号相同的效果。
- en: Now that we have completely explored the SQL panel, let's take a brief look
    at each of the other panels provided by the debug toolbar.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全探索了SQL面板，让我们简要地看一下调试工具栏提供的其他面板。
- en: The Time panel
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间面板
- en: 'Clicking on the **Time** panel brings up more detailed information on where
    time was spent during production of the page:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“时间”面板会显示有关页面生成期间时间花费的更详细信息：
- en: '![The Time panel](img/7566_08_12.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![时间面板](img/7566_08_12.jpg)'
- en: The total CPU time is split between user and system time, the total elapsed
    (wall clock) time is listed, and the number of voluntary and involuntary context
    switches are displayed. For a page that is taking too long to generate, these
    additional details about where the time is being spent can help point towards
    a cause.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总CPU时间分为用户和系统时间，列出了总经过的（挂钟）时间，并显示了自愿和非自愿的上下文切换次数。对于生成时间过长的页面，关于时间花费在哪里的额外细节可以帮助指向原因。
- en: Note that the detailed information provided by this panel comes from the Python
    `resource` module. This is a Unix-specific Python module that is not available
    on non-Unix-type systems. Thus on Windows, for example, the debug toolbar time
    panel will only show summary information, and no further details will be available.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此面板提供的详细信息来自Python的`resource`模块。这是一个特定于Unix的Python模块，在非Unix类型系统上不可用。因此，在Windows上，例如，调试工具栏时间面板只会显示摘要信息，没有更多的详细信息可用。
- en: The Settings panel
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置面板
- en: Clicking on **Settings** brings up a scrollable display of all the settings
    in effect. The code used to create this display is identical to the code used
    to display the settings on a Django debug page, so the display here will be identical
    to what you would see on a debug page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“设置”会显示所有生效设置的可滚动显示。用于创建此显示的代码与用于在Django调试页面上显示设置的代码相同，因此这里的显示将与您在调试页面上看到的相同。
- en: The HTTP Headers panel
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP头面板
- en: 'Clicking on **HTTP Headers** brings up a display of all the HTTP headers for
    the request:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“HTTP头”会显示请求的所有HTTP头：
- en: '![The HTTP Headers panel](img/7566_08_13.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP头面板](img/7566_08_13.jpg)'
- en: This is a subset of the information available in the **META** section of a debug
    page. As mentioned in the previous chapter, the `request.META` dictionary contains
    all of the HTTP headers for a request in addition to other information that has
    nothing to do with the request, since `request.META` is initially copied from
    the `os.environ` dictionary. The debug toolbar has chosen to filter the displayed
    information to include only information pertinent to the HTTP request, as shown
    in the screenshot.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调试页面“META”部分中可用信息的子集。如前一章所述，`request.META`字典包含请求的所有HTTP头，以及与请求无关的其他信息，因为`request.META`最初是从`os.environ`字典中复制的。调试工具栏选择过滤显示的信息，以包括仅与HTTP请求相关的信息，如屏幕截图所示。
- en: The Request Vars panel
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求变量面板
- en: 'Clicking on **Request Vars** brings up a display of cookies, session variables,
    GET variables, and POST data for the request. Since the survey application home
    page doesn''t have any information to display for any of those, the **Request
    Vars** display for it is not very interesting. Instead, here is an example from
    the admin application, which does use a session, and so it actually has something
    to display:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“请求变量”会显示请求的cookie、会话变量、GET变量和POST数据。由于调查应用程序主页没有任何信息可显示，因此它的“请求变量”显示并不是很有趣。相反，这里是来自管理员应用程序的一个示例，它确实使用了会话，因此实际上有一些东西可以显示：
- en: '![The Request Vars panel](img/7566_08_14.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![请求变量面板](img/7566_08_14.jpg)'
- en: Here you can see the `sessionid` cookie that was set as a result of the admin
    application using the `django.contrib.sessions` application, and you can also
    see the individual session variables that have been set in the session.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到由于管理员应用程序使用了`django.contrib.sessions`应用程序而设置的`sessionid` cookie，并且还可以看到已在会话中设置的各个会话变量。
- en: The Templates panel
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板面板
- en: 'Clicking on **Templates** brings up a display of information about template
    processing for the request. Returning to the survey home page as an example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“模板”会显示有关请求的模板处理的信息。以调查主页为例：
- en: '![The Templates panel](img/7566_08_15.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![模板面板](img/7566_08_15.jpg)'
- en: The **Template paths** section lists the paths specified in the `TEMPLATE_DIRS`
    setting; since we have not added anything to that setting, it is empty.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: “模板路径”部分列出了“TEMPLATE_DIRS”设置中指定的路径；由于我们没有向该设置添加任何内容，因此它为空。
- en: The **Templates** section shows all of the templates rendered for the response.
    Each template is listed, showing the name specified by the application for rendering
    first. Clicking on this name will bring up a display of the actual template file
    contents. Under the application-specified name is the full file path for the template.
    Finally, each template also has a **Toggle Context** link that can be used to
    see the details of the context used by each of the rendered templates.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**部分显示了响应渲染的所有模板。列出了每个模板，显示了应用程序指定的首次渲染的名称。单击此名称将显示实际模板文件内容的显示。在应用程序指定的名称下是模板的完整文件路径。最后，每个模板还有一个**切换上下文**链接，可用于查看每个已呈现模板使用的上下文的详细信息。'
- en: The **Context processors** section shows all of the installed context processors.
    Under each is a **Toggle Context** link that when clicked will show the context
    variables that the associated context processor adds to the context.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文处理器**部分显示了所有安装的上下文处理器。在每个下面都有一个**切换上下文**链接，单击后将显示相关上下文处理器添加到上下文中的上下文变量。'
- en: Note that the context processors are listed regardless of whether the application
    used a `RequestContext` to render the response. Thus, their being listed on this
    page does not imply that the variables they set were added to the context for
    this particular response.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论应用程序是否使用`RequestContext`来呈现响应，上下文处理器都会被列出。因此，它们在此页面上列出并不意味着它们设置的变量被添加到此特定响应的上下文中。
- en: The Signals panel
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号面板
- en: 'Clicking on **Signals** brings up a display of the signal configuration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**Signals**会显示信号配置的显示：
- en: '![The Signals panel](img/7566_08_16.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![信号面板](img/7566_08_16.jpg)'
- en: All of the defined Django signals are listed. For each, the arguments provided
    are shown along with the receivers that have been connected to the signal.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了所有定义的Django信号。对于每个信号，都显示了提供的参数以及已连接到该信号的接收器。
- en: Note that this display does not indicate anything about what signals were actually
    triggered during the production of the current page. It simply shows how the signals
    are configured.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此显示不表示当前页面生成过程中实际触发了哪些信号。它只显示信号的配置方式。
- en: The Logging panel
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志面板
- en: Finally, the **Logging** panel shows any messages sent via Python's `logging`
    module during the course of the request processing. Since we have not yet investigated
    using logging in the survey application, and since as of Django 1.1, Django itself
    does not use the Python logging module, there is nothing for us to see on this
    panel yet.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**日志**面板显示了在请求处理过程中通过Python的`logging`模块发送的任何消息。由于我们尚未调查在调查应用程序中使用日志记录，并且自Django
    1.1以来，Django本身不使用Python日志记录模块，因此在此面板上我们没有看到任何内容。
- en: Redirect handling by the debug toolbar
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试工具栏处理重定向
- en: 'Now recall the reason we started investigating the debug toolbar: we found
    that our original approach to tracking SQL queries for a page did not work for
    pages that returned an HTTP redirect instead of rendering a template. How does
    the debug toolbar handle this better? To see this, click on the **Television Trends**
    link on the home page, select answers for the two questions, and press **Submit**.
    The result will be:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回想一下我们开始调查调试工具栏的原因：我们发现我们最初用于跟踪页面的SQL查询的方法对于返回HTTP重定向而不是呈现模板的页面不起作用。调试工具栏如何更好地处理这个问题？要了解这一点，请单击主页上的**Television
    Trends**链接，为两个问题选择答案，然后单击**提交**。结果将是：
- en: '![Redirect handling by the debug toolbar](img/7566_08_17.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![调试工具栏处理重定向](img/7566_08_17.jpg)'
- en: 'This page shows an example of why it is sometimes necessary to use the **Hide**
    option on the toolbar, since the toolbar itself obscures part of the message on
    the page. Hiding the toolbar shows that the full message is:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面显示了为什么有时需要在工具栏上使用**隐藏**选项的示例，因为工具栏本身遮挡了页面上的部分消息。隐藏工具栏后，可以看到完整的消息是：
- en: '**The Django Debug Toolbar has intercepted a redirect to the above URL for
    debug viewing purposes. You can click the above link to continue with the redirect
    as normal. If you''d like to disable this feature, set the DEBUG_TOOLBAR_CONFIG
    dictionary''s key INTERCEPT_REDIRECTS to False.**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django调试工具栏已拦截重定向到上述URL以进行调试查看。您可以单击上面的链接以继续进行正常的重定向。如果要禁用此功能，请将DEBUG_TOOLBAR_CONFIG字典的键INTERCEPT_REDIRECTS设置为False。**'
- en: 'What the debug toolbar has done here is intercepted the redirect request and
    replaced it with a rendered response containing a link to the location specified
    in the original redirect. The toolbar itself is still in place and available to
    investigate whatever information we might like to see about the processing of
    the request that generated the redirect. For example, we can click on the **SQL**
    section and see:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 调试工具栏在这里所做的是拦截重定向请求，并用包含原始重定向指定位置的渲染响应替换它。工具栏本身仍然存在，并可用于调查我们可能希望查看有关生成重定向的请求处理的任何信息。例如，我们可以单击**SQL**部分并查看：
- en: '![Redirect handling by the debug toolbar](img/7566_08_18.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![调试工具栏处理重定向](img/7566_08_18.jpg)'
- en: These are the SQL queries that were needed to process the inbound posted form.
    Not surprisingly, the first four are exactly the same as what we saw for generating
    the form in the first place, since the same code path is initially followed for
    both GET and POST requests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是处理传入的表单所需的SQL查询。毫不奇怪，前四个与我们首次生成表单时看到的完全相同，因为最初对GET和POST请求都遵循相同的代码路径。
- en: 'It is only after those queries are issued that the `display_active_survey`
    view has different code paths for GET and POST. Specifically, in the case of a
    POST, the code is:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在发出这些查询之后，`display_active_survey`视图才对GET和POST有不同的代码路径。具体来说，在POST的情况下，代码是：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The fifth and sixth queries listed on this page are retrieving the specific
    answer instances that were selected on the submitted form. Unlike the GET case,
    where all answers for a given question were being retrieved in the fifth and sixth
    queries, these queries specify an answer `id` in the SQL WHERE clause as well
    as a question `id`. In the POST case, it is not necessary to retrieve all answers
    for a question; it is sufficient to retrieve only the one that was chosen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面上列出的第五和第六个查询正在检索在提交的表单上选择的特定答案实例。与GET情况不同，在第五和第六个查询中检索了给定问题的所有答案，这些查询还在SQL
    WHERE子句中指定了答案`id`以及问题`id`。在POST情况下，不需要检索问题的所有答案；只需要检索选择的那个答案即可。
- en: Toggling the stack trace for these queries shows that they are resulting from
    the `if not qf.is_valid()` line of code. This makes sense, since in addition to
    validating the input, the `is_valid` method normalizes the posted data before
    placing it in the form's `cleaned_data` attribute. In the case of a `ModelChoiceField`,
    the normalized value is the chosen model object instance, so it is necessary for
    the validation code to retrieve the chosen object from the database.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 切换这些查询的堆栈跟踪显示它们是由代码的`if not qf.is_valid()`行导致的。这是有道理的，因为除了验证输入外，`is_valid`方法还会将发布的数据标准化，然后将其放入表单的`cleaned_data`属性中。对于`ModelChoiceField`，标准化值是所选的模型对象实例，因此验证代码需要从数据库中检索所选对象。
- en: 'After both submitted forms are found to be valid, the `else` leg of this code
    runs. Here, the vote count for each chosen answer is incremented, and the updated
    `answer` instance is saved to the database. This code, then, must be responsible
    for the final four queries previously shown. This can be confirmed by checking
    the stack trace for those four queries: all point to the `answer.save()` line
    of code.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现两个提交的表单都有效之后，此代码的`else`部分运行。在这里，每个选择的答案的投票计数都会增加，并且更新的`answer`实例将保存到数据库中。然后，这段代码必须负责之前显示的最后四个查询。可以通过检查这四个查询的堆栈跟踪来确认：所有指向代码的`answer.save()`行。
- en: But why are four SQL statements, two SELECT and two UPDATE, needed to save two
    answers to the database? The UPDATE statements are self-explanatory, but the SELECT
    statements that precede them are a bit curious. In each case, the constant 1 is
    selected from the `survey_answer` table with a WHERE clause specifying a primary
    key value that matches the `survey` that is in the process of being saved. What
    is the intent of this query?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么需要四个SQL语句，两个SELECT和两个UPDATE，来保存两个答案到数据库中？UPDATE语句是不言自明的，但是在它们之前的SELECT语句有点奇怪。在每种情况下，都从`survey_answer`表中选择常量1，并使用WHERE子句指定与正在保存的`survey`匹配的主键值。这个查询的目的是什么？
- en: What the Django code is doing here is attempting to determine if the `answer`
    being saved already exists in the database or if it is new. Django can tell by
    whether any results are returned from the SELECT if it needs to use an UPDATE
    or an INSERT when saving the model instance to the database. Selecting the constant
    value is more efficient than actually retrieving the result when the only information
    needed is whether the result exists.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Django代码在这里所做的是尝试确定正在保存的`answer`是否已经存在于数据库中，或者是新的。Django可以通过从SELECT返回任何结果来判断在将模型实例保存到数据库时是否需要使用UPDATE或INSERT。选择常量值比实际检索结果更有效，当唯一需要的信息是结果是否存在时。
- en: You might think the Django code should know, just based on the fact that the
    primary key value is already set for the model instance, that the instance reflects
    data that is already in the database. However, Django models can use manually-assigned
    primary key values, so the fact that the primary key value has been assigned does
    not guarantee the model has already been saved to the database. Therefore, there
    is an extra SELECT to determine the model status before saving the data.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为Django代码应该知道，仅基于模型实例的主键值已经设置，该实例反映的数据已经在数据库中。但是，Django模型可以使用手动分配的主键值，因此分配了主键值并不保证模型已经保存到数据库中。因此，在保存数据之前需要额外的SELECT来确定模型的状态。
- en: 'The survey application code, though, certainly knows that all of the `answer`
    instances it is saving when processing a survey response are already saved in
    the database. When saving, the survey code can indicate that the instance must
    be saved via an UPDATE and not an INSERT by specifying `force_update` on the save
    call:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，调查应用程序代码肯定知道在处理调查响应时保存的所有`answer`实例已经保存在数据库中。在保存时，调查代码可以通过在保存调用上指定`force_update`来指示必须通过UPDATE而不是INSERT保存实例：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we make that change and try submitting another survey, we see that the SELECT
    queries have been eliminated from processing for this case, reducing the total
    number of queries needed from 10 to 8:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行更改并尝试提交另一个调查，我们会发现对于这种情况，处理中已经消除了SELECT查询，从而将所需的总查询数量从10减少到8：
- en: '![Redirect handling by the debug toolbar](img/7566_08_19.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![调试工具栏的重定向处理](img/7566_08_19.jpg)'
- en: (Yes, I realize that earlier I said now was not the time for making optimizations,
    yet here I went ahead and made one. This one was just too easy to pass up.)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: （是的，我意识到之前我说现在不是进行优化的时候，但是我还是进行了一次。这次实在是太容易了。）
- en: 'We have now covered all of the panels displayed by default by the Django Debug
    Toolbar, and seen how its default handling of returned redirects allows investigation
    of the processing that led up to the redirect. It is a very flexible tool: it
    supports adding panels, changing what panels are displayed, changing when the
    toolbar is displayed, and configuration of various other options. Discussing all
    of this is beyond the scope of what is covered here. Hopefully what has been covered
    gives you a taste for the power of this tool. If you are interested in learning
    more details on how to configure it, the README linked from its home page is a
    good place to start.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了Django Debug Toolbar默认显示的所有面板，并看到了它默认处理返回重定向的方式，允许调查导致重定向的处理过程。它是一个非常灵活的工具：它支持添加面板，更改显示的面板，更改工具栏显示的时间，以及配置各种其他选项。讨论所有这些超出了本文的范围。希望所介绍的内容让您对这个工具的强大功能有所了解。如果您有兴趣了解如何配置它的更多细节，可以从其主页链接的README开始。
- en: For now we will leave the Django Debug Toolbar and continue with a discussion
    of how to track the internal state of our application code through logging. For
    this we will want to first see how the logging appears without the toolbar, so
    at this point we should comment out the toolbar middleware in `settings.py`. (Note
    that it is not necessary to remove the `debug_toolbar` listing from `INSTALLED_APPS`,
    since this is only necessary for the application template loader to find templates
    specified by the middleware.)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将离开Django Debug Toolbar，继续讨论如何通过日志跟踪应用程序代码的内部状态。为此，我们首先要看看没有工具栏时日志是如何显示的，因此此时我们应该在`settings.py`中注释掉工具栏中间件。（请注意，不需要从`INSTALLED_APPS`中删除`debug_toolbar`列表，因为这只是必须为应用程序模板加载器找到中间件指定的模板。）
- en: Tracking internal code state
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪内部代码状态
- en: Sometimes even all of the information available from a tool like the Django
    Debug Toolbar is not enough to figure out what is going wrong to produce incorrect
    results during processing of a request. The problem probably lies somewhere in
    the application code, but from visual inspection we just cannot figure out what
    is wrong. To solve the problem we need to get more information about the internal
    state of the application code. Perhaps we need to see what the flow of control
    is through the functions in the application, or see what values are calculated
    for some intermediate results that ultimately cause the code to go down a wrong
    path.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使从像Django Debug Toolbar这样的工具中获得的所有信息也不足以弄清楚在处理请求过程中出现错误产生不正确结果的原因。问题可能在应用程序代码的某个地方，但从视觉检查中我们无法弄清楚出了什么问题。为了解决问题，我们需要获取有关应用程序代码内部状态的更多信息。也许我们需要看看应用程序中函数的控制流是什么，或者看看为一些最终导致代码走上错误路径的中间结果计算出了什么值。
- en: How do we get this kind of information? One way is to run the code under a debugger,
    and actually step through it line by line to see what it is doing. This approach
    will be covered in detail in the next chapter. It is very powerful, but can be
    time-consuming and is not practical in all situations. For example, it is difficult
    to use for problems that crop up only during production.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获得这种信息？一种方法是在调试器下运行代码，并逐行执行以查看它在做什么。这种方法将在下一章中详细介绍。这是非常强大的，但可能会耗费时间，在某些情况下并不实用。例如，对于只在生产过程中出现的问题，很难使用。
- en: Another way is to get the code to report, or log, what it is doing. This is
    the approach that will be covered in this section. This approach does not provide
    access to the full range of information that would be available under a debugger,
    but with good choices of what to log, it can provide enough clues to solve many
    problems. It can also be used more easily for production-only problems than the
    approach of running under a debugger.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是让代码报告或记录它在做什么。这是本节将要介绍的方法。这种方法并不能提供在调试器下可用的全部信息，但通过选择要记录的内容，它可以提供足够的线索来解决许多问题。它也可以更容易地用于仅在生产过程中出现的问题，而不像在调试器下运行的方法那样。
- en: Resist the urge to sprinkle prints
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抵制洒播打印的冲动
- en: When running under the development server, the output from `print` appears on
    the console, so it is easily accessible. Thus, when faced with some Django application
    code that is misbehaving during development, it is tempting to simply start adding
    ad-hoc `print` statements at key points in an attempt to figure out what is going
    on inside the code. While very tempting, it is usually a bad idea.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发服务器下运行时，`print`的输出会显示在控制台上，因此很容易访问。因此，当面对一些在开发过程中表现不佳的Django应用程序代码时，很容易就会诱惑地在关键点添加临时的`print`语句，试图弄清楚代码内部发生了什么。虽然非常诱人，但通常是一个坏主意。
- en: Why is it a bad idea? First, the problem rarely becomes obvious with just one
    or two `print` statements. It may seem at first that if we just know if the code
    gets to here or there, all will be clear. But it isn't, and we wind up adding
    more and more `print` statements, perhaps printing out values of variables, and
    both the code itself and the development server console become a mess of ad-hoc
    debug information.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这是一个坏主意？首先，问题很少会仅凭一个或两个`print`语句就变得明显。起初似乎只要知道代码是否到达这里或那里，一切都会变得清晰。但事实并非如此，我们最终会添加更多的`print`语句，也许打印出变量的值，代码本身和开发服务器控制台都变成了临时调试信息的一团糟。
- en: Then, once the problem is solved, all of those `print` statements need to be
    removed. We generally don't want them cluttering up either the code or the console
    with their output. Removing them all is a nuisance, but necessary, since some
    production environments disallow access to `sys.stdout`. Thus, a stray `print`
    left over from development debugging can cause a server error during production.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦问题解决了，所有那些`print`语句都需要被移除。我们通常不希望它们在代码或控制台中弄乱输出。移除它们都是一件麻烦事，但是必要的，因为一些生产环境不允许访问`sys.stdout`。因此，从开发调试中留下的`print`可能会在生产过程中导致服务器错误。
- en: Then, when the same or a similar problem comes up again, and it was solved in
    the past by the "sprinkle `print`" method, virtually all of the work done before
    may need to be re-done again in order to figure out what is wrong this time. The
    previous experience might give us a better idea of what `print` statements to
    put where, but if we've already deleted them after solving the first problem,
    a fair amount of work may be involved in re-doing essentially the same thing for
    the next variant of the problem that arises. This is a waste of effort.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当出现相同或类似的问题时，如果以前通过“sprinkle `print`”方法解决了问题，那么几乎所有之前的工作可能需要重新做，以便找出这次出了什么问题。以前的经验可能会给我们一个更好的主意，即在哪里放置`print`语句，但如果在解决第一个问题后已经删除了它们，那么可能需要重新做基本相同的工作，以解决出现的下一个问题变体。这是一种浪费。
- en: This sequence highlights a few main problems with the "sprinkle `print`" method
    of development debugging. First, the developer needs to decide, right at the point
    where the `print` is added, under what conditions it should be produced and where
    the output should go. It's possible to bracket added `print` statements with conditionals
    such as `if settings.DEBUG`, which might allow the added debugging support to
    remain in the code long-term, but this is a nuisance and adds clutter to the code,
    so it tends not to be done. It's also possible to specify in the `print` that
    the output should be routed someplace other than the default of `sys.stdout`,
    but again that is more work and tends not to be done.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列突出了“sprinkle `print`”方法在开发调试中的一些主要问题。首先，开发人员需要在添加`print`的地方立即决定在什么条件下它应该被产生以及输出应该去哪里。可以使用条件语句（如`if
    settings.DEBUG`）来给添加的`print`语句加上括号，这可能允许添加的调试支持长期保留在代码中，但这很麻烦并且会给代码增加杂乱，因此通常不会这样做。也可以在`print`中指定输出应该被路由到除了默认的`sys.stdout`之外的其他地方，但同样这需要更多的工作，通常也不会这样做。
- en: These problems lead to sprinkled `print` statements that are immediately removed
    when a problem is solved, leaving the code in a state where by default it reports
    nothing about its operation. Then when the next problem occurs, the developer
    has to start all over again with adding reporting of debug information.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题导致了“sprinkle `print`”语句的出现，当问题解决后立即被删除，使得代码默认情况下不报告其操作。然后，当下一个问题出现时，开发人员必须重新开始添加调试信息的报告。
- en: A far better approach is to use some disciplined logging throughout development,
    so that by default, at least when `DEBUG` is turned on, the code reports something
    about what it is doing. If it does so, then it is quite possible that no additional
    debug information needs to be collected in order to solve problems that crop up.
    Furthermore, use of a logging facility allows for the configuration of under what
    conditions messages should be output, and where they should go, to be separated
    from the actual logging statements.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是在开发过程中使用一些有纪律的日志记录，这样，至少在`DEBUG`被打开时，默认情况下，代码会报告它正在做什么。如果是这样，那么很可能不需要收集额外的调试信息来解决出现的问题。此外，使用日志记录设施允许配置在什么条件下输出消息，以及它们应该去哪里，与实际的日志记录语句分开。
- en: Simple logging configuring for development
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发的简单日志配置
- en: 'A preferred alternative to `print` statements for debugging, then, is to use
    the python `logging` module. The actual logging calls are as easy to make as they
    are with `print`. For example, a `print` to track calls into `display_active_survey`
    might look like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与`print`语句相比，一种更好的调试选择是使用Python的`logging`模块。实际的日志调用与`print`一样容易。例如，用于跟踪对`display_active_survey`的调用的`print`可能如下所示：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here the print reports the function that has been called; along with the `request.method`
    and the primary key of the survey it has been passed. On the development server
    console, the output for getting an active survey page would be:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`print`报告了已被调用的函数；以及`request.method`和它所传递的调查的主键。在开发服务器控制台上，获取活动调查页面的输出将是：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The equivalent call, only using Python `logging`, might be:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用Python的`logging`的等效调用可能是：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here the `logging.debug` call is used to specify that the passed string is a
    debug-level message. The concept of levels allows the calling code to assign a
    measure of importance to the message without actually making any decisions about
    whether the message should be output in the current circumstances. Rather, that
    decision is made by the logging facility, based on the currently set threshold
    level for logging.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用`logging.debug`调用来指定传递的字符串是调试级别的消息。级别的概念允许调用代码为消息分配重要性的度量，而不实际在当前情况下做出任何关于消息是否应该输出的决定。相反，这个决定是由日志记录设施基于当前设置的日志记录阈值级别做出的。
- en: 'The Python `logging` module provides a set of convenience methods for logging
    messages with the default defined levels. These are, in increasing order of level:
    `debug`, `info`, `warning`, `error`, and `critical`. Thus, this `logging.debug`
    message will only be output if the `logging` module''s level threshold has been
    set to include debug-level messages.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`logging`模块提供了一组方便的方法来记录消息，具有默认定义的级别。这些级别依次增加：`debug`、`info`、`warning`、`error`和`critical`。因此，只有在`logging`模块的级别阈值已设置为包括调试级别的消息时，才会输出`logging.debug`消息。
- en: 'The only problem with using this `logging.debug` statement in place of a `print`
    is that by default the logging module level threshold is set to `warning`. Thus,
    only `warning`, `error`, and `critical` messages are output by default. We need
    to configure the `logging` module to output debug-level statements in order for
    this message to appear on the console. An easy way to do this is to add a call
    to `logging.basicConfig` in the `settings.py` file. We can make the call contingent
    on `DEBUG` being turned on:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`logging.debug`语句代替`print`的唯一问题是，默认情况下，日志模块的级别阈值设置为`warning`。因此，默认情况下只输出`warning`、`error`和`critical`消息。我们需要配置`logging`模块以输出调试级别的语句，以便此消息出现在控制台上。一个简单的方法是在`settings.py`文件中添加对`logging.basicConfig`的调用。我们可以使调用依赖于`DEBUG`是否打开：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With that code added to `settings.py`, and the `logging.debug` call in the
    `display_active_survey` function, the development console will now show the message
    when the `display_active_survey` function is entered:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将该代码添加到`settings.py`中，并在`display_active_survey`函数中调用`logging.debug`，开发控制台现在将在进入`display_active_survey`函数时显示消息。
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the `DEBUG:root:` prefix on the message is a result of the default
    formatting applied to logged messages. `DEBUG` indicates the level associated
    with the message and `root` identifies the logger that was used to log the message.
    Since the `logging.debug` call does not specify any particular logger, the default
    of `root` was used.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，消息上的`DEBUG:root:`前缀是应用于记录消息的默认格式的结果。`DEBUG`表示与消息关联的级别，`root`标识用于记录消息的记录器。由于`logging.debug`调用没有指定任何特定的记录器，因此使用了`root`的默认值。
- en: Other parameters to `logging.basicConfig` could be used to change the formatting
    of the message, but full coverage of all the features of Python logging is beyond
    the scope of what we need to cover here. For our purposes, the default formatting
    will be fine.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging.basicConfig`的其他参数可用于更改消息的格式，但是在这里我们需要覆盖的Python日志的所有功能超出了范围。对于我们的目的，默认格式将很好。'
- en: Another thing that can be specified in the logging configuration is where the
    messages should be routed. We did not do so here, since the default of `sys.stderr`
    is sufficient for development debugging purposes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 日志配置中可以指定消息的路由。我们在这里没有这样做，因为默认的`sys.stderr`对于开发调试目的已经足够了。
- en: Deciding what to log
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定记录什么
- en: By switching from `print` to `logging`, we've removed the need for the developer
    adding the logging to decide under exactly what conditions the logged information
    should be produced, and where exactly it should go. The developer simply needs
    to identify the level of importance associated with the message, and then the
    logging facility itself will decide what to do with the logged information. The
    next question, then, is what should be logged?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`print`切换到`logging`，我们消除了开发人员添加日志时需要决定在什么条件下产生记录信息以及应该将记录信息放在何处的需要。开发人员只需要确定与消息相关联的重要性级别，然后日志设施本身将决定如何处理记录的信息。那么，接下来应该记录什么呢？
- en: In general, it is hard to know what information will be most useful to log when
    writing code. As developers we might make some guesses, but until we get some
    experience with the code as it actually runs, it is hard to be sure. Yet, as previously
    mentioned, it can be very helpful for code to have some built-in reporting of
    basic information about what it is doing. Thus, it is good to have some guidelines
    to follow for logging that should be included by default when initially writing
    code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在编写代码时很难知道记录哪些信息最有用。作为开发人员，我们可能会猜测一些，但在实际运行代码时，直到我们对代码有了一些经验，才能确定。然而，正如之前提到的，让代码具有一些内置的基本信息报告可能非常有帮助。因此，在最初编写代码时，最好有一些记录的指南要遵循。
- en: One such guideline might be to log entry and exit to all "significant" functions.
    The entry log message should include the values for any key parameters, and the
    exit log message should give some indication of what the function returned. With
    just this type of entry and exit logging (assuming a reasonably good split of
    code into manageable functions), we'll be able to get a pretty clear picture of
    the flow of control through the code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的一个指南可能是记录所有“重要”函数的进入和退出。输入日志消息应包括任何关键参数的值，退出日志消息应该给出函数返回的一些指示。只有这种类型的输入和退出日志（假设代码合理地分割为可管理的函数），我们将能够清楚地了解代码的控制流。
- en: Manually adding entry and exit logging, however, is a nuisance. It can also
    add clutter to the code. In reality, it is unlikely that a guideline to log all
    significant function entries and exits will be happily followed, unless it is
    much easier to do than adding the type of logging message previously noted for
    entry to `display_active_survey`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动添加条目和退出日志是一件麻烦事。这也会给代码增加混乱。实际上，很少有指南会愉快地遵循记录所有重要函数的进入和退出，除非它比为`display_active_survey`输入先前记录的日志消息更容易。
- en: Fortunately, Python provides facilities to make it easy to do exactly what we
    are looking for here. Functions can be wrapped in other functions, allowing the
    wrapping function to do things such as log entry and exit, with parameter and
    return information. Furthermore, the Python decorator syntax allows such wrapping
    to be accomplished with minimal added code clutter. In the next section, we will
    develop some simple logging wrappers for use with our existing survey application
    code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python提供了便利设施，使得我们可以轻松地做到我们在这里寻找的事情。函数可以包装在其他函数中，允许包装函数执行诸如记录输入和输出以及参数和返回信息等操作。此外，Python装饰器语法允许以最少的额外代码混乱来实现这种包装。在下一节中，我们将为现有的调查应用程序代码开发一些简单的日志包装器。
- en: Decorators to log function entry and exit
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器记录函数的输入和输出
- en: One disadvantage of using general-purpose wrappers instead of embedding entry/exit
    logging in the functions themselves is that it makes it more difficult to accomplish
    fine-grained control over what parameter and return information is logged. It
    is easy to write a general wrapper that logs all parameters, or no parameters,
    but it is difficult to impossible to write one that logs some subset of the parameters,
    for example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用包装器而不是将输入/输出日志嵌入函数本身的一个缺点是，它使得更难以对记录的参数和返回信息进行精细控制。编写一个记录所有参数或不记录任何参数的通用包装器很容易，但很难或不可能编写一个记录参数的子集的包装器，例如。
- en: Why not just log all parameters? The problem with this is that some often-used
    parameters in Django applications, such as request objects, have a very verbose
    representation. Logging their full values would produce too much output. It's
    better to start with a general-purpose wrapping logger that does not log any parameter
    values, in addition to maybe one or more special-purpose ones that can be used
    for functions with predictable parameters to log key information in those parameters.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不记录所有参数？问题在于Django应用程序中一些常用的参数，例如请求对象，具有非常冗长的表示。记录它们的完整值会产生太多的输出。最好从一个不记录任何参数值的通用包装记录器开始，可能还有一个或多个专用包装记录器，用于记录这些参数中的关键信息。
- en: For example, a special-purpose wrapper for logging entry and exit to view functions
    is likely worthwhile. A view always gets an `HttpRequest` object as its first
    parameter. While logging the full object is not helpful, logging the request method
    is both short and useful. Furthermore, since additional parameters to the view
    function come from the requested URL, they are probably not too verbose to log
    as well.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个用于记录视图函数的进入和退出的专用包装器可能是值得的。视图总是将`HttpRequest`对象作为其第一个参数。虽然记录完整对象并不有用，但记录请求方法既简短又有用。此外，由于视图函数的其他参数来自请求的URL，它们可能也不会太冗长。
- en: What about return values—should they be logged? Probably not in general for
    a Django application, which will often have functions that return `HttpResponse`
    objects. These are generally too large to be helpful when logged. However, it
    is typically useful to log at least some information about return values, such
    as their type.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值呢？它们应该被记录吗？对于Django应用程序来说，通常不会记录，因为它们经常返回`HttpResponse`对象。这些对象通常太大，无法在记录时提供帮助。但是，记录返回值的一些信息，例如它们的类型，通常是有用的。
- en: We've come up with two wrappers, then, to start with. The first, which will
    be named `log_call`, will log the entry to and exit from a function. No entry
    parameter information will be logged by `log_call`, but it will log the type of
    result it returns. The second wrapper will be more specialized, and will be used
    for wrapping view functions. This one will be named `log_view`. It will log the
    request method and any additional parameters passed to the wrapped view, as well
    as the type of its return value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提出了两个包装器。第一个将被命名为`log_call`，将记录函数的进入和退出。`log_call`不会记录任何输入参数信息，但它将记录返回结果的类型。第二个包装器将更加专业化，并且将用于包装视图函数。这个将被命名为`log_view`。它将记录请求方法和传递给包装视图的任何额外参数，以及其返回值的类型。
- en: 'Where should this code go? Again, it is not tied in any way to the survey application,
    so it makes sense to put it in `gen_utils`. We''ll create a file in `gen_utils`
    then, named `logutils.py`, that can hold any general logging utility code. We''ll
    start with an implementation of the `log_call` wrapper previously described:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该放在哪里？再次强调，它与调查应用程序没有任何关联，因此将其放在`gen_utils`中是有意义的。然后我们将在`gen_utils`中创建一个名为`logutils.py`的文件，该文件可以保存任何通用的日志记录实用程序代码。我们将从先前描述的`log_call`包装器的实现开始：
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This implementation uses the class-based style of writing wrapping functions.
    Using this style, the wrapper is defined as a class that implements `__init__`
    and `__call__` methods. The `__init__` method is called at the time the wrapper
    is created, and is passed the function it is wrapping. The `__call__` method is
    called when the wrapped function is actually called. The `__call__` implementation
    is responsible for doing whatever the wrapping function requires, calling the
    wrapped function, and returning its result.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现使用了基于类的编写包装函数的风格。使用这种风格，包装器被定义为一个实现`__init__`和`__call__`方法的类。`__init__`方法在包装器创建时被调用，并且传递了它所包装的函数。`__call__`方法在实际调用包装函数时被调用。`__call__`的实现负责执行包装函数所需的任何操作，调用包装函数，并返回其结果。
- en: 'Here the implementation is split into two classes: the base `LoggingDecorator`
    that implements `__init__`, and then `log_call`, which inherits `__init__` from
    `LoggingDecorator` and implements `__call__`. The reason for this split is so
    that we can share the common `__init__` for multiple logging wrappers. All the
    `__init__` does is save a reference to the wrapped function to be used later when
    `__call__` is called.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，实现分为两个类：基本的`LoggingDecorator`实现`__init__`，然后`log_call`继承自`LoggingDecorator`并实现`__call__`。这种分割的原因是我们可以为多个日志记录包装器共享通用的`__init__`。`__init__`只是保存对稍后在调用`__call__`时使用的包装函数的引用。
- en: The `log_call __call__` implementation, then, first logs a message that the
    function was called. The name of the wrapped function can be found in its `__name__`
    attribute. The wrapped function is then called, and its return value is saved
    in `rv`. A second message is logged noting the type returned by the called function.
    Finally, the value returned by the wrapped function is returned.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`log_call __call__`的实现首先记录一个消息，指出函数已被调用。包装函数的名称可以在其`__name__`属性中找到。然后调用包装函数，并将其返回值保存在`rv`中。然后记录第二个消息，指出被调用函数返回的类型。最后，返回包装函数返回的值。
- en: 'The `log_view` wrapper is very similar to `log_call`, differing only in the
    details of what it logs:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`log_view`包装器与`log_call`非常相似，只是在记录的细节上有所不同：'
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here the first logged message includes, in addition to the name of the wrapped
    function, the `method` attribute of the first positional argument and the keyword
    arguments passed to the wrapped function. This wrapper, since it is intended to
    be used for wrapping view functions, assumes the first positional argument is
    an `HttpRequest` object, which has a `method` attribute.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个记录的消息包括包装函数的名称，第一个位置参数的`method`属性和传递给包装函数的关键字参数。由于这个包装器是用于包装视图函数的，它假定第一个位置参数是一个`HttpRequest`对象，该对象具有`method`属性。
- en: Further, this code assumes all other arguments will be passed as keyword arguments.
    We know that this will be the case for the survey application code, since all
    of the survey URL patterns specify named groups. A more general view wrapper would
    need to log `args` (except the first one, an `HttpRequest` object) as well, if
    it wanted to support non-named groups used in the URL pattern configuration. For
    the survey application, this would just result in logging information that is
    always the same, so it has been omitted here.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此代码假定所有其他参数将作为关键字参数传递。我们知道这将是调查应用程序代码的情况，因为所有调查URL模式都指定了命名组。如果要支持URL模式配置中使用的非命名组，更通用的视图包装器将需要记录“args”（除了第一个参数，即“HttpRequest”对象）。对于调查应用程序，这只会导致记录始终相同的信息，因此在此处已被省略。
- en: Applying the decorators to the Survey code
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将装饰器应用于调查代码
- en: 'Now let''s add these decorators to the survey view functions and see what some
    typical output from browsing looks like. Adding the decorators is easy. First,
    in `views.py`, add an import for the decorators near the top of the file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这些装饰器添加到调查视图函数中，并看看浏览的一些典型输出是什么样子。添加装饰器很容易。首先，在`views.py`中，在文件顶部附近添加装饰器的导入：
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, for all functions that are actually views, add `@log_view` above the
    function definition. (This syntax assumes the Python version in use is 2.4 or
    higher.) For example, for the home page, view definition becomes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于所有实际视图函数，将`@log_view`添加到函数定义之上。（此语法假定正在使用的Python版本为2.4或更高版本。）例如，对于主页，视图定义如下：
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Do the same for `survey_detail` and `survey_thanks`. For the utility functions
    `display_active_survey` and `display_completed_survey`, use `@log_call` instead.
    For example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`survey_detail`和`survey_thanks`也是一样。对于实用函数`display_active_survey`和`display_completed_survey`，使用`@log_call`。例如：
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now when we browse around the survey site, we will have messages logged on
    the console that track basic information about what code is being called. For
    example, we might see:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们在调查网站上浏览时，我们将在控制台上记录有关所调用代码的基本信息的消息。例如，我们可能会看到：
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This shows that the home page view was called, and returned an `HttpResponse`.
    Following the survey application''s logged messages, we see the normal printout
    from the development server noting that a `GET` for `/` returned a response with
    code `200` (HTTP OK) and containing `1184` bytes. Next, we might see:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示调用了主页视图，并返回了一个“HttpResponse”。在调查应用程序的日志消息中，我们看到开发服务器的正常打印输出，指出对“/”的“GET”返回了一个带有代码“200”（HTTP
    OK）和包含“1184”字节的响应。接下来，我们可能会看到：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This shows the `survey_detail` view being called with a `GET`, likely from a
    link on the home page returned by the previous response. Further, we can see that
    the particular survey requested has a primary key of `1`. The next log message
    reveals that this must be an active survey, since `display_active_survey` is called.
    It returns an `HttpResponse`, as does the `survey_detail` view, and again the
    last survey log message is followed by Django's own printout summarizing the request
    and its outcome.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了使用“GET”调用“survey_detail”视图，很可能是从先前响应返回的主页上的链接。此外，我们可以看到所请求的特定调查具有主键“1”。下一条日志消息揭示了这必须是一个活动调查，因为调用了“display_active_survey”。它返回了一个“HttpResponse”，与“survey_detail”视图一样，最后的调查日志消息后面又是Django自己的打印输出，总结了请求及其结果。
- en: 'Next, we might see:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可能会看到：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Again this looks like a natural progression from the previous response: a `POST`
    for the same survey that was retrieved by the previous request. The `POST` indicates
    that the user is submitting a survey response. However, the return type of `HttpResponse`
    that is logged indicates that there is some problem with the submission. (We know
    an `HttpResponse` to a POST only occurs when a form is found to be invalid in
    `display_active_survey`.)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这看起来像是对先前响应的自然进展：对先前请求检索到的相同调查的“POST”。 “POST”表示用户正在提交调查响应。然而，记录的“HttpResponse”的返回类型表明提交存在问题。（我们知道“HttpResponse”只有在在“display_active_survey”中发现表单无效时才会对“POST”进行响应。）
- en: This might be a place where we would want to add additional logging beyond the
    entry/exit information, to track the specific reasons why a posted form was deemed
    invalid. In its current form, all we can know is that the returned response, since
    it was slightly larger than the original (`2466` versus `2197` bytes), likely
    included an error annotation noting what needed to be fixed on the form in order
    for it to be valid.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们希望在进入/退出信息之外添加额外日志记录的地方，以跟踪被认为无效的已发布表单的具体原因。在其当前形式中，我们只能知道返回的响应，因为它比原始响应略大（2466比2197字节），很可能包含了一个错误注释，指出需要在表单上修复什么才能使其有效。
- en: 'Next, we might see:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可能会看到：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This starts out as a repeat of the previous request, a `POST` to the `survey_detail`
    view for the survey with primary key `1`. However, this time an `HttpResponseRedirect`
    is returned, indicating that the user must have corrected whatever problem existed
    in the first submission.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始是对先前请求的重复，对具有主键“1”的调查的“survey_detail”视图的“POST”。然而，这次返回了一个“HttpResponseRedirect”，表明用户必须纠正第一次提交中存在的任何问题。
- en: 'Following this, we would likely see:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可能会看到：
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This shows the request that the browser will automatically make on receiving
    the redirect returned by the previous request. We see the `survey_thanks` view
    logging a `GET` for the same survey as all the previous requests, and an `HttpResponse`
    being returned.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了浏览器在接收到先前请求返回的重定向时将自动执行的请求。我们看到“survey_thanks”视图记录了与所有先前请求相同的调查的“GET”，并返回了一个“HttpResponse”。
- en: Thus, we can see how with very little effort we can add some basic logging that
    provides a general overview of the flow of control through our Django application
    code. Note that the logging decorators defined here are not perfect. For example,
    they don't support decoration of methods instead of functions, they impose some
    overhead even when no logging is desired, and they have some side-effects resulting
    from turning functions into classes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，通过很少的努力，我们可以添加一些基本的日志记录，提供对Django应用程序代码控制流的概述。请注意，这里定义的日志装饰器并不完美。例如，它们不支持装饰方法而不是函数，即使不需要日志记录，它们也会带来一些开销，并且由于将函数转换为类而产生一些副作用。
- en: All of these drawbacks can be overcome with some care in the development of
    the wrappers. However, the details of that are beyond the scope of what we can
    cover here. The ones presented here have the advantage of being reasonably simple
    to understand, and functional enough to hopefully demonstrate the usefulness of
    having an easy built-in logging mechanism to see the flow of control, along with
    perhaps some key parameters, through the code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些缺点都可以通过在包装器的开发中进行一些小心处理来克服。然而，这些细节超出了我们在这里可以涵盖的范围。这里介绍的方法具有相对简单的理解优势，足够功能，希望能够展示具有易于使用的内置日志记录机制的控制流以及代码中的一些关键参数的有用性。
- en: Logging in the debug toolbar
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试工具栏中的日志记录
- en: Recall that we skipped over any examination of the debug toolbar's logging panel
    since we had no logging in the survey application code. Let's return now to the
    debug toolbar and see how the added logging appears there.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，由于调查应用程序代码中没有日志记录，我们跳过了对调试工具栏的日志面板的任何检查。现在让我们返回调试工具栏，看看添加的日志记录是如何显示的。
- en: 'First, though, let''s add an additional log message to note what causes a POST
    request for an active survey to fail. As mentioned in this previous section, this
    could be useful to know. So, in the `display_active_survey` function add a logging
    call after a form is found to be invalid:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个额外的日志消息，以记录导致活动调查的POST请求失败的原因。正如在前面的部分中提到的，这可能是有用的信息。因此，在`display_active_survey`函数中，在找到一个无效的表单后添加一个日志调用：
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: (Note it will also be necessary to add an `import logging` before use of `logging`.)
    With that additional log message, we should be able to get specific information
    about why a particular survey submission was considered invalid.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，在使用`logging`之前，还需要添加`import logging`。）有了额外的日志消息，我们应该能够获取有关为什么特定调查提交被视为无效的具体信息。
- en: 'Now re-activate the debug toolbar by un-commenting its middleware in `settings.py`,
    browse to an active survey page, and attempt to force production of that log message
    by submitting an incomplete survey. When the response is returned, clicking on
    the toolbar''s **Logging** panel will bring up a page that looks like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在取消`settings.py`中调试工具栏的中间件的注释，重新激活调试工具栏，浏览到一个活动的调查页面，并尝试通过提交不完整的调查来强制生成该日志消息。当返回响应时，单击工具栏的**日志**面板将显示如下页面：
- en: '![Logging in the debug toolbar](img/7566_08_20.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![调试工具栏中的日志记录](img/7566_08_20.jpg)'
- en: On this page, we can see that in addition to the messages themselves and their
    assigned levels, the toolbar also reports the date and time they were logged in
    addition to the location in the code where they were generated. Since most of
    these log messages are coming from the wrapping functions, the location information
    here is not particularly useful. However, the newly added log message is correctly
    matched to where it appears in the code. Indeed the logged message makes it clear
    that the problem with the form was a missing choice for an answer.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，我们可以看到除了消息本身及其分配的级别之外，工具栏还报告了它们被记录的日期和时间，以及它们在代码中生成的位置。由于大多数这些日志消息来自包装函数，这里的位置信息并不特别有用。然而，新添加的日志消息正确地匹配了它在代码中的位置。事实上，记录的消息清楚地表明表单的问题是缺少一个答案的选择。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have now reached the end of discussing techniques for getting more information
    about how Django application code is running. In this chapter, we:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论完了如何获取有关Django应用程序代码运行情况的更多信息的技术。在本章中，我们：
- en: Developed some template utility code to track what SQL requests are made during
    production of a page
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发了一些模板实用程序代码，以跟踪在生成页面时进行了哪些SQL请求
- en: Learned that creating re-usable general utility code can turn into more work
    than it might first seem to require
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解到创建可重用的通用实用程序代码可能会比起初看起来需要更多的工作
- en: Learned how the Django Debug Toolbar can be used to get the same information
    as in our home-grown code in addition to more information, with much less effort
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了Django调试工具栏如何可以用更少的工作量获得与我们自己编写的代码中相同的信息，以及更多的信息。
- en: Discussed the usefulness of applying a general logging framework during code
    development, as opposed to relying on the ad-hoc "sprinkle `print`" method of
    debugging problems
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了在代码开发过程中应用通用日志框架的有用性，而不是依赖于临时的“添加`print`”方法来调试问题
- en: With the use of these tools and techniques, we are able to glean a great deal
    of information about the working of our code. Having a good understanding of how
    the code behaves when it is working properly makes it much easier to debug problems
    when they occur. Furthermore, checking on exactly what the code is doing even
    when it seems, from all outward appearances, to be working correctly, may reveal
    hidden issues that could become big problems as the code moves from development
    to production.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些工具和技术，我们能够获取关于代码运行情况的大量信息。当代码正常运行时，对代码行为有很好的理解，这样在出现问题时更容易调试。此外，即使在所有外观上看起来代码正常运行时，检查代码确切的运行情况可能会揭示潜在的问题，这些问题在代码从开发转移到生产过程中可能会变成重大问题。
- en: Sometimes, however, even all of the information available by using these techniques
    is insufficient to solve a problem at hand. In those cases, the next step may
    be to run the code under a debugger. This is the topic of the next chapter.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候，即使利用这些技术获得的所有信息也不足以解决手头的问题。在这种情况下，下一步可能是在调试器下运行代码。这是下一章的主题。
