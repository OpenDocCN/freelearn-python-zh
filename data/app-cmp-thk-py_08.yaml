- en: '*Chapter 7*: Identifying Challenges within Solutions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：识别解决方案中的挑战'
- en: In this chapter, we will be evaluating algorithms and diagrams as we learn to
    navigate through some common errors and to determine whether possible adjustments
    can be made to an existing algorithm to simplify it. We will evaluate the solutions
    based on the problem description to verify whether the solution aligns with the
    problem. We will be learning about identifying pitfalls in the solution design
    process. As a note, we will expand on the content of this chapter, later in this
    book, in *Section 2*, *Applying Python and Computational Thinking*, and *Section
    3*, *Data Processing, Analysis, and Applications Using Computational Thinking
    and Python*, of this book as we dive deeper into the **Python** programming language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将评估算法和图表，同时学习如何避免一些常见错误，并确定是否可以对现有算法进行可能的调整以简化它。我们将根据问题描述评估解决方案，以验证解决方案是否与问题一致。我们将学习如何识别解决方案设计过程中的陷阱。值得注意的是，我们将在本书的*第2节*，*应用Python和计算思维*，以及本书的*第3节*，*使用计算思维和Python进行数据处理、分析和应用*中深入探讨本章的内容，进一步深入了解**Python**编程语言。
- en: To learn about debugging, let's remind ourselves that the computational thinking
    process is not linear. Even when we are working from the original problem, we
    will sometimes redefine the problem or need to adjust the generalization due to
    a change in the population our algorithm is for or if we want to tweak our design
    of the algorithm. But sometimes, we come at problems after an algorithm has been
    designed and used. Depending on our roles, we'll be evaluating algorithms for
    errors, changes needed, and so on. Understanding how to find and analyze errors
    can help us, regardless of whether we are absolute Python beginners or deep in
    our careers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解调试，让我们提醒自己计算思维过程并不是线性的。即使我们从原始问题出发，有时我们会重新定义问题，或者需要根据算法所针对的人口变化或者我们想要调整算法设计来调整泛化。但有时，我们会在设计并使用算法后解决问题。根据我们的角色，我们将评估算法的错误、需要的更改等等。了解如何找到和分析错误可以帮助我们，无论我们是绝对的Python初学者还是在职业生涯中深入研究。
- en: Throughout this chapter, you will learn how to identify and fix bugs in your
    program and how to avoid pitfalls in the algorithm designs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何识别和修复程序中的错误，以及如何避免算法设计中的陷阱。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Identifying errors in algorithm design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别算法设计中的错误
- en: Debugging algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试算法
- en: Comparing solutions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较解决方案
- en: Refining and redefining solutions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完善和重新定义解决方案
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter07](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter07)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要最新版本的Python来运行本章中的代码。您可以在此处找到本章中使用的完整源代码：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter07](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter07)
- en: Identifying errors in algorithm design
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别算法设计中的错误
- en: Errors in algorithms are just a fact of life for any coder. It's important to
    get comfortable with making mistakes. As mentioned in [*Chapter 5*](B15413_05_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Exploring Problem Analysis*, and [*Chapter 6*](B15413_06_Final_SK_ePub.xhtml#_idTextAnchor091),
    *Solution Processes and Design*, it's good practice to test your algorithm and
    test it often. Waiting until you have finished hundreds or thousands of lines
    of code to test something is a recipe for disaster. And yes, I was once working
    on copying a game and did not test at all. Not until I had all 4,585 lines copied.
    I was young. Truth be told, I never found the error I made. I started over and
    started testing at every corner. The second time was successful, but I'd wasted
    weeks copying everything (it was from a book—GitHub wasn't a thing yet) and then
    trying to figure out the errors. So please don't be me. Please test your algorithms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何编码人员来说，算法中的错误都是生活中的一个事实。熟悉犯错是很重要的。正如在[*第5章*](B15413_05_Final_SK_ePub.xhtml#_idTextAnchor082)中提到的，*探索问题分析*，以及[*第6章*](B15413_06_Final_SK_ePub.xhtml#_idTextAnchor091)中提到的，*解决过程和设计*，测试算法并经常测试是一个好习惯。等到完成了数百或数千行代码才测试某些东西是灾难的预兆。是的，我曾经在复制一个游戏时根本没有测试。直到我复制了4585行代码。我当时很年轻。说实话，我从未找到我犯的错误。我重新开始，并在每个角落都开始测试。第二次成功了，但我浪费了数周时间复制一切（那是从一本书上复制的——当时还没有GitHub），然后试图找出错误。所以请不要成为我。请测试您的算法。
- en: Now, before moving on to debugging and working with codes, let's take a look
    at the errors we can encounter when solving problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在进行调试和处理代码之前，让我们先看看在解决问题时可能遇到的错误。
- en: 'In this section, we''ll focus on the following two broad categories of errors:
    syntax errors and logic errors.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注以下两类广泛的错误：语法错误和逻辑错误。
- en: Syntax errors
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法错误
- en: Syntax errors are sometimes called parsing errors. They're errors we create
    when we forget to indent, add a colon, add quotation marks for strings, and so
    on. Let's have a look at the different types of syntax errors in the following
    sections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时语法错误被称为解析错误。当我们忘记缩进、添加冒号、为字符串添加引号等等时，就会产生错误。让我们看看以下各种类型的语法错误。
- en: Using colons
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用冒号
- en: 'Colons are used in Python to separate conditions, create loops, and more. The
    colon is a way to tell the algorithm that the next thing is part of this particular
    block of code. When we introduce colons in Python, it automatically indents the
    next line in our code. But if we forget to include a colon where it is needed,
    the program will not run successfully. Let''s take a look at a syntax error:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，冒号用于分隔条件、创建循环等等。冒号是一种告诉算法下一步是这个特定代码块的方式。当我们在Python中引入冒号时，它会自动缩进我们代码的下一行。但如果我们忘记在需要的地方包括冒号，程序将无法成功运行。让我们看一个语法错误的例子：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we run this code, we get an error message that says *invalid syntax*. The
    following screenshot shows the pop-up window that appears when we try to run this
    program:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，会得到一个错误消息，说*invalid syntax*。下面的截图显示了当我们尝试运行这个程序时出现的弹出窗口：
- en: '![Figure 7.1 – Error pop-up window'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - 错误弹出窗口'
- en: '](image/Figure_7.1_B15413.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.1_B15413.jpg)'
- en: Figure 7.1 – Error pop-up window
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - 错误弹出窗口
- en: 'If we run this from the Python shell instead, here''s how that error appears:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从Python shell中运行这个程序，错误会如何显示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the Python program alerts us when we have code that contains
    errors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Python程序会在我们的代码中包含错误时提醒我们。
- en: 'Notice that there is a colon missing after the range in the code. Now, take
    a look at the fixed syntax in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在代码中`range`后面缺少一个冒号。现在，看一下以下代码中的修正语法：
- en: ch7_syntaxerror1.py
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_syntaxerror1.py
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we run the fixed code, the program runs and prints the numbers 1 through
    9, shown as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行修正后的代码时，程序会运行并打印出数字1到9，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You may recall that the range function does not include the upper endpoint.
    If we wanted to print the number 10, our range would have needed to be `range(1,
    11)`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得`range`函数不包括上限端点。如果我们想打印数字10，我们的范围需要是`range(1, 11)`。
- en: Now, let's take a look at other punctuation used in Python that can lead to
    some errors, namely, parentheses, nested parentheses, and brackets.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一看Python中使用的其他标点符号，可能会导致一些错误，即括号、嵌套括号和括号。
- en: Using nested parentheses and brackets
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用嵌套括号和括号
- en: 'In addition to errors in syntax that involve colons, which are my most common
    error, there are also errors when we have nested parentheses. We must always check
    that every open parenthesis has a closing parenthesis. The same is true for brackets.
    Let''s look at the following code, which contains an error with the parentheses:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了涉及冒号的语法错误外，还有嵌套括号的错误。我们必须始终检查每个开括号是否有闭括号。对于括号也是如此。让我们看一下下面的代码，其中包含括号错误：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, there are two open parentheses in the name definition, but
    only one closing parenthesis. When we run that program, we get an invalid syntax
    error from Python. Here''s what happens when we run that program in the Python
    shell or interpreter:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，名称定义中有两个开括号，但只有一个闭括号。当我们运行该程序时，Python会报告一个无效的语法错误。当我们在Python shell或解释器中运行该程序时，会发生什么：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now here's the same code without the error, notice that we even took the `str()`
    out because it was not needed, which resulted in simplifying our code and eliminating
    the error at the same time
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是没有错误的相同代码，注意我们甚至将`str()`去掉了，因为它是不需要的，这样简化了我们的代码，同时消除了错误。
- en: ch7_syntaxerror2.py
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_syntaxerror2.py
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now when we run the code, the program asks for the name then prints it. The
    output looks as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行代码时，程序会要求输入名称，然后打印出来。输出如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the program now runs without problems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，程序现在可以正常运行了。
- en: 'In [*Chapter 3*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056), *Understanding
    Algorithms and Algorithmic Thinking*, we used a dictionary to create a menu with
    pricing for each menu item. Dictionaries contain brackets to denote when the dictionary
    begins and when it ends. Let''s look at a few lines of code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*]（B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056）*理解算法和算法思维*中，我们使用字典创建了一个带有每个菜单项定价的菜单。字典包含括号，用于表示字典开始和结束的位置。让我们看一下几行代码：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we look at the program, the dictionary is missing the closing bracket, `}`,
    so we get a syntax error, the same as in our previous examples. The following
    snippet shows the corrected program:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下程序，字典缺少闭括号`}`，所以我们会得到一个语法错误，就像我们之前的例子一样。以下片段显示了已纠正的程序：
- en: ch7_syntaxerror3.py
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_syntaxerror3.py
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, once the bracket has been added, the program will run and print
    the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一旦添加了括号，程序就会运行并打印出以下输出：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each entry from the dictionary is printed in one line, divided by a comma. It
    is helpful to add `print` statements as we are writing algorithms to ensure we
    do not have any errors. I typically then remove unnecessary print functions once
    I've tested them, but they do come in handy when we're writing long algorithms
    and need to test them to avoid issues.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的每个条目都打印在一行中，用逗号分隔。在编写算法时，添加`print`语句是有帮助的，以确保我们没有任何错误。一旦测试过，我通常会删除不必要的打印函数，但在编写长算法并需要测试以避免问题时，它们确实很有用。
- en: There are many other errors we can incorporate while writing algorithms in Python.
    Let's take a look at a few more syntax errors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python编写算法时，还有许多其他错误。让我们再看看一些语法错误。
- en: Other syntax errors
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他语法错误
- en: There are many other errors in syntax that can be introduced, especially in
    longer programs. If you look at the dictionary we just used, forgetting a comma
    will also create a syntax error, for example. Generally, these syntax errors are
    quickly identified when we try to run a program. Python will highlight where an
    indentation is expected or when a bracket is missing. Syntax errors are typically
    easy to identify, but there are many other types of errors.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在更长的程序中，可能会引入许多其他语法错误。例如，如果你看一下我们刚刚使用的字典，忘记逗号也会创建一个语法错误。通常，当我们尝试运行程序时，这些语法错误会很快被识别出来。Python会突出显示缩进的位置或者括号缺失的地方。语法错误通常很容易识别，但还有许多其他类型的错误。
- en: Errors in logic
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑错误
- en: 'In [*Chapter 4*](B15413_04_Final_SK_ePub.xhtml#_idTextAnchor071), *Understanding
    Logical Reasoning*, we discussed logic errors that we can encounter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*]（B15413_04_Final_SK_ePub.xhtml#_idTextAnchor071）*理解逻辑推理*中，我们讨论了可能遇到的逻辑错误：
- en: Using the wrong variable in an equation or statement
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在等式或语句中使用错误的变量
- en: Using the wrong operator to test conditions
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误的运算符来测试条件
- en: Using wrong indentation when checking for conditions
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查条件时使用错误的缩进
- en: Now we'll look at other errors in logic that have a specific callout from Python
    and what each error represents.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下逻辑中的其他错误，这些错误在Python中有特定的调用，以及每个错误代表什么。
- en: 'Errors in logic are also called runtime errors. The following table shows some
    of the built-in errors in Python and what they represent:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑错误也称为运行时错误。下表显示了Python中一些内置错误以及它们的表示：
- en: '![Table 7.1 - Table of exceptions and causes/descriptions'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![表7.1 - 异常和原因/描述表'
- en: '](image/Table_7.1.01.jpg)![Table 7.1 - Table of exceptions and causes/descriptions'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_7.1.01.jpg)![表7.1 - 异常和原因/描述表'
- en: '](image/Table_7.1.02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_7.1.02.jpg)'
- en: Table 7.1 - Table of exceptions and causes/descriptions
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 - 异常和原因/描述表
- en: 'As you can see, there are many different types of errors that are flagged as
    exceptions in Python. You can get the list of Python exceptions by running the
    following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在Python中有许多不同类型的错误被标记为异常。你可以通过运行以下代码获取Python异常列表：
- en: ch7_errors.py
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_errors.py
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we run that code, the output provides the error values as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行该代码时，输出提供了以下错误值：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As mentioned, these are built-in exceptions in Python. There is a way to define
    our own exceptions, but we will not be going into them in this particular book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些是Python中的内置异常。有一种方法可以定义我们自己的异常，但在这本书中我们不会涉及到它们。
- en: Please note that these are not the only errors we will encounter when we are
    programming. We can have errors due to our own mistakes in calculations, as we
    discussed in [*Chapter 4*](B15413_04_Final_SK_ePub.xhtml#_idTextAnchor071), *Understanding
    Logical Reasoning*. We can introduce errors in our *Boolean* logic. The goal is
    to avoid as many as we can so that our program runs without problems. And remember,
    test your algorithms and test them often.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些不是我们在编程时会遇到的唯一错误。我们可能会因为自己在计算中犯的错误而出现错误，就像我们在[*第4章*](B15413_04_Final_SK_ePub.xhtml#_idTextAnchor071)中讨论的那样，*理解逻辑推理*。我们可能会在*布尔*逻辑中引入错误。目标是尽量避免这些错误，使我们的程序能够正常运行。记住，测试你的算法，并经常测试。
- en: Now let's look at a few algorithms with errors and try to identify the errors
    so we can correct them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些带有错误的算法，并尝试识别错误，以便我们可以纠正它们。
- en: Debugging algorithms
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试算法
- en: There is a debugger we can run in Python using the `breakpoint()` function (which
    is built-in). We can introduce this code into our program and insert it where
    we are unsure of our code. Adding `breakpoint()` will then check for bugs and
    errors. When we run a `breakpoint()` function, we'll get a `pdb` output, which
    stands for **Python Debugger**. As a note, this built-in function appears in **Python
    3.7** and newer versions. The previous debugger for **Python 3.6** and older was
    `pdb.set_trace()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用`breakpoint()`函数（内置的）运行调试器。我们可以将这段代码引入到我们的程序中，并在我们对代码不确定的地方插入它。添加`breakpoint()`将检查错误和bug。当我们运行`breakpoint()`函数时，我们会得到一个`pdb`输出，代表**Python调试器**。需要注意的是，这个内置函数出现在**Python
    3.7**和更新版本中。**Python 3.6**和更早版本的先前调试器是`pdb.set_trace()`。
- en: 'When we run the debugger, we can use four commands:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行调试器时，我们可以使用四个命令：
- en: '`c`: Continues the execution'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：继续执行'
- en: '`q`: Quits the debugger/execution'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`q`：退出调试器/执行'
- en: '`n`: Steps to the next line within the function'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`：在函数内部执行下一行的步骤'
- en: '`s`: Steps to the next line in this function or a called **function**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：在这个函数或被调用的**函数**中执行下一行的步骤'
- en: 'Let''s take a look at a code and run each of the commands outlined:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下代码，并运行所列出的每个命令：
- en: ch7_debugger.py
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_debugger.py
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Looking at this code, you can see the `breakpoint()` command after `print(number)`.
    The code will run normally until it reaches the `breakpoint()` command. At this
    stage, the execution stops. If we hit the *c* key, then it will just continue
    to run the program. Take a look at what that output looks like.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这段代码，你可以看到`print(number)`后面的`breakpoint()`命令。代码将正常运行，直到达到`breakpoint()`命令。在这个阶段，执行停止。如果我们按下*c*键，那么它将继续运行程序。看看输出是什么样子。
- en: 'Notice in the code there are three dots between two slashes, `/…/`. This is
    done because the paths may differ from your computer to mine. Yours will include
    the full path where the program is located:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在代码中有两个斜杠之间有三个点，`/…/`。这是因为路径可能会因计算机不同而不同。你的路径将包括程序所在的完整路径：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, it went on to print the string, `five`, as it just continues
    the program. Now let''s look at the output when we run the `q` command, which
    quits the program:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它继续打印字符串`five`，因为它只是继续运行程序。现在让我们看看当我们运行`q`命令时的输出，它会退出程序：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, once we use the `q` command, we get a **traceback error** because
    the program quits. It printed the line above the `breakpoint()` code, but not
    the second `print(number2)` command. Now, let''s see what happens when we type
    `n`, which should take us to the next line:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一旦我们使用`q`命令，由于程序退出，我们会得到一个**回溯错误**。它打印了`breakpoint()`代码上面的行，但没有打印第二个`print(number2)`命令。现在，让我们看看当我们输入`n`时会发生什么，它应该会带我们到下一行：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, when we typed `n`, the program continued to run and printed
    the second command line. When it does so, you can see the `-> None` output and
    the code that ran: `print(number2)`. Finally, let''s look at slightly altered
    code to see what happens when we use `s` while running the debugger:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们输入`n`时，程序继续运行并打印第二个命令行。当这样做时，你可以看到`-> None`输出和运行的代码：`print(number2)`。最后，让我们看一下稍微改变的代码，看看在运行调试器时使用`s`会发生什么：
- en: ch7_debugger2.py
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_debugger2.py
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we run this program and the debugger, we get the following output if we
    use `s`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序和调试器时，如果我们使用`s`，我们会得到以下输出：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the program encountered `TypeError` and provides more information.
    I tried to combine an integer and a string. So, we would need to fix that code
    to run it correctly. Before I do so, let''s look at what happens when I try to
    continue the code with `c`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序遇到了`TypeError`并提供了更多信息。我尝试将整数和字符串组合在一起。因此，我们需要修复代码以正确运行。在我这样做之前，让我们看看当我尝试使用`c`继续代码时会发生什么：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, I can get the same information from both commands, with slightly
    different responses from the program. To fix the problem, I''d have to convert
    the number into a string, which I can do in the `print` line using the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我可以从两个命令中获得相同的信息，程序的响应略有不同。要解决这个问题，我必须将数字转换为字符串，在`print`行中可以使用以下代码来实现：
- en: ch7_debugger3.py
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_debugger3.py
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that I''ve fixed the code so that the items in the print line are all strings,
    the output looks as follows when I use `c` to continue:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经修复了代码，使得打印行中的项目都是字符串，当我使用`c`继续时，输出如下：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the program now printed the correct information, combining the
    number as a string, with the `five` string. The double quotes add a space between
    them, which we have seen before, but will discuss again when we look at Python
    basics in [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114), *Introduction
    to Python*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序现在打印了正确的信息，将数字作为字符串与`five`字符串组合在一起。双引号在它们之间添加了一个空格，我们以前已经见过，但当我们在[*第8章*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114)中查看Python基础知识时，将再次讨论。
- en: Now, let's take a look at some solutions to the same problem so we can analyze
    them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下相同问题的一些解决方案，以便分析它们。
- en: Comparing solutions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较解决方案
- en: As we look at problems, I've mentioned that we have multiple ways of doing the
    same things in Python. Depending on what we are trying to accomplish, some commands
    may be better than others in our algorithms. Let's start by taking a look at a
    couple of solutions for one problem.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看问题时，我已经提到在Python中有多种方法可以做同样的事情。根据我们试图实现的目标，一些命令可能比我们的算法中的其他命令更好。让我们首先看一下一个问题的几种解决方案。
- en: Problem 1 - Printing even numbers
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题1 - 打印偶数
- en: You've been asked to write an algorithm that prints even numbers based on a
    range that the user provides. That is, if the user enters the range 2 through
    20, then the program would print 2, 4, 6, 8, 10, 12, 14, 16, 18, and 20\. Let's
    assume we want to include the endpoints if they are even.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求编写一个算法，根据用户提供的范围打印偶数。也就是说，如果用户输入范围为2到20，那么程序将打印2, 4, 6, 8, 10, 12, 14, 16,
    18和20。让我们假设如果端点是偶数，我们希望包括端点。
- en: Let's take a look at the first of two possible solutions. Remember, one solution
    may not be better than the other. A lot will depend on what the goal for your
    full algorithm is. *Is a list more appropriate? A dictionary? A function?* Those
    questions are important when we design solutions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下两种可能解决方案中的第一种。记住，一个解决方案可能不比另一个更好。很大程度上取决于你的完整算法的目标。*列表更合适吗？字典？函数？*当我们设计解决方案时，这些问题很重要。
- en: Algorithm solution 1 - Printing even numbers
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法解决方案1 - 打印偶数
- en: 'Recall that we will be taking user input to create a list of even numbers given
    a range. Take a look at the following code, which asks the user for the input
    then prints out the numbers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们将接受用户输入来创建一个给定范围内的偶数列表。看一下以下代码，它要求用户输入，然后打印出数字：
- en: ch7_evenalgorithm1.py
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_evenalgorithm1.py
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that `endpoint2` was converted into `endpoint2 + 1`. That is because
    if we do not add `1`, then the upper endpoint will not be included if it is an
    even number. The program also begins with a printed message for the user that
    states what the program does.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`endpoint2`被转换为`endpoint2 + 1`。这是因为如果我们不添加`1`，那么如果它是一个偶数，上限端点将不会被包括在内。程序还以用户的打印消息开始，说明程序的功能是什么。
- en: 'When I run this program with the endpoints `2` and `6`, I get the following
    output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我用端点`2`和`6`运行这个程序时，我得到以下输出：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, both endpoints are even and included. If we run the program
    with the endpoints `3` and `9`, we get the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两个端点都是偶数且包括在内。如果我们用端点`3`和`9`运行程序，我们得到以下输出：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Even though the endpoint is technically `10` now, the upper limit of the range
    is not included, so the largest even number below `10` is `8`. Now, I can run
    this program for a much larger range, but the larger the range, the harder it
    is to scroll to get all the numbers. So, let's take a look at a different way
    to get our even numbers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管终点现在在技术上是`10`，但范围的上限并不包括在内，因此在`10`以下的最大偶数是`8`。现在，我可以为一个更大的范围运行这个程序，但是范围越大，滚动以获取所有数字就越困难。因此，让我们看一种不同的方法来获取我们的偶数。
- en: Algorithm solution 2 - Printing even numbers
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法解决方案2 - 打印偶数
- en: As we saw from the previous example, each even number is being printed to a
    different line. Let's see whether we can change that and instead create a list.
    Lists in Python can be empty. We use any name for them, then equal them to items
    inside braces or just the empty braces.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的例子中看到的，每个偶数都被打印到不同的行。让我们看看是否可以改变这一点，而是创建一个列表。Python中的列表可以是空的。我们可以为它们使用任何名称，然后将它们等于括号内的项目或只是空括号。
- en: 'For example, I can create an empty list called `evenNumbers = []`. Let''s see
    what that looks like in the following algorithm:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以创建一个名为`evenNumbers = []`的空列表。让我们看看以下算法中的情况：
- en: ch7_evenalgorithm2.py
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_evenalgorithm2.py
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can see that the first few lines of code are the same. The only difference
    in this particular code is how the numbers are printed. The list is created before
    the `for` loop. Then, each of the numbers is appended to the list using the `evenNumbers.append(i)`
    code. Finally, we print our list to get the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到代码的前几行是相同的。在这个特定的代码中唯一的区别是数字的打印方式。列表是在`for`循环之前创建的。然后，使用`evenNumbers.append(i)`代码将每个数字附加到列表中。最后，我们打印我们的列表以获得以下输出：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, the even numbers are all included in one list, which is easier
    to read than if printed one at a time, one line at a time. *Imagine if you had
    to print even numbers in the range 300–1,000*. A list would make that easier to
    read when we run the program. The output would look as follows for the second
    algorithm:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有偶数都包含在一个列表中，这比一个接一个地打印更容易阅读。*想象一下，如果你必须打印范围在300-1,000之间的偶数*。当我们运行程序时，列表会使阅读更容易。对于第二个算法，输出如下：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The reason I only printed this one versus the first algorithm is that the first
    algorithm would take pages, and we don't want to waste printed pages in this book.
    You can see that one is just easier to use and more appropriate than the other
    due to the ease of reading the larger group of numbers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以只打印这一个而不是第一个算法，是因为第一个算法需要很多页，我们不想在这本书中浪费纸张。你可以看到其中一个比另一个更容易使用和更合适，因为更容易阅读更大的数字组。
- en: This is why we need to look at all of our algorithms and determine whether they
    are the best possible way to express what we need. While some algorithms work,
    they may not be the best solution, and sometimes that's okay. But other times,
    making some changes, sometimes as subtle as adding a couple of lines of code,
    as we did with *algorithm 2*, can change our output fairly dramatically and be
    much more helpful for us.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要审视我们所有的算法，并确定它们是否是表达我们所需的最佳方式。虽然有些算法可以工作，但它们可能不是最佳解决方案，有时这是可以接受的。但有时，进行一些更改，有时甚至是添加几行代码，就像我们在*算法2*中所做的那样，可以显著改变我们的输出，并对我们更有帮助。
- en: As we compared these two algorithms, we were also refining and redefining our
    solution, which we will do more of in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较这两个算法时，我们也在不断完善和重新定义我们的解决方案，这在下一节中我们会做更多。
- en: Refining and redefining solutions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精炼和重新定义解决方案
- en: If we look at algorithms long enough, we can always find ways to refine them
    and redefine them. Think about how many updates we get for apps on our phones.
    Someone is always playing with the apps, making them more secure, adding levels
    to games, updating the art files, and so on. As programmers/coders, we are always
    trying to make our work better.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们长时间观察算法，总是可以找到方法来完善和重新定义它们。想想我们手机上的应用有多少更新。总有人在玩弄这些应用，使它们更安全，增加游戏的关卡，更新艺术文件等等。作为程序员/编码人员，我们总是在努力让我们的工作变得更好。
- en: 'We are going to start this section with an algorithm. The following program
    prints out the names of three pets:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个算法开始这一节。以下程序打印出三只宠物的名字：
- en: ch7_pets1.py
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_pets1.py
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This simple code has everything within it, so there's no user input this time.
    You can see the `\` character used after `dog +` in the `print()` command. This
    backslash allows us to add the remaining code in the next line so we can more
    easily read it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的代码中包含了一切，所以这次没有用户输入。你可以看到在`print()`命令中的`dog +`后使用了`\`字符。这个反斜杠允许我们在下一行添加剩余的代码，这样我们可以更容易地阅读它。
- en: 'The output for the code looks as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, it's a simple sentence with the pet names.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个简单的句子，带有宠物名字。
- en: 'Now, let''s say we have a cat, dog, and bird, but their names are not the same.
    We can instead use a function that takes three arguments. Keep in mind we will
    go into all of the definitions and information on functions in [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114),
    *Introduction to Python*. For now, let''s look at what that algorithm could look
    like with a function. We''ll name the function `myPets()`. Take a look at the
    following algorithm:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一只猫、一只狗和一只鸟，但它们的名字不一样。我们可以使用一个带有三个参数的函数。请记住，我们将在[*第8章*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114)中详细介绍函数的定义和信息，*Python简介*。现在，让我们看看带有函数的算法。我们将函数命名为`myPets()`。看看以下算法：
- en: ch7_pets2.py
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_pets2.py
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The algorithm looks very similar to the previous one, except the definitions
    of the names are in the last line of the code. The function is called, using the
    information from that line to fill in the blanks from the definition in the algorithm
    lines above it. The output looks the same as the previous code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法看起来与上一个非常相似，只是名字的定义在代码的最后一行。调用函数时，使用该行的信息来填写上面算法行中的定义的空白。输出看起来与上一个代码相同：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, as you can see, this only printed one function because we only provided
    information for one, but we can call the function as many times as we want to
    with as many values as we want. Take a look at this algorithm:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所看到的，这只打印了一个函数，因为我们只提供了一个信息，但我们可以随时调用函数，使用任意数量的值。看看这个算法：
- en: ch7_pets3.py
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ch7_pets3.py
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, the function will now be called three times. We only have one
    `print()` command, but the function definition means that `print()` command will
    be used any time the function is called. Take a look at what the output looks
    like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，现在函数将被调用三次。我们只有一个`print()`命令，但是函数定义意味着每次调用函数时都会使用`print()`命令。看看输出是什么样子的：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that three different sentences were printed with the three sets of pet
    names provided when we called the function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们调用函数时，使用了三组宠物名字，打印了三个不同的句子。
- en: When we're writing algorithms, it's important to take into consideration what
    we need now and what we might need later. Using the first algorithm was fine for
    one instance, but if we wanted to run the algorithm for every person in a community
    or every student in a classroom, for example, the second algorithm is more helpful.
    Redefining what we need and refining our algorithms helps us to improve what we
    get out of our programs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写算法时，重要的是要考虑我们现在需要什么，以及我们将来可能需要什么。对于一个实例来说，使用第一个算法是可以的，但是如果我们想要为社区中的每个人或者教室中的每个学生运行算法，那么第二个算法更有帮助。重新定义我们的需求并完善我们的算法有助于改进我们从程序中得到的东西。
- en: Note that, as mentioned, we will talk about functions more in [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114),
    *Introduction to Python*. One of the things we'll address is creating a function
    for an unknown number of arguments. *For example, what if I only had a dog and
    a bird?* We can address that with a few changes to the algorithm. We will look
    into that soon. For now, we know just a little more about why we need to sometimes
    compare algorithms and redefine and redesign them to better fit our needs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如前面提到的，我们将在[*第8章*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114)中更多地讨论函数，*Python简介*。我们将讨论的其中一件事是为未知数量的参数创建一个函数。*例如，如果我只有一只狗和一只鸟呢？*我们可以通过对算法进行一些更改来解决这个问题。我们很快就会研究这个问题。目前，我们只是稍微了解了为什么有时需要比较算法并重新定义和重新设计它们以更好地满足我们的需求。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed errors in algorithm design and how to debug solutions.
    We also learned how to compare solutions and refine and redesign solutions when
    needed. After reading this chapter, you should know more about syntax errors in
    algorithms and how to use the debugger using the `breakpoint()` command in **Python
    3.7** and above. The built-in debugger provides you with four courses of action:
    `c` = *continue*, `q` = *quit*, `n` = *next* *line*, and `s` = *step*.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了算法设计中的错误以及如何调试解决方案。我们还学习了如何比较解决方案，并在需要时对解决方案进行改进和重新设计。阅读完本章后，您应该更了解算法中的语法错误以及如何在**Python
    3.7**及以上版本中使用`breakpoint()`命令来使用调试器。内置调试器为您提供了四种操作：`c` = *继续*，`q` = *退出*，`n` =
    *下一行*，`s` = *步进*。
- en: Using the debugger allows us to identify pieces of code where we may have made
    mistakes. We can add this line to any place in our code to determine the issue.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器可以帮助我们确定代码中可能出错的地方。我们可以在代码的任何位置添加这行代码来确定问题所在。
- en: We also looked at algorithms that provide the same output but using different
    code. By comparing algorithm solutions, we can identify which of them are more
    useful, what better suits our problem or situation, and why we should use one
    over the other. Remember that algorithms are lists of instructions. Knowing which
    instructions to use given the broader use of the algorithm is critical. Some solutions
    may be more appropriate for your problem than others. Take into consideration
    the algorithm's purpose, the snippets in the algorithm, and how they will be used
    within the bigger algorithm and make your determinations accordingly. Each problem
    and each solution is unique.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了提供相同输出但使用不同代码的算法。通过比较算法解决方案，我们可以确定哪些更有用，哪些更适合我们的问题或情况，以及为什么我们应该选择其中一个而不是另一个。请记住，算法是指令列表。在广泛使用算法的情况下，知道使用哪些指令至关重要。某些解决方案可能比其他解决方案更适合您的问题。考虑算法的目的、算法中的代码片段以及它们将如何在更大的算法中使用，并相应地做出决定。每个问题和每个解决方案都是独一无二的。
- en: As we finish out *Section 1*, *Introduction to Computational Thinking*, of this
    book, we have learned about the computational thinking process, always looking
    at possible scenarios to help us to understand the usefulness of the process,
    how to brainstorm and create flowcharts for decisions, and how to design our algorithms.
    In *Section 2*, *Applying Python and Computational Thinking*, we will begin looking
    at the Python language more in depth so we can tackle more complex problems, such
    as those dealing with data and functions. We'll also take a more in-depth look
    at the Python programming language, and we'll apply the knowledge to multiple
    types of problems in the further chapters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成本书的*第1节*，*计算思维导论*时，我们已经了解了计算思维过程，始终关注可能的场景，以帮助我们理解该过程的有用性，如何进行头脑风暴并为决策创建流程图，以及如何设计我们的算法。在*第2节*，*应用Python和计算思维*中，我们将更深入地研究Python语言，以便能够解决更复杂的问题，比如处理数据和函数的问题。我们还将更深入地了解Python编程语言，并将在后续章节中将这些知识应用于多种类型的问题。
