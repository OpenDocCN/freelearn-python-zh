- en: Button Bash Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮砸游戏
- en: In this chapter, we will create a two-player game called Button Bash that you
    can play directly on Circuit Playground Express without a computer. Each player
    must press their push button as fast as they can. Each press of the button increases
    that player's score by one point. The players' current scores will be shown visually
    with the NeoPixels. The first player that reaches a score of 20 points wins the
    game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个名为按钮砸的双人游戏，您可以直接在Circuit Playground Express上玩，无需计算机。每个玩家必须尽快按下他们的按钮。每次按下按钮都会将该玩家的分数增加一分。通过NeoPixels可以直观地显示玩家当前的分数。首先达到20分的玩家将赢得游戏。
- en: To create this game, we will combine button input with light output through
    the NeoPixels and with audio output through the built-in speakers. This chapter
    contains a number of recipes, each showing different parts of the game, and we
    combine all of these pieces in the final recipe to produce the complete game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个游戏，我们将通过NeoPixels结合按钮输入和灯光输出，并通过内置扬声器进行音频输出。本章包含许多配方，每个配方展示游戏的不同部分，我们将所有这些部分组合在最后一个配方中，以制作完整的游戏。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a class to detect a button state change
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个类来检测按钮状态变化
- en: Creating your own Python modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的Python模块
- en: Adding button interactions to the event loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将按钮交互添加到事件循环中
- en: Creating a generator to get pixel colors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个生成器来获取像素颜色
- en: Showing scores with the ScoreBoard class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ScoreBoard类显示分数
- en: Detecting winners with the ScoreBoard class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ScoreBoard类检测获胜者
- en: Adding the ScoreBoard class to the event loop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ScoreBoard类添加到事件循环中
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found in the `Chapter06` folder in the
    GitHub repository, at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub存储库的`Chapter06`文件夹中找到，网址为[https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook)。
- en: Many of the recipes in this chapter require three audio files to be transferred
    to the Circuit Playground Express board. These files are called `start.wav`, `win1.wav`,
    and `win2.wav`. They can all be downloaded from the `Chapter06` folder in the
    GitHub repository. They should be saved in the top-level folder with your `main.py` file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的许多配方需要将三个音频文件传输到Circuit Playground Express板上。这些文件分别为`start.wav`、`win1.wav`和`win2.wav`。它们都可以从GitHub存储库的`Chapter06`文件夹中下载。它们应该保存在与您的`main.py`文件的顶级文件夹中。
- en: 'Many of the recipes in this chapter make use of the Circuit Playground Express
    library, which will typically get imported in the first line of the script, with
    the following line of code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多配方都使用了Circuit Playground Express库，通常会在脚本的第一行导入，代码的下一行是：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This library will help us interact with the buttons, pixels, and speaker that
    come with the board.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库将帮助我们与板子上的按钮、像素和扬声器进行交互。
- en: Circuit Playground Express power
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Circuit Playground Express电源
- en: The game that will be presented in this chapter can run directly on Circuit
    Playground Express, without a need for a connected computer. This is an excellent
    opportunity to introduce the options you have to make your project portable on
    this type of board. The board can receive power from a number of different portable
    sources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍的游戏可以直接在Circuit Playground Express上运行，无需连接计算机。这是一个很好的机会，介绍您在这种类型的板子上使项目便携的选项。该板可以从多种不同的便携式电源接收电源。
- en: 'We''ll explore two different approaches to solving the problem of portable
    power. Each approach uses a different connector on the board. The first connector
    we will look at is the Micro B USB connector, which appears in the following image:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨解决便携式电源问题的两种不同方法。每种方法都使用板子上的不同连接器。我们将首先看一下Micro B USB连接器，它出现在以下图片中：
- en: '![](assets/f18560bf-0456-41b2-91fc-66d55b9e8615.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f18560bf-0456-41b2-91fc-66d55b9e8615.png)'
- en: Courtesy of adafruit.com
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由adafruit.com提供
- en: 'This connector can be used to connect the board to a computer for power and
    to transfer your code and audio files onto the board. One approach is to attach
    a portable power bank to the board via USB. The following photograph shows the
    board being powered by one of these power banks:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个连接器可以用来将板子连接到计算机进行供电，并将您的代码和音频文件传输到板子上。一种方法是通过USB将便携式移动电源连接到板子上。以下照片显示了板子由其中一个移动电源供电：
- en: '![](assets/d1980cd1-2afe-44a9-ae6a-77e12bf84353.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d1980cd1-2afe-44a9-ae6a-77e12bf84353.png)'
- en: The benefit of this approach is that these power banks come in all different
    sizes and capacities, so you have plenty of options to choose the one that best
    meets your needs. They are rechargeable, making them reusable, and they can easily
    be purchased at most electronics retailers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处在于，这些移动电源有各种不同的尺寸和容量，因此您有很多选择，可以选择最符合您需求的移动电源。它们是可充电的，可重复使用，并且可以很容易地在大多数电子零售商处购买。
- en: 'The second connector that we will look at is the JST battery input, which appears
    in the next photograph:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下的第二个连接器是JST电池输入，它出现在下一张照片中：
- en: '![](assets/1718da72-4ee5-42a7-96c1-0a2f95daa7ae.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1718da72-4ee5-42a7-96c1-0a2f95daa7ae.png)'
- en: Courtesy of adafruit.com
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由adafruit.com提供
- en: 'There are a number of portable battery sources that can be attached to this
    connector. Many of these battery holders are quite inexpensive, and they often
    support popular battery sizes, such as AAA batteries. Because the board has no
    built-in battery charging, you can safely use regular batteries or rechargeable
    batteries. The following photograph shows a battery holder with an on/off switch:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多便携式电池源可以连接到这个连接器。许多这些电池座价格相当便宜，它们通常支持流行的电池尺寸，如AAA电池。由于板子没有内置电池充电功能，您可以安全地使用常规电池或可充电电池。以下照片显示了一个带有开关的电池座：
- en: '![](assets/3135dd49-5835-4e6a-8969-faed1ad4cfbc.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3135dd49-5835-4e6a-8969-faed1ad4cfbc.png)'
- en: 'The next photograph shows the same holder with the cover open, to provide a
    view of the three AAA batteries it uses:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张照片显示了同一个支架，盖子打开，以便查看它使用的三节AAA电池：
- en: '![](assets/1a4b85cd-4788-42e5-994e-9a3effd699f2.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1a4b85cd-4788-42e5-994e-9a3effd699f2.png)'
- en: The battery holder shown in the previous photograph can be purchased for around
    $2 USD from [https://www.adafruit.com/product/727](https://www.adafruit.com/product/727).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张照片中显示的电池盒可以在[https://www.adafruit.com/product/727](https://www.adafruit.com/product/727)购买到约2美元。
- en: Creating a class to detect a button state change
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个检测按钮状态变化的类
- en: In this recipe, you will learn how to define a class that, when instantiated,
    can keep track of the button press events of a specific button on the board. We
    will use this class in later recipes in this chapter, in order to create objects
    that will keep track of button presses on push buttons A and B.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何定义一个类，当实例化时，可以跟踪板上特定按钮的按钮按下事件。我们将在本章的后续教程中使用这个类，以便创建对象，用于跟踪按钮A和按钮B的按下事件。
- en: You will learn how to put common chunks of code into functions and classes,
    which will improve the code reuse in your projects. It can also help with large
    projects, in order to break up a lot of the logic into smaller, independent chunks
    of functions and classes. The implementation of this button event class will be
    kept generic on purpose, so that it can easily be reused in different projects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何将常见的代码块放入函数和类中，这将提高项目中的代码重用。它还可以帮助大型项目，以便将大量逻辑分解为更小、独立的函数和类的独立块。这个按钮事件类的实现将故意保持通用，以便它可以轻松地在不同的项目中重用。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    that will be presented in this recipe.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问Circuit Playground Express上的REPL，以运行本教程中将呈现的代码。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required in this recipe:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本教程中需要的步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this stage, we have defined our class and have given it a constructor. Run
    the next block of code to create your first instance of this class and to inspect
    its `name` attribute:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经定义了我们的类并给它一个构造函数。运行下一个代码块来创建这个类的第一个实例，并检查它的`name`属性：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following block of code will access the attribute from the `cpx` library
    that will indicate whether the push button was pressed:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将访问`cpx`库中的属性，指示推按钮是否被按下：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the following block of code while holding down push button A. It should
    show the state of the push button as `pressed`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住按钮A的情况下运行以下代码块。它应该显示推按钮的状态为`pressed`：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code should be put into the `main.py` file, and, when executed,
    it will repeatedly print a message whenever push button A is pressed:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中，当执行时，每当按下按钮A时，它将重复打印一条消息：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it for the coding part; now, let's see how this works.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，编码部分就完成了；现在，让我们看看它是如何工作的。
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `ButtonEvent` class is defined to help us keep track of button presses with
    either push button A or push button B. When you instantiate the class, it expects
    one argument, which specifies the name of the button we are tracking. The name
    is saved to an attribute on the instance called `name`, and then the last variable
    is initialized with the value `False`. This variable will keep track of the last
    known value of the button state each time we check for a new event.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ButtonEvent`类被定义为帮助我们跟踪按钮A或按钮B的按下事件。当你实例化这个类时，它期望一个参数，指定我们要跟踪的按钮的名称。名称保存在实例的一个属性`name`中，然后最后一个变量被初始化为值`False`。每次我们检查新事件时，这个变量将跟踪按钮状态的上次已知值。'
- en: The `is_pressed` method is called each time we want to check whether a new button
    press event has occurred since the last time we checked. It first retrieves the
    current state of the physical push button, to find out whether it is pushed down.
    We check the value with its last known value to calculate whether a change has
    occurred; we keep this result in a variable called `changed`. We then save the
    current value for future reference. The method will then return a `True` value
    if the button state has changed and if it is currently being pushed down.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想要检查是否自上次检查以来发生了新的按钮按下事件时，都会调用`is_pressed`方法。它首先检索物理推按钮的当前状态，以找出它是否被按下。我们将检查该值与其上次已知值，以计算是否发生了变化；我们将这个结果保存在一个名为`changed`的变量中。然后我们保存当前值以供将来参考。该方法将在按钮状态发生变化且当前被按下时返回`True`值。
- en: After the class definition, we create one instance of this class that will keep
    track of push button A. Then, an infinite loop is started that keeps checking
    for new button press events and prints a message each time one of them is detected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义之后，我们创建了一个该类的实例，用于跟踪按钮A的按下事件。然后，启动一个无限循环，不断检查新的按钮按下事件，并在每次检测到其中一个时打印一条消息。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we used the class once, to keep track of a single button; but
    because we haven't hardcoded any specific button values in the class definition
    itself, we can reuse this code to keep track of a number of different buttons.
    We can just as easily watch both push buttons for button press events. Many MicroPython
    boards let you attach many extra push buttons. This approach of making a generic
    class to watch buttons can be very useful in these scenarios.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们只使用了一次该类，以跟踪单个按钮的按下事件；但是因为我们没有在类定义中硬编码任何特定的按钮值，所以我们可以重用这段代码来跟踪许多不同的按钮。我们同样可以轻松地监视按钮A和按钮B的按下事件。许多MicroPython板可以连接许多额外的推按钮。在这些情况下，制作一个通用的观察按钮的类是非常有用的。
- en: There is also a bit of logic involved in keeping track of the previous button
    state, so that we can detect what we are interested in, which is new button press
    events. By keeping all this code in one contained class, we can make our code
    more readable and more manageable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还涉及一些逻辑来跟踪先前的按钮状态，以便我们可以检测我们感兴趣的内容，即新的按钮按下事件。通过将所有这些代码放入一个包含的类中，我们可以使我们的代码更易读和更易管理。
- en: See also
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Documentation for creating classes in Python can be found at [https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关在Python中创建类的文档可以在[https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)找到。
- en: Documentation on the built-in `getattr` function can be found at [https://docs.python.org/3/library/functions.html#getattr](https://docs.python.org/3/library/functions.html#getattr).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关内置`getattr`函数的文档可以在[https://docs.python.org/3/library/functions.html#getattr](https://docs.python.org/3/library/functions.html#getattr)找到。
- en: Creating your own Python modules
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的Python模块
- en: In this recipe, you will learn how to take the code you create and put it into
    its own Python modules. We will take the code from the previous recipe, which
    helped us track button press events, and place it into its own dedicated module.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何将您创建的代码放入自己的Python模块中。我们将从前面的示例中获取代码，该示例帮助我们跟踪按钮按下事件，并将其放入自己的专用模块中。
- en: We will then import this newly created module into our main Python script and
    use its class definition to track button presses. This can be a very useful approach
    when you start working on large projects and want to split up your code into different
    modules. It can also be helpful when you find a useful module that you would like
    to incorporate into your own project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把这个新创建的模块导入到我们的主Python脚本中，并使用它的类定义来跟踪按钮按下事件。当您开始在大型项目上工作并希望将代码拆分为不同的模块时，这可能是一个非常有用的方法。当您发现一个有用的模块并希望将其纳入自己的项目时，这也可能会有所帮助。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本示例中提供的代码。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个食谱所需的步骤：
- en: 'The following code should be put into a new file called `button.py`; this will
    become the Python module that we can import in later steps:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入一个名为`button.py`的新文件中；这将成为我们以后可以导入的Python模块：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the following lines of code in the REPL:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At this stage, we have been able to import a class from our new Python module.
    The next line of code will create a new object that we can use to detect new button
    press events:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经能够从我们的新Python模块中导入一个类。下一行代码将创建一个新对象，我们可以用它来检测新的按钮按下事件：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the following block of code while you hold down push button A, and it should
    detect a button press event:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住按钮A时运行以下代码块，它应该会检测到按钮按下事件：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will repeatedly print a message whenever push button A is pressed:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中，当执行时，每当按下按钮A时，它将重复打印一条消息：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our previous recipes, we got accustomed to working with the `main.py` file.
    Creating a new Python module is as simple as creating a new file and placing our
    code in it. We have taken the `ButtonEvent` class and placed it into its own Python
    module, called `button`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们习惯于使用`main.py`文件。创建一个新的Python模块就像创建一个新文件并将我们的代码放入其中一样简单。我们已经将`ButtonEvent`类放入了自己的Python模块中，名为`button`。
- en: Now, we can import the class and create objects using that class. The rest of
    the code creates an object to monitor button presses and prints a message whenever
    they are detected.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以导入这个类并使用该类创建对象。代码的其余部分创建了一个对象来监视按钮按下事件，并在检测到事件时打印一条消息。
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you create your own custom Python module, it is important to be mindful
    of the name you give the module. The same naming restrictions for any Python module
    also apply to your MicroPython code. For example, you can't create a module that
    has space characters in it. You should also make sure not to name your module
    the same name as an existing MicroPython or CircuitPython module. Hence, you shouldn't
    call your module `board` or `math`, as these names are already taken.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建自己的自定义Python模块时，重要的是要注意您给模块的名称。任何Python模块的相同命名限制也适用于您的MicroPython代码。例如，您不能创建一个模块其中包含空格字符。您还应该确保不要将模块命名为现有的MicroPython或CircuitPython模块的相同名称。因此，您不应该将您的模块命名为`board`或`math`，因为这些名称已经被使用。
- en: The simplest way to prevent this is by going into the REPL before you create
    your new module and trying to import a module by that name. If you get an `ImportError`,
    then you know that name is not in use.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种情况发生的最简单方法是在创建新模块之前进入REPL，并尝试按该名称导入一个模块。如果出现`ImportError`，那么您就知道该名称尚未被使用。
- en: See also
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Documentation for creating Python modules can be found at [https://docs.python.org/3/tutorial/modules.html](https://docs.python.org/3/tutorial/modules.html).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关创建Python模块的文档可以在[https://docs.python.org/3/tutorial/modules.html](https://docs.python.org/3/tutorial/modules.html)找到。
- en: A discussion on the benefits of using Python modules can be found at [https://realpython.com/python-modules-packages/](https://realpython.com/python-modules-packages/).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于使用Python模块的好处的讨论可以在[https://realpython.com/python-modules-packages/](https://realpython.com/python-modules-packages/)找到。
- en: Adding button interactions to the event loop
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将按钮交互添加到事件循环
- en: In this recipe, we will start to build our main event loop. Each player will
    be assigned a single push button to press during the game. Player 1 will be assigned
    push button A, and player 2 will be assigned push button B. The event loop will
    continually check each of these buttons, looking for new button press events. When
    a new push button event is detected, it will print a message.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将开始构建我们的主事件循环。每个玩家将被分配一个单独的按键，在游戏中按下。玩家1将被分配按键A，玩家2将被分配按键B。事件循环将不断检查这些按钮，寻找新的按钮按下事件。当检测到新的按键按下事件时，它将打印一条消息。
- en: This will be further expanded in the next recipes in this chapter, in order
    to add the rest of the Button Bash game's functionality. Event loops can be found
    in many types of software applications. Exploring their usage can help you whenever
    you have to make your own, or when you have to interact with a built-in event
    loop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本章的下一个食谱中进一步扩展，以添加Button Bash游戏的其余功能。事件循环可以在许多类型的软件应用程序中找到。探索它们的使用可以帮助您在必须制作自己的事件循环时，或者在必须与内置事件循环交互时。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL来运行本食谱中提供的代码。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个食谱所需的步骤：
- en: 'Execute the next block of code in the REPL:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行下一个代码块：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At this stage, we have created two objects to monitor the two push buttons.
    Hold down push button A while you run the next block of code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经创建了两个对象来监视两个按键。在运行下一个代码块时，按住按键A：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will repeatedly print a message whenever push button A or push button B is
    pressed:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中，当执行时，每当按下按键A或按键B时，它将重复打印一条消息：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First of all, the `ButtonEvent` class is imported from the `button` module.
    A function called `main` is defined, which will contain the code for our main
    event loop. The last line of code calls the `main` function to start the execution
    of the main event loop. The main event loop first defines a dictionary that keeps
    track of each player's push button. It defines a mapping that player 1 will be
    assigned push button A and player 2 will be assigned push button B.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`button`模块导入`ButtonEvent`类。定义了一个名为`main`的函数，其中包含了我们主要事件循环的代码。代码的最后一行调用`main`函数来启动主事件循环的执行。主事件循环首先定义了一个字典，用于跟踪每个玩家的按钮。它定义了一个映射，玩家1将被分配按键A，玩家2将被分配按键B。
- en: An infinite loop is started, which will loop through each of the `ButtonEvent`
    objects and check if a button press event has occurred. If a button press is detected,
    it will then print which player pressed a button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 启动了一个无限循环，它将循环遍历每个`ButtonEvent`对象，并检查是否发生了按钮按下事件。如果检测到按钮按下事件，它将打印哪个玩家按下了按钮。
- en: There's more...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As your code gets bigger, it's a good idea to put your main block of code into
    its own function, which you can call to start execution. As your program grows
    in size, it will make it easier to keep track of variables, as they will all be
    in the scope of this main function, instead of residing in the global namespace.
    This helps to reduce some ugly bugs that can appear with large blocks of code
    all sharing the same big global namespace.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的代码变得越来越大，将主要代码块放入自己的函数中，并调用它来启动执行是一个好主意。随着程序规模的增大，这将使跟踪变量变得更容易，因为它们都将在这个主函数的范围内，而不是驻留在全局命名空间中。这有助于减少一些可能出现在共享同一个大型全局命名空间的大块代码中的丑陋bug。
- en: Another thing to note in this recipe is the use of a dictionary to maintain
    the association of players and their buttons. The dictionary data structure is
    a very natural choice for this type of requirement. If we were using hardware
    that had more push buttons, we could just keep adding an item for each player
    to our data structure. It's always a good idea to make good use of data structures
    in your code; it makes debugging and software design much easier.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中另一个要注意的事情是使用字典来维护玩家和他们的按钮的关联。字典数据结构是这种需求的一个非常自然的选择。如果我们使用的硬件有更多的按键，我们可以只需向我们的数据结构中为每个玩家添加一个项目。充分利用数据结构是一个很好的主意；它使调试和软件设计变得更加容易。
- en: See also
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Documentation on the `tkinter` library that makes use of an event loop to respond
    to button press events can be found at [https://docs.python.org/3/library/tkinter.html#a-simple-hello-world-program](https://docs.python.org/3/library/tkinter.html#a-simple-hello-world-program).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://docs.python.org/3/library/tkinter.html#a-simple-hello-world-program](https://docs.python.org/3/library/tkinter.html#a-simple-hello-world-program)找到使用事件循环响应按钮按下事件的`tkinter`库的文档。
- en: A discussion on the main event loop of `tkinter` can be found at [https://gordonlesti.com/use-tkinter-without-mainloop/](https://gordonlesti.com/use-tkinter-without-mainloop/).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`tkinter`的主事件循环的讨论可以在[https://gordonlesti.com/use-tkinter-without-mainloop/](https://gordonlesti.com/use-tkinter-without-mainloop/)找到。
- en: Creating a generator to get pixel colors
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个生成器来获取像素颜色
- en: In this recipe, we will prepare the code that will be used to control the pixels
    in the game. There are 10 pixels on the board, so each player will be given 5,
    to indicate how many points they have so far. Now, each player gets a point each
    time they press their button and a score of 20 is needed to win the game. So,
    we have to present a score of 0 to 20, but with only 5 pixels.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将准备用于控制游戏中像素的代码。棋盘上有10个像素，所以每个玩家将获得5个像素，以表示他们目前获得了多少分。现在，每当玩家按下按钮时，他们都会获得一个点，游戏需要得分20分才能赢。因此，我们必须呈现0到20的分数，但只有5个像素。
- en: The way we will do that is to have the score on each pixel be represented by
    four colors. So, for the first four points, the first pixel would go through the
    colors yellow, dark orange, red, and magenta. Then, when you reach the score 5,
    the second pixel would light up yellow and go through the same cycle.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过让每个像素的得分由四种颜色表示来实现这一点。因此，对于前四个点，第一个像素将经历黄色、深橙色、红色和品红色。然后，当你达到得分5时，第二个像素将点亮黄色并经历相同的循环。
- en: A generator will be used to get the list of colors and pixel positions that
    relate to each score for each player. Player 1 will use push button A and will
    have the five pixels next to this push button. These are pixels 0 to 4\. Player
    2 will use push button B and will have the five pixels next to that push button.
    These are pixels 5 to 9.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用生成器获取与每个玩家每个得分相关的颜色和像素位置的列表。玩家1将使用按钮A，并将拥有紧挨着该按钮的五个像素。这些是像素0到4。玩家2将使用按钮B，并将拥有紧挨着该按钮的五个像素。这些是像素5到9。
- en: Both sets of pixels will start lighting up near the USB connector and will race
    towards the finish line, which will be the JST battery input. This makes the sequence
    0 to 4 for player 1 and 9 to 5 for player 2\. This recipe will cover an interesting
    use case for generators, which can come in handy in some projects, when you need
    to generate a sequence of values based on some involved logic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 两组像素将从USB连接器附近开始点亮，并向终点线赛跑，终点线将是JST电池输入。这使得玩家1的序列为0到4，玩家2的序列为9到5。这个示例将涵盖生成器的一个有趣用例，它在一些项目中可能会派上用场，当你需要基于一些复杂的逻辑生成一系列值时。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL来运行本示例中提供的代码。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个示例所需的步骤：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this stage, the first pixel should be lit up with the color yellow. In the
    next block of code, we will define the generator and call it to generate the list
    of positions and colors for both player 1 and player 2\. There are 21 items in
    the list. The first item, which represents score 0, is a special case where we
    want all the pixels to be off if no one has scored any points yet. The remaining
    20 items represent the scores 1 to 20:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，第一个像素应该点亮黄色。在下一段代码中，我们将定义生成器并调用它来为玩家1和玩家2生成位置和颜色的列表。列表中有21个项目。第一个项目代表得分0，这是一个特殊情况，如果没有人得分，我们希望所有像素都关闭。剩下的20个项目代表得分1到20：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code should be put into the `colors.py` file and can then be
    imported in the next recipes, in order to access the color data for the game:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`colors.py`文件中，然后可以在下一个示例中导入，以便访问游戏的颜色数据：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: First of all, the `SEQUENCE` list represents the four colors that will be shown
    on each pixel to represent the player's score. The position and order of the five
    pixels that will be lit up for each player is then defined. The `generate_colors`
    generator is then defined. When called, it will produce a sequence of tuples,
    each containing the position and color of a specific score representation. This
    will be converted into a list for each player.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`SEQUENCE`列表表示将显示在每个像素上以表示玩家得分的四种颜色。然后定义了每个玩家将点亮的五个像素的位置和顺序。然后定义了`generate_colors`生成器。调用时，它将生成一系列元组，每个元组包含特定得分表示的位置和颜色。这将被转换为每个玩家的列表。
- en: In this way, we can take any score and immediately look up its associated color
    and pixel position. These colors and position values for each player and each
    score are stored in a dictionary called `COLORS` that can be used to look up these
    values by player, number, and score.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以立即查找任何得分的相关颜色和像素位置。每个玩家和每个得分的这些颜色和位置值存储在一个名为`COLORS`的字典中，可以用来通过玩家、数字和得分查找这些值。
- en: There's more...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Python **iterators** are a very powerful feature of the language. Generators
    are a type of iterator that let you implement some powerful solutions in a concise
    way. They are used in this recipe as a way to assist in building a list that has
    a special first case and two levels of nesting for the remaining values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python的**迭代器**是该语言的一个非常强大的特性。生成器是迭代器的一种类型，它让你以简洁的方式实现一些强大的解决方案。它们在这个示例中被用作一种辅助方式，用于构建一个具有特殊第一情况和两个嵌套级别的值的列表。
- en: By putting all this logic in a generator, we can contain it in one place and
    then use it as a building block to make more complicated structures. In the case
    of this recipe, the single generator is being used to build the color lookup data
    for player 1 and player 2.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有这些逻辑放入一个生成器中，我们可以将其包含在一个地方，然后将其用作构建更复杂结构的构建块。在这个示例中，单个生成器被用来构建玩家1和玩家2的颜色查找数据。
- en: See also
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Documentation on iterators can be found at [https://docs.python.org/3/tutorial/classes.html#iterators](https://docs.python.org/3/tutorial/classes.html#iterators).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器的文档可以在[https://docs.python.org/3/tutorial/classes.html#iterators](https://docs.python.org/3/tutorial/classes.html#iterators)找到。
- en: Documentation on generators can be found at [https://docs.python.org/3/tutorial/classes.html#generators](https://docs.python.org/3/tutorial/classes.html#generators).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器的文档可以在[https://docs.python.org/3/tutorial/classes.html#generators](https://docs.python.org/3/tutorial/classes.html#generators)找到。
- en: Showing scores with the ScoreBoard class
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ScoreBoard类显示得分
- en: In this recipe, we will prepare the code that will be used to keep track of
    each player's score and show their current score on the pixels. We will create
    a new class called `ScoreBoard` and put it into a new module called `score`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将准备用于跟踪每个玩家得分并在像素上显示他们当前得分的代码。我们将创建一个名为`ScoreBoard`的新类，并将其放入一个名为`score`的新模块中。
- en: This recipe will show you one way to implement a scoreboard functionality in
    a MicroPython-based game. This recipe will start with the initial logic of starting
    the game, keeping track of the score and then displaying the score on the pixels.
    In the next recipes, we will add more functionality to deal with incrementing
    the score and detecting when one of the players has won the game.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向您展示一种在基于MicroPython的游戏中实现记分牌功能的方法。这个配方将从开始游戏的初始逻辑开始，跟踪得分，然后在像素上显示得分。在接下来的配方中，我们将添加更多功能来处理得分的增加和检测玩家中的一个何时赢得比赛。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问Circuit Playground Express上的REPL来运行本配方中提供的代码。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个配方所需的步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After running the previous code, you should hear the board play the game startup
    audio, which says `1 2 3 Go!`. Then, you should see the current score of player
    1 as the value `0`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码后，您应该听到板子播放游戏启动音频，它说`1 2 3 Go!`。然后，您应该看到玩家1的当前得分为`0`。
- en: 'The following code should be put into the `score.py` file, and then we can
    import it and use it elsewhere:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`score.py`文件中，然后我们可以在其他地方导入并使用它：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code will import the `ScoreBoard` class from the `score` module,
    set the score of the first player to the value `3`, and then show this score on
    the pixels. The first pixel should turn on with the color red:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将从`score`模块导入`ScoreBoard`类，将第一个玩家的得分设置为`3`，然后在像素上显示这个得分。第一个像素应该变成红色：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ScoreBoard` class is defined in the `score` module. When the class is first
    instantiated, it prepares the board to start a match of the game. It initializes
    the scores for players 1 and 2 to 0\. Then, it sets the brightness of the pixels
    and plays the audio clip to announce the start of the match to the players.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreBoard`类在`score`模块中定义。当类首次实例化时，它准备好开始比赛。它将玩家1和2的分数初始化为0。然后，它设置像素的亮度并播放音频剪辑，向玩家宣布比赛的开始。'
- en: The `show` method expects one argument, which will be the number of the player
    to show the score for. Then, it gets the value of the player's score and uses
    it with the player number to look up the color and position of the pixel that
    must be set. This pixel then has its color set to the correct color.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`show`方法期望一个参数，这个参数将是要显示得分的玩家的编号。然后，它获取玩家得分的值，并将其与玩家编号一起使用，查找必须设置的像素的颜色和位置。然后，将该像素的颜色设置为正确的颜色。'
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have started to build the logic for showing the current scoreboard to our
    players. It's important to make a fun and responsive scoreboard in competitive
    games in which you want to keep the two players engaged in trying to beat one
    another.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始构建逻辑，向玩家展示当前的记分牌。在竞争激烈的游戏中，重要的是要制作一个有趣和响应灵敏的记分牌，以保持两名玩家参与并努力互相击败。
- en: The code to update the scoreboard has to be implemented in a fashion that performs
    well. If each update to the scoreboard is a sluggish process, the players will
    feel it and get frustrated at an application that doesn't feel responsive. All
    the code to get the color and position of the pixel to set is implemented in an
    efficient fashion to ensure its performance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 更新记分牌的代码必须以执行良好的方式实现。如果对记分牌的每次更新都是一个迟钝的过程，玩家会感觉到并对不响应的应用感到沮丧。获取像素的颜色和位置的所有代码都以高效的方式实现，以确保其性能。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: An example of a MicroPython project that shows the scores of players in a game
    can be found at [https://tinkercademy.com/tutorials/flappy-bird/](https://tinkercademy.com/tutorials/flappy-bird/).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://tinkercademy.com/tutorials/flappy-bird/](https://tinkercademy.com/tutorials/flappy-bird/)找到一个MicroPython项目的示例，显示玩家在游戏中的得分。
- en: An example of a battery operated MicroPython project to control NeoPixels can
    be found at [https://learn.adafruit.com/neopixel-coat-buttons](https://learn.adafruit.com/neopixel-coat-buttons).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/neopixel-coat-buttons](https://learn.adafruit.com/neopixel-coat-buttons)找到一个使用电池操作的MicroPython项目的示例，用于控制NeoPixels。
- en: Detecting winners with the ScoreBoard class
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ScoreBoard`类检测获胜者。
- en: In this recipe, we will extend the `ScoreBoard` class to be able to update player
    scores and to detect when a player has won the game. Once one of the players has
    won the game, the board will announce which player has won the game by playing
    an audio clip with the announcement.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将扩展`ScoreBoard`类，以便能够更新玩家得分并检测玩家何时赢得比赛。一旦玩家中的一个赢得了比赛，板子将通过播放带有宣布的音频剪辑来宣布哪个玩家赢得了比赛。
- en: This recipe is the last piece to complete the logic in the `ScoreBoard` class.
    Once it's completed, we can combine it into the main event loop and complete the
    game in the next recipe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是完成`ScoreBoard`类中逻辑的最后一部分。一旦完成，我们就可以将其合并到主事件循环中，并在下一个配方中完成游戏。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问Circuit Playground Express上的REPL来运行本配方中提供的代码。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个配方所需的步骤：
- en: 'The following code should be put into the `score.py` file, and then we can
    import it and use it elsewhere:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`score.py`文件中，然后我们可以在其他地方导入并使用它：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code will import the `ScoreBoard` class from the `score` module
    and print out the current scores of the players:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将从`score`模块导入`ScoreBoard`类，并打印出玩家的当前得分：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next block of code will increment the score of player 1, causing the first
    pixel to light up yellow, and then print out the current score. The score should
    show that player 1 has a score of 1 point:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码将增加玩家1的得分，导致第一个像素点变成黄色，并打印出当前得分。得分应该显示玩家1得到1分：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ScoreBoard` class has an additional method added to it that will increment
    in the `score` data structure whenever one of the players has scored. The `scored`
    method receives one argument, the player number, and increments that player's
    score.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreBoard`类添加了一个额外的方法，当其中一个玩家得分时，它将在`score`数据结构中递增。`scored`方法接收一个参数，即玩家编号，并增加该玩家的得分。'
- en: It then updates the pixels to show the latest score of the player, and then
    checks whether the player's score has reached 20 points. If the player has reached
    20 points, the board will then play an announcement announcing which player has
    won the game.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它会更新像素以显示玩家的最新得分，然后检查玩家的得分是否已经达到20分。如果玩家已经达到20分，棋盘将播放一条宣布哪个玩家赢得了比赛的公告。
- en: There's more...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Sound and light are a great way to interact with players in video games. Sound
    is used effectively in this class to both announce the start of the game and to
    announce its end. During the game play, light is used to motivate each player
    to bash their buttons faster, so that they can be the first to reach the finish
    line. Even though a lot is going on in this class, each method is only three to
    four lines long, making it easier to see what each piece is involved in. This
    is one way of breaking your code up into smaller chunks, by putting the different
    parts into different methods.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 声音和光是与玩家在视频游戏中进行互动的好方法。在这个课程中，声音被有效地用来宣布游戏的开始和结束。在游戏过程中，光被用来激励每个玩家更快地按下按钮，以便他们能够第一个到达终点线。尽管在这个课程中发生了很多事情，但每种方法只有三到四行代码，这使得更容易看到每个部分所涉及的内容。这是将代码分解成较小块的一种方法，通过将不同的部分放入不同的方法中。
- en: See also
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: A multiplayer game that uses Circuit Playground Express can be found at [https://learn.adafruit.com/circuit-playground-express-ir-zombie-game/](https://learn.adafruit.com/circuit-playground-express-ir-zombie-game/).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/circuit-playground-express-ir-zombie-game/](https://learn.adafruit.com/circuit-playground-express-ir-zombie-game/)找到使用Circuit
    Playground Express的多人游戏。
- en: A game implemented in CircuitPython can be found at [https://learn.adafruit.com/circuit-playground-treasure-hunt/](https://learn.adafruit.com/circuit-playground-treasure-hunt/).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/circuit-playground-treasure-hunt/](https://learn.adafruit.com/circuit-playground-treasure-hunt/)找到使用CircuitPython实现的游戏。
- en: Adding the ScoreBoard class to the event loop
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ScoreBoard类添加到事件循环
- en: This final recipe of this chapter combines all the previous recipes in this
    chapter to create the final Button Bash game. We will upgrade the event loop by
    adding the `ScoreBoard` class that we implemented in the previous recipe. This
    is the last piece of the puzzle.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个食谱将在本章中将所有先前的食谱结合起来，以创建最终的Button Bash游戏。我们将通过添加在上一个食谱中实现的`ScoreBoard`类来升级事件循环。这是谜题的最后一块。
- en: The final result is a main loop with only six lines of code. We have been able
    to achieve this result by keeping a lot of the game logic in each of the three
    Python modules created in this chapter. You can use a similar approach in your
    own projects when you find the code base has become too big and concentrated in
    one file or one function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是一个只有六行代码的主循环。我们能够通过将本章中创建的三个Python模块中的大部分游戏逻辑保留下来来实现这一结果。当您发现代码基础变得过大且集中在一个文件或一个函数中时，您可以在自己的项目中使用类似的方法。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问Circuit Playground Express上的REPL来运行本食谱中提供的代码。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个食谱所需的步骤：
- en: 'The following code should be put into the `main.py` file, and then you can
    start to play the Button Bash game:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中，然后您就可以开始玩Button Bash游戏了：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you have one of the portable power supplies mentioned at the start of this
    chapter, then you can disconnect the board from your computer and connect that
    power supply.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您拥有本章开头提到的便携式电源供应之一，那么您可以将棋盘从计算机上断开，并连接该电源供应。
- en: You can now take the game anywhere you like and play rounds between each player.
    To start the next match, press the reset button at the center of the board for
    a new round to begin.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以随身携带游戏，并在每个玩家之间进行回合。要开始下一场比赛，请按下棋盘中央的复位按钮，以开始新的一轮。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We first import the `ButtonEvent` and `ScoreBoard` objects; they are the two
    main objects that we will need to implement the remainder of the event loop. After
    we have created our button dictionary, we instantiate a new `ScoreBoard` object
    called `board`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`ButtonEvent`和`ScoreBoard`对象；它们是我们需要实现事件循环的两个主要对象。在创建了我们的按钮字典之后，我们实例化了一个名为`board`的新`ScoreBoard`对象。
- en: This will announce that the game has started, and then we will enter into the
    infinite loop that will keep checking for button press events. The moment one
    of these events is detected, it will call the `scored` method on the board object
    to increment that specific player's score. If any player has reached the final
    score, they will then be announced as the winner.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将宣布游戏已经开始，然后我们将进入一个无限循环，该循环将不断检查按钮按下事件。一旦检测到这些事件中的一个，它将调用棋盘对象上的`scored`方法来增加特定玩家的分数。如果任何玩家已经达到最终得分，那么他们将被宣布为赢家。
- en: There's more...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now that we have the basic version of the game working, there are many ways
    to change it and enhance it. We could create two modes of the game that can be
    selected with the slide switch. There could be an easy and hard mode, where one
    needs a score of 10 and the other needs 20\. When the board starts up, it checks
    the switch to load the correct parameters for colors and the final score.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了游戏的基本版本，有许多方法可以改变它并增强它。我们可以创建两种可以通过滑动开关选择的游戏模式。可以有简单和困难模式，其中一个需要得分10分，另一个需要得分20分。当棋盘启动时，它会检查开关以加载颜色和最终得分的正确参数。
- en: 'You could make a best of three mode, where the two players have to fight it
    out repeatedly for three rounds, and the one who gets the best of three wins.
    To see the game in action, take a look at the next photograph to see two players
    intensely battling away at Button Bash:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以制作一个三局两胜的模式，两名玩家必须反复进行三轮比赛，最终获得两局胜利的人获胜。要看游戏的实际操作，请查看下一张照片，看看两名玩家在Button
    Bash上激烈对抗。
- en: '![](assets/ff90c627-9968-4182-86ba-a0db4426b75f.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ff90c627-9968-4182-86ba-a0db4426b75f.png)'
- en: See also
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Here are a few references:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: A battery powered portable CircuitPython project that uses the NeoPixels can
    be found at [https://learn.adafruit.com/ufo-circuit-playground-express](https://learn.adafruit.com/ufo-circuit-playground-express).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用NeoPixels的电池供电便携式CircuitPython项目可以在[https://learn.adafruit.com/ufo-circuit-playground-express](https://learn.adafruit.com/ufo-circuit-playground-express)找到。
- en: A basketball hoop game that uses the NeoPixels can be found at [https://learn.adafruit.com/neopixel-mini-basketball-hoop](https://learn.adafruit.com/neopixel-mini-basketball-hoop).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用NeoPixels的篮球篮游戏可以在[https://learn.adafruit.com/neopixel-mini-basketball-hoop](https://learn.adafruit.com/neopixel-mini-basketball-hoop)找到。
