- en: Chapter 4. Using Modules for Real-World Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用模块进行现实世界编程
- en: 'In this chapter, we are going to use modular programming techniques to implement
    a useful real-world system. In particular, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用模块化编程技术来实现一个有用的现实世界系统。特别是，我们将：
- en: Design and implement a Python package for generating charts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现一个用于生成图表的Python包
- en: See how changing requirements can be the downfall of a successful system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看不断变化的需求如何成为成功系统的崩溃
- en: Discover the ways in which modular programming techniques can help you to deal
    with changing requirements in the best possible way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现模块化编程技术如何帮助您以最佳方式处理不断变化的需求
- en: Learn that changing requirements can be good, because they give you the opportunity
    to re-think your program, resulting in more robust and well-designed code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解不断变化的需求可能是好事，因为它们给您重新思考程序的机会，从而产生更健壮和设计良好的代码
- en: Let's start by looking at the Python chart-generating package we are going to
    implement, which we will call **Charter**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下我们将要实现的Python图表生成包，我们将其称为**Charter**。
- en: Introducing Charter
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Charter
- en: 'Charter will be a Python library for generating charts. Developers will be
    able to use Charter to convert raw numbers into good-looking line and bar charts,
    which can then be saved as image files. The following is an example of the sort
    of chart that the Charter library will be able to generate:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Charter将是一个用于生成图表的Python库。开发人员将能够使用Charter将原始数字转换为漂亮的折线图和条形图，然后将其保存为图像文件。以下是Charter库将能够生成的图表类型的示例：
- en: '![Introducing Charter](graphics/B05012_4_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![介绍Charter](graphics/B05012_4_01.jpg)'
- en: The Charter library will support line and bar charts. While we will keep Charter
    relatively simple by only supporting two types of charts, the package will be
    designed so that you can easily add more chart types and other charting options
    if you wish.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Charter库将支持折线图和条形图。虽然我们将通过仅支持两种类型的图表来保持Charter相对简单，但该包将被设计为您可以轻松添加更多的图表类型和其他图表选项。
- en: Designing Charter
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计Charter
- en: 'When you look at a chart like the one shown in the previous section, you can
    identify a number of standard elements that are used by all types of charts. These
    elements include a title, the *x* and *y* axes, and one or more data series:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看前一节中显示的图表时，您可以识别出所有类型的图表中使用的一些标准元素。这些元素包括标题、*x*轴和*y*轴，以及一个或多个数据系列：
- en: '![Designing Charter](graphics/B05012_4_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![设计Charter](graphics/B05012_4_02.jpg)'
- en: To use the Charter package, a programmer would create a new chart and set the
    title, the *x* and *y* axes, and the data series to be displayed. The programmer
    would then ask Charter to generate the chart, saving the result as an image file
    on disk. By combining and configuring the various elements in this way, a programmer
    can create any chart that they may wish to generate.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Charter包，程序员将创建一个新图表并设置标题、*x*轴和*y*轴，以及要显示的数据系列。然后程序员将要求Charter生成图表，并将结果保存为磁盘上的图像文件。通过以这种方式组合和配置各种元素，程序员可以创建任何他们希望生成的图表。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: A more sophisticated charting library would allow for additional elements, such
    as a *y* axis on the right-hand side, axis labels, a legend, and multiple overlapping
    data series. For Charter, however, we want to keep the code simple, so we will
    ignore these more complicated elements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的图表库将允许添加其他元素，例如右侧的*y*轴、轴标签、图例和多个重叠的数据系列。但是，对于Charter，我们希望保持代码简单，因此我们将忽略这些更复杂的元素。
- en: Let's take a closer look at how a programmer might interact with the Charter
    library, and then start to think about how it might be implemented.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看程序员如何与Charter库进行交互，然后开始思考如何实现它。
- en: 'We would like the programmer to be able to interact with Charter simply by
    importing the `charter` package and then calling various functions to work with
    charts. For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望程序员能够通过导入`charter`包并调用各种函数来与Charter进行交互。例如：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To set the title for the chart, the programmer would call the `set_title()`
    function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要为图表设置标题，程序员将调用`set_title()`函数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that our Charter library does not use object-oriented programming techniques.
    Using object-oriented techniques, the chart title would be set using a statement
    such as `chart.set_title("Wild Parrot Deaths per Year")`. However, object-oriented
    techniques are beyond the scope of this book, and so we will use a simpler procedural
    programming style for the Charter library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的Charter库不使用面向对象的编程技术。使用面向对象的技术，图表标题将使用类似`chart.set_title("每年野生鹦鹉死亡数量")`的语句进行设置。但是，面向对象的技术超出了本书的范围，因此我们将为Charter库使用更简单的过程式编程风格。
- en: To set the *x* and *y* axes for a chart, the programmer would have to supply
    enough information so that Charter can generate the chart and display these axes.
    To understand how this might work, let's think about what an axis looks like.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要为图表设置*x*和*y*轴，程序员必须提供足够的信息，以便Charter可以生成图表并显示这些轴。为了了解这可能是如何工作的，让我们想一想轴是什么样子。
- en: 'For some charts, an axis might represent a range of values:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些图表，轴可能代表一系列数值：
- en: '![Designing Charter](graphics/B05012_4_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![设计Charter](graphics/B05012_4_03.jpg)'
- en: In this case, a data point would be displayed by calculating the position of
    the point along the axis. For example, a data point with *x = 35* would be displayed
    halfway between the **30** and **40** points on this axis.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通过计算数据点沿轴的位置来显示数据点。例如，具有*x = 35*的数据点将显示在该轴上**30**和**40**点之间的中间位置。
- en: 'We are going to call this type of axis a **continuous axis**. Notice how, for
    this type of axis, the labels are positioned below the tick marks. Compare this
    with the following axis, which is divided up into a number of discrete "buckets":'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这种类型的轴称为**连续轴**。请注意，对于这种类型的轴，标签位于刻度线下方。将其与以下轴进行比较，该轴被分成多个离散的“桶”：
- en: '![Designing Charter](graphics/B05012_4_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![设计Charter](graphics/B05012_4_04.jpg)'
- en: In this case, each data point corresponds to a single bucket, and the label
    would appear in the space between the tick marks. This type of axis will be called
    a **discrete axis**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个数据点对应一个单独的桶，标签将出现在刻度标记之间的空间中。这种类型的轴将被称为**离散轴**。
- en: Notice that for continuous axes, the labels are displayed on the tick marks,
    while for discrete axes the labels are displayed between the tick marks. Also,
    the values for a discrete axis can be anything (in this case, month names), while
    for continuous axes, the values must be numbers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于连续轴，标签显示在刻度标记上，而对于离散轴，标签显示在刻度标记之间。此外，离散轴的值可以是任何值（在本例中是月份名称），而连续轴的值必须是数字。
- en: For the Charter library, we are going to make the *x* axis a discrete axis,
    while the *y* axis will be continuous. In theory, you could use either type of
    axis for both the *x* and *y* axes, but we are keeping this simple to make the
    library easier to implement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Charter 库，我们将使 *x* 轴成为离散轴，而 *y* 轴将是连续的。理论上，你可以为 *x* 和 *y* 轴使用任何类型的轴，但我们保持这样做是为了使库更容易实现。
- en: Knowing this, we can now look at how the various axes can be defined when creating
    a chart.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这一点，我们现在可以看一下在创建图表时如何定义各种轴。
- en: 'To define the x axis, the programmer will call the `set_x_axis()` function
    with a list of labels to use for each bucket within the discrete axis:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义 x 轴，程序员将调用 `set_x_axis()` 函数，并提供用于离散轴中每个桶的标签列表：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each entry in the list corresponds to a single bucket within the axis.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个条目对应轴中的一个桶。
- en: 'For the *y* axis, we need to define both the range of values that will be displayed
    and how these will be labeled. To do this, we''re going to need to supply minimum,
    maximum, and label values to the `set_y_axis()` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *y* 轴，我们需要定义将显示的值的范围以及这些值将如何标记。为此，我们需要向 `set_y_axis()` 函数提供最小值、最大值和标签值：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To keep things simple, we will assume that the *y* axis uses a linear scale.
    We could potentially support other types of scaling, for example to implement
    a logarithmic axis, but we're going to ignore this as it would make the Charter
    library more complicated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将假设 *y* 轴使用线性刻度。我们可能会支持其他类型的刻度，例如实现对数轴，但我们将忽略这一点，因为这会使 Charter 库变得更加复杂。
- en: 'Now that we know how the axes will be defined, we can look at how the data
    series will be specified. Firstly, we need the programmer to tell Charter what
    type of data series to display:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了轴将如何定义，我们可以看一下数据系列将如何指定。首先，我们需要程序员告诉 Charter 要显示什么类型的数据系列：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As mentioned earlier, we will support both line and bar charts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，我们将支持线图和条形图。
- en: 'The programmer then needs to specify the contents of the data series. Since
    our *x* axis is discrete while the *y* axis is continuous, we can define a data
    series as a list of *y* axis values, one for each discrete *x* axis value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后程序员需要指定数据系列的内容。由于我们的 *x* 轴是离散的，而 *y* 轴是连续的，我们可以将数据系列定义为一个 *y* 轴值的列表，每个离散的
    *x* 轴值对应一个 *y* 轴值：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This completes the definition of a chart. Once it has been defined, the programmer
    can ask the Charter library to generate the chart:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了图表的定义。一旦定义好了，程序员就可以要求 Charter 库生成图表：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Putting all this together, here is a complete program that generates the bar
    chart shown at the start of this chapter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，这是一个完整的程序，可以生成本章开头显示的条形图：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because Charter is a library intended to be used by programmers, this code gives
    a fairly complete specification for the Charter library's API. It's clear from
    this example program what is supposed to happen. Let's now look at how this can
    be implemented.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Charter 是一个供程序员使用的库，这段代码为 Charter 库的 API 提供了一个相当完整的规范。从这个示例程序中很清楚地可以看出应该发生什么。现在让我们看看如何实现这一点。
- en: Implementing Charter
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施图表
- en: We know that the Charter library's public interface will consist of a number
    of functions accessed at the package level, for example `charter.new_chart()`.
    However, using the techniques covered in the previous chapter, we know that we
    don't have to define our library's API in the package initialization file to make
    these functions available at the package level. Instead, we can define the functions
    elsewhere, and import them into the `__init__.py` file so that they are available
    for others to use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 Charter 库的公共接口将由许多在包级别访问的函数组成，例如 `charter.new_chart()`。然而，使用上一章介绍的技术，我们知道我们不必在包初始化文件中定义库的
    API，以使这些函数在包级别可用。相反，我们可以在其他地方定义这些函数，并将它们导入到 `__init__.py` 文件中，以便其他人可以使用它们。
- en: 'Let''s start by creating a directory to hold our `charter` package. Create
    a new directory named `charter`, and create within it an empty package initialization
    file, `__init__.py`. This gives us the basic framework within which to write our
    library:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个目录开始，用来保存我们的 `charter` 包。创建一个名为 `charter` 的新目录，在其中创建一个空的包初始化文件 `__init__.py`。这为我们提供了编写库的基本框架：
- en: '![Implementing Charter](graphics/B05012_4_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![实施图表](graphics/B05012_4_05.jpg)'
- en: 'Based on our design, we know that the process of generating a chart will involve
    the following three steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的设计，我们知道生成图表的过程将涉及以下三个步骤：
- en: Create a new chart by calling the `new_chart()` function.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `new_chart()` 函数创建一个新的图表。
- en: Define the contents and appearance of the chart by calling the various `set_XXX()`
    functions.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用各种 `set_XXX()` 函数来定义图表的内容和外观。
- en: Generate the chart and save it as an image file by calling the `generate_chart()`
    function.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `generate_chart()` 函数生成图表并将其保存为图像文件。
- en: To keep our code nicely organized, we're going to separate the process of generating
    a chart from the process of creating and defining a chart. To do this, we'll have
    a module named `chart`, which handles the chart creation and definition, and a
    separate module named `generator` which handles the chart generation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的代码组织良好，我们将分开生成图表的过程和创建和定义图表的过程。为此，我们将有一个名为`chart`的模块，负责图表的创建和定义，以及一个名为`generator`的单独模块，负责图表的生成。
- en: 'Go ahead and create these two new empty modules, placing them inside the `charter`
    package:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建这两个新的空模块，将它们放在`charter`包中：
- en: '![Implementing Charter](graphics/B05012_4_06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![实现Charter](graphics/B05012_4_06.jpg)'
- en: 'Now that we have an overall structure for our package, let''s create some placeholders
    for the various functions that we know we''re going to have to implement. Edit
    the `chart.py` module, and enter the following into this file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的包建立了一个整体结构，让我们为我们知道我们将不得不实现的各种函数创建一些占位符。编辑`chart.py`模块，并在该文件中输入以下内容：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, edit the `generator.py` module, and enter the following into it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，编辑`generator.py`模块，并在其中输入以下内容：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These are all the functions that we know we''ll need to implement for the Charter
    library. However, they''re not in the correct place yet—we want the user to be
    able to call `charter.new_chart()`, not `charter.chart.new_chart()`. To get around
    this, edit the `__init__.py` file, and enter the following into this file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们知道我们需要为Charter库实现的所有函数。但是，它们还没有放在正确的位置上——我们希望用户能够调用`charter.new_chart()`，而不是`charter.chart.new_chart()`。为了解决这个问题，编辑`__init__.py`文件，并在该文件中输入以下内容：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we're using relative imports to load all the functions from
    these modules into the main `charter` package's namespace.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在使用相对导入将所有这些模块中的函数加载到主`charter`包的命名空间中。
- en: Our Charter library is starting to take shape! Let's now work on each of the
    two modules in turn.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Charter库开始成形了！现在让我们依次处理这两个模块。
- en: Implementing the chart.py module
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现chart.py模块
- en: Since we're eschewing the use of object-oriented programming techniques in our
    implementation of the Charter library, we can't use an object to store the information
    about a chart. Instead, the `new_chart()` function is going to return a chart
    value, and the various `set_XXX()` functions will take that chart and add information
    to it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在Charter库的实现中避免使用面向对象的编程技术，我们不能使用对象来存储有关图表的信息。相反，`new_chart()`函数将返回一个图表值，各种`set_XXX()`函数将获取该图表并向其添加信息。
- en: 'The easiest way to store information about a chart is to use a Python dictionary.
    This makes the implementation of our `new_chart()` function very simple; edit
    the `chart.py` module and replace the placeholder for `new_chart()` with the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 存储图表信息的最简单方法是使用Python字典。这使得我们的`new_chart()`函数的实现非常简单；编辑`chart.py`模块，并用以下内容替换`new_chart()`的占位符：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we have a dictionary that will hold the chart''s data, it''s easy to store
    the various values we want into this dictionary. For example, edit the definition
    for the `set_title()` function so that it looks like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个将保存图表数据的字典，就很容易将我们想要的各种值存储到这个字典中。例如，编辑`set_title()`函数的定义，使其如下所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In a similar way, we can implement the rest of the `set_XXX()` functions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以实现`set_XXX()`函数的其余部分：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This completes the implementation for our `chart.py` module.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的`chart.py`模块的实现。
- en: Implementing the generator.py module
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现generator.py模块
- en: 'Unfortunately, the `generate_chart()` function is going to be more difficult
    to implement, which is why we moved this function into a separate module. The
    process of generating a chart will involve the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，实现`generate_chart()`函数将更加困难，这就是为什么我们将这个函数移到了一个单独的模块中。生成图表的过程将涉及以下步骤：
- en: Create an empty image to hold the generated chart.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空图像来保存生成的图表。
- en: Draw the chart's title.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制图表的标题。
- en: Draw the *x* axis.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制*x*轴。
- en: Draw the *y* axis.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制*y*轴。
- en: Draw the data series.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制数据系列。
- en: Save the resulting image file to disk.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的图像文件保存到磁盘上。
- en: Because the process of generating a chart requires us to work with images, we're
    going to need to find a library that allows us to generate image files. Let's
    grab one now.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为生成图表的过程需要我们使用图像，所以我们需要找到一个允许我们生成图像文件的库。现在让我们来获取一个。
- en: The Pillow library
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pillow库
- en: The **Python Imaging Library** (**PIL**) is a venerable library used to generate
    images. Unfortunately, PIL is no longer being actively developed. There is, however,
    a newer version of PIL, named **Pillow**, that continues to be supported and will
    allow us to create and save image files.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python Imaging Library**（**PIL**）是一个古老的用于生成图像的库。不幸的是，PIL不再得到积极的开发。然而，有一个名为**Pillow**的更新版本的PIL，它继续得到支持，并允许我们创建和保存图像文件。'
- en: The main web site for the Pillow library can be found at [http://python-pillow.org/](http://python-pillow.org/),
    and the documentation is available at [http://pillow.readthedocs.org/](http://pillow.readthedocs.org/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow库的主要网站可以在[http://python-pillow.org/](http://python-pillow.org/)找到，文档可以在[http://pillow.readthedocs.org/](http://pillow.readthedocs.org/)找到。
- en: Let's go ahead and install Pillow. The easiest way to do this is to use `pip
    install pillow`, although the installation guide ([http://pillow.readthedocs.org/en/3.0.x/installation.html](http://pillow.readthedocs.org/en/3.0.x/installation.html))
    gives you a variety of options if this won't work for you.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续安装Pillow。最简单的方法是使用`pip install pillow`，尽管安装指南([http://pillow.readthedocs.org/en/3.0.x/installation.html](http://pillow.readthedocs.org/en/3.0.x/installation.html))为您提供了各种选项，如果这种方法对您不起作用。
- en: 'Looking through the Pillow documentation, it appears that we can create an
    empty image using the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看Pillow文档，我们发现可以使用以下代码创建一个空图像：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a new RGB (red, green, blue) image with the given width and height,
    filled with the given color.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的RGB（红色，绿色，蓝色）图像，宽度和高度由给定的颜色填充。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`#7f00ff` is a hexadecimal color code for purple. Each pair of hexadecimal
    digits represents a color value: `7f` for red, `00` for green, and `ff` for blue.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`#7f00ff`是紫色的十六进制颜色代码。每对十六进制数字代表一个颜色值：`7f`代表红色，`00`代表绿色，`ff`代表蓝色。'
- en: 'To draw into this image, we will use the `ImageDraw` module. For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制这个图像，我们将使用`ImageDraw`模块。例如：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the chart has been drawn, we can save the image to disk in the following
    way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图表绘制完成后，我们可以以以下方式将图像保存到磁盘上：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This brief introduction to the Pillow library tells us how to implement steps
    1 and 6 of the chart-generation process we described earlier. It also tells us
    that for steps 2 to 5, we are going to use the `ImageDraw` module to draw the
    various chart elements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对Pillow库的简要介绍告诉我们如何实现我们之前描述的图表生成过程的第1步和第6步。它还告诉我们，对于第2到第5步，我们将使用`ImageDraw`模块来绘制各种图表元素。
- en: Renderers
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染器
- en: 'When we draw the chart, we want to be able to choose the elements to draw.
    For example, we might select between the `"bar"` and `"line"` elements depending
    on the type of data series the user wants to display. A very simple way of doing
    this would be to structure our drawing code like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制图表时，我们希望能够选择要绘制的元素。例如，我们可能根据用户想要显示的数据系列的类型在`"bar"`和`"line"`元素之间进行选择。一个非常简单的方法是将我们的绘图代码结构化如下：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, this isn't very expandable and would quickly get hard to read if the
    drawing logic gets complicated, or if we added more charting options to the library.
    To make the Charter library more modular, and to support enhancing it down the
    track, we will make use of renderer modules to do the actual drawing for us.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是很灵活，如果绘图逻辑变得复杂，或者我们向库中添加更多的图表选项，代码将很快变得难以阅读。为了使Charter库更加模块化，并支持今后的增强，我们将使用渲染器模块来实际进行绘制。
- en: In computer graphics, a **renderer** is a part of a program that draws something.
    The idea is that you can select the appropriate renderer and ask it to draw the
    element you want without having to worry about the details of how that element
    will be drawn.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，**渲染器**是程序的一部分，用于绘制某些东西。其思想是你可以选择适当的渲染器，并要求它绘制你想要的元素，而不必担心该元素将如何被绘制的细节。
- en: 'Using renderer modules, our drawing logic would look something like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用渲染器模块，我们的绘图逻辑看起来会像下面这样：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This means that we can leave the actual details of how each element is drawn
    to the renderer module itself and not clutter up our `generate_chart()` function
    with lots of detailed drawing code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将每个元素的实际绘制细节留给渲染器模块本身，而不是在我们的`generate_chart()`函数中充斥着大量详细的绘制代码。
- en: To keep track of our renderer modules, we're going to create a sub-package named
    `renderers`, and place all our renderer modules inside this sub-package. Let's
    create this sub-package now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪我们的渲染器模块，我们将创建一个名为`renderers`的子包，并将所有渲染器模块放在这个子包中。让我们现在创建这个子包。
- en: Create a new directory named `renderers` within the main `charter` directory,
    and create a new file inside it called `__init__.py` to act as the package initialization
    file. This file can be empty as we don't need to do anything special to initialize
    this sub-package.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`charter`目录中创建一个名为`renderers`的新目录，并在其中创建一个名为`__init__.py`的新文件，作为包初始化文件。这个文件可以为空，因为我们不需要做任何特殊的初始化来初始化这个子包。
- en: 'We are going to need a total of five different renderer modules for the Charter
    library:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要五个不同的渲染器模块来完成Charter库的工作：
- en: '`title.py`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title.py`'
- en: '`x_axis.py`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x_axis.py`'
- en: '`y_axis.py`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y_axis.py`'
- en: '`bar_series.py`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bar_series.py`'
- en: '`line_series.py`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line_series.py`'
- en: 'Go ahead and create these five files within the `charter.renderers` directory,
    and enter the following placeholder text into each one:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在`charter.renderers`目录中创建这五个文件，并在每个文件中输入以下占位文本：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This gives us the overall structure for our renderer modules. Let's now use
    these renderers to implement our `generate_chart()` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们渲染器模块的整体结构。现在让我们使用这些渲染器来实现我们的`generate_chart()`函数。
- en: 'Edit the `generate.py` module, and replace the placeholder definition for the
    `generate_chart()` function with the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`generate.py`模块，并用以下内容替换`generate_chart()`函数的占位符定义：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we create an `Image` object to hold our generated chart, initializing
    it to white using the hex color code `#ffffff`. We then use the `ImageDraw` module
    to define a `drawer` object to draw into the chart and call the various renderer
    modules to do all the work. Finally, we call `image.save()` to save the image
    file to disk.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们创建了一个`Image`对象来保存我们生成的图表，使用十六进制颜色代码`#ffffff`将其初始化为白色。然后我们使用`ImageDraw`模块来定义一个`drawer`对象来绘制图表，并调用各种渲染器模块来完成所有工作。最后，我们调用`image.save()`将图像文件保存到磁盘上。
- en: 'For this function to work, we need to add a few `import` statements to the
    top of our `generator.py` module:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个函数工作，我们需要在我们的`generator.py`模块的顶部添加一些`import`语句：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There''s one more thing that we haven''t dealt with yet: when we create the
    image, we make use of two constants which tell Pillow the dimensions of the image
    to create:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事我们还没有处理：当我们创建图像时，我们使用了两个常量，告诉Pillow要创建的图像的尺寸：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We need to define these two constants somewhere.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在某个地方定义这两个常量。
- en: As it turns out, we are going to need to define several more constants and use
    them throughout the Charter library. To allow for this, we'll create a special
    module just to hold our various constants.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们需要定义更多的常量并在整个Charter库中使用它们。为此，我们将创建一个特殊的模块来保存我们的各种常量。
- en: 'Create a new file named `constants.py` within the top-level `charter` directory.
    Inside this module, add the following values:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层`charter`目录中创建一个名为`constants.py`的新文件。在这个模块中，添加以下值：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, add the following `import` statement to your `generator.py` module:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的`generator.py`模块中添加以下`import`语句：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Testing the code
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试代码
- en: 'While we haven''t implemented any of our renderers, we have enough code in
    place to start testing. To do this, create an empty file named `test_charter.py`,
    and place it in the directory containing the `charter` package. Then, enter the
    following into this file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们还没有实现任何渲染器，但我们已经有足够的代码来开始测试。为此，创建一个名为`test_charter.py`的空文件，并将其放在包含`charter`包的目录中。然后，在此文件中输入以下内容：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is just a copy of the example code we saw earlier. This script will allow
    you to test the Charter library; open up a terminal or command-line window, `cd`
    into the directory containing the `test_charter.py` file, and type the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们之前看到的示例代码的副本。这个脚本将允许您测试Charter库；打开一个终端或命令行窗口，`cd`到包含`test_charter.py`文件的目录，并输入以下内容：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All going well, the program should finish without any errors. You can then look
    at the `chart.png` file, which should be an empty image file filled with a white
    background.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利的话，程序应该在没有任何错误的情况下完成。然后，您可以查看`chart.png`文件，这应该是一个填充有白色背景的空图像文件。
- en: Rendering the title
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染标题
- en: 'We next need to implement our various renderer modules, starting with the chart''s
    title. Edit the `renderers/title.py` file, and replace your placeholder definition
    of the `draw()` function with the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现各种渲染器模块，从图表的标题开始。编辑`renderers/title.py`文件，并用以下内容替换`draw()`函数的占位符定义：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This renderer starts by obtaining a font to use when drawing the title. It then
    calculates the size (in pixels) of the title text and the position to use for
    the label so that it is nicely centered on the chart. Notice that we use a constant
    named `TITLE_HEIGHT` to specify the amount of space to use for the chart's title.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个渲染器首先获取一个用于绘制标题的字体。然后计算标题文本的大小（以像素为单位）和用于标签的位置，以便它在图表上居中显示。请注意，我们使用一个名为`TITLE_HEIGHT`的常量来指定用于图表标题的空间量。
- en: The final line in this function draws the title onto the chart using the specified
    position and font. The string `#4040a0` is the hexadecimal color code to use for
    the text—this is a dark blue color.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的最后一行使用指定的位置和字体将标题绘制到图表上。字符串`#4040a0`是用于文本的十六进制颜色代码，这是一种深蓝色。
- en: 'Because this module uses the `ImageFont` module to load the font, as well as
    some constants from our `constants.py` module, we need to add the following `import`
    statements to the top of our module:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个模块使用`ImageFont`模块加载字体，以及我们的`constants.py`模块中的一些常量，我们需要在我们的模块顶部添加以下`import`语句：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that we use `..` to import the `constants` module from our parent package.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`..`从父包中导入`constants`模块。
- en: 'Finally, we need to add the `TITLE_HEIGHT` constant to our `constants.py` module:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将`TITLE_HEIGHT`常量添加到我们的`constants.py`模块中：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you now run your `test_charter.py` script, you should see the chart''s title
    appear in the generated image:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行您的`test_charter.py`脚本，您应该会看到生成的图像中出现图表的标题：
- en: '![Rendering the title](graphics/B05012_4_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![渲染标题](graphics/B05012_4_07.jpg)'
- en: Rendering the x axis
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染x轴
- en: If you remember, the *x* axis is a discrete axis with labels displayed between
    each tick mark. To draw this, we are going to have to calculate the width of each
    "bucket" on the axis, and then draw lines to represent the axis and the tick marks,
    as well as drawing the label for each bucket.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，* x *轴是一个离散轴，标签显示在每个刻度之间。为了绘制这个，我们将不得不计算轴上每个“桶”的宽度，然后绘制表示轴和刻度线的线，以及绘制每个“桶”的标签。
- en: 'Start by editing the `renderers/x_axis.py` file, and replace your placeholder
    `draw()` function with the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编辑`renderers/x_axis.py`文件，并用以下内容替换您的占位符`draw()`函数：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You''ll also need to add the following `import` statements at the top of your
    module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在模块顶部添加以下`import`语句：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, you should add the following definitions to your `constants.py` module:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该将以下定义添加到您的`constants.py`模块中：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These define the sizes of the fixed elements within the chart.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义了图表中固定元素的大小。
- en: 'If you now run your `test_charter.py` script, you should see the *x* axis displayed
    along the bottom of the chart:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行您的`test_charter.py`脚本，您应该会看到* x *轴显示在图表底部：
- en: '![Rendering the x axis](graphics/B05012_4_08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![渲染x轴](graphics/B05012_4_08.jpg)'
- en: The remaining renderers
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 剩下的渲染器
- en: As you can see, the generated image is starting to look more chart-like. Since
    the purpose of this package is to show how to structure your code, rather than
    the details of how these modules are implemented, let's skip ahead and add the
    remaining renderers without further discussion.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，生成的图像开始看起来更像图表了。由于这个包的目的是展示如何构建代码结构，而不是这些模块是如何实现的细节，让我们跳过并添加剩下的渲染器而不再讨论。
- en: 'Start by editing your `renderers/y_axis.py` file to look like the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编辑您的`renderers/y_axis.py`文件，使其如下所示：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, edit `renderers/bar_series.py` to look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`renderers/bar_series.py`，使其如下所示：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, edit `renderers.line_series.py` to look like the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编辑`renderers.line_series.py`，使其如下所示：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This completes our implementation of the Charter library.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对Charter库的实现。
- en: Testing Charter
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试Charter
- en: 'If you run the `test_charter.py` script, you should see a complete bar chart:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`test_charter.py`脚本，您应该会看到一个完整的条形图：
- en: '![Testing Charter](graphics/B05012_4_09.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![测试Charter](graphics/B05012_4_09.jpg)'
- en: There is obviously a lot more that we could do with the Charter library, but
    even in its current state, it works well. If you want, you can use it to generate
    line and bar charts for all sorts of data. For our purposes, we can declare the
    Charter library to be complete, and start using it as part of our production system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以在Charter库中做更多的事情，但即使在当前状态下，它也运行良好。如果您愿意，您可以使用它为各种数据生成线条和条形图。对于我们的目的，我们可以声明Charter库已经完成，并开始将其作为我们生产系统的一部分使用。
- en: The fly in the ointment – changing requirements
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变化的需求中的一块砂糖
- en: Of course, nothing is ever really finished. Let's pretend that you wrote the
    Charter library and have been busily extending it for several months, adding more
    data series types and lots of options. The library is being used in several big
    projects for your company, the output looks fantastic, and everyone seems to be
    very happy with it—until the day that your boss comes in and says, "It's too fuzzy.
    Can you take the fuzziness away?"
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有什么是真正完成的。假设你写了图书馆并且已经忙着扩展它好几个月，添加了更多的数据系列类型和大量的选项。该库正在公司的几个重大项目中使用，输出效果很棒，每个人似乎都对此很满意——直到有一天你的老板走进来说：“太模糊了。你能把模糊去掉吗？”
- en: 'You ask what he means, and he says that he''s been printing the charts out
    on a high-resolution laser printer. The results aren''t good enough for him to
    use in his company reports. He takes a printout and points to the heading. Looking
    closely, you can see what he means:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你问他是什么意思，他说他一直在一台高分辨率激光打印机上打印图表。结果对他来说还不够好，不能用在公司的报告中。他拿出一份打印件指着标题。仔细看，你明白了他的意思：
- en: '![The fly in the ointment – changing requirements](graphics/B05012_4_10.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![瓶中之蝇——需求变更](graphics/B05012_4_10.jpg)'
- en: Sure enough, the text is pixelated, and even the lines look a bit jagged when
    printed at high resolution. You try increasing the size of the generated chart,
    but it still doesn't look good enough—and when you try increasing the size to
    match the 1,200 dots per inch of the company's high-resolution laser printer,
    your program crashes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，文本是像素化的，即使线条在高分辨率打印时看起来也有点锯齿状。你尝试增加生成图表的大小，但仍然不够好——当你尝试将大小增加到公司高分辨率激光打印机的每英寸1200点时，你的程序崩溃了。
- en: '"But the program was never designed for that," you complain. "We wrote it to
    show charts on-screen."'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: “但这个程序从来没有为此设计过，”你抱怨道。“我们编写它是为了在屏幕上显示图表。”
- en: '"I don''t care," says your boss. "I want you to generate the output in vector
    format. That always prints fine, and isn''t fuzzy at all."'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: “我不在乎，”你的老板说。“我希望你生成矢量格式的输出。那样打印效果很好，一点都不模糊。”
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Just in case you haven''t encountered this before, there are two fundamentally
    different ways of storing image data: bitmapped images, which are made up of pixels,
    and vector images, where the individual drawing instructions (for example, "write
    some text", "draw a line," "fill a rectangle," and so on) are saved, and then
    these instructions are followed each time the image is to be displayed. Bitmapped
    images suffer from pixelation or "fuzziness," while vector images look great even
    when enlarged or printed at a high resolution.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以防你以前没有遇到过，存储图像数据有两种根本不同的方式：位图图像，由像素组成；矢量图像，其中保存了单独的绘图指令（例如，“写一些文字”，“画一条线”，“填充一个矩形”等），然后每次显示图像时都会遵循这些指令。位图图像会出现像素化或“模糊”，而矢量图像即使放大或以高分辨率打印时看起来也很棒。
- en: You do a quick Google search, and confirm that the Pillow library can't save
    vector-format images; it only works with bitmapped data. Your boss isn't sympathetic,
    "Just make it work in vector format, saving to PDF as well as PNG for those people
    already using it."
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你进行了快速的谷歌搜索，并确认Pillow库无法保存矢量格式的图像；它只能处理位图数据。你的老板并不同情，“只需使其以矢量格式工作，同时保存为PDF和PNG，以满足那些已经在使用它的人。”
- en: With a sinking heart, you wonder how you could possibly meet these new requirements.
    The whole Charter library has been built from the ground up to generate bitmapped
    PNG images. Won't you have to rewrite the whole thing from scratch?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 心情沉重，你想知道自己怎么可能满足这些新的要求。整个Charter库都是从头开始构建的，用于生成位图PNG图像。难道你不得不从头开始重写整个东西吗？
- en: Redesigning Charter
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新设计图书馆
- en: 'As the Charter library now needs to optionally save the chart as a vector-format
    PDF file, we need to find an alternative to the Python Imaging Library that supports
    writing to PDF files. There is one obvious candidate for this: **ReportLab**.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图书馆现在需要将图表保存为矢量格式的PDF文件，我们需要找到一个替代Python Imaging Library的支持写入PDF文件的库。其中一个明显的选择是**ReportLab**。
- en: ReportLab is a commercial PDF generator, which is also released under an open
    source license. You can find out more about the ReportLab toolkit at [http://www.reportlab.com/opensource/](http://www.reportlab.com/opensource/).
    The easiest way to install ReportLab is to use `pip install reportlab`. If this
    doesn't work for you, check out the installation instructions at [https://bitbucket.org/rptlab/reportlab](https://bitbucket.org/rptlab/reportlab)
    for more details. Documentation for the ReportLab toolkit can be found at [http://www.reportlab.com/docs/reportlab-userguide.pdf](http://www.reportlab.com/docs/reportlab-userguide.pdf).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ReportLab是一个商业PDF生成器，也以开源许可发布。你可以在[http://www.reportlab.com/opensource/](http://www.reportlab.com/opensource/)找到有关ReportLab工具包的更多信息。安装ReportLab的最简单方法是使用`pip
    install reportlab`。如果这对你不起作用，请查看[https://bitbucket.org/rptlab/reportlab](https://bitbucket.org/rptlab/reportlab)上的安装说明以获取更多详细信息。ReportLab工具包的文档可以在[http://www.reportlab.com/docs/reportlab-userguide.pdf](http://www.reportlab.com/docs/reportlab-userguide.pdf)找到。
- en: 'In many ways, ReportLab works in the same way as the Python Imaging Library:
    you initialize a document (called a **canvas** in ReportLab), call various methods
    to draw the elements onto the canvas, and then use the `save()` method to save
    the PDF file to disk.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，ReportLab的工作方式与Python Imaging Library相同：你初始化一个文档（在ReportLab中称为**画布**），调用各种方法将元素绘制到画布上，然后使用`save()`方法将PDF文件保存到磁盘上。
- en: 'There is one additional step, however: because the PDF file format supports
    multiple pages, you need to call the `showPage()` function to render the current
    page before saving the document. While we don''t need multiple pages for the Charter
    library, we could create multi-page PDF documents by calling `showPage()` after
    drawing each page, and then call `save()` to save the file to disk when we are
    finished.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个额外的步骤：因为PDF文件格式支持多页，你需要在保存文档之前调用`showPage()`函数来呈现当前页面。虽然我们不需要Charter库的多个页面，但我们可以通过在绘制每个页面后调用`showPage()`，然后在完成时调用`save()`来创建多页PDF文档并将文件保存到磁盘。
- en: Now that we have a tool that allows us to generate PDF files, let's take a look
    at how we can restructure the Charter package to support rendering in either PNG
    or PDF file format.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个工具，可以生成 PDF 文件，让我们看看如何重新构建 Charter 包，以支持 PNG 或 PDF 文件格式的渲染。
- en: The `generate_chart()` function seems to be the logical point at which the user
    should be able to choose the output format. In fact, we can detect the format
    automatically based on the file name—if the `filename` parameter ends with `.pdf`,
    then we should generate the chart in PDF format, while if the `filename` ends
    with `.png`, then we should generate the file in PNG format.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_chart()` 函数似乎是用户应该能够选择输出格式的逻辑点。实际上，我们可以根据文件名自动检测格式——如果 `filename`
    参数以 `.pdf` 结尾，那么我们应该生成 PDF 格式的图表，而如果 `filename` 以 `.png` 结尾，那么我们应该生成 PNG 格式的文件。'
- en: 'More generally, though, we have a problem with our renderers: they''re all
    designed to work with the Python Imaging Library, and use the `ImageDraw` module
    to draw each chart as a bitmapped image.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，我们的渲染器存在一个问题：它们都设计为与 Python Imaging Library 一起工作，并使用 `ImageDraw` 模块将每个图表绘制为位图图像。
- en: Because of this, and the complexity of the code inside each renderer module,
    it makes sense to leave these renderers alone and write new renderers that use
    ReportLab to generate the chart's elements in PDF format. To do this, we are going
    to need to **refactor** our rendering code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，以及每个渲染器模块内部的代码复杂性，将这些渲染器保持不变，并编写使用 ReportLab 生成 PDF 格式图表元素的新渲染器是有意义的。为此，我们需要对我们的渲染代码进行**重构**。
- en: 'Before we leap in and start making changes, let''s think about what we want
    to achieve. We''ll need to have two separate versions of each renderer—one to
    generate the element in PNG format and the other to generate the same element
    in PDF format:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们着手进行更改之前，让我们考虑一下我们想要实现什么。我们将需要每个渲染器的两个单独版本——一个用于生成 PNG 格式的元素，另一个用于生成相同的元素的
    PDF 格式：
- en: '![Redesigning Charter](graphics/B05012_4_11.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![重新设计 Charter](graphics/B05012_4_11.jpg)'
- en: Since all of these modules do the same thing—draw an element onto the chart—it
    would be good to have a single function that calls the appropriate renderer module's
    `draw()` function to draw a given chart element in the desired output format.
    This way, the rest of our code will only need to call one function, rather than
    choose between ten different `draw()` functions depending on the desired element
    and format.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些模块都做同样的事情——在图表上绘制一个元素，因此最好有一个单独的函数，调用适当的渲染器模块的 `draw()` 函数以在所需的输出格式中绘制给定的图表元素。这样，我们的其余代码只需要调用一个函数，而不是根据所需的元素和格式选择十个不同的
    `draw()` 函数。
- en: To do this, we'll add a new module called `renderer.py` within the `renderers`
    package, and leave calling the individual renderers to that module. This will
    simplify our design immensely.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将在 `renderers` 包内添加一个名为 `renderer.py` 的新模块，并将调用各个渲染器的工作留给该模块。这将极大简化我们的设计。
- en: Finally, our `generate_chart()` function is going to have to create a ReportLab
    canvas to generate the chart in PDF format, and then save this canvas when the
    chart has been generated, just like it does at the moment for the bitmapped image.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的 `generate_chart()` 函数将需要创建一个 ReportLab 画布以生成 PDF 格式的图表，然后在图表生成后保存这个画布，就像它现在为位图图像所做的那样。
- en: All this means that, while we have some work to do implementing new versions
    of our renderer modules, creating a new `renderer.py` module and updating the
    `generate_chart()` function, the rest of the system will remain exactly the same.
    We don't need to rewrite everything from scratch, and the rest of our modules—in
    particular, the existing renderers—don't have to be changed at all. Whew!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，虽然我们需要做一些工作来实现我们的渲染器模块的新版本，创建一个新的 `renderer.py` 模块并更新 `generate_chart()`
    函数，但系统的其余部分将保持完全相同。我们不需要从头开始重写一切，而我们的其余模块——特别是现有的渲染器——根本不需要改变。哇！
- en: Refactoring the code
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构代码
- en: We'll start our refactoring by moving the existing PNG renderers into a new
    sub-package called `renderers.png`. Create a new directory named `png` within
    the `renderers` directory, and move the `title.py`, `x_axis.py`, `y_axis.py`,
    `bar_series.py` and `line_series.py` modules into this directory. Then, create
    an empty package initialization file, `__init__.py`, inside the `png` directory
    so that Python will recognize it as a package.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将现有的 PNG 渲染器移动到名为 `renderers.png` 的新子包中来开始我们的重构。在 `renderers` 目录中创建一个名为
    `png` 的新目录，并将 `title.py`、`x_axis.py`、`y_axis.py`、`bar_series.py` 和 `line_series.py`
    模块移动到该目录中。然后，在 `png` 目录内创建一个空的包初始化文件 `__init__.py`，以便 Python 可以识别它为一个包。
- en: 'There is one minor change we are going to have to make to our existing PNG
    renderers: because each renderer module imports the `constants.py` module using
    a relative import, we will need to update these modules so that they can still
    find the `constants` module from their new position. To do this, edit each PNG
    renderer module in turn, and find the line that looks like the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不对现有的 PNG 渲染器进行一个小改动：因为每个渲染器模块使用相对导入导入 `constants.py` 模块，我们需要更新这些模块，以便它们仍然可以从新位置找到
    `constants` 模块。为此，依次编辑每个 PNG 渲染器模块，并找到以下类似的行：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add an extra `.` to each of these lines so that they look like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行的末尾添加一个额外的 `.`，使它们看起来像这样：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our next task is to create a package to hold our PDF-format renderers. Create
    a sub-directory named `pdf` in the `renderers` directory, and create an empty
    package initialization file in that directory to make it a Python package.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个任务是创建一个包来容纳我们的 PDF 格式渲染器。在 `renderers` 目录中创建一个名为 `pdf` 的子目录，并在该目录中创建一个空的包初始化文件，使其成为
    Python 包。
- en: 'We next want to implement the `renderer.py` module we talked about earlier
    so that our `generate_chart()` function can concentrate on drawing chart elements
    rather than worrying about which module each element is defined in. Create a new
    file named `renderer.py` inside the `renderers` directory, and add the following
    code to this file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要实现前面提到的`renderer.py`模块，以便我们的`generate_chart()`函数可以专注于绘制图表元素，而不必担心每个元素定义在哪个模块中。在`renderers`目录中创建一个名为`renderer.py`的新文件，并将以下代码添加到该文件中：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This module is doing something tricky, which you may not have encountered before:
    after importing each PNG-format renderer module using `import...as`, we then treat
    the imported modules as if they were Python variables, storing a reference to
    each module in the `renderers` dictionary. Our `draw()` function then selects
    the appropriate module from that dictionary using `renderers[format][element]`,
    and calls the `draw()` function within that module to do the actual drawing.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块正在做一些棘手的事情，这可能是你以前没有遇到过的：在使用`import...as`导入每个PNG格式的渲染器模块之后，我们将导入的模块视为Python变量，将每个模块的引用存储在`renderers`字典中。然后，我们的`draw()`函数使用`renderers[format][element]`从该字典中选择适当的模块，并调用该模块内部的`draw()`函数来进行实际绘制。
- en: This Python trick saves us a lot of coding—without it, we would have had to
    write a whole series of `if...then` statements to call the appropriate module's
    `draw()` function based on the desired element and format. Using a dictionary
    in this way saves us a lot of typing and makes the code much easier to read and
    debug.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python技巧为我们节省了大量的编码工作——如果没有它，我们将不得不编写一整套基于所需元素和格式调用适当模块的`if...then`语句。以这种方式使用字典可以节省我们大量的输入，并使代码更容易阅读和调试。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could have also used the Python Standard Library's `importlib` module to
    load a renderer module by name. This would have made our `renderer` module even
    shorter but would have made it harder to understand the code. Using `import...as`
    and a dictionary to select the desired module is a good trade-off between complexity
    and comprehensibility.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用Python标准库的`importlib`模块按名称加载渲染器模块。这将使我们的`renderer`模块更短，但会使代码更难理解。使用`import...as`和字典来选择所需的模块是复杂性和可理解性之间的良好折衷。
- en: We next need to update our `generate_report()` function. As discussed in the
    previous section, we want to choose the output format based on the file extension
    for the file being generated. We also need to update this function to use our
    new `renderer.draw()` function, rather than importing and calling the renderer
    modules directly.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的`generate_report()`函数。如前一节所讨论的，我们希望根据正在生成的文件的文件扩展名选择输出格式。我们还需要更新此函数以使用我们的新`renderer.draw()`函数，而不是直接导入和调用渲染器模块。
- en: 'Edit the `generator.py` module, and replace the contents of this module with
    the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`generator.py`模块，并用以下代码替换该模块的内容：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There's a lot of code in this module, but the comments should help to explain
    what is going on. As you can see, we use the supplied file name to set the `format`
    variable to `"pdf"` or `"png"` as appropriate. We then prepare the `output` variable
    to hold the generated image or PDF file. Next, we call `renderer.draw()` to draw
    each chart element in turn, passing in the `format` and `output` variables so
    that the renderer can do its job. Finally, we save the output to disk so that
    the chart will be saved to the appropriate PDF or PNG format file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块中有很多代码，但注释应该有助于解释发生了什么。正如你所看到的，我们使用提供的文件名将`format`变量设置为`"pdf"`或`"png"`。然后，我们准备`output`变量来保存生成的图像或PDF文件。接下来，我们依次调用`renderer.draw()`来绘制每个图表元素，传入`format`和`output`变量，以便渲染器可以完成其工作。最后，我们将输出保存到磁盘，以便将图表保存到适当的PDF或PNG格式文件中。
- en: With these changes in place, you should be able to use the updated Charter package
    to generate a PNG-format file. PDF files won't work yet because we haven't written
    the PDF renderers, but PNG format output should be working. Go ahead and test
    this by running the `test_charter.py` script, just to make sure you haven't made
    any typos entering the code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改，您应该能够使用更新后的Charter包来生成PNG格式文件。PDF文件还不能工作，因为我们还没有编写PDF渲染器，但PNG格式输出应该可以工作。继续运行`test_charter.py`脚本进行测试，以确保您没有输入任何拼写错误。
- en: Now that we've finished refactoring our existing code, let's add our PDF renderers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了重构现有代码，让我们添加PDF渲染器。
- en: Implementing the PDF renderer modules
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现PDF渲染器模块
- en: 'We will work through the various renderer modules one at a time. Start by creating
    the `titles.py` module inside the `pdf` directory, and enter the following code
    into this file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个处理各种渲染器模块。首先，在`pdf`目录中创建`titles.py`模块，并将以下代码输入到该文件中：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In some ways, this code is quite similar to the PNG version of this renderer:
    we calculate the width and height of the text and use this to calculate the position
    on the chart where the title should be drawn. We then draw the title in 24-point
    Helvetica font, in a dark blue color.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，这段代码与该渲染器的PNG版本非常相似：我们计算文本的宽度和高度，并使用这些来计算标题应该绘制的图表位置。然后，我们使用24点的Helvetica字体以深蓝色绘制标题。
- en: 'There are, however, some important differences:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些重要的区别：
- en: The way we calculate the width and the height of the text is different. For
    the width, we call the canvas's `stringWidth()` function, while for the height,
    we multiply the font size of the text by 1.2\. By default, ReportLab leaves a
    gap of 20% of the font size between lines of text, so multiplying the font size
    by 1.2 is an accurate way of calculating the height of a line of text.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们计算文本的宽度和高度的方式不同。对于宽度，我们调用画布的`stringWidth()`函数，而对于高度，我们将文本的字体大小乘以1.2。默认情况下，ReportLab在文本行之间留下字体大小的20%的间隙，因此将字体大小乘以1.2是计算文本行高的准确方式。
- en: The units used to calculate the position of elements on the page are different.
    ReportLab measures all positions and sizes using **points** rather than pixels.
    A point is roughly 1/72nd of an inch. Fortunately, one point is fairly close to
    the size of a pixel on a typical computer screen; this allows us to ignore the
    different measurement systems and have the PDF output still look good.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于计算页面上元素位置的单位不同。ReportLab 使用 **点** 而不是像素来测量所有位置和大小。一个点大约是一英寸的 1/72。幸运的是，一个点与典型计算机屏幕上的像素大小相当接近；这使我们可以忽略不同的测量系统，使得
    PDF 输出看起来仍然很好。
- en: PDF files use a different coordinate system to PNG files. In a PNG-format file,
    the top of the image has a *y* value of zero, while for PDF files *y=0* is at
    the bottom of the image. This means that all our positions on the page have to
    be calculated relative to the bottom of the page, rather than the top of the image
    as was done with the PNG renderers.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF 文件使用与 PNG 文件不同的坐标系统。在 PNG 格式文件中，图像的顶部 *y* 值为零，而对于 PDF 文件，*y=0* 在图像底部。这意味着我们在页面上的所有位置都必须相对于页面底部计算，而不是像
    PNG 渲染器中所做的那样相对于图像顶部计算。
- en: The colors are specified using RGB color values, where each component of the
    color is given as a number between zero and one. For example, a color value of
    `(0.25,0.25,0.625)` is equivalent to the hex color code `#4040a0`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色是使用 RGB 颜色值指定的，其中颜色的每个分量都表示为介于零和一之间的数字。例如，颜色值 `(0.25,0.25,0.625)` 相当于十六进制颜色代码
    `#4040a0`。
- en: 'Without further ado, let''s implement the remaining PDF renderer modules. The
    `x_axis.py` module should look like the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们实现剩下的 PDF 渲染模块。`x_axis.py` 模块应该如下所示：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, the `y_axis.py` module should be implemented as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`y_axis.py` 模块应该实现如下：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the `bar_series.py` module, enter the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `bar_series.py` 模块，输入以下内容：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, the `line_series.py` module should look like the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`line_series.py` 模块应该如下所示：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, these modules look very similar to their PNG versions. Anything
    we can do with the Python Imaging Library can also be done with ReportLab, as
    long as we allow for the differences in the ways these two libraries work.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些模块看起来与它们的 PNG 版本非常相似。只要我们考虑到这两个库工作方式的差异，我们可以用 ReportLab 做任何 Python
    Imaging Library 能做的事情。
- en: 'This leaves us with just one more change we have to make to complete our new
    implementation of the Charter library: we need to update the `renderer.py` module
    to make these new PDF renderer modules available. To do this, add the following
    `import` statements to the top of this module:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们只需要做一个更改，就能完成对 Charter 库的新实现：我们需要更新 `renderer.py` 模块，以使这些新的 PDF 渲染模块可用。为此，将以下
    `import` 语句添加到这个模块的顶部：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, in the part of this module where we define the `renderers` dictionary,
    create a new `pdf` entry to the dictionary by adding the following highlighted
    lines to your code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这个模块的部分中，我们定义了 `renderers` 字典，通过向你的代码添加以下突出显示的行，为字典创建一个新的 `pdf` 条目：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once this is done, you've finished refactoring and reimplementing the Charter
    module. Assuming you haven't made any mistakes, your library should now be able
    to generate charts in both PNG and PDF format.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些工作后，你已经完成了重构和重新实现 Charter 模块。假设你没有犯任何错误，你的库现在应该能够生成 PNG 和 PDF 格式的图表。
- en: Testing the code
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试代码
- en: 'To make sure your program works, edit your `test_charter.py` program and change
    the name of the output file from `chart.png` to `chart.pdf`. If you then run this
    program, you should end up with a PDF file that contains a high-quality version
    of your chart:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的程序正常工作，编辑你的 `test_charter.py` 程序，并将输出文件的名称从 `chart.png` 更改为 `chart.pdf`。然后运行这个程序，你应该会得到一个包含你的图表高质量版本的
    PDF 文件：
- en: '![Testing the code](graphics/B05012_4_12.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![测试代码](graphics/B05012_4_12.jpg)'
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the chart appears at the bottom of the page, rather than the top.
    This is because PDF files have their `y=0` position at the bottom of the page.
    You could easily move the chart to the top of the page by calculating the height
    of the page (in points) and adding an appropriate offset. Feel free to implement
    this if you want, but for now our task is complete.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图表出现在页面底部，而不是顶部。这是因为 PDF 文件将 `y=0` 位置放在页面底部。你可以通过计算页面的高度（以点为单位）并添加适当的偏移量，轻松地将图表移动到页面顶部。如果你愿意，可以实现这一点，但现在我们的任务已经完成。
- en: 'If you zoom in, you''ll see that the chart''s text still looks good:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你放大，你会发现图表的文本看起来仍然很好：
- en: '![Testing the code](graphics/B05012_4_13.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![测试代码](graphics/B05012_4_13.jpg)'
- en: This is because we're now generating a vector-format PDF file rather than a
    bitmapped image. This file can be printed on a high-quality laser printer without
    any pixelation. Even better, existing users of your library will still be able
    to request PNG versions of the charts and they won't notice any changes at all.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们现在生成的是矢量格式的 PDF 文件，而不是位图图像。这个文件可以在高质量激光打印机上打印，而不会出现像素化。更好的是，你库的现有用户仍然可以要求
    PNG 版本的图表，他们不会注意到任何变化。
- en: Congratulations—you did it!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你——你做到了！
- en: Lessons learned
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所得到的教训
- en: 'While the Charter library is just an example of modular Python programming,
    and you don''t really have a boss who insists you generate charts in PDF format,
    these examples were selected because the problem is anything but trivial, and
    the changes you needed to make were also very challenging. Looking back over what
    we have achieved, there are several things you may notice:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Charter 库只是 Python 模块化编程的一个例子，你并没有一个坚持要求你生成 PDF 格式图表的老板，但这些例子被选中是因为问题一点也不简单，你需要做出的改变也非常具有挑战性。回顾我们所取得的成就，你可能会注意到几件事情：
- en: 'When faced with a major change in requirements, our first reaction is usually
    a negative one: "Oh no! How could I possibly do that?,"a "It''ll never work,"
    and so on.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面对需求的重大变化，我们的第一反应通常是消极的：“哦，不！我怎么可能做到？”，“这永远不会起作用”，等等。
- en: Rather than jumping in and starting to tinker with the code, it is generally
    better to step back and think about the structure of the existing code base and
    what might need to be changed to meet the new requirements.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其着手开始修改代码，通常更好的做法是退后一步，思考现有代码库的结构以及为满足新需求可能需要做出的改变。
- en: Where the new requirement involves a library or tool you haven't used before,
    it is worth spending some time researching the possible options, and possibly
    writing a simple example program to check that the library will do what you want,
    before you start updating your code.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新需求涉及到以前未使用过的库或工具时，值得花一些时间研究可能的选项，并可能编写一个简单的示例程序来检查库是否能够满足您的要求，然后再开始更新您的代码。
- en: Through the judicious use of modules and packages, the changes needed to your
    existing code can be kept to a minimum. In Charter, we could make use of all our
    existing renderer modules, with only a minor change to the source code. We only
    had to rewrite one function (the `generate_chart()` function), and add a new `renderer`
    module to simplify access to our renderers, before writing a new PDF version of
    each renderer. In this way, the use of modular programming techniques helped to
    isolate the changes to just the affected parts of the program.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过谨慎使用模块和包，对现有代码所需的更改可以保持在最低限度。在Charter中，我们可以利用所有现有的渲染器模块，只需对源代码进行轻微更改。我们只需要重写一个函数（`generate_chart()`函数），并添加一个新的`renderer`模块来简化对渲染器的访问，然后编写每个渲染器的新PDF版本。通过这种方式，模块化编程技术的使用有助于将更改隔离到程序的受影响部分。
- en: As often happens, the resulting system is better than the one we started with.
    Rather than turning our program into spaghetti code, the requirement to support
    PDF generation resulted in a more modular and better structured library. In particular,
    the `renderer` module dealt with the complexity of rendering the various chart
    elements in various formats, allowing the rest of the system to simply call `renderer.draw()`
    to do the work rather than having to import and use lots of modules directly.
    Because of this change, we can easily add more chart elements, or more output
    formats, with minimal further changes to our code.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，最终的系统比我们开始时的系统更好。与其将我们的程序变成意大利面代码，支持PDF生成的需求导致了一个更模块化、更有结构的库。特别是，`renderer`模块处理了以各种格式渲染各种图表元素的复杂性，使得系统的其余部分只需调用`renderer.draw()`来完成工作，而无需直接导入和使用大量模块。由于这种改变，我们可以很容易地添加更多的图表元素或更多的输出格式，而对我们的代码进行最小的进一步更改。
- en: 'The overall lesson here is clear: rather than resist changes to your requirements,
    embrace them. The end result is a better system—more robust, more expandable,
    and often better organized. Provided, of course, that you do it right.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 总体教训很明显：与其抵制对需求的变化，不如接受它们。最终的结果是一个更好的系统——更健壮，更可扩展，通常也更有组织。当然，前提是你要做对。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we used modular programming techniques to implement a hypothetical
    chart-generation package called Charter. We saw how charts are made up of standard
    elements, and how this organization can be translated into program code. After
    successfully creating a working chart-generation library that renders charts as
    bitmapped images, we saw how a fundamental change in requirements can seem to
    be a problem at first, but is actually an opportunity to refactor and improve
    your code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们使用模块化编程技术来实现一个名为Charter的虚构图表生成包。我们看到图表由标准元素组成，以及如何将这种组织转化为程序代码。成功创建了一个能够将图表渲染为位图图像的工作图表生成库后，我们看到了需求上的根本变化起初似乎是一个问题，但实际上是重构和改进代码的机会。
- en: Following through with this hypothetical example, we refactored the Charter
    library to handle PDF formatted charts. In doing so, we learned that using modular
    techniques to respond to a major change in requirements can help to isolate the
    changes that need to be made, and that refactoring our code often results in a
    system that is better organized, more expandable and more robust than what we
    started with.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个虚构的例子，我们重构了Charter库以处理PDF格式的图表。在这样做的过程中，我们了解到使用模块化技术来应对需求的重大变化可以帮助隔离需要进行的更改，并且重构我们的代码通常会导致一个比起始状态更有组织、更可扩展和更健壮的系统。
- en: In the next chapter, we will learn how to use standard modular programming "patterns"
    to deal with a range of programming challenges.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用标准的模块化编程“模式”来处理各种编程挑战。
