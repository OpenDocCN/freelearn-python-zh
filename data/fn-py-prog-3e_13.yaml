- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: The PyMonad Library
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad 库
- en: 'A monad allows us to impose an order on an expression evaluation in an otherwise
    lenient language. We can use a monad to insist that an expression such as `a`` +`` b`` +`` c`
    is evaluated in left-to-right order. This can interfere with the compiler’s ability
    to optimize expression evaluation. This is necessary, however, when we want files
    to have their content read or written in a specific order: a monad is a way to
    assure that the `read()` and `write()` functions are evaluated in a particular
    order.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 单子允许我们在一个本应宽容的语言中对表达式评估强加一个顺序。我们可以使用单子来坚持将表达式 `a + b + c` 按从左到右的顺序评估。这可能会干扰编译器优化表达式评估的能力。然而，当我们希望文件的内容以特定的顺序读取或写入时，这是必要的：单子是一种确保
    `read()` 和 `write()` 函数以特定顺序评估的方法。
- en: Languages that are lenient and have optimizing compilers benefit from monads
    imposing order on the evaluation of expressions. Python, for the most part, is
    strict and does not optimize, meaning there are few practical requirements for
    monads in Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对宽容且具有优化编译器的语言来说，单子可以强加表达式评估的顺序，从而受益。Python 在很大程度上是严格的，并且不进行优化，这意味着在 Python
    中对单子的实际需求很少。
- en: While the PyMonad package contains a variety of monads and other functional
    tools, much of the package was designed to help folks understand functional programming
    using Python syntax. We’ll focus on a few features to help clarify this point
    of view.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 PyMonad 包包含各种单子和其他函数式工具，但该包的大部分设计是为了帮助人们使用 Python 语法理解函数式编程。我们将关注一些功能来帮助阐明这一观点。
- en: 'In this chapter, we’ll look at the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Downloading and installing PyMonad
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载和安装 PyMonad
- en: The idea of currying and how this applies to functional composition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化的概念以及它如何应用于函数式组合
- en: The PyMonad star operator for creating composite functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyMonad 的星号操作符用于创建复合函数
- en: Functors and techniques for currying data items with more generalized functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于使用更通用函数对数据项进行柯里化的函子和技术
- en: The `bind()` operation, using the Python `>>` operator, to create ordered monads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 的 `>>` 操作符的 `bind()` 操作来创建有序单子
- en: We’ll also explain how to build a Markov chain simulation using PyMonad techniques
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将解释如何使用 PyMonad 技术构建马尔可夫链模拟。
- en: What’s important is that Python doesn’t require the use of monads. In many cases,
    the reader will be able to rewrite the example using pure Python constructs. Doing
    this kind of rewrite can help solidify one’s understanding of functional programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，Python 不要求使用单子。在许多情况下，读者将能够使用纯 Python 构造重写示例。进行此类重写可以帮助巩固对函数式编程的理解。
- en: 13.1 Downloading and installing
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1 下载和安装
- en: The PyMonad package is available on the Python Package Index (PyPI). In order
    to add PyMonad to your environment, you’ll need to use the `python`` -m`` pip`` pymonad`
    command to install it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad 包可在 Python 包索引（PyPI）上找到。为了将 PyMonad 添加到您的环境中，您需要使用 `python -m pip pymonad`
    命令来安装它。
- en: This book used version 2.4.0 to test all of the examples. Visit [https://pypi.python.org/pypi/PyMonad](https://pypi.python.org/pypi/PyMonad)
    for more information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用版本 2.4.0 测试了所有示例。有关更多信息，请访问 [https://pypi.python.org/pypi/PyMonad](https://pypi.python.org/pypi/PyMonad)。
- en: 'Once the PyMonad package is installed, you can confirm it using the following
    commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 PyMonad 包，您可以使用以下命令进行确认：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will display the module’s docstring and confirm that things really are
    properly installed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示模块的文档字符串并确认一切确实已正确安装。
- en: The overall project name, PyMonad, uses mixed case. The installed Python package
    name that we import, `pymonad`, is all lower case.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 整个项目名称 PyMonad 使用混合大小写。我们导入的已安装 Python 包名称 `pymonad` 全部为小写。
- en: 13.2 Functional composition and currying
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2 函数式组合和柯里化
- en: 'Some functional languages work by transforming a multi-argument function syntax
    into a collection of single argument functions. This process is called currying:
    it’s named after logician Haskell Curry, who developed the theory from earlier
    concepts. We’ve looked at currying in depth in [Chapter 11](Chapter_11.xhtml#x1-23500011),
    [The Toolz Package](Chapter_11.xhtml#x1-23500011). We’ll revisit it from the PyMonad
    perspective here.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式语言通过将多参数函数语法转换为单个参数函数的集合来工作。这个过程称为柯里化：它以逻辑学家 Haskell Curry 命名，他开发了从早期概念的理论。我们已经在第
    11 章 [The Toolz Package](Chapter_11.xhtml#x1-23500011) 中深入探讨了柯里化。在这里，我们将从 PyMonad
    的角度重新审视它。
- en: 'Currying is a technique for transforming a multi-argument function into higher-order
    single argument functions. In a simple case, consider a function f(x,y) → z; given
    two arguments x and y; this will return some resulting value, z. We can curry
    the function f(x,y) into into two functions: f[c1](x) → f[c2](y) and f[c2](y)
    → z. Given the first argument value, x, evaluating the function f[c1](x) returns
    a new one-argument function, f[c2](y). This second function can be given the second
    argument value, y, and it returns the desired result, z.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是将多参数函数转换为高阶单参数函数的技术。在简单的情况下，考虑一个函数f(x,y) → z；给定两个参数x和y；这将返回某个结果值，z。我们可以将函数f(x,y)柯里化为两个函数：f[c1](x)
    → f[c2](y)和f[c2](y) → z。给定第一个参数值，x，评估函数f[c1](x)将返回一个新的单参数函数，f[c2](y)。这个第二个函数可以给第二个参数值，y，并返回所需的结果，z。
- en: 'We can evaluate a curried function in Python with concrete argument values
    as follows: `f_c1(2)(3)`. We apply the curried function to the first argument
    value of 2, creating a new function. Then, we apply that new function to the second
    argument value of 3.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用具体的参数值评估一个柯里化函数，如下所示：`f_c1(2)(3)`。我们将柯里化函数应用于第一个参数值2，创建一个新的函数。然后，我们将这个新函数应用于第二个参数值3。
- en: 'Let’s look at a concrete example in Python. For example, we have a function
    like the following one:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具体的Python例子。例如，我们有一个如下所示的功能：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a simple, multiple-regression-based model for systolic blood pressure.
    This predicts blood pressure from body mass index (BMI), age, gender (a value
    of 1 means male), and history of previous treatment (a value of 1 means previously
    treated). For more information on the model and how it’s derived, visit [http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html](http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于多重回归的收缩压简单模型。该模型从身体质量指数（BMI）、年龄、性别（值为1表示男性）和先前治疗史（值为1表示先前治疗过）预测血压。有关模型及其推导的更多信息，请访问[http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html](http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html)。
- en: 'We can use the `systolic_bp()` function with all four arguments, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用所有四个参数使用`systolic_bp()`函数，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A male person with a BMI of 25, age 50, and no previous treatment is predicted
    to have a blood pressure near 116\. The second example shows a similar woman with
    a history of treatment who will likely have a blood pressure of 121.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个BMI为25、50岁且没有先前治疗史的男性预测血压接近116。第二个例子显示了一个有治疗史的类似女性，其血压可能为121。
- en: 'Because we’ve used the `@curry` decorator, we can create intermediate results
    that are similar to partially applied functions. Take a look at the following
    command snippet that creates a new function, `treated()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经使用了`@curry`装饰器，我们可以创建类似于部分应用函数的中间结果。看看以下命令片段，它创建了一个新的函数`treated()`：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding case, we evaluated the `systolic_bp(25,`` 50,`` 0)` expression
    to create a curried function and assigned this to the `treated` variable. This
    built a new function, `treated`, with values for some of the parameters. The BMI,
    age, and gender values don’t typically change for a given patient. We can now
    apply the new `treated()` function to the remaining argument value to get different
    blood pressure expectations based on patient history.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们评估了`systolic_bp(25, 50, 0)`表达式来创建一个柯里化函数，并将其分配给`treated`变量。这构建了一个新的函数`treated`，其中包含一些参数的值。BMI、年龄和性别值对于一个特定的病人通常不会改变。现在我们可以将新的`treated()`函数应用于剩余的参数值，以根据患者病史获得不同的血压预期值。
- en: 'Here’s an example of creating some additional curried functions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个创建一些额外柯里化函数的例子：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a gender-based treatment function based on our initial model. We must
    provide both the needed gender and treatment argument values to get a final value
    from the model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于我们初始模型的基于性别的处理函数。我们必须提供所需的性别和处理参数值，才能从模型中获得最终值。
- en: This is similar in some respects to the `functools.partial()` function. The
    important difference is that currying creates a function that can work in a variety
    of ways. The `functools.partial()` function creates a more specialized function
    that can only be used with the given set of bound values. For more information,
    see [Chapter 10](Chapter_10.xhtml#x1-21700010), [The Functools Module](Chapter_10.xhtml#x1-21700010).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，这与`functools.partial()`函数类似。重要的区别在于柯里化创建了一个可以以多种方式工作的函数。`functools.partial()`函数创建了一个更专业的函数，它只能与给定的绑定值集一起使用。有关更多信息，请参阅[第10章](Chapter_10.xhtml#x1-21700010)、[Functools模块](Chapter_10.xhtml#x1-21700010)。
- en: 13.2.1 Using curried higher-order functions
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1 使用柯里化高阶函数
- en: 'An important application of currying shows up when we use it on higher-order
    functions. We can, for example, curry the `reduce` function, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化在应用于高阶函数时显示出其重要应用。例如，我们可以柯里化`reduce`函数，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `creduce()` function is a curried function; we can now use it to create
    functions by providing some of the required argument values. In the next example,
    we will use `operator.add` as one of the two argument values to reduce. We can
    create a new function, and assign this to `my_sum`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`creduce()`函数是一个柯里化函数；我们现在可以通过提供一些必需的参数值来使用它来创建函数。在下一个示例中，我们将使用`operator.add`作为两个参数值之一来进行归约。我们可以创建一个新的函数，并将其分配给`my_sum`。'
- en: 'We can create and use this new `my_sum()` function as shown in the following
    example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建并使用这个新的`my_sum()`函数，如下例所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also use our curried `creduce()` function with other binary operators
    to create other reductions. The following shows how to create a reduction function
    that finds the maximum value in a sequence:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用我们的柯里化`creduce()`函数与其他二元运算符一起创建其他归约。以下是如何创建一个查找序列中最大值的归约函数的示例：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We defined our own version of the default `max()` function using a lambda object
    that picks the larger of two values. We could use the built-in `max()` function
    for this. More usefully, we could use more sophisticated comparisons among items
    to locate a local maxima. For geofencing applications, we might have a maximum
    east-west function separate from a maximum north-south function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个lambda对象来定义了自己的`max()`函数版本，该对象选择两个值中较大的一个。我们可以使用内置的`max()`函数来完成这个任务。更有用的一点是，我们可以使用更复杂的比较来定位局部最大值。对于地理围栏应用，我们可能有一个东西方向的函数和一个南北方向的函数是分开的。
- en: We can’t easily create the more general form of the `max()` function using the
    PyMonad `curry()` function. This implementation is focused on positional parameters.
    Trying to use the `key=` keyword parameter adds too much complexity to make the
    technique work toward our overall goals of succinct and expressive functional
    programs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能轻易地使用PyMonad的`curry()`函数来创建`max()`函数的更通用形式。这个实现专注于位置参数。尝试使用`key=`关键字参数会添加太多的复杂性，使得这项技术无法实现我们的目标，即简洁和表达性的函数程序。
- en: The built-in reductions including the `max()`, `min()`, and `sorted()` functions
    all rely on an optional `key=` keyword parameter paradigm. Creating curried versions
    means we need variants of these that accept a function as the first argument in
    the same way as the `filter()`, `map()`, and `reduce()` functions do. We could
    also create our own library of more consistent higher-order curried functions.
    These functions would rely exclusively on positional parameters, and follow the
    pattern of providing the function first and the values last.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的归约包括`max()`、`min()`和`sorted()`函数都依赖于一个可选的`key=`关键字参数范式。创建柯里化版本意味着我们需要这些函数的变体，它们接受一个函数作为第一个参数，就像`filter()`、`map()`和`reduce()`函数一样。我们还可以创建自己的更一致的更高阶柯里化函数库。这些函数将仅依赖于位置参数，并遵循首先提供函数然后提供值的模式。
- en: 13.2.2 Functional composition with PyMonad
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2 使用PyMonad进行函数组合
- en: One of the significant benefits of using curried functions is the ability to
    combine them through functional composition. We looked at functional composition
    in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005),
    and [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用柯里化函数的一个重要好处是能够通过函数组合来组合它们。我们在[第5章](Chapter_05.xhtml#x1-1000005)、[高阶函数](Chapter_05.xhtml#x1-1000005)和[第12章](Chapter_12.xhtml#x1-25000012)、[装饰器设计技术](Chapter_12.xhtml#x1-25000012)中探讨了函数组合。
- en: When we’ve created a curried function, we can more easily perform function composition
    to create a new, more complex curried function. In this case, the PyMonad package
    defines the `*` operator for composing two functions. To explain how this works,
    we’ll define two curried functions that we can compose. First, we’ll define a
    function that computes the product, and then we’ll define a function that computes
    a specialized range of values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了一个咖喱函数后，我们可以更容易地进行函数组合，以创建一个新的、更复杂的咖喱函数。在这种情况下，PyMonad 包定义了用于组合两个函数的 `*`
    操作符。为了解释它是如何工作的，我们将定义两个可以组合的咖喱函数。首先，我们将定义一个计算乘积的函数，然后我们将定义一个计算特定范围值的函数。
- en: 'Here’s our first function, which computes the product:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个函数，它计算乘积：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is based on our curried `creduce()` function that was defined previously.
    It uses the `operator.mul()` function to compute a times-reduction of an iterable:
    we can call a product a times-reduce of a sequence.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这基于我们之前定义的咖喱 `creduce()` 函数。它使用 `operator.mul()` 函数来计算可迭代对象的乘法降维：我们可以将乘积称为序列的乘法降维。
- en: 'Here’s our second curried function that will produce a range of even or odd
    values:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第二个咖喱函数，它将生成一系列偶数或奇数值：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result of the `alt_range()` function will be even values or odd values.
    It will have only odd values up to (and including) `n`, if `n` is odd. If `n`
    is even, it will have only even values up to `n`. The sequences are important
    for implementing the semifactorial or double factorial function, n!!.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`alt_range()` 函数的结果将是偶数或奇数值。如果 `n` 是奇数，它将只包含（包括）`n` 以上的奇数。如果 `n` 是偶数，它将只包含
    `n` 以上的偶数。这些序列对于实现半阶乘或双阶乘函数 n!! 是重要的。'
- en: 'Here’s how we can combine the `prod()` and `alt_range()` functions to compute
    a result:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将 `prod()` 和 `alt_range()` 函数组合起来计算结果的方法：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One very interesting use of curried functions is the idea of creating a composition
    of those functions that can be applied to argument values. The PyMonad package
    provides operators for this, but they can be confusing. What seems better is making
    use of the `Compose` subclass of `Monad`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 咖喱函数的一个非常有趣的应用是创建可以应用于参数值的函数组合。PyMonad 包提供了这样的操作符，但它们可能会令人困惑。更好的做法是利用 `Monad`
    的 `Compose` 子类。
- en: 'We can use `Compose` to implement functional composition in a direct way. The
    following example shows how we can compose our `alt_range()` and `prod()` functions
    to compute the semifactorial:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用 `Compose` 来实现函数组合。以下示例展示了我们如何组合 `alt_range()` 和 `prod()` 函数来计算半阶乘：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve built a `Compose` monad from the `alt_range()` function composed with
    the `prod()` function. The resulting function can be applied to an argument value
    to compute a result from the composition of the two functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `alt_range()` 函数与 `prod()` 函数的组合中构建了一个 `Compose` 单子。这个函数可以应用于一个参数值，从两个函数的组合中计算结果。
- en: Using curried functions can help to clarify a complex computation by eliding
    some of the argument-passing details.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用咖喱函数可以帮助通过省略一些参数传递的细节来澄清复杂的计算。
- en: 'Note that the `then()` method imposes a strict ordering: first, compute the
    range. Once that is done, use the result to compute the final product.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`then()` 方法强加了一个严格的顺序：首先，计算范围。一旦完成，就使用结果来计算最终乘积。
- en: 13.3 Functors – making everything a function
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3 函子 – 将一切变为函数
- en: 'The idea of a functor is a functional representation of a piece of simple data.
    A functor version of the number 3.14 is a function of zero arguments that returns
    this value. Consider the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 函子的概念是对简单数据的一个函数表示。3.14 的函子版本是一个零参数函数，返回这个值。考虑以下示例：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We created a zero-argument lambda object that returns a Python float object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个零参数的 lambda 对象，它返回一个 Python 浮点对象。
- en: When we apply a curried function to a functor, we’re creating a new curried
    functor. This generalizes the idea of applying a function to an argument to get
    a value by using functions to represent the arguments, the values, and the functions
    themselves.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将咖喱函数应用于函子时，我们正在创建一个新的咖喱函子。这通过使用函数来表示参数、值以及函数本身，将应用函数到参数以获取值的概念进行了推广。
- en: Once everything in our program is a function, then all processing becomes a
    variation on the theme of functional composition. To recover the underlying Python
    object, we can use the `value` attribute of a functor object to get a Python-friendly,
    simple type that we can use in uncurried code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们程序中的所有内容都是函数，那么所有处理就变成了函数组合主题的变体。为了恢复底层的 Python 对象，我们可以使用函子对象的 `value` 属性来获取一个适合
    Python 的简单类型，我们可以在未柯里化的代码中使用它。
- en: Since this kind of programming is based on functional composition, no calculation
    needs to be done until we actually demand a value using the `value` attribute.
    Instead of performing a lot of intermediate calculations, our program defines
    intermediate complex objects that can produce a value when requested. In principle,
    this composition can be optimized by a clever compiler or runtime system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种编程基于函数组合，直到我们实际使用 `value` 属性要求一个值之前，不需要进行任何计算。而不是执行大量的中间计算，我们的程序定义了可以在请求时产生值的中间复杂对象。原则上，这种组合可以通过一个聪明的编译器或运行时系统进行优化。
- en: In order to work politely with functions that have multiple arguments, PyMonad
    offers a `to_arguments()` method. This is a handy way to clarify the argument
    value being provided to a curried function. We’ll see an example of this below,
    after introducing the `Maybe` and `Just` monads.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了礼貌地与具有多个参数的函数一起工作，PyMonad 提供了一个 `to_arguments()` 方法。这是一个澄清提供给柯里化函数的参数值的好方法。我们将在介绍
    `Maybe` 和 `Just` 单子之后看到这个示例。
- en: We can wrap a Python object with a subclass of the `Maybe` monad. The `Maybe`
    monad is interesting, because it gives us a way to deal gracefully with missing
    data. The approach we used in [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator
    Design Techniques](Chapter_12.xhtml#x1-25000012), was to decorate built-in functions
    to make them `None`-aware. The approach taken by the PyMonad library is to decorate
    the data to distinguish something that’s just an object from nothing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `Maybe` 单子的子类包装一个 Python 对象。`Maybe` 单子很有趣，因为它为我们提供了一种优雅地处理缺失数据的方法。我们在第
    12 章[装饰器设计技术](Chapter_12.xhtml#x1-25000012)中使用的方法是装饰内置函数以使它们对 `None` 有意识。PyMonad
    库采用的方法是装饰数据以区分只是一个对象和什么都没有。
- en: 'There are two subclasses of the `Maybe` monad:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe` 单子有两种子类：'
- en: '`Nothing`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nothing`'
- en: '`Just(` some Python object `)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Just(` 一些 Python 对象 `)`'
- en: We use `Nothing` similarly to the Python value of `None`. This is how we represent
    missing data. We use `Just()` to wrap all other Python objects. These are also
    functors, offering function-like representations of constant values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Nothing` 类似于 Python 的 `None` 值。这是我们表示缺失数据的方式。我们使用 `Just()` 来包装所有其他 Python
    对象。这些也是函子，提供了类似函数的常量值的表示。
- en: 'We can use a curried function with these `Maybe` objects to tolerate missing
    data gracefully. Here’s a short example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用柯里化函数与这些 `Maybe` 对象一起使用，以优雅地容忍缺失的数据。以下是一个简短的例子：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This shows us how a monad can provide an answer instead of raising a `TypeError`
    exception. This can be very handy when working with large, complex datasets in
    which data could be missing or invalid.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明了单子如何提供答案而不是引发 `TypeError` 异常。当与可能缺失或无效的大型、复杂数据集一起工作时，这可以非常方便。
- en: We must use the `value` attribute to extract the simple Python value for uncurried
    Python code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `value` 属性来提取未柯里化的 Python 代码的简单 Python 值。
- en: 13.3.1 Using the lazy ListMonad() monad
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1 使用懒的 `ListMonad()` 单子
- en: The `ListMonad()` monad can be confusing at first. It’s extremely lazy, unlike
    Python’s built-in list type. When we evaluate the a `list(range(10))` expression,
    the `list()` function will evaluate the `range()` object to create a list with
    10 items. The PyMonad `ListMonad()` monad, however, is too lazy to even do this
    evaluation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListMonad()` 单子一开始可能会让人困惑。它极其懒惰，与 Python 内置的列表类型不同。当我们评估 `list(range(10))`
    表达式时，`list()` 函数将评估 `range()` 对象以创建一个包含 10 个项目的列表。然而，PyMonad 的 `ListMonad()` 单子懒惰到甚至不进行这种评估。'
- en: 'Here’s the comparison:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对比：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ListMonad()` monad did not evaluate the `range()` object’s iterable sequence
    of values; it preserved it without being evaluated. A `ListMonad()` monad is useful
    for collecting functions without evaluating them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListMonad()` 单子没有评估 `range()` 对象的值序列的可迭代序列；它保留它而不进行评估。`ListMonad()` 单子对于收集函数而不评估它们非常有用。'
- en: 'We can evaluate the `ListMonad()` monad later as required:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在需要时评估 `ListMonad()` 单子：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We created a lazy `ListMonad()` object which contained a `range()` object. Then
    we extracted and evaluated a `range()` object at position 0 in that list.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个懒加载的 `ListMonad()` 对象，其中包含一个 `range()` 对象。然后我们在该列表的位置0提取并评估了一个 `range()`
    对象。
- en: A `ListMonad()` object won’t evaluate a generator function. It treats any iterable
    argument as a single iterator object. We can, later, apply the function being
    contained by the monad.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListMonad()` 对象不会评估生成器函数。它将任何可迭代参数视为一个单一的迭代器对象。我们可以在以后应用被函子包含的函数。'
- en: 'Here’s a curried version of the `range()` function. This has a lower bound
    of 1 instead of 0\. It’s handy for some mathematical work because it allows us
    to avoid the complexity of the positional arguments in the built-in `range()`
    function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `range()` 函数的柯里化版本。它的下限是1而不是0。这对于某些数学工作很有用，因为它允许我们避免内置 `range()` 函数中位置参数的复杂性：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We wrapped the built-in `range()` function to make it curryable by the PyMonad
    package.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 PyMonad 包将内置的 `range()` 函数包装起来，使其可柯里化。
- en: Since a `ListMonad` object is a functor, we can map functions to the `ListMonad`
    object. The function is applied to each item in the `ListMonad` object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ListMonad` 对象是一个函子，我们可以将函数映射到 `ListMonad` 对象。该函数应用于 `ListMonad` 对象中的每个项目。
- en: 'Here’s an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We defined a composite function, `fact()`, which was built from the `prod()`
    and `range1n()` functions shown previously. This is the factorial function. We
    created a `ListMonad()` functor, `seq1`, which is a sequence of 20 values. We
    mapped the `fact()` function to the `seq1` functor, which created a sequence of
    factorial values, `f1`. Finally, we extracted the first 10 of these values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个复合函数，`fact()`，它是由之前展示的 `prod()` 和 `range1n()` 函数构建的。这是阶乘函数。我们创建了一个 `ListMonad()`
    函子，`seq1`，它是一个包含20个值的序列。我们将 `fact()` 函数映射到 `seq1` 函子，从而创建了一个阶乘值的序列，`f1`。最后，我们提取了这些值中的前10个。
- en: 'Here’s another little function that we’ll use to extend this example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于扩展这个示例的另一个小函数：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This little `n21()` function does a simple computation. It’s curried, however,
    so we can apply it to a functor such as a `ListMonad()` object. Here’s the next
    part of the preceding example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小小的 `n21()` 函数执行一个简单的计算。然而，它是柯里化的，因此我们可以将其应用于一个函子，如 `ListMonad()` 对象。以下是前面示例的下一部分：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ve defined a composite function from the `prod()` and `alt_range()` functions
    shown previously. The value of the `f2` object is built by mapping our small `n21()`
    function applied to the `seq1` sequence. This creates a new sequence. We then
    applied the `semi_fact()` function to each object in this new sequence to create
    a sequence of values that are parallels to the `f1` sequence of values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个复合函数，由之前展示的 `prod()` 和 `alt_range()` 函数组成。`f2` 对象的值是通过将我们的小 `n21()` 函数应用于
    `seq1` 序列来构建的。这创建了一个新的序列。然后我们对这个新序列中的每个对象应用了 `semi_fact()` 函数，以创建一个与 `f1` 值序列平行的值序列。
- en: 'We can now map the `/` operator, `operator.truediv`, to these two parallel
    sequences of values, `f1` and `f2`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将 `/` 操作符，`operator.truediv`，映射到这两个平行的值序列，`f1` 和 `f2`：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The built-in `map()` function will apply the given operator to both functors,
    yielding a sequence of fractions that we can add.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `map()` 函数将给定的操作符应用于两个函子，得到一个可以相加的分数序列。
- en: 'We defined a fairly complex calculation using a few functional composition
    techniques and a functor class definition. This is based on a computation for
    the arctangent. Here’s the full definition for this calculation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一些函数组合技术和一个函子类定义定义了一个相当复杂的计算。这是基于反正切的计算。以下是这个计算的完整定义：
- en: '![ ∑ ---n!---- π = 2 (2n + 1)!! 0≤n<∞ ](img/file119.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ ---n!---- π = 2 (2n + 1)!! 0≤n<∞ ](img/file119.jpg)'
- en: Ideally, we prefer not to use a fixed-size `ListMonad` object with only twenty
    values. We’d prefer to have a lazy and potentially infinite sequence of integer
    values, allowing us an approximation of arbitrary accuracy. We could then use
    curried versions of the `sum()` and `takewhile()` functions to find the sum of
    values in the sequence until the values are too small to contribute to the result.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们更倾向于不使用只有20个值的固定大小的 `ListMonad` 对象。我们更希望有一个懒加载的、可能无限的整数值序列，这样我们可以得到任意精度的近似。然后我们可以使用
    `sum()` 和 `takewhile()` 函数的柯里化版本来找到序列中值的和，直到这些值太小，无法对结果产生影响。
- en: This rewrite to use the `takewhile()` function is left as an exercise for the
    reader.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个使用 `takewhile()` 函数的重写留给读者作为练习。
- en: 13.4 Monad bind() function
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4 Monad bind() 函数
- en: 'The name of the PyMonad library comes from the functional programming concept
    of a monad, a function that has a strict order. The underlying assumption behind
    much functional programming is that functional evaluation is liberal: it can be
    optimized or rearranged as necessary. A monad provides an exception that imposes
    a strict left-to-right order.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad库的名字来源于函数式编程中的单子概念，即具有严格顺序的函数。许多函数式编程背后的基本假设是函数式评估是自由的：它可以按需优化或重新排序。单子提供了一个例外，强制执行从左到右的严格顺序。
- en: Python, as we have seen, is already strict. It doesn’t require monads. We can,
    however, still apply the concept in places where it can help clarify a complex
    algorithm. We’ll look at an example, below, of using a monad-based approach to
    designing a simulation based on Markov chains.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Python已经是严格的。它不需要单子。然而，我们仍然可以在有助于澄清复杂算法的地方应用这个概念。下面我们将通过一个例子来看使用基于单子的方法来设计基于马尔可夫链的模拟。
- en: The technology for imposing strict evaluation is a binding between a monad and
    a function that will return a monad. A flat expression will become nested bindings
    that can’t be reordered by an optimizing compiler. The `then()` method of a monad
    imposes this strict ordering.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 强制严格评估的技术是连接一个单子（monad）和一个将返回单子的函数的绑定。一个平坦的表达式将变成嵌套的绑定，优化编译器无法重新排序。单子的`then()`方法强制这种严格的顺序。
- en: In other languages, such as Haskell, a monad is crucial for file input and output
    where strict ordering is required. Python’s imperative mode is much like a Haskell
    `do` block, which has an implicit Haskell `>>=` operator to force the statements
    to be evaluated in order. PyMonad uses the `then()` method for this binding.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，如Haskell，单子对于需要严格顺序的文件输入和输出至关重要。Python的命令式模式与Haskell的`do`块非常相似，它有一个隐式的Haskell
    `>>=`运算符，用于强制按顺序评估语句。PyMonad使用`then()`方法进行这种绑定。
- en: 13.5 Implementing simulation with monads
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5 使用单子实现模拟
- en: 'Monads are expected to pass through a kind of pipeline: a monad will be passed
    as an argument to a function and a similar monad will be returned as the value
    of the function. The functions must be designed to accept and return similar structures.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 预期单子将通过一种管道：单子将被作为参数传递给一个函数，并且将返回一个类似的单子作为函数的值。函数必须设计成可以接受和返回类似的结构。
- en: We’ll look at a monad-based pipeline that can be used for simulation of a process.
    This kind of simulation is sometimes called a Monte Carlo simulation. In this
    case, the simulation will create a Markov chain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一个可以用于过程模拟的单子基础管道。这种模拟有时被称为蒙特卡洛模拟。在这种情况下，模拟将创建一个马尔可夫链。
- en: A Markov chain is a model for a series of potential events. The probability
    of each event depends only on the state attained in the previous event. Each state
    of the overall system had a set of probabilities that define the events and related
    state changes. It fits well with games that involve random chance, like dice or
    cards. It also fits well with industrial processes where small random effects
    can ”ripple through” the system, leading to effects that may not appear to be—directly—related
    to tiny initial problems.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链是一系列潜在事件的模型。每个事件发生的概率只取决于前一个事件中达到的状态。整个系统的每个状态都有一个概率集，这些概率定义了事件和相关状态变化。它非常适合涉及随机机会的游戏，如骰子或牌戏。它也适合于工业流程，其中小的随机效应可以“波及”整个系统，导致可能看似与微小初始问题直接无关的效果。
- en: Our example involves some rules for a fairly complex simulation. We can visualize
    the following state changes shown in Figure 13.1 as creating a chain of events
    that ends with either a Pass or Fail event. The number of events has a lower bound
    of 1.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子涉及一些相当复杂模拟的规则。我们可以将图13.1中显示的以下状态变化可视化为创建一个以通过或失败事件结束的事件链。事件的数量有一个下限为1。
- en: '![Figure 13.1: Markov chain generator ](img/file120.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：马尔可夫链生成器](img/file120.jpg)'
- en: 'Figure 13.1: Markov chain generator'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：马尔可夫链生成器
- en: The state transition probabilities are stated as fractions, ![n- 36](img/file121.jpg),
    because this particular Markov chain generator comes from a game that uses two
    dice. There are 36 possible outcomes from a roll of the dice. When considering
    the sum of the two dice, the 10 distinct values have probabilities ranging from
    ![-1 36](img/file122.jpg) for the values 2 and 12, to ![ 6 36](img/file123.jpg)
    for the value 7.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 状态转换概率以分数形式表示，![n- 36](img/file121.jpg)，因为这个特定的马尔可夫链生成器来自使用两个骰子的游戏。掷骰子有36种可能的结果。当考虑两个骰子的和时，10个不同的值有不同的概率，从值为2和12的![
    -1 36](img/file122.jpg)到值为7的![ 6 36](img/file123.jpg)。
- en: Because this is based on a game, the actual algorithm is somewhat simpler than
    the diagram of the state transitions. The trick in simplifying the algorithm description
    is combining a number of similar behaviors into a single state defined by a parameter,
    p.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是基于游戏的，所以实际算法比状态转换图要简单一些。简化算法描述的技巧是将多个类似行为组合成一个由参数p定义的单个状态。
- en: The algorithm’s use of an internal state. For designers new to functional programming,
    this is a bit of a problem. The solution that we’ve shown in other examples is
    to expose the state as a parameter to a function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 算法使用内部状态。对于刚开始接触函数式编程的设计师来说，这是一个问题。我们在其他示例中展示的解决方案是将状态作为函数的参数公开。
- en: We’ll start with a presentation of the algorithm with explicit state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个具有显式状态的算法展示开始。
- en: '![Algorithm 9: Markov chain generator ](img/Algo_13.1.JPG)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![算法9：马尔可夫链生成器](img/Algo_13.1.JPG)'
- en: 'Algorithm 9: Markov chain generator'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 算法9：马尔可夫链生成器
- en: The algorithm can be seen as requiring a state change. Alternatively, we can
    look at this as a sequence of operations to append to the Markov chain, rather
    than a state change. There’s one function that must be used first to create an
    initial outcome or establish the value of p. Another, recursive function is used
    after that to iterate until an outcome is determined. In this way, this pairs-of-functions
    approach fits the monad design pattern nicely.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法可以看作是要求状态改变。或者，我们可以将其视为要附加到马尔可夫链上的操作序列，而不是状态改变。有一个必须首先使用的函数来创建初始结果或确定p的值。之后，另一个递归函数用于迭代，直到确定结果。这样，这种函数对的方法非常适合单子设计模式。
- en: 'To build Markov chains, we’ll need a source of random numbers:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建马尔可夫链，我们需要一个随机数源：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding function will generate a pair of dice for us. We also included
    a type hint, `DiceT`, that can be used to describe any similar function that returns
    a tuple with two integers. The type hint will be used in later functions as a
    shorthand for any similar random number generator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将为我们生成一对骰子。我们还包含了一个类型提示`DiceT`，它可以用来描述任何返回包含两个整数的元组的类似函数。类型提示将在后续函数中用作任何类似随机数生成器的简称。
- en: 'Here’s our expectations from the overall chain generator based on the game
    algorithm:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于游戏算法的总体链生成器的预期：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create an initial monad, `Just(("",`` 0,`` []))`, to define the essential
    type we’re going to work with. A game will produce a three-tuple with the outcome
    text, the point value, and a sequence of rolls. At the start of each game, a default
    three-tuple establishes the three-tuple type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个初始单子`Just(("",`` 0,`` []))`来定义我们将要工作的基本类型。一个游戏将产生一个包含结果文本、得分值和一系列掷骰子的三重元组。在每场游戏的开始，一个默认的三重元组建立了三重元组类型。
- en: We pass this monad to two other functions. This will create a resulting monad,
    `outcome`, with the results of the game. We use the `then()` method to connect
    the functions in the specific order they must be executed. In a language with
    an optimizing compiler, this will prevent the expression from being rearranged.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个单子传递给另外两个函数。这将创建一个包含游戏结果的最终单子`outcome`。我们使用`then()`方法以特定的顺序连接函数，在具有优化编译器的语言中，这将防止表达式被重新排列。
- en: We will get the value of the monad at the end using the `value` attribute. Since
    the monad objects are lazy, this request is what triggers the evaluation of the
    various monads to create the required output.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`value`属性在末尾获取单子的值。由于单子对象是惰性的，这个请求将触发对各种单子的评估，以创建所需输出。
- en: Each resulting sequence of three-tuples is a Markov chain we can analyze to
    determine the overall statistical properties. We’re often interested in the expected
    lengths of the chains. This can be difficult to predict from the initial model
    or the algorithm.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个由三元组组成的序列结果是一个我们可以分析的马尔可夫链，以确定整体统计特性。我们通常对链的预期长度感兴趣。这可能很难从初始模型或算法中预测。
- en: The `initial_roll()` function has the `rng()` function curried as the first
    argument. The monad will become the second argument to this function. The `initial_roll()`
    function can roll the dice and apply the come out rule to determine if we have
    a pass, a fail, or a point.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial_roll()` 函数也将 `rng()` 函数作为第一个参数进行柯里化。单子将成为这个函数的第二个参数。`initial_roll()`
    函数可以掷骰子并应用出局规则以确定我们是否有通过、失败或确定点。'
- en: The `point_roll()` function also has the `rng()` function curried as the first
    argument. The monad will become the second argument. The `point_roll()` function
    can then roll the dice to see if the game is resolved. If the game is unresolved,
    this function will operate recursively to continue looking for a resolution.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`point_roll()` 函数也将 `rng()` 函数作为第一个参数进行柯里化。单子将成为这个函数的第二个参数。`point_roll()` 函数可以掷骰子以查看游戏是否已解决。如果游戏未解决，这个函数将递归地操作以继续寻找解决方案。'
- en: 'The `initial_roll()` function looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial_roll()` 函数看起来像这样：'
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The dice are rolled once to determine if the initial outcome is pass, fail,
    or establish the point. We return an appropriate monad value that includes the
    outcome, a point value, and the roll of the dice that led to this state. The point
    values for an immediate pass and immediate fail aren’t really meaningful. We could
    sensibly return a 0 value here, since no point was really established.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一次掷骰子以确定初始结果是通过、失败还是建立点。我们返回一个适当的单子值，该值包括结果、点值和导致此状态的掷骰结果。立即通过和立即失败的点值实际上并不真正有意义。我们可以合理地在这里返回一个
    0 值，因为没有真正建立点。
- en: For developers using tools like pylint, the `status` argument isn’t used. This
    creates a warning that needs to be silenced. Adding a `#`` pylint:`` disable=`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用像 pylint 这样的工具的开发者来说，`status` 参数没有被使用。这会产生一个需要关闭的警告。添加 `#`` pylint:`` disable=`
    可以关闭这个警告。
- en: '`unused-argument` comment will silence the warning.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`unused-argument` 注释将关闭警告。'
- en: 'The `point_roll()` function looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`point_roll()` 函数看起来像这样：'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We decomposed the status monad into the three individual values of the tuple.
    We could have used small lambda objects to extract the first, second, and third
    values. We could also have used the `operator.itemgetter()` function to extract
    the tuple’s items. Instead, we used multiple assignment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将状态单子分解为元组的三个单独的值。我们可以使用小的 lambda 对象来提取第一个、第二个和第三个值。我们也可以使用 `operator.itemgetter()`
    函数来提取元组的项。相反，我们使用了多重赋值。
- en: If a point was not established, the previous state will be pass or fail. The
    game was resolved during the `initial_roll()` function, and this function simply
    returns the status monad.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有确定点，之前的状态将是通过或失败。游戏在 `initial_roll()` 函数中解决，这个函数只是简单地返回状态单子。
- en: If a point was established, the state will be point. The dice is rolled and
    rules applied to this new roll. If roll is 7, the game is a lost and a final monad
    is returned. If the roll is the point, the game is won and the appropriate monad
    is returned. Otherwise, a slightly revised monad is passed to the `point_roll()`
    function. The revised status monad includes this roll in the history of rolls.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经确定了一个点，状态将是点。掷骰子并应用规则到这个新的掷骰结果上。如果掷出7，游戏结束，并返回一个最终单子。如果掷出的是点，游戏胜利并返回适当的单子。否则，将稍微修改后的单子传递给
    `point_roll()` 函数。修改后的状态单子包括这个掷骰结果在掷骰历史中。
- en: 'A typical output looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的输出看起来像这样：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The final monad has a string that shows the outcome. It has the point that was
    established and the sequence of dice rolls leading to the final outcome.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的单子有一个显示结果的字符串。它有已建立的点以及导致最终结果的一系列掷骰。
- en: We can use simulation to examine different outcomes to gather statistics on
    this complex, stateful process. This kind of Markov-chain model can reflect a
    number of odd edge cases that lead to surprising distributions of results.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模拟来检查不同的结果，以收集关于这个复杂、状态化的过程的统计数据。这种马尔可夫链模型可以反映许多奇怪的边缘情况，这些情况会导致结果分布的惊人变化。
- en: A great deal of clever Monte Carlo simulation can be built with a few simple,
    functional programming design techniques. The monad, in particular, can help to
    structure these kinds of calculations when there are complex orders or internal
    states.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些简单且功能性的编程设计技术，可以构建大量的巧妙蒙特卡洛模拟。特别是，幺半群可以帮助在存在复杂顺序或内部状态时结构化这些计算。
- en: 13.6 Additional PyMonad features
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6 PyMonad 的附加功能
- en: 'One of the other features of PyMonad is the confusingly named monoid. This
    comes directly from mathematics and it refers to a group of data elements that
    have an operator and an identity element, and the group is closed with respect
    to that operator. Here’s an example of what this means: when we think of natural
    numbers, the add operator, and an identity element 0, this is a proper monoid.
    For positive integers, with an operator `*`, and an identity value of 1, we also
    have a monoid; strings using `+` as an operator and an empty string as an identity
    element also qualify.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad 的另一个特性是名为幺半群的令人困惑的特性。这直接来自数学，它指的是具有运算符和单位元素的数据元素组，并且该组在该运算符下是封闭的。以下是一个例子：当我们想到自然数、加法运算符和单位元素
    0 时，这是一个正确的幺半群。对于正整数，使用运算符 `*` 和单位值 1，我们也有一个幺半群；使用 `+` 作为运算符和空字符串作为单位元素的字符串也符合条件。
- en: PyMonad includes a number of predefined monoid classes. We can extend this to
    add our own monoid class. The intent is to limit a compiler to certain kinds of
    optimization. We can also use the monoid class to create data structures which
    accumulate a complex value, perhaps including a history of previous operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad 包含了多个预定义的幺半群类。我们可以扩展这个功能来添加我们自己的幺半群类。目的是限制编译器只能进行某些类型的优化。我们还可以使用幺半群类来创建累积复杂值的数据结构，可能包括之前操作的历史记录。
- en: The `pymonad.list` is an example of a monoid. The identity element is an empty
    list, defined by `ListMonad()`. The addition operation defines list concatenation.
    The monoid is an aspect of the overall `ListMonad()` class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`pymonad.list` 是一个幺半群的例子。单位元素是一个空列表，由 `ListMonad()` 定义。加法操作定义了列表连接。幺半群是 `ListMonad()`
    类的一个方面。'
- en: Much of this package helps provide deeper insights into functional programming.
    To paraphrase the documentation, this is an easy way to learn about functional
    programming in, perhaps, a slightly more forgiving environment. Rather than learning
    an entire language and toolset to compile and run functional programs, we can
    just experiment with interactive Python.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该包的大部分内容有助于更深入地了解函数式编程。用文档中的话来说，这是一个在可能稍微宽容一些的环境中学习函数式编程的简单方法。我们不必学习整个语言和工具集来编译和运行函数式程序，我们只需通过交互式
    Python 进行实验。
- en: Pragmatically, we don’t need too many of these features because Python is already
    stateful and offers strict evaluation of expressions. There’s no practical reason
    to introduce stateful objects in Python, or strictly ordered evaluation. We can
    write useful programs in Python by mixing functional concepts with Python’s imperative
    implementation. For that reason, we won’t delve more deeply into PyMonad.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要太多这些功能，因为 Python 已经是状态性的，并且提供了严格的表达式评估。在 Python 中引入状态性对象或严格顺序评估没有实际的理由。我们可以通过将函数概念与
    Python 的命令式实现混合来编写有用的程序。因此，我们不会更深入地探讨 PyMonad。
- en: 13.7 Summary
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.7 概述
- en: In this chapter, we looked at how we can use the PyMonad library to express
    some functional programming concepts directly in Python. The module contains many
    important functional programming techniques.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用 PyMonad 库直接在 Python 中表达一些函数式编程概念。该模块包含了许多重要的函数式编程技术。
- en: We looked at the idea of currying, a function that allows combinations of arguments
    to be applied to create new functions. Currying a function also allows us to use
    functional composition to create more complex functions from simpler pieces. We
    looked at functors that wrap simple data objects to make them into functions that
    can also be used with functional composition.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了柯里化的概念，这是一种允许将参数组合应用于创建新函数的函数。柯里化函数还允许我们使用函数组合来从更简单的部分创建更复杂的函数。我们探讨了将简单数据对象包装成函数的函子，这些函数也可以用于函数组合。
- en: Monads are a way to impose a strict evaluation order when working with an optimizing
    compiler and lazy evaluation rules. In Python, we don’t have a good use case for
    monads because Python is an imperative programming language under the hood. In
    some cases, imperative Python may be more expressive and succinct than a monad
    construction.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是在使用优化编译器和懒加载规则时强加严格评估顺序的一种方式。在Python中，我们没有很好的单子用例，因为Python底层是一种命令式编程语言。在某些情况下，命令式Python可能比单子构造更具有表现力和简洁性。
- en: In the next chapter, we’ll look at the multiprocessing and multithreading techniques
    that are available to us. These packages become particularly helpful in a functional
    programming context. When we eliminate a complex shared state and design around
    non-strict processing, we can leverage parallelism to improve the performance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨我们可用的多进程和多线程技术。这些包在函数式编程环境中尤其有用。当我们消除复杂的共享状态并围绕非严格处理进行设计时，我们可以利用并行性来提高性能。
- en: 13.8 Exercises
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.8 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于GitHub上Packt Publishing提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到GitHub上提供的代码包含一些练习的部分解决方案。这些作为提示，允许读者探索替代解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. They are often identical to the unit test cases provided in
    the GitHub repository. The reader should replace the book’s example function name
    with their own solution to confirm that it works.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。它们通常与GitHub仓库中提供的单元测试用例相同。读者应将书中的示例函数名替换为自己的解决方案以确认其正确性。
- en: 13.8.1 Revise the arctangent series
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.8.1 修订反正切级数
- en: In [Using the lazy ListMonad() monad](#x1-2720001), we showed a computation
    for π that involved summing fractions from a series that used factorials, n!,
    and double factorials, (2n + 1)!!.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用lazy ListMonad()单子](#x1-2720001)中，我们展示了涉及从使用阶乘n!和双阶乘(2n + 1)!!的级数中求和的π的计算。
- en: The examples use a sequence `seq1`` =`` ListMonad(*range(20))` with only 20
    values. This choice of 20 was arbitrary, and intended only to keep the intermediate
    results small enough to visualize.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用了一个只有20个值的序列`seq1 = ListMonad(*range(20))`。这个20的选择是随机的，目的是保持中间结果足够小，以便可视化。
- en: A better choice is to use use curried versions of the `sum()` and `takewhile()`
    functions to find the sum of values in the sequence until the values are too small
    to contribute to the result.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是使用`sum()`和`takewhile()`函数的柯里化版本来找到序列中值的和，直到这些值太小，无法对结果产生影响。
- en: Rewrite the approximation to compute π to an accuracy of 10^(−15). This is close
    to the limit of what 64-bit floating-point values can represent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将计算π的近似值重写为精度为10^(-15)。这接近64位浮点数能表示的极限。
- en: 13.8.2 Statistical computations
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.8.2 统计计算
- en: Given a list of values, `v`, we can create a useful monad with `Just(v)`. We
    can use built-in functions like `sum()` and `len()` with the `Just.map()` method
    to compute the values required for mean, variance, and standard deviation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个值列表`v`，我们可以使用`Just(v)`创建一个有用的单子。我们可以使用内置函数如`sum()`和`len()`与`Just.map()`方法来计算均值、方差和标准差所需的值。
- en: '![ ∑ x mean (D ) =---x∈D--- count(D ) ](img/file125.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ x mean (D ) =---x∈D--- count(D ) ](img/file125.jpg)'
- en: '![ ∑ (x-−-mean-(D-))2 var(D ) = count (D )− 1 x∈D ](img/file126.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ (x-−-mean-(D-))2 var(D ) = count (D )− 1 x∈D ](img/file126.jpg)'
- en: '![ ∘ ------- stdev(D ) = var(D ) ](img/file127.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![ ∘ ------- stdev(D ) = var(D ) ](img/file127.jpg)'
- en: After implementing these functions using PyMonad, compare these definitions
    with more conventional Python language techniques. Does the presence of a monad
    structure help with these relatively simple computations?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PyMonad实现这些函数后，将这些定义与更传统的Python语言技术进行比较。单子结构对这些相对简单的计算有帮助吗？
- en: 13.8.3 Data validation
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.8.3 数据验证
- en: The PyMonad library includes an `Either` class of monads. This is similar to
    the `Maybe` class of monads. The `Maybe` monad can have just a value, or nothing,
    providing a `None`-like object. An `Either` monad has two subclasses, `Left` and
    `Right`. If we use `Right` instances for valid data, we can use `Left` instances
    for error messages that identify invalid data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad 库包含一个名为 `Either` 的单子类。这与单子类中的 `Maybe` 类相似。`Maybe` 单子可以有一个值，或者没有值，提供一个类似
    `None` 的对象。`Either` 单子有两个子类，`Left` 和 `Right`。如果我们使用 `Right` 实例来表示有效数据，那么我们可以使用
    `Left` 实例来表示标识无效数据的错误信息。
- en: The above concept suggests that a `try:/except:` statement can be used. If no
    Python exception is raised, the result is a `Right(v)`. If an exception is raised,
    a `Left` can be returned with the exception’s error message.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上述概念表明可以使用 `try:/except:` 语句。如果没有抛出 Python 异常，结果将是 `Right(v)`。如果抛出异常，可以返回带有异常错误信息的
    `Left`。
- en: This permits a `Compose` or `Pipe` to process data, emitting all of the erroneous
    rows as `Left` monads. This can lead to a helpful data validation application
    because it spots all of the problems with the data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许 `Compose` 或 `Pipe` 处理数据，发出所有错误行作为 `Left` 单子。这可以导致一个有用的数据验证应用程序，因为它发现了数据中的所有问题。
- en: First, define a simple validation rule, like ”the values must be multiples of
    3 or 5.” This means they must convert to integer values and the integer modulo
    3 is zero or the integer modulo 5 is zero. Second, write the validation function
    that returns either a `Right` or `Left` object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个简单的验证规则，例如“值必须是3或5的倍数。”这意味着它们必须转换为整数值，并且整数除以3的余数为零或整数除以5的余数为零。其次，编写返回
    `Right` 或 `Left` 对象的验证函数。
- en: While a `pymonad.io.IO` object can be used to parse a file, we’ll start with
    applying the validation function to a list and examining the results. Apply the
    validation function to a sequence of values, saving the resulting sequence of
    `Either` objects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `pymonad.io.IO` 对象可以用来解析文件，但我们将从将验证函数应用于列表并检查结果开始。将验证函数应用于一系列值，保存结果序列的 `Either`
    对象。
- en: An `Either` object has an `.either()` method which can process either `Left`
    or `Right` instances. For example, `e.either(lambda`` x:`` True,`` lambda`` x:`` False)`
    will return `True` if the value of the `e` monad is a `Left` instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` 对象有一个 `.either()` 方法，可以处理 `Left` 或 `Right` 实例。例如，`e.either(lambda
    x: True, lambda x: False)` 如果 `e` 单子的值是 `Left` 实例，将返回 `True`。'
- en: 13.8.4 Multiple models
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.8.4 多个模型
- en: A given process has several alternative models that compute an expected value
    from an observed sample value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的过程有几个备选模型，它们从观察样本值计算预期值。
- en: 'Each model computes an expected value, e, from the observed value in the sample,
    s[o]:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型都从样本中的观察值计算一个预期值 e：
- en: e = 0.7412 × s[o]
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e = 0.7412 × s[o]
- en: e = 0.9 × s[o] − 90
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e = 0.9 × s[o] − 90
- en: e = 0.7724 × s[o]^(1.0134)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e = 0.7724 × s[o]^(1.0134)
- en: First, we need to implement each of these models as a curried function. This
    will let us compute predicted values using any of these models.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将这些模型作为柯里化函数实现。这将使我们能够使用这些模型中的任何一个来计算预测值。
- en: Given a model function, we then need to create a comparison function. We can
    use a general PyMonad `Composition` or `Pipe` to compute a predicted value using
    one of the models and compare the predicted value with an observed value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个模型函数，我们接下来需要创建一个比较函数。我们可以使用通用的 PyMonad `Composition` 或 `Pipe` 来计算使用其中一个模型预测的值，并将预测值与观察值进行比较。
- en: The results of this comparison function can be used as part of a χ² (chi-squared)
    test to discern how well the model fits the observations. The actual chi-squared
    metric is the subject of Chapter 16, A Chi-Squared Case Study.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较函数的结果可以用作 χ²（卡方）测试的一部分，以判断模型与观察结果拟合得如何。实际的卡方指标是第16章《卡方案例研究》的主题。
- en: For now, create the curried model functions, and the `Composition` or `Pipe`
    to compare the model’s prediction with actual results.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建柯里化模型函数和 `Composition` 或 `Pipe`，以比较模型的预测与实际结果。
- en: For actual values and observed values, see the [Logging](Chapter_12.xhtml#x1-2640004)
    exercise in [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际值和观察值，请参阅第12章中的[日志记录](Chapter_12.xhtml#x1-2640004)练习，[装饰器设计技术](Chapter_12.xhtml#x1-25000012)。
- en: Join our community Discord space
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
