- en: Python Primer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 入门
- en: 'In this chapter, we will be covering the basic syntax of Python, its built-in
    data structures, functions, classes, its standard library, and the new features
    in the latest versions of Python. If you need to get up to speed on the language,
    this is where we''ll do that. We''ll walk through, step by step, covering the
    following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Python 的基本语法、其内置数据结构、函数、类、其标准库以及 Python 最新版本的新特性。如果您需要快速掌握这门语言，这里就是我们要去的地方。我们将逐步进行，涵盖以下主题：
- en: Python basic syntax and block structure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 基本语法和块结构
- en: Built-in data structures and comprehensions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据结构和推导式
- en: First-class functions and classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首等函数和类
- en: Extensive standard library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的标准库
- en: What's new in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的新特性
- en: Python basic syntax and block structure
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 基本语法和块结构
- en: This section primarily provides a basic understanding of the Python language
    constructs. If you feel you already have a solid grasp of Python, feel free to
    skip ahead.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要提供对 Python 语言结构的初步理解。如果您觉得自己已经对 Python 有了一个坚实的掌握，请随时跳过。
- en: Let's get down to the nuts and bolts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到细节。
- en: 'A Python program is written as source code in one or more `.py` files and consists
    of statements and expressions as shown in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python 程序以源代码的形式编写在一个或多个 `.py` 文件中，并包含如下截图所示的语句和表达式：
- en: '![](img/067b6eb4-6fe8-44d3-afea-3b49b2ee5a09.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/067b6eb4-6fe8-44d3-afea-3b49b2ee5a09.jpg)'
- en: Both statements and expressions tell Python to do something. The difference
    is that expressions can be combined to form more complex expressions, while statements
    can be combined with expressions, but not with other statements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 语句和表达式都告诉 Python 做某事。区别在于表达式可以组合成更复杂的表达式，而语句可以与表达式组合，但不能与其他语句组合。
- en: 'For example, a statement looks like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个语句看起来是这样的：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An expression looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表达式看起来是这样的：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python source code files are executed from top to bottom as soon as they're
    loaded by the Python runtime. This means that for simple programs, we could just
    write a series of statements in a `.py` file and then tell Python to run them.
    In the preceding example, the `if` and `else` parts are statements or a single
    statement with two parts, if you prefer to think of it that way. Everything else
    is an expression. For more complex programs, we need a more structured approach.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python 源代码文件在 Python 运行时加载后从上到下执行。这意味着对于简单的程序，我们只需在 `.py` 文件中编写一系列语句，然后告诉 Python
    运行它们。在先前的例子中，`if` 和 `else` 部分是语句或两个部分的单一语句，如果你愿意这样想的话。其余的都是表达式。对于更复杂的程序，我们需要更结构化的方法。
- en: Like most programming languages, Python lets us create functions and classes
    in order to organize our code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言一样，Python 允许我们创建函数和类来组织我们的代码。
- en: If you don't know what functions or classes are, you could think of functions
    as miniature programs that can be used as building blocks for larger programs
    and classes as combinations of functions and data to create new kinds of data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道函数或类是什么，可以将函数视为可以作为更大程序构建块的微型程序，而类则是函数和数据组合以创建新类型数据的组合。
- en: Basic building blocks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本构建块
- en: 'To organize our code, we can divide it into four basic building blocks. We''ll
    discuss each of these separately for understanding their role and importance in
    the Python code. These are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织我们的代码，我们可以将其分为四个基本构建块。我们将分别讨论这些构建块，以了解它们在 Python 代码中的作用和重要性。以下是这些构建块：
- en: Functions
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Variables
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Expressions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式
- en: Classes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Functions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'We''ll start with a brief look at functions. Functions are created using a
    `def` statement, which is a statement using the `def` keyword as its identifying
    component. As I said earlier, Python executes the statements in a `.py` file,
    starting from the top, as shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简要了解函数开始。函数是通过使用 `def` 语句创建的，这是一个使用 `def` 关键字作为其标识组件的语句。正如我之前所说的，Python
    从 `.py` 文件顶部开始执行语句，如下面的截图所示：
- en: '![](img/5dcdfd70-0e62-4fe1-8fb6-0cf72aab81a5.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dcdfd70-0e62-4fe1-8fb6-0cf72aab81a5.jpg)'
- en: 'When Python executes a `def` statement, it creates a function as a result.
    This means that the code that runs before the `def` statement does not see the
    function because it doesn''t exist yet. The part of the `def` line inside parentheses
    is called the **parameter list**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 执行一个 `def` 语句时，它创建一个函数作为结果。这意味着在 `def` 语句之前运行的代码看不到该函数，因为它还不存在。`def`
    行中括号内的部分称为**参数列表**：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The parameter list is a list of internal names for data values that are given
    to the function as the input. Outside the function, these values might have different
    names or no names at all, but inside, they'll be stored in these variables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表是作为输入传递给函数的数据值的内部名称列表。在函数外部，这些值可能具有不同的名称或根本没有名称，但在内部，它们将存储在这些变量中。
- en: 'The indented block of code immediately after the `def` line is called the **function
    body**, and you could think of it as the source code of the function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`def`行之后立即缩进的代码块被称为**函数体**，你可以将其视为函数的源代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows the output of the preceding example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面示例的输出：
- en: '![](img/924168dc-9aa4-40b2-b94f-56974235eb75.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/924168dc-9aa4-40b2-b94f-56974235eb75.jpg)'
- en: The code inside the function body is an exception to the rule about running
    Python code from the top to the bottom of the file. This code is stored away and
    then executed later, when we tell the function to run.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体内的代码是关于从文件顶部到底部运行Python代码的规则的例外。这段代码被存储起来，然后在告诉函数运行时执行。
- en: Like the code in a file, the code in a function runs from top to bottom, one
    statement or expression at a time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件中的代码一样，函数中的代码从上到下逐行或逐个语句或表达式运行。
- en: If you're more familiar with C++ or Java, you may be wondering where the function
    *parameter types* and *return types* are. In Python, the data type is inherent
    in each data value, so the runtime always knows what type of data we're working
    with and whether what we're trying to do is a valid operation for that data type.
    Thus, for the most part, we don't need explicit data types.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更熟悉C++或Java，你可能想知道函数的*参数类型*和*返回类型*在哪里。在Python中，数据类型是每个数据值固有的，因此运行时始终知道我们正在处理哪种类型的数据，以及我们尝试执行的操作是否对该数据类型是有效的操作。因此，在大多数情况下，我们不需要显式的数据类型。
- en: 'Python programmers sometimes talk about *duck typing*, which is a reference
    to the following saying:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员有时会谈论*鸭子类型*，这是对以下说法的引用：
- en: If it quacks like a duck, it's probably a duck.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它像鸭子一样叫，它可能就是一只鸭子。
- en: What they mean by this saying is that if the operations we're trying to perform
    on a data value work, it doesn't really matter if it's precisely the kind of data
    we expected. It's probably close enough. If they don't work, Python will tell
    us what went wrong and where, which is often more useful to know than the kind
    of information that can be determined by comparing data types alone.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 他们所说的意思是，如果我们试图对一个数据值执行的操作是有效的，那么它是否正好是我们预期的数据类型并不重要。它可能足够接近。如果它们不起作用，Python会告诉我们出了什么问题以及在哪里，这通常比仅通过比较数据类型所能确定的信息更有用。
- en: For situations where we want or need to specify data types, we can use function
    annotations and the standard library typing module.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要或需要指定数据类型的情况，我们可以使用函数注解和标准库的`typing`模块。
- en: Function decorators, which we'll discuss in later chapters, can provide a convenient
    way of enforcing these annotations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中讨论的函数装饰器可以提供一种方便的方式来强制执行这些注解。
- en: Variables
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: The second major building block of a Python program is called a **variable**.
    A variable is pretty much just a box for storing a data value. The variable has
    a name and we can use that name to access the data stored in the variable or to
    replace the data with a new value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序的第二大构建块被称为**变量**。变量基本上就是一个用于存储数据值的盒子。变量有一个名称，我们可以使用该名称来访问变量中存储的数据或用新值替换数据。
- en: 'The function parameters in the previous examples were variables, as was `area`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，函数参数是变量，`area`也是如此：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To set the data stored in a variable, we use an *assignment* statement. An assignment
    is a statement, so remember this means that it can't be combined with any other
    statement. It gets a line of source code all for itself and the expressions that
    are part of it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置存储在变量中的数据，我们使用*赋值*语句。赋值是一个语句，所以请记住这意味着它不能与其他任何语句组合。它获得一行源代码，以及它包含的表达式。
- en: 'An assignment statement consists of the variable''s name on the left-hand side
    of an equal to symbol and the value we want to store in the variable on the right-hand
    side, as shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句由等号左侧的变量名和右侧我们想要存储在变量中的值组成，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the variable didn't already exist, it will be created. Irrespective of whether
    the variable existed before or not, the value is stored in the variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量之前不存在，它将被创建。无论变量之前是否存在，值都将存储在变量中。
- en: Variables that are created inside a function are only visible inside that function
    and each time the function runs they're created a new.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部创建的变量只在该函数内部可见，并且每次函数运行时都会创建一个新的。
- en: 'The following code provides an example of this in action:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了一个实际应用的例子：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last line of the preceding example demonstrates that the variable created
    inside the function does not exist for code outside the function, as shown in
    the following output of the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例的最后一条语句表明，在函数内部创建的变量对于函数外部的代码是不存在的，如下面的代码输出所示：
- en: '![](img/4988408e-1651-47ae-b81f-749466233ce3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4988408e-1651-47ae-b81f-749466233ce3.jpg)'
- en: This code example also shows what happens when we try to ask Python to do something
    impossible. It tells us what we did wrong and gives us the information about where
    the problem occurred and how we got there.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例还展示了当我们试图让Python做不可能的事情时会发生什么。它告诉我们我们做错了什么，并提供了有关问题发生位置和如何到达那里的信息。
- en: Expressions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: The third major building block of Python programs is **expressions**. We've
    seen expressions in every example so far because it's nearly impossible to do
    anything in Python without using expressions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序的主要组成部分的第三个是**表达式**。到目前为止，我们在每个例子中都看到了表达式，因为几乎不可能在Python中不使用表达式就做任何事情。
- en: 'Expressions consist of data values and operations to perform on those data
    values. The very simple expressions are a single data value and with no operations,
    for example, a single number. More complex expressions involve at least one operation
    and probably more data values as well, for example, adding two numbers or calculating
    the area, as shown in the following code example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式由数据值和在这些数据值上执行的操作组成。非常简单的表达式是一个单一的数据值，没有任何操作，例如，一个单独的数字。更复杂的表达式至少包含一个操作，可能还有更多的数据值，例如，将两个数字相加或计算面积，如下面的代码示例所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All expressions produce a resulting data value of some sort; for example, adding
    two numbers produces the sum as another number, while concatenating two text strings
    produces the concatenation as another text string. Using a `name` variable to
    look up the stored value is an expression, so is running a function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的表达式都会产生某种类型的结果数据值；例如，将两个数字相加会产生另一个数字作为和，而将两个文本字符串连接起来会产生另一个文本字符串作为连接。使用`name`变量来查找存储的值是一个表达式，运行一个函数也是如此。
- en: If the function doesn't explicitly return a value, the result is a special value
    called **none**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数没有明确返回一个值，结果将是一个特殊值，称为**none**。
- en: Anywhere we need a value, we can use any expression that produces the needed
    value. It doesn't matter whether the expression is a simple number, such as `55`,
    a variable name, a complex combination of values and operators, a function call,
    or any other expression. At least, it doesn't matter as far as the final result
    is concerned. Some expressions take less time to execute than others, so speed
    can be a factor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们需要值的地方，我们可以使用任何产生所需值的表达式。无论是简单的数字，如`55`，变量名，值的复杂组合和运算符，函数调用，还是任何其他表达式，这都不重要。至少，从最终结果的角度来看，这并不重要。某些表达式比其他表达式执行时间短，所以速度可能是一个因素。
- en: Classes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: The final fundamental building block we're going to discuss in this section
    is **classes**. The word class is a synonym for category or type; in this case,
    it is referring to data values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论的最后一种基本构建块是**类**。类这个词是类别或类型的同义词；在这种情况下，它指的是数据值。
- en: 'A class defines a new kind of data value by describing a set of internal data
    and operations for that type of data value. This is done primarily by defining
    a group of functions that make up the class. A special function called `__init__`
    is used to set up the internal data for a new data value of this type, and the
    rest of the functions define the operations on an existing data value of this
    type:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类通过描述该类型数据值的内部数据和操作来定义一种新的数据值。这主要是通过定义一组构成类的函数来完成的。一个特殊函数`__init__`用于设置新数据值的内部数据，其余的函数定义了该类型现有数据值的操作：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All the functions of a class receive a parameter called `self`**,** as shown
    in the preceding code example for classes. This parameter is the data value being
    operated on. That's different from C++ or Java because while those languages do
    basically the same thing, the parameter is implicit instead of being an explicit
    part of the function's parameter list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类的所有函数都接收一个名为 `self` 的参数，如前面类代码示例所示。这个参数是正在操作的数据值。这与 C++ 或 Java 不同，因为尽管那些语言基本上做同样的事情，但参数是隐式的，而不是函数参数列表的显式部分。
- en: Class functions, including `__init__`, should store and retrieve data from `self`
    when they want to manipulate the data value that they're connected to.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类函数，包括 `__init__`，在它们想要操作与之关联的数据值时，应该从 `self` 中存储和检索数据。
- en: Classes support **inheritance** and **multiple inheritance**, but we won't go
    into that in detail at this point in the book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类支持 **继承** 和 **多重继承**，但在此书的这一部分我们不会详细讨论。
- en: In the preceding example, we created a new data type called `Frood` and then
    made two separate data values of that type. Then, we used the `anniversary` function
    that we created as part of the class to modify each of them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个新的数据类型 `Frood`，然后创建了两个该类型的数据值。然后，我们使用作为类一部分创建的 `anniversary`
    函数来修改它们。
- en: 'The output of the code example for classes is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类的代码示例输出如下：
- en: '![](img/783c34d1-b6f0-4cae-9265-9bf3547af707.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/783c34d1-b6f0-4cae-9265-9bf3547af707.jpg)'
- en: The two instances maintain their internal variables with different values, as
    shown in the preceding output.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个实例保持它们内部变量不同的值，如前面输出所示。
- en: Flow control statements
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制语句
- en: 'Python has several flow control statements that will be familiar to people
    who know another language in the C family. For example, Python has loops and `if`,
    `elif`, and `else` branches (shown in the following code example):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有几个流程控制语句，这些语句对于熟悉 C 家族语言的用户来说很熟悉。例如，Python 有循环和 `if`、`elif` 和 `else`
    分支（如下面的代码示例所示）：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Python also has a `for` loop statement, but it''s not like the `for` loops
    in C, C++, or Java. Instead of counting through numbers, the `for` loop iterates
    through the values. If we actually want to count through numbers with a `for`
    loop, that''s easily done using a `range` iterator, as shown in the following
    screenshot in the output of the preceding code example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也有 `for` 循环语句，但它与 C、C++ 或 Java 中的 `for` 循环不同。`for` 循环不是通过计数数字，而是遍历值。如果我们实际上想用
    `for` 循环计数数字，那很容易通过 `range` 迭代器来完成，如下面代码示例的输出截图所示：
- en: '![](img/a27e13ed-6d95-4a21-8b95-023b866dd4ee.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a27e13ed-6d95-4a21-8b95-023b866dd4ee.jpg)'
- en: Before we wrap-up this section, there's one last thing I should comment on and
    that's Python's views on **indentation** to signify the block structure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，还有最后一件事我应该评论一下，那就是 Python 对表示块结构的 **缩进** 的看法。
- en: Indentation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩进
- en: 'Most other programming languages have explicit symbols that indicate the beginning
    of a block and the end of a block. However, it''s a common practice in all of
    those languages to indent blocks so that humans find the code easier to read.
    In fact, failure to do so is often taken as a sign that a programmer is an amateur.
    This means that the block structure in most languages is actually represented
    in two different ways: the symbols and the indentation. By incorporating indentation
    into syntax without the need for explicit symbols, Python both removes this duplication
    and ensures that the code is readable.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他编程语言都有明确的符号来表示块的开始和结束。然而，在所有这些语言中，缩进块是一种常见的做法，以便人类更容易阅读代码。实际上，不这样做通常被视为程序员是业余水平的标志。这意味着大多数语言中的块结构实际上以两种不同的方式表示：符号和缩进。通过将缩进纳入语法而不需要显式符号，Python
    既可以消除这种重复，又确保代码可读。
- en: With that, we've come to the end of this section. In the next section, we'll
    look at some of Python's built-in data structures and the data processing syntax.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就结束了本节。在下一节中，我们将探讨一些 Python 的内置数据结构和数据处理语法。
- en: Python's built-in data structures and comprehensions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 的内置数据结构和推导式
- en: Now, let's take a look at the core data structure types of Python. These aren't
    the only data structures available, of course, because it's fairly easy to create
    data structures using classes. However, these data structures are built right
    into the heart of Python and they're highly efficient, so it's a good idea to
    be very familiar with them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看Python的核心数据结构类型。当然，这些并不是唯一可用的数据结构，因为使用类创建数据结构相对容易。然而，这些数据结构直接构建在Python的核心中，并且效率很高，因此熟悉它们是个好主意。
- en: The first thing to understand is that data structures are themselves data values
    similar to a filing cabinet-they're one thing that contains many things. Like
    any other data value, they can be stored in a variable or used as part of an expression.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的是，数据结构本身也是类似文件柜的数据值——它们是包含许多事物的一个东西。像任何其他数据值一样，它们可以被存储在变量中或用作表达式的一部分。
- en: Dictionaries
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: The first data structure we're going to look at is Python's dictionary. A dictionary
    consists of any number of key-value pairs. The key can be used to get or set the
    value or remove the pair from the dictionary entirely.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的第一个数据结构是Python的字典。字典由任意数量的键值对组成。键可以用来获取或设置值，或者从字典中完全删除这个键值对。
- en: Similar data structures in other languages are sometimes called maps or hash
    tables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言中的类似数据结构有时被称为映射或哈希表。
- en: 'There are several ways to create a dictionary in Python. The simplest is to
    use a dictionary expression, which is just a pair of curly brackets surrounding
    the key-value pairs we want in the dictionary. Each key-value pair is marked with
    a colon between the key and value, and each pair is separated by a comma, as shown
    in the following code example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建字典有几种方法。最简单的是使用字典表达式，它就是一对花括号，包围着我们想要在字典中包含的键值对。每个键值对由键和值之间的冒号标记，每个键值对由逗号分隔，如下面的代码示例所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When this expression runs, the result is a dictionary object containing the
    keys and their values. We can also use the `dict` class to create dictionary objects:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个表达式运行时，结果是包含键及其值的字典对象。我们也可以使用`dict`类来创建字典对象：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we don''t want to use the special syntax to access one of the stored values
    in a dictionary, we use a lookup expression. This means that we place square brackets
    containing the key we want to look up after an expression that gives us the dictionary.
    Usually, this means, the name of the variable containing the dictionary, an open
    square bracket, a sub-expression that gives us the key, and then a closing square
    bracket:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想使用特殊语法来访问字典中存储的某个值，我们可以使用查找表达式。这意味着我们在给出字典的表达式之后放置一对方括号，包含我们想要查找的键。通常情况下，这意味着包含字典的变量的名称，一个开方括号，一个给出键的子表达式，然后是一个闭方括号：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also use the `dict.get` function if we prefer not to use the special
    syntax:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更喜欢不使用特殊语法，我们也可以使用`dict.get`函数：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: List
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'The next data type we''re going to look at is a **list**, which can be created
    with the list expression. A list expression is just a pair of square brackets
    surrounding the data values we want to store in the list, with each value separated
    by a comma. It is not necessary that each of the values be of the same type. The
    code example for a list is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要探讨的数据类型是**列表**，它可以通过列表表达式来创建。列表表达式就是一对方括号，包围着我们想要存储在列表中的数据值，每个值之间用逗号分隔。并不要求每个值必须是同一类型。以下是一个列表的代码示例：
- en: '![](img/25a29cea-8d84-4e12-87ba-d33ffd4dc885.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25a29cea-8d84-4e12-87ba-d33ffd4dc885.jpg)'
- en: In the preceding example, they're strings, but they could be numbers, or a list,
    or any other kind of data mixed together. We can use a lookup expression to retrieve
    data values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，它们是字符串，但它们可以是数字，或者是一个列表，或者任何其他类型的数据混合在一起。我们可以使用查找表达式来检索数据值。
- en: Unlike with a dictionary though, the keys for a list are integers. That's because
    instead of associating key values with data values, a list just stores its data
    values in order. The key for the very first item in the list is `0`. The key for
    the next item is `1`, and so on. We can also use negative integers for the key.
    We still get a data value out, but it's counted from the end of the list instead
    of the beginning, with the item at `-1` being the last item in the list.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典不同，列表的键是整数。这是因为列表不是将键值与数据值关联，而是按顺序存储其数据值。列表中第一个项目的键是`0`。下一个项目的键是`1`，依此类推。我们也可以使用负整数作为键。我们仍然可以得到一个数据值，但它是从列表的末尾而不是从开头计算的，其中`-1`是列表中的最后一个项目。
- en: 'We can use the `list.append` function to add a new item at the end of the list
    or its `insert` function to add a new item anywhere as shown in the following
    code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`list.append`函数在列表末尾添加新项目，或使用其`insert`函数在任何位置添加新项目，如下面的代码所示：
- en: '![](img/d3875dba-1cb1-4b47-920e-b9d307709016.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3875dba-1cb1-4b47-920e-b9d307709016.jpg)'
- en: The list will automatically grow to be large enough to hold all of the data
    we put into it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表会自动增长到足够大，以容纳我们放入其中的所有数据。
- en: Tuple
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: The next data structure we'll look at is the **tuple**. A tuple expression is
    any sequence of value expressions separated by commas if it happens in the place
    where the language wasn't already expecting to see a comma.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的下一个数据结构是**元组**。元组表达式是任何由逗号分隔的值表达式序列，如果它出现在语言原本不期望看到逗号的位置。
- en: 'However, it''s common and smart to put parentheses around most tuple expressions
    because it avoids ambiguity. The code example for tuple is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将括号放在大多数元组表达式周围是常见且明智的，因为它避免了歧义。元组的代码示例如下：
- en: '![](img/cd6bfea8-97a4-4663-bf58-26bf56e0c024.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd6bfea8-97a4-4663-bf58-26bf56e0c024.jpg)'
- en: Like a list, data values can be retrieved from a tuple using numbers. However,
    we can't add more data to a tuple, and we cannot replace one data value with another.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，可以使用数字从元组中检索数据值。然而，我们无法向元组添加更多数据，也无法用另一个数据值替换一个数据值。
- en: Why would we want a data structure like that?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要想要这样的数据结构呢？
- en: 'Well, there are several reasons. We can list them as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有几个原因。我们可以如下列出：
- en: First, because they are constant, tuples make good dictionary keys or set members,
    but we'll get to that in a while.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，因为它们是常量，元组可以作为良好的字典键或集合成员，但我们会稍后再讨论这一点。
- en: Second, they fill a different conceptual role than lists. We tend to expect
    every member of a list to be the same type, such as a list of names or a list
    of ages. Lists are sort of like columns of a database in that way. We tend to
    expect tuples to contain different types of data in each element, but we expect
    them to be related to each other, such as a name in the first element and an age
    in the second. To continue our analogy, tuples are something like rows in a database.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，它们在概念上扮演着与列表不同的角色。我们倾向于期望列表的每个成员都是相同类型的，例如名字列表或年龄列表。从某种意义上说，列表就像数据库的列。我们倾向于期望元组的每个元素包含不同类型的数据，但它们彼此之间是相关的，例如第一个元素是名字，第二个元素是年龄。继续我们的类比，元组就像数据库的行。
- en: Third, tuples tend to be slightly more efficient for the computer to work with,
    both in terms of time and memory usage. So, in optimization situations, they are
    preferable to lists when they are sufficient for the task.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，元组在计算机处理时通常在时间和内存使用上稍微高效一些。因此，在优化情况下，当它们足以完成任务时，它们比列表更可取。
- en: Set
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'The final data structure we''ll look at is the **set**. A set is a collection
    of data values without keys; like a list, but in no particular order, like a dictionary.
    We can create a set using a set expression, which is a pair of curly brackets
    around comma-separated values, as shown in the following code example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个数据结构是**集合**。集合是一组没有键的数据值；就像列表，但没有特定的顺序，就像字典。我们可以使用集合表达式创建一个集合，它是一对花括号包围的逗号分隔的值，如下面的代码示例所示：
- en: '![](img/55d3fdd7-9a69-439f-8b40-7b2c1500e436.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55d3fdd7-9a69-439f-8b40-7b2c1500e436.jpg)'
- en: 'Locating a specific value in a set is fast, as is adding or removing a value,
    as shown in the following example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合中定位特定值很快，添加或删除值也是如此，如下面的示例所示：
- en: '![](img/2662ba78-fa47-437c-ae0b-6f2077265660.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2662ba78-fa47-437c-ae0b-6f2077265660.jpg)'
- en: Each value can only be in the set once. Sets support a bunch of mathematical
    operations, such as union and intersection, and are generally more useful than
    might be obvious at first, though we can't really prove that here in this section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值只能出现在集合中一次。集合支持一系列数学运算，如并集和交集，并且通常比一开始看起来更有用，尽管我们在这里的章节中无法真正证明这一点。
- en: Comprehension
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导式
- en: Python has a special kind of expression called a **comprehension**. Comprehensions
    are variations of the special syntax for creating dictionaries, lists, and sets.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一种特殊的表达式，称为**推导式**。推导式是创建字典、列表和集合的特殊语法的变体。
- en: 'Let''s look at some examples. Here we see a list comprehension:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子。这里我们看到一个列表推导式：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What this expression does is that it creates a new list containing the uppercase
    versions of the words in the old list.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的作用是创建一个新列表，包含旧列表中单词的大写版本。
- en: 'The first part after the opening square bracket is an `x.upper()` expression.
    This expression describes how to derive a member of the new list from a member
    of the old list. After that is the `for` keyword, then the name of the `x` variable
    we used in the first expression to represent the values from the old list. Then,
    the keyword is followed by the `example_list` expression that gives us the old
    list and the closing square bracket. The code output is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 开方括号后的第一部分是一个`x.upper()`表达式。这个表达式描述了如何从旧列表的成员推导出新列表的成员。之后是`for`关键字，然后是我们在第一个表达式中使用的`x`变量的名称。然后，关键字后面跟着`example_list`表达式，它给出了旧列表，最后是闭方括号。代码输出如下：
- en: '![](img/5ee9358c-def4-4fc5-b9b1-e2d5e04bc9bf.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ee9358c-def4-4fc5-b9b1-e2d5e04bc9bf.jpg)'
- en: 'The dictionary and set comprehensions are very similar. If we want to use both
    the key and the value of an existing dictionary in a comprehension, we need to
    use the `dict.items` function, and dictionary comprehensions need to specify both
    the key and value separated by a colon, as shown in this example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 字典和集合推导式非常相似。如果我们想在推导式中使用现有字典的键和值，我们需要使用`dict.items`函数，并且字典推导式需要指定键和值，用冒号分隔，如本例所示：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As shown in the following screenshot, notice that the resulting data type depends
    on what sort of comprehension we used, not on what sort of data structure we used
    as the source of data:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，请注意，结果数据类型取决于我们使用了哪种推导式，而不是我们使用了哪种数据结构作为数据源：
- en: '![](img/99820c3d-5e46-48d2-8d4f-260dde7ab93c.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99820c3d-5e46-48d2-8d4f-260dde7ab93c.jpg)'
- en: We can use a list comprehension to create a list of data pulled from the values
    of a dictionary, for example, or, as we did here, we can use the set comprehension
    to create a set.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表推导式从字典的值创建数据列表，例如，或者，就像我们在这里做的那样，我们可以使用集合推导式创建集合。
- en: 'Tuples are slightly different, but only slightly. A tuple comprehension would
    look exactly like a different syntactic element called a **generator expression**.
    The code example for tuple comprehension is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 元组略有不同，但只是略有不同。元组推导式看起来就像一个名为**生成器表达式**的不同语法元素。元组推导式的代码示例如下：
- en: '![](img/08c1aa39-8f1e-46a7-9abf-96adfcd3fc7f.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08c1aa39-8f1e-46a7-9abf-96adfcd3fc7f.jpg)'
- en: Python's designers hate ambiguity; so instead, if we want the equivalent of
    a tuple comprehension, we pass a generator expression to a tuple constructor.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python的设计者讨厌歧义；因此，如果我们想要元组推导式的等效物，我们就将生成器表达式传递给元组构造函数。
- en: That's it for this quick introduction to Python's built-in data structures.
    In the next section, we're going to look at some useful, but possibly surprising,
    traits of functions and classes that are significantly different from C, C++,
    or Java.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本快速介绍Python内置数据结构的全部内容。在下一节中，我们将探讨函数和类的一些有用但可能令人惊讶的特性，这些特性与C、C++或Java有显著不同。
- en: First-class functions and classes
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一等函数和类
- en: In Python, functions and classes are first-class objects. The phrase **first-class
    object** is a fancy way of saying that the data values can be accessed, modified,
    stored, and otherwise manipulated by the program they are a part of. In Python,
    a function is just as much a data value as a text string is. The same goes for
    classes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数和类是一等对象。短语**一等对象**是一种说法，意味着数据值可以被程序访问、修改、存储和在其他方面被操作。在Python中，函数就像文本字符串一样，是一个数据值。类也是如此。
- en: 'When a function definition statement is executed, it stores the resulting function
    in a variable with the name that was specified in the `def` statement, as shown
    in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数定义语句被执行时，它会将生成的函数存储在一个变量中，该变量的名称是在 `def` 语句中指定的，如下面的截图所示：
- en: '![](img/b33d1602-663d-4bd9-933b-a7f1ce1c3d7d.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b33d1602-663d-4bd9-933b-a7f1ce1c3d7d.jpg)'
- en: This variable isn't special; it's just like any other variable holding the value.
    This means that we can use it in expressions, assign the value to other values,
    or even store a different value in place of the original function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量并不特殊；它就像任何其他持有值的变量一样。这意味着我们可以在表达式中使用它，将值赋给其他值，或者甚至用不同的值替换原始函数。
- en: 'The function value itself contains quite a few attribute variables, which we
    can access. More usefully, most of the time, we can add attributes to a `function`
    object, allowing us to store custom information about a function as part of the
    function and access that information later, as shown in the following code example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数值本身包含相当多的属性变量，我们可以访问它们。更有用的情况是，大多数时候，我们可以向 `function` 对象添加属性，这样我们就可以将有关函数的定制信息作为函数的一部分存储，并在以后访问这些信息，如下面的代码示例所示：
- en: '![](img/8cb869f9-a052-405b-ac2a-f69cdf18561c.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cb869f9-a052-405b-ac2a-f69cdf18561c.jpg)'
- en: 'One common task that first-class functions make easy is assigning handlers
    to events. To bind the **handler** function to an event in Python, we just pass
    the `function` object as a parameter when we call the **binding** function, as
    shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首类函数使一个常见任务变得简单，那就是为事件分配处理程序。要在 Python 中将 **handler** 函数绑定到事件，我们只需在调用 **binding**
    函数时将 `function` 对象作为参数传递，如下所示：
- en: '![](img/119f3862-e411-4f9e-9d33-defdf78c7151.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/119f3862-e411-4f9e-9d33-defdf78c7151.jpg)'
- en: That's a significant improvement over the hoops that C++ or Java imposes on
    us to do something similar. As function definition statements, class definition
    statements create a class object and store it in a variable. This can be confusing
    at first. Classes describe the type of object, how can they be objects themselves?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这比 C++ 或 Java 强加给我们的类似操作要灵活得多。作为函数定义语句，类定义语句创建一个类对象并将其存储在一个变量中。这可能会让人一开始感到困惑。类描述了对象的类型，它们怎么能是对象本身呢？
- en: Think of it this way-a blueprint for a house describes the type of building,
    but the blueprint is still a thing in its own, right? It's the same with class
    objects. This means that like function objects, class objects can be stored in
    variables, and otherwise, be treated as data values. Most interestingly, they
    could be used as parameters to function calls.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下——一栋房子的蓝图描述了建筑类型，但蓝图本身仍然是一个东西，对吧？类对象也是这样。这意味着，就像函数对象一样，类对象可以被存储在变量中，并且可以像数据值一样被处理。最有趣的是，它们可以用作函数调用的参数。
- en: The defaultdict class
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`defaultdict` 类'
- en: 'As an example of why that''s interesting, consider this-Python''s standard
    library contains a data structure class called `defaultdict`, which is like a
    dictionary except, when we try to look up a key that isn''t already in the dictionary.
    It creates a new value and adds it to the dictionary, before returning it to the
    code that tried the lookup, as shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为为什么这有趣的例子，考虑一下——Python 的标准库包含一个名为 `defaultdict` 的数据结构类，它就像字典一样，但是当我们尝试查找字典中尚未存在的键时，它会创建一个新的值并将其添加到字典中，然后再将其返回给尝试查找的代码，如下所示：
- en: '![](img/13e6933f-ae86-49da-9b0e-890eb946d6d7.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13e6933f-ae86-49da-9b0e-890eb946d6d7.jpg)'
- en: How does the `defaultdict` class know how to create the default value?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 类是如何知道如何创建默认值的？'
- en: The `defaultdict` class knows because we gave it `class` as a parameter when
    we created the `defaultdict` class. Thus, if we want a dictionary of list, we
    can give the `defaultdict` class the list class, as its *how to make a default*
    parameter. As an aside, `defaultdict` can also work with a function, as its *how
    to make a default* parameter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 类之所以知道如何操作，是因为我们在创建 `defaultdict` 类时给它传递了 `class` 作为参数。因此，如果我们想要一个列表的字典，我们可以给
    `defaultdict` 类传递列表类，作为其 *如何设置默认值* 参数。顺便提一下，`defaultdict` 也可以与函数一起工作，作为其 *如何设置默认值*
    参数。'
- en: The `defaultdict` class actually doesn't care what that parameter is, as long
    as the object we passed can create a new object whenever the `defaultdict` class
    needs a new default. This is an example of the duck typing we mentioned in the
    previous section. It doesn't matter whether the parameter is a function, a class,
    or anything else, so long as it behaves properly. If it doesn't behave properly,
    we'll be told what went wrong and where.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`类实际上并不关心这个参数是什么，只要我们传递的对象能够在`defaultdict`类需要新默认值时创建一个新对象。这是我们在上一节中提到的鸭子类型的一个例子。参数是函数、类还是其他任何东西，只要它表现正常即可。如果它表现不正常，我们会被告知出了什么问题以及在哪里。'
- en: Attributes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: We discussed a little while ago that we could add attributes to function objects,
    which is often handy. We could do something similar with classes, with one big
    difference- attributes that we add to functions are only visible to the code that
    has access to that function object, which usually doesn't include the code of
    the function itself, but attributes that we add to class objects are visible to
    any code that has access to the class object or to an object of the type described
    by the class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过，我们可以向函数对象添加属性，这通常很有用。我们也可以用类似的方法处理类，但有一个很大的区别——我们添加到函数中的属性只能被访问该函数对象的代码看到，通常不包括函数本身的代码，但我们添加到类对象中的属性则可以被任何访问类对象或由该类描述的对象类型的代码看到。
- en: 'This means that if we add an attribute to a class, the functions defined in
    that class will be able to access that attribute through the `self` parameter,
    as shown in the following code example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们向类添加一个属性，该类中定义的函数将能够通过`self`参数访问该属性，如下面的代码示例所示：
- en: '![](img/80d56e37-df87-4c9f-8d8a-fd99f5a9cfec.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80d56e37-df87-4c9f-8d8a-fd99f5a9cfec.jpg)'
- en: We need to be careful when adding attributes to classes because if we accidentally
    overwrite one of the class' attributes, we could break the class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在向类添加属性时，我们需要小心，因为我们可能会不小心覆盖类的一个属性，从而破坏类。
- en: We have a greater ability to manipulate classes than functions. So, we need
    to use that ability more thoughtfully. Also, notice that, in this example, one
    of the attributes we added to the class is a function, which then proceeded to
    work exactly as if it had been defined as a part of the class from the beginning.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对类的操作能力比函数要强。因此，我们需要更谨慎地使用这种能力。此外，请注意，在这个例子中，我们添加到类中的一个属性是一个函数，该函数随后开始像它从一开始就被定义为类的一部分那样工作。
- en: Next, let's take a short tour of some of the highlights of Python's standard
    library.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要地浏览一下Python标准库的一些亮点。
- en: The standard library
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库
- en: The library of code that comes pre-installed with Python is extensive, so we're
    not going into the details. The goal here is to come away with an understanding
    of the breadth of quality tools we have available, so if we need them in the future
    then we know where to look. Thus, we're going to just briefly touch on many useful
    things. You can find the official documentation on the standard library at [https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 预先安装在Python中的代码库非常广泛，所以我们不会深入细节。这里的目的是让我们了解我们可用的优质工具的广度，这样如果将来需要它们，我们就知道去哪里找。因此，我们将简要地触及许多有用的东西。您可以在[https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html)找到标准库的官方文档。
- en: Different types of packages
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的包
- en: The index page contains a list of the different packages available to you in
    Python's standard library. Let's briefly run through them in order.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 索引页面包含了一个列表，列出了Python标准库中可用的不同包。让我们简要地按顺序浏览它们。
- en: First of all, there is the `Collections` package, which contains even more data
    structures: [https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有`Collections`包，它包含更多的数据结构：[https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html)。
- en: The `Collections` package contains the `defaultdict` class that we spoke about
    in the previous section. The `Collections` package also contains an `OrderedDict`
    parameter that remembers the order in which the items were inserted and gives
    them back in the same order when we iterate over it. A `deque` class is a variation
    on tuples that uses names to access the element and a `PseudoDict` parameter that
    provides a composite view of several other dictionaries.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections` 包包含我们在上一节中提到的 `defaultdict` 类。`Collections` 包还包含一个 `OrderedDict`
    参数，它记录了项目插入的顺序，并在迭代时以相同的顺序返回它们。`deque` 类是元组的变体，使用名称来访问元素，还有一个 `PseudoDict` 参数，它提供了对几个其他字典的复合视图。'
- en: 'There are a few other data structures in there as well. One common data structure
    missing from the collections package is a `PriorityQueue` parameter, but that''s
    just because it has its own package called `heapq`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其中还有一些其他的数据结构。从集合包中缺失的一个常见数据结构是 `PriorityQueue` 参数，但这仅仅是因为它有一个自己的包叫做 `heapq`：
- en: '[https://docs.python.org/3/library/heapq.html](https://docs.python.org/3/library/heapq.html)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/heapq.html](https://docs.python.org/3/library/heapq.html)'
- en: Python's `PriorityQueue` operations are implemented as functions that work with
    built-in lists to add and remove items according to the **heap** property.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `PriorityQueue` 操作是通过与内置列表一起工作的函数实现的，这些函数根据 **堆** 属性添加和删除项目。
- en: 'Storing and retrieving data is an extremely common need for programs and the
    `pickle` package makes it easy:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和检索数据是程序的一个极其常见的需求，`pickle` 包使得这变得很容易：
- en: '[https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)'
- en: Inside the `pickle` package are classes and functions that facilitate transforming
    arbitrary Python data into a sequence of bytes that can be stored in a file, sent
    across the network, or whatever you need. The `pickle` package also has the tools
    to reverse the process and transform those bytes back into fully-fledged Python
    data objects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pickle` 包中包含了一些类和函数，它们可以方便地将任意 Python 数据转换为可以存储在文件中、通过网络发送或满足其他需求的字节序列。`pickle`
    包还提供了工具来逆转这个过程，将那些字节转换回完整的 Python 数据对象。
- en: 'Also, in the vein of storing data, the `sqlite3` package provides complete
    access to the SQLite database manager, allowing us to take advantage of a complete
    transactional relational database:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在存储数据方面，`sqlite3` 包提供了对 SQLite 数据库管理器的完全访问，使我们能够利用完整的交易性关系数据库：
- en: '[https://docs.python.org/3/library/sqlite.html](https://docs.python.org/3/library/sqlite.html)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/sqlite.html](https://docs.python.org/3/library/sqlite.html)'
- en: Third-party packages to access other database systems follow pretty much the
    same interface, so it's easy to make the switch to a different database later,
    if needed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 访问其他数据库系统的第三方包遵循几乎相同的接口，因此如果需要，很容易切换到不同的数据库。
- en: 'The `json` package is also relevant to data handling. It parses or generates
    the de facto standard **Internet Data Exchange** (**IDX**) format:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`json` 包也与数据处理相关。它解析或生成事实上的标准 **互联网数据交换**（**IDX**）格式：'
- en: '[https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html)'
- en: The `json` package is smart, so it handles **JSON** (**JavaScript Object Notation**)
    objects, arrays, strings, numbers, null values, and so on, in a sensible way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`json` 包非常智能，因此它以合理的方式处理 **JSON**（**JavaScript 对象表示法**）对象、数组、字符串、数字、null 值等。'
- en: 'Mapping them onto the proper Python datatypes, the `base64` package encodes
    bytes into base64, or decodes base64 into bytes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们映射到适当的 Python 数据类型，`base64` 包将字节编码为 base64，或将 base64 解码为字节：
- en: '[https://docs.python.org/3/library/base64.html](https://docs.python.org/3/library/base64.html)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/base64.html](https://docs.python.org/3/library/base64.html)'
- en: There are several other similar packages for `binhex`, `uu` code, and so on,
    as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个类似的包用于 `binhex`、`uu` 编码等。
- en: 'The `html` and `xml` packages provide all sorts of utilities for dealing with
    the major internet markup languages, including parsers and the document object
    model:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`html` 和 `xml` 包提供了处理主要互联网标记语言的各种实用工具，包括解析器和文档对象模型：'
- en: '[https://docs.python.org/3/library/html.html](https://docs.python.org/3/library/html.html)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/html.html](https://docs.python.org/3/library/html.html)'
- en: 'The `urllib` package provides us with convenient ways to retrieve data from
    URLs or to send data to them:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib` 包为我们提供了方便的方式来从 URL 获取数据或向其发送数据：'
- en: '[https://docs.python.org/3/library/urllib.html](https://docs.python.org/3/library/urllib.html)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/urllib.html](https://docs.python.org/3/library/urllib.html)'
- en: In particular, the `urllib.request.url` open function is extremely useful.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`urllib.request.url` 打开函数非常实用。
- en: 'The `itertools` and `functools` packages provide an assortment of utilities
    having to do with functional programming paradigms:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 和 `functools` 包提供了一系列与函数式编程范式相关的实用工具：'
- en: '[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)'
- en: In particular, the `functools` package allows for us to create partially applied
    functions and the `itertools` package lets us concatenate iterators.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`functools` 包允许我们创建部分应用函数，而 `itertools` 包则允许我们连接迭代器。
- en: 'The `enum` package contains support for creating and using named enumerations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 包包含创建和使用命名枚举的支持：'
- en: '[https://docs.python.org/3/library/enum.html](https://docs.python.org/3/library/enum.html)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/enum.html](https://docs.python.org/3/library/enum.html)'
- en: Each enumeration is a distinct data type, like a class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个枚举都是一个独立的数据类型，就像一个类。
- en: 'The `pathlib` package contains classes and functions that provide a cross-platform
    abstraction of file and file path operations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib` 包包含提供跨平台文件和文件路径操作抽象的类和函数：'
- en: '[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)'
- en: 'The `inspect` package is interesting and quite useful. It provides us with
    functions that can be used to gather information about data objects, particularly
    about functions and classes. If we want to know the names of functions, parameters,
    or we want to access an object''s documentation, or any number of things along
    those lines, the `inspect` package will get us there:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect` 包非常有趣且非常有用。它为我们提供了可以用来收集关于数据对象信息的函数，尤其是关于函数和类的信息。如果我们想了解函数、参数的名称，或者想访问对象的文档，或者做任何类似的事情，`inspect`
    包将帮助我们实现这些功能：'
- en: '[https://docs.python.org/3/library/inspect.html](https://docs.python.org/3/library/pathlib.html)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/inspect.html](https://docs.python.org/3/library/pathlib.html)'
- en: The packages we just looked at are by no means the complete list of what's available
    in the standard library, but hopefully they give some idea of the depth and breadth
    of what we get just by installing Python. Taking a look through the library documentation
    on [https://www.python.org/](https://www.python.org/) is highly recommended for
    people who want to get the most out of Python. There are some particularly useful
    packages that we didn't mention at all. That's because there are whole other sections
    devoted to them later in the book.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才提到的包绝不是标准库中所有可用内容的完整列表，但希望它们能让我们对通过安装Python所获得的深度和广度有一个大致的了解。强烈建议想要充分利用Python的人查看[https://www.python.org/](https://www.python.org/)上的库文档。有一些特别有用的包我们没有提到，那是因为在本书的后面部分有专门的部分介绍它们。
- en: So, that brings us to the end of our overview of the standard library.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就带我们结束了对标准库的概述。
- en: What's new in modern Python
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代Python的新特性
- en: 'In this section, we''re going to take a look at a few of the changes that have
    occurred in the latest releases of Python, specifically we will look at these:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Python最新版本中的一些变化，特别是我们将关注以下内容：
- en: The syntactic changes
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法上的变化
- en: The changes in the packages
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包的变化
- en: Other changes
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他变化
- en: Let's get started!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: The changes in the syntactic
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法上的变化
- en: Since version 3.5, Python has three new groups of syntactic editions. The first
    of these groups is the introduction of keywords for describing **coroutines**.
    Python already supported coroutines, but the keywords make things clear and sometimes
    simpler. We'll be discussing coroutines in depth in a later chapter, so we won't
    go into this any further now.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 自从3.5版本以来，Python有了三组新的语法版本。这些组中的第一组是引入了用于描述**协程**的关键字。Python已经支持协程，但关键字使得事情更加清晰，有时也更加简单。我们将在后面的章节中深入讨论协程，所以现在不会进一步讨论这个问题。
- en: 'The second piece of the new syntax is the introduction of the `@` symbol as
    an infix binary operator. This means that placing an `@` symbol between two sub-expressions
    is now a valid Python expression, just like placing a `+` symbol between the sub-expressions
    would be as shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 新语法中的第二部分是引入`@`符号作为中缀二元运算符。这意味着现在在两个子表达式之间放置一个`@`符号是一个有效的Python表达式，就像在子表达式之间放置一个`+`符号一样，如下截图所示：
- en: '![](img/15be46b7-377f-4fb8-ab72-939d11c66e92.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15be46b7-377f-4fb8-ab72-939d11c66e92.jpg)'
- en: However, since no built-in data type supports the `@` symbol operator yet, we
    won't be finding much use for it in this book. The intended semantic meaning of
    the `@` symbol is that it should represent matrix multiplication and it was added
    to improve support for an interoperability between third-party packages that implement
    matrixes and matrix operations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于尚无内置数据类型支持`@`符号运算符，我们在这本书中不太可能找到很多用途。`@`符号的预期语义是它应该代表矩阵乘法，并且它被添加以提高实现矩阵和矩阵运算的第三方包之间的互操作性。
- en: The third piece of new syntax is an expansion of Python's pre-existing syntax
    for using lists and dictionaries to provide the parameter values when invoking
    a function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 新语法的第三部分是对Python现有语法进行扩展，以便在调用函数时提供参数值。
- en: 'Before, it was possible to put an asterisk (`*`) before a list of values to
    indicate that those values should be assigned to the parameters in the same order
    that they appeared in the list. Here is the code example for a single asterisk:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，可以在值列表之前放置一个星号（`*`）来表示这些值应按列表中出现的顺序分配给参数。以下是一个单个星号的代码示例：
- en: '![](img/57af75ea-b85c-44ac-b107-4d526e15d7d8.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57af75ea-b85c-44ac-b107-4d526e15d7d8.jpg)'
- en: 'Similarly, `*` before two values was used to indicate that the values in a
    dictionary with text string keys should be assigned to the function''s parameters
    by name, as shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在两个值之前使用`*`表示字典中具有文本字符串键的值应按名称分配给函数的参数，如下所示：
- en: '![](img/9924a66c-e6a8-4940-bb05-d1c3c703961d.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9924a66c-e6a8-4940-bb05-d1c3c703961d.jpg)'
- en: The new syntax is just that we can now use more than one list or dictionary
    in this way, and that we can use the same asterisk and double asterisk syntax
    for constructing tuples, lists, dictionaries, and sets.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 新语法只是我们现在可以使用多个列表或字典以这种方式使用，并且我们可以使用相同的星号和双星号语法来构建元组、列表、字典和集合。
- en: We mentioned earlier that while Python attaches data types to data values rather
    than variables, it is possible to use function annotations to describe the expected
    types of function parameters' return values.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，虽然Python将数据类型附加到数据值而不是变量上，但可以使用函数注解来描述函数参数返回值的预期类型。
- en: Changes in packages
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包中的更改
- en: Python now includes a package called `typing` in the standard library that contains
    classes and functions supporting the usage of type hints.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Python现在在标准库中包含了一个名为`typing`的包，其中包含支持使用类型提示的类和函数。
- en: Python also includes a package called `zipapp` in the standard library.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python还在标准库中包含了一个名为`zipapp`的包。
- en: 'For `typing` visit the following website:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行`打字`，请访问以下网站：
- en: '[https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)
    For `zipapp`, visit this website:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)
    要了解`zipapp`，请访问此网站：'
- en: '[https://docs.python.org/3/library/zipapp.html](https://docs.python.org/3/library/zipapp.html)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/zipapp.html](https://docs.python.org/3/library/zipapp.html)'
- en: The `zipapp` package makes it easy to construct `.pyz` files. A `.pyz` file
    is an archive file containing Python code and arbitrary read-only data, which
    the Python runtime is able to execute as a self-contained program. Once a program
    is debugged and ready for distribution, packaging it into a `.pyz` file is a simple
    and smart way to hand it to the users.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipapp`包使得构建`.pyz`文件变得简单。`.pyz`文件是一个包含Python代码和任意只读数据的存档文件，Python运行时能够将其作为一个自包含程序执行。一旦程序调试完成并准备分发，将其打包成`.pyz`文件是将程序提供给用户的一种简单而智能的方式。'
- en: Other changes in Python packages
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python包中的其他更改
- en: Some low-level improvements have been made in Python since version 3.5, such
    as faster reading of `filesystem` directories, automatic retrying of interrupted
    operating system calls, and a `math.isclose` function for checking whether two
    numbers are approximately equal.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.5版本以来，Python进行了一些底层改进，例如更快地读取`filesystem`目录、自动重试中断的操作系统调用以及一个`math.isclose`函数，用于检查两个数字是否近似相等。
- en: There are also a bunch of more minor additions that improve things throughout
    the standard library, all backwards compatible with earlier Python 3 versions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对标准库进行的一些更多细微的改进，这些改进与早期的 Python 3 版本完全兼容。
- en: In the rare cases where something is added that breaks backwards compatibility,
    it's not enabled by default. For such a change, if we want to use it, we'd have
    to specifically mark our code as supporting the change. Those changes will not
    become standard until two versions later, so a breaking change in Python 3.5 would
    not become the default until Python version 3.7, with Python 3.5 and 3.6 issuing
    warnings when they encounter code that depends on the changing feature.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果添加的内容破坏了向后兼容性，则默认情况下不会启用。对于此类更改，如果我们想使用它，我们必须明确标记我们的代码以支持该更改。这些更改将在两个版本之后成为标准，因此
    Python 3.5 中的破坏性更改将不会在 Python 3.7 中成为默认设置，Python 3.5 和 3.6 在遇到依赖于更改功能的代码时会发出警告。
- en: In Python 3.5, there was only one such change-a small and smart alteration in
    the iteration protocol. It shouldn't have any effect on code that works properly,
    but technically it's a change in the interface and so it gets the full wait two
    versions treatment.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.5 中，只有一个这样的更改——迭代协议的一个小而聪明的修改。它不应该对正常工作的代码有任何影响，但从技术上讲，它是一个接口的更改，因此它得到了完整的等待两个版本的处理。
- en: If you want more detail about any of these changes I've mentioned, or if you
    ever want to find out what's changed between versions of Python, the documentation
    on [https://docs.python.org/3/](https://docs.python.org/3/) always contains a **what's
    new** document that goes into some detail about new features and provides links
    to the full documentation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于我提到的这些更改的详细信息，或者如果您想了解 Python 各个版本之间的变化，[https://docs.python.org/3/](https://docs.python.org/3/)
    上的文档总是包含一份“新特性”文档，该文档详细介绍了新特性并提供链接到完整文档。
- en: 'For details on the Python 3.6 what''s new document, visit the following link:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 3.6 的“新特性”文档的详细信息，请访问以下链接：
- en: '[https://docs.python.org/3/whatsnew/3.6.html](https://docs.python.org/3/whatsnew/3.6.html)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/whatsnew/3.6.html](https://docs.python.org/3/whatsnew/3.6.html)'
- en: I always look forward to reading the what's new document for each release of
    Python, to find out what new toys I've just been handed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是期待阅读 Python 每个版本的“新特性”文档，以了解我刚刚获得的新玩具。
- en: So, we've now taken a high-level view of the Python standard library, introducing
    us to some of the more useful items it contains. That brings us to the end of
    our Python primer.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经从高层次上了解了 Python 标准库，介绍了其中一些更有用的项目。这标志着我们 Python 入门课程的结束。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at some fundamentals of the Python programming language.
    We have seen how to create and access those data structures, and how to use comprehensions
    to create and transform data structures based on existing ones.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Python 编程语言的一些基础知识。我们看到了如何创建和访问这些数据结构，以及如何使用推导式根据现有数据结构创建和转换数据结构。
- en: We looked briefly at what it means for Python to have first-class functions
    and classes, and how that can affect the possibilities open to us as programmers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地探讨了 Python 具有第一类函数和类意味着什么，以及这如何影响我们作为程序员的可能选择。
- en: We briefly talked about some of the high points of the Python standard library.
    We also quickly covered the syntax, basic assumptions, and fundamental tools of
    the Python programming language.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地讨论了 Python 标准库的一些亮点。我们还快速介绍了 Python 编程语言的语法、基本假设和基本工具。
- en: In the next chapter, we're going to see how to set up a Python programming environment
    for us to work in for the remainder of the course and learn a bit about how to
    integrate third-party code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何设置 Python 编程环境，以便我们在课程剩余部分进行工作，并学习如何集成第三方代码。
