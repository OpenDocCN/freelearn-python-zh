- en: Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Flask 中使用模型、SQLAlchemy 和超链接 API 进行工作
- en: In this chapter, we will expand the capabilities of the RESTful API that we
    started in the previous chapter. We will use SQLAlchemy as our ORM to work with
    a PostgreSQL database, and we will take advantage of advanced features included
    in Flask and Flask-RESTful that will allow us to easily organize code for complex
    APIs, such as models and blueprints.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展上一章开始构建的 RESTful API 的功能。我们将使用 SQLAlchemy 作为我们的 ORM 来与 PostgreSQL
    数据库交互，并且我们将利用 Flask 和 Flask-RESTful 中包含的先进功能，这将使我们能够轻松组织代码以处理复杂的 API，如模型和蓝图。
- en: 'We will go through the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Design a RESTful API to interact with a PostgreSQL 10.5 database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个与 PostgreSQL 10.5 数据库交互的 RESTful API
- en: Understand the tasks performed by each HTTP method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每个 HTTP 方法执行的任务
- en: Install packages with the `requirements.txt` file to simplify our common tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `requirements.txt` 文件安装包以简化我们的常见任务
- en: Create the database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库
- en: Configure the database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据库
- en: Write code for the models with their ...
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '为模型编写代码，包括它们的 ... '
- en: Designing a RESTful API to interact with a PostgreSQL 10.5 database
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个与 PostgreSQL 10.5 数据库交互的 RESTful API
- en: So far, our RESTful API has performed CRUD operations on a simple in-memory
    dictionary that acted as a data repository. The dictionary is never persisted
    and, therefore, the data is lost whenever we restart our Flask development server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 RESTful API 已经在充当数据存储库的简单内存字典上执行了 CRUD 操作。该字典永远不会持久化，因此，每次我们重新启动 Flask
    开发服务器时，数据都会丢失。
- en: Now, we want to create a more complex RESTful API with Flask RESTful to interact
    with a database model that allows us to work with notifications that are grouped
    into notification categories. In our previous RESTful API, we used a string attribute
    to specify the notification category for a notification. In this case, we want
    to be able to easily retrieve all the notifications that belong to a specific
    notification category and, therefore, we will have a relationship between a notification
    and a notification category.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要使用 Flask RESTful 创建一个更复杂的 RESTful API，以便与一个数据库模型交互，该模型允许我们处理分组到通知类别中的通知。在我们的上一个
    RESTful API 中，我们使用一个字符串属性来指定通知的通知类别。在这种情况下，我们希望能够轻松检索属于特定通知类别的所有通知，因此，我们将有一个通知与通知类别之间的关系。
- en: 'We must be able to perform CRUD operations on different related resources and
    resource collections. The following table enumerates the resources and the class
    name that we will create to represent the model:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够对不同的相关资源和资源集合执行 CRUD 操作。以下表格列出了我们将创建以表示模型的资源和类名：
- en: '| Resources | Class name that represents the model |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | 代表模型的类名 |'
- en: '| Notification categories | `NotificationCategory` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 通知类别 | `NotificationCategory` |'
- en: '| Notifications | `Notification` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 通知 | `Notification` |'
- en: 'The notification category (`NotificationCategory`) just requires the following
    data:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通知类别（`NotificationCategory`）只需要以下数据：
- en: An integer identifier
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数标识符
- en: A string name
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串名称
- en: 'We need the following data for a notification (`Notification`):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个通知（`Notification`）的以下数据：
- en: An integer identifier
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数标识符
- en: A foreign key to a notification category (`NotificationCategory`)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向通知类别（`NotificationCategory`）的外键
- en: A string message
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串消息
- en: A **TTL** (short for **Time to Live**), that is, a duration in seconds that
    will indicate the amount of time the notification message has to be displayed
    on the OLED display
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **TTL**（即 **Time to Live**，表示 **生存时间**），即指示通知消息在 OLED 显示上显示的秒数
- en: A creation date and time. The timestamp will be added automatically when adding
    a new notification to the collection
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个创建日期和时间。时间戳将在将新通知添加到集合时自动添加
- en: An integer counter that indicates the times when the notification message has
    been displayed on the OLED display
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数计数器，表示通知消息在 OLED 显示上显示的次数
- en: A bool value indicating whether the notification message was displayed at least
    once on the OLED display
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，表示通知消息是否至少在 OLED 显示上显示过一次
- en: We will take advantage of many packages related to Flask RESTful and SQLAlchemy
    that make it easier to serialize and deserialize data, perform validations, and
    integrate SQLAlchemy with Flask and Flask RESTful. This way, we will reduce the
    boilerplate code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用许多与 Flask RESTful 和 SQLAlchemy 相关的包，这些包使得序列化和反序列化数据、执行验证以及将 SQLAlchemy
    与 Flask 和 Flask RESTful 集成变得更加容易。这样，我们将减少样板代码。
- en: Understanding the tasks performed by each HTTP method
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每个HTTP方法执行的任务
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our new API must support. Each method is composed by an HTTP
    verb and a scope, and all the methods have well-defined meanings for all the resources
    and collections:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的新API必须支持的方法的HTTP动词、作用域和语义。每个方法由一个HTTP动词和一个作用域组成，并且所有方法对所有资源和集合都有明确的含义：
- en: '| HTTP verb | Scope | Semantics |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| HTTP动词 | 作用域 | 语义 |'
- en: '| `GET` | Collection of notification categories | Retrieve all the stored notification
    categories in the collection, sorted by their name in ascending order. Each notification
    category must include the full URL for the resource. In addition, each notification
    category must include a list containing all the details of the notifications that
    belong to the category. The notifications don''t have to include ... |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 通知类别集合 | 获取集合中存储的所有通知类别，按名称升序排序。每个通知类别必须包含资源的完整URL。此外，每个通知类别必须包含一个列表，其中包含属于该类别的所有通知的详细信息。通知不必包含
    ... |'
- en: Installing packages with the requirements.txt file to simplify our common tasks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 requirements.txt 文件安装包以简化我们的常见任务
- en: Make sure you quit Flask's development server. You just need to press *Ctrl*
    + *C* in the Terminal or Command Prompt window in which it is running.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已退出 Flask 的开发服务器。您只需在运行它的终端或命令提示符窗口中按 *Ctrl* + *C* 即可。
- en: Now, we will install a number of additional packages. Make sure you have activated
    the virtual environment we created in the previous chapter and named `Flask01`.
    After you activate the virtual environment, it is time to run numerous commands,
    which will be the same for either macOS, Linux, or Windows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将安装一些额外的包。请确保您已激活我们在上一章中创建并命名为 `Flask01` 的虚拟环境。激活虚拟环境后，就是运行大量命令的时候了，这些命令对
    macOS、Linux 或 Windows 都是一样的。
- en: Now, we will edit the existing `requirements.txt` file to specify the additional
    set of packages that our application requires to be installed in any supported
    platform. This way, it will be extremely easy to repeat the installation of the
    specified packages with their versions in any new virtual environment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑现有的 `requirements.txt` 文件，以指定我们的应用程序在任何支持平台上需要安装的额外包集。这样，在任意新的虚拟环境中重复安装指定包及其版本将变得极其容易。
- en: 'Use your favorite editor to edit the existing text file named `requirements.txt`
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional packages and the versions that our new
    version of the API requires. The code file for the sample is included in the `restful_python_2_02_01`
    folder, in the `Flask01/requirements.txt` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器编辑虚拟环境根目录下名为 `requirements.txt` 的现有文本文件。在最后一行之后添加以下行，以声明API新版本所需的额外包及其版本。示例代码文件包含在
    `restful_python_2_02_01` 文件夹中，位于 `Flask01/requirements.txt` 文件中：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each additional line added to the `requirements.txt` file indicates the package
    and the version that needs to be installed. The following table summarizes the
    packages and the version numbers that we specified as additional requirements
    to the previously included packages:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `requirements.txt` 文件中添加的每一行都表示需要安装的包及其版本。以下表格总结了我们作为对先前包含的包的额外要求指定的包及其版本号：
- en: '| Package name | Version to be installed |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 包名 | 要安装的版本 |'
- en: '| `Flask-SQLAlchemy` | 2.3.2 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Flask-SQLAlchemy` | 2.3.2 |'
- en: '| `Flask-Migrate` | 2.2.1 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Flask-Migrate` | 2.2.1 |'
- en: '| `marshmallow` | 2.16.0 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `marshmallow` | 2.16.0 |'
- en: '| `marshmallow-sqlalchemy` | 0.14.1 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `marshmallow-sqlalchemy` | 0.14.1 |'
- en: '| `flask-marshmallow` | 0.9.0 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `flask-marshmallow` | 0.9.0 |'
- en: '| `psycopg2` | 2.7.5 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `psycopg2` | 2.7.5 |'
- en: '`Flask-SQLAlchemy` adds support for the SQLAlchemy ORM to Flask applications.
    This extension simplifies executing common SQLAlchemy tasks within a Flask application.
    SQLAlchemy is a dependency for `Flask-SQLAlchemy`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-SQLAlchemy` 为 Flask 应用程序添加了对 SQLAlchemy ORM 的支持。这个扩展简化了在 Flask 应用程序中执行常见的
    SQLAlchemy 任务。SQLAlchemy 是 `Flask-SQLAlchemy` 的依赖项。'
- en: '`Flask-Migrate` uses the Alembic package to handle SQLAlchemy database migrations
    for Flask applications. We will use `Flask-Migrate` to set up our PostgreSQL database.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-Migrate` 使用 Alembic 包来处理 Flask 应用程序的 SQLAlchemy 数据库迁移。我们将使用 `Flask-Migrate`
    来设置我们的 PostgreSQL 数据库。'
- en: If you've worked with previous versions of `Flask-Migrate`, it is very important
    to notice that Flask-Script is no longer a dependency for `Flask-Migrate` . Flask-Script
    was a popular package that added support for writing external scripts in Flask,
    including scripts to set up a database. The newest Flask versions install the
    `flask` script and a command-line interface based on the Click package in the
    virtual environment. Hence, it is no longer necessary to combine `Flask-Migrate`
    with Flask-Script.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过 `Flask-Migrate` 的先前版本，请注意，Flask-Script 已不再是 `Flask-Migrate` 的依赖项。Flask-Script
    是一个流行的包，它为 Flask 添加了编写外部脚本的支持，包括设置数据库的脚本。最新的 Flask 版本在虚拟环境中安装了 `flask` 脚本和基于 Click
    包的命令行界面。因此，不再需要将 `Flask-Migrate` 与 Flask-Script 结合使用。
- en: Marshmallow is a lightweight library for converting complex datatypes to and
    from native Python datatypes. Marshmallow provides schemas that we can use to
    validate input data, deserialize input data to app-level objects, and serialize
    app-level objects to Python primitive types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Marshmallow 是一个轻量级库，用于将复杂的数据类型转换为原生 Python 数据类型，反之亦然。Marshmallow 提供了模式，我们可以使用它们来验证输入数据，将输入数据反序列化为应用级别的对象，以及将应用级别的对象序列化为
    Python 原始类型。
- en: '`marshmallow-sqlalchemy` provides SQLAlchemy integration with the previously
    installed `marshmallow` validation, serialization, and deserialization lightweight
    library.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`marshmallow-sqlalchemy` 提供了与之前安装的 `marshmallow` 验证、序列化和反序列化轻量级库的 SQLAlchemy
    集成。'
- en: Flask-Marshmallow integrates the previously installed `marshmallow` library
    with Flask applications and makes it easy to generate URL and hyperlink fields.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-Marshmallow 将之前安装的 `marshmallow` 库与 Flask 应用程序集成，使得生成 URL 和超链接字段变得简单易行。
- en: Psycopg 2 (`psycopg2`) is a Python-PostgreSQL database adapter and SQLAlchemy
    will use it to interact with our recently created PostgreSQL database. Again,
    it is very important to make sure that the PostgreSQL `bin` folder is included
    in the `PATH` environmental variable before we run the installation for this package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Psycopg 2 (`psycopg2`) 是一个 Python-PostgreSQL 数据库适配器，SQLAlchemy 将使用它来与我们的最近创建的
    PostgreSQL 数据库交互。同样，在运行此包的安装之前，确保 PostgreSQL 的 `bin` 文件夹包含在 `PATH` 环境变量中是非常重要的。
- en: 'Now, we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions explained in the previous table with
    `pip` by using the recently edited `requirements` file. Make sure you are located
    in the folder that has the `requirements.txt` file before running the command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在 macOS、Linux 或 Windows 上运行以下命令来安装先前表格中解释的附加包和版本，使用 `pip` 通过最近编辑的 `requirements`
    文件。在运行命令之前，请确保您位于包含 `requirements.txt` 文件的文件夹中：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last lines for the output will indicate that all the new packages and their
    dependencies have been successfully installed. If you downloaded the source code
    for the example and you didn''t work with the previous version of the API, `pip`
    will also install the other packages included in the `requirements.txt` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有新安装的包及其依赖项已成功安装。如果您下载了示例的源代码，并且您没有使用 API 的先前版本，`pip` 还将安装 `requirements.txt`
    文件中包含的其他包：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating the database
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库
- en: Now, we will create the PostgreSQL 10.5 database that we will use as a repository
    for our API. You will have to download and install a PostgreSQL database server
    if you aren't already running it in your computer or on a development server.
    You can download and install this database management system from its web page
    ([http://www.postgresql.org)](http://www.postgresql.org). If you are working with
    macOS, `Postgres.app` provides a really easy way to install and use PostgreSQL
    on this operating system. You can refer to it from [http://postgresapp.com](http://postgresapp.com).
    If you are working with Windows, EnterpriseDB and BigSQL provide graphics installers
    that simplify the configuration process on modern Windows server or desktop versions
    (visit [https://www.postgresql.org/download/windows ...](https://www.postgresql.org/download/windows)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 PostgreSQL 10.5 数据库，我们将使用它作为我们的 API 的存储库。如果您还没有在您的计算机或开发服务器上运行 PostgreSQL
    数据库服务器，您将需要下载并安装它。您可以从其网页([http://www.postgresql.org](http://www.postgresql.org))下载并安装这个数据库管理系统。如果您使用的是
    macOS，`Postgres.app` 提供了一种非常简单的方法来安装和使用 PostgreSQL。您可以从 [http://postgresapp.com](http://postgresapp.com)
    参考它。如果您使用的是 Windows，EnterpriseDB 和 BigSQL 提供了图形安装程序，这些安装程序简化了在现代 Windows 服务器或桌面版本上的配置过程（访问
    [https://www.postgresql.org/download/windows](https://www.postgresql.org/download/windows)）。
- en: Configuring the database
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据库
- en: If you are using the same virtual environment we have created for the previous
    example, or you downloaded the code sample, the `service` folder already exists.
    If you created a new virtual environment, create a folder named `service` within
    the root folder for the  virtual environment created.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是我们为之前示例创建的相同虚拟环境，或者你下载了代码示例，那么`service`文件夹已经存在。如果你创建了一个新的虚拟环境，请在虚拟环境根文件夹内创建一个名为`service`的文件夹。
- en: 'Create a new `config.py` file within the `service` folder. The following lines
    show the code that declares variables that determine the configuration for Flask
    and SQLAlchemy. The `SQL_ALCHEMY_DATABASE_URI` variable generates an SQLAlchemy
    URI for the PostgreSQL database. Make sure you specify the desired database name
    in the value for `DB_NAME` and that you configure the user, password, host, and
    port based on your PostgreSQL configuration. If you followed the previous steps,
    use the settings specified in these steps. The code file for the sample is included
    in the `restful_python_2_02_01` folder, in the `Flask01/service/config.py` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service`文件夹内创建一个新的`config.py`文件。以下行展示了声明用于确定Flask和SQLAlchemy配置的变量的代码。`SQL_ALCHEMY_DATABASE_URI`变量生成用于PostgreSQL数据库的SQLAlchemy
    URI。确保你在`DB_NAME`的值中指定所需的数据库名称，并根据你的PostgreSQL配置配置用户、密码、主机和端口。如果你遵循了之前的步骤，请使用这些步骤中指定的设置。示例代码文件包含在`restful_python_2_02_01`文件夹中，位于`Flask01/service/config.py`文件中：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will specify the previously created module (`config`) as an argument to a
    function that will create a Flask app. This way, we have one module that specifies
    all the values for the different configuration variables related to SQLAlchemy,
    and another module that creates a Flask app. We will create the Flask app factory
    as our final step toward our new API.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指定之前创建的模块（`config`）作为创建Flask应用的函数的参数。这样，我们有一个模块指定了与SQLAlchemy相关的所有不同配置变量的值，另一个模块创建Flask应用。我们将创建Flask应用工厂作为我们迈向新API的最终步骤。
- en: Creating models with their relationships
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有其关系的模型
- en: Now, we will create the models that we will use to represent and persist the
    notification categories, notifications, and their relationships in the PostgreSQL
    database.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们将用于在PostgreSQL数据库中表示和持久化通知类别、通知及其关系的模型。
- en: 'Open the `service/models.py` file and replace its contents with the following
    code. The lines that declare fields related to other models are highlighted in
    the code listing. If you created a new virtual environment, create a new `models.py`
    file within the `service` folder. The code file for the sample is included in
    the `restful_python_2_02_01` folder, in the `Flask01/service/models.py` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`service/models.py`文件，并用以下代码替换其内容。代码中声明与其它模型相关字段的行被突出显示。如果你创建了一个新的虚拟环境，请在`service`文件夹内创建一个新的`models.py`文件。示例代码文件包含在`restful_python_2_02_01`文件夹中，位于`Flask01/service/models.py`文件中：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating schemas to validate, serialize, and deserialize models
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于验证、序列化和反序列化模型的模式
- en: Now, we will create the Flask-Marshmallow schemas that we will use to validate,
    serialize, and deserialize the previously declared `NotificationCategory` and
    `Notification` models, and their relationships.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们将用于验证、序列化和反序列化之前声明的`NotificationCategory`和`Notification`模型及其关系的Flask-Marshmallow模式。
- en: 'Open the `models.py` file within the `service` folder and add the following
    code after the last line. The lines that declare fields related to other schemas
    are highlighted in the code listing. The code file for the sample is included
    in the `restful_python_2_02_01` folder, in the `Flask01/service/models.py` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`service`文件夹内的`models.py`文件，并在最后一行之后添加以下代码。代码中声明与其它模式相关字段的行被突出显示。示例代码文件包含在`restful_python_2_02_01`文件夹中，位于`Flask01/service/models.py`文件中：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code declares the following two schemas, that is, two subclasses of the
    `ma.Schema` class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下两个模式，即`ma.Schema`类的两个子类：
- en: '`NotificationCategorySchema`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotificationCategorySchema`'
- en: '`NotificationSchema`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotificationSchema`'
- en: We don't use the Flask-Marshmallow features that allow us to automatically determine
    the appropriate type for each attribute based on the fields declared in a model
    because we want to use specific options for each field.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用Flask-Marshmallow允许我们根据模型中声明的字段自动确定每个属性适当类型的特性，因为我们想为每个字段使用特定的选项。
- en: We declare the attributes that represent fields as instances of the appropriate
    classes declared in the `marshmallow.fields` module. Whenever we specify the `True`
    value for the `dump_only` argument, it means that we want the field to be read-only.
    For example, we won't be able to provide a value for the `id` field in any of
    the schemas. The value for this field will be automatically generated by the auto-increment
    primary key in the PostgreSQL database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表示字段的属性声明为`marshmallow.fields`模块中声明的适当类的实例。每当我们将`dump_only`参数指定为`True`时，这意味着我们希望该字段为只读。例如，我们无法在任何模式中为`id`字段提供值。该字段的值将由PostgreSQL数据库中的自增主键自动生成。
- en: The `NotificationCategorySchema` class declares the `name` attribute as an instance
    of `fields.String`. The `required` argument is set to `True` to specify that the
    field cannot be an empty string. The `validate` argument is set to `validate.Length(3)`
    to specify that the field must have a minimum length of three characters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationCategorySchema`类将`name`属性声明为`fields.String`类的一个实例。`required`参数设置为`True`，以指定该字段不能为空字符串。`validate`参数设置为`validate.Length(3)`，以指定该字段必须至少有三个字符的长度。'
- en: 'The class declares the `url` field with the following lines:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用以下行声明了`url`字段：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `url` attribute is an instance of the `ma.URLFor` class and this field
    will output the full URL of the resource, that is, the URL for the notification
    category. The first argument is the Flask endpoint''s name: `''service.notificationcategoryresource''`.
    We will create a `NotificationCategoryResource` class later and the `URLFor` class
    will use it to generate the URL. The `id` argument specifies `''<id>''` because
    we want the `id` to be pulled from the object to be serialized. The `id` string
    enclosed within less than (`<`) and greater than (`>`) symbols specifies that
    we want the field to be pulled from the object that has to be serialized. The
    `_external` attribute is set to `True` because we want to generate the full URL
    for the resource. This way, every time we serialize a `NotificationCategory`,
    it will include the full URL for the resource in the `url` key or property.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`属性是`ma.URLFor`类的一个实例，并且这个字段将输出资源的完整URL，即通知类别的URL。第一个参数是Flask端点的名称：`''service.notificationcategoryresource''`。我们将在稍后创建`NotificationCategoryResource`类，`URLFor`类将使用它来生成URL。`id`参数指定`''<id>''`，因为我们希望从要序列化的对象中提取`id`。小于（`<`）和大于（`>`）符号内的`id`字符串指定我们希望从必须序列化的对象中提取字段。`_external`属性设置为`True`，因为我们希望生成资源的完整URL。这样，每次序列化`NotificationCategory`时，它都会在`url`键或属性中包含资源的完整URL。'
- en: In this case, we are using our insecure API behind HTTP. If our API is configured
    with HTTPS, we should set the `_scheme` argument to `'https'` when we create the
    `ma.URLFor` instance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用不安全的API在HTTP后面。如果我们的API配置为HTTPS，那么在创建`ma.URLFor`实例时，我们应该将`_scheme`参数设置为`'https'`。
- en: 'The class declares the `notifications` field with the following lines:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用以下行声明了`notifications`字段：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `notifications` attribute is an instance of the `marshmallow.fields.Nested`
    class, and this field will nest a collection of `Schema`, so, therefore, we specify
    `True` for the `many` argument. The first argument specifies the name for the
    nested `Schema` class as a string. We declare the `NotificationSchema` class after
    we defined the `NotificationCategorySchema` class. Thus, we specify the `Schema`
    class name as a string instead of using the type that we haven't defined yet.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`notifications`属性是`marshmallow.fields.Nested`类的一个实例，并且这个字段将嵌套一个`Schema`集合，因此，我们为`many`参数指定`True`。第一个参数指定嵌套`Schema`类的名称为一个字符串。我们在定义了`NotificationCategorySchema`类之后声明`NotificationSchema`类。因此，我们指定`Schema`类名为一个字符串，而不是使用我们尚未定义的类型。'
- en: In fact, we will end up with two objects that nest to each other; that is, we
    will create a two-way nesting between notification categories and notifications.
    We use the `exclude` parameter with a tuple of string to indicate that we want
    the `notification_category` field to be excluded from the fields that are serialized
    for each notification. This way, we avoid infinite recursion because the inclusion
    of the `notification_category` field would serialize all the notifications related
    to the category.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们将得到两个相互嵌套的对象；也就是说，我们将在通知类别和通知之间创建双向嵌套。我们使用一个字符串元组作为`exclude`参数，以指示我们希望`notification_category`字段从为每个通知序列化的字段中排除。这样，我们避免了无限递归，因为包含`notification_category`字段将序列化与该类别相关的所有通知。
- en: When we declared the `Notification` model, we used the `orm.relationship` function
    to provide a many-to-one relationship to the `NotificationCategory` model. The
    `backref` argument specified a call to the `orm.backref` function with `'notifications'`
    as the first value that indicates the name to use for the relation from the related
    `NotificationCategory` object back to a `Notification` object. With the previously
    explained line, we created the `notifications` fields that use the same name we
    indicated for the `db.backref` function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明`Notification`模型时，我们使用了`orm.relationship`函数来提供对`NotificationCategory`模型的多对一关系。`backref`参数指定了一个调用`orm.backref`函数的调用，其中`'notifications'`作为第一个值，表示从相关的`NotificationCategory`对象返回到`Notification`对象的关系名称。通过之前解释的行，我们创建了使用我们为`db.backref`函数指定的相同名称的`notifications`字段。
- en: The `NotificationSchema` class declares the `notification` attribute as an instance
    of `fields.String`. The `required` argument is set to `True` to specify that the
    field cannot be an empty string. The `validate` argument is set to `validate.Length(5)`
    to specify that the field must have a minimum length of five characters. The class
    declares the `ttl`, `creation_date`, `displayed_times`, and `displayed_once` fields
    with the corresponding classes based on the types we used in the `Message` model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationSchema`类将`notification`属性声明为`fields.String`类的一个实例。`required`参数设置为`True`，以指定该字段不能为空字符串。`validate`参数设置为`validate.Length(5)`，以指定该字段必须至少有五个字符长。该类使用与我们在`Message`模型中使用的类型相对应的类声明了`ttl`、`creation_date`、`displayed_times`和`displayed_once`字段。'
- en: 'The class declares the `notification_category` field with the following lines:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用以下行声明了`notification_category`字段：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `notification_category` attribute is an instance of the `marshmallow.fields.Nested`
    class, and this field will nest a single `NotificationCategorySchema`. We specify
    `True` for the `required` argument because a notification must belong to a category.
    The first argument specifies the name for the nested `Schema` class. We already
    declared the `NotificationCategorySchema` class and, therefore, we specify `NotificationCategorySchema`
    as the value for the first argument. We use the `only` parameter with a list of
    strings to indicate the field names that we want to be included when the nested
    `NotificationCategorySchema` is serialized. We want the `id`, `url`, and `name`
    fields to be included. We don't specify the `notifications` field because we don't
    want the notification category to serialize the list of notifications that belong
    to it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`notification_category`属性是`marshmallow.fields.Nested`类的一个实例，并且这个字段将嵌套一个`NotificationCategorySchema`。我们为`required`参数指定`True`，因为通知必须属于一个类别。第一个参数指定了嵌套`Schema`类的名称。我们已声明了`NotificationCategorySchema`类，因此我们将`NotificationCategorySchema`指定为第一个参数的值。我们使用带有字符串列表的`only`参数来指示在序列化嵌套的`NotificationCategorySchema`时要包含的字段名称。我们希望包含`id`、`url`和`name`字段。我们没有指定`notifications`字段，因为我们不希望通知类别序列化属于它的通知列表。'
- en: 'The class declares the `url` field with the following lines:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用以下行声明了`url`字段：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `url` attribute is an instance of the `ma.URLFor` class and this field
    will output the full URL of the resource, that is, of the notification resource.
    The first argument is the Flask endpoint name: `''service.notificationresource''`.
    We will create a `NotificationResource` class later and the `URLFor` class will
    use it to generate the URL. The `id` argument specifies `''<id>''` because we
    want `id` to be pulled from the object to be serialized. The `_external` attribute
    is set to `True` because we want to generate the full URL for the resource. This
    way, each time we serialize a `Notification`, it will include the full URL for
    the resource in the `url` key.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`属性是`ma.URLFor`类的一个实例，并且这个字段将输出资源的完整URL，即通知资源的URL。第一个参数是Flask端点名称：`''service.notificationresource''`。我们稍后会创建`NotificationResource`类，`URLFor`类将使用它来生成URL。`id`参数指定为`''<id>''`，因为我们希望从要序列化的对象中提取`id`。`_external`属性设置为`True`，因为我们希望为资源生成完整的URL。这样，每次我们序列化一个`Notification`时，它都会在`url`键中包含资源的完整URL。'
- en: The `NotificationSchema` class declares a `process_notification_category` method
    that uses the `@pre_load` decorator, specifically, `marshmallow.pre_load`. This
    decorator registers a method to invoke before deserializing an object. This way,
    before Marshmallow deserializes a notification, the `process_category` method
    will be executed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationSchema` 类声明了一个 `process_notification_category` 方法，该方法使用 `@pre_load`
    装饰器，具体来说，是 `marshmallow.pre_load`。这个装饰器注册了一个在反序列化对象之前调用的方法。这样，在 Marshmallow 反序列化通知之前，`process_category`
    方法将被执行。'
- en: The method receives the data to be deserialized in the `data` argument and it
    returns the processed data. When we receive a request to `POST` a new notification,
    the notification category name can be specified in a key named `'notification_category'`.
    If a category with the specified name exists, we will use the existing category
    as the one that is related to the new notification. If a category with the specified
    name doesn't exist, we will create a new notification category and then we will
    use this new category as the one that is related to the new notification. This
    way, we make it easy and straightforward for the user to create new notifications
    related to categories.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接收 `data` 参数中的要反序列化的数据，并返回处理后的数据。当我们收到一个请求以 `POST` 新通知时，通知类别名称可以指定为名为 `'notification_category'`
    的键。如果存在具有指定名称的类别，我们将使用现有的类别作为与新的通知相关联的类别。如果不存在具有指定名称的类别，我们将创建一个新的通知类别，然后我们将使用这个新类别作为与新的通知相关联的类别。这样，我们使用户创建与类别相关的新通知变得简单直接。
- en: The `data` argument might have a notification category name specified as a string
    for the `'notification_category'` key. However, in other cases, the `'notification_category'`
    key will include the key-value pairs with the field name and field values for
    an existing notification category.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 参数可能包含一个指定为 `''notification_category''` 键的字符串形式的通知类别名称。然而，在其他情况下，`''notification_category''`
    键将包含具有字段名称和字段值的键值对，这些值对应于现有的通知类别。'
- en: The code in the `process_notification_category` method checks the value of the
    `'notification_category'` key and returns a dictionary with the appropriate data
    to make sure that we are able to deserialize a notification category with the
    appropriate key-value pairs, irrespective of the differences between the incoming
    data. Finally, the method returns the processed dictionary. We will dive deep
    on the work done by the `process_notification_category` method later when we start
    composing and sending HTTP requests to the new API.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_notification_category` 方法中的代码检查 `''notification_category''` 键的值，并返回一个包含适当数据的字典，以确保我们能够使用适当的键值对反序列化通知类别，无论传入数据之间的差异如何。最后，该方法返回处理后的字典。当我们在开始组合和发送对新
    API 的 HTTP 请求时，我们将深入了解 `process_notification_category` 方法所做的工作。'
- en: Combining blueprints with resourceful routing
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将蓝图与资源路由相结合
- en: 'Now, we will create the resources that compose our main building blocks for
    the RESTful API. First, we will create a few instances that we will use in the
    different resources. Create a new `views.py` file within the `services` folder
    and add the following lines. Notice that the code imports the `HttpStatus` enum
    declared in the `http_status.py` module that we created in the previous chapter.
    The code file for the sample is included in the `restful_python_2_02_01` folder,
    in the `Flask01/service/views.py` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建组成我们 RESTful API 主要构建块的资源。首先，我们将创建一些将在不同资源中使用的实例。在 `services` 文件夹内创建一个新的
    `views.py` 文件，并添加以下行。注意，代码导入了在上一章中创建的 `http_status.py` 模块中声明的 `HttpStatus` 枚举。示例代码文件包含在
    `restful_python_2_02_01` 文件夹中，位于 `Flask01/service/views.py` 文件：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Understanding and configuring resourceful routing
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和配置资源路由
- en: 'The following table shows the method of our previously created classes that
    we want to be executed for each combination of HTTP verb and scope:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了我们要为每个 HTTP 动词和范围组合执行的先前创建的类的操作方法：
- en: '| HTTP verb | Scope | Class and method |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 动词 | 范围 | 类和方法 |'
- en: '| `GET` | Collection of notifications | `NotificationListResource.get` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 通知集合 | `NotificationListResource.get` |'
- en: '| `GET` | Notification | `NotificationResource.get` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 通知 | `NotificationResource.get` |'
- en: '| `POST` | Collection of notifications | `NotificationListResource.post` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 通知集合 | `NotificationListResource.post` |'
- en: '| `PATCH` | Notification | `NotificationResource.patch` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 通知 | `NotificationResource.patch` |'
- en: '| `DELETE` | Notification | `NotificationResource.delete` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 通知 | `NotificationResource.delete` |'
- en: '| `GET` | Collection of notification categories | `NotificationCategoryListResource.get`
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 通知类别集合 | `NotificationCategoryListResource.get` |'
- en: '| `GET` | Notification category | `NotificationCategoryResource.get` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 通知类别 | `NotificationCategoryResource.get` |'
- en: '| `POST` | Collection of notification categories | `NotificationCategoryListResource.post`
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 通知类别集合 | `NotificationCategoryListResource.post` |'
- en: '| `PATCH` | Notification category | `NotificationCategoryResource.patch` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 通知类别 | `NotificationCategoryResource.patch` |'
- en: '| `DELETE` | Notification category | `NotificationCategoryResource.delete`
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 通知类别 | `NotificationCategoryResource.delete` |'
- en: If the request results in the invocation of a resource with an unsupported HTTP
    method, Flask-RESTful will return a response with the HTTP `405 Method Not Allowed`
    status code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求导致调用一个不支持 HTTP 方法的资源，Flask-RESTful 将返回一个带有 HTTP `405 Method Not Allowed`
    状态码的响应。
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines configure the resource routing for the service. Open the previously created
    `views.py` file within the `service` folder and add the following code after the
    last line. The code file for the sample is included in the `restful_python_2_02_01`
    folder, in the `Flask01/service/views.py` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过定义 URL 规则来进行必要的资源路由配置，以调用适当的方法，并通过传递所有必要的参数。以下行配置了服务的资源路由。在 `service`
    文件夹中打开之前创建的 `views.py` 文件，并在最后一行之后添加以下代码。示例的代码文件包含在 `restful_python_2_02_01` 文件夹中，位于
    `Flask01/service/views.py` 文件：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each call to the `service.add_resource` method routes a URL to a resource; specifically,
    to one of the previously declared subclasses of the `flask_restful.Resource` superclass.
    Whenever there is a request to the API, and the URL matches one of the URLs specified
    in the `service.add_resource` method, Flask will call the method that matches
    the HTTP verb in the request for the specified class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `service.add_resource` 方法都会将一个 URL 路由到一个资源；具体来说，是到之前声明的 `flask_restful.Resource`
    超类的一个先前声明的子类。每当有 API 请求，并且 URL 与 `service.add_resource` 方法中指定的 URL 之一匹配时，Flask
    将调用与请求中指定的类匹配的 HTTP 动词的方法。
- en: Registering the blueprint and running migrations
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册蓝图和运行迁移
- en: 'Create a new `app.py` file within the `service` folder. The following lines
    show the code that creates a Flask application. The code file for the sample is
    included in the `restful_python_2_02_01` folder, in the `Flask01/service/app.py`
    file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `service` 文件夹中创建一个新的 `app.py` 文件。以下行显示了创建 Flask 应用程序的代码。示例的代码文件包含在 `restful_python_2_02_01`
    文件夹中，位于 `Flask01/service/app.py` 文件：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code in the `service/app.py` file declares a `create_app` function ...
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`service/app.py` 文件中的代码声明了一个 `create_app` 函数...'
- en: Verifying the contents of the PostgreSQL database
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证 PostgreSQL 数据库的内容
- en: After we run the previous scripts, we can use the PostgreSQL command line or
    any other application that allows us to easily verify the contents of the PostgreSQL
    10.5 database to check the tables that the migration generated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行前面的脚本之后，我们可以使用 PostgreSQL 命令行或任何允许我们轻松验证 PostgreSQL 10.5 数据库内容的其他应用程序来检查迁移生成的表。
- en: 'Run the following command to list the generated tables. If the database name
    you are using is not named `flask_notifications`, make sure you use the appropriate
    database name. The code file for the sample is included in the `restful_python_2_02_01`
    folder, in the `Flask01/list_database_tables.sql` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以列出生成的表。如果您使用的数据库名称不是 `flask_notifications`，请确保您使用适当的数据库名称。示例的代码文件包含在
    `restful_python_2_02_01` 文件夹中，位于 `Flask01/list_database_tables.sql` 文件：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following lines show the output with all the generated table names:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了所有生成的表名的输出：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'SQLAlchemy generated the following two tables with the unique constraints and
    the foreign keys based on the information included in our models:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 根据我们模型中包含的信息生成了以下两个表，具有唯一约束和外键：
- en: '`notification_category`: This table persists the `NotificationCategory` model.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notification_category`：此表持久化 `NotificationCategory` 模型。'
- en: '`notification`: This table persists the `Notification` model.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notification`：此表持久化 `Notification` 模型。'
- en: 'The following command will allow you to check the contents of the two tables
    after we compose and send HTTP requests to the RESTful API and execute CRUD operations
    on the two tables. The commands assume that you are running PostgreSQL 10.5 on
    the same computer in which you are running the command. The code file for the
    sample is included in the `restful_python_2_02_01` folder, in the `Flask01/check_tables_contents.sql`
    file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在我们向RESTful API发送HTTP请求并执行两个表上的CRUD操作后，允许你检查两个表的内容。这些命令假设你在运行命令的同一台计算机上运行PostgreSQL
    10.5。示例代码文件包含在`restful_python_2_02_01`文件夹中的`Flask01/check_tables_contents.sql`文件中：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instead of working with the PostgreSQL command-line utility, you can use your
    favorite GUI tool to check the contents of the PostgreSQL database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用PostgreSQL的命令行工具，你可以使用你喜欢的GUI工具来检查PostgreSQL数据库的内容。
- en: Alembic generated an additional table named `alembic_version` that saves the
    version number for the database in the `version_num` column. This table makes
    it possible for the migration commands to retrieve the current version for the
    database and upgrade or downgrade it based on our needs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Alembic生成了一个名为`alembic_version`的额外表，该表在`version_num`列中保存数据库的版本号。这个表使得迁移命令能够检索数据库的当前版本，并根据我们的需求升级或降级。
- en: Creating and retrieving related resources
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和检索相关资源
- en: Now, we will use the flask script to launch Flask's development server and our
    RESTful API. We want to enable the debug mode and, therefore, we will set the
    value for the `FLASK_ENV` environment variable to `development`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`flask`脚本启动Flask的开发服务器和我们的RESTful API。我们想启用调试模式，因此我们将`FLASK_ENV`环境变量的值设置为`development`。
- en: 'Run the following command in the Terminal in Linux or macOS with a bash shell:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或macOS的bash shell中的终端运行以下命令：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In Windows, if you are using the Command Prompt, run the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，如果你正在使用命令提示符，请运行以下命令：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Windows, if you are using Windows PowerShell, run the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，如果你正在使用Windows PowerShell，请运行以下命令：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, run the `flask` script that launches Flask's development server and the
    application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行启动Flask开发服务器和应用程序的`flask`脚本。
- en: Now that the `FLASK_ENV` environment variable is configured to work in development
    ...
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经将`FLASK_ENV`环境变量配置为在开发模式下工作...
- en: Test your knowledge
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'Which of the following commands start the Flask development server and the
    Flask application, and makes it listen on every interface on port `5000`?:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令启动Flask开发服务器和Flask应用程序，并使其在`5000`端口上监听所有接口？
- en: '`flask run -h 0.0.0.0`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flask run -h 0.0.0.0`'
- en: '`flask run -p 0.0.0.0 -h 5000`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flask run -p 0.0.0.0 -h 5000`'
- en: '`flask run -p 0.0.0.0`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flask run -p 0.0.0.0`'
- en: '`Flask-Migrate` is:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Flask-Migrate`是：'
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个轻量级的库，用于将复杂的数据类型转换为原生Python数据类型，以及从原生Python数据类型转换回复杂的数据类型。
- en: A library that uses the Alembic package to handle SQLAlchemy database migrations
    for Flask applications.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个使用Alembic包来处理Flask应用程序的SQLAlchemy数据库迁移的库。
- en: A library that replaces SQLAlchemy to run queries on PostgreSQL.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个替代SQLAlchemy以在PostgreSQL上运行查询的库。
- en: 'Marshmallow is:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Marshmallow是：
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个轻量级的库，用于将复杂的数据类型转换为和从原生Python数据类型。
- en: An ORM.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个ORM。
- en: A lightweight web framework that replaces Flask.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个轻量级的Web框架，用于替代Flask。
- en: 'SQLAlchemy is:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQLAlchemy是：
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个轻量级的库，用于将复杂的数据类型转换为和从原生Python数据类型。
- en: An ORM.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个ORM。
- en: A lightweight web framework that replaces Flask.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个轻量级的Web框架，用于替代Flask。
- en: 'The `marshmallow.pre_load` decorator:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`marshmallow.pre_load`装饰器：'
- en: Registers a method to run after any instance of the `Resource` class is created.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Resource`类的任何实例创建后注册一个要调用的方法。
- en: Registers a method to invoke after serializing an object.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在序列化对象后注册一个要调用的方法。
- en: Registers a method to invoke before deserializing an object.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在反序列化对象之前注册一个要调用的方法。
- en: 'The `dump` method for any instance of a `Schema` subclass:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Schema`子类的任何实例的`dump`方法：'
- en: Routes URLs to Python primitives.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL路由到Python原语。
- en: Persists the instance or collection of instances passed as an argument to the
    database.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将作为参数传递的实例或实例集合持久化到数据库中。
- en: Takes the instance or collection of instances passed as an argument and applies
    the field filtering and output formatting specified in the `Schema` subclass to
    the instance or collection of instances.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收作为参数传递的实例或实例集合，并将`Schema`子类中指定的字段过滤和输出格式应用于实例或实例集合。
- en: 'When we declare an attribute as an instance of the `marshmallow.fields.Nested`
    class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将属性声明为`marshmallow.fields.Nested`类的实例时：
- en: The field will nest a single `Schema` or a collection of `Schema` based on the
    value for the `many` argument.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该字段将根据`many`参数的值嵌套单个`Schema`或`Schema`集合。
- en: The field will nest a single `Schema`. If we want to nest a collection of `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedCollection` class.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该字段将嵌套单个`Schema`。如果我们想嵌套`Schema`集合，我们必须使用`marshmallow.fields.NestedCollection`类的实例。
- en: The field will nest a collection of `Schema`. If we want to nest a single `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedSingle` class.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该字段将嵌套一个`Schema`集合。如果我们想嵌套单个`Schema`，我们必须使用`marshmallow.fields.NestedSingle`类的实例。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we expanded the capabilities of the previous version of the
    RESTful API we created in the preceding chapter. We used SQLAlchemy as our ORM
    to work with a PostgreSQL 10.5 database. We added many packages to simplify many
    common tasks, we wrote code for the models and their relationships, and we worked
    with schemas to validate, serialize, and deserialize these models.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了上一章中创建的RESTful API的前一个版本的功能。我们使用SQLAlchemy作为我们的ORM来与PostgreSQL 10.5数据库一起工作。我们添加了许多包来简化许多常见任务，我们为模型及其关系编写了代码，并与模式一起工作以验证、序列化和反序列化这些模型。
- en: We combined blueprints with resourceful routing, and we were able to generate
    the database from the models. We composed and sent many HTTP requests to our RESTful
    API and analyzed how each HTTP request was processed in our code and how the models
    persisted in the database tables.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将蓝图与资源路由相结合，从而能够从模型生成数据库。我们向RESTful API发送了许多HTTP请求，并分析了我们的代码中每个HTTP请求的处理方式以及模型在数据库表中的持久化情况。
- en: Now that we have built a complex API with Flask, Flask-RESTful, and SQLAlchemy,
    ...
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Flask、Flask-RESTful和SQLAlchemy构建了一个复杂的API，...
