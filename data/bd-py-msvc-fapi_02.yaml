- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Exploring the Core Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索核心功能
- en: In the previous chapter, we found out how easy it is to install and start developing
    REST APIs using the **FastAPI** framework. Handling requests, cookies, and form
    data was fast, easy, and straightforward with FastAPI, as was building the different
    HTTP path operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们发现使用**FastAPI**框架安装和开始开发REST API非常容易。使用FastAPI处理请求、cookies和表单数据既快又简单，构建不同的HTTP路径操作也是如此。
- en: To learn about the framework’s features further, this chapter will guide us
    on how to upgrade our REST APIs by adding some essential FastAPI features to the
    implementation. These include some handlers that can help minimize unchecked exceptions,
    JSON encoders that can directly manage endpoint responses, background jobs that
    can create audit trails and logs, and multiple threads to run some API methods
    asynchronously with the **uvicorn**’s main thread. Moreover, issues such as managing
    source files, modules, and packages for huge enterprise projects will also be
    addressed in this chapter. This chapter will use and dissect an *intelligent tourist
    system* prototype to assist with elaborating upon and exemplifying FastAPI’s core
    modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解框架的功能，本章将指导我们如何通过添加一些必要的FastAPI功能来升级我们的REST API实现。这包括一些可以帮助最小化未检查异常的处理程序，可以直接管理端点响应的JSON编码器，可以创建审计跟踪和日志的后台作业，以及使用**uvicorn**的主线程异步运行某些API方法的多个线程。此外，本章还将解决大型企业项目中的源文件、模块和包管理问题。本章将使用并剖析一个*智能旅游系统*原型，以帮助阐述和举例说明FastAPI的核心模块。
- en: 'Based on these aforementioned features, this chapter will discuss the following
    major concepts that can help us extend our learning about this framework:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上述功能，本章将讨论以下主要概念，这些概念可以帮助我们扩展对该框架的了解：
- en: Structuring and organizing huge projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化和组织大型项目
- en: Managing API-related exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理与API相关的异常
- en: Converting objects to JSON-compatible types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象转换为JSON兼容类型
- en: Managing API responses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理API响应
- en: Creating background processes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建后台进程
- en: Using asynchronous path operations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步路径操作
- en: Applying middleware to filter path operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将中间件应用于过滤路径操作
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will implement a prototype of an intelligent tourist system designed
    to provide booking information and reservation about tourist spots. It can provide
    user details, tourist spot details, and location grids. It also allows users or
    tourists to comment on tours and rate them. The prototype has an administrator
    account for adding and removing all the tour details, managing users, and providing
    some listings. The application will not use any database management system yet,
    so all the data is temporarily stored in Python collections. The code is all uploaded
    at [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch02](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch02).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将实现一个智能旅游系统的原型，旨在提供旅游景点的预订信息和预约服务。它可以提供用户详情、旅游景点详情和位置网格。同时，它还允许用户或游客对旅游进行评论并评分。该原型有一个管理员账户，用于添加和删除所有旅游详情、管理用户和提供一些列表。该应用程序目前不使用任何数据库管理系统，因此所有数据临时存储在Python集合中。代码已全部上传至[https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch02](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch02)。
- en: Structuring and organizing huge projects
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化和组织大型项目
- en: In FastAPI, big projects are organized and structured by adding *packages* and
    *modules* without destroying the setup, configuration, and purpose. The project
    should always be flexible and scalable in case of additional features and requirements.
    One component must correspond to one package, with several modules equivalent
    to a *blueprint* in a Flask framework.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在FastAPI中，大型项目通过添加*包*和*模块*来组织和结构化，而不会破坏设置、配置和目的。项目在添加额外功能和需求的情况下，应始终保持灵活性和可扩展性。一个组件必须对应一个包，几个模块相当于Flask框架中的一个*蓝图*。
- en: 'In this prototypical intelligent tourist system, the application has several
    modules such as the login, administration, visit, destination, and feedback-related
    functionalities. The two most crucial are the *visit* module, which manages all
    the travel bookings of the users, and the *feedback* module, which enables clients
    to post their feedback regarding their experiences at every destination. These
    modules should be separated from the rest since they provide the core transactions.
    *Figure 2.1* shows how to group implementations and separate a module from the
    rest using **packages**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个原型智能旅游系统中，应用程序有几个模块，如登录、管理、访问、目的地和反馈相关的功能。其中两个最重要的是*访问*模块，它管理所有用户的旅行预订，以及*反馈*模块，它允许客户在每一个目的地发布他们的反馈。由于它们提供了核心交易，这些模块应该与其他模块分开。*图2.1*
    展示了如何使用**包**来分组实现并将一个模块与其他模块分开：
- en: '![Figure 2.1 – The FastAPI project structure](img/Figure_2.1_B17975.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – FastAPI项目结构](img/Figure_1.1_B17975.jpg)'
- en: Figure 2.1 – The FastAPI project structure
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – FastAPI项目结构
- en: Each package in *Figure 2.1* contains all the modules where the API services
    and some dependencies are implemented. All the aforementioned modules now have
    their own respective packages that make it easy to test, debug, and expand the
    application. Testing FastAPI components will be discussed in the upcoming chapters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.1* 中的每个包都包含了实现API服务和一些依赖项的所有模块。所有上述模块现在都有自己的相应包，这使得测试、调试和扩展应用程序变得容易。将在接下来的章节中讨论测试FastAPI组件。'
- en: Important note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: FastAPI does not require adding the `__init__.py` file into each Python package
    when using *VS Code Editor* and *Python 3.8* during development, unlike in Flask.
    The `__pycache__` folder generated inside a package during compilation contains
    binaries of the module scripts accessed and utilized by other modules. The main
    folder will also become a package since it will have its own `__pycache__` folder
    together with the others. But we must exclude `__pycache__` when deploying the
    application to the repository, since it may take up a lot of space.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*VS Code编辑器*和*Python 3.8*进行开发时，FastAPI不需要在Python包中添加`__init__.py`文件，这与Flask不同。在编译过程中，包内部生成的`__pycache__`文件夹包含被其他模块访问和使用的模块脚本的二进制文件。主文件夹也将成为一个包，因为它将拥有自己的`__pycache__`文件夹，与其他包一起。但是，在将应用程序部署到仓库时，我们必须排除`__pycache__`，因为它可能占用大量空间。
- en: On the other hand, what remains in the main folder are the core components such
    as the *background tasks*, *custom exception handlers*, *middleware,* and the
    `main.py` file. Now, let us learn about how FastAPI can bundle all these packages
    as one huge application when deployed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，主文件夹中剩下的核心组件包括*后台任务*、*自定义异常处理器*、*中间件*以及`main.py`文件。现在，让我们了解FastAPI如何在部署时将这些包捆绑成一个巨大的应用程序。
- en: Implementing the API services
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现API服务
- en: 'For these module packages to function, the `main.py` file must call and register
    all their API implementations through the FastAPI instance. The scripts inside
    each package are already REST API implementations of the microservices, except
    that they are built by `APIRouter` instead of the `FastAPI` object. `APIRouter`
    also has the same path operations, query and request parameter setup, handling
    of form data, generation of responses, and parameter injection of model objects.
    What is lacking in `APIRouter` is the support for an exception handler, middleware
    declaration, and customization:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些模块包能够运行，`main.py`文件必须通过FastAPI实例调用并注册它们所有的API实现。每个包内部的脚本已经是微服务的REST API实现，只是它们是由`APIRouter`而不是`FastAPI`对象构建的。`APIRouter`也有相同的路径操作、查询和请求参数设置、表单数据处理、响应生成以及模型对象的参数注入。`APIRouter`缺少的是异常处理器、中间件声明和自定义的支持：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `list_all_tourists()` API method operation here is part of the `manager.py`
    module in the `admin` package, implemented using `APIRouter` due to project structuring.
    The method returns a list of tourist records that are allowed to access the application,
    which can only be provided by the `user.py` module in the `login` package.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`list_all_tourists()` API方法操作是`admin`包中`manager.py`模块的一部分，由于项目结构使用`APIRouter`实现。该方法返回允许访问应用程序的游客记录列表，这只能由`login`包中的`user.py`模块提供。
- en: Importing the module components
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入模块组件
- en: 'Module scripts can share their *containers*, `BaseModel` *classes*, and other
    *resource objects* to other modules using Python’s `from… import` statement. Python’s
    `from… import` statement is better since it allows us to import specific components
    from a module, instead of including unnecessary ones:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模块脚本可以使用Python的`from…import`语句与其他模块共享它们的*容器*、`BaseModel` *类*和其他*资源对象*。Python的`from…import`语句更好，因为它允许我们从模块中导入特定的组件，而不是包含不必要的组件：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `update_tour_destination()` operation here will not work without importing
    the `Tour`, `TourBasicInfo`, and `TourLocation` model classes from `destination.py`
    in the `places` package. It shows the dependency between modules that happens
    when structuring is imposed on big enterprise web projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果不从`places`包中的`destination.py`导入`Tour`、`TourBasicInfo`和`TourLocation`模型类，`update_tour_destination()`操作将无法工作。这展示了在大型企业级Web项目中结构化时模块之间的依赖关系。
- en: Module scripts can also import components from the main project folder when
    needed by the implementation. One such example is accessing the *middleware*,
    *exception* *handlers*, and *tasks* from the `main.py` file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现需要时，模块脚本也可以从主项目文件夹导入组件。一个这样的例子是从`main.py`文件中访问*中间件*、*异常处理器*和*任务*。
- en: Important note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Avoid cycles when dealing with the `from… import` statement. A `a.py`, accesses
    components from `b.py` that import resource objects from `a.py`. FastAPI does
    not accept this scenario and will issue an error message.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`from…import`语句时避免循环。`a.py`从`b.py`访问组件，而`b.py`则从`a.py`导入资源对象。FastAPI不接受这种场景，并将发出错误消息。
- en: Implementing the new main.py file
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现新的main.py文件
- en: 'Technically, the project’s packages and its module scripts will not be recognized
    by the framework unless their respective `router` object is added or injected
    into the application’s core through the `main.py` file. `main.py`, just as the
    other project-level scripts do, uses `FastAPI` and not `APIRouter` to create and
    register components, as well as the package’s modules. The FastAPI class has an
    `include_router()` method that adds all these routers and injects them into the
    framework to make them part of the project structure. Beyond registering the routers,
    this method can also add other attributes and components to the router such as
    *URL prefixes*, *tags*, *dependencies such as exception handlers*, and *status
    codes*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，除非通过`main.py`文件将各自的`router`对象添加或注入到应用程序的核心中，否则框架不会识别项目包及其模块脚本。`main.py`，就像其他项目级脚本一样，使用`FastAPI`而不是`APIRouter`来创建和注册组件，以及包的模块。FastAPI类有一个`include_router()`方法，它添加所有这些路由并将它们注入到框架中，使它们成为项目结构的一部分。除了注册路由外，此方法还可以向路由添加其他属性和组件，例如*URL前缀*、*标签*、*异常处理器依赖项*和*状态码*：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code is the `main.py` implementation of the intelligent tourist system
    prototype tasked to import all the registers of the module’s scripts from the
    different packages, before adding them as components to the framework. Run the
    application using the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码是智能旅游系统原型`main.py`的实现，负责在将模块脚本的不同包中的所有注册项添加到框架之前导入它们。使用以下命令运行应用程序：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will allow you to access all the APIs of these modules at `http://localhost:8000/docs`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您通过`http://localhost:8000/docs`访问这些模块的所有API。
- en: What happens to the application when API services encounter runtime problems
    during execution? Is there a way to manage these problems besides applying Python’s
    `try-except` block? Let us explore implementing API services with exception-handling
    mechanisms further.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当API服务在执行过程中遇到运行时问题时，应用程序会发生什么？除了应用Python的`try-except`块外，还有没有管理这些问题的方法？让我们进一步探讨实现具有异常处理机制的API服务。
- en: Managing API-related exceptions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理API相关异常
- en: 'The FastAPI framework has a built-in exception handler derived from its Starlette
    toolkit that always returns default JSON responses whenever `HTTPException` is
    encountered during the execution of the REST API operation. For instance, accessing
    the API at `http://localhost:8000/ch02/user/login` without providing the `username`
    and `password` will give us the default JSON output depicted in *Figure 2.2*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI框架有一个从其Starlette工具包派生的内置异常处理器，当在执行REST API操作期间遇到`HTTPException`时，它总是返回默认的JSON响应。例如，在`http://localhost:8000/ch02/user/login`访问API而没有提供`username`和`password`时，我们将得到*图2.2*中描述的默认JSON输出：
- en: '![Figure 2.2 – The default exception result](img/Figure_2.2_B17975.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 默认异常结果](img/Figure_2.2_B17975.jpg)'
- en: Figure 2.2 – The default exception result
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 默认异常结果
- en: In some rare cases, the framework sometimes chooses to return the HTTP response
    status instead of the default JSON content. But developers can still opt to override
    these default handlers to choose which responses to return whenever a specific
    exception cause happens.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些罕见的情况下，框架有时会选择返回 HTTP 响应状态而不是默认的 JSON 内容。但开发者仍然可以选择覆盖这些默认处理程序，以便在特定异常原因发生时选择返回哪些响应。
- en: Let us now explore how to formulate a standardized and appropriate way of managing
    runtime errors in our API implementation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何在我们的 API 实现中制定一种标准化且适当的方式来管理运行时错误。
- en: A single status code response
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个状态码响应
- en: One way of managing the exception-handling mechanism of your application is
    to apply a `try-except` block to manage the return responses of your API when
    it encounters an exception or none. After applying `try-block`, the operation
    should trigger a single `FastAPI` and `APIRouter` has a `status_code` parameter
    that we can use to indicate the type of status code we want to raise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 管理应用程序异常处理机制的一种方法是在遇到异常或无异常时，通过应用 `try-except` 块来管理 API 的返回响应。在应用 `try-block`
    之后，操作应触发单个 `FastAPI` 和 `APIRouter` 具有用于指示我们想要引发的状态码类型的 `status_code` 参数。
- en: In FastAPI, status codes are integer constants that are found in the `status`
    module. It also allows integer literals to indicate the needed status code if
    they are a valid status code number.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中，状态码是位于 `status` 模块中的整数常量。它还允许使用整数文字来表示所需的状态码，如果它们是有效的状态码数字。
- en: Important Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A status code is a 3-digit number that indicates a reason for, information on,
    or status of the HTTP response of a REST API operation. The status code range
    200 to 299 denotes a successful response, 300 to 399 pertains to redirection,
    400-499 pertains to client-related problems, and 500 to 599 is related to server
    errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码是一个三位数，它表示 REST API 操作 HTTP 响应的原因、信息或状态。状态码范围 200 到 299 表示成功响应，300 到 399
    与重定向相关，400-499 与客户端相关的问题相关，而 500 到 599 与服务器错误相关。
- en: 'This technique is rarely used because there are times that an operation needs
    to be clear in recognizing every exception that it encounters, which can only
    be done by returning `HTTPException` instead of a custom error message wrapped
    in a JSON object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术很少使用，因为在某些情况下，操作需要清楚地识别它遇到的每个异常，这只能通过返回 `HTTPException` 而不是包含在 JSON 对象中的自定义错误消息来完成：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `list_all_tours()` method shown here is the kind of REST API service that
    should emit Status Code 200 – it gives an error-free result just by rendering
    the Python collection with data. Observe that the literal integer value, `200`,
    or *SC 200*, assigned to the `status_code` parameter of the `GET` path operation
    always raises an *OK* status. On the other hand, the `update_tour_destination()`
    method shows another approach in emitting status codes by using a `try-except`
    block, wherein both blocks return a custom JSON response. Whichever scenario happens,
    it will always trigger *SC 202*, which may not apply to some REST implementations.
    After the `status` module is imported, its `HTTP_202_ACCEPTED` constant is used
    to set the value of the `status_code` parameter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的 `list_all_tours()` 方法是那种应该返回状态码 200 的 REST API 服务类型——它仅通过渲染包含数据的 Python
    集合就能给出无错误的结果。注意，分配给 `GET` 路径操作 `status_code` 参数的文本整数值 `200` 或 *SC 200* 总是引发一个
    *OK* 状态。另一方面，`update_tour_destination()` 方法展示了另一种通过使用 `try-except` 块来发出状态码的方法，其中两个块都返回自定义的
    JSON 响应。无论哪种情况发生，它都会始终触发 *SC 202*，这可能不适用于某些 REST 实现。在导入 `status` 模块后，使用其 `HTTP_202_ACCEPTED`
    常量来设置 `status_code` 参数的值。
- en: Multiple status codes
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个状态码
- en: 'If we need each block in `try-except` to return their respective status code,
    we need to avoid using the `status_code` parameter of the path operations and
    use `JSONResponse` instead. `JSONResponse` is one of the FastAPI classes used
    to render a JSON response to the client. It is instantiated, constructor-injected
    with values for its `content` and `status_code` parameters, and returned by the
    path operations. By default, the framework uses this API to help path operations
    render responses as JSON types. Its `content` parameter should be a JSON-type
    object, while the `status_code` parameter can be an integer constant and a valid
    status code number, or it can be a constant from the module status:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要 `try-except` 中的每个块返回它们各自的状态码，我们需要避免使用路径操作的 `status_code` 参数，而应使用 `JSONResponse`。`JSONResponse`
    是 FastAPI 类之一，用于向客户端渲染 JSON 响应。它被实例化，通过构造函数注入其 `content` 和 `status_code` 参数的值，并由路径操作返回。默认情况下，框架使用此
    API 帮助路径操作以 JSON 类型渲染响应。其 `content` 参数应该是一个 JSON 类型的对象，而 `status_code` 参数可以是一个整数常量和一个有效的状态码数字，或者它可以是模块状态中的一个常量：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `add_tour_destination()` operation here has a `try-except` block where its
    `try` block returns the tour details and *SC 201*, while its `catch` block returns
    an error message inside a JSON-type object with a server error of *SC 500*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `add_tour_destination()` 操作包含一个 `try-except` 块，其 `try` 块返回旅游详情和 *SC 201*，而其
    `catch` 块返回一个包含服务器错误 *SC 500* 的 JSON 类型错误信息。
- en: Raising HTTPException
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出 HTTPException
- en: 'Another way of managing possible errors is by letting the REST API throw the
    `HTTPException` object. `HTTPException` is a FastAPI class that has required constructor
    parameters: `detail`, which needs an error message in the `str` type, and `status_code`,
    which asks for a valid integer value. The `detail` part is converted to JSON-type
    and returned to the user as a response after the `HTTPException` instance is thrown
    by the operation.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种管理可能错误的方法是让 REST API 抛出 `HTTPException` 对象。`HTTPException` 是一个 FastAPI 类，它有必需的构造参数：`detail`，它需要一个
    `str` 类型的错误信息，以及 `status_code`，它需要一个有效的整数值。`detail` 部分被转换为 JSON 类型，并在操作抛出 `HTTPException`
    实例后作为响应返回给用户。
- en: 'To throw `HTTPException`, a validation process using any variations of `if`
    statements is more appropriate than using the `try-except` block because the cause
    of the error needs to be identified before throwing the `HTTPException` object
    using the `raise` statement. Once `raise` is executed, the whole operation will
    halt and send the HTTP error message in JSON-type to the client with the specified
    status code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要抛出 `HTTPException`，使用任何形式的 `if` 语句进行验证过程比使用 `try-except` 块更合适，因为需要在抛出使用 `raise`
    语句的 `HTTPException` 对象之前识别错误的起因。一旦执行 `raise`，整个操作将停止，并将指定的状态码的 HTTP 错误信息以 JSON
    类型发送给客户端：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `create_booking()` operation here simulates a booking process for a *tourist*
    account, but before the procedure starts, it first checks whether the *tourist*
    is still a valid user; otherwise, it will raise `HTTPException`, halting all the
    operations in order to return an error message.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `create_booking()` 操作模拟了一个为 *旅游者* 账户的预订过程，但在程序开始之前，它首先检查 *旅游者* 是否仍然是一个有效的用户；如果不是，它将引发
    `HTTPException` 异常，以停止所有操作并返回一个错误信息。
- en: Custom exceptions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义异常
- en: It is also possible to create a user-defined `HTTPException` object to handle
    business-specific problems. This custom exception requires a custom handler needed
    to manage its response to the client whenever an operation raises it. These custom
    components should be available to all API methods across the project structure;
    thus, they must be implemented at the project-folder level.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以创建一个用户定义的 `HTTPException` 对象来处理特定业务问题。这个自定义异常需要一个自定义处理程序来管理它在操作引发时对客户端的响应。这些自定义组件应该在整个项目结构中的所有
    API 方法中可用；因此，它们必须在项目文件夹级别实现。
- en: 'In our application, there are two custom exceptions created in `handler_exceptions.py`,
    the `PostFeedbackException` and `PostRatingFeedback` exceptions, which handle
    problems related to posting feedback and ratings on a particular tour:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，`handler_exceptions.py` 文件中创建了两个自定义异常，分别是 `PostFeedbackException`
    和 `PostRatingFeedback` 异常，它们用于处理与特定旅游中发布反馈和评分相关的问题：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A valid FastAPI exception is a subclass of an `HTTPException` object inheriting
    the essential attributes, namely the `status_code` and `detail` attributes. We
    need to supply values to these attributes before the path operation raises the
    exception. After creating these custom exceptions, a specific handler is implemented
    and mapped to an exception.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的 FastAPI 异常是继承自 `HTTPException` 对象的子类，继承了基本属性，即 `status_code` 和 `detail`
    属性。在路径操作引发异常之前，我们需要为这些属性提供值。在创建这些自定义异常之后，实现一个特定的处理器并将其映射到异常。
- en: 'The FastAPI `@app` decorator in `main.py` has an `exception_handler()` method,
    used to define a custom handler and map it to the appropriate custom exception.
    A handler is simply a Python function with two local parameters, `Request` and
    the *custom exception* that it manages. The purpose of the `Request` object is
    to retrieve cookies, payloads, headers, query parameters, and path parameters
    from the path operation if the handler expects any of this request data. Now,
    once the custom exception is raised, the handler is set to generate a JSON-type
    response to the client containing the `detail` and the `status_code` attributes
    provided by the path operation that raised the exception:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.py` 中的 FastAPI `@app` 装饰器有一个 `exception_handler()` 方法，用于定义自定义处理器并将其映射到适当的自定义异常。处理器只是一个具有两个局部参数的
    Python 函数，即 `Request` 和它管理的 *自定义异常*。`Request` 对象的目的是在处理器期望任何此类请求数据的情况下，从路径操作中检索
    cookies、有效载荷、headers、查询参数和路径参数。现在，一旦引发自定义异常，处理器将被设置为生成一个包含由引发异常的路径操作提供的 `detail`
    和 `status_code` 属性的 JSON 类型的响应给客户端：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When an operation in `post.py` raises `PostFeedbackException`, the `feedback_exception_handler()`
    given here will trigger its execution to generate a response that can provide
    details about what has caused the feedback problem. The same thing will happen
    to `PostRatingException` and its `rating_exception_handler()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `post.py` 中的操作引发 `PostFeedbackException` 时，这里提供的 `feedback_exception_handler()`
    将触发其执行以生成一个响应，可以提供有关导致反馈问题的详细信息。对于 `PostRatingException` 和其 `rating_exception_handler()`
    也会发生同样的事情：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`post_tourist_feedback()` and `update_tour_rating()` here are the API operations
    that will raise the `PostFeedbackException` and `PostRatingException` custom exceptions,
    respectively, triggering the execution of their handlers. The `detail` and `status_code`
    values injected into the constructor are passed to the handlers to create the
    response.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_tourist_feedback()` 和 `update_tour_rating()` 这里的 API 操作将分别引发 `PostFeedbackException`
    和 `PostRatingException` 自定义异常，从而触发其处理器的执行。构造函数中注入的 `detail` 和 `status_code` 值传递给处理器以创建响应。'
- en: A default handler override
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认处理器的覆盖
- en: 'The optimum way to override the exception-handling mechanism of your application
    is to replace the global exception handler of the FastAPI framework that manages
    its core Starlette’s `HTTPException` and the `RequestValidationError` triggered
    by `raise` from JSON-type to plain text, we can create custom handlers for each
    of the aforementioned core exceptions that will pursue the format conversion.
    The following snippets of `main.py` show these types of custom handlers:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖您应用程序的异常处理机制的最佳方式是替换 FastAPI 框架的全局异常处理器，该处理器管理其核心 Starlette 的 `HTTPException`
    和由 `raise` 从 JSON 类型到纯文本触发的 `RequestValidationError`。我们可以为上述所有核心异常创建自定义处理器，以执行格式转换。以下
    `main.py` 的代码片段显示了这些类型的自定义处理器：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both the `global_exception_handler()` and `validationerror_exception_handler()`
    handlers are implemented to change the framework’s JSON-type exception response
    to `PlainTextResponse`. An alias, `GlobalStarletteHTTPException`, is assigned
    to Starlette’s `HTTPException` class to distinguish it from FastAPI’s `HTTPException`,
    which we previously used to build custom exceptions. On the other hand, `PostFeedbackException`
    and `PostRatingException` are both implemented in the `handler_exceptions.py`
    module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`global_exception_handler()` 和 `validationerror_exception_handler()` 处理器都实现了将框架的
    JSON 类型异常响应更改为 `PlainTextResponse`。一个别名 `GlobalStarletteHTTPException` 被分配给 Starlette
    的 `HTTPException` 类，以区分我们之前用于构建自定义异常的 FastAPI 的 `HTTPException`。另一方面，`PostFeedbackException`
    和 `PostRatingException` 都在 `handler_exceptions.py` 模块中实现。'
- en: JSON objects are all over the FastAPI framework’s REST API implementation, from
    the incoming request to the outgoing responses. However, what if the JSON data
    involved in the process is not a FastAPI JSON-compatible type? The following discussion
    will expound more upon this kind of object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JSON对象遍布FastAPI框架的REST API实现中，从传入的请求到发出的响应。然而，如果涉及过程中的JSON数据不是FastAPI兼容的JSON类型怎么办？以下讨论将更详细地阐述这类对象。
- en: Converting objects to JSON-compatible types
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象转换为与JSON兼容的类型
- en: It is easier for FastAPI to process JSON-compatible types such as `dict`, `list`,
    and `BaseModel` objects because they can be easily converted to JSON by the framework
    using its default JSON editor. However, there are circumstances in which runtime
    exceptions are raised when processing BaseModel, data model, or JSON objects containing
    data. One of the many reasons for this is that these data objects have attributes
    that are not supported by JSON rules, such as UUID and non-built-in date types.
    Regardless, using a framework’s module classes, these objects can still be utilized
    by converting them into JSON-compatible ones.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FastAPI来说，处理像`dict`、`list`和`BaseModel`对象这样的与JSON兼容的类型更容易，因为框架可以使用其默认的JSON编辑器轻松地将它们转换为JSON。然而，在处理BaseModel、数据模型或包含数据的JSON对象时，可能会引发运行时异常。许多原因之一是这些数据对象具有JSON规则不支持的特征，例如UUID和非内置日期类型。无论如何，使用框架的模块类，这些对象仍然可以通过将它们转换为与JSON兼容的类型来被利用。
- en: 'When it comes to the direct handling of the API operation’s responses, FastAPI
    has a built-in method that can encode typical model objects to convert them to
    JSON-compatible types before persisting them to any datastore or passing them
    to the `detail` parameter of `JSONResponse`. This method, `jsonable_encoder()`,
    returns a `dict` type with all the keys and values compatible with JSON:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到直接处理API操作响应时，FastAPI有一个内置方法可以将典型模型对象编码为与JSON兼容的类型，在将它们持久化到任何数据存储或传递给`JSONResponse`的`detail`参数之前。这个方法，`jsonable_encoder()`，返回一个包含所有键和值的`dict`类型，这些键和值与JSON兼容：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our application has a `POST` operation, `signup()`, shown here that captures
    the profile of a newly created user to be approved by the administrator. If you
    observe the `Tourist` model class, it has a `date_signed` attribute that is declared
    as `datettime`, and temporal types are not always JSON-friendly. Having model
    objects with non-JSON-friendly components in FastAPI-related operations can cause
    serious exceptions. To avoid these Pydantic validation issues, it is always advisable
    to use `jsonable_encoder()` to manage the conversion of all the attributes of
    our model object into JSON-types.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有一个`POST`操作，`signup()`，如这里所示，它捕获由管理员批准的新创建用户的个人资料。如果你观察`Tourist`模型类，它有一个`date_signed`属性，声明为`datettime`，而时间类型并不总是与JSON兼容。在FastAPI相关操作中具有非JSON兼容组件的模型对象可能会导致严重的异常。为了避免这些Pydantic验证问题，始终建议使用`jsonable_encoder()`来管理将我们模型对象的所有属性转换为JSON类型的转换。
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `json` module with its `dumps()` and `loads()` utility methods can be used
    instead of `jsonable_encoder()` but a custom JSON encoder should be created to
    successfully map the `UUID` type, the formatted `date` type, and other complex
    attribute types to `str`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用带有`dumps()`和`loads()`实用方法的`json`模块来代替`jsonable_encoder()`，但应该创建一个自定义的JSON编码器来成功地将`UUID`类型、格式化的`date`类型和其他复杂属性类型映射到`str`。
- en: '[*Chapter 9*](B17975_09.xhtml#_idTextAnchor266), *Utilizing Other Advanced
    Features*, will discuss other JSON encoders that can encode and decode JSON responses
    faster than the `json` module.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第9章*](B17975_09.xhtml#_idTextAnchor266)，*利用其他高级功能*，将讨论其他可以比`json`模块更快地编码和解码JSON响应的JSON编码器。'
- en: Managing API responses
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理API响应
- en: 'The use of `jsonable_encoder()` can help an API method not only with data persistency
    problems but also with the integrity and correctness of its response. In the `signup()`
    service method, `JSONResponse` returns the encoded `Tourist` model instead of
    the original object to ensure that the client always received a JSON response.
    Aside from raising status codes and providing error messages, `JSONResponse` can
    also do some tricks in handling the API responses to the client. Although optional
    in many circumstances, applying the encoder method when generating responses is
    recommended to avoid runtime errors:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `jsonable_encoder()` 可以帮助 API 方法不仅解决数据持久性问题，还可以确保其响应的完整性和正确性。在 `signup()`
    服务方法中，`JSONResponse` 返回编码后的 `Tourist` 模型而不是原始对象，以确保客户端始终收到 JSON 响应。除了抛出状态码和提供错误信息外，`JSONResponse`
    还可以在处理 API 对客户端的响应时做一些技巧。尽管在许多情况下是可选的，但在生成响应时应用编码方法以避免运行时错误是推荐的：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`check_tour_profile()` here uses `JSONResponse` to ensure that its response
    is JSON-compatible and is fetched from the purpose of managing its exceptions.
    Moreover, it can also be used to return headers together with the JSON-type response:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_tour_profile()` 这里使用 `JSONResponse` 确保其响应是 JSON 兼容的，并从管理其异常的目的进行获取。此外，它还可以用来返回与
    JSON 类型的响应一起的头信息：'
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The application’s `list_tour_destinations()` here returns three cookies: `AppName`,
    `Max-Age`, and `Version`, and two user-defined response headers. Headers that
    have names beginning with `X-` are custom headers. Besides `JSONResponse`, the
    `fastapi` module also has a `Response` class that can create response headers:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`list_tour_destinations()` 应用程序返回三个 Cookie：`AppName`、`Max-Age` 和 `Version`，以及两个用户定义的响应头。以
    `X-` 开头的头是自定义头。除了 `JSONResponse` 之外，`fastapi` 模块还有一个 `Response` 类可以创建响应头：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our prototype’s `check_recommend_tour()` uses `Response` to create two custom
    response headers and a known `str` types and are stored in the browser for many
    reasons, such as creating an identity for the application, leaving user trails,
    dropping advertisement-related data, or leaving an error message to the browser
    when an API encounters one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的原型的 `check_recommend_tour()` 使用 `Response` 创建两个自定义响应头和一个已知的 `str` 类型，并存储在浏览器中，出于许多原因，例如为应用程序创建身份，留下用户轨迹，丢弃与广告相关的数据，或者当
    API 遇到错误时向浏览器留下错误信息：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`HTTPException`, as shown in the `show_booked_tours()` service method here,
    not only contains the status code and error message but also some headers in case
    the operation needs to leave some error information to the browser once it is
    raised.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如此处的 `show_booked_tours()` 服务方法中所示，`HTTPException` 不仅包含状态码和错误信息，还包含一些头信息，以防操作需要在抛出时向浏览器留下一些错误信息。
- en: Let us now explore the capability of FastAPI to create and manage transactions
    that are designed to run in the background using some server threads.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 FastAPI 创建和管理在后台使用一些服务器线程运行的交易的能力。
- en: Creating background processes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建后台进程
- en: The FastAPI framework is also capable of running background jobs as part of
    an API service execution. It can even run more than one job almost simultaneously
    without intervening in the main service execution. The class responsible for this
    is `BackgroundTasks`, which is part of the `fastapi` module. Conventionally, we
    declare this at the end of the parameter list of the API service method for the
    framework to inject the `BackgroundTask` instance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 框架还能够作为 API 服务执行的一部分运行后台作业。它甚至可以在不干扰主服务执行的情况下几乎同时运行多个作业。负责此功能的类是 `BackgroundTasks`，它是
    `fastapi` 模块的一部分。通常，我们在 API 服务方法的参数列表末尾声明此内容，以便框架注入 `BackgroundTask` 实例。
- en: 'In our application, the task is to create audit logs of all API service executions
    and store them in an `audit_log.txt` file. This operation is part of the `background.py`
    script that is part of the main project folder, and the code is shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，任务是创建所有 API 服务执行的审计日志并将它们存储在 `audit_log.txt` 文件中。这个操作是主项目文件夹中的 `background.py`
    脚本的一部分，代码如下所示：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, `audit_log_transaction()` must be injected into the application using
    `BackgroundTasks`’s `add_task()` method to become a background process that will
    be executed by the framework later:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，必须使用 `BackgroundTasks` 的 `add_task()` 方法将 `audit_log_transaction()` 注入到应用程序中，使其成为一个稍后由框架执行的背景进程：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `login()` service method is just one of the services of our application
    that logs its details. It uses the `bg_task` object to add `audit_log_transaction()`
    into the framework to be processed later. Transactions such as logging, *SMTP*-/*FTP*-related
    requirements, events, and some database-related triggers are the best candidates
    for background jobs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`login()` 服务方法只是我们应用程序中记录其详细信息的众多服务之一。它使用 `bg_task` 对象将 `audit_log_transaction()`
    添加到框架中以便稍后处理。日志记录、*SMTP*-/*FTP*-相关需求、事件以及一些数据库相关的触发器是后台作业的最佳候选。'
- en: Important Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Clients will always get their response from the REST API method despite the
    execution time of the background task. Background tasks are for processes that
    will take enough time that including them in the API operation could cause performance
    degradation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管后台任务执行时间可能很长，但客户端总是会从 REST API 方法中获取其响应。后台任务是为了处理时间足够长的过程，如果将其包含在 API 操作中可能会导致性能下降。
- en: Using asynchronous path operations
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步路径操作
- en: 'When it comes to improving performance, FastAPI is an asynchronous framework,
    and it uses Python’s `async` to the `func` signature of the service:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到提高性能时，FastAPI 是一个异步框架，它使用 Python 的 `async` 来定义服务的 `func` 签名：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our application has a `show_tourist_post()` service that can retrieve all the
    feedback posted by a certain `touristId` about a vacation tour that they have
    experienced. The application will not be affected no matter how long the service
    will take because its execution will be simultaneous to the `main` thread.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有一个 `show_tourist_post()` 服务，可以检索某个 `touristId` 关于他们所经历的度假旅游发布的所有反馈。无论该服务需要多长时间，应用程序都不会受到影响，因为它的执行将与
    `main` 线程同时进行。
- en: Important Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `feedback` APIRouter uses a `/ch02/post` prefix indicated in its `main.py`’s
    `include_router()` registration. So, to run `show_tourist_post()`, the URL should
    be `http://localhost:8000/ch02/post`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`feedback` APIRouter 使用在 `main.py` 的 `include_router()` 注册中指定的 `/ch02/post`
    前缀。因此，要运行 `show_tourist_post()`，URL 应该是 `http://localhost:8000/ch02/post`。'
- en: 'An asynchronous API endpoint can invoke both synchronous and asynchronous Python
    functions that can be DAO (Data Access Object), native services, or utility. Since
    FastAPI also follows the `Async/Await` design pattern, the asynchronous endpoint
    can call an asynchronous non-API operation using the `await` keyword, which halts
    the API operation until the non-API transaction is done processing a promise:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 异步 API 端点可以调用同步和异步的 Python 函数，这些函数可以是 DAO（数据访问对象）、原生服务或实用工具。由于 FastAPI 也遵循 `Async/Await`
    设计模式，异步端点可以使用 `await` 关键字调用异步非 API 操作，这将暂停 API 操作，直到非 API 事务完成处理承诺：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`delete_tourist_feedback()` here is an asynchronous REST API endpoint that
    calls an asynchronous Python function, `check_post_owner()`, from the `utility.py`
    script. For the two components to have a handshake, the API service invokes `check_post_owner()`,
    using an `await` keyword for the former to wait for the latter to finish its validation,
    and retrieves the promise that it can get from `await`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `delete_tourist_feedback()` 是一个异步 REST API 端点，它从 `utility.py` 脚本中调用异步 Python
    函数 `check_post_owner()`。为了两个组件进行握手，API 服务调用 `check_post_owner()`，使用 `await` 关键字让前者等待后者完成验证，并检索它可以从
    `await` 获取的承诺。
- en: Important Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `await` keyword can only be used with the `async` REST API and native transactions,
    not with synchronous ones.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 关键字只能与异步 REST API 和原生事务一起使用，不能与同步事务一起使用。'
- en: 'To improve performance, you can add more threads within the `uvicorn` thread
    pool by including the `--workers` option when running the server. Indicate your
    preferred number of threads after calling the option:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，你可以在运行服务器时通过包含 `--workers` 选项在 `uvicorn` 线程池中添加更多线程。在调用选项后指定你喜欢的线程数：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[*Chapter 8*](B17975_08.xhtml#_idTextAnchor229), *Creating Coroutines, Events,
    and Message-Driven Transactions*, will discuss the *AsyncIO* platform and the
    use of *coroutines* in more detail.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第8章*](B17975_08.xhtml#_idTextAnchor229)，*创建协程、事件和消息驱动事务*，将更详细地讨论 *AsyncIO*
    平台和协程的使用。'
- en: And now, the last, most important core feature that FastAPI can provide is the
    middleware or the "request-response filter."
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，FastAPI 可以提供的最后一个、最重要的核心功能是中间件或“请求-响应过滤器”。
- en: Applying middleware to filter path operations
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用中间件以过滤路径操作
- en: 'There are FastAPI components that are inherently asynchronous and one of them
    is the middleware. It is an asynchronous function that acts as a filter for the
    REST API services. It filters out the incoming request to pursue validation, authentication,
    logging, background processing, or content generation from the cookies, headers,
    request parameters, query parameters, form data, or authentication details of
    the request body before it reaches the API service method. Equally, it takes the
    outgoing response body to pursue rendition change, response header updates and
    additions, and other kinds of transformation that could possibly be applied to
    the response before it reaches the client. Middleware should be implemented at
    the project level and can even be part of `main.py`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI有一些固有的异步组件，其中之一就是中间件。它是一个异步函数，充当REST API服务的过滤器。它在到达API服务方法之前，从cookie、头部、请求参数、查询参数、表单数据或请求体的认证细节中过滤出传入的请求以进行验证、认证、日志记录、后台处理或内容生成。同样，它还处理出站的响应体，以进行渲染更改、响应头更新和添加以及其他可能应用于响应的转换，在它到达客户端之前。中间件应在项目级别实现，甚至可以是`main.py`的一部分：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To implement middleware, first, create an `async` function that has two local
    parameters: the first one is `Request` and the second one is a function called
    `call_next()`, which takes the `Request` parameter as its argument to return the
    response. Then, decorate the method with `@app.middleware("http")` to inject the
    component into the framework.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现中间件，首先，创建一个具有两个局部参数的`async`函数：第一个参数是`Request`，第二个参数是一个名为`call_next()`的函数，它将`Request`参数作为其参数以返回响应。然后，使用`@app.middleware("http")`装饰器将方法装饰，以将组件注入到框架中。
- en: The tourist application has one middleware implemented by the asynchronous `add_transaction_filter()`
    here that logs the necessary request data of a particular API method before its
    execution and modifies its response object by adding a response header, `X-Time-Elapsed`,
    which carries the running time of the execution.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 旅游应用程序在这里通过异步的`add_transaction_filter()`实现了一个中间件，它在执行特定API方法之前记录必要的请求数据，并通过添加一个响应头`X-Time-Elapsed`来修改其响应对象，该响应头携带了执行时间。
- en: The execution of `await call_next(request)` is the most crucial part of the
    middleware because it explicitly controls the execution of the REST API service.
    It is the area of the component where `Request` passes through to the API execution
    for processing. Equally, it is where `Response` tunnels out, going to the client.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`await call_next(request)`的执行是中间件中最关键的部分，因为它明确控制了REST API服务的执行。这是组件中`Request`通过API执行进行处理的区域。同样，这也是`Response`通过隧道传输到客户端的区域。'
- en: Besides logging, middleware can also be used for implementing one-way or two-way
    authentication, checking user roles and permissions, global exception handling,
    and other filtering-related operations right before the execution of `call_next()`.
    When it comes to controlling the outgoing `Response`, it can be used to modify
    the content type of the response, remove some existing browser cookies, modify
    the response detail and status code, redirections, and other response transformation-related
    transactions. [*Chapter 9*](B17975_09.xhtml#_idTextAnchor266), *Utilizing Other
    Advanced Features*, will discuss the types of middleware, middleware chaining,
    and other means to customize middleware to help build a better microservice.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日志记录外，中间件还可以用于实现单向或双向认证、检查用户角色和权限、全局异常处理以及其他在执行`call_next()`之前与过滤相关的操作。当涉及到控制出站的`Response`时，它可以用来修改响应的内容类型、删除一些现有的浏览器cookie、修改响应细节和状态码、重定向以及其他与响应转换相关的交易。[*第9章*](B17975_09.xhtml#_idTextAnchor266)，*利用其他高级功能*，将讨论中间件类型、中间件链以及其他自定义中间件的方法，以帮助构建更好的微服务。
- en: Important note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The FastAPI framework has some built-in middleware that is ready to be injected
    into the application such as `GzipMiddleware`, `ServerErrorMiddleware`, `TrustedHostMiddleware`,
    `ExceptionMiddleware`, `CORSMiddleware`, `SessionMiddleware`, and `HTTPSRedirectionMiddleware`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI框架有一些内置的中间件，可以注入到应用程序中，例如`GzipMiddleware`、`ServerErrorMiddleware`、`TrustedHostMiddleware`、`ExceptionMiddleware`、`CORSMiddleware`、`SessionMiddleware`和`HTTPSRedirectionMiddleware`。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Exploring the core details of a framework always helps us create a comprehensive
    plan and design to build quality applications to the required standards. We have
    learned that FastAPI injects all its incoming form data, request parameters, query
    parameters, cookies, request headers, and authentication details into the `Request`
    object, and the outgoing cookies, response headers, and response data are carried
    out to the client by the `Response` object. When managing the response data, the
    framework has a built-in `jsonable_encoder()` function that can convert the model
    into JSON types to be rendered by the `JSONResponse` object. Its middleware is
    one powerful feature of FastAPI because we can customize it to handle the `Request`
    object before it reaches the API execution and the `Response` object before the
    client receives it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 探索框架的核心细节总是有助于我们制定全面的计划和设计，以按照所需标准构建高质量的应用程序。我们了解到 FastAPI 将所有传入的表单数据、请求参数、查询参数、cookie、请求头和认证详情注入到
    `Request` 对象中，而出去的 cookie、响应头和响应数据则由 `Response` 对象传递给客户端。在管理响应数据时，框架内置了一个 `jsonable_encoder()`
    函数，可以将模型转换为 `JSONResponse` 对象渲染的 JSON 类型。FastAPI 的中间件是其一个强大功能，因为我们可以在它到达 API 执行之前和客户端接收它之前对其进行自定义。
- en: Managing the exceptions is always the first step to consider before creating
    a practical and sustainable solution for the resiliency and health of a microservice
    architecture. Alongside its robust default **Starlette** global exception handler
    and **Pydantic** model validator, FastAPI allows exception-handling customization
    that provides the flexibility needed when business processes become intricate.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 管理异常始终是创建一个实用且可持续的微服务架构弹性和健康解决方案的第一步。FastAPI 拥有强大的默认 **Starlette** 全局异常处理程序和
    **Pydantic** 模型验证器，它允许对异常处理进行定制，这在业务流程变得复杂时提供了所需的灵活性。
- en: FastAPI follows Python’s **AsyncIO** principles and standards for creating async
    REST endpoints, which makes implementation easy, handy, and reliable. This kind
    of platform is helpful for building complex architectures that require more threads
    and asynchronous transactions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 遵循 Python 的 **AsyncIO** 原则和标准来创建异步 REST 端点，这使得实现变得简单、方便且可靠。这种平台对于构建需要更多线程和异步事务的复杂架构非常有帮助。
- en: This chapter is a great leap toward fully learning about the principles and
    standards of how FastAPI manages its web containers. The features highlighted
    in this chapter hitherto open up a new level of knowledge that we need to explore
    further if we want to utilize FastAPI to build great microservices. In the next
    chapter, we will be discussing FastAPI dependency injection and how this design
    pattern affects our FastAPI projects.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是全面了解 FastAPI 如何管理其网络容器的原则和标准的一个巨大飞跃。本章中突出显示的功能为我们开启了一个新的知识层面，如果我们想利用 FastAPI
    构建出色的微服务，就需要进一步探索。在下一章中，我们将讨论 FastAPI 依赖注入以及这种设计模式如何影响我们的 FastAPI 项目。
