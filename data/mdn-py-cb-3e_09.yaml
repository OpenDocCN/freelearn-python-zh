- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: Functional Programming Features
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程特性
- en: The idea of functional programming is to focus on writing small, expressive
    functions that perform the required data transformations. Combinations of functions
    can often create code that is more succinct and expressive than long strings of
    procedural statements or the methods of complex, stateful objects. This chapter
    focuses on functional programming features of Python more than procedural or object-oriented
    programming.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的思想是专注于编写小而表达性强的函数，以执行所需的数据转换。函数的组合通常可以创建比长串过程语句或复杂有状态对象的方法定义更简洁、更具有表现力的代码。本章重点介绍Python的函数式编程特性，而不是过程式或面向对象编程。
- en: This provides an avenue for software design distinct from the strictly object-oriented
    approach used elsewhere in this book. The combination of objects with functions
    permits flexibility in assembling an optimal collection of components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种与本书其他地方严格面向对象的方法不同的软件设计途径。将对象与函数的组合允许在组装最佳组件集合时具有灵活性。
- en: Conventional mathematics defines many things as functions. Multiple functions
    can be combined to build up a complex result from previous transformations. When
    we think of mathematical operators as functions, an expression like p = f(n,g(n))
    can also be written as two separate functions. We might think of this as p = f(n,b),
    where b = g(n).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 传统数学将许多事物定义为函数。多个函数可以组合起来，从之前的转换构建复杂的结果。当我们把数学运算符视为函数时，表达式p = f(n,g(n))也可以写成两个单独的函数。我们可能会将其视为p
    = f(n,b)，其中b = g(n)。
- en: 'Ideally, we can also create a composite function from these two functions:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们还可以从这两个函数创建一个复合函数：
- en: '![p = f(n,g(n)) = g ∘f (n ) ](img/file58.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![p = f(n,g(n)) = g ∘f (n ) ](img/file58.png)'
- en: Defining a new composite function, g ∘ f, instead of nested functions can help
    to clarify the intent behind a design. This re-framing of the components can allow
    us to take a number of small details and combine them into a larger chunk of knowledge
    that embodies the concept behind the design.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个新的复合函数g ∘ f，而不是嵌套函数，可以帮助阐明设计背后的意图。这种对组件的重构可以让我们将许多小的细节组合成更大的知识块，体现设计背后的概念。
- en: Since programming often works with collections of data, we’ll often be applying
    a function to all the items of a collection. This happens when doing database
    extraction and transformation to align data from diverse source applications.
    It also happens when summarizing data. Something as commonplace as transforming
    a CSV file into a statistical summary is a composition of transformation functions
    from rows of text to rows of data, and from rows of data to a mean and standard
    deviation. This fits nicely with the mathematical idea of a set builder or set
    comprehension.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编程通常与数据集合一起工作，我们经常会将函数应用到集合的所有项目上。这发生在进行数据库提取和转换以对齐来自不同源应用程序的数据时。这也发生在汇总数据时。将CSV文件转换为统计摘要这样常见的事情，就是从文本行到数据行的转换函数的组合，以及从数据行到平均值和标准差的转换。这与集合构造者或集合理解数学思想非常吻合。
- en: 'There are three common patterns for applying one function to a set of data:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用一个函数到一组数据的三种常见模式：
- en: 'Mapping: This applies a function to all the elements of a collection, {m(x)|x
    ∈ S}. We apply some function, m(x), to each item, x, of a larger collection, S.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射：这将对集合的所有元素应用一个函数，{m(x)|x ∈ S}。我们将某个函数m(x)应用到较大的集合S中的每个项目x上。
- en: 'Filtering: This uses a function to select elements from a collection, {x|x
    ∈ S if f(x)}. We use a function, f(x), to determine whether to pass or reject
    each item, x, from the larger collection, S.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤：这使用一个函数从集合中选择元素，{x|x ∈ S if f(x)}。我们使用一个函数，f(x)，来确定是否将较大的集合S中的每个项目x通过或拒绝。
- en: 'Reducing: This summarizes the items of a collection. One of the most common
    reductions is creating a sum of all items in a collection, S, written as ∑ [x∈S]x.
    Other common reductions include finding the smallest item, the largest one, and
    the product of all items.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少：这总结了集合中的项目。最常见的一种减少是将集合S中所有项目求和，表示为 ∑ [x∈S]x。其他常见的减少还包括找到最小项、最大项以及所有项的乘积。
- en: We’ll often combine these patterns to create more complex composite applications.
    What’s important here is that small functions, such as m(x) and f(x), can be combined
    via the built-in higher-order functions such as map(), filter(), and reduce().
    The itertools module contains many additional higher-order functions that we can
    use to build an application. And, of course, we can define our own higher-order
    functions to combine smaller functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常将这些模式结合起来创建更复杂的复合应用程序。这里重要的是，像m(x)和f(x)这样的小函数可以通过内置的高阶函数如map()、filter()和reduce()进行组合。itertools模块包含许多额外的更高阶函数，我们可以使用它们来构建应用程序。当然，我们也可以定义我们自己的高阶函数来组合较小的函数。
- en: Some of these recipes will show computations that could also be defined as properties
    of a class definition created using the @property decorator. This is yet another
    design alternative that can limit the complexity of stateful objects. In this
    chapter, however, we’ll try to stick to a functional approach, that is, transformation
    to create new objects rather than using properties.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些食谱中的一些将展示可以定义为使用@property装饰器创建的类定义属性的运算。这是另一种可以限制有状态对象复杂性的设计选择。然而，在本章中，我们将尝试坚持一种函数式方法，即通过转换来创建新对象，而不是使用属性。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下食谱：
- en: '[Writing generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用yield语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)'
- en: '[Applying transformations to a collection](ch013_split_000.xhtml#x1-5090002)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[对集合应用转换](ch013_split_000.xhtml#x1-5090002)'
- en: '[Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用堆叠的生成器表达式](ch013_split_000.xhtml#x1-5180003)'
- en: '[Picking a subset – three ways to filter](ch013_split_000.xhtml#x1-5270004)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[选择子集 – 三种过滤方式](ch013_split_000.xhtml#x1-5270004)'
- en: '[Summarizing a collection – how to reduce](ch013_split_000.xhtml#x1-5350005)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结集合 – 如何减少](ch013_split_000.xhtml#x1-5350005)'
- en: '[Combining the map and reduce transformations](ch013_split_001.xhtml#x1-5440006)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[组合map和reduce转换](ch013_split_001.xhtml#x1-5440006)'
- en: '[Implementing “there exists” processing](ch013_split_001.xhtml#x1-5500007)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现“存在”处理](ch013_split_001.xhtml#x1-5500007)'
- en: '[Creating a partial function](ch013_split_001.xhtml#x1-5560008)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建部分函数](ch013_split_001.xhtml#x1-5560008)'
- en: '[Writing recursive generator functions with the yield from statement](ch013_split_001.xhtml#x1-5640009)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用yield from语句编写递归生成器函数](ch013_split_001.xhtml#x1-5640009)'
- en: We’ll start with a recipe where we will create functions that yield an iterable
    sequence of values. Rather than creating an entire list (or set, or some other
    collection), a generator function yields the individual items of a collection
    as demanded by a client operation. This saves memory and may save time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建函数开始，这些函数将产生一个可迭代的值序列。而不是创建一个完整的列表（或集合，或其他集合），生成器函数根据客户端操作的需求产生集合的各个项目。这节省了内存，并且可能节省时间。
- en: 9.1 Writing generator functions with the yield statement
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 使用yield语句编写生成器函数
- en: A generator function is often designed to apply some kind of transformation
    to each item of a collection. Generators can create data, too. A generator is
    called lazy because the values it yields must be consumed by a client; values
    are not computed until a client attempts to consume them. Client operations like
    the list() function or a for statement are common examples of consumers. Each
    time a function like list() demands a value, the generator function must yield
    a value using the yield statement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数通常被设计为对集合中的每个项目应用某种类型的转换。生成器也可以创建数据。生成器被称为懒惰的，因为其产生的值必须由客户端消耗；值只有在客户端尝试消耗它们时才会被计算。客户端操作，如list()函数或for语句，是常见的消费者示例。每次像list()这样的函数需要值时，生成器函数必须使用yield语句产生一个值。
- en: In contrast, an ordinary function can be called eager. Without the yield statement,
    a function will compute the entire result and return it via the return statement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个普通函数可以被调用为急切模式。没有yield语句，函数将计算整个结果并通过return语句返回。
- en: A lazy approach is very helpful in cases where we can’t fit an entire collection
    in memory. For example, analyzing gigantic web log files can be done in small
    doses rather than by creating a vast in-memory collection.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们无法将整个集合放入内存的情况下，一种懒惰的方法非常有帮助。例如，分析巨大的网络日志文件可以通过小批量进行，而不是创建一个庞大的内存集合。
- en: In the language of Python’s type hints, we’ll often use the Iterator generic
    to describe generators. We’ll need to clarify this generic with a type, like Iterator[str],
    to show that the function yields string objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 的类型提示语言中，我们经常使用 Iterator 泛型来描述生成器。我们需要使用类型来澄清这个泛型，例如 Iterator[str]，以表明函数产生字符串对象。
- en: The items that are being consumed by a generator will often be from a collection
    described by the Iterable generic type. All of Python’s built-in collections are
    Iterable, as are files. A list of string values, for example, can be viewed as
    an Iterable[str].
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器正在消耗的项目通常来自由 Iterable 泛型类型描述的集合。所有 Python 的内置集合都是可迭代的，文件也是如此。例如，字符串值的列表可以被视为
    Iterable[str]。
- en: Both the Iterable and Iterator types are available from the collections.abc
    module. They can also be imported from the typing module.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从 collections.abc 模块中可以获得 Iterable 和 Iterator 类型。它们也可以从 typing 模块中导入。
- en: The yield statement is what changes an ordinary function into a generator. It
    will compute and yield results iteratively.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: yield 语句将普通函数转换为生成器。它将迭代计算并产生结果。
- en: 9.1.1 Getting ready
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1.1 准备工作
- en: We’ll apply a generator to some web log data. We’ll design a generator that
    will transform raw text into more useful structured objects. The generator function
    serves to isolate transformation processing. This permits flexibility in applying
    filter or summary operations after the initial transformation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对一些网络日志数据进行生成器应用。我们将设计一个生成器，将原始文本转换为更有用的结构化对象。生成器函数用于隔离转换处理。这允许在初始转换之后灵活地应用过滤或汇总操作。
- en: 'The entries start out as lines of text that look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 条目最初是看起来像这样的文本行：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ve seen other examples of working with this kind of log in the [Using more
    complex structures – maps of lists](ch012.xhtml#x1-4810005) recipe in Chapter [8](ch012.xhtml#x1-4520008).
    Using REs from the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe in Chapter [1](ch005_split_000.xhtml#x1-170001), we can decompose each
    line into a more useful structure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第八章的[使用更复杂结构 - 列表映射](ch012.xhtml#x1-4810005)食谱中看到了使用这种日志的其他示例。使用第一章的[使用正则表达式进行字符串解析](ch005_split_000.xhtml#x1-350003)食谱中的正则表达式，我们可以将每一行分解成更有用的结构。
- en: 'It’s often helpful to capture the details of each line of the log in an object
    of a distinct type. This helps make the code more focused, and it helps us use
    the mypy tool to confirm that types are used properly. Here’s a NamedTuple class
    definition:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志的每一行中捕获详细信息，并将其存储在具有不同类型的对象中通常很有帮助。这有助于使代码更加专注，并有助于我们使用 mypy 工具来确认类型被正确使用。以下是一个
    NamedTuple 类定义：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll start with the transformation of an iterable source of strings string
    into an iterator over tuple of fields. After that, we’ll apply the recipe again
    to transform the date attribute from a string into a useful datetime object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将字符串类型的可迭代源代码转换为字段元组的迭代器开始。之后，我们将再次应用该食谱，将日期属性从字符串转换为有用的日期时间对象。
- en: 9.1.2 How to do it...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1.2 如何做...
- en: 'A generator function is a function, so the recipe is similar to those shown
    in Chapter [3](ch007_split_000.xhtml#x1-1610003). We’ll start by defining the
    function, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数是一个函数，所以食谱与第三章中显示的类似。我们首先定义函数，如下所示：
- en: 'Import the needed type hints from the collections.abc module. Import the re
    module to parse the line of the log file:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 collections.abc 模块导入所需的类型提示。导入 re 模块以解析日志文件的行：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define a function that iterates over RawLog objects. It seems helpful to include
    _iter in the function name to emphasize that the result is an iterator, not a
    single value. The parameter is an iterable source of log lines:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个遍历 RawLog 对象的函数。在函数名称中包含 _iter 可以帮助强调结果是迭代器，而不是单个值。参数是日志行的可迭代源：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The parse_line_iter() transformation function relies on a regular expression
    to decompose each line. We can define this inside the function to keep it tightly
    bound with the rest of the processing:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: parse_line_iter() 转换函数依赖于正则表达式来分解每一行。我们可以在函数内部定义它，以保持它与处理的其他部分的紧密绑定：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A for statement will consume each line of the iterable source, allowing us
    to create and then yield each RawLog object in isolation:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: for 语句将消耗可迭代源代码的每一行，使我们能够单独创建并产生每个 RawLog 对象：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The body of the for statement can map each string instance that matches the
    pattern to a new RawLog object using the match groups:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: for 语句的主体可以使用匹配组将每个与模式匹配的字符串实例映射到一个新的 RawLog 对象：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Non-matching lines will be silently dropped. For the most part, this seems sensible
    because a log can be filled with messages from a variety of sources.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不匹配的行将被静默丢弃。在大多数情况下，这似乎是合理的，因为日志可以充满来自各种来源的消息。
- en: Without a yield statement, a function is “ordinary” and computes a single result.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有yield语句的函数是“普通”的，并计算一个单一的结果。
- en: 'Here’s how we use this function to emit a sequence of RawLog instances from
    the sample data shown above:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用这个函数从上面显示的样本数据中发出一系列RawLog实例的：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could also collect items into a list object using something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用类似的方法将项目收集到一个列表对象中：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, the list() function consumes all of the items produced by
    the parse_line_iter() function. A generator is a relatively passive construct:
    until data is demanded, it doesn’t do any work.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，list()函数消耗了parse_line_iter()函数产生的所有项目。生成器是一个相对被动的结构：直到需要数据，它不会做任何工作。
- en: 9.1.3 How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1.3 它是如何工作的...
- en: Each of Python’s built-in collection types implements a special method, __iter__(),
    to produce an iterator object. An iterator object implements the __next__() special
    method to both return an item and advance the state of the iterator to return
    the next item. This is the Iterator protocol. The built-in next() function evaluates
    this method of an iterator object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python的每个内置集合类型都实现了一个特殊方法，__iter__()，用于生成一个迭代器对象。迭代器对象实现了__next__()特殊方法，用于返回一个项目并推进迭代器的状态以返回下一个项目。这就是迭代器协议。内置的next()函数评估迭代器对象的这个方法。
- en: While the Python built-in collections can create Iterator objects, a generator
    function also implements this protocol. A generator will return itself in response
    to the iter() function. In response to the next() function, a generator suspends
    execution at a yield statement, and provides a value that becomes the result of
    the next() function. Since the function is suspended, it can be resumed when another
    next() function is evaluated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python内置的collections可以创建Iterator对象，但生成器函数也实现了这个协议。生成器在响应iter()函数时会返回自身。在响应next()函数时，生成器在yield语句处暂停执行，并提供一个值，该值成为next()函数的结果。由于函数被暂停，它可以在另一个next()函数被评估时恢复。
- en: 'To see how the yield statement works, look at this small function, which yields
    two objects:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解yield语句是如何工作的，请看这个小型函数，它产生两个对象：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s what happens when we evaluate the next() function on this generator:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在生成器上评估next()函数时，会发生以下情况：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first time we evaluated the next() function, the first print() function
    was evaluated, and then the yield statement produced a value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次评估next()函数时，第一个print()函数被评估，然后yield语句产生了一个值。
- en: The use of the next() function resumed processing, and the statements between
    the two yield statements were evaluated.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用next()函数恢复处理，并在两个yield语句之间的语句被评估。
- en: 'What happens next? Since there are no more yield statements in the function’s
    body, so we observe the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来会发生什么？由于函数体中没有更多的yield语句，所以我们观察到以下情况：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The StopIteration exception is raised at the end of a generator function. This
    is expected by the processing of a for statement. It is quietly absorbed to break
    from processing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器函数的末尾会抛出StopIteration异常。这是for语句处理过程中预期到的。它被静默地吸收以跳出处理。
- en: 'If we don’t use a function like list() or a for statement to consume the data,
    we’ll see something like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用像list()或for语句这样的函数来消耗数据，我们会看到类似以下的内容：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The value returned by evaluating the parse_line_iter() function is a generator.
    It’s not a collection of items, but an object that will produce items, one at
    a time, on demand from a consumer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 评估parse_line_iter()函数返回的值是一个生成器。它不是一个项目集合，而是一个将按需从消费者那里产生项目，一次一个的对象。
- en: 9.1.4 There’s more...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1.4 更多内容...
- en: 'We can apply this recipe to convert the date attributes in each RawLog object.
    The more refined kind of data from each line will follow this class definition:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个方法应用到转换每个RawLog对象中的日期属性。每行更精细的数据类型将遵循以下类定义：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This has a more useful datetime.datetime object for the timestamp. The other
    fields remain as strings.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个更有用的datetime.datetime对象作为时间戳。其他字段保持为字符串。
- en: 'Here’s a generator function – using a for statement and yield so that it’s
    an iterator – that’s used to refine each RawLog object into a DatedLog object:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成器函数——使用for语句和yield关键字，使其成为一个迭代器——用于将每个RawLog对象精炼成DatedLog对象：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Breaking overall processing into small generator functions confers several significant
    advantages. First, the decomposition makes each function more succinct because
    it is focused on a specific task. This makes these functions easier to design,
    test, and maintain. Second, it makes the overall composition somewhat more expressive
    of the work being done.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将整体处理分解成小的生成器函数提供了几个显著的优势。首先，分解使得每个函数更加简洁，因为它专注于特定的任务。这使得这些函数更容易设计、测试和维护。其次，它使得整体组合更能够表达所做的工作。
- en: 'We can combine these two generators in the following kind of composition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个生成器以以下方式组合：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The parse_line_iter() function will consume lines from the source data, creating
    RawLog objects when they are demanded by a consumer. The parse_date_iter() function
    is a consumer of RawLog objects; from these, it creates DatedLog objects when
    demanded by a consumer. The outer for statement is the ultimate consumer, demanding
    DatedLog objects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: parse_line_iter()函数将消耗源数据中的行，当消费者需要时创建RawLog对象。parse_date_iter()函数是RawLog对象的消费者；从这些对象中，当消费者需要时，它创建DatedLog对象。外部的for语句是最终消费者，需要DatedLog对象。
- en: At no time will there be a large collection of intermediate objects in memory.
    Each of these functions works with a single object, limiting the amount of memory
    used.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，内存中都不会存在大量中间对象。这些函数中的每一个都只处理一个对象，从而限制了内存的使用量。
- en: 9.1.5 See also
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1.5 参见
- en: In the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe, we’ll combine generator functions to build complex processing stacks from
    simple components.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[使用堆叠生成器表达式](ch013_split_000.xhtml#x1-5180003)的菜谱中，我们将结合生成器函数，从简单组件构建复杂处理堆栈。
- en: In the [Applying transformations to a collection](ch013_split_000.xhtml#x1-5090002)
    recipe, we’ll see how the built-in map() function can be used to create complex
    processing from a simple function and an iterable source of data.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[将转换应用于集合](ch013_split_000.xhtml#x1-5090002)的菜谱中，我们将看到如何使用内置的map()函数从简单的函数和可迭代的数据源创建复杂处理。
- en: In the [Picking a subset – three ways to filter](ch013_split_000.xhtml#x1-5270004)
    recipe, we’ll see how the built-in filter() function can also be used to build
    complex processing from a simple function and an iterable source of data.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[选择子集 - 三种过滤方式](ch013_split_000.xhtml#x1-5270004)的菜谱中，我们将看到如何使用内置的filter()函数也从简单的函数和可迭代的数据源构建复杂处理。
- en: 9.2 Applying transformations to a collection
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 将转换应用于集合
- en: We often define generator functions with the intention apply the function to
    a collection of data items. There are a number of ways that generators can be
    used with collections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常定义生成器函数，目的是将函数应用于数据项的集合。生成器与集合的交互有几种方式。
- en: In the [Writing generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)
    recipe in this chapter, we created a generator function to transform data from
    a string into a more complex object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的[使用yield语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)的菜谱中，我们创建了一个生成器函数，将数据从字符串转换成更复杂的对象。
- en: 'Generator functions have a common structure, and generally look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数具有共同的架构，通常看起来是这样的：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The yield statement means the results will be generated iteratively. The function’s
    type hints emphasize that it consumes items from the source collection. This template
    for writing a generator function exposes a common design pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: yield语句意味着结果将迭代生成。函数的类型提示强调它从源集合中消费项目。这个编写生成器函数的模板暴露了一个常见的设计模式。
- en: 'Mathematically, we can summarize this as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，我们可以这样总结：
- en: '![N = {m (x ) | x ∈ S} ](img/file59.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![N = {m (x ) | x ∈ S} ](img/file59.png)'
- en: The new collection, N, is a transformation, m(x), applied to each item, x, of
    the source, S. This emphasizes the transformation function, m(x), separating it
    from the details of consuming the source and producing the result. In the Python
    example previously shown, this function was called some_transformation().
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 新集合N是对源S中的每个项目x应用转换m(x)的结果。这强调了转换函数m(x)，将其与消费源和产生结果的细节分开。在之前显示的Python示例中，这个函数被调用为some_transformation()。
- en: This mathematical summary suggests that the for statement can be understood
    as a kind of scaffold around the transformation function. There are two additional
    forms this scaffolding can take. We can write a generator expression or we can
    use the built-in map() function. This recipe will examine all three techniques.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数学总结表明，for语句可以被理解为围绕转换函数的一种支架。这种支架可以有两种额外的形式。我们可以写一个生成器表达式，或者我们可以使用内置的map()函数。这个配方将检查所有三种技术。
- en: 9.2.1 Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2.1 准备工作
- en: We’ll look at the web log data from the [Writing generator functions with the
    yield statement](ch013_split_000.xhtml#x1-5030001) recipe. This had dates as strings
    that we would like to transform into a proper datetime object to be used for further
    computations. We’ll make use of the DatedLog class definition from that earlier
    recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看[使用yield语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)配方中的网络日志数据。这些数据中的日期是以字符串形式表示的，我们希望将其转换为合适的datetime对象，以便用于后续的计算。我们将利用之前配方中的DatedLog类定义。
- en: 'The [Writing generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)
    recipe used a generator function like the following example to transform a sequence
    of RawLog objects into an iterator of more useful DatedLog instances:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用yield语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)的配方使用了如下示例中的生成器函数，将一系列RawLog对象转换为一个更有用的DatedLog实例迭代器：'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This parse_date_iter() function has a significant amount of scaffolding code
    around an interesting function. The for and yield statements are examples of scaffolding.
    The date parsing, on the other hand, is the distinctive, interesting part of the
    function. We need to extract this distinct processing to permit use of more flexible
    scaffolding.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个parse_date_iter()函数在有趣的功能周围有大量的支架代码。for和yield语句是支架的例子。另一方面，日期解析是函数中独特、有趣的部分。我们需要提取这个独特的处理过程，以便使用更灵活的支架。
- en: 9.2.2 How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2.2 如何实现...
- en: To make use of different approaches to applying a generator function, we’ll
    need to start by refactoring the original parse_date_iter() function. This will
    extract a parse_date() function that can be used in a variety of ways. After this
    initial step, we’ll show three separate mini-recipes for using the refactored
    code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用不同的生成器函数应用方法，我们需要首先重构原始的parse_date_iter()函数。这将提取一个parse_date()函数，可以以多种方式使用。在此初始步骤之后，我们将展示三个独立的迷你配方，用于使用重构后的代码。
- en: 'Refactor the iterator to define a function that can be applied to a single
    row of the data. It should produce an item of the result type from an item of
    the source type:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重构迭代器以定义一个函数，该函数可以将源类型的项目转换为结果类型的项目：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This transformation can be applied to a collection of data in three ways: a
    generator function, a generator expression, and via the map() function. We’ll
    start by rebuilding the original generator.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换可以通过三种方式应用于数据集合：生成器函数、生成器表达式和通过map()函数。我们将首先重建原始生成器。
- en: Using the for and yield statements
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用for和yield语句
- en: 'We can apply a single-row parse_date() transformation function to each item
    of a collection using the for and yield statements. This was shown in the [Writing
    generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)
    recipe earlier in this chapter. Here’s what it looks like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用for和yield语句将单行parse_date()转换函数应用于集合中的每个项目。这在前面的[使用yield语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)配方中已经展示过。下面是这个例子：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using a generator expression
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用生成器表达式
- en: 'We can apply the parse_date() function to each item of a collection using a
    generator expression. A generator expression includes two parts – the mapping
    function, and a for clause – enclosed by (). This follows the pattern of the [Building
    lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用生成器表达式将parse_date()函数应用于集合中的每个项目。生成器表达式包括两个部分——映射函数和一个for子句——由括号()包围。这遵循了第[4](ch008_split_000.xhtml#x1-2240004)章中[构建列表——字面量、追加和推导式](ch008_split_000.xhtml#x1-2310002)配方中的模式：
- en: Write the () brackets that surround the generator.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出包围生成器的括号()。
- en: 'Write a for clause for the source of the data, assigning each item to a variable,
    in this case, item:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为数据源编写一个for子句，将每个项目分配给一个变量，在这个例子中是item：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Prefix the for clause with the mapping function, applied to the variable:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在for子句前加上映射函数，应用于变量：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The expression can be the return value from a function that provides suitable
    type hints for the source and the resulting expression. Here’s the entire function,
    since it’s so small:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该表达式可以是函数的返回值，该函数为源和结果表达式提供合适的类型提示。以下是整个函数，因为它非常小：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function returns the generator expression that applies the parse_date()
    function to each item in the source iterable.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数返回一个生成器表达式，它将 parse_date() 函数应用于源可迭代中的每个项目。
- en: Yes, this function is so small, it doesn’t seem to require the overhead of a
    def statement and a name. The type hints can be helpful in some contexts, making
    this a sensible choice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这个函数很小，似乎不需要 def 语句和名称的开销。在某些情况下，类型提示可能会有所帮助，这使得这是一个合理的选择。
- en: Using the map() function
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 map() 函数
- en: 'We can apply the parse_date() function to each item of a collection using the
    map() built-in function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 map() 内置函数将 parse_date() 函数应用于集合中的每个项目：
- en: 'Use the map() function to apply the transformation to the source data:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 map() 函数将转换应用于源数据：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The expression can be the return value from a function that provides suitable
    type hints for the source and the resulting expression. Here’s the entire function,
    since it’s so small:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该表达式可以是函数的返回值，该函数为源和结果表达式提供合适的类型提示。以下是整个函数，因为它非常小：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The map() function is an iterator that applies the parse_date() function to
    each item from the source iterable. It yields the objects created by the parse_date()
    function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: map() 函数是一个迭代器，它将 parse_date() 函数应用于源可迭代中的每个项目。它产生由 parse_date() 函数创建的对象。
- en: It’s important to note that the parse_date name without () is a reference to
    a function object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，parse_date 名称不带 () 是对函数对象的引用。
- en: It’s a common error to think the function must be evaluated, and include extra,
    unnecessary uses of ().
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 认为函数必须被评估，并包含额外的、不必要的 () 的使用是一个常见的错误。
- en: All three techniques are equivalent.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种技术是等效的。
- en: 9.2.3 How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2.3 它是如何工作的...
- en: The map() function replaces some common code that acts as a scaffold around
    the processing. It does the work of a for statement. It applies the given function
    to each item in the source iterable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: map() 函数替换了一些常见的代码，这些代码在处理周围充当脚手架。它执行 for 语句的工作。它将给定的函数应用于源可迭代中的每个项目。
- en: 'We can define our own version of map() as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下定义我们自己的 map() 版本：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we’ve seen, these are identical in their behavior. Different audiences for
    the code may have distinct preferences. The guidance we offer is to choose the
    style that makes the meaning and intention the most clear to the audience reading
    the code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，它们的行为是相同的。不同的代码受众可能有不同的偏好。我们提供的指导是选择使代码的意义和意图对阅读代码的受众最清晰的风格。
- en: 9.2.4 There’s more...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2.4 更多...
- en: In this example, we’ve used the map() function to apply a function that takes
    a single parameter to each item of a single iterable collection. It turns out
    that the map() function can do a bit more than this. The map() function can process
    several sequences.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 map() 函数将一个函数应用于单个可迭代集合中的每个项目。结果证明，map() 函数可以做得更多。map() 函数可以处理多个序列。
- en: 'Consider this function and these two sources of data:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个函数和这两个数据源：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can apply the mul() function to the sequence of pairs drawn from each source
    of data:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 mul() 函数应用于从每个数据源中抽取的配对序列：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This allows us to merge several sequences of values using different kinds of
    operations on argument values pulled from the sequences.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用从序列中提取的参数值的不同类型的操作合并几个值序列。
- en: 9.2.5 See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2.5 参见
- en: In the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe later in this chapter, we will look at stacked generators. We will build
    a composite function from a number of individual mapping operations, written as
    various kinds of generator functions.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章后面的 [使用堆叠的生成器表达式](ch013_split_000.xhtml#x1-5180003) 菜单中，我们将查看堆叠生成器。我们将从多个单个映射操作构建一个复合函数，这些操作以各种类型的生成器函数的形式编写。
- en: 9.3 Using stacked generator expressions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 使用堆叠的生成器表达式
- en: In the [Writing generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)
    recipe earlier in this chapter, we created a simple generator function that performed
    a single transformation on a piece of data. As a practical matter, we often have
    several functions that we’d like to apply to incoming data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的[使用yield语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)配方中，我们创建了一个简单的生成器函数，它对数据执行单个转换。作为一个实际问题，我们经常希望对传入的数据应用几个函数。
- en: How can we stack or combine multiple generator functions to create a composite
    function?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何堆叠或组合多个生成器函数以创建一个复合函数？
- en: 9.3.1 Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.1 准备工作
- en: This recipe will apply several different kinds of transformations to source
    data. There will be restructuring of the rows to combine three rows into a single
    row, data conversions to convert the source strings into useful numbers or datetime
    stamps, and filtering to reject rows that aren’t useful.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将对源数据应用几种不同的转换。将有三行重组以合并为单行，数据转换将源字符串转换为有用的数字或日期时间戳，以及过滤掉无用的行。
- en: We have a spreadsheet that is used to record fuel consumption on a large sailboat.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个电子表格，用于记录大型帆船的燃料消耗。
- en: For details of this data, see the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004). We’ll look at parsing
    this in more detail in the [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此数据的详细信息，请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[切片和切块列表](ch008_split_000.xhtml#x1-2400003)配方。我们将在第[11](ch015_split_000.xhtml#x1-61500011)章中的[使用CSV模块读取分隔文件](ch015_split_000.xhtml#x1-6320003)配方中更详细地查看解析。
- en: 'We’d like to apply a number of transformations to each row-level list of this
    list-of-lists-of-strings object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对列表-of-lists-of-strings对象的每一行级别的列表应用多个转换：
- en: Exclude the three lines of headers (and any blank lines) that are present in
    the data.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排除数据中存在的三行标题（以及任何空白行）。
- en: Merge three physical lines of text strings into one logical row of data.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将三个物理文本行合并为一个逻辑数据行。
- en: Convert the separated date and time strings into datetime objects.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分隔的日期和时间字符串转换为日期时间对象。
- en: Convert the fuel height from a string to a float, ideally in gallons (or liters)
    instead of inches.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将燃料高度从字符串转换为浮点数，理想情况下以加仑（或升）为单位，而不是英寸。
- en: 'Our goal is to create a group of generator functions. Assuming we have assigned
    the results of a generator function to a variable, datetime_gen, the transformations
    allow us to have software that looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一组生成器函数。假设我们已经将生成器函数的结果分配给一个变量，datetime_gen，这些转换允许我们拥有如下所示的软件：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We need to design a composite function that can create this datetime_gen generator.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设计一个复合函数来创建这个datetime_gen生成器。
- en: 9.3.2 How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.2 如何实现...
- en: 'We’ll decompose this into three separate mini-recipes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将将其分解为三个独立的迷你配方：
- en: Restructuring the rows.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新排列行。
- en: Excluding the header row.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排除标题行。
- en: Creating more useful row objects.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建更有用的行对象。
- en: We’ll start with restructuring three physical lines into a logical row.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将三个物理行重组为一个逻辑行开始。
- en: Restructuring the rows
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新排列行
- en: 'We’ll start by creating a row_merge() function to restructure the data:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个row_merge()函数来重新排列数据：
- en: 'We’ll use a named tuple to define a type for the combined logical rows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用命名元组来定义组合逻辑行的类型：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The raw data has empty cells; we’ve called them filler_1, filler_2, and filler_3\.
    Preserving these junk columns can make it easier to debug problems.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原始数据有空单元格；我们称它们为filler_1、filler_2和filler_3。保留这些垃圾列可以更容易地调试问题。
- en: 'The source rows created by a CSV reader will have a list[str] type; we’ll provide
    an alias for this type, RawRow. The function’s definition will accept an iterable
    of RawRow instances. It is an iterator over CombinedRow objects:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSV读取器创建的源行将具有list[str]类型；我们将为此类型提供一个别名，RawRow。函数的定义将接受RawRow实例的可迭代对象。它是一个CombinedRow对象的迭代器：
- en: '[PRE30]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The body of the function will consume rows from the source iterator, skipping
    empty lines, building a cluster that defines a CombinedRow object. When the first
    column is non-empty, any previous cluster is complete, it is yielded, and a new
    cluster is started. The very last cluster also needs to be yielded:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的主体将消耗源迭代器中的行，跳过空行，构建一个定义CombinedRow对象的簇。当第一列非空时，任何之前的簇就完成了，它被产出，然后开始一个新的簇。最后一个簇也需要被产出：
- en: '[PRE31]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This initial transformation can be used to convert a sequence of lines of CSV
    cell values into CombinedRow objects where each of the field values from three
    separate rows have their own unique attributes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始转换可以用来将CSV单元格值的行序列转换为CombinedRow对象，其中每个来自三个不同行的字段值都有它们自己的独特属性：
- en: The first row output from this transformation will be a header row. The next
    part is a function to drop this row.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换的第一个输出行将是标题行。下一部分是一个函数来删除这一行：
- en: Excluding the header row
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排除标题行
- en: 'The first three lines of text from the source CSV file will create a CombinedRow
    object that’s not very useful. We’ll exclude a row with labels instead of data:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 源CSV文件的前三行文本将创建一个不太有用的CombinedRow对象。我们将排除一个带有标签而不是数据的行：
- en: 'Define a function to work with an iterable collection of CombinedRow objects,
    creating an iterator of CombinedRow objects:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来处理一个由CombinedRow对象组成的可迭代集合，创建一个CombinedRow对象的迭代器：
- en: '[PRE32]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The function’s body consumes each row of the source and yields the good rows.
    It uses a continue statement to reject the undesirable rows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数体消费源数据中的每一行，并产出好的行。它使用continue语句来拒绝不想要的行：
- en: '[PRE33]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This can be combined with the row_merge() function shown in the previous recipe
    to provide an iterator over good data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以与之前配方中显示的row_merge()函数结合使用，以提供良好数据的迭代器：
- en: There are several transformation steps required to make the merged data truly
    useful. Next, we’ll look at one of these, creating proper datetime.datetime objects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要使合并的数据真正有用，需要几个转换步骤。接下来，我们将查看其中之一，创建正确的datetime.datetime对象：
- en: Creating more useful row objects
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建更有用的行对象
- en: 'The dates and times in each row aren’t very useful as separate strings. The
    function we’ll write can have a slightly different form than the previous two
    steps in this recipe because it applies to each row in isolation. The single-row
    transformation looks like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每行中的日期和时间作为单独的字符串并不很有用。我们将编写的函数可以比这个配方中前两个步骤有稍微不同的形式，因为它适用于每个单独的行。单行转换看起来像这样：
- en: 'Define a new NamedTuple class that specifies a more useful type for the time
    values:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的NamedTuple类，指定一个对时间值更有用的类型：
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define a mapping function to convert one CombinedRow instance into a single
    DatetimeRow instance:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个映射函数，将一个CombinedRow实例转换为一个单一的DatetimeRow实例：
- en: '[PRE35]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The body of this function will perform a number of date-time computations and
    create a new DatetimeRow instance:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的主体将执行多个日期时间计算并创建一个新的DatetimeRow实例：
- en: '[PRE36]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now stack the transformation functions to merge rows, exclude the header,
    and perform date time conversions. The processing looks like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以堆叠转换函数来合并行、排除标题行并执行日期时间转换。处理过程如下：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We’ve decomposed the reformatting, filtering, and transformation problems into
    three separate functions. Each of these three steps does a small part of the overall
    job. We can test each of the three functions separately. More important than being
    able to test is being able to fix or revise one step without completely breaking
    the entire stack of transformations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将重新格式化、过滤和转换问题分解为三个单独的函数。这三个步骤中的每一个都只完成整体工作的一个小部分。我们可以单独测试这三个函数。比能够测试更重要的是能够修复或修改一个步骤，而不会完全破坏整个转换堆栈：
- en: 9.3.3 How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.3 它是如何工作的...
- en: When we write a generator function, the argument value can be a collection of
    items, or it can be any other kind of iterable source of items. Since generator
    functions are iterators, it becomes possible to create a pipeline of generator
    functions by stacking them. The results of one generator are the input to the
    next one in the stack.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个生成器函数时，参数值可以是一个项目集合，或者它可以是一个任何其他类型的可迭代项目源。由于生成器函数是迭代器，因此可以通过堆叠它们来创建一个生成器函数的管道。一个生成器的结果成为堆叠中下一个生成器的输入：
- en: The datetime_gen object created by this recipe is a composition of three separate
    generators. A for statement can gather values from the datetime_gen generator
    expression. The body of that statement can print details and compute summaries
    of the objects being generated.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由这个配方创建的datetime_gen对象是由三个独立的生成器组成的组合。一个for语句可以从datetime_gen生成器表达式收集值。该语句的主体可以打印详细信息并计算正在生成的对象的摘要：
- en: This design emphasizes small, incremental operations at each stage. Some stages
    of the pipeline will consume multiple source rows for a single result row, restructuring
    the data as it is processed. Other stages consume and transform a single row,
    making them amenable to being described by generator expressions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计强调每个阶段的微小、增量操作。管道的某些阶段将消耗多个源行以生成单个结果行，在处理过程中重新构建数据。其他阶段则消耗并转换单行，这使得它们可以通过生成器表达式来描述。
- en: The entire pipeline is driven by demand from the client. Note that there’s no
    concurrency in this processing. Each function is “suspended” at the yield statement
    until a client demands more data from it via the built-in next() function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 整个管道由客户端的需求驱动。请注意，此处理中没有并发。每个函数在yield语句处“暂停”，直到客户端通过内置的next()函数要求更多数据。
- en: Most importantly, the individual transformation steps can be debugged and tested
    separately. This decomposition can help to create more robust and reliable software.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，可以单独调试和测试各个转换步骤。这种分解有助于创建更健壮和可靠的软件。
- en: 9.3.4 There’s more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.4 更多内容...
- en: There are a number of other conversions required to make this data useful. We’ll
    want to transform the start and end timestamps into a duration. We also need to
    transform the fuel height values into floating-point numbers instead of strings.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些数据变得有用，需要进行一些其他转换。我们希望将开始和结束时间戳转换为持续时间。我们还需要将燃油高度值转换为浮点数，而不是字符串。
- en: 'We have a number of ways to handle these derived data computations:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法来处理这些派生数据计算：
- en: We can create additional transformation steps in our stack of generator functions.
    This reflects an eager computation approach.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在我们的生成器函数堆栈中创建额外的转换步骤。这反映了急切计算方法。
- en: We can also add @property methods to the class definition. This is lazy computation;
    it’s only performed when the property value is required.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以在类定义中添加@property方法。这是一种惰性计算；只有在需要属性值时才会执行。
- en: To compute additional fuel height and volume values eagerly, we can apply the
    design pattern again. First, define additional named tuple classes with the required
    fields. Then, define a transformation function to convert height from a string
    to a float. Also, define a transformation to convert height from inches to gallons.
    These additional functions will be small and easy to test.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了急切地计算额外的燃油高度和体积值，我们可以再次应用设计模式。首先，定义具有所需字段的额外命名元组类。然后，定义一个转换函数，将高度从字符串转换为浮点数。还要定义一个将高度从英寸转换为加仑的转换。这些额外的函数将是小型且易于测试的。
- en: We now have a sophisticated computation that’s defined in a number of small
    and (almost) completely independent chunks. Each function does the work required
    to create only one row, keeping the overheads to a minimum. We can modify one
    piece without having to think deeply about how the other pieces work.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个复杂的计算，它由多个小型（几乎）完全独立的块定义。每个函数只执行创建一行所需的工作，将开销保持在最低。我们可以修改一个部分，而不必深入思考其他部分的工作方式。
- en: 9.3.5 See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.5 参见
- en: See the [Writing generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)
    recipe for an introduction to generator functions.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[使用yield语句编写生成器函数的说明](ch013_split_000.xhtml#x1-5030001)以了解生成器函数的简介。
- en: See the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe
    in Chapter [4](ch008_split_000.xhtml#x1-2240004), for more information on the
    fuel consumption dataset.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[切片和切块列表](ch008_split_000.xhtml#x1-2400003)说明，以获取有关燃油消耗数据集的更多信息。
- en: See the [Combining the map and reduce transformations](ch013_split_001.xhtml#x1-5440006)
    recipe for another way to combine operations.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[组合map和reduce转换](ch013_split_001.xhtml#x1-5440006)说明，了解另一种组合操作的方法。
- en: The [Picking a subset – three ways to filter](ch013_split_000.xhtml#x1-5270004)
    recipe covers the filter function in more detail.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[选择子集的三种过滤方法](ch013_split_000.xhtml#x1-5270004)说明详细介绍了过滤函数。'
- en: 9.4 Picking a subset – three ways to filter
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 选择子集 – 三种过滤方法
- en: Choosing a subset of relevant rows can be termed filtering a collection of data.
    We can view a filter as rejecting bad rows or including the desirable rows. There
    are several ways to apply a filtering function to a collection of data items.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 选择相关行的子集可以称为过滤数据集合。我们可以将过滤视为拒绝不良行或包含期望行。有几种方法可以将过滤函数应用于数据项集合。
- en: 'In the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe, we wrote the skip_header_date() generator function to exclude some rows
    from a set of data. The skip_header_date() function combined two elements: a rule
    to pass or reject items, and a source of data. This generator function had a general
    pattern that looks like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用堆叠生成器表达式](ch013_split_000.xhtml#x1-5180003)的配方中，我们编写了skip_header_date()生成器函数来排除一组数据中的某些行。skip_header_date()函数结合了两个元素：一个用于通过或拒绝项的规则，以及数据源。这个生成器函数有一个通用的模式，如下所示：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This data_filter_iter() function’s type hints emphasize that it is an iterable
    that consumes items of a type, T, from an iterable source collection. Some expression
    is applied to each item to determine if it’s valid. This expression can be defined
    as a separate function. We can define filters of considerable sophistication.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个data_filter_iter()函数的类型提示强调它是一个可迭代的，从可迭代的源集合中消费类型为T的项。对每个项应用一些表达式以确定其是否有效。这个表达式可以定义为单独的函数。我们可以定义相当复杂的过滤器。
- en: 'The design pattern can be summarized as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式可以总结如下：
- en: '![N = {x | x ∈ S if f(x)} ](img/file60.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![N = {x | x ∈ S if f(x)} ](img/file60.png)'
- en: The new collection, N, is each item, x, in the source, S, where a filter function,
    f(x), is true. This summary emphasizes the filter function, f(x), separating it
    from minor technical details of consuming the source and producing the result.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 新集合N是源S中的每个项x，其中过滤器函数f(x)为真。这个总结强调了过滤器函数f(x)，将其与消耗源和产生结果的技术细节区分开来。
- en: This mathematical summary suggests the for statement is little more than scaffolding
    code. Because it’s less important than the filter rule, it can help to refactor
    a generator function and extract the filter from the other processing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数学总结表明for语句几乎只是脚手架代码。因为它不如过滤规则重要，所以它可以帮助重构生成器函数并从其他处理中提取过滤功能。
- en: 'Considering the for statement as scaffolding, how else can we apply a filter
    to each item of a collection? There are two additional techniques we can use:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将for语句视为脚手架，我们还能如何将过滤器应用于集合中的每个项？我们可以使用两种额外的技术：
- en: We can write a generator expression.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写一个生成器表达式。
- en: We can use the built-in filter() function.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用内置的filter()函数。
- en: Both of these require refactoring the generator function — skip_header_date(),
    shown earlier in the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe — to extract the decision-making expression, separate from the for and
    if scaffolding around it. From this function, we can then move to creating a generator
    expression, and using the filter() function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都需要重构生成器函数——skip_header_date()，如前所述，在[使用堆叠生成器表达式](ch013_split_000.xhtml#x1-5180003)的配方中——以提取决策表达式，使其与周围的for和if脚手架分离。从这个函数中，我们然后可以转向创建生成器表达式，并使用filter()函数。
- en: 9.4.1 Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4.1 准备工作
- en: In this recipe, we’ll look at the fuel consumption data from the [Using stacked
    generator expressions](ch013_split_000.xhtml#x1-5180003) recipe in this chapter.
    For details of this data, see the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将查看本章[使用堆叠生成器表达式](ch013_split_000.xhtml#x1-5180003)配方中的燃料消耗数据。关于这些数据的详细信息，请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[切片和切块列表](ch008_split_000.xhtml#x1-2400003)配方。
- en: We used two generator functions. The first, row_merge(), restructured the physical
    lines into logical rows. A named tuple, CombinedRow, was used to provide a more
    useful structure to the row data. The second generator function, skip_header_date(),
    rejected the heading rows of the data, passing the useful data rows.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两个生成器函数。第一个，row_merge()，将物理行重新组织成逻辑行。使用命名元组CombinedRow为行数据提供了更有用的结构。第二个生成器函数skip_header_date()拒绝了数据表中的标题行，传递了有用的数据行。
- en: We’ll rewrite the skip_header_date() function to demonstrate three distinct
    approaches to extracting useful data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重写skip_header_date()函数来展示三种不同的提取有用数据的方法。
- en: 9.4.2 How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4.2 如何做到...
- en: The first part of this recipe will refactor the “good data” rule out of the
    generator function to make it more widely useful.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的第一部分将把“良好数据”规则从生成器函数中重构出来，使其更具有通用性。
- en: 'Start with a draft version of a generator function with the following outline:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下大纲开始编写生成器函数的草稿版本：
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The expression in the if statement can be refactored into a function that can
    be applied to a single row of the data, producing a bool value:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: if语句中的表达式可以被重构为一个函数，该函数可以应用于数据的一行，产生一个bool值：
- en: '[PRE41]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The original generator function can now be simplified:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始的生成器函数现在可以简化：
- en: '[PRE42]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The pass_non_date() function can be used in three ways. As shown here, it can
    be used by a generator function. It can also be used in a generator expression,
    and with the filter() function. Next, we’ll look at writing an expression.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: pass_non_date()函数可以用三种方式使用。如所示，它可以由一个生成器函数使用。它也可以用在生成器表达式中，以及与filter()函数一起使用。接下来，我们将看看如何编写一个表达式。
- en: Using a filter in a generator expression
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在生成器表达式中使用filter
- en: 'A generator expression includes three parts – the item, a for clause, and an
    if clause – all enclosed by ():'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式包括三个部分——项目、一个for子句和一个if子句——所有这些都包含在括号()中。
- en: 'Start with a for clause that assigns objects to a variable. This source comes
    from some iterable collection, which is called source in this example:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个for子句开始，将对象分配给一个变量。这个源来自某个可迭代的集合，在这个例子中称为source：
- en: '[PRE43]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Because this is a filter, the result expression should be the variable from
    the for clause:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为这是一个过滤器，结果表达式应该是for子句中的变量：
- en: '[PRE44]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Write an if clause using the filter rule function, pass_non_date():'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用filter规则函数pass_non_date()编写一个if子句。
- en: '[PRE45]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This generator expression can be the return value from a function that provides
    suitable type hints for the source and the resulting expression. Here’s the entire
    function, since it’s so small:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个生成器表达式可以是一个函数的返回值，该函数为源表达式和结果表达式提供了合适的类型提示。以下是整个函数，因为它非常小：
- en: '[PRE46]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function returns the result of the generator expression. The function doesn’t
    do very much, but it does applying a name and a set of type hints to the expression.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数返回生成器表达式的结果。这个函数并没有做很多，但它确实给表达式应用了一个名称和一组类型提示。
- en: The skip_header_gen() function uses a generator expression that applies the
    pass_non_date() function to each item in the source collection to determine whether
    it passes and is kept, or whether it is rejected.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: skip_header_gen()函数使用一个生成器表达式，该表达式将pass_non_date()函数应用于源集合中的每个项目，以确定它是否通过并保留，或者是否被拒绝。
- en: The results are identical to the original skip_header_date() function, shown
    above.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与上面显示的原始skip_header_date()函数相同。
- en: Using the filter() function
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用filter()函数
- en: 'Using the filter() function includes two parts – the decision function and
    the source of data – as arguments:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用filter()函数包括两个部分——决策函数和数据来源——作为参数：
- en: 'Use the filter() function to apply the function to the source data:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用filter()函数将函数应用于源数据：
- en: '[PRE47]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The filter() function is an iterator that applies the given function, pass_non_date()
    as a rule to pass or reject each item from the given iterable, data. It yields
    the rows for which the pass_non_date() function returns True.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: filter()函数是一个迭代器，它将给定的函数pass_non_date()作为规则应用于给定的可迭代对象data中的每个项目，以决定是否通过或拒绝。它产生那些pass_non_date()函数返回True的行。
- en: It’s important to note that the pass_non_date name without () is a reference
    to a function object.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，没有括号的pass_non_date名称是对一个函数对象的引用。
- en: It’s a common error to think the function must be evaluated, and include extra,
    unnecessary uses of ().
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的错误是认为函数必须被评估，并包含额外的、不必要的括号使用。
- en: 9.4.3 How it works...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4.3 它是如何工作的...
- en: A generator expression must include a for clause to provide a source of data
    items. The optional if clause can apply a condition that preserves some items
    while rejecting others. Placing a filter condition in an if clause can make the
    expression clear and expressive of the algorithm.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式必须包含一个for子句以提供数据项的来源。可选的if子句可以应用一个条件，保留一些项同时拒绝其他项。在if子句中放置一个过滤器条件可以使表达式清晰并表达算法。
- en: Generator expressions have an important limitation. As expressions, they cannot
    use statement-oriented features of Python. The try-except statement, used to handle
    exceptional data conditions, is often helpful.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式有一个重要的限制。作为表达式，它们不能使用Python的面向语句的特性。try-except语句，用于处理异常数据条件，通常很有帮助。
- en: 9.4.4 There’s more...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4.4 更多内容...
- en: Sometimes, it’s difficult to write a simple rule to define the valid data or
    reject the invalid data. In many cases, it may be impossible to use a simple string
    comparison to identify rows to reject. This happens when a file is filled with
    extraneous information; manually prepared spreadsheets suffer from this. It some
    cases, there’s no trivial regular expression that helps to characterize valid
    data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，很难编写一个简单的规则来定义有效数据或拒绝无效数据。在许多情况下，可能无法使用简单的字符串比较来识别要拒绝的行。当文件中充满了无关信息时，这种情况就会发生；手动准备的电子表格就存在这个问题。在某些情况下，没有简单的正则表达式可以帮助描述有效数据。
- en: We can often encounter data where the easiest way to establish validity is to
    attempt a conversion, and transform the presence or absence of an exception into
    a Boolean condition.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常遇到数据，其中确定有效性的最简单方法就是尝试转换，并将异常的存在或不存在转换为布尔条件。
- en: 'Consider the following function to ascertain if a row of data has a valid date:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数，以确定数据行是否具有有效的日期：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will attempt a conversion of a date. It will reject invalid strings of
    characters that fail to follow the essential format rule. It will also reject
    2/31/24; while the string of digits is valid, this is not a real date.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尝试转换日期。它将拒绝不符合基本格式规则的无效字符字符串。它还将拒绝2/31/24；虽然数字字符串是有效的，但这不是一个真实日期。
- en: 9.4.5 See also
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4.5 参见
- en: In the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe earlier in this chapter, we placed a function like this in a stack of generators.
    We built a composite function from a number of individual mapping and filtering
    operations written as generator functions.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面的[使用堆叠生成器表达式](ch013_split_000.xhtml#x1-5180003)配方中，我们将类似这样的函数放入生成器堆栈中。我们通过将多个作为生成器函数编写的单个映射和过滤操作组合起来，构建了一个复合函数。
- en: 9.5 Summarizing a collection – how to reduce
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 汇总集合 – 如何reduce
- en: A reduction is the generalized concept behind computing a summmary like the
    total or the maximum of a collection of numbers. Computing statistical measures
    like mean or variance are also reductions. In this recipe, we’ll look at several
    summarization or reduction techniques.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Reduction是计算集合的总和或最大值等摘要的通用概念。计算均值或方差等统计度量也是reduce。在本配方中，我们将探讨几种摘要或reduce技术。
- en: 'In the introduction to this chapter, we noted that there are three processing
    patterns that Python supports elegantly: map, filter, and reduce. We saw examples
    of mapping in the [Applying transformations to a collection](ch013_split_000.xhtml#x1-5090002)
    recipe and examples of filtering in the [Picking a subset – three ways to filter](ch013_split_000.xhtml#x1-5270004)
    recipe.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的介绍中，我们提到Python支持三种优雅的处理模式：map、filter和reduce。我们在[应用于集合的转换](ch013_split_000.xhtml#x1-5090002)配方中看到了映射的示例，在[选择子集
    – 三种过滤方式](ch013_split_000.xhtml#x1-5270004)配方中看到了过滤的示例。
- en: The third common pattern is reduction. In the [Designing classes with lots of
    processing](ch011_split_000.xhtml#x1-3890003) and the [Extending a built-in collection
    – a list that does statistics](ch011_split_001.xhtml#x1-4250009) recipes, we looked
    at class definitions that computed a number of statistical values. These definitions
    relied — almost exclusively — on the built-in sum() function. This is one of the
    more common reduce operations.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种常见的模式是reduce。在[设计大量处理类的配方](ch011_split_000.xhtml#x1-3890003)和[扩展内置集合 – 执行统计的列表](ch011_split_001.xhtml#x1-4250009)配方中，我们看到了计算多个统计值的类定义。这些定义几乎完全依赖于内置的sum()函数。这是更常见的reduce操作之一。
- en: In this recipe, we’ll look at a way to generalize summation, leading to ways
    to write a number of different kinds of reductions that are similar. Generalizing
    the concept of reduction will let us build on a reliable foundation to create
    more sophisticated algorithms.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将探讨一种泛化求和的方法，从而可以编写多种不同类型的类似reduce。泛化reduce的概念将使我们能够在一个可靠的基础上构建更复杂的算法。
- en: 9.5.1 Getting ready
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.1 准备工作
- en: Some of the most common reduce operations are the sum, minimum, maximum. These
    reductions are so common, they’re built in. The average and variance, on the other
    hand, are reductions defined in the statistics module. The math module has a variant
    on sum, fsum(), that works particularly well for collections of floating-point
    values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的reduce操作包括求和、最小值、最大值。这些操作非常常见，因此它们是内置的。另一方面，平均值和方差是在统计模块中定义的reduce。数学模块有一个sum的变体，即fsum()，它特别适用于浮点数值集合。
- en: Summations are the backbone of financial reporting. It is the essence of what
    a spreadsheet has been used for since the days of doing financial reports using
    pen and paper.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 求和是财务报告的骨架。它是自使用笔和纸进行财务报告以来电子表格所使用的本质。
- en: 'The mathematics of summation help us to see how an operator is used to convert
    a collection of values into a single value. Here’s a way to think of the mathematical
    definition of the sum function using an operator, +, applied to the values in
    a collection, C = {c[0],c[1],c[2],…,c[n]}:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 求和的数学帮助我们了解运算符是如何将值集合转换为单个值的。下面是使用运算符 + 应用到集合 C = {c[0],c[1],c[2],…,c[n]} 中的值来思考求和函数的数学定义的一种方法：
- en: '![∑ ci = c0 + c1 + c2 + ⋅⋅⋅+ cn + 0 ci∈C ](img/file61.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![∑ ci = c0 + c1 + c2 + ⋅⋅⋅+ cn + 0 ci∈C ](img/file61.png)'
- en: We’ve expanded the definition of sum by folding the + operator into the sequence
    of values in C.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将加法运算符 + 拼接到 C 中的值序列来扩展 sum 的定义。
- en: 'Folding involves two items: a binary operator and a base value. For sum, the
    operator was + and the base value was zero. For product, the operator is × and
    the base value is one. The base value needs to be the identity element for the
    given operator.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 拼接涉及两个项目：一个二元运算符和一个基本值。对于 sum，运算符是 +，基本值是零。对于 product，运算符是 ×，基本值是一。基本值需要是给定运算符的单位元素。
- en: We can apply this concept to many algorithms, potentially simplifying the definition.
    In this recipe, we’ll define a product function. This is the ![∏ ](img/file62.png)
    operator, similar to the ![∑ ](img/file63.png) operator.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个概念应用到许多算法中，可能简化定义。在这个配方中，我们将定义一个乘积函数。这是 ![∏ ](img/file62.png) 运算符，类似于
    ![∑ ](img/file63.png) 运算符。
- en: 9.5.2 How to do it...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.2 如何操作...
- en: 'Here’s how we define a reduction that implements product of a collection of
    numbers:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何定义一个实现数字集合乘积的减少操作：
- en: 'Import the reduce()) function from the functools module:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 functools 模块导入 reduce() 函数：
- en: '[PRE49]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Pick the operator. For sum, it’s +. For product, it will be ×. These can be
    defined in a variety of ways. Here’s the long version. Other ways to define the
    necessary binary operators will be shown later:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择运算符。对于 sum，它是 +。对于 product，它将是 ×。这些可以用各种方式定义。下面是长版本。稍后还会展示定义必要的二元运算符的其他方式：
- en: '[PRE50]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Pick the base value required. The additive identity value for sum is zero.
    The multiplicative identity for a product is one:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所需的基本值。对于 sum 的加法单位值是零。对于 product 的乘法单位值是一：
- en: '[PRE51]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can use this prod() function to define other functions. One example is the
    factorial function. It looks like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个 prod() 函数来定义其他函数。一个例子是阶乘函数。它看起来是这样的：
- en: '[PRE53]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'How many six-card cribbage hands are possible? The binomial calculation uses
    the factorial function to compute the number of ways 6 cards can be extracted
    from a 52 card deck:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少种六张牌的克里比奇牌手是可能的？二项式计算使用阶乘函数来计算从 52 张牌的牌堆中抽取 6 张牌的方法数：
- en: '![( ) 52 = ----52!--- 6 6!(52− 6)! ](img/file64.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) 52 = ----52!--- 6 6!(52− 6)! ](img/file64.png)'
- en: 'Here’s a Python implementation:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 Python 实现：
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For any given shuffle, there are about 20 million different possible cribbage
    hands we might see.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的洗牌，大约有 2000 万种不同的克里比奇牌手可能出现。
- en: 9.5.3 How it works...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.3 它是如何工作的...
- en: 'The reduce() function behaves as though it has this definition:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: reduce() 函数的行为好像它有如下定义：
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The type hints shows how there has to be a unifying type, T, that applies to
    the operator being folded, and the initial value for the folding. The given function,
    fn(), must combine two values of type T and return another value of the same type
    T. The result of the reduce() function will be a value of this type also.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示显示必须有一个统一的类型 T，它适用于折叠的运算符和折叠的初始值。给定的函数 fn() 必须组合两个类型为 T 的值并返回另一个类型为 T 的值。reduce()
    函数的结果也将是这个类型。
- en: Furthermore, in Python, the reduce operation will iterate through the values
    from left to right. It will apply the given binary function, fn(), between the
    previous result and the next item from the source collection. This additional
    detail is important when thinking about non-commutative operators like subtraction
    or division.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 Python 中，reduce 操作将从左到右遍历值。它将在源集合的前一个结果和下一个项目之间应用给定的二元函数 fn()。当考虑非交换运算符（如减法或除法）时，这个额外细节很重要。
- en: 9.5.4 There’s more...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.4 更多...
- en: 'We’ll look at three additional topics. First, ways to define the operation.
    After that, we’ll look at applying reduce to Boolean values in [Logical reductions:
    any and all](ch013_split_001.xhtml#x1-5410004). Finally, in [Identity elements](ch013_split_001.xhtml#x1-5420004),
    we’ll look at the identity elements used by various operators.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨三个额外的主题。首先，定义操作的方法。之后，我们将探讨在[逻辑简化：任意和所有](ch013_split_001.xhtml#x1-5410004)中将reduce应用于布尔值。最后，在[恒等元素](ch013_split_001.xhtml#x1-5420004)中，我们将探讨各种运算符使用的恒等元素。
- en: Operation definition
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作定义
- en: 'When designing a new application for the reduce() function, we need to provide
    a binary operator. There are three ways to define the necessary binary operator.
    First, we can use a complete function definition, as shown above in the recipe.
    There are two other choices. We can use a lambda object instead of a complete
    function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当为reduce()函数设计新应用时，我们需要提供一个二元运算符。有三种方法来定义必要的二元运算符。首先，我们可以使用完整的函数定义，如上所示在配方中。还有两种选择。我们可以使用lambda对象而不是完整的函数：
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A lambda object is an anonymous function boiled down to just two essential
    elements: the parameters and the return expression. There are no statements inside
    a lambda, only a single expression.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: lambda对象是一个匿名函数，简化为仅包含两个基本元素：参数和返回表达式。lambda内部没有语句，只有一个表达式。
- en: We assigned the lambda object to a variable, lmul, so that we can use the expression
    lmul(2, 3) to apply the lambda object to argument values.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将lambda对象赋值给变量lmul，这样我们就可以使用表达式lmul(2, 3)来将lambda对象应用于参数值。
- en: 'When the operation is one of Python’s built-in operators, we have another choice
    – import the definition from the operator module:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作是Python的内置运算符之一时，我们还有另一个选择——从operator模块导入定义：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This works nicely for all the built-in arithmetic operators.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于所有内置的算术运算符都适用。
- en: It’s essential to consider the complexity of the operator being used to reduce.
    Performing a reduce operation increases an operation’s complexity by a factor
    of n. An operation that’s O(1) becomes O(n) when applied to n items in a collection.
    For the operators we’ve shown, like add and mul, this fits our expectations. An
    operator with more complexity than O(1) can turn into a performance nightmare.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑正在使用的运算符的复杂性是至关重要的。执行reduce操作会将运算符的复杂性增加n倍。当应用于集合中的n个元素时，O(1)的操作变为O(n)。对于我们所展示的运算符，如加法和乘法，这符合我们的预期。比O(1)更复杂的运算符可能会变成性能噩梦。
- en: In the next section, we’ll look at the logical reduction functions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨逻辑简化函数。
- en: 'Logical reductions: any and all'
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑简化：任意和所有
- en: Conceptually, it seems like we should be able to do reduce() operations using
    the Boolean operators and and or. It turns out this involves some additional consideration.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，我们似乎应该能够使用布尔运算符and和or来进行reduce()操作。实际上，这涉及到一些额外的考虑。
- en: 'Python’s Boolean operators have a short-circuit feature: when we evaluate the
    expression False and 3 / 0, the result is only False. The expression on the right-hand
    side of the and operator, 3 / 0, is never evaluated. The or operator is similar:
    when the left side is True, the right-hand side is never evaluated.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Python的布尔运算符具有短路特性：当我们评估表达式False and 3 / 0时，结果仅为False。and运算符右侧的表达式3 / 0永远不会被评估。or运算符类似：当左侧为True时，右侧永远不会被评估。
- en: If we want to be sure that a sequence of bool values is all true, building our
    own reduce() will do far too much work. Once the initial False is seen, there’s
    no reason to process the remaining items. The short-circuit feature of and and
    or does not not fit with the reduce() function.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想确保一个布尔值序列全部为真，自己构建reduce()将会做太多工作。一旦看到初始的False，就没有必要处理剩余的项目。and和or的短路特性与reduce()函数不匹配。
- en: The built-in functions any() and all(), on the other hand, are reductions using
    logic operators. The any() function is, effectively, a kind of reduce() using
    the or operator. Similarly, the all() function behaves as if it’s a reduce() with
    the and operator.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数any()和all()另一方面，是使用逻辑运算符的简化。实际上，any()函数相当于使用or运算符的reduce()。同样，all()函数的行为就像是一个使用and运算符的reduce()。
- en: Identity elements
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恒等元素
- en: 'Generally, an operator used for a reduction must have an identity element.
    This is provided to the reduce() function as the initial value. The identity element
    will also be the result when they’re applied against an empty sequence. Here are
    some common examples:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，用于归约的运算符必须有一个恒等元素。这作为初始值提供给 reduce() 函数。当它们应用于空序列时，恒等元素也将是结果。以下是一些常见示例：
- en: sum([]) is zero.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sum([]) 是零。
- en: math.prod([]) is one.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: math.prod([]) 是一个例子。
- en: any([]) is False.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: any([]) 是 False。
- en: all([]) is True.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: all([]) 是 True。
- en: The identity value for the given operation is a matter of definition.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 给定操作的恒等值是定义问题。
- en: 'In the case of any() and all() specifically, it can help to think of the fundamental
    fold operation. The identity element can always be folded in without changing
    the result. Here’s how all() would look with explicitly folded and operators:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何() 和 all() 的特定情况下，可以考虑基本折叠操作。恒等元素总是可以折叠而不改变结果。以下是 all() 以显式折叠和运算符的形式看起来是怎样的：
- en: '![b0 and b1 and b2 and ... and bn and True ](img/file65.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![b0 和 b1 和 b2 和 ... 和 bn 和 True](img/file65.png)'
- en: If all of the values b[0],b[1],b[2],...,b[n] are True, then the additional and
    True doesn’t change the value. If any of the values b[0],b[1],b[2],...,b[n] are
    are False, similarly, the additional and True has no impact.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 b[0],b[1],b[2],...,b[n] 中的所有值都是 True，那么额外的 True 不会改变值。如果 b[0],b[1],b[2],...,b[n]
    中的任何值是 False，同样地，额外的 True 也不会产生影响。
- en: When there are no values in a collection, the value for all() is the identity
    element, True.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合中没有值时，all() 的值是恒等元素，即 True。
- en: 9.5.5 See also
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.5 参见
- en: See the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe in this chapter for a context in which sum can be applied to compute total
    hours and total fuel.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，查看 [使用堆叠的生成表达式](ch013_split_000.xhtml#x1-5180003) 菜单，了解在何种情况下可以将 sum()
    函数应用于计算总小时数和总燃料量。
- en: 9.6 Combining the map and reduce transformations
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 map 和 reduce 转换的结合
- en: 'In the other recipes in this chapter, we’ve been looking at map, filter, and
    reduce operations. We’ve looked at each of these functions in isolation:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其他菜谱中，我们一直在查看 map、filter 和 reduce 操作。我们已经单独查看过这些函数：
- en: The [Applying transformations to a collection](ch013_split_000.xhtml#x1-5090002)
    recipe shows the map() function.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[对集合应用转换](ch013_split_000.xhtml#x1-5090002) 菜单展示了 map() 函数。'
- en: The [Picking a subset – three ways to filter](ch013_split_000.xhtml#x1-5270004)
    recipe shows the filter() function.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[选择子集 – 三种过滤方式](ch013_split_000.xhtml#x1-5270004) 菜单展示了 filter() 函数。'
- en: The [Summarizing a collection – how to reduce](ch013_split_000.xhtml#x1-5350005)
    recipe shows the reduce() function.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结集合 – 如何归约](ch013_split_000.xhtml#x1-5350005) 菜单展示了 reduce() 函数。'
- en: Many algorithms will involve creating composite functions that combine these
    more basic operations. Additionally, we’ll need to look at a profound limitation
    of working with iterators and generator functions.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 许多算法将涉及创建组合函数，这些函数结合了更基本的操作。此外，我们还需要考虑使用迭代器和生成函数的一个深刻限制。
- en: 'Here’s an example of this limitation:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个这个限制的例子：
- en: '[PRE59]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We created an iterator over a sequence of values by manually applying the iter()
    function to a literal list object. The first time that the sum() function consumed
    the values from typical_iterator, it consumed all five values. The next time we
    try to apply any function to typical_iterator, there will be no more values to
    be consumed; the iterator will appear empty. By definition, the identity value
    — 0 for summation — is the result.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过手动将 iter() 函数应用于一个字面量列表对象来创建一个值序列的迭代器。第一次 sum() 函数从 typical_iterator 消费值时，它消费了所有五个值。下一次我们尝试将任何函数应用于
    typical_iterator 时，将没有更多的值可以消费；迭代器将看起来是空的。根据定义，恒等值（对于求和来说是 0）是结果。
- en: An iterator can only produce values once.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器只能产生一次值。
- en: After the values have been consumed, an iterator appears to be an empty collection.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在值被消费后，迭代器看起来像是一个空集合。
- en: This one-time-only constraint will force us to cache intermediate results when
    we need to perform multiple reductions on the data. Creating intermediate collection
    objects will consume memory, leading to the need for a careful design when working
    with very large collections of data. (Processing large collections of data is
    difficult. Python offers some ways to create workable solutions; it does not magically
    make the problem evaporate.)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一次性约束将迫使我们缓存中间结果，当我们需要对数据进行多次减少时。创建中间集合对象将消耗内存，因此在处理非常大的数据集时需要仔细设计。（处理大量数据集是困难的。Python提供了一些创建可行解决方案的方法；它并不能神奇地使问题消失。）
- en: To apply a complex transformation of a collection, we often find instances of
    map, filter, and reduce operations that can be implemented separately. These can
    then be combined into sophisticated composite operations.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要对一个集合应用复杂的转换，我们通常会发现可以单独实现的map、filter和reduce操作的实例。然后，这些操作可以组合成复杂的复合操作。
- en: 9.6.1 Getting ready
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6.1 准备工作
- en: In the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe earlier in this chapter, we looked at some sailboat data. The spreadsheet
    was badly organized, and a number of steps were required to impose a more useful
    structure on the data.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面[使用堆叠生成器表达式](ch013_split_000.xhtml#x1-5180003)的配方中，我们查看了一些帆船数据。电子表格组织得很差，需要多个步骤来对数据进行更有用的结构化。
- en: In that recipe, we looked at a spreadsheet that is used to record fuel consumption
    on a large sailboat. For details of this data, see the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004). We’ll look at parsing
    this in more detail in the [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个配方中，我们查看了一个用于记录大型帆船燃油消耗的电子表格。关于这些数据的详细信息，请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[切片和切块列表](ch008_split_000.xhtml#x1-2400003)配方。我们将在第[11](ch015_split_000.xhtml#x1-61500011)章的[使用CSV模块读取定界文件](ch015_split_000.xhtml#x1-6320003)配方中更详细地查看解析。
- en: The initial processing in the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe created a sequence of operations to change the organization of the data,
    filter out the headings, and compute some useful values. We’d need to supplement
    this with two more reductions to get some average and variance information. These
    statistics will help us understand the data more fully. We’ll build on that earlier
    processing with some additional steps.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用堆叠生成器表达式](ch013_split_000.xhtml#x1-5180003)的配方中，初始处理创建了一系列操作以改变数据的组织结构，过滤掉标题，并计算一些有用的值。我们需要补充两个额外的减少步骤来获取一些平均值和方差信息。这些统计数据将帮助我们更全面地理解数据。我们将在此基础上进行一些额外的步骤。
- en: 9.6.2 How to do it...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6.2 如何实现...
- en: We’ll start with a target line of code as the design goal. In this case, we’d
    like a function to sum the fuel use per hour. This follows a common three-step
    processing pattern. First, we normalize the data with row_merge(). Second, we
    use mapping and filtering to create more useful objects with clean_data_iter().
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从目标代码行作为设计目标开始。在这种情况下，我们希望有一个函数来计算每小时的燃油使用量。这遵循了一个常见的三步处理模式。首先，我们使用row_merge()对数据进行归一化。其次，我们使用映射和过滤通过clean_data_iter()创建更实用的对象。
- en: 'The third step should look like the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步应该看起来像以下内容：
- en: '[PRE60]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Our target function, total_fuel(), is designed to work with a few other functions
    that clean and organize the raw data. We’ll start with the normalization and proceed
    to defining the final summary function as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标函数total_fuel()被设计成与几个用于清理和整理原始数据的函数一起工作。我们将从归一化开始，然后定义最终的汇总函数，如下所示：
- en: 'Import the functions from earlier recipes to reuse the initial preparation:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的配方中导入函数以重用初始准备：
- en: '[PRE61]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Define the target data structure created by the cleaning and enrichment step.
    We’ll use a mutable dataclass in this example. The fields coming from the normalized
    CombinedRow object can be initialized directly. The other five fields will be
    computed eagerly by several separate functions. Fields not computed in the __init__()
    method must be given an initial value of field(init=False):'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义由清理和丰富步骤创建的目标数据结构。在这个例子中，我们将使用可变的数据类。来自归一化CombinedRow对象的字段可以直接初始化。其他五个字段将通过几个单独的函数积极计算。在__init__()方法中没有计算的字段必须提供一个初始值field(init=False)：
- en: '[PRE62]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define the overall data cleansing and enrichment data function. This will build
    the enriched Leg objects from the source CombinedRow objects. We’ll build this
    from seven simpler functions. The implementation is a stack of map() and filter()
    operations that will derive data from the source fields:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义整体数据清洗和丰富数据函数。这将从源CombinedRow对象构建丰富的Leg对象。我们将从七个更简单的函数构建它。实现是一个map()和filter()操作的堆栈，它将从源字段推导数据：
- en: '[PRE63]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Each statement makes use of the iterator produced by the preceding statement.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个语句都使用前一个语句产生的迭代器。
- en: 'Write the make_Leg() function to create Leg instances from CombinedRow instances:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写make_Leg()函数，从CombinedRow实例创建Leg实例：
- en: '[PRE64]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Write the reject_date_header() function used by filter() to remove the heading
    rows:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写reject_date_header()函数，用于filter()移除标题行：
- en: '[PRE65]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Write the data conversion functions. We’ll start with the two date and time
    strings, which need to become a single datetime object:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写数据转换函数。我们将从两个日期和时间字符串开始，它们需要变成一个单一的datetime对象：
- en: '[PRE66]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Mutate the Leg instances with additional values:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用额外的值修改Leg实例：
- en: '[PRE67]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This update-in-place approach is an optimization to avoid creating intermediate
    objects.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种原地更新方法是一种优化，以避免创建中间对象。
- en: 'Compute the derived duration from the timestamps:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从时间戳计算派生持续时间：
- en: '[PRE68]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Compute any other metrics that are needed for the analysis:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算分析所需的其他任何指标：
- en: '[PRE69]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The final fuel_per_hour() function’s calculation depends on the entire preceding
    stack of calculations. Each of these computations is done separately to clarify
    and isolate the computation details. This approach permits changes to the isolated
    computations. Most importantly, it permits testing each computation as a separate
    unit.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的fuel_per_hour()函数的计算依赖于整个前面的计算堆栈。每个这些计算都是单独进行的，以阐明和隔离计算细节。这种方法允许对隔离的计算进行更改。最重要的是，它允许将每个计算作为一个单独的单元进行测试。
- en: 9.6.3 How it works...
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6.3 它是如何工作的...
- en: The core concept is to build a composite transformation from a sequence of small
    steps. Since each step is conceptually distinct, it makes it somewhat easier to
    understand the composition.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 核心概念是从一系列小步骤构建一个复合转换。由于每个步骤在概念上是不同的，这使得理解组合变得相对容易。
- en: 'In this recipe, we’ve used three kinds of transformations:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了三种类型的转换：
- en: Structural changes. An initial generator function grouped physical lines into
    logical rows.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构变化。一个初始生成函数将物理行分组到逻辑行中。
- en: Filters. A generator function rejected rows that were invalid.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器。一个生成函数拒绝无效的行。
- en: 'Enrichment. As we’ve seen, there are two design approaches to enriching data:
    lazy and eager. The lazy approach may involve methods or properties, computed
    only as needed. This design shows eager computation, where a number of fields
    had values built by the processing pipeline.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富。正如我们所见，有两种设计方法可以丰富数据：懒加载和急加载。懒加载方法可能涉及仅在需要时计算的方法或属性。这种设计显示了急加载计算，其中许多字段值是由处理管道构建的。
- en: The various enrichment methods worked by updating stateful Leg objects, setting
    computed column values. Using stateful objects like this requires the various
    enrichment transformations be performed in a strict order because some (like duration())
    depend on others having been performed first.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 各种丰富方法通过更新状态化的Leg对象、设置计算列值来实现。使用这种状态化对象需要严格按照顺序执行各种丰富转换，因为其中一些（如duration()）依赖于其他转换先执行。
- en: 'We can now design the target computation functions:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以设计目标计算函数：
- en: '[PRE70]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This meets our design goal of being able to perform meaningful computations
    on the raw data.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合我们的设计目标，即能够在原始数据上执行有意义的计算。
- en: 9.6.4 There’s more...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6.4 更多内容...
- en: As we noted, we can only perform one iteration of consuming the items from an
    iterable source of data. If we want to compute several averages, or the average
    as well as the variance, we’ll need to use a slightly different design pattern.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，我们只能对可迭代数据源中的项目进行一次迭代。如果我们想计算多个平均值，或者平均值以及方差，我们需要使用稍微不同的设计模式。
- en: 'In order to compute multiple summaries of the data, it’s often best to create
    a concrete object of some kind that can be summarized repeatedly:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算多个数据摘要，通常最好创建某种类型的具体对象，该对象可以被反复总结：
- en: '[PRE71]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, we’ve created a very large tuple from the cleaned and enriched data. From
    this tuple, we can can produce any number of iterators. This lets us compute any
    number of distinct summaries.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从清洗和丰富后的数据创建了一个非常大的元组。从这个元组中，我们可以产生任意数量的迭代器。这使我们能够计算任意数量的不同摘要。
- en: We can also use the tee() function in the itertools module for this kind of
    processing. This can devolve to inefficient processing because of the way the
    cloned instances of the iterator maintain their internal state. It’s often better
    to create an intermediate structure like a list or tuple than to use itertools.tee().
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用itertools模块中的tee()函数进行此类处理。由于克隆迭代器的实例保持其内部状态的方式，这可能导致效率低下的处理。通常，创建一个中间结构（如列表或元组）比使用itertools.tee()更好。
- en: The design pattern applies a number of transformations to the source data. We’ve
    built it using a stack of separate map, filter, and reduce operations.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式将多个转换应用于源数据。我们使用单独的映射、过滤和减少操作堆叠构建了它。
- en: 9.6.5 See also
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6.5 参考信息
- en: See the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe in this chapter for a context in which sum can be applied to compute total
    hours and total fuel.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中查看[使用堆叠生成器表达式](ch013_split_000.xhtml#x1-5180003)的配方，了解sum函数可以应用于计算总小时数和总燃料量的上下文。
- en: See the [Summarizing a collection – how to reduce](ch013_split_000.xhtml#x1-5350005)
    recipe in this chapter for some background on the reduce() function.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中查看[总结集合 – 如何减少](ch013_split_000.xhtml#x1-5350005)的配方，了解reduce()函数的一些背景信息。
- en: See [Python High Performance](https://www.packtpub.com/product/python-high-performance-second-edition-second-edition/9781787282896)
    for more on distributed map-reduce processing.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关分布式map-reduce处理的更多信息，请参阅[Python High Performance](https://www.packtpub.com/product/python-high-performance-second-edition-second-edition/9781787282896)。
- en: We look at lazy properties in the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007). Also, this recipe looks
    at some important variations of map-reduce processing.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在[使用属性进行懒属性](ch011_split_001.xhtml#x1-43100010)的配方中查看懒性属性，在第7章。此外，这个配方还探讨了map-reduce处理的某些重要变体。
- en: 9.7 Implementing “there exists” processing
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7 实现“存在”处理
- en: 'The processing patterns we’ve been looking at can all be summarized with the
    universal quantifier, ∀, meaning for all. It’s been an implicit part of all of
    the processing definitions:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在研究的处理模式都可以用全称量化符∀来概括，意味着对于所有。这一直是所有处理定义的隐含部分：
- en: 'Map: For all items in the source, S, apply the map function, m(x). We can use
    the universal quantifier: ∀[x∈S]m(x).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射：对于源中的所有项，S，应用映射函数，m(x)。我们可以使用全称量化符：∀[x∈S]m(x)。
- en: 'Filter: This, also, means for all items in the source, S, pass those for which
    the filter function, f(x), is true. Here, also, we can use the universal quantifier:
    ∀[x∈S]x if f(x).'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤：这也意味着对于源中的所有项，S，传递那些过滤函数，f(x)，为真的项。在这里，我们也可以使用全称量化符：∀[x∈S]x if f(x)。
- en: 'Reduce: For all items in the source, use the given operator and base value
    to compute a summary. The universal quantification is implicit in the definition
    of operators ∑ [x∈S]x and ∏ [x∈S]x.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少：对于源中的所有项，使用给定的运算符和基数值来计算摘要。在运算符∑[x∈S]x和∏[x∈S]x的定义中隐含了全称量化。
- en: Contrast these universal functions with the cases where we are only interested
    in locating a single item. We often describe these cases as a search to show there
    exists at least one item where a condition is true. This can be described with
    the existential quantifier, ∃, meaning there exists.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些通用函数与仅对我们定位单个项感兴趣的情况进行对比。我们经常将这些情况描述为搜索，以表明至少存在一个项满足条件。这可以用存在量化符∃来描述，意味着存在。
- en: We’ll need to use some additional features of Python to create generator functions
    that stop when the first value matches some predicate. We’d like to emulate the
    short-circuit capabilities of the built-in any() and all() functions.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用Python的一些附加功能来创建生成器函数，当第一个值匹配某个谓词时停止。我们希望模拟内置的any()和all()函数的短路功能。
- en: 9.7.1 Getting ready
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7.1 准备工作
- en: For an example of an existence test, consider a function to determine if a number
    is prime or composite. A prime number has no factors other than 1 and itself.
    Numbers with multiple factors are called composite. The number 42 is composite
    because it has the numbers 2, 3, and 7 as prime factors.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个存在性测试的例子为例，考虑一个确定一个数是素数还是合数的函数。素数没有除了1和它自己之外的因子。具有多个因子的数被称为合数。数字42是合数，因为它有2、3和7作为素数因子。
- en: 'Finding if a number is prime number is the same as showing it is not composite.
    For any composite (or non-prime) number, n, the rule is this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 判断一个数是否为素数等同于证明它不是合数。对于任何合数（或非素数）数，n，规则是这样的：
- en: '![¬P (n ) = ∃2≤i<n(n ≡ 0 mod i) ](img/file66.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![¬P (n ) = ∃2≤i<n(n ≡ 0 mod i) ](img/file66.png)'
- en: A number, n, is not prime if there exists a value, i, between 2 and the number
    itself, that divides the number evenly. For a test to see if a number is prime,
    we don’t need to know all the factors. The existence of a single factor shows
    the number is composite.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在一个值i，介于2和该数本身之间，可以整除该数，则一个数n不是素数。为了测试一个数是否是素数，我们不需要知道所有的因子。单个因子的存在表明该数是合数。
- en: The overall idea is to iterate over the range of candidate numbers, breaking
    from the iteration when a factor is found. In Python, this early exit from a for
    statement is done with the break statement, shifting the semantics from “for all”
    to “there exists.” Because break is a statement, we can’t easily use a generator
    expression; we’re constrained to writing a generator function.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 整体思路是遍历候选数字的范围，在找到因子时退出迭代。在Python中，这种从for语句中的提前退出是通过break语句完成的，将语义从“对所有”转换为“存在”。因为break是一个语句，所以我们不能轻易使用生成器表达式；我们被迫编写生成器函数。
- en: (The Fermat test is generally more efficient than what we’re using for these
    examples, but it doesn’t involve a simple search for the existence of a factor.
    We’re using this as an illustration of search, not as an illustration of good
    primality tests.)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: (费马测试通常比我们在这些例子中使用的更有效，但它不涉及简单地搜索因子的存在。我们使用它作为搜索的示例，而不是作为良好素性测试的示例。)
- en: 9.7.2 How to do it...
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7.2 如何做到...
- en: 'In order to build this kind of search function, we’ll need to create a generator
    function that will complete processing when it finds the first match. One way
    to do this is with the break statement, as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这种搜索函数，我们需要创建一个生成器函数，当它找到第一个匹配项时将完成处理。一种方法是使用break语句，如下所示：
- en: 'Define a generator function to skip items until a test is passed. The generator
    can yield the first value that passes the predicate test. The generator works
    by applying a predicate function, fn(), to the items in a sequence of items of
    some type, T:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个生成器函数以跳过项，直到通过测试。生成器可以产生通过谓词测试的第一个值。生成器通过将谓词函数fn()应用于某些类型T的项序列中的项来工作：
- en: '[PRE72]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Define the specific predicate function for this application. Since we’re testing
    for being prime, we’re looking for any value that divides the target number, n,
    evenly. Here’s the kind of expression that’s needed:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此应用定义特定的谓词函数。由于我们正在测试是否为素数，我们正在寻找任何可以整除目标数n的值。以下是所需的表达式类型：
- en: '[PRE73]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Apply the find_first() search function with the given range of values and predicate.
    If the factors iterable has an item, then n is composite. Otherwise, there are
    no values in the factors iterable, which means n is a prime number:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用给定的值范围和谓词应用find_first()搜索函数。如果因子可迭代有项，则n是合数。否则，因子可迭代中没有值，这意味着n是素数：
- en: '[PRE74]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As a practical matter, we don’t need to test every number between two and n
    to see whether n is prime. It’s only necessary to test values, i, such that 2
    ≤ i < ⌊![√n-](img/file67.png)⌋.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要测试介于两个数和n之间的每个数来查看n是否为素数。只需要测试满足2 ≤ i < ⌊![√n-](img/file67.png)⌋的值i。
- en: 9.7.3 How it works...
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7.3 它是如何工作的...
- en: In the find_first() function, we introduce a break statement to stop processing
    the source iterable. When the for statement stops, the generator will reach the
    end of the function and return normally.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在find_first()函数中，我们引入了break语句来停止处理源可迭代。当for语句停止时，生成器将到达函数的末尾并正常返回。
- en: A client function consuming values from this generator will be given the StopIteration
    exception. The find_first() function can raise an exception, but it’s not an error;
    it’s the signal that an iterable has finished processing the input values.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 消费此生成器值的客户端函数将收到StopIteration异常。find_first()函数可以引发异常，但这不是错误；它是可迭代已处理输入值的信号。
- en: 'In this case, the StopIteration exception means one of two things:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，StopIteration异常意味着以下两种情况之一：
- en: If a value had been yielded previously, the value is a factor of n.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果之前已经产生了值，则该值是n的因子。
- en: If no value was yielded, then n is prime.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有产生值，则n是素数。
- en: This small change of breaking early from the for statement makes a dramatic
    difference in the meaning of the generator function. Instead of processing all
    values from the source, the find_first() generator will stop processing as soon
    as the predicate is true.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这种提前从for语句中退出的微小变化在生成器函数的意义上产生了巨大的差异。find_first()生成器将停止处理，而不是处理所有源值。
- en: 9.7.4 There’s more...
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7.4 更多...
- en: In the itertools module, there is an alternative to the find_first() function.
    The takewhile() function uses a predicate function to take values from the input
    while the predicate function is true. When the predicate becomes false, then the
    function stops consuming and producing values.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 itertools 模块中，find_first() 函数有一个替代方案。takewhile() 函数使用谓词函数从输入中取值，只要谓词函数为真。当谓词变为假时，函数停止消费和产生值。
- en: To use the takewhile() function, we need to invert our factor test. We need
    to consume values that are non-factors until we find the first factor. This leads
    to a change in the lambda from lambda i: n % i == 0 to lambda i: n % i != 0.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '要使用 takewhile() 函数，我们需要反转我们的因子测试。我们需要消费非因子值，直到我们找到第一个因子。这导致 lambda 表达式从 lambda
    i: n % i == 0 变为 lambda i: n % i != 0。'
- en: 'Let’s look at a test to see if 47 is prime. We need to check numbers in the
    range 2 to ![√ --- 49](img/file68.png) = 7:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个测试，看看 47 是否为质数。我们需要检查 2 到 ![√ --- 49](img/file68.png) = 7 范围内的数字：
- en: '[PRE75]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: For a prime number, like 47, none of the test values are factors. All these
    non-factor test values pass the takewhile() predicate because it’s always true.
    The resulting list is the same as the original set of test values.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 47 这样的质数，没有任何测试值是因子。所有这些非因子测试值都通过了 takewhile() 谓词，因为它是始终为真的。结果列表与原始测试值集合相同。
- en: For a composite number, the non-factor test values will be a subset of the test
    values. Some values will have been excluded because a factor was found.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个合数，非因子测试值将是测试值的一个子集。由于找到了一个因子，一些值已被排除。
- en: There are a number of additional functions in the itertools module that can
    be used to simplify complex map-reduce applications. We encourage you to look
    closely at this module.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: itertools 模块中还有许多其他函数可以用来简化复杂的 map-reduce 应用。我们鼓励您仔细研究这个模块。
- en: 9.7.5 See also
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7.5 参见
- en: In the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe earlier in this chapter, we made extensive use of immutable class definitions.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面的 [使用堆叠的生成表达式](ch013_split_000.xhtml#x1-5180003) 菜谱中，我们广泛使用了不可变类定义。
- en: See [https://projecteuler.net/problem=10](https://projecteuler.net/problem=10)
    for a challenging problem related to prime numbers less than 2 million. Parts
    of the problem seem obvious. It can be difficult, however, to test all those numbers
    for being prime.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关小于 200 万的质数相关的一个具有挑战性的问题，请参阅 [https://projecteuler.net/problem=10](https://projecteuler.net/problem=10)。问题的某些部分看起来很明显。然而，测试所有这些数字是否为质数可能很困难。
- en: The itertools module provides numerous functions that can simplify functional
    design.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: itertools 模块提供了许多函数，可以简化函数设计。
- en: Outside the standard library, packages like [Pyrsistent](https://pypi.org/project/pyrsistent/)
    offer functional programming components.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标准库之外，像 [Pyrsistent](https://pypi.org/project/pyrsistent/) 这样的包提供了函数式编程组件。
- en: 9.8 Creating a partial function
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.8 创建一个部分函数
- en: 'When we look at functions such as reduce(), sorted(), min(), and max(), we
    see that we’ll often have some argument values that change very rarely, if at
    all. In a particular context, they’re essentially fixed. For example, we might
    find a need to write something like this in several places:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 reduce()、sorted()、min() 和 max() 等函数时，我们会看到我们经常会遇到一些参数值几乎不会改变，或者在特定上下文中实际上是固定的。例如，我们可能会在几个地方需要编写类似以下内容：
- en: '[PRE76]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Of the three argument values for reduce(), only one – the iterable to process
    – actually changes. The operator and the initial value argument values are essentially
    fixed at operator.mul and 1.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在 reduce() 的三个参数值中，只有一个——要处理的可迭代对象——实际上会改变。操作符和初始值参数值基本上固定在 operator.mul 和 1。
- en: 'Clearly, we can define a whole new function for this:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以为这个定义一个新的函数：
- en: '[PRE77]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Python has a few ways to simplify this pattern so we don’t have to repeat the
    boilerplate def and return statements.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有几种方法可以简化这个模式，这样我们就不必重复编写样板 def 和 return 语句。
- en: The goal of this recipe is different from providing general default values.
    A partial function doesn’t provide a way for us to override the defaults. A partial
    function has specific values bound when it is defined. The idea is to be able
    to create many partial functions, each with specific argument values bound in
    advance. This is also sometimes called a closure, but applied to some of the parameters.
    See [Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    in Chapter [3](ch007_split_000.xhtml#x1-1610003) for more examples of partial
    function definition.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的目标与提供一般默认值不同。部分函数不提供覆盖默认值的方法。部分函数在定义时绑定特定的值。想法是能够创建许多部分函数，每个函数在预先绑定特定的参数值。这有时也被称为闭包，但应用于一些参数。参见第[3](ch007_split_000.xhtml#x1-1610003)章中的[基于部分函数选择参数顺序](ch007_split_001.xhtml#x1-1940006)以获取更多部分函数定义的示例。
- en: 9.8.1 Getting ready
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.1 准备工作
- en: Some statistical modeling is done with standardized values, sometimes called
    z-scores. The idea is to standardize a raw measurement onto a value that can be
    easily compared to a normal distribution, and easily compared to related numbers
    that may be measured in different units.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 一些统计建模使用标准化值进行，有时称为z分数。想法是将原始测量值标准化到一个可以轻松与正态分布比较的值，并且可以轻松与可能以不同单位测量的相关数字比较。
- en: 'The calculation is this:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 计算过程如下：
- en: '![z = x−-μ- σ ](img/file69.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![z = x−-μ- σ ](img/file69.png)'
- en: Here, x is a raw value, μ is the population mean, and σ is the population standard
    deviation. The value z will have a mean of 0 and a standard deviation of 1, providing
    a standardized value. We can use this value to spot outliers – values that are
    suspiciously far from the mean. We expect that (approximately) 99.7% of our z
    values will be between -3 and +3.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，x是一个原始值，μ是总体均值，σ是总体标准差。z的值将具有0的均值和1的标准差，提供标准化值。我们可以使用这个值来发现异常值——那些可疑地远离均值的值。我们预计（大约）99.7%的z值将在-3和+3之间。
- en: 'We could define a function to compute standard scores, like this:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个函数来计算标准分数，如下所示：
- en: '[PRE78]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This standardize() function will compute a z-score from a raw score, x. When
    we use this function in a practical context, we’ll see that there are two kinds
    of argument values for the parameters:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个standardize()函数将从原始分数x计算z分数。当我们在这个实际应用中使用这个函数时，我们会看到参数有两种类型的值：
- en: The argument values for the mean and stdev parameters are essentially fixed.
    Once we’ve computed the population values, we’ll have to provide the same two
    values to the standardize() function over and over again.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值和stdev参数的值基本上是固定的。一旦我们计算了总体值，我们就必须反复将相同的两个值提供给standardize()函数。
- en: The value for the x parameter will vary each time we evaluate the standardize()
    function.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次评估standardize()函数时，x参数的值都会变化。
- en: 'Let’s work with a collection of data samples with two variables, x and y. These
    pairs are defined by the DataPair class:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理一个包含两个变量x和y的数据样本集合。这些对由DataPair类定义：
- en: '[PRE79]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As an example, we’ll compute a standardized value for the x attribute. This
    means computing the mean and standard deviation for the x values. Then, we’ll
    need to apply the mean and standard deviation values to standardize the data in
    our collection. The computation looks like this:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将计算x属性的标准化值。这意味着计算x值的平均值和标准差。然后，我们需要将平均值和标准差值应用于标准化我们收集中的数据。计算过程如下：
- en: '[PRE80]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Providing the mean_x, and stdev_x values each time we evaluate the standardize()
    function can clutter an algorithm with details that aren’t deeply important.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 每次评估standardize()函数时提供mean_x和stdev_x值可能会使算法充斥着不重要的细节。
- en: We can use a partial function to simplify this use of standardize() with two
    fixed argument values and one that is left to vary.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用部分函数简化使用具有两个固定参数值和一个可变参数的standardize()的使用。
- en: 9.8.2 How to do it...
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.2 如何实现...
- en: 'To simplify using a function with a number of fixed argument values, we can
    create a partial function. This recipe will show two ways to create a partial
    functions as separate mini-recipes:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化使用具有多个固定参数值的函数，我们可以创建一个部分函数。这个菜谱将展示两种创建部分函数的方法，作为独立的迷你菜谱：
- en: Using the partial() function from the functools module to build a new function
    from the full standardize() function
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用functools模块中的partial()函数从完整的standardize()函数构建一个新的函数
- en: Creating a lambda object to supply argument values that don’t change
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个lambda对象来提供不变的参数值
- en: Using functools.partial()
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用functools.partial()
- en: 'Import the partial() function from the functools module:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 functools 模块导入 partial() 函数：
- en: '[PRE81]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a new function using partial(). We provide the base function, plus the
    positional arguments that need to be included. Any parameters that are not supplied
    when the partial is defined must be supplied when the partial is evaluated: [firstline=79,lastline=79,gobble=4][python]src/ch09/recipe˙08.py'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 partial() 创建一个新的函数。我们提供基本函数，以及需要包含的位置参数。当定义 partial 时未提供的任何参数必须在评估 partial
    时提供：[firstline=79,lastline=79,gobble=4][python]src/ch09/recipe˙08.py
- en: We’ve provided fixed values for the first two parameters, mean and stdev, of
    the standardize() function. We can now use the z() function with a single value,
    z(a), and it will evaluate the expression standardize(mean_x, stdev_x, a).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为 standardize() 函数的前两个参数，即平均值和标准差，提供了固定值。现在我们可以使用 z() 函数的单个值，z(a)，它将评估表达式
    standardize(mean_x, stdev_x, a)。
- en: Creating a lambda object
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 lambda 对象
- en: 'Define a lambda object that binds the fixed parameters: [firstline=105,lastline=105,gobble=8][python]src/ch09/recipe˙08.py'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个绑定固定参数的 lambda 对象：[firstline=105,lastline=105,gobble=8][python]src/ch09/recipe˙08.py
- en: 'Assign this lambda to a variable to create a callable object, z(): [firstline=105,lastline=105,gobble=4][python]src/ch09/recipe˙08.py'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此 lambda 分配给变量以创建一个可调用的对象，z()：[firstline=105,lastline=105,gobble=4][python]src/ch09/recipe˙08.py
- en: This provides fixed values for the first two parameters, mean and stdev, of
    the standardize() function. We can now use the z() lambda object with a single
    value, z(a), and it will evaluate the expression standardize(mean_x, stdev_x, a).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这为 standardize() 函数的前两个参数，即平均值和标准差，提供了固定值。现在我们可以使用 z() lambda 对象的单个值，z(a)，它将评估表达式
    standardize(mean_x, stdev_x, a)。
- en: 9.8.3 How it works...
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.3 工作原理...
- en: 'Both techniques create a callable object – a function – named z() that has
    the values for mean_x and stdev_x already bound to the first two positional parameters.
    With either approach, we can now have processing that can look like this:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都创建了一个可调用的对象——一个函数——名为 z()，它已经将 mean_x 和 stdev_x 的值绑定到前两个位置参数。使用这两种方法中的任何一种，我们现在都可以进行如下处理：
- en: '[firstline=107,lastline=108,gobble=4][python]src/ch09/recipe˙08.py'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[firstline=107,lastline=108,gobble=4][python]src/ch09/recipe˙08.py'
- en: We’ve applied the z() function to each set of data. Because z() is a partial
    function and has some parameters already applied, its use is simplified.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 z() 函数应用于每一组数据。因为 z() 是一个部分函数并且已经应用了一些参数，所以它的使用被简化了。
- en: 'There’s one significant difference between the two techniques for creating
    the z() function:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 z() 函数的两种技术之间有一个显著的区别：
- en: The partial() function binds the actual values of the parameters. Any subsequent
    change to the variables that were used will not change the definition of the partial
    function that’s created.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: partial() 函数绑定参数的实际值。任何后续对这些变量所做的更改都不会改变创建的部分函数的定义。
- en: The lambda object binds the variable name, not the value. Any subsequent change
    to the variable’s value will change the way the lambda behaves.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda 对象绑定变量名，而不是值。任何后续对变量值的更改都会改变 lambda 的行为方式。
- en: 'We can modify the lambda slightly to bind specific values instead of names:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微修改 lambda 以绑定特定值而不是名称：
- en: '[firstline=131,lastline=131,gobble=4][python]src/ch09/recipe˙08.py'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[firstline=131,lastline=131,gobble=4][python]src/ch09/recipe˙08.py'
- en: This extracts the current values of mean_x and stdev_x to create default values
    for the lambda object’s parameters. The values of mean_x and stdev_x are now irrelevant
    to the proper operation of the lambda object, z().
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提取当前 mean_x 和 stdev_x 的值以创建 lambda 对象参数的默认值。mean_x 和 stdev_x 的值现在与 lambda
    对象 z() 的正确操作无关。
- en: 9.8.4 There’s more...
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.4 更多内容...
- en: We can provide keyword argument values as well as positional argument values
    when creating a partial function. While this works nicely in general, there are
    a few cases where it doesn’t work.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建部分函数时，我们可以提供关键字参数值以及位置参数值。虽然这在一般情况下工作得很好，但还有一些情况它不起作用。
- en: We started this recipe looking at the reduce() function. Interestingly, this
    function is one example of functions that can’t be trivially turned into a partial
    function. The parameters aren’t in the ideal order for creating a partial and
    it doesn’t permit providing argument values by name.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始这个配方时查看 reduce() 函数。有趣的是，这个函数是函数不能轻易转换为部分函数的一个例子。参数的顺序不是创建部分函数的理想顺序，并且它不允许通过名称提供参数值。
- en: 'It appears as though the reduce() function is defined like this:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: reduce() 函数似乎是这样定义的：
- en: '[PRE82]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If this were the actual definition, we could do this:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是实际的定义，我们可以这样做：
- en: '[PRE83]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Practically, the preceding example raises a TypeError. It doesn’t work because
    the definition of reduce() does not take keyword argument values. Consequently,
    we can’t easily create partial functions that use it.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，前面的例子会引发一个 TypeError。它不起作用，因为 reduce() 的定义不接受关键字参数值。因此，我们无法轻松地创建使用它的部分函数。
- en: 'This means that we’re forced to use the following lambda technique:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们被迫使用以下 lambda 技术：
- en: '[PRE84]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In Python, a function is an object. We’ve seen numerous ways that functions
    can be arguments to other functions. A function that accepts or returns another
    function as an argument is sometimes called a higher-order function.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，函数是一个对象。我们已经看到了许多函数可以作为其他函数的参数的方式。接受或返回另一个函数作为参数的函数有时被称为高阶函数。
- en: 'Similarly, functions can also return a function object as a result. This means
    that we can create a function like this:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，函数也可以返回一个函数对象作为结果。这意味着我们可以创建一个像这样的函数：
- en: '[PRE85]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, we’ve defined a function over a sequence of type DataPair, which are (x,y)
    samples. We’ve computed the mean and standard deviation of the x attribute of
    each sample. We then created a partial function that can standardize scores based
    on the computed statistics. The result of this function is a function we can use
    for data analysis.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个在类型为 DataPair 的序列上的函数，这些是 (x,y) 样本。我们计算了每个样本的 x 属性的平均值和标准差。然后我们创建了一个部分函数，可以根据计算出的统计数据标准化分数。这个函数的结果是一个我们可以用于数据分析的函数。
- en: 'The following example shows how this newly created function is used:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用这个新创建的函数：
- en: '[PRE86]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The result of the prepare_z() function is a callable object that will standardize
    a score based on the computed mean and standard deviation.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: prepare_z() 函数的结果是一个可调用对象，它将根据计算出的平均值和标准差标准化分数。
- en: 9.8.5 See also
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.5 参考阅读
- en: See [Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    in Chapter [3](ch007_split_000.xhtml#x1-1610003) for more examples of partial
    function definition.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见第[3](ch007_split_000.xhtml#x1-1610003)章中的[Picking an order for parameters
    based on partial functions](ch007_split_001.xhtml#x1-1940006)以获取部分函数定义的更多示例。
- en: 9.9 Writing recursive generator functions with the yield from statement
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.9 使用 yield from 语句编写递归生成器函数
- en: Many algorithms can be expressed neatly as recursions. In the [Designing recursive
    functions around Python’s stack limits](ch007_split_001.xhtml#x1-2090008) recipe,
    we looked at some recursive functions that could be optimized to reduce the number
    of function calls.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 许多算法可以简洁地表示为递归。在[围绕 Python 的堆限制设计递归函数](ch007_split_001.xhtml#x1-2090008)的配方中，我们查看了一些可以优化以减少函数调用的递归函数。
- en: When we look at some data structures, we see that they involve recursion. In
    particular, JSON documents (as well as XML and HTML documents) can have a recursive
    structure. A JSON document is a complex object that can contain other complex
    objects within it.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看某些数据结构时，我们发现它们涉及递归。特别是，JSON 文档（以及 XML 和 HTML 文档）可以具有递归结构。JSON 文档是一个复杂对象，它可以包含其内的其他复杂对象。
- en: In many cases, there are advantages to using generators for processing these
    kinds of structures. In this recipe, we’ll look at ways to handle recursive data
    structures with generator functions.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用生成器处理这些结构具有优势。在这个配方中，我们将查看处理递归数据结构的方法。
- en: 9.9.1 Getting ready
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9.1 准备工作
- en: In this recipe, we’ll look at a way to search for all matching values in a complex,
    recursive data structure. When working with complex JSON documents, they often
    contain dict-of-dict, dict-of-list, list-of-dict, and list-of-list structures.
    Of course, a JSON document is not limited to two levels; dict-of-dict can really
    mean dict-of-dict-of.... Similarly, dict-of-list could mean dict-of-list-of....
    The search algorithm must descend through the entire structure looking for a particular
    key or value.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将查看一种在复杂、递归数据结构中搜索所有匹配值的方法。当处理复杂的 JSON 文档时，它们通常包含 dict-of-dict、dict-of-list、list-of-dict
    和 list-of-list 结构。当然，JSON 文档不仅限于两层；dict-of-dict 实际上可以意味着 dict-of-dict-of...。同样，dict-of-list
    可以意味着 dict-of-list-of...。搜索算法必须遍历整个结构以查找特定的键或值。
- en: 'A document with a complex structure might look like this:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有复杂结构的文档可能看起来像这样：
- en: '[PRE87]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The value "value" can be found in three places:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 值 "value" 可以在三个地方找到：
- en: '["array", 0, "array_item_key1"]: This path starts with the top-level field
    named array, then visits item zero of a list, then a field named array_item_key1.'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '["array", 0, "array_item_key1"]：此路径从顶级字段名为 array 开始，然后访问列表中的第 0 个项目，然后是名为 array_item_key1
    的字段。'
- en: '["field2"]: This path has just a single field name where the value is found.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '["field2"]：此路径只有一个字段名，其中找到了值。'
- en: '["object", "attribute1"]: This path starts with the top-level field named object,
    then the child, attribute1, of that field.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '["object", "attribute1"]：此路径以顶级字段object开头，然后是该字段的子字段attribute1。'
- en: A find_value() function should yield all these paths when it searches the overall
    document for the target value. The core algorithm for this is a depth-first search.
    The output from this function must be a list of paths that identify the target
    value. Each path will be a sequence of field names or field names mixed with index
    positions.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: find_value()函数应在搜索整个文档以查找目标值时产生所有这些路径。这个算法的核心是深度优先搜索。此函数的输出必须是一个路径列表，用于标识目标值。每个路径将是一个字段名序列或字段名与索引位置的混合。
- en: 9.9.2 How to do it...
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9.2 如何操作...
- en: 'We’ll start with an overview of the depth-first algorithm to visit all of the
    nodes in a JSON document:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从概述深度优先算法开始，以访问JSON文档中的所有节点。
- en: 'Start with a sketch of the function to process each of the alternative structures
    in the overall data structure. Here are the imports and some type hints:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从处理整体数据结构中每个替代结构的函数草图开始。以下是导入和一些类型提示：
- en: '[PRE88]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here is the sketch of the function:'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是函数的草图：
- en: '[PRE89]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here’s a starting version to look at each key of a dictionary. This replaces
    the # apply find_value to each key in dnode line in the preceding code. Test this
    to be sure the recursion works properly: [firstline=58,lastline=60,gobble=8][python]src/ch09/recipe˙10.py'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个起始版本，用于查看字典的每个键。这替换了前面代码中的# apply find_value to each key in dnode行。测试以确保递归正常工作：[firstline=58,lastline=60,gobble=8][python]src/ch09/recipe˙10.py
- en: 'Replace the inner for with a yield from statement: [firstline=98,lastline=100,gobble=8][python]src/ch09/recipe˙10.py'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内部的for循环替换为yield from语句：[firstline=98,lastline=100,gobble=8][python]src/ch09/recipe˙10.py
- en: 'This has to be done for the list case as well. Start an examination of each
    item in the list: [firstline=62,lastline=64,gobble=8][python]src/ch09/recipe˙10.py'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也必须应用于列表情况。开始检查列表中的每个项目：[firstline=62,lastline=64,gobble=8][python]src/ch09/recipe˙10.py
- en: 'Replace the inner for with a yield from statement: [firstline=102,lastline=104,gobble=8][python]src/ch09/recipe˙10.py'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内部的for循环替换为yield from语句：[firstline=102,lastline=104,gobble=8][python]src/ch09/recipe˙10.py
- en: 'The complete depth-first find_value() search function, when complete, will
    look like this:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 当完整时，完整的深度优先find_value()搜索函数将看起来像这样：
- en: '[PRE90]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'When we use the find_value() function, it looks like this:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用find_value()函数时，它看起来像这样：
- en: '[PRE91]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The resulting list has three items. Each of these is a list of keys that form
    a path to an item with the target value of "value".
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 结果列表有三个项目。这些项目中的每一个都是一个键列表，这些键构成了一条到具有“value”目标值的项的路径。
- en: 9.9.3 How it works...
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9.3 它是如何工作的...
- en: For background, see the [Writing generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)
    recipe in this chapter.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 关于背景信息，请参阅本章中的[使用yield语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)配方。
- en: 'The yield from statement is shorthand for:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: yield from语句是以下内容的简写：
- en: '[firstline=135,lastline=136,gobble=8][python]src/ch09/recipe˙10.py'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '[firstline=135,lastline=136,gobble=8][python]src/ch09/recipe˙10.py'
- en: The yield from statement lets us write a succinct recursive algorithm that will
    behave as an iterator and properly yield multiple values. It saves the overhead
    of a boilerplate for statement.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: yield from语句让我们能够编写简洁的递归算法，该算法将表现得像一个迭代器，并正确地产生多个值。它节省了样板for语句的开销。
- en: This can also be used in contexts that don’t involve a recursive function. It’s
    entirely sensible to use a yield from statement anywhere that an iterable result
    is involved. It’s a handy simplification for recursive functions because it preserves
    a clearly recursive structure.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以用于不涉及递归函数的上下文中。在任何涉及可迭代结果的上下文中使用yield from语句是完全合理的。对于递归函数来说，这是一个方便的简化，因为它保留了清晰的递归结构。
- en: 9.9.4 There’s more...
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9.4 还有更多...
- en: Another common style of definition assembles a list of items using append operations.
    We can rewrite this into an iterator and avoid the overhead of building and mutating
    a list object.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的定义方式是使用append操作来组装项目列表。我们可以将其重写为一个迭代器，以避免构建和修改列表对象的开销。
- en: 'When factoring a number, we can define the set of prime factors of a number,
    x, like this:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在分解一个数字时，我们可以定义一个数字x的质因数集合，如下所示：
- en: '![ ( |{ F(x) = x if x is prime |( x √-- n∪ F (n) if x ≡ 0 mod n and 2 ≤ n ≤
    x ](img/file70.png)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ F(x) = x if x is prime |( x √-- n∪ F (n) if x ≡ 0 mod n and 2 ≤ n ≤
    x ](img/file70.png)'
- en: If the value, x, is prime, it has only itself in the set of prime factors. Otherwise,
    there must be some prime number, n, which is the least factor of x. We can assemble
    a set of factors starting with this number n and then append all factors of ![xn](img/file71.png).
    To be sure that only prime factors are found, n must be prime. If we search ascending
    values of n, starting from 2, we’ll find prime factors before finding composite
    factors.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值 x 是质数，它在质因子集合中只有它自己。否则，必须有一些质数 n，它是 x 的最小因子。我们可以从这个数字 n 开始组装一个因子集合，然后追加
    ![xn](img/file71.png) 的所有因子。为了确保只找到质因子，n 必须是质数。如果我们从 2 开始搜索 n 的递增值，我们将在找到合数因子之前找到质数因子。
- en: 'An eager approach builds a complete list of factors. A lazy approach be be
    a generator of factors for a consumer. Here’s an eager list-building function:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 一种急切的方法是构建一个完整的因子列表。一种懒惰的方法可以是生成器，为消费者提供因子。以下是一个急切构建列表的函数：
- en: '[PRE92]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This factor_list() function will build a list object. If a factor, n, is found,
    it will start a list with that factor. It will then extend the list with the factors
    built from the value of x // n. If there are no factors of x, then the value is
    prime, and this returns a list with only the value of x.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 factor_list() 函数将构建一个列表对象。如果找到一个因子 n，它将以该因子开始一个列表。然后，它将使用 x // n 的值构建的因子扩展列表。如果没有
    x 的因子，那么这个值是质数，并且它将返回一个只包含 x 值的列表。
- en: (This has an inefficiency stemming from the way this searches for composite
    numbers as well as prime numbers. For example, after testing 2 and 3, this will
    also test 4 and 6, even though they’re composite and all of their factors have
    already been tested. The example is centered on list-building, not efficient factoring
    of numbers.)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: （这有一个效率低下的原因，因为它以这种方式搜索合数和质数。例如，在测试 2 和 3 之后，它还将测试 4 和 6，即使它们是合数，并且它们的所有因子都已经测试过了。这个例子集中在列表构建上，而不是高效地分解数字。）
- en: 'We can rewrite this as an iterator by replacing the recursive calls with yield from
    statements. The function will look like this:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用 yield from 语句替换递归调用将此重写为迭代器。函数将看起来像这样：
- en: '[PRE93]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When a factor is found, the function will yield the factor, n, followed by all
    other factors found via a recursive call to factor_iter(). If no factors are found,
    the function will yield the prime number, x, and nothing more.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到一个因子时，该函数将产生因子 n，然后通过递归调用 factor_iter() 找到所有其他因子。如果没有找到因子，该函数将产生质数 x，不再产生其他内容。
- en: 'Using an iterator allows the client of this function to build any kind of collection
    from the factors. Instead of being limited to always creating a list object, we
    can create a multiset using the collections.Counter class. It would look like
    this:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器允许此函数的客户从因子构建任何类型的集合。我们不仅可以创建列表对象，还可以使用 collections.Counter 类创建多重集。它看起来像这样：
- en: '[PRE94]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This shows us that:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明：
- en: '![384 = 27 × 3 ](img/file72.png)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![384 = 27 × 3 ](img/file72.png)'
- en: In some cases, this kind of multiset can be easier to work with than a simple
    list of factors.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这种多重集可能比简单的因子列表更容易处理。
- en: What’s important is that the multiset was created directly from the factor_iter()
    iterator without creating any intermediate list objects. This kind of optimization
    lets us build complex algorithms that aren’t forced to consume large volumes of
    memory.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这个多重集是直接从 factor_iter() 迭代器创建的，而没有创建任何中间列表对象。这种优化让我们能够构建不强制消耗大量内存的复杂算法。
- en: 9.9.5 See also
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9.5 参见
- en: In the [Designing recursive functions around Python’s stack limits](ch007_split_001.xhtml#x1-2090008)
    recipe, earlier in this chapter, we covered the core design patterns for recursive
    functions. This recipe provides an alternative way to create the results.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面的[围绕 Python 栈限制设计递归函数](ch007_split_001.xhtml#x1-2090008)配方中，我们介绍了递归函数的核心设计模式。这个配方提供了一种创建结果的替代方法。
- en: For background, see the [Writing generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)
    recipe in this chapter.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于背景，请参阅本章中的[使用 yield 语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)配方。
- en: Join our community Discord space
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
