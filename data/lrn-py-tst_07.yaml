- en: Chapter 7. Test-driven Development Walk-through
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。测试驱动开发演练
- en: In this chapter, we're not going to talk about new techniques of testing in
    Python, and we're not going to spend much time talking about the philosophy of
    testing. Instead, what we're going to do is a step-by-step walk-through of an
    actual development process. Your humble and sadly fallible author has commemorated
    his mistakes—and the ways that testing helped him fix them—while developing part
    of a personal scheduling program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会讨论Python的新测试技术，也不会花太多时间讨论测试的哲学。相反，我们将逐步演示一个实际的开发过程。谦逊且不幸易犯错的作者在开发个人日程安排程序的一部分时，记录了他的错误——以及测试如何帮助他修复这些错误。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing a testable specification
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可测试规范
- en: Writing unit tests that drive the development process
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写驱动开发过程的单元测试
- en: Writing code that complies with the specification and unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写符合规范和单元测试的代码
- en: Using the testable specification and unit tests to help debug
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可测试规范和单元测试来帮助调试
- en: You'll be prompted to design and build your own module as you read through this
    chapter, so that you can walk through your own process as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章时，你将被提示设计和构建自己的模块，这样你就可以走自己的过程。
- en: Writing the specification
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写规范
- en: As usual, the process starts with a written specification. The specification
    is a `doctest` that we learned in [Chapter 2](ch02.html "Chapter 2. Working with
    doctest"), *Working with doctest*, and [Chapter 3](ch03.html "Chapter 3. Unit
    Testing with doctest"), *Unit Testing with doctest*, so the computer can use it
    to check the implementation. The specification isn't strictly a set of unit tests,
    though the discipline of unit testing has been sacrificed (for the moment) in
    exchange for making the document more accessible to a human reader. That's a common
    trade-off, and it's fine as long as you make up for it by also writing unit tests
    covering the code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，这个过程从一份书面规范开始。规范是一个我们在[第2章](ch02.html "第2章。使用doctest")和[第3章](ch03.html
    "第3章。使用doctest进行单元测试")中学习的`doctest`，即*使用doctest*，所以计算机可以使用它来检查实现。尽管规范并不是一组单元测试，但为了使文档更易于人类读者理解，我们牺牲了单元测试的纪律（暂时如此）。这是一个常见的权衡，只要你也编写覆盖代码的单元测试来弥补，那就没问题。
- en: The goal of the project in this chapter is to make a Python package capable
    of representing personal time management information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章项目的目标是创建一个能够表示个人时间管理信息的Python包。
- en: 'The following code goes in a file called `docs/outline.txt`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码放在一个名为`docs/outline.txt`的文件中：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This `doctest` will serve as a testable specification for my project, which
    means that it will be the foundation stone for all of my tests and my program
    code that will be built on. Let''s look at each section in more detail:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`doctest`将作为我项目的可测试规范，这意味着它将成为所有测试和将要构建的程序代码的基础。让我们更详细地看看每个部分：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code consists of some introductory English text, and a couple
    of `import` statements that bring in code that we need for these tests. By doing
    so, they also tell us about some of the structure of the `planner` package. It
    contains a module called `data` that defines `Activity` and `Status`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码包含一些介绍性英文文本，以及几个`import`语句，它们引入了我们需要用于这些测试的代码。通过这样做，它们也告诉我们`planner`包的一些结构。它包含一个名为`data`的模块，该模块定义了`Activity`和`Status`。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding tests describe some of the desired behavior of `the Schedule`
    instances when interacting with the `Activity` and `Status` objects. According
    to these tests, a `Schedule` instance must accept an `Activity` or `Status` object
    as the parameter of its `add` and `remove` methods; once added, the `in` operator
    must return `True` for an object until it is removed. Furthermore, the two `Activity`
    instances that have the same parameters must be treated as the same object by
    `Schedule`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段测试描述了`Schedule`实例与`Activity`和`Status`对象交互时的一些期望行为。根据这些测试，`Schedule`实例必须接受`Activity`或`Status`对象作为其`add`和`remove`方法的参数；一旦添加，`in`运算符必须返回`True`，直到对象被移除。此外，具有相同参数的两个`Activity`实例必须被`Schedule`视为同一个对象：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding test code describes what should happen when overlapping activities
    are added to a schedule. Specifically, a `ScheduleError` exception should be raised:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段测试代码描述了当将重叠活动添加到日程安排中时应该发生的情况。具体来说，应该抛出一个`ScheduleError`异常：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding test code describes what should happen when overlapping statuses
    are added to a schedule: the schedule should accept them. Furthermore, if a status
    and an activity overlap, they can still both be added:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试代码描述了当将重叠状态添加到日程安排时应该发生什么：日程安排应该接受它们。此外，如果一个状态和一个活动重叠，它们仍然都可以被添加：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code describes how schedule storage should work. It also tells
    us that the `planner` package needs to contain a `persistence` module that, in
    turn, should contain `File`. It also tells us that `Schedule` instances should
    have `load` and `store` methods, and that the `==` operator should return `True`
    when they contain the same data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码描述了日程存储应该如何工作。它还告诉我们，`planner` 包需要包含一个 `persistence` 模块，该模块反过来应该包含 `File`。它还告诉我们，`Schedule`
    实例应该有 `load` 和 `store` 方法，并且当它们包含相同的数据时，`==` 操作符应该返回 `True`。
- en: Try it for yourself – what are you going to do?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下你自己——你打算做什么？
- en: 'It''s time for you to come up with a project of your own, something you can
    work on for yourself. We step through the development process:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候你自己想出一个项目了，一个你可以自己工作的项目。我们逐步通过开发过程：
- en: Think of a project of approximately the same complexity as the one described
    in this chapter. It should be a single module or a few modules in a single package.
    It should also be something that interests you, which is why I haven't given you
    a specific assignment here.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想想一个与本章中描述的项目大致相同复杂性的项目。它应该是一个单独的模块或一个包中的几个模块。它还应该是你感兴趣的东西，这就是为什么我没有在这里给你一个具体的任务。
- en: Imagine that the project is already done, and you need to write a description
    of what you've done, along with a little bit of demonstration code. Then go ahead
    and write your description and demo code in the form of a `doctest` file.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象一下项目已经完成，你需要编写一个描述你所做的工作，以及一些演示代码的描述。然后继续编写你的描述和演示代码，以 `doctest` 文件的形式。
- en: As you're writing the `doctest` file, watch out for places where your original
    idea has to change a little bit to make the demo easier to write or work better.
    When you find such cases, pay attention to them! At this stage, it's better to
    change the idea a little bit and save yourself effort all through the process.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你编写 `doctest` 文件时，要注意你的原始想法需要稍作改变以使演示更容易编写或工作得更好的地方。当你找到这样的案例时，请注意它们！在这个阶段，最好是稍微改变一下想法，并在整个过程中节省自己精力。
- en: Wrapping up the specification
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结规范
- en: We've now got testable specifications for a couple of moderately-sized projects—yours
    and mine. These will help us to write unit tests and code, and they'll give us
    a sense of how complete each project is as a whole.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为几个中等规模的项目——你的和我的——有了可测试的规范。这将帮助我们编写单元测试和代码，并让我们对每个项目作为一个整体完成的情况有一个整体的认识。
- en: In addition, the process of writing code into the `doctest` gave us a chance
    to test-drive our ideas. We've probably improved on our projects a little bit
    by using them in a concrete manner, even though the project implementation is
    still merely imaginary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将代码写入 `doctest` 的过程给了我们测试驱动我们想法的机会。尽管项目实现仍然只是想象中的，但我们可能通过具体使用它们来稍微改进了我们的项目。
- en: Once again, it's important that we have these tests written before writing the
    code that they will test. By writing the tests first, we give ourselves a touchstone
    that we can use in order to judge how well our code conforms to what we intended.
    If we write the code first, and then the tests, all we end up doing is enshrining
    what the code actually does—as opposed to what we meant for it to do—into the
    tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，我们在编写将要测试的代码之前编写这些测试是非常重要的。通过先编写测试，我们为自己提供了一个试金石，我们可以用它来判断我们的代码是否符合我们的意图。如果我们先编写代码，然后再编写测试，最终我们只是将代码实际执行的行为——而不是我们希望它执行的行为——嵌入到测试中。
- en: Writing initial unit tests
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写初始单元测试
- en: Since the specification doesn't contain unit tests, there's still a need for
    unit tests before the coding of the module can begin. The `planner.data` classes
    are the first target for the implementation, so they're the first ones to get
    the tests.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于规范中不包含单元测试，在开始模块编码之前仍然需要单元测试。`planner.data` 类是实施的第一目标，因此它们是第一个接受测试的。
- en: Activities and statuses are defined to be very similar, so their test modules
    are also similar. They're not identical, though, and they're not required to have
    any particular inheritance relationship; so the tests remain distinct.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 活动和状态被定义为非常相似，因此它们的测试模块也是相似的。尽管它们并不完全相同，也不需要具有任何特定的继承关系；因此测试仍然是独立的。
- en: 'The following tests are in `tests/test_activities.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试位于 `tests/test_activities.py`：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s take a look at the following code, step-by-step:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地看看以下代码：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `test_valid` method checks whether the constructor works correctly when
    all of the parameters are correct. This is an important test, because it defines
    what correct behavior should be normally. We need more tests, though, to define
    correct behavior in abnormal situations:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_valid` 方法检查当所有参数都正确时构造函数是否工作正常。这是一个重要的测试，因为它定义了正常情况下应该是什么正确的行为。然而，我们还需要更多的测试来定义在异常情况下的正确行为：'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we''re making sure that you can''t create an activity that ends before
    it begins. That doesn''t make any sense, and can easily throw off assumptions
    made during the implementation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们确保不能创建一个在开始之前就结束的活动。这没有意义，并且很容易在实现过程中导致假设出错：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We don''t want extremely short activities, either. In the real world, an activity
    that takes no time is meaningless, so we have a test here to make sure that such
    things are not allowed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不希望活动非常短。在现实世界中，耗时为零的活动是没有意义的，所以我们在这里有一个测试来确保不允许这种情况发生：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While `repr(activity)` isn't likely to be used in any production code paths,
    it's handy during development and debugging. This test defines how the text representation
    of an activity ought to look, to make sure that it contains the desired information.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `repr(activity)` 在任何生产代码路径中可能不会被使用，但在开发和调试期间非常方便。这个测试定义了活动文本表示应该看起来是什么样子，以确保它包含所需的信息。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `repr` function is often useful during debugging, because it attempts to
    take any object and turn it into a string that represents that object. This is
    distinct from the `str` function, because `str` tries to turn the object into
    a string that is convenient for humans to read. The `repr` function, on the other
    hand, tries to create a string containing code that will recreate the object.
    That''s a slightly tough concept, so here''s an example contrasting `str` and
    `repr`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`repr` 函数在调试期间通常很有用，因为它试图将任何对象转换成一个表示该对象的字符串。这与 `str` 函数不同，因为 `str` 尝试将对象转换成一个对人类阅读方便的字符串。另一方面，`repr`
    函数试图创建一个包含代码的字符串，该代码可以重新创建对象。这是一个稍微有点难理解的概念，所以这里有一个对比 `str` 和 `repr` 的例子：'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's up to the objects stored in a schedule to decide whether they are exclusive
    with other objects they overlap. Specifically, activities are supposed to exclude
    each other, so we check this here. We're using a mock object for the main activity,
    but we're being a bit lazy and use a real `Activity` instance to compare it against,
    trusting that there won't be a problem in this case. We don't expect that `Activity.excludes`
    will do much more than apply the `isinstance` function to its parameter, so there's
    not much that an error in the constructor can do to mess things up.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在日程表中的对象决定它们是否与其他它们重叠的对象互斥。具体来说，活动应该相互排除，所以我们在这里进行检查。我们使用一个模拟对象作为主要活动，但我们有点偷懒，使用一个真实的
    `Activity` 实例进行比较，相信在这种情况下不会有问题。我们预计 `Activity.excludes` 不会做很多比将其参数应用于 `isinstance`
    函数之外的事情，所以构造函数中的错误不会对事情造成太大影响。
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These tests describe the behavior of the code that checks whether activities
    overlap in the cases where the first activity:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试描述了在第一个活动重叠的情况下检查活动是否重叠的代码行为。
- en: Comes before the second activity
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个活动之前
- en: Overlaps the beginning of the second activity
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与第二个活动的开始重叠
- en: Overlaps the end of the second activity
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与第二个活动的结束重叠
- en: Begins and ends within the range of the second activity
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个活动的范围内开始和结束
- en: Begins before the second activity and ends after it
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个活动之前开始并在其之后结束
- en: Comes after the second activity
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个活动之后
- en: This covers the domain of possible relationships between the tasks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了任务之间可能存在的关系域。
- en: No actual activities were used in these tests, just `Mock` objects that had
    been given the attributes that the `Activity.overlaps` function should look for.
    As always, we're doing our best to keep the code in different units from being
    able to interact during the tests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些测试中没有使用任何实际的活动，只是给 `Mock` 对象赋予了 `Activity.overlaps` 函数应该查找的属性。一如既往，我们尽力确保不同的代码单元在测试期间不能相互交互。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might have noticed that we used a shortcut to create the mock objects, by
    passing the attributes, we wanted them to have as keyword parameters for the constructor.
    Most of the time, that's a handy way to save a little work, but it does have the
    problem that it only works for attribute names that don't happen to be used as
    actual parameters to the `Mock` constructor. Notably, attributes called `name`
    can't be assigned in this way, because that parameter has a special meaning for
    `Mock`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们通过传递构造函数所需的属性作为关键字参数来创建模拟对象，使用了一个快捷方式来创建模拟对象。大多数时候，这是一种节省一点工作的便捷方式，但它确实有一个问题，那就是它只适用于没有用作`Mock`构造函数实际参数的属性名称。值得注意的是，名为`name`的属性不能以这种方式分配，因为该参数对`Mock`有特殊含义。
- en: 'The code in `tests/test_statuses.py` is almost the same, except that it uses
    the `Status` class instead of the `Activity` class. There is one significant difference,
    though:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_statuses.py`中的代码几乎相同，只是它使用的是`Status`类而不是`Activity`类。尽管如此，有一个显著的区别：'
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The defining difference between a `Status` and an `Activity` is that a status
    does not exclude other tasks that overlap with it. The tests, naturally, should
    reflect that difference.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Status`和`Activity`之间的定义性区别在于，状态不会排除与之重叠的其他任务。测试自然应该反映这种差异。'
- en: 'The following code goes in `tests/test_schedules.py`. We define several mock
    objects that behave as if they were statuses or activities, and in which they
    support the overlap and exclusion protocol. We''ll use these mock objects in several
    tests, to see how the schedule deals with the various combinations of overlapping
    and exclusive objects:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码位于`tests/test_schedules.py`中。我们定义了几个模拟对象，它们表现得像状态或活动，并且支持重叠和排除协议。我们将在几个测试中使用这些模拟对象，以查看调度如何处理重叠和排除对象的组合：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s take a closer look at some sections of the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看以下代码的一些部分：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These lines create mock objects as attributes of the `add_tests` class. Each
    of these mock objects has mocked `overlaps` and `excludes` methods that will always
    return either `True` or `False` when called. This means that each of these mock
    objects considers itself as overlap ping either everything or nothing, and excludes
    either everything or nothing. Between the four mock objects, we have covered all
    the possible combinations. In the following tests, we''ll add various combinations
    of these mock objects to a schedule, and make sure that it does the right things:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将模拟对象作为`add_tests`类的属性创建。每个模拟对象都有模拟的`overlaps`和`excludes`方法，当被调用时总是返回`True`或`False`。这意味着每个模拟对象都认为自己是重叠的，要么是所有东西，要么什么都不是，并且排除要么是所有东西，要么什么都不是。在这四个模拟对象之间，我们涵盖了所有可能的组合。在接下来的测试中，我们将添加这些模拟对象的组合到调度中，并确保它做了正确的事情：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding four tests are covering cases where we add a nonoverlapping object
    to a schedule. All of them are expected to accept the nonoverlapping object, except
    the first. In this test, we've previously added an object that claims that it
    does indeed overlap; furthermore, it excludes anything it overlaps. This test
    shows that, if either the object being added or an object already in the schedule
    believes that there's an overlap, the schedule must treat it as an overlap.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的四个测试涵盖了我们将非重叠对象添加到调度中的情况。所有这些测试都预期会接受非重叠对象，除了第一个。在这个测试中，我们之前添加了一个声称确实存在重叠的对象；此外，它排除了所有与之重叠的对象。这个测试表明，如果被添加的对象或已经在调度中的对象认为存在重叠，那么调度必须将其视为重叠。
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this test, we're making sure that if an object already in the schedule overlaps
    a new object and claims exclusivity, then adding the new object will fail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们确保如果已经在调度中的对象与新的对象重叠并声称具有排他性，那么添加新的对象将失败。
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this test, we're making sure that, even though the object already in the
    schedule doesn't think that it overlaps with the new object, it excludes the new
    object because the new object thinks that there's an overlap.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们确保即使已经在调度中的对象认为它不会与新的对象重叠，它也会排除新的对象，因为新的对象认为存在重叠。
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These tests are making sure that the inclusive objects don't somehow interfere
    with adding each other to a schedule.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试确保包容性对象不会以某种方式干扰彼此添加到调度中。
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These two tests describe the schedule behavior with respect to the `in` operator.
    Specifically, it should return `True` when the object in question is actually
    in the schedule.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试描述了与`in`操作符相关的调度行为。具体来说，当问题中的对象实际上在调度中时，它应该返回`True`。
- en: Try it for yourself – write your early unit tests
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亲自试试看——编写您的早期单元测试
- en: 'A specification—even a testable specification written in `doctest`—still hosts
    a lot of ambiguities that can be ironed out with good unit tests. Add that to
    the fact that the specification doesn''t maintain separation between different
    tests, and you can see that it''s time for your project to gain some unit tests.
    Perform the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一个用`doctest`编写的可测试规范，仍然存在许多可以通过良好的单元测试来消除的歧义。再加上规范没有在不同测试之间保持分离，您就可以看到，是时候让您的项目获得一些单元测试了。执行以下步骤：
- en: Find some element of your project that is described in (or implied by) your
    specification.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到您项目中由规范（或由规范暗示）描述的某个元素。
- en: Write a unit test that describes the behavior of that element when given the
    correct input.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个单元测试，描述当给定正确输入时该元素的行为。
- en: Write a unit test that describes the behavior of that element when given the
    incorrect input.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个单元测试，描述当给定错误输入时该元素的行为。
- en: Write unit tests that describe the behavior of the element at the boundaries
    between correct and incorrect input.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写单元测试，描述该元素在正确和错误输入之间的边界行为。
- en: Go back to step 1 if you can find another untested part of your program.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您能找到程序中另一个未测试的部分，请回到步骤1。
- en: Wrapping up the initial unit tests
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结初始单元测试
- en: This is where you really take what was an ill-defined idea and turn it into
    a precise description of what you're going to do.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您真正将一个模糊不清的想法转化为您将要做的精确描述的地方。
- en: The end result can be quite lengthy, which shouldn't come as much of a surprise.
    After all, your goal at this stage is to completely define the behavior of your
    project; even without concerning yourself with the details of how that behavior
    is implemented, that's a lot of information.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果可能相当长，这不应该让人感到惊讶。毕竟，在这个阶段，您的目标是完全定义您项目的行为；即使不考虑实现该行为的具体细节，这也是很多信息。
- en: Coding planner.data
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码`planner.data`
- en: It's time to write some code using the specification document and the unit tests
    as guides. Specifically, it's time to write the `planner.data` module, which contains
    `Status`, `Activity`, and `Schedule`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候根据规范文档和单元测试编写一些代码了。具体来说，是时候编写`planner.data`模块了，该模块包含`Status`、`Activity`和`Schedule`。
- en: To create this package, I made a directory called `planner` and, within this
    directory, created a file called `__init__.py`. There's no need to put anything
    inside `__init__.py`, but the file itself needs to exist to tell Python that the
    `planner` directory is a package.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个包，我创建了一个名为`planner`的目录，并在该目录内创建了一个名为`__init__.py`的文件。不需要在`__init__.py`中放置任何内容，但该文件本身需要存在，以便告诉Python`planner`目录是一个包。
- en: 'The following code goes in `planner/data.py`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码位于`planner/data.py`：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Task` class here contains most of the behavior that is needed for both
    the `Activity` class and the `Status` class. Since so much of what they do is
    common to both, it makes sense to write the code once and reuse it. Only the `excludes`
    method needs to be different in each of the subclasses. That makes the classes
    for activities and statuses very simple. The `Schedule` class turns out to be
    pretty easy, too. But is it right? Our tests will tell us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Task`类包含了`Activity`类和`Status`类所需的大部分行为。由于它们所做的大部分事情都是共同的，因此编写一次代码并重用是有意义的。只有`excludes`方法在每个子类中都需要不同。这使得活动和状态类非常简单。`Schedule`类也相当简单。但是，这是正确的吗？我们的测试将告诉我们。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We used the `timedelta` class and the `datetime.isoformat` method in the preceding
    code. Both are useful but somewhat obscure features of the `datetime` module.
    A `timedelta` instance represents the duration between two points in time. The
    `isoformat` method returns a string representing the `datetime` module in ISO
    8601 standard format.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`timedelta`类和`datetime.isoformat`方法。这两个都是`datetime`模块的有用但有些晦涩的功能。`timedelta`实例表示两个时间点之间的持续时间。`isoformat`方法返回一个表示`datetime`模块的ISO
    8601标准格式的字符串。
- en: Using tests to get the code right
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试来确保代码正确
- en: All right, so that code looks fairly good. Unfortunately, Nose tells us that
    there are a few problems. Actually, Nose reports quite a large number of problems,
    but a lot of them seem to be related to a few root causes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以这段代码看起来相当不错。不幸的是，Nose告诉我们有几个问题。实际上，Nose报告了相当多的问题，但其中很多似乎与几个根本原因有关。
- en: 'First, let''s address the problem that, though the `Activity` and `Status`
    classes don''t seem to have the `exclude` methods, some of our code tries to call
    that method. A typical report of this problem from the Nose output looks like
    a traceback followed by:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解决尽管`Activity`和`Status`类似乎没有`exclude`方法，但一些代码尝试调用该方法的问题。从Nose输出中看到的这个问题的典型报告看起来像跟踪回溯后：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Looking at our code, we see that it is properly called `excludes`. The tracebacks
    included in the Nose error report tell us that the problem is on line 51 of `planner/data.py`,
    and it looks like a quick fix.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的代码，我们看到它正确地被命名为`excludes`。Nose错误报告中包含的跟踪回溯告诉我们问题出在`planner/data.py`的第51行，看起来是一个简单的修复。
- en: 'We''ll just change line 51 from the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将第51行的内容更改为以下内容：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'to:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 变为：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: and run Nose again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次运行Nose。
- en: 'Similarly, several of our tests report the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们的几个测试报告了以下输出：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is clearly another typo. That one's on line 52 of `planner/data.py`. Oops!!
    We'll fix that one, too, and run Nose again to see what else is wrong.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是另一个打字错误。这一次是在`planner/data.py`的第52行。哎呀！我们也会修复这个问题，并再次运行Nose以查看还有什么问题。
- en: 'Continuing our trend of picking the low-hanging fruit first, let''s clear up
    the problem reported as the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们优先处理低垂果实的趋势，让我们澄清以下报告的问题：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is yet another typo, this time in `docs/outline.txt`. This time, it's not
    a problem with the code being tested, but with the test itself. It still needs
    to be fixed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是另一个打字错误，这一次在`docs/outline.txt`中。这一次，问题不是测试中的代码问题，而是测试本身的问题。它仍然需要修复。
- en: The problem is that, when originally entering the tests, I apparently only typed
    in two dots at the beginning of several lines, instead of the three that tell
    doctest that an expression continues onto that line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，在最初输入测试时，我显然只在几行的开头输入了两个点，而不是三个点，这告诉doctest表达式将继续到那一行。
- en: 'After fixing that, things are starting to get less obvious. Let''s pick on
    this one next:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 修复那个问题后，事情开始变得不那么明显了。让我们接下来处理这个问题：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Why isn't the activity being seen as a member of the schedule? The previous
    example passed, which shows that the `in` operator works for the activity we actually
    added to the schedule. The failure shows up when we try to use an equivalent activity;
    once we realize that, we know what we need to fix. Either our `__eq__` method
    isn't working, or (as is the actual case) we forgot to write it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么活动没有被看作是日程表的一部分？前面的例子通过了，这表明`in`操作符对我们实际添加到日程表中的活动是有效的。失败出现在我们尝试使用等效活动时；一旦我们意识到这一点，我们就知道我们需要修复什么。要么是我们的`__eq__`方法不起作用，要么（正如实际情况）我们忘记编写它。
- en: We can fix this bug by adding the `__eq__` and `__ne__` methods to `Task`, which
    will be inherited by `Activity` and `Status`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`Task`添加`__eq__`和`__ne__`方法来修复这个bug，这些方法将被`Activity`和`Status`继承。
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, two tasks that have the same name, start time, and end time will compare
    as equivalent even if one is a `Status` and the other is an `Activity`. The last
    isn't necessarily right, but it doesn't cause any of our tests to fail, so we'll
    leave it for now. If it becomes a problem later, we'll write a test that checks
    it, and then fix it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个具有相同名称、开始时间和结束时间的任务将被视为等效，即使一个是`Status`而另一个是`Activity`。后者不一定正确，但它并没有导致我们的任何测试失败，所以我们暂时保留它。如果以后成为问题，我们将编写一个测试来检查它，然后修复它。
- en: What's the deal with this one?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这一个是怎么回事？
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Well, it looks ugly but, if you look at it, you'll see that `doctest` is just
    complaining that the raised exception doesn't print out as expected. It's even
    the right exception; it's just a question of formatting.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，看起来很丑陋，但如果你仔细看，你会发现`doctest`只是在抱怨抛出的异常没有按预期打印出来。它甚至是正确的异常；只是格式问题。
- en: 'We can fix this on line 62 of `planner/data.py`, by changing the line to read:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`planner/data.py`的第62行修复这个问题，通过将这一行改为读取：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There's one more problem with this doctest example, which is that we wrote the
    name of the expected exception as `ScheduleError`, and that was how Python 2 printed
    out exceptions. Python 3 prints out exceptions with a qualified name, though,
    so we need to change it to `planner.data.ScheduleError` on line 63 of the doctest
    file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个doctest示例还有一个问题，那就是我们写下了期望的异常名为`ScheduleError`，这是Python 2打印异常的方式。然而，Python
    3使用限定名称打印异常，所以我们需要在doctest文件的第63行将其更改为`planner.data.ScheduleError`。
- en: Now, if you've been following along, all of the errors should be fixed, except
    for some of the acceptance tests in `docs/outline.txt`. Basically, these failing
    tests tell us that we haven't written the persistence code yet, which is true.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你一直在跟随，所有的错误都应该已经修复，除了 `docs/outline.txt` 中的某些验收测试。基本上，这些失败的测试告诉我们我们还没有编写持久化代码，这是真的。
- en: Try it for yourself – writing and debugging code
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亲自尝试——编写和调试代码
- en: 'The basic procedure, as we''ve discussed before, is to write some code, then
    run the tests to find problems with the code, and repeat. When you happen to come
    across an error that isn''t covered by an existing test, you need to write a new
    test and continue the process. Perform the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基本步骤，正如我们之前讨论的，是编写一些代码，然后运行测试以查找代码中的问题，并重复。当你偶然遇到一个现有测试未涵盖的错误时，你需要编写一个新的测试并继续这个过程。执行以下步骤：
- en: Write code that ought to satisfy at least some of your tests.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写满足至少一些测试的代码。
- en: 'Run your tests. If you''ve used the tools we talked about in the previous chapters,
    you should be able to run everything simply by executing:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行你的测试。如果你使用了我们在前几章中提到的工具，你应该可以通过执行以下命令来运行所有内容：
- en: '[PRE32]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If there are errors in the code you've already written, use the test output
    to help you locate and identity them. Once you understand the bugs, try to fix
    them and then go back to step 2.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在已经编写的代码中发现了错误，请使用测试输出帮助你定位和识别它们。一旦你理解了这些错误，尝试修复它们，然后回到步骤2。
- en: Once you've fixed all the errors in the code you've written, and if your project
    isn't complete, choose some new tests to concentrate on and go back to step 1.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你修复了你编写的代码中的所有错误，如果你的项目还没有完成，选择一些新的测试来集中精力，然后回到步骤1。
- en: Enough iterations on this procedure lead you to have a complete and tested project.
    Of course, the real task is more difficult than simply saying "it will work" but,
    in the end, it will work. You will produce a codebase that you can be confident
    in. It will also be an easier process than it would have been without the tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个过程的足够迭代将引导你拥有一个完整且经过测试的项目。当然，实际任务比简单地说是“它会工作”要困难得多，但最终它会工作。你将产生一个你可以有信心的代码库。这也会是一个比没有测试更容易的过程。
- en: Your project might be done, but there's still more to do on the personal scheduler.
    At this stage of the chapter, I haven't finished going through the writing and
    debugging process. It's time to do that.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目可能已经完成，但在个人调度器上还有更多的事情要做。在这一章的这个阶段，我还没有完成编写和调试过程。现在是时候去做这件事了。
- en: Writing the persistence tests
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写持久化测试
- en: 'Since I don''t have any actual unit tests for the persistence code yet, I''ll
    start off by making some. In the process, I have to figure out how persistence
    will actually work. The following code goes in `tests/test_persistence.py`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我还没有实际的持久化代码单元测试，我将从编写一些测试开始。在这个过程中，我必须弄清楚持久化实际上是如何工作的。以下代码放在 `tests/test_persistence.py`
    中：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Looking at each of the important sections of the test code, we see the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 观察测试代码的每个重要部分，我们看到以下内容：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `test_basic` test creates `File`, stores a single object under the name
    `'tag1'`, and then loads that object back from storage and checks whether it is
    equal to the original object. It really is a very basic test, but it covers the
    simple use case.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_basic` 测试创建 `File`，在名称 `''tag1''` 下存储一个单一的对象，然后从存储中重新加载该对象并检查它是否与原始对象相等。这确实是一个非常基础的测试，但它覆盖了简单的用例。'
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We don't need a test fixture here because we're not actually working with an
    on-disk file that we need to create and delete. The special filename `':memory:'`
    tells SQLite to do everything in memory. This is particularly handy for testing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们不需要测试夹具，因为我们实际上并没有在处理需要创建和删除的磁盘文件。特殊的文件名 `':memory:'` 告诉SQLite在内存中完成所有操作。这对于测试来说特别方便。
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `test_multiple_tags` test creates a storage, and then stores multiple objects
    in it, some with duplicate tags. It then checks whether the storage keeps all
    of the objects with a given tag, and returns all of them on request.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_multiple_tags` 测试创建一个存储，然后在其中存储多个对象，其中一些具有重复的标签。然后它检查存储是否保留了所有给定标签的对象，并在请求时返回它们。'
- en: In other words, all these tests define the persistence file as a multimap from
    string keys to object values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，所有这些测试都将持久化文件定义为从字符串键到对象值的multimap。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A multimap is a mapping between single keys and any number of values. In other
    words, each individual key might be associated with one value, of fifty.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 多映射是单个键和任意多个值之间的映射。换句话说，每个单独的键可能关联一个值，也可能是五十个。
- en: Finishing up the personal planner
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成个人计划
- en: 'Now that there are at least basic unit tests covering the persistence mechanism,
    it''s time to write the persistence code itself. The following goes in `planner/persistence.py`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经有了至少基本的单元测试覆盖持久化机制，是时候编写持久化代码本身了。以下内容位于 `planner/persistence.py` 文件中：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `store_object` method runs a short SQL statement to store the object into
    a database field. The object serialization is handled by the `dumps` function
    from the `pickle` module.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`store_object` 方法运行一个简短的 SQL 语句将对象存储到数据库字段中。对象序列化由 `pickle` 模块的 `dumps` 函数处理。'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `pickle` module, as a whole, deals with storing and retrieving Python objects.
    The `dumps` function in particular transforms Python objects into byte strings
    that can be transformed back into a Python object via the `loads` function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle` 模块整体处理存储和检索 Python 对象。特别是 `dumps` 函数将 Python 对象转换为字节字符串，这些字节字符串可以通过
    `loads` 函数转换回 Python 对象。'
- en: The `load_object` method uses SQL to query the database for the serialized version
    of every object stored under a given tag, and then uses `pickle.loads` to transform
    these serializations into real objects for it to return.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_object` 方法使用 SQL 查询数据库以获取存储在给定标签下的每个对象的序列化版本，然后使用 `pickle.loads` 将这些序列化转换为要返回的实际对象。'
- en: 'Now I run Nose to find out what''s broken:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我运行 Nose 来找出什么出了问题：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Ah, yes. The `sqlite3` module returns the query rows as tuples, unless you
    tell it otherwise. I want to use column names as indexes, so I need to set the
    row factory. We''ll add the following line to the `File` constructor:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，是的。`sqlite3` 模块返回查询行作为元组，除非你告诉它否则。我想使用列名作为索引，所以我需要设置行工厂。我们将在 `File` 构造函数中添加以下行：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now when I run Nose, the only problems it tells me about are that I haven''t
    implemented `Schedule.load` and `Schedule.store` yet. Furthermore, there aren''t
    any unit tests that check these methods. The only error comes from the specification
    doctest. It''s time to write some more unit tests in `tests/test_schedules.py`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我运行 Nose，它告诉我的唯一问题是，我还没有实现 `Schedule.load` 和 `Schedule.store`。此外，还没有任何单元测试来检查这些方法。唯一的错误来自规范
    doctest。是时候在 `tests/test_schedules.py` 中编写更多的单元测试了：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that I have some tests to check against, it''s time to write the store
    and load methods of the `Schedule` class in `planner/data.py`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有一些测试要检查，是时候在 `planner/data.py` 中编写 `Schedule` 类的存储和加载方法了：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These changes also imply a change to the Schedule constructor:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改还意味着对 `Schedule` 构造函数的更改：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Okay, now, I run Nose, and... something''s still broken::'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在，我运行 Nose，然后... 仍然有问题：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Looks like schedules need to compare equal based on their contents, too. That''s
    easily done:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，日程表也需要根据其内容进行比较。这很容易做到：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Just like last time we wrote a comparison function; this one has some unusual
    behavior, in that it only considers two schedules equal if the tasks were added
    to them in the same order. Again, though this smells a little funny, it doesn't
    make any tests fail, and it's not clearly wrong; so we'll leave it until it matters.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上次我们编写比较函数一样；这个函数有一些不寻常的行为，即它只有在任务以相同的顺序添加到日程表中时才认为两个日程表相等。再次强调，尽管这有点奇怪，但它并没有导致任何测试失败，而且它并不明显错误；所以我们将其留到它变得重要的时候再处理。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how the skills that we covered in earlier
    parts of this book are applied in practice. We did this by stepping through a
    recording of your humble author's actual process in writing a package. At the
    same time, you had the chance to work through your own project, make your own
    decisions, and design your own tests. You've taken the lead in a test-driven project,
    and you should be able to do it again whenever you want.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将本书前面部分介绍过的技能应用于实践中。我们通过逐步分析你谦逊的作者实际编写包的过程的录音来做到这一点。同时，你也有机会处理自己的项目，做出自己的决定，并设计自己的测试。你已经在一个测试驱动型项目中担任了领导角色，你应该能够在任何时候再次做到这一点。
- en: Now that we've covered the heart of Python testing, we're ready to talk about
    testing at the integration and system levels, which we'll do in the next chapter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 Python 测试的核心，我们准备讨论集成和系统级别的测试，我们将在下一章中这样做。
