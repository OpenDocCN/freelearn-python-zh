- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Rendering and Shaders
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染和着色器
- en: A process called *rendering* generates the pixels of finished images by evaluating
    the geometries, lights, and camera of the scene.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个称为 *渲染* 的过程通过评估场景的几何形状、灯光和相机来生成完成图像的像素。
- en: 'The renderers, or Render Engines, that handle those computations can be external
    programs, independent from the 3D application, or fully integrated features of
    the animation package. All renderers have strong and weak points and can be grouped
    into two categories: real time, which assume a few approximations to achieve immediate
    visualization, and offline, which take more time to take more details into account.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些计算的渲染器可以是外部程序，独立于 3D 应用程序，或者动画包的完全集成功能。所有渲染器都有优点和缺点，可以分为两类：实时渲染，它通过假设一些近似值来实现即时可视化，和离线渲染，它需要更多时间来考虑更多细节。
- en: To generate images, renderers rely on shaders – that is, instructions on how
    an object reacts to the light and position of the observer, and how that translates
    into the rendered pixels.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成图像，渲染器依赖于着色器——即关于物体如何对光线和观察者的位置做出反应，以及这如何转化为渲染像素的指令。
- en: Shaders can be complex and are a discipline of their own, but the basic concept
    of how they work is not hard to grasp.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器可能很复杂，是一门独立的学科，但它们的工作基本概念并不难理解。
- en: In this chapter, you will learn where to set the render properties, how to automate
    the creation of shaders using Python, and how to use the **File Browser** for
    loading images.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何设置渲染属性，如何使用 Python 自动创建着色器，以及如何使用 **文件浏览器** 加载图像。
- en: 'This chapter covers the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding the materials system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解材料系统
- en: Loading images in the Shader Editor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在着色器编辑器中加载图像
- en: Connecting and arranging shader nodes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接和排列着色器节点
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will use Blender and Visual Studio Code in this chapter. The examples created
    for this chapter, along with the media files, can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将使用 Blender 和 Visual Studio Code。为本章创建的示例，以及媒体文件，可以在 [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12)
    找到。
- en: Render and materials
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染和材质
- en: 'Blender comes with two render engines: **Eevee**, the real-time renderer that
    can be used in the Viewport, and **Cycles**, an offline renderer. Additional engines,
    including most of the commercial offerings, can be installed in the form of render
    add-ons. A third option, **Workbench**, can be used for quickly and simply displaying
    renders in the Viewport.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 随带两个渲染引擎：**Eevee**，一个可以在视口使用的实时渲染器，以及 **Cycles**，一个离线渲染器。其他引擎，包括大多数商业产品，可以以渲染插件的形式安装。还有一个选项，**工作台**，可以用于在视口中快速简单地显示渲染。
- en: Setting the Render Engine
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置渲染引擎
- en: 'The current **Render Engine**, along with other render settings, can be found
    in the scene **Render** properties. It’s the first tab and is marked with an icon
    of a TV set:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 **渲染引擎**，以及其他渲染设置，可以在场景 **渲染** 属性中找到。它是第一个标签页，并带有电视机的图标：
- en: '![Figure 12.1: Selecting the current Render Engine](img/Figure_12.01_B18375.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1：选择当前渲染引擎](img/Figure_12.01_B18375.jpg)'
- en: 'Figure 12.1: Selecting the current Render Engine'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：选择当前渲染引擎
- en: While **Workbench** is designed to have only a few render options and no shading
    system, **Eevee** and **Cycles** can combine images, colors, and attributes using
    a node-based system. This can be done in the **Shader Editor** area, available
    in the **Shading** workspace.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 **工作台** 设计时只包含少量渲染选项和没有着色系统，**Eevee** 和 **Cycles** 可以通过基于节点的系统结合图像、颜色和属性。这可以在
    **着色器编辑器** 区域完成，该区域位于 **着色** 工作区。
- en: The Shading workspace
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色工作区
- en: 'Shading involves disparate activities, such as accessing image files, checking
    the Viewport, and editing object properties. Once we set our **Render Engine**
    to Eeeve, Cycles, or an external engine that supports Blender’s shading system,
    we can carry out those tasks in the **Shading** workspace. It contains the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 着色涉及不同的活动，如访问图像文件、检查视口和编辑物体属性。一旦我们将 **渲染引擎** 设置为 Eeeve、Cycles 或支持 Blender 着色系统的外部引擎，我们就可以在
    **着色** 工作区执行这些任务。它包含以下内容：
- en: A **File Browser** for importing images
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于导入图像的 **文件浏览器**
- en: The **3D Viewport** area for checking the materials
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于检查材质的 **3D 视口** 区域
- en: An **Outliner**
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **大纲**
- en: Data **Properties**; by default, the **World** settings tab is active
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据**属性**；默认情况下，**世界**设置选项卡是激活的
- en: The **Shaders** **Editor** area
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器****编辑器**区域'
- en: 'The **Image** **Editor** area:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像****编辑器**区域：'
- en: '![Figure 12.2: The Shading workspace](img/Figure_12.02_B18375.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：着色工作区](img/Figure_12.02_B18375.jpg)'
- en: 'Figure 12.2: The Shading workspace'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：着色工作区
- en: The default material presents a few color attributes that can be set in the
    **Material Properties** area. To understand how to script articulated materials
    with a proper layout, we will provide a brief overview of how the shader components
    come together in the shader graph.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认材质提供了一些可以在**材质属性**区域设置的着色属性。为了理解如何使用适当的布局编写可动材质的脚本，我们将简要概述着色器组件如何在着色器图中组合在一起。
- en: Understanding object materials
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解物体材质
- en: We can change the overall look of an object by specifying its material. The
    term *material* follows the analogy of real-world objects, whose look is affected
    by the material of which they are made or coated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定物体的材质来改变物体的整体外观。术语*材质*遵循现实世界物体的类比，其外观受其制成或涂层的材质影响。
- en: Object materials can be edited in the **Material Properties** area. In version
    3.3, it’s the second-to-last property tab, marked with an icon of a sphere with
    a checkerboard pattern, as shown in *Figure 12**.3*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 物体的材质可以在**材质属性**区域中进行编辑。在3.3版本中，它是倒数第二个属性选项卡，带有带有棋盘图案的球体图标，如图*图12*.3所示。
- en: Setting Material Properties
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置材质属性
- en: Materials exist independently from objects. One material can be shared among
    multiple objects and an object can have more materials assigned to different sets
    of faces.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 材质独立于物体存在。一种材质可以共享给多个物体，并且一个物体可以分配给不同面的集合的多个材质。
- en: 'Scrolling down to the material **Settings**, we can edit how the material is
    processed by Blender – for instance, how its transparent parts are rendered over
    the background:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到材质**设置**，我们可以编辑Blender如何处理材质——例如，其透明部分如何渲染在背景之上：
- en: '![Figure 12.3: Settings in the Material Properties area](img/Figure_12.03_B18375.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：材质属性区域的设置](img/Figure_12.03_B18375.jpg)'
- en: 'Figure 12.3: Settings in the Material Properties area'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：材质属性区域的设置
- en: The properties commonly associated with actual materials, such as roughness,
    color, and transparency, are displayed in the **Surface** panel. Those properties
    are part of the **shader**, a generic algorithm used for computing how a surface
    should look. Every material has a shader associated with it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与实际材料通常关联的属性，如粗糙度、颜色和透明度，在**表面**面板中显示。这些属性是**着色器**的一部分，着色器是一种通用的算法，用于计算表面应该如何看起来。每种材料都与其关联一个着色器。
- en: 'Shaders introduce a new concept to this book: a visual framework known as the
    **nodes tree**. We can learn how it works by looking at the **Shader** **Editor**
    area.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器为本书引入了一个新概念：称为**节点树**的可视框架。我们可以通过查看**着色器****编辑器**区域来了解它是如何工作的。
- en: The Shader Editor
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器编辑器
- en: 'The shading system supports different styles: realistic, cartoon, or technical
    drawings, to mention a few. Rather than providing a single interface with defined
    widgets, the functionalities of a renderer are scattered through interconnecting
    units called **nodes**.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 着色系统支持不同的风格：现实感、卡通或技术图纸等。而不是提供一个具有定义小部件的单个界面，渲染器的功能分散在称为**节点**的互联单元中。
- en: Much like a function, a node performs a specific operation on one or more inputs
    and makes the results available through one or more outputs. Nodes are visual
    representations of functions, allowing non-programmers to combine logic blocks
    to get custom results.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，节点对一个或多个输入执行特定的操作，并通过一个或多个输出提供结果。节点是函数的可视表示，允许非程序员组合逻辑块以获得自定义结果。
- en: Nodes are not unique to shading – they are used for **Compositing** and for
    generating meshes in the **Geometry** **Nodes** modifier.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 节点不仅限于着色使用——它们还用于**合成**以及在**几何****节点**修改器中生成网格。
- en: By default, a Blender material presents a **Material Output** node in the **Shader
    Editor** area, with a **Principled BSDF** node as its **Surface** input. **Bidirectional
    Scattering Distribution Function** (**BSFD**) is a mathematical model of how a
    surface receives and reflects light rays. It is a form of **Physically-Based Rendering**
    (**PBR**), an approach based on how visual properties such as color, roughness,
    and permeability interact with light in the real world.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Blender材质在**着色器编辑器**区域显示一个**材质输出**节点，其**表面**输入为**原理BSDF**节点。**双向散射分布函数**（**BSDF**）是一个数学模型，描述了表面如何接收和反射光线。它是一种**基于物理的渲染**（**PBR**）形式，基于视觉属性如颜色、粗糙度和渗透性如何在现实世界中与光线相互作用。
- en: '**Material Output** is the last node of the graph and transfers the shading
    to an object.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**材质输出**是图中的最后一个节点，将着色传递到对象上。'
- en: Only one output can be active at any time, so the shader graph is also called
    the **Node Tree**, with the output as the root from which all the other branches
    stem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候只能有一个输出处于活动状态，因此着色器图也称为**节点树**，输出作为根节点，所有其他分支都由此节点衍生。
- en: Understanding the Node Tree
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解节点树
- en: The inputs and outputs of a node are displayed as colored circles called **sockets**.
    Input sockets are on the left-hand side of the node, while output sockets are
    on the right. Their color depends on the data type of the socket. For instance,
    the **Base Color** socket of a **Principled** node, which is yellow, assigns a
    color to a material, while **Roughness**, a gray socket, is a float number to
    denote how far from smooth it is.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的输入和输出以彩色圆圈的形式显示，称为**插座**。输入插座位于节点的左侧，而输出插座位于右侧。它们的颜色取决于插座的数据类型。例如，**原理**节点的**基础颜色**插座，颜色为黄色，为材质分配颜色，而**粗糙度**，一个灰色插座，是一个浮点数，表示其与平滑度的距离。
- en: Purple sockets, such as **Normal**, are vectors and can contain directional
    data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 紫色插座，如**法线**，是向量，可以包含方向数据。
- en: 'Output sockets are on the right-hand side of a node, and can be connected,
    or linked, to the input sockets on the left-hand side of another node:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输出插座位于节点的右侧，可以连接或链接到另一个节点的左侧输入插座：
- en: '![Figure 12.4: A principled node receiving color, roughness, and normal inputs](img/Figure_12.04_B18375.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：一个接受颜色、粗糙度和法线输入的原理节点](img/Figure_12.04_B18375.jpg)'
- en: 'Figure 12.4: A principled node receiving color, roughness, and normal inputs'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：一个接受颜色、粗糙度和法线输入的原理节点
- en: 'So, the color attribute of a **Base Color** is an input socket and can be connected
    to any color output from another node. For instance, the input of a **Principled**
    node’s **Base Color** can come from an **RGB** node, as shown in *Figure 12**.4*,
    but also from an **Image Texture**, as shown in *Figure 12**.5*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**基础颜色**的颜色属性是一个输入插座，可以连接到来自另一个节点的任何颜色输出。例如，**原理**节点的**基础颜色**输入可以来自**RGB**节点，如图*12*.4*所示，也可以来自**图像纹理**，如图*12*.5*所示：
- en: '![Figure 12.5: A principled node, with an image as the input of Base Color](img/Figure_12.05_B18375.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5：一个原理节点，以图像作为基础颜色的输入](img/Figure_12.05_B18375.jpg)'
- en: 'Figure 12.5: A principled node, with an image as the input of Base Color'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：一个原理节点，以图像作为基础颜色的输入
- en: Connection is conversion!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 连接即转换！
- en: We can connect sockets of different types, such as vectors and colors; the data
    is converted automatically. The *X*, *Y*, and *Z* vector components are converted
    into the red, green, and blue elements of color, while the brightness of colors
    is converted into float values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将不同类型的插座连接起来，例如向量和颜色；数据会自动转换。*X*、*Y*和*Z*向量分量被转换为颜色的红色、绿色和蓝色元素，而颜色的亮度被转换为浮点值。
- en: Now that we know how materials work, we will write a script that helps load
    **Image Textures**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了材质的工作原理，我们将编写一个脚本，帮助加载**图像纹理**。
- en: Writing the Textament add-on
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Textament插件
- en: While creating a shader can take time, we can automate some of the simpler operations.
    For instance, we can write an add-on to ease the task of loading images from disk
    and connecting them to the shader.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建着色器可能需要时间，但我们也可以自动化一些简单的操作。例如，我们可以编写一个插件来简化从磁盘加载图像并将它们连接到着色器的任务。
- en: Using texture images
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纹理图像
- en: 'With the **Texture Image** node, we can use an image for coloring an object.
    That adds variation to how a material looks, as images can vary along the extension
    of an object and are not limited to a single color:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**纹理图像**节点，我们可以使用图像来为对象着色。这增加了材质外观的多样性，因为图像可以沿着对象的延伸方向变化，而不仅仅是单一颜色：
- en: '![Figure 12.6: An image texture of a Rubik’s cube, applied to a plain cube](img/Figure_12.06_B18375.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6：一个魔方的图像纹理，应用于一个平面立方体](img/Figure_12.06_B18375.jpg)'
- en: 'Figure 12.6: An image texture of a Rubik’s cube, applied to a plain cube'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：一个魔方的图像纹理，应用于一个平面立方体
- en: The operator that we are going to write will load multiple images from disk
    and guess their usage from the image’s filename. For instance, an image named
    `Metallic.png` would be loaded as a **Texture Image** and connected to the **Metallic**
    input of a **Principled** node.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的操作符将从磁盘加载多个图像，并从图像的文件名中猜测其用途。例如，名为 `Metallic.png` 的图像将被加载为**纹理图像**，并连接到**Principled**节点的**Metallic**输入。
- en: As usual, we will set up an environment for developing a new add-on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们将为开发新插件设置一个环境。
- en: Setting up the environment
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'We will create a Python script for our add-on and make it known to Blender
    by performing these steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的插件创建一个Python脚本，并通过执行以下步骤使其为Blender所知：
- en: Create a folder called `PythonScriptingBlender/ch12/addons`. We can use the
    file manager or the file tab of our IDE for this, such as **VS Code**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `PythonScriptingBlender/ch12/addons` 的文件夹中创建一个文件夹。我们可以使用文件管理器或我们IDE的文件标签页来完成此操作，例如**VS
    Code**。
- en: Create a new file in that folder and name it `textament.py`. We can use the
    file manager or the **New File** button of our IDE to do this.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中创建一个新文件，并将其命名为 `textament.py`。我们可以使用文件管理器或我们IDE的**新建文件**按钮来完成此操作。
- en: Open the file in your editor of choice.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的编辑器中打开文件。
- en: Set the `PythonScriptingBlender/ch12` in Blender’s **File** **Paths** preferences.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blender的**文件** **路径**首选项中设置 `PythonScriptingBlender/ch12`。
- en: Restart Blender to update the search paths.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Blender以更新搜索路径。
- en: Now, we will start writing the add-on information as usual.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将像往常一样开始编写插件信息。
- en: Writing the Textament add-on information
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Textament插件信息
- en: 'In the information, we must specify what the add-on is for and where its tools
    can be found:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息中，我们必须指定插件的作用以及其工具的位置：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The add-on contains just one class – an import operator for loading images.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件仅包含一个类——一个用于加载图像的导入操作符。
- en: Writing an import operator
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写导入操作符
- en: Our operator loads the image textures from disk, so we will need the `os` module
    to handle disk paths. Besides `bpy`, this operator will inherit from the `ImportHelper`
    utility class so that it can access Blender’s **File Browser**
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的操作符从磁盘加载图像纹理，因此我们需要 `os` 模块来处理磁盘路径。除了 `bpy`，此操作符还将继承自 `ImportHelper` 工具类，以便它可以访问Blender的**文件浏览器**
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Operators that derive from `ImportHelper` store the selected file paths in a
    few extra properties.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `ImportHelper` 派生的操作符将所选文件路径存储在几个额外的属性中。
- en: Using Blender’s File Browser
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Blender的文件浏览器
- en: 'Like all operators, `AddTextures` is based on `bpy.types.Operator`, but since
    it operates on files, it inherits from the `ImportHelper` class too. By inheriting
    from both classes, when it is launched, `AddTextures` runs the `invoke` method
    of `ImportHelper`, which opens the `execute` method runs as usual:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有操作符一样，`AddTextures` 基于 `bpy.types.Operator`，但由于它操作文件，它也继承自 `ImportHelper`
    类。通过继承这两个类，当它启动时，`AddTextures` 将运行 `ImportHelper` 的 `invoke` 方法，然后 `execute` 方法正常运行：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Deriving from `ImportHelper` adds a `filepath` attribute to `AddTexture`, in
    which the path to the selected file is stored.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `ImportHelper` 派生为 `AddTexture` 添加了一个 `filepath` 属性，其中存储了所选文件的路径。
- en: 'The `filepath` attribute stores the disk path to a single file, which is not
    enough in our case as we intend to load multiple files at once. For that reason,
    we need to store the selected `directory` in a `StringProperty`, and the selected
    `files` as a collection of `OperatorFileListElement`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath` 属性存储单个文件的磁盘路径，在我们的情况下这还不够，因为我们打算一次性加载多个文件。因此，我们需要将所选的 `directory`
    存储在 `StringProperty` 中，并将所选的 `files` 作为 `OperatorFileListElement` 的集合：'
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In another `StringProperty`, `filter_glob`, set the extensions of the files
    that should be displayed in the `.png` and `.jpg` images. This property is `"HIDDEN"`:
    we don’t want it to show up in the operator’s options:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个 `StringProperty`，`filter_glob` 中设置应显示在 `.png` 和 `.jpg` 图像中的文件扩展名。此属性是 `"HIDDEN"`：我们不希望它在操作员的选项中显示：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we can write the operator method. We will start with `poll`, the method
    that checks if the operator can be launched.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写操作符方法。我们将从 `poll` 方法开始，该方法检查操作符是否可以启动。
- en: Checking the existence of an active node
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查活动节点的存在
- en: 'This operator works on the current node, so we need to check for the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作符在当前节点上工作，因此我们需要检查以下内容：
- en: An active object exists
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个活动对象
- en: There is an active material
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个活动的材质
- en: A material node tree has been found
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已找到材质节点树
- en: The material tree has an active node
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料树有一个活动的节点
- en: 'So, the `poll` method returns `False` unless all the aforementioned conditions
    apply:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`poll`方法在所有上述条件都适用的情况下才返回`False`：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the operator is launched and files are selected, they will be stored to be
    used in the `execute` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动了操作符并且选择了文件，它们将被存储以在`execute`方法中使用。
- en: Matching texture filenames
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配纹理文件名
- en: 'At the beginning of `execute`, we store the currently active node in a variable:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`execute`的开始，我们将当前活动的节点存储在一个变量中：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Operators that inherit from `ImportHelper` display the `execute` method after
    a choice in the **File Browser** is confirmed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自`ImportHelper`的操作符在**文件浏览器**中的选择确认后显示`execute`方法。
- en: For that reason, at the time when `execute` is run, the `self.files` attribute
    will contain the file selection from the user. We can iterate `self.files` and
    compare each filename with the shader inputs. Rather than looking for an exact
    match, we will be happy to find a filename and an input name that are similar
    at large.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当`execute`运行时，`self.files`属性将包含用户选择的文件选择。我们可以迭代`self.files`，并将每个文件名与着色器输入进行比较。我们更愿意找到一个与文件名和输入名在大体上相似的文件名，而不是寻找完全匹配。
- en: For instance, `"baseColor.png"` should connect with the `"Base Color"` socket.
    In other words, we want case-insensitive and space-insensitive matching.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`"baseColor.png"`应该连接到`"Base Color"`插座。换句话说，我们希望进行不区分大小写和不区分空格的匹配。
- en: 'A quick way to achieve this is by using a combination of the `lower` and `replace`
    methods. We can test this in any Python console; for example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的快捷方式是使用`lower`和`replace`方法的组合。我们可以在任何Python控制台中测试这一点；例如：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will need to perform this operation for every file, on any input, so we should
    create a function for that.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对每个文件、任何输入执行此操作，因此我们应该为这个操作创建一个函数。
- en: 'The `lambda` statement is a quick way to create a function by just stating
    its arguments and one expression. For instance, putting an input, *x*, into lowercase
    and as a non-spaced string can be written in this form:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`语句是一种通过仅声明其参数和一个表达式来创建函数的快捷方式。例如，将输入*x*转换为小写并作为一个无空格的字符串可以写成这种形式：'
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Unlike `def`, `lambda` doesn’t assign a name to the function as names are not
    a requirement of the syntax:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与`def`不同，`lambda`不将名称分配给函数，因为名称不是语法的要求：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we are storing its result in the `match_rule` variable, our example is
    equivalent to writing the following lines:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将结果存储在`match_rule`变量中，我们的示例等价于编写以下几行：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`lambda` can be used to write more compact code, or if a function is required
    as an argument but is not supposed to be called directly.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`可以用来编写更紧凑的代码，或者如果需要一个函数作为参数但不需要直接调用它。'
- en: We will use `match_rule` on every filename and every potential socket and compare
    the results while looking for a match.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对每个文件名和每个潜在的插座使用`match_rule`，并在寻找匹配项时比较结果。
- en: 'Node sockets are stored in `inputs`, a dictionary-like collection attribute
    of every node. We can get a list of the socket names using the `keys` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 节点插座存储在`inputs`中，这是每个节点的类似字典的集合属性。我们可以使用`keys`方法获取插座名称列表：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, it’s time to look for textures to link. We can combine two for loops and
    scroll all the inputs for each entry in `self.files`. If a match is found, the
    input/filename pair will be added to the `matching_names` dictionary:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候寻找可以链接的纹理了。我们可以组合两个for循环，遍历`self.files`中的每个条目的所有输入。如果找到匹配项，输入/文件名对将被添加到`matching_names`字典中：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `break` statement aborts the `input_names` loop when a match is found so
    that we can proceed to the next file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句在找到匹配项时终止`input_names`循环，这样我们就可以继续处理下一个文件。'
- en: Once the `matching_names` dictionary contains the input for which textures were
    found and the relative filenames, we can load the images from disk and add them
    to the graph.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`matching_names`字典包含了找到纹理的输入和相对文件名，我们就可以从磁盘加载图像并将它们添加到图中。
- en: Loading image files
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载图像文件
- en: 'The elements of `self.file` are not full disk paths. We can build this from
    `directory` and `os.path.join` so that we can use `bpy.data.images.load`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.file`的元素不是完整的磁盘路径。我们可以从`directory`和`os.path.join`构建它，这样我们就可以使用`bpy.data.images.load`：'
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `check_existing` parameter avoids loading the same image more than once:
    if it is already present in `bpy.data.images`, the `load` method returns the existing
    entry.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_existing`参数避免了加载相同的图像多次：如果它已经在`bpy.data.images`中存在，则`load`方法返回现有条目。'
- en: We have mentioned that not all sockets are colors, but also that vectors, colors,
    and float sockets are converted automatically when they are connected. Therefore,
    non-color data such as metallic (a float number) or normal (a vector) can be stored
    in images.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，并非所有插座都是颜色，但也提到当它们连接时，向量、颜色和浮点插座会自动转换。因此，非颜色数据，如金属（一个浮点数）或法线（一个向量），可以存储在图像中。
- en: One of the main points of a node graph is that we should be able to connect
    sockets of different, but broadly similar, types.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 节点图的一个主要观点是我们应该能够连接不同但大致相似类型的插座。
- en: Getting non-color attributes from images
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从图像获取非颜色属性
- en: 'The colors of an image are not different from vectors in terms of their information,
    which consists of three channels or components: **red**, **green**, and **blue**.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的颜色在信息方面并不与向量不同，它们由三个通道或组成部分组成：**红色**、**绿色**和**蓝色**。
- en: Connecting a **Color** socket to a **Vector** socket will use the red, green,
    and blue channels as the *X*, *Y*, and *Z* coordinates of a three-dimensional
    vector, respectively.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将**颜色**插座连接到**向量**插座时，将分别使用红色、绿色和蓝色通道作为三维向量的**X**、**Y**和**Z**坐标。
- en: If a color output is connected to a float socket, the brightness, also called
    its **luminance** or **value**, will be used as float input.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果颜色输出连接到浮点插座，则亮度，也称为其**亮度**或**值**，将用作浮点输入。
- en: Whenever an image is used for storing values rather than colors, it’s important
    to inform Blender about that; otherwise, color adjustments from the renderer would
    alter the image information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像用于存储值而不是颜色时，向Blender告知这一点很重要；否则，渲染器的颜色调整会改变图像信息。
- en: 'We can do that by setting the image color space to `NonColor` if a socket is
    not of the `"``RGBA"` type:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个插座不是`"``RGBA"`类型，我们可以通过将图像颜色空间设置为`NonColor`来做这件事：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we don’t do that, even correct textures will produce render artifacts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不这样做，即使是正确的纹理也会产生渲染伪影。
- en: 'At this stage, the images have been loaded into Blender but they are not present
    in the node tree yet: we need to create an **Image Texture** for that.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，图像已经加载到Blender中，但它们尚未出现在节点树中：我们需要为它创建一个**图像纹理**。
- en: Creating image texture nodes
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建图像纹理节点
- en: New material nodes can be added to a material shading graph by accessing the
    `nodes` collection of its `node_tree`. The `new` collection method requires the
    node to be of the `argument` type. In this case, `ShaderNodeTexImage` is the type
    that we use for creating image textures, but we can find the Python type of every
    shading node by looking at the menu tooltips.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过访问其`node_tree`的`nodes`集合来向材质着色图中添加新的材质节点。`new`集合方法需要节点为`argument`类型。在这种情况下，`ShaderNodeTexImage`是我们用于创建图像纹理的类型，但我们可以通过查看菜单提示来找到每个着色节点的Python类型。
- en: 'If **Python Tooltips** is enabled in **Edit** | **Preferences**, like we learned
    to do in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033), we can view the node
    type by hovering over the menu entry:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在**编辑** | **首选项**中启用了**Python工具提示**，就像我们在[*第2章*](B18375_02.xhtml#_idTextAnchor033)中学到的那样，我们可以通过悬停在菜单项上查看节点类型：
- en: '![Figure 12.7: Hovering over the Add menu entries displays the node type in
    the tooltip](img/Figure_12.7_B18375.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7：悬停在添加菜单项上会在提示中显示节点类型](img/Figure_12.7_B18375.jpg)'
- en: 'Figure 12.7: Hovering over the Add menu entries displays the node type in the
    tooltip'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：悬停在添加菜单项上会在提示中显示节点类型
- en: 'This way, we can create a new texture node and set its `image` attribute to
    the image that we have loaded from disk:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以创建一个新的纹理节点，并将其`image`属性设置为从磁盘加载的图像：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The texture nodes added to the graph are now ready for connection links.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到图中的纹理节点现在已准备好创建连接链接。
- en: Connecting nodes
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接节点
- en: While most texture output can be connected directly to a shading node, some
    input types might require helper nodes in between. The most prominent case is
    that of detail, or **normal maps**. Before creating new connections, our code
    should check that no additional nodes are required.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数纹理输出可以直接连接到着色节点，但某些输入类型可能需要在之间使用辅助节点。最突出的情况是细节，或**法线贴图**。在创建新连接之前，我们的代码应该检查是否需要额外的节点。
- en: Connecting image colors
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接图像颜色
- en: 'Connection links can be created using the `node_tree.links.new` method. Its
    arguments are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`node_tree.links.new`方法创建连接链接。它的参数如下：
- en: The output socket of the outgoing node
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出节点输出插座
- en: The input socket of the receiving node
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收节点的输入插座
- en: 'If we are not dealing with a normal map, we can connect the `"Color"` output
    of the texture to the input of the active node. No other action is required, so
    we can use `continue` to pass to the next input:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是在处理法线贴图，我们可以将纹理的 `"Color"` 输出连接到活动节点的输入。不需要其他操作，因此我们可以使用 `continue` 来传递到下一个输入：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A `normal` input would not trigger `continue`, so we don’t need an `else` statement
    for it: the normal map code follows, without additional indentation.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `normal` 输入不会触发 `continue`，因此我们不需要为它添加 `else` 语句：法线贴图代码随后，无需额外缩进。
- en: Connecting normal maps
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接法线贴图
- en: Rendering a detailed surface using geometry alone would require so many polygons
    that the resulting model would be too heavy to store or display.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用几何形状渲染一个详细的表面将需要如此多的多边形，以至于生成的模型将过于庞大，无法存储或显示。
- en: '**Normal mapping** stores geometric details in the pixels of an image using
    the RGB-to-XYZ conversion.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**法线贴图**使用 RGB 到 XYZ 转换在图像的像素中存储几何细节。'
- en: Since the normals stored in this way must be merged with the original ones,
    a **Normal** texture should not connect directly to a shader node; instead, it
    should pass through a **NormalMap** node.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以这种方式存储的法线必须与原始法线合并，因此法线纹理不应直接连接到着色器节点；相反，它应通过一个 **NormalMap** 节点传递。
- en: 'We can add a `"ShaderNodeNormalMap"` to the tree using `new`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `new` 在树中添加一个 `"ShaderNodeNormalMap"`：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `"Normal"` output of `normal_map` can be connected to the node input using
    the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`normal_map` 的 `"Normal"` 输出可以通过以下代码连接到节点输入：'
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we must connect `tex_img` to the `normal_map` node:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将 `tex_img` 连接到 `normal_map` 节点：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the `inp, fname` loop is over, we can return the `''FINISHED''` status
    and exit:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `inp, fname` 循环结束，我们可以返回 `'FINISHED'` 状态并退出：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since this script aims to make setting up the texture faster, we can add an
    operator button for quick execution.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此脚本旨在使设置纹理更快，我们可以添加一个操作符按钮以快速执行。
- en: Adding a header button
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标题按钮
- en: 'We have used menus for most of the operators in this book, but this time, we
    will add a button in the **Shader Editor** area’s top bar – that is, its header.
    The steps are the same as those we used to add menu entries:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书的大部分操作符中使用了菜单，但这次，我们将在 **Shader Editor** 区域的顶部栏中添加一个按钮——即其标题栏。步骤与添加菜单项时使用的步骤相同：
- en: Create a function that accepts two arguments, `self` and `context`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接受两个参数 `self` 和 `context` 的函数。
- en: Append that function to the header type when the add-on registers.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当插件注册时，将此函数附加到标题类型中。
- en: 'Using `NODE_TEXTURE`. The `layout.operator` method will display `AddTextures`
    as a header button:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NODE_TEXTURE`。`layout.operator` 方法将 `AddTextures` 显示为标题按钮：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, it’s time to register the operator and the header function. We can find
    the header class we are looking for, `NODE_HT_header`, by looking in Blender’s
    source file, `space_node.py`. This file can be loaded into Blender’s text editor
    by right-clicking and choosing **Edit Source**. We can do this on any element
    of the **Shader Editor** area’s header:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候注册操作符和标题函数了。我们可以通过查看 Blender 的源文件 `space_node.py` 来找到我们正在寻找的标题类 `NODE_HT_header`。可以通过右键单击并选择
    **Edit Source** 将此文件加载到 Blender 的文本编辑器中。我们可以在 **Shader Editor** 区域的标题的任何元素上这样做：
- en: '![Figure 12.8: NODE_HT_header is the first class in space_node.py](img/Figure_12.8_B18375.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8：NODE_HT_header 是 space_node.py 中的第一类](img/Figure_12.8_B18375.jpg)'
- en: 'Figure 12.8: NODE_HT_header is the first class in space_node.py'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8：NODE_HT_header 是 space_node.py 中的第一类
- en: 'As an alternative, we can print a list of all the header types using a `comprehension`
    in Blender’s Python console. We learned how to do this in [*Chapter 8*](B18375_08.xhtml#_idTextAnchor206):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，我们可以使用 Blender 的 Python 控制台中的 `comprehension` 打印所有标题类型的列表。我们已经在 [*第 8
    章*](B18375_08.xhtml#_idTextAnchor206) 中学习了如何这样做：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`NODE_HT_header` is in the middle of the list. We must append our entry to
    it inside the `register` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`NODE_HT_header` 在列表的中间。我们必须在 `register` 函数内部将其添加到我们的条目中：'
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `unregister`, we must remove our interface and class when the add-on is
    disabled:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `unregister` 中，当插件禁用时，我们必须删除我们的界面和类： '
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that the add-on is ready, we can use it for loading textures instantly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件已经准备好了，我们可以用它来即时加载纹理。
- en: Using Load Textures
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用加载纹理
- en: 'If the `ch12` folder was added to the **Scripts** path, we can enable **Textament**
    in the **Learning** category of the **Add-ons** preferences:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ch12` 文件夹被添加到 **Scripts** 路径，我们可以在 **Add-ons** 预设的 **Learning** 类别中启用 **Textament**：
- en: '![Figure 12.9: Enabling the “Textament” add-on](img/Figure_12.09_B18375.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9：启用“Textament”插件](img/Figure_12.09_B18375.jpg)'
- en: 'Figure 12.9: Enabling the “Textament” add-on'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9：启用“Textament”插件
- en: 'Once it’s enabled, a button called **Load Textures** will be added to the **Shader**
    **Editor** header:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用，将在**着色器** **编辑器**标题栏中添加一个名为**加载纹理**的按钮：
- en: '![Figure 12.10: The Load Textures button in the Shader Editor header](img/Figure_12.10_B18375.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10：着色器编辑器标题栏中的加载纹理按钮](img/Figure_12.10_B18375.jpg)'
- en: 'Figure 12.10: The Load Textures button in the Shader Editor header'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：着色器编辑器标题栏中的加载纹理按钮
- en: Selecting a node allows you to click the **Load Textures** button, which opens
    the **File** **Browser** area.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个节点后，你可以点击**加载纹理**按钮，这将打开**文件** **浏览器**区域。
- en: 'To test this add-on on a simple model, we can apply a brick wall material to
    the default cube by following these steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要在简单模型上测试此插件，我们可以通过以下步骤将砖墙材质应用到默认立方体上：
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Blender或通过**文件** | **新建** | **通用**返回默认场景。
- en: Switch to the **Shading** workspace using the tabs at the top of the window.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用窗口顶部的选项卡切换到**着色**工作区。
- en: Click **Load Textures** in the **Shader Editor** area’s header.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**着色器编辑器**区域的标题栏中点击**加载纹理**。
- en: In the **File Browser** area, navigate to a folder containing images. The textures
    accompanying this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文件浏览器**区域，导航到一个包含图像的文件夹。本章伴随的纹理可以在[https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures)找到。
- en: 'Optionally, we can switch the **File Browser** area to **thumbnails** mode
    by clicking the thumbnails button on the top right. This is useful for looking
    for textures:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，我们可以通过点击右上角的缩略图按钮将**文件浏览器**区域切换到**缩略图**模式。这对于寻找纹理很有用：
- en: '![Figure 12.11: “Load and connect” thumbnails in the File Browser area](img/Figure_12.11_B18375.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11：文件浏览器区域的“加载并连接”缩略图](img/Figure_12.11_B18375.jpg)'
- en: 'Figure 12.11: “Load and connect” thumbnails in the File Browser area'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：文件浏览器区域的“加载并连接”缩略图
- en: We can select multiple files by using the lasso, *Ctrl* + clicking, or pressing
    *A* to select all.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过套索、*Ctrl* + 点击或按*A*键来选择多个文件。
- en: Press **Load and connect** to add the textures to the graph.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**加载并连接**将纹理添加到图中。
- en: 'The `bricks_baseColor`, `bricks_normal`, and `bricks_roughness` textures are
    now the inputs of the material and make the cube look like a brick wall:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`bricks_baseColor`、`bricks_normal`和`bricks_roughness`纹理现在是材质的输入，使立方体看起来像砖墙：'
- en: '![Figure 12.12: Brick textures loaded into the Shader Editor area](img/Figure_12.12_B18375.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12：加载到着色器编辑器区域的砖纹理](img/Figure_12.12_B18375.jpg)'
- en: 'Figure 12.12: Brick textures loaded into the Shader Editor area'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：砖纹理加载到着色器编辑器区域
- en: The operator was successful but all the nodes were created at the center of
    the graph. We can improve this considerably by adding code that rearranges the
    nodes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员成功，但所有节点都创建在图的中心。我们可以通过添加重新排列节点的代码来显著改进这一点。
- en: Improving Load Textures
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进加载纹理
- en: Nodes can be moved to a different position by setting the `x` and `y` attributes
    of their `location` property. This allows us to arrange them in our scripts.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置节点`location`属性的`x`和`y`属性来将节点移动到不同的位置。这允许我们在脚本中排列它们。
- en: Arranging shader nodes
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安排着色器节点
- en: 'Even if we can move our nodes freely, the API poses a few limitations:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们可以自由移动节点，API也带来了一些限制：
- en: We can’t access the exact location of the sockets
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法访问插座的精确位置
- en: The width and height of new nodes are not available in the scripts
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新节点的高度和宽度在脚本中不可用
- en: One of those two issues at a time would be tolerable, as we could either move
    our nodes at the height of their inputs or get the space required by a new node
    on the fly. Since they occur together, we will resort to a workaround.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题中的任何一个都是可以容忍的，因为我们可以在节点输入的高度移动节点，或者实时获取新节点所需的空间。由于它们同时发生，我们将求助于一个解决方案。
- en: Assuming node spacing
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 假设节点间距
- en: 'We cannot get the size of new nodes in a script, but we can learn the default
    size of a texture node beforehand by looking at an existing shader tree. For instance,
    after we use `dimensions` property of an `''Image` `Texture''` node:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在脚本中获取新节点的大小，但我们可以通过查看现有的着色器树来预先了解纹理节点默认的大小。例如，在使用`'Image' `Texture'`节点的`dimensions`属性后：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Vector` property returned by `dimensions` contains the bounding box of
    the node, not the node’s exact measures. We can verify that by querying the node’s
    `width` instead:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`dimensions` 返回的 `Vector` 属性包含节点的边界框，而不是节点的精确尺寸。我们可以通过查询节点的 `width` 来验证这一点：'
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Even if it is present, the `height` attribute does not help because it hasn’t
    been updated and its value stays fixed at `100.0`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 即使存在，`height` 属性也没有帮助，因为它尚未更新，其值保持在 `100.0` 不变。
- en: 'Despite that weakness in the API, we have enough information to rearrange our
    tree: leaving `100.0` units between two nodes leaves enough room for connections,
    so we can use a spacing of `340.0` units between our textures and the initial
    node.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管API存在这种弱点，但我们有足够的信息来重新排列我们的树：在两个节点之间留下 `100.0` 单位的空间为连接留出足够的空间，因此我们可以在纹理和初始节点之间使用
    `340.0` 单位的间距。
- en: 'We must store that value in the declaration of our operator:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在操作符的声明中存储该值：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To arrange our nodes vertically, we need to process them in the correct order.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了垂直排列我们的节点，我们需要以正确的顺序处理它们。
- en: Sorting the node creation
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点创建排序
- en: 'To space the nodes vertically in the correct way, we need to process them while
    following the sockets order in the target node layout; otherwise, the connection
    links will cross each other:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以正确的方式垂直排列节点，我们需要在处理它们的同时遵循目标节点布局中的插座顺序；否则，连接链接会相互交叉：
- en: '![Figure 12.13: An unordered vertical arrangement leads to tangled, confusing
    links](img/Figure_12.13_B18375.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13：无序的垂直排列导致混乱、令人困惑的链接](img/Figure_12.13_B18375.jpg)'
- en: 'Figure 12.13: An unordered vertical arrangement leads to tangled, confusing
    links'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13：无序的垂直排列导致混乱、令人困惑的链接
- en: 'Python dictionaries are unordered by design, so `matching_names` doesn’t follow
    any order, but the `input_names` list does. This list contains the ordered names
    of all sockets. By filtering it with `matching_names`, we can obtain an ordered
    list of the matching inputs:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Python 字典按设计是无序的，因此 `matching_names` 不遵循任何顺序，但 `input_names` 列表是按顺序排列的。通过使用
    `matching_names` 过滤它，我们可以获得匹配输入的有序列表：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We must replace the `for inp, fname in matching_names.items()` loop with an
    iteration of `sorted_inputs`. Since we need an ordinal for vertical spacing, we
    must use `enumerate` to get the index of the current input. Here is the new image
    loop:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将 `for inp, fname in matching_names.items()` 循环替换为 `sorted_inputs` 的迭代。由于我们需要一个序号来进行垂直间距，我们必须使用
    `enumerate` 来获取当前输入的索引。以下是新的图像循环：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After a texture nodes is connected, we can change its location. We start with
    the same coordinates as `target_node`, then move the texture to the left by subtracting
    `_spacing` from `location.x`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接纹理节点之后，我们可以更改其位置。我们首先使用与 `target_node` 相同的坐标，然后通过从 `location.x` 减去 `_spacing`
    来将纹理向左移动：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can move the texture nodes downwards by subtracting `self._spacing` from
    `location.y`. We are stacking the nodes vertically, so their `y` coordinates depend
    on their ordinal indexes. The first node, which has an index of `0`, will not
    move at all from the initial position, the second node moves down by `self._spacing`
    times `1`, the third by `self._spacing` times `2`, and so on:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从 `location.y` 减去 `self._spacing` 来向下移动纹理节点。我们正在垂直堆叠节点，因此它们的 `y` 坐标取决于它们的序号索引。第一个节点（索引为
    `0`）将完全保持在初始位置不动，第二个节点向下移动 `self._spacing` 倍的 `1`，第三个向下移动 `self._spacing` 倍的 `2`，依此类推：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Connecting `ShaderNodeNormalMap` requires horizontal space, so, after we align
    `normal_map` with its `img_node`, we must make some room by moving the texture
    to the left and `normal_map` to the right, by an amount of half `_spacing`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 `ShaderNodeNormalMap` 需要水平空间，因此，在我们将 `normal_map` 与其 `img_node` 对齐后，我们必须通过将纹理向左移动和将
    `normal_map` 向右移动一半的 `_spacing` 来腾出一些空间：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we must save the add-on and update it by clicking *F3* and choosing **Reload
    Scripts**. Launching **Load Textures** sets up a properly arranged node tree:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须保存插件并更新它，通过点击 *F3* 并选择**重新加载脚本**。启动**加载纹理**设置了一个正确排列的节点树：
- en: '![Figure 12.14: Texture set up, with arranged nodes](img/Figure_12.14_B18375.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14：纹理设置，节点排列](img/Figure_12.14_B18375.jpg)'
- en: 'Figure 12.14: Texture set up, with arranged nodes'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14：纹理设置，节点排列
- en: Now that the basic functionality is complete, we can implement an option for
    customizing the color of the material.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本功能已经完成，我们可以实现一个选项来自定义材质的颜色。
- en: Mixing the Base Color
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合基础颜色
- en: 'Sometimes, even if we are happy with our texture setup, we want to change the
    color while retaining the texture pattern. We can do that by adding a **MixRGB**
    node before the **Base Color** property of a principled node:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，即使我们对纹理设置感到满意，我们仍然想要在保留纹理图案的同时更改颜色。我们可以通过在原则节点`Base Color`属性之前添加一个**MixRGB**节点来实现这一点：
- en: '![Figure 12.15: Affecting the material color with a MixRGB node](img/Figure_12.15_B18375.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图12.15：使用MixRGB节点影响材质颜色](img/Figure_12.15_B18375.jpg)'
- en: 'Figure 12.15: Affecting the material color with a MixRGB node'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：使用MixRGB节点影响材质颜色
- en: The **MixRGB** node features a factor slider (**Fac**) for blending two colors.
    The default blending type, **Mix**, replaces **Color1** with **Color2**, but other
    blending modes known in computer graphics, such as **Multiply**, **Overlay**,
    and **Color Dodge**, are also available.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**MixRGB**节点具有一个用于混合两种颜色的因子滑块（**Fac**）。默认的混合类型**Mix**用**Color2**替换**Color1**，但计算机图形学中已知的其他混合模式，如**Multiply**、**Overlay**和**Color
    Dodge**，也是可用的。'
- en: 'The Python setup for a `ShaderNodeMixRGB` node is similar to that of a `"Base
    Color"`, we create an intermediate node:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShaderNodeMixRGB`节点的Python设置与`"Base Color"`类似，我们创建一个中间节点：'
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we align the image texture and the **Mix** node, and make room for additional
    connection links:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将图像纹理和**Mix**节点对齐，并为额外的连接链接留出空间：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We connect the image color to the `"Color1"` input of the **Mix** node:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图像颜色连接到**Mix**节点的`"Color1"`输入：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this point, we would connect the `img_node` variable instead.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该连接`img_node`变量。
- en: 'This way, the connection to `target_node` is made by the same line of code
    that connects all the other inputs except `"Normal"`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，通过连接所有其他输入（除了`"Normal"`）的同一行代码，我们就可以将`target_node`连接起来：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we execute **Reload Scripts** and then launch **Load Textures** again, a
    mixed layout like the one displayed in *Figure 12**.15* is created. We can click
    on the **Color2** attribute and select a color from the picker or change the **Mix**
    node’s **Blending Mode** from its drop-down menu.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行**重新加载脚本**然后再次启动**加载纹理**，就会创建一个类似于*图12.15*中显示的混合布局。我们可以点击**Color2**属性并从拾色器中选择颜色，或者从下拉菜单中更改**Mix**节点的**混合模式**。
- en: We can also experiment with different solutions. For instance, we can use `"ShaderNodeMixRGB"`
    with `"ShaderNodeHueSaturation"` and `"Color1"` with `"Color"`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试不同的解决方案。例如，我们可以使用`"ShaderNodeMixRGB"`与`"ShaderNodeHueSaturation"`以及`"Color1"`与`"Color"`。
- en: Node trees are interesting as they can be considered visual programming, but
    even the trivial operation of loading a few textures, if done manually, can take
    time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 节点树很有趣，因为它们可以被视为可视化编程，但即使是加载几个纹理这样的简单操作，如果手动进行，也可能需要花费时间。
- en: This time, we didn’t have to create an interface for manipulating the blended
    color as the mix node already provides it, so we could combine the best of two
    procedural approaches.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不需要为操作混合颜色创建界面，因为混合节点已经提供了它，所以我们能够结合两种过程方法的优点。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how materials work and how nodes are created and
    connected in the **Shader Editor** area. We also learned how image textures can
    change the appearance of shaded objects and how they can store non-color data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了材质的工作原理以及如何在**着色器编辑器**区域中创建和连接节点。我们还学习了图像纹理如何改变着色物体的外观以及它们如何存储非颜色数据。
- en: This was our first encounter with node trees, a generic visual programming approach
    that is not limited to shaders and is planned to expand to deformation and rigging
    in the future.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次接触节点树，这是一种通用的可视化编程方法，不仅限于着色器，并计划在未来扩展到变形和绑定。
- en: Node-based systems are flexible and powerful, but they benefit from scripted
    tools, like all other aspects of Blender.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 基于节点的系统灵活且强大，但它们从脚本工具中受益，就像Blender的其他所有方面一样。
- en: Rendering is not the final step of production as compositing and editing follow
    in the computer graphics pipeline. But since this stage converts three-dimensional
    data into images, it’s usually considered the last step of the 3D workflow.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染并不是生产的最终步骤，因为合成和编辑在计算机图形管道中紧随其后。但既然这一阶段将三维数据转换为图像，它通常被认为是3D工作流程的最后一步。
- en: That ends our journey into how Blender scripting works. We have covered object
    creation, deformation, animation, and rendering, but most importantly, how tools
    are designed and implemented, and how the software limitations can be overcome.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Blender脚本工作原理的探索。我们已经涵盖了对象创建、变形、动画和渲染，但最重要的是，工具的设计和实现方式，以及如何克服软件的限制。
- en: Those skills, combined with individual talent and experience, allow technical
    directors to bridge between artistic needs and software capabilities, empower
    their teams, and improve their abilities and understanding in the process.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '这些技能，结合个人才能和经验，使技术指导员能够在艺术需求与软件能力之间架起桥梁，赋能他们的团队，并在过程中提高他们的能力和理解。 '
- en: Questions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How many render engines are present in Blender?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Blender中存在多少渲染引擎？
- en: Do the words *material* and *shader* have the same meaning?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “材质”和“着色器”这两个词有相同的意思吗？
- en: Are the shader nodes predefined values that determine how objects look or separate
    units performing independent operations?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器节点是预先定义的值，用于确定对象的外观，还是独立执行操作的单独单元？
- en: Can we use images for coloring objects?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否使用图像为对象着色？
- en: Can we make connections between different data types?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在不同数据类型之间建立联系？
- en: How do we arrange nodes in a graph?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在图中排列节点？
- en: In our shaders, can we alter the colors coming from an image?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的着色器中，我们能否改变来自图像的颜色？
- en: Appendix
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Blender and Python are so vast that even writing scripts for a shortlist of
    use cases encompasses a wide range of skills and disciplines. This book contains
    elements of animation, rigging, and shading and introduces programming techniques
    while exploring those processes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Blender和Python如此庞大，以至于即使是针对短列表用例编写脚本也涵盖了广泛的技能和学科。本书包含了动画、绑定和着色元素，并在探索这些过程中介绍了编程技术。
- en: This appendix contains a comprehensive summary that can be useful as a recap
    to help with the retention of the concepts explored in this book and help the
    reader navigate through the chapters.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录包含一个全面的总结，可以作为复习，帮助读者巩固本书探讨的概念，并帮助读者在章节之间导航。
- en: 'Part 1: An Introduction to Python'
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分：Python简介
- en: This section covers the fundamentals of scripting and helps you become familiar
    with Blender’s Python utilities. Besides providing a solid base for the chapters
    ahead, it contains all the information required for writing fully working tools.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了脚本编写的基础知识，并帮助您熟悉Blender的Python实用工具。除了为后续章节提供坚实的基础外，它还包含了编写完整工作工具所需的所有信息。
- en: '[Chapter 1](B18375_01.xhtml#_idTextAnchor014), Python’s Integration with Blender'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第1章](B18375_01.xhtml#_idTextAnchor014)，Python与Blender的集成'
- en: This chapter introduces the tools used for scripting, internal and external
    text editors, and version control.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了用于脚本编写的工具，内部和外部文本编辑器，以及版本控制。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里总结了本章讨论的主题。
- en: Installing multiple versions of Blender on the main operating systems
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在主要操作系统上安装多个版本的Blender
- en: 'Blender 3.3 is the *long-term support* release used in the writing process.
    Although the content of this book is valid for all the 3\. x series of blender,
    if you want to install version 3.3 alongside other versions, the following instructions
    are provided:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 3.3是写作过程中使用的*长期支持*版本。尽管本书的内容对所有3.x系列的Blender版本都有效，但如果您想在其他版本旁边安装3.3版本，以下提供了相应的说明：
- en: Using Windows Installer
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Windows安装程序
- en: Using the Microsoft Store
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Microsoft Store
- en: Downloading a portable archive
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载便携式存档
- en: Installing on macOS
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在macOS上安装
- en: Using Python in Blender
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Blender中使用Python
- en: 'The **Scripting** workspace is a Blender layout optimized for running Python
    quickly. It consists of an interactive console, a logger listing the commands
    of past actions, and a Text Editor that can run scripts. We will become familiar
    with it through these topics:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本**工作区是一个针对快速运行Python优化的Blender布局。它包括一个交互式控制台、一个列出过去操作命令的记录器，以及一个可以运行脚本的文本编辑器。我们将通过以下主题熟悉它：'
- en: Producing console output with the *“Hello* *World!”* example
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“Hello World！”示例产生控制台输出
- en: How to copy and paste Python instructions from the **Info Log**
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从**信息日志**中复制和粘贴Python指令
- en: Checking the current version of Blender and Python using scripts
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本检查Blender和Python的当前版本
- en: An explanation of functions and arguments
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和参数的解释
- en: Using external editors and version control tools
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用外部编辑器和版本控制工具
- en: 'Even though the Text Editor is quick and useful, programmers usually take advantage
    of external code editors as well. **Visual Studio Code**, a multiplatform editor
    from **Microsoft**, is used in this book, but there are plenty of alternatives.
    **Version control** tools are useful tools that for storing the history of code
    changes. We learn how to use these tools by going through the following topics:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管文本编辑器快速且有用，但程序员通常还会利用外部代码编辑器。本书中使用的是来自**Microsoft**的多平台编辑器**Visual Studio
    Code**，但还有许多替代方案。**版本控制**工具是用于存储代码更改历史的实用工具。我们通过以下主题学习如何使用这些工具：
- en: Loading folders in Visual Studio Code
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中加载文件夹
- en: Refreshing text files in the Blender Text Editor
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Blender文本编辑器中刷新文本文件
- en: Initializing and using a **Git** repository
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化和使用**Git**仓库
- en: '[Chapter 2](B18375_02.xhtml#_idTextAnchor033), Python Entities and API'
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第2章](B18375_02.xhtml#_idTextAnchor033)，Python实体和API'
- en: This chapter explains how to interact with Blender using scripts, how to take
    advantage of features for developers, and how the **Application Programming Interface**
    (**API**) works.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何使用脚本与Blender交互，如何利用开发者功能，以及**应用程序编程接口**（**API**）的工作原理。
- en: The following sections are a summary of the topics discussed in the chapter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节是本章讨论主题的摘要。
- en: User interface features for developers
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发者用户界面功能
- en: 'There are two useful options in the **Interface** section of Blender’s preferences:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender首选项的**界面**部分有两个有用的选项：
- en: '**Developer Extras**: This displays the **Edit Source** option when we right-click
    on an element of the interface so that we can easily access the Python source
    code of the **user interface** (**UI**). It also makes non-UI operators available
    in the search bar.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者附加功能**：当我们在界面元素上右键单击时，它会显示**编辑源**选项，以便我们可以轻松访问**用户界面**（**UI**）的Python源代码。它还使非UI操作员在搜索栏中可用。'
- en: '**Python Tooltips**: This displays the Python property relative to the UI element
    under the mouse cursor.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python提示**：此功能显示鼠标光标下UI元素的相对Python属性。'
- en: Console features for developers
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发者控制台功能
- en: 'The interactive console provides two handy features for quick scripting:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式控制台提供了两个方便的功能，用于快速脚本编写：
- en: Code auto-completion by pressing the *Tab* key
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按*Tab*键进行代码自动补全
- en: Commands history by pressing the Up-arrow key
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按上箭头键查看命令历史
- en: Viewport features for developers
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发者视图功能
- en: The **Math Vis (Console)** add-on included with Blender and available in the
    **3D View** section of the **Preferences** > **Add-ons** dialog displays three-dimensional
    mathematical entities such as *vectors* and *matrices* in the 3D Viewport. It
    can be useful when working with object location and rotation values.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在Blender中并提供在**首选项** > **插件**对话框中**3D视图**部分的**Math Vis (Console)**插件显示三维数学实体，如*向量*和*矩阵*在3D视图中。当处理对象位置和旋转值时可能很有用。
- en: Using Blender modules
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Blender模块
- en: Blender’s Python module, `bpy`, is accessed in scripts using the `import` statement.
    Each of its components covers a specific aspect of the 3D app. Most notably, `data`
    contains all the objects available in the current session, while `context` contains
    the current state of the user interaction, such as the current selection. The
    API documentation is available online but can also be viewed using the `help()`
    function.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中使用`import`语句访问Blender的Python模块`bpy`。它的每个组件都涵盖3D应用程序的特定方面。最值得注意的是，`data`包含当前会话中所有可用的对象，而`context`包含用户交互的当前状态，例如当前选择。API文档可在网上查看，也可以使用`help()`函数查看。
- en: Using object collections
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对象集合
- en: Lists of objects are accessed through `bpy_collection`, an aggregate type similar
    to a Python `dictionary`. Elements of a collection can be accessed with numeral
    indices or keywords and can be iterated in Python loops.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对象列表通过`bpy_collection`访问，这是一种类似于Python `dictionary`的聚合类型。集合的元素可以通过数字索引或关键字访问，并且可以在Python循环中迭代。
- en: Operations such as renaming can reorder the elements of a collection, so a conversion
    to `list` is advised when the order is critical.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 像重命名这样的操作可以重新排序集合的元素，因此在顺序至关重要时建议转换为`list`。
- en: 'Blender collections don’t have an `append()` method: the `new()` method is
    used for creating a new object, which is automatically appended. The `remove()`
    method removes an element from a collection and deletes it from Blender.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Blender集合没有`append()`方法：使用`new()`方法创建新对象，该对象将自动附加。`remove()`方法从集合中删除元素并将其从Blender中删除。
- en: Context and user activity
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文和用户活动
- en: Users can change the current state or context of Blender by adding or selecting
    objects. The last selected object is considered *active* and is the main target
    of object-related actions.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过添加或选择对象来更改Blender的当前状态或上下文。最后选中的对象被认为是*活动*的，并且是对象相关操作的主要目标。
- en: Context information is available as properties of `bpy.context`, is read-only,
    and can only be changed indirectly. For instance, `ob.select_set(True)` is used
    to select an object, as it’s impossible to append to the `bpy.context.selected_objects`
    list.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文信息作为`bpy.context`的属性可用，是只读的，并且只能间接更改。例如，`ob.select_set(True)`用于选择一个对象，因为它不可能追加到`bpy.context.selected_objects`列表中。
- en: '[Chapter 3](B18375_03.xhtml#_idTextAnchor049), Creating Your Add-Ons'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第3章](B18375_03.xhtml#_idTextAnchor049)，创建您的附加功能'
- en: 'This chapter illustrates the process of creating Blender add-ons: Python scripts
    that can be installed as Blender plugins to add custom functions.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本章说明了创建Blender附加功能的过程：可以作为Blender插件安装的Python脚本，以添加自定义功能。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章讨论主题的总结。
- en: Writing scripts that are add-ons
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写附加功能的脚本
- en: Add-ons are Python modules or packages containing a dictionary named `bl_info`.
    This dictionary contains information such as the author and name of the add-on.
    Add-ons must provide two functions, `register()` and `unregister()`, used when
    an add-on is enabled or disabled.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 附加功能是包含名为`bl_info`的字典的Python模块或包。此字典包含有关附加功能的作者和名称等信息。附加功能必须提供两个函数，`register()`和`unregister()`，用于在启用或禁用附加功能时使用。
- en: Add-ons can be installed in Blender preferences, but setting the folder where
    they are developed as `Reload Scripts` in the *F3* key search bar.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 附加功能可以在Blender首选项中安装，但将它们开发的文件夹设置为*F3*键搜索栏中的*重新加载脚本*。
- en: Writing Object Collector, an add-on that groups objects in the Outliner
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写对象收集器，一个将对象分组在Outliner中的附加功能
- en: Adding features to Blender involves the creation of an operator, that is, an
    instruction that can be launched from the user interface. The `bl_idname` and
    `bl_label` attributes determine how an operator is found and displayed in Blender,
    while the `poll()` and `execute()` functions regulate when it can be launched
    and what happens when it runs.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 向Blender添加功能涉及创建一个操作符，即可以从用户界面启动的指令。`bl_idname`和`bl_label`属性决定了操作符在Blender中的查找和显示方式，而`poll()`和`execute()`函数则规定了何时可以启动以及运行时会发生什么。
- en: Add-ons add operators to Blender in their `register()` and `unregister()` functions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 附加功能在其`register()`和`unregister()`函数中向Blender添加操作符。
- en: Tips for working on add-ons
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理附加功能的技巧
- en: When using an external editor, enabling auto-save might help ensure that the
    Python script always includes the latest changes.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用外部编辑器时，启用自动保存可能有助于确保Python脚本始终包含最新的更改。
- en: Enabling add-ons from the development folder might leave *bytecode*, that is,
    Python-compiled files in a folder named `__pycache__`. If we use Git version control,
    we can create a text file named `.gitignore` that contains `__pycache__` to avoid
    bytecode files ever being versioned.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发文件夹启用附加功能可能会留下*字节码*，即名为`__pycache__`文件夹中的Python编译文件。如果我们使用Git版本控制，我们可以创建一个名为`.gitignore`的文本文件，其中包含`__pycache__`以避免字节码文件被版本化。
- en: Avoiding duplicates using try and except
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用try和except避免重复
- en: To prevent our script from creating the same collection twice, resulting in
    duplicates, we look for a collection inside a `try` statement and add an `except
    KeyError` block that is triggered when no collection is found. By creating new
    collections under the `except` statement, we ensure that collections with a given
    name are only created once. The try/except pattern is called *forgiveness rather
    than permission*, as it focuses on pulling back from non-allowed actions rather
    than checking whether an action is possible in the first place.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的脚本创建相同的集合两次，导致重复，我们在`try`语句中查找集合，并添加一个`except KeyError`块，当找不到集合时触发。通过在`except`语句下创建新的集合，我们确保具有给定名称的集合只创建一次。try/except模式被称为*宽恕而非许可*，因为它侧重于从非允许的操作中撤回，而不是检查操作是否首先可行。
- en: We use the `title()` string method for nicely formatted names with a capital
    first letter. We can create functions for adding our operator to Blender menus.
    They accept the `self` and `context` arguments and add operators to `self.layout`.
    Menu functions are added to Blender in the `register()` and `unregister()` functions
    of the add-on.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`title()`字符串方法为具有大写首字母的名称提供良好的格式化。我们可以创建函数将我们的运算符添加到Blender菜单中。它们接受`self`和`context`参数，并将运算符添加到`self.layout`。菜单函数通过附加组件的`register()`和`unregister()`函数添加到Blender中。
- en: '[Chapter 4](B18375_04.xhtml#_idTextAnchor075), Exploring Object Transformations'
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第4章](B18375_04.xhtml#_idTextAnchor075)，探索对象变换'
- en: This chapter shows how to affect `location`, `rotation`, and `scale` of an object
    using Python and how the transform information is stored in Blender.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何使用Python影响对象的`location`、`rotation`和`scale`，以及变换信息在Blender中的存储方式。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章讨论主题的总结。
- en: Moving and scaling objects with Python
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python移动和缩放对象
- en: '`location` is stored as the `x`, `y`, and `z` coordinates of a three-dimensional
    vector. The coordinates of a vector can be changed individually or together, using
    tuple assignment.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`存储为三维向量的`x`、`y`和`z`坐标。向量的坐标可以单独或一起更改，使用元组赋值。'
- en: '`scale` is stored as an `x`, `y`, `z` vector too. While the rest value of `location`
    has the `(0.0, 0.0, 0.0)` coordinates, a non-scaled object’s `scale` attribute
    is `(1.0,` `1.0, 1.0)`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale`也存储为`x`、`y`、`z`向量。虽然`location`的其余值具有`(0.0, 0.0, 0.0)`坐标，但未缩放对象的`scale`属性是`(1.0,`
    `1.0, 1.0)`。'
- en: Peculiarities of rotations
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旋转的奇特之处
- en: Rotations are less straightforward than `location` and `scale`, as the `rotation`
    values over the three axes can affect each other, causing an issue known as *gimbal
    lock*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转比`location`和`scale`更复杂，因为三个轴上的旋转值可能会相互影响，导致一个称为*万向节锁*的问题。
- en: 'There is more than one way to represent rotations; some involve multidimensional
    entities such as quaternions or rotation matrices, and two measure units for angles:
    *degrees* and *radians*. Blender objects have attributes for each notation system,
    which can be set via Python. Conversion utilities are provided for switching from
    one notation system to another.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转有多种表示方式；一些涉及多维实体，如四元数或旋转矩阵，以及两种角度度量单位：*度*和*弧度*。Blender对象具有每个表示系统的属性，可以通过Python设置。提供了转换实用工具，用于在一种表示系统之间切换。
- en: Indirect transformations with parents and constraints
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用父亲和约束进行间接变换
- en: Objects can be arranged in hierarchies. Transformations of an object higher
    in the hierarchy (*parent*) affect all the objects under them (*children*).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以按层次排列。层次中较高的对象（*父对象*）的变换会影响其下的所有对象（*子对象*）。
- en: Constraints are another way to transform an object without affecting its channels.
    They can be added using the `new()` method of the `constraints` collection.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是另一种在不影响其通道的情况下转换对象的方法。它们可以通过使用`constraints`集合的`new()`方法添加。
- en: Transforming objects with matrices
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用矩阵变换对象
- en: Setting values for the `location`, `rotation`, and `scale` channels affects
    the relative coordinates of an object. Assigning a transformation matrix allows
    us to use world-space coordinates instead. Matrix values are lazy-copied unless
    stated otherwise; if we store a matrix as a variable and don’t want its values
    to change we need to use its `copy()` method.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为`location`、`rotation`和`scale`通道设置值会影响对象的相对坐标。分配一个变换矩阵允许我们使用世界空间坐标。除非另有说明，矩阵值是延迟复制的；如果我们想存储一个矩阵作为变量并且不希望其值改变，我们需要使用它的`copy()`方法。
- en: Parenting to a transformed object in Python changes the object location unless
    a reverse transformation is set in the `matrix_parent_inverse` attribute.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中将对象作为变换对象进行父化会改变对象位置，除非在`matrix_parent_inverse`属性中设置了反向变换。
- en: Writing Elevator, an add-on that sets a floor for the selected objects
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Elevator，一个为所选对象设置楼层的附加组件
- en: The operator from the `FloatProperty` that can be set when it’s launched. Optional
    behaviors can be enabled by switching its `BoolProperty` members.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动时可以设置的`FloatProperty`运算符。可以通过切换其`BoolProperty`成员启用可选行为。
- en: Editable properties must be added as *annotations*, Python arbitrary attributes.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 必须将可编辑属性作为*注释*、Python任意属性添加。
- en: Parent objects at the top of the hierarchy are moved first to avoid duplicate
    transformations. Constraints can be used optionally.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构顶部移动父对象以避免重复变换。可以可选地使用约束。
- en: '[Chapter 5](B18375_05.xhtml#_idTextAnchor100), Designing Graphical Interfaces'
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第5章](B18375_05.xhtml#_idTextAnchor100)，设计图形界面'
- en: This chapter explains how to add custom panels and add them to the Blender interface.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何添加自定义面板并将它们添加到Blender界面中。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章讨论主题的总结。
- en: Components of the UI
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI组件
- en: The Blender window is structured into areas, regions, and panels. Panels have
    a layout that is populated with text, icons, and buttons using Python.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Blender窗口结构为区域、区域和面板。面板使用Python填充文本、图标和按钮的布局。
- en: Writing the Simple Panel add-on
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Simple Panel插件
- en: This add-on registers a simple `Panel` class that displays text and icons in
    the `row()` or `column()`methods, non-uniform columns using `split()`, and uniform
    tables using `grid_flow()`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件注册了一个简单的`Panel`类，该类在`row()`或`column()`方法中显示文本和图标，使用`split()`显示非均匀列，使用`grid_flow()`显示均匀表格。
- en: Blender icon names can be looked up using the **Icon Viewer** add-on or, in
    some cases, built using Python’s string formatting.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**图标查看器**插件或在某些情况下使用Python的字符串格式化查找Blender图标名称。
- en: Red and gray colors can be used to give visual feedback using the `alert` or
    `enabled` flags of a widget.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用红色和灰色颜色通过小部件的`alert`或`enabled`标志提供视觉反馈。
- en: Operators added to a layout using the `operator()` method are displayed as buttons.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`operator()`方法添加到布局中的操作员将显示为按钮。
- en: 'Part 2: Interactive Tools and Animation'
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：交互工具和动画
- en: This section explains how to write add-ons as folders rather than single files,
    interact with the animation system, and write modal operators that wait for user
    input. By the end of this section, you will be able to write advanced, interactive
    tools.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何将插件编写为文件夹而不是单个文件，与动画系统交互，并编写等待用户输入的模式操作员。在本节结束时，您将能够编写高级的交互式工具。
- en: '[Chapter 6](B18375_06.xhtml#_idTextAnchor129), Structuring Our Code and Add-Ons'
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第6章](B18375_06.xhtml#_idTextAnchor129)，构建我们的代码和插件'
- en: This chapter explains how to write and distribute addons containing multiple
    files in a folder.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何编写包含文件夹中多个文件的插件，并分发这些插件。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章讨论主题的总结。
- en: The relationship between modules, packages, and add-ons
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块、包和插件之间的关系
- en: While a single `.py` file is a Python module, a folder containing `.py` files
    is a Python package. Packages contain a file named `__init__.py`. If our package
    is an add-on, this file must contain the `bl_info` dictionary.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单个`.py`文件是一个Python模块，但包含`.py`文件的文件夹是一个Python包。包包含一个名为`__init__.py`的文件。如果我们的包是插件，则此文件必须包含`bl_info`字典。
- en: Guidelines for partitioning code
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分区代码的指南
- en: 'Some criteria for separating the code through different `.py` files are as
    follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不同的`.py`文件分离代码的一些标准如下：
- en: Media loaders
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体加载器
- en: Generic code versus specific code
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用代码与特定代码
- en: Interface code
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界面代码
- en: Operator modules
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员模块
- en: Use of imported modules
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入模块的使用
- en: For example, all the code used for loading custom icons, as explained in [*Chapter
    5*](B18375_05.xhtml#_idTextAnchor100), can be moved to a module named `img_loader.py`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，所有用于加载自定义图标（如[*第5章*](B18375_05.xhtml#_idTextAnchor100)中所述）的代码都可以移动到名为`img_loader.py`的模块中。
- en: Only `__init__.py` is reloaded by the `importlib.reload()` function.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`__init__.py`文件会被`importlib.reload()`函数重新加载。
- en: A panel to display the add-on preferences can be written in a `preferences.py`
    file, while `panel.py` and `operators.py` contain, respectively, the UI and the
    add-on operators.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`preferences.py`文件中编写用于显示插件首选项的面板，而`panel.py`和`operators.py`分别包含UI和插件操作员。
- en: Add-on folders compressed as `.zip` archives can be installed using the **Preferences**
    | **Addons** | **Install** button.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 将压缩为`.zip`存档的插件文件夹可以使用**首选项** | **插件** | **安装**按钮安装。
- en: '[Chapter 7](B18375_07.xhtml#_idTextAnchor171), The Animation System'
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第7章](B18375_07.xhtml#_idTextAnchor171)，动画系统'
- en: This chapter explains how to animate objects in Blender and how to create and
    edit animations with Python.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何在Blender中动画化对象，以及如何使用Python创建和编辑动画。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章讨论主题的总结。
- en: The Animation system
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画系统
- en: The **Layout** and **Animation** Workspaces display animation keyframes on a
    **Timeline** including the scene actions, keyframes, and range. Keyframes establish
    the value of a property at a certain time.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**布局**和**动画**工作空间在**时间轴**上显示动画关键帧，包括场景动作、关键帧和范围。关键帧确定了某个时间点的属性值。'
- en: Writing the Action to Range add-on
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Action to Range插件
- en: This add-on sets the start and end of the playback to the first and last frame
    of the current action of the active object. If a timeline is displayed onscreen,
    it is recentered to the new range. To do that, `context.temp_override()` is used
    to pass a timeline region to the `bpy.ops.action.view_all()` factory operator.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 此附加组件将播放的开始和结束设置为活动对象当前动作的第一帧和最后一帧。如果屏幕上显示时间轴，它将重新居中到新的范围。为此，使用`context.temp_override()`将时间轴区域传递给`bpy.ops.action.view_all()`工厂操作符。
- en: Writing the Vert Runner add-on
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Vert Runner附加组件
- en: This add-on animates the selected objects along the vertices of the active object.
    The vertex coordinates stored in `context.object.data.vertices` are read, while
    trigonometric functions are used for computing the shortest rotation arc that
    orients an object toward its next position.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此附加组件沿着活动对象的顶点动画化所选对象。读取存储在`context.object.data.vertices`中的顶点坐标，同时使用三角函数计算将对象定向到其下一个位置的最短旋转弧。
- en: '[Chapter 8](B18375_08.xhtml#_idTextAnchor206), Animation Modifiers'
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第8章](B18375_08.xhtml#_idTextAnchor206)，动画修改器'
- en: This chapter covers non-destructive modifiers for animation f-curves and their
    use in animating procedural effects.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了用于动画f曲线的非破坏性修改器及其在动画程序效果中的应用。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章讨论主题的总结。
- en: Adding f-curve modifiers
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加f曲线修改器
- en: F-curve modifiers can be added by selecting a curve in the graph editor and
    clicking `new()` method from the `modifiers` collection of f-curves.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在图编辑器中选择曲线并从f曲线的`modifiers`集合中点击`new()`方法来添加f曲线修改器。
- en: Writing the Shaker add-on
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写震动附加组件
- en: This add-on uses a **Noise** f-modifier to add a trembling effect on the active
    object and allows to set the duration and amount of the trembling. *Soft limits*
    set an initial limitation on the noise strength parameter while still allowing
    you to type out-of-range values using the keyboard. We add a menu entry for invoking
    this operator using the right-click menu in the Viewport.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此附加组件使用**噪声**f修改器在活动对象上添加颤抖效果，并允许设置颤抖的持续时间和数量。*软限制*对噪声强度参数设置初始限制，同时仍然允许您使用键盘输入超出范围的值。我们添加了一个菜单项，通过在视图中右键单击菜单调用此操作符。
- en: '[Chapter 9](B18375_09.xhtml#_idTextAnchor226), Animation Drivers'
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第9章](B18375_09.xhtml#_idTextAnchor226)，动画驱动器'
- en: This chapter introduces animation drivers, which are the connections between
    different properties used to control complex actions. Drivers can incorporate
    short Python expressions in their logic.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了动画驱动器，它们是用于控制复杂动作的不同属性之间的连接。驱动器可以在其逻辑中包含简短的Python表达式。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章讨论主题的总结。
- en: Creating and setting drivers
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和设置驱动器
- en: Drivers can be created quickly by selecting **Copy As New Driver** and **Paste
    Driver** from the right-click menu of Blender properties. Using an object’s location
    as input for its rotation creates a wheel setup since the object rotates when
    it’s moved.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从Blender属性的右键单击菜单中选择**复制为新驱动器**和**粘贴驱动器**来快速创建驱动器。使用对象的定位作为其旋转的输入创建了一个轮设置，因为当对象移动时，对象会旋转。
- en: Using Python drivers
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python驱动器
- en: Python expression-based drivers can be created quickly by pressing the *#* key,
    followed by Python code while editing a Blender property. Oscillatory motions
    can be created using trigonometric cyclic functions such as `sin`, and the pendulum
    equation from the physics classroom can be implemented as a driver expression.
    Object custom properties can be used as parameters in driver expressions.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在编辑Blender属性时按*#*键，然后输入Python代码，可以快速创建基于Python表达式的驱动器。可以使用三角周期函数如`sin`创建振荡运动，并将物理课堂中的摆动方程实现为驱动器表达式。可以将对象自定义属性用作驱动器表达式中的参数。
- en: Writing the Pendulum add-on
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写摆动附加组件
- en: This add-on instantly sets up the pendulum expression and parameters. Drivers
    are added using the `object.driver_add()` method.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 此附加组件立即设置摆动表达式和参数。通过使用`object.driver_add()`方法添加驱动器。
- en: '[Chapter 10](B18375_10.xhtml#_idTextAnchor247), Advanced and Modal Operators'
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第10章](B18375_10.xhtml#_idTextAnchor247)，高级和模态算子'
- en: This chapter explains how to write advanced operators by enriching their execution
    flow and implementing optional methods.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何通过丰富执行流程和实现可选方法来编写高级算子。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章讨论主题的总结。
- en: Operator execution details
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算子执行细节
- en: The `invoke()` method of `Operator`, if defined, runs when the operator is launched.
    Inside `invoke()`, we can switch either to the `execute()` method or to the `modal()`
    method. The latter listens to user inputs such as key presses or mouse movements.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`Operator` 的 `invoke()` 方法，如果已定义，则在启动操作时运行。在 `invoke()` 内部，我们可以切换到 `execute()`
    方法或 `modal()` 方法。后者监听用户输入，如按键或鼠标移动。'
- en: Writing the PunchClock add-on
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 PunchClock 扩展插件
- en: This add-on creates time-formatted text in the scene. Its operator sets the
    initial values of its hour and minute parameters in `invoke()` using Python `datetime`
    utilities. When adding the operator to a menu, `operator_context` of the layout
    is set to `"INVOKE_DEFAULT"` so that the execution of `invoke()` is never skipped.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件在场景中创建时间格式化的文本。其操作符在 `invoke()` 中使用 Python `datetime` 工具设置其小时和分钟参数的初始值。当将操作符添加到菜单时，布局的
    `operator_context` 设置为 `"INVOKE_DEFAULT"`，以确保 `invoke()` 的执行永远不会被跳过。
- en: Modal behavior
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模态行为
- en: The operator is added to the modal handlers so that its `modal()` method is
    run at every update of the UI. Inside the modal, the `"MOUSEMOVE"` events change
    the displayed hour and minute.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符被添加到模态处理程序中，以便在 UI 的每次更新时运行其 `modal()` 方法。在模态内部，`"MOUSEMOVE"` 事件更改显示的小时和分钟。
- en: Customizing the undo panel
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义撤销面板
- en: The undo panel displays the operator properties after the execution is customized
    by implementing the `draw()` method. With this method, we can design a graphic
    interface using the same techniques learned in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过实现 `draw()` 方法自定义执行后，撤销面板显示操作符属性。使用此方法，我们可以使用在 [*第 5 章*](B18375_05.xhtml#_idTextAnchor100)
    中学到的相同技术设计图形界面。
- en: 'Part 3: Delivering Output'
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：输出交付
- en: 'This section covers the final stages of the 3D pipeline: deformation and rendering.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了 3D 管道的最终阶段：变形和渲染。
- en: '[Chapter 11](B18375_11.xhtml#_idTextAnchor265), Object Modifiers'
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第 11 章](B18375_11.xhtml#_idTextAnchor265)，对象修饰符'
- en: This chapter covers object modifiers and their use in animation.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了对象修饰符及其在动画中的应用。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章讨论主题的总结。
- en: Adding object modifiers
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加对象修饰符
- en: 'Modifiers are grouped into four categories: **Modify**, **Generate**, **Deform**,
    and **Physics**. They are created by clicking the **Add Modifier** button in the
    **Modifiers** property.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符分为四个类别：**修改**、**生成**、**变形**和**物理**。它们通过在 **修饰符** 属性中点击 **添加修饰符** 按钮来创建。
- en: Adding modifiers in Python
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 中添加修饰符
- en: The `new()` method of the `object.modifiers` collection requires the `type`
    modifier as an argument. A list of the possible `type` keywords can be found by
    accessing the `bpy.types.ObjectModifiers.bl_rna.functions["new"]` function and
    querying its `parameters["type"].enum_items`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`object.modifiers` 集合的 `new()` 方法需要一个 `type` 修饰符作为参数。可以通过访问 `bpy.types.ObjectModifiers.bl_rna.functions["new"]`
    函数并查询其 `parameters["type"].enum_items` 来找到可能的 `type` 关键字列表。'
- en: Writing the Latte Express add-on
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 Latte Express 扩展插件
- en: This add-on sets up a **Lattice** modifier to deform an object using a three-dimensional
    grid cage. It finds the center of the model by querying its bounding box and has
    input parameters for changing the lattice and the object’s resolutions.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件设置一个 **晶格** 修饰符，使用三维网格笼变形对象。它通过查询其边界框找到模型的中心，并为改变晶格和对象的分辨率提供了输入参数。
- en: Using armature deformers
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用骨架变形器
- en: Armatures affect characters using a deformation skeleton. Bones can be created
    in Python using `object.data.edit_bones.new()` after switching to `bpy.ops.object.mode_set()`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架通过变形骨架影响角色。在切换到 `bpy.ops.object.mode_set()` 后，可以使用 `object.data.edit_bones.new()`
    在 Python 中创建骨骼。
- en: Vertex groups are created on the lattice object to bind the lattice vertices
    to the armature bones. This way, a lattice deformed by an armature can be created
    via a script.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在晶格对象上创建顶点组以将晶格顶点绑定到骨架骨骼。这样，可以通过脚本创建由骨架变形的晶格。
- en: Creating control shapes
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建控制形状
- en: Replacing the default octahedral shape with custom wireframe shapes makes an
    armature more animator friendly. For that reason, a simple mesh can be created
    in Python using the `mesh.from_pydata` method, and assigned to the `pose_bone.custom_shape`
    attribute.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 用自定义线框形状替换默认的八面体形状使骨架更符合动画师的需求。因此，可以使用 `mesh.from_pydata` 方法在 Python 中创建一个简单的网格，并将其分配给
    `pose_bone.custom_shape` 属性。
- en: '[Chapter 12](B18375_12.xhtml#_idTextAnchor304), Rendering and Shaders'
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[第 12 章](B18375_12.xhtml#_idTextAnchor304)，渲染和着色器'
- en: This chapter introduces rendering and materials, the shader editor, and its
    node tree. Although some steps such as post-processing and video encoding may
    follow, rendering is commonly regarded as the last stage of a 3D process.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了渲染和材质、着色器编辑器及其节点树。尽管可能还有一些步骤，如后期处理和视频编码，但渲染通常被认为是 3D 流程的最后阶段。
- en: Here’s a summary of the topics discussed in the chapter.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章讨论主题的总结。
- en: How rendering works
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染的工作原理
- en: A render engine such as Blender’s **Eevee** or **Cycles** converts the 3D geometry
    to finished images using *shaders* to determine how objects look. Blender shaders
    are networks of operations called nodes, that is, blocks that elaborate and exchange
    color and geometry information by connecting their input/output sockets.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Blender 的 **Eevee** 或 **Cycles** 这样的渲染引擎使用 *着色器* 将 3D 几何形状转换为完成的图像，以确定对象的外观。Blender
    着色器是由称为节点的操作网络组成，即通过连接它们的输入/输出插孔来详细阐述和交换颜色和几何信息的块。
- en: Writing the Textament add-on
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 Textament 插件
- en: This add-on imports images from disk and creates the `ImportHelper` and `Operator`,
    and display the Blender file browser when invoked. The files the user selecteds
    are accessed as the `directory` and `files` member attributes.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件从磁盘导入图像并创建 `ImportHelper` 和 `Operator`，并在调用时显示 Blender 文件浏览器。用户选择的文件作为 `directory`
    和 `files` 成员属性访问。
- en: Looking for case-insensitive matches in file names
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文件名中查找不区分大小写的匹配项
- en: 'Uppercase letters and spaces might cause unwanted mismatches, such as the `"base
    color"` strings not being associated with `"Base Color"`. A function for string
    manipulation can be written with the usual syntax or defined in one line using
    a `lambda` expression. Removing all spaces and converting all letters to lowercase
    becomes the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 大写字母和空格可能会导致不希望的匹配错误，例如 `"base color"` 字符串没有与 `"Base Color"` 关联。可以使用常规语法编写字符串操作函数，或者使用一行
    `lambda` 表达式定义。删除所有空格并将所有字母转换为小写的结果如下：
- en: '`lambda x : x.lower().replace(" ", "")`'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda x : x.lower().replace(" ", "")`'
- en: Non-color data in images
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像中的非颜色数据
- en: Images can contain geometric or masking information. In that case, the `colorspace_setting.name`
    image attribute must be set to `"Non-Color"`, or Blender will apply color filters
    that pollute the information.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以包含几何或遮罩信息。在这种情况下，必须将 `colorspace_setting.name` 图像属性设置为 `"Non-Color"`，否则
    Blender 将应用颜色过滤器，这会污染信息。
- en: Connecting images in shaders
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在着色器中连接图像
- en: Creating a `"ShaderNodeTexImage"` as an argument of `node_tree.nodes.new("ShaderNodeTexImage")`
    allows you to use images in shaders. The connection between a texture node and
    a shader node input is created using `node_tree.links.new()`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `"ShaderNodeTexImage"` 作为 `node_tree.nodes.new("ShaderNodeTexImage")` 的参数创建，允许你在着色器中使用图像。使用
    `node_tree.links.new()` 创建纹理节点和着色器节点输入之间的连接。
- en: '*Normal map* textures give the illusion of detail. They must connect to **Normal
    Map**, which is then connected to the **Normal** input of a shader.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '*法线贴图* 纹理提供了细节的错觉。它们必须连接到 **Normal Map**，然后连接到着色器的 **Normal** 输入。'
- en: Adding custom buttons to headers
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在标题中添加自定义按钮
- en: 'Operators can be added to headers in the same way as they are added to menus:
    using a function that takes the `self` and `context` arguments, and adds elements
    to `self.layout`. This function is appended to a *Header Type* in the `register()`
    function of the add-on.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像在菜单中添加操作员一样在标题中添加操作员：使用一个接受 `self` 和 `context` 参数的函数，并将元素添加到 `self.layout`。此函数附加到插件
    `register()` 函数中的 *标题类型*。
- en: Arranging nodes in the node editor
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在节点编辑器中排列节点
- en: Nodes created in Python are positioned at the center of the editor and overlap
    each other. They can be moved by setting their `location` `x` and `y` coordinates.
    They should be placed on the left-hand side of their output node and sorted vertically
    according to the order of their output node sockets.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中创建的节点位于编辑器的中心，并且相互重叠。可以通过设置它们的 `location` `x` 和 `y` 坐标来移动它们。它们应该放置在输出节点的左侧，并按照输出节点插孔的顺序垂直排列。
- en: Altering texture colors
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改纹理颜色
- en: The color of a texture can be manipulated by adding a **Mix** node between a
    texture and its output node. That allows you to change the overall color of an
    object while retaining the details coming from the image.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在纹理和其输出节点之间添加一个 **Mix** 节点来操纵纹理的颜色。这允许你改变物体的整体颜色，同时保留来自图像的细节。
