- en: '*Chapter 2*: Using Modularization to Handle Complex Projects'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：使用模块化处理复杂项目'
- en: When you start programming in Python, it is very tempting to put all your program
    code in a single file. There is no problem in defining functions and classes in
    the same file where your main program is. This option is attractive to beginners
    because of the ease of execution of the program and to avoid managing code in
    multiple files. But a single-file program approach is not scalable for medium-
    to large-size projects. It becomes challenging to keep track of all the various
    functions and classes that you define.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始用 Python 编程时，将所有程序代码放入一个文件中是非常诱人的。在您的主程序文件中定义函数和类没有问题。这个选项对初学者有吸引力，因为程序的执行简单，可以避免在多个文件中管理代码。但是，对于中到大型项目，单文件程序方法不可扩展。跟踪您定义的所有各种函数和类变得具有挑战性。
- en: To overcome the situation, modular programming is the way to go for medium to
    large projects. Modularity is a key tool to reduce the complexity of a project.
    Modularization also facilitates efficient programming, easy debugging and management,
    collaboration, and reusability. In this chapter, we will discuss how to build
    and consume modules and packages in Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种情况，模块化编程是中到大型项目的最佳选择。模块化是减少项目复杂性的关键工具。模块化还促进了高效的编程、易于调试和管理、协作和重用。在本章中，我们将讨论如何在
    Python 中构建和消费模块和软件包。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introduction to modules and packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和软件包简介
- en: Importing modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入模块
- en: Loading and initializing a module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和初始化模块
- en: Writing reusable modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可重用模块
- en: Building packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建软件包
- en: Accessing packages from any location
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任何位置访问软件包
- en: Sharing a package
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享软件包
- en: This chapter will help you understand the concepts of modules and packages in
    Python.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您理解 Python 中模块和软件包的概念。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的技术要求：
- en: You need to have Python 3.7 or later installed on your computer.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在您的计算机上安装 Python 3.7 或更高版本。
- en: You need to register an account with Test PyPI and create an API token under
    your account.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在 Test PyPI 上注册一个账户，并在您的账户下创建一个 API 令牌。
- en: Sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在[https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02)找到。
- en: Introduction to modules and packages
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和软件包简介
- en: Modules in Python are Python files with a `.py` extension. In reality, they
    are a way to organize functions, classes, and variables using one or more Python
    files such that they are easy to manage, reuse across the different modules, and
    extend as the programs become complex.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的模块是具有 `.py` 扩展名的 Python 文件。实际上，它们是通过一个或多个 Python 文件组织函数、类和变量的方式，使得它们易于管理、跨不同模块重用，并在程序变得复杂时扩展。
- en: A Python package is the next level of modular programming. A package is like
    a folder for organizing multiple modules or sub-packages, which is fundamental
    for sharing the modules for reusability.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python 软件包是模块化编程的下一级。软件包就像一个文件夹，用于组织多个模块或子软件包，这对于模块的重用性共享是基本的。
- en: Python source files that use only the standard libraries are easy to share and
    easy to distribute using email, GitHub, and shared drives, with the only caveat
    being that there should be Python version compatibility. But this sharing approach
    will not scale for projects that have a decent number of files and have dependencies
    on third-party libraries and may be developed for a specific version of Python.
    To rescue the situation, building and sharing packages is a must for efficient
    sharing and reusability of Python programs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用标准库的 Python 源文件易于共享和分发，可以通过电子邮件、GitHub 和共享驱动器进行，唯一的缺点是应该有 Python 版本兼容性。但是，对于拥有相当数量的文件并依赖于第三方库的项目，以及可能为特定版本的
    Python 开发的项目，这种共享方法将无法扩展。为了解决这个问题，构建和共享软件包对于 Python 程序的有效共享和重用是必不可少的。
- en: Next, we will discuss how to import modules and the different types of import
    techniques supported in Python.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何导入模块以及 Python 支持的不同类型的导入技术。
- en: Importing modules
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入模块
- en: Python code in one module can get access to the Python code in another module
    by a process called importing modules.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python 模块中的一个模块可以通过一个称为导入模块的过程访问另一个模块中的 Python 代码。
- en: To elaborate on the different module and package concepts, we will build two
    modules and one main script that will use those two modules. These two modules
    will be updated or reused throughout this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细说明不同的模块和包概念，我们将构建两个模块和一个主脚本，这些脚本将使用这两个模块。这两个模块将在本章中更新或重用。
- en: 'To create a new module, we will create a `.py` file with the name of the module.
    We will create a `mycalculator.py` file with two functions: `add` and `subtract`.
    The `add` function computes the sum of the two numbers provided to the function
    as arguments and returns the computed value. The `subtract` function computes
    the difference between the two numbers provided to the function as arguments and
    returns the computed value.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的模块，我们将创建一个以模块名称命名的 `.py` 文件。我们将创建一个 `mycalculator.py` 文件，其中包含两个函数：`add`
    和 `subtract`。`add` 函数计算传递给函数作为参数的两个数字的和，并返回计算值。`subtract` 函数计算传递给函数作为参数的两个数字之间的差，并返回计算值。
- en: 'A code snippet of `mycalculator.py` is shown next:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来展示 `mycalculator.py` 的代码片段：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the name of the module is the name of the file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模块的名称就是文件的名称。
- en: 'We will create a second module by adding a new file with the name `myrandom.py`.
    This module has two functions: `random_1d` and `random_2d`. The `random_1d` function
    is for generating a random number between 1 and 9 and the `random_2d` function
    is for generating a random number between 10 and 99\. Note that this module is
    also using the `random` library, which is a built-in module from Python.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加一个名为 `myrandom.py` 的新文件来创建第二个模块。此模块有两个函数：`random_1d` 和 `random_2d`。`random_1d`
    函数用于生成介于 1 和 9 之间的随机数，而 `random_2d` 函数用于生成介于 10 和 99 之间的随机数。请注意，此模块也使用了 `random`
    库，这是 Python 的内置模块。
- en: 'The code snippet of `myrandom.py` is shown next:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来展示 `myrandom.py` 的代码片段：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To consume these two modules, we also created the main Python script (`calcmain1.py`),
    which imports the two modules and uses them to achieve these two calculator functions.
    The `import` statement is the most common way to import built-in or custom modules.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这两个模块，我们还创建了主 Python 脚本（`calcmain1.py`），它导入这两个模块并使用它们来实现这两个计算器功能。`import`
    语句是导入内置或自定义模块最常见的方式。
- en: 'A code snippet of `calcmain1.py` is shown next:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来展示 `calcmain1.py` 的代码片段：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this main script (another module), we import the two modules using the `import`
    statement. We defined the main function (`my_main`), which will be executed only
    if this script or the `calcmain1` module is executed as the main program. The
    details of executing the main function from the main program will be covered later
    in the *Setting special variables* section. In the `my_main` function, we are
    generating two random numbers using the `myrandom` module and then calculating
    the sum and difference of the two random numbers using the `mycalculator` module.
    In the end, we are sending the results to the console using the `print` statement.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主脚本（另一个模块）中，我们使用 `import` 语句导入两个模块。我们定义了主函数（`my_main`），它只会在脚本或 `calcmain1`
    模块作为主程序执行时运行。主程序中执行主函数的细节将在后面的 *设置特殊变量* 部分进行介绍。在 `my_main` 函数中，我们使用 `myrandom`
    模块生成两个随机数，然后使用 `mycalculator` 模块计算这两个随机数的和与差。最后，我们使用 `print` 语句将结果发送到控制台。
- en: Important Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A module is loaded only once. If a module is imported by another module or by
    the main Python script, the module will be initialized by executing the code in
    the module. If another module in your program imports the same module again, it
    will not be loaded twice but only once. This means if there are any local variables
    inside the module, they will act as a Singleton (initialized only once).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模块只加载一次。如果一个模块被另一个模块或主 Python 脚本导入，该模块将通过执行模块中的代码来初始化。如果程序中的另一个模块再次导入相同的模块，它将不会加载两次，而只加载一次。这意味着如果模块内部有任何局部变量，它们将作为单例（只初始化一次）。
- en: There are other options available to import a module, such as `importlib.import_module()`
    and the built-in `__import__()` function. Let's discuss how `import` and other
    alternative options works.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模块还有其他选项，例如 `importlib.import_module()` 和内置的 `__import__()` 函数。让我们讨论一下 `import`
    和其他替代选项是如何工作的。
- en: Using the import statement
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导入语句
- en: 'As mentioned already, the `import` statement is a common way to import a module.
    The next code snippet is an example of using an `import` statement:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`import` 语句是导入模块的一种常见方式。下面的代码片段是使用 `import` 语句的一个示例：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `import` statement is responsible for two operations: first, it searches
    for the module given after the `import` keyword, and then it binds the results
    of that search to a variable name (which is the same as the module name) in the
    local scope of the execution. In the next two subsections, we will discuss how
    `import` works and also how to import specific elements from a module or a package.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句负责两个操作：首先，它搜索`import`关键字后面的模块，然后将搜索结果绑定到执行局部作用域中的一个变量名（与模块名相同）。在接下来的两个小节中，我们将讨论`import`是如何工作的，以及如何从模块或包中导入特定元素。'
- en: Learning how import works
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习如何使用导入
- en: 'Next, we need to understand how the `import` statement works. First, we need
    to remind ourselves that all global variables and functions are added to the global
    namespace by the Python interpreter at the start of an execution. To illustrate
    the concept, we can write a small Python program to spit out of the contents of
    the `globals` namespace, as shown next:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要了解`import`语句是如何工作的。首先，我们需要提醒自己，Python解释器在执行开始时会将所有全局变量和函数添加到全局命名空间中。为了说明这个概念，我们可以编写一个小型的Python程序来输出`globals`命名空间的内容，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This program has two functions: `print_globals` and `hello`. The `print_globals`
    function will spit out the contents of the global namespace. The `hello` function
    will not be executed and is added here to show its reference in the console output
    of the global namespace. The console output after executing this Python code will
    be similar to the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有两个函数：`print_globals`和`hello`。`print_globals`函数将输出全局命名空间的内容。`hello`函数将不会执行，这里添加它是为了在全局命名空间的控制台输出中显示其引用。执行此Python代码后的控制台输出将类似于以下内容：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The key points to be noticed in this console output are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制台输出中需要注意的关键点如下：
- en: The `__name__` variable is set to the `__main__` value. This will be discussed
    in more detail in the *Loading and initializing a module* section.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__name__`变量被设置为`__main__`值。这将在*加载和初始化模块*部分进行更详细的讨论。'
- en: The `__file__` variable is set to the file path of the main module here.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__file__`变量被设置为主模块的文件路径。'
- en: A reference to each function is added at the end.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在末尾添加每个函数的引用。
- en: 'If we add `print(globals())` to our `calcmain1.py` script, the console output
    after adding this statement will be similar to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`calcmain1.py`脚本中添加`print(globals())`，那么添加此语句后的控制台输出将类似于以下内容：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An important point to note is that there are two additional variables (`mycalculator`
    and `myrandom`) added to the global namespace corresponding to each `import` statement
    used to import these modules. Every time we import a library, a variable with
    the same name is created, which holds a reference to the module just like a variable
    for the global functions (`my_main` in this case).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要点是，对于每个使用`import`语句导入这些模块的情况，都会在全局命名空间中添加两个额外的变量（`mycalculator`和`myrandom`）。每次我们导入一个库时，都会创建一个具有相同名称的变量，该变量持有对模块的引用，就像全局函数的变量（在这种情况下是`my_main`）一样。
- en: We will see, in other approaches of importing modules, that we can explicitly
    define some of these variables for each module. The `import` statement does this
    automatically for us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，在其他导入模块的方法中，我们可以为每个模块显式定义一些这些变量。`import`语句会自动为我们完成这项工作。
- en: Specific import
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定导入
- en: 'We can also import something specific (variable or function or class) from
    a module instead of importing the whole module. This is achieved using the `from`
    statement, such as the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从模块中导入特定的内容（变量、函数或类），而不是导入整个模块。这是通过使用`from`语句实现的，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another best practice is to use a different name for an imported module for
    convenience or sometimes when the same names are being used for different resources
    in two different libraries. To illustrate this idea, we will be updating our `calcmain1.py`
    file (the updated program is `calcmain2.py`) from the earlier example by using
    the `calc` and `rand` aliases for the `mycalculator` and `myrandom` modules, respectively.
    This change will make use of the modules in the main script much simpler, as shown
    next:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最佳实践是，为了方便或有时在两个不同的库中使用相同名称为不同资源时，为导入的模块使用不同的名称。为了说明这个想法，我们将更新之前的`calcmain1.py`文件（更新的程序是`calcmain2.py`），通过使用`calc`和`rand`别名分别代表`mycalculator`和`myrandom`模块。这个更改将使在主脚本中使用模块变得更加简单，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As a next step, we will combine the two concepts discussed earlier in the next
    iteration of the `calcmain1.py` program (the updated program is `calcmain3.py`).
    In this update, we will use the `from` statement with the module names and then
    import the individual functions from each module. In the case of the `add` and
    `subtract` functions, we used the `as` statement to define a different local definition
    of the module resource for illustration purposes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们将在`calcmain1.py`程序的下一迭代中结合之前讨论的两个概念（更新后的程序是`calcmain3.py`）。在这个更新中，我们将使用`from`语句与模块名称一起，然后从每个模块中导入单个函数。对于`add`和`subtract`函数，我们使用了`as`语句来定义一个不同的本地模块资源定义，以供说明。
- en: 'A code snippet of `calcmain3.py` is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`calcmain3.py`的代码片段如下：'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we used the `print (globals())` statement with this program, the console
    output of this program will show that the variables corresponding to each function
    are created as per our alias. The sample console output is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`print (globals())`语句，这个程序的控制台输出将显示每个函数对应的变量按照我们的别名创建。示例控制台输出如下：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the variables in bold correspond to the changes we made in the `import`
    statements in the `calcmain3.py` file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，粗体变量对应我们在`calcmain3.py`文件中的`import`语句所做的更改。
- en: Using the __import__ statement
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`__import__`语句
- en: 'The `__import__` statement is a low-level function in Python that takes a string
    as input and triggers the actual import operation. Low-level functions are part
    of the core Python language and are typically meant to be used for library development
    or for accessing operating system resources, and are not commonly used for application
    development. We can use this keyword to import the `random` library in our `myrandom.py`
    module as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`__import__`语句是Python中的一个低级函数，它接受一个字符串作为输入并触发实际的导入操作。低级函数是Python核心语言的一部分，通常用于库开发或访问操作系统资源，并不常用于应用程序开发。我们可以使用这个关键字在我们的`myrandom.py`模块中导入`random`库，如下所示：'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The rest of the code in `myrandom.py` can be used as it is without any change.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`myrandom.py`中的其余代码可以原样使用，无需任何更改。'
- en: We illustrated a simple case of using the `__import__` method for academic reasons
    and we will skip the advanced details for those of you who are interested in exploring
    as further reading. The reason for this is that the `__import__` method is not
    recommended to be used for user applications; it is designed more for interpreters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了学术目的说明了使用`__import__`方法的一个简单案例，并将跳过那些对进一步探索感兴趣的人的详细内容。原因是`__import__`方法不建议用于用户应用程序；它设计得更多是为了解释器。
- en: The `importlib.import_module` statement is the one to be used other than the
    regular import for advanced functionality.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`importlib.import_module`语句是除了常规导入之外用于高级功能的语句。'
- en: Using the importlib.import_module statement
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用importlib.import_module语句
- en: 'We can import any module using the `importlib` library. The `importlib` library
    offers a variety of functions, including `__import__`, related to importing modules
    in a more flexible way. Here is a simple example of how to import a `random` module
    in our `myrandom.py` module using `importlib`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`importlib`库导入任何模块。`importlib`库提供了一系列与以更灵活方式导入模块相关的函数，包括`__import__`。以下是一个如何在我们的`myrandom.py`模块中使用`importlib`导入`random`模块的简单示例：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The rest of the code in `myrandom.py` can be used as it is without any change.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`myrandom.py`中的其余代码可以原样使用，无需任何更改。'
- en: The `importlib` module is best known for importing modules dynamically and is
    very useful in cases where the name of the module is not known in advance and
    we need to import the modules at runtime. This is a common requirement for the
    development of plugins and extensions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`importlib`模块最出名的是动态导入模块，在模块名称事先未知且需要在运行时导入模块的情况下非常有用。这是插件和扩展开发中的常见需求。'
- en: 'Commonly used functions available in the `importlib` module are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`importlib`模块中可用的常用函数如下：'
- en: '`__import__`: This is the implementation of the `__import__` function, as already
    discussed.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__import__`：这是`__import__`函数的实现，如前所述。'
- en: '`import_module`: This is used to import a module and is most commonly used
    to load a module dynamically. In this method, you can specify whether you want
    to import a module using an absolute or relative path. The `import_module` function
    is a wrapper around `importlib.__import__`. Note that the former function brings
    back the package or module (for example, `packageA.module1`), which is specified
    with the function, while the latter function always returns the top-level package
    or module (for example, `packageA`).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import_module`：这个函数用于导入一个模块，最常用于动态加载模块。在这个方法中，你可以指定是否使用绝对路径或相对路径来导入模块。`import_module`
    函数是 `importlib.__import__` 的包装器。请注意，前一个函数返回的是由函数指定的包或模块（例如，`packageA.module1`），而后一个函数总是返回顶级包或模块（例如，`packageA`）。'
- en: '`importlib.util.find_spec`: This is a replaced method for the `find_loader`
    method, which is deprecated since Python release 3.4\. This method can be used
    to validate whether the module exists and it is valid.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`importlib.util.find_spec`：这是 `find_loader` 方法的替代方法，自 Python 3.4 版本以来已被弃用。这个方法可以用来验证模块是否存在且有效。'
- en: '`invalidate_caches`: This method can be used to invalidate the internal caches
    of finders stored at `sys.meta_path`. The internal cache is useful to load the
    module faster without triggering the finder methods again. But if we are dynamically
    importing a module, especially if it is created after the interpreter began execution,
    it is a best practice to call the `invalidate_caches` method. This function will
    clear all modules or libraries from the cache to make sure the requested module
    is loaded from the system path by the `import` system.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalidate_caches`：这个方法可以用来使存储在 `sys.meta_path` 中的查找器的内部缓存失效。内部缓存对于快速加载模块很有用，无需再次触发查找器方法。但是，如果我们正在动态导入一个模块，尤其是如果它在解释器开始执行之后创建，那么调用
    `invalidate_caches` 方法是一种最佳实践。这个函数将清除所有模块或库从缓存，以确保请求的模块是通过 `import` 系统从系统路径加载的。'
- en: '`reload`: As the name suggests, this function is used to reload a previously
    imported module. We need to provide the module object as an input parameter for
    this function. This means the `import` function has to be done successfully. This
    function is very helpful when module source code is expected to be edited or changed
    and you want to load the new version without restarting the program.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reload`：正如其名所示，这个函数用于重新加载之前导入的模块。我们需要为这个函数提供模块对象作为输入参数。这意味着 `import` 函数必须成功执行。当模块源代码预期将被编辑或更改，并且你想要加载新版本而不重新启动程序时，这个函数非常有用。'
- en: Absolute versus relative import
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绝对导入与相对导入
- en: 'We have fairly a good idea of how to use `import` statements. Now it is time
    to understand **absolute** and **relative** imports, especially when we are importing
    custom or project-specific modules. To illustrate the two concepts, let''s take
    an example of a project with different packages, sub-packages, and modules, as
    shown next:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对如何使用 `import` 语句有了相当好的了解。现在是时候理解**绝对**和**相对**导入，尤其是在我们导入自定义或项目特定模块时。为了说明这两个概念，让我们以一个具有不同包、子包和模块的项目为例，如下所示：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using this project structure, we will discuss how to use absolute and relative
    imports.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种项目结构，我们将讨论如何使用绝对和相对导入。
- en: Absolute import
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对导入
- en: 'We can use absolute paths starting from the top-level package and drilling
    down to the sub-package and module level. A few examples of importing different
    modules are shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用从顶级包开始，向下钻取到子包和模块级别的绝对路径。这里展示了导入不同模块的一些示例：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For absolute import statements, we must give a detailed path for each package
    or file, from the top-level package folder, which is similar to a file path.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绝对导入语句，我们必须为每个包或文件提供一个详细的路径，从顶级包文件夹开始，类似于文件路径。
- en: Absolute imports are recommended because they are easy to read and easy to follow
    the exact location of imported resources. Absolute imports are least impacted
    by project sharing and changes in the current location of `import` statements.
    In fact, PEP 8 explicitly recommends the use of absolute imports.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对导入推荐使用，因为它们易于阅读，也易于跟踪导入资源的确切位置。绝对导入受项目共享和当前 `import` 语句位置变化的影响最小。实际上，PEP 8
    明确推荐使用绝对导入。
- en: Sometimes, however, absolute imports are quite long statements depending on
    the size of the project folder structure, which is not convenient to maintain.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时绝对导入的语句相当长，这取决于项目文件夹结构的大小，这不利于维护。
- en: Relative import
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对导入
- en: A relative import specifies the resource to be imported relative to the current
    location, which is mainly the current location of the Python code file where the
    `import` statement is used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 相对导入指定了相对于当前位置要导入的资源，这主要是使用 `import` 语句的 Python 代码文件当前位置。
- en: 'For the project examples discussed earlier, here are a few scenarios of relative
    import. The equivalent relative import statements are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面讨论的项目示例，以下是相对导入的一些场景。等效的相对导入语句如下：
- en: '`funct1` inside `module1.py`:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module1.py` 中的 `funct1`：'
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`module4` inside `module1.py`:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module1.py` 中的 `module4`：'
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Func2` inside `module1.py`:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module1.py` 中的 `Func2`：'
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One advantage of relative imports is that they are simple and can significantly
    reduce long `import` statements. But relative `import` statements can be messy
    and difficult to maintain when projects are shared across teams and organizations.
    Relative imports are not easy to read and manage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 相对导入的一个优点是它们简单，并且可以显著减少长的 `import` 语句。但是，当项目在团队和组织之间共享时，相对导入语句可能会变得混乱且难以维护。相对导入不易阅读和管理。
- en: Loading and initializing a module
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和初始化模块
- en: Whenever the Python interpreter interacts with an `import` or equivalent statement,
    it does three operations, which are described in the next sections.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 Python 解释器与 `import` 或等效语句交互时，它执行三个操作，这些操作将在下一节中描述。
- en: Loading a module
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载模块
- en: The Python interpreter searches for the specified module on a `sys.path` (to
    be discussed in the *Accessing packages from any location* section) and loads
    the source code. This has been explained in the *Learning how import works* section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器在 `sys.path`（将在 *从任何位置访问包* 部分讨论）上搜索指定的模块，并加载源代码。这已在 *学习 import 的工作原理*
    部分中解释。
- en: Setting special variables
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置特殊变量
- en: In this step, the Python interpreter defines a few special variables, such as
    `__name__`, which basically defines the namespace that a Python module is running
    in. The `__name__` variable is one of the most important variables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，Python 解释器定义了一些特殊变量，例如 `__name__`，它基本上定义了 Python 模块运行的命名空间。`__name__` 变量是最重要的变量之一。
- en: 'In the case of our example of the `calcmain1.py`, `mycalculator.py`, and `myrandom.py`
    modules, the `__name__` variable will be set for each module as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`calcmain1.py`、`mycalculator.py` 和 `myrandom.py` 模块的情况下，每个模块的 `__name__`
    变量将被设置为以下内容：
- en: '![Table 2.1 – The __name__ attribute value for different modules](img/table.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.1 – 不同模块的 __name__ 属性值](img/table.jpg)'
- en: Table 2.1 – The __name__ attribute value for different modules
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 不同模块的 __name__ 属性值
- en: There are two cases of setting the `__name__` variable, which are described
    next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `__name__` 变量有两种情况，下面将进行描述。
- en: Case A – module as the main program
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 情况 A – 模块作为主程序
- en: If you are running your module as the main program, the `__name__` variable
    will be set to the `__main__` value regardless of whatever the name of the Python
    file or module is. For example, when `calcmain1.py` is executed, the interpreter
    will assign the hardcoded `__main__` string to the `__name__` variable. If we
    run `myrandom.py` or `mycalculator.py` as the main program, the `__name__` variable
    will automatically get the value of `__main__`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将你的模块作为主程序运行，无论 Python 文件或模块的名称是什么，`__name__` 变量都将被设置为 `__main__` 值。例如，当执行
    `calcmain1.py` 时，解释器将硬编码的 `__main__` 字符串分配给 `__name__` 变量。如果我们以主程序的方式运行 `myrandom.py`
    或 `mycalculator.py`，`__name__` 变量将自动获取 `__main__` 的值。
- en: Therefore, we added an `if __name__ == '__main__'` line to all main scripts
    to check whether this is the main execution program.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在所有主脚本中添加了 `if __name__ == '__main__'` 行来检查这是否是主执行程序。
- en: Case B – module is imported by another module
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 情况 B – 模块被另一个模块导入
- en: In this case, your module is not the main program, but it is imported by another
    module. In our example, `myrandom` and `mycalculator` are imported in `calcmain1.py`.
    As soon as the Python interpreter finds the `myrandom.py` and `mycalculator.py`
    files, it will assign the `myrandom` and `mycalculator` names from the `import`
    statement to the `__name__` variable for each module. This assignment is done
    prior to executing the code inside these modules. This is reflected in *Table
    2.1*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你的模块不是主程序，但它被另一个模块导入。在我们的示例中，`myrandom` 和 `mycalculator` 在 `calcmain1.py`
    中被导入。一旦 Python 解释器找到 `myrandom.py` 和 `mycalculator.py` 文件，它将把 `import` 语句中的 `myrandom`
    和 `mycalculator` 名称分配给每个模块的 `__name__` 变量。这个分配是在执行这些模块内的代码之前完成的。这反映在 *表 2.1* 中。
- en: 'Some of the other noticeable special variables are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他值得注意的特殊变量如下：
- en: '`__file__`: This variable contains the path to the module that is currently
    being imported.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__file__`：此变量包含当前正在导入的模块的路径。'
- en: '`__doc__`: This variable will output the docstring that is added in a class
    or a method. As discussed in [*Chapter 1*](B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013),
    *Optimal Python Development Life Cycle*, a docstring is a comment line added right
    after the class or method definition.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__doc__`：此变量将输出在类或方法中添加的文档字符串。如在第[*第一章*](B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013)中讨论的，*最佳Python开发生命周期*，文档字符串是在类或方法定义后添加的注释行。'
- en: '`__package__`: This is used to indicate whether the module is a package or
    not. Its value can be a package name, an empty string, or `none`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__package__`：这用于指示模块是否为包。其值可以是包名、空字符串或`none`。'
- en: '`__dict__`: This will return all attributes of a class instance as a dictionary.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__dict__`：这将返回一个类实例的所有属性作为字典。'
- en: '`dir`: This is actually a method that returns every associated method or attribute
    as a list.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir`：这实际上是一个返回每个相关方法或属性列表的方法。'
- en: '`Locals` and `globals`: These are also used as methods that display the local
    and global variables as dictionary entries.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Locals`和`globals`：这些也被用作显示局部和全局变量作为字典条目的方法。'
- en: Executing the code
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行代码
- en: 'After the special variables are set, the Python interpreter executes the code
    in the file line by line. It is important to know that functions (and the code
    under the classes) are not executed unless they are not called by other lines
    of code. Here is a quick analysis of the three modules from the execution point
    of view when `calcmain1.py` is run:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置特殊变量后，Python解释器将逐行执行文件中的代码。重要的是要知道，除非被其他代码行调用，否则函数（以及类下的代码）不会执行。以下是当运行`calcmain1.py`时，从执行点对三个模块的快速分析：
- en: '`mycalculator.py`: After setting the special variables, there is no code to
    be executed in this module at the initialization time.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mycalculator.py`：在设置特殊变量后，在初始化时此模块没有代码要执行。'
- en: '`myrandom.py`: After setting the special variables and the `import` statement,
    there is no further code to be executed in this module at initialization time.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myrandom.py`：在设置特殊变量和导入语句后，在初始化时此模块没有其他代码要执行。'
- en: '`calcmain1.py`: After setting the special variables and executing the `import`
    statements, it executes the following `if` statement: `if __name__ == "__main__":`.
    This will return `true` because we launched the `calcmain1.py` file. Inside the
    `if` statement, the `my_main ()` function will be called, which in fact then calls
    methods from the `myrandom.py` and `mycalculator.py` modules.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calcmain1.py`：在设置特殊变量和执行导入语句后，它将执行以下`if`语句：`if __name__ == "__main__"`。这将返回`true`，因为我们启动了`calcmain1.py`文件。在`if`语句内部，将调用`my_main()`函数，该函数实际上调用`myrandom.py`和`mycalculator.py`模块的方法。'
- en: We can add an `if __name__ == "__main__"` statement to any module regardless
    of whether it is the main program or not. The advantage of using this approach
    is that the module can be used both as a module or as a main program. There is
    also another application of using this approach, which is to add unit tests within
    the module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何模块中添加`if __name__ == "__main__"`语句，无论它是否是主程序。使用此方法的优势是模块既可以作为模块使用，也可以作为主程序使用。还有使用此方法的另一种应用，即在模块中添加单元测试。
- en: Standard modules
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准模块
- en: 'Python comes with a library of over 200 standard modules. The exact number
    varies from one distribution to the other. These modules can be imported into
    your program. The list of these modules is very extensive but only a few commonly
    used modules are mentioned here as an example of standard modules:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带超过200个标准模块的库。确切的数量因分发版而异。这些模块可以被导入到你的程序中。这些模块的列表非常广泛，但在此仅列举一些常用模块作为标准模块的示例：
- en: '`math`: This module provides mathematical functions for arithmetic operations.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`math`：此模块提供算术运算的数学函数。'
- en: '`random`: This module is helpful to generate pseudo-random numbers using different
    types of distributions.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random`：此模块有助于使用不同类型的分布生成伪随机数。'
- en: '`statistics`: This module offers statistics functions such as `mean`, `median`,
    and `variance`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statistics`：此模块提供诸如`mean`、`median`和`variance`之类的统计函数。'
- en: '`base64`: This module provides functions to encode and decode data.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base64`：此模块提供编码和解码数据的函数。'
- en: '`calendar`: This module offers functions related to the calendar, which is
    helpful for calendar-based computations.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calendar`：此模块提供与日历相关的函数，有助于基于日历的计算。'
- en: '`collections`: This module contains specialized container data types other
    than the general-purpose built-in containers (such as `dict`, `list`, or `set`).
    These specialized data types include `deque`, `Counter`, and `ChainMap`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections`：此模块包含除通用内置容器（如`dict`、`list`或`set`）之外的特殊容器数据类型。这些特殊数据类型包括`deque`、`Counter`和`ChainMap`。'
- en: '`csv`: This module helps in reading from and writing to comma-based delimited
    files.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csv`：此模块有助于从基于逗号的分隔文件中读取和写入。'
- en: '`datetime`: This module offers general-purpose data and time functions.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datetime`：此模块提供通用日期和时间函数。'
- en: '`decimal`: This module is specific for decimal-based arithmetic operations.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal`：此模块专门用于基于十进制的算术运算。'
- en: '`logging`: This module is used to facilitate logging into your application.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logging`：此模块用于简化应用程序的日志记录。'
- en: '`os` and `os.path`: These modules are used to access operating system-related
    functions.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os`和`os.path`：这些模块用于访问操作系统相关的功能。'
- en: '`socket`: This module provides low-level functions for socket-based network
    communication.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`：此模块提供基于套接字的网络通信的低级函数。'
- en: '`sys`: This module provides access to a Python interpreter for low-level variables
    and functions.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys`：此模块提供对Python解释器低级变量和函数的访问。'
- en: '`time`: This module offers time-related functions such as converting to different
    time units.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`：此模块提供时间相关的函数，如转换到不同的时间单位。'
- en: Writing reusable modules
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可重用模块
- en: 'For a module to be declared reusable, it has to have the following characteristics:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使模块可重用，它必须具有以下特征：
- en: Independent functionality
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立功能
- en: General-purpose functionality
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用功能
- en: Conventional coding style
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的编码风格
- en: Well-defined documentation
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确的文档
- en: If a module or package does not have these characteristics, it would be very
    hard, if not impossible, to reuse it in other programs. We will discuss each characteristic
    one by one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块或包没有这些特征，那么在其他程序中重用它将非常困难，甚至不可能。我们将逐一讨论每个特征。
- en: Independent functionality
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立功能
- en: The functions in a module should offer functionality independent of other modules
    and independent of any local or global variables. The more independent the functions
    are, the more reusable the module is. If it has to use other modules, it has to
    be minimal.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的函数应提供与其他模块以及任何局部或全局变量无关的功能。函数越独立，模块的可重用性就越高。如果它必须使用其他模块，那么它必须是最小的。
- en: 'In our example of `mycalculator.py`, the two functions are completely independent
    and can be reused by other programs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`mycalculator.py`示例中，这两个函数是完全独立的，可以被其他程序重用：
- en: '![Figure 2.1 – The mycalculator module with add and subtract functions'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – mycalculator模块的加法和减法功能'
- en: '](img/B17189_02_01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_02_01.jpg)'
- en: Figure 2.1 – The mycalculator module with add and subtract functions
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – mycalculator模块的加法和减法功能
- en: 'In the case of `myrandom.py`, we are using the `random` system library to provide
    the functionality of generating random numbers. This is still a very reusable
    module because the `random` library is one of the built-in modules in Python:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`myrandom.py`的情况下，我们使用`random`系统库来提供生成随机数的功能。这仍然是一个非常可重用的模块，因为`random`库是Python中的内置模块之一：
- en: '![Figure 2.2 – The myrandom module with function dependency on the random library'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – myrandom模块与random库的功能依赖关系'
- en: '](img/B17189_02_02.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_02_02.jpg)'
- en: Figure 2.2 – The myrandom module with function dependency on the random library
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – myrandom模块与random库的功能依赖关系
- en: In cases where we have to use third-party libraries in our modules, we can get
    into problems when sharing our modules with others if the target environment does
    not have the third-party libraries already installed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们必须在我们的模块中使用第三方库的情况下，如果目标环境尚未安装第三方库，那么在与其他人共享我们的模块时可能会遇到问题。
- en: To elaborate this problem further, we'll introduce a new module, `mypandas.py`,
    which will leverage the basic functionality of the famous `pandas` library. For
    simplicity, we added only one function to it, which is to print the DataFrame
    as per the dictionary that is provided as an input variable to the function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阐述这个问题，我们将引入一个新的模块`mypandas.py`，它将利用著名`pandas`库的基本功能。为了简单起见，我们只向其中添加了一个函数，该函数根据作为函数输入变量的字典打印DataFrame。
- en: 'The code snippet of `mypandas.py` is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`mypandas.py`的代码片段如下：'
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our `mypandas.py` module will be using the `pandas` library to create a `dataframe`
    object from the dictionary. This dependency is shown in the next block diagram
    as well:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `mypandas.py` 模块将使用 `pandas` 库从字典中创建 `dataframe` 对象。这种依赖关系也在下一个块图中显示：
- en: '![Figure 2.3 – The mypandas module with dependency on a third-party pandas
    library'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – mypandas 模块依赖于第三方 pandas 库'
- en: '](img/B17189_02_03.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_02_03.jpg)'
- en: Figure 2.3 – The mypandas module with dependency on a third-party pandas library
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – mypandas 模块依赖于第三方 pandas 库
- en: 'Note that the `pandas` library is not a built-in or system library. When we
    try to share this module with others without defining a clear dependency on a
    third-party library (`pandas` in this case), the program that will try to use
    this module will give the following error message:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`pandas` 库不是一个内置库或系统库。当我们试图与他人共享此模块而不定义对第三方库（在这种情况下为 `pandas`）的清晰依赖关系时，尝试使用此模块的程序将给出以下错误信息：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is why it is important that the module is as independent as possible. If
    we have to use third-party libraries, we need to define clear dependencies and
    use an appropriate packaging approach. This will be discussed in the *Sharing
    a package* section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么使模块尽可能独立很重要。如果我们必须使用第三方库，我们需要定义清晰的依赖关系并使用适当的打包方法。这将在“共享包”部分进行讨论。
- en: Generalization functionality
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛化功能
- en: An ideal reusable module should focus on solving a general problem rather than
    a very specific problem. For example, we have a requirement of converting inches
    to centimeters. We can easily write a function that converts inches into centimeters
    by applying a conversion formula. What about writing a function that converts
    any value in the imperial system to a value in the metric system? We can have
    one function for different conversions that may handle inches to centimeters,
    feet to meters, or miles to kilometers, or separate functions for each type of
    these conversions. What about the reverse functions (centimeters to inches)? This
    may not be required now but may be required later on or by someone who is reusing
    this module. This generalization will make the module functionality not only comprehensive
    but also more reusable without extending it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个理想的可重用模块应该专注于解决一个通用问题，而不是一个非常具体的问题。例如，我们有一个将英寸转换为厘米的需求。我们可以轻松地编写一个函数，通过应用转换公式将英寸转换为厘米。那么，编写一个将英制系统中的任何值转换为公制系统中的值的函数呢？我们可以有一个函数来处理英寸到厘米、英尺到米或英里到千米的转换，或者为每种类型的转换编写单独的函数。那么，反向函数（厘米到英寸）呢？这可能现在不是必需的，但将来可能需要，或者由重新使用此模块的人需要。这种泛化将使模块的功能不仅全面，而且更易于重用，而无需扩展它。
- en: To illustrate the generalization concept, we will revise the design of the `myrandom`
    module to make it more general and thus more reusable. In the current design,
    we define separate functions for one-digit and two-digit numbers. What if we need
    to generate a three-digit random number or to generate a random number between
    20 and 30? To generalize the requirement, we introduce a new function, `get_random`,
    in the same module, which takes user input for lower and upper limits of the random
    numbers. This newly added function is a generalization of the two random functions
    we already defined. With this new function in the module, the two existing functions
    can be removed, or they can stay in the module for convenience of use. Note that
    the newly added function is also offered by the `random` library out of the box;
    the reason for providing the function in our module is purely for illustration
    of the generalized function (`get_random` in this case) versus the specific functions
    (`random_1d` and `random_2d` in this case).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明泛化概念，我们将修改 `myrandom` 模块的设计，使其更加通用，从而更易于重用。在当前的设计中，我们为一位数和两位数定义了单独的函数。如果我们需要生成一个三位数的随机数或生成一个介于
    20 到 30 之间的随机数怎么办？为了泛化需求，我们在同一模块中引入了一个新的函数 `get_random`，它接受用户输入随机数的下限和上限。这个新添加的函数是对我们已定义的两个随机函数的泛化。在这个模块中，通过这个新函数，可以删除两个现有的函数，或者为了方便使用，它们可以保留在模块中。请注意，这个新添加的函数也是由
    `random` 库直接提供的；在我们的模块中提供此函数的原因纯粹是为了说明泛化函数（在这种情况下为 `get_random`）与特定函数（在这种情况下为
    `random_1d` 和 `random_2d`）之间的区别。
- en: 'The updated version of the `myrandom.py` module (`myrandomv2.py`) is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`myrandom.py` 模块的更新版本（`myrandomv2.py`）如下：'
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Conventional coding style
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传统的编码风格
- en: This primarily focuses on how we write function names, variable names, and module
    names. Python has a coding system and naming conventions, which were discussed
    in the previous chapter of this book. It is important to follow the coding and
    naming conventions, especially when building reusable modules and packages. Otherwise,
    we will be discussing such modules as bad examples of reusable modules.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要关注我们如何编写函数名、变量名和模块名。Python有一个编码系统和命名约定，这在本书的前一章中已经讨论过。遵循编码和命名约定非常重要，尤其是在构建可重用模块和软件包时。否则，我们将讨论这些模块作为可重用模块的坏例子。
- en: 'To illustrate this point, we will show the following code snippet with function
    and parameter names using camel case:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们将展示以下代码片段，其中函数和参数名使用了驼峰式命名法：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you are coming from a Java background, this code style will seem fine. But
    it is considered bad practice in Python. The use of the non-Pythonic style of
    coding makes the reusability of such modules very difficult.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Java背景，这种代码风格看起来不错。但在Python中，这被认为是不良实践。使用非Python风格的编码使得此类模块的重用非常困难。
- en: 'Here is another snippet of a module with appropriate coding style for function
    names:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个模块的代码片段示例，其中函数名采用了适当的编码风格：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another example of a good reusable coding style is illustrated in the next
    screenshot, which is taken from the PyCharm IDE for the `pandas` library:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图展示了另一个良好的可重用编码风格的例子，该截图来自PyCharm IDE中的`pandas`库：
- en: '![Figure 2.4 – The pandas library view in the PyCharm IDE'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – PyCharm IDE中的pandas库视图'
- en: '](img/B17189_02_04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_02_04.jpg)'
- en: Figure 2.4 – The pandas library view in the PyCharm IDE
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – PyCharm IDE中的pandas库视图
- en: The functions and the variable names are easy to follow even without reading
    any documentation. Following a standard coding style makes the reusability more
    convenient.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不阅读任何文档，函数和变量名也很容易理解。遵循标准编码风格可以使重用更方便。
- en: Well-defined documentation
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明确的文档
- en: Well-defined and clear documentation is as important as writing a generalized
    and independent module with the Python coding guidelines. Without clear documentation,
    the module will not increase the interest of developers to reuse with convenience.
    But as programmers, we put more focus on the code than the documentation. Writing
    a few lines of documentation can make 100 lines of our code more usable and maintainable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 明确且清晰的文档与遵循Python编码指南编写的通用和独立模块一样重要。没有清晰的文档，模块将不会增加开发者方便重用的兴趣。但作为程序员，我们更关注代码而不是文档。编写几行文档可以使我们100行代码更易于使用和维护。
- en: 'We will provide a couple of good examples of documentation from a module point
    of view by using our `mycalculator.py` module example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用我们的`mycalculator.py`模块示例，从模块的角度提供几个良好的文档示例：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In Python, it is important to remember the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，重要的是要记住以下几点：
- en: We can use three quote characters to mark a string that goes across more than
    one line of the Python source file.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用三个引号字符来标记跨越Python源文件多行的字符串。
- en: Triple-quoted strings are used at the start of a module, and then this string
    is used as the documentation for the module as a whole.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三引号字符串用于模块的开头，然后这个字符串被用作整个模块的文档。
- en: If any function starts with a triple-quoted string, then this string is used
    as documentation for that function.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何函数以三引号字符串开头，那么这个字符串将用作该函数的文档。
- en: As a general conclusion, we can make as many modules as we want by writing hundreds
    of lines of code, but it takes more than writing code to make a reusable module,
    including generalization, coding style, and most importantly, documentation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般结论，我们可以通过编写数百行代码来创建尽可能多的模块，但要创建可重用的模块，除了编写代码之外，还需要包括泛化、编码风格，最重要的是文档。
- en: Building packages
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建软件包
- en: There are a number of techniques and tools available for creating and distributing
    packages. The truth is that Python does not have a great history of standardizing
    the packaging process. There have been multiple projects started in the first
    decade of the 21st century to streamline this process but not with a lot of success.
    In the last decade, we have had some success, thanks to the initiatives of the
    **Python Packaging Authority** (**PyPA**).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术和工具可用于创建和分发软件包。事实是，Python在标准化打包过程方面并没有一个很好的历史。在21世纪的前十年中，已经启动了多个项目来简化这一过程，但并没有取得很大的成功。在过去的十年中，我们取得了一些成功，这要归功于**Python打包权威机构**（**PyPA**）的倡议。
- en: In this section, we will be covering techniques of building packages, accessing
    the packages in our program, and publishing and sharing the packages as per the
    guidelines provided by PyPA.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍构建包的技术、访问程序中的包以及根据PyPA提供的指南发布和共享包的方法。
- en: We will start with package names, followed by the use of an initialization file,
    and then jump into building a sample package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从包名称开始，然后是初始化文件的使用，接着进入构建示例包。
- en: Naming
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名
- en: Package names should follow the same rule for naming as for modules, which is
    lowercase with no underscores. Packages act like structured modules.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 包名称应遵循与模块相同的命名规则，即小写且不带下划线。包类似于结构化模块。
- en: Package initialization file
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包初始化文件
- en: 'A package can have an optional source file named `__init__.py` (or simply an
    `init` file). The presence of the `init` file (even a blank one) is recommended
    to mark folders as packages. Since Python release 3.3 or later, the use of an
    `init` file is optional (PEP 420: Implicit Namespace Packages). There can be multiple
    purposes of using this `init` file and there is always a debate about what can
    go inside an `init` file versus what cannot go in. A few uses of the `init` file
    are discussed here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包可以有一个可选的源文件，名为`__init__.py`（或简单地称为`init`文件）。建议存在`init`文件（即使是空的）来标记文件夹为包。自Python
    3.3或更高版本以来，使用`init`文件是可选的（PEP 420：隐式命名空间包）。使用此`init`文件可能有多个目的，并且总是有关于什么可以放入`init`文件以及什么不可以放入的争论。这里讨论了`init`文件的一些用途：
- en: '**Empty __init__.py**: This will force developers to use explicit imports and
    manage the namespaces as they like. As expected, developers have to import separate
    modules, which can be tedious for a large package.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空的`__init__.py`**：这将迫使开发者使用显式导入并按他们喜欢的管理命名空间。正如预期的那样，开发者必须导入单独的模块，对于大型包来说可能会很繁琐。'
- en: '`__init__` file.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`文件。'
- en: '`init` file from different modules and manage them under the package namespace.
    This provides the additional benefit of providing a wrapper around the underlying
    module''s functionality. If by any chance we have to refactor the underlying modules,
    we have an option to keep the namespace the same, especially for API consumers.
    The only drawback of this approach is that it requires extra effort to manage
    and maintain such `init` files.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同的模块创建`init`文件并管理它们在包命名空间下。这提供了额外的优势，即在底层模块的功能周围提供一个包装器。如果万一我们需要重构底层模块，我们有选项保持命名空间不变，特别是对于API消费者。这种方法的唯一缺点是，需要额外的努力来管理和维护这样的`init`文件。
- en: Sometimes, developers add code to the `init` file that is executed when a module
    is imported from a package. An example of such code is to create a session for
    remote systems such as a database or remote SSH server.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发者会在`init`文件中添加代码，当从包中导入模块时执行。这类代码的一个例子是为远程系统（如数据库或远程SSH服务器）创建一个会话。
- en: Building a package
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个包
- en: 'Now we will discuss how to build a package with one sample package example.
    We will build a `masifutil` package using the following modules and a sub-package:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论如何使用一个示例包来构建一个包。我们将使用以下模块和一个子包来构建`masifutil`包：
- en: 'The `mycalculator.py` module: We already built this module for the *Importing
    modules* section.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mycalculator.py`模块：我们已经在*导入模块*部分构建了这个模块。'
- en: 'The `myrandom.py` module: This module was also built for the *Importing modules*
    section.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myrandom.py`模块：这个模块也是为*导入模块*部分构建的。'
- en: 'The `advcalc` sub-package: This will be a sub-package and will contain one
    module in it (`advcalculator.py`). We will define an `init` file for this sub-package
    but it will be empty.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`advcalc`子包：这将是一个子包，并包含一个模块（`advcalculator.py`）。我们将为这个子包定义一个`init`文件，但它将是空的。'
- en: 'The `advcalculator.py` module has additional functions for calculating the
    square root and log using base 10 and base 2\. The source code for this module
    is shown next:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`advcalculator.py`模块具有额外的函数，用于使用10和2的底数计算平方根和对数。此模块的源代码如下：'
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The file structure of the `masifutil` package with `init` files will look like
    this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 包`masifutil`的文件结构以及`init`文件将看起来像这样：
- en: '![Figure 2.5 – Folder structure of the masifutil package with modules and sub-packages'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 包含模块和子包的masifutil包的文件夹结构'
- en: '](img/B17189_02_05.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 包含模块和子包的masifutil包的文件夹结构'
- en: Figure 2.5 – Folder structure of the masifutil package with modules and sub-packages
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 包含模块和子包的masifutil包的文件夹结构
- en: 'In the next step, we will build a new main script (`pkgmain1.py`) to consume
    the modules from the package or `masifutil` subfolder. In this script, we will
    import the modules from the main package and sub-package using the folder structure,
    and then use the module functions to compute two random numbers, the sum and difference
    of the two numbers, and the square root and logarithmic values of the first random
    numbers. The source code for `pkgmain1.py` is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将构建一个新的主脚本（`pkgmain1.py`）来消费包或`masifutil`子文件夹中的模块。在这个脚本中，我们将使用文件夹结构从主包和子包导入模块，然后使用模块函数计算两个随机数，这两个数的和与差，以及第一个随机数的平方根和对数值。`pkgmain1.py`的源代码如下：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we will be using the package name and module name to import the modules,
    which is cumbersome especially when we need to import the sub-packages. We can
    also use the following statements with the same results:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用包名和模块名来导入模块，这在需要导入子包时尤其繁琐。我们还可以使用以下语句，结果相同：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As mentioned earlier, the use of the empty `__init__.py` file is optional. But
    we have added it in this case for illustration purposes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用空的`__init__.py`文件是可选的。但在这个例子中，我们添加了它以供说明。
- en: 'Next, we will explore how to add some `import` statements to the `init` file.
    Let''s start with importing the modules inside the `init` file. In this top-level
    `init` file, we will import all functions as shown next:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何在`init`文件中添加一些`import`语句。让我们从在`init`文件中导入模块开始。在这个顶级`init`文件中，我们将导入所有函数，如下所示：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the use of `.` before the module name. This is required for Python for
    the strict use of relative imports.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意模块名称前的`.`的使用。这对于Python来说，是严格使用相对导入所必需的。
- en: 'As a result of these three lines inside the `init` file, the new main script
    will become simple and the sample code is shown next:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`init`文件中的这三行，新的主脚本将变得简单，下面的示例代码展示了这一点：
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The functions of the two main modules and the sub-package module are available
    at the main package level and the developers do not need to know the underlying
    hierarchy and structure of the modules within the package. This is the convenience
    we discussed earlier of using `import` statements inside the `init` file.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要模块和子包模块的功能在主包级别可用，开发者不需要知道包内模块的底层层次和结构。这是我们之前讨论的在使用`init`文件内的`import`语句时的便利性。
- en: We build the package by keeping the package source code in the same folder where
    the main program or script resides. This works only to share the modules within
    a project. Next, we will discuss how to access the package from other projects
    and from any program from anywhere.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将包源代码保存在主程序或脚本所在的同一文件夹中来构建包。这仅适用于在项目内共享模块。接下来，我们将讨论如何从其他项目和从任何程序从任何地方访问包。
- en: Accessing packages from any location
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从任何位置访问包
- en: The package we built in the previous subsection is accessible only if the program
    calling the modules is at the same level as the package location. This requirement
    is not practical for code reusability and code sharing.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一小节中构建的包，只有当调用模块的程序与包位置处于同一级别时才能访问。这一要求对于代码重用和代码共享来说并不实用。
- en: In this section, we will discuss a few techniques to make packages available
    and usable from any program on any location in our system.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些使包在任何程序和系统中的任何位置可用和可用的技术。
- en: Appending sys.path
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 追加sys.path
- en: This is a useful option for setting `sys.path` dynamically. Note that `sys.path`
    is a list of directories on which a Python interpreter searches every time it
    executes an `import` statement in a source program. By using this approach, we
    are appending (adding) paths of directories or folders containing our packages
    to `sys.path`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个设置`sys.path`动态的有用选项。请注意，`sys.path`是Python解释器在执行源程序中的每个`import`语句时搜索的目录列表。通过使用这种方法，我们将包含我们的包的目录或文件夹的路径追加到`sys.path`中。
- en: 'For the `masifutil` package, we will build a new program, `pkgmain3.py`, which
    is a copy of `pkgmain2.py` (to be updated later) but is kept outside the folder
    where our `masifutil` package is residing. `pkgmain3.py` can be in any folder
    other than the `mypackages` folder. Here is the folder structure with a new main
    script (`pkgmain3.py`) and the `masifutil` package for reference:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`masifutil`包，我们将构建一个新的程序，`pkgmain3.py`，它是`pkgmain2.py`（稍后更新）的副本，但被保存在我们的`masifutil`包所在文件夹之外。`pkgmain3.py`可以放在除`mypackages`文件夹之外的任何文件夹中。以下是包含新主脚本（`pkgmain3.py`）和`masifutil`包的文件夹结构，供参考：
- en: '![Figure 2.6 – Folder structure of the masifutil package and a new main script,
    pkgmain3.py'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.6 – Folder structure of the masifutil package and a new main script,
    pkgmain3.py](img/B17189_02_06.jpg)'
- en: '](img/B17189_02_06.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_02_06.jpg](img/B17189_02_06.jpg)'
- en: Figure 2.6 – Folder structure of the masifutil package and a new main script,
    pkgmain3.py
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – masifutil包的文件夹结构和新的主脚本，pkgmain3.py
- en: 'When we execute the `pkgmain3.py` program, it returns an error: `ModuleNotFoundError:
    No module named ''masifutil''`. This is expected as the path of the `masifutil`
    package is not added to `sys.path`. To add the package folder to `sys.path`, we
    will update the main program; let''s name it `pkgmain4.py`, with additional statements
    for appending `sys.path`, which is shown next:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们执行`pkgmain3.py`程序时，它返回一个错误：`ModuleNotFoundError: No module named ''masifutil''`。这是预期的，因为`masifutil`包的路径没有被添加到`sys.path`中。为了将包文件夹添加到`sys.path`，我们将更新主程序；让我们称它为`pkgmain4.py`，并添加附加的`sys.path`追加语句，如下所示：'
- en: '[PRE29]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After adding the additional lines of appending `sys.path`, we executed the main
    script without any error and with the expected console output. This is because
    our `masifutil` package is now available on a path where the Python interpreter
    can load it when we are importing it in our main script.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加追加`sys.path`的附加行之后，我们执行了主脚本而没有错误，并且输出了预期的控制台输出。这是因为我们的`masifutil`包现在位于Python解释器可以加载它的路径上，当我们在我们主脚本中导入它时。
- en: 'Alternative to appending `sys.path`, we can also use the `site.addsitedir`
    function from the site module. The only advantage of using this approach is that
    this function also looks for `.pth` files within the included folders, which is
    helpful for adding additional folders such as sub-packages. A snippet of a sample
    main script (`pktpamin5.py`) with the `addsitedir` function is shown next:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了追加`sys.path`之外，我们还可以使用site模块中的`site.addsitedir`函数。使用这种方法的优势仅在于这个函数也会在包含的文件夹中查找.pth文件，这对于添加额外的文件夹，如子包，很有帮助。下面是一个带有`addsitedir`函数的示例主脚本（`pktpamin5.py`）片段：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that the directories we append or add using this approach are available
    only during the program execution. To set `sys.path` permanently (at the session
    or system level), the approaches that we will discuss next are more helpful.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用这种方法追加或添加的目录仅在程序执行期间可用。要永久设置`sys.path`（在会话或系统级别），我们将讨论的以下方法更有帮助。
- en: Using the PYTHONPATH environment variable
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用PYTHONPATH环境变量
- en: This is a convenient way to add our package folder to `sys.path`, which the
    Python interpreter will use to search for the package and modules if not present
    in the built-in library. Depending on the operating system we are using, we can
    define this variable as follows.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方便的方法将我们的包文件夹添加到`sys.path`，Python解释器将使用它来搜索包和模块，如果它们不在内置库中。根据我们使用的操作系统，我们可以如下定义这个变量。
- en: 'In Windows, the environment variable can be defined using either of the following
    options:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，可以使用以下任一选项定义环境变量：
- en: '`PYTHONPATH = "C:\pythonpath1;C:\pythonpath2"`. This is good for one active
    session.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PYTHONPATH = "C:\pythonpath1;C:\pythonpath2"`。这对于一个活动会话来说很好。'
- en: '**The graphical user interface**: Go to **My Computer** | **Properties** |
    **Advanced System Settings** | **Environment Variables**. This is a permanent
    setting.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形用户界面**：转到**我的电脑** | **属性** | **高级系统设置** | **环境变量**。这是一个永久设置。'
- en: In Linux and macOS, it can be set using `` export PYTHONPATH= `/some/path/`
    ``. If set using Bash or an equivalent terminal, the environment variable will
    be effective for the terminal session only. To set it permanently, it is recommended
    to add the environment variable at the end of a profile file, such as `~/bash_profile`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS中，可以使用`export PYTHONPATH= `/some/path/` ``来设置。如果使用Bash或等效终端设置，环境变量将仅对终端会话有效。要永久设置，建议将环境变量添加到配置文件末尾，例如`~/bash_profile`。
- en: 'If we execute the `pkgmain3.py` program without setting `PYTHONPATH`, it returns
    an error: `ModuleNotFoundError: No module named ''masifutil''`. This is again
    expected as the path of the `masifutil` package is not added to `PYTHONPATH`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们不设置`PYTHONPATH`就执行`pkgmain3.py`程序，它将返回一个错误：`ModuleNotFoundError: No module
    named ''masifutil''`。这同样是可以预料的，因为`masifutil`包的路径没有被添加到`PYTHONPATH`中。'
- en: In the next step, we will add the folder path containing `masifutil` to the
    `PYTHONPATH` variable and rerun the `pkgmain3` program. This time, it works without
    any error and with the expected console output.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将添加包含`masifutil`的文件夹路径到`PYTHONPATH`变量中，并重新运行`pkgmain3`程序。这次，它没有错误并且输出了预期的控制台输出。
- en: Using the .pth file under the Python site package
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Python站点包下的.pth文件
- en: This is another convenient way of adding packages to `sys.path`. This is achieved
    by defining a `.pth` file under the Python site packages. The file can hold all
    the folders we want to add to `sys.path`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种将软件包添加到 `sys.path` 的便捷方式。这是通过在 Python 站点包下定义一个 `.pth` 文件来实现的。该文件可以包含我们想要添加到
    `sys.path` 的所有文件夹。
- en: 'For illustration purposes, we created a `my.pth` file under `venv/lib/Python3.7/site-packages`.
    As we can see in *Figure 2.7*, we added a folder that contains our `masifutil`
    package. With this simple `.pth` file, our main script `pkymain3.py` program works
    fine without any error and with expected console output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明目的，我们在 `venv/lib/Python3.7/site-packages` 下创建了一个 `my.pth` 文件。正如我们在 *图 2.7*
    中所看到的，我们添加了一个包含我们的 `masifutil` 软件包的文件夹。通过这个简单的 `.pth` 文件，我们的主要脚本 `pkymain3.py`
    程序运行良好，没有任何错误，并产生预期的控制台输出：
- en: '![Figure 2.7 – A view of a virtual environment with the my.pth file](img/B17189_02_07.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 包含 my.pth 文件的虚拟环境视图](img/B17189_02_07.jpg)'
- en: Figure 2.7 – A view of a virtual environment with the my.pth file
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 包含 my.pth 文件的虚拟环境视图
- en: The approaches we discussed to access custom packages are effective to reuse
    the packages and modules on the same system with any program. In the next section,
    we will explore how to share packages with other developers and communities.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的访问自定义软件包的方法对于在相同系统上的任何程序中重用软件包和模块是有效的。在下一节中，我们将探讨如何与其他开发者和社区共享软件包。
- en: Sharing a package
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享软件包
- en: To distribute Python packages and projects across communities, there are many
    tools available. We will focus only on the tools that are recommended as per the
    guidelines provided by PyPA.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在社区间分发 Python 软件包和项目，有许多工具可供选择。我们只关注根据 PyPA 提供的指南推荐使用的工具。
- en: 'In this section, we will be covering installing and distributing packaging
    techniques. A few tools that we will use or are at least worth mentioning in this
    section as a reference are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍安装和分发打包技术。我们将使用或至少在本节中作为参考的一些工具如下：
- en: '**distutils**: This comes with Python with base functionality. It is not easy
    to extend for complex and custom package distribution.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**distutils**：这是 Python 的一部分，具有基本功能。对于复杂和定制的软件包分发，它不容易扩展。'
- en: '**setuputils**: This is a third-party tool and an extension of distutils and
    is recommended for building packages.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setuputils**：这是一个第三方工具，是 distutils 的扩展，并建议用于构建软件包。'
- en: '**wheel**: This is for the Python packaging format and it makes installations
    faster and easier as compared to its predecessors.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wheel**：这是 Python 打包格式，与前辈相比，它使安装更快、更简单。'
- en: '`pip install <module name>`.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install <module name>`。'
- en: '**The Python Package Index (PyPI)**: This is a repository of software for the
    Python programming language. PyPI is used to find and install software developed
    and shared by the Python community.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 包索引 (PyPI)**：这是一个 Python 编程语言的软件仓库。PyPI 用于查找和安装由 Python 社区开发和共享的软件。'
- en: '**Twine**: This is a utility for publishing Python packages to PyPI.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Twine**：这是一个用于将 Python 软件包发布到 PyPI 的实用工具。'
- en: In the next subsections, we will update the `masifutil` package to include additional
    components as per the guidelines provided by PyPA. This will be followed by installing
    the updated `masifutil` package system-wide using pip. In the end, we will publish
    the updated `masifutil` package to **Test PyPI** and install it from Test PyPI.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将根据 PyPA 提供的指南更新 `masifutil` 软件包，以包含额外的组件。这将随后通过 pip 在系统范围内安装更新的
    `masifutil` 软件包。最后，我们将发布更新的 `masifutil` 软件包到 **测试 PyPI** 并从测试 PyPI 安装它。
- en: Building a package as per the PyPA guidelines
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据 PyPA 指南构建软件包
- en: 'PyPA recommends using a sample project for building reusable packages and it
    is available at [https://github.com/pypa/sampleproject](https://github.com/pypa/sampleproject).
    A snippet of the sample project from the GitHub location is as shown:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: PyPA 推荐使用示例项目来构建可重用的软件包，该项目可在 [https://github.com/pypa/sampleproject](https://github.com/pypa/sampleproject)
    找到。以下是从 GitHub 位置获取的示例项目片段：
- en: '![Figure 2.8 – A view of the sample project on GitHub by PyPA'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – PyPA 在 GitHub 上的示例项目视图](img/B17189_02_08.jpg)'
- en: '](img/B17189_02_08.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – 包含 my.pth 文件的虚拟环境视图](img/B17189_02_08.jpg)'
- en: Figure 2.8 – A view of the sample project on GitHub by PyPA
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – PyPA 在 GitHub 上的示例项目视图
- en: 'We will introduce key files and folders, which are important to understand
    before we use them for updating our `masifutil` package:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用它们更新 `masifutil` 软件包之前，我们将介绍一些关键文件和文件夹，这些文件和文件夹对于理解它们很重要：
- en: '`setup.py`: This is the most important file, which has to exist at the root
    of the project or package. It is a script for building and installing the package.
    This file contains a global `setup()` function. The setup file also provides a
    command-line interface for running various commands.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py`：这是最重要的文件，它必须存在于项目或包的根目录中。它是一个用于构建和安装包的脚本。此文件包含一个全局的`setup()`函数。设置文件还提供了用于运行各种命令的命令行界面。'
- en: '`setup.cfg`: This is an `ini` file that can be used by `setup.py` to define
    defaults.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.cfg`：这是一个`ini`文件，可以被`setup.py`用来定义默认值。'
- en: '`setup()` args: The key arguments that can be passed to the setup function
    are as follows:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup()`参数：可以传递给设置函数的关键参数如下：'
- en: a) Name
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 名称
- en: b) Version
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 版本
- en: c) Description
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 描述
- en: d) URL
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 网址
- en: e) Author
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e) 作者
- en: f) License
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: f) 许可证
- en: '`README.rst`/`README.md`: This file (either reStructured or Markdown format)
    can contain information about the package or project.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.rst`/`README.md`：此文件（无论是 reStructuredText 还是 Markdown 格式）可以包含有关包或项目的信息。'
- en: '`license.txt`: The `license.txt` file should be included with every package
    with details of the terms and conditions of distribution. The license file is
    important, especially in countries where it is illegal to distribute packages
    without the appropriate license.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license.txt`：`license.txt`文件应包含每个包的分发条款和条件详情。许可证文件很重要，尤其是在那些在没有适当许可证的情况下分发包是非法的国家。'
- en: '`MANIFEST.in`: This file can be used to specify a list of additional files
    to include in the package. This list of files doesn''t include the source code
    files (which are automatically included).'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MANIFEST.in`：此文件可以用来指定要包含在包中的附加文件列表。此文件列表不包括源代码文件（这些文件会自动包含）。'
- en: '`<package>`: This is the top-level package containing all the modules and packages
    inside it. It is not mandatory to use, but it is a recommended approach.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<package>`：这是包含其中所有模块和包的顶级包。虽然不是强制性的，但这是一个推荐的方法。'
- en: '`data`: This is a place to add data files if needed.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是一个添加数据文件的地点。'
- en: '`tests`: This is a placeholder to add unit tests for the modules.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`：这是一个占位符，用于添加模块的单元测试。'
- en: 'As a next step, we will update our previous `masifutil` package as per the
    PyPA guidelines. Here is the new folder and file structure of the updated `masifutilv2`
    package:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们将根据 PyPA 指南更新我们之前的`masifutil`包。以下是更新后的`masifutilv2`包的新文件夹和文件结构：
- en: '![Figure 2.9 – A view of the updated masifutilv2 file structure'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 – 更新后的masifutilv2文件结构视图'
- en: '](img/B17189_02_09.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_02_09.jpg)'
- en: Figure 2.9 – A view of the updated masifutilv2 file structure
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 更新后的masifutilv2文件结构视图
- en: We have added `data` and `tests` directories, but they are actually empty for
    now. We will evaluate the unit tests in a later chapter to complete this topic.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了`data`和`tests`目录，但目前它们实际上是空的。我们将在后面的章节中评估单元测试来完成这个主题。
- en: The contents of most of the additional files are covered in the sample project
    and thus will not be discussed here, except the `setup.py` file.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数附加文件的内容已在示例项目中涵盖，因此在此不讨论，除了`setup.py`文件。
- en: 'We updated `setup.py` with basic arguments as per our package project. The
    details of the rest of the arguments are available in the sample `setup.py` file
    provided with the sample project by PyPA. Here is a snippet of our `setup.py`
    file:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据我们的包项目更新了`setup.py`的基本参数。其余参数的详细信息可在 PyPA 提供的示例`setup.py`文件中找到。以下是我们的`setup.py`文件的一个片段：
- en: '[PRE31]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this `setup.py` file, we are ready to share our `masifutilv2` package locally
    as well as remotely, which we will discuss in the next subsections.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`setup.py`文件，我们准备在本地以及远程共享我们的`masifutilv2`包，这将在下一节中讨论。
- en: Installing from the local source code using pip
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pip 从本地源代码安装
- en: 'Once we have updated the package with new files, we are ready to install it
    using the pip utility. The simplest way to install it is by executing the following
    command with the path to the `masifutilv2` folder:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用新文件更新了包，我们就可以使用 pip 工具安装它。最简单的方法是执行以下命令，并指定`masifutilv2`文件夹的路径：
- en: '[PRE32]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the console output of the command when run without installing
    the wheel package:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在不安装 wheel 包的情况下运行命令的控制台输出：
- en: '[PRE33]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The pip utility installed the package successfully but using the egg format
    since the `wheel` package was not installed. Here is a view of our virtual environment
    after the installation:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: pip 工具成功安装了包，但由于`wheel`包尚未安装，所以使用了 egg 格式。以下是安装后的虚拟环境视图：
- en: '![Figure 2.10 – A view of the virtual environment after installing masifutilv2
    using pip'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10 – 使用 pip 安装 masifutilv2 后的虚拟环境视图'
- en: '](img/B17189_02_10.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_02_10.jpg)'
- en: Figure 2.10 – A view of the virtual environment after installing masifutilv2
    using pip
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 使用 pip 安装 masifutilv2 后的虚拟环境视图
- en: After installing the package under the virtual environment, we tested it with
    our `pkgmain3.py` program, which worked as expected.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境中安装包后，我们使用 `pkgmain3.py` 程序进行了测试，它按预期工作。
- en: Tip
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To uninstall the package, we can use `pip uninstall masifutilv2`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载包，我们可以使用 `pip uninstall masifutilv2`。
- en: 'As a next step, we will install the `wheel` package and then reinstall the
    same package again. Here is the installation command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们将安装 `wheel` 包，然后再次重新安装相同的包。以下是安装命令：
- en: '[PRE34]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The console output will be similar to the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出将类似于以下内容：
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The package is installed successfully using `wheel` this time and we can see
    it appears in our virtual environment as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这次使用 `wheel` 成功安装了包，我们可以看到它如下出现在我们的虚拟环境中：
- en: '![Figure 2.11 – A view of the virtual environment after installing masifutilv2
    with wheel and using pip'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11 – 使用 wheel 和 pip 安装 masifutilv2 后的虚拟环境视图'
- en: '](img/B17189_02_11.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_02_11.jpg)'
- en: Figure 2.11 – A view of the virtual environment after installing masifutilv2
    with wheel and using pip
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 使用 wheel 和 pip 安装 masifutilv2 后的虚拟环境视图
- en: In this section, we have installed a package using the pip utility from the
    local source code. In the next section, we will publish the package to a centralized
    repository (Test PyPI).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已使用 pip 工具从本地源代码安装了一个包。在下一节中，我们将把包发布到集中式仓库（测试 PyPI）。
- en: Publishing a package to Test PyPI
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布包到测试 PyPI
- en: As a next step, we will add our sample package to the PyPI repository. Before
    executing any command for publishing our package, we will need to create an account
    on Test PyPI. Note that Test PyPI is a separate instance of the package index
    specifically for testing. In addition to the account with Test PyPI, we also need
    to add an **API token** to the account. We will leave the details of creating
    an account and adding an API token to the account for you by following the instructions
    available on the Test PyPI website ([https://test.pypi.org/](https://test.pypi.org/)).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们将把我们的样本包添加到 PyPI 仓库。在执行任何发布我们包的命令之前，我们需要在测试 PyPI 上创建一个账户。请注意，测试 PyPI
    是一个专门用于测试的包索引的独立实例。除了测试 PyPI 的账户外，我们还需要向账户添加一个 **API 令牌**。我们将根据测试 PyPI 网站上的说明（[https://test.pypi.org/](https://test.pypi.org/)）为您留下创建账户和添加
    API 令牌的详细信息。
- en: 'To push the package to Test PyPI, we will need the Twine utility. We assume
    Twine is installed using the pip utility. To upload the `masifutilv2` package,
    we will execute the following steps:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要将包推送到测试 PyPI，我们需要 Twine 工具。我们假设 Twine 是使用 pip 工具安装的。要上传 `masifutilv2` 包，我们将执行以下步骤：
- en: 'Create a distribution using the following command. This `sdist` utility will
    create a TAR ZIP file under a `dist` folder:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个分发。此 `sdist` 工具将在 `dist` 文件夹下创建一个 TAR ZIP 文件：
- en: '[PRE36]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Upload the distribution file to Test PyPI. When prompted for a username and
    password, provide `__token__` as the username and the API token as the password:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分发文件上传到测试 PyPI。当提示输入用户名和密码时，请使用 `__token__` 作为用户名，API 令牌作为密码：
- en: '[PRE37]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This command will push the package TAR ZIP file to the Test PyPI repository
    and the console output will be similar to the following:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将包的 TAR ZIP 文件推送到测试 PyPI 仓库，控制台输出将类似于以下内容：
- en: '[PRE38]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can view the uploaded file at [https://test.pypi.org/project/masifutilv2/0.1.0/](https://test.pypi.org/project/masifutilv2/0.1.0/)
    after a successful upload.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功上传后，我们可以在 [https://test.pypi.org/project/masifutilv2/0.1.0/](https://test.pypi.org/project/masifutilv2/0.1.0/)
    查看上传的文件。
- en: Installing the package from PyPI
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 PyPI 安装包
- en: 'Installing the package from Test PyPI is the same as installing from a regular
    repository, except that we need to provide the repository URL by using the `index-url`
    arguments. The command and the console output will be similar to the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试 PyPI 安装包与从常规仓库安装相同，只是我们需要通过使用 `index-url` 参数提供仓库 URL。命令和控制台输出将类似于以下内容：
- en: '[PRE39]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This command will present console output similar to the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示类似于以下内容的控制台输出：
- en: '[PRE40]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As we can see in the console output, pip is searching for the module in Test
    PyPI. Once it finds the package with the name `masifutilv2`, it starts downloading
    and then installing it in the virtual environment.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在控制台输出中看到的那样，pip 正在 Test PyPI 中搜索模块。一旦它找到了名为 `masifutilv2` 的包，它就开始下载并在虚拟环境中安装它。
- en: In short, we have observed that once we create a package using the recommended
    format and style, then publishing and accessing the package is just a matter of
    using Python utilities and following the standard steps.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们观察到，一旦我们使用推荐的格式和风格创建了一个包，那么发布和访问包就只是使用 Python 工具和遵循标准步骤的问题。
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the concept of modules and packages in Python.
    We discussed how to build reusable modules and how they can be imported by other
    modules and programs. We also covered the loading and initializing of modules
    when included (by an import process) by other programs. In the later part of this
    chapter, we discussed building simple and advanced packages. We also provided
    a lot of code examples to access the packages, as well as installing and publishing
    the package for efficient reusability.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Python 中的模块和包的概念。我们讨论了如何构建可重用的模块以及它们如何被其他模块和程序导入。我们还介绍了模块在被其他程序包含（通过导入过程）时的加载和初始化。在本章的后半部分，我们讨论了构建简单和高级包。我们还提供了大量的代码示例来访问包，以及安装和发布包以提高重用性。
- en: After going through this chapter, you have learned how to build modules and
    packages and how to share and publish the packages (and modules). These skills
    are important if you are working on a project as a team in an organization or
    you are building Python libraries for a larger community.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完本章后，你已经学会了如何构建模块和包，以及如何共享和发布包（和模块）。如果你在一个组织内作为团队的一员工作，或者你正在为更大的社区构建 Python
    库，这些技能都是非常重要的。
- en: In the next chapter, we will discuss the next level of modularization using
    object-oriented programming in Python. This will encompass encapsulation, inheritance,
    polymorphism, and abstraction, which are key tools to build and manage complex
    projects in the real world.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用 Python 面向对象编程进行模块化的高级层次。这包括封装、继承、多态和抽象，这些是在现实世界中构建和管理复杂项目的关键工具。
- en: Questions
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a module and a package?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块和包之间有什么区别？
- en: What are absolute and relative imports in Python?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 中的绝对导入和相对导入是什么？
- en: What is PyPA?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyPA 是什么？
- en: What is Test PyPI and why do we need it?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 PyPI 是什么，为什么我们需要它？
- en: Is an `init` file a requirement to build a package?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`init` 文件是构建包的必要条件吗？'
- en: Further reading
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Modular Programming with Python* by Erik Westra'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Python 模块化编程*》由 Erik Westra 编著
- en: '*Expert Python Programming* by Michał Jaworski and Tarek Ziadé'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*专家 Python 编程*》由 Michał Jaworski 和 Tarek Ziadé 编著
- en: Python Packaging User Guide ([https://packaging.python.org/](https://packaging.python.org/))
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 打包用户指南 ([https://packaging.python.org/](https://packaging.python.org/))
- en: 'PEP 420: Implicit Namespace Packages ([https://www.python.org/dev/peps/pep-0420/](https://www.python.org/dev/peps/pep-0420/))'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 420：隐式命名空间包 ([https://www.python.org/dev/peps/pep-0420/](https://www.python.org/dev/peps/pep-0420/))
- en: Answers
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A module is meant to organize functions, variables, and classes into separate
    Python code files. A Python package is like a folder to organize multiple modules
    or sub-packages.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块旨在将函数、变量和类组织到单独的 Python 代码文件中。Python 包就像一个文件夹，用于组织多个模块或子包。
- en: Absolute import requires the use of the absolute path of a package starting
    from the top level, whereas relative import is based on the relative path of the
    package as per the current location of the program in which the `import` statement
    is to be used.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绝对导入需要从顶级开始使用包的绝对路径，而相对导入是基于包的相对路径，该路径根据程序当前的位置来确定，其中要使用 `import` 语句。
- en: The **Python Packaging Authority** (**PyPA**) is a working group that maintains
    a core set of software projects used in Python packaging.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Python 包管理权威机构**（**PyPA**）是一个维护 Python 打包中使用的核心软件项目的工作组。'
- en: Test PyPI is a repository of software for the Python programming language for
    testing purposes.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试 PyPI 是用于测试目的的 Python 编程语言的软件仓库。
- en: The `init` file is optional since Python version 3.3.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Python 3.3 版本开始，`init` 文件是可选的。
