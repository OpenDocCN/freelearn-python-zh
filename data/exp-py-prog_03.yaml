- en: Chapter 3. Syntax Best Practices – above the Class Level
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。 语法最佳实践-在类级别以上
- en: We will now focus on syntax best practices for classes. It is not intended to
    cover design patterns here, as they will be discussed in [Chapter 14](ch14.html
    "Chapter 14. Useful Design Patterns"), *Useful Design Patterns*. This chapter
    gives an overview of the advanced Python syntax to manipulate and enhance the
    class code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于类的语法最佳实践。这里不打算涵盖设计模式，因为它们将在[第14章](ch14.html "第14章。有用的设计模式")*有用的设计模式*中讨论。本章概述了高级Python语法，以操纵和增强类代码。
- en: Object model evolved greatly during history of Python 2\. For a long time we
    lived in a world where two implementations of the object-oriented programming
    paradigm coexisted in the same language. These two models were simply referred
    to as *old-style* and *new-style* classes. Python 3 ended this dichotomy and only
    model known as *new-style* classes is available to the developers. Anyway, it
    is still important to know how both of them worked in Python 2 because it will
    help you in porting old code and writing backwards compatible applications. Knowing
    how the object model changed will also help you in understanding why it is designed
    that way right now. This is the reason why the following chapter will have a relatively
    large number of notes about old Python 2 features despite this book targets the
    latest Python 3 releases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对象模型在Python 2的历史中发生了很大的变化。很长一段时间，我们生活在一个同一语言中两种面向对象编程范式的实现并存的世界中。这两种模型简单地被称为*旧式*和*新式*类。Python
    3结束了这种二分法，只有*新式*类这种模型可供开发人员使用。无论如何，了解它们在Python 2中是如何工作的仍然很重要，因为它将帮助您移植旧代码并编写向后兼容的应用程序。了解对象模型的变化也将帮助您理解为什么它现在是这样设计的。这就是为什么下一章将有相对较多关于旧Python
    2功能的注释，尽管本书的目标是最新的Python 3版本。
- en: 'The following topics will be discussed in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下主题：
- en: Subclassing built-in types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类内置类型
- en: Accessing methods from super classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从超类访问方法
- en: Using properties and slots
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和插槽
- en: Metaprogramming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元编程
- en: Subclassing built-in types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类内置类型
- en: Subclassing built-in types in Python is pretty straightforward. A built-in type
    called `object` is a common ancestor for all built-in types as well as all user-defined
    classes that have no explicit parent class specified. Thanks to this, every time
    a class that behaves almost like one of the built-in types needs to be implemented,
    the best practice is to subtype it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，对内置类型进行子类化非常简单。名为`object`的内置类型是所有内置类型以及所有未明确指定父类的用户定义类的共同祖先。由于这个原因，每当需要实现一个行为几乎像内置类型之一的类时，最佳实践是对其进行子类型化。
- en: 'Now, we will show you the code for a class called `distinctdict`, which uses
    this technique. It is a subclass of the usual Python `dict` type. This new class
    behaves in most ways like an ordinary Python `dict`. But instead of allowing multiple
    keys with the same value, when someone tries to add a new entry with an identical
    value, it raises a `ValueError` subclass with a help message:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向您展示一个名为`distinctdict`的类的代码，它使用了这种技术。它是通常的Python `dict`类型的子类。这个新类在大多数方面的行为都像一个普通的Python
    `dict`。但是，与其允许具有相同值的多个键不同，当有人尝试添加一个具有相同值的新条目时，它会引发一个带有帮助消息的`ValueError`子类：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is an example of using `distictdict` in interactive session:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在交互会话中使用`distictdict`的示例：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you take a look at your existing code, you may find a lot of classes that
    partially implement the built-in types, and could be faster and cleaner as subtypes.
    The `list` type, for instance, manages the sequences and could be used every time
    a class works internally with a sequence:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看现有代码，可能会发现许多部分实现内置类型的类，并且可以作为子类型更快，更清洁。例如，`list`类型管理序列，并且可以在类内部使用序列时使用：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is an example usage in interactive session:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在交互会话中的一个示例用法：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Built-in types cover most use cases**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**内置类型涵盖了大多数用例**'
- en: When you are about to create a new class that acts like a sequence or a mapping,
    think about its features and look over the existing built-in types. The `collections`
    module extends basic built-in types with many useful containers. You will end
    up using one of them most of the time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当您要创建一个类似序列或映射的新类时，请考虑其特性并查看现有的内置类型。`collections`模块扩展了许多有用的容器的基本内置类型。您将大部分时间使用其中一个。
- en: Accessing methods from superclasses
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从超类访问方法
- en: '`super` is a built-in class that can be used to access an attribute belonging
    to an object''s superclass.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`是一个内置类，可用于访问属于对象的超类的属性。'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Python official documentation lists `super` as a built-in function. But
    it''s a built-in class, even if it is used like a function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python官方文档将`super`列为内置函数。但它是一个内置类，即使它像一个函数一样使用：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Its usage is a bit confusing when you are used to accessing a class attribute
    or method by calling the parent class directly and passing `self` as the first
    argument. This is really old pattern but still can be found in some codebases
    (especially in legacy projects). See the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当您习惯于通过直接调用父类并将`self`作为第一个参数传递来访问类属性或方法时，其用法有点令人困惑。这是一个非常古老的模式，但在一些代码库中仍然可以找到（特别是在传统项目中）。请参阅以下代码：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When run in an interpreter session it gives following result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释器会话中运行时，会得到以下结果：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Look particularly at the line `Mama.says(self)`, where we use the technique
    just described to call the `says()` method of the superclass (that is, the `Mama`
    class), and pass `self` as the argument. This means, the `says()` method belonging
    to `Mama` will be called. But the instance on which it will be called is provided
    as the `self` argument, which is an instance of `Sister` in this case.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`Mama.says(self)`这一行，我们使用刚才描述的技术来调用超类（即`Mama`类）的`says()`方法，并将`self`作为参数传递。这意味着将调用属于`Mama`的`says()`方法。但是，它将被调用的实例作为`self`参数提供，这在这种情况下是`Sister`的一个实例。
- en: 'Instead, the `super` usage would be:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`super`的用法将是：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can also use the shorter form of the `super()` call:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用`super()`调用的更短形式：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The shorter form of `super` (without passing any arguments) is allowed inside
    the methods but `super` is not limited to methods. It can be used in any place
    of code where a call to the given instance superclass method implementation is
    required. Still, if `super` is not used inside the method, then its arguments
    are mandatory:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`的更短形式（不传递任何参数）允许在方法内部使用，但`super`不仅限于方法。它可以在任何需要调用给定实例的超类方法实现的代码中使用。但是，如果在方法内部不使用`super`，则其参数是必需的：'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last and most important thing that should be noted about `super` is that
    its second argument is optional. When only the first argument is provided, then
    `super` returns an unbounded type. This is especially useful when working with
    `classmethod`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`super`最后且最重要的一点是，它的第二个参数是可选的。当只提供第一个参数时，`super`将返回一个无界类型。这在使用`classmethod`时特别有用：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the zero-argument `super()` form is also allowed for methods decorated
    with the `classmethod` decorator. `super()` called without arguments in such a
    method is treated as having only the first argument defined.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方法装饰有`classmethod`装饰器的方法也允许使用零参数的`super()`形式。在这样的方法中，不带参数地调用`super()`被视为只定义了第一个参数。
- en: The use cases presented earlier are very simple to follow and understand, but
    when you face a multiple inheritance schema, it becomes hard to use `super`. Before
    explaining these problems, understanding when `super` should be avoided and how
    the **Method Resolution** **Order** (**MRO**) works in Python is important.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面介绍的用例非常简单易懂，但当您面对多重继承模式时，使用`super`就变得困难了。在解释这些问题之前，了解何时应避免使用`super`以及Python中**方法解析顺序**（**MRO**）的工作原理是很重要的。
- en: Old-style classes and super in Python 2
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 2中的旧式类和super
- en: '`super()` in Python 2 works almost exactly the same. The only difference in
    call signature is that the shorter, zero-argument form is not available, so at
    least one of the expected arguments must be provided always.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2中的`super()`几乎完全相同。调用签名的唯一区别是，更短的零参数形式不可用，因此始终必须提供预期的参数之一。
- en: 'Another important thing for programmers who want to write cross-version compatible
    code is that `super` in Python 2 works only for new-style classes. The earlier
    versions of Python did not have a common ancestor for all classes in the form
    of `object`. The old behavior was left in every Python 2.x branch release for
    backwards compatibility, so in those versions, if the class definition has no
    ancestor specified, it is interpreted as an old-style class and it cannot use
    `super`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要编写跨版本兼容代码的程序员来说，另一个重要的事情是，Python 2中的`super`仅适用于新式类。早期版本的Python没有以`object`形式的所有类的共同祖先。旧行为在每个Python
    2.x分支版本中都保留了向后兼容性，因此在这些版本中，如果类定义没有指定祖先，它将被解释为旧式类，无法使用`super`：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The new-style class in Python 2 must explicitly inherit from the object or
    other new-style class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2中的新式类必须明确继承自object或其他新式类：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Python 3 no longer maintains the concept of old-style classes, so any class
    that does not inherit from any other class implicitly inherits from `object`.
    This means that explicitly stating that a class inherits from `object` may seem
    redundant. The general good practice is to not include redundant code, but removing
    such redundancy in this case is a good approach only for projects that no longer
    target any of the Python 2 versions. Code that aims for cross-version compatibility
    of Python must always include `object` as an ancestor of base classes even if
    this is redundant in Python 3\. Not doing so will result in such classes being
    interpreted as old style, and this will eventually lead to issues that are very
    hard to diagnose.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3不再维护旧式类的概念，因此任何不继承自其他类的类都隐式继承自`object`。这意味着明确声明一个类继承自`object`可能看起来是多余的。一般的良好实践是不包含多余的代码，但在这种情况下去除这种多余对于不再针对任何Python
    2版本的项目来说是一个好方法。目标跨版本兼容性的Python代码必须始终将`object`作为基类的祖先包括在内，即使在Python 3中这是多余的。不这样做将导致这样的类被解释为旧式类，最终会导致非常难以诊断的问题。
- en: Understanding Python's Method Resolution Order
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Python的方法解析顺序
- en: Python's Method Resolution Order is based on **C3**, the MRO built for the Dylan
    programming language ([http://opendylan.org](http://opendylan.org)). The reference
    document, written by Michele Simionato, is located at [http://www.python.org/download/releases/2.3/mro](http://www.python.org/download/releases/2.3/mro).
    It describes how C3 builds the **linearization** of a class, also called **precedence**,
    which is an ordered list of the ancestors. This list is used to seek an attribute.
    The C3 algorithm is described in more detail later in this section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python的方法解析顺序基于**C3**，这是为Dylan编程语言构建的MRO（[http://opendylan.org](http://opendylan.org)）。Michele
    Simionato撰写的参考文档位于[http://www.python.org/download/releases/2.3/mro](http://www.python.org/download/releases/2.3/mro)。它描述了C3如何构建类的**线性化**，也称为**优先级**，这是祖先的有序列表。这个列表用于寻找属性。稍后在本节中将更详细地描述C3算法。
- en: 'The MRO change was made to resolve an issue introduced with the creation of
    a common base type (`object`). Before the change to the C3 linearization method,
    if a class had two ancestors (refer to *Figure 1*), the order in which methods
    were resolved was quite simple to compute and track for simple cases that do not
    use the multiple inheritance model. Here is an example of code that under Python
    2 would not use C3 as a Method Resolution Order:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: MRO的变化是为了解决引入共同基本类型（`object`）时出现的问题。在C3线性化方法改变之前，如果一个类有两个祖先（参见*图1*），那么解析方法的顺序对于不使用多重继承模型的简单情况来说是非常简单的。以下是一个在Python
    2下不使用C3作为方法解析顺序的代码示例：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following transcript from interactive session shows this method resolution
    at work:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式会话的以下转录显示了这种方法解析的工作方式：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When `MyClass().method()` is called, the interpreter looks for the method in
    `MyClass`, then `Base1`, and then eventually finds it in `Base2`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`MyClass().method()`时，解释器首先在`MyClass`中查找方法，然后在`Base1`中查找，最终在`Base2`中找到：
- en: '![Understanding Python''s Method Resolution Order](graphics/5295_03_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![理解Python的方法解析顺序](graphics/5295_03_01.jpg)'
- en: Figure 1 Classical hierarchy
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图1 经典层次结构
- en: When we introduce some `CommonBase` class on top of the two base classes (both
    `Base1` and `Base2` inherit from it, refer to *Figure 2*), things get more complicated.
    As a result, the simple resolution order that behaves according to the *left to
    right depth first* rule is getting back to the top through the `Base1` class before
    looking into the `Base2` class. This algorithm results in a counterintuitive output.
    In some cases, the method that is executed may not be the one that is the closest
    in the inheritance tree.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在两个基类（`Base1`和`Base2`都继承自它，参见*图2*）之上引入一些`CommonBase`类时，情况变得更加复杂。结果，按照*从左到右深度优先*规则行为的简单解析顺序在查看`Base2`类之前通过`Base1`类返回到顶部。这种算法会产生出人意料的输出。在某些情况下，执行的方法可能不是在继承树中最接近的方法。
- en: 'Such an algorithm is still available in Python 2 when old-style classes (not
    inheriting from `object`) are used. Here is an example of the old method resolution
    in Python 2 using old-style classes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Python 2中使用旧式类（不继承自`object`）时，仍然可以使用这种算法。以下是Python 2中使用旧式类的旧方法解析的示例：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following transcript from interactive session shows that `Base2.method()`
    will not be called despite `Base2` is closer in the class hierarchy than `CommonBase`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 来自交互会话的以下转录显示，尽管`Base2`在类层次结构中比`CommonBase`更接近，但`Base2.method()`不会被调用：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Understanding Python''s Method Resolution Order](graphics/5295_03_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![理解Python的方法解析顺序](graphics/5295_03_02.jpg)'
- en: Figure 2 The Diamond class hierarchy
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2 钻石类层次结构
- en: Such an inheritance scenario is extremely uncommon, so this is more a problem
    of theory than practice. The standard library does not structure the inheritance
    hierarchies in this way, and many developers think it is a bad practice. But with
    the introduction of `object` at the top of the types hierarchy, the multiple inheritance
    problem pops up on the C side of the language, resulting in conflicts when doing
    subtyping. Note also that every class in Python 3 has now the same common ancestor.
    Since making it work properly with the existing MRO involved too much work, a
    new MRO was a simpler and quicker solution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种继承场景极为罕见，因此更多是理论问题而不是实践问题。标准库不以这种方式构造继承层次结构，许多开发人员认为这是一种不好的做法。但是，随着在类型层次结构顶部引入`object`，多重继承问题在语言的C端出现冲突。还要注意的是，Python
    3中的每个类现在都有相同的共同祖先。由于使其与现有的MRO正常工作涉及太多工作，新的MRO是一个更简单和更快的解决方案。
- en: 'So, the same example run under Python 3 gives a different result:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Python 3下运行相同的示例会产生不同的结果：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here is usage showing that C3 serialization will pick method of the closest
    ancestor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用示例，显示C3序列化将选择最接近祖先的方法：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the above behavior cannot be replicated in Python 2 without the `CommonBase`
    class explicitly inheriting from `object`. The reasons why it may be useful to
    specify `object` as a class ancestor in Python 3 even if this is redundant were
    mentioned in the previous section, *Old-style classes and super in Python 2*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述行为在Python 2中无法复制，除非`CommonBase`类明确继承自`object`。即使在Python 3中这是多余的，也有必要在Python
    3中指定`object`作为类祖先的原因在前一节*Python 2中的旧式类和super*中提到。
- en: 'The Python MRO is based on a recursive call over the base classes. To summarize
    the Michele Simionato paper referenced at the beginning of this section, the C3
    symbolic notation applied to our example is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python MRO基于对基类的递归调用。总结Michele Simionato在本节开头引用的论文，应用于我们示例的C3符号表示法是：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `L[MyClass]` is the linearization of the `MyClass` class, and `merge`
    is a specific algorithm that merges several linearization results.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`L[MyClass]`是`MyClass`类的线性化，`merge`是一个合并多个线性化结果的特定算法。
- en: 'So, a synthetic description would be, as Simionato says:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Simionato所说的合成描述是：
- en: '*"The linearization of C is the sum of C plus the merge of the linearizations
    of the parents and the list of the parents"*'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"C的线性化是C的总和加上父类的线性化的合并和父类的列表"*'
- en: 'The `merge` algorithm is responsible for removing the duplicates and preserving
    the correct ordering. It is described in the paper like this (adapted to our example):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`算法负责删除重复项并保留正确的顺序。它在论文中描述如下（适用于我们的示例）：'
- en: '*"Take the head of the first list, that is, L[Base1][0]; if this head is not
    in the tail of any of the other lists, then add it to the linearization of MyClass
    and remove it from the lists in the merge, otherwise look at the head of the next
    list and take it, if it is a good head.*'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"取第一个列表的头，即L[Base1][0]；如果这个头不在其他列表的尾部，则将其添加到MyClass的线性化中并从合并的列表中删除它，否则查看下一个列表的头并取出它，如果它是一个好的头。*'
- en: '>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Then, repeat the operation until all the classes are removed or it is impossible
    to find good heads. In this case, it is impossible to construct the merge, Python
    2.3 will refuse to create the class MyClass and will raise an exception."*'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*然后，重复操作，直到所有类都被移除或者无法找到好的头。在这种情况下，无法构造合并，Python 2.3将拒绝创建`MyClass`类并引发异常。*'
- en: The `head` is the first element of a list and the `tail` contains the rest of
    the elements. For example, in `(Base1, Base2, ..., BaseN), Base1` is the `head`,
    and `(Base2, ..., BaseN)` the `tail`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`是列表的第一个元素，`tail`包含其余的元素。例如，在`(Base1, Base2, ..., BaseN)`中，`Base1`是`head`，`(Base2,
    ..., BaseN)`是`tail`。'
- en: In other words, C3 does a recursive depth lookup on each parent to get a sequence
    of lists. Then it computes a left-to-right rule to merge all lists with a hierarchy
    disambiguation, when a class is involved in several lists.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，C3对每个父类进行递归深度查找以获得一系列列表。然后，它计算一个从左到右的规则，以合并所有包含类的列表，并进行层次结构消歧义。
- en: 'So the result is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此结果是：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `__mro__` attribute of a class (which is read-only) stores the result of
    the linearization computation, which is done when the class definition is loaded.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类的`__mro__`属性（只读）存储了线性化计算的结果，这是在类定义加载时完成的。
- en: You can also call `MyClass.mro()` to compute and get the result. This is another
    reason why classes in Python 2 should be taken with extra case. While old-style
    classes in Python 2 have a defined order in which methods are resolved, they do
    not provide the `__mro__` attribute and the `mro()` method. So, despite the order
    of resolution, it is wrong to say that they have MRO. In most cases, whenever
    someone refers to MRO in Python, it means that they refer to the C3 algorithm
    described in this section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以调用`MyClass.mro()`来计算并获取结果。这也是Python 2中的类应该额外小心的另一个原因。虽然Python 2中的旧式类有一定的方法解析顺序，但它们不提供`__mro__`属性和`mro()`方法。因此，尽管有解析顺序，但说它们有MRO是错误的。在大多数情况下，每当有人在Python中提到MRO时，他们指的是本节中描述的C3算法。
- en: super pitfalls
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: super陷阱
- en: Back to `super`. Its usage, when using the multiple inheritance hierarchy, can
    be quite dangerous, mainly because of the initialization of classes. In Python,
    the base classes are not implicitly called in `__init__()`, and so it is up to
    the developer to call them. We will see a few examples.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`super`。在使用多重继承层次结构时，它可能非常危险，主要是因为类的初始化。在Python中，基类不会在`__init__()`中被隐式调用，因此开发人员需要调用它们。我们将看到一些例子。
- en: Mixing super and explicit class calls
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合使用super和显式类调用
- en: 'In the following example taken from James Knight''s website ([http://fuhm.net/super-harmful](http://fuhm.net/super-harmful)),
    a `C` class that calls its base classes using the `__init__()` method will make
    the `B` class be called twice:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，来自James Knight网站（[http://fuhm.net/super-harmful](http://fuhm.net/super-harmful)）的一个示例，一个调用其基类使用`__init__()`方法的`C`类将使`B`类被调用两次：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is the output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This happens due to the `A.__init__(self)` call, which is made with the `C`
    instance, thus making the `super(A, self).__init__()` call the `B.__init__()`
    method. In other words, `super` should be used in the whole class hierarchy. The
    problem is that sometimes a part of this hierarchy is located in third-party code.
    Many related pitfalls on the hierarchy calls introduced by multiple inheritances
    can be found on James's page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由`A.__init__(self)`调用引起的，它是用`C`实例进行的，因此使得`super(A, self).__init__()`调用`B.__init__()`方法。换句话说，`super`应该在整个类层次结构中使用。问题在于有时这个层次结构的一部分位于第三方代码中。James的网页上可以找到由多重继承引入的层次结构调用的许多相关陷阱。
- en: Unfortunately, you cannot be sure that external packages use `super()` in their
    code. Whenever you need to subclass some third-party class, it is always a good
    approach to take a look inside of its code and code of other classes in the MRO.
    This may be tedious, but as a bonus you get some information about the quality
    of code provided by such a package and more understanding of its implementation.
    You may learn something new that way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你无法确定外部包在他们的代码中是否使用`super()`。每当你需要对第三方类进行子类化时，最好的方法是查看其代码以及MRO中其他类的代码。这可能会很繁琐，但作为奖励，你会得到有关该软件包提供的代码质量的一些信息，以及对其实现的更多理解。你可能会通过这种方式学到一些新东西。
- en: Heterogeneous arguments
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异构参数
- en: 'Another issue with `super` usage is the argument passing in initialization.
    How can a class call its base class `__init__()` code if it doesn''t have the
    same signature? This leads to the following problem:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`用法的另一个问题是初始化中的参数传递。如果一个类调用其基类的`__init__()`代码，但它的签名不同，会导致以下问题：'
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'An attempt to create a `MyClass` instance will raise `TypeError` due to the
    mismatch of the parent classes'' `__init__()` signatures:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建`MyClass`实例将由于父类的`__init__()`签名不匹配而引发`TypeError`：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'One solution would be to use arguments and keyword arguments packed with `*args`
    and `**kwargs` magic so that all constructors pass along all the parameters even
    if they do not use them:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是使用`*args`和`**kwargs`魔术打包的参数和关键字参数，以便所有构造函数传递所有参数，即使它们不使用它们：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this approach the parent class signatures will always match:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，父类的签名将始终匹配：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is an awful fix though, because it makes all constructors accept any kind
    of parameter. It leads to weak code, since anything can be passed and gone through.
    Another solution is to use the explicit `__init__()` calls of specific classes
    in `MyClass`, but this would lead to the first pitfall.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个糟糕的修复方法，因为它使所有构造函数都接受任何类型的参数。这会导致代码质量低下，因为任何东西都可以被传递和执行。另一个解决方案是在`MyClass`中使用特定类的显式`__init__()`调用，但这将导致第一个陷阱。
- en: Best practices
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'To avoid all the mentioned problems, and until Python evolves in this field,
    we need to take into consideration the following points:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免所有提到的问题，并且在Python在这个领域发展之前，我们需要考虑以下几点：
- en: '**Multiple inheritance should be avoided**: It can be replaced with some design
    patterns presented in [Chapter 14](ch14.html "Chapter 14. Useful Design Patterns"),
    *Useful Design Patterns*.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应避免多重继承：它可以用[第14章](ch14.html "第14章。有用的设计模式")中介绍的一些设计模式来替代，*有用的设计模式*。
- en: '**super usage has to be consistent**: In a class hierarchy, `super` should
    be used everywhere or nowhere. Mixing `super` and classic calls is a confusing
    practice. People tend to avoid `super`, for their code to be more explicit.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超级用法必须保持一致：在类层次结构中，`super`应该在所有地方或者都不使用。混合使用`super`和经典调用是一种令人困惑的做法。人们倾向于避免使用`super`，以使他们的代码更加明确。
- en: '**Explicitly inherit from object in Python 3 if you target Python 2 too**:
    Classes without any ancestor specified are recognized as old-style classes in
    Python 2\. Mixing old-style classes with new-style classes should be avoided in
    Python 2.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的目标是Python 2，那么在Python 3中明确从object继承：在Python 2中，没有指定任何祖先的类被识别为旧式类。在Python
    2中应避免混合旧式类和新式类。
- en: '**Class hierarchy has to** **be looked over when a parent class is called**:
    To avoid any problems, every time a parent class is called, a quick glance at
    the involved MRO (with `__mro__`) has to be done.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在调用父类时必须查看类层次结构**：为了避免任何问题，每次调用父类时，都必须快速查看涉及的MRO（使用`__mro__`）。'
- en: Advanced attribute access patterns
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级属性访问模式
- en: 'When many C++ and Java programmers first learn Python, they are surprised by
    Python''s lack of a `private` keyword. The nearest concept is *name mangling*.
    Every time an attribute is prefixed by `__`, it is renamed by the interpreter
    on the fly:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多C++和Java程序员首次学习Python时，他们会对Python缺少`private`关键字感到惊讶。最接近的概念是*名称混淆*。每当属性以`__`为前缀时，解释器会即时重命名属性：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Accessing the `__secret_value` attribute by its initial name will raise an
    `AttributeError` exception:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其初始名称访问`__secret_value`属性将引发`AttributeError`异常：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This feature is provided to avoid name collision under inheritance, as the attribute
    is renamed with the class name as a prefix. It is not a real lock, since the attribute
    can be accessed through its composed name. This feature could be used to protect
    the access of some attributes, but in practice, `__` should never be used. When
    an attribute is not public, the convention to use is a `_` prefix. This does not
    call any mangling algorithm, but just documents the attribute as a private element
    of the class and is the prevailing style.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 提供此功能是为了避免继承下的名称冲突，因为属性会以类名作为前缀进行重命名。这不是真正的锁，因为可以通过其组合名称访问属性。此功能可用于保护对某些属性的访问，但在实践中，不应该使用`__`。当属性不是公共的时，使用的约定是使用`_`前缀。这不会调用任何混淆算法，而只是将属性记录为类的私有元素，并且是主要的样式。
- en: Other mechanisms are available in Python to build the public part of the class
    together with the private code. The descriptors and properties that are the key
    features to OOP design should be used to design a clean API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python中还有其他机制可用于构建类的公共部分以及私有代码。应该使用描述符和属性来设计一个干净的API，这是面向对象设计的关键特性。
- en: Descriptors
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符
- en: A descriptor lets you customize what should be done when you refer to an attribute
    on an object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符允许您自定义在对象上引用属性时应执行的操作。
- en: Descriptors are the base of a complex attribute access in Python. They are used
    internally to implement properties, methods, class methods, static methods, and
    the `super` type. They are classes that define how attributes of another class
    can be accessed. In other words, a class can delegate the management of an attribute
    to another one.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是Python中复杂属性访问的基础。它们在内部用于实现属性、方法、类方法、静态方法和`super`类型。它们是定义另一个类的属性如何被访问的类。换句话说，一个类可以将属性的管理委托给另一个类。
- en: 'The descriptor classes are based on three special methods that form the **descriptor
    protocol**:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符类基于三个形成**描述符协议**的特殊方法：
- en: '`__set__(self, obj, type=None)`: This is called whenever the attribute is set.
    In the following examples, we will refer to this as a **setter**.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__set__(self, obj, type=None)`: 每当设置属性时调用此方法。在以下示例中，我们将其称为**setter**。'
- en: '`__get__(self, obj, value)`: This is called whenever the attribute is read
    (referred to as a **getter**).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__get__(self, obj, value)`: 每当读取属性时调用此方法（称为**getter**）。'
- en: '`__delete__(self, obj)`: This is called when `del` is invoked on the attribute.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delete__(self, obj)`: 当对属性调用`del`时调用此方法。'
- en: A descriptor that implements `__get__()` and `__set__()` is called a **data
    descriptor**. If it just implements `__get__()`, then it is called a **non-data
    descriptor**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`__get__()`和`__set__()`的描述符称为**数据描述符**。如果只实现`__get__()`，则称为**非数据描述符**。
- en: 'Methods of this protocol are in fact called by the object''s special `__getattribute__()`
    method (do not confuse it with `__getattr__()`, which has a different purpose)
    on every attribute lookup. Whenever such a lookup is performed, either by using
    dotted notation in the form of `instance.attribute` or by using the `getattr(instance,
    ''attribute'')` function call, the `__getattribute__()` method is implicitly invoked
    and it looks for an attribute in the following order:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，该协议的方法是由对象的特殊`__getattribute__()`方法调用的（不要与具有不同目的的`__getattr__()`混淆），在每次属性查找时都会隐式调用`__getattribute__()`方法，并且它按以下顺序查找属性：
- en: It verifies if the attribute is a data descriptor on the class object of the
    instance.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它验证属性是否是实例的类对象上的数据描述符。
- en: If not, it looks to see if the attribute can be found in the `__dict__` of the
    instance object.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，它会查看属性是否可以在实例对象的`__dict__`中找到。
- en: Finally, it looks to see if the attribute is a non-data descriptor on the class
    object of the instance.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它查看属性是否是实例的类对象上的非数据描述符。
- en: In other words, data descriptors take precedence over `__dict__` lookup and
    `__dict__` lookup takes precedence over non-data descriptors.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，数据描述符优先于`__dict__`查找，而`__dict__`查找优先于非数据描述符。
- en: 'To make it more clear, here is an example from the official Python documentation
    that shows how descriptors work on real code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚，这里有一个来自官方Python文档的示例，展示了描述符在实际代码中的工作原理：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And here is an example of using it in the interactive session:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在交互会话中使用它的示例：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding example clearly shows that if a class has the data descriptor
    for the given attribute, then the descriptor''s `__get__()` method is called to
    return the value every time the instance attribute is retrieved, and `__set__()`
    is called whenever a value is assigned to such an attribute. Although the case
    for the descriptor''s `__del__` method is not shown in the preceding example,
    it should be obvious now: it is called whenever an instance attribute is deleted
    with the `del instance.attribute` statement or the `delattr(instance, ''attribute'')`
    call.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子清楚地表明，如果一个类具有给定属性的数据描述符，那么每次检索实例属性时都会调用描述符的`__get__()`方法来返回值，并且每当将值分配给这样的属性时都会调用`__set__()`。虽然在前面的例子中没有显示描述符的`__del__`方法的情况，但现在应该很明显：每当使用`del
    instance.attribute`语句或`delattr(instance, 'attribute')`调用删除实例属性时都会调用它。
- en: 'The difference between data and non-data descriptors is important due to the
    fact stated at the beginning. Python already uses the descriptor protocol to bind
    class functions to instances as a methods. They also power the mechanism behind
    the `classmethod` and `staticmethod` decorators. This is because, in fact, the
    function objects are non-data descriptors too:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和非数据描述符之间的区别是重要的，因为在开始时已经说明的事实。Python已经使用描述符协议将类函数绑定到实例作为方法。它们还支持`classmethod`和`staticmethod`装饰器背后的机制。这是因为实际上，函数对象也是非数据描述符：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And this is also true for functions created with lambda expressions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用lambda表达式创建的函数也是如此：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, without `__dict__` taking precedence over non-data descriptors, we would
    not be able to dynamically override specific methods on already constructed instances
    at runtime. Fortunately, thanks to how descriptors work in Python. It is available,
    so developers may use a popular technique called monkey-patching to change the
    way how instances work without the need of subclassing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`__dict__`不优先于非数据描述符，我们将无法在运行时动态覆盖已构造实例上的特定方法。幸运的是，由于Python中描述符的工作方式。它是可用的，因此开发人员可以使用一种称为猴子补丁的流行技术来改变实例的工作方式，而无需子类化。
- en: Real-life example – lazily evaluated attributes
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现实生活中的例子-延迟评估属性
- en: 'One example usage of descriptors may be to delay initialization of the class
    attribute to the moment when it is accessed from the instance. This may be useful
    if initialization of such attributes depends on the global application context.
    The other case is when such initialization is simply expensive but it is not known
    whether it will be used anyway when the class is imported. Such a descriptor could
    be implemented as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符的一个例子用法可能是将类属性的初始化延迟到从实例中访问它的时刻。如果此类属性的初始化取决于全局应用上下文，则这可能是有用的。另一种情况是当这样的初始化只是昂贵的，但不知道在导入类时是否会使用它。这样的描述符可以实现如下：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And here is example usage:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子用法：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The official OpenGL Python library available on PyPI under the `PyOpenGL` name
    uses a similar technique to implement `lazy_property` that is both a decorator
    and a data descriptor:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI上提供的官方OpenGL Python库以`PyOpenGL`名称可用，使用类似的技术来实现`lazy_property`，它既是装饰器又是数据描述符：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Such an implementation is similar to using the `property` decorator (described
    later), but the function that is wrapped with it is executed only once and then
    the class attribute is replaced with a value returned by such a property. Such
    a technique is often useful when the developer needs to fulfill the following
    two requirements at the same time:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的实现类似于使用`property`装饰器（稍后描述），但用它包装的函数只执行一次，然后类属性被此类属性返回的值替换。当开发人员需要同时满足以下两个要求时，这种技术通常很有用：
- en: An object instance needs to be stored as a class attribute shared between its
    instances to save resources
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象实例需要存储为一个类属性，在其实例之间共享，以节省资源
- en: This object cannot be initialized on import time because its creation process
    depends on some global application state/context
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个对象不能在导入时初始化，因为它的创建过程取决于一些全局应用状态/上下文
- en: In the case of applications written using OpenGL, this is very often true. For
    example, the creation of shaders in OpenGL is expensive because it requires compilation
    of code written in **GLSL** (**OpenGL Shading Language**). It is reasonable to
    create them only once and include their definition in close proximity to classes
    that require them. On the other hand, shader compilation cannot be performed without
    having initialized the OpenGL context, so it is hard to define and compile them
    reliably in global module namespace at import time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用OpenGL编写的应用程序中，这通常是很真实的。例如，在OpenGL中创建着色器是昂贵的，因为它需要编译用**GLSL**（**OpenGL着色语言**）编写的代码。只有在需要时才合理地创建它们，并将它们的定义包含在需要它们的类的紧密接近中。另一方面，没有初始化OpenGL上下文就无法执行着色器编译，因此很难在导入时在全局模块命名空间中可靠地定义和编译它们。
- en: 'The following example shows the possible usage of the modified version of PyOpenGL''s
    `lazy_property` decorator (here `lazy_class_attribute`) in some imaginary OpenGL-based
    application. The highlighted change to the original `lazy_property` decorator
    was required in order to allow sharing the attribute between different class instances:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了在某个想象的基于OpenGL的应用程序中使用修改后的PyOpenGL的`lazy_property`装饰器（这里是`lazy_class_attribute`）的可能用法。对原始`lazy_property`装饰器的突出更改是为了允许在不同类实例之间共享属性：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Like every advanced Python syntax feature, this one should also be used with
    caution and documented well in code. For unexperienced developers, the altered
    class behavior might be very confusing and unexpected because descriptors affect
    the very basic part of class behavior such as attribute access. Because of that,
    it is very important to make sure that all team members are familiar with descriptors
    and understand this concept well if it plays an important role in the project's
    codebase.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 像Python的每个高级语法特性一样，这个特性也应该谨慎使用，并在代码中进行良好的文档记录。对于经验不足的开发人员来说，修改后的类行为可能会非常令人困惑和意外，因为描述符会影响类行为的基本部分，比如属性访问。因此，非常重要的是确保所有团队成员都熟悉描述符，并且如果它在项目的代码库中起重要作用，他们对这个概念有很好的理解。
- en: Properties
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'The properties provide a built-in descriptor type that knows how to link an
    attribute to a set of methods. A `property` takes four optional arguments: `fget`,
    `fset`, `fdel`, and `doc`. The last one can be provided to define a `docstring`
    that is linked to the attribute as if it were a method. Here is an example of
    a `Rectangle` class that can be controlled either by direct access to attributes
    that store two corner points or by using the `width`, and `height` properties:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 属性提供了一种内置的描述符类型，知道如何将属性链接到一组方法。`property`接受四个可选参数：`fget`，`fset`，`fdel`和`doc`。最后一个可以提供用于定义与属性关联的`docstring`，就像它是一个方法一样。下面是一个`Rectangle`类的示例，可以通过直接访问存储两个角点的属性或使用`width`和`height`属性来控制：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The example usage of such defined properties in an interactive session is as
    follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式会话中使用这些定义的属性的示例用法如下：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The properties make it easier to write descriptors, but must be handled carefully
    when using inheritance over classes. The created attribute is made on the fly
    using the methods of the current class and will not use methods that are overridden
    in the derived classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 属性使得编写描述符更加容易，但在使用继承时必须小心处理。创建的属性是使用当前类的方法动态生成的，并不会使用在派生类中被覆盖的方法。
- en: 'For instance, the following example will fail to override the implementation
    of the `fget` method of the parent''s class (`Rectangle`) `width` property:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下示例将无法覆盖父类（`Rectangle`）`width`属性的`fget`方法的实现：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In order to solve this, the whole property simply needs to be overwritten in
    the derived class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，只需要在派生类中简单地覆盖整个属性：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Unfortunately, the preceding code has some maintainability issues. It can be
    a source of issue if the developer decides to change the parent class, but forgets
    about updating the property call. This is why overriding only parts of the property
    behavior is not advised. Instead of relying on the parent class's implementation,
    it is recommended to rewrite all the property methods in the derived classes,
    if there is need to change how they work. In most cases, this is the only option
    anyway, because usually the change to property `setter` behavior implies a change
    to the behavior of the `getter` as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，前面的代码存在一些可维护性问题。如果开发人员决定更改父类，但忘记更新属性调用，这可能会成为一个问题。这就是为什么不建议仅覆盖属性行为的部分。与其依赖于父类的实现，不如在派生类中重写所有属性方法，如果需要更改它们的工作方式。在大多数情况下，这通常是唯一的选择，因为通常更改属性的`setter`行为意味着需要更改`getter`的行为。
- en: 'Due to the preceding reason, the best syntax for creating properties is using
    `property` as a decorator. This will reduce the number of method signatures inside
    of the class and make code more readable and maintainable:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的原因，创建属性的最佳语法是使用`property`作为装饰器。这将减少类内部方法签名的数量，并使代码更易读和易维护：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Slots
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Slots
- en: An interesting feature that is almost never used by developers is slots. They
    allow you to set a static attribute list for a given class with the `__slots__`
    attribute, and skip the creation of the `__dict__` dictionary in each instance
    of the class. They were intended to save memory space for classes with very few
    attributes, since `__dict__` is not created at every instance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员几乎从不使用的一个有趣特性是slots。它们允许您为给定类设置一个静态属性列表，使用`__slots__`属性，并跳过在每个类实例中创建`__dict__`字典。它们旨在为具有非常少属性的类节省内存空间，因为`__dict__`不会在每个实例中创建。
- en: 'Besides this, they can help to design classes whose signature needs to be frozen.
    For instance, if you need to restrict the dynamic features of the language over
    a class, defining slots can help:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，它们可以帮助设计需要被冻结的类的签名。例如，如果您需要限制语言的动态特性在一个类上，定义slots可以帮助：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This feature should be used carefully. When a set of available attributes is
    limited using `__slots__`, it is much harder to add something to the object dynamically.
    Some techniques, such as monkey-patching, will not work with instances of classes
    that have slots defined. Fortunately, the new attributes can be added to the derived
    class if it does not have its own slots defined:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性应该谨慎使用。当使用`__slots__`限制一组可用属性时，动态地向对象添加内容就会变得更加困难。一些技术，比如猴子补丁，将无法用于具有定义slots的类的实例。幸运的是，如果派生类没有定义自己的slots，新属性可以添加到派生类中：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Metaprogramming
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程
- en: 'There may be a good definition of metaprogramming from some academy paper that
    could be cited here, but this is rather a book about good software craftsmanship
    than about computer science theory. This is why we will use a simple one:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一些学术论文中对元编程有很好的定义，可以在这里引用，但这更像是一本关于良好软件工艺的书，而不是关于计算机科学理论的书。这就是为什么我们将使用一个简单的定义：
- en: '*"Metaprogramming is a technique of writing computer programs that can treat
    themselves as data, so you can introspect, generate, and/or modify itself while
    running."*'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “元编程是一种编写计算机程序的技术，可以在运行时将自身视为数据，因此可以自省、生成和/或修改自身。”
- en: Using this definition, we can distinguish two major approaches to metaprogramming
    in Python.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个定义，我们可以区分Python中的两种主要元编程方法。
- en: The first approach concentrates on the language's ability to introspect its
    basic elements such as functions, classes, or types and to create or modify them
    on the fly. Python gives a lot of tools to developers in this area. The easiest
    ones are decorators that allow to add additional functionality to the existing
    functions, methods, or classes. Next are special methods of classes that allow
    you to interfere with class instance process creation. The most powerful are metaclasses
    that allow programmers to even completely redesign the Python's implementation
    of the object-oriented programming paradigm. Here also, we have a good selection
    of different tools that allow programmers to work directly with code either in
    its raw plain text format or in the more programmatically accessible **Abstract
    Syntax Tree** (**AST**) form. This second approach is of course more complicated
    and difficult to work with but allows for really extraordinary things, such as
    extending Python's language syntax or even creating your own **Domain Specific
    Language** (**DSL**).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法集中在语言的能力上，可以自省其基本元素，如函数、类或类型，并在运行时创建或修改它们。Python为开发人员在这个领域提供了很多工具。最简单的是装饰器，允许向现有的函数、方法或类添加额外的功能。接下来是类的特殊方法，允许您干预类实例的创建过程。最强大的是元类，允许程序员甚至完全重新设计面向对象编程范式的Python实现。在这里，我们还有一系列不同的工具，允许程序员直接使用代码，无论是以原始纯文本格式还是以更具编程访问性的抽象语法树（AST）形式。这第二种方法当然更复杂，更难处理，但允许实现非常特别的事情，比如扩展Python的语言语法，甚至创建自己的领域特定语言（DSL）。
- en: Decorators – a method of metaprogramming
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器-元编程的一种方法
- en: 'The decorator syntax is explained in [Chapter 2](ch02.html "Chapter 2. Syntax
    Best Practices – below the Class Level"), *Syntax Best Practices – below the Class
    Level*, as a simple pattern:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器语法在[第2章](ch02.html "第2章。语法最佳实践-类级别以下")中有解释，*语法最佳实践-类级别以下*，作为一个简单的模式：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This clearly shows what the decorator does. It takes a function object and modifies
    it at run time. As a result, a new function (or anything else) is created based
    on the previous function object with the same name. This may be even a complex
    operation that performs some introspection to give different results depending
    on how the original function is implemented. All this means is that decorators
    can be considered as a metaprogramming tool.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地展示了装饰器的作用。它接受一个函数对象，并在运行时对其进行修改。结果，基于先前的函数对象创建了一个新函数（或其他任何东西），名称相同。这甚至可能是一个复杂的操作，根据原始函数的实现方式给出不同的结果。这意味着装饰器可以被视为元编程工具。
- en: This are good news. Decorators are relatively easy to catch and in most cases
    make code shorter, easier to read, and also cheaper to maintain. Other metaprogramming
    tools available in Python are more difficult to grasp and master. Also, they might
    not make the code simple at all.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好消息。装饰器相对容易掌握，在大多数情况下可以使代码更简洁、更易读，也更便于维护。Python中的其他元编程工具更难以理解和掌握。而且，它们可能根本不会使代码简单。
- en: Class decorators
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类装饰器
- en: 'One of the less known syntax features of Python is the class decorator. The
    syntax and the way that they work is exactly the same as with function decorators
    mentioned in [Chapter 2](ch02.html "Chapter 2. Syntax Best Practices – below the
    Class Level"), *Syntax Best Practices – below the Class Level*. The only difference
    is that they are expected to return a class instead of the function object. Here
    is an example class decorator that modifies the `__repr__()` method to return
    the printable object representation that is shortened to some arbitrary number
    of characters:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Python的一个不太为人知的语法特性是类装饰器。它们的语法和工作方式与[第2章](ch02.html "第2章。语法最佳实践-类级别以下")中提到的函数装饰器完全相同，*语法最佳实践-类级别以下*。唯一的区别是它们期望返回一个类，而不是函数对象。以下是一个修改`__repr__()`方法以返回可打印对象表示的示例类装饰器，该表示被缩短为任意数量字符：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following is what you will see in the output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您将在输出中看到的内容：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Of course, the preceding code snippet is not an example of a good code by any
    means because it is too cryptic. Still, it shows how multiple language features
    explained in this chapter can be used together:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的代码片段绝对不是一个好的代码示例，因为它太神秘了。但它展示了本章中解释的多种语言特性如何可以一起使用：
- en: Not only instances but also class objects can be modified at runtime
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不仅实例，类对象也可以在运行时修改
- en: Functions are descriptors too, so they can be added to the class at runtime
    because the actual binding instance is performed on the attribute lookup as part
    of the descriptor protocol
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数也是描述符，因此它们可以在运行时添加到类中，因为实际的绑定实例是作为描述符协议的一部分进行属性查找的
- en: The `super()` call can be used outside of a class definition scope as long as
    proper arguments are provided
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super()`调用可以在类定义范围之外使用，只要提供适当的参数'
- en: Finally, class decorators can be used on class definitions
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，类装饰器可以用于类定义
- en: 'The other aspects of the writing function decorators apply to the class decorators
    as well. Most importantly, they can use closures and be parametrized. Taking advantage
    of these facts, the previous example can be rewritten into a more readable and
    maintainable form:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数装饰器的其他方面也适用于类装饰器。最重要的是，它们可以使用闭包并且可以被参数化。利用这些事实，前面的示例可以重写为更可读和可维护的形式：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The major drawback of using closures this way in class decorators is that the
    resulting objects are no longer instances of the class that was decorated but
    instances of the subclass created dynamically in the decorator function. Among
    others, this will affect the class''s `__name__` and `__doc__` attributes:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在类装饰器中使用闭包的主要缺点是，结果对象不再是被装饰的类的实例，而是在装饰器函数中动态创建的子类的实例。除其他外，这将影响类的`__name__`和`__doc__`属性：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Such usage of class decorators will result in following changes to the class
    metadata:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器的这种用法将导致对类元数据的以下更改：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Unfortunately, this cannot be fixed as simply as explained in the *Introspection
    Preserving Decorators* section of [Chapter 2](ch02.html "Chapter 2. Syntax Best
    Practices – below the Class Level"), *Syntax Best Practices – below the Class
    Level*, using the additional `wraps` decorator. This makes use of the class decorators
    in this form limited in some circumstances. If no additional work is performed
    to preserve the old class's metadata, then this can break results of many automated
    documentation generation tools.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不能像在[第2章](ch02.html "第2章。语法最佳实践 - 类级别以下")的*保留内省装饰器*部分中所解释的那样简单修复，*语法最佳实践
    - 类级别以下*，使用额外的`wraps`装饰器。这使得在某些情况下，以这种形式使用类装饰器受到限制。如果没有额外的工作来保留旧类的元数据，那么这可能会破坏许多自动化文档生成工具的结果。
- en: Still, despite this single caveat, class decorators are a simple and lightweight
    alternative to the popular mixin class pattern.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这个单一的警告，类装饰器仍然是流行的mixin类模式的一个简单而轻量的替代品。
- en: 'A mixin in Python is a class that is not meant to be instantiated, but is instead
    used to provide some reusable API or functionality to other existing classes.
    Mixin classes are almost always added using multiple inheritance in the form of:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，mixin是一个不打算被实例化的类，而是用来为其他现有类提供一些可重用的API或功能。Mixin类几乎总是以多重继承的形式添加的：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Mixins are useful design patterns that are used in many libraries. To name one,
    Django is one of the frameworks that uses them extensively. While useful and popular,
    the mixins can cause some trouble if not designed well, because, in most cases,
    they require the developer to rely on multiple inheritance. As was said earlier,
    Python handles multiple inheritance relatively well, thanks to the MRO. Anyway,
    it may be better to avoid subclassing multiple classes if it only does not require
    too much additional work and makes code simpler. This is why class decorators
    may be a good replacement of mixins.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Mixin是一种有用的设计模式，在许多库中被使用。举个例子，Django是其中一个广泛使用它们的框架。虽然有用且受欢迎，但如果设计不好，mixin可能会引起一些麻烦，因为在大多数情况下，它们需要开发人员依赖多重继承。正如之前所说，Python相对较好地处理多重继承，这要归功于MRO。无论如何，如果不需要太多额外的工作并且使代码更简单，最好避免对多个类进行子类化。这就是为什么类装饰器可能是mixin的一个很好的替代品。
- en: Using the __new__() method to override instance creation process
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`__new__()`方法来重写实例创建过程
- en: 'The special method `__new__()` is a static method responsible for creating
    class instances. It is special-cased, so there is no need to declare it as a static
    using the `staticmethod` decorator. This `__new__(cls, [,...])` method is called
    prior to the `__init__()` initialization method. Typically, the implementation
    of overridden `__new__()` invokes its superclass version using `super().__new__()`
    with suitable arguments and modifies the instance before returning it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法`__new__()`是一个负责创建类实例的静态方法。它是特殊情况，因此不需要使用`staticmethod`装饰器将其声明为静态方法。这个`__new__(cls,
    [,...])`方法在`__init__()`初始化方法之前被调用。通常，重写的`__new__()`的实现会使用`super().__new__()`调用其超类版本，并使用合适的参数修改实例后返回它：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is the log of example interactive session that shows how our `InstanceCountingClass`
    implementation works:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例交互会话的日志，展示了我们的`InstanceCountingClass`实现是如何工作的：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `__new__()` method should usually return an instance of featured class
    but it is also possible that it returns other class instances. If it does happen
    (different class instance is returned) then the call to the `__init__()` method
    is skipped. This fact is useful when there is a need to modify creation behavior
    of non-mutable class instances such as some of Python''s built-in types:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()`方法通常应该返回一个特色类的实例，但也可能返回其他类的实例。如果发生这种情况（返回不同的类实例），则对`__init__()`方法的调用将被跳过。当需要修改非可变类实例的创建行为时，这一事实是有用的，比如Python的一些内置类型：'
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s see this in the interactive session:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在交互式会话中看看这个：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'So, when to use `__new__()`? The answer is simple: only when `__init__()` is
    not enough. One such case was already mentioned. This is subclassing of non-mutable
    built-in Python types such as `int`, `str`, `float`, `frozenset`, and so on. It''s
    because there is no way to modify such a nonmutable object instance in the `__init__()`
    method once it is created.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候使用`__new__()`呢？答案很简单：只有当`__init__()`不够用时。已经提到了这样的情况。这是对非可变的内置Python类型（如`int`、`str`、`float`、`frozenset`等）进行子类化。这是因为一旦创建了这样一个不可变对象实例，就没有办法在`__init__()`方法中修改它。
- en: Some programmers can argue that `__new__()` may be useful for performing important
    object initialization that may be missed if the user forgets to use `super()`.The
    _`_init__()` call is the overridden initialization method. While it sounds reasonable,
    this has a major drawback. If such an approach is used, then it becomes harder
    for the programmer to explicitly skip previous initialization steps if this is
    the already desired behavior. It also breaks an unspoken rule of all initializations
    performed in `__init__()`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员可能会认为`__new__()`对于执行重要的对象初始化可能是有用的，如果用户忘记使用`super()`，则可能会错过。`__init__()`调用是被重写的初始化方法。虽然听起来是合理的，但这有一个主要的缺点。如果使用这种方法，那么程序员更难以显式地跳过先前的初始化步骤，如果这已经是期望的行为。它也打破了`__init__()`中执行的所有初始化的一个不成文的规则。
- en: Because `__new__()` is not constrained to return the same class instance, it
    can be easily abused. Irresponsible usage of this method might do a lot of harm
    to the code, so it should always be used carefully and backed with extensive documentation.
    Generally, it is better to search for other solutions that may be available for
    the given problem, instead of affecting object creation in a way that will break
    basic programmers' expectations. Even overridden initialization of non-mutable
    types mentioned earlier can be replaced with more predictable and well-established
    design patterns, such as the Factory Method, which is described in [Chapter 14](ch14.html
    "Chapter 14. Useful Design Patterns"), *Useful Design Patterns*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`__new__()`不受限于返回相同的类实例，所以它很容易被滥用。对这种方法的不负责任使用可能对代码造成很大的伤害，因此应该始终小心使用，并配以广泛的文档支持。通常，最好是寻找可能可用于给定问题的其他解决方案，而不是以一种会破坏基本程序员期望的方式影响对象创建。甚至前面提到的不可变类型的重写初始化也可以用更可预测和成熟的设计模式来替代，比如工厂方法，它在[第14章](ch14.html
    "第14章。有用的设计模式")中有描述，*有用的设计模式*。
- en: There is at least one aspect of Python programming where extensive usage of
    the `__new__()` method is well justified. These are metaclasses that are described
    in the next section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python编程中至少有一个方面，广泛使用`__new__()`方法是完全合理的。这些是在下一节中描述的元类。
- en: Metaclasses
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元类
- en: Metaclass is a Python feature that is considered by many as one of the most
    difficult thing in this language and thus avoided by a great number of developers.
    In reality, it is not as complicated as it sounds once you understand few basic
    concepts. As a reward, knowing this feature grants the ability to do some things
    that were not possible using other approaches.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 元类是Python的一个特性，被许多人认为是这种语言中最困难的东西，因此被许多开发人员所避免。实际上，一旦你理解了一些基本概念，它并不像听起来那么复杂。作为回报，了解这个特性可以做一些使用其他方法不可能做到的事情。
- en: 'Metaclass is a type (class) that defines other types (classes). The most important
    thing to know in order to understand how they work is that classes that define
    object instances are objects too. So, if they are objects, then they have an associated
    class. The basic type of every class definition is simply the built-in `type`
    class. Here is a simple diagram that should make it clear:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 元类是定义其他类型（类）的类型（类）。要理解它们的工作原理，最重要的是要知道定义对象实例的类也是对象。因此，如果它们是对象，那么它们就有一个关联的类。每个类定义的基本类型只是内置的`type`类。下面是一个简单的图表，应该能够清楚地说明这一点：
- en: '![Metaclasses](graphics/5295_03_03.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![元类](graphics/5295_03_03.jpg)'
- en: Figure 3 How classes are typed
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图3 类型化类的方式
- en: In Python, it is possible to substitute the metaclass for a class object with
    our own type. Usually, the new metaclass is still the subclass of the `type` class
    (refer to *Figure 4*) because not doing so would make the resulting classes highly
    incompatible with other classes in terms of inheritance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以用我们自己的类型替换类对象的元类。通常，新的元类仍然是`type`类的子类（参见*图4*），因为不这样做会使得结果类在继承方面与其他类高度不兼容。
- en: '![Metaclasses](graphics/5295_03_04.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![元类](graphics/5295_03_04.jpg)'
- en: Figure 4 Usual implementation of custom metaclasses
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图4 自定义元类的通用实现
- en: The general syntax
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一般语法
- en: 'The call to the built-in `type()` class can be used as a dynamic equivalent
    of the class statement. It creates a new class object given its name, its base
    classes, and a mapping containing its attributes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对内置的`type()`类的调用可以用作类语句的动态等价物。它根据其名称、基类和包含其属性的映射创建一个新的类对象：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following is the output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is equivalent to the explicit definition of the class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于对类的显式定义：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here is what you will get:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将得到的：
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Every class created with the class statement implicitly uses `type` as its
    metaclass. This default behavior can be changed by providing the `metaclass` keyword
    argument to the class statement:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类语句隐式创建的每个类都将`type`作为其元类。通过在类语句中提供`metaclass`关键字参数，可以更改此默认行为：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The value provided as a `metaclass` argument is usually another class object,
    but it can be any other callable that accepts the same arguments as the `type`
    class and is expected to return another class object. The call signature is `type(name,
    bases, namespace)`, which is explained as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`metaclass`参数提供的值通常是另一个类对象，但它可以是任何其他可调用对象，接受与`type`类相同的参数，并且预期返回另一个类对象。调用签名是`type(name,
    bases, namespace)`，如下所述：
- en: '`name`: This is the name of class that will be stored in the `__name__` attribute'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是将存储在`__name__`属性中的类的名称'
- en: '`bases`: This is the list of parent classes that will become the `__bases__`
    attribute and will be used to construct the MRO of a newly created class'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bases`：这是将成为`__bases__`属性并用于构造新创建类的MRO的父类列表'
- en: '`namespace`: This is a namespace (mapping) with definitions for the class body
    that will become the `__dict__` attribute'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespace`：这是一个包含类体定义的命名空间（映射），将成为`__dict__`属性'
- en: One way of thinking about metaclasses is the `__new__()` method, but at a higher
    level of class definition.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 思考元类的一种方式是`__new__()`方法，但在类定义的更高级别上。
- en: 'Despite the fact that functions that explicitly call `type()` can be used in
    place of metaclasses, the usual approach is to use a different class that inherits
    from `type` for this purpose. The common template for a metaclass is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用显式调用`type()`的函数来替代元类，但通常的方法是使用一个从`type`继承的不同类来实现这个目的。元类的通用模板如下：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `name`, `bases`, and `namespace` arguments have the same meaning as in
    the `type()` call explained earlier, but each of these four methods can have different
    purposes:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`、`bases`和`namespace`参数的含义与前面解释的`type()`调用相同，但这四种方法中的每一种都可以有不同的目的：'
- en: '`__new__(mcs, name, bases, namespace)`: This is responsible for the actual
    creation of the class object in the same way as it does for ordinary classes.
    The first positional argument is a metaclass object. In the preceding example,
    it would simply be a `Metaclass`. Note that `mcs` is the popular naming convention
    for this argument.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__new__(mcs, name, bases, namespace)`: 这负责实际创建类对象，方式与普通类相同。第一个位置参数是一个元类对象。在前面的示例中，它将简单地是一个`Metaclass`。注意，`mcs`是这个参数的常用命名约定。'
- en: '`__prepare__(mcs, name, bases, **kwargs)`: This creates an empty namespace
    object. By default, it returns an empty `dict`, but it can be overridden to return
    any other mapping type. Note that it does not accept `namespace` as an argument
    because before calling it the namespace does not exist.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__prepare__(mcs, name, bases, **kwargs)`: 这创建一个空的命名空间对象。默认情况下，它返回一个空的`dict`，但可以被覆盖以返回任何其他映射类型。注意，它不接受`namespace`作为参数，因为在调用它之前命名空间不存在。'
- en: '`__init__(cls, name, bases, namespace, **kwargs)`: This is not seen popularly
    in metaclass implementations but has the same meaning as in ordinary classes.
    It can perform additional class object initialization once it was created with
    `__new__()`. The first positional argument is now named `cls` by convention to
    mark that this is already a created class object (metaclass instance) and not
    a metaclass object. When `__init__()` gets called, the class was already constructed
    and so this method can do less things than the `__new__()` method. Implementing
    such a method is very similar to using class decorators, but the main difference
    is that `__init__()` will be called for every subclass, while class decorators
    are not called for subclasses.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__(cls, name, bases, namespace, **kwargs)`: 这在元类实现中并不常见，但与普通类中的意义相同。它可以在使用`__new__()`创建类对象后执行额外的类对象初始化。第一个位置参数现在按照惯例命名为`cls`，以标记这已经是一个已创建的类对象（元类实例），而不是一个元类对象。当调用`__init__()`时，类已经被构建，因此这个方法可以做的事情比`__new__()`方法少。实现这样一个方法与使用类装饰器非常相似，但主要区别在于`__init__()`将被调用用于每个子类，而类装饰器不会被子类调用。'
- en: '`__call__(cls, *args, **kwargs)`: This is called when an instance of a metaclass
    is called. The instance of a metaclass is a class object (refer to *Figure 3*);
    it is invoked when you create new instances of a class. This can be used to override
    the default way how class instances are created and initialized.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__call__(cls, *args, **kwargs)`: 当调用元类的实例时调用此方法。元类的实例是一个类对象（参见*图3*）；当创建类的新实例时调用它。这可以用来覆盖类实例被创建和初始化的默认方式。'
- en: 'Each of the preceding methods can accept additional extra keyword arguments
    here represented by `**kwargs`. These arguments can be passed to the metaclass
    object using extra keyword arguments in the class definition in the form of the
    following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的每个方法都可以接受额外的关键字参数，这里用`**kwargs`表示。这些参数可以通过在类定义中使用额外的关键字参数传递给元类对象，形式如下代码：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Such amount of information can be overwhelming at the beginning without proper
    examples, so let''s trace the creation of metaclasses, classes, and instances
    with some `print()` calls:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有适当的示例的情况下，这么多的信息可能会让人感到不知所措，所以让我们通过一些`print()`调用来追踪元类、类和实例的创建：
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using `RevealingMeta` as a metaclass to create a new class definition will
    give the following output in the Python interactive session:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RevealingMeta`作为元类来创建一个新的类定义将在Python交互会话中给出以下输出：
- en: '[PRE63]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: New Python 3 syntax for metaclasses
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元类的新Python 3语法
- en: 'Metaclasses are not a new feature and are available in Python since version
    2.2\. Anyway, the syntax of this changed significantly and this change is neither
    backwards nor forwards compatible. While the new syntax is:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 元类不是一个新特性，在Python 2.2版本以来就可用。无论如何，这种语法的改变是显著的，这种改变既不向后兼容也不向前兼容。新的语法是：
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In Python 2, this must be written as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2中，这必须写成如下形式：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Class statements in Python 2 do not accept keyword arguments, so Python 3 syntax
    for defining `metaclasses` will raise the `SyntaxError` exception on import. It
    is still possible to write a code using metaclasses that will run on both Python
    versions, but it requires some extra work. Fortunately, compatibility-related
    packages such as `six` provide simple and reusable solutions to this problem:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2中的类语句不接受关键字参数，因此在Python 3中定义`metaclasses`的语法将在导入时引发`SyntaxError`异常。仍然可以编写使用元类的代码在两个Python版本上运行，但需要一些额外的工作。幸运的是，像`six`这样的与兼容性相关的包提供了这个问题的简单可重用的解决方案。
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The other important difference is the lack of the `__prepare__()` hook in Python
    2 metaclasses. Implementing such a function will not raise any exceptions under
    Python 2 but is pointless because it will not be called in order to provide a
    clean namespace object. This is why packages that need to maintain Python 2 compatibility
    need to rely on more complex tricks if they want to achieve things that are a
    lot easier to implement using `__prepare__()`. For instance, the Django REST Framework
    ([http://www.django-rest-framework.org](http://www.django-rest-framework.org))
    uses the following approach to preserve the order in which attributes are added
    to a class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的区别是Python 2中元类缺少`__prepare__()`钩子。实现这样一个函数在Python 2中不会引发任何异常，但是没有意义，因为它不会被调用以提供一个干净的命名空间对象。这就是为什么需要保持Python
    2兼容性的包需要依赖更复杂的技巧，如果它们想要实现使用`__prepare__()`更容易实现的功能。例如，Django REST Framework ([http://www.django-rest-framework.org](http://www.django-rest-framework.org))
    使用以下方法来保留属性添加到类的顺序：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This is the workaround if the default namespace type, which is `dict`, does
    not guarantee to preserve the order of the key-value tuples. The `_creation_counter`
    attribute is expected to be in every instance of the `Field` class. This `Field.creation_counter`
    attribute is created in the same way as `InstanceCountingClass.instance_number`
    that was presented in the section about the `__new__()` method. This is a rather
    complex solution that breaks a single responsibility principle by sharing its
    implementation across two different classes only to ensure a trackable order of
    attributes. In Python 3, this could be simpler because `__prepare__()` can return
    other mapping types such as `OrderedDict`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认命名空间类型，即`dict`，不能保证保留键值元组的顺序的解决方法。预期`Field`类的每个实例中都会有`_creation_counter`属性。`Field.creation_counter`属性的创建方式与`__new__()`方法部分中介绍的`InstanceCountingClass.instance_number`相同。这是一个相当复杂的解决方案，它通过在两个不同的类之间共享其实现来打破单一责任原则，以确保属性的可跟踪顺序。在Python
    3中，这可能会更简单，因为`__prepare__()`可以返回其他映射类型，如`OrderedDict`：
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here is what you will see:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您将看到的内容：
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more examples, there's a great introduction to metaclass programming in
    Python 2 by David Mertz, which is available at [http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html](http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多示例，请参阅David Mertz在Python 2中的元类编程的介绍，网址为[http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html](http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html)。
- en: Metaclass usage
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元类用法
- en: Metaclasses once mastered are a powerful feature but always complicate the code.
    They might also make the code less robust that is intended to work on any kind
    of class. For instance, you might encounter bad interactions when slots are used
    in the class, or when some base class already implements a metaclass, which conflicts
    with what yours does. They just do not compose well.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦掌握了元类，它就是一个强大的功能，但总是会使代码复杂化。它们可能还会使代码不够健壮，而这些代码本来是打算适用于任何类型的类。例如，当类中使用槽时，或者当某个基类已经实现了一个元类，与您的元类发生冲突时，可能会遇到不良的交互。它们只是无法很好地组合。
- en: For simple things like changing the read/write attributes or adding new ones,
    metaclasses can be avoided in favor of simpler solutions such as properties, descriptors,
    or class decorators.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的事情，如更改读/写属性或添加新属性，可以避免使用元类，而使用更简单的解决方案，如属性、描述符或类装饰器。
- en: It is also true that often metaclasses can be replaced with other simpler approaches,
    but there are situations where things cannot be easily done without them. For
    instance, it is hard to imagine Django's ORM implementation built without extensive
    use of metaclasses. It could be possible, but it is rather unlikely that the resulting
    solution would be similarly easy to use. And frameworks are the place where metaclasses
    are really well-suited. They usually have a lot of complex solutions that are
    not easy to understand and follow, but eventually allow other programmers to write
    more condensed and readable code that operates on a higher level of abstraction.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可以肯定的是，元类经常可以用其他更简单的方法替代，但也有一些情况下很难在没有它们的情况下轻松完成。例如，很难想象没有广泛使用元类的Django的ORM实现。这可能是可能的，但结果解决方案很可能不会像使用那样容易。而框架是元类真正适合的地方。它们通常有很多复杂的解决方案，不容易理解和遵循，但最终允许其他程序员编写更简洁和可读的代码，以更高的抽象级别操作。
- en: Metaclass pitfalls
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元类陷阱
- en: Like some other advanced Python features, metaclasses are very elastic and can
    be easily abused. While the call signature of the class is rather strict, Python
    does not enforce the type of the return parameter. It can be anything as long
    as it accepts incoming arguments on calls and has the required attributes whenever
    it is needed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些高级Python特性一样，元类非常灵活，很容易被滥用。虽然类的调用签名相当严格，但Python并不强制返回参数的类型。只要它在调用时接受传入的参数并在需要时具有所需的属性，它可以是任何东西。
- en: 'One such object that can be *anything-anywhere* is the instance of the `Mock`
    class provided in the `unittest.mock` module. `Mock` is not a metaclass and also
    does not inherit from the `type` class. It also does not return the class object
    on instantiating. Still, it can be included as a metaclass keyword argument in
    the class definition and this will not raise any issues, despite, it is pointless
    to do so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 可以是*任何地方*的一个对象是`unittest.mock`模块中提供的`Mock`类的实例。`Mock`不是一个元类，也不继承自`type`类。它在实例化时也不返回类对象。尽管如此，它可以作为类定义中的元类关键字参数包含在内，这不会引发任何问题，尽管这样做是没有意义的：
- en: '[PRE70]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding example, of course, completely does not make sense and will fail
    on any attempt to instantiate such a `Nonsense` pseudo-class. It is still important
    to know that such things are possible because issues with `metaclass` types that
    do not result in the creation of the `type` subclass are sometimes very hard to
    spot and understand. As a proof, here is a traceback of the exception raised when
    we try to create a new instance of the `Nonsense` class presented earlier:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的例子完全没有意义，任何尝试实例化这样一个`Nonsense`伪类都会失败。但重要的是要知道这样的事情是可能的，因为`metaclass`类型的问题有时很难发现和理解，不会导致`type`子类的创建。作为证明，这是我们尝试创建前面介绍的`Nonsense`类的新实例时引发的异常的回溯：
- en: '[PRE71]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Some tips on code generation
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有关代码生成的一些建议
- en: As already mentioned, dynamic code generation is the most difficult approach
    to code generation. There are some tools in Python that allow you to generate
    and execute code or even do some modifications to the already compiled code objects.
    A complete book could be written about this and even that will not exhaust the
    topic completely.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，动态代码生成是代码生成中最困难的方法。Python中有一些工具可以让您生成和执行代码，甚至对已编译的代码对象进行一些修改。关于这个话题可以写一本完整的书，即使那样也无法完全穷尽这个话题。
- en: Various projects, such as **Hy** (mentioned later), show that even whole languages
    can be re-implemented in Python using code generation techniques. This proves
    that the possibilities are practically limitless. Knowing how vast this topic
    is and how badly it is riddled with various pitfalls, I won't even try to give
    detailed suggestions on how to create code this way or to provide useful code
    samples.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如**Hy**（稍后提到）之类的各种项目表明，甚至可以使用代码生成技术在Python中重新实现整个语言。这证明了可能性几乎是无限的。知道这个话题有多广泛，以及它有多少各种各样的陷阱，我甚至不会尝试提供关于如何以这种方式创建代码或提供有用的代码示例的详细建议。
- en: Anyway, knowing what is possible may be useful for you if you plan to study
    this field deeper by yourself. So, treat this section only as a short summary
    of possible starting points for further learning. Most of it is flavored with
    many warnings in case you would like to eagerly jump into calling `exec()` and
    `eval()` in your own project.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果你打算自己深入研究这个领域，知道什么是可能的可能对你有用。因此，只把这一部分当作进一步学习的可能起点的简短总结。大部分内容都带有许多警告，以防你急于在自己的项目中调用`exec()`和`eval()`。
- en: exec, eval, and compile
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: exec、eval和compile
- en: 'Python provides three built-in functions to manually execute, evaluate, and
    compile arbitrary Python code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了三个内置函数来手动执行、评估和编译任意Python代码：
- en: '`exec(object, globals, locals)`: This allows you to dynamically execute the
    Python code. `object` should be a string or a code object (see the `compile()`
    function). The `globals` and `locals` arguments provide global and local namespaces
    for the executed code and are optional. If they are not provided, then the code
    is executed in the current scope. If provided, `globals` must be dictionary, while
    `locals` might be any mapping object; it always returns `None`.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec(object, globals, locals)`: 这允许你动态执行Python代码。`object`应该是一个字符串或代码对象（参见`compile()`函数）。`globals`和`locals`参数为执行的代码提供全局和局部命名空间，是可选的。如果它们没有提供，那么代码将在当前范围内执行。如果提供了，`globals`必须是字典，而`locals`可以是任何映射对象；它总是返回`None`。'
- en: '`eval(expression, globals, locals)`: This is used to evaluate the given expression
    returning its value. It is similar to `exec()`, but it accepts that `expression`
    should be a single Python expression and not a sequence of statements. It returns
    the value of the evaluated expression.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval(expression, globals, locals)`: 用于评估给定表达式并返回其值。它类似于`exec()`，但它接受`expression`应该是单个Python表达式而不是一系列语句。它返回评估表达式的值。'
- en: '`compile(source, filename, mode)`: This compiles the source into the code object
    or AST object. The code to be compiled is provided as a string in the source argument.
    The filename should be the file from which the code was read. If it has no file
    associated because its source was created dynamically, then `<string>` is the
    value that is commonly used. Mode should be either `exec` (sequence of statements),
    `eval` (single expression), or `single` (a single interactive statement such as
    in Python interactive session).'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile(source, filename, mode)`: 这将源代码编译为代码对象或AST对象。要编译的代码以字符串形式提供在源参数中。文件名应该是从中读取代码的文件。如果它没有关联的文件，因为它的源是动态创建的，那么`<string>`是通常使用的值。模式应该是`exec`（一系列语句）、`eval`（单个表达式）或`single`（单个交互式语句，如Python交互式会话中的语句）。'
- en: The `exec()` and `eval()` functions are the easiest to start with when trying
    to dynamically generate code because they can operate on strings. If you already
    know how to program in Python, then you may know how to correctly generate a working
    source code programmatically. I hope you do.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec()`和`eval()`函数是在尝试动态生成代码时最容易开始的，因为它们可以操作字符串。如果你已经知道如何在Python中编程，那么你可能知道如何正确地以编程方式生成可工作的源代码。我希望你知道。'
- en: The most useful in the context of metaprogramming is obviously `exec()` because
    it allows us to execute any sequence of Python statements. And the word *any*
    should be alarming for you. Even `eval()`, which only allows evaluation of expressions
    in the hands of a skillful programmer (when fed with the user input), can lead
    to serious security holes. Note that crashing the Python interpreter is the least
    scary scenario you should be afraid of. Introducing vulnerability to remote execution
    exploits due to irresponsible use of `exec()` and `eval()` can cost you your image
    as a professional developer, or even your job.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在元编程的上下文中最有用的显然是`exec()`，因为它允许我们执行任何一系列Python语句。而*任何*这个词对你来说应该是令人警惕的。即使是`eval()`，它只允许在熟练的程序员（在接收用户输入时）的手中评估表达式，也可能导致严重的安全漏洞。请注意，崩溃的Python解释器是你应该害怕的最不可怕的情景。由于不负责任地使用`exec()`和`eval()`而引入远程执行漏洞可能会让你失去作为专业开发人员的形象，甚至失去工作。
- en: Even if used with a trusted input, there is a long list of little details about
    `exec()` and `eval()` that is too long to be included here, but might affect how
    your application works in the ways you would not expect. Armin Ronacher has a
    good article that lists the most important of them called *Be careful with exec
    and eval in Python* (refer to [http://lucumr.pocoo.org/2011/2/1/exec-in-python/](http://lucumr.pocoo.org/2011/2/1/exec-in-python/)).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在使用受信任的输入时，关于`exec()`和`eval()`的一长串细节太长而无法在这里包括，但可能会影响你的应用程序的工作方式，这是你意想不到的。Armin
    Ronacher有一篇很好的文章列出了其中最重要的一些，名为*小心使用Python中的exec和eval*（参见[http://lucumr.pocoo.org/2011/2/1/exec-in-python/](http://lucumr.pocoo.org/2011/2/1/exec-in-python/)）。
- en: 'Despite all these frightening warnings, there are natural situations where
    the usage of `exec()` and `eval()` is really justified. The popular statement
    about when you have to use them is: *you will know*. In other words, in case of
    even the tiniest doubt, you should not use them and try to find a different solution.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有所有这些令人恐惧的警告，但也有自然情况下使用`exec()`和`eval()`是真正合理的。关于何时必须使用它们的流行说法是：*你会知道*。换句话说，如果有一丁点疑虑，你就不应该使用它们，而应该尝试找到另一种解决方案。
- en: Tip
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**eval() and untrusted input**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**eval()和不受信任的输入**'
- en: The signature of the `eval()` function might make you think that if you provide
    empty `globals` and `locals` namespaces and wrap it with proper `try ... except`
    statements, then it will be reasonably safe. There could be nothing more wrong.
    Ned Batcheler has written a very good article in which he shows how to cause an
    interpreter segmentation fault in the `eval()` call even with erased access to
    all Python built-ins ([http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html](http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html)).
    This is a single proof that both `exec()` and `eval()` should never be used with
    untrusted input.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`函数的签名可能会让您认为，如果提供空的`globals`和`locals`命名空间，并用适当的`try ... except`语句包装它，那么它将是相当安全的。这是完全错误的。Ned
    Batchelder在一篇非常好的文章中展示了如何在`eval()`调用中导致解释器分段错误，即使已经擦除了对所有Python内置函数的访问（[http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html](http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html)）。这是一个单一的证据，`exec()`和`eval()`都不应该与不受信任的输入一起使用。'
- en: Abstract Syntax Tree
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象语法树
- en: The Python syntax is converted to **Abstract Syntax Tree** (**AST**) before
    it is compiled to byte code. This is a tree representation of the abstract syntactic
    structure of the source code. The processing of Python grammar is available thanks
    to the built-in `ast` module. Raw AST of Python code can be created using the
    `compile()` function with the `ast.PyCF_ONLY_AST` flag, or using the `ast.parse()`
    helper. Direct translation in reverse is not that simple and there is no function
    provided in the built-ins for that. Some projects, such as PyPy, do such things
    though.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Python语法在编译成字节码之前会转换为**抽象语法树**（**AST**）。这是源代码的抽象语法结构的树形表示。Python语法的处理得益于内置的`ast`模块。可以使用带有`ast.PyCF_ONLY_AST`标志的`compile()`函数或使用`ast.parse()`助手来创建Python代码的原始AST。直接逆向翻译并不那么简单，内置函数中也没有提供这样的功能。不过一些项目，比如PyPy，确实会这样做。
- en: 'The `ast` module provides some helper functions that allow working with the
    AST:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`ast`模块提供了一些辅助函数，允许与AST一起工作：'
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output of `ast.dump()` in the preceding example was reformatted to increase
    the readability and better show the tree-like structure of the AST. It is important
    to know that the AST can be modified before being passed to the `compile()` call
    that gives many new possibilities. For instance, new syntax nodes can be used
    for additional instrumentation such as test coverage measurement. It is also possible
    to modify the existing code tree in order to add new semantics to the existing
    syntax. Such a technique is used by the MacroPy project ([https://github.com/lihaoyi/macropy](https://github.com/lihaoyi/macropy))
    to add syntactic macros to Python using the already existing syntax (refer to
    *Figure 5*):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`ast.dump()`的输出被重新格式化以增加可读性，并更好地显示AST的树状结构。重要的是要知道，在传递给`compile()`调用之前，AST可以被修改，这给出了许多新的可能性。例如，可以使用新的语法节点进行额外的插装，比如测试覆盖率测量。还可以修改现有的代码树，以添加新的语义到现有的语法中。MacroPy项目（[https://github.com/lihaoyi/macropy](https://github.com/lihaoyi/macropy)）使用了这样的技术，以使用已经存在的语法向Python添加语法宏（参见*图5*）：
- en: '![Abstract Syntax Tree](graphics/5295_03_05.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![抽象语法树](graphics/5295_03_05.jpg)'
- en: 'Figure 5: How MacroPy adds syntactic macros to Python modules on import'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：MacroPy在导入时如何向Python模块添加语法宏
- en: AST can also be created in a purely artificial manner and there is no need to
    parse any source at all. This gives Python programmers the ability to create Python
    bytecode for custom domain-specific languages or even completely implement other
    existing programming languages on top of Python VM.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: AST也可以以纯人工方式创建，根本不需要解析任何源代码。这使得Python程序员能够为自定义领域特定语言甚至完全实现其他现有编程语言在Python VM之上。
- en: Import hooks
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入钩子
- en: 'Taking advantage of the MacroPy''s ability to modify original AST would not
    be as easy as using the `import macropy.activate` statement if it would not somehow
    override the Python import behavior. Fortunately, Python provides a way to intercept
    imports using two kinds of import hooks:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 利用MacroPy修改原始AST的能力不像使用`import macropy.activate`语句那么容易，如果它不以某种方式覆盖Python的导入行为。幸运的是，Python提供了使用两种类型的导入钩子拦截导入的方法：
- en: '**Meta hooks**: These are called before any other `import` processing has occurred.
    Using meta hooks, you can override the way how `sys.path` is processed or even
    frozen and built-in modules. In order to add new meta hook, a new **meta path
    finder** object must be added to the `sys.meta_path` list.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元钩子**：这些在任何其他`import`处理发生之前被调用。使用元钩子，可以覆盖`sys.path`的处理方式，甚至冻结和内置模块。为了添加新的元钩子，必须将新的**元路径查找器**对象添加到`sys.meta_path`列表中。'
- en: '**Import path hooks**: These are called as part of `sys.path` processing. They
    are used if the path item associated with the given hook is encountered. The import
    path hooks are added by extending the `sys.path_hooks` list with a new **path
    finder** object.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入路径钩子：这些被称为`sys.path`处理的一部分。如果遇到与给定钩子相关联的路径项，则会使用它们。导入路径钩子是通过将新的**路径查找器**对象添加到`sys.path_hooks`列表来扩展的。
- en: The details on implementing both path finders and meta path finders are extensively
    implemented in the official Python documentation ([https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html)).
    The official documentation should be your primary resource if you want to interact
    with imports on that level. It's so because import machinery in Python is rather
    complex and any attempt to summarize it in a few paragraphs would inevitably fail.
    Treat this section rather as a note that such things are possible and as a reference
    to more detailed information.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有关实现路径查找器和元路径查找器的详细信息在官方Python文档中有广泛的实现（[https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html)）。如果您想在这个层面上与导入交互，官方文档应该是您的主要资源。这是因为Python中的导入机制相当复杂，任何试图在几段文字中总结它的尝试都不可避免地会失败。请将本节视为这样的一个注释，即这样的事情是可能的，并作为更详细信息的参考。
- en: Projects using code generation patterns
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用代码生成模式的项目
- en: 'It is really hard to find a really usable implementation of the library that
    relies on code generation patterns that is not only an experiment or simple proof
    of concepts. The reasons for that situation are fairly obvious:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很难找到一个真正可用的库实现，它依赖于代码生成模式，而不仅仅是一个实验或简单的概念证明。这种情况的原因是相当明显的：
- en: Deserved fear of the `exec()` and `eval()` functions because if used irresponsibly
    they can cause real disasters
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`exec()`和`eval()`函数的恐惧是理所当然的，因为如果不负责任地使用它们，可能会造成真正的灾难。
- en: Successful code generation is simply very difficult because it requires a deep
    understanding of the featured language and exceptional programming skills in general
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功的代码生成非常困难，因为它需要对所选语言有深刻的理解和一般的卓越编程技能
- en: Despite these difficulties, there are some projects that successfully take this
    approach either to improve performance or achieve things that would be impossible
    by other means.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些困难，但仍有一些项目成功地采用了这种方法，以改善性能或实现其他方式无法实现的目标。
- en: Falcon's compiled router
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Falcon的编译路由器
- en: Falcon ([http://falconframework.org/](http://falconframework.org/)) is a minimalist
    Python WSGI web framework for building fast and lightweight APIs. It strongly
    encourages REST architectural style that is currently very popular around the
    Web. It is a good alternative to other rather heavy frameworks such as Django
    or Pyramid. It is also a strong competitor to other micro-frameworks that aim
    for simplicity such as Flask, Bottle, and web2py.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Falcon ([http://falconframework.org/](http://falconframework.org/))是一个极简的Python
    WSGI Web框架，用于构建快速轻量级的API。它强烈推崇REST架构风格，这在Web上目前非常流行。它是Django或Pyramid等其他相当沉重的框架的良好替代品。它也是其他旨在简化的微框架（如Flask、Bottle和web2py）的强有力竞争对手。
- en: One of its features is its very simple routing mechanism. It is not as complex
    as the routing provided by Django `urlconf` and does not provide as many features
    but in most cases is just enough for any API that follows the REST architectural
    design. What is most interesting about falcon's routing is that the actual router
    is implemented using the code generated from the list of routes provided to the
    object that defines the API configuration. This is the effort to make routing
    fast.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一个特点是其非常简单的路由机制。它不像Django的`urlconf`提供的路由那样复杂，也不提供那么多功能，但在大多数情况下，对于遵循REST架构设计的任何API来说，它都足够了。关于falcon路由最有趣的是，实际的路由器是使用从提供给定义API配置的对象的路由列表生成的代码来实现的。这是为了使路由更快。
- en: 'Consider this very short API example taken from falcon''s web documentation:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下从falcon的Web文档中摘取的这个非常简短的API示例：
- en: '[PRE73]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The highlighted call to the `api.add_route()` method in brief words translates
    to updating the whole dynamically generated router code tree, compiling using
    `compile()` and generating the new route-finding function using `eval()`. Looking
    at the `__code__` attribute of the `api._router._find()` function shows that it
    was generated from the string and that it changes with every call to `api.add_route()`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在简短的话语中，对`api.add_route()`方法的突出调用意味着更新整个动态生成的路由器代码树，使用`compile()`进行编译，并使用`eval()`生成新的路由查找函数。查看`api._router._find()`函数的`__code__`属性显示，它是从字符串生成的，并且随着对`api.add_route()`的每次调用而更改：
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Hy
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hy
- en: Hy ([http://docs.hylang.org/](http://docs.hylang.org/)) is the dialect of Lisp
    written entirely in Python. Many similar projects implementing other code in Python
    usually try only to tokenize the plain form of code provided either as a file-like
    object or string and interpret it as a series of explicit Python calls. Unlike
    others, Hy can be considered a language that runs fully in the Python run-time
    environment just as Python does. Code written in Hy can use the existing built-in
    modules and external packages and vice versa. Code written with Hy can be imported
    back to Python.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Hy ([http://docs.hylang.org/](http://docs.hylang.org/))是完全用Python编写的Lisp方言。许多类似的项目通常只尝试在Python中实现其他代码，只是将提供的纯文本代码标记化为文件对象或字符串，并将其解释为一系列明确的Python调用。与其他项目不同，Hy可以被视为在Python运行时环境中完全运行的语言，就像Python一样。使用Hy编写的代码可以使用现有的内置模块和外部包，反之亦然。使用Hy编写的代码可以被导入回Python。
- en: 'In order to embed Lisp in Python, Hy translates Lisp code directly to Python
    Abstract Syntax Tree. Import interoperability is achieved using import hook that
    is registered once the Hy module is imported in Python. Every module with the
    `.hy` extension is treated as the Hy module and can be imported like the ordinary
    Python module. Thanks to this fact, the following "hello world" program is written
    in this Lisp dialect:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中嵌入Lisp，Hy直接将Lisp代码转换为Python抽象语法树。使用导入挂钩实现了导入互操作性，一旦在Python中导入Hy模块，就会注册该挂钩。具有`.hy`扩展名的每个模块都被视为Hy模块，并且可以像普通的Python模块一样导入。由于这个事实，下面的“hello
    world”程序是用这种Lisp方言编写的：
- en: '[PRE75]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It can be imported and executed by the following Python code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过以下Python代码导入和执行：
- en: '[PRE76]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If we dig deeper and try to disassemble `hyllo.hello` using the built-in `dis`
    module, we will notice that the byte code of the Hy function does not differ significantly
    from its pure Python counterpart:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们深入挖掘并尝试使用内置的`dis`模块来分解`hyllo.hello`，我们会注意到Hy函数的字节码与其纯Python对应物并没有显著的区别：
- en: '[PRE77]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter presented the best syntax practices related with classes. It started
    with basic information on how to subclass built-in types and call the method from
    superclasses. After that, more advanced concepts of object oriented programing
    in Python were presented. These were useful syntax features that focus on instance
    attribute access: descriptors and properties. It was shown how they can be used
    to create cleaner and more maintainable code. Slots too were featured, with an
    important note that they should always be used with caution.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了与类相关的最佳语法实践。它从如何对内置类型进行子类化和调用超类方法的基本信息开始。之后，介绍了Python中面向对象编程的更高级概念。这些是有用的语法特性，侧重于实例属性访问：描述符和属性。它展示了它们如何用于创建更清晰和更易维护的代码。插槽也被介绍了，重要的是要谨慎使用它们。
- en: The rest of the chapter explored the vast topic of metaprogramming in Python.
    The syntax features that favor the various metaprogramming patterns such as decorators
    and metaclasses were described in detail with some examples taken from real-life
    code.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分探讨了Python中元编程的广泛主题。详细描述了语法特性，有利于各种元编程模式，如装饰器和元类，并举了一些来自实际代码的例子。
- en: The other important aspect of metaprogramming in the form of dynamic code generation
    was described only briefly as it is too vast to fit in the limited space of this
    book. However, it should be a good starting point that gives a quick summary of
    the possible options in that field.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程的另一个重要方面是以动态代码生成的形式进行描述，但由于篇幅有限，只是简单地描述了一下，因为这个主题实在是太广泛了。然而，这应该是一个很好的起点，它快速总结了该领域的可能选项。
