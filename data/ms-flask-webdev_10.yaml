- en: Useful Flask Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的 Flask 扩展
- en: As we have seen throughout this book, Flask is designed to be as small as possible,
    while still giving you the flexibility and tools needed to create web applications.
    However, there are a lot of features that are common to many web applications,
    which means that many applications will require code that does the same task for
    each web application. To solve this problem, and avoid reinventing the wheel,
    people have created extensions for Flask, and we have seen many Flask extensions
    already throughout the book. This chapter will focus on some of the more useful
    Flask extensions that don't have enough content to separate them out into their
    own chapter, but will save you a lot of time and frustration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在整本书中看到的那样，Flask 被设计得尽可能小，同时仍然提供创建 Web 应用程序所需的灵活性和工具。然而，有很多功能是许多 Web 应用程序共有的，这意味着许多应用程序将需要执行相同任务的代码。为了解决这个问题，并避免重复造轮子，人们为
    Flask 创建了扩展，我们在整本书中已经看到了许多 Flask 扩展。本章将重点介绍一些更有用的 Flask 扩展，它们的内容不足以单独成章，但将为您节省大量时间和挫折。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Developing a debug toolbar, with great backend performance metrics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个具有出色后端性能指标的调试工具栏
- en: Page cache using Redis or memcached
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redis 或 memcached 进行页面缓存
- en: Creating an administration back office, with CRUD functionality for all your
    models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有所有模型 CRUD 功能的管理后台
- en: Enabling internationalization (i18n), and translating your site into multiple
    languages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用国际化（i18n），并将您的网站翻译成多种语言
- en: Sending emails easily
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易发送电子邮件
- en: Flask CLI
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask CLI
- en: In [Chapter 1](2d7573ed-1b2f-48df-9fac-9423d3f1cd51.xhtml), *Getting Started*,
    we introduced some basic features and learned how to use Flask CLI. Now, we are
    going to see how to make good use of this feature.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](2d7573ed-1b2f-48df-9fac-9423d3f1cd51.xhtml) “入门”中，我们介绍了一些基本功能，并学习了如何使用
    Flask CLI。现在，我们将看到如何充分利用这一功能。
- en: In Flask CLI, you can create custom commands to be run within the application
    context. Flask CLI itself uses **Click**,which is a library developed by the creator
    of Flask to create command-line tools with complex arguments early.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask CLI 中，你可以创建自定义命令，在应用程序上下文中运行。Flask CLI 本身使用 **Click**，这是一个由 Flask 的创建者开发的库，用于创建具有复杂参数的命令行工具。
- en: For further details on Click, take a look at the documentation, available at [http://click.pocoo.org](http://click.pocoo.org).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 Click 的更多详细信息，请查看文档，可在 [http://click.pocoo.org](http://click.pocoo.org)
    找到。
- en: 'Our goal is to create a set of commands to help us manage and deploy our Flask
    app. The first problem to tackle is where and how we are going to create these
    command-line functions. Since our CLI is an application global utility, we are
    going to place it in `webapp/cli.py`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一组命令，帮助我们管理和部署我们的 Flask 应用程序。首先要解决的问题是我们将在哪里以及如何创建这些命令行函数。由于我们的 CLI
    是一个应用程序的全局实用工具，我们将将其放置在 `webapp/cli.py`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are going to develop all of our functions inside the `register` function,
    so that we don''t have to import our Flask app from the main module. Doing so
    would result in a circular dependency import. Next, take note of the following
    decorators we use:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `register` 函数内部开发所有我们的函数，这样我们就不需要从主模块导入我们的 Flask 应用程序。这样做会导致循环依赖导入。接下来，请注意以下我们使用的装饰器：
- en: '`@app.cli.command` registers that our function has a new command-line command;
    if no argument is passed, then `Click` will assume the function''s name.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@app.cli.command` 注册了我们的函数有一个新的命令行命令；如果没有传递参数，那么 `Click` 将假设函数的名称。'
- en: '`@click.argument` adds a command-line argument; in our case, for username and
    password (needed to create the user credentials). Arguments are positional command-line
    options.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@click.argument` 添加了一个命令行参数；在我们的情况下，用于用户名和密码（用于创建用户凭据）。参数是位置命令行选项。'
- en: 'We register all of our command-line functions in `main.py`. Note the highlighted
    text in the following snippet, where we call the previously created `register` method:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `main.py` 中注册了所有的命令行函数。注意以下片段中突出显示的文本，其中我们调用了之前创建的 `register` 方法：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From the CLI, let''s try our newly created command as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行界面（CLI）开始，让我们尝试我们刚刚创建的命令，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, you can go to your web browser and log in to our blog using the newly
    created `user10` credentials.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以打开你的网络浏览器，并使用新创建的 `user10` 凭据登录我们的博客。
- en: 'The provided code also includes a `list-users` command, but its implementation
    should be straightforward for you by now, without any additional explanation here.
    Let''s focus on a simple and handy function to show all of our app''s routes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码还包括一个 `list-users` 命令，但它的实现现在对你来说应该很直观，这里不再进行额外解释。让我们关注一个简单且实用的函数，用于显示我们应用程序的所有路由：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `list-routes` command lists all of the routes registered on the `app` object,
    and the URL tied to that route. This is very useful while debugging Flask extensions,
    as it makes it trivial to see whether or not the registration of its blueprints
    is working.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`list-routes` 命令列出了在 `app` 对象上注册的所有路由及其关联的 URL。这在调试 Flask 扩展时非常有用，因为它使得检查其蓝图注册是否工作变得非常简单。'
- en: Flask Debug Toolbar
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Debug Toolbar
- en: '**Flask Debug Toolbar** is a Flask extension that aids development by adding
    debugging tools into the web view of your application. It gives you information
    on things such as the bottlenecks of your view rendering code, and how many SQLAlchemy
    queries it took to render the view.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flask Debug Toolbar** 是一个 Flask 扩展，通过将调试工具添加到你的应用程序的网页视图中来帮助开发。它为你提供了关于视图渲染代码的瓶颈以及渲染视图所需的
    SQLAlchemy 查询次数等信息。'
- en: 'As always, we will use `pip` to install Flask Debug Toolbar and add it to our `requirements.txt` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将使用 `pip` 安装 Flask Debug Toolbar 并将其添加到我们的 `requirements.txt` 文件中：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to add Flask Debug Toolbar to the `webapp/__init__.py` file.
    As we will be modifying this file a lot in this chapter, here is the start of
    the file so far, along with the code to initialize Flask Debug Toolbar:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 Flask Debug Toolbar 添加到 `webapp/__init__.py` 文件中。由于在本章中我们将大量修改此文件，以下是到目前为止文件的开始部分，以及初始化
    Flask Debug Toolbar 的代码：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is all that is needed to get Flask Debug Toolbar up and running. If the
    `DEBUG` variable in your app''s `config` is set to `true`, the toolbar will appear.
    If `DEBUG` is not set to `true`, the toolbar will not be injected into the page:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将 Flask Debug Toolbar 启用并运行所需的所有内容。如果你的应用配置中的 `DEBUG` 变量设置为 `true`，则工具栏将显示。如果
    `DEBUG` 没有设置为 `true`，则工具栏不会注入到页面中：
- en: '![](img/21d3d10e-70e0-49a7-81ad-5d2b1fcd2ad3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21d3d10e-70e0-49a7-81ad-5d2b1fcd2ad3.png)'
- en: On the right-hand side of the screen, you will see the toolbar. Each section
    is a link that will display a table of values on the page. To get a list of all
    the functions that were called in order to render the view, click the checkbox
    next to Profiler to enable it, then reload the page and click on Profiler. This
    view easily allows you to quickly diagnose which parts of your apps are the slowest,
    or are called the most.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的右侧，你会看到工具栏。每个部分都是一个链接，它将在页面上显示一个值表。要获取渲染视图时调用的所有函数的列表，请点击 Profiler 旁边的复选框以启用它，然后重新加载页面并点击
    Profiler。这个视图可以让你轻松快速地诊断你的应用程序中哪些部分运行最慢，或者被调用得最多。
- en: 'By default, Flask Debug Toolbar intercepts `HTTP 302 redirect` requests. To
    disable this, add the following to your configuration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flask Debug Toolbar 会拦截 `HTTP 302 重定向` 请求。要禁用此功能，请将以下内容添加到你的配置中：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, if you are using Flask-MongoEngine, you can view all of the queries that
    were made to render the page, by overriding which panels are rendered and adding
    MongoEngine''s custom panel as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你正在使用 Flask-MongoEngine，你可以通过覆盖要渲染的面板并添加以下 MongoEngine 的自定义面板来查看渲染页面时所做的所有查询：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will add a panel to the toolbar that is very similar to the default SQLAlchemy
    one.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在工具栏中添加一个与默认 SQLAlchemy 面板非常相似的面板。
- en: Flask Caching
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask 缓存
- en: In [Chapter 7](2f42c8ba-61f2-4855-bc61-af2c22f24800.xhtml), *Using NoSQL with
    Flask*, we learned that page load time is one of the most important factors that
    will determine the success or failure of your web app. Despite the facts that
    our pages do not change very often, and that new posts will not be made very often,
    we still render the template and query the database every single time the page
    is asked for by our users' browsers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](2f42c8ba-61f2-4855-bc61-af2c22f24800.xhtml) “使用 Flask 与 NoSQL”，我们了解到页面加载时间是决定你的
    Web 应用成功或失败的最重要因素之一。尽管我们的页面不经常更改，而且新帖子也不会经常发布，但我们仍然每次用户浏览器请求页面时都会渲染模板并查询数据库。
- en: 'Flask Caching solves this problem by allowing us to store the results of our
    view functions and return the stored results, rather than render the template
    again. First, we need to install Flask Caching on our virtual environment. This
    was already done when running the `init.sh` bash script. The `init.sh` script
    will first install all the declared dependencies in `requirements.txt`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 缓存通过允许我们存储视图函数的结果并返回存储的结果，而不是再次渲染模板来解决此问题。首先，我们需要在我们的虚拟环境中安装 Flask 缓存。这已经在运行
    `init.sh` bash 脚本时完成。`init.sh` 脚本将首先安装 `requirements.txt` 中声明的所有依赖项：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, initialize it in `webapp/__init__.py` as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `webapp/__init__.py` 中初始化它，如下所示：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before we can start caching our views, we need to tell Flask Cache how we want
    to store the results of our new functions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始缓存视图之前，我们需要告诉 Flask 缓存我们希望如何存储新函数的结果：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `simple` option tells Flask Cache to store the results in memory in a Python
    dictionary, which, for the vast majority of Flask apps, is adequate. We'll cover
    more types of cache backends later in this section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple` 选项告诉 Flask 缓存将结果存储在内存中的 Python 字典中，这对于 Flask 应用程序的大多数情况是足够的。我们将在本节后面介绍更多类型的缓存后端。'
- en: Caching views and functions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存视图和函数
- en: 'In order to cache the results of a view function, simply add a decorator to
    any function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓存视图函数的结果，只需将装饰器添加到任何函数中：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `timeout` parameter specifies how many seconds the cached result should
    last, before the function should again be run and stored. To confirm that the
    view is actually being cached, check the SQLAlchemy section of the Debug toolbar.
    Also, we can see the impact that caching has on page load times, by activating
    the profiler and comparing the times for before and after. On the author's top-of-the-range
    laptop, the main blog page takes 34 ms to render, mainly due to the eight different
    queries that are made to the database. But, after the cache is activated, this
    decreases to 0.08 ms. That's a 462.5 percent increase in speed!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeout` 参数指定缓存结果应该持续多少秒，然后函数应该再次运行并存储。为了确认视图实际上正在被缓存，请检查调试工具栏中的 SQLAlchemy
    部分。我们还可以通过激活分析器并比较前后时间来查看缓存对页面加载时间的影响。在作者的顶级笔记本电脑上，主要博客页面渲染需要 34 毫秒，主要是由于对数据库进行的八次不同查询。但是，在激活缓存后，这减少到
    0.08 毫秒。这是速度提高了 462.5 倍！'
- en: 'View functions are not the only thing that can be cached. To cache any Python
    function, simply add a similar decorator to the function definition, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 视图函数不是唯一可以缓存的东西。为了缓存任何 Python 函数，只需将类似的装饰器添加到函数定义中，如下所示：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `key_prefix` keyword argument is necessary in order for Flask Caching to
    properly store the results of non-view functions. This needs to be unique for
    every function cached, or the results of the functions will override each other.
    Also, note that the timeout for this function is set to two hours, rather than
    the 60 seconds, as in the previous examples. This is because the results for this
    function are less likely to change than the view functions, and if the data is
    stale, it is not as big of an issue as it would be for the view functions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`key_prefix` 关键字参数对于 Flask 缓存正确存储非视图函数的结果是必要的。对于每个缓存的函数，这需要是唯一的，否则函数的结果将相互覆盖。此外，请注意，此函数的超时设置为两小时，而不是之前的
    60 秒。这是因为此函数的结果不太可能像视图函数那样发生变化，如果数据已过时，这并不是一个很大的问题。'
- en: Caching functions with parameters
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存带参数的函数
- en: 'However, the normal cache decorator does not take function parameters into
    account. If we cached a function that took parameters with the normal cache decorator,
    it would return the same result for every parameter set. In order to fix this,
    we use the `memoize` function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正常的缓存装饰器不考虑函数参数。如果我们使用正常的缓存装饰器缓存了一个带有参数的函数，它将为每个参数集返回相同的结果。为了解决这个问题，我们使用
    `memoize` 函数：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Memoize` stores the parameters passed to the function as well as the result.
    In the preceding example, `memoize` is being used to store the result of the `verify_auth_token`
    method, which is called many times, and queries the database every single time.
    This method can safely memoized, because it returns the same result every time
    if the same token is passed to it. The only exception to this rule is if the user
    object gets deleted during the 60 seconds that the function is stored, but this
    is very unlikely.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memoize`存储传递给函数的参数以及结果。在上面的例子中，`memoize`被用来存储`verify_auth_token`方法的返回结果，该方法被多次调用，并且每次都会查询数据库。这个方法可以安全地进行memoization，因为它每次在传入相同的令牌时都会返回相同的结果。唯一的例外是，如果在函数存储的60秒内用户对象被删除，但这非常不可能。'
- en: Be careful not to `memoize` or cache functions that rely on either globally-scoped
    variables, or on constantly changing data. This can lead to some very subtle bugs,
    and in the worst case, data race. The best candidates for memoization are what
    are referred to as pure functions. **Pure functions** are functions that will
    produce the same result when the same parameters are passed to it. It does not
    matter how many times the function is run. Pure functions also don't have any
    *side effects*, which means that they do not change globally scoped variables.
    This also means that pure functions cannot do any I/O operations. While the `verify_auth_token`
    function is not pure, because it does database I/O, this is okay, because, as
    was stated before, it is very unlikely that the underlying data will change.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必小心，不要对依赖于全局作用域变量或不断变化数据的函数进行`memoize`或缓存。这可能会导致一些非常微妙的错误，在最坏的情况下，甚至会导致数据竞争。最适合进行memoization的函数被称为纯函数。**纯函数**是指当传入相同的参数时，将产生相同结果的函数。无论函数运行多少次，结果都不会改变。纯函数也没有任何*副作用*，这意味着它们不会改变全局作用域变量。这也意味着纯函数不能执行任何I/O操作。虽然`verify_auth_token`函数不是纯函数，因为它执行数据库I/O，但这是可以接受的，因为，如前所述，底层数据发生变化的可能性非常小。
- en: 'While we are developing the application, we do not want the view functions
    to be cached, because results will be changing all the time. To fix this, set
    the `CACHE_TYPE` variable to `null` and, in the production configuration, set
    the `CACHE_TYPE` variable to simple, so when the app is deployed, everything works
    as expected:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发应用程序时，我们不希望缓存视图函数，因为结果会不断变化。为了解决这个问题，将`CACHE_TYPE`变量设置为`null`，在生产配置中，将`CACHE_TYPE`变量设置为简单，这样当应用程序部署时，一切都会按预期工作：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Caching routes with query strings
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用查询字符串缓存路由
- en: Some routes, such as our `home` and `post` routes, take the parameters through
    the URL and return content specific to those parameters. We run into a problem
    if routes like these are cached, as the first rendering of the route will be returned
    for all requests, regardless of the URL parameters. The solution to this is rather
    simple. The `key_prefix` keyword argument in the cache method can be either a
    string or a function, which will be executed to dynamically generate a key.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些路由，如我们的`home`和`post`路由，通过URL传递参数并返回特定于这些参数的内容。如果这些路由被缓存，我们会遇到问题，因为第一个渲染的路由将返回所有请求，无论URL参数如何。这个问题的解决方案相当简单。缓存方法中的`key_prefix`关键字参数可以是字符串或函数，它将被执行以动态生成键。
- en: 'This means that a function can be created to create, in turn, a key that is
    tied to the URL parameters, so that each request only returns a cached page if
    that specific combination of parameters was called before. In the `blog/controllers.py`
    file, find the following function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可以创建一个函数，该函数会根据URL参数创建一个相关的键，这样每个请求只有在之前调用过该特定参数组合时才会返回缓存的页面。在`blog/controllers.py`文件中，找到以下函数：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use this function to create a cache key, using a mixture of URL paths, arguments,
    and Flask messages. This will prevent messages from not being shown when a user
    logs out. We will be using this type of cache key generation on the home view
    and show post by ID.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此函数通过混合URL路径、参数和Flask消息来创建缓存键。这将防止用户登出时消息不显示。我们将在主页视图和按ID显示帖子时使用这种类型的缓存键生成。
- en: Now, each individual post page will be cached for 10 minutes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个单独的帖子页面将被缓存10分钟。
- en: Using Redis as a cache backend
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis作为缓存后端
- en: 'If the amount of view functions, or the number of unique parameters, passed
    to your cached functions becomes too large for memory, you can use a different
    backend for the cache. As was mentioned in [Chapter 7](2f42c8ba-61f2-4855-bc61-af2c22f24800.xhtml),
    *Using NoSQL with Flask*, Redis can be used as a backend for the cache. To implement
    that functionality, all that needs to be done is to add the following configuration
    variables to the `ProdConfig` class, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给缓存函数的视图函数数量或唯一参数的数量太大，以至于内存无法处理，你可以为缓存使用不同的后端。正如在 [第 7 章](2f42c8ba-61f2-4855-bc61-af2c22f24800.xhtml)
    中提到的 *使用 NoSQL 与 Flask*，Redis 可以作为缓存的后端。要实现这个功能，需要做的只是将以下配置变量添加到 `ProdConfig`
    类中，如下所示：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you replace the values of the variables with your own data, Flask Cache will
    automatically create a connection to your `redis` database and use it to store
    the results of the functions. All that is needed is to install the Python `redis`
    library. This is already installed after issuing the `init.sh` script, which we
    did to set up the work environment for this chapter. You will find the library
    in `requirements.txt`**:**
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用你自己的数据替换了变量的值，Flask Cache 将会自动创建一个连接到你的 `redis` 数据库，并使用它来存储函数的结果。所需做的只是安装
    Python 的 `redis` 库。在执行了 `init.sh` 脚本之后，这个库就已经安装好了，我们执行这个脚本是为了设置本章的工作环境。你可以在 `requirements.txt`
    中找到这个库：**
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to test your Redis cache, we have prepared a Docker composer file
    that includes RabbitMQ and Redis. To launch it, just issue the following on the
    CLI:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试你的 Redis 缓存，我们准备了一个包含 RabbitMQ 和 Redis 的 Docker composer 文件。要启动它，只需在 CLI
    上执行以下命令：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Remember to test your application using the production configuration as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 记得使用以下生产配置来测试你的应用程序：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using memcached as a cache backend
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 memcached 作为缓存后端
- en: 'Just like the Redis backend, the memcached backend provides an alternative
    way of storing results, should the storage constraints become too limiting. In
    contrast to Redis, memcached is designed to cache objects for later use and reduce
    load on the database. Both Redis and memcached serve the same purpose, and choosing
    one over the other comes down to personal preference. To use memcached, we need
    to install its Python library with the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Redis 后端一样，memcached 后端提供了一种存储结果的替代方式，如果存储限制变得过于限制性。与 Redis 相比，memcached
    是设计用来缓存对象以供后续使用并减少数据库负载的。Redis 和 memcached 都服务于相同的目的，选择哪一个取决于个人偏好。要使用 memcached，我们需要使用以下命令安装它的
    Python 库：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The process of connecting to your memcached server is handled in the configuration
    object, just like the Redis setup:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到你的 memcached 服务器的过程在配置对象中处理，就像 Redis 设置一样：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Flask Assets
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Assets
- en: Another bottleneck in web applications is the amount of HTTP requests required
    to download the CSS and JavaScript libraries for the page. The extra files can
    only be downloaded after HTML for the page has been loaded and parsed. To combat
    this, many modern browsers download many of these libraries at once, but there
    is a limit to how many simultaneous requests the browser can make.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序的另一个瓶颈是需要下载页面上的 CSS 和 JavaScript 库的 HTTP 请求的数量。额外的文件只能在页面 HTML 加载和解析之后下载。为了解决这个问题，许多现代浏览器会一次性下载许多这些库，但浏览器可以发起的并发请求数量是有限的。
- en: Several things can be done on the server to reduce the amount of time spent
    downloading these files. The main technique that developers use to solve this
    is to concatenate all of the JavaScript libraries into one file, and all of the
    CSS libraries into another, while removing all of the whitespace and carriage
    returns from the resulting files (also known as **minification**). This reduces
    the overhead of multiple HTTP requests, and can reduce file's size by up to 30
    percent. Another technique is to tell the browser to cache the files locally,
    with specialized HTTP headers, so the file is only loaded again once it changes.
    These can be tedious to do manually, because they need to be done after every
    deployment to the server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上可以执行几个操作来减少下载这些文件所需的时间。开发者用来解决这个问题的主要技术是将所有的 JavaScript 库合并成一个文件，所有的 CSS
    库合并成另一个文件，同时从生成的文件中移除所有的空白和回车符（也称为 **minification**）。这减少了多个 HTTP 请求的开销，并且可以将文件大小减少高达
    30%。另一种技术是告诉浏览器使用特殊的 HTTP 头部信息本地缓存文件，这样文件只有在发生变化时才会再次加载。这些操作手动执行可能会很繁琐，因为它们需要在每次部署到服务器后执行。
- en: Thankfully, Flask Assets implements all the discussed techniques. Flask Assets
    works by giving it a list of files and a way to concatenate them, and then adding
    a special control block into your templates, in place of the normal link and script
    tags. Flask Assets will then add in a `link` or a `script` tag that links to the
    new generated file. To get started, Flask Assets needs to be installed. We also
    need to install `cssmin` and `jsmin`—you can find these dependencies in `requirements.txt`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Flask Assets实现了所有讨论的技术。Flask Assets通过提供一个文件列表和连接它们的方式工作，然后在模板中添加一个特殊的控制块，代替正常的链接和脚本标签。然后，Flask
    Assets将添加一个指向新生成文件的`link`或`script`标签。要开始使用，需要安装Flask Assets。我们还需要安装`cssmin`和`jsmin`——你可以在`requirements.txt`中找到这些依赖项。
- en: 'Now, the collections of files to be concatenated, named bundles, need to be
    created. In `ewebapp/__init__.py`, we have the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要创建要连接的文件集合，即所谓的包。在`ewebapp/__init__.py`中，我们有以下内容：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each `Bundle` object takes an infinite number of files as positional arguments
    to define the files to be bundled, a keyword argument `filters` to define the
    filters to send the files through, and an `output` that defines the filename in
    the `static` folder to which the result will be saved.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Bundle`对象接受无限数量的文件作为位置参数来定义要打包的文件，一个`filters`关键字参数来定义要发送文件通过的过滤器，以及一个`output`参数，它定义了结果将保存到`static`文件夹中的文件名。
- en: The `filters` keyword can be a single value or a list. To get the full list
    of available filters, including automatic Less and CSS compilers, see the docs
    at [http://webassets.readthedocs.org/en/latest/](http://webassets.readthedocs.org/en/latest/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`filters`关键字可以是一个值或一个列表。要获取所有可用的过滤器列表，包括自动的Less和CSS编译器，请参阅[http://webassets.readthedocs.org/en/latest/](http://webassets.readthedocs.org/en/latest/)上的文档。'
- en: While it's true that, because our site is light on styles, the CSS bundle only
    has one file in it, it's still a good idea to put the file in a bundle for two
    reasons. Firstly, while we are in development, we can use the un-minified versions
    of the libraries, which makes debugging easier. When the app is deployed to production,
    the libraries are automatically minified. Secondly, these libraries will be sent
    to the browser with the cache headers, when linking them normally in HTML would
    not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然确实，由于我们的站点样式较少，CSS包中只有一个文件，但将文件放入包中仍然是一个好主意，有两个原因。首先，在我们开发期间，我们可以使用未压缩版本的库，这使得调试更容易。当应用部署到生产环境时，库会自动压缩。其次，这些库将带有缓存头信息发送到浏览器，而在HTML中正常链接它们时则不会。
- en: 'Before Flask Assets can be tested, three more changes need to be made. First,
    in the `_init_.py` format, the extension and bundles need to be registered:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask Assets可以测试之前，需要做三个更改。首先，在`_init_.py`格式中，需要注册扩展和包：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, the `DevConfig` class needs an extra variable to tell Flask Assets not to compile
    the libraries while in development:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`DevConfig`类需要一个额外的变量来告诉Flask Assets在开发期间不要编译库：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, the link and script tags in both of the `base.html` files need to
    be replaced with the control block from Flask Assets. We have the following in
    the files already:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两个`base.html`文件中的链接和脚本标签都需要替换为Flask Assets的控制块。文件中已经有以下内容：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Replace the preceding snippet with the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换前面的片段：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Likewise, find the following in the `base.html` files:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`base.html`文件中找到以下内容：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, replace the preceding code with the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，用以下代码替换前面的代码：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, if you reload the page, all of the CSS and JavaScript will be handled by
    Flask Assets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你重新加载页面，所有的CSS和JavaScript都将由Flask Assets处理。
- en: Flask Admin
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Admin
- en: In [Chapter 6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml), *Securing Your App*,
    we created an interface to allow users to create and edit blog posts without having
    to use the CLI. This was adequate to demonstrate the security measures presented
    in the chapter, but there is still no way for posts to be deleted, or to assign
    tags to posts, using the interface. We also do not have a way to delete or edit
    comments that is hidden from regular users. What our app needs is a fully featured
    administrator interface, in the same vein as the WordPress interface. This is
    such a common requirement for apps that a Flask extension, called Flask Admin,
    was produced to help developers create administrator interfaces easily. Once more,
    we can find Flask Admin on the list of dependencies in `requirements.txt`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml)，“保护您的应用”，我们创建了一个接口，允许用户创建和编辑博客文章，而无需使用CLI。这对于展示章节中提到的安全措施是足够的，但仍然没有通过接口删除文章或为文章分配标签的方法。我们也没有为普通用户隐藏的删除或编辑评论的方法。我们的应用需要的是一个功能齐全的管理员界面，类似于WordPress界面。这对于应用来说是一个如此常见的需求，以至于出现了一个名为Flask
    Admin的Flask扩展，旨在帮助开发者轻松创建管理员界面。再次，我们可以在`requirements.txt`的依赖列表中找到Flask Admin。
- en: 'Since we are going to create a full administrator interface, with forms, views
    and templates, Flask Admin is a good candidate for a new module on our application.
    First, take a look at our new application structure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将创建一个包含表单、视图和模板的完整管理员界面，Flask Admin是我们应用中新的模块的好候选者。首先，看看我们新的应用结构：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As usual, we need to create the  `create_module` function in our `webapp/admin/__init__.py` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们需要在我们的`webapp/admin/__init__.py`文件中创建`create_module`函数：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, call the `create_module` function in the main `webapp/__init__.py` file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在主`webapp/__init__.py`文件中调用`create_module`函数：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Flask Admin works by registering view classes on the `admin` object that define
    one or more routes. Flask Admin has three main types of views: `ModelView`, `FileAdmin`,
    and `BaseView`. Next, we are going to see how to use these views and customize
    them.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Admin通过在`admin`对象上注册定义一个或多个路由的视图类来工作。Flask Admin主要有三种类型的视图：`ModelView`、`FileAdmin`和`BaseView`。接下来，我们将看到如何使用这些视图并对其进行自定义。
- en: 'Finally, we add a navigation bar option to the admin interface, and only render
    it to the users that have the admin role. So, in the `templates/navbar.html` file,
    insert the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向管理员界面添加一个导航栏选项，并且只将其渲染给具有管理员角色的用户。因此，在`templates/navbar.html`文件中，插入以下内容：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Creating basic admin pages
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本管理页面
- en: 'The `BaseView` class allows normal Flask pages to be added to your `admin`
    interface. This is normally the least used type of view in Flask Admin setups,
    but if you wish to include something like custom reporting with JavaScript charting
    libraries, you can do it with a base view alone. As expected, we are going to
    define our views in the `admin/controllers.py` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseView`类允许将正常的Flask页面添加到您的`admin`界面中。这通常是Flask Admin设置中最少使用的视图类型，但如果您希望包含类似使用JavaScript图表库的自定义报告，您可以使用基础视图单独完成。正如预期的那样，我们将在`admin/controllers.py`文件中定义我们的视图：'
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In a subclass of `BaseView`, multiple views can be registered at once, if they
    are defined together. Keep in mind, however, that each subclass of `BaseView`
    requires at least one exposed method on the `/` path. Also, methods other than
    the method within the `/` path will not be in the navigation of the administrator
    interface, and will have to be linked to the other pages in the class. The expose
    and `self.render` functions work exactly the same as their counterparts in the
    normal Flask API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BaseView`的子类中，如果它们一起定义，可以一次性注册多个视图。然而，请注意，每个`BaseView`的子类至少需要在`/`路径上有一个公开的方法。此外，除`/`路径内的方法之外的其他方法将不会出现在管理员界面的导航中，并将需要链接到该类中的其他页面。`expose`和`self.render`函数与正常Flask
    API中的对应函数工作方式完全相同。
- en: 'To have your templates inherit the default styles of Flask Admin, we create
    a new folder in the templates directory, named `admin`, containing a file named
    `custom.html`, and add the following Jinja code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要让您的模板继承Flask Admin的默认样式，我们在模板目录中创建一个新的文件夹，命名为`admin`，包含一个名为`custom.html`的文件，并添加以下Jinja代码：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To view this template, an instance of `CustomView` needs to be registered on
    the `admin` object. This will be done in the `create_module` function, following
    the same structure and logic as for the API module:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此模板，需要在`admin`对象上注册`CustomView`的一个实例。这将在`create_module`函数中完成，遵循与API模块相同的结构和逻辑：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `name` keyword argument specifies that the label, used in the navigation
    bar on the top of the `admin` interface, should read `Custom`. After you have
    registered `CustomView` to the `admin` object, your `admin` interface should now
    have a second link in the navigation bar, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 关键字参数指定在 `admin` 接口顶部的导航栏上使用的标签应读取为“自定义”。在你将 `CustomView` 注册到 `admin`
    对象之后，你的 `admin` 接口现在应该在导航栏中有一个第二个链接，如下面的截图所示：'
- en: '![](img/53cf3e18-3657-4f5f-a025-99e502d0e002.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53cf3e18-3657-4f5f-a025-99e502d0e002.png)'
- en: Creating database admin pages
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库管理页面
- en: 'The main power of Flask Admin comes from the fact that you can automatically
    create administrator pages for your data by giving Flask Admin your SQLAlchemy
    or MongoEngine models. Creating these pages is very easy; in `admin.py`, you just
    need to write the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Admin 的主要优势在于你可以通过提供 SQLAlchemy 或 MongoEngine 模型给 Flask Admin 来自动创建数据的管理页面。创建这些页面非常简单；在
    `admin.py` 文件中，你只需要编写以下代码：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, in `admin/__init__.py`, register  the database `session` object and the
    class with the model you wish to use, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `admin/__init__.py` 文件中，注册数据库 `session` 对象以及你希望使用的模型类，如下所示：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `category` keyword tells Flask Admin to put all of the views with the same
    category value into the same drop-down menu on the navigation bar. If you go to
    the browser now, you will see a new drop-down menu labeled Models, with links
    to the admin pages of all of the tables in the database, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`category` 关键字告诉 Flask Admin 将具有相同类别值的所有视图放入导航栏上的同一个下拉菜单中。如果你现在打开浏览器，你会看到一个名为“模型”的新下拉菜单，其中包含指向数据库中所有表的管理页面的链接，如下所示：'
- en: '![](img/dd891965-d771-4133-b666-3a74a4965b4e.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd891965-d771-4133-b666-3a74a4965b4e.png)'
- en: The generated interface for each model provides a lot of functionality. New
    posts can be created, and the existing posts can be deleted in bulk. All of the
    fields can be set from this interface, including the relationship fields, which
    are implemented as searchable drop-down menus. The `date` and `datetime` fields
    even have custom JavaScript inputs with drop-down calendar menus. Overall, this
    is a huge improvement to the hand-created interface that was created in [Chapter
    6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml), *Securing Your App*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个模型生成的接口提供了很多功能。可以创建新的帖子，并且可以批量删除现有的帖子。所有字段都可以通过这个接口设置，包括作为可搜索下拉菜单实现的关系字段。`date`
    和 `datetime` 字段甚至有自定义的 JavaScript 输入和下拉日历菜单。总的来说，这是对在 [第 6 章](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml)
    中创建的手动接口的一个巨大改进，*保护你的应用*。
- en: Enhancing administration for the post page
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强 `post` 页面的管理功能
- en: While this interface is a huge step up in quality, there are some features missing.
    We no longer have the WYSIWYG editor that was available in the original interface,
    but this page can be improved by enabling some of the more powerful Flask Admin
    features.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个接口在质量上有了巨大的提升，但仍然缺少一些功能。我们不再有原始接口中可用的 WYSIWYG 编辑器，但通过启用一些更强大的 Flask Admin
    功能，这个页面可以得到改进。
- en: 'To add the WYSIWYG editor back into the `post` creation page, we will need
    a new `WTForms` field, as Flask Admin constructs its forms with Flask WTF. We
    will also need to override the `textarea` field in the `post` edit and creation
    page with this new field type. The first thing that needs to be done is to create
    the new field type in `admin/forms.py` by using the `textarea` field as a base,
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 WYSIWYG 编辑器重新添加到 `post` 创建页面，我们需要一个新的 `WTForms` 字段，因为 Flask Admin 使用 Flask
    WTF 构建其表单。我们还需要用这个新字段类型覆盖 `post` 编辑和创建页面中的 `textarea` 字段。首先需要做的是在 `admin/forms.py`
    文件中创建新的字段类型，使用 `textarea` 字段作为基础，如下所示：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this code, we created a new field type, `CKTextAreaField`, that adds a widget
    to the `textarea`. All that the widget does is adds a class to the HTML tag. Now,
    to add this field to the `Post` admin page, the `Post` will need its own `ModelView`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个新的字段类型，`CKTextAreaField`，它为 `textarea` 添加了一个小部件。这个小部件所做的只是给 HTML
    标签添加一个类。现在，要将这个字段添加到 `Post` 管理页面，`Post` 需要自己的 `ModelView`：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There are several new things in this code. First, the `form_overrides` class
    variable tells Flask Admin to override the field type of the name text with this
    new field type. The `column_searchable_list` function defines which columns are
    searchable via text. Adding this will allow Flask Admin to include a search field
    on the overview page, with which we can search the values of the defined fields.
    Next, the `column_filters` class variable tells Flask Admin to create a `filters`
    interface on the overview page of this model. The `filters` interface allows columns
    that are not text to be filtered down by adding conditions to the shown rows.
    An example that could be implemented with the preceding code is to create a filter
    that shows all rows with `publish_date` values greater than January 1, 2015.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有几个新内容。首先，`form_overrides` 类变量告诉 Flask Admin 用这个新字段类型覆盖名称文本的字段类型。`column_searchable_list`
    函数定义了哪些列可以通过文本进行搜索。添加这个功能将允许 Flask Admin 在概览页面上包含一个搜索字段，我们可以通过这个字段搜索定义的字段值。接下来，`column_filters`
    类变量告诉 Flask Admin 在该模型的概览页面上创建一个 `filters` 接口。`filters` 接口允许通过向显示的行添加条件来过滤非文本列。使用前面的代码可以实现的示例是创建一个过滤器，显示所有
    `publish_date` 值大于 2015 年 1 月 1 日的行。
- en: 'Finally, the `create_template` and `edit_template` class variables allow you
    to define custom templates for Flask Admin to use. For the custom template that
    we will be using, we need to create a new file, `post_edit.html`, in the `admin`
    folder. In this template, we will include the same JavaScript library that was
    used in [Chapter 6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml), *Securing Your
    App*, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`create_template` 和 `edit_template` 类变量允许你为 Flask Admin 定义自定义模板。对于我们将要使用的自定义模板，我们需要在
    `admin` 文件夹中创建一个新的文件，名为 `post_edit.html`。在这个模板中，我们将包含与 [第 6 章](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml)
    中 *保护你的应用* 所使用的相同的 JavaScript 库，如下所示：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, to add our newly created customized view to Flask-Admin, we need to
    add it to the `create_module` function in the `admin/__init__.py` file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要将我们新创建的自定义视图添加到 Flask-Admin 中，我们需要将其添加到 `admin/__init__.py` 文件中的 `create_module`
    函数中：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The tail block of the inherited template is located at the end of the file.
    Once the template is created, your `post` edit and creation page should look like
    this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 继承模板的尾部位于文件末尾。一旦模板创建完成，你的 `post` 编辑和创建页面应该看起来像这样：
- en: '![](img/bd0e778c-7096-4441-97c8-4fad385505b4.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd0e778c-7096-4441-97c8-4fad385505b4.png)'
- en: Creating file system admin pages
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件系统管理页面
- en: 'Another common function that most `admin` interfaces cover is being able to
    access the server''s file system from the web. Thankfully, Flask Admin includes
    this feature with the `FileAdmin` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `admin` 接口都覆盖的一个常见功能是能够从网络访问服务器的文件系统。幸运的是，Flask Admin 通过 `FileAdmin` 类包含了这个功能：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, just import the new class into your `admin/__init__.py` file, and pass
    in the path that you wish to be accessible from the web:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需将新类导入到你的 `admin/__init__.py` 文件中，并传入你希望从网络访问的路径：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Securing Flask Admin
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 Flask Admin
- en: 'Currently, the entire `admin` interface is accessible to the world—let''s fix
    that. The routes in the `CustomView` can be secured just like any other route,
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，整个 `admin` 界面对全世界都是可访问的——让我们来修复这个问题。`CustomView` 中的路由可以像任何其他路由一样进行保护，如下所示：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To secure the `ModeView` and `FileAdmin` subclasses, they need to have a method
    named `is_accessible` defined, which either returns `true` or `false`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要保护 `ModeView` 和 `FileAdmin` 子类，它们需要定义一个名为 `is_accessible` 的方法，该方法要么返回 `true`，要么返回
    `false`：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because we set up our authentication correctly in [Chapter 6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml),
    *Securing Your App*, this task was trivial.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 [第 6 章](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml) 中正确设置了认证，*保护你的应用*，这个任务变得非常简单。
- en: Flask-Babel
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask-Babel
- en: 'In this section, we will explore a way to enable internationalization for our
    blog. This is an essential feature for building global websites with multi-language
    support. We will be using the Flask-Babel extension, again created by the author
    of Flask. As always, we will make sure this dependency exists in our `requirements.txt`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一种为我们的博客启用国际化的方法。这是构建支持多语言的全局网站的一个基本功能。我们将再次使用 Flask-Babel 扩展，它是由
    Flask 的作者创建的。像往常一样，我们将确保这个依赖项存在于我们的 `requirements.txt` 文件中：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Flask-Babel uses the Babel Python library for i18 and localization, and adds
    some utilities and Flask integration. To use Flask-Babel, first we need to configure
    Babel in the `babel/babel.cfg` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-Babel 使用 Babel Python 库进行国际化（i18n）和本地化，并添加了一些实用工具和 Flask 集成。要使用 Flask-Babel，首先我们需要在
    `babel/babel.cfg` 文件中配置 Babel：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We configure Babel to look for text to translate in Python files in the `webapp` directory
    only, and to extract text from `Jinja2` templates in the `webapp/templates` directory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Babel 配置为仅在 `webapp` 目录中查找要翻译的 Python 文件，并从 `webapp/templates` 目录中的 `Jinja2`
    模板中提取文本。
- en: Then, we need to create a translations directory on `webapp/translations`, where
    all the translations for our supported languages will be.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在 `webapp/translations` 上创建一个翻译目录，其中将包含我们支持的所有语言的翻译。
- en: 'Babel comes with a command-line utility, named `pybabel`. We will use it to
    set up all the languages that our blog will support, in addition to triggering
    an extract process, updating, and compiling. First, to create a new language,
    enter the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 附带一个名为 `pybabel` 的命令行实用程序。我们将使用它来设置我们博客将支持的所有语言，以及触发提取过程、更新和编译。首先，要创建一种新语言，输入以下命令：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Portuguese, or `pt`, is already initialized in the provided support code, but
    you could try creating a new language. Just change `pt` to some other language.
    After this, you can check `webapp/translations`, and should see that Babel has
    created a new directory with our language code. This directory contains a `messages.po` file,
    where we are going to write the translations necessary for the extracted text,
    and a `messages.mo` compiled version of the `messages.po` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 葡萄牙语，或 `pt`，已经在提供的支持代码中初始化，但你可以尝试创建一种新语言。只需将 `pt` 改为其他语言。之后，你可以检查 `webapp/translations`，应该会看到
    Babel 已经创建了一个包含我们语言代码的新目录。此目录包含一个 `messages.po` 文件，我们将在此文件中编写提取文本所需的翻译，以及 `messages.mo`
    的编译版本。
- en: 'Next, to trigger Babel to search for text to be translated on our application,
    use this command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了触发 Babel 在我们的应用程序中搜索要翻译的文本，使用以下命令：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will update the `messages.pot` main file with all the text that needs
    to be translated. Then, we tell Babel to update all the `messages.po` files for
    all the supported languages with the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新 `messages.pot` 主文件，其中包含所有需要翻译的文本。然后，我们告诉 Babel 使用以下命令更新所有支持语言的 `messages.po`
    文件：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, the `messages.po` files will contain something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`messages.po` 文件将包含类似以下内容：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, the translator will need to update `msgstr` with the translated text
    from `msgid`. English to some target language. After this is done, we will tell
    Babel to compile the `messages.po` files and generate updated `messages.mo` files
    with the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，翻译者需要使用从 `msgid` 翻译的文本更新 `msgstr`。从英语翻译到某种目标语言。完成此操作后，我们将告诉 Babel 编译 `messages.po`
    文件，并使用以下命令生成更新的 `messages.mo` 文件：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'How does Babel identify which text to translate on our application? Simple—`Jinja2`
    is already prepared for Babel, so on our templates, we just have to enter the
    following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 如何识别我们应用程序中要翻译的文本？很简单——`Jinja2` 已经为 Babel 准备好了，所以在我们的模板中，我们只需输入以下内容：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`_(''text'')` is an alias for the `gettext` function, and will return a translation
    for the string if one exists, and `ngettext` for text that can become plural.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`_(''text'')` 是 `gettext` 函数的别名，如果存在翻译，则返回字符串的翻译，对于可能变为复数的文本使用 `ngettext`。'
- en: 'For Flaskintegration, we are going to create a new module named `webapp/babel`.
    This is where we will initialize the extension. To do this, add the following
    to the `babel/__init__.py` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Flask 集成，我们将创建一个名为 `webapp/babel` 的新模块。这是我们初始化扩展的地方。为此，在 `babel/__init__.py`
    文件中添加以下内容：
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we need to define a function that returns the current locale code to
    Flask-Babel. The best place to add it is in the `babel/__init__.py` file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要定义一个函数，该函数返回当前的区域代码给 Flask-Babel。最佳位置是在 `babel/__init__.py` 文件中添加它：
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We will use the session to hold the currently selected locale, and if none exists,
    we'll fall back to English. Our function is decorated with `@babel.localeselector` to
    register our function on Flask-Babel.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用会话来保存当前选定的区域设置，如果没有设置，我们将回退到英语。我们的函数用 `@babel.localeselector` 装饰器装饰，以在
    Flask-Babel 上注册我们的函数。
- en: 'Next, we need to define an endpoint that can be called to switch the current
    selected language. This endpoint will set the session locale to the new language
    and redirect to the home page. Do this by adding the following code to the `babel/controllers.py` file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个端点，可以通过调用它来切换当前选定的语言。此端点将会将会话区域设置为新的语言并重定向到主页。通过在 `babel/controllers.py`
    文件中添加以下代码来完成此操作：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we will create a way for our users to change the current language.
    This will be done on the navigation bar. To do this, add the following to the `templates/navbar.html` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为我们的用户提供一种更改当前语言的方式。这将在导航栏中完成。为此，将以下内容添加到 `templates/navbar.html` 文件中：
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The new navigation bar options will send us to our Babel index endpoint with
    the selected language. Any new languages that we want to support should be added
    here. Finally, we just have to call Babel''s `create_module` function on our main `__init__.py` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 新的导航栏选项将带我们到带有选定语言的 Babel 索引端点。任何我们想要支持的新语言都应该添加到这里。最后，我们只需在我们的主 `__init__.py`
    文件上调用 Babel 的 `create_module` 函数即可。
- en: '[PRE58]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: And that's it. We now have all the necessary configurations in place to support
    any language on our blog application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们现在已经设置了所有必要的配置，以支持我们博客应用程序上的任何语言。
- en: '![](img/0264c6b3-d3e0-4420-829d-b6a38b377432.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0264c6b3-d3e0-4420-829d-b6a38b377432.png)'
- en: Flask Mail
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Mail
- en: 'The final Flask extension that this chapter will cover is Flask Mail, which
    allows you to connect and configure your SMTP client from Flask''s configuration.
    Flask Mail will also help to simplify application testing in [Chapter 12](9ffdc8da-2c26-4e97-8738-eebc7629535c.xhtml),
    *Testing Flask Apps*. The first step is to install Flask Mail with `pip`. You
    should already have done this in this chapter, in our `init.sh` script, so let''s
    check our dependencies file for the following to make sure:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要介绍的最后一个 Flask 扩展是 Flask Mail，它允许你从 Flask 的配置中连接和配置你的 SMTP 客户端。Flask Mail
    还将有助于简化 [第 12 章](9ffdc8da-2c26-4e97-8738-eebc7629535c.xhtml)，*测试 Flask 应用程序* 中的应用程序测试。第一步是使用
    `pip` 安装 Flask Mail。你应该在本章中已经完成了这个步骤，在我们的 `init.sh` 脚本中，所以让我们检查我们的依赖文件，以确保以下内容：
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`flask_mail` will connect to our SMTP server of choice by reading the configuration
    variables in our `app` object, so we need to add those values to our `config`
    object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask_mail` 将通过读取 `app` 对象中的配置变量来连接我们选择的 SMTP 服务器，因此我们需要将这些值添加到我们的 `config`
    对象中：'
- en: '[PRE60]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, the `mail` object is initialized on the `app` object in `_init_.py`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `_init_.py` 中初始化 `mail` 对象：
- en: '[PRE61]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To see how Flask Mail can simplify our emailing code, consider the following—this
    code snippet is the Remind task that we created in [Chapter 9](5672073f-7a18-4865-9800-a2124147042c.xhtml),
    *Creating Asynchronous Tasks with Celery*, but uses Flask Mail instead of the
    standard library SMTP module:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Flask Mail 如何简化我们的电子邮件代码，请考虑以下内容——这个代码片段是我们创建在 [第 9 章](5672073f-7a18-4865-9800-a2124147042c.xhtml)，*使用
    Celery 创建异步任务* 中的 Remind 任务，但使用 Flask Mail 而不是标准库的 SMTP 模块：
- en: '[PRE62]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The tasks in this chapter have allowed us to grow the functionality of our app
    significantly. We now have a fully featured administrator interface, a useful
    debugging tool in the browser, two tools that greatly speed up page load times,
    and a utility to make sending emails less of a headache.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的任务使我们能够显著扩展我们应用程序的功能。我们现在拥有了一个功能齐全的管理员界面，浏览器中的一个有用的调试工具，两个可以大大加快页面加载时间的工具，以及一个使发送电子邮件不那么头疼的实用工具。
- en: As was stated at the start of this chapter, Flask is bare-bones, and allows
    you to pick and choose the functionality that you want. Therefore, it is important
    to keep in mind that it is not necessary to include all of these extensions in
    your app. If you are the only content creator working on your app, the CLI might
    be all you need, because adding in these features takes up development time (and
    maintenance time, when they inevitably break). This warning is given at the end
    of the chapter, because one of the main reasons many Flask apps become unwieldy
    is because they include so many extensions, that testing and maintaining all of
    them becomes a very large task.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，Flask 是一个基础框架，允许你挑选和选择你需要的功能。因此，重要的是要记住，在你的应用程序中并不需要包含所有这些扩展。如果你是唯一一个在应用程序上工作的内容创作者，CLI
    可能就是你所需要的，因为添加这些功能会占用开发时间（当它们不可避免地出现问题时，还会占用维护时间）。这个警告是在本章末尾给出的，因为许多 Flask 应用程序变得难以管理的主要原因之一就是它们包含了太多的扩展，测试和维护所有这些扩展变成了一项非常庞大的任务。
- en: In the next chapter, you will learn the internals of how an extension works,
    and how to create your own extension.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习扩展的内部工作原理，以及如何创建你自己的扩展。
