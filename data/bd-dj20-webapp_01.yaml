- en: Starting MyMDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动MyMDB
- en: 'The first project we will build is a basic **Internet Movie Database** (**IMDB**)
    clone called **My Movie Database (MyMDB)** written in Django 2.0 that we will
    deploy using Docker. Our IMDB clone will have the following two types of users:
    users and administrators. The users will be able to rate movies, add images from
    movies, and view movies and cast. The administrators will be able to add movies,
    actors, writers, and directors.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的第一个项目是一个基本的**互联网电影数据库**（**IMDB**）克隆，名为**我的电影数据库（MyMDB）**，使用Django 2.0编写，我们将使用Docker部署。我们的IMDB克隆将有以下两种类型的用户：用户和管理员。用户将能够对电影进行评分，添加电影图片，并查看电影和演员阵容。管理员将能够添加电影、演员、作家和导演。
- en: 'In this chapter, we''ll do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Create our new Django project MyMDB, an IMDB clone
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的新Django项目MyMDB，一个IMDB克隆
- en: Make a Django app and create our first models, views, and templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Django应用程序并创建我们的第一个模型、视图和模板
- en: Learn about and use a variety of fields in our models and create relationships
    across models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解并使用我们模型中的各种字段，并在模型之间创建关系
- en: The code for this project is available online at [https://github.com/tomaratyn/MyMDB](https://github.com/tomaratyn/MyMDB).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码可在以下网址在线获取：[https://github.com/tomaratyn/MyMDB](https://github.com/tomaratyn/MyMDB)。
- en: By the end, we'll be able to add movies, people, and roles into our project
    and let users view them in easy-to-customize HTML templates.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将能够在我们的项目中添加电影、人物和角色，并让用户在易于定制的HTML模板中查看它们。
- en: Starting My Movie Database (MyMDB)
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动我的电影数据库（MyMDB）
- en: 'First, let''s make a directory for our project:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的项目创建一个目录：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All our future commands and paths will be relative to this project directory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有未来的命令和路径都将相对于这个项目目录。
- en: Starting the project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动项目
- en: 'A Django project is composed of multiple Django apps. A Django app can come
    from many different places:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Django项目由多个Django应用程序组成。Django应用程序可以来自许多不同的地方：
- en: Django itself (for example, `django.contrib.admin`, the admin backend app)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django本身（例如，`django.contrib.admin`，管理后台应用程序）
- en: Installed Python packages (for example, `django-rest-framework`, a framework
    for creating REST APIs from Django models)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Python包（例如，`django-rest-framework`，一个从Django模型创建REST API的框架）
- en: Written as part of the project (the code we'll be writing)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为项目的一部分（我们将要编写的代码）
- en: Usually, a project uses a mix of all of the preceding three options.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个项目会使用前面三个选项的混合。
- en: Installing Django
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Django
- en: 'We''ll install Django using `pip`, Python''s preferred package manager and
    track which packages we install in a `requirements.dev.txt` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pip`安装Django，Python的首选包管理器，并在`requirements.dev.txt`文件中跟踪我们安装的包：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s install the packages:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装这些包：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating the project
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'With Django installed, we have the `django-admin` command-line tool with which
    we can generate our project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Django后，我们有了`django-admin`命令行工具，可以用它来生成我们的项目：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The parent of the `settings.py` file is called `config` because we named our
    project `config` instead of `mymdb`. However, letting that top-level directory
    continue to be called `config` is confusing, so let''s just rename it `django`
    (a project may grow to contain lots of different types of code; calling the parent
    of the Django code `django`, again, makes it clear):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings.py`文件的父级称为`config`，因为我们将项目命名为`config`而不是`mymdb`。然而，让顶级目录继续被称为`config`是令人困惑的，所以让我们将其重命名为`django`（一个项目可能会包含许多不同类型的代码；再次称呼Django代码的父级目录为`django`，可以让人清楚地知道）：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s take a closer look at some of these files:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看其中一些文件：
- en: '`settings.py`: This is where Django stores all the configuration for your app
    by default. In the absence of a `DJANGO_SETTINGS` environment variable, this is
    where Django looks for settings by default.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settings.py`：这是Django默认存储应用程序所有配置的地方。在缺少`DJANGO_SETTINGS`环境变量的情况下，Django默认在这里查找设置。'
- en: '`urls.py`: This is the root `URLConf` for the entire project. Every request
    that your web app gets will get routed to the first view that matches a path inside
    this file (or a file `urls.py` reference).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urls.py`：这是整个项目的根`URLConf`。你的Web应用程序收到的每个请求都将被路由到这个文件内匹配路径的第一个视图（或`urls.py`引用的文件）。'
- en: '`wsgi.py`: **Web Server Gateway Interface** (**WSGI**) is the interface between
    Python and a web server. You won''t touch this file very much, but it''s how your
    web server and your Python code know how to talk to each other. We''ll reference
    it in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml), *Deploying with
    Docker*.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsgi.py`：**Web Server Gateway Interface**（**WSGI**）是Python和Web服务器之间的接口。你不会经常接触到这个文件，但这是你的Web服务器和Python代码知道如何相互通信的方式。我们将在[第5章](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml)中引用它，*使用Docker部署*。'
- en: '`manage.py`: This is the command center for making non-code changes. Whether
    it''s creating a database migration, running tests, or starting the development
    server, we will use this file often.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manage.py`：这是进行非代码更改的命令中心。无论是创建数据库迁移、运行测试，还是启动开发服务器，我们经常会使用这个文件。'
- en: Note what's missing is that the `django` directory is not a Python module. There's
    no `__init__.py` file in there, and there should *not* be. If you add one, many
    things will break because we want the Django apps we add to be top-level Python
    modules.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，缺少的是`django`目录不是Python模块。里面没有`__init__.py`文件，也不应该有。如果添加了一个，许多东西将会出错，因为我们希望添加的Django应用程序是顶级Python模块。
- en: Configuring database settings
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据库设置
- en: By default, Django creates a project that will use SQLite, but that's not usable
    for production, so we'll follow the best practice of using the same database in
    development as in production.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Django创建一个将使用SQLite的项目，但这对于生产来说是不可用的，所以我们将遵循在开发和生产中使用相同数据库的最佳实践。
- en: 'Let''s open up `django/config/settings.py` and update it to use our Postgres
    server. Find the line in `settings.py` that starts with `DATABASES`. By default,
    it will look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`django/config/settings.py`并更新它以使用我们的Postgres服务器。找到`settings.py`中以`DATABASES`开头的行。默认情况下，它看起来像这样：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use Postgres, change the preceding code to the following one:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Postgres，请将上述代码更改为以下代码：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Most of this will seem familiar if you''ve connected to a database before,
    but let''s review:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前连接过数据库，大部分内容都会很熟悉，但让我们回顾一下：
- en: '`DATABASES = {`: This constant is a dictionary of database connection information
    and is required by Django. You can have multiple connections to different databases,
    but, most of the time, you will just need an entry called `default`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATABASES = {`: 这是数据库连接信息的字典常量，并且是Django所必需的。您可以连接到不同数据库的多个连接，但大部分时间，您只需要一个名为`default`的条目。'
- en: '`''default'': {`: This is the default database connection configuration. You
    should always have a `default` set of connections settings. Unless you specify
    otherwise (and, in this book, we won''t), this is the connection you''ll be using.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''default'': {`: 这是默认的数据库连接配置。您应该始终具有一组`default`连接设置。除非另有说明（在本书中我们不会），否则这是您将要使用的连接。'
- en: '`''ENGINE'': ''django.db.backends.postgresql ''`: This tells Django to use
    the Postgres backend. This in turn uses `psycopg2`, Python''s Postgres library.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''ENGINE'': ''django.db.backends.postgresql ''`: 这告诉Django使用Postgres后端。这反过来使用`psycopg2`，Python的Postgres库。'
- en: '`''NAME'': ''mymdb'',`: The name of the database you want to connect to.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''NAME'': ''mymdb'',`: 您想要连接的数据库的名称。'
- en: '`‘USER'': ''mymdb'',`: The username for your connection.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`‘USER'': ''mymdb'',`: 您的连接用户名。'
- en: '`‘PASSWORD'': ''development'',`: The password for your database user.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`‘PASSWORD'': ''development'',`: 您的数据库用户的密码。'
- en: '`‘HOST'': ''127.0.0.1’,`: The address of the database server you want to connect
    to.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`‘HOST'': ''127.0.0.1’,`: 您要连接的数据库服务器的地址。'
- en: '`‘PORT'': ''5432'',`: The port you want to connect to.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`‘PORT'': ''5432'',`: 您要连接的端口。'
- en: The core app
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心应用程序
- en: 'Django apps follow a **Model View Template** (**MVT**) pattern; in this pattern,
    we will note the following things:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Django应用程序遵循**模型视图模板**（**MVT**）模式；在这种模式中，我们将注意以下事项：
- en: '**Models** are responsible for saving and retrieving data from the database'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**负责从数据库保存和检索数据'
- en: '**Views** are responsible for processing HTTP Requests, initiating operations
    on Models, and returning HTTP responses'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**负责处理HTTP请求，启动模型上的操作，并返回HTTP响应'
- en: '**Templates** are responsible for the look of the response body'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**负责响应主体的外观'
- en: There's no limit on how many apps you can have in your Django project. Ideally,
    each app should have a tightly scoped and self-contained functionality like any
    other Python module, but at the beginning of a project, it can be hard to know
    where the complexity will lie. That's why I find it useful to start off with a
    `core` app. Then, when I notice clusters of complexity around particular topics
    (let's say, in our project, actors could become unexpectedly complex if we're
    getting traction there), then we can refactor that into its own tightly scoped
    app. Other times, it's clear that a site has self-contained components (for example,
    an admin backend), and it's easy to start off with multiple apps.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django项目中，您可以拥有任意数量的应用程序。理想情况下，每个应用程序应该具有像任何其他Python模块一样紧密范围和自包含的功能，但在项目开始时，很难知道复杂性将出现在哪里。这就是为什么我发现从`core`应用程序开始很有用。然后，当我注意到特定主题周围存在复杂性集群时（比如说，在我们的项目中，如果我们在那里取得进展，演员可能会变得意外复杂），那么我们可以将其重构为自己的紧密范围的应用程序。其他时候，很明显一个站点有自包含的组件（例如，管理后端），并且很容易从多个应用程序开始。
- en: Making the core app
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作核心应用程序
- en: 'To make a new Django app, we first have to use `manage.py` to create the app
    and then add it to the list of `INSTALLED_APPS`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的Django应用程序，我们首先必须使用`manage.py`创建应用程序，然后将其添加到`INSTALLED_APPS`列表中：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s take a closer look at what''s inside of the core:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看核心内部有什么：
- en: '`core/__init__.py`: The core is not just a directory, but also a Python module.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core/__init__.py`: 核心不仅是一个目录，还是一个Python模块。'
- en: '`admin.py`: This is where we will register our models with the built-in admin
    backend. We''ll describe that in the *Movie Admin* section.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin.py`: 这是我们将在其中使用内置管理后端注册我们的模型。我们将在*电影管理*部分进行描述。'
- en: '`apps.py`: Most of the time, you''ll leave this alone. This is where you would
    put any code that needs to run when registering your application, which is useful
    if you''re making a reusable Django app (for example, a package you want to upload
    to PyPi).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apps.py`: 大部分时间，您会将其保持不变。这是您将在其中放置任何在注册应用程序时需要运行的代码的地方，如果您正在制作可重用的Django应用程序（例如，您想要上传到PyPi的软件包）。'
- en: '`migrations`: This is a Python module with database migrations. Database migrations
    describe how to *migrate* the database from one known state to another. With Django,
    if you add a model, you can just generate and run a migration using `manage.py`,
    which you can see later in this chapter in the *Migrating the database* section.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`migrations`: 这是一个带有数据库迁移的Python模块。数据库迁移描述了如何从一个已知状态迁移数据库到另一个状态。使用Django，如果您添加了一个模型，您只需使用`manage.py`生成并运行迁移，您可以在本章后面的*迁移数据库*部分中看到。'
- en: '`models.py`: This is for models.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.py`: 这是用于模型的。'
- en: '`tests.py`: This is for tests.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests.py`: 这是用于测试的。'
- en: '`views.py`: This is for views.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views.py`: 这是用于视图的。'
- en: Installing our app
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装我们的应用程序
- en: 'Now that our core app exists, let''s make Django aware of it by adding it to
    the list of installed apps in `settings.py` file. Your `settings.py` should have
    a line that looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的核心应用程序存在了，让我们通过将其添加到`settings.py`文件中的已安装应用程序列表中，让Django意识到它。您的`settings.py`应该有一行看起来像这样的：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`INSTALLED_APPS` is a list of Python paths to Python modules that are Django
    apps. We already have apps installed to solve common problems, such as managing
    static files, sessions, and authentication and an admin backend because of Django''s
    Batteries Included philosophy.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSTALLED_APPS`是Django应用程序的Python模块的Python路径列表。我们已经安装了用于解决常见问题的应用程序，例如管理静态文件、会话和身份验证以及管理后端，因为Django的Batteries
    Included哲学。'
- en: 'Let''s add our `core` app to the top of that list:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的`core`应用程序添加到列表的顶部：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding our first model – Movie
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加我们的第一个模型 - 电影
- en: Now we can add our first model, that is, Movie.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加我们的第一个模型，即电影。
- en: A Django model is a class that is derived from `Model` and has one or more `Fields`.
    In database terms, a `Model` class corresponds to a database table, `Field` classes
    correspond to columns, and instances of a `Model` correspond to rows. Using an
    ORM like Django's, let's take advantage of Python and Django to write expressive
    classes instead of DB writing our models once in Python and again in SQL.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Django模型是从`Model`派生的类，具有一个或多个`Fields`。在数据库术语中，`Model`类对应于数据库表，`Field`类对应于列，`Model`的实例对应于行。使用像Django这样的ORM，让我们利用Python和Django编写表达性的类，而不是在Python中编写我们的模型，然后再在SQL中编写一次。
- en: 'Let''s edit `django/core/models.py` to add a `Movie` model:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑`django/core/models.py`来添加一个`Movie`模型：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Movie` is derived from `models.Model`, which is the base class for all Django
    models. Next, there''s a series of constants that describe ratings; we''ll take
    a look at that when we look at the `rating` field, but first let''s look at the
    other fields:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Movie`派生自`models.Model`，这是所有Django模型的基类。接下来，有一系列描述评级的常量；我们将在查看`rating`字段时再看一下，但首先让我们看看其他字段：'
- en: '`title = models.CharField(max_length=140)`: This will become a `varchar` column
    with a length of 140\. Databases generally require a maximum size for `varchar` columns,
    so Django does too.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title = models.CharField(max_length=140)`: 这将成为一个长度为140的`varchar`列。数据库通常要求`varchar`列的最大大小，因此Django也要求。'
- en: '`plot = models.TextField()`: This will become a `text` column in our database,
    which has no maximum length requirement. This makes it more appropriate for a
    field that can have a paragraph (or even pages) of text.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plot = models.TextField()`: 这将成为我们数据库中的一个`text`列，它没有最大长度要求。这使得它更适合可以有一段（甚至一页）文本的字段。'
- en: '`year = models.PositiveIntegerField()`: This will become an `integer` column,
    and Django will validate the value before saving it to ensure that it is `0` or
    higher when you save it.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`year = models.PositiveIntegerField()`: 这将成为一个`integer`列，并且Django将在保存之前验证该值，以确保在保存时它是`0`或更高。'
- en: '`rating = models.IntegerField(choices=RATINGS, default=NOT_RATED)`: This is
    a more complicated field. Django will know that this is going to be an `integer` column.
    The optional argument `choices` (which is available for all `Fields`, not just
    `IntegerField`) takes an iterable (list or tuple) of value/display pairs. The
    first element in the pair is a valid value that can be stored in the database
    and the second is a human-friendly version of the value. Django will also add
    an instance method to our model called `get_rating_display()`, which will return
    the matching second element for the value stored in our model. Anything that doesn''t
    match one of the values in `choices` will be a `ValidationError` on save. The
    `default` argument provides a default value if one is not provided when creating
    the model.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rating = models.IntegerField(choices=RATINGS, default=NOT_RATED)`: 这是一个更复杂的字段。Django将知道这将是一个`integer`列。可选参数`choices`（对于所有`Fields`都可用，不仅仅是`IntegerField`）接受一个值/显示对的可迭代对象（列表或元组）。对中的第一个元素是可以存储在数据库中的有效值，第二个是该值的人性化版本。Django还将在我们的模型中添加一个名为`get_rating_display()`的实例方法，它将返回与存储在我们的模型中的值匹配的第二个元素。任何不匹配`choices`中的值的内容在保存时都将是一个`ValidationError`。`default`参数在创建模型时提供默认值。'
- en: '`runtime = models.PositiveIntegerField()`: This is the same as the `year` field.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime = models.PositiveIntegerField()`: 这与`year`字段相同。'
- en: '`website = models.URLField(blank=True)`: Most databases don''t have a native
    URL column type, but data-driven web apps often need to store them. A `URLField`
    is a `varchar(200)` field by default (this can be set by providing a `max_length`
    argument). `URLField` also comes with validation, checking whether its value is
    a valid web (`http`/`https`/`ftp`/`ftps`) URL. The `blank` argument is used by
    the `admin` app to know whether to require a value (it does not affect the database).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`website = models.URLField(blank=True)`: 大多数数据库没有本机URL列类型，但数据驱动的Web应用程序通常需要存储它们。`URLField`默认情况下是一个`varchar(200)`字段（可以通过提供`max_length`参数来设置）。`URLField`还带有验证，检查其值是否为有效的Web（`http`/`https`/`ftp`/`ftps`）URL。`blank`参数由`admin`应用程序用于知道是否需要值（它不影响数据库）。'
- en: Our model also has a `__str__(self)` method, which is a best practice that helps
    Django convert the model to a string. Django does this in the administrative UI
    and in our own debugging.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型还有一个`__str__(self)`方法，这是一种最佳实践，有助于Django将模型转换为字符串。Django在管理UI和我们自己的调试中都会这样做。
- en: Django's ORM automatically adds an autoincrementing `id` column, so we don't
    have to repeat that on all our models. It's a simple example of Django's **Don't
    Repeat Yourself** **(DRY)** philosophy. We'll take a look at more examples as
    we go along.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Django的ORM自动添加了一个自增的`id`列，因此我们不必在所有模型上重复。这是Django的**不要重复自己**（DRY）哲学的一个简单例子。随着我们的学习，我们将看更多的例子。
- en: Migrating the database
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移数据库
- en: Now that we have a model, we will need to create a table in our database that
    matches it. We will use Django to generate a migration for us and then run the
    migration to create a table for our movie model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个模型，我们需要在数据库中创建一个与之匹配的表。我们将使用Django为我们生成一个迁移，然后运行迁移来为我们的电影模型创建一个表。
- en: 'While Django can create and run migrations for our Django apps, it will not
    create the database and database user for our Django project. To create the database
    and user, we have to connect to the server using an administrator''s account.
    Once we''ve connected we can create the database and user by executing the following
    SQL:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Django可以为我们的Django应用程序创建和运行迁移，但它不会为我们的Django项目创建数据库和数据库用户。要创建数据库和用户，我们必须使用管理员帐户连接到服务器。连接后，我们可以通过执行以下SQL来创建数据库和用户：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The above SQL statements will create the database and user for our Django project.
    The `GRANT` statement ensures that our mymdb user will have access to the database.
    Then, we set a password on the `mymdb` user (make sure it's the same as in your
    `settings.py` file). Finally, we give the `mymdb` user permission to create new
    databases, which will be used by Django to create a test database when running
    tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述SQL语句将为我们的Django项目创建数据库和用户。`GRANT`语句确保我们的mymdb用户将能够访问数据库。然后，我们在`mymdb`用户上设置密码（确保与您的`settings.py`文件中的密码相同）。最后，我们授予`mymdb`用户创建新数据库的权限，这将在运行测试时由Django用于创建测试数据库。
- en: 'To generate a migration for our app, we''ll need to tell `manage.py` file to
    do as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的应用程序生成迁移，我们需要告诉`manage.py`文件执行以下操作：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A `migration` is a Python file in our Django app that describes how to change
    the database into a desired state. Django migrations are not tied to a particular
    database system (the same migrations will work across supported databases, unless
    *we* add database-specific code). Django generates migration files that use Django's
    migrations API, which we won't be looking at in this book, but it's useful to
    know that it exists.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`迁移`是我们Django应用程序中的一个Python文件，描述了如何将数据库更改为所需的状态。Django迁移不绑定到特定的数据库系统（相同的迁移将适用于支持的数据库，除非*我们*添加特定于数据库的代码）。Django生成使用Django的迁移API的迁移文件，我们不会在本书中研究它，但知道它存在是有用的。'
- en: Remember that it's *apps* not *projects* that have migrations (since it's *apps*
    that have models).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，有迁移的是*应用程序*而不是*项目*（因为有*模型*的是*应用程序*）。
- en: 'Next, we tell `manage.py` to migrate our app:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉`manage.py`迁移我们的应用程序：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, our table exists in our database:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据库中存在我们的表：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see that our database has two tables. The default naming scheme for Django's
    model's tables is `<app_name>_<model_name>`. We can tell `core_movie` is the table
    for the `Movie` model from the `core` app. `django_migrations` is for Django's
    internal use to track the migrations that have been applied. Altering the `django_migrations`
    table directly instead of using `manage.py` is a bad idea, which will lead to
    problems when you try to apply or roll back migrations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的数据库有两个表。Django模型表的默认命名方案是`<app_name>_<model_name>`。我们可以看出`core_movie`是`core`应用程序的`Movie`模型的表。`django_migrations`是Django内部用于跟踪已应用的迁移的表。直接修改`django_migrations`表而不使用`manage.py`是一个坏主意，这将在尝试应用或回滚迁移时导致问题。
- en: 'The migration commands can also run without specifying an app, in which case
    it will run on all the apps. Let''s run the `migrate` command without an app:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移命令也可以在不指定应用程序的情况下运行，在这种情况下，它将在所有应用程序上运行。让我们在没有应用程序的情况下运行`migrate`命令：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This creates tables to keep track of users, sessions, permissions, and the administrative
    backend.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建用于跟踪用户、会话、权限和管理后端的表。
- en: Creating our first movie
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个电影
- en: 'Like Python, Django offers an interactive REPL to try things out. The Django
    shell is fully connected to the database, so we can create, query, update, and
    delete models from the shell:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python一样，Django提供了一个交互式REPL来尝试一些东西。Django shell完全连接到数据库，因此我们可以在shell中创建、查询、更新和删除模型：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding Django shell session, note that there are a number of attributes
    of `Movie` that we didn''t create:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的Django shell会话中，请注意我们没有创建的`Movie`的许多属性：
- en: '`objects` is the model''s default manager. Managers are an interface for querying
    the model''s table. It also offers a `create()` method for creating and saving
    an instance. Every model must have at least one manager, and Django offers a default
    manager. It''s often advisable to create a custom manager; we''ll see that later
    in the *Adding Person and model relationships* section.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objects`是模型的默认管理器。管理器是查询模型表的接口。它还提供了一个`create()`方法来创建和保存实例。每个模型必须至少有一个管理器，Django提供了一个默认管理器。通常建议创建一个自定义管理器；我们将在*添加人员和模型关系*部分中看到这一点。'
- en: '`id` is the primary key of the row for this instance. As mentioned in the preceding
    step, Django creates it automatically.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`是此实例的行的主键。如前一步骤中所述，Django会自动创建它。'
- en: '`get_rating_display()` is a method that Django added because the `rating` field
    was given a tuple of `choices`. We didn''t have to provide `rating` with a value
    in our `create()` call because the `rating` field has a `default` value (`0`).
    The `get_rating_display()` method looks up the value and returns the corresponding
    display value. Django will generate a method like this for each `Field` attribute
    with a `choices` argument.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_rating_display()`是Django添加的一个方法，因为`rating`字段给定了一个`choices`元组。我们在`create()`调用中没有为`rating`提供值，因为`rating`字段有一个`default`值（`0`）。`get_rating_display()`方法查找该值并返回相应的显示值。Django将为具有`choices`参数的每个`Field`属性生成这样的方法。'
- en: Next, let's create a backend for managing movies using the Django Admin app.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用Django Admin应用程序创建一个管理电影的后端。
- en: Creating movie admin
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建电影管理
- en: Being able to quickly generate a backend UI lets users to start building the
    content of the project while the rest of the project is still in development.
    It's a nice feature that helps parallelize progress and avoid a repetitious and
    boring task (read/update views share a lot of functionalities). Providing this
    functionality out of the box is another example of Django's Batteries Included
    philosophy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 能够快速生成后端UI让用户在项目的其余部分仍在开发中时开始构建项目的内容。这是一个很好的功能，可以帮助并行化进度并避免重复和乏味的任务（读取/更新视图共享许多功能）。提供这种功能是Django“电池包含”哲学的另一个例子。
- en: 'To get Django''s admin app working with our models, we will perform the following
    steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Django的管理应用程序与我们的模型一起工作，我们将执行以下步骤：
- en: Register our model
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册我们的模型
- en: Create a super user who can access the backend
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可以访问后端的超级用户
- en: Run the development server
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行开发服务器
- en: Access the backend in a browser
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中访问后端
- en: 'Let''s register our `Movie` model with the admin by editing `django/core/admin.py`,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编辑`django/core/admin.py`来注册我们的`Movie`模型，如下所示：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now our model is registered!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模型已注册！
- en: 'Let''s now create a user who can access the backend using `manage.py`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个可以使用`manage.py`访问后端的用户：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Django ships with a **development server** that can serve our app, but is not
    appropriate for production:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Django附带了一个**开发服务器**，可以为我们的应用提供服务，但不适合生产：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, open it in a browser by navigating to `http://localhost:8000/`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在浏览器中打开它，导航到`http://localhost:8000/`：
- en: '![](img/c5d69a74-d95a-4ac1-bc57-b8f9d2989a81.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5d69a74-d95a-4ac1-bc57-b8f9d2989a81.png)'
- en: 'To access the admin backend, go to `http://localhost:8000/admin`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问管理后端，请转到`http://localhost:8000/admin`：
- en: '![](img/e130b85c-4a7d-4ebd-be17-d30cbc878b1a.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e130b85c-4a7d-4ebd-be17-d30cbc878b1a.png)'
- en: 'Once we log in with the credentials, we have to manage users and movies:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用凭据登录，我们必须管理用户和电影：
- en: '![](img/d08ecd07-31c3-428a-b304-eeacc8c92455.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d08ecd07-31c3-428a-b304-eeacc8c92455.png)'
- en: 'Clicking on MOVIES will show us a list of movies:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 点击MOVIES将显示我们的电影列表：
- en: '![](img/82037e20-995e-44f9-b0dc-c8fa391fc008.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82037e20-995e-44f9-b0dc-c8fa391fc008.png)'
- en: 'Note that the title of the link is the result of our `Movie.__str__` method.
    Clicking on it will give you a UI to edit the movie:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，链接的标题是我们的`Movie.__str__`方法的结果。点击它将为您提供一个UI来编辑电影：
- en: '![](img/458293e5-e7b4-4749-96c4-aee88035d581.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/458293e5-e7b4-4749-96c4-aee88035d581.png)'
- en: 'On the main admin screen and on the movie list screen, you have links to add
    a new movie. Let''s add a new movie:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在主管理屏幕和电影列表屏幕上，您可以找到添加新电影的链接。让我们添加一个新电影：
- en: '![](img/71ba97c6-1365-49c5-a547-f0024f46980b.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71ba97c6-1365-49c5-a547-f0024f46980b.png)'
- en: 'Now, our movie list shows both movies:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的电影列表显示了所有电影：
- en: '![](img/6facc9e0-0de1-466b-a991-f78bd53a0662.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6facc9e0-0de1-466b-a991-f78bd53a0662.png)'
- en: Now that we have a way of letting our team populate the database with movies,
    let's start working on the views for our users.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种让团队填充电影数据库的方法，让我们开始为用户编写视图。
- en: Creating MovieList view
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MovieList视图
- en: When Django gets a request, it uses the path of the request and the `URLConf`
    of the project to match a request to a view, which returns an HTTP response. Django's
    views can be either functions, often referred to as **Function-Based Views** (**FBVs**),
    or classes, often called **Class-Based Views** (**CBVs**). The advantage of CBVs
    is that Django comes with a rich suite of generic views that you can subclass
    to easily (almost declaratively) write views to accomplish common tasks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django收到请求时，它使用请求的路径和项目的`URLConf`来匹配请求和视图，后者返回HTTP响应。Django的视图可以是函数，通常称为**基于函数的视图**（**FBVs**），也可以是类，通常称为**基于类的视图**（**CBVs**）。CBVs的优势在于Django附带了丰富的通用视图套件，您可以对其进行子类化，以轻松（几乎是声明性地）编写视图以完成常见任务。
- en: 'Let''s write a view to list the movies that we have. Open `django/core/views.py` and
    change it to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个视图来列出我们拥有的电影。打开`django/core/views.py`并将其更改为以下内容：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`ListView` requires at least a `model` attribute. It will query for all the
    rows of that model, pass it to the template, and return the rendered template
    in a response. It also offers a number of hooks that we may use to replace default
    behavior, which are fully documented.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`至少需要一个`model`属性。它将查询该模型的所有行，将其传递给模板，并返回渲染后的模板响应。它还提供了许多我们可以使用的钩子来替换默认行为，这些都有完整的文档记录。'
- en: How does `ListView` know how to query all the objects in `Movie`? For that,
    we will need to discuss manager and `QuerySet` classes. Every model has a default
    manager. Manager classes are primarily used to query objects by offering methods,
    such as `all()`, that return a `QuerySet`. A `QuerySet` class is Django's representation
    of a query to the database. `QuerySet` has a number of methods, including `filter()`
    (such as a `WHERE` clause in a `SELECT` statement) to limit a result. One of the
    nice features of the `QuerySet` class is that it is lazy; it is not evaluated
    until we try to get a model out of the `QuerySet`. Another nice feature is that
    methods such as `filter()` take *lookup expressions*, which can be field names
    or span across relationship models. We'll be doing this throughout our projects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`如何知道如何查询`Movie`中的所有对象？为此，我们需要讨论管理器和`QuerySet`类。每个模型都有一个默认管理器。管理器类主要用于通过提供方法（例如`all()`）来查询对象，返回`QuerySet`。`QuerySet`类是Django对数据库查询的表示。`QuerySet`有许多方法，包括`filter()`（例如`SELECT`语句中的`WHERE`子句）来限制结果。`QuerySet`类的一个很好的特性是它是惰性的；直到我们尝试从`QuerySet`中获取模型时，它才会被评估。另一个很好的特性是`filter()`等方法采用*查找表达式*，可以是字段名称或跨关系模型。我们将在整个项目中都这样做。'
- en: All manager classes have an `all()` method that should return an unfiltered
    `Queryset`, the equivalent of writing `SELECT * FROM core_movie;`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有管理器类都有一个`all()`方法，应返回一个未经过滤的`Queryset`，相当于编写`SELECT * FROM core_movie;`。
- en: 'So, how does `ListView` know that it has to query all the objects in `Movie`?
    `ListView` checks whether it has a `model` attribute, and, if present, knows that
    `Model` classes have a default manager with a `all()` method, which it calls. `ListView`
    also gives us a convention for where to put our template, as follows: `<app_name>/<model_name>_list.html`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`ListView`如何知道它必须查询`Movie`中的所有对象？`ListView`检查它是否有`model`属性，如果有，它知道`Model`类具有默认管理器，带有`all()`方法，它会调用该方法。`ListView`还为我们提供了放置模板的约定，如下所示：`<app_name>/<model_name>_list.html`。
- en: Adding our first template – movie_list.html
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加我们的第一个模板 - movie_list.html
- en: Django ships with its own template language called the **Django Template language**.
    Django can also use other template languages (for example, Jinja2), but most Django
    projects find using the Django Template language to be efficient and convenient.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Django附带了自己的模板语言，称为**Django模板语言**。Django还可以使用其他模板语言（例如Jinja2），但大多数Django项目发现使用Django模板语言是高效和方便的。
- en: In the default configuration that is generated in our `settings.py` file, the
    Django Template language is configured to use `APP_DIRS`, meaning that each Django
    app can have a `templates` directory, which will be searched to find a template.
    This can be used to override templates that other apps use without having to modify
    the third-party apps themselves.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`settings.py`文件中生成的默认配置中，Django模板语言配置为使用`APP_DIRS`，这意味着每个Django应用程序都可以有一个`templates`目录，该目录将被搜索以找到模板。这可以用来覆盖其他应用程序使用的模板，而无需修改第三方应用程序本身。
- en: 'Let''s make our first template in `django/core/templates/core/movie_list.html`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/core/templates/core/movie_list.html`中创建我们的第一个模板：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Django templates are standard HTML (or whatever text format you wish to use)
    with variables (for example, `object_list` in our example) and tags (for example, `for`
    in our example). Variables will be evaluated to strings by being surrounded with
    `{{ }}`. Filters can be used to help format or modify variables before being printed
    (for example, `yesno`). We can also create custom tags and filters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Django模板是标准的HTML（或者您希望使用的任何文本格式），其中包含变量（例如我们的示例中的`object_list`）和标签（例如我们的示例中的`for`）。变量将通过用`{{
    }}`括起来来评估为字符串。过滤器可以用来在打印之前帮助格式化或修改变量（例如`yesno`）。我们还可以创建自定义标签和过滤器。
- en: A full list of filters and tags is provided in the Django docs ([https://docs.djangoproject.com/en/2.0/ref/templates/builtins/](https://docs.djangoproject.com/en/2.0/ref/templates/builtins/)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Django文档中提供了完整的过滤器和标签列表（[https://docs.djangoproject.com/en/2.0/ref/templates/builtins/](https://docs.djangoproject.com/en/2.0/ref/templates/builtins/)）。
- en: 'The Django template language is configured in the `TEMPLATES` variable of `settings.py`.
    The `DjangoTemplates` backend can take a lot of `OPTIONS`. In d*evelopment*, it
    can be helpful to add `''string_if_invalid'': ''INVALID_VALUE'',`. Any time Django
    can''t match a variable in a template to a variable or tag, it will print out
    `INVALID_VALUE`, which makes it easier to catch typos. Remember that you should
    not use this setting in *Production*. The full list of options is available in
    Django''s documentation ([https://docs.djangoproject.com/en/dev/topics/templates/#django.template.backends.django.DjangoTemplates](https://docs.djangoproject.com/en/dev/topics/templates/#django.template.backends.django.DjangoTemplates)).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'Django模板语言在`settings.py`的`TEMPLATES`变量中进行配置。`DjangoTemplates`后端可以使用很多`OPTIONS`。在*开发*中，添加`''string_if_invalid'':
    ''INVALID_VALUE'',`可能会有所帮助。每当Django无法将模板中的变量匹配到变量或标签时，它将打印出`INVALID_VALUE`，这样更容易捕捉拼写错误。请记住，不要在*生产*中使用此设置。完整的选项列表可以在Django的文档中找到（[https://docs.djangoproject.com/en/dev/topics/templates/#django.template.backends.django.DjangoTemplates](https://docs.djangoproject.com/en/dev/topics/templates/#django.template.backends.django.DjangoTemplates)）。'
- en: The final step will be to connect our view to a `URLConf`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步将是将我们的视图连接到一个`URLConf`。
- en: Routing requests to our view with URLConf
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用URLConf将请求路由到我们的视图
- en: Now that we have a model, view, and template, we will need to tell Django which
    requests it should route to our `MovieList` View using a URLConf. Each new project
    has a root URLConf that created by Django (in our case it's the `django/config/urls.py`
    file). Django developers have developed the best practice of each app having its
    own URLConf. Then, the root URLConf of a project will include each app's URLConf
    using the `include()` function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模型、视图和模板，我们需要告诉Django应该将哪些请求路由到我们的`MovieList`视图使用URLConf。每个新项目都有一个由Django创建的根URLConf（在我们的情况下是`django/config/urls.py`文件）。Django开发人员已经形成了每个应用程序都有自己的URLConf的最佳实践。然后，项目的根URLConf将使用`include()`函数包含每个应用程序的URLConf。
- en: 'Let''s create a URLConf for our `core` app by creating a  `django/core/urls.py` file
    with the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个`django/core/urls.py`文件并使用以下代码来为我们的`core`应用程序创建一个URLConf：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At its simplest, a URLConf is a module with a `urlpatterns` attribute, which
    is a list of `path` s. A `path` is composed of a string that describes a string,
    describing the path in question and a callable. CBVs are not callable, so the
    base `View` class has a static `as_view()` method that *returns* a callable. FBVs
    can just be passed in as a callback (without the `()` operator, which would execute
    them).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，URLConf是一个带有`urlpatterns`属性的模块，其中包含一系列`path`。`path`由描述路径的字符串和可调用对象组成。CBV不是可调用的，因此基本的`View`类有一个静态的`as_view()`方法来*返回*一个可调用对象。FBV可以直接作为回调传递（不需要`()`运算符，这会执行它们）。
- en: Each `path()` should be named, which is a helpful best practice for when we
    have to reference that path in our template. Since a URLConf can be included by
    another URLConf, we may not know the full path to our view. Django offers a `reverse()`
    function and `url` template tag to go from a name to the full path to a view.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`path()`都应该被命名，这是一个有用的最佳实践，当我们需要在模板中引用该路径时。由于一个URLConf可以被另一个URLConf包含，我们可能不知道我们的视图的完整路径。Django提供了`reverse()`函数和`url`模板标签，可以从名称转到视图的完整路径。
- en: The `app_name` variable sets the app that this `URLConf` belongs to. This way,
    we can reference a named `path` without Django getting confused about other apps
    having a `path` of the same name (for example, `index` is a very common name,
    so we can say `appA:index` and `appB:index` to distinguish between them).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`app_name`变量设置了这个`URLConf`所属的应用程序。这样，我们可以引用一个命名的`path`，而不会让Django混淆其他应用程序具有相同名称的`path`（例如，`index`是一个非常常见的名称，所以我们可以说`appA:index`和`appB:index`来区分它们）。'
- en: 'Finally, let''s connect our `URLConf` to the root `URLConf` by changing `django/config/urls.py`
    to the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过将`django/config/urls.py`更改为以下内容来将我们的`URLConf`连接到根`URLConf`：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This file looks much like our file previous `URLConf`, except that our `path()` object
    isn't taking a view but instead the result of the `include()` function. The `include()` function lets
    us prefix an entire `URLConf` with a path and give it a custom namespace.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件看起来很像我们之前的`URLConf`文件，只是我们的`path()`对象不是取一个视图，而是`include()`函数的结果。`include()`函数让我们可以用一个路径前缀整个`URLConf`并给它一个自定义的命名空间。
- en: Namespaces let us distinguish between `path` names like the `app_name` attribute
    does, except without modifying the app (for example, a third-party app).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间让我们区分`path`名称，就像`app_name`属性一样，但不需要修改应用程序（例如，第三方应用程序）。
- en: You might wonder why we're using `include()` but the Django Admin site is using
    `property`? Both `include()` and `admin.site.urls` return similarly formatted
    3-tuple. However, instead of remembering what each portion of the 3-tuple has
    to have, you should just use `include()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为什么我们使用`include()`而Django管理网站使用`property`？`include()`和`admin.site.urls`都返回格式类似的3元组。但是，您应该使用`include()`，而不是记住3元组的每个部分应该具有什么。
- en: Running the development server
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行开发服务器
- en: 'Django now knows how to route requests to our View, which knows the Models
    that need to be shown and which template to render. We can tell `manage.py` to
    start our development server and view our result:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Django现在知道如何将请求路由到我们的View，View知道需要显示哪些模型以及要呈现哪个模板。我们可以告诉`manage.py`启动我们的开发服务器并查看我们的结果：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our browser, go to `http://127.0.0.1:8000/movies`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的浏览器中，转到`http://127.0.0.1:8000/movies`：
- en: '![](img/7f511e2a-1389-4a8b-949e-ec7496d3e5ad.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f511e2a-1389-4a8b-949e-ec7496d3e5ad.png)'
- en: Good job! We made our first page!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们制作了我们的第一个页面！
- en: In this section, we created our first model, generated and ran the migration
    for it, and created a view and template so that users can browse it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们创建了我们的第一个模型，生成并运行了它的迁移，并创建了一个视图和模板，以便用户可以浏览它。
- en: Now, let's add a page for each movie.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为每部电影添加一个页面。
- en: Individual movie pages
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单独的电影页面
- en: Now that we have our project layout, we can move more quickly. We're already
    tracking information for each movie. Let's create a view that will show that information.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了项目布局，我们可以更快地移动。我们已经在跟踪每部电影的信息。让我们创建一个视图来显示这些信息。
- en: 'To add movie details, we''ll need to do the following things:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加电影详细信息，我们需要做以下事情：
- en: Create a `MovieDetail` view
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MovieDetail`视图
- en: Create `movie_detail.html` template
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`movie_detail.html`模板
- en: Reference to our `MovieDetail` view in our `URLConf`
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`URLConf`中引用`MovieDetail`视图
- en: Creating the MovieDetail view
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MovieDetail视图
- en: Just like Django provides us with a `ListView` class to do all the common tasks
    of listing models, Django also provides a `DetailView` class that we can subclass
    to create a view showing the details of a single `Model`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Django为我们提供了一个`ListView`类来执行列出模型的所有常见任务一样，Django还提供了一个`DetailView`类，我们可以子类化以创建显示单个`Model`详细信息的视图。
- en: 'Let’s create our view in `django/core/views.py`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/core/views.py`中创建我们的视图：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A `DetailView` requires that a `path()` object include either a `pk` or `slug`
    in the `path` string so that `DetailView` can pass that value to the `QuerySet` to
    query for a specific model instance. A **slug** is a short URL-friendly label
    that is often used in content-heavy sites, as it is SEO friendly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`DetailView`要求`path()`对象在`path`字符串中包含`pk`或`slug`，以便`DetailView`可以将该值传递给`QuerySet`以查询特定的模型实例。**slug**是一个短的、URL友好的标签，通常在内容丰富的网站中使用，因为它对SEO友好。'
- en: Creating the movie_detail.html template
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建movie_detail.html模板
- en: Now that we have the View, let's make our template.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了View，让我们制作我们的模板。
- en: Django's Template language supports template inheritance, which means that you
    can write a template with all the look and feel for your website and mark the `block` sections
    that other templates will override. This lets us to create the look and feel of
    the entire website without having to edit each template. Let's use this to create
    a base template with MyMDB’s branding and look and feel and then add a Movie Detail
    template that inherits from the base template.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Django的模板语言支持模板继承，这意味着您可以编写一个包含网站外观和感觉的模板，并标记其他模板将覆盖的`block`部分。这使我们能够创建整个网站的外观和感觉，而无需编辑每个模板。让我们使用这个功能创建一个具有MyMDB品牌和外观的基本模板，然后添加一个从基本模板继承的电影详细信息模板。
- en: 'A base template shouldn''t be tied to a particular app, so let''s make a general
    templates directory:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 基本模板不应该与特定的应用程序绑定，因此让我们创建一个通用的模板目录：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Django doesn''t know to check our `templates` directory yet, so we will need
    to update the configuration in our `settings.py` file. Find the line that starts
    with `TEMPLATES` and change the configuration to list our `templates` directory
    in the `DIRS` list:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Django还不知道如何检查我们的`templates`目录，因此我们需要更新`settings.py`文件中的配置。找到以`TEMPLATES`开头的行，并更改配置以在`DIRS`列表中列出我们的`templates`目录：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The only change we've made is that we added our new `templates` directory to
    the list under the `DIRS` key. We have avoided hardcoding the path to our `templates`
    directory using Python's `os.path.join()` function and the already configured
    `BASE_DIR`. `BASE_DIR` is set at runtime to the path of the project. We don't
    need to add `django/core/templates` because the `APP_DIRS` setting tells Django
    to check each app for the `templates` directory.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一做的改变是将我们的新`templates`目录添加到`DIRS`键下的列表中。我们避免使用Python的`os.path.join()`函数和已配置的`BASE_DIR`来将路径硬编码到我们的`templates`目录。`BASE_DIR`在运行时设置为项目的路径。我们不需要添加`django/core/templates`，因为`APP_DIRS`设置告诉Django检查每个应用程序的`templates`目录。
- en: Although it's very convenient that `settings.py` is the Python file where we
    can use `os.path.join` and all of Python, be careful not to get too clever. `settings.py` needs
    to be easy to read and understand. There's nothing worse than having to debug
    your `settings.py`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`settings.py`是一个非常方便的Python文件，我们可以在其中使用`os.path.join`和所有Python的功能，但要小心不要太聪明。`settings.py`需要易于阅读和理解。没有什么比不得不调试你的`settings.py`更糟糕的了。
- en: 'Let''s create a base template in `django/templates/base.html` that has a main
    column and sidebar:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/templates/base.html`中创建一个基本模板，其中有一个主列和侧边栏：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Most of this HTML is actually bootstrap (HTML/CSS framework) boilerplate, but
    we do have a few new Django tags:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML的大部分实际上是bootstrap（HTML/CSS框架）样板，但我们有一些新的Django标签：
- en: '`{% block title %}MyMDB{% endblock %}`: This creates a block that other templates
    can replace. If the block is not replaced, the contents from the parent template
    will be used.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% block title %}MyMDB{% endblock %}`：这创建了一个其他模板可以替换的块。如果未替换该块，则将使用父模板中的内容。'
- en: '`href="{% url ''core:MovieList'' %}"`: The `url` tag will produce a URL path
    for the named `path`. URL names should be referenced as `<app_namespace>:<name>`;
    in our case, `core` is the namespace of the core app (per `django/core/urls.py`),
    and `MovieList` is the name of the `MovieList` view''s URL.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`href="{% url ''core:MovieList'' %}"`：`url`标签将为命名的`path`生成URL路径。URL名称应该被引用为`<app_namespace>:<name>`；在我们的情况下，`core`是核心应用程序的命名空间（在`django/core/urls.py`中），而`MovieList`是`MovieList`视图的URL的名称。'
- en: 'This lets us create a simple template in `django/core/templates/core/movie_detail.html`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以在`django/core/templates/core/movie_detail.html`中创建一个简单的模板：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This template has a lot less HTML in it because `base.html` already has that.
    All `MovieDetail.html` has to do is provide values to the blocks that `base.html`
    defines. Let''s take a look at some new tags:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板的HTML要少得多，因为`base.html`已经有了。`MovieDetail.html`所要做的就是为`base.html`定义的块提供值。让我们来看看一些新标签：
- en: '`{% extends ''base.html'' %}`: If a template wants to extend another template
    the first line must be an `extends` tag. Django will look for the base template
    (which can `extend` another template) and execute it first, then replace the blocks.
    A template that extends another cannot have content outside of `block`s because
    it''s ambiguous where to put that content.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% extends ''base.html'' %}`：如果一个模板想要扩展另一个模板，第一行必须是一个`extends`标签。Django将寻找基本模板（它可以扩展另一个模板）并首先执行它，然后替换块。一个扩展另一个的模板不能在`block`之外有内容，因为不清楚将内容放在哪里。'
- en: '`{{ object.title }} - {{ block.super }}`: We reference `block.super` inside the `title`
    template `block`. `block.super` returns the contents of the `title` template `block`
    in the base template.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ object.title }} - {{ block.super }}`：我们在`title`模板`block`中引用`block.super`。`block.super`返回基本模板中`title`模板`block`的内容。'
- en: '`{{ object.get_rating_display }}`: The Django Template language doesn''t use
    `()` to execute the method, just referencing it by name will execute the method.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ object.get_rating_display }}`：Django模板语言不使用`()`来执行方法，只需通过名称引用它即可执行该方法。'
- en: Adding MovieDetail to core.urls.py
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将MovieDetail添加到core.urls.py
- en: 'Finally, we add our `MovieDetail` view to `core/urls.py`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`MovieDetail`视图添加到`core/urls.py`：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `MovieDetail` and `MovieList` `path()` calls both look almost the same,
    except for the `MovieDetail` string that has a named parameter. A `path` route
    string can include angle brackets to give a parameter a name (for example, `<pk>`)
    and even define a type that the parameter's content must conform to (for example,
    `<int:pk>` will only match values that parse as an `int`). These named sections
    are captured by Django and passed to the view by name. `DetailView` expects a `pk`
    (or `slug`) argument and uses it to get the correct row from the database.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`MovieDetail`和`MovieList`的`path()`调用几乎看起来一样，只是`MovieDetail`字符串有一个命名参数。`path`路由字符串可以包括尖括号，给参数一个名称（例如，`<pk>`），甚至定义参数的内容必须符合的类型（例如，`<int:pk>`只匹配解析为`int`的值）。这些命名部分被Django捕获并按名称传递给视图。`DetailView`期望一个`pk`（或`slug`）参数，并使用它从数据库中获取正确的行。'
- en: 'Let''s use `python manage.py runserver` to start the `dev` server and take
    a look at what our new template looks like:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`python manage.py runserver`来启动`dev`服务器，看看我们的新模板是什么样子的：
- en: '![](img/3094cb49-5280-4a44-a4b0-437e42dfc6be.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3094cb49-5280-4a44-a4b0-437e42dfc6be.png)'
- en: A quick review of the section
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾本节
- en: In this section, we've created a new view, `MovieDetail`, learned about template
    inheritance, and how to pass parameters from a URL path to our view.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个新视图`MovieDetail`，学习了模板继承，以及如何将参数从URL路径传递给我们的视图。
- en: Next, we'll add pagination to our `MovieList` view to prevent it from querying
    the entire database each time.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的`MovieList`视图添加分页，以防止每次查询整个数据库。
- en: Pagination and linking movie list to movie details
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页和将电影列表链接到电影详情
- en: In this section, we'll update our movie list to provide a link to each movie
    and to have pagination to prevent our entire database being dumped into one page.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将更新我们的电影列表，为每部电影提供一个链接，并进行分页，以防止我们的整个数据库被倾倒到一个页面上。
- en: Updating MovieList.html to extend base.html
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新MovieList.html以扩展base.html
- en: 'Our original `MovieList.html` was a pretty sparse affair. Let''s update it
    to look nicer using our `base.html` template and the bootstrap CSS it provides:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原来的`MovieList.html`是一个相当简陋的事情。让我们使用我们的`base.html`模板和它提供的bootstrap CSS来更新它，使它看起来更好看：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We're also seeing the `url` tag being used with a named argument `pk` because
    the `MovieDetail` URL requires a `pk` argument. If there was no argument provided,
    then Django would raise a `NoReverseMatch` exception on rendering, resulting in
    a `500` error.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到`url`标签与命名参数`pk`一起使用，因为`MovieDetail` URL需要一个`pk`参数。如果没有提供参数，那么Django在渲染时会引发`NoReverseMatch`异常，导致`500`错误。
- en: 'Let''s take a look at what it looks like:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它是什么样子的：
- en: '![](img/b0cc7929-c9da-46a7-afba-de85b9d7d5ef.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0cc7929-c9da-46a7-afba-de85b9d7d5ef.png)'
- en: Setting the order
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置订单
- en: Another problem with our current view is that it's not ordered. If the database
    is returning an unordered query, then pagination won't help navigation. What's
    more, there's no guarantee that each time the user changes pages that the content
    will be consistent, as the database may return a differently ordered result set
    for each time. We need our query to be ordered consistently.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前视图的另一个问题是它没有排序。如果数据库返回的是无序查询，那么分页就无法帮助导航。而且，每次用户更改页面时，内容都不一致，因为数据库可能会返回一个不同顺序的结果集。我们需要我们的查询有一致的顺序。
- en: Ordering our model also makes our lives as developers easier too. Whether using
    a debugger, writing tests, or running a shell ensuring that our models are returned
    in a consistent order can make troubleshooting simpler.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的模型进行排序也可以让开发人员的生活更轻松。无论是使用调试器、编写测试，还是运行shell，确保我们的模型以一致的顺序返回可以使故障排除变得更简单。
- en: 'A Django model may optionally have an inner class called `Meta`, which lets
    us specify information about a Model. Let''s add a `Meta` class with an `ordering`
    attribute:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Django模型可以选择具有一个名为`Meta`的内部类，它让我们指定有关模型的信息。让我们添加一个带有`ordering`属性的`Meta`类：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`ordering` takes a list or tuple of, usually, strings that are field names,
    optionally prefixed by a `-` character that denotes descending order. `(''-year'',
    ''title'')` is the equivalent of the SQL clause `ORDER BY year DESC, title`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`ordering`接受一个列表或元组，通常是字段名称的字符串，可选地以`-`字符为前缀，表示降序。`(''-year'', ''title'')`相当于SQL子句`ORDER
    BY year DESC, title`。'
- en: Adding `ordering` to a Model's `Meta` class will mean that `QuerySets` from
    the model's manager will be ordered.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ordering`添加到模型的`Meta`类中意味着来自模型管理器的`QuerySets`将被排序。
- en: Adding pagination
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分页
- en: Now that our movies are always ordered the same way, let's add pagination. A
    Django `ListView` already has built-in support for pagination, so all we need
    to do is take advantage of it. **Pagination** is controlled by the `GET` parameter
    `page` that controls which page to show.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的电影总是以相同的方式排序，让我们添加分页。Django的`ListView`已经内置了对分页的支持，所以我们只需要利用它。**分页**由控制要显示的页面的`GET`参数`page`控制。
- en: 'Let''s add pagination to the bottom of our `main` template `block`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`main`模板`block`底部添加分页：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s take a look at some important points of our `MovieList` template:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们的`MovieList`模板的一些重要点：
- en: '`page_obj` is of the `Page` type, which knows information about this page of
    results. We use it to check whether there is a next/previous page using `has_next()`/`has_previous()`
    (we don''t need to put `()` in the Django template language, but `has_next()`
    is a method, not a property). We also use it to get the `next_page_number()`/`previous_page_number()`.
    Note that it is important to use the `has_*()` method to check for the existence
    of  the next/previous page numbers before retrieving them. If they don''t exist
    when retrieved, `Page` throws an `EmptyPage` exception.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page_obj`是`Page`类型，知道有关此结果页面的信息。我们使用它来检查是否有下一页/上一页，使用`has_next()`/`has_previous()`（在Django模板语言中，我们不需要在`()`中放置`()`，但`has_next()`是一个方法，而不是属性）。我们还使用它来获取`next_page_number()`/`previous_page_number()`。请注意，在检索下一页/上一页数字之前使用`has_*()`方法检查其存在性非常重要。如果在检索时它们不存在，`Page`会抛出`EmptyPage`异常。'
- en: '`object_list` continues to be available and hold the correct values. Even though
    `page_obj` encapsulates the results for this page in `page_obj.object_list`, `ListView`
    does the convenient work of ensuring that we can continue to use `object_list`
    and our template doesn''t break.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object_list`仍然可用并保存正确的值。即使`page_obj`封装了此页面的结果在`page_obj.object_list`中，`ListView`也方便地确保我们可以继续使用`object_list`，而我们的模板不会中断。'
- en: We now have the pagination working!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有分页功能了！
- en: 404 – for when things go missing
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 404-当事物丢失时
- en: We now have a couple of views that can't function if given the wrong value in
    the URL (the wrong `pk` will break `MovieDetail`; the wrong `page` will break
    `MovieList`); let’s plan for that by handling `404` errors. Django offers a hook
    in the root URLConf to let us use a custom view for `404` errors (also for `403`,
    `400`, and `500`—all following the same names scheme). In your root `urls.py` file,
    add a variable called `handler404` whose value is a string Python path to your
    custom view.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些视图，如果在URL中给出错误的值（错误的`pk`将破坏`MovieDetail`；错误的`page`将破坏`MovieList`），它们将无法正常运行；让我们通过处理`404`错误来解决这个问题。Django在根URLConf中提供了一个钩子，让我们可以使用自定义视图来处理`404`错误（也适用于`403`、`400`和`500`，都遵循相同的命名方案）。在您的根`urls.py`文件中，添加一个名为`handler404`的变量，其值是指向您自定义视图的Python路径的字符串。
- en: 'However, we can continue to use the default `404` handler view and just write
    a custom template. Let''s add a `404` template in `django/templates/404.html`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以继续使用默认的`404`处理程序视图，并只编写一个自定义模板。让我们在`django/templates/404.html`中添加一个`404`模板：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Even if another app throws a `404` error, this template will be used.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 即使另一个应用程序抛出`404`错误，也将使用此模板。
- en: 'At the moment, if you''ve got an unused URL such as `http://localhost:8000/not-a-real-page`,
    you won''t see our custom 404 template because Django''s `DEBUG` settings is `True`
    in `settings.py`. To make our 404 template visible, we will need to change the
    `DEBUG` and `ALLOWED_HOSTS` settings in `settings.py`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果您有一个未使用的URL，例如`http://localhost:8000/not-a-real-page`，您将看不到我们的自定义404模板，因为Django的`settings.py`中的`DEBUG`设置为`True`。要使我们的404模板可见，我们需要更改`settings.py`中的`DEBUG`和`ALLOWED_HOSTS`设置：
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`ALLOWED_HOSTS` is a setting that restricts which `HOST` values in an HTTP
    request Django will respond to. If `DEBUG` is `False` and a `HOST` does not match
    an `ALLOWED_HOSTS` value, then Django will return a `400` error (you can customize
    both the view and template for this error as described in the preceding code).
    This is a security feature that protects us and will be discussed more in our
    chapter on security.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALLOWED_HOSTS`是一个设置，限制Django将响应的HTTP请求中的`HOST`值。如果`DEBUG`为`False`，并且`HOST`不匹配`ALLOWED_HOSTS`值，则Django将返回`400`错误（您可以根据前面的代码自定义此错误的视图和模板）。这是一项保护我们的安全功能，将在我们的安全章节中更多地讨论。'
- en: 'Now that our project is configured, let''s run the Django development server:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目已配置好，让我们运行Django开发服务器：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With it running, we can use our web browser to open [http://localhost:8000/not-a-real-page](http://localhost:8000/not-a-real-page).
    Our results should look like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，我们可以使用我们的网络浏览器打开[http://localhost:8000/not-a-real-page](http://localhost:8000/not-a-real-page)。我们的结果应该是这样的：
- en: '![](img/6681144e-cf38-4fe2-9d54-eb011487af6c.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6681144e-cf38-4fe2-9d54-eb011487af6c.png)'
- en: Testing our view and template
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的视图和模板
- en: Since we now have some logic in our `MoveList` template, let's write some tests.
    We'll talk a lot more about testing in the [Chapter 8](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml),
    *Testing Answerly*. However, the basics are simple and follow the common XUnit
    pattern of the `TestCase` classes holding test methods that make assertions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在在`MoveList`模板中有一些逻辑，让我们写一些测试。我们将在[第8章](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml)
    *测试Answerly*中更多地讨论测试。但是，基础知识很简单，遵循常见的XUnit模式，即`TestCase`类包含进行断言的测试方法。
- en: For Django's `TestRunner` to find a test, it must be in the `tests` module of
    an installed app. Right now, that means `tests.py`, but, eventually, you may wish
    to switch to a directory Python module (in which case, prefix your test filenames
    with `test` for the `TestRunner` to find them).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Django的`TestRunner`来找到一个测试，它必须在已安装应用的`tests`模块中。现在，这意味着`tests.py`，但是，最终，您可能希望切换到一个目录Python模块（在这种情况下，为了让`TestRunner`找到它们，为您的测试文件名加上`test`前缀）。
- en: 'Let''s add a test that performs the following functions:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个执行以下功能的测试：
- en: If there's more than 10 movies, then pagination controls should be rendered
    in the template
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有超过10部电影，那么分页控件应该在模板中呈现
- en: 'If there''s more than 10 movies and we don''t provide `page` `GET` parameters,
    consider the following things:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有超过10部电影，而我们没有提供`page` `GET`参数，请考虑以下事项：
- en: The `page_is_last` context variable should be `False`
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page_is_last`上下文变量应该是`False`'
- en: The `page_is_first` context variable should be `True`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page_is_first`上下文变量应该是`True`'
- en: The first item in the pagination should be marked as active
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页中的第一项应该被标记为活动状态
- en: 'The following is our `tests.py` file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`tests.py`文件：
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s take a look at some interesting points:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些有趣的地方：
- en: '`class MovieListPaginationTestCase(TestCase)`: `TestCase` is the base class
    for all Django tests. It has a number of conveniences built in, including a number
    of convenient assert methods.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class MovieListPaginationTestCase(TestCase)`: `TestCase`是所有Django测试的基类。它内置了许多便利功能，包括许多方便的断言方法。'
- en: '`def setUp(self)`: Like most XUnit testing frameworks, Django''s `TestCase`
    class offers a `setUp()` hook that is run before each test. A `tearDown()` hook
    is also available if needed. The database is cleaned up between each test, so
    we don''t need to worry about deleting any models we added.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def setUp(self)`: 像大多数XUnit测试框架一样，Django的`TestCase`类提供了一个在每个测试之前运行的`setUp()`钩子。如果需要，还可以使用`tearDown()`钩子。在每个测试之间清理数据库，因此我们不需要担心删除任何我们添加的模型。'
- en: '`def testFirstPage(self):`: A method is a test if its name is prefixed with
    `test`.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def testFirstPage(self):`: 如果方法的名称以`test`开头，那么它就是一个测试方法。'
- en: '`movie_list_path = reverse(''core:MovieList'')`: `reverse()` was mentioned
    before and is the Python equivalent of the `url` Django template tag. It will
    resolve the name into a path.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie_list_path = reverse(''core:MovieList'')`: `reverse()`之前提到过，它是`url` Django模板标签的Python等价物。它将解析名称为路径。'
- en: '`request = RequestFactory().get(path=movie_list_path)`: `RequestFactory` is
    a convenient factory for creating fake HTTP requests. A `RequestFactory` has convenience
    methods for creating `GET`, `POST`, and `PUT` requests by its convenience methods
    named after the verb (for example, `get()` for `GET` requests). In our case, the
    `path` object provided doesn''t matter, but other views may want to inspect the
    path of the request.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request = RequestFactory().get(path=movie_list_path)`: `RequestFactory`是一个方便的工厂，用于创建虚拟的HTTP请求。`RequestFactory`具有创建`GET`、`POST`和`PUT`请求的便利方法，这些方法以动词命名（例如，`get()`用于`GET`请求）。在我们的情况下，提供的`path`对象并不重要，但其他视图可能希望检查请求的路径。'
- en: '`self.assertEqual(200, response.status_code)`: This asserts that the two arguments
    are equal. A response''s `status_code` to check success or failure (`200` being
    the status code for success—the one code you never see when you browse the web).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertEqual(200, response.status_code)`: 这断言两个参数是否相等。检查响应的`status_code`以检查成功或失败（`200`是成功的状态代码——在浏览网页时从不会看到的代码）。'
- en: '`self.assertTrue(response.context_data[''is_paginated''])`: This asserts that
    the argument evaluates to `True`. `response` exposes the context that is used
    in rendering the template. This makes finding bugs much easier as you can quickly
    check actual values used in rendering.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertTrue(response.context_data[''is_paginated''])`：这断言该参数评估为`True`。`response`公开了在渲染模板中使用的上下文。这使得查找错误变得更容易，因为您可以快速检查在渲染中使用的实际值。'
- en: '`self.assertInHTML(`: `assertInHTML` is one of the many convenient methods
    that Django provides as part of its **Batteries Included** philosophy. Given a
    valid HTML string `needle` and valid HTML string `haystack`, it will assert that
    `needle` is in `haystack`. The two strings need to be valid HTML because Django
    will parse them and examine whether one is inside the other. You don''t need to
    worry about spacing or the order of attributes/classes. It''s a very convenient
    assertion when you try to ensure that templates are working right.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertInHTML(`: `assertInHTML`是Django提供的许多便利方法之一，作为其**一揽子**哲学的一部分。给定一个有效的HTML字符串`needle`和有效的HTML字符串`haystack`，它将断言`needle`是否在`haystack`中。这两个字符串需要是有效的HTML，因为Django将解析它们并检查一个是否在另一个中。您不需要担心间距或属性/类的顺序。当您尝试确保模板正常工作时，这是一个非常方便的断言。'
- en: 'To run tests, we can use `manage.py`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们可以使用`manage.py`：
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, we can be confident that we've got pagination working right.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以确信我们已经正确地实现了分页。
- en: Adding Person and model relationships
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加人物和模型关系
- en: In this section, we will add relationships between models to our project. People's
    relationship to movies can create a complex data model. The same person can be
    the actor, writer, and director (for example, *The Apostle* (1997) written, directed,
    and starring Robert Duvall). Even leaving out the crew and production teams and
    simplifying a bit, the data model will involve a one-to-many relationship using
    a `ForiengKey` field, a many-to-many relationship using a `ManyToManyField`, and
    a class that adds extra information about a many-to-many relationship using a
    `through` class in a `ManyToManyField`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在项目中为模型添加关系。人物与电影的关系可以创建一个复杂的数据模型。同一个人可以是演员、作家和导演（例如，*The Apostle*（1997）由Robert
    Duvall编写、导演和主演）。即使忽略了工作人员和制作团队并简化了一些，数据模型将涉及使用`ForiengKey`字段的一对多关系，使用`ManyToManyField`的多对多关系，以及使用`ManyToManyField`中的`through`类添加关于多对多关系的额外信息的类。
- en: 'In this section, we will do the following things step by step:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步执行以下操作：
- en: Create a `Person` model
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Person`模型
- en: Add a `ForeignKey` field from `Movie` to `Person` to track the director
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Movie`到`Person`添加一个`ForeignKey`字段以跟踪导演
- en: Add a `ManyToManyField` from `Movie` to `Person` to track the writers
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Movie`到`Person`添加一个`ManyToManyField`来跟踪编剧
- en: Add a `ManyToManyField` with a `through` class (`Actor`) to track who performed
    and in what role in a Movie
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有`through`类（`Actor`）的`ManyToManyField`来跟踪谁在电影中扮演了什么角色
- en: Create the migration
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建迁移
- en: Add the director, writer, and actors to the movie details template
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将导演、编剧和演员添加到电影详情模板
- en: Add a `PersonDetail` view to the list that indicates what movies a Person has
    directed, written, and performed in
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为列表添加一个`PersonDetail`视图，指示一个人导演了哪些电影，写了哪些电影，以及在哪些电影中表演了
- en: Adding a model with relationships
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加具有关系的模型
- en: 'First, we will need a `Person` class to describe and store a person involved
    in a movie:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个`Person`类来描述和存储参与电影的人：
- en: '[PRE39]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In `Person`, we also see a new field (`DateField`) and a new parameter for fields
    (`null`).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Person`中，我们还看到了一个新字段（`DateField`）和字段的一个新参数（`null`）。
- en: '`DateField` is used for tracking date-based data, using the appropriate column
    type on the database (`date` on Postgres) and `datetime.date` in Python. Django
    also offers a `DateTimeField` to store the date and time.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateField`用于跟踪基于日期的数据，使用数据库上的适当列类型（Postgres上的`date`）和Python中的`datetime.date`。Django还提供了`DateTimeField`来存储日期和时间。'
- en: All fields support the `null` parameter (`False` by default), which indicates
    whether the column should accept `NULL` SQL values (represented by `None` in Python).
    We mark `died` as supporting `null` so that we can record people as living or
    dead. Then, in the `__str__()` method we print out a different string representation
    if someone is alive or dead.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字段都支持`null`参数（默认为`False`），它指示列是否应该接受`NULL` SQL值（在Python中表示为`None`）。我们将`died`标记为支持`null`，以便我们可以记录人是活着还是死了。然后，在`__str__()`方法中，如果某人是活着的或死了，我们打印出不同的字符串表示。
- en: We now have the `Person` model that can have various relationships with `Movies`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Person`模型，它可以与`Movies`有各种关系。
- en: Different types of relationship fields
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的关系字段
- en: Django's ORM has support for fields that map relationships between models, including
    one-to-many, many-to-many, and many-to-many with an intermediary model.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Django的ORM支持映射模型之间的关系的字段，包括一对多、多对多和带有中间模型的多对多。
- en: When two models have a one-to-many relationship, we use a `ForeignKey` field,
    which will create a column with a **Foreign Key** (**FK**) constraint (assuming
    that there is database support) between the two tables. In the model without the
    `ForeignKey` field, Django will automatically add a `RelatedManager` object as
    an instance attribute. The `RelatedManager` class makes it easier to query for
    objects in a relationship. We'll take a look at examples of this in the following
    sections.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个模型有一对多的关系时，我们使用`ForeignKey`字段，它将在两个表之间创建一个带有**外键**（**FK**）约束的列（假设有数据库支持）。在没有`ForeignKey`字段的模型中，Django将自动添加`RelatedManager`对象作为实例属性。`RelatedManager`类使得在关系中查询对象更容易。我们将在以下部分看一些例子。
- en: When two models have a many-to-many relationship, either (but not both) of them
    can get the `ManyToManyField()`; Django will create a `RelatedManager` on the
    other side for you. As you may know, relational databases cannot actually have
    a many-to-many relationship between two tables. Rather, relational databases require
    a *bridging* table with foreign keys to each of related tables. Assuming that
    we don’t want to add any attributes describing the relationship, Django will create
    and manage this bridging table for us automatically.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个模型有多对多的关系时，它们中的一个（但不是两者）可以得到`ManyToManyField()`；Django将在另一侧为你创建一个`RelatedManager`。正如你可能知道的，关系数据库实际上不能在两个表之间有多对多的关系。相反，关系数据库需要一个*桥接*表，其中包含到每个相关表的外键。假设我们不想添加任何描述关系的属性，Django将自动为我们创建和管理这个桥接表。
- en: Sometimes, we want extra fields to describe a many-to-many relationship (for
    example, when it started or ended); for that, we can provide a `ManyToManyField`
    with a `through` model (sometimes called an association class in UML/OO). This
    model will have a `ForeignKey` to each side of the relationship and any extra
    fields we want.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要额外的字段来描述多对多的关系（例如，它何时开始或结束）；为此，我们可以提供一个带有`through`模型的`ManyToManyField`（有时在UML/OO中称为关联类）。这个模型将对关系的每一侧都有一个`ForeignKey`和我们想要的任何额外字段。
- en: We'll create an example of each of these, as we go along adding directors, writers,
    and actors into our `Movie` model.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加导演、编剧和演员到我们的`Movie`模型时，我们将为每一个创建一个例子。
- en: Director – ForeignKey
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导演 - 外键
- en: 'In our model, we will say that each movie can have one director, but each director
    can have directed many movies. Let''s use the `ForiengKey` field to add a director
    to our movie:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模型中，我们将说每部电影可以有一个导演，但每个导演可以导演很多电影。让我们使用`ForiengKey`字段来为我们的电影添加一个导演：
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s take a look at our new field line by line:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看我们的新字段：
- en: '`to=''Person''`: All of Django''s relationship fields can take a string reference
    as well as reference to the related model. This argument is required.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to=''Person''`：Django的所有关系字段都可以接受字符串引用以及对相关模型的引用。这个参数是必需的。'
- en: '`on_delete=models.SET_NULL`: Django needs instruction on what to do when the
    referenced model (instance/row) is deleted. `SET_NULL` will set the `director` field
    of all the `Movie`  model instances directed by the deleted `Person` to `NULL`. If
    we wanted to cascade deletes we would use the `models.CASCADE` object.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_delete=models.SET_NULL`: Django需要指示在引用的模型（实例/行）被删除时该怎么做。`SET_NULL`将把所有由已删除的`Person`导演的`Movie`模型实例的`director`字段设置为`NULL`。如果我们想要级联删除，我们将使用`models.CASCADE`对象。'
- en: '`related_name=''directed''`: This is an optional argument that indicates the
    name of the `RelatedManager` instance on the other model (which lets us query
    all the `Movie` model instances a `Person` directed). If `related_name` were not
    provided, then `Person` would get an attribute called `movie_set` (following the `<model
    with FK>_set` pattern). In our case, we will have multiple different relationships
    between `Movie` and `Person` (writer, director, and actors), so `movie_set` would
    become ambiguous, and we must provide a `related_name`.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`related_name=''directed''`：这是一个可选参数，表示另一个模型上的`RelatedManager`实例的名称（它让我们查询`Person`导演的所有`Movie`模型实例）。如果没有提供`related_name`，那么`Person`将得到一个名为`movie_set`的属性（遵循`<具有FK的模型>_set`模式）。在我们的情况下，我们将在`Movie`和`Person`之间有多个不同的关系（编剧，导演和演员），所以`movie_set`将变得模糊不清，我们必须提供一个`related_name`。'
- en: This is also the first time we're adding a field to an existing model. When
    doing so, we have to *either* add `null=True` or offer a `default` value. If we
    do not, then the migration will force us to. This requirement exists because Django
    has to assume that there are existing rows in the table (even if there aren't)
    when the migration is run. When a database adds the new column, it needs to know
    what it should insert into existing rows. In the case of the `director` field,
    we can accept that it may sometimes be `NULL`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们第一次向现有模型添加字段。在这样做时，我们必须*要么*添加`null=True`，*要么*提供一个`default`值。如果不这样做，那么迁移将强制我们这样做。这是因为Django必须假设在迁移运行时表中存在现有行（即使没有），当数据库添加新列时，它需要知道应该插入现有行的内容。在`director`字段的情况下，我们可以接受它有时可能是`NULL`。
- en: We have now added a field to `Movie` and a new attribute to `Person` instances
    called `directed` (of the `RelatedManager` type). `RelatedManager` is a very useful
    class that is like a model’s default Manager, but automatically manages the relationship
    across the two models.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经向`Movie`添加了一个字段，并向`Person`实例添加了一个名为`directed`的新属性（类型为`RelatedManager`）。`RelatedManager`是一个非常有用的类，它类似于模型的默认Manager，但自动管理两个模型之间的关系。
- en: Let's take a look at `person.directed.create()` and compare it to `Movie.objects.create()`.
    Both methods will create a new `Movie`, but `person.directed.create()` will make
    sure that the new `Movie` has `person` as its `director`. `RelatedManager` also
    offers the `add` and `remove` methods so that we can add a `Movie` to a `directed`
    set of `Person` by calling `person.directed.add(movie)`. There's also a `remove()`
    method that works similarly, but removes a model from the relationship.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`person.directed.create()`并将其与`Movie.objects.create()`进行比较。这两种方法都将创建一个新的`Movie`，但`person.directed.create()`将确保新的`Movie`将`person`作为其`director`。`RelatedManager`还提供了`add`和`remove`方法，以便我们可以通过调用`person.directed.add(movie)`将`Movie`添加到`Person`的`directed`集合中。还有一个类似的`remove()`方法，但是从关系中删除一个模型。
- en: Writers – ManyToManyField
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Writers - ManyToManyField
- en: 'Two models may also have a many-to-many relationship, for example, a person
    may write many movies and a movie may be written by many people. Next, we''ll
    add a `writers` field to our `Movie` model:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模型也可以有多对多的关系，例如，一个人可以写很多电影，一个电影也可以由很多人写。接下来，我们将在我们的`Movie`模型中添加一个`writers`字段：
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A `ManyToManyField` established a many-to-many relationship and acts like a
    `RelatedManager`, permitting users to query and create models. We again use the `related_name`
    to avoid giving `Person` a `movie_set` attribute and instead give it a `writing_credits`
    attribute that will be a `RelatedManager`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManyToManyField`建立了一个多对多的关系，并且像`RelatedManager`一样，允许用户查询和创建模型。我们再次使用`related_name`来避免给`Person`一个`movie_set`属性，而是给它一个`writing_credits`属性，它将是一个`RelatedManager`。'
- en: In the case of a `ManyToManyField`, both sides of the relationship have `RelatedManager`
    s so that `person.writing_credits.add(movie)` has the same effect as writing `movie.writers.add(person)`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ManyToManyField`的情况下，关系的两侧都有`RelatedManager`，因此`person.writing_credits.add(movie)`的效果与写`movie.writers.add(person)`相同。
- en: Role – ManyToManyField with a through class
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Role - 通过类的ManyToManyField
- en: The last example of a relationship field we'll look at is used when we want
    to use an intermediary model to describe the relationship between two other models
    that have a many-to-many relationship. Django lets us do this by creating a model
    that describes the *join table* between the two models in a many-to-many relationship.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个关系字段的最后一个例子，当我们想要使用一个中间模型来描述两个其他模型之间的多对多关系时使用。Django允许我们通过创建一个模型来描述两个多对多关系模型之间的*连接表*来实现这一点。
- en: 'In our case, we will create a many-to-many relationship between `Movie` and
    `Person` through `Role`, which will have a `name` attribute:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将通过`Role`在`Movie`和`Person`之间创建一个多对多关系，它将有一个`name`属性：
- en: '[PRE42]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This looks like the preceding `ManyToManyField`, except we have both a `to`
    (referencing `Person` as before) argument and a `through` (referencing `Role`)
    argument.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像前面的`ManyToManyField`，只是我们有一个`to`（引用`Person`）参数和一个`through`（引用`Role`）参数。
- en: The `Role` model looks much like one would design a *join table*; it has a `ForeignKey`
    to each side of the many-to-many relationship. It also has an extra field called `name`
    to describe the role.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role`模型看起来很像一个*连接表*的设计；它对多对多关系的每一侧都有一个`ForeignKey`。它还有一个额外的字段叫做`name`来描述角色。'
- en: '`Role` also has a unique constraint on it. It requires that `movie`, `person`,
    and `billing` all to be unique together; setting the `unique_together` attribute
    on the `Meta` class of `Role` will prevent duplicate data.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role`还对其进行了唯一约束。它要求`movie`，`person`和`billing`一起是唯一的；在`Role`的`Meta`类上设置`unique_together`属性将防止重复数据。'
- en: 'This user of `ManyToManyField` will create four new `RelatedManager` instances:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用`ManyToManyField`将创建四个新的`RelatedManager`实例：
- en: '`movie.actors` will be a related manager to `Person`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie.actors`将是`Person`的相关管理器'
- en: '`person.acting_credits` will be a related manager to `Movie`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person.acting_credits`将是`Movie`的相关管理器'
- en: '`movie.role_set` will be a related manager to `Role`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie.role_set`将是`Role`的相关管理器'
- en: '`person.role_set` will be a related manager to `Role`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person.role_set`将是`Role`的相关管理器'
- en: We can use any of the managers to query models but only the `role_set` managers
    to create models or modify relationships because of the intermediary class. Django
    will throw an `IntegrityError` exception if you try to run `movie.actors.add(person)`
    because there’s no way to fill in the value for `Role.name`. However, you can
    write `movie.role_set.add(person=person, name='Hamlet')`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何管理器来查询模型，但只能使用`role_set`管理器来创建模型或修改关系，因为存在中间类。如果尝试运行`movie.actors.add(person)`，Django将抛出`IntegrityError`异常，因为没有办法填写`Role.name`的值。但是，您可以编写`movie.role_set.add(person=person,
    name='Hamlet')`。
- en: Adding the migration
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加迁移
- en: 'Now, we can generate a migration for our new models:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的新模型生成一个迁移：
- en: '[PRE43]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we can run our migration so that the changes get applied:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行我们的迁移，以应用这些更改：
- en: '[PRE44]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, let's make our movie pages link to the people in the movies.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们让我们的电影页面链接到电影中的人物。
- en: Creating a PersonView and updating MovieList
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个PersonView并更新MovieList
- en: 'Let''s add a `PersonDetail` view that our `movie_detail.html` template can
    link to. To create our view, we''ll go through a four-step process:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`PersonDetail`视图，我们的`movie_detail.html`模板可以链接到。为了创建我们的视图，我们将经历一个四步过程：
- en: Create a manager to limit the number of database queries
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管理器来限制数据库查询的数量
- en: Create our view
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的视图
- en: Create our template
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的模板
- en: Create a URL that references our view
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建引用我们视图的URL
- en: Creating a custom manager – PersonManager
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义管理器-PersonManager
- en: Our `PersonDetail` view will list all the movies in which a `Person` is acting,
    writing, or directing credits. In our template, we will print out the name of
    each film in each credit (and `Role.name` for the acting credits). To avoid sending
    a flood of queries to the database, we will create new managers for our models
    that will return smarter `QuerySet` s.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PersonDetail`视图将列出一个`Person`在其中扮演、编写或导演的所有电影。在我们的模板中，我们将打印出每个角色中每部电影的名称（以及扮演角色的`Role.name`）。为了避免向数据库发送大量查询，我们将为我们的模型创建新的管理器，这些管理器将返回更智能的`QuerySet`。
- en: In Django, any time we access a property across a relationship, then Django
    will query the database to get the related item (in the case of looping over each
    item `person.role_set.all()`, one for each related `Role`). In the case of a `Person`
    who is in *N* movies, this will result in *N* queries to the database. We can
    avoid this situation with the `prefetch_related()` method (later we will look
    at `select_related()` method). Using the `prefetch_related()` method, Django will
    query all the related data across a single relationship in a single additional
    query. However, if we don't end up using the prefetched data, querying for it
    will waste time and memory.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，每当我们跨越关系访问属性时，Django将查询数据库以获取相关项目（例如在每个相关`Role`上循环时`person.role_set.all()`，对于每个相关`Role`）。对于出演*N*部电影的`Person`，这将导致*N*次数据库查询。我们可以使用`prefetch_related()`方法避免这种情况（稍后我们将看到`select_related()`方法）。使用`prefetch_related()`方法，Django将在单个附加查询中查询单个关系的所有相关数据。但是，如果我们最终没有使用预取的数据，查询它将浪费时间和内存。
- en: 'Let''s create a `PersonManager` with a new method, `all_with_prefetch_movies()`,
    and make it the default manager for `Person`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`PersonManager`，其中包含一个新的方法`all_with_prefetch_movies()`，并将其设置为`Person`的默认管理器：
- en: '[PRE45]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our `PersonManager` will still offer all the same methods as the default because
    `PersonManager` inherits from `models.Manager`. We also define a new method, which
    uses `get_queryset()` to get a `QuerySet`, and tells it to prefetch the related
    models. `QuerySets` are lazy, so no communication with the database happens until
    the query set is evaluated (for example by, iteration, casting to a bool, slicing,
    or evaluated by an `if` statement). `DetailView` won't evaluate the query until
    it uses `get()` to get the model by PK.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PersonManager`仍将提供与默认相同的所有方法，因为`PersonManager`继承自`models.Manager`。我们还定义了一个新方法，该方法使用`get_queryset()`获取`QuerySet`，并告诉它预取相关模型。`QuerySets`是惰性的，因此直到查询集被评估（例如通过迭代、转换为布尔值、切片或通过`if`语句进行评估）之前，与数据库的通信都不会发生。`DetailView`在使用`get()`获取模型时才会评估查询。
- en: The `prefetch_related()` method takes one or more *lookups*, and after the initial
    query is done, it automatically queries those related models. When you access
    a model related to the one from your `QuerySet`, Django won't have to query it,
    as you will already have it prefetched in the `QuerySet.`
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefetch_related()`方法接受一个或多个*lookups*，在初始查询完成后，它会自动查询这些相关模型。当您访问与您的`QuerySet`中的模型相关的模型时，Django不必查询它，因为您已经在`QuerySet`中预取了它。'
- en: 'A *lookup* is what a Django `QuerySet` takes to express a field or `RelatedManager`
    in a model. A lookup can even span across relationships by separating the name
    of the relationship field (or `RelatedManager`) and the related models field with
    two underscores:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是Django `QuerySet`用来表示模型中的字段或`RelatedManager`的方式。查询甚至可以跨越关系，通过用两个下划线分隔关系字段（或`RelatedManager`）和相关模型的字段来实现：
- en: '[PRE46]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding call will return a `QuerySet` for all the `Movie`  model instances
    in which Morgan Freeman has been an actor.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 上述调用将返回一个`QuerySet`，其中摩根·弗里曼曾经是演员的所有`Movie`模型实例。
- en: In our `PersonManager`, we're telling Django to prefetch all the movies that
    a `Person` has directed, written, and had a role in as well as prefetch the roles
    themselves. Using the `all_with_prefetch_movies()` method will result in a constant
    number of queries no matter how prolific the `Person` has been.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`PersonManager`中，我们告诉Django预取`Person`执导、编写和扮演的所有电影，以及预取角色本身。使用`all_with_prefetch_movies()`方法将导致查询数量保持恒定，无论`Person`的作品有多么丰富。
- en: Creating a PersonDetail view and template
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个PersonDetail视图和模板
- en: 'Now we can write a very thin view in `django/core/views.py`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`django/core/views.py`中编写一个非常简单的视图：
- en: '[PRE47]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This `DetailView` is different because we're not providing it with a `model`
    attribute. Instead, we're giving it a `QuerySet` object from our `PersonManager` class. When `DetailView` uses
    the `filter()` of `QuerySet` and `get()` methods to retrieve the model instance,
    `DetailView` will derive the name of the template from the model instance's class
    name just as if we had provided model class as an attribute on the view.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`DetailView`不同的地方在于我们没有为它提供一个`model`属性。相反，我们从我们的`PersonManager`类中给它一个`QuerySet`对象。当`DetailView`使用`QuerySet`的`filter()`和`get()`方法来检索模型实例时，`DetailView`将从模型实例的类名中派生模板的名称，就像我们在视图上提供了模型类属性一样。
- en: 'Now, let''s create our template in `django/core/templates/core/person_detail.html`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`django/core/templates/core/person_detail.html`中创建我们的模板：
- en: '[PRE48]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Our template doesn't have to do anything special to make use of our prefetching.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板不需要做任何特殊的事情来利用我们的预取。
- en: Next, we should give the `MovieDetail` view the same benefit that our `PersonDetail`
    view received.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该给`MovieDetail`视图提供与我们的`PersonDetail`视图相同的好处。
- en: Creating MovieManager
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MovieManager
- en: 'Let''s start with a `MovieManager` in `django/core/models.py`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`django/core/models.py`中创建一个`MovieManager`开始：
- en: '[PRE49]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `MovieManager` introduces another new method, called `select_related()`.
    The `select_related()` method is much like the `prefetch_related()` method but
    it is used when the relation leads to only one related model (for example, with
    a `ForeignKey` field). The `select_related()` method works by using a `JOIN` SQL
    query to retrieve the two models in one query. Use `prefetch_related()` when the
    relation *may* lead to more than one model (for example, either side of a `ManyToManyField` or
    a `RelatedManager` attribute).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`MovieManager`引入了另一个新方法，称为`select_related()`。`select_related()`方法与`prefetch_related()`方法非常相似，但当关系只导致一个相关模型时（例如，使用`ForeignKey`字段），它会被使用。`select_related()`方法通过使用`JOIN`
    SQL查询来在一次查询中检索两个模型。当关系*可能*导致多个模型时（例如，`ManyToManyField`的任一侧或`RelatedManager`属性），使用`prefetch_related()`。'
- en: 'Now, we can update our `MovieDetail` view to use the query set instead of the
    model directly:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新我们的`MovieDetail`视图，以使用查询集而不是直接使用模型：
- en: '[PRE50]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The view renders exactly the same, but it won't have to query the database each
    time a related  `Person` model instance is required, as they were all prefetched.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 视图渲染完全相同，但在需要相关的`Person`模型实例时，它不必每次查询数据库，因为它们都已经被预取。
- en: A quick review of the section
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本节的快速回顾
- en: In this section, we created the `Person` model and established a variety of
    relationships between the `Movie` and `Person` models. We created a one-to-many
    relationship with a `ForeignKey` field class, a many-to-many relationship using
    the `ManyToManyField` class,  and used an intermediary (or association) class
    to add extra information for a many-to-many relationship by providing a `through`
    model to a `ManyToManyField`. We also created a `PersonDetail` view to show a
    `Person` model instance and used a custom model manager to control the number
    of queries Django sends to the database.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们创建了`Person`模型，并在`Movie`和`Person`模型之间建立了各种关系。我们使用`ForeignKey`字段类创建了一对多的关系，使用`ManyToManyField`类创建了多对多的关系，并使用了一个中介（或关联）类，通过为`ManyToManyField`提供一个`through`模型来为多对多关系添加额外的信息。我们还创建了一个`PersonDetail`视图来显示`Person`模型实例，并使用自定义模型管理器来控制Django发送到数据库的查询数量。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we created our Django project and started our `core` Django
    app. We saw how to use Django's Model-View-Template approach to create easy-to-understand
    code. We created concentrated database logic near the model, pagination in views,
    and HTML in templates following the Django best practice of *fat models, thin
    views,* and *dumb templates*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了我们的Django项目，并启动了我们的`core` Django应用程序。我们看到了如何使用Django的模型-视图-模板方法来创建易于理解的代码。我们在模型附近创建了集中的数据库逻辑，视图中的分页，以及遵循Django最佳实践的模板中的HTML，即*fat
    models, thin views,*和*dumb templates*。
- en: Now we're ready to add users who can register and vote on their favorite movies.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备添加用户，他们可以注册并投票给他们最喜欢的电影。
