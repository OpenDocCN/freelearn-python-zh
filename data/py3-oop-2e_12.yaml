- en: Chapter 12. Testing Object-oriented Programs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。测试面向对象的程序
- en: 'Skilled Python programmers agree that testing is one of the most important
    aspects of software development. Even though this chapter is placed near the end
    of the book, it is not an afterthought; everything we have studied so far will
    help us when writing tests. We''ll be studying:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 技术娴熟的Python程序员一致认为测试是软件开发中最重要的方面之一。尽管本章放在书的末尾，但它并不是一个事后想法;到目前为止我们所学的一切都将帮助我们编写测试。我们将学习：
- en: The importance of unit testing and test-driven development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试和测试驱动开发的重要性
- en: The standard `unittest` module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的`unittest`模块
- en: The `py.test` automated testing suite
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`py.test`自动化测试套件'
- en: The `mock` module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock`模块'
- en: Code coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Cross-platform testing with `tox`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tox`进行跨平台测试
- en: Why test?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要测试？
- en: A large collection of programmers already know how important it is to test their
    code. If you're among them, feel free to skim this section. You'll find the next
    section—where we actually see how to do the tests in Python—much more scintillating.
    If you're not convinced of the importance of testing, I promise that your code
    is broken, you just don't know it. Read on!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员已经知道测试代码的重要性。如果你是其中之一，请随意略过本节。你会发现下一节——我们实际上如何在Python中进行测试——更加有趣。如果你还不相信测试的重要性，我保证你的代码是有问题的，只是你不知道而已。继续阅读!
- en: Some people argue that testing is more important in Python code because of its
    dynamic nature; compiled languages such as Java and C++ are occasionally thought
    to be somehow "safer" because they enforce type checking at compile time. However,
    Python tests rarely check types. They're checking values. They're making sure
    that the right attributes have been set at the right time or that the sequence
    has the right length, order, and values. These higher-level things need to be
    tested in any language. The real reason Python programmers test more than programmers
    of other languages is that it is so easy to test in Python!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有人认为测试在Python代码中更为重要，因为它的动态性;编译语言如Java和C++有时被认为在某种程度上更“安全”，因为它们在编译时强制执行类型检查。然而，Python测试很少检查类型。他们检查值。他们确保正确的属性在正确的时间设置，或者序列具有正确的长度，顺序和值。这些更高级的东西需要在任何语言中进行测试。Python程序员比其他语言的程序员进行更多测试的真正原因是在Python中测试是如此容易!
- en: But why test? Do we really need to test? What if we didn't test? To answer those
    questions, write a tic-tac-toe game from scratch without any testing at all. Don't
    run it until it is completely written, start to finish. Tic-tac-toe is fairly
    simple to implement if you make both players human players (no artificial intelligence).
    You don't even have to try to calculate who the winner is. Now run your program.
    And fix all the errors. How many were there? I recorded eight on my tic-tac-toe
    implementation, and I'm not sure I caught them all. Did you?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么要测试？我们真的需要测试吗？如果我们不测试会怎样？要回答这些问题，请从头开始编写一个井字棋游戏，完全不进行任何测试。在完全编写完成之前不要运行它。如果让两个玩家都是人类玩家（没有人工智能），实现井字棋是相当简单的。你甚至不必尝试计算谁是赢家。现在运行你的程序。并修复所有错误。有多少错误？我在我的井字棋实现中记录了八个错误，我不确定是否都捕捉到了。你呢？
- en: We need to test our code to make sure it works. Running the program, as we just
    did, and fixing the errors is one crude form of testing. Python programmers are
    able to write a few lines of code and run the program to make sure those lines
    are doing what they expect. But changing a few lines of code can affect parts
    of the program that the developer hadn't realized will be influenced by the changes,
    and therefore won't test it. Furthermore, as a program grows, the various paths
    that the interpreter can take through that code also grow, and it quickly becomes
    impossible to manually test all of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试我们的代码以确保它能正常工作。运行程序，就像我们刚刚做的那样，并修复错误是一种粗糙的测试形式。Python程序员可以编写几行代码并运行程序，以确保这些行正在做他们期望的事情。但是更改几行代码可能会影响开发人员没有意识到将受到更改影响的程序的部分，因此不会测试它。此外，随着程序的增长，解释器可以通过代码的各种路径也在增长，手动测试所有这些路径很快就变得不可能。
- en: To handle this, we write automated tests. These are programs that automatically
    run certain inputs through other programs or parts of programs. We can run these
    test programs in seconds and cover more possible input situations than one programmer
    would think to test every time they change something.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们编写自动化测试。这些是自动运行某些输入通过其他程序或程序部分的程序。我们可以在几秒钟内运行这些测试程序，并覆盖比一个程序员每次更改某些东西时想到的更多可能的输入情况。
- en: 'There are four main reasons to write tests:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的四个主要原因：
- en: To ensure that code is working the way the developer thinks it should
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保代码按照开发人员的预期工作
- en: To ensure that code continues working when we make changes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保代码在进行更改时继续工作
- en: To ensure that the developer understood the requirements
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保开发人员理解了要求
- en: To ensure that the code we are writing has a maintainable interface
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们正在编写的代码具有可维护的接口
- en: The first point really doesn't justify the time it takes to write a test; we
    can simply test the code directly in the interactive interpreter. But when we
    have to perform the same sequence of test actions multiple times, it takes less
    time to automate those steps once and then run them whenever necessary. It is
    a good idea to run tests whenever we change code, whether it is during initial
    development or maintenance releases. When we have a comprehensive set of automated
    tests, we can run them after code changes and know that we didn't inadvertently
    break anything that was tested.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点确实不能证明编写测试所需的时间;我们可以在交互式解释器中直接测试代码。但是，当我们必须多次执行相同的测试操作序列时，自动化这些步骤一次然后在需要时运行它们需要的时间更少。无论是在初始开发还是维护版本期间，改变代码时都要运行测试是个好主意。当我们有一套全面的自动化测试时，我们可以在代码更改后运行它们，并知道我们没有无意中破坏任何被测试的东西。
- en: The last two points are more interesting. When we write tests for code, it helps
    us design the API, interface, or pattern that code takes. Thus, if we misunderstood
    the requirements, writing a test can help highlight that misunderstanding. On
    the other side, if we're not certain how we want to design a class, we can write
    a test that interacts with that class so we have an idea what the most natural
    way to test it would be. In fact, it is often beneficial to write the tests before
    we write the code we are testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两点更有趣。当我们为代码编写测试时，它有助于我们设计代码所采用的API、接口或模式。因此，如果我们误解了需求，编写测试可以帮助突出这种误解。另一方面，如果我们不确定如何设计一个类，我们可以编写一个与该类交互的测试，这样我们就知道测试它的最自然方式是什么。事实上，通常在编写我们要测试的代码之前编写测试是有益的。
- en: Test-driven development
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '"Write tests first" is the mantra of test-driven development. Test-driven development
    takes the "untested code is broken code" concept one step further and suggests
    that only unwritten code should be untested. Do not write any code until you have
    written the tests for this code. So the first step is to write a test that proves
    the code would work. Obviously, the test is going to fail, since the code hasn''t
    been written. Then write the code that ensures the test passes. Then write another
    test for the next segment of code.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “先写测试”是测试驱动开发的口头禅。测试驱动开发将“未经测试的代码是有问题的代码”概念推进了一步，并建议只有未编写的代码才应该未经测试。在编写代码之前不要编写任何代码，直到为该代码编写了测试。因此，第一步是编写一个证明代码可以工作的测试。显然，测试将失败，因为代码还没有被编写。然后编写确保测试通过的代码。然后为下一段代码编写另一个测试。
- en: Test-driven development is fun. It allows us to build little puzzles to solve.
    Then we implement the code to solve the puzzles. Then we make a more complicated
    puzzle, and we write code that solves the new puzzle without unsolving the previous
    one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是有趣的。它允许我们构建小的谜题来解决。然后我们实现解决谜题的代码。然后我们制作一个更复杂的谜题，编写解决新谜题的代码，而不会解决以前的谜题。
- en: 'There are two goals to the test-driven methodology. The first is to ensure
    that tests really get written. It''s so very easy, after we have written code,
    to say: "Hmm, it seems to work. I don''t have to write any tests for this. It
    was just a small change, nothing could have broken." If the test is already written
    before we write the code, we will know exactly when it works (because the test
    will pass), and we''ll know in the future if it is ever broken by a change we,
    or someone else has made.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动方法论有两个目标。第一个目标是确保测试确实被编写。在编写了代码之后，很容易说：“嗯，它似乎可以工作。我不必为此编写任何测试。这只是一个小改动，不可能出错。”如果测试在编写代码之前已经编写好，我们将确切地知道它何时能够工作（因为测试将通过），并且在将来，如果我们或其他人做出的更改破坏了它，我们也会知道。
- en: Secondly, writing tests first forces us to consider exactly how the code will
    be interacted with. It tells us what methods objects need to have and how attributes
    will be accessed. It helps us break up the initial problem into smaller, testable
    problems, and then to recombine the tested solutions into larger, also tested,
    solutions. Writing tests can thus become a part of the design process. Often,
    if we're writing a test for a new object, we discover anomalies in the design
    that force us to consider new aspects of the software.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，首先编写测试强迫我们考虑代码将如何进行交互。它告诉我们对象需要具有哪些方法以及如何访问属性。它帮助我们将初始问题分解为更小的、可测试的问题，然后将经过测试的解决方案重新组合成更大的、同样经过测试的解决方案。编写测试因此可以成为设计过程的一部分。通常，如果我们为一个新对象编写测试，我们会发现设计中的异常，这会迫使我们考虑软件的新方面。
- en: As a concrete example, imagine writing code that uses an object-relational mapper
    to store object properties in a database. It is common to use an automatically
    assigned database ID in such objects. Our code might use this ID for various purposes.
    If we are writing a test for such code, before we write it, we may realize that
    our design is faulty because objects do not have these IDs until they have been
    saved to the database. If we want to manipulate an object without saving it in
    our test, it will highlight this problem before we have written code based on
    the faulty premise.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 举个具体的例子，想象一下编写代码，使用对象关系映射器将对象属性存储在数据库中。在这种对象中使用自动分配的数据库ID是很常见的。我们的代码可能会为各种目的使用这个ID。如果我们为这样的代码编写测试，在编写之前，我们可能会意识到我们的设计是有问题的，因为对象在保存到数据库之前是没有这些ID的。如果我们想在测试中操作一个对象而不保存它，它会在我们基于错误前提编写代码之前突出显示这个问题。
- en: Testing makes software better. Writing tests before we release the software
    makes it better before the end user sees or purchases the buggy version (I have
    worked for companies that thrive on the "the users can test it" philosophy. It's
    not a healthy business model!). Writing tests before we write software makes it
    better the first time it is written.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使软件更好。在发布软件之前编写测试可以使软件在最终用户看到或购买有错误的版本之前变得更好（我曾为奉行“用户可以测试”的理念的公司工作过。这不是一个健康的商业模式！）。在编写软件之前编写测试可以使软件第一次编写时变得更好。
- en: Unit testing
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Let's start our exploration with Python's built-in test library. This library
    provides a common interface for **unit tests**. Unit tests focus on testing the
    least amount of code possible in any one test. Each one tests a single unit of
    the total amount of available code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Python的内置测试库开始探索。该库提供了一个**单元测试**的通用接口。单元测试专注于在任何一个测试中测试尽可能少的代码。每个测试都测试可用代码的一个单元。
- en: The Python library for this is called, unsurprisingly, `unittest`. It provides
    several tools for creating and running unit tests, the most important being the
    `TestCase` class. This class provides a set of methods that allow us to compare
    values, set up tests, and clean up when they have finished.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的Python库被称为`unittest`，这并不奇怪。它提供了几个工具来创建和运行单元测试，其中最重要的是`TestCase`类。这个类提供了一组方法，允许我们比较值，设置测试，并在测试完成时进行清理。
- en: 'When we want to write a set of unit tests for a specific task, we create a
    subclass of `TestCase`, and write individual methods to do the actual testing.
    These methods must all start with the name `test`. When this convention is followed,
    the tests automatically run as part of the test process. Normally, the tests set
    some values on an object and then run a method, and use the built-in comparison
    methods to ensure that the right results were calculated. Here''s a very simple
    example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为特定任务编写一组单元测试时，我们创建一个`TestCase`的子类，并编写单独的方法来进行实际测试。这些方法必须都以`test`开头。遵循这个约定时，测试会自动作为测试过程的一部分运行。通常，测试会在对象上设置一些值，然后运行一个方法，并使用内置的比较方法来确保计算出了正确的结果。以下是一个非常简单的例子：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code simply subclasses the `TestCase` class and adds a method that calls
    the `TestCase.assertEqual` method. This method will either succeed or raise an
    exception, depending on whether the two parameters are equal. If we run this code,
    the `main` function from `unittest` will give us the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地继承了`TestCase`类，并添加了一个调用`TestCase.assertEqual`方法的方法。这个方法要么成功，要么引发异常，这取决于这两个参数是否相等。如果我们运行这段代码，`unittest`的`main`函数将给我们以下输出：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Did you know that floats and integers can compare as equal? Let''s add a failing
    test:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道浮点数和整数可以比较相等吗？让我们添加一个失败的测试：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of this code is more sinister, as integers and strings are not considered
    equal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出更加阴险，因为整数和字符串不被视为相等：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The dot on the first line indicates that the first test (the one we wrote before)
    passed successfully; the letter `F` after it shows that the second test failed.
    Then, at the end, it gives us some informative output telling us how and where
    the test failed, along with a summary of the number of failures.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行的点表示第一个测试（我们之前写的那个）成功通过；其后的`F`字母表示第二个测试失败。然后，在最后，它给出了一些信息性的输出，告诉我们测试失败的原因和位置，以及失败的数量总结。 '
- en: We can have as many test methods on one `TestCase` class as we like; as long
    as the method name begins with `test`, the test runner will execute each one as
    a separate test. Each test should be completely independent of other tests. Results
    or calculations from a previous test should have no impact on the current test.
    The key to writing good unit tests is to keep each test method as short as possible,
    testing a small unit of code with each test case. If your code does not seem to
    naturally break up into such testable units, it's probably a sign that your design
    needs rethinking.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个`TestCase`类上有尽可能多的测试方法；只要方法名以`test`开头，测试运行器就会将每个方法作为单独的测试执行。每个测试应该完全独立于其他测试。上一个测试的结果或计算不应该对当前测试产生影响。编写良好的单元测试的关键是尽可能保持每个测试方法的长度短，每个测试用例测试代码的一个小单元。如果你的代码似乎无法自然地分解成这样可测试的单元，这可能是你的设计需要重新思考的迹象。
- en: Assertion methods
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言方法
- en: The general layout of a test case is to set certain variables to known values,
    run one or more functions, methods, or processes, and then "prove" that correct
    expected results were returned or calculated by using `TestCase` assertion methods.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例的一般布局是将某些变量设置为已知值，运行一个或多个函数、方法或进程，然后使用`TestCase`断言方法来“证明”正确的预期结果是通过的。
- en: 'There are a few different assertion methods available to confirm that specific
    results have been achieved. We just saw `assertEqual`, which will cause a test
    failure if the two parameters do not pass an equality check. The inverse, `assertNotEqual`,
    will fail if the two parameters do compare as equal. The `assertTrue` and `assertFalse`
    methods each accept a single expression, and fail if the expression does not pass
    an `if` test. These tests are not checking for the Boolean values `True` or `False`.
    Rather, they test the same condition as though an `if` statement were used: `False`,
    `None`, `0`, or an empty list, dictionary, string, set, or tuple would pass a
    call to the `assertFalse` method, while nonzero numbers, containers with values
    in them, or the value `True` would succeed when calling the `assertTrue` method.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些不同的断言方法可用于确认已经实现了特定的结果。我们刚刚看到了`assertEqual`，如果两个参数未通过相等检查，它将导致测试失败。相反，`assertNotEqual`将在两个参数比较相等时失败。`assertTrue`和`assertFalse`方法各自接受一个表达式，并在表达式未通过`if`测试时失败。这些测试不是检查布尔值`True`或`False`。相反，它们测试与使用`if`语句相同的条件：`False`、`None`、`0`或空列表、字典、字符串、集合或元组会通过调用`assertFalse`方法，而非零数、包含值的容器或值`True`在调用`assertTrue`方法时会成功。
- en: 'There is an `assertRaises` method that can be used to ensure a specific function
    call raises a specific exception or, optionally, it can be used as a context manager
    to wrap inline code. The test passes if the code inside the `with` statement raises
    the proper exception; otherwise, it fails. Here''s an example of both versions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`assertRaises`方法，可以用来确保特定的函数调用引发特定的异常，或者可以作为上下文管理器来包装内联代码。如果`with`语句内的代码引发了正确的异常，测试通过；否则，测试失败。以下是两个版本的示例：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The context manager allows us to write the code the way we would normally write
    it (by calling functions or executing code directly), rather than having to wrap
    the function call in another function call.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器允许我们以通常的方式编写代码（通过调用函数或直接执行代码），而不必在另一个函数调用中包装函数调用。
- en: 'There are also several other assertion methods, summarized in the following
    table:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几种断言方法，总结如下表：
- en: '| Methods | Description |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `assertGreater``assertGreaterEqual``assertLess``assertLessEqual` | Accept
    two comparable objects and ensure the named inequality holds. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `assertGreater``assertGreaterEqual``assertLess``assertLessEqual` | 接受两个可比较的对象，并确保命名的不等式成立。
    |'
- en: '| `assertIn``assertNotIn` | Ensure an element is (or is not) an element in
    a container object. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `assertIn``assertNotIn` | 确保元素是（或不是）容器对象中的元素。 |'
- en: '| `assertIsNone``assertIsNotNone` | Ensure an element is (or is not) the exact
    value `None` (but not another falsey value). |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `assertIsNone``assertIsNotNone` | 确保元素是（或不是）确切的值`None`（但不是其他假值）。 |'
- en: '| `assertSameElements` | Ensure two container objects have the same elements,
    ignoring the order. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '`assertSameElements` | 确保两个容器对象具有相同的元素，忽略顺序。'
- en: '| `assertSequenceEqualassertDictEqual``assertSetEqual``assertListEqual``assertTupleEqual`
    | Ensure two containers have the same elements in the same order. If there''s
    a failure, show a code diff comparing the two lists to see where they differ.
    The last four methods also test the type of the list. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '`assertSequenceEqualassertDictEqual``assertSetEqual``assertListEqual``assertTupleEqual`
    | 确保两个容器具有相同顺序的相同元素。如果失败，显示一个代码差异，比较两个列表的差异位置。最后四种方法还测试列表的类型。'
- en: Each of the assertion methods accepts an optional argument named `msg.` If supplied,
    it is included in the error message if the assertion fails. This is useful for
    clarifying what was expected or explaining where a bug may have occurred to cause
    the assertion to fail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个断言方法都接受一个名为`msg`的可选参数。如果提供，它将包含在错误消息中，如果断言失败。这对于澄清预期的内容或解释可能导致断言失败的错误的位置非常有用。
- en: Reducing boilerplate and cleaning up
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少样板代码和清理
- en: 'After writing a few small tests, we often find that we have to do the same
    setup code for several related tests. For example, the following `list` subclass
    has three methods for statistical calculations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 写了一些小测试之后，我们经常发现我们必须为几个相关的测试做相同的设置代码。例如，以下`list`子类有三种用于统计计算的方法：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Clearly, we''re going to want to test situations with each of these three methods
    that have very similar inputs; we''ll want to see what happens with empty lists
    or with lists containing non-numeric values or with lists containing a normal
    dataset. We can use the `setUp` method on the `TestCase` class to do initialization
    for each test. This method accepts no arguments, and allows us to do arbitrary
    setup before each test is run. For example, we can test all three methods on identical
    lists of integers as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们将要测试这三种方法中每一种具有非常相似的输入的情况；我们将要看看空列表或包含非数字值的列表或包含正常数据集的列表会发生什么。我们可以使用`TestCase`类上的`setUp`方法为每个测试进行初始化。这个方法不接受任何参数，并允许我们在每次测试运行之前进行任意设置。例如，我们可以按照以下方式测试所有三种方法在相同的整数列表上：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we run this example, it indicates that all tests pass. Notice first that
    the `setUp` method is never explicitly called inside the three `test_*` methods.
    The test suite does this on our behalf. More importantly notice how `test_median`
    alters the list, by adding an additional `4` to it, yet when `test_mode` is called,
    the list has returned to the values specified in `setUp` (if it had not, there
    would be two fours in the list, and the `mode` method would have returned three
    values). This shows that `setUp` is called individually before each test, to ensure
    the test class starts with a clean slate. Tests can be executed in any order,
    and the results of one test should not depend on any other tests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个例子，它表明所有测试都通过了。首先注意到`setUp`方法从未在三个`test_*`方法内显式调用过。测试套件会代表我们执行这个操作。更重要的是注意`test_median`如何改变列表，通过向其中添加额外的`4`，然而当调用`test_mode`时，列表已经返回到`setUp`中指定的值（如果没有的话，列表中会有两个四，并且`mode`方法会返回三个值）。这表明`setUp`在每个测试之前被单独调用，以确保测试类从一个干净的状态开始。测试可以以任何顺序执行，一个测试的结果不应该依赖于任何其他测试。
- en: In addition to the `setUp` method, `TestCase` offers a no-argument `tearDown`
    method, which can be used for cleaning up after each and every test on the class
    has run. This is useful if cleanup requires anything other than letting an object
    be garbage collected. For example, if we are testing code that does file I/O,
    our tests may create new files as a side effect of testing; the `tearDown` method
    can remove these files and ensure the system is in the same state it was before
    the tests ran. Test cases should never have side effects. In general, we group
    test methods into separate `TestCase` subclasses depending on what setup code
    they have in common. Several tests that require the same or similar setup will
    be placed in one class, while tests that require unrelated setup go in another
    class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`setUp`方法，`TestCase`还提供了一个无参数的`tearDown`方法，它可以用于在类的每个测试运行后进行清理。如果清理需要除了让对象被垃圾回收之外的其他操作，这是很有用的。例如，如果我们正在测试进行文件I/O的代码，我们的测试可能会创建新文件作为测试的副作用；`tearDown`方法可以删除这些文件，并确保系统处于测试运行之前的相同状态。测试用例不应该具有副作用。一般来说，我们根据它们共同的设置代码将测试方法分组到单独的`TestCase`子类中。需要相同或类似设置的几个测试将放在一个类中，而需要不相关设置的测试将放在另一个类中。
- en: Organizing and running tests
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织和运行测试
- en: It doesn't take long for a collection of unit tests to grow very large and unwieldy.
    It quickly becomes complicated to load and run all the tests at once. This is
    a primary goal of unit testing; it should be trivial to run all tests on our program
    and get a quick "yes or no" answer to the question, "Did my recent changes break
    any existing tests?".
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单元测试集合很快就会变得非常庞大和难以管理。一次性加载和运行所有测试很快就会变得复杂。这是单元测试的主要目标；应该很容易运行我们程序上的所有测试，并快速得到一个“是或否”的答案，回答“我的最近的更改是否破坏了任何现有的测试？”的问题。
- en: Python's `discover` module basically looks for any modules in the current folder
    or subfolders with names that start with the characters `test`. If it finds any
    `TestCase` objects in these modules, the tests are executed. It's a painless way
    to ensure we don't miss running any tests. To use it, ensure your test modules
    are named `test_<something>.py` and then run the command `python3 -m unittest
    discover`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`discover`模块基本上是在当前文件夹或子文件夹中查找以`test`开头的模块。如果在这些模块中找到任何`TestCase`对象，就会执行测试。这是一个无痛的方式来确保我们不会错过运行任何测试。要使用它，请确保你的测试模块的名称是`test_<something>.py`，然后运行命令`python3
    -m unittest discover`。
- en: Ignoring broken tests
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略损坏的测试
- en: Sometimes, a test is known to fail, but we don't want the test suite to report
    the failure. This may be because a broken or unfinished feature has had tests
    written, but we aren't currently focusing on improving it. More often, it happens
    because a feature is only available on a certain platform, Python version, or
    for advanced versions of a specific library. Python provides us with a few decorators
    to mark tests as expected to fail or to be skipped under known conditions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，测试可能会失败，但我们不希望测试套件报告失败。这可能是因为一个破损或未完成的功能已经编写了测试，但我们目前并不专注于改进它。更常见的情况是，因为某个功能仅在特定平台、Python版本或特定库的高级版本上可用。Python为我们提供了一些装饰器，用于标记测试为预期失败或在已知条件下跳过。
- en: 'The decorators are:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是：
- en: '`expectedFailure()`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectedFailure()`'
- en: '`skip(reason)`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip(reason)`'
- en: '`skipIf(condition, reason)`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipIf(condition, reason)`'
- en: '`skipUnless(condition, reason)`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipUnless(condition, reason)`'
- en: 'These are applied using the Python decorator syntax. The first one accepts
    no arguments, and simply tells the test runner not to record the test as a failure
    when it fails. The `skip` method goes one step further and doesn''t even bother
    to run the test. It expects a single string argument describing why the test was
    skipped. The other two decorators accept two arguments, one a Boolean expression
    that indicates whether or not the test should be run, and a similar description.
    In use, these three decorators might be applied like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用Python装饰器语法应用的。第一个不接受任何参数，只是告诉测试运行器在失败时不记录测试为失败。`skip`方法更进一步，甚至不会运行测试。它期望一个描述为什么跳过测试的字符串参数。另外两个装饰器接受两个参数，一个是布尔表达式，指示是否应该运行测试，另一个是类似的描述。在使用时，这三个装饰器可能会像这样应用：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first test fails, but it is reported as an expected failure; the second
    test is never run. The other two tests may or may not be run depending on the
    current Python version and operating system. On my Linux system running Python
    3.4, the output looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试失败，但被报告为预期失败；第二个测试从未运行。其他两个测试可能会运行，也可能不会，这取决于当前的Python版本和操作系统。在我运行Python
    3.4的Linux系统上，输出如下：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `x` on the first line indicates an expected failure; the two `s` characters
    represent skipped tests, and the `F` indicates a real failure, since the conditional
    to `skipUnless` was `True` on my system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行上的`x`表示预期失败；两个`s`字符代表跳过的测试，`F`表示真正的失败，因为在我的系统上，`skipUnless`的条件为`True`。
- en: Testing with py.test
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用py.test进行测试
- en: The Python `unittest` module requires a lot of boilerplate code to set up and
    initialize tests. It is based on the very popular JUnit testing framework for
    Java. It even uses the same method names (you may have noticed they don't conform
    to the PEP-8 naming standard, which suggests underscores rather than CamelCase
    to separate words in a method name) and test layout. While this is effective for
    testing in Java, it's not necessarily the best design for Python testing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python `unittest`模块需要大量样板代码来设置和初始化测试。它基于非常流行的Java的JUnit测试框架。它甚至使用相同的方法名称（您可能已经注意到它们不符合PEP-8命名标准，该标准建议使用下划线而不是CamelCase来分隔方法名称中的单词），以及测试布局。虽然这对于在Java中进行测试是有效的，但不一定是Python测试的最佳设计。
- en: Because Python programmers like their code to be elegant and simple, other test
    frameworks have been developed, outside the standard library. Two of the more
    popular ones are `py.test` and `nose`. The former is more robust and has had Python
    3 support for much longer, so we'll discuss it here.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python程序员喜欢他们的代码简洁而简单，所以在标准库之外开发了其他测试框架。其中两个较受欢迎的是`py.test`和`nose`。前者更为健壮，而且支持Python
    3的时间更长，因此我们将在这里讨论它。
- en: Since `py.test` is not part of the standard library, you'll need to download
    and install it yourself; you can get it from the `py.test` home page at [http://pytest.org/](http://pytest.org/).
    The website has comprehensive installation instructions for a variety of interpreters
    and platforms, but you can usually get away with the more common python package
    installer, pip. Just type `pip install pytest` on your command line and you'll
    be good to go.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`py.test`不是标准库的一部分，您需要自己下载和安装它；您可以从[http://pytest.org/](http://pytest.org/)的`py.test`主页获取它。该网站提供了各种解释器和平台的全面安装说明，但通常您可以使用更常见的Python包安装程序pip。只需在命令行上键入`pip
    install pytest`，您就可以开始使用了。
- en: '`py.test` has a substantially different layout from the `unittest` module.
    It doesn''t require test cases to be classes. Instead, it takes advantage of the
    fact that Python functions are objects, and allows any properly named function
    to behave like a test. Rather than providing a bunch of custom methods for asserting
    equality, it uses the `assert` statement to verify results. This makes tests more
    readable and maintainable. When we run `py.test`, it will start in the current
    folder and search for any modules in that folder or subpackages whose names start
    with the characters `test_`. If any functions in this module also start with `test`,
    they will be executed as individual tests. Furthermore, if there are any classes
    in the module whose name starts with `Test`, any methods on that class that start
    with `test_` will also be executed in the test environment.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`的布局与`unittest`模块有很大不同。它不要求测试用例是类。相反，它利用了Python函数是对象的事实，并允许任何命名正确的函数像测试一样行为。它不是提供一堆用于断言相等的自定义方法，而是使用`assert`语句来验证结果。这使得测试更易读和易维护。当我们运行`py.test`时，它将从当前文件夹开始搜索该文件夹或子包中以`test_`开头的任何模块。如果此模块中的任何函数也以`test`开头，它们将作为单独的测试执行。此外，如果模块中有任何以`Test`开头的类，该类上以`test_`开头的任何方法也将在测试环境中执行。'
- en: 'Let''s port the simplest possible `unittest` example we wrote earlier to `py.test`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们之前编写的最简单的`unittest`示例移植到`py.test`：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For the exact same test, we've written two lines of more readable code, in comparison
    to the six lines required in our first `unittest` example.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完全相同的测试，我们编写了两行更易读的代码，与我们第一个`unittest`示例中需要的六行相比。
- en: 'However, we are not forbidden from writing class-based tests. Classes can be
    useful for grouping related tests together or for tests that need to access related
    attributes or methods on the class. This example shows an extended class with
    a passing and a failing test; we''ll see that the error output is more comprehensive
    than that provided by the `unittest` module:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们并不禁止编写基于类的测试。类可以用于将相关测试分组在一起，或者用于需要访问类上相关属性或方法的测试。这个例子展示了一个扩展类，其中有一个通过的测试和一个失败的测试；我们将看到错误输出比`unittest`模块提供的更全面：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that the class doesn''t have to extend any special objects to be picked
    up as a test (although `py.test` will run standard `unittest TestCases` just fine).
    If we run `py.test <filename>`, the output looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类不必扩展任何特殊对象才能被选为测试（尽管`py.test`可以很好地运行标准的`unittest TestCases`）。如果我们运行`py.test
    <filename>`，输出如下：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output starts with some useful information about the platform and interpreter.
    This can be useful for sharing bugs across disparate systems. The third line tells
    us the name of the file being tested (if there are multiple test modules picked
    up, they will all be displayed), followed by the familiar `.F` we saw in the `unittest`
    module; the `.` character indicates a passing test, while the letter `F` demonstrates
    a failure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以有关平台和解释器的一些有用信息开始。这对于在不同系统之间共享错误很有用。第三行告诉我们正在测试的文件的名称（如果有多个测试模块被选中，它们都将被显示），然后是在`unittest`模块中看到的熟悉的`.F`；`.`字符表示通过的测试，而字母`F`表示失败。
- en: 'After all tests have run, the error output for each of them is displayed. It
    presents a summary of local variables (there is only one in this example: the
    `self` parameter passed into the function), the source code where the error occurred,
    and a summary of the error message. In addition, if an exception other than an
    `AssertionError` is raised, `py.test` will present us with a complete traceback,
    including source code references.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试运行完毕后，将显示每个测试的错误输出。它呈现了本地变量的摘要（在本例中只有一个：传递到函数中的`self`参数），错误发生的源代码以及错误消息的摘要。此外，如果引发的异常不是`AssertionError`，`py.test`将向我们呈现完整的回溯，包括源代码引用。
- en: By default, `py.test` suppresses output from `print` statements if the test
    is successful. This is useful for test debugging; when a test is failing, we can
    add `print` statements to the test to check the values of specific variables and
    attributes as the test runs. If the test fails, these values are output to help
    with diagnosis. However, once the test is successful, the `print` statement output
    is not displayed, and they can be easily ignored. We don't have to "clean up"
    the output by removing `print` statements. If the tests ever fail again, due to
    future changes, the debugging output will be immediately available.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`py.test`在测试成功时会抑制`print`语句的输出。这对于测试调试很有用；当测试失败时，我们可以向测试中添加`print`语句，以检查测试运行时特定变量和属性的值。如果测试失败，这些值将被输出以帮助诊断。然而，一旦测试成功，`print`语句的输出就不会显示，可以轻松忽略。我们不必通过删除`print`语句来“清理”输出。如果测试因未来更改而再次失败，调试输出将立即可用。
- en: One way to do setup and cleanup
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和清理的一种方法
- en: '`py.test` supports setup and teardown methods similar to those used in `unittest`,
    but it provides even more flexibility. We''ll discuss these briefly, since they
    are familiar, but they are not used as extensively as in the `unittest` module,
    as `py.test` provides us with a powerful funcargs facility, which we''ll discuss
    in the next section.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`支持类似于`unittest`中使用的设置和清理方法，但它提供了更多的灵活性。我们将简要讨论这些，因为它们很熟悉，但它们没有像在`unittest`模块中那样被广泛使用，因为`py.test`为我们提供了强大的funcargs功能，我们将在下一节中讨论。'
- en: 'If we are writing class-based tests, we can use two methods called `setup_method`
    and `teardown_method` in basically the same way that `setUp` and `tearDown` are
    called in `unittest`. They are called before and after each test method in the
    class to perform setup and cleanup duties. There is one difference from the `unittest`
    methods though. Both methods accept an argument: the function object representing
    the method being called.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写基于类的测试，我们可以使用两个名为`setup_method`和`teardown_method`的方法，基本上与`unittest`中调用`setUp`和`tearDown`的方式相同。它们在类中的每个测试方法之前和之后被调用，以执行设置和清理任务。不过，与`unittest`方法有一个区别。这两个方法都接受一个参数：表示被调用方法的函数对象。
- en: In addition, `py.test` provides other setup and teardown functions to give us
    more control over when setup and cleanup code is executed. The `setup_class` and
    `teardown_class` methods are expected to be class methods; they accept a single
    argument (there is no `self` argument) representing the class in question.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`py.test`还提供了其他设置和清理函数，以便更多地控制设置和清理代码的执行时间。`setup_class`和`teardown_class`方法预期是类方法；它们接受一个表示相关类的单个参数（没有`self`参数）。
- en: Finally, we have the `setup_module` and `teardown_module` functions, which are
    run immediately before and after all tests (in functions or classes) in that module.
    These can be useful for "one time" setup, such as creating a socket or database
    connection that will be used by all tests in the module. Be careful with this
    one, as it can accidentally introduce dependencies between tests if the object
    being set up stores the state.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`setup_module`和`teardown_module`函数，它们在该模块中的所有测试（在函数或类中）之前和之后立即运行。这些可以用于“一次性”设置，例如创建将被模块中所有测试使用的套接字或数据库连接。要小心使用这个，因为如果设置的对象存储状态，它可能会意外地引入测试之间的依赖关系。
- en: 'That short description doesn''t do a great job of explaining exactly when these
    methods are called, so let''s look at an example that illustrates exactly when
    it happens:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的描述并没有很好地解释这些方法究竟在什么时候被调用，所以让我们看一个例子，确切地说明了它们何时被调用：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The sole purpose of the `BaseTest` class is to extract four methods that would
    be otherwise identical to the test classes, and use inheritance to reduce the
    amount of duplicate code. So, from the point of view of `py.test`, the two subclasses
    have not only two test methods each, but also two setup and two teardown methods
    (one at the class level, one at the method level).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseTest`类的唯一目的是提取四个方法，否则这些方法将与测试类相同，并使用继承来减少重复代码的数量。因此，从`py.test`的角度来看，这两个子类不仅每个都有两个测试方法，还有两个设置和两个拆卸方法（一个在类级别，一个在方法级别）。'
- en: 'If we run these tests using `py.test` with the `print` function output suppression
    disabled (by passing the `-s` or `--capture=no` flag), they show us when the various
    functions are called in relation to the tests themselves:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`py.test`运行这些测试，并且禁用`print`函数输出抑制（通过传递`-s`或`--capture=no`标志），它们会向我们显示各种函数在与测试本身相关的情况下被调用的时间：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The setup and teardown methods for the module are executed at the beginning
    and end of the session. Then the lone module-level test function is run. Next,
    the setup method for the first class is executed, followed by the two tests for
    that class. These tests are each individually wrapped in separate `setup_method`
    and `teardown_method` calls. After the tests have executed, the class teardown
    method is called. The same sequence happens for the second class, before the `teardown_module`
    method is finally called, exactly once.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的设置和拆卸方法在会话的开始和结束时执行。然后运行单个模块级别的测试函数。接下来，执行第一个类的设置方法，然后执行该类的两个测试。这些测试分别包裹在单独的`setup_method`和`teardown_method`调用中。测试执行完毕后，调用类的拆卸方法。在第二个类之前，发生了相同的顺序，最后调用`teardown_module`方法，确切地调用一次。
- en: A completely different way to set up variables
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置变量的完全不同的方法
- en: One of the most common uses for the various setup and teardown functions is
    to ensure certain class or module variables are available with a known value before
    each test method is run.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 各种设置和拆卸函数的最常见用途之一是确保在运行每个测试方法之前，某些类或模块变量可用，并具有已知的值。
- en: '`py.test` offers a completely different way to do this using what are known
    as **funcargs**, short for function arguments. Funcargs are basically named variables
    that are predefined in a test configuration file. This allows us to separate configuration
    from execution of tests, and allows the funcargs to be used across multiple classes
    and modules.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`提供了一种完全不同的方法来使用所谓的**funcargs**，即函数参数。Funcargs基本上是预定义在测试配置文件中的命名变量。这使我们能够将配置与测试的执行分开，并允许funcargs在多个类和模块中使用。'
- en: 'To use them, we add parameters to our test function. The names of the parameters
    are used to look up specific arguments in specially named functions. For example,
    if we wanted to test the `StatsList` class we used while demonstrating `unittest`,
    we would again want to repeatedly test a list of valid integers. But we can write
    our tests like so instead of using a setup method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它们，我们向测试函数添加参数。参数的名称用于在特殊命名的函数中查找特定的参数。例如，如果我们想测试我们在演示`unittest`时使用的`StatsList`类，我们将再次想要重复测试一个有效整数列表。但是，我们可以这样编写我们的测试，而不是使用设置方法：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each of the three test methods accepts a parameter named `valid_stats`; this
    parameter is created by calling the `pytest_funcarg__valid_stats` function defined
    at the top of the file. It can also be defined in a file called `conftest.py`
    if the funcarg is needed by multiple modules. The `conftest.py` file is parsed
    by `py.test` to load any "global" test configuration; it is a sort of catch-all
    for customizing the `py.test` experience.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 三个测试方法中的每一个都接受一个名为`valid_stats`的参数；这个参数是通过调用文件顶部定义的`pytest_funcarg__valid_stats`函数创建的。如果funcarg需要多个模块使用，它也可以在名为`conftest.py`的文件中定义。`conftest.py`文件由`py.test`解析，以加载任何“全局”测试配置；它是一种用于自定义`py.test`体验的捕捉所有的文件。
- en: As with other `py.test` features, the name of the factory for returning a funcarg
    is important; funcargs are functions that are named `pytest_funcarg__<identifier>`,
    where `<identifier>` is a valid variable name that can be used as a parameter
    in a test function. This function accepts a mysterious `request` parameter, and
    returns the object to be passed as an argument into the individual test functions.
    The funcarg is created afresh for each call to an individual test function; this
    allows us, for example, to change the list in one test and know that it will be
    reset to its original values in the next test.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他`py.test`功能一样，返回funcarg的工厂的名称很重要；funcargs是被命名为`pytest_funcarg__<identifier>`的函数，其中`<identifier>`是一个可以在测试函数中用作参数的有效变量名。这个函数接受一个神秘的`request`参数，并返回要传递给各个测试函数的对象。对于每次调用单个测试函数，都会新创建一个funcarg；这使我们能够在一个测试中更改列表，并知道它将在下一个测试中被重置为其原始值。
- en: Funcargs can do a lot more than return basic variables. That `request` object
    passed into the funcarg factory provides some extremely useful methods and attributes
    to modify the funcarg's behavior. The `module`, `cls`, and `function` attributes
    allow us to see exactly which test is requesting the funcarg. The `config` attribute
    allows us to check command-line arguments and other configuration data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Funcargs可以做的远不止返回基本变量。传递给funcarg工厂的`request`对象提供了一些极其有用的方法和属性，以修改funcarg的行为。`module`、`cls`和`function`属性允许我们准确地看到哪个测试正在请求funcarg。`config`属性允许我们检查命令行参数和其他配置数据。
- en: More interestingly, the request object provides methods that allow us to do
    additional cleanup on the funcarg, or to reuse it across tests, activities that
    would otherwise be relegated to setup and teardown methods of a specific scope.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，请求对象提供了一些方法，允许我们对funcarg进行额外的清理，或者在测试之间重用它，这些方法否则将被限制在特定范围的设置和拆卸方法中。
- en: 'The `request.addfinalizer` method accepts a callback function that performs
    cleanup after each test function that uses the funcarg has been called. This provides
    the equivalent of a teardown method, allowing us to clean up files, close connections,
    empty lists, or reset queues. For example, the following code tests the `os.mkdir`
    functionality by creating a temporary directory `funcarg`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`request.addfinalizer`方法接受一个回调函数，在每个使用funcarg的测试函数之后执行清理。这提供了一个类似于拆卸方法的功能，允许我们清理文件、关闭连接、清空列表或重置队列。例如，以下代码通过创建一个临时目录`funcarg`来测试`os.mkdir`功能：'
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The funcarg creates a new empty temporary directory for files to be created
    in. Then it adds a finalizer call to remove that directory (using `shutil.rmtree`,
    which recursively removes a directory and anything inside it) after the test has
    completed. The filesystem is then left in the same state in which it started.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: funcarg为文件创建一个新的空临时目录。然后它添加一个finalizer调用，在测试完成后删除该目录（使用`shutil.rmtree`，递归删除目录及其中的所有内容）。文件系统的状态将保持与开始时相同。
- en: 'We can use the `request.cached_setup` method to create function argument variables
    that last longer than one test. This is useful when setting up an expensive operation
    that can be reused by multiple tests as long as the resource reuse doesn''t break
    the atomic or unit nature of the tests (so that one test does not rely on and
    is not impacted by a previous one). For example, if we were to test the following
    echo server, we may want to run only one instance of the server in a separate
    process, and then have multiple tests connect to that instance:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`request.cached_setup`方法创建持续时间超过一个测试的函数参数变量。当设置一个昂贵的操作并且可以被多个测试重复使用时，这是非常有用的，只要资源重用不会破坏测试的原子性或单元性质（以便一个测试不依赖于先前的测试并且不受其影响）。例如，如果我们要测试以下回显服务器，我们可能只想在单独的进程中运行服务器的一个实例，然后让多个测试连接到该实例：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All this code does is listen on a specific port and wait for input from a client
    socket. When it receives input, it sends the same value back. To test this, we
    can start the server in a separate process and cache the result for use in multiple
    tests. Here''s how the test code might look:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用只是在特定端口上监听并等待来自客户端套接字的输入。当它接收到输入时，它会将相同的值发送回去。为了测试这一点，我们可以在单独的进程中启动服务器，并将结果缓存以供多个测试使用。以下是测试代码的样子：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ve created two funcargs here. The first runs the echo server in a separate
    process, and returns the process object. The second instantiates a new socket
    object for each test, and closes it when the test has completed, using `addfinalizer`.
    The first funcarg is the one we''re currently interested in. It looks much like
    a traditional unit test setup and teardown. We create a `setup` function that
    accepts no parameters and returns the correct argument; in this case, a process
    object that is actually ignored by the tests, since they only care that the server
    is running. Then, we create a `cleanup` function (the name of the function is
    arbitrary since it''s just an object we pass into another function), which accepts
    a single argument: the argument returned by `setup`. This cleanup code terminates
    the process.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了两个funcarg。第一个在单独的进程中运行回显服务器，并返回进程对象。第二个为每个测试实例化一个新的套接字对象，并在测试完成时关闭它，使用`addfinalizer`。我们目前感兴趣的是第一个funcarg。它看起来很像传统的单元测试设置和拆卸。我们创建一个`setup`函数，不接受任何参数并返回正确的参数；在这种情况下，实际上测试忽略了进程对象，因为它们只关心服务器是否正在运行。然后，我们创建一个`cleanup`函数（函数的名称是任意的，因为它只是我们传递给另一个函数的对象），它接受一个参数：`setup`返回的参数。这个清理代码终止了进程。
- en: Instead of returning a funcarg directly, the parent function returns the results
    of a call to `request.cached_setup`. It accepts two arguments for the `setup`
    and `teardown` functions (which we just created), and a `scope` argument. This
    last argument should be one of the three strings "function", "module", or "session";
    it determines just how long the argument will be cached. We set it to "session"
    in this example, so it is cached for the duration of the entire `py.test` run.
    The process will not be terminated or restarted until all tests have run. The
    "module" scope, of course, caches it only for tests in that module, and the "function"
    scope treats the object more like a normal funcarg, in that it is reset after
    each test function is run.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 父函数不直接返回funcarg的结果，而是返回对`request.cached_setup`调用的结果。它接受`setup`和`teardown`函数的两个参数（我们刚刚创建的），以及一个`scope`参数。这个最后一个参数应该是三个字符串之一："function"、"module"或"session"；它决定了参数的缓存时间。在这个例子中，我们将其设置为"session"，因此它在整个`py.test`运行期间都被缓存。直到所有测试运行完毕之前，进程都不会被终止或重新启动。当然，"module"作用域只在该模块中缓存它，而"function"作用域则更像一个普通的funcarg，因为它在每个测试函数运行后都会被重置。
- en: Skipping tests with py.test
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用py.test跳过测试
- en: 'As with the `unittest` module, it is frequently necessary to skip tests in
    `py.test`, for a variety of reasons: the code being tested hasn''t been written
    yet, the test only runs on certain interpreters or operating systems, or the test
    is time consuming and should only be run under certain circumstances.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与`unittest`模块一样，经常需要在`py.test`中跳过测试，原因有很多：被测试的代码尚未编写、测试只在某些解释器或操作系统上运行、或者测试很耗时，只应在特定情况下运行。
- en: 'We can skip tests at any point in our code using the `py.test.skip` function.
    It accepts a single argument: a string describing why it has been skipped. This
    function can be called anywhere; if we call it inside a test function, the test
    will be skipped. If we call it at the module level, all the tests in that module
    will be skipped. If we call it inside a funcarg function, all tests that call
    that funcarg will be skipped.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码的任何地方使用`py.test.skip`函数跳过测试。它接受一个参数：描述为什么要跳过的字符串。这个函数可以在任何地方调用；如果我们在测试函数内部调用它，测试将被跳过。如果我们在模块级别调用它，那么该模块中的所有测试都将被跳过。如果我们在funcarg函数内部调用它，那么调用该funcarg的所有测试都将被跳过。
- en: 'Of course, in all these locations, it is often desirable to skip tests only
    if certain conditions are or are not met. Since we can execute the `skip` function
    at any place in Python code, we can execute it inside an `if` statement. So we
    may write a test that looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在所有这些位置，通常希望只有在满足或不满足某些条件时才跳过测试。由于我们可以在Python代码的任何地方执行`skip`函数，我们可以在`if`语句内执行它。因此，我们可以编写一个看起来像这样的测试：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's some pretty silly code, really. There is no Python platform named `fakeos`,
    so this test will skip on all operating systems. It shows how we can skip conditionally,
    and since the `if` statement can check any valid conditional, we have a lot of
    power over when tests are skipped. Often, we check `sys.version_info` to check
    the Python interpreter version, `sys.platform` to check the operating system,
    or `some_library.__version__` to check whether we have a recent enough version
    of a given API.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一些非常愚蠢的代码。没有名为`fakeos`的Python平台，因此这个测试将在所有操作系统上跳过。它展示了我们如何有条件地跳过测试，由于`if`语句可以检查任何有效的条件，我们对何时跳过测试有很大的控制权。通常，我们会检查`sys.version_info`来检查Python解释器版本，`sys.platform`来检查操作系统，或者`some_library.__version__`来检查我们是否有足够新的给定API版本。
- en: 'Since skipping an individual test method or function based on a certain conditional
    is one of the most common uses of test skipping, `py.test` provides a convenience
    decorator that allows us to do this in one line. The decorator accepts a single
    string, which can contain any executable Python code that evaluates to a Boolean
    value. For example, the following test will only run on Python 3 or higher:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于某个条件跳过单个测试方法或函数是测试跳过的最常见用法之一，`py.test`提供了一个方便的装饰器，允许我们在一行中执行此操作。该装饰器接受一个字符串，其中可以包含任何可执行的Python代码，该代码将求值为布尔值。例如，以下测试只会在Python
    3或更高版本上运行：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `py.test.mark.xfail` decorator behaves similarly, except that it marks a
    test as expected to fail, similar to `unittest.expectedFailure()`. If the test
    is successful, it will be recorded as a failure; if it fails, it will be reported
    as expected behavior. In the case of `xfail`, the conditional argument is optional;
    if it is not supplied, the test will be marked as expected to fail under all conditions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test.mark.xfail`装饰器的行为类似，只是它标记一个测试为预期失败，类似于`unittest.expectedFailure()`。如果测试成功，它将被记录为失败；如果失败，它将被报告为预期行为。在`xfail`的情况下，条件参数是可选的；如果没有提供，测试将被标记为在所有条件下预期失败。'
- en: Imitating expensive objects
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟昂贵的对象
- en: Sometimes, we want to test code that requires an object be supplied that is
    either expensive or difficult to construct. While this may mean your API needs
    rethinking to have a more testable interface (which typically means a more usable
    interface), we sometimes find ourselves writing test code that has a ton of boilerplate
    to set up objects that are only incidentally related to the code under test.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要测试需要提供一个对象的代码，这个对象可能很昂贵或者很难构建。虽然这可能意味着您的API需要重新思考，以拥有一个更可测试的接口（通常意味着一个更可用的接口），但我们有时会发现自己编写的测试代码有大量样板代码来设置与被测试代码只是偶然相关的对象。
- en: 'For example, imagine we have some code that keeps track of flight statuses
    in a key-value store (such as `redis` or `memcache`) such that we can store the
    timestamp and the most recent status. A basic version of such code might look
    like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一些代码，用于在键值存储中跟踪航班状态（如`redis`或`memcache`），以便我们可以存储时间戳和最新状态。这样的基本版本代码可能如下所示：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are a lot of things we ought to test in that `change_status` method. We
    should check that it raises the appropriate error if a bad status is passed in.
    We need to ensure that it converts statuses to uppercase. We can see that the
    key and value have the correct formatting when the `set()` method is called on
    the `redis` object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`change_status`方法中，有很多事情我们应该测试。我们应该检查如果传入了错误的状态，它是否引发了适当的错误。我们需要确保它将状态转换为大写。我们可以看到当在`redis`对象上调用`set()`方法时，键和值是否具有正确的格式。
- en: One thing we don't have to check in our unit tests, however, is that the `redis`
    object is properly storing the data. This is something that absolutely should
    be tested in integration or application testing, but at the unit test level, we
    can assume that the py-redis developers have tested their code and that this method
    does what we want it to. As a rule, unit tests should be self-contained and not
    rely on the existence of outside resources, such as a running Redis instance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的单元测试中不需要检查`redis`对象是否正确存储数据。这是绝对应该在集成或应用程序测试中进行测试的内容，但在单元测试级别，我们可以假设py-redis开发人员已经测试过他们的代码，并且这个方法确实符合我们的要求。通常，单元测试应该是自包含的，不依赖于外部资源的存在，比如正在运行的Redis实例。
- en: 'Instead, we only need to test that the `set()` method was called the appropriate
    number of times and with the appropriate arguments. We can use `Mock()` objects
    in our tests to replace the troublesome method with an object we can introspect.
    The following example illustrates the use of mock:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们只需要测试`set()`方法被调用的次数是否正确，以及传入的参数是否正确。我们可以在测试中使用`Mock()`对象来替换有问题的方法，以便我们可以内省。以下示例说明了模拟的使用：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This test, written using `py.test` syntax, asserts that the correct exception
    is raised when an inappropriate argument is passed in. In addition, it creates
    a mock object for the `set` method and makes sure that it is never called. If
    it was, it would mean there was a bug in our exception handling code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个使用`py.test`语法编写的测试断言在传入不合适的参数时会引发正确的异常。此外，它为`set`方法创建了一个模拟对象，并确保它从未被调用。如果被调用了，这意味着我们的异常处理代码中存在错误。
- en: Simply replacing the method worked fine in this case, since the object being
    replaced was destroyed in the end. However, we often want to replace a function
    or method only for the duration of a test. For example, if we want to test the
    timestamp formatting in the mock method, we need to know exactly what `datetime.datetime.now()`
    is going to return. However, this value changes from run to run. We need some
    way to pin it to a specific value so we can test it deterministically.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，简单地替换方法效果很好，因为被替换的对象最终被销毁了。然而，我们经常希望仅在测试期间替换函数或方法。例如，如果我们想测试模拟方法中的时间戳格式，我们需要确切地知道`datetime.datetime.now()`将返回什么。然而，这个值会随着运行而改变。我们需要一种方法将其固定到一个特定的值，以便我们可以进行可预测的测试。
- en: 'Remember monkey-patching? Temporarily setting a library function to a specific
    value is an excellent use of it. The mock library provides a patch context manager
    that allows us to replace attributes on existing libraries with mock objects.
    When the context manager exits, the original attribute is automatically restored
    so as not to impact other test cases. Here''s an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得猴子补丁吗？临时将库函数设置为特定值是其极好的用法。模拟库提供了一个修补上下文管理器，允许我们用模拟对象替换现有库的属性。当上下文管理器退出时，原始属性会自动恢复，以免影响其他测试用例。下面是一个例子：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we first construct a value called `fake_now`, which we will
    set as the return value of the `datetime.datetime.now` function. We have to construct
    this object before we patch `datetime.datetime` because otherwise we'd be calling
    the patched `now` function before we constructed it!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先构造了一个名为`fake_now`的值，我们将把它设置为`datetime.datetime.now`函数的返回值。我们必须在修补`datetime.datetime`之前构造这个对象，否则我们会在构造它之前调用修补的`now`函数！
- en: The `with` statement invites the patch to replace the `datetime.datetime` module
    with a mock object, which is returned as the value `dt`. The neat thing about
    mock objects is that any time you access an attribute or method on that object,
    it returns another mock object. Thus when we access `dt.now`, it gives us a new
    mock object. We set the `return_value` of that object to our `fake_now` object;
    that way, whenever the `datetime.datetime.now` function is called, it will return
    our object instead of a new mock object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句邀请修补程序用模拟对象替换`datetime.datetime`模块，并将其返回为值`dt`。模拟对象的好处是，每当您访问该对象的属性或方法时，它都会返回另一个模拟对象。因此，当我们访问`dt.now`时，它会给我们一个新的模拟对象。我们将该对象的`return_value`设置为我们的`fake_now`对象；这样，每当调用`datetime.datetime.now`函数时，它将返回我们的对象，而不是一个新的模拟对象。'
- en: Then, after calling our `change_status` method with known values, we use the
    mock class's `assert_called_once_with` function to ensure that the `now` function
    was indeed called exactly once with no arguments. We then call it a second time
    to prove that the `redis.set` method was called with arguments that were formatted
    as we expected them to be.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在使用已知值调用我们的`change_status`方法之后，我们使用模拟类的`assert_called_once_with`函数来确保`now`函数确实被调用了一次，且没有参数。然后我们再次调用它，以证明`redis.set`方法被调用时，参数的格式与我们预期的一样。
- en: The previous example is a good indication of how writing tests can guide our
    API design. The `FlightStatusTracker` object looks sensible at first glance; we
    construct a `redis` connection when the object is constructed, and we call into
    it when we need it. When we write tests for this code, however, we discover that
    even if we mock out that `self.redis` variable on a `FlightStatusTracker`, the
    `redis` connection still has to be constructed. This call actually fails if there
    is no Redis server running, and our tests also fail.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子很好地说明了编写测试如何指导我们的API设计。`FlightStatusTracker`对象乍一看似乎很合理；我们在对象构造时构建了一个`redis`连接，并在需要时调用它。然而，当我们为这段代码编写测试时，我们发现，即使我们在`FlightStatusTracker`上模拟了`self.redis`变量，`redis`连接仍然必须被构造。如果没有运行Redis服务器，这个调用实际上会失败，我们的测试也会失败。
- en: 'We could solve this problem by mocking out the `redis.StrictRedis` class to
    return a mock in a `setUp` method. A better idea, however, might be to rethink
    our example. Instead of constructing the `redis` instance inside`__init__`, perhaps
    we should allow the user to pass one in, as in the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`setUp`方法中模拟`redis.StrictRedis`类来解决这个问题。然而，一个更好的想法可能是重新思考我们的示例。与其在`__init__`中构造`redis`实例，也许我们应该允许用户传入一个，就像下面的示例中一样：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This allows us to pass a mock in when we are testing, so the `StrictRedis` method
    never gets constructed. However, it also allows any client code that talks to
    `FlightStatusTracker` to pass in their own `redis` instance. There are a variety
    of reasons they might want to do this. They may have already constructed one for
    other parts of their code. They may have created an optimized implementation of
    the `redis` API. Perhaps they have one that logs metrics to their internal monitoring
    systems. By writing a unit test, we've uncovered a use case that makes our API
    more flexible from the start, rather than waiting for clients to demand we support
    their exotic needs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在测试时传入一个模拟对象，这样`StrictRedis`方法就不会被构造。然而，它也允许任何与`FlightStatusTracker`交互的客户端代码传入他们自己的`redis`实例。他们可能有各种各样的原因想要这样做。他们可能已经为其代码的其他部分构造了一个`redis`实例。他们可能已经创建了一个优化的`redis`
    API实现。也许他们有一个将指标记录到内部监控系统的实例。通过编写单元测试，我们发现了一个使用案例，使我们的API从一开始就更加灵活，而不是等待客户要求支持他们的特殊需求。
- en: This has been a brief introduction to the wonders of mocking code. Mocks are
    part of the standard `unittest` library since Python 3.3, but as you see from
    these examples, they can also be used with `py.test` and other libraries. Mocks
    have other more advanced features that you may need to take advantage of as your
    code gets more complicated. For example, you can use the `spec` argument to invite
    a mock to imitate an existing class so that it raises an error if code tries to
    access an attribute that does not exist on the imitated class. You can also construct
    mock methods that return different arguments each time they are called by passing
    a list as the `side_effect` argument. The `side_effect` parameter is quite versatile;
    you can also use it to execute arbitrary functions when the mock is called or
    to raise an exception.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对模拟代码奇迹的简要介绍。自Python 3.3以来，模拟是标准的`unittest`库的一部分，但正如你从这些例子中看到的，它们也可以与`py.test`和其他库一起使用。模拟还有其他更高级的功能，当你的代码变得更加复杂时，你可能需要利用这些功能。例如，你可以使用`spec`参数邀请模拟模仿现有的类，以便在代码尝试访问模仿类上不存在的属性时引发错误。你还可以构造模拟方法，每次调用时返回不同的参数，通过将列表作为`side_effect`参数传递。`side_effect`参数非常灵活；你还可以使用它在调用模拟时执行任意函数或引发异常。
- en: In general, we should be quite stingy with mocks. If we find ourselves mocking
    out multiple elements in a given unit test, we may end up testing the mock framework
    rather than our real code. This serves no useful purpose whatsoever; after all,
    mocks are well-tested already! If our code is doing a lot of this, it's probably
    another sign that the API we are testing is poorly designed. Mocks should exist
    at the boundaries between the code under test and the libraries they interface
    with. If this isn't happening, we may need to change the API so that the boundaries
    are redrawn in a different place.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们在使用模拟时应该非常节俭。如果我们发现自己在给定的单元测试中模拟了多个元素，我们可能最终测试的是模拟框架，而不是我们真正的代码。这毫无用处；毕竟，模拟已经经过了充分的测试！如果我们的代码经常这样做，这可能是我们正在测试的API设计不好的另一个迹象。模拟应该存在于被测试代码和它们接口的库之间的边界上。如果这种情况没有发生，我们可能需要改变API，以便在不同的地方重新划定边界。
- en: How much testing is enough?
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试多少是足够的？
- en: We've already established that untested code is broken code. But how can we
    tell how well our code is tested? How do we know how much of our code is actually
    being tested and how much is broken? The first question is the more important
    one, but it's hard to answer. Even if we know we have tested every line of code
    in our application, we do not know that we have tested it properly. For example,
    if we write a stats test that only checks what happens when we provide a list
    of integers, it may still fail spectacularly if used on a list of floats or strings
    or self-made objects. The onus of designing complete test suites still lies with
    the programmer.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定未经测试的代码是有问题的代码。但是我们如何知道我们的代码被测试得有多好？我们如何知道我们的代码有多少被测试，有多少是有问题的？第一个问题更重要，但很难回答。即使我们知道我们已经测试了应用程序中的每一行代码，我们也不知道我们是否已经适当地测试了它。例如，如果我们编写了一个统计测试，只检查当我们提供一个整数列表时会发生什么，如果用于浮点数、字符串或自定义对象的列表，它可能仍然会失败。设计完整的测试套件的责任仍然在程序员身上。
- en: The second question—how much of our code is actually being tested—is easy to
    verify. Code coverage is essentially an estimate of the number of lines of code
    that are executed by a program. If we know that number and the number of lines
    that are in the program, we can get an estimate of what percentage of the code
    was really tested, or covered. If we additionally have an indicator as to which
    lines were not tested, we can more easily write new tests to ensure those lines
    are less broken.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题——我们的代码有多少实际被测试——很容易验证。代码覆盖本质上是程序执行的代码行数的估计。如果我们知道这个数字和程序中的代码行数，我们就可以估计实际被测试或覆盖的代码百分比。如果我们另外有一个指示哪些行没有被测试，我们可以更容易地编写新的测试来确保这些行不会出错。
- en: The most popular tool for testing code coverage is called, memorably enough,
    `coverage.py`. It can be installed like most other third-party libraries using
    the command `pip install coverage`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码覆盖率最流行的工具叫做`coverage.py`。它可以像大多数其他第三方库一样使用`pip install coverage`命令进行安装。
- en: 'We don''t have space to cover all the details of the coverage API, so we''ll
    just look at a few typical examples. If we have a Python script that runs all
    our unit tests for us (for example, using `unittest.main`, a custom test runner
    or `discover`), we can use the following command to perform a coverage analysis:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有空间来涵盖覆盖API的所有细节，所以我们只看一些典型的例子。如果我们有一个运行所有单元测试的Python脚本（例如，使用`unittest.main`，自定义测试运行器或`discover`），我们可以使用以下命令进行覆盖分析：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This command will exit normally, but it creates a file named `.coverage` that
    holds the data from the run. We can now use the `coverage report` command to get
    an analysis of code coverage:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将正常退出，但它会创建一个名为`.coverage`的文件，其中包含运行的数据。现在我们可以使用`coverage report`命令来获取代码覆盖的分析：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This basic report lists the files that were executed (our unit test and a module
    it imported). The number of lines of code in each file, and the number that were
    executed by the test are also listed. The two numbers are then combined to estimate
    the amount of code coverage. If we pass the `-m` option to the report command,
    it will additionally add a column that looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本报告列出了被执行的文件（我们的单元测试和一个导入的模块）。还列出了每个文件中的代码行数，以及测试执行的代码行数。然后将这两个数字合并，估计代码覆盖的数量。如果我们在报告命令中传递`-m`选项，它还会额外添加一个看起来像这样的列：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The ranges of lines listed here identify lines in the `stats` module that were
    not executed during the test run.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的行范围标识了在测试运行期间未执行的`stats`模块中的行。
- en: 'The example we just ran the code coverage tool on uses the same stats module
    we created earlier in the chapter. However, it deliberately uses a single test
    that fails to test a lot of code in the file. Here''s the test:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚运行代码覆盖工具的示例使用了我们在本章前面创建的相同的stats模块。然而，它故意使用了一个失败的单一测试来测试文件中的大量代码。这是测试：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code doesn't test the median or mode functions, which correspond to the
    line numbers that the coverage output told us were missing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有测试中位数或模式函数，这对应于覆盖输出告诉我们缺失的行号。
- en: 'The textual report is sufficient, but if we use the command `coverage html`,
    we can get an even fancier interactive HTML report that we can view in a web browser.
    The web page even highlights which lines in the source code were and were not
    tested. Here''s how it looks:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 文本报告已经足够了，但如果我们使用命令`coverage html`，我们可以得到一个更漂亮的交互式HTML报告，我们可以在Web浏览器中查看。网页甚至会突出显示源代码中测试和未测试的行。它看起来是这样的：
- en: '![How much testing is enough?](images/8781OS_12_01.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![测试多少是足够的？](images/8781OS_12_01.jpg)'
- en: We can use the `coverage.py` module with `py.test` as well. We'll need to install
    the `py.test` plugin for code coverage, using `pip install pytest-coverage`. The
    plugin adds several command-line options to `py.test`, the most useful being `--cover-report`,
    which can be set to `html`, `report`, or `annotate` (the latter actually modifies
    the source code to highlight any lines that were not covered).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`coverage.py`模块与`py.test`一起使用。我们需要安装`py.test`的代码覆盖插件，使用`pip install pytest-coverage`。该插件为`py.test`添加了几个命令行选项，其中最有用的是`--cover-report`，可以设置为`html`、`report`或`annotate`（后者实际上修改源代码以突出显示任何未覆盖的行）。
- en: Unfortunately, if we could somehow run a coverage report on this section of
    the chapter, we'd find that we have not covered most of what there is to know
    about code coverage! It is possible to use the coverage API to manage code coverage
    from within our own programs (or test suites), and `coverage.py` accepts numerous
    configuration options that we haven't touched on. We also haven't discussed the
    difference between statement coverage and branch coverage (the latter is much
    more useful, and the default in recent versions of `coverage.py`) or other styles
    of code coverage.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们可以在本章的这一部分上运行覆盖报告，我们会发现我们并没有覆盖大部分关于代码覆盖的知识！可以使用覆盖API来从我们自己的程序（或测试套件）中管理代码覆盖，并且`coverage.py`接受许多我们尚未涉及的配置选项。我们还没有讨论语句覆盖和分支覆盖之间的区别（后者更有用，并且是最近版本的`coverage.py`的默认值），或其他风格的代码覆盖。
- en: Bear in mind that while 100 percent code coverage is a lofty goal that we should
    all strive for, 100 percent coverage is not enough! Just because a statement was
    tested does not mean that it was tested properly for all possible inputs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然100%的代码覆盖是我们应该努力追求的一个远大目标，但100%的覆盖是不够的！仅仅因为一个语句被测试了，并不意味着它对所有可能的输入都进行了适当的测试。
- en: Case study
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: Let's walk through test-driven development by writing a small, tested, cryptography
    application. Don't worry, you won't need to understand the mathematics behind
    complicated modern encryption algorithms such as Threefish or RSA. Instead, we'll
    be implementing a sixteenth-century algorithm known as the Vigenère cipher. The
    application simply needs to be able to encode and decode a message, given an encoding
    keyword, using this cipher.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个小型的、经过测试的密码应用程序来走一遍测试驱动开发。不用担心，你不需要理解复杂的现代加密算法（如Threefish或RSA）背后的数学原理。相反，我们将实现一个被称为维吉尼亚密码的十六世纪算法。该应用程序只需要能够使用这个密码对消息进行编码和解码，给定一个编码关键字。
- en: 'First, we need to understand how the cipher works if we apply it manually (without
    a computer). We start with a table like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解如果我们手动应用密码，它是如何工作的（没有计算机）。我们从这样的表开始：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Given a keyword, TRAIN, we can encode the message ENCODED IN PYTHON as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个关键字TRAIN，我们可以这样编码消息ENCODED IN PYTHON：
- en: 'Repeat the keyword and message together such that it is easy to map letters
    from one to the other:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复关键字和消息在一起，以便从一个到另一个映射字母变得容易：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For each letter in the plain text, find the row that begins with that letter
    in the table.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于明文中的每个字母，找到以该字母开头的行在表中的位置。
- en: Find the column with the letter associated with the keyword letter for the chosen
    plaintext letter.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到与所选明文字母的关键字字母相关联的列。
- en: The encoded character is at the intersection of this row and column.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码字符位于这一行和列的交点处。
- en: For example, the row starting with E intersects the column starting with T at
    the character X. So, the first letter in the ciphertext is X. The row starting
    with N intersects the column starting with R at the character E, leading to the
    ciphertext XE. C intersects A at C, and O intersects I at W. D and N map to Q
    while E and T map to X. The full encoded message is XECWQXUIVCRKHWA.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以E开头的行与以T开头的列相交于字符X。因此，密文的第一个字母是X。以N开头的行与以R开头的列相交于字符E，导致密文XE。C与A相交于C，O与I相交于W。D和N映射到Q，而E和T映射到X。完整的编码消息是XECWQXUIVCRKHWA。
- en: Decoding basically follows the opposite procedure. First, find the row with
    the character for the shared keyword (the T row), then find the location in that
    row where the encoded character (the X) is located. The plaintext character is
    at the top of the column for that row (the E).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 解码基本上遵循相反的过程。首先，找到具有共享关键字的字符（T行），然后找到该行中编码字符（X）的位置。明文字符位于该行的列顶部（E）。
- en: Implementing it
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施它
- en: Our program will need an `encode` method that takes a keyword and plaintext
    and returns the ciphertext, and a `decode` method that accepts a keyword and ciphertext
    and returns the original message.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将需要一个`encode`方法，它接受关键字和明文并返回密文，以及一个`decode`方法，它接受关键字和密文并返回原始消息。
- en: 'But rather than just writing those methods, let''s follow a test-driven development
    strategy. We''ll be using `py.test` for our unit testing. We need an `encode`
    method, and we know what it has to do; let''s write a test for that method first:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不仅仅是编写这些方法，让我们遵循测试驱动的开发策略。我们将使用`py.test`进行单元测试。我们需要一个`encode`方法，我们知道它该做什么；让我们先为该方法编写一个测试：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This test fails, naturally, because we aren't importing a `VigenereCipher` class
    anywhere. Let's create a new module to hold that class.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试自然会失败，因为我们没有在任何地方导入`VigenereCipher`类。让我们创建一个新模块来保存该类。
- en: 'Let''s start with the following `VigenereCipher` class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下`VigenereCipher`类开始：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we add a `from vigenere_cipher import VigenereCipher` line to the top of
    our test class and run `py.test`, the preceding test will pass! We've finished
    our first test-driven development cycle.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在我们的测试类顶部添加一行`from vigenere_cipher import VigenereCipher`并运行`py.test`，前面的测试将通过！我们完成了我们的第一个测试驱动开发周期。
- en: 'Obviously, returning a hardcoded string is not the most sensible implementation
    of a cipher class, so let''s add a second test:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，返回一个硬编码的字符串并不是密码类的最明智的实现，所以让我们添加第二个测试：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Ah, now that test will fail. It looks like we''re going to have to work harder.
    But I just thought of something: what if someone tries to encode a string with
    spaces or lowercase characters? Before we start implementing the encoding, let''s
    add some tests for these cases, so we don''t we forget them. The expected behavior
    will be to remove spaces, and to convert lowercase letters to capitals:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，现在那个测试会失败。看来我们要更加努力了。但我突然想到了一件事：如果有人尝试对一个带有空格或小写字符的字符串进行编码会怎么样？在我们开始实现编码之前，让我们为这些情况添加一些测试，这样我们就不会忘记它们。预期的行为将是去除空格，并将小写字母转换为大写：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we run the new test suite, we find that the new tests pass (they expect the
    same hardcoded string). But they ought to fail later if we forget to account for
    these cases.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行新的测试套件，我们会发现新的测试通过了（它们期望相同的硬编码字符串）。但是如果我们忘记考虑这些情况，它们以后应该会失败。
- en: 'Now that we have some test cases, let''s think about how to implement our encoding
    algorithm. Writing code to use a table like we used in the earlier manual algorithm
    is possible, but seems complicated, considering that each row is just an alphabet
    rotated by an offset number of characters. It turns out (I asked Wikipedia) that
    we can use modulo arithmetic to combine the characters instead of doing a table
    lookup. Given plaintext and keyword characters, if we convert the two letters
    to their numerical values (with A being 0 and Z being 25), add them together,
    and take the remainder mod 26, we get the ciphertext character! This is a straightforward
    calculation, but since it happens on a character-by-character basis, we should
    probably put it in its own function. And before we do that, we should write a
    test for the new function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些测试用例，让我们考虑如何实现我们的编码算法。编写代码使用像我们在早期手动算法中使用的表是可能的，但考虑到每一行只是一个按偏移字符旋转的字母表，这似乎很复杂。事实证明（我问了维基百科），我们可以使用模算术来组合字符，而不是进行表查找。给定明文和关键词字符，如果我们将两个字母转换为它们的数值（A为0，Z为25），将它们相加，并取余数模26，我们就得到了密文字符！这是一个简单的计算，但由于它是逐个字符进行的，我们可能应该将它放在自己的函数中。在这之前，我们应该为新函数编写一个测试：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we can write the code to make this function work. In all honesty, I had
    to run the test several times before I got this function completely correct; first
    I returned an integer, and then I forgot to shift the character back up to the
    normal ASCII scale from the zero-based scale. Having the test available made it
    easy to test and debug these errors. This is another bonus of test-driven development.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写代码使这个函数工作。老实说，我在完全正确之前不得不运行测试几次；首先我返回了一个整数，然后我忘记了将字符从零基础的比例转回到正常的ASCII比例。有了测试可用，很容易测试和调试这些错误。这是测试驱动开发的另一个好处。
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that `combine_characters` is tested, I thought we'd be ready to implement
    our `encode` function. However, the first thing we want inside that function is
    a repeating version of the keyword string that is as long as the plaintext. Let's
    implement a function for that first. Oops, I mean let's implement the test first!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`combine_characters`已经经过测试，我以为我们已经准备好实现我们的`encode`函数了。然而，在该函数内部我们首先需要一个与明文一样长的关键词字符串的重复版本。让我们先实现一个函数。哎呀，我是说让我们先实现测试！
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before writing this test, I expected to write `extend_keyword` as a standalone
    function that accepted a keyword and an integer. But as I started drafting the
    test, I realized it made more sense to use it as a helper method on the `VigenereCipher`
    class. This shows how test-driven development can help design more sensible APIs.
    Here''s the method implementation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这个测试之前，我期望将`extend_keyword`作为一个独立的函数，接受一个关键词和一个整数。但是当我开始起草测试时，我意识到将其作为`VigenereCipher`类的辅助方法更合理。这显示了测试驱动开发如何帮助设计更合理的API。这是方法的实现：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once again, this took a few runs of the test to get right. I ended up adding
    a second versions of the test, one with fifteen and one with sixteen letters,
    to make sure it works if the integer division has an even number.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这需要几次测试才能做对。最后我添加了第二个版本的测试，一个有十五个字母，一个有十六个字母，以确保它在整数除法有偶数的情况下也能正常工作。
- en: 'Now we''re finally ready to write our `encode` method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好编写我们的`encode`方法了：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That looks correct. Our test suite should pass now, right?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来正确。我们的测试套件现在应该通过了，对吗？
- en: 'Actually, if we run it, we''ll find that two tests are still failing. We totally
    forgot about the spaces and lowercase characters! It is a good thing we wrote
    those tests to remind us. We''ll have to add this line at the beginning of the
    method:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们运行它，我们会发现仍然有两个测试失败。我们完全忘记了空格和小写字符！我们写了这些测试来提醒我们是一件好事。我们将不得不在方法的开头添加这一行：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If we have an idea about a corner case in the middle of implementing something,
    we can create a test describing that idea. We don't even have to implement the
    test; we can just run `assert False` to remind us to implement it later. The failing
    test will never let us forget the corner case and it can't be ignored like filing
    a task can. If it takes a while to get around to fixing the implementation, we
    can mark the test as an expected failure.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在实现某事的过程中对一个特殊情况有了想法，我们可以创建一个描述这个想法的测试。我们甚至不需要实现这个测试；我们可以运行`assert False`来提醒我们以后再实现它。失败的测试永远不会让我们忘记这个特殊情况，它不能被忽视，就像提交任务一样。如果修复实现需要一段时间，我们可以将测试标记为预期失败。
- en: 'Now all the tests pass successfully. This chapter is pretty long, so we''ll
    condense the examples for decoding. Here are a couple tests:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的测试都成功通过了。这一章非常长，所以我们将压缩解码的示例。以下是一些测试：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here''s the `separate_character` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`separate_character`函数：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And the `decode` method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`decode`方法：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'These methods have a lot of similarity to those used for encoding. The great
    thing about having all these tests written and passing is that we can now go back
    and modify our code, knowing it is still safely passing the tests. For example,
    if we replace our existing `encode` and `decode` methods with these refactored
    methods, our tests still pass:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与编码时使用的方法非常相似。有了所有这些编写并通过的测试，我们现在可以回过头修改我们的代码，知道它仍然安全地通过了测试。例如，如果我们用这些重构后的方法替换我们现有的`encode`和`decode`方法，我们的测试仍然通过：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is the final benefit of test-driven development, and the most important.
    Once the tests are written, we can improve our code as much as we like and be
    confident that our changes didn''t break anything we have been testing for. Furthermore,
    we know exactly when our refactor is finished: when the tests all pass.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试驱动开发的最终好处，也是最重要的。一旦测试编写完成，我们可以尽情改进我们的代码，而且可以确信我们的更改没有破坏我们一直在测试的任何东西。此外，我们知道我们的重构何时完成：当所有测试都通过时。
- en: Of course, our tests may not comprehensively test everything we need them to;
    maintenance or code refactoring can still cause undiagnosed bugs that don't show
    up in testing. Automated tests are not foolproof. If bugs do occur, however, it
    is still possible to follow a test-driven plan; step one is to write a test (or
    multiple tests) that duplicates or "proves" that the bug in question is occurring.
    This will, of course, fail. Then write the code to make the tests stop failing.
    If the tests were comprehensive, the bug will be fixed, and we will know if it
    ever happens again, as soon as we run the test suite.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的测试可能并不全面测试我们需要的一切；维护或代码重构仍然可能导致未经诊断的错误，这些错误在测试中不会显示出来。自动化测试并不是绝对可靠的。然而，如果出现错误，仍然可以遵循测试驱动的计划；第一步是编写一个测试（或多个测试），复制或“证明”所讨论的错误正在发生。这当然会失败。然后编写代码使测试停止失败。如果测试全面，错误将被修复，我们将知道它是否再次发生，一旦我们运行测试套件。
- en: Finally, we can try to determine how well our tests operate on this code. With
    the `py.test` coverage plugin installed, `py.test –coverage-report=report` tells
    us that our test suite has 100 percent code coverage. This is a great statistic,
    but we shouldn't get too cocky about it. Our code hasn't been tested when encoding
    messages that have numbers, and its behavior with such inputs is thus undefined.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以尝试确定我们的测试在这段代码上的运行情况。安装了`py.test`覆盖插件后，`py.test –coverage-report=report`告诉我们我们的测试套件覆盖了100%的代码。这是一个很好的统计数据，但我们不应该对此过于自负。当编码带有数字的消息时，我们的代码还没有经过测试，因此其行为是未定义的。
- en: Exercises
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Practice test-driven development. That is your first exercise. It's easier to
    do this if you're starting a new project, but if you have existing code you need
    to work on, you can start by writing tests for each new feature you implement.
    This can become frustrating as you become more enamored with automated tests.
    The old, untested code will start to feel rigid and tightly coupled, and will
    become uncomfortable to maintain; you'll start feeling like changes you make are
    breaking the code and you have no way of knowing, for lack of tests. But if you
    start small, adding tests will improve, the codebase improves over time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 练习测试驱动开发。这是你的第一个练习。如果你开始一个新项目，这样做会更容易，但如果你有现有的代码需要处理，你可以开始为你实现的每个新功能编写测试。随着你对自动化测试的热爱增加，这可能会变得令人沮丧。未经测试的旧代码将开始感觉僵化和紧密耦合，并且维护起来会变得不舒服；你会开始感觉到你所做的更改正在破坏代码，而你却无法知道，因为没有测试。但是如果你从小处开始，添加测试将改善，随着时间的推移，代码库会得到改善。
- en: So to get your feet wet with test-driven development, start a fresh project.
    Once you've started to appreciate the benefits (you will) and realize that the
    time spent writing tests is quickly regained in terms of more maintainable code,
    you'll want to start writing tests for existing code. This is when you should
    start doing it, not before. Writing tests for code that we "know" works is boring.
    It is hard to get interested in the project until you realize just how broken
    the code we thought was working really is.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要开始尝试测试驱动开发，可以开始一个新项目。一旦你开始意识到写测试的好处（你会的），并意识到写测试所花费的时间很快就能通过更易于维护的代码得到回报，你就会想要开始为现有代码编写测试。这就是你应该开始做的时候，而不是之前。为我们“知道”有效的代码编写测试是无聊的。在意识到我们认为有效的代码实际上有多糟糕之前，很难对项目产生兴趣。
- en: Try writing the same set of tests using both the built-in `unittest` module
    and `py.test`. Which do you prefer? `unittest` is more similar to test frameworks
    in other languages, while `py.test` is arguably more Pythonic. Both allow us to
    write object-oriented tests and to test object-oriented programs with ease.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用内置的`unittest`模块和`py.test`编写相同的一组测试。你更喜欢哪个？`unittest`更类似于其他语言中的测试框架，而`py.test`可以说更符合Python的风格。两者都允许我们编写面向对象的测试，并轻松测试面向对象的程序。
- en: We used `py.test` in our case study, but we didn't touch on any features that
    wouldn't have been easily testable using `unittest`. Try adapting the tests to
    use test skipping or funcargs. Try the various setup and teardown methods, and
    compare their use to funcargs. Which feels more natural to you?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例研究中，我们使用了`py.test`，但我们没有涉及任何使用`unittest`不容易进行测试的功能。尝试调整测试以使用测试跳过或funcargs。尝试各种设置和拆卸方法，并将它们与funcargs进行比较。哪种对你来说更自然？
- en: In our case study, we have a lot of tests that use a similar `VigenereCipher`
    object; try reworking this code to use a funcarg. How many lines of code does
    it save?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例研究中，我们有很多使用类似`VigenereCipher`对象的测试；尝试重新设计这段代码以使用funcarg。这样能节省多少行代码？
- en: Try running a coverage report on the tests you've written. Did you miss testing
    any lines of code? Even if you have 100 percent coverage, have you tested all
    the possible inputs? If you're doing test-driven development, 100 percent coverage
    should follow quite naturally, as you will write a test before the code that satisfies
    that test. However, if writing tests for existing code, it is more likely that
    there will be edge conditions that go untested.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对你编写的测试运行覆盖率报告。你有没有漏掉测试任何代码行？即使你有100%的覆盖率，你是否测试了所有可能的输入？如果你在进行测试驱动开发，100%的覆盖率应该自然而然地遵循，因为你会在满足该测试的代码之前编写测试。然而，如果为现有代码编写测试，很可能会有未经测试的边缘情况。
- en: 'Think carefully about the values that are somehow different: empty lists when
    you expect full ones, zero or one or infinity compared to intermediate integers,
    floats that don''t round to an exact decimal place, strings when you expected
    numerals, or the ubiquitous `None` value when you expected something meaningful.
    If your tests cover such edge cases, your code will be in good shape.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑一下某种程度上不同的值：当你期望完整的列表时却得到空列表，与中间整数相比的零或一或无穷大，不能精确到小数位的浮点数，当你期望数字时得到字符串，或者当你期望有意义的东西时得到无处不在的`None`值。如果你的测试涵盖了这些边缘情况，你的代码将会很好。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have finally covered the most important topic in Python programming: automated
    testing. Test-driven development is considered a best practice. The standard library
    `unittest` module provides a great out-of-the-box solution for testing, while
    the `py.test` framework has some more Pythonic syntaxes. Mocks can be used to
    emulate complex classes in our tests. Code coverage gives us an estimate of how
    much of our code is being run by our tests, but it does not tell us that we have
    tested the right things.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于涵盖了Python编程中最重要的主题：自动化测试。测试驱动开发被认为是最佳实践。标准库`unittest`模块提供了一个很好的开箱即用的测试解决方案，而`py.test`框架具有一些更Pythonic的语法。模拟可以用于在我们的测试中模拟复杂的类。代码覆盖率给出了我们的代码有多少被我们的测试运行的估计，但它并不告诉我们我们已经测试了正确的东西。
- en: 'In the next chapter, we''ll jump into a completely different topic: concurrency.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进入一个完全不同的主题：并发。
