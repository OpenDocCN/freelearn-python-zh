- en: Chapter 7. Additional Tuple Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。其他元组技术
- en: Many of the examples we've looked at have either been `scalar` functions, or
    relatively simple structures built from small tuples. We can often exploit Python's
    immutable `namedtuple` as a way to build complex data structures. We'll look at
    how we use and how we create `namedtuples`. We'll also look at ways that immutable
    `namedtuples` can be used instead of stateful object classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看到的许多示例要么是`scalar`函数，要么是从小元组构建的相对简单的结构。我们经常可以利用Python的不可变`namedtuple`来构建复杂的数据结构。我们将看看我们如何使用以及如何创建`namedtuples`。我们还将研究不可变的`namedtuples`可以用来代替有状态对象类的方法。
- en: One of the beneficial features of object-oriented programming is the ability
    to create complex data structures incrementally. In some respects, an object is
    simply a cache for results of functions; this will often fit well with functional
    design patterns. In other cases, the object paradigm provides for property methods
    that include sophisticated calculations. This is an even better fit for functional
    design ideas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个有益特性是逐步创建复杂数据结构的能力。在某些方面，对象只是函数结果的缓存；这通常与功能设计模式很匹配。在其他情况下，对象范式提供了包括复杂计算的属性方法。这更适合功能设计思想。
- en: In some cases, however, object class definitions are used statefully to create
    complex objects. We'll look at a number of alternatives that provide similar features
    without the complexities of stateful objects. We can identify stateful class definitions
    and then include meta-properties for valid or required ordering of method function
    calls. Statements such as *If X.p() is called before X.q(), the results are undefined*
    are outside the formalism of the language and are meta-properties of a class.
    Sometimes, stateful classes include the overhead of explicit assertions and error
    checking to assure that methods are used in the proper order. If we avoid stateful
    classes, we eliminate these kinds of overheads.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，对象类定义被用于有状态地创建复杂对象。我们将研究一些提供类似功能的替代方案，而不涉及有状态对象的复杂性。我们可以识别有状态的类定义，然后包括元属性以对方法函数调用的有效或必需排序。诸如*如果在调用X.q()之前调用X.p()，结果是未定义的*之类的陈述是语言形式主义之外的，是类的元属性。有时，有状态的类包括显式断言和错误检查的开销，以确保方法按正确的顺序使用。如果我们避免有状态的类，我们就消除了这些开销。
- en: We'll also look at some techniques to write generic functions outside any polymorphic
    class definition. Clearly, we can rely on `Callable` classes to create a polymorphic
    class hierarchy. In some cases, this might be a needless overhead in a functional
    design.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究一些在任何多态类定义之外编写通用函数的技术。显然，我们可以依赖`Callable`类来创建多态类层次结构。在某些情况下，这可能是功能设计中不必要的开销。
- en: Using an immutable namedtuple as a record
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不可变的命名元组作为记录
- en: 'In [Chapter 3](ch03.html "Chapter 3. Functions, Iterators, and Generators"),
    *Functions, Iterators, and Generators*, we showed two common techniques to work
    with tuples. We''ve also hinted at a third way to handle complex structures. We
    can do any of the following, depending on the circumstances:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。函数、迭代器和生成器")，“函数、迭代器和生成器”中，我们展示了处理元组的两种常见技术。我们也暗示了处理复杂结构的第三种方法。根据情况，我们可以执行以下任一操作：
- en: Use `lambdas` (or functions) to select a named item using the index
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`lambdas`（或函数）通过索引选择一个命名项目
- en: Use `lambdas` (or functions) with `*parameter` to select an item by parameter
    name, which maps to an index
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`lambdas`（或函数）与`*parameter`通过参数名称选择一个项目，该参数名称映射到一个索引
- en: Use `namedtuples` to select an item by attribute name or index
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`namedtuples`通过属性名称或索引选择项目
- en: Our trip data, introduced in [Chapter 4](ch04.html "Chapter 4. Working with
    Collections"), *Working with Collections*, has a rather complex structure. The
    data started as an ordinary time series of position reports. To compute the distances
    covered, we transposed the data into a sequence of legs with a start position,
    end position, and distance as a nested three-tuple.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅行数据，介绍在[第4章](ch04.html "第4章。与集合一起工作")，“与集合一起工作”，有一个相当复杂的结构。数据最初是一个普通的时间序列位置报告。为了计算覆盖的距离，我们将数据转换为一个具有起始位置、结束位置和距离的嵌套三元组的序列。
- en: 'Each item in the sequence of legs looks as follows as a three-tuple:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 序列中的每个项目如下所示为一个三元组：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a short trip between two points on the Chesapeake Bay.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在切萨皮克湾上两点之间的短途旅行。
- en: A nested tuple of tuples can be rather difficult to read; for example, expressions
    such as `first_leg[0][0]` aren't very informative.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套元组可能相当难以阅读；例如，诸如`first_leg[0][0]`之类的表达式并不是很有信息量。
- en: 'Let''s look at the three alternatives for selected values out of a `tuple`.
    The first technique involves defining some simple selection functions that can
    pick items from a `tuple` by index position:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从`tuple`中选择值的三种替代方案。第一种技术涉及定义一些简单的选择函数，可以按索引位置从`tuple`中选择项目：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With these definitions, we can use `latitude(start(first_leg))` to refer to
    a specific piece of data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些定义，我们可以使用`latitude(start(first_leg))`来引用特定的数据片段。
- en: 'These definitions don''t provide much guidance on the data types involved.
    We can use a simple naming convention to make this a bit more clear. The following
    are some examples of selection functions that use a suffix:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义并没有提供有关所涉及的数据类型的指导。我们可以使用简单的命名约定来使这一点更加清晰。以下是一些使用后缀的选择函数的示例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When used judiciously, this can be helpful. It can also degenerate into an elaborately
    complex Hungarian notation as a prefix (or suffix) of each variable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用得当时，这可能是有帮助的。它也可能退化为一个复杂的匈牙利符号，作为每个变量的前缀（或后缀）。
- en: 'The second technique uses the `*parameter` notation to conceal some details
    of the index positions. The following are some selection functions that use the
    `*` notation:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术使用`*parameter`符号来隐藏索引位置的一些细节。以下是一些使用`*`符号的选择函数：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these definitions, we can use `latitude(*start(*first_leg))` to refer to
    a specific piece of data. This has the advantage of clarity. It can look a little
    odd to see the `*` operator in front of the `tuple` arguments to these selection
    functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些定义，我们可以使用`latitude(*start(*first_leg))`来引用特定的数据。这有清晰度的优势。在这些选择函数的`tuple`参数前面看到`*`运算符可能有点奇怪。
- en: 'The third technique is the `namedtuple` function. In this case, we have nested
    namedtuple functions such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种技术是`namedtuple`函数。在这种情况下，我们有嵌套的命名元组函数，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This allows us to use `first_leg.start.latitude` to fetch a particular piece
    of data. The change from prefix function names to postfix attribute names can
    be seen as a helpful emphasis. It can also be seen as a confusing shift in the
    syntax.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以使用`first_leg.start.latitude`来获取特定的数据。从前缀函数名称到后缀属性名称的变化可以被视为一种有用的强调。也可以被视为语法上的混乱转变。
- en: We will also replace `tuple()` functions with appropriate `Leg()` or `Point()`
    function calls in our process that builds the raw data. We will also have to locate
    some `return` and `yield` statements that implicitly create tuples.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在构建原始数据的过程中，用适当的`Leg()`或`Point()`函数调用替换`tuple()`函数。我们还必须找到一些隐式创建元组的`return`和`yield`语句。
- en: 'For example, take a look at the following code snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下以下代码片段：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code would be changed to the following code snippet:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将被更改为以下代码片段：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This would build `Point` objects instead of anonymous tuples of `floating-point`
    coordinates.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建`Point`对象，而不是`浮点`坐标的匿名元组。
- en: 'Similarly, we can introduce the following to build the complete trip of `Leg`
    objects:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以引入以下内容来构建`Leg`对象的完整行程：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will iterate through the basic path of points, pairing them up to make
    `start` and `end` for each `Leg` object. These pairs are then used to build `Leg`
    instances using the start point, end point, and the `haversine()` function from
    [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with Collections*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历基本路径点，将它们配对以为每个`Leg`对象创建`start`和`end`。然后使用这些配对使用`start`点、结束点和来自[第4章](ch04.html
    "第4章。与集合一起工作")的`haversine()`函数构建`Leg`实例，*与集合一起工作*。
- en: 'The `trip` object will look as follows when we try to print it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试打印`trip`对象时，它将如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that the `haversine()` function was written to use simple
    tuples. We've reused this function with `namedtuples`. As we carefully preserved
    the order the arguments, this small change in representation was handled gracefully
    by Python.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`haversine()`函数是用简单的元组编写的。我们已经将这个函数与`namedtuples`一起重用。由于我们仔细保留了参数的顺序，Python优雅地处理了这种表示上的小改变。
- en: In some cases, the `namedtuple` function adds clarity. In other cases, the `namedtuple`
    is a needless change in syntax from prefix to suffix.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`namedtuple`函数增加了清晰度。在其他情况下，`namedtuple`是从前缀到后缀的语法不必要的变化。
- en: Building namedtuples with functional constructors
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用功能构造函数构建命名元组
- en: There are three ways we can build `namedtuple` instances. The choice of technique
    we use is generally based on how much additional information is available at the
    time of object construction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三种方法构建`namedtuple`实例。我们选择使用的技术通常取决于在对象构建时有多少额外的信息可用。
- en: 'We''ve shown two of the three techniques in the examples in the previous section.
    We''ll emphasize the design considerations here. It includes the following choices:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的示例中，我们展示了三种技术中的两种。我们将在这里强调设计考虑因素。它包括以下选择：
- en: We can provide the parameter values according to their positions. This works
    out well when there are one or more expressions that we were evaluating. We used
    it when applying the `haversine()` function to the `start` and `end` points to
    create a `Leg` object.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以根据它们的位置提供参数值。当我们评估一个或多个表达式时，这种方法非常有效。我们在将`haversine()`函数应用于`start`和`end`点以创建`Leg`对象时使用了它。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can use the `*argument` notation to assign parameters according to their
    positions in a tuple. This works out well when we're getting the arguments from
    another iterable or an existing tuple. We used it when using `map()` to apply
    the `float()` function to the `latitude` and `longitude` values.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`*argument`符号根据元组中的位置分配参数。当我们从另一个可迭代对象或现有元组中获取参数时，这种方法非常有效。我们在使用`map()`将`float()`函数应用于`latitude`和`longitude`值时使用了它。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can use explicit keyword assignment. While not used in the previous example,
    we might see something like this as a way to make the relationships more obvious:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用显式的关键字赋值。虽然在前面的示例中没有使用，但我们可能会看到类似以下的东西，以使关系更加明显：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's helpful to have the flexibility of a variety of ways of created `namedtuple`
    instances. This allows us to more easily transform the structure of data. We can
    emphasize features of the data structure that are relevant for reading and understanding
    the application. Sometimes, the index number of 0 or 1 is an important thing to
    emphasize. Other times, the order of `start`, `end`, and `distance` is important.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多种创建`namedtuple`实例的灵活性是有帮助的。这使我们更容易地转换数据结构。我们可以强调与阅读和理解应用程序相关的数据结构特性。有时，索引号0或1是需要强调的重要事项。其他时候，`start`、`end`和`distance`的顺序是重要的。
- en: Avoiding stateful classes by using families of tuples
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过使用元组族避免有状态的类
- en: In several previous examples, we've shown the idea of **Wrap-Unwrap** design
    patterns that allow us to work with immutable tuples and `namedtuples`. The point
    of this kind of designs is to use immutable objects that wrap other immutable
    objects instead of mutable instance variables.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的几个示例中，我们展示了**Wrap-Unwrap**设计模式的概念，它允许我们使用不可变的元组和`namedtuples`。这种设计的重点是使用包装其他不可变对象的不可变对象，而不是可变的实例变量。
- en: A common statistical measure of correlation between two sets of data is the
    Spearman rank correlation. This compares the rankings of two variables. Rather
    than trying to compare values, which might have different scales, we'll compare
    the relative orders. For more information, visit [http://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient](http://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 两组数据之间的常见统计相关度测量是Spearman等级相关度。这比较了两个变量的排名。我们将比较相对顺序，而不是尝试比较可能具有不同规模的值。有关更多信息，请访问[http://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient](http://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient)。
- en: Computing the Spearman rank correlation requires assigning a rank value to each
    observation. It seems like we should be able to use `enumerate(sorted())` to do
    this. Given two sets of possibly correlated data, we can transform each set into
    a sequence of rank values and compute a measure of correlation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 计算Spearman等级相关性需要为每个观察分配一个排名值。我们似乎应该能够使用`enumerate(sorted())`来做到这一点。给定两组可能相关的数据，我们可以将每组转换为一系列排名值，并计算相关度的度量。
- en: We'll apply the Wrap-Unwrap design pattern to do this. We'll `wrap` data items
    with their rank for the purposes of computing the correlation coefficient.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用Wrap-Unwrap设计模式来做到这一点。我们将为了计算相关系数而将数据项与其排名“wrap”起来。
- en: 'In [Chapter 3](ch03.html "Chapter 3. Functions, Iterators, and Generators"),
    *Functions, Iterators, and Generators*, we showed how to parse a simple dataset.
    We''ll extract the four samples from that dataset as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。函数、迭代器和生成器")中，*函数、迭代器和生成器*，我们展示了如何解析一个简单的数据集。我们将从该数据集中提取四个样本，如下所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each of these series is a `tuple` of `Pair` objects. Each `Pair` object has
    `x` and `y` attributes. The data looks as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系列中的每一个都是“Pair”对象的`tuple`。每个“Pair”对象都有`x`和`y`属性。数据如下所示：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can apply the `enumerate()` function to create sequences of values as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用`enumerate()`函数来创建值序列，如下所示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first step will create simple two-tuples with `(0)` a rank number and `(1)`
    the original `Pair` object. As the data was sorted by the `y` value in each pair,
    the rank value will reflect this ordering.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将创建简单的两元组，`(0)`是排名数字，`(1)`是原始的“Pair”对象。由于数据是按每对中的`y`值排序的，排名值将反映这种排序。
- en: 'The sequence will look as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 序列将如下所示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The second step will `wrap` these two-tuples into yet another layer of wrapping.
    We'll sort by the *x* value in the original raw data. The second enumeration will
    be by the *x* value in each pair.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步将把这两个元组再包装一层。我们将按照原始原始数据中的*x*值进行排序。第二个枚举将按照每对中的*x*值进行排序。
- en: 'We''ll create more deeply nested objects that should look like the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建更深层次的嵌套对象，应该如下所示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In principle, we can now compute rank-order correlations between the two variables
    by using the *x* and *y* rankings. The extraction expression, however, is rather
    awkward. For each ranked sample in the data set, `r`, we have to compare `r[0]`
    with `r[1][0]`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们现在可以使用*x*和*y*的排名来计算两个变量之间的秩序相关。然而，提取表达式相当尴尬。对于数据集中的每个排名样本`r`，我们必须比较`r[0]`和`r[1][0]`。
- en: 'To overcome these awkward references, we can write selector functions as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些尴尬的引用，我们可以编写选择器函数如下：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This allows us to compute correlation using `x_rank(r)` and `y_rank(r)`, making
    references to values less awkward.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以使用`x_rank(r)`和`y_rank(r)`来计算相关性，使得引用值不那么尴尬。
- en: We've `wrapped` the original `Pair` object twice, which created new tuples with
    the ranking value. We've avoided stateful class definitions to create complex
    data structures incrementally.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经两次“wrapped”原始的“Pair”对象，创建了带有排名值的新元组。我们避免了有状态的类定义来逐步创建复杂的数据结构。
- en: 'Why create deeply nested tuples? The answer is simple: laziness. The processing
    required to unpack a `tuple` and build a new, flat `tuple` is simply time consuming.
    There''s less processing involved in `wrapping` an existing `tuple`. There are
    some compelling reasons for giving up the deeply nested structure.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要创建深度嵌套的元组？答案很简单：懒惰。解包`tuple`并构建新的平坦`tuple`所需的处理只是耗时的。在现有的`tuple`上“wrap”涉及的处理更少。放弃深度嵌套结构有一些令人信服的理由。
- en: 'There are two improvements we''d like to make; they are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望做两个改进；它们如下：
- en: 'We''d like a flatter data structure. The use of a nested `tuple` of `(x rank,
    (y rank, Pair()))` doesn''t feel expressive or succinct:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个更扁平的数据结构。使用嵌套的`(x rank, (y rank, Pair()))`的`tuple`并不感觉表达或简洁：
- en: The `enumerate()` function doesn't deal properly with ties. If two observations
    have the same value, they should get the same rank. The general rule is to average
    the positions of equal observations. The sequence `[0.8, 1.2, 1.2, 2.3, 18]` should
    have rank values of `1, 2.5, 2.5, 4`. The two ties in positions 2 and 3 have the
    midpoint value of `2.5` as their common rank.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate()`函数不能正确处理并列。如果两个观察结果具有相同的值，则它们应该获得相同的排名。一般规则是对相等的观察位置进行平均。序列`[0.8,
    1.2, 1.2, 2.3, 18]`应该具有排名值`1, 2.5, 2.5, 4`。在位置2和3上的两个并列具有它们的共同排名的中点值`2.5`。'
- en: Assigning statistical ranks
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配统计排名
- en: We'll break the rank ordering problem into two parts. First, we'll look at a
    generic, higher-order function that we can use to assign ranks to either the *x*
    or *y* value of a `Pair` object. Then, we'll use this to create a `wrapper` around
    the `Pair` object that includes both *x* and *y* rankings. This will avoid a deeply
    nested structure.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把排名排序问题分为两部分。首先，我们将研究一个通用的高阶函数，我们可以用它来为“Pair”对象的*x*或*y*值分配排名。然后，我们将使用这个函数来创建一个“wrapper”，包含*x*和*y*的排名。这将避免深度嵌套的结构。
- en: 'The following is a function that will create a rank order for each observation
    in a dataset:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个将为数据集中的每个观察创建一个等级顺序的函数：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our function to create the rank ordering relies on creating an object that is
    like `Counter` to discover duplicate values. We can't use a simple `Counter` function,
    as it uses the entire object to create a collection. We only want to use a key
    function applied to each object. This allows us to pick either the *x* or *y*
    value of a `Pair` object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建排名顺序的函数依赖于创建一个类似于`Counter`的对象，以发现重复值。我们不能使用简单的`Counter`函数，因为它使用整个对象来创建一个集合。我们只想使用应用于每个对象的键函数。这使我们可以选择`Pair`对象的*x*或*y*值。
- en: The `duplicates` collection in this example is a stateful object. We could have
    written a properly recursive function. We'd then have to do tail-call optimization
    to allow working with large collections of data. We've shown the optimized version
    of that recursion here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`duplicates`集合是一个有状态的对象。我们本来可以编写一个适当的递归函数。然后我们需要进行尾递归优化，以允许处理大量数据的工作。我们在这里展示了该递归的优化版本。
- en: As a hint to how this recursion would look, we've provided the arguments to
    `build_duplicates()` that expose the state as argument values. Clearly, the base
    case for the recursion is when `data_iter` is empty. When `data_iter` is not empty,
    a new collection is built from the old collection and the head `next(data_iter)`.
    A recursive evaluation of `build_duplicates()` will handle all items in the tail
    of `data_iter`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这种递归的提示，我们提供了`build_duplicates()`的参数，以暴露状态作为参数值。显然，递归的基本情况是当`data_iter`为空时。当`data_iter`不为空时，从旧集合和头部`next(data_iter)`构建一个新集合。`build_duplicates()`的递归评估将处理`data_iter`的尾部中的所有项目。
- en: Similarly, we could have written two properly recursive functions to emit the
    collection with the assigned rank values. Again, we've optimized that recursion
    into nested `for` loops. To make it clear how we're computing the rank value,
    we've included the low end of the range (`base+1`) and the high end of the range
    (`base+dups`) and taken the midpoint of these two values. If there is only a single
    `duplicate`, we evaluate `(2*base+2)/2`, which has the advantage of being a general
    solution.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以编写两个适当的递归函数来发出分配了排名值的集合。同样，我们将该递归优化为嵌套的`for`循环。为了清楚地说明我们如何计算排名值，我们包括了范围的低端（`base+1`）和范围的高端（`base+dups`），并取这两个值的中点。如果只有一个`duplicate`，我们评估`(2*base+2)/2`，这有一个通用解决方案的优势。
- en: The following is how we can test this to be sure it works.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何测试这个确保它工作。
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The sample data included two identical values. The resulting ranks split positions
    2 and 3 to assign position 2.5 to both values. This is the common statistical
    practice for computing the Spearman rank-order correlation between two sets of
    values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例数据包括两个相同的值。结果排名将位置2和3分开，以分配位置2.5给两个值。这是计算两组值之间的Spearman秩相关性的常见统计做法。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `rank()` function involves rearranging the input data as part of discovering
    duplicated values. If we want to rank on both the `x` and `y` values in each pair,
    we need to reorder the data twice.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`rank()`函数涉及重新排列输入数据以发现重复值。如果我们想在每对中的`x`和`y`值上进行排名，我们需要两次重新排序数据。'
- en: Wrapping instead of state changing
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新包装而不是状态改变
- en: 'We have two general strategies to do wrapping; they are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种一般策略来进行包装；它们如下：
- en: '**Parallelism**: We can create two copies of the data and rank each copy. We
    then need to reassemble the two copies into a final result that includes both
    rankings. This can be a bit awkward because we''ll need to somehow merge two sequences
    that are likely to be in different orders.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行性**：我们可以创建数据的两个副本并对每个副本进行排名。然后，我们需要重新组合这两个副本，以便最终结果包括两个排名。这可能有点尴尬，因为我们需要以某种方式合并两个可能按不同顺序排列的序列。'
- en: '**Serialism**: We can compute ranks on one variable and save the results as
    a wrapper that includes the original raw data. We can then rank this wrapped data
    on the other variable. While this can create a complex structure, we can optimize
    it slightly to create a flatter wrapper for the final results.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行性**：我们可以计算一个变量的排名，并将结果保存为一个包含原始原始数据的包装器。然后，我们可以对另一个变量上的这些包装数据进行排名。虽然这可能会创建一个复杂的结构，但我们可以稍微优化它，以创建最终结果的一个更平坦的包装器。'
- en: 'The following is how we can create an object that wraps a pair with the rank
    order based on the `y` value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何创建一个对象，该对象使用基于`y`值的排名顺序包装一对：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've defined a `namedtuple` function that contains the `y` value rank plus
    the original (`raw`) value. Our `rank_y()` function will create instances of this
    tuple by applying the `rank()` function using a `lambda` that selects the `y`
    value of each `pairs` object. We then created instances of the resulting two tuples.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个包含`y`值排名加上原始（`raw`）值的`namedtuple`函数。我们的`rank_y()`函数将通过使用一个`lambda`选择每个`pairs`对象的`y`值来应用`rank()`函数，从而创建这个元组的实例。然后我们创建了结果的两个元组的实例。
- en: 'The idea is that we can provide the following input:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供以下输入：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can get the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得到以下输出：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The raw `Pair` objects have been wrapped in a new object that includes the rank.
    This isn't all we need; we'll need to wrap this one more time to create an object
    that has both x and y rank information.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`Pair`对象已经被包装在一个包含排名的新对象中。这还不够；我们需要再次包装一次，以创建一个既有x排名信息又有y排名信息的对象。
- en: Rewrapping instead of state changing
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新包装而不是状态改变
- en: 'We can use a `namedtuple` named `Ranked_X` that contains two attributes: `r_x`
    and `ranked_y`. The `ranked_y` attribute is an instance of `Ranked_Y` that has
    two attributes: `r_y` and `raw`. Although this looks simple, the resulting objects
    are annoying to work with because the `r_x` and `r_y` values aren''t simple peers
    in a flat structure. We''ll introduce a slightly more complex wrapping process
    that produces a slightly simpler result.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个名为`Ranked_X`的`namedtuple`，其中包含两个属性：`r_x`和`ranked_y`。`ranked_y`属性是`Ranked_Y`的一个实例，它具有两个属性：`r_y`和`raw`。虽然这看起来很简单，但由于`r_x`和`r_y`值在一个平坦结构中不是简单的对等项，因此生成的对象令人讨厌。我们将引入一个稍微更复杂的包装过程，以产生一个稍微更简单的结果。
- en: 'We want the output to look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望输出看起来像这样：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''re going to create a flat `namedtuple` with multiple peer attributes. This
    kind of expansion is often easier to work with than deeply nested structures.
    In some applications, we might have a number of transformations. For this application,
    we have only two transformations: x-ranking and y-ranking. We''ll break this into
    two steps. First, we''ll look at a simplistic wrapping like the one shown previously
    and then a more general unwrap-rewrap.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个带有多个对等属性的平面`namedtuple`。这种扩展通常比深度嵌套的结构更容易处理。在某些应用中，我们可能有许多转换。对于这个应用程序，我们只有两个转换：x排名和y排名。我们将把这分为两个步骤。首先，我们将看一个类似之前所示的简单包装，然后是一个更一般的解包-重新包装。
- en: 'The following is how the `x-y` ranking builds on the y-ranking:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`x-y`排名建立在y排名的基础上：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've used the `rank_y()` function to build `Rank_Y` objects. Then, we applied
    the `rank()` function to those objects to order them by the original `x` values.
    The result of the second rank function will be two tuples with `(0)` the `x` rank
    and `(1)` the `Rank_Y` object. We build a `Ranked_XY` object from the `x` ranking
    (`r_x)`, the `y` ranking (`rank_y_raw[0]`), and the original object (`rank_y_raw[1]`).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`rank_y()`函数构建了`Rank_Y`对象。然后，我们将`rank()`函数应用于这些对象，以便按照原始的`x`值对它们进行排序。第二个排名函数的结果将是两个元组，其中`(0)`是`x`排名，`(1)`是`Rank_Y`对象。我们从`x`排名(`r_x`)、`y`排名(`rank_y_raw[0]`)和原始对象(`rank_y_raw[1]`)构建了一个`Ranked_XY`对象。
- en: What we've shown in this second function is a more general approach to adding
    data to a `tuple`. The construction of the `Ranked_XY` object shows how to unwrap
    the values from a data and rewrap to create a second, more complete structure.
    This approach can be used generally to introduce new variables to a `tuple`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这第二个函数中，我们展示了一种更一般的方法来向`tuple`添加数据。`Ranked_XY`对象的构造显示了如何从数据中解包值并重新包装以创建第二个更完整的结构。这种方法通常可以用来向`tuple`引入新变量。
- en: 'The following is some sample data:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些样本数据：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This allows us to create ranking objects as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以创建以下排名对象：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once we have this data with the appropriate *x* and *y* rankings, we can compute
    the Spearman rank-order correlation value. We can compute the Pearson correlation
    from the raw data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了适当的*x*和*y*排名的数据，我们就可以计算Spearman秩相关值。我们可以从原始数据计算Pearson相关性。
- en: Our multiranking approach involves decomposing a `tuple` and building a new,
    flat `tuple` with the additional attributes we need. We will often need this kind
    of design when computing multiple derived values from source data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的多排名方法涉及分解一个`tuple`并构建一个新的、平坦的`tuple`，其中包含我们需要的附加属性。当从源数据计算多个派生值时，我们经常需要这种设计。
- en: Computing the Spearman rank-order correlation
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算Spearman秩相关
- en: 'The Spearman rank-order correlation is a comparison between the rankings of
    two variables. It neatly bypasses the magnitude of the values, and it can often
    find a correlation even when the relationship is not linear. The formula is as
    follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Spearman秩相关是两个变量排名之间的比较。它巧妙地绕过了值的大小，甚至在关系不是线性的情况下，它通常也能找到相关性。公式如下：
- en: '![Computing the Spearman rank-order correlation](graphics/B03652_07_01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![计算Spearman秩相关](graphics/B03652_07_01.jpg)'
- en: 'This formula shows us that we''ll be summing the differences in rank, ![Computing
    the Spearman rank-order correlation](graphics/B03652_07_02.jpg) and ![Computing
    the Spearman rank-order correlation](graphics/B03652_07_03.jpg), for all of the
    pairs of observed values. The Python version of this depends on the `sum()` and
    `len()` functions, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式告诉我们，我们将对观察值的所有对的排名差异进行求和，![计算Spearman秩相关](graphics/B03652_07_02.jpg)和![计算Spearman秩相关](graphics/B03652_07_03.jpg)。这个Python版本依赖于`sum()`和`len()`函数，如下所示：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've created `Rank_XY` objects for each `pair`. Given this, we can then subtract
    the `r_x` and `r_y` values from those pairs to compare their difference. We can
    then square and sum the differences.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每对`pair`创建了`Rank_XY`对象。有了这个，我们就可以从这些对中减去`r_x`和`r_y`的值来比较它们的差异。然后我们可以对差异进行平方和求和。
- en: A good article on statistics will provide detailed guidance on what the coefficient
    means. A value around 0 means that there is no correlation between the data ranks
    of the two series of data points. A scatter plot shows a random scattering of
    points. A value around +1 or -1 indicates a strong relationship between the two
    values. A graph shows a clear line or curve.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关于统计学的一篇好文章将提供关于系数含义的详细指导。约为0的值意味着两个数据点系列的数据排名之间没有相关性。散点图显示了点的随机分布。约+1或-1的值表示两个值之间的强关系。图表显示了明显的线条或曲线。
- en: 'The following is an example based on Anscombe''s Quartet series I:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于安斯库姆四重奏系列I的一个例子：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For this particular data set, the correlation is strong.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的数据集，相关性很强。
- en: 'In [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with
    Collections*, we showed how to compute the Pearson correlation coefficient. The
    function we showed, `corr()`, worked with two separate sequences of values. We
    can use it with our sequence of `Pair` objects as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。处理集合")中，*处理集合*，我们展示了如何计算Pearson相关系数。我们展示的`corr()`函数与两个独立的值序列一起工作。我们可以将它与我们的`Pair`对象序列一起使用，如下所示：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We've unwrapped the `Pair` objects to get the raw values that we can use with
    the existing `corr()` function. This provides a different correlation coefficient.
    The Pearson value is based on how well the standardized values compare between
    two sequences. For many data sets, the difference between the Pearson and Spearman
    correlations is relatively small. For some datasets, however, the differences
    can be quite large.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解开了`Pair`对象，得到了我们可以与现有的`corr()`函数一起使用的原始值。这提供了一个不同的相关系数。Pearson值基于两个序列之间标准化值的比较。对于许多数据集，Pearson和Spearman相关性之间的差异相对较小。然而，对于一些数据集，差异可能相当大。
- en: To see the importance of having multiple statistical tools for exploratory data
    analysis, compare the Spearman and Pearson correlations for the four sets of data
    in the Anscombe's Quartet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解对探索性数据分析具有多个统计工具的重要性，请比较Anscombe's Quartet中四组数据的Spearman和Pearson相关性。
- en: Polymorphism and Pythonic pattern matching
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态和Pythonic模式匹配
- en: Some functional programming languages offer clever approaches to working with
    statically typed function definitions. The issue is that many functions we'd like
    to write are entirely generic with respect to data type. For example, most of
    our statistical functions are identical for `integer` or `floating-point` numbers,
    as long as division returns a value that is a subclass of `numbers.Real` (for
    example, `Decimal`, `Fraction`, or `float`). In order to make a single generic
    definition work for multiple data types, sophisticated type or pattern-matching
    rules are used by the compiler.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式编程语言提供了处理静态类型函数定义的巧妙方法。问题在于，我们想要编写的许多函数对于数据类型来说是完全通用的。例如，我们的大多数统计函数对于`integer`或`floating-point`数字来说是相同的，只要除法返回的值是`numbers.Real`的子类（例如`Decimal`，`Fraction`或`float`）。为了使单个通用定义适用于多种数据类型，编译器使用了复杂的类型或模式匹配规则。
- en: Instead of the (possibly) complex features of statically typed functional languages,
    Python changes the issue using dynamic selection of the final implementation of
    an operator based on the data types being used. This means that a compiler doesn't
    certify that our functions are expecting and producing the proper data types.
    We generally rely on unit testing for this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态类型的函数式语言的（可能）复杂特性不同，Python通过动态选择基于正在使用的数据类型的操作符的最终实现来改变问题。这意味着编译器不会验证我们的函数是否期望和产生正确的数据类型。我们通常依赖单元测试来解决这个问题。
- en: In Python, we're effectively writing generic definitions because the code isn't
    bound to any specific data type. The Python runtime will locate the appropriate
    operations using a simple set of matching rules. The *3.3.7 Coercion rules* section
    of the language reference manual and the `numbers` module in the library provide
    details on how this mapping from operation to special method name works.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们实际上是在编写通用定义，因为代码不绑定到任何特定的数据类型。Python运行时将使用一组简单的匹配规则来定位适当的操作。语言参考手册中的*3.3.7
    强制规则*部分和库中的`numbers`模块提供了关于操作到特殊方法名称映射的详细信息。
- en: 'In rare cases, we might need to have different behavior based on the types
    of the data elements. We have two ways to tackle this; they are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，我们可能需要根据数据元素的类型有不同的行为。我们有两种方法来解决这个问题，它们如下：
- en: We can use the `isinstance()` function to distinguish the different cases
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`isinstance()`函数来区分不同的情况。
- en: We can create our own subclass of `numbers.Number` or `tuple` and implement
    a proper polymorphic special method names
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建自己的`numbers.Number`或`tuple`的子类，并实现适当的多态特殊方法名称。
- en: In some cases, we'll actually need to do both so that we can include appropriate
    data type conversions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们实际上需要两者都做，以便包含适当的数据类型转换。
- en: When we look back at the ranking example in the previous section, we're tightly
    bound to the idea of applying rank-ordering to simple pairs. While this is the
    way the Spearman correlation is defined, we might have a multivariate dataset
    and have a need to do rank-order correlation among all the variables.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾前一节中的排名示例时，我们紧密地与将排名应用于简单对的想法联系在一起。虽然这是Spearman相关性的定义方式，但我们可能有一个多变量数据集，并且需要对所有变量进行排名相关性。
- en: 'The first thing we''ll need to do is generalize our idea of rank-order information.
    The following is a `namedtuple` that handles a `tuple` of ranks and a `tuple`
    of raw data:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是概括我们对排名信息的想法。以下是一个处理排名元组和原始数据元组的`namedtuple`：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For any specific piece of `Rank_Data`, such as `r`, we can use `r.rank_seq[0]`
    to get a specific ranking and `r.raw` to get the original observation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何特定的`Rank_Data`，比如`r`，我们可以使用`r.rank_seq[0]`来获取特定的排名，使用`r.raw`来获取原始观察值。
- en: 'We''ll add some syntactic sugar to our ranking function. In many previous examples,
    we''ve required either an iterable or a collection. The `for` statement is graceful
    about working with either one. However, we don''t always use the `for` statement,
    and for some functions, we''ve had to explicitly use `iter()` to make an `iterable`
    out of a collection. We can handle this situation with a simple `isinstance()`
    check, as shown in the following code snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的排名函数添加一些语法糖。在许多以前的例子中，我们要求要么是一个可迭代对象，要么是一个集合。`for`语句在处理任一种情况时都很优雅。但是，我们并不总是使用`for`语句，对于一些函数，我们不得不明确使用`iter()`来使一个集合成为一个`iterable`。我们可以通过简单的`isinstance()`检查来处理这种情况，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've included a type check to handle the small difference between the two collection`s`,
    which doesn't work with `next()` and an `iterable`, which supports `next()`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了一个类型检查，以处理两个集合之间的小差异，它不适用于`next()`和一个支持`next()`的可迭代对象。
- en: 'In the context of our rank-ordering function, we will use this variation on
    the design pattern:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的排名函数的上下文中，我们将使用这种设计模式的变体：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ve decomposed the ranking into three cases for three different types of
    data. We''re forced it to do this when the different kinds of data aren''t polymorphic
    subclasses of a common superclass. The following are the three cases:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将排名分解为三种不同类型数据的三种情况。当不同类型的数据不是共同超类的多态子类时，我们被迫这样做。以下是三种情况：
- en: Given an `iterable` (without a usable `__getitem__()` method), we'll materialize
    a `tuple` that we can work with
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个（没有可用的`__getitem__()`方法的）可迭代对象，我们将实现一个我们可以使用的`tuple`。
- en: Given a collection of some unknown type of data, we'll wrap the unknown objects
    into `Rank_Data` tuples
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一组某种未知类型的数据，我们将未知对象包装成`Rank_Data`元组。
- en: Finally, given a collection of `Rank_Data` tuples, we'll add yet another ranking
    to the tuple of ranks inside the each `Rank_Data` container
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，给定一组`Rank_Data`元组，我们将在每个`Rank_Data`容器内部的排名元组中添加另一个排名。
- en: This relies on a `rerank()` function that inserts and returns another ranking
    into the `Rank_Data` tuple. This will build up a collection of individual rankings
    from a complex record of raw data values. The `rerank()` function follows a slightly
    different design than the example of the `rank()` function shown previously.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于一个`rerank()`函数，它在`Rank_Data`元组中插入并返回另一个排名。这将从原始数据值的复杂记录中构建一个单独的排名集合。`rerank()`函数的设计与之前显示的`rank()`函数的示例略有不同。
- en: 'This version of the algorithm uses sorting instead of creating a groups in
    a objects like `Counter` object:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的这个版本使用排序而不是在对象中创建分组，比如`Counter`对象：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We've started by reassembling a single, sortable collection from the head and
    the data iterator. In the context in which this is used, we can argue that this
    is a bad idea.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从头部和数据迭代器重新组装了一个可排序的集合。在使用的上下文中，我们可以说这是一个坏主意。
- en: 'This function relies on two other functions. They can be declared within the
    body of `rerank()`. We''ll show them separately. The following is the ranker,
    which accepts an iterable, a base rank number, a collection of values with the
    same rank, and a key:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数依赖于另外两个函数。它们可以在`rerank()`的主体内声明。我们将分开展示它们。以下是ranker，它接受一个可迭代对象，一个基本排名数字，一个具有相同排名的值的集合，以及一个键：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We've extracted the next item from the `iterable` collection of sorted values.
    If this fails, there is no next item, and we need to emit the final collection
    of equal-valued items in the `same_rank_seq` sequence. If this works, then we
    need to use the `key()` function to see whether the next item, which is a value,
    has the same key as the collection of equal-ranked items. If the key is the same,
    the overall value is defined recursively; the reranking is the rest of the sorted
    items, the same base value for the rank, a larger collection of `same_rank` items,
    and the same `key()` function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从已排序值的`iterable`集合中提取了下一个项目。如果这失败了，就没有下一个项目，我们需要发出`same_rank_seq`序列中相等值项目的最终集合。如果这成功了，那么我们需要使用`key()`函数来查看下一个项目，即一个值，是否与相同排名项目的集合具有相同的键。如果键相同，则整体值被递归地定义；重新排名是其余的排序项目，排名的相同基值，一个更大的`same_rank`项目集合，以及相同的`key()`函数。
- en: If the next item's key doesn't match the sequence of equal-valued items, the
    result is a sequence of equal-valued items. This will be followed by the reranking
    of the rest of the sorted items, a base value incremented by the number of equal-valued
    items, a fresh list of equal-rank items with just the new value, and the same
    `key` extraction function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个项目的键与相等值项目的序列不匹配，则结果是相等值项目的序列。这将在对其余排序项目进行重新排名之后，一个基值增加了相等值项目的数量，一个只有新值的相同排名项目的新列表，以及相同的`key`提取函数。
- en: 'This depends on the `yield_sequence()` function, which looks as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于`yield_sequence()`函数，其如下所示：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We've written this in a way that emphasizes the recursive definition. We don't
    really need to extract the head, emit it, and then recursively emit the remaining
    items. While a single `for` statement might be shorter, it's sometimes more clear
    to emphasize the recursive structure that has been optimized into a `for` loop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一种强调递归定义的方式编写了这个。我们实际上不需要提取头部，发出它，然后递归发出其余的项目。虽然单个`for`语句可能更短，但有时更清晰地强调已经优化为`for`循环的递归结构。
- en: 'The following are some examples of using this function to rank (and rerank)
    data. We''ll start with a simple collection of scalar values:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此函数对数据进行排名（和重新排名）的一些示例。我们将从一个简单的标量值集合开始：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Each value becomes the `raw` attribute of a `Rank_Data` object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值都成为`Rank_Data`对象的`raw`属性。
- en: 'When we work with a slightly more complex object, we can also have multiple
    rankings. The following is a sequence of two tuples:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理稍微复杂的对象时，我们也可以有多个排名。以下是两个元组的序列：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we defined a collection of pairs. Then, we ranked the two tuples, assigning
    the sequence of `Rank_Data` objects to the `rank_x` variable. We then ranked this
    collection of `Rank_Data` objects, creating a second rank value and assigning
    the result to the `rank_xy` variable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一组对。然后，我们对这两个元组进行了排名，将`Rank_Data`对象的序列分配给`rank_x`变量。然后，我们对这个`Rank_Data`对象的集合进行了排名，创建了第二个排名值，并将结果分配给`rank_xy`变量。
- en: The resulting sequence can be used to a slightly modified `rank_corr()` function
    to compute the rank correlations of any of the available values in the `rank_seq`
    attribute of the `Rank_Data` objects. We'll leave this modification as an exercise
    for the readers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的序列可以用于稍微修改的`rank_corr()`函数，以计算`Rank_Data`对象的`rank_seq`属性中任何可用值的排名相关性。我们将把这个修改留给读者作为练习。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at different ways to use `namedtuple` objects to
    implement more complex data structures. The essential features of a `namedtuple`
    are a good fit with functional design. They can be created with a creation function
    and accessed by position as well as name.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用`namedtuple`对象实现更复杂的数据结构的不同方法。`namedtuple`的基本特性与函数式设计非常匹配。它们可以通过创建函数创建，并且可以按位置和名称访问。
- en: We looked at how to use immutable `namedtuples` instead of stateful object definitions.
    The core technique was to wrap an object in an immutable `tuple` to provide additional
    attribute values.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了如何使用不可变的`namedtuples`而不是有状态的对象定义。核心技术是将对象包装在不可变的`tuple`中，以提供额外的属性值。
- en: We also looked at ways to handle multiple data types in Python. For most arithmetic
    operations, Python's internal method dispatch locates proper implementations.
    To work with collections, however, we might want to handle iterators and sequences
    slightly differently.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了如何处理Python中的多种数据类型。对于大多数算术运算，Python的内部方法分派会找到合适的实现。然而，对于处理集合，我们可能希望稍微不同地处理迭代器和序列。
- en: In the next two chapters, we'll look at the `itertools` module. This `library`
    module provides a number of functions that help us work with iterators in sophisticated
    ways. Many of these tools are examples of higher-order functions. They can help
    make a functional design stay succinct and expressive.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将看一下`itertools`模块。这个`库`模块提供了许多函数，帮助我们以复杂的方式处理迭代器。其中许多工具都是高阶函数的例子。它们可以帮助使函数式设计保持简洁和表达力。
