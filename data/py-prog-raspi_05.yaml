- en: Data Types and Object-Oriented Programming in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中的数据类型和面向对象编程
- en: In this chapter, we will discuss data types and **object-oriented programming**
    (**OOP**) in Python. We will discuss data types including lists, dictionaries,
    tuples and sets in Python. We will also discuss OOP, it's necessity and how to
    write object-oriented code in Python for Raspberry Pi based projects (such as,
    using OOP to control appliances at home). We will discuss making use of OOP in
    a Raspberry Pi Zero project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Python 中的数据类型和面向对象编程（**OOP**）。我们将讨论包括列表、字典、元组和集合在内的 Python 中的数据类型。我们还将讨论
    OOP 的必要性以及如何在基于 Raspberry Pi 的项目中编写面向对象的代码（例如，使用 OOP 控制家用电器）。我们还将讨论在 Raspberry
    Pi Zero 项目中利用 OOP。
- en: Lists
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: In Python, a list is a data type (its documentation is available here, [https://docs.python.org/3.4/tutorial/datastructures.html#](https://docs.python.org/3.4/tutorial/datastructures.html#))
    that could be used to store elements in a sequence.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，列表是一种数据类型（其文档在此处可用，[https://docs.python.org/3.4/tutorial/datastructures.html#](https://docs.python.org/3.4/tutorial/datastructures.html#))，可以用来按顺序存储元素。
- en: 'The topics discussed in this chapter can be difficult to grasp unless used
    in practice. Any example that is represented using this notation: `>>>` indicates
    that it could be tested using the Python interpreter.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不实际使用，本章中讨论的主题可能难以理解。任何使用此符号 `>>>` 表示的示例都可以使用 Python 解释器进行测试。
- en: 'A list may consist of strings, objects (discussed in detail in this chapter)
    or numbers, and so on. For instance, the following are examples of lists:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以包含字符串、对象（在本章中详细讨论）或数字等。例如，以下是一些列表示例：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding set of examples, the `sequence` list consists of numbers between
    `1` and `6` while the `example_list` list consists of a combination of strings,
    integer, and floating-point numbers. A list is represented by square brackets
    (`[]`). Items can be added to a list separated by commas:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例集中，`sequence` 列表包含 `1` 到 `6` 之间的数字，而 `example_list` 列表则包含字符串、整数和浮点数的组合。列表用方括号
    (`[]`) 表示。可以通过逗号分隔来向列表中添加项目：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since a list is an ordered sequence of elements, the elements of a list could
    be fetched by iterating through the list elements using a `for` loop as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表是有序元素序列，因此可以通过使用 `for` 循环遍历列表元素来获取列表中的元素，如下所示：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is something as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since Python's loop can iterate through a sequence of elements, it fetches each
    element and assigns it to `item`. This item is printed on the console.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 的循环可以遍历元素序列，它将获取每个元素并将其分配给 `item`。这个项目将在控制台上打印出来。
- en: Operations that could be performed on a list
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以在列表上执行的操作
- en: 'In Python, the attributes of a data type can be retrieved using the `dir()` method.
    For example, the attributes available for the `sequence` list can be retrieved
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以使用 `dir()` 方法检索数据类型的属性。例如，可以如下检索 `sequence` 列表可用的属性：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These attributes enable performing different operations on a list. Let's discuss
    each attribute in detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性使得可以对列表执行不同的操作。让我们详细讨论每个属性。
- en: 'Append element to list:'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向列表中添加元素：
- en: 'It is possible to add an element using the `append()` method:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `append()` 方法添加元素：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Remove element from list:'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列表中删除元素：
- en: 'The `remove()` method finds the first instance of the element (passed an argument)
    and removes it from the list. Let''s consider the following examples:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()` 方法查找传递的参数的第一个元素实例，并将其从列表中删除。让我们看看以下示例：'
- en: '**Example 1**:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例 1**:'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Example 2**:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例 2**:'
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Example 3**:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例 3**:'
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Retrieving the index of an element
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取元素索引
- en: 'The `index()` method returns the position of an element in a list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()` 方法返回列表中元素的位置：'
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, the method returns the index of the element `5`. Since Python
    uses zero-based indexing that is the index is counted from 0 and hence the index
    of the element `5` is `4`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，该方法返回元素 `5` 的索引。由于 Python 使用基于零的索引，因此索引从 0 开始计数，因此元素 `5` 的索引是 `4`：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the method returns the position of the first instance of the
    element. The element `5` is located at the third position.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，该方法返回元素第一个实例的位置。元素 `5` 位于第三个位置。
- en: Popping an element from the list
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列表中弹出元素
- en: 'The `pop()` method enables removing an element from a specified position and
    return it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()` 方法允许从指定位置删除元素并返回它：'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `index_list` list consists of numbers between `1` and `7`.
    When the third element is popped by passing the index position `(3)` as an argument,
    the number `4` is removed from the list and returned.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`index_list` 列表包含 `1` 到 `7` 之间的数字。当通过传递索引位置 `(3)` 作为参数弹出第三个元素时，数字 `4`
    被从列表中移除并返回。
- en: 'If no arguments are provided for the index position, the last element is popped
    and returned:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供索引位置参数，则最后一个元素将被弹出并返回：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the last element `(7)` was popped and returned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，最后一个元素 `(7)` 被弹出并返回。
- en: 'Counting the instances of an element:'
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算元素实例：
- en: 'The `count()` method returns the number of times an element appears in a list.
    For example, the element appears twice in the list: `random_list`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()` 方法返回元素在列表中出现的次数。例如，元素在列表中出现了两次：`random_list`。'
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inserting element at a specific position:'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在特定位置插入元素：
- en: 'The `insert()` method enables adding an element at a specific position in the
    list. For example, let''s consider the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 方法可以用来在列表的特定位置添加一个元素。例如，让我们考虑以下示例：'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the list, `Wednesday` is missing. It needs to be positioned between `Tuesday`
    and `Thursday` at position 2 (Python uses **zero based indexing** that is the
    positions/indexes of elements are counted as 0, 1, 2, and so on.). It could be
    added using insert as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，`Wednesday` 缺失。它需要被放置在 `Tuesday` 和 `Thursday` 之间，位置为 2（Python 使用 **基于零的索引**，即元素的位置/索引从
    0、1、2 等开始计数）。可以使用 `insert` 方法添加如下：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Challenge to the reader
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对读者的挑战
- en: In the preceding list, `Sunday` is missing. Use the `insert` attribute of lists
    to insert it at the correct position.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，`Sunday` 缺失。使用列表的 `insert` 属性将其插入到正确的位置。
- en: Extending a list
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展列表
- en: 'Two lists can be combined together using the `extend()` method. The `day_of_week`
    and `sequence` lists can be combined as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `extend()` 方法将两个列表合并在一起。例如，`day_of_week` 和 `sequence` 列表可以这样合并：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Lists can also be combined as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表也可以按照以下方式合并：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is also possible to add a list as an element to another list:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将一个列表作为元素添加到另一个列表中：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Clearing the elements of a list
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除列表元素
- en: 'All the elements of a list could be deleted using the `clear()` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `clear()` 方法删除列表中的所有元素：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sorting the elements of a list
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序列表元素
- en: 'The elements of a list could be sorted using the `sort()` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `sort()` 方法对列表元素进行排序：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When a list consists of a collection of strings, they are sorted in the alphabetical
    order:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表由字符串集合组成时，它们将按字母顺序排序：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Reverse the order of elements in list
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转列表中元素的顺序
- en: 'The `reverse()` method enables the reversing the order of the list elements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()` 方法可以用来反转列表元素的顺序：'
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Create copies of a list
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建列表的副本
- en: 'The `copy()` method enables creating copies of a list:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy()` 方法可以用来创建列表的副本：'
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Accessing list elements
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问列表元素
- en: 'The list elements could be accessed by specifying the index position of the
    `list_name[i]` element. For example, the zeroth list element of the `random_list`
    list could be accessed as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定 `list_name[i]` 元素的索引位置来访问列表元素。例如，`random_list` 列表的零索引元素可以这样访问：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Accessing a set of elements within a list
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问列表中的元素集合
- en: 'It is possible to access elements between specified indices. For example, it
    is possible to retrieve all elements between indices 2 and 4:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以访问指定索引之间的元素。例如，可以检索索引 2 和 4 之间的所有元素：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first six elements of a list could be accessed as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式访问列表的前六个元素：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The elements of a list could be printed in the reverse order as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式以相反的顺序打印列表元素：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Every second element in the list could be fetched as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式获取列表中的每隔一个元素：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It is also possible to fetch every second element after the second element
    after skipping the first two elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在跳过前两个元素后获取第二个元素之后的每隔一个元素：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: List membership
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表成员
- en: 'It is possible to check if a value is a member of a list using the `in` keyword.
    For example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `in` 关键字检查一个值是否是列表的成员。例如：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this list, we could check if the number `6` is a member:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们可以检查数字 `6` 是否是成员：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's build a simple game!
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的游戏！
- en: 'This exercise consists of two parts. In the first part, we will review building
    a list containing ten random numbers between `0` and `10`. The second part is
    a challenge to the reader. Perform the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习包括两个部分。在第一部分，我们将回顾构建包含 `0` 到 `10` 之间十个随机数的列表。第二部分是对读者的挑战。执行以下步骤：
- en: 'The first step is creating an empty list. Let''s create an empty list called
    `random_list`. An empty list can be created as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个空列表。让我们创建一个名为 `random_list` 的空列表。一个空列表可以创建如下：
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will be making use of Python''s `random` module ([https://docs.python.org/3/library/random.html](https://docs.python.org/3/library/random.html))
    to generate random numbers. In order to generate random numbers between `0` and
    `10`, we will make use of the `randint()` method from the `random` module:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 Python 的 `random` 模块（[https://docs.python.org/3/library/random.html](https://docs.python.org/3/library/random.html)）来生成随机数。为了生成介于
    `0` 和 `10` 之间的随机数，我们将使用 `random` 模块中的 `randint()` 方法：
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s append the generated number to the list. This operation is repeated
    `10` times using a `for` loop:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将生成的数字追加到列表中。此操作通过 `for` 循环重复 `10` 次：
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The generated list looks something like this:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的列表看起来大致如下：
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We discussed generating a list of random numbers. The next step is taking user
    input where we ask the user to make a guess for a number between `0` and `10`.
    If the number is a member of the list, the message `Your guess is correct` is
    printed to the screen, else, the message `Sorry! Your guess is incorrect` is printed.
    We leave the second part as a challenge to the reader. Get started with the `list_generator.py`
    code sample available for download with this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了生成随机数列表。下一步是获取用户输入，我们要求用户猜测一个介于 `0` 和 `10` 之间的数字。如果数字是列表的成员，则屏幕上打印出消息 `Your
    guess is correct`，否则，打印出消息 `Sorry! Your guess is incorrect`。我们将第二部分留给读者作为挑战。可以从本章提供的下载代码示例
    `list_generator.py` 开始。
- en: Dictionaries
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词典
- en: 'A dictionary ([https://docs.python.org/3.4/tutorial/datastructures.html#dictionaries](https://docs.python.org/3.4/tutorial/datastructures.html#dictionaries))
    is a data type that is an unordered collection of key and value pairs. Each key
    in a dictionary has an associated value. An example of a dictionary is:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 字典（[https://docs.python.org/3.4/tutorial/datastructures.html#dictionaries](https://docs.python.org/3.4/tutorial/datastructures.html#dictionaries)）是一种数据类型，它是一个无序的键值对集合。字典中的每个键都有一个相关联的值。一个字典的例子是：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A dictionary is created by using the braces `{}`. At the time of creation,
    new members are added to the dictionary in the following format: `key: value`
    (shown in the preceding example). In the previous example `1` and `2` are keys
    while `''Hello''` and `''World''` are the associated values. Each value added
    to a dictionary needs to have an associated key.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '字典是通过使用花括号 `{}` 创建的。在创建时，新成员以以下格式添加到字典中：`key: value`（如前例所示）。在前例中，`1` 和 `2`
    是键，而 `''Hello''` 和 `''World''` 是相关联的值。添加到字典中的每个值都需要一个相关联的键。'
- en: 'The elements of a dictionary do not have an order i.e. the elements cannot
    be retrieved in the order they were added. It is possible to retrieving the values
    of a dictionary by iterating through the keys. Let''s consider the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的元素没有顺序，即元素不能按添加的顺序检索。可以通过遍历键来检索字典的值。让我们考虑以下示例：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are several ways to print the keys or values of a dictionary:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打印字典的键或值有几种方法：
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding example, we iterate through the keys of the dictionary and
    retrieve the value using the key, `my_dict[key]`. It is also possible to retrieve
    the values using the `values()` method available with dictionaries:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前例中，我们遍历字典的键，并使用键 `my_dict[key]` 获取值。也可以使用字典中可用的 `values()` 方法来检索值：
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The keys of a dictionary can be an integer, string, or a tuple. The keys of
    a dictionary need to be unique and it is immutable, that is a key cannot be modified
    after creation. Duplicates of a key cannot be created. If a new value is added
    to an existing key, the latest value is stored in the dictionary. Let''s consider
    the following example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的键可以是整数、字符串或元组。字典的键需要是唯一的，且不可变，也就是说键在创建后不能被修改。不能创建键的重复项。如果向现有键添加新值，则将最新值存储在字典中。让我们考虑以下示例：
- en: 'A new key/value pair could be added to a dictionary as follows:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以按照以下方式向字典中添加新的键/值对：
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s try creating a duplicate of the key `9`:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们尝试创建键 `9` 的一个副本：
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As shown in the preceding example, when we try to create a duplicate, the value
    of the existing key is modified.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前例所示，当我们尝试创建重复时，现有键的值被修改。
- en: 'It is possible to have multiple values associated with a key. For example, as
    a list or a dictionary:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将多个值与一个键关联起来。例如，作为一个列表或字典：
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Dictionaries are useful in scenarios like parsing CSV files and associating
    each row with a unique key. Dictionaries are also used to encode and decode JSON data
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 字典在解析CSV文件和将每一行与一个唯一键关联的场景中很有用。字典也用于编码和解码JSON数据
- en: Tuples
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'A tuple (pronounced either like *two-ple* or *tuh-ple*) is an immutable data
    type that are ordered and separated by a comma. A tuple can be created as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元组（发音为 *two-ple* 或 *tuh-ple*）是一个不可变的数据类型，它是有序的，由逗号分隔。元组可以创建如下：
- en: '[PRE43]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since tuples are immutable, the value at a given index cannot be modified:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组是不可变的，给定索引处的值不能被修改：
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A tuple can consist of a number, string, or a list. Since lists are mutable,
    if a list is a member of a tuple, it can be modified. For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以由数字、字符串或列表组成。由于列表是可变的，如果列表是元组的一个成员，它可以被修改。例如：
- en: '[PRE45]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Tuples are especially useful in scenarios where the value cannot be modified.
    Tuples are also used to return values from a function. Let''s consider the following
    example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在值不能被修改的场景中特别有用。元组也用于从函数中返回值。让我们考虑以下示例：
- en: '[PRE46]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, the `items()` method returns a list of tuples.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`items()` 方法返回一个元组列表。
- en: Sets
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'A set ([https://docs.python.org/3/tutorial/datastructures.html#sets](https://docs.python.org/3/tutorial/datastructures.html#sets))
    is an unordered collection of immutable elements without duplicate entries. A
    set could be created as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 集合（[https://docs.python.org/3/tutorial/datastructures.html#sets](https://docs.python.org/3/tutorial/datastructures.html#sets)）是一个无序的、不可变的、无重复条目的元素集合。集合可以创建如下：
- en: '[PRE47]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s add a duplicate list to this set:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向这个集合中添加一个重复的列表：
- en: '[PRE48]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Sets enable avoid duplication of entries and saving the unique entries. A single
    element can be added to a set as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以避免条目重复并保存唯一条目。可以将单个元素添加到集合中，如下所示：
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Sets are used to test memberships of an element among different sets. There
    are different methods that are related to membership tests. We recommend learning
    about each method using the documentation on sets (run `help(my_set)` to find
    the different methods available for membership tests).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 集合用于测试元素在不同集合中的成员资格。有不同与成员资格测试相关的方法。我们建议通过集合的文档（运行 `help(my_set)` 以找到可用于成员资格测试的不同方法）来了解每个方法。
- en: OOP in Python
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的面向对象编程（OOP）
- en: OOP is a concept that helps simplifying your code and eases application development.
    It is especially useful in reusing your code. Object-oriented code enables reusing
    your code for sensors that use the communications interface. For example, all
    sensors that are equipped with a UART port could be grouped together using object-oriented
    code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一个有助于简化代码并简化应用程序开发的理念。它特别有助于代码的重用。面向对象的代码允许为使用通信接口的传感器重用代码。例如，所有配备UART端口的传感器都可以使用面向对象的代码分组在一起。
- en: One example of OOP is the **GPIO Zero library** ([https://www.raspberrypi.org/blog/gpio-zero-a-friendly-python-api-for-physical-computing/](https://www.raspberrypi.org/blog/gpio-zero-a-friendly-python-api-for-physical-computing/))
    used in previous chapters. In fact, everything is an object in Python.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个例子是之前章节中使用的**GPIO Zero库**（[https://www.raspberrypi.org/blog/gpio-zero-a-friendly-python-api-for-physical-computing/](https://www.raspberrypi.org/blog/gpio-zero-a-friendly-python-api-for-physical-computing/)）。实际上，在Python中，一切都是对象。
- en: Object-oriented code is especially helpful in collaboration with other people
    on a project. For example, you could implement a sensor driver using object-oriented
    code in Python and document its usage. This enables other developers to develop
    an application without paying attention to the nitty-gritty detail behind the
    sensor's interface. OOP provides modularity to an application that simplifies
    application development. We are going to review an example in this chapter that
    demonstrates the advantage of OOP. In this chapter, we will be making use of OOP
    to bring modularity to our project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的代码在与他人合作的项目中特别有帮助。例如，你可以使用Python的面向对象代码实现一个传感器驱动程序，并记录其用法。这使得其他开发者可以在不关注传感器接口背后的细节的情况下开发应用程序。面向对象编程为应用程序提供了模块化，简化了应用程序开发。在本章中，我们将回顾一个示例，以展示面向对象编程的优势。在本章中，我们将利用面向对象编程为我们的项目带来模块化。
- en: Let's get started!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Revisiting the student ID card example
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾学生身份证示例
- en: 'Let''s revisit the ID card example from [Chapter 2](9e475135-4205-42c5-a109-cc59bfadad7d.xhtml),
    *Arithmetic Operations, Loops, and Blinky Lights* (`input_test.py`). We discussed
    writing a simple program that captures and prints the information belonging to
    a student. A student''s contact information could be retrieved and stored as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下来自 [第2章](9e475135-4205-42c5-a109-cc59bfadad7d.xhtml)，*算术运算、循环和闪烁灯*（`input_test.py`）的身份证示例。我们讨论了编写一个简单的程序来捕获并打印属于学生的信息。学生的联系信息可以按以下方式检索和存储：
- en: '[PRE50]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, consider a scenario where the information of 10 students has to be saved
    and retrieved at any point during program execution. We would need to come up
    with a nomenclature for the variables used to save the student information. It
    would be a clutter if we use 30 different variables to store information belonging
    to each student. This is where object oriented programming can be really helpful.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一个场景，在程序执行期间需要保存和检索10名学生的信息。我们需要为用于保存学生信息的变量制定一个命名约定。如果我们使用30个不同的变量来存储每个学生的信息，将会很混乱。这正是面向对象编程可以真正发挥作用的地方。
- en: Let's rewrite this example using OOP to simplify the problem. The first step
    in OOP is declaring a structure for the object. This is done by defining a class.
    The class determines the functions of an object. Let's write a Python class that
    defines the structure for a student object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用面向对象编程（OOP）重写这个例子以简化问题。OOP 的第一步是声明对象的结构。这是通过定义一个类来完成的。类决定了对象的功能。让我们编写一个
    Python 类，定义学生对象的结构。
- en: Class
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'Since we are going to save student information, the class is going to be called
    `Student`. A class is defined using the `class` keyword as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将保存学生信息，因此类将被命名为 `Student`。类是通过 `class` 关键字定义的，如下所示：
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Thus, a class called `Student` has been defined. Whenever a new object is created,
    the method `__init__()` (the underscore indicate that the init method is a magic
    method, that is it is a function that is called by Python when an object is created)
    is called internally by Python.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，已定义了一个名为 `Student` 的类。每当创建一个新对象时，Python 会内部调用 `__init__()` 方法（下划线表示 init
    方法是一个魔法方法，即它是 Python 在创建对象时调用的函数）。
- en: 'This method is defined within the class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在类内部定义：
- en: '[PRE52]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, the arguments to the `__init__` method include `name`, `age`
    and `address`. These arguments are called **attributes**. These attributes enable
    creating a unique object that belongs to the `Student` class. Hence, in this example,
    while creating an instance of the `Student` class, the attributes `name`, `age`,
    and `address` are required arguments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`__init__` 方法的参数包括 `name`、`age` 和 `address`。这些参数被称为 **属性**。这些属性使得可以创建一个属于
    `Student` 类的独特对象。因此，在这个例子中，创建 `Student` 类的实例时，需要提供 `name`、`age` 和 `address` 属性作为必需参数。
- en: 'Let''s create an object (also called an instance) belonging to the `Student`
    class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个属于 `Student` 类的对象（也称为实例）：
- en: '[PRE53]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, we created an object belonging to the `Student` class called
    `student1` where `John Doe` (name), `29` (age) and `123 Main Street, Newark, CA`(address)
    are attributes required to create an object. When we create an object that belongs
    to the `Student` class by passing the requisite arguments (declared earlier in
    the `__init__()` method of the `Student` class), the `__init__()` method is automatically
    called to initialize the object. Upon initialization, the information related
    to `student1` is stored under the object `student1`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `student1` 的 `Student` 类对象，其中 `John Doe`（姓名）、`29`（年龄）和 `123
    Main Street, Newark, CA`（地址）是创建对象所需的属性。当我们通过传递必需的参数（在 `Student` 类的 `__init__()`
    方法中先前声明）创建属于 `Student` 类的对象时，`__init__()` 方法会自动被调用以初始化对象。初始化后，与 `student1` 相关的信息存储在
    `student1` 对象下。
- en: 'Now, the information belonging to `student1` could be retrieved as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`student1` 对象的信息可以按以下方式检索：
- en: '[PRE54]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s create another object called `student2`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个名为 `student2` 的对象：
- en: '[PRE55]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We created two objects called `student1` and `student2`. Each object's attributes
    are accessible as `student1.name`, `student2.name` and so on. In the absence of
    object oriented programming, we will have to create variables like `student1_name`,
    `student1_age`, `student1_address`, `student2_name`, `student2_age` and `student2_address`
    and so on. Thus, OOP enables modularizing the code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个对象，分别称为 `student1` 和 `student2`。每个对象的属性都可以通过 `student1.name`、`student2.name`
    等方式访问。在没有面向对象编程的情况下，我们将不得不创建像 `student1_name`、`student1_age`、`student1_address`、`student2_name`、`student2_age`
    和 `student2_address` 等变量。因此，面向对象编程使代码模块化成为可能。
- en: Adding methods to a class
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向类中添加方法
- en: 'Let''s add some methods to our `Student` class that would help retrieve a student''s
    information:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Student` 类中添加一些方法，以帮助检索学生的信息：
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this example, we have added three methods namely `return_name()`, `return_age()`
    and `return_address()` that returns the attributes `name`, `age` and `address`
    respectively. These methods of a class are called **callable attributes**. Let's
    review a quick example where we make use of these callable attributes to print
    an object's information.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了三个方法，分别是 `return_name()`、`return_age()` 和 `return_address()`，分别返回属性
    `name`、`age` 和 `address`。这些类的方法被称为 **可调用属性**。让我们快速回顾一个例子，我们使用这些可调用属性来打印一个对象的信息。
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So far, we discussed methods that retrieves information about a student. Let''s
    include a method in our class that enables updating information belonging to a
    student. Now, let''s add another method to the class that enables updating address
    by a student:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了检索学生信息的方法。现在，让我们在我们的类中添加一个方法，以便更新属于学生的信息。现在，让我们再添加另一个方法到类中，允许学生通过以下方式更新地址：
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s compare the `student1` object''s address before and after updating the
    address:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较更新地址前后 `student1` 对象的地址：
- en: '[PRE59]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This would print the following output to your screen:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的屏幕上打印以下输出：
- en: '[PRE60]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Thus, we have written our first object-oriented code that demonstrates the ability
    to modularize the code. The preceding code sample is available for download along
    with this chapter as `student_info.py`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经编写了第一个面向对象的代码，展示了代码模块化的能力。前面的代码示例可以作为本章节的附件下载，名为 `student_info.py`。
- en: Doc strings in Python
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中的文档字符串
- en: 'In the object oriented example, you might have noticed a sentence enclosed
    in triple double quotes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的例子中，你可能注意到了一个被三重双引号包围的句子：
- en: '[PRE61]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is called a **doc string**. The doc string is used to document information
    about a class or a method. Doc strings are especially helpful while trying to
    store information related to the usage of a method or a class (this will be demonstrated
    later in this chapter). Doc strings are also used at the beginning of a file to
    store multi-line comments related to an application or a code sample. Doc strings
    are ignored by the Python interpreter and they are meant to provide documentation
    about a class to fellow programmers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 **文档字符串**。文档字符串用于记录有关类或方法的信息。文档字符串在尝试存储有关方法或类的使用信息时特别有用（这将在本章后面演示）。文档字符串还用于文件的开始部分，以存储有关应用程序或代码示例的多行注释。文档字符串被
    Python 解释器忽略，它们旨在为其他程序员提供有关类的文档。
- en: Similarly, the Python interpreter ignores any single line comment that starts
    with a `#` sign. Single line comments are generally used to make a specific note
    on a block of code. The practice of including well-structured comments makes your
    code readable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Python 解释器会忽略以 `#` 符号开始的任何单行注释。单行注释通常用于对代码块进行特定注释。包含良好结构的注释可以使你的代码易于阅读。
- en: 'For example, the following code snippet informs the reader that a random number
    between `0` and `9` is generated and stored in the variable `rand_num`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段通知读者生成了一个介于 `0` 和 `9` 之间的随机数，并将其存储在变量 `rand_num` 中：
- en: '[PRE62]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'On the contrary, a comment that provides no context is going to confuse someone
    who is reviewing your code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个没有上下文的注释可能会让审查你代码的人感到困惑：
- en: '[PRE63]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It is quite possible that you may not be able to recall what needs fixing when
    you revisit the code later.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能在你稍后再次查看代码时，你可能无法回忆起需要修复的内容。
- en: self
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: self
- en: 'In our object-oriented example, the first argument to every method had an argument
    called `self`. `self` refers to the instance of the class in use and the `self`
    keyword is used as the first argument in methods that interact with the instances
    of the class. In the preceding example, `self` refers to the object `student1`.
    It is equivalent to initializing an object and accessing it as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的面向对象示例中，每个方法的第一个参数都有一个名为`self`的参数。`self`指的是正在使用的类的实例，`self`关键字在与类的实例交互的方法中用作第一个参数。在上面的示例中，`self`指的是`student1`对象。它相当于初始化一个对象并如下访问它：
- en: '[PRE64]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `self` keyword simplifies how we access an object's attributes in this case.
    Now, let's review some examples where we make use of OOP involving the Raspberry
    Pi.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`关键字简化了我们访问对象属性的方式。现在，让我们回顾一些使用OOP和Raspberry Pi的示例。'
- en: Speaker controller
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扬声器控制器
- en: Let's write a Python class (`tone_player.py` in downloads) that plays a musical
    tone indicating that the boot-up of your Raspberry Pi is complete. For this section,
    you will need a USB sound card and a speaker interfaced to the USB hub of the
    Raspberry Pi.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个Python类（下载中的`tone_player.py`），该类播放一个音乐音调，表示你的Raspberry Pi启动完成。对于本节，你需要一个USB声卡和一个连接到Raspberry
    Pi USB集线器的扬声器。
- en: 'Let''s call our class `TonePlayer`. This class should be capable of controlling
    the speaker volume and playing any file passed as an argument while creating an
    object:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称我们的类为`TonePlayer`。这个类应该能够控制扬声器的音量和在创建对象时播放任何作为参数传递的文件：
- en: '[PRE65]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this case, the file that has to be played by the `TonePlayer` class has
    to be passed an argument. For example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`TonePlayer`类必须传递一个文件作为参数来播放。例如：
- en: '[PRE66]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We also need to be able to set the volume level at which the tone has to be
    played. Let''s add a method to do the same:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够设置音调播放的音量级别。让我们添加一个方法来完成同样的任务：
- en: '[PRE67]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the `set_volume` method, we make use of Python's `subprocess` module to run
    the Linux system command that adjusts the sound drive volume.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`set_volume`方法中，我们使用Python的`subprocess`模块运行Linux系统命令来调整声音驱动程序的音量。
- en: 'The most essential method for this class is the `play` command. When the `play`
    method is called, we need to play the tone sound using Linux''s a `play` command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类最重要的方法是`play`命令。当调用`play`方法时，我们需要使用Linux的`play`命令播放音调声音：
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Put it all together:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 把它们放在一起：
- en: '[PRE69]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Save the `TonePlayer` class to your Raspberry Pi (save it to a file called `tone_player.py`)
    and use a tone sound file from sources like *freesound* ([https://www.freesound.org/people/zippi1/sounds/18872/](https://www.freesound.org/people/zippi1/sounds/18872/)).
    Save it to a location of your choice and try running the code. It should play
    the tone sound at the desired volume!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将`TonePlayer`类保存到你的Raspberry Pi（保存到名为`tone_player.py`的文件）中，并使用来自类似*freesound*（[https://www.freesound.org/people/zippi1/sounds/18872/](https://www.freesound.org/people/zippi1/sounds/18872/)）的音调声音文件。将其保存到您选择的位置，并尝试运行代码。它应该在期望的音量下播放音调声音！
- en: 'Now, edit `/etc/rc.local` and add the following line to the end of the file
    (right before the `exit 0` line):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑`/etc/rc.local`文件，并在文件末尾添加以下行（在`exit 0`行之前）：
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This should play a tone whenever the Pi boots up!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在Pi启动时播放音调！
- en: Light control daemon
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光控制守护进程
- en: 'Let''s review another example where we implement a simple daemon using OOP
    that turns on/off lights at specified times of the day. In order to be able to
    perform tasks at scheduled times, we will make use of the `schedule` library ([https://github.com/dbader/schedule](https://github.com/dbader/schedule)).
    It could be installed as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾另一个示例，其中我们使用OOP实现一个简单的守护进程，在指定的时间打开/关闭灯光。为了能够在预定时间执行任务，我们将使用`schedule`库（[https://github.com/dbader/schedule](https://github.com/dbader/schedule)）。它可以如下安装：
- en: '[PRE71]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s call our class, `LightScheduler`. It should be capable of accepting
    start and top times to turn on/off lights at given times. It should also provide
    override capabilities to let the user turn on/off lights as necessary. Let''s
    assume that the light is controlled using **PowerSwitch Tail II** ([http://www.powerswitchtail.com/Pages/default.aspx](http://www.powerswitchtail.com/Pages/default.aspx)).
    It is interfaced as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称我们的类为`LightScheduler`。它应该能够接受开始和结束时间，在指定的时间打开/关闭灯光。它还应该提供覆盖功能，让用户根据需要打开/关闭灯光。假设使用**PowerSwitch
    Tail II**（[http://www.powerswitchtail.com/Pages/default.aspx](http://www.powerswitchtail.com/Pages/default.aspx)）来控制灯光。它如下所示连接：
- en: '![](img/image_05_001.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_001.png)'
- en: Raspberry Pi Zero interfaced to the PowerSwitch Tail II
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Zero连接到PowerSwitch Tail II
- en: 'The following is the `LightSchedular` class created:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建的`LightSchedular`类：
- en: '[PRE72]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Whenever an instance of `LightScheduler` is created, the GPIO pin is initialized
    to control the PowerSwitch Tail II. Now, let''s add methods to turn on/off lights:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建`LightScheduler`的一个实例时，GPIO引脚被初始化以控制PowerSwitch Tail II。现在，让我们添加开启/关闭灯光的方法：
- en: '[PRE73]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the `init_schedule()` method, the start and stop times that were passed as
    arguments are used to initialize `schedule` to turn on/off the lights at the specified
    times.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init_schedule()`方法中，传入的起始和结束时间作为参数被用来初始化`schedule`，以便在指定的时间开启/关闭灯光。
- en: 'Put it together, we have:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们放在一起，我们有：
- en: '[PRE74]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding example, the lights are scheduled to be turned on at 6:30 p.m.
    and turned off at 9:30 a.m. Once the jobs are scheduled, the program enters an
    infinite loop where it awaits task execution. This example could be run as a daemon
    by executing the file at start-up (add a line called `light_scheduler.py` to `/etc/rc.local`).
    After scheduling the job, it will continue to run as a daemon in the background.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，灯光被安排在下午6:30开启，早上9:30关闭。一旦任务被安排，程序进入一个无限循环，等待任务执行。这个示例可以作为守护进程运行（在启动时执行文件，将名为`light_scheduler.py`的行添加到`/etc/rc.local`中）。在安排任务后，它将继续作为守护进程在后台运行。
- en: This is just a basic introduction to OOP and its applications (keeping the beginner
    in mind). Refer to this book's website for more examples on OOP.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个对面向对象编程及其应用的简单介绍（考虑到初学者的需求）。有关OOP的更多示例，请参阅本书的网站。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed lists and the advantages of OOP. We discussed
    OOP examples using the Raspberry Pi as the center of the examples. Since the book
    is targeted mostly towards beginners, we decided to stick to the basics of OOP
    while discussing examples. There are advanced aspects that are beyond the scope
    of the book. We leave it up to the reader to learn advanced concepts using other
    examples available on this book's site.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了列表和面向对象编程（OOP）的优势。我们以树莓派为中心，讨论了OOP的示例。由于本书主要面向初学者，我们决定在讨论示例时坚持OOP的基础知识。书中未涉及一些高级内容。我们留给读者使用本书网站上提供的其他示例来学习高级概念。
