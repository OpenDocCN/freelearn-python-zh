- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Expecting the Unexpected
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预期意外之事
- en: Systems built with software can be fragile. While the software is highly predictable,
    the runtime context can provide unexpected inputs and situations. Devices fail,
    networks are unreliable, mere anarchy is loosed on our application. We need to
    have a way to work around the spectrum of failures that plague computer systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用软件构建的系统可能很脆弱。虽然软件本身具有高度的预测性，但运行时环境可能会提供意外的输入和情况。设备会故障，网络不可靠，纯粹的无政府状态被释放到我们的应用程序中。我们需要有一种方法来应对困扰计算机系统的各种故障范围。
- en: 'There are two broad approaches to dealing with the unforeseen. One approach
    is to return a recognizable error-signaling value from a function. A value, like
    `None`, could be used. Other library functions can then be used by an application
    to retrieve details of the erroneous condition. A variation on this theme is to
    pair a return from an OS request with a success or failure indicator. The other
    approach is to interrupt the normal, sequential execution of statements and divert
    to statements that handle exceptions. This second approach is what Python does:
    it eliminates the need to check return values for errors.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 处理意外情况有两种主要方法。一种方法是在函数中返回一个可识别的错误信号值。例如，可以使用`None`这样的值。应用程序可以使用其他库函数来检索错误条件的相关细节。对此主题的一种变体是将操作系统请求的返回值与成功或失败指示器配对。另一种方法是中断语句的正常、顺序执行，并转向处理异常的语句。第二种方法正是Python所采用的：它消除了检查返回值以确定错误的需求。
- en: 'In this chapter, we will study **exceptions**, special error objects raised
    when a normal response is impossible. In particular, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习**异常**，这是在正常响应不可能时抛出的特殊错误对象。特别是，我们将涵盖以下内容：
- en: How to cause an exception to occur
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何引发异常发生
- en: How to recover when an exception has occurred
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当异常发生时如何恢复
- en: How to handle different exception types in different ways
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以不同的方式处理不同的异常类型
- en: Cleaning up when an exception has occurred
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生异常时进行清理
- en: Creating new types of exception
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的异常类型
- en: Using the exception syntax for flow control
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异常语法进行流程控制
- en: The case study for this chapter will look at data validation. We'll examine
    a number of ways exceptions can be used to ensure that inputs to our classifier
    are valid.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究将探讨数据验证。我们将检查多种使用异常来确保我们的分类器输入有效的方法。
- en: We'll start by looking at Python's concept of an `Exception`, and how exceptions
    are raised and handled.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨 Python 的 `异常` 概念，以及异常是如何被引发和处理的。
- en: Raising exceptions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Python's normal behavior is to execute statements in the order they are found,
    either in a file or at the `>>>` prompt interactively. A few statements, specifically
    `if`, `while`, and `for`, alter the simple top-to-bottom sequence of statement
    execution. Additionally, an exception can break the sequential flow of execution.
    Exceptions are raised, and this interrupts the sequential execution of statements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python的正常行为是按照它们被找到的顺序执行语句，无论是在文件中还是在`>>>`提示符的交互式模式下。一些语句，特别是`if`、`while`和`for`，会改变语句执行的简单自上而下的顺序。此外，异常可以打断执行流程。异常会被引发，这会中断语句的顺序执行。
- en: In Python, the exception that's raised is also an object. There are many different
    exception classes available, and we can easily define more of our own. The one
    thing they all have in common is that they inherit from a built-in class called `BaseException`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，抛出的异常也是一个对象。有众多不同的异常类可供选择，我们也可以轻松地定义更多的自定义异常。它们共有的一个特点是都继承自一个内置类，称为`BaseException`。
- en: When an exception is raised, everything that was supposed to happen is pre-empted.
    Instead, exception handling replaces normal processing. Make sense? Don't worry,
    it will!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，原本应该发生的一切都被打断。取而代之的是，异常处理取代了正常处理。这说得通吗？别担心，它会的！
- en: 'The easiest way to cause an exception to occur is to do something silly. Chances
    are you''ve done this already and seen the exception output. For example, any
    time Python encounters a line in your program that it can''t understand, it bails
    with `SyntaxError`, which is a type of exception. Here''s a common one:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 引发异常的最简单方式就是做一些愚蠢的事情。很可能你已经这样做过了，并且看到了异常输出。例如，每当Python遇到它无法理解的程序中的某一行时，它会通过`SyntaxError`退出，这是一种异常类型。下面是一个常见的例子：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `print()` function requires the arguments to be enclosed in parentheses.
    So, if we type the preceding command into a Python 3 interpreter, we raise a `SyntaxError`
    exception.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()` 函数要求参数必须放在括号内。因此，如果我们把前面的命令输入到 Python 3 解释器中，就会引发一个 `SyntaxError`
    异常。'
- en: 'In addition to `SyntaxError`, some other common exceptions are shown in the
    following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`SyntaxError`，以下示例中展示了其他一些常见的异常：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can partition these exceptions into roughly four categories. Some cases
    are blurry, but some edges have a bright line separating them:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些异常情况大致分为四个类别。有些情况比较模糊，但有些边缘有一条清晰的界限：
- en: Sometimes, these exceptions are indicators of something clearly wrong in our
    program. Exceptions like `SyntaxError` and `NameError` mean we need to find the
    indicated line number and fix the problem.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，这些异常是我们程序中存在明显错误的指示。像`SyntaxError`和`NameError`这样的异常意味着我们需要找到指示的行号并修复问题。
- en: Sometimes, these exceptions are indicators of something wrong in the Python
    runtime. There's a `RuntimeError` exception that can get raised. In many cases,
    this is resolved by downloading and installing a newer Python. (Or, if you're
    wrestling with a "Release Candidate" version, reporting the bug to the maintainers.)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，这些异常是 Python 运行时出现问题的指示。可能会引发一个 `RuntimeError` 异常。在许多情况下，这个问题可以通过下载并安装更新的
    Python 版本来解决。（或者，如果你正在与“发布候选”版本搏斗，可以向维护者报告这个错误。）
- en: Some exceptions are design problems. We may fail to account for an edge case
    properly and sometimes try to compute an average of an empty list. This will result
    in a `ZeroDivisionError`. When we find these, again, we'll have to go to the indicated
    line number. But once we've found the resulting exception, we'll need to work
    backwards from there to find out what caused the problem that raised the exception.
    Somewhere there will be an object in an unexpected or not-designed-for state.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些异常是设计问题。我们可能未能正确处理边缘情况，有时甚至尝试计算空列表的平均值。这会导致`ZeroDivisionError`错误。当我们再次发现这些问题时，我们还得回到指示的行号。但一旦我们找到了产生的异常，我们就需要从那里回溯以找出导致异常的问题原因。某个地方将会有一个处于意外或非设计状态的对象。
- en: 'The bulk of the exceptions arise near our program''s interfaces. Any user input,
    or operating system request, including file operations, can encounter problems
    with the resources outside our program, leading to exceptions. We can subdivide
    these interface problems further into two sub-groups:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数异常都出现在我们程序的接口附近。任何用户输入，或操作系统请求，包括文件操作，都可能遇到我们程序外部资源的问题，从而导致异常。我们可以将这些接口问题进一步细分为两个子组：
- en: External objects in an unusual or unanticipated state. This is common with files
    that aren't found because the path was spelled incorrectly, or directories that
    already exist because our application crashed earlier and we restarted it. These
    will often be some kind of `OSError` with a reasonably clear root cause. It's
    also common with users entering things incorrectly, or even users maliciously
    trying to subvert the application. These should be application-specific exceptions
    to prevent dumb mistakes or intentional abuse.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不寻常或未预料到的状态下出现的外部对象。这通常发生在由于路径拼写错误而找不到文件，或者由于我们的应用程序之前崩溃并重新启动而已经存在的目录。这些情况通常会导致某种`OSError`，其根本原因相对明确。当用户输入错误，甚至恶意尝试破坏应用程序时，这种情况也很常见。这些应该是特定于应用程序的异常，以防止愚蠢的错误或故意的滥用。
- en: And there's also the (relatively small) category of simple chaos. In the final
    analysis, a computer system is a lot of interconnected devices and any one of
    the components could behave badly. These are hard to anticipate and it's harder
    still to plan a recovery strategy. When working with a small IoT computer, there
    are few parts, but it may be installed in a challenging physical environment.
    When working with an enterprise server farm with thousands of components, a 0.1%
    failure rate means something is always broken.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有相对较小的简单混沌类别。最终分析，计算机系统是由许多相互连接的设备组成，任何一个组件都可能表现不佳。这些情况难以预测，制定恢复策略更是难上加难。当使用小型物联网计算机时，部件较少，但可能安装在具有挑战性的物理环境中。当与拥有数千个组件的企业服务器农场一起工作时，0.1%的故障率意味着总会有东西出问题。
- en: You may have noticed all of Python's built-in exceptions end with the name `Error`.
    In Python, the words **error** and **exception** are used almost interchangeably.
    Errors are sometimes considered more dire than exceptions, but they are dealt
    with in exactly the same way. Indeed, all the error classes in the preceding example
    have `Exception` (which extends `BaseException`) as their superclass.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到Python的所有内置异常都以名称`Error`结尾。在Python中，`error`和`exception`这两个词几乎可以互换使用。有时人们认为错误（error）比异常（exception）更为严重，但它们处理的方式完全相同。确实，前面示例中的所有错误类都以`Exception`（它扩展了`BaseException`）作为它们的超类。
- en: Raising an exception
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'We''ll get to responding to such exceptions in a minute, but first, let''s
    discover what we should do if we''re writing a program that needs to inform the
    user or a calling function that the inputs are invalid. We can use the exact same
    mechanism that Python uses. Here''s a simple class that adds items to a list only
    if they are even-numbered integers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一分钟内了解如何处理此类异常，但首先，让我们探讨如果我们正在编写一个需要通知用户或调用函数输入无效的程序时，我们应该做什么。我们可以使用Python使用的完全相同的机制。以下是一个简单的类，它只将偶数整数的项添加到列表中：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class extends the built-in list, as we discussed in *Chapter 2*, *Objects
    in Python*. We've provided a type hint suggesting we're creating a list of integer
    objects only. To do this, we've overridden the `append` method to check two conditions
    that ensure the item is an even integer. We first check whether the input is an
    instance of the `int` type, and then use the modulo operator to ensure it is divisible
    by two. If either of the two conditions is not met, the `raise` keyword causes
    an exception to occur.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了内置的列表，正如我们在*第二章*，*Python中的对象*中讨论的那样。我们提供了一个类型提示，表明我们正在创建一个仅包含整数对象的列表。为此，我们重写了`append`方法来检查两个条件，确保项目是一个偶数整数。我们首先检查输入是否是`int`类型的实例，然后使用取模运算符来确保它能被2整除。如果这两个条件中的任何一个不满足，`raise`关键字将导致异常发生。
- en: The `raise` keyword is followed by the object being raised as an exception.
    In the preceding example, two objects are constructed from the built-in `TypeError` and `ValueError` classes.
    The raised object could just as easily be an instance of a new `Exception` class
    we create ourselves (we'll see how shortly), an exception that was defined elsewhere,
    or even an `Exception` object that has been previously raised and handled.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise` 关键字后面跟着要抛出的异常对象。在上一个例子中，从内置的 `TypeError` 和 `ValueError` 类中构造了两个对象。抛出的对象也可以是我们自己创建的新
    `Exception` 类的实例（我们很快就会看到），或者是在其他地方定义的异常，甚至是之前已经抛出并被处理的 `Exception` 对象。'
- en: 'If we test this class in the Python interpreter, we can see that it is outputting
    useful error information when exceptions occur, just as before:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Python 解释器中测试这个类，我们可以看到当发生异常时，它正在输出有用的错误信息，就像之前一样：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this class is effective for demonstrating exceptions in action, it isn't
    very good at its job. It is still possible to get other values into the list using
    index notation or slice notation. These additional behaviors can be avoided by
    overriding other appropriate methods, some of which are magic double-underscore
    methods. To be really complete, we'd need to override methods like `extend()`,
    `insert()`, `__setitem__()`, and even `__init__()` to be sure things start off
    correctly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个类在演示异常行为方面很有效，但它并不擅长自己的工作。仍然可以通过索引表示法或切片表示法将其他值放入列表中。可以通过覆盖其他适当的方法来避免这些额外的行为，其中一些是魔法双下划线方法。为了真正完整，我们需要覆盖像`extend()`、`insert()`、`__setitem__()`甚至`__init__()`这样的方法，以确保事情从正确开始。
- en: The effects of an exception
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常的影响
- en: When an exception is raised, it appears to stop program execution immediately.
    Any lines that were supposed to run after the exception is raised are not executed,
    and unless the exception is handled by an `except` clause, the program will exit
    with an error message. We'll examine unhandled exceptions first, and then take
    a close look at handling exceptions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，它似乎会立即停止程序执行。在异常抛出后本应运行的任何代码行都不会被执行，除非异常被`except`子句处理，否则程序将带错误信息退出。我们将首先检查未处理的异常，然后详细探讨异常处理。
- en: 'Take a look at this basic function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个基本函数：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've included the `NoReturn` type hint for this function. This helps ease **mypy**'s
    worry that there's no way for this function to reach the end and return a string
    value. The type hint states, formally, the function isn't expected to return a
    value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个函数添加了`NoReturn`类型提示。这有助于减轻**mypy**的担忧，即这个函数没有返回字符串值的途径。类型提示正式地说明，这个函数预期不会返回任何值。
- en: (Note that **mypy** is aware the final `return` cannot be executed. It does
    not object to the return type being `NoReturn`, even though there's a `return`
    statement with a string literal. It's clear this cannot be executed.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，**mypy**知道最终的`return`无法执行。它不会反对返回类型为`NoReturn`，即使有一个包含字符串字面量的`return`语句。很明显，这无法执行。）
- en: 'If we execute this function, we see that the first `print()` call is executed
    and then the exception is raised. The second `print()` function call is never
    executed, nor is the `return` statement. Here''s what it looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个函数，我们会看到第一个`print()`调用被执行，然后抛出异常。第二个`print()`函数调用永远不会被执行，同样，`return`语句也不会执行。下面是它的样子：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Furthermore, if we have a function that calls another function that raises
    an exception, nothing is executed in the first function after the point where
    the second function''s exception was raised. Raising an exception stops all execution
    right up through the function call stack until it is either handled or forces
    the interpreter to exit. To demonstrate, let''s add a second function that calls
    the `never_returns()` function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们有一个函数调用了另一个抛出异常的函数，那么在第二个函数抛出异常的点之后，第一个函数中就没有任何代码被执行。抛出异常会立即停止所有执行，直到异常被处理或者迫使解释器退出。为了演示，让我们添加一个调用`never_returns()`函数的第二个函数：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we call this function, we see that the first `print` statement executes,
    as well as the first line in the `never_returns()` function. But once the exception
    is raised, nothing else executes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，我们会看到第一条`print`语句执行了，以及`never_returns()`函数中的第一条语句。但是一旦抛出异常，其他任何操作都不会执行：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that **mypy** didn't recognize what `never_returns()` does to the processing
    in `call_exceptor()`. Based on previous examples, it seems like `call_exceptor()`
    is better described as a `NoReturn` function. When we try this, we get a warning
    from **mypy**. It turns out the **mypy** focus is rather narrow; it examines function
    and method definitions in relative isolation; it isn't aware that `never_returns()`
    raises an exception.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 **mypy** 没有识别出 `never_returns()` 在 `call_exceptor()` 中的处理方式。根据之前的示例，似乎 `call_exceptor()`
    更适合被描述为一个 `NoReturn` 函数。当我们尝试这样做时，我们收到了 **mypy** 的警告。结果证明，**mypy** 的关注点相当狭窄；它相对独立地检查函数和方法定义；它没有意识到
    `never_returns()` 会引发一个异常。
- en: We can control how exceptions propagate from the initial `raise` statement.
    We can react to and deal with the exception inside either of these methods in
    the call stack.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以控制异常从初始`raise`语句的传播方式。我们可以在调用栈中的任意一个方法内对异常做出反应并处理。
- en: Look at the output from the unhandled exception above, called a **traceback**.
    This shows the call stack. The command line ("`<module>`" is the name used when
    there's no input file) called `call_exceptor()`, and `call_exceptor()` called
    `never_returns()`. Inside `never_returns()`, the exception is initially raised.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上面未处理的异常的输出，这被称为**跟踪回溯**。这显示了调用栈。命令行（"`<module>`"是在没有输入文件时使用的名称）调用了`call_exceptor()`，而`call_exceptor()`又调用了`never_returns()`。在`never_returns()`内部，异常最初被抛出。
- en: The exception propagates up through the call stack. From inside `call_exceptor()`,
    the pesky `never_returns()` function was called and the exception *bubbled up* to
    the calling method. From there, it went up one more level to the main interpreter,
    which, not knowing what else to do with it, gave up and printed the traceback
    object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 异常沿着调用栈向上传播。在`call_exceptor()`函数内部，那个讨厌的`never_returns()`函数被调用，异常被*冒泡*到调用方法。从那里，它又向上提升一级到达主解释器，主解释器不知道如何处理它，于是放弃并打印了跟踪对象。
- en: Handling exceptions
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'Now let''s look at the tail side of the exception coin. If we encounter an
    exception situation, how should our code react to or recover from it? We handle
    exceptions by wrapping any code that might throw one (whether it is exception
    code itself, or a call to any function or method that may have an exception raised
    inside it) inside a `try...except` clause. The most basic syntax looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看异常硬币的背面。如果我们遇到异常情况，我们的代码应该如何反应或恢复？我们通过将可能抛出异常的任何代码（无论是异常代码本身，还是调用任何可能在其内部引发异常的函数或方法）包裹在`try...except`子句中来处理异常。最基础的语法看起来是这样的：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we run this simple script using our existing `never_returns()` function—which,
    as we know very well, always throws an exception—we get this output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用现有的`never_returns()`函数运行这个简单的脚本——正如我们所非常清楚的那样，这个函数总是会抛出异常——我们会得到以下输出：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `never_returns()` function happily informs us that it is about to raise
    an exception and raises it. The `handler()` function's `except` clause catches
    the exception. Once caught, we are able to clean up after ourselves (in this case,
    by outputting that we are handling the situation), and continue on our way. The
    remainder of the code in the `never_returns()` function remains unexecuted, but
    the code in the `handler()` function after the `try:` statement is able to recover
    and continue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`never_returns()` 函数愉快地通知我们它即将抛出一个异常，并且确实抛出了异常。`handler()` 函数的 `except` 子句捕获了这个异常。一旦捕获到异常，我们就能够自行清理（在这个例子中，通过输出我们正在处理这种情况），然后继续前进。`never_returns()`
    函数中剩余的代码保持未执行状态，但 `try:` 语句之后的 `handler()` 函数中的代码能够恢复并继续执行。'
- en: Note the indentation around `try` and `except`. The `try` clause wraps any code
    that might throw an exception. The `except` clause is then back on the same indentation
    level as the `try` line. Any code to handle the exception is indented inside the `except` clause.
    Then normal code resumes at the original indentation level.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`try`和`except`周围的缩进。`try`子句包含可能抛出异常的任何代码。然后`except`子句回到与`try`行相同的缩进级别。处理异常的任何代码都缩进在`except`子句内部。然后正常代码在原始缩进级别上继续执行。
- en: The problem with the preceding code is that it uses the `Exception` class to
    match any type of exception. What if we were writing some code that could raise
    either `TypeError` or `ZeroDivisionError`? We might need to catch `ZeroDivisionError`
    because it reflects a known object state, but let any other exceptions propagate
    to the console because they reflect bugs we need to catch and kill. Can you guess
    the syntax?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的问题在于它使用`Exception`类来匹配任何类型的异常。如果我们编写了一些可能引发`TypeError`或`ZeroDivisionError`的代码，会怎样呢？我们可能需要捕获`ZeroDivisionError`，因为它反映了已知的对象状态，但让其他任何异常传播到控制台，因为它们反映了我们需要捕获并解决的错误。你能猜到语法吗？
- en: 'Here''s a rather silly function that does just that:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个相当愚蠢的功能，它就是做这件事：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function does a simple computation. We've provided the type hint of `float`
    for the `divisor` parameter. We can provide an integer, and ordinary Python type
    coercion will work. The **mypy** tool is aware of the ways integers can be coerced
    to floats, saving it from having to obsess over the parameter types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数执行简单的计算。我们为`divisor`参数提供了`float`类型的类型提示。我们可以提供一个整数，普通的Python类型转换将起作用。**mypy**工具了解整数如何转换为浮点数的方式，从而避免了对参数类型的过度关注。
- en: 'We do, however, have to be very clear about the return types. If we don''t
    raise an exception, we''ll compute and return a floating result. If we do raise
    a `ZeroDivisionError` exception, it will be handled, and we''ll return a string
    result. Any other exceptions? Let''s try it and see:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须非常清楚关于返回类型。如果我们不抛出异常，我们将计算并返回一个浮点结果。如果我们抛出`ZeroDivisionError`异常，它将被处理，我们将返回一个字符串结果。还有其他异常吗？让我们试一试看看：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line of output shows that if we enter `0`, we get properly mocked.
    If we call with a valid number, it operates correctly. Yet if we enter a string
    (you were wondering how to get a `TypeError`, weren't you?), it fails with an
    unhandled exception. If we don't specify matching the `ZeroDivisionError` exception
    class, our handler would also see the `TypeError`, and accuse us of dividing by
    zero when we sent it a string, which is not a proper behavior at all.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行显示，如果我们输入`0`，我们会得到适当的模拟。如果我们使用一个有效的数字进行调用，它将正确运行。然而，如果我们输入一个字符串（你可能想知道如何得到一个`TypeError`，对吧？），它将因为未处理的异常而失败。如果我们没有指定匹配`ZeroDivisionError`异常类，我们的处理器也会看到`TypeError`，并指责我们在发送字符串时除以零，这根本不是一种合适的行为。
- en: Python also has a bare except syntax. Using `except:` with no exception class
    to match is widely frowned upon because it will prevent an application from simply
    crashing when it should. We generally use `except Exception:` to explicitly catch
    a sensible set of exceptions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还有一种“裸除”的异常处理语法。使用 `except:` 而不指定匹配的异常类通常是不被推荐的，因为这会阻止应用程序在应该崩溃时简单地崩溃。我们通常使用
    `except Exception:` 来显式捕获一组合理的异常。
- en: The bare except syntax is actually the same as using `except BaseException``:`,
    which attempts to handle system-level exceptions that are often impossible to
    recover from. Indeed, this can make it impossible to crash your application when
    it's misbehaving.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 空的异常语法实际上与使用 `except BaseException:` 相同，它试图处理通常无法恢复的系统级异常。确实，这可以使应用程序在行为异常时无法崩溃。
- en: 'We can even catch two or more different exceptions and handle them with the
    same code. Here''s an example that raises three different types of exceptions.
    It handles `TypeError` and `ZeroDivisionError` with the same exception handler,
    but it may also raise a `ValueError` error if you supply the number `13`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以捕获两个或更多不同类型的异常，并使用相同的代码来处理它们。以下是一个引发三种不同类型异常的示例。它使用相同的异常处理程序来处理`TypeError`和`ZeroDivisionError`，但如果您提供数字`13`，它也可能引发一个`ValueError`错误：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ve included multiple exception classes in the `except` clause. This lets
    us handle a variety of conditions with a common handler. Here''s how we can test
    this with a bunch of different values:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`except`子句中包含了多个异常类。这使得我们可以用一个通用的处理程序来处理各种条件。以下是我们可以如何使用一系列不同的值来测试这一点：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `for` statement iterates over several test inputs and prints the results.
    If you're wondering about that `end` parameter in the `print` function, it just
    turns the default trailing newline into a space so that it's joined with the output
    from the next line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句遍历多个测试输入并打印结果。如果你对`print`函数中的那个`end`参数感到好奇，它只是将默认的尾随换行符转换为一个空格，这样就可以与下一行的输出连接起来。'
- en: The number 0 and the string are both caught by the `except` clause, and a suitable
    error message is printed. The exception from the number `13` is not caught because
    it is a `ValueError`, which was not included in the types of exceptions being
    handled. This is all well and good, but what if we want to catch different exceptions
    and do different things with them? Or maybe we want to do something with an exception
    and then allow it to continue to bubble up to the parent function, as if it had
    never been caught?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 数字0和字符串都被`except`子句捕获，并打印出合适的错误信息。来自数字`13`的异常没有被捕获，因为它是一个`ValueError`，这并没有包含在正在处理的异常类型中。这一切都很好，但如果我们想捕获不同的异常并对它们做不同的事情呢？或者，我们可能想在处理异常之后让它继续向上冒泡到父函数，就像它从未被捕获一样？
- en: 'We don''t need any new syntax to deal with these cases. It''s possible to stack
    the `except` clauses, and only the first match will be executed. For the second
    question, the `raise` keyword, with no arguments, will re-raise the last exception
    if we''re already inside an exception handler. Observe the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要任何新的语法来处理这些情况。我们可以堆叠`except`子句，并且只有第一个匹配的将会被执行。对于第二个问题，使用不带参数的`raise`关键字，如果我们已经在一个异常处理程序内部，它将会重新抛出最后一个异常。观察以下代码：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The last line re-raises the `ValueError` error, so after outputting `No, No,
    not 13!`, it will raise the exception again; we'll still get the original stack
    trace on the console.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行再次引发`ValueError`错误，因此在输出`No, No, not 13!`之后，它将再次抛出异常；我们仍然会在控制台上得到原始的堆栈跟踪信息。
- en: If we stack exception clauses like we did in the preceding example, only the
    first matching clause will be run, even if more than one of them fits. How can
    more than one clause match? Remember that exceptions are objects, and can therefore
    be subclassed. As we'll see in the next section, most exceptions extend the `Exception` class
    (which is itself derived from `BaseException`). If we have an `except` clause
    to match `Exception` before we match `TypeError`, then only the `Exception` handler
    will be executed, because `TypeError` is an `Exception` by inheritance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像前一个示例中那样堆叠异常子句，即使多个子句都匹配，也只会运行第一个匹配的子句。如何会有多个子句匹配呢？记住，异常是对象，因此可以被继承。正如我们将在下一节中看到的，大多数异常都扩展了`Exception`类（它本身是从`BaseException`派生出来的）。如果我们有一个匹配`Exception`的`except`子句在匹配`TypeError`之前，那么只有`Exception`处理程序会被执行，因为`TypeError`是通过继承成为`Exception`的。
- en: This can come in handy in cases where we want to handle some exceptions specifically,
    and then handle all remaining exceptions as a more general case. We can list `Exception` in
    its own clause after catching all the specific exceptions and handle the general
    case there.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要特别处理一些异常情况，然后以更通用的方式处理所有剩余异常的情况下，这会很有用。在捕获所有特定异常之后，我们可以在自己的子句中列出`Exception`，并在那里处理通用情况。
- en: 'Often, when we catch an exception, we need a reference to the `Exception` object
    itself. This most often happens when we define our own exceptions with custom
    arguments, but can also be relevant with standard exceptions. Most exception classes
    accept a set of arguments in their constructor, and we might want to access those
    attributes in the exception handler. If we define our own `Exception` class, we
    can even call custom methods on it when we catch it. The syntax for capturing
    an exception as a variable uses the `as` keyword:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们捕获异常时，我们需要引用到`Exception`对象本身。这种情况最常发生在我们使用自定义参数定义自己的异常时，但也可能与标准异常相关。大多数异常类在其构造函数中接受一组参数，我们可能希望在异常处理程序中访问这些属性。如果我们定义了自己的`Exception`类，那么在捕获它时甚至可以调用自定义方法。捕获异常作为变量的语法使用`as`关键字：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've seen several variations on the syntax for handling exceptions, but we
    still don't know how to execute code regardless of whether or not an exception
    has occurred. We also can't specify code that should be executed **only** if an
    exception does **not** occur. Two more keywords, `finally` and `else`, provide
    some additional execution paths. Neither one takes any extra arguments.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了处理异常的语法变体，但我们仍然不知道如何在发生异常与否的情况下执行代码。我们也不能指定仅在未发生异常时才应执行的代码。另外两个关键字 `finally`
    和 `else` 提供了一些额外的执行路径。这两个关键字都不需要任何额外的参数。
- en: We'll show an example with the `finally` clause. For the most part, we often
    use context managers instead of exception blocks as a cleaner way to implement
    a finalization that occurs whether or not an exception interrupted processing.
    The idea is to encapsulate responsibility for finalization in the context manager.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过带有`finally`子句的示例来展示。大部分情况下，我们通常使用上下文管理器而不是异常块，作为一种更干净的方式来实现无论是否发生异常中断处理都会发生的最终化操作。其理念是将最终化责任封装在上下文管理器中。
- en: 'The following example iterates through a number of exception classes, raising
    an instance of each. Then some not-so-complicated exception handling code runs
    that illustrates the newly introduced syntax:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例遍历了多个异常类，为每个类抛出一个实例。然后运行了一些不太复杂的异常处理代码，展示了新引入的语法：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we run this example – which illustrates almost every conceivable exception
    handling scenario – we''ll see the following output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个示例——它几乎涵盖了所有可想象的异常处理场景——我们将看到以下输出：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note how the `print` statement in the `finally` clause is executed no matter
    what happens. This is one way to perform certain tasks after our code has finished
    running (even if an exception has occurred). Some common examples include the
    following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在`finally`子句中的`print`语句无论发生什么情况都会被执行。这是在我们代码运行完成后执行某些任务的一种方式（即使发生了异常）。以下是一些常见的例子：
- en: Cleaning up an open database connection
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理一个打开的数据库连接
- en: Closing an open file
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭一个打开的文件
- en: Sending a closing handshake over the network
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上发送关闭握手
- en: All of these are more commonly handled with context managers, one of the topics
    of *Chapter 8*, *The Intersection of Object-Oriented and Functional Programming*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些通常都通过上下文管理器来处理，这是*第8章*，*面向对象与函数式编程的交汇*，的主题之一。
- en: While obscure, the `finally` clause is executed after the `return` statement
    inside a `try` clause. While this can be exploited for post-`return` processing,
    it can also be confusing to folks reading the code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然晦涩，但`finally`子句会在`try`子句中的`return`语句之后执行。虽然这可以被用于`return`之后的处理，但对于阅读代码的人来说也可能造成困惑。
- en: 'Also, pay attention to the output when no exception is raised: both the `else` and
    the `finally` clauses are executed. The `else` clause may seem redundant, as the
    code that should be executed when no exception is raised could just be placed
    after the entire `try...except` block. The difference is that the `else` block
    will not be executed if an exception is caught and handled. We''ll see more on
    this when we discuss using exceptions as flow control later.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意在未抛出异常时的输出：`else` 和 `finally` 子句都会被执行。`else` 子句可能看起来是多余的，因为当没有抛出异常时应该执行的代码可以直接放在整个
    `try...except` 块之后。区别在于，如果捕获并处理了异常，`else` 块将不会被执行。当我们后面讨论使用异常作为流程控制时，我们会看到更多关于这一点的内容。
- en: Any of the `except`, `else`, and `finally` clauses can be omitted after a `try` block
    (although `else` by itself is invalid). If you include more than one, the `except` clauses
    must come first, then the `else` clause, with the `finally` clause at the end.
    You must be sure the order of the `except` clauses has classes that move from
    the most specific subclasses to most generic superclasses.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try`块之后，可以省略任何`except`、`else`和`finally`子句（尽管单独的`else`是无效的）。如果你包含多个子句，`except`子句必须首先出现，然后是`else`子句，最后是`finally`子句。你必须确保`except`子句的顺序是从最具体的子类到最通用的超类。
- en: The exception hierarchy
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常层次结构
- en: We've already seen several of the most common built-in exceptions, and you'll
    probably encounter the rest over the course of your regular Python development.
    As we noticed earlier, most exceptions are subclasses of the `Exception` class.
    But this is not true of all exceptions. The `Exception` class actually extends
    a class called `BaseException`. In fact, all exceptions must extend the `BaseException` class
    or one of its subclasses.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几个最常见的内置异常，你可能在日常的Python开发过程中会遇到其余的。正如我们之前注意到的，大多数异常都是`Exception`类的子类。但并非所有异常都如此。实际上，`Exception`类扩展了一个名为`BaseException`的类。实际上，所有异常都必须扩展`BaseException`类或其子类之一。
- en: There are two key built-in exception classes, `SystemExit` and `KeyboardInterrupt`,
    that derive directly from the `BaseException` class instead of the `Exception`
    class. The `SystemExit` exception is raised whenever the program exits naturally,
    typically because we called the `sys.exit()` function somewhere in our code (for
    example, when the user selected an exit menu item, clicked the Close button on
    a window, entered a command to shut down a server, or the OS sent a signal to
    the application to terminate). This exception is designed to allow us to clean
    up code before the program ultimately exits.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个关键的内置异常类，`SystemExit` 和 `KeyboardInterrupt`，它们直接从 `BaseException` 类派生，而不是从
    `Exception` 类派生。`SystemExit` 异常在程序自然退出时被抛出，通常是因为我们在代码的某个地方调用了 `sys.exit()` 函数（例如，当用户选择退出菜单项、点击窗口上的“关闭”按钮、输入命令关闭服务器，或者操作系统向应用程序发送信号以终止）。这个异常的设计目的是为了让我们在程序最终退出之前清理代码。
- en: If we do handle the `SystemExit` exception, we would normally re-raise the exception,
    since catching it could stop the program from exiting. Imagine a web service with
    a bug that is holding database locks and can't be stopped without rebooting the
    server.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理了`SystemExit`异常，我们通常会重新抛出异常，因为捕获它可能会阻止程序退出。想象一下一个存在bug的web服务，它正在锁定数据库，并且不重启服务器就无法停止。
- en: We don't want a `SystemExit` exception to be accidentally caught in generic
    `except Exception:` clauses. This is why it derives directly from `BaseException`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望`SystemExit`异常被意外地捕获在通用的`except Exception:`子句中。这就是为什么它直接从`BaseException`派生出来的原因。
- en: The `KeyboardInterrupt` exception is common in command-line programs. It is
    thrown when the user explicitly interrupts program execution with an OS-dependent
    key combination (normally, Ctrl + C). For Linux and macOS users, the `kill -2
    <pid>` command will also work. This is a standard way for the user to deliberately
    interrupt a running program and, like the `SystemExit` exception, it should almost
    always respond by terminating the program. Also, like `SystemExit`, it can handle
    any cleanup tasks inside the `finally` blocks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyboardInterrupt` 异常在命令行程序中很常见。当用户使用操作系统依赖的键组合（通常是 Ctrl + C）显式中断程序执行时，会抛出此异常。对于
    Linux 和 macOS 用户，`kill -2 <pid>` 命令也会生效。这是用户故意中断正在运行程序的标准方式，并且，像 `SystemExit`
    异常一样，它几乎总是通过终止程序来响应。此外，像 `SystemExit` 一样，它可以在 `finally` 块内处理任何清理任务。'
- en: 'Here is a class diagram that fully illustrates the hierarchy:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个完全展示层次的类图：
- en: '![Diagram  Description automatically generated](img/B17070_04_01.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_04_01.png)'
- en: 'Figure 4.1: Exception hierarchy'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：异常层次结构
- en: When we use the `except:` clause without specifying any type of exception, it
    will catch all subclasses of `BaseException`; which is to say, it will catch all
    exceptions, including the two special ones. Since we almost always want these
    to get special treatment, it is unwise to use the `except:` statement without
    arguments. If you want to catch all exceptions (other than `SystemExit` and `KeyboardInterrupt`),
    always explicitly catch `Exception`. Most Python developers assume that `except:` without
    a type is an error and will flag it in code review.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用不带指定异常类型的 `except:` 子句时，它将捕获 `BaseException` 的所有子类；也就是说，它将捕获所有异常，包括两个特殊的异常。由于我们几乎总是希望对这些异常进行特殊处理，因此在不带参数的情况下使用
    `except:` 语句是不明智的。如果你想要捕获所有异常（除了 `SystemExit` 和 `KeyboardInterrupt`），请始终显式捕获 `Exception`。大多数
    Python 开发者认为不带类型的 `except:` 是一个错误，并在代码审查中将其标记出来。
- en: Defining our own exceptions
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们自己的异常
- en: Occasionally, when we want to raise an exception, we find that none of the built-in
    exceptions are suitable. The distinction is often focused on how applications
    must handle the exception; when we introduce a new exception it must be because
    there will be distinct processing in a handler.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们想要抛出一个异常时，我们会发现内置的任何异常都不合适。区别通常集中在应用程序必须如何处理异常；当我们引入一个新的异常时，必须是因为在异常处理程序中会有不同的处理方式。
- en: There's no good reason to define an exception that's handled exactly like `ValueError`;
    we can use `ValueError`. Luckily, it's trivial to define new exceptions of our
    own. The name of the class is usually designed to communicate what went wrong,
    and we can provide arbitrary arguments in the initializer to include additional
    information.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 没有充分的理由去定义一个与`ValueError`处理方式完全相同的异常；我们可以直接使用`ValueError`。幸运的是，定义我们自己的新异常非常简单。类的名称通常被设计用来传达出了什么问题，我们可以在初始化器中提供任意的参数来包含额外的信息。
- en: All we have to do is inherit from the `Exception` class or one of the existing
    exceptions that's semantically similar. We don't even have to add any content
    to the class! We can, of course, extend `BaseException` directly, but this means
    we're inventing new ways of stopping a running program, a very unusual thing to
    be creating.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要从`Exception`类或其中一个语义上相似的现有异常类继承。我们甚至不需要向类中添加任何内容！当然，我们也可以直接扩展`BaseException`，但这意味着我们正在发明新的停止运行程序的方法，这是一个非常不寻常的事情去创造。
- en: 'Here''s a simple exception we might use in a banking application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个我们可能在银行应用程序中使用的简单异常：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `raise` statement illustrates how to raise the newly defined exception.
    We are able to pass an arbitrary number of arguments into the exception. Often
    a string message is used, but any object that might be useful in a later exception
    handler can be stored. The `Exception.__init__()` method is designed to accept
    any arguments and store them as a tuple in an attribute named `args`. This makes
    exceptions easier to define without needing to override `__init__()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise`语句说明了如何引发新定义的异常。我们能够向异常传递任意数量的参数。通常使用字符串消息，但任何可能在后续异常处理中有用的对象都可以存储。`Exception.__init__()`方法被设计为接受任何参数并将它们存储为一个名为`args`的属性中的元组。这使得定义异常变得更加容易，而无需覆盖`__init__()`方法。'
- en: 'Of course, if we do want to customize the initializer, we are free to do so.
    Here''s a revision to the above exception whose initializer accepts the current
    balance and the amount the user wants to withdraw. In addition, it adds a method
    to calculate how overdrawn the request is:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们确实想要自定义初始化器，我们完全可以这样做。以下是上述异常的修订版，其初始化器接受当前余额和用户想要取出的金额。此外，它还增加了一个方法来计算请求的超支程度：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since we're working with currency, we've imported the `Decimal` class of numbers.
    We can't use Python's default `int` or `float` types for money where there are
    a fixed number of decimal places and exquisitely complex rounding rules that assume
    exact decimal arithmetic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是货币，我们已经导入了数字的`Decimal`类。对于有固定小数位数和复杂四舍五入规则的货币，我们不能使用Python的默认`int`或`float`类型，因为这些类型假设了精确的小数运算。
- en: (Also note that the account number is not part of the exception. Bankers frown
    on using account numbers in a way that could expose them in a log or a traceback
    message.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: （同时请注意，账号号码不属于例外范围。银行家们对在日志或跟踪消息中可能暴露账号号码的使用方式表示不满。）
- en: 'Here''s an example of creating an instance of this exception:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个创建此异常实例的示例：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s how we would handle an `InvalidWithdrawal` exception if one was raised:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如有`InvalidWithdrawal`异常抛出，我们将这样处理：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we see a valid use of the `as` keyword to save the exception in a local
    variable, `ex`. By convention, most Python coders assign the exception a variable
    like `ex`, `exc`, or `exception`; although, as usual, you are free to call it `the_exception_raised_above`,
    or `aunt_sally` if you prefer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`as`关键字被有效用于将异常保存在局部变量`ex`中。按照惯例，大多数Python程序员会将异常赋值给变量如`ex`、`exc`或`exception`；尽管如此，通常情况下，你可以自由地将其命名为`the_exception_raised_above`，或者如果你愿意，可以叫它`aunt_sally`。
- en: 'There are many reasons for defining our own exceptions. It is often useful
    to add information to the exception or log it in some way. But the utility of
    custom exceptions truly comes to light when creating a framework, library, or
    API that is intended for access by other programmers. In that case, be careful
    to ensure your code is raising exceptions that make sense to the client programmer.
    Here are some criteria:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们自己的异常有很多原因。通常情况下，向异常中添加信息或以某种方式记录它是很有用的。但是，当创建一个旨在供其他程序员访问的框架、库或API时，自定义异常的实用性才能真正显现出来。在这种情况下，务必确保你的代码抛出的异常对客户端程序员来说是合理的。以下是一些标准：
- en: They should clearly describe what went on. The `KeyError` exception, for example,
    provides the key that could not be found.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们应该清楚地描述发生了什么。例如，`KeyError` 异常提供了找不到的键。
- en: The client programmer should easily see how to fix the error (if it reflects
    a bug in their code) or handle the exception (if it's a situation they need to
    be made aware of).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端程序员应该能够轻松地看到如何修复错误（如果它反映了他们代码中的错误）或处理异常（如果这是一个他们需要了解的情况）。
- en: The handling should be distinct from other exceptions. If the handling is the
    same as an existing exception, reusing the existing exception is best.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理方式应与其他异常区分开来。如果处理方式与现有异常相同，则重用现有异常为最佳选择。
- en: Now that we've looked at raising exceptions and defining new exceptions, we
    can look at some of the design considerations that surround exceptional data and
    responding to problems. There are a number of alternative design choices, and
    we'll start with the idea that exceptions, in Python, can be used for a number
    of things that aren't – strictly speaking – erroneous.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何抛出异常和定义新的异常，我们可以看看围绕异常数据和应对问题的一些设计考虑。存在许多不同的设计选择，我们将从这样一个观点开始，即在Python中，异常可以用于许多并非严格意义上的错误情况。
- en: Exceptions aren't exceptional
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常并不特殊
- en: 'Novice programmers tend to think of exceptions as only useful for exceptional
    circumstances. However, the definition of exceptional circumstances can be vague
    and subject to interpretation. Consider the following two functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 新手程序员往往认为异常情况仅适用于特殊情况。然而，特殊情况的定义可能模糊且具有主观性。考虑以下两个函数：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These two functions behave identically. If `divisor` is zero, an error message
    is printed; otherwise, a message printing the result of the division is displayed.
    We could avoid `ZeroDivisionError` ever being thrown by testing for it with an `if` statement.
    In this example, the test for a valid division is relatively simple-looking (`divisor
    == 0`). In some cases, it can be rather complex. In some cases, it may involve
    computing intermediate results. In the worst cases, the test for "will this work?"
    involves using a number of other methods of a class to – in effect – dry-run the
    operation to see if there would be an error along the way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的行为完全相同。如果`divisor`为零，则会打印错误信息；否则，会显示除法结果的打印信息。我们可以通过使用`if`语句来检查它，从而避免`ZeroDivisionError`异常被抛出。在这个例子中，对有效除法的检查看起来相对简单（`divisor
    == 0`）。在某些情况下，它可能相当复杂。在某些情况下，它可能涉及计算中间结果。在最坏的情况下，对“这会起作用吗？”的测试涉及到使用类中的多个其他方法——实际上——进行操作预演，以查看过程中是否会出现错误。
- en: Python programmers tend to follow a model summarized by "**It's Easier to Ask
    Forgiveness Than Permission**," sometimes abbreviated EAFP. The point is to execute
    code and then deal with anything that goes wrong. The alternative is described
    as "**Look Before You Leap**," often abbreviated LBYL. This is generally less
    popular. There are a few reasons for this, but the main one is that it shouldn't
    be necessary to burn CPU cycles looking for an unusual situation that is not going
    to arise in the normal path through the code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员倾向于遵循一个被总结为“**求原谅比求许可更容易**”的模式，有时简称为EAFP。其核心思想是先执行代码，然后处理可能出现的任何错误。另一种做法被描述为“**三思而后行**”，通常简称为LBYL。这通常不太受欢迎。原因有几个，但最主要的原因是，在代码的正常执行路径中，通常没有必要浪费CPU周期去寻找那些不太可能发生的不寻常情况。
- en: Therefore, it is wise to use exceptions for exceptional circumstances, even
    if those circumstances are only a little bit exceptional. Taking this argument
    further, exception syntax can be effective for flow control. Like an `if` statement,
    exceptions can be used for decision making, branching, and message passing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在特殊情况下使用异常是明智的，即使这些情况只是稍微有些特殊。进一步来说，异常语法在流程控制中可以非常有效。就像一个`if`语句一样，异常可以被用来进行决策、分支和消息传递。
- en: Imagine an inventory application for a company that sells widgets and gadgets.
    When a customer makes a purchase, the item can either be available, in which case
    the item is removed from inventory and the number of items left is returned, or
    it might be out of stock. Now, being out of stock is a perfectly normal thing
    to happen in an inventory application. It is certainly not an exceptional circumstance.
    But what do we return if it's out of stock? A string saying "out of stock"? A
    negative number? In both cases, the calling method would have to check whether
    the return value is a positive integer or something else, to determine if it is
    out of stock. That seems a bit messy, especially if we forget to do it somewhere
    in our code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一家销售小工具和配件的公司库存应用。当顾客进行购买时，该商品可以是可用的，在这种情况下，商品将从库存中移除，并返回剩余商品的数量，或者它可能已经缺货。现在，在库存应用中缺货是完全正常的事情发生。这绝对不是一种异常情况。但如果缺货了，我们应该返回什么？一条说“缺货”的字符串？一个负数？在这两种情况下，调用方法都必须检查返回值是正整数还是其他东西，以确定是否缺货。这看起来有点混乱，尤其是如果我们忘记在代码的某个地方做这件事的话。
- en: Instead, we can raise an `OutOfStock` exception and use the `try` statement
    to direct program flow control. Make sense? In addition, we want to make sure
    we don't sell the same item to two different customers, or sell an item that isn't
    in stock yet. One way to facilitate this is to lock each type of item to ensure
    only one person can update it at a time. The user must lock the item, manipulate
    the item (purchase, add stock, count items left...), and then unlock the item.
    (This is, in effect, a context manager, one subject of *Chapter 8*.)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以抛出一个 `OutOfStock` 异常，并使用 `try` 语句来控制程序流程。这说得通吗？此外，我们还想确保不会将同一件商品卖给两个不同的客户，或者出售尚未到货的商品。实现这一目标的一种方法是将每种类型的商品锁定，以确保一次只能有一个人更新它。用户必须锁定商品，操作商品（购买、增加库存、计算剩余数量...），然后解锁商品。（这实际上是一个上下文管理器，是
    *第8章* 的一个主题。）
- en: 'Here''s an incomplete `Inventory` example with docstrings that describes what
    some of the methods should do:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个带有文档字符串的、不完整的`库存`示例，它描述了某些方法应该执行的操作：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We could hand this object prototype to a developer and have them implement the
    methods to do exactly as they say while we work on the code needed to make a purchase.
    We'll use Python's robust exception handling to consider different branches, depending
    on how the purchase was made. We can even write a test case to be sure there's
    no question about how this class should work.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个对象原型交给开发者，并让他们实现所需的方法，确保它们按照所说的那样执行，同时我们专注于编写完成购买所需的代码。我们将利用Python强大的异常处理功能来考虑不同的分支，这取决于购买的方式。我们甚至可以编写一个测试用例，以确保对这个类应该如何工作没有任何疑问。
- en: 'Here''s a definition of `ItemType`, just to round out the example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`ItemType`的定义，只是为了完善这个例子：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here''s an interactive session using this `Inventory` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用这个`Inventory`类的交互会话：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All the possible exception handling clauses are used to ensure the correct actions
    happen at the correct time. Even though `OutOfStock` is not a terribly exceptional
    circumstance, we are able to use an exception to handle it suitably. This same
    code could be written with an `if...elif...else` structure, but it wouldn't be
    as easy to read or maintain.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可能的异常处理子句都被用来确保在正确的时间发生正确的操作。即使`OutOfStock`并不是一个特别异常的情况，我们仍然能够使用异常来适当地处理它。同样的代码也可以用`if...elif...else`结构来编写，但这样阅读和维护起来就不会那么容易。
- en: 'As an aside, one of the exception messages, `There are {num_left} {item_to_buy.name}s
    left`, suffers from a goofy English grammar problem. When there''s only one item
    left, it needs a major revision to `There is {num_left} {item_to_buy.name} left`.
    In order to support a sensible approach to translation, it''s best to avoid fiddling
    around with grammar details inside the f-string. It''s best to deal with it in
    the `else:` clause, using something like this to select the message with appropriate
    grammar:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个插曲，其中一条异常信息“`There are {num_left} {item_to_buy.name}s left`”存在一个蹩脚的英语语法问题。当只剩下一个物品时，它需要经过重大修改为“`There
    is {num_left} {item_to_buy.name} left`”。为了支持合理的翻译方法，最好避免在f-string内部篡改语法细节。最好在`else:`子句中处理它，使用类似以下的方法来选择合适的语法信息：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can also use exceptions to pass messages between different methods. For example,
    if we wanted to inform the customer as to what date the item is expected to be
    in stock again, we could ensure our `OutOfStock` object requires a `back_in_stock`
    parameter when it is constructed. Then, when we handle the exception, we can check
    that value and provide additional information to the customer. The information
    attached to the object can be easily passed between two different parts of the
    program. The exception could even provide a method that instructs the inventory
    object to reorder or backorder an item.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用异常在方法之间传递消息。例如，如果我们想通知客户商品预计何时再次有库存，我们可以在构造`OutOfStock`对象时确保它需要一个`back_in_stock`参数。然后，当我们处理异常时，我们可以检查该值并向客户提供额外信息。附加到对象的信息可以轻松地在程序的两个不同部分之间传递。异常甚至可以提供一个方法，指示库存对象重新订购或补货商品。
- en: Using exceptions for flow control can make for some handy program designs. The
    important thing to take from this discussion is that exceptions are not a bad
    thing that we should try to avoid. Having an exception occur does not mean that
    you should have prevented this exceptional circumstance from happening. Rather,
    it is just a powerful way to communicate information between two sections of code
    that may not be directly calling each other.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常进行流程控制可以设计出一些方便的程序。从这个讨论中，我们得到的重要一点是，异常并不是我们应该试图避免的坏事情。出现异常并不意味着你应该阻止这种特殊情况发生。相反，这只是在不同代码部分之间传递信息的一种强大方式，这些部分可能并没有直接相互调用。
- en: Case study
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'This chapter''s case study will look at some ways that we can find – and help
    the users fix – potential problems with the data or the application''s computations.
    Both the data and the processing are possible sources of exceptional behavior.
    They aren''t, however, equivalent; we can compare the two as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究将探讨一些我们可以找到并帮助用户修复数据或应用程序计算中潜在问题的方法。数据和处理都是异常行为可能的来源。然而，它们并不等价；我们可以如下比较这两个方面：
- en: Exceptional data is the most common source of problems. The data may not follow
    the syntax rules and have an invalid physical format. Other, more minor errors
    may stem from data not having a recognized logical organization, for example wrong
    spelling of column names. Exceptions can also reflect users attempting to perform
    an unauthorized operation. We need to alert users and administrators of invalid
    data or invalid operations.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常数据是问题最常见的原因。数据可能不遵循语法规则，或者具有无效的物理格式。其他更小的错误可能源于数据没有公认的逻辑组织，例如列名拼写错误。异常也可能反映用户试图执行未经授权的操作。我们需要提醒用户和管理员注意无效数据或无效操作。
- en: Exceptional processing is what is commonly called a **bug**. An application
    shouldn't try to recover from these problems. While we prefer to find them as
    part of unit or integration testing (see *Chapter 13*, *Testing Object-Oriented
    Programs*), it's possible that a problem escaped our scrutiny and wound up in
    production, and is exposed to the users of our software. We need to tell the users
    that something's broken and – as gracefully as possible – stop processing, or
    "crash." To continue in the presence of a bug is a serious breach of trust.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理通常被称为**错误**。应用程序不应该尝试从这些问题中恢复。虽然我们更喜欢在单元测试或集成测试中找到它们（参见*第13章*，*面向对象程序的测试*），但有可能一个问题逃过了我们的审查，最终在生产环境中出现，并暴露给了我们软件的用户。我们需要告诉用户有些东西出了问题，并且尽可能优雅地停止处理，或者“崩溃”。在有错误的情况下继续运行是一种严重的信任破坏。
- en: 'In our case study, we have three kinds of inputs that need to be examined for
    potential problems:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例研究中，我们需要检查三种类型的输入，以寻找潜在的问题：
- en: The known `Sample` instances, provided by a Botanist, and reflecting expert
    judgement. While this data should be exemplary in its quality, there's no guarantee
    that someone didn't accidentally rename a file and replace good data with something
    invalid or otherwise unprocessable.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由植物学家提供的已知`样本`实例，反映了专家判断。尽管这些数据在质量上应该是典范的，但无法保证没有人不小心重命名了一个文件，用无效数据或无法处理的数据替换了好的数据。
- en: The unknown `Sample` instances, provided by Researchers. These may have all
    kinds of data quality problems. We'll look at few of them.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由研究人员提供的未知`Sample`实例，这些可能存在各种数据质量问题。我们将查看其中的一些。
- en: Actions taken by a Researcher or a Botanist. We'll review the use cases to see
    what actions should be allowed by each class of user. In some cases, these problems
    are prevented by offering each class of user a focused menu of actions they can
    take.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 研究员或植物学家采取的行动。我们将审查使用案例，以确定每个用户类别应允许采取哪些行动。在某些情况下，通过为每个用户类别提供他们可以采取的特定操作菜单，可以预防这些问题。
- en: We'll start with a review of the use cases, so we can identify the kinds of
    exceptions that are required by this application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾使用案例，以便确定这个应用程序所需的异常类型。
- en: Context view
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文视图
- en: The role of "User" in the Context Diagram from *Chapter 1* is – at this point
    – less than ideal. It was tolerable as an initial description of the interfaces
    to the application. As we work through the design, we can see that a more specific
    term like "Researcher" might be a better description for someone researching a
    sample and looking for a classification.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章的上下文图中，“用户”这一角色的描述——目前来看——并不理想。作为对应用程序接口的初始描述，它是可以容忍的。随着我们逐步进行设计，我们可以看到，像“研究员”这样的更具体术语可能更适合描述那些研究样本并寻找分类的人。
- en: 'Here''s an expanded context diagram with a new consideration of users and their
    authorized actions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个考虑了用户及其授权操作的新扩展上下文图：
- en: '![Diagram  Description automatically generated](img/B17070_04_02.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_04_02.png)'
- en: 'Figure 4.2: Application context diagram'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：应用上下文图
- en: The Botanist is responsible for one kind of data, and has two valid operations.
    The Researcher is responsible for a different kind of data, and has only one valid
    operation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 植物学家负责一种类型的数据，并且有两个有效的操作。研究人员负责另一种类型的数据，并且只有一个有效的操作。
- en: The data and the processing use cases are intimately tied together. When a Botanist
    provides new training data or sets the parameters and tests the classifier, the
    application software must be sure their inputs are valid.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和处理用例紧密相连。当植物学家提供新的训练数据或设置参数并测试分类器时，应用程序软件必须确保他们的输入是有效的。
- en: Similarly, when a Researcher tries to classify a sample, the software must confirm
    that the data is valid and can be used. Invalid data must be reported to the Researcher
    so they can fix their inputs and try again.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，当研究员试图对样本进行分类时，软件必须确认数据是有效的并且可以使用的。无效数据必须报告给研究员，以便他们可以修复输入并再次尝试。
- en: 'We can decompose handling bad data into two parts, each of which is tackled
    separately:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将处理不良数据分解为两部分，每部分分别处理：
- en: Discovering exceptional data. As we've seen in this chapter, this is implemented
    as raising an exception when invalid data is encountered.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现异常数据。正如我们在本章所看到的，当遇到无效数据时，这通过抛出一个异常来实现。
- en: Responding to exceptional data. This is implemented as a `try:`/`except:` block
    that provides useful information on the nature of the problem and likely courses
    of action to resolve it.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应对异常数据。这通过一个`try:`/`except:`块实现，该块提供了关于问题性质和可能采取的解决措施的有用信息。
- en: We'll start with discovering the exceptional data, first. Raising the right
    exception is the foundation for handling bad data.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从发现异常数据开始。正确地抛出异常是处理不良数据的基础。
- en: Processing view
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理视图
- en: 'While there are a lot of data objects in this application, we''re going to
    narrow our focus to the `KnownSample` and `UnknownSample` classes. These two are
    related to a common superclass, the `Sample` class. These are created by two other
    classes. The following diagram shows where the `Sample` objects are created:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个应用程序中有许多数据对象，但我们将把我们的焦点缩小到`KnownSample`和`UnknownSample`类。这两个类与一个共同的超类`Sample`类相关。它们是由另外两个类创建的。以下图表显示了`Sample`对象是如何被创建的：
- en: '![Diagram  Description automatically generated](img/B17070_04_03.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_04_03.png)'
- en: 'Figure 4.3: Object creation'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：对象创建
- en: We've included two classes that will create these two kinds of samples. The `TrainingData` class
    will load known samples. An overall `ClassifierApp` class will validate an unknown
    sample, and attempt to classify it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了两个类来创建这两种类型的样本。`TrainingData`类将加载已知样本。一个整体的`ClassifierApp`类将验证未知样本，并尝试对其进行分类。
- en: 'A `KnownSample` object has five attributes, each of which has a narrowly-defined
    set of valid values:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`KnownSample`对象有五个属性，每个属性都有一个定义明确的有效值集合：
- en: The measurements, `sepal_length`, `sepal_width`, `petal_length`, `petal_width`,
    are all floating-point numbers. There's a lower-bound of zero for these values.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量值`花瓣长度`、`花瓣宽度`、`花瓣长度`、`花瓣宽度`都是浮点数。这些值的下限为零。
- en: The expert-supplied `species` value is a string, with three valid values.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专家提供的`species`值是一个字符串，有三个有效值。
- en: An `UnknownSample` object has only the four measurements. The idea of using
    a common superclass definition can help us ensure this validation processing is
    reused.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`UnknownSample`对象只有四个测量值。使用公共超类定义的想法可以帮助我们确保这种验证处理被重用。
- en: The rules for valid values listed above only define the valid values for each
    attribute considered in isolation. In some applications, there may be complex
    relationships among the attributes, or rules that define relationships among the
    samples. For our case study, we'll focus on the five attribute validation rules.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上列的有效值规则仅定义了在单独考虑每个属性时的有效值。在某些应用中，可能存在属性之间的复杂关系，或者定义样本之间关系的规则。对于我们的案例研究，我们将重点关注五个属性验证规则。
- en: What can go wrong?
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会出什么问题？
- en: It helps to consider what can go wrong when loading a `Sample` object, and what
    – if anything – the user can do about it. Our sample validation rules suggest
    we may want to raise specialized kinds of `ValueError` exceptions to describe
    data where the measurements aren't valid float values or the species name isn't
    one of the known strings.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到加载一个`Sample`对象时可能出现的错误，以及用户可以对此做些什么，这会有所帮助。我们的样本验证规则建议我们可能需要引发特殊的`ValueError`异常来描述那些测量值不是有效的浮点值或物种名称不是已知字符串的情况。
- en: 'We can use a class like the following to define the condition of bad data that
    can''t be processed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下类来定义无法处理的不良数据条件：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This lets us raise an `InvalidSampleError` exception for input data that this
    application can't process. The intent is to provide a message with the details
    of what needs to be repaired.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们为这个应用程序无法处理的输入数据抛出一个`InvalidSampleError`异常。目的是提供一个包含需要修复详情的消息。
- en: This can help us distinguish between bugs in our code, which may raise a `ValueError`
    exception, and correct behavior in the presence of bad data, where the `InvalidSampleError`
    exception will be raised. This means we need to be specific in our `except:` blocks,
    using the `InvalidSampleError` exception.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助我们区分代码中的错误，这些错误可能会引发一个`ValueError`异常，以及存在不良数据时出现的正确行为，此时将引发`InvalidSampleError`异常。这意味着我们需要在`except:`块中具体指定，使用`InvalidSampleError`异常。
- en: If we ever use `except ValueError:`, it will handle both generic exceptions
    as well as our unique exception. This means we might treat a more serious bug
    as invalid data. The trick is to be cautious handling generic exceptions; we may
    be working around a bug.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `except ValueError:`，它将处理通用异常以及我们独特的异常。这意味着我们可能会将更严重的错误视为无效数据。技巧是要小心处理通用异常；我们可能是在绕过一个错误。
- en: Bad behavior
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不良行为
- en: Earlier we suggested that a user might attempt an action which is invalid. For
    example, a Researcher might try to provide classified `KnownSample` objects. The
    action of loading new training data is reserved for the Botanist; this means an
    attempt by a Researcher should raise some kind of exception.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们建议用户可能会尝试执行一个无效的操作。例如，研究人员可能会尝试提供分类的`已知样本`对象。加载新的训练数据的行为保留给植物学家；这意味着研究人员的尝试应该引发某种类型的异常。
- en: Our application works in the context of the overall operating system. For command-line
    applications, we can partition users into two groups, and use the operating system
    file ownership and access permissions to limit which group can run which applications.
    This is an effective and comprehensive solution, and doesn't require any Python
    code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在整体操作系统的环境中运行。对于命令行应用程序，我们可以将用户分为两组，并使用操作系统的文件所有权和访问权限来限制哪一组可以运行哪些应用程序。这是一个有效且全面的解决方案，且不需要任何Python代码。
- en: For web-based applications, however, we need to authenticate each user to a
    web application. All of the web application frameworks for Python provide user
    authentication mechanisms. Many frameworks have handy plug-ins for systems like
    Open Authentication, OAuth. See [https://oauth.net/2/](https://oauth.net/2/) for
    more information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Web的应用程序，然而，我们需要对每个用户进行Web应用程序的认证。所有Python的Web应用程序框架都提供了用户认证机制。许多框架都提供了方便的插件，用于系统如开放认证、OAuth。更多信息请参阅[https://oauth.net/2/](https://oauth.net/2/)。
- en: 'For web applications, we generally have two tiers of processing:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用，我们通常有两层处理级别：
- en: '**Authentication** of the user. This is where a user identifies themselves.
    This might involve a single factor like a password, or multiple factors like a
    physical key or an interaction with a cell phone.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户认证**。这是用户进行身份识别的地方。这可能涉及单一因素，如密码，或者多个因素，如物理钥匙或与手机的交互。'
- en: '**Authorization** to perform some action. We''ll often define roles for the
    users, and limit access to various resources based on the user''s role. This means
    raising an exception when the user doesn''t have the appropriate role to access
    a resource.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**执行某些操作。我们通常会为用户定义角色，并根据用户的角色限制对各种资源的访问。这意味着当用户没有适当的角色来访问资源时，会引发一个异常。'
- en: Many web frameworks will use exceptions as an internal signal that something
    should not be allowed. This internal exception must then be mapped to external
    HTTP status codes, like a `401 Authorization Required` response.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web框架会将异常用作一个内部信号，表示某些操作不被允许。然后，这个内部异常必须映射到外部的HTTP状态码，例如`401授权所需`响应。
- en: This is a deep topic, outside the scope of this book. See, for example, *Building
    Web Applications with Flask* ([https://www.packtpub.com/product/building-web-applications-with-flask/9781784396152](https://www.packtpub.com/product/building-web-applications-with-flask/9781784396152))
    for an introduction to web applications.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个深入的话题，超出了本书的范围。例如，请参阅*使用Flask构建Web应用程序*([https://www.packtpub.com/product/building-web-applications-with-flask/9781784396152](https://www.packtpub.com/product/building-web-applications-with-flask/9781784396152))以了解Web应用程序的介绍。
- en: Creating samples from CSV files
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 CSV 文件创建样本
- en: Details of various options for reading samples in different file formats is
    something we need to defer to *Chapter 9*, *Strings, Serialization, and File Paths*,
    where we talk in detail about serialization techniques. For now, we'll skip a
    number of details and focus on an approach that works very nicely for CSV-formatted
    data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不同文件格式下读取样本的详细选项，我们需要参考*第9章*，*字符串、序列化和文件路径*，在那里我们详细讨论了序列化技术。目前，我们将跳过许多细节，并专注于一种非常适合CSV格式数据的处理方法。
- en: '**CSV** – **Comma-Separated Values** – can be used to define the rows of a
    spreadsheet. Within each row, the cell values are represented as text, separated
    by commas. When this data is parsed by Python''s `csv` module, each row can be
    represented by a dictionary where the keys are the column names and the values
    are the cell values from a particular row.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSV** – **逗号分隔值** – 可以用来定义电子表格的行。在每一行中，单元格值以文本形式表示，并用逗号分隔。当这些数据被 Python 的
    `csv` 模块解析时，每一行可以表示为一个字典，其中键是列名，值是特定行的单元格值。'
- en: 'For example, a row might look like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一行可能看起来像这样：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `csv` module's `DictReader` class provides an iterable sequence of `dict[str,
    str]` row instances. We need to transform these raw rows into instances of one
    of the subclasses of `Sample`, if all of the features have valid string values.
    If the raw data isn't valid, then we need to raise an exception.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv`模块的`DictReader`类提供了一系列的`dict[str, str]`类型的行实例。我们需要将这些原始行转换为`Sample`的一个子类的实例，如果所有特征都有有效的字符串值。如果原始数据无效，那么我们需要抛出一个异常。'
- en: 'Given rows like the example above, here''s a method that will translate from
    the dictionary to a more useful object. This is part of the `KnownSample` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如上例所示的行，这里有一个方法可以将字典翻译成更有用的对象。这是`KnownSample`类的一部分：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `from_dict()` method makes a check of the species value, raising an exception
    if it's not valid. It attempts to create a row, applying the `float()` function
    to convert various measurements from string values to float values. If the conversions
    all work, then the `cls` parameter – the class to create – will build the expected
    object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_dict()` 方法会检查物种值，如果无效则抛出异常。它尝试创建一行，应用 `float()` 函数将各种测量值从字符串值转换为浮点值。如果转换都成功，那么
    `cls` 参数——要创建的类——将构建预期的对象。'
- en: If any of the `float()` function evaluations encounters a problem, and raises
    a `ValueError` exception; this is used to create our application's unique `InvalidSampleError`
    exception.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`float()`函数的任何评估遇到问题并引发`ValueError`异常；这被用来创建我们应用程序的特定`InvalidSampleError`异常。
- en: This style of validation is a mixture of some **Look Before You Leap** (**LBYL**)
    and **Easier to Ask Forgiveness than Permission** (**EAFP**) styles. The most
    widely-used approach in Python is EAFP. In the case of the species value, however,
    there's no conversion function similar to `float()` to raise an exception or bad
    data. In this example, we've chosen to use LBYL for this attribute value. We'll
    look at an alternative below.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这种验证方式是**先观察再行动**（**LBYL**）和**求原谅比求许可更容易**（**EAFP**）两种风格的混合体。在Python中，最广泛使用的方法是EAFP。然而，对于物种值的情况，没有类似于`float()`的转换函数来引发异常或处理错误数据。在这个例子中，我们选择使用LBYL来处理这个属性值。下面我们将探讨一个替代方案。
- en: 'The `from_dict()` method is defined with the `@classmethod` decoration. This
    means the actual class object becomes the first parameter, `cls`. When we do this,
    it means any subclass that inherits this will have the method tailored for that
    subclass. We can create a new subclass, for example, `TrainingKnownSample`, using
    code like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_dict()` 方法使用 `@classmethod` 装饰器定义。这意味着实际的类对象成为第一个参数，`cls`。当我们这样做时，意味着任何继承这个方法的子类都将拥有针对该子类定制的功能。我们可以创建一个新的子类，例如，`TrainingKnownSample`，使用如下代码：'
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `TrainingKnownSample.from_dict()` method will be given the `TrainingKnownSample`
    class as the `cls` parameter value; without any other code, the `from_dict()`
    method of this class will build instances of the `TrainingKnownSample` class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrainingKnownSample.from_dict()` 方法将接受 `TrainingKnownSample` 类作为 `cls` 参数的值；在不添加任何其他代码的情况下，这个类的
    `from_dict()` 方法将构建 `TrainingKnownSample` 类的实例。'
- en: 'While this works nicely, it''s not clear to **mypy** that it works. We can
    use the following definition to provide an explicit type mapping:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做效果不错，但对**mypy**来说并不明确它是否有效。我们可以使用以下定义来提供显式的类型映射：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: An alternative is to use the simpler class definition and put the `cast()` operation
    in the places where `from_dict()` is actually used, for example, `cast(TrainingKnownSample,
    TrainingKnownSample.from_dict(data))`. Since this method is not used in very many
    places, it's difficult to assert which variation is simpler.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用更简单的类定义，并将`cast()`操作放在实际使用`from_dict()`的地方，例如，`cast(TrainingKnownSample,
    TrainingKnownSample.from_dict(data))`。由于这种方法在许多地方都没有使用，因此很难断言哪种变体更简单。
- en: 'Here''s the rest of the `KnownSample` class, repeated from the previous chapter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自上一章的`KnownSample`类的其余部分，重复如下：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s see how this works in practice. Here''s an example of loading some valid
    data:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实际中是如何工作的。以下是一个加载一些有效数据的示例：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We created the dictionary, `valid`, that a `csv.DictReader` would create from
    a line of input. Then, we built a `TrainingKnownSample` instance, `rks`, from
    this dictionary. The resulting object has proper floating-point values, showing
    that conversions from strings have been performed as needed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `valid` 的字典，这是一个 `csv.DictReader` 从输入行创建的。然后，我们从该字典构建了一个 `TrainingKnownSample`
    实例，命名为 `rks`。生成的对象具有适当的浮点数值，表明已按需执行了字符串到数值的转换。
- en: 'Here''s how the validation behaves. This is an example of the kind of exception
    raised for bad data:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了验证的行为。这是一个为不良数据引发的异常类型的示例：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When we tried to create a `TestingKnownSample` instance, the invalid species
    value raised an exception.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试创建一个`TestingKnownSample`实例时，无效的物种值引发了一个异常。
- en: Have we spotted all potential problems? The `csv` module handles the physical
    format issues, so providing a PDF file, for example, will lead to exceptions being
    raised by the `csv` module. Invalid species names and float values are checked
    in the `from_dict()` method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否已经发现了所有潜在的问题？`csv`模块处理物理格式问题，因此提供PDF文件等，将导致`csv`模块抛出异常。在`from_dict()`方法中会检查无效的物种名称和浮点值。
- en: 'There are some things we did not check. Here are some additional validations:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有些事情我们没有检查。以下是额外的验证：
- en: Missing keys. If a key is spelled incorrectly, this code will raise a `KeyError` exception,
    which would not be restated as an `InvalidSampleError` exception. This change
    is left as an exercise for the reader.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少的键。如果一个键拼写错误，此代码将引发一个`KeyError`异常，它不会被重新表述为`InvalidSampleError`异常。这个变化留给读者作为练习。
- en: Extra keys. If there are unexpected columns, is the data invalid, or do we ignore
    this? It may be that we're given data from a spreadsheet with extra columns that
    should be ignored. While it's helpful to be flexible, it's also important to expose
    potential problems with the input.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外键。如果出现意外的列，数据是否无效，或者我们应该忽略它们？可能的情况是，我们得到了包含额外列的电子表格数据，这些列应该被忽略。虽然灵活性是有帮助的，但同时也非常重要，要揭示输入中可能存在的问题。
- en: Out-of-range float values. There are likely some sensible upper and lower bounds
    on the range of measurements. The lower bound of zero, seems clear; negative measurements
    don't make much sense. The upper bound, however, isn't as clear. There are some
    statistical techniques for locating outliers, including the **Median Absolute
    Deviation** (**MAD**) technique.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出范围的浮点值。测量范围很可能存在一些合理的上下限。下限为零是显然的；负数测量没有太多意义。然而，上限并不那么明确。有一些统计技术用于定位异常值，包括**中值绝对偏差**（**MAD**）技术。
- en: See [https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm)
    for more information on how to spot data that doesn't seem to fit a normal distribution.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查阅[https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm)获取更多关于如何识别似乎不符合正态分布的数据的信息。
- en: The first of these additional checks can be added to the `from_dict()` method.
    The second is a decision that must be reached with the users, and then potentially
    added to the `from_dict()` method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外检查中的第一个可以添加到`from_dict()`方法中。第二个则是一个必须与用户达成一致的决策，然后可能添加到`from_dict()`方法中。
- en: 'The outlier detection is more sophisticated. We need to perform this check
    after all the testing and training samples have been loaded. Because the outlier
    check doesn''t apply to a single row, it needs a different exception. We might
    define another exception like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值检测更为复杂。我们需要在所有测试和训练样本加载完毕后执行此检查。因为异常值检查不适用于单行，它需要一个不同的异常处理。我们可能定义另一个异常，如下所示：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This exception can be used with a simple range check, or the more sophisticated
    MAD method for outlier detection.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常可以使用简单的范围检查，或者更复杂的MAD方法来检测异常值。
- en: Validating enumerated values
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证枚举值
- en: The list of valid species isn't very visible. We've essentially buried it inside
    the `from_dict()` method, which may become a maintenance problem. When the source
    data changes, we need to also update this method, something that can be hard to
    remember and almost as hard to find. If the list of species becomes long, the lines
    of code could become hard to read.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的物种列表并不十分明显。我们基本上将它隐藏在了`from_dict()`方法中，这可能会成为一个维护问题。当源数据发生变化时，我们还需要更新这个方法，这可能会很难记住，而且几乎和找到它一样困难。如果物种列表变得很长，代码行可能会变得难以阅读。
- en: 'Using an explicit `enum` class with the list of valid values is a way to convert
    this to purely EAFP processing. Consider using the following to validate species.
    Doing this means redefining a number of classes:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有有效值列表的显式`enum`类是将此转换为纯EAFP处理的一种方法。考虑使用以下方式来验证物种。这样做意味着重新定义多个类：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we apply the `enum` class name, `Species`, to one of the enumerated literal
    values, it will raise a `ValueError` exception to show the string representation
    of the species is invalid. This parallels the way `float()` and `int()` raise `ValueError` exceptions
    for a string that's not a valid number.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`enum`类名称`Species`应用于枚举字面值之一时，它将引发一个`ValueError`异常来显示物种的字符串表示形式无效。这类似于`float()`和`int()`对于不是有效数字的字符串引发`ValueError`异常的方式。
- en: Switching to enumerated values would also require changes to the class definition
    for a known sample. The class needs to be modified to use the enumeration, `Species`,
    instead of `str`. For this case study, the list of values is small, and an `Enum`
    seems practical. For other problem domains, however, the enumerated list of values
    could be quite large and an `Enum` class might be long and uninformative.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将值切换为枚举值也将需要修改已知样本的类定义。类需要修改为使用枚举`Species`而不是`str`。对于这个案例研究，值列表很小，使用`Enum`似乎很实用。然而，对于其他问题域，值的枚举列表可能相当大，并且`Enum`类可能很长且信息量不足。
- en: 'Instead of an `Enum` class, we might continue to use string objects. We can
    define each unique domain of string values as an extension to a `Set[str]` class:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能继续使用字符串对象而不是`Enum`类。我们可以将每个唯一的字符串值域定义为`Set[str]`类的扩展：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can use the `species.validate()` function similar to the way we used the
    `float()` function. This will validate the string, without coercing it to a different
    value. Instead, it returns the string. For invalid values, it raises a `ValueError` exception.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `species.validate()` 函数，类似于我们使用 `float()` 函数的方式。这将验证字符串，而不会将其强制转换为不同的值。相反，它返回字符串。对于无效值，它将引发一个
    `ValueError` 异常。
- en: 'This lets us rewrite the body of the `from_dict()` method as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够将`from_dict()`方法的主体重写如下：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This variation relies on the global `species` to be a set of valid species.
    It also uses a pleasantly consistent EAFP approach to building the required object
    or raising an exception.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化依赖于全局的`species`是一个有效的物种集合。它还使用了一种令人愉悦的EAFP方法来构建所需的对象或引发异常。
- en: As we mentioned earlier, there are two parts to this design. We've looked at
    the foundational element, raising an appropriate exception. Now we can look at
    the context in which we use this `from_dict()` function, and how errors get reported
    to users.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这个设计分为两部分。我们已经探讨了基础元素，即抛出一个合适的异常。现在我们可以看看我们使用这个`from_dict()`函数的上下文，以及错误是如何报告给用户的。
- en: Reading CSV files
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取 CSV 文件
- en: 'We''ll provide a common template for creating objects from CSV source data.
    The idea is to leverage the `from_dict()` methods of the various classes to create
    the objects our application uses:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一个通用的模板，用于从CSV源数据创建对象。其思路是利用各种类的`from_dict()`方法来创建应用程序所使用的对象：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `load()` method is partitioning the samples into testing and training subsets.
    It expects an iterable source of `dict[str, str]` objects, which are produced
    by a `csv.DictReader` object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`方法正在将样本划分为测试集和训练集。它期望一个可迭代的`dict[str, str]`对象源，这些对象由`csv.DictReader`对象生成。'
- en: 'The user experience implemented here is to report the first failure and return.
    This might lead to an error message like the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里实现的用户体验是报告第一次失败并返回。这可能会导致如下错误信息：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This message has all the required information, but may not be as helpful as
    desired. We might, for example, want to report *all* failures, instead of the
    first failure. Here''s how we might restructure the `load()` method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息包含了所有必要的信息，但可能不如期望的那样有帮助。例如，我们可能希望报告**所有**失败，而不仅仅是第一次失败。以下是我们可以如何重构`load()`方法的示例：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This variation would catch each `InvalidSampleError` error, displaying a message
    and counting the number of problems. This information might be more helpful because
    the user could then correct all of the rows which are invalid.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化会捕获每个`InvalidSampleError`错误，显示一条消息并计算问题数量。这些信息可能更有帮助，因为用户可以纠正所有无效的行。
- en: In the case of a very, very large set of data, this may lead to a useless level
    of detail. If we accidentally used a CSV file with several hundred thousand rows
    of images of hand-written numbers, for example, instead of Iris data, we'd get
    several hundred thousand messages telling us each individual row was bad.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理一个非常、非常大的数据集的情况下，这可能会导致无用细节达到一个很高的水平。如果我们不小心使用了一个包含几十万行手写数字图像的CSV文件，而不是鸢尾花数据，那么我们会收到几十万条消息，告诉我们每一行都是错误的。
- en: Some additional user experience design is required around this loading operation,
    to make it useful in a wide variety of situations. The foundation, however, is
    the Python exception that's raised when something's not right. In this case study,
    we leveraged the `float()` function's `ValueError` and rewrote it to be our application's
    unique `InvalidSampleError` exception. We also created our own `ValueError` exceptions
    for unexpected strings.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个加载操作周围需要一些额外的用户体验设计，以便使其在各种情况下都非常有用。然而，其基础是当出现问题时引发的 Python 异常。在本案例研究中，我们利用了
    `float()` 函数的 `ValueError` 并将其重写为我们的应用程序特有的 `InvalidSampleError` 异常。我们还创建了针对意外字符串的我们自己的
    `ValueError` 异常。
- en: Don't repeat yourself
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复自己
- en: The `load()` method of `TrainingData` will create two different subclasses of
    `KnownSample`. We've put most of the processing into the `KnownSample` superclass;
    this avoids repeating the validation processing in each subclass.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrainingData` 的 `load()` 方法将创建两个不同的 `KnownSample` 子类。我们将大部分处理工作放在了 `KnownSample`
    超类中；这样做可以避免在每个子类中重复进行验证处理。'
- en: 'For an `UnknownSample`, however, we have a tiny problem: there''s no species
    data in an `UnknownSample`. It would be ideal to extract the validation of the
    four measurements, and keep them separate from validating the species. If we do
    this, we can''t trivially combine building a `Sample` with doing the validation
    in one simple EAFP kind of method that either creates the desired object or raises
    an exception that it can''t be built.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个`UnknownSample`，然而，我们遇到了一个小问题：在`UnknownSample`中没有物种数据。理想的情况是提取四个测量的验证，并将它们与验证物种分开。如果我们这样做，我们就不能简单地通过一个简单的EAFP方法来同时构建一个`Sample`和进行验证，这个方法要么创建所需的对象，要么抛出一个无法构建的异常。
- en: 'When a subclass introduces new fields, we have two choices:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类引入新字段时，我们有两种选择：
- en: 'Abandon simple-looking EAFP validation. In this case, we would need to separate
    validation from object construction. This will lead to the cost of doing `float()`
    conversions twice: once to validate the data and again to create the target object.
    Multiple `float()` conversions means we haven''t really followed the **Don''t
    Repeat Yourself** (**DRY**) principle.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放弃看似简单的 EAFP 验证。在这种情况下，我们需要将验证与对象构造分离。这将导致进行两次 `float()` 转换的成本：一次用于验证数据，另一次用于创建目标对象。多次
    `float()` 转换意味着我们并没有真正遵循**不要重复自己**（**DRY**）的原则。
- en: Build an intermediate representation that can be used by subclasses. This means
    the two `KnownSample` subclass of `Sample` would involve three steps. First, build
    a `Sample` object, validating the four measurements. Then, validate the species.
    Finally, build the `KnownSample` using the valid fields from the `Sample` object
    and the valid species value. This creates a temporary object, but avoids repeating
    any code.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个中间表示，该表示可以被子类使用。这意味着`Sample`的`KnownSample`子类将涉及三个步骤。首先，构建一个`Sample`对象，验证四个测量值。然后，验证物种。最后，使用从`Sample`对象中获取的有效字段和有效的物种值来构建`KnownSample`。这创建了一个临时对象，但避免了代码的重复。
- en: We'll leave the implementation details as an exercise for the reader.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把实现细节留给读者作为练习。
- en: Once the exception is defined, we also need to display the results to the user
    in a form that guides them to a the right remedial action. This is a separate
    user experience design consideration that is built on the foundation of the underlying
    exception.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了异常，我们还需要以引导用户采取正确补救措施的形式向用户展示结果。这是基于底层异常构建的独立用户体验设计考虑因素。
- en: Recall
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆
- en: 'Some key points in this chapter:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键点：
- en: Raising an exception happens when something goes wrong. We looked at division
    by zero as an example. Exceptions can also be raised with the `raise` statement.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常发生在出现错误时。我们以除以零为例进行了说明。也可以使用`raise`语句来抛出异常。
- en: The effects of an exception are to interrupt the normal sequential execution
    of statements. It saves us from having to write a lot of `if` statements to check
    to see if things can possibly work or check to see if something actually failed.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常的效果是中断语句的正常顺序执行。它使我们免于编写大量的`if`语句来检查事情是否可能工作，或者检查是否真的失败了。
- en: Handling exceptions is done with the `try:` statement, which has an `except:`
    clause for each kind of exception we want to handle.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常是通过`try:`语句完成的，该语句为每种我们想要处理的异常都有一个`except:`子句。
- en: The exception hierarchy follows object-oriented design patterns to define a
    number of subclasses of the `Exception` class we can work with. Some additional
    exceptions, `SystemExit` and `KeyboardInterrupt`, are not subclasses of the `Exception`
    class; handling these introduces risks and doesn't solve very many problems, so
    we generally ignore them.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常层次结构遵循面向对象设计模式来定义我们可以与之工作的`Exception`类的多个子类。一些额外的异常，如`SystemExit`和`KeyboardInterrupt`，并不是`Exception`类的子类；处理这些异常会引入风险，并且并不能解决很多问题，所以我们通常忽略它们。
- en: Defining our own exceptions is a matter of extending the `Exception` class.
    This makes it possible to define exceptions with very specific semantics.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们自己的异常是扩展`Exception`类的问题。这使得我们可以定义具有非常特定语义的异常。
- en: Exercises
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you've never dealt with exceptions before, the first thing you need to do
    is look at any old Python code you've written and notice if there are places you
    should have been handling exceptions. How would you handle them? Do you need to
    handle them at all? Sometimes, letting the exception propagate to the console
    is the best way to communicate to the user, especially if the user is also the
    script's coder. Sometimes, you can recover from the error and allow the program
    to continue. Sometimes, you can only reformat the error into something the user
    can understand and display it to them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未处理过异常，首先你需要查看你之前写的任何Python代码，注意是否有应该处理异常的地方。你会如何处理它们？你是否需要处理它们？有时，让异常传播到控制台是向用户传达信息的最有效方式，尤其是如果用户也是脚本的编写者。有时，你可以从错误中恢复，并允许程序继续运行。有时，你只能将错误重新格式化为用户可以理解的形式，并将其显示给他们。
- en: Some common places to look are file I/O (is it possible your code will try to
    read a file that doesn't exist?), mathematical expressions (is it possible that
    a value you are dividing by is zero?), list indices (is the list empty?), and
    dictionaries (does the key exist?).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的检查点包括文件输入输出（你的代码是否尝试读取一个不存在的文件？），数学表达式（你正在除的值是否为零？），列表索引（列表是否为空？），以及字典（键是否存在？）。
- en: Ask yourself whether you should ignore the problem, handle it by checking values
    first, or handle it with an exception. Pay special attention to areas where you
    might have used `finally` and `else` to ensure the correct code is executed under
    all conditions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 问问自己是否应该忽略这个问题，先检查值来处理它，还是通过异常来处理它。特别注意那些你可能使用了`finally`和`else`的地方，以确保在所有条件下都能执行正确的代码。
- en: Now write some new code, extending the case study to cover any additional validation
    checks for the input data. For example, we need to check the measurements to be
    sure they're in a sensible range. This can be an additional subclass of `ValueError`.
    We can apply the concept to other parts of the case study. For example, we might
    want to validate `Sample` objects to be sure the values are all positive numbers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写一些新的代码，将案例研究扩展到涵盖对输入数据的任何额外验证检查。例如，我们需要检查测量值以确保它们在合理的范围内。这可以是一个额外的`ValueError`子类。我们可以将这个概念应用到案例研究的其他部分。例如，我们可能想要验证`Sample`对象以确保所有值都是正数。
- en: The case study doesn't do any range checking in the `from_dict()` method. Checking
    the lower bound of zero is easy, and it would be good to add this as the first
    exercise.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究在`from_dict()`方法中没有进行任何范围检查。检查零的下界很容易，最好将其作为第一个练习添加。
- en: For setting an upper bound on the various measurements, it's important to know
    the data. First, it's helpful to survey the data and find the actual minimum,
    maximum, median, and the absolute deviations from the median. Given this summary
    information, a sensible set of limits can be defined and range checks added.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对各种测量结果设定上限，了解数据非常重要。首先，对数据进行调查并找出实际的最小值、最大值、中位数以及与中位数的绝对偏差是有帮助的。有了这些汇总信息，就可以定义一个合理的范围，并添加范围检查。
- en: 'We haven''t addressed creating `UnknownSample` instances, leaving the `from_dict()`
    method as an exercise for the reader. In the *Don''t repeat yourself* section,
    above, we described an implementation where validating the four measurements in
    the `from_dict()` processing is refactored into the Sample class. This leads to
    two design changes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未解决创建`UnknownSample`实例的问题，将`from_dict()`方法留作读者的练习。在上面的*不要重复自己*部分，我们描述了一个实现，其中在`from_dict()`处理中对四个测量值的验证被重构到Sample类中。这导致了两个设计变更：
- en: In `KnownSample`, use the `Sample.from_dict()` to validate the measurements,
    validate species, and build the final `KnownSample` object.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `KnownSample` 中，使用 `Sample.from_dict()` 来验证测量结果、验证物种，并构建最终的 `KnownSample`
    对象。
- en: In `UnknownSample`, use the `Sample.from_dict()` to validate the measurements,
    then build the final `UnknownSample` object.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `UnknownSample` 中，使用 `Sample.from_dict()` 验证测量结果，然后构建最终的 `UnknownSample` 对象。
- en: These changes should lead to a reasonably flexible data validation that doesn't
    involve copying and pasting the validation rules for measurements or species.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改应导致一个相对灵活的数据验证，不需要复制和粘贴测量或物种的验证规则。
- en: Finally, try to think of places in your code where you can raise exceptions.
    It can be in code you've written or are working on, or you can write a new project
    as an exercise. You'll probably have the best luck designing a small framework
    or API that is meant to be used by other people; exceptions are a terrific communication
    tool between your code and someone else's. Remember to design and document any
    self-raised exceptions as part of the API, or they won't know whether or how to
    handle them!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试思考一下在你的代码中可以抛出异常的地方。这可能是在你编写或正在工作的代码中，或者你可以作为一个练习写一个新的项目。你可能最有可能成功设计一个旨在供他人使用的简单框架或API；异常是你代码与他人的代码之间一个极好的沟通工具。记住，要将任何自抛出的异常的设计和文档作为API的一部分，否则他们可能不知道如何处理它们！
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went into the gritty details of raising, handling, defining,
    and manipulating exceptions. Exceptions are a powerful way to communicate unusual
    circumstances or error conditions without requiring a calling function to explicitly
    check return values. There are many built-in exceptions and raising them is trivially
    easy. There are several different syntaxes for handling different exception events.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了异常的创建、处理、定义和操作等细节。异常是一种强大的方式，可以在不要求调用函数显式检查返回值的情况下，传达异常情况或错误条件。存在许多内置的异常，抛出它们非常简单。处理不同的异常事件有不同的语法。
- en: In the next chapter, everything we've studied so far will come together as we
    discuss how object-oriented programming principles and structures should best
    be applied in Python applications.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把迄今为止所学的所有内容结合起来，讨论如何在Python应用程序中最佳地应用面向对象编程的原则和结构。
