- en: Chapter 4. Working with Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。处理集合
- en: Python offers a number of functions that process whole collections. They can
    be applied to sequences (lists or tuples), sets, mappings, and iterable results
    of generator expressions. We'll look at some of Python's collection-processing
    functions from a functional programming viewpoint.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了许多处理整个集合的函数。它们可以应用于序列（列表或元组）、集合、映射和生成器表达式的可迭代结果。我们将从函数式编程的角度看一些Python的集合处理函数。
- en: We'll start out by looking at iterables and some simple functions that work
    with iterables. We'll look at some additional design patterns to handle iterables
    and sequences with recursion as well as explicit `for` loops. We'll look at how
    we can apply a `scalar()` function to a collection of data with a generator expression.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一下可迭代对象和一些与可迭代对象一起工作的简单函数。我们将看一些额外的设计模式来处理可迭代对象和递归序列，以及显式的`for`循环。我们将看一下如何使用生成器表达式将`scalar()`函数应用于数据集合。
- en: 'In this chapter, we''ll show examples of how to use the following functions
    to work with collections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示如何使用以下函数来处理集合的示例：
- en: '`any()` and `all()`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any()`和`all()`'
- en: '`len()` and `sum()` and some higher-order statistical processing related to
    these functions'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len()`和`sum()`以及与这些函数相关的一些高阶统计处理'
- en: '`zip()` and some related techniques to structure and flatten lists of data'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip()`和一些相关的技术来构造和展平数据列表'
- en: '`reversed()`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reversed()`'
- en: '`enumerate()`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate()`'
- en: The first four functions can all be called reductions; they reduce a collection
    to a single value. The other three functions (`zip()`, `reversed()`, and `enumerate()`)
    are mappings; they produce a new collection from an existing collection(s). In
    the next chapter, we'll look at some `mapping()` and `reduction()` functions that
    use an additional function as an argument to customize their processing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个函数都可以称为缩减函数；它们将集合减少为单个值。另外三个函数（`zip()`、`reversed()`和`enumerate()`）是映射函数；它们从现有集合中产生一个新的集合。在下一章中，我们将看一些使用额外函数作为参数来定制其处理的`mapping()`和`reduction()`函数。
- en: In this chapter, we'll start out by looking at ways to process data using generator
    expressions. Then, we'll apply different kinds of collection-level functions to
    show how they can simplify the syntax of iterative processing. We'll also look
    at some different ways of restructuring data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先看一下使用生成器表达式处理数据的方法。然后，我们将应用不同类型的集合级函数，以展示它们如何简化迭代处理的语法。我们还将看一些不同的数据重构方式。
- en: In the next chapter, we'll focus on using higher-order collection functions
    to do similar kinds of processing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于使用高阶集合函数来进行类似的处理。
- en: An overview of function varieties
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数种类概述
- en: 'We need to distinguish between two broad species of functions, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要区分以下两种广义函数：
- en: Scalar functions apply to individual values and compute an individual result.
    Functions such as `abs()`, `pow(),` and the entire `math` module are examples
    of scalar functions.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量函数适用于单个值，并计算单个结果。`abs()`、`pow()`和整个`math`模块都是标量函数的例子。
- en: '`Collection()` functions work with iterable collections.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection()`函数与可迭代集合一起工作。'
- en: 'We can further subdivide the collection functions into three subspecies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步将集合函数细分为三个亚种：
- en: '**Reduction**: This uses a function that is used to fold values in the collection
    together, resulting in a single final value. We can call this an aggregate function,
    as it produces a single aggregate value for an input collection.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩减**：这使用一个函数来将集合中的值合并在一起，产生一个最终的单一值。我们可以称之为聚合函数，因为它为输入集合产生一个单一的聚合值。'
- en: '**Mapping**: This applies a function to all items of a collection; the result
    is a collection of the same size.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：这将一个函数应用于集合的所有项目；结果是相同大小的集合。'
- en: '**Filter**: This applies a function to all items of a collection that rejects
    some items and passes others. The result is a subset of the input. A filter might
    do nothing, which means that the output matches the input; this is an improper
    subset, but it still fits the broader definition of subset.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：这将一个函数应用于集合的所有项目，拒绝一些项目并通过其他项目。结果是输入的子集。过滤器可能什么也不做，这意味着输出与输入匹配；这是一个不恰当的子集，但它仍然符合子集的更广泛定义。'
- en: We'll use this conceptual framework to characterize ways in which we use the
    built-in collection functions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个概念框架来描述我们使用内置集合函数的方式。
- en: Working with iterables
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可迭代对象
- en: As we noted in the previous chapters, we'll often use Python's `for` loop to
    work with collections. When working with materialized collections such as tuples,
    lists, maps, and sets, the `for` loop involves an explicit management of state.
    While this strays from purely functional programming, it reflects a necessary
    optimization for Python. If we assure that state management is localized to an
    iterator object that's created as part of the `for` statement evaluation, we can
    leverage this feature without straying too far from pure, functional programming.
    For example, if we use the `for` loop variable outside the indented body of `loop`,
    we've strayed too far from purely functional programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中所指出的，我们经常使用Python的`for`循环来处理集合。当处理元素化的集合（如元组、列表、映射和集合）时，`for`循环涉及对状态的显式管理。虽然这偏离了纯函数式编程，但它反映了Python的必要优化。如果我们确保状态管理局限于作为`for`语句评估的一部分创建的迭代器对象，我们就可以利用这个特性，而不会偏离纯粹的函数式编程太远。例如，如果我们在缩进的`loop`体之外使用`for`循环变量，我们就偏离了纯粹的函数式编程。
- en: We'll return to this in [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"),
    *Recursion and Reduction*. It's an important topic, and we'll just scratch the
    surface here with a quick example of working with generators.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](ch06.html "第6章。递归和缩减")*递归和缩减*中回顾这一点。这是一个重要的话题，我们在这里只是简单地用一个快速的例子来介绍与生成器一起工作。
- en: One common application of `for` loop iterable processing is the `unwrap(process(wrap(iterable)))`
    design pattern. A `wrap()` function will first transform each item of an iterable
    into a two tuples with a derived sort key or other value and then the original
    immutable item. We can then process these two tuples based on the wrapped value.
    Finally, we'll use an `unwrap()` function to discard the value used to wrap, which
    recovers the original item.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环可迭代处理的一个常见应用是`unwrap(process(wrap(iterable)))`设计模式。`wrap()`函数首先将可迭代对象的每个项转换为一个带有派生排序键或其他值的两个元组，然后是原始的不可变项。然后我们可以根据包装值处理这两个元组。最后，我们将使用`unwrap()`函数丢弃用于包装的值，恢复原始项。'
- en: 'This happens so often in a functional context that we have two functions that
    are used heavily for this; they are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这在功能上经常发生，我们有两个函数经常用于此目的; 它们如下：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These two functions pick the first and second values from a tuple, and both
    are handy for the `process()` and `unwrap()` functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数从元组中选择第一个和第二个值，对于`process()`和`unwrap()`函数都很方便。
- en: Another common pattern is `wrap(wrap(wrap()))`. In this case, we're starting
    with simple tuples and then wrapping them with additional results to build up
    larger and more complex tuples. A common variation on this theme is `extend(extend(extend()))`
    where the additional values build new, more complex `namedtuple` instances without
    actually wrapping the original tuples. We can summarize both of these as the Accretion
    design pattern.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的模式是`wrap(wrap(wrap()))`。在这种情况下，我们从简单的元组开始，然后用额外的结果包装它们，以构建更大更复杂的元组。这个主题的一个常见变体是`extend(extend(extend()))`，其中额外的值构建新的更复杂的`namedtuple`实例，而不实际包装原始元组。我们可以将这两者总结为Accretion设计模式。
- en: We'll apply the Accretion design to work with a simple sequence of latitude
    and longitude values. The first step will convert the simple points (`lat`, `lon`)
    on a path into pairs of legs (`begin`, `end`). Each pair in the result will be
    ((`lat`, `lon`), (`lat`, `lon`)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用Accretion设计来处理一系列简单的纬度和经度值。第一步将简单的路径上的点(`lat`, `lon`)转换为腿(`begin`, `end`)的对。结果中的每对将是((`lat`,
    `lon`), (`lat`, `lon`))。
- en: In the next sections, we'll show how to create a generator function that will
    iterate over the content of a file. This iterable will contain the raw input data
    that we will process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将展示如何创建一个生成器函数，它将迭代文件的内容。这个可迭代对象将包含我们将处理的原始输入数据。
- en: 'Once we have the data, later sections will show how to decorate each leg with
    the **haversine** distance along the leg. The final result of the `wrap(wrap(iterable())))`
    processing will be a sequence of three tuples: ((`lat`, `lon`), (`lat`, `lon`),
    `distance`). We can then analyze the results for the longest, shortest distance,
    bounding rectangle, and other summaries of the data.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了数据，后面的部分将展示如何在每条路径上装饰**haversine**距离。`wrap(wrap(iterable())))`处理的最终结果将是三个元组的序列：((`lat`,
    `lon`), (`lat`, `lon`), `distance`)。然后我们可以分析结果，找出最长、最短的距离，边界矩形和其他数据的摘要。
- en: Parsing an XML file
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析XML文件
- en: We'll start by parsing an **XML** (short for **Extensible** **Markup** **Language**)
    file to get the raw latitude and longitude pairs. This will show how we can encapsulate
    some not-quite functional features of Python to create an iterable sequence of
    values. We'll make use of the `xml.etree` module. After parsing, the resulting
    `ElementTree` object has a `findall()` method that will iterate through the available
    values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从解析一个**XML**（**可扩展** **标记** **语言**的缩写）文件开始，以获取原始的纬度和经度对。这将展示我们如何封装Python的一些不太功能性的特性，以创建一个可迭代的值序列。我们将使用`xml.etree`模块。解析后，生成的`ElementTree`对象有一个`findall()`方法，可以遍历可用的值。
- en: 'We''ll be looking for constructs such as the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将寻找以下代码片段这样的结构：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The file will have a number of `<Placemark>` tags, each of which has a point
    and coordinate structure within it. This is typical of **Keyhole Markup Language**
    (**KML**) files that contain geographic information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 文件将有许多`<Placemark>`标签，每个标签中都有一个点和坐标结构。这是包含地理信息的**Keyhole Markup Language** (**KML**)文件的典型情况。
- en: Parsing an XML file can be approached at two levels of abstraction. At the lower
    level, we need to locate the various tags, attribute values, and content within
    the XML file. At a higher level, we want to make useful objects out of the text
    and attribute values.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 解析XML文件可以在两个抽象级别上进行。在较低级别，我们需要定位XML文件中的各种标签、属性值和内容。在较高级别，我们希望将文本和属性值转换为有用的对象。
- en: 'The lower-level processing can be approached in the following way:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 较低级别的处理可以通过以下方式进行：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function requires a file that was already opened, usually via a `with`
    statement. However, it can also be any of the file-like objects that the XML parser
    can handle. The function includes a simple static `dict` object, `ns_map`, that
    provides the `namespace` mapping information for the XML tags we'll be searching.
    This dictionary will be used by the `XML` `ElementTree.findall()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要一个已经打开的文件，通常是通过`with`语句打开的。但它也可以是XML解析器可以处理的任何文件类对象。该函数包括一个简单的静态`dict`对象`ns_map`，为我们将要搜索的XML标签提供`namespace`映射信息。这个字典将被`XML`
    `ElementTree.findall()`方法使用。
- en: The essence of the parsing is a generator function that uses the sequence of
    tags located by `doc.findall()`. This sequence of tags is then processed by a
    `comma_split()` function to tease the text value into its comma-separated components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解析的本质是一个生成器函数，它使用`doc.findall()`定位的标签序列。然后，这些标签序列由`comma_split()`函数处理，将文本值分解为逗号分隔的组件。
- en: 'The `comma_split()` function is the functional version of the `split()` method
    of a string, which is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`comma_split()`函数是字符串`split()`方法的功能版本，如下所示：'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've used the functional wrapper to emphasize a slightly more uniform syntax.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用功能包装器来强调略微更统一的语法。
- en: 'The result of this function is an iterable sequence of rows of data. Each row
    will be a tuple composed of three strings: `latitude`, `longitude`, and `altitude`
    of a waypoint along this path. This isn''t directly useful yet. We''ll need to
    do some more processing to get `latitude` and `longitude` as well as converting
    these two numbers into useful floating-point values.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的结果是一个可迭代的数据行序列。每一行将是一个由三个字符串组成的元组：`纬度`、`经度`和路径上一个航路点的`高度`。这还不直接有用。我们需要做一些额外的处理，以获得`纬度`和`经度`，并将这两个数字转换为有用的浮点值。
- en: This idea of an iterable sequence of tuples as results of lower-level parsing
    allows us to process some kinds of data files in a simple and uniform way. In
    [Chapter 3](ch03.html "Chapter 3. Functions, Iterators, and Generators"), *Functions,
    Iterators, and Generators*, we looked at how **Comma** **Separated** **Values**
    (**CSV**) files are easily handled as rows of tuples. In [Chapter 6](ch06.html
    "Chapter 6. Recursions and Reductions"), *Recursions and Reductions*, we'll revisit
    the parsing idea to compare these various examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将较低级别解析的结果作为元组的可迭代序列的想法，使我们能够以一种简单和统一的方式处理某些类型的数据文件。在[第3章](ch03.html "第3章。函数、迭代器和生成器")中，*函数、迭代器和生成器*，我们看到**逗号**
    **分隔** **值**（**CSV**）文件可以很容易地处理为元组的行。在[第6章](ch06.html "第6章。递归和归约")中，*递归和归约*，我们将重新讨论解析的想法，以比较这些各种例子。
- en: 'The output from the preceding function looks like the following code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数的输出看起来像以下的代码片段：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each row is the source text of the `<ns0:coordinates>` tag split using `,` that's
    part of the text content. The values are the East-West longitude, North-South
    latitude, and altitude. We'll apply some additional functions to the output of
    this function to create a usable set of data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都是使用`,`分割的`<ns0:coordinates>`标签的源文本内容。这些值是东西经度、南北纬度和高度。我们将对这个函数的输出应用一些额外的函数，以创建一个可用的数据集。
- en: Parsing a file at a higher level
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在更高级别解析文件
- en: Once we've parsed the low-level syntax, we can restructure the raw data into
    something usable in our Python program. This kind of structuring applies to XML,
    **JavaScript Object Notation** (**JSON**), CSV, and any of the wide variety of
    physical formats in which data is serialized.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们解析了低级语法，我们可以将原始数据重构为我们的Python程序中可用的形式。这种结构适用于XML、**JavaScript对象表示**（**JSON**）、CSV以及数据序列化的各种物理格式。
- en: 'We''ll aim to write a small suite of generator functions that transforms the
    parsed data into a form our application can use. The generator functions include
    some simple transformations on the text that''s found by the `row_iter_kml()`
    function, which are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将致力于编写一套小的生成器函数，将解析后的数据转换为我们的应用程序可以使用的形式。生成器函数包括对`row_iter_kml()`函数找到的文本进行一些简单的转换，如下所示：
- en: Discarding `altitude`, or perhaps keeping only `latitude` and `longitude`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃`高度`，或者可能只保留`纬度`和`经度`
- en: Changing the order from (`longitude`, `latitude`) to (`latitude`, `longitude`)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顺序从（`经度`，`纬度`）更改为（`纬度`，`经度`）
- en: 'We can make these two transformations have more syntactic uniformity by defining
    a utility function as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个实用函数来使这两种转换具有更多的语法统一性，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use this function as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式使用这个函数：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function will apply the `pick_lat_lon()` function to each row. We've used
    `*row` to assign each element of the row three tuple to separate parameters of
    the `pick_lat_lon()` function. The function can then extract and reorder the two
    relevant values from each three tuple.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将对每一行应用`pick_lat_lon()`函数。我们使用`*row`将每个行的三元组的每个元素分配给`pick_lat_lon()`函数的单独参数。然后函数可以从每个三元组中提取和重新排序两个相关值。
- en: It's important to note that a good functional design allows us to freely replace
    any function with its equivalent, which makes refactoring quite simple. We've
    tried to achieve this goal when we provide alternative implementations of the
    various functions. In principle, a clever functional language compiler might do
    some replacements as part of an optimization pass.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，一个良好的函数式设计允许我们自由地用其等效物替换任何函数，这使得重构非常简单。当我们提供各种函数的替代实现时，我们试图实现这个目标。原则上，一个聪明的函数式语言编译器可能会在优化过程中进行一些替换。
- en: 'We''ll use the following kind of processing to parse the file and build a structure
    we can use, such as the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下类型的处理来解析文件并构建一个我们可以使用的结构，例如以下代码片段：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've used the `urllib` command to open a source. In this case, it's a local
    file. However, we can also open a KML file on a remote server. Our objective with
    using this kind of file opening is to assure that our processing is uniform no
    matter what the source of the data is.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`urllib`命令打开一个源。在这种情况下，它是一个本地文件。然而，我们也可以打开一个远程服务器上的KML文件。我们使用这种文件打开的目的是确保我们的处理无论数据的来源如何都是统一的。
- en: We've shown the two functions that do low-level parsing of the KML source. The
    `row_iter_kml(source)` expression produces a sequence of text columns. The `lat_lon_kml()`
    function will extract and reorder the `latitude` and `longitude` values. This
    creates an intermediate result that sets the stage for further processing. The
    subsequent processing is independent of the original format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了两个执行KML源的低级解析的函数。`row_iter_kml(source)`表达式产生一个文本列的序列。`lat_lon_kml()`函数将提取和重新排序`纬度`和`经度`的值。这创建了一个中间结果，为进一步处理奠定了基础。随后的处理与原始格式无关。
- en: 'When we run this, we see results like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个函数时，我们会看到以下结果：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've extracted just the `latitude` and `longitude` values from a complex XML
    file using an almost purely functional approach. As the result is an iterable,
    we can continue to use functional programming techniques to process each point
    that we retrieve from the file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从一个复杂的XML文件中提取了`纬度`和`经度`的值，使用了几乎纯函数式的方法。由于结果是可迭代的，我们可以继续使用函数式编程技术来处理从文件中检索到的每个点。
- en: We've explicitly separated low-level XML parsing from higher-level reorganization
    of the data. The XML parsing produced a generic tuple of string structure. This
    is compatible with the output from the CSV parser. When working with **SQL** databases,
    we'll have a similar iterable of tuple structures. This allows us to write code
    for higher-level processing that can work with data from a variety of sources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确地将低级别的XML解析与数据的高级重组分开。XML解析产生了一个通用的字符串结构元组。这与CSV解析器的输出兼容。在处理**SQL**数据库时，我们将有一个类似的元组结构的可迭代对象。这使我们能够编写用于处理来自各种来源的数据的高级处理代码。
- en: We'll show a series of transformations to rearrange this data from a collection
    of strings to a collection of waypoints along a route. This will involve a number
    of transformations. We'll need to restructure the data as well as convert from
    `strings` to `floating-point` values. We'll also look at a few ways to simplify
    and clarify the subsequent processing steps. We'll use this data set in later
    chapters because it's reasonably complex.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示一系列转换，将这些数据从字符串集合重新排列为路径上的路标集合。这将涉及许多转换。我们需要重组数据，以及从`字符串`转换为`浮点`值。我们还将研究一些简化和澄清后续处理步骤的方法。我们将在后面的章节中使用这个数据集，因为它相当复杂。
- en: Pairing up items from a sequence
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从序列中配对项目
- en: A common restructuring requirement is to make start-stop pairs out of points
    in a sequence. Given a sequence, ![Pairing up items from a sequence](graphics/B03652_04_01.jpg),
    we want to create a paired sequence ![Pairing up items from a sequence](graphics/B03652_04_02.jpg).
    When doing time-series analysis, we might be combining more widely separated values.
    In this example, it's adjacent values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的重组要求是将序列中的点制作成起始-停止对。给定一个序列，![从序列中配对项目](graphics/B03652_04_01.jpg)，我们想要创建一个配对的序列![从序列中配对项目](graphics/B03652_04_02.jpg)。在进行时间序列分析时，我们可能会组合更广泛分开的值。在这个例子中，是相邻的值。
- en: A paired sequence will allow us to use each pair to compute distances from point
    to point using a trivial application of a `haversine` function. This technique
    is also used to convert a path of points into a series of line segments in a graphics
    application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 配对的序列将允许我们使用每对来计算点与点之间的距离，使用`haversine`函数的一个简单应用。这种技术也用于将点的路径转换为图形应用程序中的一系列线段。
- en: Why pair up items? Why not do something like this?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要配对项目？为什么不像这样做？
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This, clearly, will process each leg of the data as a begin-end pair. However,
    the processing function and the loop that restructures the data are tightly bound,
    making reuse more complex than necessary. The algorithm for pairing is hard to
    test in isolation because it's bound to the `compute_something()` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然会将数据的每个部分处理为一个起始-结束对。然而，处理函数和重组数据的循环是紧密绑定的，使得重用比必要复杂。配对算法很难在隔离中进行测试，因为它与`compute_something()`函数绑定在一起。
- en: This combined function also limits our ability to reconfigure the application.
    There's no easy way to inject an alternative implementation of the `compute_something()`
    function. Additionally, we've got a piece of explicit state, the `begin` variable,
    which makes life potentially complex. If we try to add features to the body of
    `loop`, we can easily fail to set the `begin` variable correctly if a point is
    dropped from consideration. A `filter()` function introduces an `if` statement
    that can lead to an error in updating the `begin` variable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合函数也限制了我们重新配置应用程序的能力。没有简单的方法来注入`compute_something()`函数的替代实现。此外，我们有一个显式状态，即`begin`变量，这可能使生活变得复杂。如果我们试图在`loop`的主体中添加功能，如果一个点被从考虑中删除，我们很容易无法正确设置`begin`变量。`filter()`函数引入了一个`if`语句，可能导致在更新`begin`变量时出错。
- en: We achieve better reuse by separating this simple pairing function. This, in
    the long run, is one of our goals. If we build up a library of helpful primitives
    such as this pairing function, we can tackle problems more quickly and confidently.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离这个简单的配对函数，我们实现了更好的重用。这在长远来看是我们的一个目标。如果我们建立一个有用的原语库，比如这个配对函数，我们就可以更快更自信地解决问题。
- en: There are many ways to pair up the points along the route to create start and
    stop information for each leg. We'll look at a few here and then revisit this
    in [Chapter 5](ch05.html "Chapter 5. Higher-order Functions"), *Higher-order Functions*
    and again in [Chapter 8](ch08.html "Chapter 8. The Itertools Module"), *The Itertools
    Module*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以将路径上的点配对，以为每条路径创建起始和停止信息。我们将在这里看一些方法，然后在[第5章](ch05.html "第5章。高阶函数")*高阶函数*中重新讨论这个问题，再次在[第8章](ch08.html
    "第8章。Itertools模块")*Itertools模块*中重新讨论。
- en: 'Creating pairs can be done in a purely functional way using a recursion. The
    following is one version of a function to pair up the points along a route:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用递归以纯函数方式创建配对。以下是一个配对路径上点的函数的一个版本：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The essential function is the internal `pair_from()` function. This works with
    the item at the head of an iterable plus the iterable itself. It yields the first
    pair, pops the next item from the iterable, and then invokes itself recursively
    to yield any additional pairs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基本函数是内部的`pair_from()`函数。它使用可迭代对象头部的项目加上可迭代对象本身。它产生第一对，从可迭代对象中弹出下一个项目，然后递归调用自身以产生任何额外的对。
- en: We've invoked this function from the `pairs()` function. The `pairs()` function
    ensures that the initialization is handled properly and the terminating exception
    is silenced properly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`pairs()`函数中调用了这个函数。`pairs()`函数确保初始化被正确处理，并且终止异常被正确地消除。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python iterable recursion involves a `for` loop to properly consume and yield
    the results from the recursion. If we try to use a simpler-looking `return pair_from(nxt,
    iterable_tail)` method, we'll see that it does not properly consume the iterable
    and yield all of the values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Python可迭代递归涉及使用`for`循环来正确消耗并产生递归的结果。如果我们尝试使用一个看起来更简单的`return pair_from(nxt,
    iterable_tail)`方法，我们会发现它并没有正确消耗可迭代对象并产生所有的值。
- en: Recursion in a generator function requires `yield` from a statement to consume
    the resulting iterable. For this, use `yield from recursive_iter(args)`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数中的递归需要`yield` from语句来消耗生成的可迭代对象。为此，使用`yield from recursive_iter(args)`。
- en: Something like `return recursive_iter(args)` will return only a generator object;
    it doesn't evaluate the function to return the generated values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类似`return recursive_iter(args)`的语句将只返回一个生成器对象；它不会评估函数以返回生成的值。
- en: 'Our strategy for performing tail-call optimization is to replace the recursion
    with a generator expression. We can clearly optimize this recursion into a simple
    `for` loop. The following is another version of a function to pair up the points
    along a route:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行尾递归优化的策略是用生成器表达式替换递归。我们可以将这种递归明显优化为简单的`for`循环。以下是另一个配对路线上点的函数的版本：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The version is quite fast and free from stack limits. It's independent of any
    particular type of sequence, as it will pair up anything emitted by a sequence
    generator. As there's no processing function inside loop, we can reuse the `legs()`
    function as needed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本非常快速，没有堆栈限制。它不依赖于任何特定类型的序列，因为它将任何序列生成器发出的任何东西配对。由于循环内没有处理函数，我们可以根据需要重用`legs()`函数。
- en: 'We can think of this function as one that yields the following kind of sequence
    of pairs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个函数看作是产生以下类型的配对序列：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another view of this function is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的另一个视图如下：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While informative, these other two formulations only work for sequence objects.
    The `legs()` and `pairs()` functions work for any iterable, including sequence
    objects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然信息丰富，但这另外两种表述只适用于序列对象。`legs()`和`pairs()`函数适用于任何可迭代对象，包括序列对象。
- en: Using the iter() function explicitly
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用iter()函数显式地
- en: 'The purely functional viewpoint is that all of our iterables can be processed
    with recursive functions, where the state is merely the recursive call stack.
    Pragmatically, Python iterables will often involve evaluation of other `for` loops.
    There are two common situations: collections and iterables. When working with
    a collection, an iterator object is created by the `for` statement. When working
    with a generator function, the generator function is the iterator and maintains
    its own internal state. Often, these are equivalent from a Python programming
    perspective. In rare cases, generally those situations where we have to use an
    explicit `next()` function, the two won''t be precisely equivalent.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹的功能观点是，我们所有的可迭代对象都可以用递归函数处理，其中状态仅仅是递归调用堆栈。从实用的角度来看，Python可迭代对象通常涉及其他`for`循环的评估。有两种常见情况：集合和可迭代对象。在处理集合时，`for`语句会创建一个迭代器对象。在处理生成器函数时，生成器函数是迭代器，并维护其自己的内部状态。从Python编程的角度来看，这些通常是等效的。在极少数情况下，通常是那些必须使用显式的`next()`函数的情况下，这两者不会完全等效。
- en: Our `legs()` function shown previously has an explicit `next()` function call
    to get the first value from the iterable. This works wonderfully well with generator
    functions, expressions, and other iterables. It doesn't work with sequence objects
    such as tuples or `lists`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前展示的`legs()`函数有一个显式的`next()`函数调用，以从可迭代对象中获取第一个值。这在生成器函数、表达式和其他可迭代对象中非常有效。但在元组或`lists`等序列对象中却不起作用。
- en: 'The following are three examples to clarify the use of the `next()` and `iter()`
    functions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三个例子，以阐明`next()`和`iter()`函数的用法：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the first case, we applied the `legs()` function to an iterable. In this
    case, the iterable was a generator expression. This is the expected behavior based
    on our previous examples in this chapter. The items are properly paired up to
    create two legs from three waypoints.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们将`legs()`函数应用于一个可迭代对象。在这种情况下，可迭代对象是一个生成器表达式。根据本章中之前的例子，这是预期的行为。项目被正确地配对，以从三个航点中创建两条腿。
- en: In the second case, we tried to apply the `legs()` function to a sequence. This
    resulted in an error. While a `list` object and an iterable are equivalent when
    used in a `for` statement, they aren't equivalent everywhere. A sequence isn't
    an iterator; it doesn't implement the `next()` function. The `for` statement handles
    this gracefully, however, by creating an iterator from a sequence automatically.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们尝试将`legs()`函数应用于一个序列。这导致了一个错误。虽然`list`对象和可迭代对象在`for`语句中使用时是等效的，但它们在其他地方并不等效。序列不是迭代器；它不实现`next()`函数。然而，`for`语句通过自动从序列创建迭代器来优雅地处理这个问题。
- en: To make the second case work, we need to explicitly create an iterator from
    a `list` object. This permits the `legs()` function to get the first item from
    the iterator over the `list` items.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使第二种情况起作用，我们需要显式地从`list`对象创建一个迭代器。这允许`legs()`函数从`list`项的迭代器中获取第一个项目。
- en: Extending a simple loop
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展简单循环
- en: We have two kinds of extensions we might factor into a simple loop. We'll look
    first at a `filter` extension. In this case, we might be rejecting values from
    further consideration. They might be data outliers, or perhaps source data that's
    improperly formatted. Then, we'll look at mapping source data by performing a
    simple transformation to create new objects from the original objects. In our
    case, we'll be transforming `strings` to `floating-point` numbers. The idea of
    extending a simple `loop` with a mapping, however, applies to situations. We'll
    look at refactoring the above `pairs()` function. What if we need to adjust the
    sequence of points to discard a value? This will introduce a `filter` extension
    that rejects some data values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种扩展可以因素成一个简单的循环。我们首先看一下`filter`扩展。在这种情况下，我们可能会拒绝进一步考虑的值。它们可能是数据异常值，或者可能是格式不正确的源数据。然后，我们将通过执行简单的转换来映射源数据，从原始对象创建新对象。在我们的情况下，我们将把`strings`转换为`floating-point`数字。然而，将简单的`loop`与映射扩展的想法适用于各种情况。我们将重新设计上面的`pairs()`函数。如果我们需要调整点的序列以丢弃一个值，会引入一个`filter`扩展来拒绝一些数据值。
- en: As the loop we're designing simply returns pairs without performing any additional
    application-related processing, the complexity is minimal. Simplicity means we're
    somewhat less likely to confuse the processing state.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们设计的循环只是返回一对，而没有执行任何额外的应用相关处理，所以复杂性是最小的。简单意味着我们更不太可能混淆处理状态。
- en: 'Adding a `filter` extension to this design might look something like the following
    code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中添加一个`filter`扩展可能看起来像以下代码片段：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have plugged in a processing rule to reject certain values. As the `loop`
    remains succinct and expressive, we are confident that the processing will be
    done properly. Also, we can easily write a test for this function, as the results
    work for any iterable, irrespective of the long-term destination of the pairs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经插入了一个处理规则来拒绝某些值。由于`loop`保持简洁和表达力十足，我们有信心处理将会被正确完成。此外，我们可以很容易地为这个函数编写一个测试，因为结果适用于任何可迭代对象，而不管这些对象的长期目的地是什么。
- en: The next refactoring will introduce additional mapping to a loop. Adding mappings
    is common when a design is evolving. In our case, we have a sequence of `string`
    values. We need to convert these to `floating-point` values for later use. This
    is a relatively simple mapping that shows the design pattern.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次重构将向循环引入额外的映射。当设计正在演变时，添加映射是很常见的。在我们的情况下，我们有一系列`string`值。我们需要将它们转换为以后使用的`floating-point`值。这是一个相对简单的映射，展示了设计模式。
- en: 'The following is one way to handle this data mapping, through a generator expression
    that wraps a generator function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过包装一个生成器函数的生成器表达式来处理这些数据映射的一种方法：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've applied the `legs()` function to a generator expression that creates `float`
    values from the output of the `lat_lon_kml()` function. We can read this in the
    opposite order as well. The `lat_lon_kml()` function's output is transformed into
    a pair of `float` values, which is then transformed into a sequence of `legs`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`legs()`函数应用于一个生成器表达式，该表达式从`lat_lon_kml()`函数的输出中创建`float`值。我们也可以以相反的顺序阅读。`lat_lon_kml()`函数的输出被转换为一对`float`值，然后转换为一系列`legs`。
- en: 'This is starting to get complex. We''ve got a large number of nested functions
    here. We''re applying `float()`, `legs()`, and `tuple()` to a data generator.
    One common refactoring of complex expressions is to separate the generator expression
    from any materialized collection. We can do the following to simplify the expression:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始变得复杂了。我们这里有大量嵌套的函数。我们将`float()`、`legs()`和`tuple()`应用于数据生成器。复杂表达式的一个常见重构是将生成器表达式与任何实现的集合分开。我们可以做以下工作来简化表达式：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've assigned the generator function to a variable named `flt`. This variable
    isn't a collection object; we're not using a `list` comprehension to create an
    object. We've merely assigned the generator expression to a variable name. We've
    then used the `flt` variable in another expression.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成函数分配给一个名为`flt`的变量。这个变量不是一个集合对象；我们没有使用`list`推导来创建一个对象。我们只是将生成器表达式分配给一个变量名。然后我们在另一个表达式中使用了`flt`变量。
- en: The evaluation of the `tuple()` method actually leads to a proper object being
    built so that we can print the output. The `flt` variable's objects are created
    only as needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple()`方法的评估实际上导致了一个适当的对象被构建，以便我们可以打印输出。`flt`变量的对象只在需要时被创建。'
- en: There are other refactoring's we might like to do. In general, the source of
    the data is something we often want to change. In our example, the `lat_lon_kml()`
    function is tightly bound in the rest of the expression. This makes reuse difficult
    when we have a different data source.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想做其他的重构。一般来说，数据的来源是我们经常想要更改的。在我们的例子中，`lat_lon_kml()`函数与表达式的其余部分紧密绑定。当我们有不同的数据源时，这使得重用变得困难。
- en: 'In the case where the `float()` operation is something we''d like to parameterize
    so that we can reuse it, we can define a function around the generator expression.
    We''ll extract some of the processing into a separate function merely to group
    the operations. In our case, the string-pair to float-pair is unique to a particular
    source data. We can rewrite a complex float-from-string expression into a simpler
    function such as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`float()`操作是我们想要参数化以便重用的情况下，我们可以定义一个围绕生成器表达式的函数。我们将一些处理提取到一个单独的函数中，仅仅是为了将操作分组。在我们的情况下，字符串对到浮点对是特定于特定源数据的。我们可以将复杂的从字符串到浮点数的表达式重写为一个更简单的函数，如下所示：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `float_from_pair()` function applies the `float()` function to the first
    and second values of each item in the iterable, yielding a two tuple of floats
    created from an input value. We've relied on Python's `for` statement to decompose
    the two tuple.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`float_from_pair()`函数将`float()`函数应用于可迭代项中的第一个和第二个值，产生从输入值创建的两个浮点数元组。我们依赖于Python的`for`语句来分解这两个元组。'
- en: 'We can use this function in the following context:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下上下文中使用这个函数：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We're going to create `legs` that are built from `float` values that come from
    a KML file. It's fairly easy to visualize the processing, as each stage in the
    process is a simple prefix function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建从KML文件中获取的`float`值构建的`legs`。很容易将处理可视化，因为过程中的每个阶段都是一个简单的前缀函数。
- en: When parsing, we often have sequences of `string` values. For numeric applications,
    we'll need to convert `strings` to `float`, `int`, or `Decimal` values. This often
    involves inserting a function such as the `float_from_pair()` function into a
    sequence of expressions that clean up the source data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析时，我们经常有一系列`string`值。对于数值应用，我们需要将`strings`转换为`float`、`int`或`Decimal`值。这通常涉及将一个函数插入到一系列清理源数据的表达式中，比如`float_from_pair()`函数。
- en: 'Our previous output was all strings; it looked like the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先前的输出都是字符串；看起来像以下代码片段：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll want data like the following code snippet, where we have floats:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望数据像以下代码片段一样，其中包含浮点数：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We'll need to create a pipeline of simpler transformation functions. Above,
    we arrived at `flt= ((float(lat), float(lon)) for lat,lon in lat_lon_kml())`.
    We can exploit the substitution rule for functions and replace a complex expression
    such as `(float(lat), float(lon)) for lat,lon in lat_lon_kml())` with a function
    that has the same value, in this case, `float_from_pair(lat_lon_kml())`. This
    kind of refactoring allows us to be sure that a simplification has the same effect
    as a more complex expression.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个更简单的转换函数的管道。上面，我们得到了`flt= ((float(lat), float(lon)) for lat,lon in lat_lon_kml())`。我们可以利用函数的替换规则，用一个具有相同值的函数替换一个复杂的表达式，比如`(float(lat),
    float(lon)) for lat,lon in lat_lon_kml())`，在这种情况下，是`float_from_pair(lat_lon_kml())`。这种重构允许我们确保简化具有与更复杂表达式相同的效果。
- en: There are some simplifications that we'll look at in [Chapter 5](ch05.html "Chapter 5. Higher-order
    Functions"), *Higher-order Functions*. We will revisit this in [Chapter 6](ch06.html
    "Chapter 6. Recursions and Reductions"), *Recursions and Reductions* to see how
    to apply these simplifications to the file-parsing problem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](ch05.html "第5章。高阶函数")*高阶函数*中查看一些简化。我们将在[第6章](ch06.html "第6章。递归和缩减")*递归和缩减*中重新讨论这个问题，看看如何将这些简化应用到文件解析问题上。
- en: Applying generator expressions to scalar functions
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将生成器表达式应用于标量函数
- en: We'll look cat a more complex kind of generator expression to map data values
    from one kind of data to another. In this case, we'll apply a fairly complex function
    to individual data values created by a generator.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一种更复杂的生成器表达式，将数据值从一种数据映射到另一种数据。在这种情况下，我们将对生成器创建的单个数据值应用一个相当复杂的函数。
- en: We'll call these non-generator functions *scalar*, as they work with simple
    `scalar` values. To work with collections of data, a scalar function will be embedded
    in a generator expression.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些非生成器函数称为*标量*，因为它们处理简单的`标量`值。要处理数据集，标量函数将嵌入到生成器表达式中。
- en: To continue the example started earlier, we'll provide a `haversine` function
    and then use a generator expression to apply a scalar `haversine()` function to
    a sequence of pairs from our KML file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 继续之前的示例，我们将提供一个`haversine`函数，然后使用生成器表达式将标量`haversine()`函数应用于我们KML文件中的一系列对。
- en: 'The `haversine()` function looks like following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`haversine()`函数如下所示：'
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a relatively simple implementation copied from the **World** **Wide**
    **Web**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对简单的实现，复制自**World** **Wide** **Web**。
- en: 'The following is how we might use our collection of functions to examine some
    KML data and produce a sequence of distances:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用我们的函数集合来检查一些KML数据并产生一系列距离的方式：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The essence of the processing is the generator expression assigned to the `trip`
    variable. We've assembled three tuples with a start, end, and the distance from
    start to end. The start and end pairs come from the `legs()` function. The `legs()`
    function works with `floating-point` data built from the `latitude-longitude`
    pairs extracted from a KML file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 处理的精髓是分配给`trip`变量的生成器表达式。我们已经组装了三个元组，其中包括起点、终点和起点到终点的距离。起点和终点对来自`legs()`函数。`legs()`函数使用从KML文件中提取的`纬度-经度`对构建的`浮点`数据。
- en: 'The output looks like the following command snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像以下命令片段：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Each individual processing step has been defined succinctly. The overview, similarly,
    can be expressed succinctly as a composition of functions and generator expressions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的处理步骤都被简洁地定义了。同样，概述也可以被表达为函数和生成器表达式的组合。
- en: Clearly, there are several further processing steps we might like to apply to
    this data. First, of course, is to use the `format()` method of a string to produce
    better-looking output.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可能希望对这些数据应用几个进一步的处理步骤。首先，当然，是使用字符串的`format()`方法来产生更好看的输出。
- en: More importantly, there are a number of aggregate values we'd like to extract
    from this data. We'll call these values reductions of the available data. We'd
    like to reduce the data to get the maximum and minimum latitude—for example, to
    show the extreme North and South ends of this route. We'd like to reduce the data
    to get the maximum distance in one leg as well as the total distance for all `legs`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们想要从这些数据中提取一些聚合值。我们将这些值称为可用数据的缩减。我们想要缩减数据以获得最大和最小纬度，例如，以显示这条路线的极端北端和南端。我们想要缩减数据以获得一条腿的最大距离以及所有`legs`的总距离。
- en: The problem we'll have using Python is that the output generator in the `trip`
    variable can only be used once. We can't easily perform several reductions of
    this detailed data. We can use `itertools.tee()` to work with the iterable several
    times. It seems wasteful, however, to read and parse the KML file for each reduction.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用Python时会遇到的问题是，`trip`变量中的输出生成器只能使用一次。我们无法轻松地对这些详细数据进行多次缩减。我们可以使用`itertools.tee()`来多次使用可迭代对象。然而，每次缩减都读取和解析KML文件似乎是一种浪费。
- en: We can make our processing more efficient by materializing intermediate results.
    We'll look at this in the next section. Then, we can see how to compute multiple
    reductions of the available data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现中间结果来使我们的处理更有效。我们将在下一节中看到这一点。然后，我们可以看看如何计算可用数据的多个缩减。
- en: Using any() and all() as reductions
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用any()和all()作为缩减
- en: The `any()` and `all()` functions provide `boolean` reduction capabilities.
    Both functions reduce a collection of values to a single `True` or `False`. The
    `all()` function assures that all values are `True`. The `any()` function assures
    that at least one value is `True`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`any()`和`all()`函数提供了`布尔`缩减功能。这两个函数都将一组值缩减为单个`True`或`False`。`all()`函数确保所有值都为`True`。`any()`函数确保至少有一个值为`True`。'
- en: 'These functions are closely related to a universal quantifier and an existential
    quantifier used to express mathematical logic. We might, for example, want to
    assert that all elements in a given collection have some property. One formalism
    for this might look like following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与用于表达数学逻辑的普遍量词和存在量词密切相关。例如，我们可能想要断言给定集合中的所有元素都具有某种属性。其中一种形式可能如下所示：
- en: '![Using any() and all() as reductions](graphics/B03652_04_03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![使用any()和all()作为缩减](graphics/B03652_04_03.jpg)'
- en: 'We''d read this as: *for all x in SomeSet, the function* ![Using any() and
    all() as reductions](graphics/B03652_04_04.jpg)  *is true*. We''ve put a quantifier
    in front of the logical expression.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会读到这样的内容：*对于SomeSet中的所有x，函数*![使用any()和all()作为缩减](graphics/B03652_04_04.jpg)
    *是真的*。我们在逻辑表达式前面放了一个量词。
- en: 'In Python, we switch the order of the items slightly to transcribe the logic
    expression as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们稍微改变了项目的顺序，以转录逻辑表达式如下：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will evaluate each argument value (`isprime(x)`) and reduce the collection
    of values to a single `True` or `False`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估每个参数值（`isprime(x)`）并将值集合缩减为单个`True`或`False`。
- en: 'The `any()` function is related to the existential quantifier. If we want to
    assert that no value in a collection is prime, we might have something like one
    of the two equivalent expressions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`any()`函数与存在量词有关。如果我们想要断言集合中没有值是素数，我们可能会有类似以下两个等价表达式之一：'
- en: '![Using any() and all() as reductions](graphics/B03652_04_05.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![使用any()和all()作为缩减](graphics/B03652_04_05.jpg)'
- en: The first states that *it is not the case that all elements in SomeSet are prime*.
    The second version asserts that *there exists one element in SomeSet that is not
    prime*. These two are equivalent—that is, *if not all elements are prime, then
    one element must be non-prime*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个陈述*SomeSet中的所有元素都不是素数*。第二个版本断言*SomeSet中存在一个不是素数的元素*。这两者是等价的——也就是说，*如果不是所有元素都是素数，那么必定存在一个元素不是素数*。
- en: 'In Python, we can switch the order of the terms and transcribe these to working
    code as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以交换术语的顺序，并将其转录为以下工作代码：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As they''re equivalent, there are two reasons for preferring one over the other:
    performance and clarity. The performance is nearly identical, so it boils down
    to clarity. Which of these states the condition the most clearly?'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是等价的，有两个原因可以优先选择一个而不是另一个：性能和清晰度。性能几乎相同，所以归结为清晰度。哪一个最清晰地陈述了条件？
- en: The `all()` function can be described as an `and` reduction of a set of values.
    The result is similar to folding the `and` operator between the given sequence
    of values. The `any()` function, similarly, can be described as an `or` reduction.
    We'll return to this kind of general-purpose reduce when we look at the `reduce()`
    function in [Chapter 10](ch10.html "Chapter 10. The Functools Module"), *The Functools
    Module*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()`函数可以描述为一组值的`and`缩减。结果类似于在给定值序列之间折叠`and`运算符。类似地，`any()`函数可以描述为`or`缩减。当我们查看[第10章](ch10.html
    "第10章。Functools模块")中的`reduce()`函数时，我们将回到这种通用缩减。*Functools模块*。'
- en: We also need to look at the degenerate case of these functions. What if the
    sequence has 0 elements? What are the values of `all(())` or `all([])`?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要看一下这些函数的退化情况。如果序列有0个元素会怎样？`all(())`或`all([])`的值是什么？
- en: If we ask, "Are all elements in an empty set prime?", then what's the answer?
    As there are no elements, the question is a bit difficult to answer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们问，“空集中的所有元素都是素数吗？”，那么答案是什么？由于没有元素，这个问题有点难以回答。
- en: If we ask "Are all elements in an empty set prime and all elements in `SomeSet`
    prime?", we have a hint as to how we have to proceed. We're performing an `and`
    reduction of an empty set and an `and` reduction of `SomeSet`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们问“空集中的所有元素都是素数，`SomeSet`中的所有元素都是素数吗？”，我们对如何继续进行有一些提示。我们正在执行空集的`and`缩减和`SomeSet`的`and`缩减。
- en: '![Using any() and all() as reductions](graphics/B03652_04_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![使用any()和all()作为缩减](graphics/B03652_04_06.jpg)'
- en: 'It turns out that the `and` operator can be distributed freely. We can rewrite
    this to a union of the two sets, which is then evaluated for being prime:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明`and`运算符可以自由分布。我们可以将其重写为两个集合的并集，然后对其进行素数评估：
- en: '![Using any() and all() as reductions](graphics/B03652_04_07.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用any()和all()作为缩减](graphics/B03652_04_07.jpg)'
- en: 'Clearly, ![Using any() and all() as reductions](graphics/B03652_04_08.jpg).
    If we union an empty set, we get the original set. The empty set can be called
    the **union identify element**. This parallels the way 0 is the additive identity
    element: ![Using any() and all() as reductions](graphics/B03652_04_09.jpg).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，![使用any()和all()作为缩减](graphics/B03652_04_08.jpg)。如果我们联合一个空集，我们会得到原始集合。空集可以称为**联合标识元素**。这类似于0是加法标识元素的方式：![使用any()和all()作为缩减](graphics/B03652_04_09.jpg)。
- en: Similarly, `any(())` must be the `or` identity element, which is `False`. If
    we think of the multiplicative identify element, 1, where ![Using any() and all()
    as reductions](graphics/B03652_04_10.jpg), then `all(())` must be `True`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`any(())`必须是`or`标识元素，即`False`。如果我们考虑乘法标识元素1，其中![使用any()和all()作为缩减](graphics/B03652_04_10.jpg)，那么`all(())`必须是`True`。
- en: 'We can demonstrate that Python follows these rules:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以证明Python遵循这些规则：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Python gives us some very nice tools to perform processing that involves logic.
    We have the built-in `and`, `or`, and `not` operators. However, we also have these
    collection-oriented `any()` and `all()` functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了一些非常好的工具来执行涉及逻辑的处理。我们有内置的`and`、`or`和`not`运算符。但是，我们还有这些面向集合的`any()`和`all()`函数。
- en: Using len() and sum()
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用len()和sum()
- en: 'The `len()` and `sum()` functions provide two simple reductions: a count of
    the elements and the sum of the elements in a sequence. These two functions are
    mathematically similar, but their Python implementation is quite different.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()`和`sum()`函数提供了两个简单的缩减：元素的计数和序列中元素的总和。这两个函数在数学上是相似的，但它们的Python实现是非常不同的。'
- en: Mathematically, we can observe this cool parallelism. The `len()` function returns
    the sum of 1's for each value in a collection, X:![Using len() and sum()](graphics/B03652_04_11.jpg).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，我们可以观察到这种很酷的平行性。`len()`函数返回集合X中每个值的1的总和：![使用len()和sum()](graphics/B03652_04_11.jpg)。
- en: The `sum()` function returns the sum of *x* for each value in a collection,
    X:![Using len() and sum()](graphics/B03652_04_12.jpg).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()`函数返回集合X中每个值的*x*的总和：![使用len()和sum()](graphics/B03652_04_12.jpg)。'
- en: The `sum()` function works for any iterable. The `len()` function doesn't apply
    to iterables; it only applies to sequences. This little asymmetry in the implementation
    of these functions is a little awkward around the edges of statistical algorithms.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()`函数适用于任何可迭代对象。`len()`函数不适用于可迭代对象；它只适用于序列。这些函数的实现中存在的这种小不对称在统计算法的边缘有点尴尬。'
- en: For empty sequences, both of these functions return a proper additive identity
    element of 0.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空序列，这两个函数都返回一个适当的加法恒元素0。
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course, `sum(())` returns an integer 0\. When other numeric types are used,
    the integer 0 will be coerced to the proper type for the available data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他数值类型被使用时，`sum(())`返回整数0。整数0将被强制转换为可用数据的适当类型。
- en: Using sums and counts for statistics
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用求和和计数进行统计
- en: 'The definitions of the arithmetic mean have an appealingly trivial definition
    based on `sum()` and `len()`, which is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 算术均值的定义基于`sum()`和`len()`有一个吸引人的平凡定义，如下所示：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While elegant, this doesn't actually work for iterables. This definition only
    works for sequences.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然优雅，但实际上这对于可迭代对象并不适用。这个定义只适用于序列。
- en: Indeed, we have a hard time performing a simple computation of mean or standard
    deviation based on iterables. In Python, we must either materialize a sequence
    object, or resort to somewhat more complex operations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们很难基于可迭代对象执行均值或标准差的简单计算。在Python中，我们必须要么实例化一个序列对象，要么使用更复杂的操作。
- en: 'We have a fairly elegant expression of mean and standard deviation in the following
    definitions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个相当优雅的均值和标准差的表达式如下定义：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These three sums, `s0`, `s1`, and `s2`, have a tidy, parallel structure. We
    can easily compute the mean from two of the sums. The standard deviation is a
    bit more complex, but it's still based on the three sums.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个总和`s0`、`s1`和`s2`有一个整洁的平行结构。我们可以很容易地从这两个总和中计算均值。标准差稍微复杂一些，但仍然基于这三个总和。
- en: This kind of pleasant symmetry also works for more complex statistical functions
    such as correlation and even least-squares linear regression.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种愉快的对称性也适用于更复杂的统计函数，比如相关性甚至最小二乘线性回归。
- en: 'The moment of correlation between two sets of samples can be computed from
    their standardized value. The following is a function to compute the standardized
    value:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 两组样本之间的相关性矩可以从它们的标准化值中计算。以下是一个计算标准化值的函数：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The calculation is simply to subtract the mean, `μ_x`, from each sample, `x`,
    and divide by the standard deviation, `σ_x`. This gives as a value measured in
    units of sigma, `σ`. A value ±1 σ is expected about two-thirds of the time. Larger
    values should be less common. A value outside ±3 σ should happen less than 1 percent
    of the time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 计算很简单，只需从均值`μ_x`中减去每个样本`x`，然后除以标准差`σ_x`。这给出了一个以sigma为单位的值，`σ`。±1σ的值预计大约有三分之二的时间。更大的值应该更少见。±3σ之外的值应该少于1%的时间发生。
- en: 'We can use this scalar function as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个标量函数如下：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We've materialized `list` that consists of normalized scores based on some raw
    data in the variable, `d`. We used a generator expression to apply the scalar
    function, `z()`, to the sequence object.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实例化了一个由变量`d`中的一些原始数据基于标准化分数组成的`list`。我们使用了一个生成器表达式来将标量函数`z()`应用于序列对象。
- en: 'The `mean()` and `stdev()` functions are simply based on the examples shown
    above:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`mean()`和`stdev()`函数只是基于上面显示的例子：'
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The three sum functions, similarly, are based on the examples above:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这三个总和函数是基于上面的例子：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: While this is very expressive and succinct, it's a little frustrating because
    we can't simply use an iterable here. We're computing a mean, which requires a
    sum of the iterable, plus a count. We're also computing a standard deviation that
    requires two sums and a count from the iterable. For this kind of statistical
    processing, we must materialize a sequence object so that we can examine the data
    multiple times.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这非常表达和简洁，但有点令人沮丧，因为我们不能简单地在这里使用可迭代对象。我们正在计算一个均值，这需要对可迭代对象进行求和，再加上一个计数。我们还在计算一个需要从可迭代对象中进行两次求和和一个计数的标准差。对于这种统计处理，我们必须实例化一个序列对象，以便我们可以多次检查数据。
- en: 'The following is how we can compute the correlation between two sets of samples:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何计算两组样本之间的相关性：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This correlation function gathers basic statistical summaries of the two sets
    of samples: the mean and standard deviation. Given these summaries, we defined
    two generator functions that will create normalized values for each set of samples.
    We can then use the `zip()` function (see the next example) to pair up items from
    the two sequences of normalized values and compute the product of those two normalized
    values. The average of the product of the normalized scores is the correlation.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相关性函数收集了两组样本的基本统计摘要：均值和标准差。在得到这些摘要后，我们定义了两个生成器函数，它们将为每组样本创建标准化值。然后我们可以使用`zip()`函数（见下一个例子）将来自两个标准化值序列的项目配对，并计算这两个标准化值的乘积。标准化分数的乘积的平均值就是相关性。
- en: 'The following is an example of gathering the correlation between two sets of
    samples:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个收集两组样本之间相关性的例子：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've shown two sequences of data points, `xi` and `yi`. The correlation is
    over .99, which shows a very strong relationship between the two sequences.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了两组数据点`xi`和`yi`。相关性超过了0.99，显示了两个序列之间非常强的关系。
- en: This shows one of the strengths of functional programming. We've created a handy
    statistical module using a half-dozen functions with definitions that are single
    expressions. The counterexample is the `corr()` function that can be reduced to
    a single very long expression. Each internal variable in this function is used
    just once; a local variable can be replaced with a copy-and-paste of the expression
    that created it. This shows us that the `corr()` function has a functional design
    even though it's written out in six separate lines of Python.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了函数式编程的一个优点。我们使用了半打函数来创建一个方便的统计模块，这些函数的定义都是单个表达式。反例是`corr()`函数，它可以简化为一个非常长的表达式。这个函数中的每个内部变量只使用一次；一个局部变量可以用创建它的表达式的复制粘贴来替换。这告诉我们，`corr()`函数具有函数式设计，即使它是用Python的六行单独写出的。
- en: Using zip() to structure and flatten sequences
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用zip()来构造和展开序列
- en: The `zip()` function interleaves values from several iterators or sequences.
    It will create *n* tuples from the values in each of the *n* input iterables or
    sequences. We used it in the previous section to interleave data points from two
    sets of samples, creating two tuples.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数会从几个迭代器或序列中交错值。它将从每个*n*输入可迭代对象或序列中的值创建*n*个元组。我们在上一节中使用它来交错来自两组样本的数据点，创建两个元组。'
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `zip()` function is a generator. It does not materialize a resulting collection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数是一个生成器。它不会实现一个结果集合。'
- en: 'The following is an example that shows what the `zip()` function does:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了`zip()`函数的作用：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are a number of edge cases for the `zip()` function. We must ask the
    following questions about its behavior:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数有许多边缘情况。我们必须问以下关于其行为的问题：'
- en: What happens where then are no arguments at all?
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有任何参数会发生什么？
- en: What happens where there's only one argument?
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当只有一个参数时会发生什么？
- en: What happens when the sequences are different lengths?
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当序列长度不同时会发生什么？
- en: For reductions (`any()`, `all()`, `len()`, `sum()`), we want an identity element
    from reducing an empty sequence.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于缩减（`any()`、`all()`、`len()`、`sum()`）,我们希望从缩减空序列中得到一个标识元素。
- en: 'Clearly, each of these edge cases must produce some kind of iterable output.
    Here are some examples to clarify the behaviors. First, the empty argument list:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些边缘情况中的每一个都必须产生某种可迭代的输出。以下是一些例子，以澄清这些行为。首先是空参数列表：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can see that the `zip()` function with no arguments is a generator function,
    but there won't be any items. This fits the requirement that the output is iterable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`zip()`函数没有参数是一个生成器函数，但不会有任何项。这符合输出是可迭代的要求。
- en: 'Next, we''ll try a single iterable:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试一个单个可迭代对象：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this case, the `zip()` function emitted one tuple from each input value.
    This too makes considerable sense.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`zip()`函数从每个输入值中发出一个元组。这也是非常有意义的。
- en: 'Finally, we''ll look at the different-length `list` approach used by the `zip()`
    function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看一下`zip()`函数使用的不同长度的`list`方法：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This result is debatable. Why truncate? Why not pad the shorter list with `None`
    values? This alternate definition of `zip()` function is available in the `itertools`
    module as the `zip_longest()` function. We'll look at this in [Chapter 8](ch08.html
    "Chapter 8. The Itertools Module"), *The Itertools Module*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果是有争议的。为什么要截断？为什么不用`None`值填充较短的列表？`zip()`函数的另一种定义在`itertools`模块中作为`zip_longest()`函数可用。我们将在[第8章](ch08.html
    "第8章。迭代工具模块")中看到，*迭代工具模块*。
- en: Unzipping a zipped sequence
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解压压缩的序列
- en: '`zip()` mapping can be inverted. We''ll look at several ways to unzip a collection
    of tuples.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`映射可以被反转。我们将看几种解压元组集合的方法。'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can't fully unzip an iterable of tuples, since we might want to make multiple
    passes over the data. Depending on our needs, we might need to materialize the
    iterable to extract multiple values.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法完全解压元组的可迭代对象，因为我们可能需要多次遍历数据。根据我们的需求，我们可能需要实现可迭代对象以提取多个值。
- en: 'The first way is something we''ve seen many times; we can use a generator function
    to unzip a sequence of tuples. For example, assume that the following pairs are
    a sequence object with two tuples:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是我们已经看到很多次的；我们可以使用一个生成器函数来解压一个元组序列。例如，假设以下对是一个包含两个元组的序列对象：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will create two sequences. The `p0` sequence has the first element of each
    two tuple; the `p1` sequence has the second element of each two tuple.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个序列。`p0`序列有每个两元组的第一个元素；`p1`序列有每个两元组的第二个元素。
- en: 'Under some circumstances, we can use the multiple ssignment of a `for` loop
    to decompose the tuples. The following is an example that computes the sum of
    products:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以使用`for`循环的多重赋值来分解元组。以下是一个计算乘积和的示例：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We used the `for` statement to decompose each two tuple into `p0` and `p1`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`语句将每个两元组分解为`p0`和`p1`。
- en: Flattening sequences
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展平序列
- en: 'Sometimes, we''ll have zipped data that needs to be flattened. For example,
    our input might be a file that looks like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会有需要展平的压缩数据。例如，我们的输入可能是一个看起来像这样的文件：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can easily use `((line.split() for line in file)` to create a sequence of
    ten tuples.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用`((line.split() for line in file)`来创建一个包含十个元组的序列。
- en: 'We might heave data in blocks that looks as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会有以下形式的数据块：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This isn't really what we want, though. We want to get the numbers into a single,
    flat sequence. Each item in the input is a ten tuple; we'd rather not wrangle
    with decomposing this one item at a time.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是我们想要的。我们希望将数字放入一个单一的、扁平的序列中。输入中的每个项目都是一个十元组；我们宁愿不要与逐个分解这个项目打交道。
- en: 'We can use a two-level generator expression, as shown in the following code
    snippet, for this kind of flattening:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两级生成器表达式，如下面的代码片段所示，用于这种展平：
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The two-level generator is confusing at first. We can understand this through
    a simple rewrite as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，两级生成器是令人困惑的。我们可以通过一个简单的重写来理解这一点：
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This transformation shows us how the generator expression works. The first `for`
    clause (`for line in data`) steps through each ten tuple in the data. The second
    `for` clause (`for x in line`) steps through each item in the first `for` clause.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换向我们展示了生成器表达式的工作原理。第一个`for`子句（`for line in data`）遍历数据中的每个十元组。第二个`for`子句（`for
    x in line`）遍历第一个`for`子句中的每个项目。
- en: This expression flattens a sequence-of-sequence structure into a single sequence.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式将一个序列结构压缩成一个单一的序列。
- en: Structuring flat sequences
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造平面序列
- en: Sometimes, we'll have raw data that is a flat list of values that we'd like
    to bunch up into subgroups. This is a bit more complex. We can use the `itertools`
    module's `groupby()` function to implement this. This will have to wait until
    [Chapter 8](ch08.html "Chapter 8. The Itertools Module"), *The Iterools Module*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会有原始数据，它是一列值的平面列表，我们希望将其分成子组。这有点复杂。我们可以使用`itertools`模块的`groupby()`函数来实现这一点。这将等到[第8章](ch08.html
    "第8章。迭代工具模块")*迭代工具模块*。
- en: 'Let''s say we have a simple flat `list` as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的平面`list`如下：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can write nested generator functions to build a sequence-of-sequence structure
    from flat data. In order to do this, we''ll need a single iterator that we can
    use multiple times. The expression looks like the following code snippet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写嵌套的生成器函数，从平面数据构建一个序列结构。为了做到这一点，我们需要一个可以多次使用的单一迭代器。表达式看起来像以下的代码片段：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, we created an iterator that exists outside either of the two loops that
    we'll use to create our sequence-of-sequences. The generator expression uses `tuple(next(flat_iter)
    for i in range(5))` to create five tuples from the iterable values in the `flat_iter`
    variable. This expression is `nested` inside another generator that repeats the
    inner loop the proper number of times to create the required sequence of values.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个迭代器，它存在于我们将用来创建我们的序列结构的两个循环之外。生成器表达式使用`tuple(next(flat_iter) for i
    in range(5))`从`flat_iter`变量中的可迭代值创建了五个元组。这个表达式被嵌套在另一个生成器中，它重复内部循环正确次数，以创建所需的值序列。
- en: This works only when the flat list is divided evenly. If the last row has partial
    elements, we'll need to process them separately.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在平面列表均匀分割时有效。如果最后一行有部分元素，我们需要单独处理它们。
- en: 'We can use this kind of function to group data into same-sized tuples, with
    an odd sized tuple at the end using the following definitions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种函数将数据分组为相同大小的元组，最后一个元组的大小为奇数，使用以下定义：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We've created an initial `list` where each `tuple` is of the size `n`. If there
    are leftovers, we'll have a trailer `tuple` with a non-zero length that we can
    append to the `list` of full-sized items. If the trailer `tuple` is of the length
    0, we'll ignore it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个初始的`list`，其中每个`tuple`的大小为`n`。如果有剩余的元素，我们将有一个长度非零的尾部`tuple`，我们可以将其附加到完整大小的项目的`list`上。如果尾部`tuple`的长度为0，我们将忽略它。
- en: 'This isn''t as delightfully simple and functional-looking as other algorithms
    we''ve looked at. We can rework this into a pleasant-enough generator function.
    The following code uses a `while` loop as part of tail-recursion optimization:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这不像我们之前看过的其他算法那样简单和功能性。我们可以将其改写为一个相当愉快的生成器函数。以下代码使用`while`循环作为尾递归优化的一部分：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've created a row of the required length from the input iterable. When we
    get to the end of the input iterable, the value of `tuple(next(iterable) for i
    in range(n))` will be a zero-length tuple. This is the base case of a recursion,
    which we've written as the terminating condition for a `while` loop.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从输入可迭代对象中创建了所需长度的一行。当我们到达输入可迭代对象的末尾时，`tuple(next(iterable) for i in range(n))`的值将是一个长度为零的元组。这是递归的基本情况，我们已经将其写成了`while`循环的终止条件。
- en: Structuring flat sequences—an alternative approach
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造平面序列——另一种方法
- en: 'Let''s say we have a simple, flat `list` and we want to create pairs from this
    list. The following is the required data:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的平面`list`，我们想从这个`list`中创建成对的元素。以下是所需的数据：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can create pairs using list slices as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表切片创建成对的元素，如下所示：
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The slice `flat[0::2]` is all of the even positions. The slice `flat[1::2]`
    is all of the odd positions. If we zip these together, we get a two tuple of `(0)`,
    the value from the first even position, and `(1)`, the value from the first odd
    position. If the number of elements is even, this will produce pairs nicely.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 切片`flat[0::2]`是所有偶数位置。切片`flat[1::2]`是所有奇数位置。如果我们将它们一起压缩，我们得到一个两个元素的元组`(0)`，第一个偶数位置的值，和`(1)`，第一个奇数位置的值。如果元素的数量是偶数，这将很好地产生成对。
- en: This has the advantage of being quite short. The functions shown in the previous
    section are longer ways to solve the same problem.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个相当简短的优点。前一节中显示的函数是解决相同问题的更长的方法。
- en: 'This approach can be generalized. We can use the `*(args)` approach to generate
    a sequence-of-sequences that must be zipped together. It looks like the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以泛化。我们可以使用`*(args)`方法生成必须被压缩在一起的序列结构。它看起来像以下的样子：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will generate `n` slices: `flat[0::n]`, `flat[1::n]`, `flat[2::n]`, …,
    `flat[n-1::n]`. This collection of slices becomes the arguments to `zip()`, which
    then interleaves values from each slice.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成`n`个切片：`flat[0::n]`，`flat[1::n]`，`flat[2::n]`，…，`flat[n-1::n]`。这些切片的集合成为`zip()`的参数，然后交错地从每个切片中提取值。
- en: Recall that `zip()` truncates the sequence at the shortest `list`. This means
    that, if the `list` is not an even multiple of the grouping factor `n`, (`len(flat)%n
    != 0`), which is the final slice, won't be the same length as the others and the
    others will all be truncated. This is rarely what we want.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`zip()`会将序列截断为最短的`list`。这意味着，如果`list`不是分组因子`n`的偶数倍（`len(flat)%n != 0`），也就是最后一个切片，它的长度将不同于其他切片的长度，其他切片都将被截断。这很少是我们想要的。
- en: If we use the `itertools.zip_longest()` method, then we'll see that the final
    tuple will be padded with enough `None` values to make it have a length of `n`.
    In some cases, this padding is acceptable. In other cases, the extra values are
    undesirable.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`itertools.zip_longest()`方法，那么我们将看到最终的元组将填充足够的`None`值，使其长度为`n`。在某些情况下，这种填充是可以接受的。在其他情况下，额外的值是不希望的。
- en: The `list` slicing approach to grouping data is another way to approach the
    problem of structuring a flat sequence of data into blocks. As it is a general
    solution, it doesn't seem to offer too many advantages over the functions in the
    previous section. As a solution specialized for making two tuples from a flat
    last, it's elegantly simple.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`切片方法对数据进行分组是另一种处理将扁平数据结构化为块的方法。作为一种通用解决方案，它似乎并没有比前一节中的函数提供太多优势。作为专门用于从扁平数据中制作两个元组的解决方案，它非常简单。'
- en: Using reversed() to change the order
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用reversed()改变顺序
- en: 'There are times when we need a sequence reversed. Python offers us two approaches
    to this: the `reversed()` function and slices with reversed indices.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要一个反转的序列。Python为我们提供了两种方法：`reversed()`函数和使用反转索引的切片。
- en: 'For an example, consider performing a base conversion to hexadecimal or binary.
    The following is a simple conversion function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑将基数转换为十六进制或二进制。以下是一个简单的转换函数：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This function uses a recursion to yield the digits from the least significant
    to the most significant. The value of `x%b` will be the least significant digits
    of `x` in the base `b`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用递归从最不重要的位到最重要的位产生数字。`x%b`的值将是基数`b`中`x`的最不重要的数字。
- en: 'We can formalize it as following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其形式化如下：
- en: '![Using reversed() to change the order](graphics/B03652_04_13.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![使用reversed()改变顺序](graphics/B03652_04_13.jpg)'
- en: 'In many cases, we''d prefer the digits to be yielded in the reverse order.
    We can wrap this function with the `reversed()` function to swap the order of
    the digits:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们更喜欢以相反的顺序产生数字。我们可以使用`reversed()`函数包装这个函数，以交换数字的顺序：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `reversed()` function produces an iterable, but the argument value must
    be a sequence object. The function then yields the items from that object in the
    reverse order.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()`函数产生一个可迭代对象，但参数值必须是一个序列对象。然后该函数以相反的顺序产生该对象的项目。'
- en: We can do a similar kind of thing also with a slice such as `tuple(digits(x,
    b))[::-1]`. The slice, however, is not an iterator. A slice is a materialized
    object built from another materialized object. In this case, for such small collections
    of values, the distinction is minor. As the `reversed()` function uses less memory,
    it might be advantageous for larger collections.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用切片来做类似的事情，比如`tuple(digits(x, b))[::-1]`。然而，切片不是一个迭代器。切片是从另一个实例化对象构建的实例化对象。在这种情况下，对于这样小的值集合，区别是微不足道的。由于`reversed()`函数使用的内存较少，对于更大的集合来说可能更有优势。
- en: Using enumerate() to include a sequence number
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用enumerate()包括序列号
- en: Python offers the `enumerate()` function to apply index information to values
    in a sequence or iterable. It performs a specialized kind of wrap that can be
    used as part of an `unwrap(process(wrap(data)))` design pattern.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了`enumerate()`函数，将索引信息应用于序列或可迭代对象中的值。它执行一种特殊的包装，可以作为`unwrap(process(wrap(data)))`设计模式的一部分使用。
- en: 'It looks like the following code snippet:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像下面的代码片段：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `enumerate()` function transformed each input `item` into a pair with a
    sequence number and the original `item`. It''s vaguely similar to something as
    follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`函数将每个输入`item`转换为一个带有序列号和原始`item`的对。它与以下内容略有相似：'
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: An important feature of `enumerate()` is that the result is an iterable and
    it works with any iterable input.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`的一个重要特点是，结果是可迭代的，并且可以与任何可迭代的输入一起使用。'
- en: When looking at statistical processing, for example, the `enumerate()` function
    comes in handy to transform a single sequence of values into a more proper time
    series by prefixing each sample with a number.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在统计处理时，`enumerate()`函数非常方便，可以通过为每个样本加上一个数字，将单个值序列转换为更适当的时间序列。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw detailed ways to use a number of built-in reductions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了使用多种内置缩减的方法。
- en: We've used `any()` and `all()` to do essential logic processing. These are tidy
    examples of reductions using a simple operator such as `or` or `and`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`any()`和`all()`来进行基本逻辑处理。这些都是使用简单运算符如`or`或`and`的简洁示例。
- en: We've also looked at numeric reductions such as `len()` and `sum()`. We've applied
    these functions to create some higher-order statistical processing. We'll return
    to these reductions in [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"),
    *Recursions and Reductions*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了一些数值缩减，如`len()`和`sum()`。我们应用这些函数来创建一些高阶统计处理。我们将在[第6章](ch06.html "第6章。递归和缩减")*递归和缩减*中回顾这些缩减。
- en: We've also looked at some of the built-in mappings.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了一些内置映射。
- en: The `zip()` function merges multiple sequences. This leads us to look at using
    this in the context of structuring and flattening more complex data structures.
    As we'll see in examples in later chapters, nested data is helpful in some situations
    and flat data is helpful in others.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数合并多个序列。这使我们考虑在结构化和扁平化更复杂的数据结构的上下文中使用它。正如我们将在后面的章节中看到的例子，嵌套数据在某些情况下很有帮助，而扁平数据在其他情况下很有帮助。'
- en: The `enumerate()` function maps an iterable to a sequence of two tuples. Each
    two tuple has `(0)` as the sequence number and `(1)` as the original item.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`函数将可迭代对象映射到两个元组的序列。每个两元组都有`(0)`作为序列号和`(1)`作为原始项目。'
- en: The `reversed()` function iterates over the items in a sequence object with
    their original order reversed. Some algorithms are more efficient at producing
    results in one order, but we'd like to present these results in the opposite order.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()`函数按照它们的原始顺序迭代序列对象中的项目。一些算法更有效地按照一种顺序产生结果，但我们希望以相反的顺序呈现这些结果。'
- en: In the next chapter, we'll look at the `mapping` and `reduction` functions that
    use an additional function as an argument to customize their processing. Functions
    that accept a function as an argument are our first examples of higher-order functions.
    We'll also touch on functions that return functions as a result.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看`mapping`和`reduction`函数，它们使用额外的函数作为参数来定制它们的处理。接受函数作为参数的函数是我们的第一个高阶函数的例子。我们还将涉及返回函数作为结果的函数。
