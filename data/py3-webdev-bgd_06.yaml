- en: Chapter 6. Building a Wiki
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 建立维基
- en: Nowadays, a wiki is a well-known tool to enable people to maintain a body of
    knowledge in a cooperative way. Wikipedia (http://wikipedia.org) might be the
    most famous example of a wiki today, but countless numbers of forums use some
    sort of wiki and many tools and libraries exist to implement a wiki application.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，维基是一个广为人知的工具，它能够以合作的方式让人们维护知识体系。维基百科（http://wikipedia.org）可能是今天最著名的维基示例，但无数的论坛都使用某种维基，并且存在许多工具和库来实现维基应用程序。
- en: In this chapter, we will develop a wiki of our own, and in doing so, we will
    focus on two important concepts in building web applications. The first one is
    the design of the data layer. We will build upon the simple framework created
    in the previous chapter and we will try to establish where the limitations in
    our current implementation lie. The wiki application we will be building is a
    good test case as it is considerably more complex than the book database developed
    earlier.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发自己的维基，在这个过程中，我们将关注构建Web应用程序的两个重要概念。第一个是数据层的设计。我们将基于上一章创建的简单框架进行构建，并尝试确定我们当前实现中的局限性。我们将构建的维基应用程序是一个很好的测试案例，因为它比之前开发的图书数据库要复杂得多。
- en: The second one is input validation. A wiki is normally a very public application
    that might not even employ a basic authentication scheme to identify users. This
    makes contributing to a wiki very simple, yet also makes a wiki vulnerable in
    the sense that anyone can put anything on a wiki page. It's therefore a good idea
    to verify the content of any submitted change. You may, for example, strip out
    any HTML markup or disallow external links.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二个是输入验证。维基通常是一个非常公开的应用程序，甚至可能不采用基本的身份验证方案来识别用户。这使得向维基贡献变得非常简单，但同时也使得维基在某种程度上容易受到攻击，因为任何人都可以在维基页面上放置任何内容。因此，验证任何提交的更改内容是一个好主意。例如，您可以移除任何HTML标记或禁止外部链接。
- en: Enhancing user interactions in a meaningful way is often closely related with
    input validation. As we saw in the previous chapter, client-side input validation
    helps prevent the user from entering unwanted input and is therefore a valuable
    addition to any application but is not a substitute for server-side input validation
    as we cannot trust the outside world not to try and access our server in unintended
    ways.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以有意义的方式增强用户交互通常与输入验证密切相关。正如我们在上一章中看到的，客户端输入验证有助于防止用户输入不希望的内容，因此它是任何应用程序的有价值补充，但不能替代服务器端输入验证，因为我们不能信任外部世界不会试图以未预期的方式访问我们的服务器。
- en: We will address both input validation and user interaction explicitly when we
    develop our wiki application in this chapter.
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们在本章开发我们的维基应用程序时，我们将明确处理输入验证和用户交互。
- en: 'In this chapter, we will:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Implement a data layer for a wiki application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为维基应用程序实现数据层
- en: Implement a delivery layer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现交付层
- en: Take a good look at input validation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细研究输入验证
- en: Encounter jQuery UI's dialog widget
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到jQuery UI的对话框小部件
- en: So let's get on with it...
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始吧...
- en: The data layer
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据层
- en: A wiki consists of quite a number of distinct entities we can indentify. We
    will implement these entities and the relations that exist between them by reusing
    the Entity/Relation framework developed earlier.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个维基由许多我们可以识别的独立实体组成。我们将通过重用之前开发的实体/关系框架来实现这些实体及其之间的关系。
- en: Time for action designing the wiki data model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计维基数据模型的时间
- en: 'As with any application, when we start developing our wiki application we must
    first take a few steps to create a data model that can act as a starting point
    for the development:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何应用程序一样，当我们开始开发我们的维基应用程序时，我们必须首先采取一些步骤来创建一个可以作为开发起点的数据模型：
- en: Identify each entity that plays a role in the application. This might depend
    on the requirements. For example, because we want the user to be able to change
    the title of a topic and we want to archive revisions of the content, we define
    separate Topic and Page entities.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别在应用程序中扮演角色的每个实体。这可能会取决于需求。例如，因为我们希望用户能够更改主题的标题，并且我们希望存档内容的修订版本，所以我们定义了单独的主题和页面实体。
- en: 'Identify direct relations between entities. Our decision to define separate
    Topic and Page entities implies a relation between them, but there are more relations
    that can be identified, for example, between Topic and Tag. Do not specify indirect
    relations: All topics marked with the same tag are in a sense related, but in
    general, it is not necessary to record these indirect relations as they can easily
    be inferred from the recorded relation between topics and tags.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别实体之间的直接关系。我们决定定义独立的主题和页面实体意味着它们之间存在关系，但还可以识别更多关系，例如主题和标签之间的关系。不要指定间接关系：所有标记相同标签的主题在某种程度上是相关的，但通常没有必要记录这些间接关系，因为它们可以从记录的主题和标签之间的关系中轻易推断出来。
- en: The image shows the different entities and relations we can identify in our
    wiki application. Note that like in the books application, a User is a separate
    entity that is distinct from any user in, for example, a password database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图像显示了我们在维基应用程序中可以识别的不同实体和关系。请注意，与书籍应用程序一样，用户是一个独立的实体，与例如密码数据库中的任何用户都不同。
- en: 'In the diagram, we have illustrated the fact that a `Topic` may have more than
    one `Page` while a `Page` refers to a single User in a rather informal way by
    representing Page as a stack of rectangles and `User` as a single rectangle. In
    this manner, we can grasp the most relevant aspects of the relations at a glance.
    When we want to show more relations or relations with different characteristics,
    it might be a good idea to use more formal methods and tools. A good starting
    point is the Wikipedia entry on UML: [http://en.wikipedia.org/wiki/Unified_Modelling_Language](http://en.wikipedia.org/wiki/Unified_Modelling_Language).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们说明了这样一个事实：一个`主题`可能拥有多个`页面`，而`页面`通过将页面表示为矩形堆叠和将`用户`表示为单个矩形的方式，以一种相当非正式的方式引用单个用户。这样，我们可以一眼抓住关系的最相关方面。当我们想要显示更多关系或具有不同特性的关系时，使用更正式的方法和工具可能是个好主意。一个好的起点是维基百科上的UML条目：[http://en.wikipedia.org/wiki/Unified_Modelling_Language](http://en.wikipedia.org/wiki/Unified_Modelling_Language)。
- en: '![Time for action designing the wiki data model](img/3746OS_06_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![设计维基数据模型的时间](img/3746OS_06_01.jpg)'
- en: What just happened?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: With the entities and relations in our data model identified, we can have a
    look at their specific qualities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据模型中确定了实体和关系之后，我们可以看看它们的特定品质。
- en: The basic entity in a wiki is a `Topic`. A topic, in this context, is basically
    a title that describes what this topic is about. A topic has any number of associated
    Pages. Each instance of a `Page` represents a revision; the most recent revision
    is the *current* version of a topic. Each time a topic is edited, a new revision
    is stored in the database. This way, we can simply revert to an earlier version
    if we made a mistake or compare the contents of two revisions. To simplify identifying
    revisions, each revision has a modification date. We also maintain a relation
    between the `Page` and the `User` that modified that `Page`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 维基中的基本实体是`主题`。在这个上下文中，主题基本上是一个描述该主题内容的标题。一个主题可以关联任意数量的页面。每个`页面`实例代表一个修订版；最新的修订版是主题的*当前版本*。每次编辑主题时，都会在数据库中存储一个新的修订版。这样，如果我们犯了错误，可以简单地回滚到早期版本，或者比较两个修订版的内容。为了简化修订版的识别，每个修订版都有一个修改日期。我们还维护了`页面`和修改该`页面`的`用户`之间的关系。
- en: In the wiki application that we will develop, it is also possible to associate
    any number of tags with a topic. A `Tag` entity consists simply of a `tag` attribute.
    The important part is the relation that exists between the `Topic` entity and
    the `Tag` entity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将要开发的维基应用程序中，也可以将任意数量的标签与主题关联。`标签`实体简单地由一个`标签`属性组成。重要的是存在于`主题`实体和`标签`实体之间的关系。
- en: Like a `Tag`, a `Word` entity consists of a single attribute. Again, the important
    bit is the relation, this time, between a `Topic` and any number of `Words`. We
    will maintain this relation to reflect the words used in the current versions
    (that is, the last revision of a `Page)` of a `Topic`. This will allow for fairly
    responsive full text search facilities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与`标签`类似，`单词`实体由一个属性组成。同样，重要的是关系，这次是`主题`与任意数量的`单词`之间的关系。我们将维护这种关系以反映主题当前版本（即页面的最后修订版）中使用的单词。这将允许我们有相当响应的全文本搜索功能。
- en: 'The final entity we encounter is the `Image` entity. We will use this to store
    images alongside the pages with text. We do not define any relation between topics
    and images. Images might be referred to in the text of the topic, but besides
    this textual reference, we do not maintain a formal relation. If we would like
    to maintain such a relation, we would be forced to scan for image references each
    time a new revision of a page was stored, and probably we would need to signal
    something if a reference attempt was made to a non-existing image. In this case,
    we choose to ignore this: references to images that do not exist in the database
    will simply show nothing:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的最后一个实体是`Image`实体。我们将使用它来存储与文本页面一起的图片。我们不会在主题和图片之间定义任何关系。图片可能会在主题的文本中提到，但除了这个文本引用之外，我们不会维护正式的关系。如果我们想维护这样的关系，每次存储页面的新修订时，我们就必须扫描图片引用，并且如果尝试引用一个不存在的图片，我们可能还需要发出某种信号。在这种情况下，我们选择忽略这一点：数据库中不存在的图片引用将简单地显示为无：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Because we can reuse the entity and relation modules we developed earlier,
    the actual implementation of the database layer is straightforward (full code
    is available as `wikidb.py)`. After importing both modules, we first define a
    subclass of `Entity` for each entity we identified in our data model. All these
    classes are used as is, so they have only a `pass` statement as their body.**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**因为我们可以重用我们之前开发的实体和关系模块，所以数据库层的实际实现很简单（完整代码作为`wikidb.py`提供）。在导入这两个模块后，我们首先为我们在数据模型中确定的所有实体定义一个`Entity`的子类。所有这些类都是直接使用的，因此它们的主体只有一个`pass`语句。**'
- en: '**Likewise, we define a subclass of `Relation` for each relation we need to
    implement in our wiki application.**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**同样，我们为我们的wiki应用程序中需要实现的每个关系定义一个`Relation`的子类。**'
- en: '**All these `Entity` and `Relation` subclasses still need the initialization
    code to be called once each time the application starts and that is where the
    convenience function `initdb()` comes in. It bundles the initialization code for
    each entity and relation (highlighted).**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有这些`Entity`和`Relation`子类仍然需要在每次应用程序启动时调用一次初始化代码，这就是便利函数`initdb()`的作用所在。它捆绑了每个实体和关系的初始化代码（突出显示）。**'
- en: '**Many entities we define here are simple but a few warrant a closer inspection.
    The `Page` entity contains a `modified` column that has a `non null` constraint.
    It also has a default: `CURRENT_TIMESTAMP` (highlighted). This default is SQLite
    specific (other database engines will have other ways of specifying such a default)
    and will initialize the modified column to the current date and time if we create
    a new `Page` record without explicitly setting a value.**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们在这里定义的许多实体都很简单，但其中一些需要更仔细的检查。`Page`实体包含一个`modified`列，该列有一个`non null`约束。它还有一个默认值：`CURRENT_TIMESTAMP`（突出显示）。这个默认值是SQLite特定的（其他数据库引擎将会有其他指定此类默认值的方式），如果我们创建一个新的`Page`记录而没有明确设置值，它将初始化修改列到当前日期和时间。**'
- en: '**The `Image` entity also has a definition that is a little bit different:
    its `data` column is explicitly defined to have a `blob` affinity. This will enable
    us to store binary data without any problem in this table, something we need to
    store and retrieve the binary data contained in an image. Of course, SQLite will
    happily store anything we pass it in this column, but if we pass it an array of
    bytes (not a string that is), that array is stored as is.**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Image`实体也有一个稍微不同的定义：它的`data`列被明确定义为具有`blob`亲和力。这将使我们能够在这个表中无任何问题地存储二进制数据，这是我们存储和检索图片中包含的二进制数据所必需的。当然，SQLite会高兴地存储我们传递给这个列的任何东西，但如果我们传递一个字节数组（而不是字符串），那么这个数组将按原样存储。**'
- en: '**# The delivery layer'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 传输层**'
- en: 'With the foundation, that is, the data layer in place, we build on it when
    we develop the delivery layer. Between the delivery layer and the database layer,
    there is an additional layer that encapsulates the domain-specific knowledge (that
    is, it knows how to verify that the title of a new `Topic` entity conforms to
    the requirements we set for it before it stores it in the database):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据层的基础上，即数据层就绪后，我们在开发传输层时在此基础上构建。在传输层和数据库层之间，还有一个额外的层，它封装了特定领域的知识（即，它知道如何验证新`Topic`实体的标题是否符合我们在将其存储在数据库之前设定的要求）：
- en: '![The delivery layer](img/3746OS_06_09.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![传输层](img/3746OS_06_09.jpg)'
- en: Each different layer in our application is implemented in its own file or files.
    It is easy to get confused, so before we delve further into these files, have
    a look at the following table. It lists the different files that together make
    up the wiki application and refers to the names of the layers introduced in [Chapter
    1](ch01.html "Chapter 1. Choosing Your Tools"), *Choosing Your Tools* (shown again
    in the previous image).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中的每个不同层都在其自己的文件或文件中实现。很容易混淆，所以在我们进一步深入研究这些文件之前，先看看以下表格。它列出了组成wiki应用程序的不同文件，并引用了在[第1章](ch01.html
    "第1章。选择你的工具")中引入的层名称，“选择你的工具”（如前图所示）。
- en: '| File | Layer |   |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 层 |   |'
- en: '| --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `wikiweb.py` | Content Delivery Framework | Our main CherryPy application
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `wikiweb.py` | 内容交付框架 | 我们的主要CherryPy应用程序 |'
- en: '| `wiki.py` | Object Relational Mapper | The domain specific part; Imported
    by `wikiweb.py` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `wiki.py` | 对象关系映射器 | 领域特定部分；由`wikiweb.py`导入 |'
- en: '| `wikidb.py` | Object Relational Mapper | The domain independent part; Imported
    by `wikiweb.py` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `wikidb.py` | 对象关系映射器 | 领域无关部分；由`wikiweb.py`导入 |'
- en: '| `basepage.html` | Structural Representation | Used by `wikiweb.py` to serve
    pages to the client |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `basepage.html` | 结构表示 | 由`wikiweb.py`用于向客户端提供页面 |'
- en: '| `wikiweb.js` | Graphical User Interface | Referred to in `basepage.html`;
    Implements user interaction like mouse clicks. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `wikiweb.js` | 图形用户界面 | 在`basepage.html`中引用；实现鼠标点击等用户交互。 |'
- en: '| `wiki.css` | Graphical User Interface | Referred to in `basepage.html`; Implements
    the layout of graphical components. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `wiki.css` | 图形用户界面 | 在`basepage.html`中引用；实现图形组件的布局。 |'
- en: We'll focus on the main CherryPy application first to get a feel for the behavior
    of the application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先关注主要CherryPy应用程序，以了解应用程序的行为。
- en: Time for action implementing the opening screen
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施开篇屏幕的时间
- en: 'The opening screen of the wiki application shows a list of all defined topics
    on the right and several ways to locate topics on the left. Note that it still
    looks quite rough because, at this point, we haven''t applied any style sheets:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: wiki应用程序的开篇屏幕显示了右侧所有定义的主题列表以及几种在左侧定位主题的方法。请注意，它看起来仍然相当粗糙，因为我们还没有应用任何样式表：
- en: '![Time for action implementing the opening screen](img/3746_06_002.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![实施开篇屏幕的时间](img/3746_06_002.jpg)'
- en: 'Let us first take a few steps to identify the underlying structure. This structure
    is what we would like to represent in the HTML markup:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先采取一些步骤来识别底层结构。这个结构就是我们希望在HTML标记中表示的结构：
- en: Identify related pieces of information that are grouped together. These form
    the backbone of a structured web page. In this case, the search features on the
    left form a group of elements distinct from the list of topics on the right.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别出分组在一起的相关信息。这些构成了结构化网页的骨干。在这种情况下，左侧的搜索功能形成了一个与右侧主题列表不同的元素组。
- en: Identify distinct pieces of functionality within these larger groups. For example,
    the elements (input field and search button) that together make up the word search
    are such a piece of functionality, as are the tag search and the tag cloud.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些更大的组内识别出不同的功能部分。例如，组成单词搜索的元素（输入字段和搜索按钮）是这样的一个功能部分，标签搜索和标签云也是如此。
- en: Try to identify any hidden functionality, that is, necessary pieces of information
    that will have to be part of the HTML markup, but are not directly visible on
    a page. In our case, we have links to the jQuery and JQuery UI JavaScript libraries
    and links to CSS style sheets.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试识别任何隐藏的功能，即将成为HTML标记一部分的必要信息，但在页面上并不直接可见。在我们的例子中，我们有jQuery和JQuery UI JavaScript库的链接以及CSS样式表的链接。
- en: Identifying these distinct pieces will not only help to put together HTML markup
    that reflects the structure of a page, but also help to identify necessary functionality
    in the delivery layer because each of these functional pieces is concerned with
    specific information processed and produced by the server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 识别这些不同的部分不仅有助于组合出反映页面结构的HTML标记，而且有助于在交付层中识别必要的功能，因为每个功能部分都关注服务器处理和生成的特定信息。
- en: What just happened?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Let us look in somewhat more detail at the structure of the opening page that
    we identified.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看我们已识别的开篇页面的结构。
- en: Most notable are three search input fields to locate topics based on words occurring
    in their bodies, based on their actual title or based on tags associated with
    a topic. These search fields feature auto complete functionality that allows for
    comma-separated lists. In the same column, there is also room for a tag cloud,
    an alphabetical list of tags with font sizes dependent on the number of topics
    marked with that tag.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最值得注意的是三个搜索输入字段，可以根据它们正文中的单词、实际标题或与主题关联的标签来定位主题。这些搜索字段具有自动完成功能，允许使用逗号分隔的列表。在同一列中，还有一个用于显示标签云的空间，这是一个按字母顺序排列的标签列表，字体大小取决于带有该标签的主题数量。
- en: The structural components
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构组件
- en: 'The HTML markup for this opening page is shown next. It is available as the
    file `basepage.html` and the contents of this file are served by several methods
    in the `Wiki` class implementing the delivery layer, each with a suitable content
    segment. Also, some of the content will be filled in by AJAX calls, as we will
    see in a moment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该打开页面的HTML标记如下所示。它作为文件`basepage.html`提供，该文件的内容通过`Wiki`类实现的数据层中的多种方法提供，每种方法都包含合适的内容段。此外，一些内容将通过AJAX调用填充，正如我们稍后将看到的：
- en: '**Chapter6/basepage.html**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter6/basepage.html**'
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The`<head>` element contains both links to CSS style sheets and`<script>` elements
    that refer to the jQuery libraries. This time, we choose again to retrieve these
    libraries from a public content delivery network.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`<head>`元素包含指向CSS样式表的链接和引用jQuery库的`<script>`元素。这次，我们再次选择从公共内容交付网络检索这些库。'
- en: The highlighted lines show the top-level`<div>` elements that define the structure
    of the page. In this case, we have identified a navigation part and a content
    part and this is reflected in the HTML markup.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的行显示了定义页面结构的顶级`<div>`元素。在这种情况下，我们已识别出导航部分和内容部分，并在HTML标记中反映了这一点。
- en: Enclosed in the navigation part are the search functions, each in their own`<div>`
    element. The content part contains just an interpolation placeholder `%s` for
    now, that will be filled in by the method that serves this markup. Just before
    the end of the body of the markup is a final`<script>` element that refers to
    a JavaScript file that will perform actions specific to our application and we
    will examine those later.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 导航部分包含搜索功能，每个功能都在自己的`<div>`元素中。内容部分目前只包含一个占位符`%s`，该占位符将由提供此标记的方法填充。在标记的末尾之前，有一个最终的`<script>`元素，它引用了一个将执行我们应用程序特定操作的JavaScript文件，我们将在稍后检查这些文件。
- en: The application methods
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序方法
- en: 'The markup from the previous section is served by methods of the `Wiki` class,
    an instance of which class can be mounted as a CherryPy application. The `index()`
    method, for example, is where we produce the markup for the opening screen (the
    complete file is available as `wikiweb.py` and contains several other methods
    that we will examine in the following sections):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的标记由`Wiki`类的`index()`方法提供，该类的一个实例可以挂载为CherryPy应用程序。例如，`index()`方法是我们生成打开屏幕（完整文件作为`wikiweb.py`提供，并包含我们将在以下部分检查的几个其他方法）的标记的地方：
- en: '**Chapter6/wikiweb.py**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter6/wikiweb.py**'
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we define the markup for every topic we will display in the main area
    of the opening page (highlighted). The markup consists of a list item that contains
    an anchor element that refers to a URL relative to the page showing the opening
    screen. Using relative URLs allows us to mount the class that implements this
    part of the application anywhere in the tree that serves the CherryPy application.
    The `show()` method that will serve this URL takes a topic parameter whose value
    is interpolated in the next line for each topic that is present in the database.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为主页主要区域（突出显示）中将要显示的每个主题定义标记。该标记由一个包含锚元素的列表项组成，该锚元素引用显示打开屏幕的页面的相对URL。使用相对URL允许我们将实现此应用程序部分的功能的类挂载在为CherryPy应用程序提供服务的树中的任何位置。将提供此URL的`show()`方法接受一个主题参数，其值将在下一行中为数据库中存在的每个主题进行插值。
- en: The result is joined to a single string that is interpolated into yet another
    string that encapsulates all the list items we just generated in an unordered
    list (a`<ul>` element in the markup) and this is finally returned as the interpolated
    content of the `basepage` variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 结果被连接成一个字符串，然后将其插值到另一个字符串中，该字符串封装了我们刚刚生成的所有列表项，在一个无序列表（标记中的`<ul>`元素）中，并最终作为`basepage`变量的插值内容返回。
- en: 'In the definition of the `index()` method, we see a pattern that will be repeated
    often in the wiki application: methods in the delivery layer, like `index()`,
    concern themselves with constructing and serving markup to the client and delegate
    the actual retrieval of information to a module that knows all about the wiki
    itself. Here the list of topics is produced by the `wiki.gettopiclist()` function,
    while `index()` converts this information to markup. Separation of these activities
    helps to keep the code readable and therefore maintainable.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index()` 方法的定义中，我们看到一个在维基应用程序中经常重复的模式：交付层中的方法，如 `index()`，关注于构建和向客户端提供标记，并将实际检索信息委托给一个了解维基本身的所有信息的模块。在这里，主题列表是由
    `wiki.gettopiclist()` 函数生成的，而 `index()` 将这些信息转换为标记。这些活动的分离有助于保持代码的可读性，从而便于维护。
- en: Time for action implementing a wiki topic screen
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现维基主题屏幕的行动时间
- en: 'When we request a URL of the form `show?topic=value`, this will result in calling
    the `show()` method. If `value` equals an existing topic, the following (as yet
    unstyled) screen is the result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求形式为 `show?topic=value` 的 URL 时，这将导致调用 `show()` 方法。如果 `value` 等于一个现有主题，以下（尚未样式化）的屏幕就是结果：
- en: '![Time for action implementing a wiki topic screen](img/3746_06_003.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![实现维基主题屏幕的行动时间](img/3746_06_003.jpg)'
- en: 'Just as for the opening screen, we take steps to:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如首页一样，我们采取了以下步骤：
- en: Identify the main areas on screen
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别屏幕上的主要区域
- en: Identify specific functionality
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别特定的功能
- en: Identify any hidden functionality
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别任何隐藏的功能
- en: The page structure is very similar to the opening screen, with the same navigational
    items, but instead of a list of topics, we see the content of the requested topic
    together with some additional information like the tags associated with this subject
    and a button that may be clicked to edit the contents of this topic. After all,
    collaboratively editing content is what a Wiki is all about.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 页面结构与首页非常相似，具有相同的导航项，但与主题列表不同，我们看到了请求的主题内容以及一些附加信息，如与该主题相关的标签和一个可以点击以编辑该主题内容的按钮。毕竟，协同编辑内容是维基的核心所在。
- en: We deliberately made the choice not to refresh the contents of just a part of
    the opening screen with an AJAX call, but opted instead for a simple link that
    replaces the whole page. This way, there will be an unambiguous URL in the address
    bar of the browser that will point at the topic. This allows for easy bookmarking.
    An AJAX call would have left the URL of the opening screen that is visible in
    the address bar of the browser unaltered and although there are ways to alleviate
    this problem, we settle for this simple solution here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意选择不通过 AJAX 调用仅刷新首页的一部分内容，而是选择了一个简单的链接来替换整个页面。这样，浏览器地址栏中将有一个明确的 URL 指向该主题。这允许轻松地进行书签。如果使用
    AJAX 调用，浏览器地址栏中可见的首页 URL 将保持不变，尽管有方法可以缓解这个问题，但我们在这里选择了这个简单的解决方案。
- en: What just happened?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: As the main structure we identified is almost identical to the one for the opening
    page, the `show()` method will reuse the markup in `basepage.html`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们确定的主要结构与首页几乎完全相同，因此 `show()` 方法将重用 `basepage.html` 中的标记。
- en: '**Chapter6/wikiweb.py**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6章/wikiweb.py**'
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `show()` method delegates most of the work to the `wiki.gettopic()` method
    (highlighted) that we will examine in the next section and concentrates on creating
    the markup it will deliver to the client. `wiki.gettopic()` will return a tuple
    that consists of both the current content of the topic and a list of tags.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`show()` 方法将大部分工作委托给下一节将要讨论的 `wiki.gettopic()` 方法（已突出显示），并专注于创建将发送给客户端的标记。`wiki.gettopic()`
    将返回一个元组，其中包含主题的当前内容和与该主题相关联的标签列表。'
- en: Those tags are converted to`<li>` elements with anchors that point to the `searchtags`
    URL. This list of tags provides a simple way for the reader to find related topics
    with a single click. The `searchtags` URL takes a `tags` argument so a single`<li>`
    element constructed this way may look like this:`<li><a href="http://searchtags?tags=Python">Python</a></li>`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签被转换为指向 `searchtags` URL 的锚点的 `<li>` 元素。这个标签列表为读者提供了一个简单的方法，通过单次点击即可找到相关主题。`searchtags`
    URL 接受一个 `tags` 参数，因此这样构造的单个 `<li>` 元素可能看起来像这样：`<li><a href="http://searchtags?tags=Python">Python</a></li>`。
- en: The content and the clickable list of tags are embedded in the markup of the
    `basepage` together with an anchor that points to the `edit` URL. Later, we will
    style this anchor to look like a button and when the user clicks it, it will present
    a page where the content may be edited.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 内容和可点击的标签列表嵌入在`basepage`的标记中，以及一个指向`edit` URL的锚点。稍后，我们将为此锚点设置样式，使其看起来像按钮，当用户点击它时，它将显示一个可以编辑内容的页面。
- en: Time for action editing wiki topics
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑wiki主题的时间
- en: 'In the previous section, we showed how to present the user with the contents
    of a topic but a wiki is not just about finding topics, but must present the user
    with a way to edit the content as well. This edit screen is presented in the following
    screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了如何向用户展示主题的内容，但wiki不仅仅是关于找到主题，还必须向用户提供一种编辑内容的方式。以下截图显示了此编辑屏幕：
- en: '![Time for action editing wiki topics](img/3746_06_004.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![编辑wiki主题的时间](img/3746_06_004.jpg)'
- en: 'Besides the navigation column on the left, within the edit area, we can point
    out the following functionality:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了左侧的导航栏外，在编辑区域内，我们还可以指出以下功能：
- en: Elements to alter the title of the subject.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于更改主题标题的元素。
- en: Modify the tags (if any) associated with the topic.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改与主题关联的标签（如果有）。
- en: A large text area to edit the contents of the topic. On the top of the text
    area, we see a number of buttons that can be used to insert references to other
    topics, external links, and images.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大文本区域用于编辑主题的内容。在文本区域的顶部，我们可以看到一些按钮，可以用来插入对其他主题、外部链接和图片的引用。
- en: A **Save** button that will submit the changes to the server.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将更改提交到服务器的**保存**按钮。
- en: What just happened?
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'The `edit()` method in `wikiweb.py` is responsible for showing the edit screen
    as well as processing the information entered by the user, once the save button
    is clicked:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`wikiweb.py`中的`edit()`方法负责显示编辑屏幕以及处理用户点击保存按钮后输入的信息：'
- en: '**Chapter6/wikiweb.py**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6章/wikiweb.py**'
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first priority of the `edit()` method is to verify that the user is logged
    in as we want only known users to edit the topics. By setting the `returntopage`
    parameter to true, the `checkauth()` method will return to this page once the
    user is authenticated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit()`方法的第一个优先级是验证用户是否已登录，因为我们只想让已知的用户编辑主题。通过将`returntopage`参数设置为true，`checkauth()`方法将在用户验证后返回此页面。'
- en: The `edit()` method is designed to present the edit screen for a topic as well
    as to process the result of this editing when the user clicks the **Save** button
    and therefore takes quite a number of parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit()` 方法旨在显示主题的编辑屏幕，并在用户点击**保存**按钮时处理此编辑的结果，因此需要相当多的参数。'
- en: The distinction is made based on the `content` parameter. If this parameter
    is not present (highlighted), the method will produce the markup to show the various
    elements in the edit screen. If the content parameter is not equal to `None`,
    the `edit()` method was called as a result of submitting the content of the form
    presented in the edit screen, in which case, we delegate the actual update of
    the content to the `wiki.updatetopic()` method. Finally, we redirect the client
    to a URL that will show the edited content again in its final form without the
    editing tools.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 区分是基于`content`参数。如果此参数不存在（高亮显示），则方法将生成标记来显示编辑屏幕中的各种元素。如果内容参数不等于`None`，则`edit()`方法是在提交编辑屏幕中显示的表单内容后调用的，在这种情况下，我们将实际更新内容的工作委托给`wiki.updatetopic()`方法。最后，我们将客户端重定向到将再次以最终形式显示编辑内容的URL，而不显示编辑工具。
- en: At this point, you may wonder what all this business is about with both a `topic`
    and an `originaltopic` parameter. In order to allow the user to change the title
    of the topic while that title is also used to find the topic entity that we are
    editing, we pass the title of the topic as a hidden variable in the edit form,
    and use this value to retrieve the original topic entity, a ploy necessary because,
    at this point, we may have a new title and yet have to find the associated topic
    that still resides in the database with the old title.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道为什么会有`topic`和`originaltopic`参数。为了允许用户在标题被用于查找我们正在编辑的主题实体时更改主题的标题，我们将主题的标题作为隐藏变量传递到编辑表单中，并使用此值检索原始主题实体，这是必要的策略，因为在此点，我们可能有一个新的标题，但仍然需要找到仍然以旧标题存在于数据库中的相关主题。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Cross Site Request Forgery**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**'
- en: When we process the data sent to the `edit()` function we make sure that only
    authenticated users submit anything. Unfortunately, this might not be enough if
    the user is tricked into sending an authenticated request on behalf of someone
    else. This is called **Cross Site Request Forgery** (CSRF) and although there
    are ways to prevent this, these methods are out of scope for this example. Security
    conscious people should read up on these exploits, however, and a good place to
    start is [http://www.owasp.org/index.php/Main_Page](http://www.owasp.org/index.php/Main_Page)
    and for Python-specific discussions [http://www.pythonsecurity.org/](http://www.pythonsecurity.org/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理发送给`edit()`函数的数据时，我们确保只有经过认证的用户提交任何内容。不幸的是，如果用户被诱骗代表其他人发送经过认证的请求，这可能还不够。这被称为**跨站请求伪造**（CSRF），尽管有防止这种攻击的方法，但这些方法超出了本例的范围。然而，有安全意识的人应该了解这些漏洞，一个好的起点是[http://www.owasp.org/index.php/Main_Page](http://www.owasp.org/index.php/Main_Page)，以及针对Python的特定讨论[http://www.pythonsecurity.org/](http://www.pythonsecurity.org/)。
- en: Pop quiz
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: What other attribute of the `Topic` entity could we have passed to retrieve
    a reference to the topic we are editing?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将哪个`Topic`实体的属性传递以获取我们正在编辑的主题的引用？
- en: Additional functionality
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他功能
- en: In the opening screen as well as in the pages showing the content of topics
    and in the editing page, there is a lot of hidden functionality. We already encountered
    several functions of the `wiki` module and we will examine them in detail in this
    section together with some JavaScript functionality to enhance the user interface.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开屏幕以及显示主题内容和编辑页面的页面上，有很多隐藏的功能。我们已经在`wiki`模块中遇到了几个函数，我们将在本节中详细检查它们，以及一些JavaScript功能来增强用户界面。
- en: Time for action selecting an image
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择图像的行动时间
- en: 'On the page that allows us to edit a topic, we have half hidden an important
    element: the dialog to insert an image. If the insert image button is clicked,
    a dialog is present, as shown in the following image:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在允许我们编辑主题的页面上，我们半隐藏了一个重要元素：插入图像的对话框。如果点击插入图像按钮，会出现一个对话框，如下面的图像所示：
- en: '![Time for action selecting an image](img/3746_06_005.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![选择图像的行动时间](img/3746_06_005.jpg)'
- en: 'Because a dialog is, in a way, a page of its own, we take the same steps to
    identify the functional components:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因为对话框在某种程度上是一个独立的页面，所以我们采取相同的步骤来识别功能组件：
- en: Identify the main structure
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别主要结构
- en: Identify specific functional components
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别特定功能组件
- en: Identify hidden functionality
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别隐藏功能
- en: The dialog consists of two forms. The top one consists of an input field that
    can be used to look for images with a given title. It will be augmented with jQuery
    UI's auto complete functionality.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框由两种形式组成。顶部的一种包含一个输入字段，可以用来根据给定的标题查找图像。它将增加jQuery UI的自动完成功能。
- en: The second form gives the user the possibility to upload a new file while the
    rest of the dialog is filled with any number of images. Clicking on one of the
    images will close the dialog and insert a reference to that image in the text
    area of the edit page. It is also possible to close the dialog again without selecting
    an image by either clicking the small close button on the top-right or by pressing
    the *Escape* key.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式允许用户在上传新文件的同时，对话框中填充任意数量的图像。点击任意一个图像将关闭对话框，并在编辑页面的文本区域中插入对该图像的引用。也可以通过点击右上角的小关闭按钮或按*Esc*键不选择图像而再次关闭对话框。
- en: What just happened ?
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The whole dialog consists of markup that is served by the `images()` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 整个对话框由`images()`方法提供的标记组成。
- en: '**Chapter6/wikiweb.py**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter6/wikiweb.py**'
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is some trickiness here to understand well: from the `edit()` method,
    we call this `images()` method to provide the markup that we insert in the page
    that is delivered to the client requesting the `edit` URL, but because we have
    decorated the `images()` method with a `@cherrypy.expose` decorator, the `images()`
    method is visible from the outside and may be requested with the `images` URL.
    If accessed that way, CherryPy will take care of adding the correct response headers.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要很好理解的技巧：从`edit()`方法中，我们调用这个`images()`方法来提供我们插入到请求`edit` URL的客户端页面中的标记，但由于我们用`@cherrypy.expose`装饰器装饰了`images()`方法，所以`images()`方法对外部可见，并且可以通过`images`
    URL进行请求。如果以这种方式访问，CherryPy将负责添加正确的响应头。
- en: 'Being able to call this method this way is useful in two ways: because the
    dialog is quite a complex page with many elements, we may check how it looks without
    being bothered by it being part of a dialog, and we can use it as the target of
    the form that is part of the images dialog and that allows us to upload new images.
    As with the `edit()` method, the distinction is again made based on a whether
    a certain parameter is present. The parameter that serves this purpose is `file`
    and will contain a `file` object if this method is called in response to an image
    being submitted (highlighted).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 能够以这种方式调用此方法有两个用途：因为对话框是一个非常复杂的页面，包含许多元素，我们可能检查它的外观而不会被它作为对话框的一部分所打扰，并且我们可以将其用作图像对话框中表单的目标，该表单允许我们上传新的图像。与
    `edit()` 方法一样，区别再次基于是否存在某个参数。用于此目的的参数是 `file`，如果此方法在响应图像提交时被调用（已突出显示），则将包含一个 `file`
    对象。
- en: The `file` object is a `cherrypy.file` object, not a Python built in `file`
    object, and has several attributes, including an attribute called `file` that
    is a regular Python stream object. This Python stream object serves as an interface
    to a temporary file that CherryPy has created to store the uploaded file. We can
    use the streams `read()` method to get at its content.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 对象是一个 `cherrypy.file` 对象，不是一个 Python 内置的 `file` 对象，并且有几个属性，包括一个名为 `file`
    的属性，它是一个常规的 Python 流对象。这个 Python 流对象充当 CherryPy 创建的临时文件的接口，用于存储上传的文件。我们可以使用流的
    `read()` 方法来获取其内容。'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Sorry about all the references to `file`, I agree it is possibly a bit confusing.
    Read it twice if needed and relax. This summary may be convenient:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有关于 `file` 的引用，我同意这可能有点令人困惑。如果需要，请阅读两遍并放松。此摘要可能很有用：
- en: '**This item has a which is a**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**此项目有一个which是a**'
- en: The `images()` method `file` parameter `herrypy.file` object
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`images()` 方法的 `file` 参数 `herrypy.file` 对象'
- en: A `cherrypy.file` object `file` attribute Python `stream` object
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `cherrypy.file` 对象的 `file` 属性 Python `stream` 对象
- en: A Python `stream` object `name` attribute name of a file on disk
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python `stream` 对象的 `name` 属性，是磁盘上文件的名称
- en: The Python stream can belong to a number of classes where all implement the
    same API. Refer to [http://docs.python.org/py3k/library/functions.html#open](http://docs.python.org/py3k/library/functions.html#open)
    for details on Python streams.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python 流可以属于多个类，其中所有类都实现了相同的 API。有关 Python 流的详细信息，请参阅 [http://docs.python.org/py3k/library/functions.html#open](http://docs.python.org/py3k/library/functions.html#open)。
- en: The `cherrypy.file` also has a `content_type` attribute whose string representation
    we use together with the title and the binary data to create a new `Image` instance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`cherrypy.file` 还有一个 `content_type` 属性，其字符串表示形式我们与标题和二进制数据一起使用来创建一个新的 `Image`
    实例。'
- en: The next step is to present the HTML markup that will produce the dialog, possibly
    including the uploaded image. This markup contains two forms.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是展示将生成对话框的 HTML 标记，可能包括上传的图像。此标记包含两个表单。
- en: The first one (highlighted in the previous code snippet) consists of an input
    field and a submit button. The input field will be augmented with auto complete
    functionality as we will see when we examine `wikiweb.js`. The submit button will
    replace the selection of images when clicked. This is also implemented in `wikiweb.js`
    by adding a click handler that will perform an AJAX call to the `getimages` URL.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个（在上一个代码片段中突出显示）由一个输入字段和一个提交按钮组成。当我们在检查 `wikiweb.js` 时，我们将看到输入字段将增加自动完成功能。当点击提交按钮时，它将替换图像选择。这也在
    `wikiweb.js` 中实现，通过添加一个点击处理程序，该处理程序将对 `getimages` URL 执行 AJAX 调用。
- en: The next form is the file upload form. What makes it a file upload form is the`<input>`
    element of the type `file` (highlighted). Behind the scenes, CherryPy will store
    the contents of a file type`<input>` element in a temporary file and pass it to
    the method servicing the requested URL by submitting the form.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个形式是文件上传表单。使其成为文件上传表单的是类型为 `file` 的 `<input>` 元素（已突出显示）。幕后，CherryPy 将将文件类型
    `<input>` 元素的 内容存储在一个临时文件中，并通过提交表单将其传递给服务请求 URL 的方法。
- en: 'There is a final bit of magic to pay attention to: we insert the markup for
    the dialog as part of the markup that is served by the `edit()` method, yet the
    dialog only shows if the user clicks the insert image button. This magic is performed
    by jQuery UI''s dialog widget and we convert the`<div>` element containing the
    dialog''s markup by calling its `dialog` method, as shown in this snippet of markup
    served by the `edit()` method():'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点魔法需要注意：我们将对话框的标记作为 `edit()` 方法提供的标记的一部分插入，但对话框只有在用户点击插入图像按钮时才会显示。这种魔法是由jQuery
    UI的对话框小部件执行的，我们通过调用其 `dialog` 方法来转换包含对话框标记的 `<div>` 元素，如 `edit()` 方法提供的以下标记片段所示：
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By setting the `autoOpen` option to false, we ensure that the dialog remains
    hidden when the page is loaded, after all, the dialog should only be opened if
    the user clicks the insert image button.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `autoOpen` 选项设置为 false，我们确保在页面加载后对话框保持隐藏，毕竟，对话框只有在用户点击插入图像按钮时才应该打开。
- en: 'Opening the dialog is accomplished by several pieces of JavaScript (full code
    available as `wikiweb.js)`. The first piece associates a click handler with the
    insert image button that will pass the `open` option to the dialog, causing it
    to display itself:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 打开对话框是通过几段JavaScript代码完成的（完整代码作为 `wikiweb.js` 提供）。第一段代码将一个点击处理程序与插入图像按钮关联起来，该处理程序将
    `open` 选项传递给对话框，使其显示：
- en: '**Chapter6/wikiweb.js**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6章/wikiweb.js**'
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the default action of a dialog is to close itself when the *Escape*
    key is pressed, so we don't have to do anything about that.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对话框的默认操作是在按下 *Escape* 键时关闭自身，所以我们不必对此做任何事情。
- en: 'Within the dialog, we have to configure the images displayed there to insert
    a reference in the text area when clicked and then close the dialog. We do this
    by configuring a `live` handler for the `click` event. A `live` handler will apply
    to elements that match the selector (in this case, images with the `selectable-image`
    class) even if they are not present yet. This is crucial, as we may upload new
    images that are not yet present in the list of images shown when the dialog is
    first loaded:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话框中，我们必须配置显示的图像，以便在点击时在文本区域中插入引用，然后关闭对话框。我们通过配置一个 `live` 处理程序来为 `click` 事件完成此操作。一个
    `live` 处理程序将应用于匹配选择器（在这种情况下，具有 `selectable-image` 类的图像）的元素，即使它们尚未存在。这是至关重要的，因为我们可能上传新的图像，这些图像在对话框首次加载时尚未出现在图像列表中：
- en: '**Chapter6/wikiweb.js**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6章/wikiweb.js**'
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first activity of this handler is to close the dialog. The next step is
    to determine what text we would like to insert into the text area (highlighted).
    In this case, we have decided to represent a reference to an image within the
    database as a number followed by a description within angled brackets. For example,
    image number 42 in the database might be represented as`<42,"Picture of a shovel">`.
    When we examine the `render()` method in `wikiweb.py`, we will see how we will
    convert this angled bracket notation to HTML markup.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序的第一项活动是关闭对话框。下一步是确定我们想要插入文本区域（高亮显示）的文本。在这种情况下，我们决定将数据库中图像的引用表示为一个数字，后面跟着一个尖括号内的描述。例如，数据库中的图像编号42可能表示为`<42,"Picture
    of a shovel">`。当我们检查 `wikiweb.py` 中的 `render()` 方法时，我们将看到我们将如何将这种尖括号表示法转换为HTML标记。
- en: The remaining part of the function is concerned with inserting this reference
    into the`<textarea>` element. We therefore retrieve the jQuery object that matches
    our text area first (highlighted) and because such a selection is always an array
    and we need access to the underlying JavaScript functionality of the`<textarea>`
    element, we fetch the first element.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分涉及将此引用插入 `<textarea>` 元素。因此，我们首先检索匹配我们的文本区域（高亮显示）的jQuery对象，并且由于这样的选择始终是一个数组，我们需要访问
    `<textarea>` 元素的底层JavaScript功能，所以我们获取第一个元素。
- en: The `value` attribute of a`<textarea>` element holds the text that is being
    edited and we split this text into a part before the cursor position and a part
    after it and then combine it again with our image reference inserted. We then
    make sure the text area has the focus again (which might have shifted when the
    user was using the dialog) and position the cursor at a position that is just
    after the newly inserted text.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`<textarea>` 元素的 `value` 属性包含正在编辑的文本，我们将此文本分为光标位置之前的部分和之后的部分，然后再次将其与我们的图像引用组合。然后我们确保文本区域再次获得焦点（当用户使用对话框时可能会改变），并将光标定位在刚插入文本之后的位置。'
- en: Time for action implementing a tag cloud
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现标签云的时间到了
- en: One of the distinct pieces of functionality we identified earlier was a so called
    tag cloud.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前确定的一个独特功能是所谓的标签云。
- en: '![Time for action implementing a tag cloud](img/3746_06_006.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![实现标签云的时间](img/3746_06_006.jpg)'
- en: The tag cloud that is present in the navigation section of all pages shows an
    alphabetically sorted list of tags. The styling of the individual tags represents
    the relative number of topics that are marked with this tag. Clicking on the tags
    will show the list of associated topics. In this implementation, we vary just
    the font size but we could have opted for additional impact by varying the color
    as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有页面的导航部分中显示的标签云是一个按字母顺序排序的标签列表。单个标签的样式表示带有此标签的主题的相对数量。点击标签将显示相关主题的列表。在这个实现中，我们只改变了字体大小，但我们也可以选择通过改变颜色来增加额外的效果。
- en: 'Before we implement a tag cloud, we should take a step back and take a good
    look at what we need to implement:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现标签云之前，我们应该退后一步，仔细看看我们需要实现什么：
- en: We need to retrieve a list of tags
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要检索一个标签列表
- en: We need to sort them
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要对这些进行排序
- en: We need to present markup. This markup should contain links that will refer
    to a suitable URL that will represent a list of topics that are marked with this
    tag. Also, this markup must in some way indicate what the relative number of topics
    is that have this tag so it can be styled appropriately.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要展示标记。这个标记应该包含指向一个合适的URL的链接，该URL将表示带有此标签的主题列表。此外，这个标记必须以某种方式表明具有此标签的主题的相对数量，以便可以适当地进行样式化。
- en: The last requirement is again a matter of separating structure from representation.
    It is easier to adapt a specific style by changing a style sheet than to alter
    structural markup.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要求又是将结构从表示中分离出来的问题。通过更改样式表来适应特定的样式比更改结构标记更容易。
- en: What just happened?
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'If we look at the HTML that represents an example tag cloud, we notice that
    the tags are represented by`<span>` elements with a `class` attribute that indicates
    its weight. In this case, we divide the range of weights in five parts, giving
    us classes from `weight0` for the least important tag to `weight4` for the most
    important one:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看表示示例标签云的HTML，我们会注意到标签由具有表示其权重的`class`属性的`<span>`元素表示。在这种情况下，我们将权重的范围分为五个部分，从对最不重要的标签的`weight0`类到对最重要的标签的`weight4`类：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The actual font size we use to represent these weights is determined by the
    styles in `wiki.css:`
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来表示这些权重的实际字体大小由`wiki.css`中的样式决定。
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The tag cloud itself is delivered by the `tagcloud()` method in `wikiweb.py`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 标签云本身是由`wikiweb.py`中的`tagcloud()`方法提供的。
- en: '**Chapter6/wikiweb.py**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter6/wikiweb.py**'
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This method iterates over all tuples retrieved from `wiki.tagcloud()` (highlighted).
    These tuples consist of a weight and a tag name and these are transformed to links
    and encapsulated in a`<span>` element with a fitting `class` attribute:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历从`wiki.tagcloud()`（突出显示）检索到的所有元组。这些元组由一个权重和一个标签名称组成，并将它们转换为链接，并封装在一个具有合适`class`属性的`<span>`元素中：
- en: '**Chapter6/wiki.py**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter6/wiki.py**'
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `tagcloud()` function in `wiki.py` starts off by retrieving a list of all
    `Tag` objects and sorts them based on their `tag` attribute. Next, it iterates
    over all these tags and retrieves their associated topics (highlighted). It then
    checks if there really are topics by checking the length of the list of topics.
    Some tags may not have any associated topics and are not counted in this ranking
    operation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`wiki.py`中的`tagcloud()`函数首先检索所有`Tag`对象的列表，并根据它们的`tag`属性进行排序。接下来，它遍历所有这些标签，检索它们的相关主题（突出显示）。然后，它通过检查主题列表的长度来检查是否真的有主题。一些标签可能没有任何相关主题，并且不会计入这次排名操作。'
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When a tag is removed from a topic, we do not actually delete the tag itself
    if it no longer has any associated topics. This might lead to a buildup of unused
    tags and, if necessary, you might want to implement some clean-up scheme.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个标签从主题中移除时，如果它不再有任何相关主题，我们实际上不会删除该标签本身。这可能会导致未使用的标签积累，如果需要，你可能想实现一些清理方案。
- en: If a tag does have associated topics, the number of topics is added to the total
    and a tuple consisting of the tag name and the number of topics is appended to
    the `tagrank` list. Because our list of `Tag` objects was sorted, `tagrank` will
    be sorted as well when we have finished counting the topics.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个标签确实有相关主题，主题的数量将被加到总数中，并且一个包含标签名称和主题数量的元组将被附加到`tagrank`列表中。由于我们的`Tag`对象列表已经排序，当我们完成主题计数后，`tagrank`也将被排序。
- en: In order to determine the relative weight of the tags, we iterate again, this
    time over the `tagrank` list to find the maximum number of topics associated with
    any tag. Then, in a final iteration, we yield a tuple consisting of the tag name
    and it relative weight, where the relative weight is computed by dividing the
    number of topics by the maximum number we encountered (plus one, to prevent divide
    by zero errors). This weight will then be between zero and one (exclusive) and
    by multiplying this by 5 and rounding down to an integer, a whole number between
    0 and 4 (inclusive) is obtained.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定标签的相对权重，我们再次迭代，这次是遍历`tagrank`列表以找到与任何标签关联的主题的最大数量。然后，在最后的迭代中，我们提供一个包含标签名称及其相对权重的元组，其中相对权重是通过将主题数量除以我们遇到的最大数量（加一，以防止除以零错误）来计算的。这个权重将在零和一（不包括）之间，通过将这个数乘以5并向下取整到整数，可以得到一个介于0到4（包括）之间的整数。
- en: Time for action searching for words
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索单词的行动时间
- en: 'To be able to find a list of all topics which contain one or more specific
    words, we present the user with a search form in the navigation area. These are
    some of the considerations when designing such a form:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够找到包含一个或多个特定单词的所有主题的列表，我们在导航区域向用户提供一个搜索表单。在设计此类表单时需要考虑以下因素：
- en: The user must be able to enter more than one word to find topics with all those
    words in their content
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须能够输入多个单词以找到包含所有这些单词的内容的主题
- en: Searching should be case insensitive
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索应该是大小写不敏感的
- en: Locating those topics should be fast even if we have a large number of topics
    with lots of text
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位这些主题应该很快，即使我们有很多主题并且文本量很大
- en: Auto completion would be helpful to aid the user in specifying words that are
    actually part of the content of some topic
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动完成将有助于帮助用户指定实际上是某些主题内容部分的单词
- en: All these considerations will determine how we will implement the functionality
    in the delivery layer and on the presentation side.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些考虑因素将决定我们如何在交付层和展示层实现该功能。
- en: What just happened?
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: The search options in the navigation area and the tag entry field in the edit
    screen all feature autocomplete functionality. We encountered autocomplete functionality
    before in the previous chapter where it was employed to show a list of titles
    and authors.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 导航区域中的搜索选项和在编辑屏幕中的标签输入字段都具备自动完成功能。我们在上一章中遇到了自动完成功能，当时它被用来显示标题和作者列表。
- en: 'With the word and tag search fields in the wiki application, we would like
    to go one step further. Here we would like to have auto completion on the list
    of items separated by commas. The illustrations show what happens if we type a
    single word and what happens when a second word is typed in:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在维基应用程序中的单词和标签搜索字段中，我们希望更进一步。在这里，我们希望对以逗号分隔的项目列表进行自动完成。插图显示了如果我们输入一个单词会发生什么，以及当我们输入第二个单词时会发生什么：
- en: '![What just happened?](img/3746_06_007.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/3746_06_007.jpg)'
- en: We cannot simply send the list of items complete with commas to the server because
    in that case we could not impose a minimum character limit. It would work for
    the first word of course, but once the first word is present in the input field,
    each subsequent character entry would result in a request to the server whereas
    we would like this to happen when the minimum character count for the second word
    is reached.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将带有逗号的物品列表发送到服务器，因为在那种情况下，我们无法强制设置最小字符限制。当然，对于第一个单词来说，这是可行的，但一旦第一个单词出现在输入字段中，每个后续字符的输入都会导致向服务器发送请求，而我们所希望的是，当第二个单词的最小字符数达到时才发生。
- en: Fortunately, the jQuery UI website already shows an example of how to use the
    autocomplete widget in exactly this situation (check the example at [http://jqueryui.com/demos/autocomplete/#multiple-remote)](http://jqueryui.com/demos/autocomplete/#multiple-remote)).
    As this online example is fairly well explained in its comments, we will not list
    it here, but note that the trick lies in the fact that instead of supplying the
    autocomplete widget with just a source URL, it is also given a callback function
    that will be invoked instead of retrieving information directly. This callback
    has access to the string of comma-separated items in the input field and can call
    the remote source with just the last item in the list.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，jQuery UI网站已经展示了如何在这种情况下使用自动完成小部件的示例（请查看[http://jqueryui.com/demos/autocomplete/#multiple-remote)](http://jqueryui.com/demos/autocomplete/#multiple-remote)中的示例）。由于这个在线示例的注释中解释得相当清楚，我们这里不再列出，但请注意，技巧在于，除了向自动完成小部件提供源URL之外，还提供了一个回调函数，该函数将代替直接检索信息而被调用。此回调函数可以访问输入字段中的逗号分隔项字符串，并且可以仅使用列表中的最后一个项调用远程源。
- en: On the delivery side, the word search functionality is represented by two methods.
    The first one is the `getwords()` method in `wikiweb.py:`
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在交付方面，单词搜索功能由两个方法表示。第一个方法是`wikiweb.py`中的`getwords()`方法：
- en: '**Chapter6/wikiweb.py**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter6/wikiweb.py**'
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`getwords()` will return a list of words that starts with the characters in
    the `term` argument and returns those as a JSON serialized string for use by the
    auto completion function that we will add to the input field of the word search
    form. Words are stored all lowercase in the database. Therefore, the `term` argument
    is lowercased as well before matching any words (highlighted). Note that the argument
    to `json.dumps()` is in square brackets to convert the generator returned by the
    list comprehension to a list. This is necessary because `json.dumps` does not
    accept generators.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`getwords()`将返回一个以`term`参数中的字符开头的单词列表，并将其作为JSON序列化字符串返回，以便用于我们将添加到单词搜索表单输入字段的自动完成函数。单词在数据库中以小写形式存储。因此，在匹配任何单词之前，`term`参数也被转换为小写（高亮显示）。请注意，`json.dumps()`的参数用方括号括起来，以将列表推导式返回的生成器转换为列表。这是必要的，因为`json.dumps`不接受生成器。'
- en: 'The second method is called `searchwords()`, which will return a list of clickable
    items consisting of those topics that contain all words passed to it as a string
    of comma-separated words. The list will be alphabetically sorted on the name of
    the topic:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法称为`searchwords()`，它将返回一个包含所有以逗号分隔的单词字符串传递给它的主题的列表，这些主题包含所有传递给它的单词。列表将按主题名称进行字母排序：
- en: '**Chapter6/wikiweb.py**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter6/wikiweb.py**'
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the markup returned by `searchwords()` is not a complete HTML page,
    as it will be called asynchronously when the user clicks the search button and
    the result will replace the content part.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`searchwords()`返回的标记不是完整的HTML页面，因为它将在用户点击搜索按钮时异步调用，并将结果替换内容部分。
- en: Again, the hard work of actually finding the topics that contain the words is
    not done in the delivery layer, but delegated to the function `wiki.searchwords():`
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，实际上找到包含这些单词的主题的艰苦工作不是在交付层完成的，而是委托给`wiki.searchwords()`函数：
- en: '**Chapter6/wiki.py**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter6/wiki.py**'
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This `searchwords()` function starts by splitting the comma-separated items
    in its `word` argument and sanitizing each item by stripping, leading, and trailing
    punctuation and whitespace and converting it to lowercase (highlighted).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`searchwords()`函数首先通过分割其`word`参数中的逗号分隔项，并通过去除每个项的前导、尾随标点符号和空白字符以及将其转换为小写（高亮显示）来清理每个项。
- en: The next step is to consider only items that consist solely of alphanumeric
    characters because these are the only ones stored as word entities to prevent
    pollution by meaningless abbreviations or markup.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是仅考虑仅由字母数字字符组成的项，因为这些是唯一作为单词实体存储的，以防止无意义的缩写或标记的污染。
- en: We then check whether the item is present in the database by calling the `list()`
    method of the `Word` class. This will return either an empty list or a list containing
    just a single ID. In the latter case, this ID is used to construct a `Word` instance
    and we use that to retrieve a list of `Topic` IDs associated with this word by
    calling the `list()` method of the `TopicWord` class (highlighted) and convert
    it to a set for easy manipulation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`Word`类的`list()`方法来检查项目是否存在于数据库中。这将返回一个空列表或只包含单个ID的列表。在后一种情况下，这个ID被用来构建一个`Word`实例，我们使用它通过调用`TopicWord`类的`list()`方法（突出显示）来检索与该单词关联的`Topic`
    ID列表，并将其转换为集合以便于操作。
- en: If this is the first word we are checking, the `topics` variable will contain
    `None` and we simply assign the set to it. If the `topic` variable already contains
    a set, we replace the set by the intersection of the stored set and the set of
    topic IDs associated with the word we are now examining. The intersection of two
    sets is calculated by the`&` operator (in this case, replacing the left-hand side
    directly, hence the`&=` variant). The result of the intersection will be that
    we have a set of topic IDs of topics that contain all words examined so far.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是我们检查的第一个单词，`topics`变量将包含`None`，我们只需将其赋值为集合。如果`topic`变量已经包含一个集合，我们用存储的集合和我们现在检查的单词关联的主题ID集合的交集来替换这个集合。两个集合的交集是通过`&`运算符（在这种情况下，直接替换左侧，因此是`&=`变体）计算的。交集的结果将是我们有一个包含所有已检查单词的主题ID集合。
- en: If the resulting set contains any IDs at all, these are converted to `Topic`
    instances to yield their `title` attribute.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果集合包含任何ID，这些ID将被转换为`Topic`实例以获取它们的`title`属性。
- en: The importance of input validation
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入验证的重要性
- en: Anything that is passed as an argument to the methods that service the wiki
    application, can potentially damage the application. This may sound a bit pessimistic,
    but remember that when designing an application, you cannot rely on the goodwill
    of the public, especially when the application is accessible over the Internet
    and your public may consist of dimwitted search bots or worse.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 任何传递给服务wiki应用的方法的参数，都可能损害该应用。这听起来可能有点悲观，但请记住，在设计应用时，你不能依赖于公众的善意，尤其是当应用可以通过互联网访问，而你的公众可能包括愚蠢的搜索引擎机器人或更糟糕的情况。
- en: We may limit the risks by granting the right to edit a page only to people we
    know by implementing some sort of authentication scheme, but we don't want even
    these people to mess up the appearance of a topic by inserting all sorts of HTML
    markup, references to images that do not exist or even malicious snippets of JavaScript.
    We therefore want to get rid of any unwanted HTML elements present in the content
    before we store it in the database, a process generally known as *scrubbing*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实施某种身份验证方案，仅授予我们认识的人编辑页面的权限来限制风险，但我们不希望这些人通过插入各种HTML标记、不存在或甚至恶意的JavaScript片段来破坏主题的外观。因此，在我们将内容存储到数据库之前，我们希望去除内容中存在的任何不受欢迎的HTML元素，这个过程通常被称为*清洗*。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Preventing Cross-Site Scripting (XSS) (as the inclusion of unwanted code in
    web pages is called) is covered in depth on this webpage: [http://www.pythonsecurity.org/wiki/cross-sitescripting/](http://www.pythonsecurity.org/wiki/cross-sitescripting/).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个网页上深入探讨了防止跨站脚本攻击（XSS）（正如在网页中包含不受欢迎的代码所称呼的）：[http://www.pythonsecurity.org/wiki/cross-sitescripting/](http://www.pythonsecurity.org/wiki/cross-sitescripting/).
- en: Time for action scrubbing your content
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洗内容的时间
- en: Many wikis do not allow any HTML markup at all, but use simpler markup methods
    to indicate bulleted lists, headers, and so on.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 许多维基不允许使用任何HTML标记，而是使用更简单的标记方法来表示项目符号列表、标题等。
- en: 'Consider the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: Will the user understand some HTML markup or opt for no HTML markup at all?
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户能否理解一些HTML标记，或者完全选择不使用HTML标记？
- en: What will the wiki contain? Just text or also external references or references
    to binary objects (like images) stored in the wiki?
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基将包含什么？仅仅是文本，还是也包括外部引用或存储在维基中的二进制对象（如图片）的引用？
- en: 'For this wiki, we will implement a mixed approach. We will allow some HTML
    markup like`<b>` and`<ul>` but not any links. References to topics in the wiki
    might be entered as `[Topic]`, whereas links to external pages might be denoted
    as `{www.example.org}`. Images stored in the wiki may be referred to as`<143>`.
    Each type of reference will take an optional description as well. Example markup,
    as entered by the user, is shown next:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个维基，我们将实施一种混合方法。我们将允许一些HTML标记，如`<b>`和`<ul>`，但不允许任何链接。维基中主题的引用可以输入为`[Topic]`，而外部页面的链接可以表示为`{www.example.org}`。存储在维基中的图片可以引用为`<143>`。每种类型的引用都可以有一个可选的描述。以下是一个用户输入的示例标记：
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When viewed, it will look like the following image:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看时，它将看起来像以下图片：
- en: '![Time for action scrubbing your content](img/3746_06_008.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![内容清理行动时间](img/3746_06_008.jpg)'
- en: What just happened?
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'When we encountered the `edit()` method in `wikiweb.py`, we saw that the actual
    update of the content of a topic was delegated to the `updatetopic()` function
    in `wiki.py`, so let''s have a look at how this function is organized:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`wikiweb.py`中遇到`edit()`方法时，我们看到实际更新主题内容的工作被委托给了`wiki.py`中的`updatetopic()`函数，因此让我们看看这个函数是如何组织的：
- en: '**Chapter6/wiki.py**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**第六章/wiki.py**'
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First it checks whether the topic already exists by retrieving a list of `Topic`
    objects that have a `title` attribute that matches the `originaltopic` parameter.
    If this list is empty, it creates a new topic (highlighted), otherwise we update
    the `title` attribute of the first matching topic found. (See the explanation
    of the `edit()` method for the rationale behind this).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先它会检查主题是否已经存在，通过检索具有匹配`originaltopic`参数的`title`属性的`Topic`对象列表。如果这个列表为空，它会创建一个新的主题（高亮显示），否则我们更新找到的第一个匹配主题的`title`属性。（有关`edit()`方法的解释，请参阅背后的原因）。
- en: Then it calls the `scrub()` function to sanitize the content and then creates
    a new `Page` instance to store this content and associates it with the `Topic`
    instance `t`. So every time we update the content, we create a new revision and
    old revisions are still available for comparison.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它调用`scrub()`函数来清理内容，然后创建一个新的`Page`实例来存储这些内容，并将其与`Topic`实例`t`关联起来。因此，每次我们更新内容时，我们都会创建一个新的修订版，旧的修订版仍然可用于比较。
- en: The next step is to update the list of words used in the topic. We therefore
    create a set of unique words by passing the content to the `splitwords()` function
    (not shown here, available in `wiki.py)` and converting the list of words to a
    set. Converting a list to a set will remove any duplicate items.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是更新主题中使用的单词列表。因此，我们通过将内容传递给`splitwords()`函数（此处未显示，可在`wiki.py`中找到）并将单词列表转换为集合来创建一个唯一的单词集。将列表转换为集合将删除任何重复的项目。
- en: We convert the set of words to a dictionary with `Word` objects as keys and
    the words themselves as values and call the `updateitemrelation()` function to
    perform the update.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将单词集转换为以`Word`对象为键、单词本身为值的字典，并调用`updateitemrelation()`函数来执行更新。
- en: The same scenario is used with any tags associated with the topic. The `updateitemrelation()`
    function may look intimidating, but that is mainly due to the fact that it is
    made general enough to deal with any `Relation`, not just one between `Topic`
    and `Word` or `Topic` and `Tag`. By designing a general function, we have less
    code to maintain which is good although, in this case, readability may have suffered
    too much.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的场景也用于与主题相关联的任何标签。`updateitemrelation()`函数可能看起来令人畏惧，但这主要是因为它被设计得足够通用，可以处理任何`Relation`，而不仅仅是`Topic`和`Word`或`Topic`和`Tag`之间的关系。通过设计一个通用的函数，我们维护的代码更少，这很好，尽管在这种情况下，可读性可能受到了过多的损害。
- en: '**Chapter6/wiki.py**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**第六章/wiki.py**'
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First we determine if any items currently associated with the primary entity
    `p` are not in the new list of items. If so, they are deleted, that is, the recorded
    relation between the primary entity and the item is removed from the database,
    otherwise we store them in the `olditems` set.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确定与主实体`p`当前关联的任何项目是否不在新的项目列表中。如果是这样，它们将被删除，也就是说，主实体与项目之间的记录关系将从数据库中删除，否则我们将它们存储在`olditems`集中。
- en: The next step determines the difference between the `newitems` and `olditmes`
    (highlighted). The result represents those items that have to be associated with
    the primary entity, but may not yet be stored in the database. This is determined
    by using the `list()` method to find any, and if no entity is found, to create
    one. Finally, we add a new relation between the primary entity and the item
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步确定 `newitems` 和 `olditems`（突出显示）之间的差异。结果表示那些需要与主要实体关联的项目，但可能尚未存储在数据库中。这是通过使用
    `list()` 方法查找任何实体来确定的，如果没有找到实体，则创建一个。最后，我们在主要实体和项目之间添加一个新的关系
- en: 'The `scrub()` method is used to remove any HTML tags from the content that
    are not explicitly listed as being allowed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrub()` 方法用于从内容中移除任何未明确列出为允许的 HTML 标签：'
- en: '**Chapter6/wiki.py**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**第六章/wiki.py**'
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For this purpose, it instantiates a `Scrubber` object with a very limited list
    of allowable tags (highlighted) and feeds the content to its `feed()` method.
    The result is then found in the result attribute of the `Scrubber` instance:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，它实例化了一个具有非常有限允许标签列表（突出显示）的 `Scrubber` 对象，并将内容传递给其 `feed()` 方法。然后，结果可以在
    `Scrubber` 实例的结果属性中找到：
- en: '**Chapter6/wiki.py**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**第六章/wiki.py**'
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Scrubber` class is a subclass of the `HTMLParser` class provided in Python's
    `html.parser` module. We override suitable methods here to deal with start and
    end tags and data and ignore the rest (like processing instructions and the like).
    Both beginning and end tags are only appended to the result if they are present
    in the list of allowable tags. Regular data (text, that is) is simply appended
    to the result.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scrubber` 类是 Python 的 `html.parser` 模块中提供的 `HTMLParser` 类的子类。我们在这里覆盖了适当的方法来处理开始和结束标签以及数据，并忽略其他部分（如处理指令等）。只有当开始和结束标签存在于允许的标签列表中时，它们才会被附加到结果中。常规数据（即文本）简单地附加到结果中。'
- en: Time for action rendering content
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间：渲染内容
- en: We added specific JavaScript functionality to the text area editor to insert
    references to external websites, other wiki topics, and wiki images in a format
    that we devised ourselves and that cannot be interpreted as HTML. Now we have
    to provide code that will convert this notation to something that will be understood
    by the client.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文本区域编辑器中添加了特定的 JavaScript 功能，以插入对外部网站、其他维基主题和维基图片的引用，这些引用是我们自己设计的格式，不能被解释为
    HTML。现在我们必须提供将这种表示法转换为客户端可以理解的代码。
- en: What just happened?
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'Recognizing those items that we have to convert to HTML is mostly done by using
    regular expressions. We therefore define three regular expressions first, each
    representing a distinct pattern. Note that we use raw strings here to prevent
    interpretation of backslashes. Backslashes are meaningful in regular expression,
    and if we didn''t use raw strings, we would have to escape each and every backslash
    with a backslash, resulting in an unreadable sea of backslashes:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 识别那些需要转换为 HTML 的项目主要通过使用正则表达式完成。因此，我们首先定义了三个正则表达式，每个代表一个独特的模式。请注意，我们在这里使用原始字符串以防止转义字符的解释。在正则表达式中，反斜杠是有意义的，如果我们不使用原始字符串，我们就必须用反斜杠转义每个反斜杠，这将导致一个难以阅读的反斜杠海洋：
- en: '**Chapter6/wiki.py**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**第六章/wiki.py**'
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more on Python regular expressions have a look at [http://docs.python.org/py3k/library/re.html](http://docs.python.org/py3k/library/re.html)
    or check the reading list in the appendix.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 Python 正则表达式的信息，请查看 [http://docs.python.org/py3k/library/re.html](http://docs.python.org/py3k/library/re.html)
    或查阅附录中的阅读清单。
- en: 'Next we define three utility functions, one for each pattern. Each function
    takes a `match` object that represents a matching pattern and returns a string
    that can be used in HTML to show or link to that reference:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了三个实用函数，每个模式一个。每个函数接受一个表示匹配模式的 `match` 对象，并返回一个可以在 HTML 中使用以显示或链接到该引用的字符串：
- en: '**Chapter6/wiki.py**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**第六章/wiki.py**'
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `render()` function is passed a string with content to convert to HTML.
    For each line in the content, it tries to find the predefined patterns and converts
    them by passing the appropriate function to the `re.sub()` method. If a line consists
    of whitespace only, suitable HTML is produced to end a paragraph (highlighted).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()` 函数接受一个包含要转换为 HTML 的内容的字符串。对于内容中的每一行，它尝试找到预定义的模式，并通过将适当的函数传递给 `re.sub()`
    方法来转换它们。如果一行只包含空白字符，则生成适当的 HTML 以结束一个段落（突出显示）。'
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about implementing a web application that consists
    of more than a few entities and their relations.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关于实现由多个实体及其关系组成的网络应用学到了很多。
- en: 'Specifically, we covered:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How to create a data model that describes entities and relations accurately
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个准确描述实体和关系的模型
- en: How to create a delivery layer that is security conscious and treats incoming
    data with care
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个具有安全意识且对传入数据谨慎处理的传输层
- en: How to use jQuery UI's dialog widget and extend the functionality of the autocomplete
    widget
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用jQuery UI的对话框小部件并扩展自动完成小部件的功能
- en: 'We also encountered some limitations, especially in our entity/relation framework.
    It is, for example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也遇到了一些限制，尤其是在我们的实体/关系框架中。例如：
- en: Quite a lot of work to initialize the database as each entity and relation needs
    its own initialization code
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化数据库的工作量很大，因为每个实体和关系都需要自己的初始化代码
- en: Unwieldy to specify things like sort order when retrieving entities
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检索实体时指定排序顺序等事项很不方便
- en: Difficult to check input values or display formats in a uniform way
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以统一检查输入值或显示格式
- en: Difficult to differentiate between different types of relations, like one-to-many
    or many-to-many
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以区分不同类型的关联，如一对一或多对多
- en: This hardly poses a problem for our moderately complex wiki application, but
    more complex applications can only be built with a more flexible framework which
    is the topic of the next chapter.**
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于我们中等复杂度的维基应用来说几乎不构成问题，但更复杂的应用只能通过一个更灵活的框架来构建，这正是下一章的主题。**
