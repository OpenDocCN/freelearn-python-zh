- en: Chapter 6. Making the 2048 Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：制作2048游戏
- en: 'In the next few chapters, we will build a series of increasingly complex game
    projects to demonstrate some of the concepts commonly associated with game development:
    state management, controls, sound effects, and fast shader-based graphics, to
    name a few.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将构建一系列越来越复杂的游戏项目，以展示与游戏开发相关的一些常见概念：状态管理、控制、音效和基于快速着色器的图形，仅举几例。
- en: 'An important thing to consider upfront is that no approach is actually unique
    to game development: there are whole other classes of software that use the same
    algorithms and performance hacks as video games.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始需要考虑的重要事情是，没有任何方法实际上是游戏开发独有的：还有其他类别的软件使用与视频游戏相同的算法和性能技巧。
- en: However, let's start small and gradually work our way to complex things. Our
    first project is re-implementing the relatively well-known **2048** board game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们从小处着手，逐步过渡到更复杂的事情。我们的第一个项目是重新实现相对知名的**2048**游戏。
- en: 'This chapter will shed light on a number of Kivy techniques that are practically
    required when developing games:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍在开发游戏时实际上必需的许多Kivy技术：
- en: Creating Kivy widgets with custom visual appearance and behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有自定义外观和行为的Kivy小部件
- en: Drawing on canvas and utilizing built-in graphics instructions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布上绘制并利用内置的图形指令
- en: Using absolute positioning to arrange widgets arbitrarily on screen (as opposed
    to relying on a structured layout)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绝对定位在屏幕上任意排列小部件（而不是依赖于结构化布局）
- en: Moving widgets smoothly using Kivy's built-in support for animations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kivy内置的动画支持平滑地移动小部件
- en: Positioning widgets in absolute coordinates may sound like a regression after
    getting used to layout classes, but it's necessary in highly interactive applications
    such as games. For example, a rectangular playing field of many board games can
    be represented by a `GridLayout`, but even a basic animation such as movement
    from cell to cell will be tricky to implement. Such a task is doomed to include
    widget reparenting in some form; this alone pretty much marginalizes any gains
    from using a fixed layout.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绝对坐标定位小部件可能听起来是在习惯了布局类之后的一种倒退，但在高度交互式应用程序（如游戏）中是必要的。例如，许多桌面游戏的矩形游戏场可以用`GridLayout`表示，但即使是基本的动画，如从单元格到单元格的移动，也会很难实现。这样的任务注定要包括以某种形式进行小部件的重父化；这本身几乎就抵消了使用固定布局的任何好处。
- en: About the game
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于游戏
- en: 'For the uninitiated, the game of 2048 is a math puzzle where you combine numbers
    to get to 2048 and possibly beyond that, to 4096 and 8192 (albeit this may prove
    challenging, so 2048 is a sufficiently hard-to-achieve winning condition). The
    board is a 4×4 square grid. It is mostly empty at first, with a few **2** tiles.
    Each turn the player moves all tiles in the same direction of choice: up, right,
    down, or left. If a tile cannot advance in that direction (there is no free space
    available), then it stays put in place.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，2048游戏是一种数学谜题，玩家需要合并数字以达到2048，甚至可能超过2048，达到4096和8192（尽管这可能很有挑战性，所以2048是一个足够难以达到的胜利条件）。游戏板是一个4×4的方形网格。一开始大部分是空的，只有几个**2**方块。每个回合玩家将所有方块移动到所选的方向：上、右、下或左。如果一个方块无法向该方向前进（没有可用空间），则它将保持在原地。
- en: '![About the game](img/B01620_06_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![关于游戏](img/B01620_06_01.jpg)'
- en: The 2048 board (a screenshot from the original game)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 2048游戏板（原游戏截图）
- en: 'When two tiles having the same value touch (or rather, attempt to move on top
    of one another), they merge into one and sum up, increasing the tile nominal to
    a next power of two. So the progression looks like this: 2, 4, 8, 16, ... , 2048
    and so on; programmers usually find this sequence familiar. After each turn, another
    **2** tile is spawned in a random empty space.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个具有相同数值的方块接触（或者说，尝试移动到对方上方）时，它们会合并成一个，并相加，将方块的名义值增加到下一个2的幂。因此，进度看起来是这样的：2，4，8，16，...，2048等等；程序员通常会发现这个序列很熟悉。每回合结束后，在随机空位中会生成另一个**2**方块。
- en: The original version of 2048 also sometimes creates **4** instead of **2**;
    this is a minor feature that won't be addressed in this chapter, but should be
    rather simple to implement.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2048游戏的原版有时也会创建**4**而不是**2**；这是一个不太重要的特性，本章不会涉及，但实现起来应该相当简单。
- en: The game ends if there are no valid moves available to the player (the board
    is filled up in an unfortunate combination where no tiles of the same value are
    next to each other). You can play the original game of 2048 at [http://gabrielecirulli.github.io/2048/](http://gabrielecirulli.github.io/2048/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家没有有效的移动可用（棋盘被填充成一个不幸的组合，其中没有相同值的瓷砖相邻），游戏就会结束。你可以在[http://gabrielecirulli.github.io/2048/](http://gabrielecirulli.github.io/2048/)上玩原始的2048游戏。
- en: Gameplay concepts and overview
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏玩法概念和概述
- en: 'Games are generally very much stateful: the application goes through a number
    of distinctive states, such as the start screen, world map, town screen, and so
    on, depending on the specifics of the game. Certainly, each game is very different
    and there aren''t many aspects that are common across a significant number of
    games.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通常非常具有状态性：应用程序会经过多个独特的状态，例如起始屏幕、世界地图、城镇屏幕等，具体取决于游戏的细节。当然，每个游戏都非常不同，并且没有许多方面在大量游戏中是共同的。
- en: One such aspect, and very basic at that, is that most games have either a win
    or a loss condition, often both. This may sound trivial, but these conditions
    and associated game states may have a tremendous impact on player's engagement
    and perception of the game.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个方面，而且非常基础，就是大多数游戏要么有赢的条件，要么有输的条件，通常两者都有。这听起来可能很微不足道，但这些条件和相关的游戏状态可能会对玩家的参与度和对游戏的感知产生巨大影响。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are games that are completely endless by design and have no connotation
    of the "game over" state (neither win nor loss) within the rules, and they are
    incredibly hard to get right in terms of player motivation. Such games also commonly
    provide a state of strong local advantage and disadvantage to compensate.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有些游戏设计上完全是无限的，规则中没有任何“游戏结束”状态的含义（既不赢也不输），在玩家动机方面非常难以正确实现。这类游戏通常还会提供强烈的局部优势和劣势状态来补偿。
- en: For example, while you cannot win the game or die completely and get into a
    "game over" state in World of Warcraft, or numerous other MMORPG titles that followed
    the same design concepts, you are certainly punished for neglecting your character's
    health and stats by having to perform in-game revival and associated tasks like
    repairing broken equipment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，虽然你无法在《魔兽世界》或遵循相同设计概念的许多其他MMORPG游戏中赢得游戏或完全死亡并进入“游戏结束”状态，但你确实会因为忽视角色的健康和统计数据而受到惩罚，需要执行游戏内的复活和相关任务，如修复损坏的装备。
- en: Also, if you're exceptionally good, oftentimes you can team up with other highly
    skilled players and obtain items that aren't otherwise obtainable (and hence are
    unavailable to bad or casual players). This includes numerous boss encounters,
    raids, and those hard-to-get achievements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你特别擅长，你通常可以与其他高技能玩家组队，获得其他玩家无法获得的物品（因此对不良或休闲玩家不可用）。这包括许多Boss遭遇战、突袭以及那些难以获得的成就。
- en: The aforementioned losing condition found in 2048—the game ends when there are
    no available moves on the board—works great in practice because it makes the game
    gradually harder towards the end.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 2048中提到的上述失败条件——当棋盘上没有可用的移动时游戏结束——在实践中效果很好，因为它使得游戏在结束时逐渐变得更加困难。
- en: 'At the very beginning, the game isn''t difficult at all: the player can basically
    perform completely random moves without any strategy. New tiles are added to the
    board having the same value, so it''s impossible to fill all cells and run out
    of valid moves during first few turns, even on purpose—all the tiles are compatible
    and can be combined, no matter which direction the player chooses to move.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始时，游戏本身并不难：玩家基本上可以完全随机地移动，没有任何策略。新瓷砖以相同的值添加到棋盘上，因此在最初的几轮中，不可能填满所有单元格并耗尽有效的移动，即使是有意为之——所有的瓷砖都是兼容的，可以组合，无论玩家选择向哪个方向移动。
- en: However, as you progress further in the game and variation is introduced to
    the board, free cells become increasingly scarcer. Since different values cannot
    be merged together, board management quickly becomes a problem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着你在游戏中进一步前进，棋盘上的变化引入，空闲单元格变得越来越稀缺。由于不同的值不能合并在一起，棋盘管理很快就会成为一个问题。
- en: 'Gameplay mechanics is what makes 2048 so engaging: it''s really easy to start,
    the rules are simple and don''t change over the course of the game, and 2048 doesn''t
    punish experimentation in the beginning, even in the form of clearly suboptimal
    behavior, until much later in the game.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏玩法机制是使2048如此吸引人的原因：它很容易开始，规则简单，并且在整个游戏过程中不会改变，2048在游戏初期不会惩罚实验性的行为，即使是以明显次优的行为形式，直到游戏后期。
- en: Randomness, or lack thereof
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机性，或者缺乏随机性
- en: Since all tiles (up to 16) move at once, some of the resulting situations may
    have not been foreseen by players if they don't pay close attention. Albeit completely
    deterministic, this algorithm is perceived as having a touch of randomness to
    it. This also helps engagement by making 2048 feel more like an arcade game, slightly
    unpredictable and surprising.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有瓦片（最多16个）同时移动，如果玩家没有密切注意，一些由此产生的情况可能没有被预见。尽管这个算法是完全确定性的，但它给人的感觉是带有一点随机性。这也通过使2048感觉更像街机游戏，略带不可预测性和惊喜，来帮助提高参与度。
- en: 'This is generally a good thing: random encounters (or more accurately, encounters
    that are perceived as random, like in this case) may add life to an otherwise
    linear process, making the gameplay more interesting.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一件好事：随机遭遇（或者更准确地说，像这种情况中被感知为随机的遭遇）可以为其他方面线性的过程增添活力，使游戏玩法更有趣。
- en: The 2048 project outline
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2048项目概述
- en: 'To summarize, the following are the defining characteristics of the game:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，以下是该游戏的定义特征：
- en: The playing field (the board) is 4×4 cells
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏场（即棋盘）是4×4个单元格
- en: 'The following actions occur during each turn:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每一回合中发生以下动作：
- en: Player moves all tiles in a direction of choice
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家将所有瓦片移动到所选方向
- en: Colliding two tiles having the same value produces one tile of greater value
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并两个具有相同数值的瓦片会产生一个数值更大的瓦片
- en: New **2** tile is spawned in empty space
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在空白空间中生成一个新的**2**瓦片
- en: The player wins by creating a **2048** tile
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家通过创建一个**2048**瓦片获胜
- en: The game ends when there are no valid moves left (that is, none of the possible
    moves can change the situation on the board anymore)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有有效的移动剩下时（也就是说，没有可能的移动可以再改变棋盘上的情况时），游戏结束
- en: This checklist will come in handy later on, as it forms the essential technical
    outline of what we're going to implement in this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单将在稍后派上用场，因为它形成了我们在本章中将要实现的基本技术概述。
- en: What makes 2048 a good choice of project?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么使2048成为项目选择的好选择？
- en: One might ask whether re-implementing an existing game is a sound idea. The
    answer is, by all means, yes; a more detailed explanation follows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会问，重新实现现有游戏是否是一个明智的想法。答案是，无论如何都是肯定的；更详细的解释将在下面提供。
- en: This is slightly off-topic when talking about practical software development,
    but the rationale to recreate a well-known project may not be obvious. If this
    chapter's approach makes perfect sense to you without lengthy explanations, then
    feel free to skip to the next section where the actual development begins.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论实际软件开发时，这一点稍微有些离题。但重新创建一个知名项目的理由可能并不明显。如果这个章节的方法对你来说没有冗长的解释就完全合理，那么请随意跳到下一节，那里将开始实际开发。
- en: 'To support the choice of 2048 (and the approach of "re-implementing the wheel"
    as a whole), let''s first assume the following: game development is extremely
    challenging on many different levels:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持选择2048（以及整体上“重新实现轮子”的方法），让我们首先假设以下情况：游戏开发在许多不同层面上都极具挑战性：
- en: Interesting game designs are hard to come by. There has to be a central idea
    to game mechanics, which may require a healthy amount of creativity.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有趣的游戏设计很难找到。游戏机制必须有一个中心思想，这可能需要一定程度的创造力。
- en: A good game requires that gameplay isn't way too complex, which may quickly
    lead to frustration, but not too easy and therefore boring either. Balancing this
    may sound simple at first, but is usually hard to get right.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款好游戏需要游戏玩法不是过于复杂，否则可能会迅速导致挫败感，但也不能过于简单，否则会变得无聊。平衡这一点听起来可能一开始很简单，但通常很难做到恰到好处。
- en: Some algorithms are harder than others. Path-finding on a flat, tiled map is
    easily approachable, but path-finding in a dynamic arbitrary three-dimensional
    space is a whole other story; **artificial intelligence** (**AI**) for a shooter
    may be simplistic and still deliver excellent results, while AI for a strategy
    game has to be clever and unpredictable to provide sufficient challenge and variety.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些算法比其他算法更难。在平坦的瓦片地图上寻找路径是容易接近的，但在动态的任意三维空间中寻找路径则完全是另一回事；为射击游戏设计的**人工智能**（**AI**）可能很简单，但仍能提供出色的结果，而策略游戏中的AI则必须聪明且不可预测，以提供足够的挑战和多样性。
- en: The attention to detail and the amount of polish that makes a good game can
    be downright overwhelming, even to professionals working in the field.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意细节以及使游戏变得出色的打磨程度，即使是该领域的专业人士也可能感到压倒性，甚至令人难以承受。
- en: This list is by no means exhaustive and serves not to scare everyone away from
    game development, but to get the point across—there are many things that can go
    wrong, so don't hesitate to offload some of the tasks to a third party. This increases
    your chances of delivering a working project and reduces the associated amount
    of frustration.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表绝对不是详尽的，它的目的不是让所有人都远离游戏开发，而是要传达一个观点——有很多事情可能会出错，所以不要犹豫，将一些任务外包给第三方。这增加了你交付一个可工作的项目的可能性，并减少了相关的挫折感。
- en: A go-to approach in gamedev (especially a sporadic, zero-budget effort like
    this book's projects) is to avoid costly creative search, especially in terms
    of gameplay. If you cannot get the project out of the door, its uniqueness is
    of very little value. That's why one should reuse as many existing elements as
    possible when building a new game.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中（尤其是像本书项目这样的零预算、偶尔的努力）的一个常用方法就是避免昂贵的创意搜索，尤其是在游戏玩法方面。如果你不能让项目走出大门，其独特性几乎毫无价值。这就是为什么在构建新游戏时，应该尽可能多地重用现有元素。
- en: You don't have to copy someone else's ideas verbatim, of course—tweaking every
    aspect of the game can be fun and a very rewarding endeavor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必逐字复制别人的想法——调整游戏的每个方面都可以很有趣，并且是一项非常有回报的努力。
- en: In fact, most games borrow ideas, gameplay, and sometimes even visual attributes
    from their predecessors, and there is very little variety overall (this isn't
    necessarily a good thing, just the state of today's industry, for better or worse).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，大多数游戏都借鉴了前人的想法、游戏玩法，有时甚至包括视觉属性，整体上变化非常小（这并不一定是好事，只是当今行业的状态，无论好坏）。
- en: Simplicity as a feature
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单性作为一项特性
- en: Getting back to the 2048 game, it's worth noting that its rules are very simple,
    borderline trivial. The fun factor, however, is inexplicably high; 2048 was very
    popular for a relatively long time, with numerous spin-offs flooding the Internet
    and app stores.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 2048 游戏来说，值得注意的是，它的规则非常简单，几乎可以说是微不足道的。然而，乐趣因素却不可思议地高；2048 在相当长的一段时间里非常受欢迎，无数的衍生作品充斥着互联网和应用商店。
- en: This alone makes the game of 2048 well worth rebuilding from scratch, even more
    so for the purpose of learning. Let's assume that at this point you're entirely
    convinced that 2048 is a fantastic choice of a project, and are eager to move
    on to actual development.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此一点就使得 2048 游戏值得从头开始重建，尤其是为了学习目的。让我们假设，到这一点，你已经完全确信 2048 是一个绝佳的项目选择，并且渴望继续实际开发。
- en: Creating the 2048 board
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 2048 游戏板
- en: 'Up until now, we were relying on existing Kivy widgets, customizing them as
    needed to fit our specific use case. For this application, we''re going to build
    our own unique widgets: `Board` (the playing field) and `Tile`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖于现有的 Kivy 小部件，根据需要对其进行定制以适应我们的特定用例。对于这个应用程序，我们将构建我们自己的独特小部件：`Board`（游戏区域）和`Tile`。
- en: Let's begin with the simple stuff and create the background for the playing
    field. The most unimaginative way to do so would be just using a static image;
    this approach has many problems, for example, it does not support the multitude
    of possible screen sizes properly (remember that we're talking about both desktop
    and mobile at the same time, so the screen size can vary wildly).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的事情开始，为游戏区域创建背景。最缺乏想象力的方法就是使用静态图像；这种方法有很多问题，例如，它不能正确支持多种可能的屏幕尺寸（记住，我们同时谈论的是桌面和移动设备，所以屏幕尺寸可能会有很大的变化）。
- en: Instead, we will create the `Board` widget that renders the playing field graphics
    onto its canvas. This way, the board's positioning and size will be given declaratively
    in a Kivy language file, same as with other widgets we've used before (such as
    text labels and buttons).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将创建一个`Board`小部件，它将游戏区域的图形渲染到其画布上。这样，游戏板的定位和大小将在 Kivy 语言文件中以声明性方式给出，就像我们之前使用过的其他小部件一样（例如文本标签和按钮）。
- en: 'Probably the easiest thing to start with is indeed setting the position and
    size of a board. To do this efficiently, we can use `FloatLayout`; this is one
    of the simplest layout classes provided by Kivy, which uses just the size and
    position hints. The following listing pretty much summarizes the usage of `FloatLayout`
    (this code resides in the `game.kv` file):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最容易开始的事情确实是设置游戏板的定位和大小。为了高效地完成这项任务，我们可以使用`FloatLayout`；这是 Kivy 提供的简单布局类之一，它只使用大小和位置提示。以下列表基本上总结了`FloatLayout`的使用（此代码位于`game.kv`文件中）：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `Board` widget is centered on the screen, both vertically and horizontally.
    In order to account for any possible screen orientation or aspect ratio, we compute
    board size by picking the smaller side of the screen (either width or height)
    and subtracting the padding twice (we want the same gap from both sides). The
    board is square, so its dimensions are equal.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Board` 小部件在屏幕上水平和垂直居中。为了考虑到任何可能的屏幕方向或纵横比，我们通过选择屏幕较小的边（宽度或高度）并减去两次填充（我们希望两侧有相同的间隙）来计算棋盘大小。棋盘是正方形的，所以其尺寸相等。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `[...] * 2` trick on the `size:` line is a fairly standard Python feature
    to avoid repeating the same value in a list or tuple many times over when initializing
    the data structure, for example, `[1] * 3` equals `[1, 1, 1]`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `size:` 行上的 `[...] * 2` 技巧是 Python 的一个相当标准的特性，用于在初始化数据结构时避免多次重复相同的值，例如，`[1]
    * 3` 等于 `[1, 1, 1]`。
- en: To avoid confusion with the arithmetic multiplication, we employ this feature
    sparingly. However, in production you should consider using this syntax where
    appropriate, as it's more concise than writing the same repetitive list or tuple
    by hand.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免与算术乘法混淆，我们应谨慎使用此功能。然而，在生产环境中，您应考虑在适当的地方使用此语法，因为它比手动编写相同的重复列表或元组更简洁。
- en: 'In order to see the result of our work so far, we need to define the `Board`
    widget itself and make it render something (by default, empty widgets are completely
    invisible). This will take place in the `main.py` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到我们迄今为止的工作结果，我们需要定义 `Board` 小部件本身并使其渲染某些内容（默认情况下，空小部件是完全不可见的）。这将在 `main.py`
    文件中完成：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similar to the definition of `padding` in `game.kv`, we define `spacing` at
    the top of the Python source code. This is the distance between two adjacent cells
    and from an edge of the board to an edge of the nearby cell.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `game.kv` 中 `padding` 的定义类似，我们在 Python 源代码的顶部定义 `spacing`。这是两个相邻单元格之间的距离，以及从棋盘边缘到附近单元格边缘的距离。
- en: 'The `resize()` method plays a central role in this part of the code: it''s
    called when the `Board` widget is created (directly from `__init__()`) or repositioned
    (with the help of `on_pos` and `on_size` event callbacks). If the widget was indeed
    resized, we compute the new `cell_size` up front; it''s a very simple computation
    actually, so it won''t hurt even if the size of the widget did not change between
    invocations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`resize()` 方法在本部分代码中起着核心作用：它在创建 `Board` 小部件（直接从 `__init__()`）或重新定位（借助 `on_pos`
    和 `on_size` 事件回调）时被调用。如果小部件确实进行了调整大小，我们预先计算新的 `cell_size`；实际上，这是一个非常简单的计算，所以即使小部件在调用之间的大小没有改变，也不会造成伤害：'
- en: '![Creating the 2048 board](img/7849OS_06_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![创建 2048 棋盘](img/7849OS_06_02.jpg)'
- en: Here, *size* means either width or height, since all objects in question are
    square.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*大小*指的是宽度或高度，因为所有相关对象都是正方形的。
- en: Next, we render the background. We clear the `canvas.before` graphics instruction
    group and fill it with primitives (which are represented by just `BorderImage`
    at the moment). The `canvas.before` group, as opposed to `canvas.after` or just
    `canvas`, is executed first when a widget is being rendered. This makes it perfect
    for background imagery that needs to be below any child other graphics.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们渲染背景。我们清除 `canvas.before` 图形指令组，并用原语（目前仅由 `BorderImage` 表示）填充它。与 `canvas.after`
    或 `canvas` 相比，`canvas.before` 组在渲染小部件时首先执行。这使得它非常适合需要位于任何子图形之下的背景图像。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Canvas instruction groups are Kivy's way of organizing lower-level graphical
    operations, such as copying image data to canvas, drawing lines, and performing
    raw OpenGL calls. For a brief introduction to using the canvas, refer to [Chapter
    2](ch02.html "Chapter 2. Building a Paint App"), *Building a Paint App*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 画布指令组是 Kivy 组织底层图形操作的方式，例如将图像数据复制到画布、绘制线条和执行原始 OpenGL 调用。有关使用画布的简要介绍，请参阅[第 2
    章](ch02.html "第 2 章。构建绘图应用程序")，*构建绘图应用程序*。
- en: Individual canvas instructions, living in the `kivy.graphics` namespace, are
    conceptually children of a `canvas` object (or `canvas.before` and `canvas.after`),
    just like leaf widgets are children of a container or root widget. Hierarchical
    definitions in code also look very similar.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 单个画布指令，存在于 `kivy.graphics` 命名空间中，在概念上是 `canvas` 对象（或 `canvas.before` 和 `canvas.after`）的子对象，就像叶小部件是容器或根小部件的子对象一样。代码中的分层定义看起来也非常相似。
- en: An important difference, however, is that widgets have a complex lifecycle,
    can align themselves on the screen, respond to events, and do more. Rendering
    instructions, on the contrary, are just that—mostly self-contained primitives
    for drawing. For example, the `Color` instruction changes the color (tint) for
    next instructions in queue, if any; `Image` draws an image on canvas; and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个重要的区别是，小部件具有复杂的生命周期，可以在屏幕上对齐，响应事件，并执行更多操作。相反，渲染指令只是那样——主要是用于绘图的自我包含的基本原语。例如，`Color`指令更改队列中后续指令的颜色（色调）；`Image`在画布上绘制图像；等等。
- en: For now, the background is just a rectangle. It has rounded corners, thanks
    to the background image, `board.png`, rendered using the `BorderImage` instruction—a
    9-patch technique described in [Chapter 1](ch01.html "Chapter 1. Building a Clock
    App"), *Building a Clock App*, similar to how bordered buttons were implemented
    in all previous examples over the course of this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，背景只是一个矩形。由于背景图片`board.png`的使用，它具有圆角，这是通过`BorderImage`指令实现的——一种在[第1章](ch01.html
    "第1章. 构建时钟应用")中描述的9宫格技术，*构建时钟应用*，类似于本书中所有前例中实现带边框按钮的方式。
- en: Going through cells
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历单元格
- en: 'Our playing field is two-dimensional, and traversing a two-dimensional array
    can be achieved in a very obvious fashion by nesting `for` loops like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的竞技场是二维的，通过嵌套`for`循环可以非常明显地遍历二维数组，如下所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Not only is this unwieldy and adds two levels of indentation, but also leads
    to repetitive code when used in many places throughout the program, which is undesirable.
    In Python, we can refactor this code using a generator function as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅难以操作，增加了两层缩进，而且当在程序中的许多地方使用时，还会导致代码重复，这是不希望的。在Python中，我们可以使用如这里所示的生成器函数重构此代码：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The generator function itself looks similar to the straightforward approach
    shown in the previous code snippet. Its usage, however, is clearer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数本身看起来与前面代码片段中显示的直接方法相似。然而，它的使用却更加清晰：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is basically the same code running two nested loops, but the details of
    those are abstracted, and as such we have a tidy one-liner, which is also more
    customizable than the code interspersed with literal `for` loops over each coordinate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是运行两个嵌套循环的相同代码，但那些细节被抽象化了，因此我们有一个整洁的一行代码，它也比穿插在每个坐标上的直接`for`循环代码更可定制。
- en: In the following code, we will refer to board coordinates (those that designate
    a board cell, as opposed to pixel coordinates of rendered objects on screen) as
    `board_x` and `board_y`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将把板坐标（指代板上的单元格，而不是屏幕上渲染对象的像素坐标）称为`board_x`和`board_y`。
- en: Rendering empty cells
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染空单元格
- en: The position and size of the game board as a whole are defined by placement
    of the `Board` widget, but the location of individual cells is yet undefined.
    Next, we're going to compute each cell's coordinates on screen and draw all cells
    on the canvas.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏板的整体位置和大小由`Board`小部件的位置定义，但单个单元格的位置尚未确定。接下来，我们将计算每个单元格在屏幕上的坐标，并在画布上绘制所有单元格。
- en: 'The location of a cell on screen, taking `spacing` into account, can be calculated
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`spacing`，屏幕上单元格的位置可以这样计算：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Canvas operations typically expect absolute coordinates, and this is why we're
    adding the `Board` location (`self.x`, `self.y`) to the computed value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 画布操作通常期望绝对坐标，这就是为什么我们要将`Board`的位置（`self.x`，`self.y`）添加到计算值中。
- en: 'Now that we can iterate over the playing field and compute an onscreen position
    of each cell based on its board location, the only thing that''s left is actually
    rendering cells on the canvas. Tweaking the `canvas.before` code as follows should
    suffice:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够遍历竞技场，并根据每个单元格的板位置计算其在屏幕上的位置，剩下要做的就是实际上在画布上渲染单元格。按照以下方式调整`canvas.before`代码应该足够：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When rendering images, the `Color` instruction serves the same purpose as we''ve
    discussed previously in this book (for example, in [Chapter 2](ch02.html "Chapter 2. Building
    a Paint App"), *Building a Paint App*): it allows every tile to be colored differently
    while using the same (white) image for a texture.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染图像时，`Color`指令与本书中之前讨论过的目的相同（例如，在[第2章](ch02.html "第2章. 构建绘图应用")中，*构建绘图应用*）：它允许每个瓦片有不同的颜色，同时使用相同的（白色）图像作为纹理。
- en: Also, note the use of `cell_pos` and `cell_size`—these are the *real* screen
    coordinates in pixels. They vary according to the application's window size, and
    are generally computed just to draw something on the screen. For game logic, we
    are going to use much simpler board coordinates `board_x` and `board_y`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意 `cell_pos` 和 `cell_size` 的使用——这些是实际的屏幕坐标（以像素为单位）。它们根据应用程序窗口的大小而变化，通常仅用于在屏幕上绘制某些内容。对于游戏逻辑，我们将使用更简单的棋盘坐标
    `board_x` 和 `board_y`。
- en: 'This screenshot summarizes all work we''ve done so far:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图总结了到目前为止我们所做的工作：
- en: '![Rendering empty cells](img/B01620_06_03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![渲染空单元格](img/B01620_06_03.jpg)'
- en: The playing field, devoid of anything remotely interesting yet
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛场地，目前没有任何有趣的东西
- en: Board data structure
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 棋盘数据结构
- en: 'To be able to work on game logic, we need to keep an internal representation
    of the board. For this, we will use a simple two-dimensional array (to be technically
    correct, a list of lists). The blank state of the board looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够处理游戏逻辑，我们需要保留棋盘的内部表示。为此，我们将使用一个简单的二维数组（从技术上讲，是一个列表的列表）。棋盘的空白状态如下所示：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The value of `None` means the cell is empty. The described data structure can
    be initialized using the nested list comprehension, as shown in the following
    code fragment:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 的值表示单元格为空。可以使用嵌套列表推导式初始化描述的数据结构，如下面的代码片段所示：'
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We call the preceding function `reset()` because, in addition to initializing
    the data structure beforehand, it will also be used to return the game to a blank
    state after a game-over situation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称先前的函数为 `reset()`，因为它不仅会在事先初始化数据结构，而且在游戏结束后也会将游戏状态恢复到空白状态。
- en: The use of list comprehensions isn't strictly necessary; this notation is just
    more concise than the literal list of lists which is also shown earlier. If you
    think that the literal form (as shown earlier) is more readable, by all means
    use it instead when initializing the grid.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式的使用并非绝对必要；这种表示法只是比之前展示的列表列表形式更为简洁。如果你认为（如之前所示）的原始形式更易读，那么在初始化网格时，完全可以使用它。
- en: Variable naming
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量命名
- en: A short name, `b`, is deemed appropriate because this property should be considered
    internal to the class, so it doesn't take part in the external API (or lack thereof).
    We will also use this variable heavily in the following code, so this also serves
    to reduce typing, akin to the commonly used loop iterator variables `i` and `j`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的名字 `b` 被认为是合适的，因为这个属性应该被视为类的内部属性，因此它不参与外部 API（或缺乏 API）。我们还将在这个代码中大量使用这个变量，这也起到了减少输入的作用，类似于常用的循环迭代变量
    `i` 和 `j`。
- en: In Python, private fields are usually designated with the leading underscore,
    for example, `_name`. We do not follow this convention strictly here, partly because
    this looks bad when used with very short names. This whole class is largely internal
    to the application anyway and barely, if at all, reusable as a separate module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，通常使用前导下划线来表示私有字段，例如 `_name`。我们在这里并不严格遵循这一惯例，部分原因是因为当与非常短的名字一起使用时，这看起来不太好。这个类的大部分内容都是应用程序内部的，几乎无法作为单独的模块重用。
- en: 'Consider `Board.b` a local variable for all intents and purposes, especially
    since `Board` acts as a singleton in our app: there should be only one instance
    of it at a given time.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有目的和意义上，将 `Board.b` 视为一个局部变量，特别是 `Board` 在我们的应用程序中充当单例：在任何给定时间点，应该只有一个实例。
- en: Calling reset()
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用 reset()
- en: 'We should call `Board.reset()` at the beginning of the game to initialize the
    internal representation of the board. The right place to do so is the application''s
    `on_start` callback, as shown in the following code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，我们应该调用 `Board.reset()` 来初始化棋盘的内部表示。这样做的地方是应用程序的 `on_start` 回调，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Testing passability
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试通行性
- en: We don't have anything clever to put in the grid yet, but this doesn't prevent
    us from writing a passability check, `can_move()`. This helper function tests
    whether we can place a tile at the specified location on the board.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还没有什么巧妙的东西可以放入网格中，但这并不妨碍我们编写通行性检查，`can_move()`。这个辅助函数测试我们是否可以在棋盘的指定位置放置一个瓷砖。
- en: The check is two-fold. First we need to make sure that the coordinates that
    are provided generally make sense (that is, don't fall outside the board), and
    this check will live in a separate function called `valid_cell()`. Then, we look
    up the board cell to see if it's empty (equals to `None`). The return value will
    be `True` if the move is legal and the cell is free, and `False` otherwise.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 检查有两重。首先，我们需要确保提供的坐标在一般情况下是有意义的（也就是说，不要超出棋盘），这个检查将存在于一个名为 `valid_cell()` 的单独函数中。然后，我们查找棋盘单元格以查看它是否为空（等于
    `None`）。如果移动是合法的且单元格是空的，则返回值将为 `True`，否则为 `False`。
- en: 'The preceding sentence can be literally translated to Python:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的句子可以直译为 Python：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These methods will be used later when writing the code responsible for tile
    movement. But first, we need to create the tiles.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法将在编写负责瓦片移动的代码时使用。但首先，我们需要创建瓦片。
- en: Making tiles
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作瓦片
- en: This part of the chapter is devoted to building the `Tile` widget. Tiles are
    more dynamic in nature than, for example, the `Board` widget that we've seen earlier.
    To account for this, we are going to create a number of Kivy properties on the
    `Tile` class so that any visible change to tile automatically leads to redrawing
    it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分致力于构建 `Tile` 小部件。与我们在前面看到的 `Board` 小部件相比，瓦片在性质上更加动态。为了解决这个问题，我们将在 `Tile`
    类上创建多个 Kivy 属性，以便任何对瓦片的可见更改都会自动导致重新绘制它。
- en: 'Kivy properties differ from regular Python ones: a property in Python is basically
    just a variable bound to an instance of class, possibly coupled with getter and
    setter functions. In Kivy, properties have an additional feature: they emit events
    when changed and as such you can observe interesting properties and adjust other
    related variables accordingly, or perhaps repaint the screen.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 属性与常规 Python 属性不同：Python 中的属性基本上只是一个绑定到类实例的变量，可能还与获取器和设置器函数相关联。在 Kivy 中，属性具有一个额外的功能：它们在更改时发出事件，因此你可以观察有趣的属性并根据需要调整其他相关变量，或者可能重新绘制屏幕。
- en: 'Most of this work happens under the hood without your intervention: when you
    issue a change to, for example, the `pos` or `size` of a widget, an event (`on_pos`
    or `on_size` respectively) is fired.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作都在幕后进行，无需你的干预：当你对例如小部件的 `pos` 或 `size` 发出更改时，会触发一个事件（分别是 `on_pos` 或 `on_size`）。
- en: 'Interestingly, all properties that are defined in a `.kv` file are propagated
    automatically. For example, you can write things such as:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在 `.kv` 文件中定义的所有属性都会自动传播。例如，你可以写一些如下内容：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the `root.pos` property changes, so does this label's `pos` value; they
    are kept in sync effortlessly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `root.pos` 属性改变时，这个标签的 `pos` 值也会改变；它们可以轻松地保持同步。
- en: 'We are going to use this quality to our advantage when creating the `Tile`
    widget. First, let''s declare interesting properties that should be accounted
    for when rendering the widget:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `Tile` 小部件时，我们将利用这一特性。首先，让我们声明在渲染小部件时应考虑的有趣属性：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is all that's needed to draw a tile; property names should be rather self-explanatory,
    with the possible exception of `color`, a tile's background color. The `number`
    property denotes the *face value* of the tile.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是绘制瓦片所需的所有内容；属性名称应该是相当自解释的，可能唯一的例外是 `color`，它是瓦片的背景颜色。`number` 属性表示瓦片的*面值*。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to run this code right now, please replace `tile_colors[2]` with
    a literal color value, for example, `'#EEE4DA'`. We will define the `tile_colors`
    list properly later in this section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在想运行此代码，请将 `tile_colors[2]` 替换为实际的颜色值，例如，`'#EEE4DA'`。我们将在本节的稍后部分正确定义 `tile_colors`
    列表。
- en: 'Next, in `game.kv`, we define graphical elements that constitute our widget:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `game.kv` 文件中，我们定义构成我们小部件的图形元素：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Custom properties coming from the `Tile` class are highlighted. Note that inside
    the `canvas` declaration, `self` refers to `<Tile>`, and not to the canvas itself.
    This is because `canvas` is merely a property of the corresponding widget. `Label`,
    on the other hand, is a nested widget in its own right, so it uses `root.XXX`
    to refer to `<Tile>` properties. It's the top-level definition in this case, so
    it works.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `Tile` 类的自定义属性被突出显示。请注意，在 `canvas` 声明内部，`self` 指的是 `<Tile>`，而不是画布本身。这是因为
    `canvas` 只是相应小部件的一个属性。另一方面，`Label` 是一个独立的小部件，因此它使用 `root.XXX` 来引用 `<Tile>` 属性。在这种情况下，它是顶级定义，所以它有效。
- en: Tile initialization
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓦片初始化
- en: In the original 2048 game, tiles have varying background colors according to
    their numeric value. We are going to implement the same effect, and for this we
    need a color mapping, *number → color*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始2048游戏中，瓷砖的背景颜色根据它们的数值而变化。我们将实现相同的效果，为此我们需要一个颜色映射，*number → color*。
- en: 'The following list of colors is close to what the original 2048 game uses:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下颜色列表接近原始2048游戏使用的颜色：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to map them to numbers, which in 2048 are powers of two, we can use
    the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将它们映射到数字，在2048中这些数字是2的幂，我们可以使用以下代码：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is exactly the mapping we need, with tile numbers as keys and corresponding
    colors as values:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要的映射，以瓷砖编号为键，相应的颜色为值：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the colors in place, we can write an initializer of the `Tile` class,
    the `Tile.__init__` method. It will mostly just assign properties of the tile
    in question, as shown in the following listing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在颜色就绪后，我们可以编写`Tile`类的初始化器，即`Tile.__init__`方法。它将主要只是分配所讨论的瓷砖的属性，如下所示：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s briefly talk about every property that we see here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈我们在这里看到的每个属性：
- en: '`font_size`: This is set to half of `cell_size`. This is basically an arbitrary
    value which looks fine. We cannot just put an absolute font size here, because
    the board is scaled to fit the window; the best approach is to keep font size
    to scale.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font_size`: 这设置为`cell_size`的一半。这基本上是一个任意值，看起来还不错。我们无法在这里直接使用绝对字体大小，因为板子是按比例缩放以适应窗口的；最佳方法是保持字体大小与缩放一致。'
- en: '`number`: This is passed from the calling function and defaults to **2**.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`：这是从调用函数传递的，默认为**2**。'
- en: '`color` (the background color of a tile): This originates from the mapping
    discussed earlier, based on the value of `number`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`（瓷砖的背景颜色）：这源于之前讨论的映射，基于`number`的值。'
- en: '`number_color`: This is chosen based on the `number` property, too, but with
    much less variety. There are just two colors: a dark one (the default) which is
    used on a light background, and a lighter one for better contrast on a bright
    background, as numbers go up; hence the check (`if self.number > 4`).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number_color`：这是基于`number`属性选择的，但变化较少。只有两种颜色：一种深色（默认），用于浅色背景，以及一种较浅的颜色，用于在明亮背景上提供更好的对比度，因为数字增加；因此有检查（`if
    self.number > 4`）。'
- en: Everything else is passed to the superclass in the form of `kwargs` (keyword
    arguments). This includes position and size attributes, which coincidentally are
    the topic of the next section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有内容都以`kwargs`（关键字参数）的形式传递给超类。这包括位置和大小属性，这恰好是下一节的主题。
- en: Colors live in a helper function of their own, `update_colors()`, because later
    we will need to update them when merging tiles.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色存在于它们自己的辅助函数中，`update_colors()`，因为稍后我们需要在合并瓷砖时更新它们。
- en: 'It''s worth mentioning that at this point, you can create a tile using something
    along the lines of:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在这个阶段，你可以使用类似以下的方式创建一个瓷砖：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As a result, a new tile will be visible on the screen. (The preceding code should
    reside in the `Board` class. Alternatively, change all `self` references to an
    instance of `Board`.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，屏幕上会出现一个新的瓷砖。（前面的代码应该位于`Board`类中。或者，将所有`self`引用更改为`Board`实例。）
- en: Resizing tiles
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整瓷砖大小
- en: Another problem with tiles is that they aren't aware that they should keep up
    with the board being resized. If you enlarge or shrink the application window,
    the board adjusts its size and position, but tiles don't. We're going to fix that.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 瓷砖的另一个问题是它们没有意识到它们应该随着板子的大小调整而保持同步。如果你放大或缩小应用程序窗口，板子会调整其大小和位置，但瓷砖不会。我们将解决这个问题。
- en: 'Let''s start with a helper method for updating all relevant `Tile` properties
    at once:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新所有相关`Tile`属性的一次性辅助方法开始：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although this method isn't strictly required, it makes the following code a
    bit more concise.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法不是必需的，但它使下面的代码更加简洁。
- en: 'The actual resizing code will be located at the end of the `Board.resize()`
    method, which is invoked by Kivy property bindings. Here, we can iterate over
    all tiles and fix their metrics according to new values of `cell_size` and `cell_pos`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的调整大小代码将位于`Board.resize()`方法的末尾，该方法由Kivy属性绑定调用。在这里，我们可以遍历所有瓷砖，并根据新的`cell_size`和`cell_pos`值调整它们的度量：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This approach is the exact opposite of automatic property binding we''ve seen
    earlier: we do all resizing in a centralized, explicit fashion. Some programmers
    may find this way of doing things more readable and less *magical* (for example,
    Python code allows you to set breakpoints inside event handlers and such; on the
    contrary, Kivy language files are much harder to meaningfully debug, should the
    need arise).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与我们之前看到的自动属性绑定正好相反：我们以集中和明确的方式完成所有调整大小操作。一些程序员可能会觉得这种方式更易于阅读且不那么*神秘*（例如，Python
    代码允许你在事件处理器等内部设置断点；相反，如果需要，Kivy 语言文件更难进行有意义的调试）。
- en: Implementing the game logic
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏逻辑
- en: 'Now that we''ve built all the components required to make an implementation
    of the 2048 game, let''s move on to more interesting things: spawning, moving,
    and combining tiles.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了实现 2048 游戏所需的所有组件，让我们继续更有趣的事情：生成、移动和合并瓷砖。
- en: 'It''s only logical that we begin with spawning new tiles in random empty cells.
    The algorithm for doing so is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从随机空单元格中开始生成新瓷砖是合乎逻辑的。这样做的方法如下：
- en: Find all cells that are currently empty.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到所有当前为空的单元格。
- en: Pick a random one from those found in step 1.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤 1 中找到的单元格中随机选择一个。
- en: Create a new tile at the position determined in step 2.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤 2 确定的位置创建一个新的瓷砖。
- en: Add it to the internal grid (`Board.b`), and to the board widget itself (using
    `add_widget()`) for Kivy to render it.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其添加到内部网格（`Board.b`），并使用 `add_widget()` 添加到板小部件本身（以便 Kivy 进行渲染）。
- en: 'The sequence of actions should be self-evident; the following Python implementation
    of this algorithm is also very straightforward:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 行动序列应该是显而易见的；以下 Python 实现此算法也非常简单：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'New tiles spawn at the beginning of the game and after every move. We will
    get to moving tiles shortly, and we can already implement spawning tiles at the
    beginning:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 新的瓷砖在游戏开始时以及每次移动后生成。我们很快就会涉及到移动瓷砖，现在我们可以实现开始时生成瓷砖：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you run the program after this change, you should see two tiles added to
    the board in random places.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在更改后运行程序，你应该会看到两个瓷砖随机添加到板的各个位置。
- en: '![Implementing the game logic](img/B01620_06_04.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![实现游戏逻辑](img/B01620_06_04.jpg)'
- en: Spawning tiles in action
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 实际生成瓷砖
- en: Moving tiles
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动瓷砖
- en: To implement movement efficiently, we'll need to map every input event to a
    directional vector. Then, the `Board.move()` method will accept such a vector
    and rearrange the board accordingly. A directional vector is typically normalized
    (its length equals to one), and in our case, we can just add it to the current
    tile's coordinates to get its possible new location.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地实现移动，我们需要将每个输入事件映射到一个方向向量。然后，`Board.move()` 方法将接受这样的向量并相应地重新排列板。方向向量通常是归一化的（其长度等于一），在我们的情况下，我们只需将其添加到当前瓷砖的坐标中，就可以得到其可能的新位置。
- en: 'The 2048 game only allows four options for movement, so the keyboard mapping
    definition is very short:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 2048 游戏只允许四种移动选项，因此键盘映射定义非常简短：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this listing, we're referring to arrow keys, aptly named `'up'`, `'right'`,
    `'down'`, and `'left'` in Kivy's predefined `keycodes` dictionary.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们指的是箭头键，在 Kivy 的预定义 `keycodes` 字典中恰当地命名为 `'up'`、`'right'`、`'down'` 和
    `'left'`。
- en: 'Listening to keyboard events in Kivy can be implemented using the `Window.bind()`
    method, as shown in the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kivy 中，可以通过 `Window.bind()` 方法实现监听键盘事件，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Board.move()` method gets called as a result. It accepts the directional
    vector components, `dir_x` and `dir_y`, unpacked from `key_vectors[key]`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board.move()` 方法因此被调用。它接受从 `key_vectors[key]` 中解包的方向向量分量，`dir_x` 和 `dir_y`。'
- en: Controlling the iteration sequence
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制迭代顺序
- en: Before we get to actually build the `Board.move()` method, we need to make the
    `all_cells()` generator function customizable; correct iteration order depends
    on the movement direction.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正构建 `Board.move()` 方法之前，我们需要使 `all_cells()` 生成器函数可定制；正确的迭代顺序取决于移动方向。
- en: For example, when going up, we have to start with the topmost cell in each column.
    This way we can ensure that all tiles will be arranged densely at the top of the
    board. In the event of incorrect iteration, you will inevitably see holes remaining
    from cells at the bottom bumping into cells at the top before those have reached
    their topmost available position.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当向上移动时，我们必须从每一列的最顶部的单元格开始。这样我们可以确保所有瓷砖都将紧密排列在板的顶部。在迭代错误的情况下，你不可避免地会看到来自底部单元格的孔洞，因为它们在达到顶部可用位置之前撞到了顶部的单元格。
- en: 'Taking this new requirement into account, we can easily write a new version
    of the generator function as shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个新的要求，我们可以轻松地编写一个新版本的生成函数，如下所示：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You may also want to write just `(3, 2, 1, 0)` instead of `reversed(range(4))`.
    In this specific case, literal enumeration is more concise than the iterator that
    produces it. Whether you choose to do so is a matter of personal preference and
    doesn't affect the functionality in any way.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以只写`(3, 2, 1, 0)`而不是`reversed(range(4))`。在这种情况下，直接枚举比产生它的迭代器更简洁。是否这样做是个人偏好的问题，并且不会以任何方式影响功能。
- en: Implementing the move() method
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现move()方法
- en: Now, we can build the simplest version of the `Board.move()` function. At the
    moment, it will only facilitate moving tiles around, but we will soon upgrade
    it to also merge tiles together.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建`Board.move()`函数的最简单版本。目前，它将仅便于移动瓦片，但我们将很快将其升级以合并瓦片。
- en: 'Here''s an overview of this function''s algorithm so far:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个函数算法的概述：
- en: Go through all (existing) tiles.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有（现有）瓦片。
- en: For each tile, move it in the specified direction until it bumps into another
    tile or the playing field boundary.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个瓦片，将其移动到指定的方向，直到它撞到另一个瓦片或游戏场边界。
- en: If the tile's coordinates stay the same, continue to the next tile.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果瓦片的坐标保持不变，则继续到下一个瓦片。
- en: Animate the tile's transition to new coordinates and continue to the next tile.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动画化瓦片的过渡到新坐标，并继续到下一个瓦片。
- en: 'The Python implementation closely follows the previous description:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Python实现紧密遵循之前的描述：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this listing, you can see the usage of `can_move()` function that we've built
    earlier.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，你可以看到我们之前构建的`can_move()`函数的使用。
- en: 'The `Animation` API works akin to CSS transitions in a browser. We need to
    provide:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animation` API在浏览器中的工作方式类似于CSS过渡。我们需要提供：'
- en: Values of properties we want to animate (in this example, `pos`)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要动画化的属性值（在这个例子中，是`pos`）
- en: Duration, in seconds
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续时间，以秒为单位
- en: Transition type (`'linear'` means equal speed throughout the route)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡类型（`'linear'`表示在整个路径上速度相等）
- en: Given all that, Kivy renders a smooth animation with the widget morphing from
    the current state to a new one.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，Kivy通过将小部件从当前状态转换为新的状态，渲染出平滑的动画。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All transition types are detailed in the Kivy manual ([http://kivy.org/docs/api-kivy.animation.html](http://kivy.org/docs/api-kivy.animation.html)).
    There are just too many of them to provide a meaningful summary here.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有过渡类型都在Kivy手册中详细说明（[http://kivy.org/docs/api-kivy.animation.html](http://kivy.org/docs/api-kivy.animation.html)）。这里的内容太多，无法在此提供有意义的摘要。
- en: Binding touch controls
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定触摸控制
- en: Let's also implement touch controls (swipes) in addition to keyboard bindings
    that we've done previously. Thanks to mouse input events being processed just
    like touches in Kivy, our code will also support mouse gestures.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再实现触摸控制（滑动），除了我们之前实现的键盘绑定。由于Kivy中鼠标输入事件的处理方式与触摸相同，我们的代码也将支持鼠标手势。
- en: 'To do so, we need to merely add an event handler to the `Board` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需要向`Board`类添加一个事件处理程序：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this code, we''re converting an arbitrary gesture to a unit vector that
    we need for `Board.move()` to work. The complete walkthrough is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将任意手势转换为所需的单位向量，以便`Board.move()`函数能够正常工作。完整的操作步骤如下：
- en: The `if v.length() < 20:` condition checks for eliminating very short gestures.
    If the travel distance is very short, then probably it was a click or tap, not
    a swipe.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if v.length() < 20:`条件检查消除非常短的手势。如果旅行距离非常短，那么可能是一个点击或轻触，而不是滑动。'
- en: The `if abs(v.x) > abs(v.y):` condition sets the shorter component of the vector
    to zero. The remaining component thus designates the direction.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if abs(v.x) > abs(v.y):`条件将向量的较短分量设置为0。因此，剩余的分量指定了方向。'
- en: And then we simply normalize the vector and feed it into `Board.move()`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需将向量归一化并将其输入到`Board.move()`中。
- en: This last point is exactly the reason why you shouldn't invent your own ways
    to represent *mathematically expressible* things such as directions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一个观点正是你不应该发明自己的方式来表示*数学上可表达*的事物，如方向的原因。
- en: Everyone out there understands vectors, you get compatibility with any other
    library essentially for free when you use them; but should you reinvent the wheel
    and define some other representation, for example, `UP = 0`, `RIGHT = 1` and so
    on—and boom, you're now all alone in the cold, dark nowhere, inconsistent with
    the rest of the world. Seriously, don't do that unless you have at least two very
    good reasons.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有人都知道向量，当你使用它们时，你几乎可以免费获得与其他任何库的兼容性；但是如果你要重新发明轮子并定义另一种表示，例如，`UP = 0`，`RIGHT
    = 1`等等——那么，你现在就独自一人置身于寒冷、黑暗的虚无之中，与世界上的其他事物不一致。说真的，除非你有至少两个非常好的理由，否则不要这样做。
- en: Combining tiles
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并瓷砖
- en: 'We will discuss the last fun part of the gameplay now: merging tiles as they
    bump into one another. The following code is surprisingly not very convoluted;
    one would probably expect it to be harder than that.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论游戏最后有趣的部分：当瓷砖相互碰撞时合并。下面的代码出人意料地并不复杂；人们可能会预期它比这更难。
- en: We will build yet another helper function, `can_combine()`. Conceptually very
    similar to `can_move()`, this function returns `True` if we can combine the current
    tile with the one at the provided location, that is, if the coordinates are same
    and the location contains a tile having the same value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建另一个辅助函数，`can_combine()`。在概念上与`can_move()`非常相似，这个函数如果我们可以将当前瓷砖与提供的位置的瓷砖合并，即如果坐标相同且位置包含具有相同值的瓷砖，则返回`True`。
- en: 'This is the unabridged listing of the described method. Compare this function
    to its counterpart, `can_move()`, and you will notice that it looks almost identical:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是描述的方法的不完整列表。将此函数与其对应函数`can_move()`进行比较，你会注意到它们几乎完全相同：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this function in place, we can now expand the `Board.move()` function to
    support merging cells.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个函数之后，我们现在可以扩展`Board.move()`函数以支持合并单元格。
- en: 'Just add the following snippet after the movement `while self.can_move()` block:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在`while self.can_move()`移动块之后添加以下片段：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please see the full source code for this project if you're unsure about the
    code layout. The latest version of all the source code accompanying this book
    can be found at [https://github.com/mvasilkov/kb](https://github.com/mvasilkov/kb).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对代码布局不确定，请参阅此项目的完整源代码。本书所有源代码的最新版本可在[https://github.com/mvasilkov/kb](https://github.com/mvasilkov/kb)找到。
- en: Again, this code resembles the movement logic, with two notable differences.
    The tile we're combining with gets removed using `remove_widget()`, and the remaining
    tile's number is updated, which means that we need to also update its colors.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此代码与移动逻辑相似，有两个显著的不同之处。我们要合并的瓷砖使用`remove_widget()`移除，剩余瓷砖的数字被更新，这意味着我们还需要更新其颜色。
- en: So, our tiles merge happily and their values add up. The game would absolutely
    be playable at this point, if not for the last few things discussed next.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的瓷砖愉快地合并，它们的值相加。如果不是接下来讨论的最后几件事，游戏现在绝对可以玩。
- en: Adding more tiles
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加更多瓷砖
- en: Our game really should spawn new tiles after each turn. To complicate things
    further, this has to be done at the end of the animation sequence, when tiles
    that were affected by the last turn are done moving.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏确实应该在每一回合结束后生成新的瓷砖。更进一步的是，这需要在动画序列的末尾完成，当受上一回合影响的瓷砖完成移动后。
- en: Thankfully, there is a fitting event, `Animation.on_complete`, which is exactly
    what we're going to use here. Since we run a number of animations equal to the
    number of active tiles simultaneously, we need to bind the event only to the first
    `Animation` instance—they all start at the same time and have the same duration
    anyway, so there shouldn't be a noticeable difference between the timings of the
    first and the last animation in a synchronized batch.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个合适的事件，`Animation.on_complete`，这正是我们要在这里使用的。由于我们同时运行多个动画，动画的数量等于活动瓷砖的数量，我们只需要将事件绑定到第一个`Animation`实例——它们都同时开始并且具有相同的持续时间，所以同步批量中第一个和最后一个动画之间的时间差不应该有明显的差异。
- en: 'The implementation resides in the same `Board.move()` method that we''ve seen
    previously:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 实现位于我们之前看到的同一个`Board.move()`方法中：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As soon as the animation ends and the `on_complete` event fires, `new_tile()`
    is called and the game continues.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦动画结束并且触发`on_complete`事件，就会调用`new_tile()`，游戏继续。
- en: The reason we introduce a Boolean flag named `moving` is to ensure that `new_tile()`
    won't be called more than once per turn. Skipping this check leads to the board
    getting flooded with new titles in no time.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入名为`moving`的布尔标志的原因是确保`new_tile()`在每个回合中不会调用超过一次。跳过这个检查会导致棋盘在短时间内被新的标题淹没。
- en: Synchronizing turns
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步回合
- en: 'You might have noticed that there is a bug in the current implementation of
    animated tiles: the player can start a new turn before the previous one has ended.
    The easiest way to reproduce and obviate this issue is to increase the duration
    of the movement considerably, for example, to 10 seconds:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当前动画瓷砖的实现中存在一个错误：玩家可以在前一个回合结束之前开始新的回合。解决这个问题的最简单方法是将移动的持续时间大大增加，例如，增加到10秒：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The easiest way we can fix this bug is by ignoring subsequent calls to `move()`
    while the tiles are in motion already. In order to do that, we have to broaden
    the scope of the previously seen `moving` flag. From now on, it will be a property
    of the `Board` class. We are also adjusting the `move()` method accordingly:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修复这个错误的简单方法是忽略在瓷砖移动过程中对`move()`的后续调用。为了做到这一点，我们必须扩大之前看到的`moving`标志的作用范围。从现在起，它将成为`Board`类的一个属性。我们也在相应地调整`move()`方法：
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Don't forget to reset `moving` back to `False` in `new_tile()`, or else tiles
    will cease to move at all after the first turn.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`new_tile()`中将`moving`重置回`False`，否则瓷砖在第一回合之后将不再移动。
- en: Game over
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束
- en: One more thing that is missing from the game is the "game over" state. We discussed
    winning and losing conditions at the beginning of the chapter, so it's stylistically
    appropriate to end the implementation with the same topic.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中缺少的另一件事是“游戏结束”状态。我们在本章开头讨论了胜利和失败的条件，因此以相同的话题结束实现是符合风格的。
- en: The winning condition
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 胜利条件
- en: 'Testing whether the player has managed to assemble a 2048 tile can be easily
    done in the only place where the tile value is doubled when combining tiles in
    the `Board.move()` function:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 测试玩家是否成功组装了一个2048瓷砖可以在`Board.move()`函数中合并瓷砖时值加倍的唯一地方轻松完成：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that the specific UI for reporting end game conditions is purposefully
    omitted. Creating yet another simple screen with a button and some text would
    unnecessarily clutter the chapter without adding anything to the content already
    present in the book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，报告游戏结束条件的特定UI故意省略了。创建另一个带有按钮和一些文本的简单屏幕会不必要地使章节变得杂乱，而不会增加书中已有的内容。
- en: In other words, implementing visually appealing end game states is again left
    as an exercise—we will only suggest an algorithm for detecting them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，实现视觉上吸引人的游戏结束状态再次留作练习——我们只会建议一个检测它们的算法。
- en: To test end game conditions, it may be useful to lower the winning requirement
    severely by replacing `2048` by, for example, `64`, but don't forget to change
    it back before a public release!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试游戏结束条件，可能需要将胜利要求严重降低，例如将`2048`替换为`64`，但别忘了在公开发布前将其改回！
- en: The loss condition
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 失败条件
- en: 'This algorithm is a bit more complex, and as such it can be written in a number
    of ways. Probably the most literal approach would be to traverse the board completely
    before each move to test whether the board is deadlocked:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法稍微复杂一些，因此可以用多种方式编写。最直接的方法可能是在每次移动之前完全遍历棋盘，以测试棋盘是否陷入死胡同：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The explanation: for every tile on the board we''re testing the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：对于棋盘上的每个瓷砖，我们正在测试以下内容：
- en: Found an empty cell? This instantly means that we're not deadlocked—another
    tile can move to that cell.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个空单元格？这立刻意味着我们并没有陷入死胡同——另一个瓷砖可以移动到那个单元格。
- en: Otherwise, if the selected tile can combine with the one to the right or to
    the bottom, we're good, since we have a possible move.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果选中的瓷砖可以与右侧或下方的瓷砖组合，那么我们就没问题，因为我们有一个可能的移动。
- en: If all else fails and we cannot find a cell that satisfies either of the previous
    conditions, this means we're out of moves—the game is over at this point.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有其他方法都失败了，我们找不到满足上述任一条件的单元格，这意味着我们无法移动了——游戏到此结束。
- en: '![The loss condition](img/B01620_06_05.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![失败条件](img/B01620_06_05.jpg)'
- en: 'Game over: there are no valid moves'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束：没有有效的移动
- en: 'A fitting place to run this test would be in the `new_tile()` method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试的一个合适的地方是在`new_tile()`方法中：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The precondition (`len(empty_cells) == 1`) allows us to run the check less
    often: there is no point in testing for the loss when the board isn''t full yet.
    It''s worth noting that our `is_deadlocked()` method would have correctly returned
    `False` in this case anyway, so this is purely an optimization, not affecting
    the "business logic" in any way.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 预设条件（`len(empty_cells) == 1`）允许我们减少检查的频率：在棋盘还没有满的情况下测试失败是没有意义的。值得注意的是，我们的`is_deadlocked()`方法在这种情况下也会正确返回`False`，所以这纯粹是一个优化，不会以任何方式影响“业务逻辑”。
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'This approach is still a little suboptimal, performance-wise, and could be
    improved at the cost of lengthening the code: one obvious optimization would be
    skipping the last row and column, and then not checking for bounds on each iteration,
    which `can_combine()` function implicitly does.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在性能上仍然略逊一筹，可以通过增加代码长度来改进：一个明显的优化是跳过最后一行和最后一列，然后在每次迭代中不必检查边界，这是`can_combine()`函数隐式执行的。
- en: However, the gain in this case would be negligible, since this check runs at
    most once every turn, and we're mostly waiting for user input anyway.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种检查的收益可以忽略不计，因为这种检查最多每回合运行一次，我们大多数时间都在等待用户输入。
- en: Where to go from here
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来该做什么
- en: 'The game is finally playable, but there certainly are many areas in which it
    can be improved. If you''re willing to toy with the concept of 2048 some more,
    consider some of the following tasks:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在终于可以玩了，但确实有许多可以改进的地方。如果你愿意进一步探索2048的概念，可以考虑以下任务：
- en: Add more animations—they do wonders in terms of perceived interactivity.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多动画——它们在感知交互方面大有裨益。
- en: As an additional motivational factor, add a score counter and the related infrastructure
    (for instance, the ability to save high scores and transmit them to the global
    server-side leaderboard).
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为额外的激励因素，添加分数计数器和相关的基础设施（例如，保存高分并将其传输到全球服务器端排行榜）。
- en: Tweak the game rules so that they are exactly like the original 2048 game.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整游戏规则，使其与原始的2048游戏完全一致。
- en: For a more mind-bending experimentation, build an algorithm that predicts fruitless
    game sessions in advance. As a player, I would positively love to receive a notification
    that reads, "No matter what you do, in 7 turns it's over for you, thanks for playing."
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了进行更具挑战性的实验，构建一个可以提前预测无果游戏会话的算法。作为一个玩家，我非常希望收到一条通知，内容为：“无论你做什么，7次回合后游戏就结束了，感谢你的参与。”
- en: Change the rules completely. Add a multiplayer arena death match mode—be creative.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全改变规则。添加多人竞技场死亡匹配模式——发挥创意。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're interested in seeing another, more complete Kivy implementation of
    the same 2048 game, take a look at [https://github.com/tito/2048](https://github.com/tito/2048).
    This project, written by a core Kivy developer Mathieu Virbel, features Google
    Play integration, achievements, and a high-score leaderboard, among other things.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，想看看另一个更完整的Kivy实现的2048游戏，请查看[https://github.com/tito/2048](https://github.com/tito/2048)。这个项目由核心Kivy开发者Mathieu
    Virbel编写，包括Google Play集成、成就和排行榜等功能。
- en: It should be postulated that reading other people's code is a great way to learn.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 应该假设阅读他人的代码是学习的好方法。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we built a playable replica of the 2048 game. We also showcased
    a number of implementation details that can be reused in other similar projects:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个可玩复制的2048游戏。我们还展示了一些可以在其他类似项目中重用的实现细节：
- en: Creating a scalable board that fits the screen in any resolution and orientation
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可伸缩的棋盘，使其在任何分辨率和方向上都能适应屏幕
- en: Putting together custom tiles, and implementing smooth movement for those with
    the help of Kivy's `Animation` API
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合自定义的方块，并利用Kivy的`Animation` API实现平滑的移动
- en: Mapping player's controls to both touch screen gestures and keyboard arrow keys
    at the same time, to account for any control scheme the user might expect from
    the game
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩家的控制映射到触摸屏手势和键盘方向键上，以适应用户可能期望从游戏中得到的任何控制方案
- en: The Kivy framework supports game development nicely; in particular, canvas rendering
    and support for animations can be very useful when building video games. Prototyping
    in Kivy is also feasible, albeit somewhat harder to do than in JavaScript (a modern
    browser is a very powerful platform, and it's especially hard to beat when it
    comes to cheap prototyping).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 框架在游戏开发方面支持得很好；特别是画布渲染和对动画的支持，在构建视频游戏时非常有用。在 Kivy 中进行原型设计也是可行的，尽管比在 JavaScript
    中（现代浏览器是一个非常强大的平台，特别是在廉价原型设计方面尤其难以超越）要困难一些。
- en: The resulting Python program is also inherently cross-platform unless you're
    using an OS-specific API in a way that prevents other systems from functioning.
    This means that technically your game can be played by everyone, reaching the
    widest possible audience.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 结果生成的 Python 程序也是跨平台的，除非你以某种方式使用特定于操作系统的 API，这会阻止其他系统运行。这意味着从技术上讲，你的游戏可以被每个人玩，达到最广泛的受众。
- en: The use of Kivy also doesn't conflict with publishing your work on major app
    distribution platforms, be it Apple AppStore, Google Play, or even Steam.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kivy 也不会与在主要应用分发平台上发布你的作品相冲突，无论是苹果应用商店、谷歌应用商店，甚至是 Steam。
- en: Certainly, Kivy lacks a great many features and most of the toolchain if compared
    to a full-fledged game engine like the Unreal Engine or Unity. This is due to
    the fact that Kivy is a general purpose UI framework and not a game engine per
    se; one can argue that such a comparison of vastly different software categories
    over respective feature sets is incorrect.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与像虚幻引擎或 Unity 这样的完整游戏引擎相比，Kivy 缺乏许多功能以及大部分工具链。这是因为 Kivy 是一个通用 UI 框架，而不是一个游戏引擎本身；有人可能会争论，这种在各自功能集上对截然不同的软件类别进行的比较是不正确的。
- en: To summarize, Kivy is a solid choice for sporadic indie game development. Angry
    Birds could have been implemented in Python and Kivy by *you*! Imagine the scale
    of the opportunity you've missed back then. (But please don't feel bad about this,
    it was meant as an encouragement. Rovio's path to a successful game title wasn't
    exactly easy either.)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Kivy 是一个不错的选择，适用于偶尔的独立游戏开发。愤怒的小鸟本可以用 Python 和 Kivy 来实现，这可能是你当时错过的机会规模。
    (但请不要为此感到难过，这只是一句鼓励的话。Rovio 成功游戏标题的道路也并不容易。)
- en: 'This brings us to the topic of the next chapter: writing an arcade game using
    Kivy. It will utilize the familiar concept of Kivy widgets in a variety of unorthodox
    ways to create an interactive side-scrolling environment, reminiscent of another
    critically acclaimed indie game, Flappy Bird.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了下一章的主题：使用 Kivy 编写街机游戏。它将以各种非常规的方式利用 Kivy 小部件的熟悉概念，创建一个交互式的横向卷轴环境，让人联想到另一款备受好评的独立游戏，Flappy
    Bird。
