- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Fetching Data with React APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React API获取数据
- en: Over the past few years, there has been an increase in the demand for database-driven
    web applications. This increase is a consequence of the abundance of data available
    at this present time. With widespread internet adoption, businesses leverage web
    applications to interact with customers, employees, and other stakeholders.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，对数据库驱动Web应用程序的需求有所增加。这种增加是当前数据丰富性的结果。随着互联网的广泛采用，企业利用Web应用程序与客户、员工和其他利益相关者进行互动。
- en: More than ever, web developers are constantly faced with tasks such as the organization
    and consumption of data. Both internal and external data require us to have smart
    and business-oriented database-driven web applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 比以往任何时候，Web开发者都面临着诸如数据组织和消费等任务。内部和外部数据都需要我们拥有智能且以业务为导向的数据库驱动Web应用程序。
- en: As a full stack software engineer, some of your frontend tasks will be to consume
    data, either from an internally developed API or a third-party API. Before we
    delve into approaches or tools you can use to fetch data in React projects, let’s
    briefly discuss what APIs are all about and why they are redefining ways of building
    user interfaces and web applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为全栈软件工程师，你的前端任务之一将是消费数据，无论是来自内部开发的API还是第三方API。在我们深入探讨在React项目中获取数据的方法或工具之前，让我们简要地讨论一下API是什么以及为什么它们正在重新定义构建用户界面和Web应用程序的方式。
- en: An API simply allows communication among systems using a set of rules in a standard
    accepted format. In web development, HTTP protocols define the set of rules for
    web-based systems communication. HTTP is a data exchange protocol used to fetch
    resources across the internet.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: API简单地说就是允许系统之间通过一组标准接受的格式中的规则进行通信。在Web开发中，HTTP协议定义了基于Web的系统通信的规则集。HTTP是一种用于在互联网上获取资源的数据交换协议。
- en: 'There are two major formats for exchanging data: **XML** and **JSON**. JSON
    is winning the popularity contest between these two widely used formats for data
    exchange. JSON is specifically designed for data interchange, handles arrays seamlessly,
    and is used widely among developers.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 数据交换有两种主要格式：**XML**和**JSON**。JSON在这两种广泛使用的数据交换格式中赢得了人气竞赛。JSON专门设计用于数据交换，无缝处理数组，并且在开发者中被广泛使用。
- en: In the React ecosystem, developers have access to a range of exposed interfaces
    designed to facilitate data fetching from various sources. These APIs are aimed
    at empowering React developers to create intuitive user interfaces and enhance
    the overall user experience when interacting with web applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在React生态系统内，开发者可以访问一系列公开的接口，旨在简化从各种来源获取数据。这些API旨在赋予React开发者创建直观用户界面并提升与Web应用程序交互的整体用户体验。
- en: 'In this chapter, we are going to learn about some of the methods and techniques
    used in React frontend development to fetch data from disparate sources. In this
    chapter, we will be covering the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些在React前端开发中用于从不同来源获取数据的方法和技术。在本章中，我们将涵盖以下主题：
- en: Fetching data using the Fetch API in React
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中使用Fetch API获取数据
- en: Fetching data using `async/await` syntax
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`async/await`语法获取数据
- en: Fetching data using Axios
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Axios获取数据
- en: Fetching data using React Query
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Query获取数据
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04).
- en: Fetching data using the Fetch API in React
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中使用Fetch API获取数据
- en: '**Fetch API** is an inbuilt API in a web browser that provides the JavaScript
    interface for communication over the internet using HTTP. Every web browser has
    a JavaScript engine as a runtime to compile and run JavaScript code.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fetch API**是Web浏览器内建的一个API，它提供了使用HTTP进行互联网通信的JavaScript接口。每个Web浏览器都有一个JavaScript引擎作为运行时来编译和运行JavaScript代码。'
- en: The React ecosystem relies inarguably on JavaScript. This is a fact and one
    of the reasons you are expected to understand modern JavaScript before delving
    into React application development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: React生态系统无疑依赖于JavaScript。这是一个事实，也是为什么在深入React应用程序开发之前，你被期望理解现代JavaScript的原因之一。
- en: As a React developer, you will need network resources to build web applications.
    The `fetch()` method provides you with the means to access and manipulate HTTP
    object requests and HTTP protocol responses. Let’s say that in our web application,
    we want to display the list of conference speakers and their associated data.
    This information is housed in another resource database server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名React开发者，你需要网络资源来构建网络应用。`fetch()`方法为你提供了访问和操作HTTP对象请求以及HTTP协议响应的手段。假设在我们的网络应用中，我们想要显示会议演讲者和他们相关的数据。这些信息存储在另一个资源数据库服务器上。
- en: 'From a third-party public API, we are going to consume the user’s resource
    to fetch hypothetical data to be used in our React application as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从第三方公开API中，我们将消费用户的资源以获取假设数据，用于我们的React应用，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s discuss the preceding `fetch` data snippet in detail:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一下前面的`fetch`数据片段：
- en: '`import React, { useEffect, useState } from ''react''`: This line imports React’s
    core functions and some Hooks for use in our component.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import React, { useEffect, useState } from ''react''`：这一行导入了React的核心函数和一些Hooks，用于在我们的组件中使用。'
- en: 'Initializing the `useState`: We initialize our state by calling `useState`
    in our component as follows:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化`useState`：我们在组件中通过调用`useState`来初始化我们的状态，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `useState` accepts an initial state of an empty array (`useState([])`)
    and returns two values, `data` and `setData`:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useState`接受一个初始状态为空数组（`useState([])`），并返回两个值，`data`和`setData`：'
- en: '`data`: The current state'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：当前状态'
- en: '`setData`: State updater function (this function is responsible for the new
    state of the initial state)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setData`：状态更新函数（此函数负责初始状态的新状态）'
- en: '`useState([])` is `useState` with the initial value of empty array`[]`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState([])`是带有初始值空数组`[]`的`useState`：'
- en: 'The following snippet has a global `fetch()` method that accepts the URL of
    the endpoint, `https://jsonplaceholder.typicode.com/users`, where we have the
    hypothetical resource for speakers:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码片段包含一个全局的`fetch()`方法，它接受端点URL，`https://jsonplaceholder.typicode.com/users`，其中包含我们假设的资源，用于演讲者：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The URL in the preceding code is our resource endpoint. It returns JSON as data.
    `setData()` accepts the new state, which is the returned data in JSON.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码中的URL是我们的资源端点。它返回JSON格式的数据。`setData()`函数接受新的状态，即返回的JSON数据。
- en: 'The `useEffect` Hook is used to invoke the `getSpeaker` function:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useEffect`钩子来调用`getSpeaker`函数：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`map()` is invoked on the data array and used to iterate on the speakers’ data
    to display details on the screen:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据数组上调用`map()`函数，用于遍历演讲者的数据并在屏幕上显示详细信息：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In sum, `fetch()` accepts the resource URL ([https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users))
    as an argument, which is the path to the resource over the network we are interested
    in, and returns to a promise that moves to the status of fulfilled once the requested
    resource response is available.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`fetch()`函数接受资源URL（[https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)）作为参数，这是我们所感兴趣的网络资源路径，并且当请求的资源响应可用时，返回一个状态为已满足的Promise。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In real-world applications, it’s crucial to manage network errors effectively,
    especially when data retrieval encounters issues or when the absence of data occurs.
    Additionally, implementing a loading state can significantly enhance the overall
    user experience.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，有效地管理网络错误至关重要，尤其是在数据检索遇到问题或数据缺失时。此外，实现加载状态可以显著提升整体用户体验。
- en: Next, we are going to look at another technique for fetching data in React projects
    using `async/await` using the ECMAScript 2017 feature.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨在React项目中使用`async/await`和ECMAScript 2017特性来获取数据的另一种技术。
- en: Fetching data using async/await syntax
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`async/await`语法获取数据
- en: 'There are three ways to write asynchronous codes in vanilla JavaScript: callbacks,
    promises, and `async/await`. In this section, we are going to focus on `async`
    `/await` and see how it can be used in React web applications. `async/await` is
    an improvement on promises.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯JavaScript中编写异步代码有三种方式：回调函数、Promise和`async/await`。在本节中，我们将重点关注`async` `/await`，并探讨它如何在React网络应用中使用。`async/await`是对Promise的改进。
- en: 'The following snippet explains how `async/await` can be used to fetch data
    from an API using a promise-based approach:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段解释了如何使用基于Promise的方法通过`async/await`从API获取数据：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s discuss the preceding code snippet, which demonstrates how to use `async/await`
    to fetch data asynchronously:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下前面的代码片段，它展示了如何使用`async/await`异步获取数据：
- en: '`import React, { useEffect, useState } from ''react''`: This line imports React
    core functions and some Hooks for use in our component.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import React, { useEffect, useState } from ''react''`: 这行代码导入 React 核心函数和一些
    Hooks 以用于我们的组件。'
- en: 'Initializing the `useState`: We initialize our state by calling `useState`
    in our component as follows:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '初始化 `useState`: 我们通过在组件中调用 `useState` 来初始化我们的状态，如下所示：'
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`useState` accepts an initial state of empty array (`useState([])`) and returns
    two values, `data` and `setData`:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useState` 接受一个空数组的初始状态（`useState([])`）并返回两个值，`data` 和 `setData`：'
- en: '`data`: The current state'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`: 当前状态'
- en: '`setData`: State updater function (this function is responsible for the new
    state of the initial state)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setData`: 状态更新函数（此函数负责初始状态的新状态）'
- en: '`useState([])` is `useState` with the initial value of empty array`[]`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState([])` 是带有空数组初始值 `[]` 的 `useState`。'
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have the hypothetical resource for speakers in the preceding endpoint. This
    is our resource endpoint. It returns JSON as data. `setData()` accepts the new
    state, which is the returned data in JSON.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的端点中，我们有假设的演讲者资源。这是我们的资源端点。它返回 JSON 格式的数据。`setData()` 接受新的状态，即返回的 JSON 数据。
- en: 'The `useEffect` Hook is used to invoke the `fetchSpeakers` function, which
    fetches data asynchronously from the endpoint `const API_URL = "`[https://dummyjson.com/users](https://dummyjson.com/users)`"`:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子用于调用 `fetchSpeakers` 函数，该函数从端点 `const API_URL = "`[https://dummyjson.com/users](https://dummyjson.com/users)`"`
    异步获取数据：'
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The array dependency is supplied with the data state. When the data state changes,
    maybe because of the addition or removal of speakers in the list, the component
    re-renders and shows the updated state.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数组依赖项提供数据状态。当数据状态发生变化时，可能是由于列表中添加或删除演讲者，组件会重新渲染并显示更新后的状态。
- en: 'Finally, `map()` is invoked on the data, and it is used to iterate on the speakers’
    data to render details to the screen:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`map()` 在数据上被调用，它用于遍历演讲者的数据以将详细信息渲染到屏幕上：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `async/await` approach of fetching data gives your codes better organization
    and improves the responsiveness and performance of your React applications. The
    non-blocking mode of `async/await` means you can carry on with the rest of the
    code operations while you await responses from a large amount of data running
    tasks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async/await` 方法获取数据可以为你的代码提供更好的组织结构，并提高你的 React 应用的响应性和性能。`async/await`
    的非阻塞模式意味着你可以在等待大量数据运行任务响应的同时继续执行其他代码操作。
- en: Next, we are going to look at another approach for fetching data from an API,
    using a third-party npm package called Axios.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨另一种从 API 获取数据的方法，使用名为 Axios 的第三方 npm 包。
- en: Fetching data using Axios
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Axios 获取数据
- en: '**Axios** is simply a lightweight JavaScript, promise-based HTTP client used
    to consume API services. It is mainly used in the browser and Node.js. To use
    Axios in our project, open the project terminal and type the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Axios** 是一个轻量级的基于 Promise 的 HTTP 客户端，用于消费 API 服务。它主要用于浏览器和 Node.js。要在我们的项目中使用
    Axios，请打开项目终端并输入以下命令：'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s see how to use Axios in the following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在以下代码片段中使用 Axios：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s examine the preceding code snippet to see how Axios can be used in data
    fetching:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查前面的代码片段，看看 Axios 如何在数据获取中使用：
- en: '`import React, { useEffect, useState } from ''react''`: This line imports React
    core functions and some Hooks for use in our component.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import React, { useEffect, useState } from ''react''`: 这行代码导入 React 核心函数和一些
    Hooks 以用于我们的组件。'
- en: '`import axios from "axios"`: This line brings in the already installed Axios
    package for use in the project.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import axios from "axios"`: 这行代码将已安装的 Axios 包引入到项目中以便使用。'
- en: 'Initializing `useState`: We initialize our state by calling `useState` in our
    component as follows:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '初始化 `useState`: 我们通过在组件中调用 `useState` 来初始化我们的状态，如下所示：'
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`useState` accepts an initial state of an empty array (`useState([])`) and
    returns two values, `data` and `setData`:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState` 接受一个空数组的初始状态（`useState([])`）并返回两个值，`data` 和 `setData`：'
- en: '`data`: The current state'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`: 当前状态'
- en: '`setData`: State updater function (this function is responsible for the new
    state of the initial state)'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setData`: 状态更新函数（此函数负责初始状态的新状态）'
- en: '`useState([])` is `useState` with the initial value of empty array`[]`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState([])` 是带有空数组初始值 `[]` 的 `useState`。'
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is our resource endpoint. It returns JSON as data. The `setData()` accepts
    the new state, which is the returned data in JSON.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们的资源端点。它返回 JSON 格式的数据。`setData()` 接受新的状态，即返回的 JSON 数据。
- en: 'The `getSpeakers` function uses `axios.get()` to fetch external data from the
    endpoint and return a promise. The state value is updated, and we have a new state
    in `setData` from the response object:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getSpeakers` 函数使用 `axios.get()` 从端点获取外部数据并返回一个承诺。状态值被更新，我们从响应对象中获取一个新的状态 `setData`：'
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `useEffect` Hook is used to call `getSpeaker()` and renders the component:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useEffect` 钩子调用 `getSpeaker()` 并渲染组件：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, `map()` is used to iterate on the speakers’ data and display names
    and emails on the screen.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，使用 `map()` 函数遍历演讲者的数据，并在屏幕上显示姓名和电子邮件。
- en: Moving on to data fetching techniques in React, we are going to look at another
    approach to fetching data using React Query.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 React 中的数据获取技术，我们将探讨使用 React Query 获取数据的一种新方法。
- en: Fetching data using the React Query in React
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 中使用 React Query 获取数据
- en: '**React Query** is an npm package library created for data fetching purposes
    with a ton of functionalities loaded with it. In React Query, the state management,
    pre-fetching of data, request retries, and caching are handled out of the box.
    React Query is a critical component of the React ecosystem with over a million
    downloads weekly.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Query** 是一个用于数据获取目的的 npm 包库，其中包含大量功能。在 React Query 中，状态管理、数据预取、请求重试和缓存都是开箱即用的。React
    Query 是 React 生态系统的一个关键组件，每周下载量超过一百万。'
- en: 'Let’s refactor the code snippet we used in the *Fetching data using Axios*
    section and experience the awesomeness of React Query:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们在 *使用 Axios 获取数据* 部分使用的代码片段，并体验 React Query 的神奇之处：
- en: 'First, install React Query. In the root directory of the project, do the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装 React Query。在项目的根目录中，执行以下操作：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside `App.js`, add the following:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App.js` 中添加以下内容：
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Check the preceding *Fetching data using Axios* section to compare the code
    snippet. The React Query snippet is way shorter and more concise. The need for
    `useState` and `useEffect` Hooks have been handled out of the box by the `useQuery()`
    Hook.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面的 *使用 Axios 获取数据* 部分，比较代码片段。React Query 的代码片段要短得多，更简洁。`useState` 和 `useEffect`
    钩子的需求已经被 `useQuery()` 钩子开箱即用处理。
- en: 'Let’s dissect the preceding code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的代码：
- en: '`useQuery` accepts two arguments: the query key (`speakers`) and a callback
    function that uses `axios()` to fetch a hypothetical speaker from the resource
    endpoint.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useQuery` 接受两个参数：查询键（`speakers`）和一个使用 `axios()` 从资源端点获取假设演讲者的回调函数。'
- en: '`useQuery` is destructured with variables – `{data, isLoading, error}`. We
    then check to see whether there is an error message coming from the error object.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useQuery` 使用变量进行解构 – `{data, isLoading, error}`。然后我们检查是否有来自错误对象的错误消息。'
- en: Once we have data, then the `return()` function returns an array of speakers’
    data.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们有了数据，`return()` 函数就返回一个演讲者数据的数组。
- en: 'Inside `index.js`, add the following code. The existing `index.js` codes are
    presumed present:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.js` 中添加以下代码。假设现有的 `index.js` 代码已经存在：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s have some explanation of the code snippet in `index.js`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `index.js` 中的代码片段进行一些解释：
- en: 'Import the `{ QueryClient, QueryClientProvider }` from React Query: `QueryClient`
    allows us to leverage the global defaults for all queries and mutations in React
    Query. The `QueryClientProvider` connects and provides a `QueryClient` to the
    application.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 React Query 导入 `{ QueryClient, QueryClientProvider }`：`QueryClient` 允许我们在
    React Query 中利用所有查询和变更的全局默认值。`QueryClientProvider` 连接到应用程序并提供一个 `QueryClient`。
- en: 'Create a new `QueryClient` instance, `queryClient`: Wrap your component with
    `QueryClientProvider`—in this case, `<App` `/>` is the component—and pass the
    new instance as an attribute value.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 `QueryClient` 实例 `queryClient`：将组件包裹在 `QueryClientProvider` 中——在这个例子中，`<App/>`
    是组件，并将新实例作为属性值传递。
- en: 'Now run `npm start` if `localhost:3000` is not running. The following should
    be displayed on the screen:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `localhost:3000` 没有运行，现在运行 `npm start`。屏幕上应该显示以下内容：
- en: '![Figure 4.1 – Screenshot showing the usage of React Query in fetching data](img/Figure_4.1_B18554.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 屏幕截图展示了 React Query 在获取数据中的应用](img/Figure_4.1_B18554.jpg)'
- en: Figure 4.1 – Screenshot showing the usage of React Query in fetching data
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 屏幕截图展示了 React Query 在获取数据中的应用
- en: React Query is very effective at fetching data from API resources. It encapsulates
    functions that may be required by `useState` and `useEffect`. React Query radically
    redefines the way we fetch data in React applications by introducing a powerful
    caching mechanism with the `queryKey`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 在从 API 资源获取数据方面非常有效。它封装了可能由 `useState` 和 `useEffect` 需要的函数。通过引入带有
    `queryKey` 的强大缓存机制，React Query 根本重新定义了我们在 React 应用程序中获取数据的方式。
- en: Instead of manually managing data fetching and caching, React Query handles
    it transparently. React Query allows developers to easily fetch and cache data
    with just a few lines of code, reducing boilerplate and improving performance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动管理数据获取和缓存不同，React Query 以透明的方式处理这些操作。React Query 允许开发者仅用几行代码就轻松地获取和缓存数据，从而减少样板代码并提高性能。
- en: The library provides various Hooks and utilities that simplify data fetching,
    error handling, and data synchronization with the server, leading to a more efficient
    and seamless user experience. Exploring React Query further can open up a world
    of possibilities in handling complex data fetching scenarios and optimizing data
    management in React applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆提供了各种钩子和实用工具，这些工具简化了数据获取、错误处理以及与服务器之间的数据同步，从而带来了更高效、更流畅的用户体验。进一步探索 React
    Query 可以打开处理复杂数据获取场景和优化 React 应用程序数据管理的新世界。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Handling data is a critical component of any web application. React has proven
    to be very efficient and scalable in handling data at scale. In this chapter,
    we discussed various approaches you can utilize in your project to handle data
    fetching. We discussed fetching data using the Fetch API, `async/await`, Axios,
    and React Query.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据是任何网络应用程序的关键组成部分。React 已经证明在处理大量数据时非常高效和可扩展。在本章中，我们讨论了您可以在项目中利用的各种处理数据获取的方法。我们讨论了使用
    Fetch API、`async/await`、Axios 和 React Query 获取数据。
- en: In the next chapter, we are going to discuss JSX and how you can display lists
    in React.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 JSX 以及如何在 React 中显示列表。
