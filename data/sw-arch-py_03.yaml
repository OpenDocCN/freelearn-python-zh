- en: Chapter 3. Testability – Writing Testable Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。可测试性 - 编写可测试代码
- en: In the previous chapter, we covered a very important architectural attribute
    of software, namely, Modifiability and its related aspects. In this chapter, the
    topic is a closely related quality attribute of **testability** of software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们涵盖了软件的一个非常重要的架构属性，即可修改性及其相关方面。在本章中，我们将讨论软件的一个与之密切相关的质量属性——软件的可测试性。
- en: We briefly covered testability in the first chapter of this book, where we understood
    what testability is, and how it relates to the complexity of the code. In this
    chapter, we will look into the different aspects of software testability in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一章中，我们简要介绍了可测试性，了解了可测试性是什么，以及它与代码复杂性的关系。在本章中，我们将详细探讨软件可测试性的不同方面。
- en: Software testing by itself has developed into a large field with its own standards
    and unique set of tools and processes. The focus of this chapter is not to cover
    the formal aspects of software testing. Instead, what we will strive to do here
    is to understand software testing from an architectural perspective, understand
    its relation to the other quality attributes, and in the second half of the chapter,
    discuss the Python tools and libraries relevant to our discussion on software
    testing using Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试本身已经发展成一个拥有自己标准和独特工具和流程的大领域。本章的重点不是涵盖软件测试的正式方面。相反，我们在这里将努力从架构的角度理解软件测试，了解它与其他质量属性的关系，并在本章的后半部分讨论与我们在Python中使用软件测试相关的Python工具和库。
- en: Understanding testability
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解可测试性
- en: 'The testability can be defined as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可测试性可以定义如下：
- en: '*"The degree of ease with which a software system exposes its faults through
    execution-based testing"*'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“软件系统通过基于执行的测试轻松暴露其故障的程度”*'
- en: A software system with a high level of testability provides a high degree of
    exposure of its faults through testing, thereby giving the developers higher accessibility
    to the system's issues, and allowing them to find and fix bugs faster. A less
    testable system, on the other hand, would make it difficult for the developers
    to figure out issues with it, and can often lead to unexpected failures in production.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 具有高可测试性的软件系统通过测试提供了其故障的高度暴露，从而使开发人员更容易访问系统的问题，并允许他们更快地找到和修复错误。另一方面，可测试性较低的系统会使开发人员难以找出其中的问题，并且往往会导致生产中的意外故障。
- en: The testability is, thus, an important aspect in ensuring the quality, stability,
    and predictability of the software system in production.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可测试性是确保软件系统在生产中的质量、稳定性和可预测性的重要方面。
- en: Software testability and related attributes
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件的可测试性和相关属性
- en: A software system is testable if it gives up (exposes) its faults easily to
    the tester. Not only that, the system should behave in a predictable way for the
    tester to develop useful tests. An unpredictable system would give varying outputs
    to a fixed input at varying times, hence, is not testable (or very useful for
    that matter!).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件系统能够很容易地向测试人员暴露其故障，那么它就是可测试的。而且，系统应该以可预测的方式对测试人员进行有用的测试。一个不可预测的系统会在不同的时间给出不同的输出，因此是不可测试的（或者说没有用！）。
- en: More than unpredictability, complex or chaotic systems are also less amenable
    to testing. For example, a system whose behavior varies wildly across a spectrum
    under load doesn't make a good candidate for load testing. Hence, deterministic
    behavior is also important to assure the testability of a system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与不可预测性一样，复杂或混乱的系统也不太适合测试。例如，一个在负载下行为迥异的系统并不适合进行负载测试。因此，确定性行为对于确保系统的可测试性也是重要的。
- en: Another aspect is the amount of control that the tester has on the substructures
    of the system. In order to design meaningful tests, a system should be easily
    identifiable to subsystems with their well-defined APIs, for which tests can be
    written . A software system that is complex, and doesn't provide easy access to
    its subsystems, by definition, becomes much less testable than the one which does.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方面是测试人员对系统子结构的控制程度。为了设计有意义的测试，系统应该很容易地被识别为具有明确定义的API的子系统，可以为其编写测试。一个复杂的软件系统，如果不能轻松访问其子系统，从定义上来说，比那些可以访问的系统要难以测试得多。
- en: This means that systems which are more structurally complex are more difficult
    to test than ones which aren't.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着结构上更复杂的系统比那些不复杂的系统更难测试。
- en: Let us list this down in an easy-to-read table.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些列在一个易于阅读的表格中。
- en: '| Determinism | Complexity | Testability |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 确定性 | 复杂性 | 可测试性 |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| High | Low | High |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 高 | 低 | 高 |'
- en: '| Low | High | Low |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 低 | 高 | 低 |'
- en: Testability – architectural aspects
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试性 - 架构方面
- en: Software testing generally implies that the software artifact being tested is
    being assessed for its functionality. However, in practical software testing,
    functionality is just one of the aspects that can fail. Testing implies assessing
    the software for other quality attributes such as performance, security, robustness,
    and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试通常意味着正在评估被测试的软件产品的功能。然而，在实际的软件测试中，功能只是可能失败的方面之一。测试意味着评估软件的其他质量属性，如性能、安全性、健壮性等。
- en: Due to these different aspects of testing, software testability is usually grouped
    at different levels. We will take a look at these from the point of view of software
    architecture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试的不同方面，软件的可测试性通常被分为不同的级别。我们将从软件架构的角度来看这些方面。
- en: 'Here is a brief listing of the different aspects that usually fall under software
    testing:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通常属于软件测试的不同方面的简要列表：
- en: '**Functional testing**: This involves testing the software for verifying its
    functionality. A unit of software passes its functional test if it behaves exactly
    the way it is supposed to as per its development specifications. Functional testing
    is usually of two types:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试：这涉及测试软件以验证其功能。如果软件单元按照其开发规范的预期行为，它通过了功能测试。功能测试通常有两种类型：
- en: '**White-box testing**: These are usually tests implemented by the developers,
    who have visibility into the software code, themselves. The units being tested
    here are the individual functions, methods, classes, or modules that make up the
    software rather than the end user functionality. The most basic form of white-box
    testing is **Unit testing**. Other types are **integration testing** and **system
    testing**.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白盒测试：这些通常是由开发人员实施的测试，他们可以看到软件代码。这里测试的单元是组成软件的个别函数、方法、类或模块，而不是最终用户功能。白盒测试的最基本形式是单元测试。其他类型包括集成测试和系统测试。
- en: '**Black-box testing**: This type of testing is usually performed by someone
    who is outside the development team. The tests have no visibility into the software
    code, and treat the entire system like a black box. Black-box testing tests the
    end user functionality of the system without bothering about its internal details.
    Such tests are usually performed by dedicated testing or QA engineers. However,
    nowadays, a lot of black-box tests on web-based applications can be automated
    by using testing frameworks like Selenium.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑盒测试：这种类型的测试通常由开发团队之外的人员执行。测试对软件代码没有可见性，将整个系统视为黑盒。黑盒测试测试系统的最终用户功能，而不关心其内部细节。这些测试通常由专门的测试或QA工程师执行。然而，如今，许多基于Web的应用程序的黑盒测试可以通过使用Selenium等测试框架进行自动化。
- en: Other than functional testing, there are a lot of testing methodologies, which
    are used to assess the various architectural quality attributes of a system. We
    will discuss these next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了功能测试之外，还有许多测试方法，用于评估系统的各种架构质量属性。我们将在下面讨论这些。
- en: '**Performance testing**: Tests which measure how a software performs with respect
    to its responsiveness and robustness (stability) under high workloads come within
    this category. Performance tests are usually categorized into the following:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试：衡量软件在高负载下的响应性和鲁棒性（稳定性）的测试属于这一类别。性能测试通常分为以下几种：
- en: '**Load testing**: Tests that assess how a system performs under a certain specific
    load, either in terms of the number of concurrent users, input data, or transactions.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载测试：评估系统在特定负载下的性能，无论是并发用户数量、输入数据还是事务。
- en: '**Stress testing**: Tests the robustness and response of the system when some
    inputs present a sudden or high rate of growth and go to extreme limits. Stress
    tests typically tend to test the system slightly beyond its prescribed design
    limits. A variation of stress testing is running the system under a certain specified
    load for extended periods of time, and measuring its responsiveness and stability.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力测试：当某些输入突然或高速增长并达到极限时，测试系统的鲁棒性和响应。压力测试通常倾向于在规定的设计极限之外轻微测试系统。压力测试的变体是在一定的负载下长时间运行系统，并测量其响应性和稳定性。
- en: '**Scalability testing**: Measure how much the system can scale out or scale
    up when the load is increased. For example, if a system is configured to use a
    cloud service, this can test the horizontal scalability—as in how the system auto
    scales to a certain number of nodes upon increased load, or vertical scalability—in
    terms of the degree of utilization of CPU cores and/or RAM of the system.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性测试：衡量系统在负载增加时能够扩展或扩大多少。例如，如果系统配置为使用云服务，这可以测试水平可扩展性——即系统在负载增加时如何自动扩展到一定数量的节点，或垂直可扩展性——即系统CPU核心和/或RAM的利用程度。
- en: '**Security testing**: Tests that verify the system''s security fall into this
    category. For web-based applications, this usually involves verifying authorization
    of roles by checking that a given login or role can only perform a specified set
    of actions and nothing more (or less). Other tests that fall under security would
    be to verify proper access to data or static files to make sure that all sensitive
    data of an application is protected by proper authorization via logins.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全测试：验证系统安全性的测试属于这一类别。对于基于Web的应用程序，这通常涉及通过检查给定的登录或角色只能执行指定的一组操作而不多（或更少）来验证角色的授权。属于安全性的其他测试包括验证对数据或静态文件的适当访问，以确保应用程序的所有敏感数据都受到适当的登录授权保护。
- en: '**Usability testing**: Usability testing involves testing how much the user
    interface of a system is easy to use, is intuitive, and understandable by its
    end users. Usability testing is usually done via target groups comprising selected
    people who fall into the definition of the intended audience or end users of the
    system.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性测试：可用性测试涉及测试系统的用户界面对其最终用户是否易于使用、直观和可理解。可用性测试通常通过包括符合预期受众或系统最终用户定义的选定人员的目标群体来进行。
- en: '**Installation testing**: For software that is shipped to the customer''s location
    and is installed there, installation testing is important. This tests and verifies
    that all the steps involved in building and/or installing the software at the
    customer''s end work as expected. If the development hardware differs from the
    customer''s, then the testing also involves verifying the steps and components
    in the end user''s hardware. Apart from a regular software installation, installation
    testing is also important when delivering software updates, partial upgrades,
    and so on.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装测试：对于运送到客户位置并在那里安装的软件，安装测试很重要。这测试并验证了在客户端构建和/或安装软件的所有步骤是否按预期工作。如果开发硬件与客户的不同，那么测试还涉及验证最终用户硬件中的步骤和组件。除了常规软件安装外，当交付软件更新、部分升级等时，安装测试也很重要。
- en: '**Accessibility testing**: Accessibility, from a software standpoint, refers
    to the degree of usability and inclusion of a software system towards end users
    with disabilities. This is usually done by incorporating support for accessibility
    tools in the system, and designing the user interface by using accessible design
    principles. A number of standards and guidelines have been developed over the
    years, which allow organizations to develop software with a view to making the
    software accessible to such an audience. Examples are the **Web Content Accessibility
    Guidelines** (**WCAG**) of W3C, Section 508 of the Government of USA, and the
    like.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性测试**：从软件角度来看，可访问性指的是软件系统对残障用户的可用性和包容性程度。通常通过在系统中加入对可访问性工具的支持，并使用可访问性设计原则设计用户界面来实现。多年来已经制定了许多标准和指南，允许组织开发软件以使其对这样的受众具有可访问性。例如，W3C的**Web内容可访问性指南**（**WCAG**）、美国政府的第508节等。'
- en: Accessibility testing aims to assess the accessibility of software with respect
    to these standards, wherever applicable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性测试旨在根据这些标准评估软件的可访问性，适用时。
- en: There are various other types of software testing, which involves different
    approaches, and are invoked at various phases of software development, such as
    Regression testing, Acceptance testing, Alpha or Beta testing, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有各种其他类型的软件测试，涉及不同的方法，并在软件开发的各个阶段调用，例如回归测试、验收测试、Alpha或Beta测试等。
- en: However, since our focus of discussion is on the architectural aspects of software
    testing, we will limit our attention to the topics mentioned in the previous list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们讨论的重点是软件测试的架构方面，我们将把注意力限制在前面列表中提到的主题上。
- en: Testability – strategies
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试性 - 策略
- en: We saw in a previous section how testability varies according to the complexity
    and determinism of the software system under testing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分中看到，测试性根据正在测试的软件系统的复杂性和确定性而变化。
- en: Being able to isolate and control the artifacts that are being tested is critical
    to software testing. Separation of concerns on the system being tested, as in
    being able to test components independently and without too much external dependency,
    is key to this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 能够隔离和控制正在测试的工件对软件测试至关重要。在测试系统的关注点分离中，即能够独立测试组件并且不过多地依赖外部是关键。
- en: Let us look at the strategies that the Software architect can employ in order
    to make sure that the components he is subjecting to tests provide predictable
    and deterministic behavior, which will provide valid and useful test results.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看软件架构师可以采用的策略，以确保他正在测试的组件提供可预测和确定的行为，从而提供有效和有用的测试结果。
- en: Reduce system complexity
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少系统复杂性
- en: 'As mentioned earlier, a complex system has lower testability. The system complexity
    can be reduced by techniques such as splitting systems into subsystems, providing
    well-defined APIs for systems to be tested, and so on. Here is a list of these
    techniques in some detail:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，复杂系统的可测试性较低。系统复杂性可以通过将系统拆分为子系统、为系统提供明确定义的API以进行测试等技术来减少。以下是这些技术的一些详细列表：
- en: '**Reducing coupling**: To isolate components so that coupling is reduced in
    the system. Inter-component dependencies should be well defined, and if possible,
    documented.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少耦合**：隔离组件，以减少系统中的耦合。组件间的依赖关系应该被明确定义，并且如果可能的话，应该被记录下来。'
- en: '**Increasing cohesion**: To increase cohesion of modules, that is, to make
    sure that a particular module or class performs only a well-defined set of functions.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**增加内聚性**：增加模块的内聚性，即确保特定模块或类只执行一组明确定义的功能。'
- en: '**Providing well-defined interfaces**: Try to provide well-defined interfaces
    for getting/setting the state of the components and classes involved. For example,
    getters and setters allow one to provide specific methods for getting and setting
    the value of a class''s attributes. A reset method allows to set the internal
    state of an object to its state at the time of creation. In Python, this can be
    done by defining properties.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供明确定义的接口**：尝试为获取/设置组件和类的状态提供明确定义的接口。例如，getter和setter允许提供用于获取和设置类属性值的特定方法。重置方法允许将对象的内部状态设置为其创建时的状态。在Python中，可以通过定义属性来实现这一点。'
- en: '**Reducing class complexity**: To reduce the number of classes a class derives
    from. A metric called **Response For Class** (**RFC**) is a set of methods of
    a class C, plus the methods on other classes called by the methods of class C.
    It is suggested to keep the RFC of a class in manageable limits, usually not more
    than 50 for small- to medium-sized systems.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少类的复杂性**：减少一个类派生的类的数量。一个称为**类响应**（**RFC**）的度量是类C的一组方法，以及类C的方法调用的其他类的方法。建议将类的RFC保持在可管理的限制范围内，通常对于小到中等规模的系统，不超过50。'
- en: Improving predictability
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高可预测性
- en: 'We saw that having a deterministic behavior is very important to design tests
    that provide predictable results, and hence, can be used to build a test harness
    for repeatable testing. Here are some strategies to improve the predictability
    of the code under test:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，具有确定性行为对设计提供可预测结果的测试非常重要，因此可以用于构建可重复测试的测试工具。以下是一些改善被测试代码可预测性的策略：
- en: '**Correct exception handling**: – Missing or improperly-written exception handlers
    is one of the main reasons for bugs and thence, unpredictable behavior in software
    systems. It is important to find out places in the code where exceptions can occur,
    and then handle errors. Most of the time, exceptions occur when a code interacts
    with an external resource such as performing a database query, fetching a URL,
    waiting on a shared mutex, and the like.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确的异常处理**：缺少或编写不当的异常处理程序是软件系统中错误和不可预测行为的主要原因之一。重要的是找出代码中可能发生异常的地方，然后处理错误。大多数情况下，异常发生在代码与外部资源交互时，例如执行数据库查询、获取URL、等待共享互斥锁等。'
- en: '**Infinite loops and/or blocked wait**: When writing loops that depend on specific
    conditions such as availability of an external resource, or getting handle to
    or data from a shared resource, say a shared mutex or queue, it is important to
    make sure that there are always safe exit or break conditions provided in the
    code. Otherwise, the code can get stuck in infinite loops that never break, or
    on never-ending blocked waits on resources causing bugs which are hard to troubleshoot
    and fix.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限循环和/或阻塞等待：当编写依赖于特定条件的循环时，比如外部资源的可用性，或者从共享资源（如共享互斥锁或队列）获取句柄或数据时，重要的是要确保代码中始终提供安全的退出或中断条件。否则，代码可能会陷入永远不会中断的无限循环，或者在资源上永远阻塞等待，导致难以排查和修复的错误。
- en: '**Logic that is time dependent**: When implementing logic that is dependent
    on certain times of the day (hours or specific weekdays), make sure that the code
    works in a predictable fashion. When testing such code, one often needs to isolate
    such dependencies by using mocks or stubs.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间相关的逻辑：在实现依赖于一天中特定时间（小时或特定工作日）的逻辑时，确保代码以可预测的方式工作。在测试这样的代码时，通常需要使用模拟或存根来隔离这些依赖关系。
- en: '**Concurrency**: When writing code that uses concurrent methods such as multiple
    threads and/or processes, it is important to make sure that the system logic is
    not dependent on threads or processes starting in any specific order. The system
    state should be initialized in a clean and repeatable way via well-defined functions
    or methods which allow the system behavior to be repeatable, and hence, testable.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发：在编写使用并发方法（如多线程和/或进程）的代码时，重要的是确保系统逻辑不依赖于线程或进程以任何特定顺序启动。系统状态应该通过定义良好的函数或方法以一种干净和可重复的方式初始化，从而使系统行为可重复，因此可测试。
- en: '**Memory Management**: A very common reason for software errors and unpredictability
    is incorrect usage and mismanagement of memory. In modern runtimes with dynamic
    memory management, such as Python, Java, or Ruby, this is less of a problem. However,
    memory leaks and unreleased memory leading to bloated software are still very
    much a reality in modern software systems.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理：软件错误和不可预测性的一个非常常见的原因是内存的错误使用和管理不当。在具有动态内存管理的现代运行时环境中，如Python、Java或Ruby，这不再是一个问题。然而，内存泄漏和未释放的内存导致软件膨胀仍然是现代软件系统中非常真实的问题。
- en: It is important to analyze and be able to predict the maximum memory usage of
    your software system so that you allocate enough memory for it, and run it in
    the right hardware. Also, software should be periodically evaluated and tested
    for memory leaks and better memory management, and any major issues should be
    addressed and fixed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要分析并能够预测软件系统的最大内存使用量，以便为其分配足够的内存，并在正确的硬件上运行。此外，软件应定期进行内存泄漏和更好的内存管理的评估和测试，并且应该解决和修复任何主要问题。
- en: Control and isolate external dependencies
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制和隔离外部依赖
- en: Tests usually have some sort of external dependency. For example, a test may
    need to load/save data to/from a database. Another may depend on the test running
    on specific times of the day. A third may require fetching data from a URL on
    the Web.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常具有某种外部依赖。例如，一个测试可能需要从数据库中加载/保存数据。另一个可能依赖于一天中特定的时间运行测试。第三个可能需要从Web上的URL获取数据。
- en: However, having external dependencies usually complicates a test scenario. This
    is because external dependencies are usually not within the control of the test
    designer. In the aforementioned cases, the database may be in another data center,
    or the connection may fail, or the website may not respond within the configured
    time, or give a 50X error.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，具有外部依赖通常会使测试场景变得更加复杂。这是因为外部依赖通常不在测试设计者的控制范围内。在上述情况下，数据库可能位于另一个数据中心，或者连接可能失败，或者网站可能在配置的时间内不响应，或者出现50X错误。
- en: 'Isolating such external dependencies is very important in designing and writing
    repeatable tests. The following are a few techniques for the same:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和编写可重复的测试时，隔离这些外部依赖非常重要。以下是一些相同的技术：
- en: '**Data sources**: Most realistic tests require data of some form. More often
    than not, data is read from a database. However, a database being an external
    dependency, cannot be relied upon. The following are a few techniques to control
    data source dependencies:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源：大多数真实的测试都需要某种形式的数据。往往情况下，数据是从数据库中读取的。然而，数据库作为外部依赖，不能被依赖。以下是一些控制数据源依赖的技术：
- en: 'Using local files instead of a database: Quite often, test files with prefilled
    data can be used instead of querying a database. Such files could be text, JSON,
    CSV, or YAML files. Usually, such files are used with mock or stub objects.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地文件而不是数据库：经常可以使用预填充数据的测试文件，而不是查询数据库。这些文件可以是文本、JSON、CSV或YAML文件。通常，这些文件与模拟或存根对象一起使用。
- en: 'Using an in-memory database: Rather than connecting to a real database, a small
    in-memory database could be used. A good example is the SQLite DB, a file or memory-based
    database which implements a good, but minimal, subset of SQL.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存数据库：与连接到真实数据库不同，可以使用一个小型的内存数据库。一个很好的例子是SQLite DB，它是一个基于文件或内存的数据库，实现了一个良好但是最小的SQL子集。
- en: 'Using a test database: If the test really requires a database, the operation
    can use a test database which uses **transactions**. The database is set up in
    the `setUp()` method of the test case, and rolled back in the `tearDown()` method
    so that no real data remains at the end of the operation.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试数据库：如果测试确实需要数据库，操作可以使用一个使用事务的测试数据库。数据库在测试用例的`setUp()`方法中设置，并在`tearDown()`方法中回滚，以便在操作结束时不留下真实数据。
- en: '**Resource virtualization**: In order to control the behavior of resources
    which are outside the system, one can virtualize them, that is, build a version
    of these resources which mimic their APIs, but not the internal implementation.
    Some common techniques for resource virtualization are as follows:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源虚拟化**: 为了控制系统外部资源的行为，可以对它们进行虚拟化，即构建这些资源的版本，模仿它们的API，但不是内部实现。一些常见的资源虚拟化技术如下：'
- en: '**Stubs**: Stubs provide standard (canned) responses to function calls made
    during a test. A `Stub()` function replaces the details of the function it replaces,
    only returning the response as required.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**: 存根为测试期间进行的函数调用提供标准（预定义）响应。`Stub()`函数替换了它替代的函数的细节，只返回所需的响应。'
- en: 'For example, here is a function that returns `data` for a given URL:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个根据给定URL返回`data`的函数：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And the following is the stub that replaces it, which internalizes the external
    dependency of the URL:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是替代它的存根，它内部化了URL的外部依赖：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A more common way to write such a function is to combine both the original request
    and the file cache in the same code. The URL is requested just once—the first
    time the function is called—and in subsequent requests, the data from the file
    cache is returned.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样一个函数的更常见的方法是将原始请求和文件缓存合并到同一代码中。URL只被请求一次——在第一次调用函数时——在后续请求中，从文件缓存返回数据。
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Mocks**: Mocks fake the API of the real-world objects they replace. One programs
    mock objects directly in the test by setting expectations—in terms of the type
    and order of the arguments the functions will expect and the responses they will
    return. Later, the expectations can be optionally verified in a verification step.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**: 模拟对象是对它们替代的真实世界对象的API进行伪装。一个程序可以通过设置期望来直接在测试中模拟对象——期望函数将期望的参数类型和顺序以及它们将返回的响应。稍后，可以选择性地在验证步骤中验证这些期望。'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between Mocks and Stubs is that a Stub implements just enough
    behavior for the object under test to execute the test. A Mock usually goes beyond
    by also verifying that the object under test calls the Mock as expected—for example,
    in terms of number and order of arguments.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和存根之间的主要区别在于存根只实现了足够的行为，使得被测试对象能够执行测试。模拟通常会超出范围，还会验证被测试对象是否按预期调用模拟——例如，参数的数量和顺序。
- en: When using a Mock object, part of the test involves verifying that the Mock
    was used correctly. In other words, both Mocks and Stubs answer the question,
    *What is the result?*, but Mocks also answer the question, *How has the result
    been achieved?*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟对象时，测试的一部分涉及验证模拟是否被正确使用。换句话说，模拟和存根都回答了问题，“结果是什么？”，但模拟还回答了问题，“结果是如何实现的？”
- en: We will see examples of writing unit test via mocks with Python later.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面看到使用Python进行模拟的单元测试的示例。
- en: '**Fakes**: The `Fake` objects have working implementations, but fall short
    of production usage because they have some limitations. A `Fake` object provides
    a very lightweight implementation, which goes beyond just stubbing the object.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伪造**: `Fake`对象具有工作实现，但由于存在一些限制，不足以用于生产。`Fake`对象提供了一个非常轻量级的实现，不仅仅是存根对象。'
- en: 'For example, here is a `Fake` object that implements a very minimal logging,
    mimicking the API of the `Logger` object of the Python''s logging module:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个实现非常简单的日志记录的`Fake`对象，模仿了Python的日志记录模块的`Logger`对象的API：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `FakeLogger` class in the preceding code implements some main methods of
    the `logging.Logger` class, which it is trying to fake.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`FakeLogger`类实现了`logging.Logger`类的一些主要方法，它试图伪装。
- en: It is ideal as a fake object for replacing the `Logger` object for implementing
    tests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为替换`Logger`对象来实现测试的伪造对象是理想的。
- en: White-box testing principles
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 白盒测试原则
- en: From a software architecture perspective, one of the most important steps of
    testing is at the time the software is developed. The behavior or functionality
    of a software, which is apparent only to its end users, is an artifact of the
    implementation details of the software.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件架构的角度来看，测试的一个最重要的步骤是在软件开发时进行。软件的行为或功能，只对最终用户可见，是软件实现细节的产物。
- en: Hence, it follows that a system which is tested early and tested often has a
    higher likelihood to produce a testable and robust system, which provides the
    required functionality to the end user in a satisfactory manner.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个早期进行测试并经常进行测试的系统更有可能产生一个可测试和健壮的系统，以满意的方式为最终用户提供所需的功能。
- en: The best way, therefore, to start implementing testing principles is right from
    the source, that is, where the software is written, and by the developers. Since
    the source code is visible to the developer, this testing is often called White-box
    testing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实施测试原则的最佳方式是从源头开始，也就是软件编写的地方，由开发人员来实施。由于源代码对开发人员可见，这种测试通常被称为白盒测试。
- en: So, how do we make sure that we can follow the correct testing principles, and
    perform due diligence while the software is getting developed? Let us take a look
    at the different types of testing that are involved during the development stage
    before the software ends up in front of the customer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何确保我们可以遵循正确的测试原则，并在软件开发过程中进行尽职调查呢？让我们来看看在软件最终呈现给客户之前，在开发阶段涉及的不同类型的测试。
- en: Unit testing
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is the most fundamental type of testing performed by developers.
    A unit test applies the most basic unit of software code—typically, functions
    or class methods—by using executable assertions, which check the output of the
    unit being tested against an expected outcome.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是开发人员执行的最基本的测试类型。单元测试通过使用可执行的断言来应用软件代码的最基本单元——通常是函数或类方法——来检查被测试单元的输出与预期结果是否一致。
- en: In Python, support for unit testing is provided by the `unittest` module in
    the standard library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，通过标准库中的`unittest`模块提供对单元测试的支持。
- en: The unit test module provides the following high-level objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试模块提供以下高级对象。
- en: '**Test cases**: The `unittest` module provides the `TestCase` class, which
    provides support for test cases. A new test case class can be set up by inheriting
    from this class, and setting up the test methods. Each test method will implement
    unit tests by checking the response against an expected outcome.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例**：`unittest`模块提供了`TestCase`类，它提供了对测试用例的支持。可以通过继承这个类并设置测试方法来设置一个新的测试用例类。每个测试方法将通过检查响应与预期结果是否匹配来实现单元测试。'
- en: '**Test fixtures**: Test fixtures represent any setup or preparation required
    for one or more tests followed by any cleanup actions. For example, this may involve
    creating temporary or in-memory databases, starting a server, creating a directory
    tree, and the like. In the `unittest` module, support for fixtures is provided
    by the `setUp()` and `tearDown()` methods of the `TestCase` class and the associated
    class and module methods of the `TestSuite` class.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试固件**：测试固件代表一个或多个测试所需的任何设置或准备工作，然后是任何清理操作。例如，这可能涉及创建临时或内存数据库，启动服务器，创建目录树等。在`unittest`模块中，通过`TestCase`类的`setUp()`和`tearDown()`方法以及`TestSuite`类的相关类和模块方法提供了对固件的支持。'
- en: '**Test suites**: A test suite is an aggregation of related test cases. A test
    suite can also contain other test suites. A test suite allows to group test cases
    that perform functionally similar tests on a software system, and whose results
    should be read or analyzed together. The `unittest` module provides support for
    test suites through the `TestSuite` class.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**：测试套件是相关测试用例的聚合。测试套件还可以包含其他测试套件。测试套件允许将在软件系统上执行功能相似的测试的测试用例分组，并且其结果应该一起阅读或分析。`unittest`模块通过`TestSuite`类提供了对测试套件的支持。'
- en: '**Test runners**: A test runner is an object that manages and runs the test
    cases, and provides the results to the tester. A test runner can use a text interface
    or a GUI.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试运行器**：测试运行器是一个管理和运行测试用例，并向测试人员提供结果的对象。测试运行器可以使用文本界面或图形界面。'
- en: '**Test results**: Test result classes manage the test result output shown to
    the tester. Test results summarize the number of successful, failed, and erred-out
    test cases. In the `unittest` module, this is implemented by the `TestResult`
    class with a concrete, default implementation of the `TextTestResult` class.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试结果**：测试结果类管理向测试人员显示的测试结果输出。测试结果总结了成功、失败和出错的测试用例数量。在`unittest`模块中，这是通过`TestResult`类实现的，具体的默认实现是`TextTestResult`类。'
- en: Other modules that provide support for Unit testing in Python are nose (nose2)
    and **py.test**. We will discuss each of these briefly in the following sections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中提供支持单元测试的其他模块包括nose（nose2）和**py.test**。我们将在接下来的部分简要讨论每一个。
- en: Unit testing in action
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试实例
- en: Let us take a specific unit-testing task, and then try to build a few test cases
    and test suites. Since the `unittest` module is the most popular, and available
    by default in the Python standard library, we will start with it first.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做一个具体的单元测试任务，然后尝试构建一些测试用例和测试套件。由于`unittest`模块是最流行的，并且在Python标准库中默认可用，我们将首先从它开始。
- en: For our test purposes, we will create a class that has a few methods, which
    are used for date/time conversions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的测试目的，我们将创建一个具有一些用于日期/时间转换的方法的类。
- en: 'The following code shows our class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们的类：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our class `DateTimeHelper` has a few methods, which are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DateTimeHelper`类有一些方法，如下所示：
- en: '`date`: Returns the day''s timestamp in the dd/mm/yyyy format'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：以dd/mm/yyyy格式返回当天的时间戳'
- en: '`weekday`: Returns the day''s weekday, for example, Sunday, Monday, and so
    on'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weekday`：返回当天的星期几，例如，星期日，星期一等等'
- en: '`us_to_indian`: Converts a US date format (mm/dd/yy(yy)) to the Indian format
    (dd/mm/yyyy)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us_to_indian`：将美国日期格式（mm/dd/yy(yy)）转换为印度格式（dd/mm/yyyy）'
- en: 'Here is a `unittest TestCase` class, which implements a test for the last method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`unittest TestCase`类，它实现了对最后一个方法的测试：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that in the main part of the testcase code, we just invoke `unittest.main()`.
    This automatically figures out the test cases in the module, and executes them.
    The following image shows the output of the test run:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在测试用例代码的主要部分中，我们只是调用了`unittest.main()`。这会自动找出模块中的测试用例，并执行它们。以下图片显示了测试运行的输出：
- en: '![Unit testing in action](../Images/image00386.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![单元测试实例](../Images/image00386.jpeg)'
- en: 'Output of the unit-test case for datetimehelper module - version #1'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetimehelper`模块的单元测试案例输出 - 版本#1'
- en: As we can see from the output, this simple test case passes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，这个简单的测试用例通过了。
- en: Extending our unit test case
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展我们的单元测试用例
- en: You may have noted that the first version of the unit test case for the `datetimehelper`
    module contained a test only for one method, namely, the method that converts
    the US date format to the Indian one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到`datetimehelper`模块的第一个版本的单元测试用例只包含了一个方法的测试，即将美国日期格式转换为印度日期格式的方法。
- en: However, what about the other two methods? Shouldn't we write unit tests for
    them too?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，其他两种方法呢？难道我们也不应该为它们编写单元测试吗？
- en: The problem with the other two methods is that they get data from today's date.
    In other words, the output is dependent on the exact day that the code is run.
    Hence, it is not possible to write a specific test case for them by feeding in
    a date value, and expecting the result to match an outcome as the code is time
    dependent. We need a way to control this external dependency.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两种方法的问题在于它们获取来自今天日期的数据。换句话说，输出取决于代码运行的确切日期。因此，无法通过输入日期值并期望结果与预期结果匹配来为它们编写特定的测试用例，因为代码是时间相关的。我们需要一种方法来控制这种外部依赖。
- en: Here is where Mocking comes to our rescue. Remember that we had discussed Mock
    objects as a way to control external dependencies. We can use the patching support
    of `unittest.mock` library, and patch the method that returns today's date to
    return a date that we control. This way, we are able to test the methods that
    depend on it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Mocking来拯救我们。记住我们曾讨论过Mock对象作为控制外部依赖的一种方式。我们可以使用`unittest.mock`库的修补支持，并修补返回今天日期的方法，以返回我们控制的日期。这样，我们就能够测试依赖于它的方法。
- en: 'Here is the modified test case with support added for the two methods using
    this technique:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修改后的测试用例，使用了这种技术来支持两种方法：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have patched the `today` method to return a specific date
    in the two test methods. This allows us to control the method's output, and, in
    turn, compare the result with a specific outcome.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经对`today`方法进行了修补，使其在两个测试方法中返回特定日期。这使我们能够控制该方法的输出，并将结果与特定结果进行比较。
- en: 'Here is the new output of the test case:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试用例的新输出：
- en: '![Extending our unit test case](../Images/image00387.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![扩展我们的单元测试用例](../Images/image00387.jpeg)'
- en: 'Output of the unit-test case for datetimehelper module with two more tests
    - version #2'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试用例的输出，用于datetimehelper模块，增加了两个测试 - 版本＃2
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'NOTE: `unittest.main` is a convenience function on the `unittest` module, which
    makes it easy to load a set of test cases automatically from a module and run
    them.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`unittest.main`是`unittest`模块上的一个便利函数，它可以轻松地从一个模块中自动加载一组测试用例并运行它们。
- en: 'To find out more details of what is happening when the tests are run, we can
    make the test runner show more information by increasing the verbosity. This can
    be done either by passing the `verbosity` argument to `unittest.main`, or by passing
    the `-v` option on the command line as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解测试运行时发生了什么的更多细节，我们可以通过增加冗长度来让测试运行器显示更多信息。可以通过将`verbosity`参数传递给`unittest.main`，或者通过在命令行上传递`-v`选项来实现。
- en: '![Extending our unit test case](../Images/image00388.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![扩展我们的单元测试用例](../Images/image00388.jpeg)'
- en: Producing verbose output from the unit-test case by passing the -v argument
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递`-v`参数来从单元测试用例中生成冗长输出
- en: Nosing around with nose2
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用nose2四处嗅探
- en: There are other unit-testing modules in Python which are not part of the standard
    library, but are available as third-party packages. We will look at the first
    one named `nose`. The most recent version (at the time of writing) is version
    2, and the library has been renamed as nose2.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python中还有其他单元测试模块，它们不是标准库的一部分，但作为第三方包可用。我们将看一下第一个名为`nose`的模块。最新版本（写作时）是版本2，该库已更名为nose2。
- en: The nose2 package can be installed by using the Python package installer, pip.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Python包安装程序pip来安装nose2包。
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running nose2 is very simple. It automatically detects Python test cases to
    run in the folder that it is run from by looking for classes derived from `unittest.TestCase`,
    and also functions starting with `test`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行nose2非常简单。它会自动检测要从中运行的Python测试用例所在的文件夹，方法是查找从`unittest.TestCase`派生的类，以及以`test`开头的函数。
- en: 'In the case of our datetimehelper test-case, nose2 picks it up automatically.
    Simply run it from the folder containing the module. Here is the test output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的datetimehelper测试用例中，nose2会自动捡起它。只需从包含模块的文件夹中运行它。以下是测试输出：
- en: '![Nosing around with nose2](../Images/image00389.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![用nose2四处嗅探](../Images/image00389.jpeg)'
- en: Running unit-tests using nose2
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2运行单元测试
- en: The preceding output doesn't, however, report anything, since, by default, nose2
    runs quietly. We can turn on some reporting of tests by using the verbose option
    (`-v`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的输出并没有报告任何内容，因为默认情况下，nose2会静默运行。我们可以通过使用冗长选项（`-v`）来打开一些测试报告。
- en: '![Nosing around with nose2](../Images/image00390.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![用nose2四处嗅探](../Images/image00390.jpeg)'
- en: Running unit-tests using nose2, with verbose output
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2运行单元测试，带有冗长输出
- en: The nose2 also supports reporting code coverage by using plugins. We will look
    at code coverage in a later section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: nose2还支持使用插件来报告代码覆盖。我们将在后面的部分看到代码覆盖。
- en: Testing with py.test
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用py.test进行测试
- en: The py.test package, commonly known as pytest, is a full-featured, mature testing
    framework for Python. Like nose2, py.test also supports test discovery by looking
    for files starting with certain patterns.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: py.test包，通常称为pytest，是Python的一个功能齐全、成熟的测试框架。与nose2一样，py.test也支持通过查找以特定模式开头的文件来发现测试。
- en: The py.test can also be installed with pip.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: py.test也可以使用pip安装。
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Like nose2, test execution with py.test is also easy. Simply run the executable
    pytest in the folder containing the test cases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 像nose2一样，使用py.test进行测试也很容易。只需在包含测试用例的文件夹中运行可执行文件pytest。
- en: '![Testing with py.test](../Images/image00391.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![使用py.test进行测试](../Images/image00391.jpeg)'
- en: Test discovery and execution with py.test
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用py.test进行测试发现和执行
- en: Like nose2, pytest also comes with its own plugin support, the most useful among
    them being the code coverage plugin. We will see examples in a later section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 像nose2一样，pytest也具有自己的插件支持，其中最有用的是代码覆盖插件。我们将在后面的部分看到示例。
- en: It is to be noted that pytest doesn't require test cases to be derived formally
    from the `unittest.TestCase` module. Py.test automatically discovers tests from
    any modules containing classes prefixed with `Test`, or from functions prefixed
    with `test_`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，pytest不要求测试用例正式派生自`unittest.TestCase`模块。Py.test会自动从包含以`Test`为前缀的类或以`test_`为前缀的函数的模块中发现测试。
- en: For example, here is a new test case without any dependency on the `unittest`
    module but with the test case class derived from object, the most base type in
    Python. The new module is called `test_datetimehelper_object`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个新的测试用例，没有依赖于`unittest`模块，但测试用例类是从Python中最基本的类型object派生的。新模块名为`test_datetimehelper_object`。
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note how this class has zero dependency on the `unittest` module, and defines
    no fixtures. Here is the output of running pytest on the folder now:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个类与`unittest`模块没有任何依赖关系，并且没有定义任何固定装置。以下是现在在文件夹中运行pytest的输出：
- en: '![Testing with py.test](../Images/image00392.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![使用py.test进行测试](../Images/image00392.jpeg)'
- en: Test case discovery and execution without unittest module support using py.test
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用py.test进行测试用例发现和执行，而不使用unittest模块支持
- en: The pytest has picked up the test case in this module, and executed it automatically
    as the output shows.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: pytest已经捕捉到了这个模块中的测试用例，并自动执行了它，正如输出所示。
- en: The nose2 also has similar capabilities to pick up such test cases. The next
    image shows the output of nose2 with the new test case defined.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: nose2也具有类似的功能来捕捉这样的测试用例。下一张图片显示了nose2对新测试用例的输出。
- en: '![Testing with py.test](../Images/image00393.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![使用py.test进行测试](../Images/image00393.jpeg)'
- en: Test case discovery and execution without unittest module support using nose2
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2进行测试用例发现和执行，而不使用unittest模块支持
- en: The preceding output shows that the new test has been picked up and executed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了新测试已被捕捉并执行。
- en: The `unittest` module, nose2, and py.test packages provide a lot of support
    for developing and implementing test cases, fixtures, and test suites in a very
    flexible and customizable manner. Discussing all the multitude of options of these
    tools is beyond the scope of this chapter, as our focus is on getting to know
    these tools to understand how we can use them to satisfy the architectural quality
    attribute of testability.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块、nose2和py.test包提供了大量支持，以非常灵活和可定制的方式开发和实现测试用例、固定装置和测试套件。讨论这些工具的多种选项超出了本章的范围，因为我们的重点是了解这些工具，以理解我们如何使用它们来满足测试性的架构质量属性。'
- en: So, at this point, we will go on to the next major topic in unit testing, that
    of **code coverage**. We will look at these three tools, namely, `unittest`, nose2,
    and py.test, and see how they allow the architect to help his developers and testers
    find information about the code coverage in their unit tests.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将继续讨论单元测试的下一个重要主题，即**代码覆盖率**。我们将看看这三个工具，即`unittest`、nose2和py.test，以及它们如何允许架构师帮助他的开发人员和测试人员找到有关他们单元测试中代码覆盖率的信息。
- en: Code coverage
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Code coverage is measured as the degree to which the source code under test
    is covered by a specific test suite. Ideally, test suites should aim for higher
    code coverage, as this would expose a larger percentage of the source code to
    tests, and help to uncover bugs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是衡量被测试的源代码被特定测试套件覆盖的程度。理想情况下，测试套件应该追求更高的代码覆盖率，因为这将使更大比例的源代码暴露给测试，并有助于发现错误。
- en: Code coverage metrics are reported typically as a percentage of **Lines of Code**
    (**LOC**), or a percentage of the subroutines (functions) covered by a test suite.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率指标通常报告为**代码行数**（**LOC**）的百分比，或者测试套件覆盖的子程序（函数）的百分比。
- en: Let us now look at different tools support for measuring code coverage. We will
    continue to use our test example (`datetimehelper`) for these illustrations too.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看不同工具对于测量代码覆盖率的支持。我们将继续使用我们的测试示例（`datetimehelper`）进行这些说明。
- en: Measuring coverage using coverage.py
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用coverage.py进行覆盖率测量
- en: Coverage.py is a third-party Python module, which works with test suites and
    cases written with the `unittest` module, and reports their code coverage.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py是一个第三方的Python模块，它与使用`unittest`模块编写的测试套件和测试用例一起工作，并报告它们的代码覆盖率。
- en: Coverage.py can be installed, like other tools shown here so far, using pip.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py可以像其他工具一样使用pip进行安装。
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This last command installs the coverage application, which is used to run and
    report code coverages.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的命令安装了coverage应用程序，用于运行和报告代码覆盖率。
- en: 'Coverage.py has two stages: first, where it runs a piece of source code, and
    collects coverage information, and next, where it reports the coverage data.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py有两个阶段：首先，它运行一段源代码，并收集覆盖信息，然后报告覆盖数据。
- en: 'To run coverage.py, use the following syntax:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行coverage.py，请使用以下语法：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the run is complete, report the coverage using this command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完成后，使用此命令报告覆盖率：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For example, here is the output with our test modules:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我们测试模块的输出：
- en: '![Measuring coverage using coverage.py](../Images/image00394.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![使用coverage.py进行覆盖率测量](../Images/image00394.jpeg)'
- en: Test coverage report for datetimehelper module using coverage.py
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用coverage.py对datetimehelper模块进行测试覆盖率报告
- en: Coverage.py reports that our tests cover `93%` of the code in the `datetimehelper`
    module, which is pretty good code coverage. (You can ignore the report on the
    test module itself.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage.py报告称我们的测试覆盖了`datetimehelper`模块中`93%`的代码，这是相当不错的代码覆盖率。（您可以忽略关于测试模块本身的报告。）
- en: Measuring coverage using nose2
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用nose2进行覆盖率测量
- en: 'The nose2 package comes with plugin support for code coverage. This is not
    installed by default. To install the code coverage plugin for nose2, use this
    command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: nose2包带有用于代码覆盖率的插件支持。这不是默认安装的。要为nose2安装代码覆盖插件，请使用此命令：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, nose2 can be run with the code coverage option to run the test cases,
    and to report coverage in one shot. This can be done as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，nose2可以使用代码覆盖选项运行测试用例，并一次性报告覆盖率。可以这样做：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: Behind the scenes cov-core makes use of coverage.py to get its work done,
    so the metric report of coverage by both coverage.py and nose2 is the same.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在幕后，cov-core利用coverage.py来完成其工作，因此coverage.py和nose2的覆盖度度量报告是相同的。
- en: 'Here is the output of running test coverage using nose2:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用nose2运行测试覆盖率的输出：
- en: '![Measuring coverage using nose2](../Images/image00395.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![使用nose2进行覆盖率测量](../Images/image00395.jpeg)'
- en: Test coverage report for datetimehelper module using nose2
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2对datetimehelper模块进行测试覆盖率报告
- en: By default, the coverage report is written to the console. To produce other
    forms of output, the `–coverage-report` option can be used. For example, `--coverage-report
    html` will write the coverage report in the HTML format to a subfolder named `htmlcov`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，覆盖率报告会被写入控制台。要生成其他形式的输出，可以使用`–coverage-report`选项。例如，`--coverage-report
    html`将以HTML格式将覆盖率报告写入名为`htmlcov`的子文件夹。
- en: '![Measuring coverage using nose2](../Images/image00396.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![使用nose2进行覆盖率测量](../Images/image00396.jpeg)'
- en: Producing HTML coverage output using nose2
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2生成HTML覆盖率输出
- en: 'Here is how the HTML output looks in the browser:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是浏览器中的HTML输出效果：
- en: '![Measuring coverage using nose2](../Images/image00397.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![使用nose2测量覆盖率](../Images/image00397.jpeg)'
- en: HTML coverage report as viewed in the browser
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看的HTML覆盖报告
- en: Measuring coverage using py.test
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用py.test测量覆盖率
- en: Pytest also comes with its own coverage plugin for reporting code coverage.
    Like nose2, it utilizes coverage.py behind the scenes to get the work done.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest还配备了自己的覆盖插件，用于报告代码覆盖。与nose2一样，它在后台利用coverage.py来完成工作。
- en: 'To provide support for code coverage for py.test, the package `pytest-cov`
    needs to be installed as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为py.test提供代码覆盖支持，需要安装`pytest-cov`包，如下所示：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To report code coverage of test cases in the current folder, use the following
    command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要报告当前文件夹中测试用例的代码覆盖率，请使用以下命令：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a sample output of pytest code coverage:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是pytest代码覆盖的示例输出：
- en: '![Measuring coverage using py.test](../Images/image00398.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![使用py.test测量覆盖率](../Images/image00398.jpeg)'
- en: Running code coverage for current folder using py.test
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用py.test运行当前文件夹的代码覆盖
- en: Mocking things up
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟事物
- en: We saw an example of using the patch support of `unittest.mock` in our test
    example earlier. However, the Mock support provided by `unittest` is even more
    powerful than this, so let us look at one more example to understand its power
    and applicability in writing unit tests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的测试示例中看到了使用`unittest.mock`的patch支持的示例。然而，`unittest`提供的Mock支持甚至比这个更强大，所以让我们看一个更多的例子来理解它的强大和适用性在编写单元测试中。
- en: For the purpose of this illustration, we will consider a class that performs
    keyword search on a large dataset, and returns the results ordered by weightage.
    Assume that the dataset is stored in a database, and the results are returned
    as a list of (sentence, relevance) tuples, where sentence is the original string
    with a match for the keyword, and relevance is its hit weightage in the result
    set.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们将考虑一个在大型数据集上执行关键字搜索并按权重排序返回结果的类，并假设数据集存储在数据库中，并且结果作为（句子、相关性）元组列表返回，其中句子是具有关键字匹配的原始字符串，相关性是其在结果集中的命中权重。
- en: 'Here is the code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The class has the following three methods:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有以下三种方法：
- en: '`__init__`: The initializer, it accepts an object that acts as a handle to
    the data source (database); also initializes a few attributes, and connects to
    the database'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`：初始化器，它接受一个充当数据源（数据库）句柄的对象；还初始化了一些属性，并连接到数据库'
- en: '`setup`: It sets up the searcher, and also configures the database object'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup`：它设置搜索器，并配置数据库对象'
- en: '`get_results`: It performs a search using the data source (database), and returns
    the results for a given keyword'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_results`：它使用数据源（数据库）执行搜索，并返回给定关键字的结果'
- en: We now want to implement a unit test case for this searcher. Since the database
    is an external dependency, we will virtualize the database object by mocking it.
    We will test only the searcher's logic, callable signatures, and return data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要为这个搜索器实现一个单元测试用例。由于数据库是一个外部依赖，我们将通过模拟来虚拟化数据库对象。我们将仅测试搜索器的逻辑、可调用签名和返回数据。
- en: We will develop this program step by step so that each step of Mocking is clear
    to you. We will use a Python interactive interpreter session for the same.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步开发这个程序，以便每个模拟步骤对您来说都是清晰的。我们将使用Python交互式解释器会话来进行相同的操作。
- en: First, the mandatory imports.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是必要的导入。
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since we want to Mock the DB, the first step is to do that exactly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要模拟数据库，第一步就是确切地做到这一点。
- en: '[PRE19]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now let us create the `searcher` object. We are not going to Mock this, as we
    need to test the calling signature and the return value of its methods.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`searcher`对象。我们不打算模拟这个，因为我们需要测试其方法的调用签名和返回值。
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, the database object has been passed to the `__init__` method
    of the `searcher`, and `connect` has been called on it. Let's verify this expectation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，数据库对象已被传递给`searcher`的`__init__`方法，并且已经在其上调用了`connect`。让我们验证这个期望。
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: No issues, so the assertion has succeeded! Let us now set up the `searcher`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 没有问题，所以断言成功了！现在让我们设置`searcher`。
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Looking at the code of the `TextSearcher` class, we realize that the preceding
    call should have called `configure` on the database object with the parameter
    `max_items` set to the value `100`. Let's verify this.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`TextSearcher`类的代码，我们意识到前面的调用应该调用数据库对象上的`configure`方法，并将参数`max_items`设置为值`100`。让我们验证一下。
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Bravo!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: Finally, let us try and test the logic of the `get_results` method. Since our
    database is a Mock object, it won't be able to do any actual query, so we pass
    some canned results to its `query` method, effectively mocking it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试并测试`get_results`方法的逻辑。由于我们的数据库是一个模拟对象，它将无法执行任何实际查询，因此我们将一些预先准备好的结果传递给它的`query`方法，有效地模拟它。
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now we set up the keyword and the number of results, and call `get_results`
    using these parameters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置关键字和结果的数量，并使用这些参数调用`get_results`。
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's inspect the data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查数据。
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Looks good!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！
- en: In the next step, we verify that `get_results` has indeed called `query` with
    the given keyword.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们验证`get_results`确实使用给定的关键字调用了`query`。
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we verify that the data returned has been sorted right and truncated
    to the number of results (`num`) value we passed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们验证返回的数据是否已正确排序并截断到我们传递的结果数（`num`）值。
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All good!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常！
- en: The example shows how to use Mock support in the `unittest` module in order
    to mock an external dependency and effectively virtualize it, at the same time
    testing the program's logic, control flow, callable arguments, and return values.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例显示了如何使用`unittest`模块中的Mock支持来模拟外部依赖项并有效地虚拟化它，同时测试程序的逻辑、控制流、可调用参数和返回值。
- en: Here is a test module combining all these tests into a single test module, and
    the output of nose2 on it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个测试模块，将所有这些测试组合成一个单独的测试模块，并在其上运行nose2的输出。
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the output of nose2 on this test case:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是nose2在这个测试用例上的输出：
- en: '![Mocking things up](../Images/image00399.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![模拟事物](../Images/image00399.jpeg)'
- en: Running testsearcher test-case using nose2
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nose2运行testsearcher测试用例
- en: For good measure, let us also look at the coverage of our mock test example,
    the `test_textsearch` module, using the py.test coverage plugin.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保险起见，让我们也看一下我们的模拟测试示例`test_textsearch`模块的覆盖率，使用py.test覆盖率插件。
- en: '![Mocking things up](../Images/image00400.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![模拟事物](../Images/image00400.jpeg)'
- en: Measuring coverage of textsearcher module via test_textsearch test-case using
    py.test
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用py.test测试文本搜索测试用例来测量textsearcher模块的覆盖率
- en: So our Mock test has a coverage of *90%*, missing just two statements out of
    *20*. Not bad!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的模拟测试覆盖率为*90%*，只有*20*个语句中的两个没有覆盖到。还不错！
- en: Tests inline in documentation – doctests
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档中的内联测试 - doctests
- en: Python has unique support for another form of inline code tests, which are commonly
    called **doctests**. These are inline unit tests in a function, class or module
    documentation, which add a lot of value by combining code and tests in one place
    without having to develop or maintain separate test suites.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Python对另一种内联代码测试有独特的支持，通常称为**doctests**。这些是函数、类或模块文档中的内联单元测试，通过将代码和测试结合在一个地方，无需开发或维护单独的测试套件，从而增加了很多价值。
- en: The doctest module works by looking for pieces of text in code documentation
    that look like Python strings, and executing those sessions to verify that they
    work exactly as found. Any test failures are reported on the console.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: doctest模块通过查找代码文档中看起来像Python字符串的文本片段来工作，并执行这些会话以验证它们确实与找到的一样工作。任何测试失败都会在控制台上报告。
- en: 'Let us look at a code example to see this in action. The following piece of
    code implements the simple factorial function by using an iterative approach:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个代码示例来看看它是如何运作的。以下代码实现了简单的阶乘函数，采用了迭代方法：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's look at the output of executing this module.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下执行这个模块的输出。
- en: '![Tests inline in documentation – doctests](../Images/image00401.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![文档中的内联测试 - doctests](../Images/image00401.jpeg)'
- en: Output of doctest for the factorial module
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘模块的doctest输出
- en: The doctest reports that one out of four tests failed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest报告说四个测试中有一个失败了。
- en: A quick scan of the output tells us that we forgot to code in the special case
    to compute the factorial for zero. The error occurs because the code tries to
    compute range(1, 1), which raises an exception with `reduce`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 快速扫描输出告诉我们，我们忘记编写计算零的阶乘的特殊情况。错误是因为代码尝试计算range(1, 1)，这会导致`reduce`引发异常。
- en: 'The code can be easily rewritten to fix this. Here is the modified code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以很容易地重写以解决这个问题。以下是修改后的代码：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The next image shows the fresh output of executing the module now:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张图片显示了现在执行模块的新输出：
- en: '![Tests inline in documentation – doctests](../Images/image00402.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![文档中的内联测试 - doctests](../Images/image00402.jpeg)'
- en: Output of doctest for factorial module after the fix
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 修复后阶乘模块的doctest输出
- en: Now all the tests pass.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的测试都通过了。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: We turned on the verbose option of the doctest module''s `testmod` function
    in this example in order to show the details of the tests. Without this option,
    doctest would be silent if all the tests passed, producing no output.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这个例子中，我们打开了doctest模块的`testmod`函数的详细选项，以显示测试的详细信息。如果没有这个选项，如果所有测试都通过，doctest将保持沉默，不产生任何输出。
- en: The doctest module is very versatile. Rather than just Python code, it can also
    load Python interactive sessions from sources like text files, and execute them
    as tests.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: doctest模块非常灵活。它不仅可以加载Python代码，还可以从文本文件等来源加载Python交互会话，并将它们作为测试执行。
- en: Doctest examines all docstrings including function, class, and module doc-strings
    to search for Python interactive sessions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest检查所有文档字符串，包括函数、类和模块文档字符串，以搜索Python交互会话。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: The pytest package comes with built-in support for doctests. To allow
    pytest to discover and run doctests in the current folder, use the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：pytest包内置支持doctests。要允许pytest发现并运行当前文件夹中的doctests，请使用以下命令：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Integration tests
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Unit tests, though very useful to discover and fix bugs during white-box testing
    early on in the software development life cycle, aren't enough by themselves.
    A software system is fully functional only if the different components work together
    in expected ways in order to deliver the required functionality to the end user,
    satisfying the pre-defined architectural quality attributes. This is where integration
    tests assume importance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试虽然在软件开发生命周期早期的白盒测试中非常有用，可以发现和修复错误，但单靠它们是不够的。只有当不同组件按预期方式协同工作，以向最终用户提供所需的功能并满足预定义的架构质量属性时，软件系统才能完全正常运行。这就是集成测试的重要性所在。
- en: The purpose of integration tests is to verify the functional, performance, and
    other quality requirements on the different functional subsystems of a software
    system, which act as a logical unit, providing certain functionality. Such subsystems
    deliver some piece of functionality through the cumulative action of their individual
    units. Though each component may have defined its own unit test, it is also important
    to verify the combined functionality of the system by writing integration tests.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的目的是验证软件系统的不同功能子系统的功能、性能和其他质量要求，这些子系统作为一个逻辑单元提供某些功能。这些子系统通过它们各自单元的累积行动来提供一些功能。虽然每个组件可能已经定义了自己的单元测试，但通过编写集成测试来验证系统的组合功能也是很重要的。
- en: Integration tests are usually written after unit testing is completed, and before
    validation testing is done.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常是在单元测试完成之后，验证测试之前编写的。
- en: It would be instructional to list down the advantages provided by integration
    tests at this point, as this could be useful for any software architect who is
    at a phase where he has designed and implemented his unit tests for the different
    components.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，列出集成测试提供的优势将是有益的，因为这对于任何在设计和实现了不同组件的单元测试的软件架构师来说都是有用的。
- en: '**Testing component interoperability**: Each unit in a functional subsystem
    could be written by different programmers. Though each programmer is aware of
    how his component should perform, and may have written unit tests for the same,
    the entire system may have issues working in unison, as there could be errors
    or misunderstanding in the integration points where components talk to each other.
    Integration testing would reveal such mistakes.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试组件的互操作性**：功能子系统中的每个单元可能由不同的程序员编写。尽管每个程序员都知道他的组件应该如何执行，并可能已经为其编写了单元测试，但整个系统可能在协同工作方面存在问题，因为组件之间的集成点可能存在错误或误解。集成测试将揭示这样的错误。'
- en: '**Testing for system requirement modifications**: The requirements may have
    changed during the time of implementation. These updated requirements may not
    have been unit tested, hence, an integration test becomes very useful to reveal
    issues. Also some parts of the system may not have implemented the requirements
    correctly, which can also be revealed by an appropriate Integration test.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试系统需求修改**：需求可能在实施期间发生了变化。这些更新的需求可能没有经过单元测试，因此，集成测试非常有用，可以揭示问题。此外，系统的某些部分可能没有正确实现需求，这也可以通过适当的集成测试来揭示。'
- en: '**Testing external dependencies and APIs**: Software components these days
    use a lot of third-party APIs, which are usually mocked or stubbed during unit
    tests. Only an integration test would reveal how these APIs would perform and
    expose any issues either in the calling convention, response data, or performance
    with them.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试外部依赖和API**：当今软件组件使用大量第三方API，这些API通常在单元测试期间被模拟或存根。只有集成测试才能揭示这些API的性能，并暴露调用约定、响应数据或性能方面的任何问题。'
- en: '**Debugging hardware issues**: Integration tests are helpful in getting information
    about any hardware problems, and debugging such tests gives the developer(s) data
    about whether an update or change in the hardware configuration is required.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试硬件问题**：集成测试有助于获取有关任何硬件问题的信息，调试这些测试可以为开发人员提供有关是否需要更新或更改硬件配置的数据。'
- en: '**Uncovering exceptions in code paths**: Integration tests can also help developers
    figure out exceptions that they may not have handled in their code, as unit tests
    wouldn''t have executed paths or conditions which raised such errors. Higher code
    coverage can identify and fix a lot of such issues. However, a good integration
    test combining known code paths for each functionality with high coverage is a
    good formula for making sure most potential errors that may occur during usage
    are uncovered and executed during testing.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**揭示代码路径中的异常**：集成测试还可以帮助开发人员找出他们在代码中可能没有处理的异常，因为单元测试不会执行引发此类错误的路径或条件。更高的代码覆盖率可以识别和修复许多此类问题。然而，一个良好的集成测试结合每个功能的已知代码路径和高覆盖率是确保在使用过程中可能发生的大多数潜在错误都被发现并在测试期间执行的良好公式。'
- en: 'There are three approaches to writing integration tests. These are as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 编写集成测试有三种方法。它们如下：
- en: '**Bottom-up**: In this approach, components at the lower level are tested first,
    and these test results are used to integrate tests of the higher-level components
    in the chain. The process repeats until we reach the top of the hierarchy of the
    components with respect to the control flow. In this approach, critical modules
    at the top of the hierarchy may be tested inadequately.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自下而上：在这种方法中，首先测试低层组件，然后使用这些测试结果来集成链中更高级组件的测试。该过程重复进行，直到达到与控制流相关的组件层次结构的顶部。在这种方法中，层次结构顶部的关键模块可能得到不充分的测试。
- en: If the top-level components are under development, Drivers may be required to
    simulate (Mock) them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果顶层组件正在开发中，可能需要使用驱动程序来模拟它们。
- en: '![Integration tests](../Images/image00403.jpeg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![集成测试](../Images/image00403.jpeg)'
- en: Bottom-Up strategy of integration testing
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 自下而上的集成测试策略
- en: '**Top-down**: Test development and testing happens top-down, following the
    workflow in the software system. Hence, components at the top level of the hierarchy
    are tested first and the lower-level modules are tested last. In this approach,
    critical modules are tested on priority, so we can identify major design or development
    flaws first and fix them. However, lower-level modules may be tested inadequately.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自上而下**：测试开发和测试按照软件系统中的工作流程自上而下进行。因此，首先测试层次结构顶部的组件，最后测试低级模块。在这种方法中，首要测试关键模块，因此我们可以首先识别主要的设计或开发缺陷并加以修复。然而，低级模块可能得到不充分的测试。'
- en: Lower-level modules can be replaced by Stubs which mock their functionality.
    Early prototypes are possible in this approach, as lower-level module logic can
    be stubbed out.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 低级模块可以被模拟其功能的存根所替代。在这种方法中，早期原型是可能的，因为低级模块逻辑可以被存根化。
- en: '![Integration tests](../Images/image00404.jpeg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![集成测试](../Images/image00404.jpeg)'
- en: Top-Down strategy of integration testing
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 自上而下的集成测试策略
- en: '**Big-bang**: This is the approach is one where all the components are integrated
    and tested at the very end of development. Since the integration tests come at
    the end, this approach saves time for development. However, this may not give
    enough time to test critical modules, as there may not be enough time to spend
    equally on all the components.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大爆炸**：这种方法是在开发的最后阶段集成和测试所有组件。由于集成测试是在最后进行的，这种方法节省了开发时间。然而，这可能不会给予足够的时间来测试关键模块，因为可能没有足够的时间平等地花在所有组件上。'
- en: There is no specific software for general integration testing. A certain class
    of applications, such as web frameworks, define their own specific integration
    test frameworks. For example, some web frameworks like Django, Pyramid, and Flask
    have some specific testing frameworks developed by their own communities.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特定的软件用于一般集成测试。某些类别的应用程序，如Web框架，定义了自己特定的集成测试框架。例如，一些Web框架如Django、Pyramid和Flask都有一些由其自己社区开发的特定测试框架。
- en: Another example is the popular `webtest` framework, which is useful for automated
    testing of the Python WSGI applications. A detailed discussion of such frameworks
    is outside the scope of this chapter and this book.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是流行的`webtest`框架，它对Python WSGI应用程序的自动化测试很有用。这些框架的详细讨论超出了本章和本书的范围。
- en: Test automation
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试自动化
- en: There are a number of tools on the Internet that are useful for automating integration
    testing of software applications. We will take a quick look at some of the popular
    ones here.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多有用的工具，用于自动化软件应用程序的集成测试。我们将在这里快速看一些流行的工具。
- en: Test automation using Selenium Web Driver
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Selenium Web Driver进行测试自动化
- en: Selenium has been a popular choice for automating Integration, Regression, and
    Validation tests for a number of software applications. Selenium is free and open
    source, and comes with support for most popular web browser engines.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium一直是自动化集成、回归和验证测试的热门选择，适用于许多软件应用程序。Selenium是免费开源的，并支持大多数流行的Web浏览器引擎。
- en: In Selenium, the primary object is a **web driver**, which is a stateful object
    on the client side, representing a browser. The web driver can be programmed to
    visit URLs, perform actions (such as clicking, filling forms, and submitting forms),
    effectively replacing the human test subject, who usually performs these steps
    manually.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在Selenium中，主要对象是**web driver**，它是客户端上的一个有状态的对象，代表一个浏览器。Web driver可以被编程访问URL，执行操作（如点击、填写表单和提交表单），有效地替换通常手动执行这些步骤的人类测试对象。
- en: Selenium provides client driver support for most popular programming languages
    and runtimes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium为大多数流行的编程语言和运行时提供客户端驱动程序支持。
- en: 'To install the Selenium web driver in Python, use the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中安装Selenium Web Driver，请使用以下命令：
- en: '[PRE33]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will look at a small example that uses Selenium along with pytest in order
    to implement a small automation test, which will test the Python website ([http://www.python.org](http://www.python.org))
    for some simple test cases.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个小例子，使用Selenium和pytest来实现一个小的自动化测试，测试Python网站（[http://www.python.org](http://www.python.org)）的一些简单测试用例。
- en: Here is our test code. The module is named `selenium_testcase.py`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的测试代码。模块名为`selenium_testcase.py`。
- en: '[PRE34]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Before running the preceding example and showing the output, let us inspect
    the functions a bit.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述示例并显示输出之前，让我们稍微检查一下函数。
- en: Function `setUp` is a test fixture, which sets up the main object required for
    our test, that is, the Selenium Web driver for Firefox. We convert the `setUp`
    function to a context manager by decorating it with the `contextmanager` decorator
    from the `contextlib` module. At the end of the `setUp` function, the driver exits,
    since its `quit` method is called.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数`setUp`是一个测试装置，它为我们的测试设置了主要对象，即Firefox的Selenium Web driver。我们通过在`contextlib`模块中使用`contextmanager`装饰器将`setUp`函数转换为上下文管理器。在`setUp`函数的末尾，驱动程序退出，因为调用了它的`quit`方法。
- en: In the test function `test_python_dot_org`, we set up a rather simple, contrived
    test for visiting the main Python website URL, and checking its title via an assertion.
    We then load the URL for the Python community by locating it on the main page,
    and then visit this URL. We finally assert its title and URL before ending our
    tests.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试函数`test_python_dot_org`中，我们设置了一个相当简单的、人为的测试，用于访问主Python网站URL，并通过断言检查其标题。然后我们通过在主页上找到它来加载Python社区的URL，然后访问这个URL。最后在结束测试之前断言其标题和URL。
- en: 'Let us see the program in action. We will specifically ask pytest to load only
    this module, and run it. The command line for this is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序的运行情况。我们将明确要求pytest只加载这个模块，并运行它。这个命令行如下：
- en: '[PRE35]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The Selenium driver will launch the browser (Firefox), and open a window automatically,
    visiting the Python website URL while running the tests. The console output for
    the test is shown in the following image:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium驱动程序将启动浏览器（Firefox），并自动打开一个窗口，访问Python网站URL，同时运行测试。测试的控制台输出如下图所示：
- en: '![Test automation using Selenium Web Driver](../Images/image00405.jpeg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![使用Selenium Web Driver进行测试自动化](../Images/image00405.jpeg)'
- en: Console output of simple selenium test case on the Python programming language
    website
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的Selenium测试用例在Python编程语言网站上的控制台输出
- en: Selenium can be used for more complex test cases, as it provides a number of
    methods for inspecting the HTML of pages, locating elements, and interacting with
    them. There are also plugins for Selenium, which can execute the JavaScript content
    of the pages to make the testing support complex interactions via JavaScript (such
    as AJAX requests).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium可以用于更复杂的测试用例，因为它提供了许多方法来检查页面的HTML，定位元素并与之交互。还有一些Selenium的插件，可以执行页面的JavaScript内容，以通过JavaScript执行复杂的交互（如AJAX请求）。
- en: Selenium can also be run on the server. It provides support for remote clients
    via its remote driver support. Browsers are instantiated on the server (typically,
    using virtual X sessions), whereas, the tests can be run and controlled from client
    machines via the network.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium也可以在服务器上运行。它通过远程驱动程序支持提供对远程客户端的支持。浏览器在服务器上实例化（通常使用虚拟X会话），而测试可以通过网络从客户端机器运行和控制。
- en: Test-Driven Development
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test-Driven Development** (**TDD**), is an agile practice of software development,
    which uses a very short development cycle, where code is written to satisfy an
    incremental test case.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种敏捷软件开发实践，使用非常短的开发周期，编写代码以满足增量测试用例。'
- en: In TDD, a functional requirement is mapped to a specific test case. Code is
    written to pass the first test case. Any new requirement is added as a new test
    case. Code is refactored to support the new test case. The process continues till
    the code is able to support the entire spectrum of user functionality.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，将功能需求映射到特定的测试用例。编写代码以通过第一个测试用例。任何新需求都被添加为一个新的测试用例。代码被重构以支持新的测试用例。这个过程一直持续到代码能够支持整个用户功能的范围。
- en: 'The steps in TDD are as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的步骤如下：
- en: Define a few starting test cases as a specification for the program.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些起始测试用例作为程序的规范。
- en: Write code to make the early test cases pass.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码使早期测试用例通过。
- en: Add a new test case defining new functionality.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个定义新功能的新测试用例。
- en: Run all the tests, and see if the new test fails or passes.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试，看看新测试是失败还是通过。
- en: If the new test fails, write some code for the test to pass.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果新测试失败，请编写一些代码使测试通过。
- en: Run the tests again.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。
- en: Repeat steps 4 to 6 till the new test passes.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤4到6，直到新测试通过。
- en: Repeat steps 3 to 7 to add a new functionality via test cases.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤3到7，通过测试用例添加新功能。
- en: In TDD, the focus is on keeping everything simple, including the unit test cases
    and the new code that is added to support the test cases. TDD practitioners believe
    that writing tests upfront allows the developer to understand the product requirements
    better, allowing a focus on software quality from the very beginning of the development
    lifecycle.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，重点是保持一切简单，包括单元测试用例和为支持测试用例而添加的新代码。TDD的实践者认为，提前编写测试允许开发人员更好地理解产品需求，从开发生命周期的最开始就专注于软件质量。
- en: In TDD, often, a final refactoring step is also done after many tests have been
    added to the system in order to make sure no coding smells or antipatterns are
    introduced, and to maintain code readability and maintainability.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，通常在系统中添加了许多测试之后，还会进行最终的重构步骤，以确保不会引入编码异味或反模式，并保持代码的可读性和可维护性。
- en: There is no specific software for TDD, rather, it is a methodology and process
    for software development. Most of the time, TDD uses unit tests, so, the toolchain
    support is mostly the `unittest` module and the related packages that we've discussed
    in this chapter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: TDD没有特定的软件，而是一种软件开发的方法和过程。大多数情况下，TDD使用单元测试，因此，工具链支持主要是`unittest`模块和本章讨论过的相关软件包。
- en: TDD with palindromes
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回文的TDD
- en: Let us understand TDD as discussed earlier with a simple example of developing
    a program in Python, which checks whether an input string is a palindrome.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像之前讨论的那样，通过一个简单的示例来理解TDD，开发一个检查输入字符串是否为回文的Python程序。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A Palindrome is a string that reads the same in both directions. For example,
    *bob*, *rotator*, and *Malayalam* are palindromes. So is the sentence, *Madam,
    I'm Adam* when you get rid of the punctuations.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 回文是一个在两个方向上都读取相同的字符串。例如，*bob*，*rotator*和*Malayalam*都是回文。当你去掉标点符号时，句子*Madam,
    I'm Adam*也是回文。
- en: 'Let us follow the steps of TDD. Initially, we need a test case that defines
    the basic specification of the program. Our first version of the test code looks
    like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循TDD的步骤。最初，我们需要一个定义程序基本规范的测试用例。我们的测试代码的第一个版本看起来像这样：
- en: '[PRE36]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the preceding code not only gives us a specification for the program
    in terms of its early functionality, but also gives a function name and signature—in
    terms of the argument and return value. We can list down the requirements for
    the first version by looking at the test.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述代码不仅在早期功能方面为我们提供了程序的规范，还给出了函数名称和签名——包括参数和返回值。我们可以通过查看测试来列出第一个版本的要求。
- en: The function is named is `_palindrome`. It should accept a string, and return
    True if it is a palindrome, and False otherwise. The function sits in the module
    `palindrome`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数名为`_palindrome`。它应该接受一个字符串，如果是回文则返回True，否则返回False。该函数位于`palindrome`模块中。
- en: The function should treat strings as case-insensitive.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数应将字符串视为不区分大小写。
- en: 'With these specifications, here is our first version of the `palindrome` module:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些规范，这是我们的`palindrome`模块的第一个版本：
- en: '[PRE37]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let us check if this passes our test. We will run py.test on the test module
    to verify this.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这是否通过了我们的测试。我们将在测试模块上运行py.test来验证这一点。
- en: '![TDD with palindromes](../Images/image00406.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![回文的TDD](../Images/image00406.jpeg)'
- en: 'Test output of test_palindrome.py version #1'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: test_palindrome.py版本＃1的测试输出
- en: As you can see in the last image, the basic test passes; so, we've got a first
    version of `palindrome` module, which works and passes its tests.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在最后一张图片中看到的，基本测试通过了；所以，我们得到了一个`palindrome`模块的第一个版本，它可以工作并通过测试。
- en: 'Now as per the TDD step, let''s go to step (3), and add a new test case. This
    adds a check for testing palindrome strings with spaces. Here is the new test
    module with this extra test:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照TDD步骤，让我们进行第三步，添加一个新的测试用例。这增加了对带有空格的回文字符串进行测试的检查。以下是带有这个额外测试的新测试模块：
- en: '[PRE38]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's run the updated test and see the results.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行更新后的测试并查看结果。
- en: '![TDD with palindromes](../Images/image00407.jpeg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![回文的TDD](../Images/image00407.jpeg)'
- en: 'Test output of test_palindrome.py version #2'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: test_palindrome.py版本＃2的测试输出
- en: The test fails, because the code is not enabled to process palindrome strings
    with spaces in them. So let us do as TDD step (5) says, and write some code to
    make this test pass.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败，因为代码无法处理带有空格的回文字符串。所以让我们按照TDD步骤（5）的说法，编写一些代码使这个测试通过。
- en: 'Since it is clear we need to ignore spaces, a quick fix is to purge all spaces
    from the input string. Here is the modified palindrome module with this simple
    fix:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于明显需要忽略空格，一个快速的解决方法是从输入字符串中清除所有空格。以下是带有这个简单修复的修改后的回文模块：
- en: '[PRE39]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's now repeat step (4) of TDD to see if the updated code makes the test pass.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重复TDD的第四步，看看更新后的代码是否使测试通过。
- en: '![TDD with palindromes](../Images/image00408.jpeg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![回文的TDD](../Images/image00408.jpeg)'
- en: 'Console output of test_palindrome.py version #2, after code updates'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更新后的test_palindrome.py版本＃2的控制台输出
- en: Surely, the code passes the test now!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在代码通过了测试！
- en: What we just saw was an instance of TDD with one update cycle for implementing
    a module in Python, which checks strings for palindromes. In a similar way, one
    can keep adding tests, and keep updating the code as per step (8) of TDD, thereby
    adding new functionality while maintaining the updated tests naturally via the
    process.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的是TDD的一个实例，用于在Python中实现一个模块的更新周期，该模块检查字符串是否为回文。以类似的方式，可以不断添加测试，并根据TDD的第8步不断更新代码，从而在维护更新的测试的过程中添加新功能。
- en: We conclude this section with the final version of our palindrome test case,
    which adds a testcase for checking for strings with extra punctuations.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用检查最终版本的回文测试用例结束了本节，其中添加了一个检查带有额外标点符号的字符串的测试用例。
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And here is the updated palindrome module which makes this test pass:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新后的回文模块，使得这个测试通过：
- en: '[PRE41]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's inspect the final output of the test `_palindrome` module on the console.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下控制台上`_palindrome`模块的最终输出。
- en: '![TDD with palindromes](../Images/image00409.jpeg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![回文的TDD](../Images/image00409.jpeg)'
- en: 'Console output of test_palindrome.py version #3, with matching code updates'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: test_palindrome.py版本＃3的控制台输出，带有匹配的代码更新
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we revisited the definition of testability and its related
    architectural quality aspects, such as complexity and determinism. We looked at
    the different architectural aspects that are tested and got an understanding of
    the type of tests that are usually performed by the software testing process.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重新审视了可测试性的定义及其相关的架构质量方面，如复杂性和确定性。我们研究了被测试的不同架构方面，并了解了软件测试过程通常执行的测试类型。
- en: We then discussed the various strategies for improving the testability of software,
    and looked at techniques to reduce system complexity, improve predictability,
    and to control and manage external dependencies. Along the way, we learned the
    different ways to virtualize and manage external dependencies, such as fakes,
    mocks and stubs, by way of examples.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了改进软件可测试性的各种策略，并研究了减少系统复杂性、提高可预测性以及控制和管理外部依赖的技术。在这个过程中，我们学习了不同的虚拟化和管理外部依赖的方法，例如伪装、模拟和存根，通过示例进行了说明。
- en: We then looked at unit testing and its various aspects mainly from the perspective
    of the Python `unittest` module. We saw an example by using a datetime helper
    class, and explained how to write effective unit tests—a simple example followed
    by an interesting example of patching functions using the Mock library of `unittest`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从Python `unittest`模块的角度主要讨论了单元测试及其各个方面。我们通过使用一个datetime辅助类的示例，解释了如何编写有效的单元测试——先是一个简单的例子，然后是使用`unittest`的Mock库对函数进行打补丁的有趣的例子。
- en: We then introduced, and learned quite a bit about, the two other well-known
    testing frameworks in Python, namely, nose2 and py.test. Next we discussed the
    very important aspect of code coverage, and saw examples of measuring code coverage
    using the coverage.py package directly, and also by using it via plugins of nose2
    and pytest.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍并学习了Python中另外两个著名的测试框架，即nose2和py.test。接下来我们讨论了代码覆盖率的非常重要的方面，并看到了使用coverage.py包直接测量代码覆盖率的示例，以及通过nose2和pytest的插件使用它的示例。
- en: In the next section, we sketched an example of a textsearch class for using
    advanced mock objects, where we mocked its external dependency and wrote a unit
    test case. We went on to discuss the Python doctest support of embedding tests
    in the documentation of classes, modules, methods, and functions via the doctest
    module while looking at examples.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们勾勒了一个使用高级模拟对象的textsearch类的示例，我们对其外部依赖进行了模拟，并编写了一个单元测试用例。我们继续讨论了Python
    doctest支持，通过doctest模块在类、模块、方法和函数的文档中嵌入测试的示例。
- en: The next topic was integration tests, where we discussed the different aspects
    and advantages of integration tests, and looked at the three different ways in
    which tests can be integrated in a software organization. Test automation via
    Selenium was discussed next with an example of automating a couple of tests on
    the Python language website using Selenium and py.test.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个话题是集成测试，我们讨论了集成测试的不同方面和优势，并看了一下测试可以在软件组织中集成的三种不同方式。接下来讨论了通过Selenium进行测试自动化，以及使用Selenium和py.test在Python语言网站上自动化一些测试的示例。
- en: We ended the chapter with a quick overview of TDD, and discussed an example
    of writing a program for detecting palindromes in Python using the TDD principles,
    where we developed the program using tests in a step-by-step fashion.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以对TDD的快速概述结束了本章，并讨论了使用TDD原则编写Python中检测回文的程序的示例，我们以逐步的方式使用测试开发了这个程序。
- en: In the next chapter, we will look at one of the most critical quality attribute
    of architecture when developing software—namely, Performance.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论在开发软件时架构的一个最关键的质量属性，即性能。
