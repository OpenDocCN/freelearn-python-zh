- en: '*Chapter 7:* Program Control Structures'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章：程序控制结构*'
- en: If all of our code was simply executed in sequence, our programs would always
    do the same thing, no matter what data we provided them with. We must be able
    to control the path through the program so that some part of the code executes
    at the designated time, and other parts at other times, depending on the values
    provided by the data. For instance, only if it is cold outside do you put on warm
    clothes, not always. The same thing applies to our code. When things are a certain
    way, we want something to happen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的所有代码都简单地按顺序执行，无论我们向它们提供什么数据，我们的程序总是会做同样的事情。我们必须能够控制程序的路径，以便某些代码部分在指定的时间执行，而其他部分在其他时间执行，这取决于数据提供的值。例如，只有当外面很冷时，你才会穿上保暖的衣服，而不是总是这样。同样的事情也适用于我们的代码。当事情以某种方式发生时，我们希望发生某些事情。
- en: In a way, we can say that we, by this, will introduce some sort of intelligence,
    or at least some decision-making capabilities into our code. If things are this
    way, do this, if not, do that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，我们可以这样说，我们将通过这种方式在我们的代码中引入某种智能，或者至少是某种决策能力。如果事情是这样，这样做，如果不是，那样做。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Controlling the execution path of the program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制程序的执行路径
- en: Making decisions with the help of `if` statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`语句做出决策
- en: Selecting one out of many options with `switch` statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`switch`语句从许多选项中选择一个
- en: Repeating code execution with `for` loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`循环重复执行代码
- en: Iterating over code until a condition is false using `while` and `do while`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`while`和`do while`迭代代码直到条件为假
- en: Going over a sequence of data, one item at the time using `for each`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for each`逐个遍历数据序列
- en: In this chapter, we will dive into some real programming. In the topics that
    we will cover here, we will be able to control the execution path of the program.
    Let's first explore what that means.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入一些实际的编程。在我们将要涵盖的主题中，我们将能够控制程序的执行路径。让我们首先探索这意味着什么。
- en: Controlling the execution path
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制执行路径
- en: In [*Chapter 5*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081), *Sequence
    – The Basic Building Block of a Computer Program*, we learned that the code within
    a program is executed in sequence.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081)，*序列 – 计算机程序的基本构建块*中，我们学习了程序中的代码是按顺序执行的。
- en: A sequence is one of the three basic logical structures we have in programming.
    So, in this chapter, we will cover the other two, *selection* and *iteration*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是我们编程中拥有的三个基本逻辑结构之一。因此，在本章中，我们将介绍其他两个，*选择*和*迭代*。
- en: Selection statements
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择语句
- en: 'There are situations when we only want to execute some code if a condition
    is met. For example, if you recall our application from [*Chapter 5*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081),
    *Sequence - The Basic Building Block of a Computer Program* which turned on the
    outdoor light, we had a condition that said if our phone detected that we were
    within a given range from our house, it should send a signal to the home computer.
    To refresh your memory, let''s take a look at some images you have seen before.
    *Figure 7.1* was used to illustrate the action of us entering the range:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们只想在满足条件时执行一些代码。例如，如果你还记得我们的应用从[*第5章*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081)，*序列
    - 计算机程序的基本构建块*，其中打开了户外灯光，我们有一个条件说如果我们的手机检测到我们距离房子在给定范围内，它应该向家庭电脑发送信号。为了刷新你的记忆，让我们看看你之前看到的一些图片。*图7.1*被用来说明我们进入范围的行动：
- en: '![Figure 7.1: The phone detects that it is within a given range from our house](img/B15554_07_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：手机检测到它距离我们的房子在给定范围内](img/B15554_07_01.jpg)'
- en: 'Figure 7.1: The phone detects that it is within a given range from our house'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：手机检测到它距离我们的房子在给定范围内
- en: 'Then, we have a condition. We used the illustration shown in *Figure 7.2* to
    indicate that when the condition was true, that is, we are within the range, a
    signal should be sent to the home computer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个条件。我们使用*图7.2*中的插图来表示当条件为真时，即我们处于范围内，应该向家庭电脑发送信号：
- en: '![Figure 7.2: The condition is met, so the code for sending the message can
    be executed](img/B15554_07_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：条件满足，因此可以执行发送消息的代码](img/B15554_07_02.jpg)'
- en: 'Figure 7.2: The condition is met, so the code for sending the message can be
    executed'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：条件满足，因此可以执行发送消息的代码
- en: 'Let''s break it down a bit more and consider the actual steps involved. The
    application on the phone would need to do the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地分解一下，考虑实际涉及的步骤。手机上的应用程序需要执行以下操作：
- en: Ask the GPS on the phone for the current position.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向手机上的GPS请求当前位置。
- en: With the help of the given coordinates, calculate the distance to our home.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定坐标的帮助下，计算到我们家的距离。
- en: If the distance is within a given range from our house, then send a signal to
    the home computer.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果距离在我们的房子给定范围内，那么向家用电脑发送信号。
- en: 'As you can see, in *step 3*, we have a condition that states that the signal
    will only be sent if the condition is true. So, here, we have some code that will
    not always be executed. We call this selection. We could define selection like
    this: *selection is the ability to execute a section of code only if a condition
    is met.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在*步骤3*中，我们有一个条件，表示只有在条件为真时才会发送信号。所以，这里有一些代码不会总是被执行。我们称这为选择。我们可以这样定义选择：*选择是在满足条件时仅执行代码段的能力*。
- en: Now we can ask ourselves another question. What should we do if the condition
    is false, that is, we are not within the range? Well, for this application, the
    answer is nothing. If we are not in the range, then we won't need to do anything.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以问自己另一个问题。如果条件为假，也就是说，我们不在范围内，我们应该做什么？对于这个应用来说，答案是没有任何操作。如果我们不在范围内，那么我们就不需要做任何事情。
- en: The phone app also had another feature that is interesting to us now. When we
    have finished checking whether we are within the range or not, we will either
    send a signal to the home computer or do nothing. After that, we will go back
    to the beginning and repeat everything again so that we can be ready to check
    whether, after the movement, we are in the given range. We call this an *iteration*.
    We will learn what this is next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 手机应用还有一个我们现在感兴趣的功能。当我们完成检查我们是否在范围内后，我们将向家用电脑发送信号或什么都不做。之后，我们将回到开始并重复一切，以便我们可以准备好检查移动后我们是否在给定的范围内。我们称这为*迭代*。我们将在下一节学习这是什么。
- en: Iteration statements
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代语句
- en: An iteration is when we want to repeat something several times. It can also
    be referred to as a loop. The number of times we want to iterate something can
    be in the range of 2 to infinity. Now, in programming, infinity has a somewhat
    different perspective on things than you and I would usually have. Infinity in
    programming does not mean forever and ever, but more like as long as the program
    is running. So, in programming, infinity ends when the program ends.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是我们想要重复多次的事情。它也可以被称为循环。我们想要迭代的次数可以在2到无穷大之间。现在，在编程中，无穷大对事物的看法与我们通常的看法有所不同。编程中的无穷大并不意味着永远永远，而更像是在程序运行期间。所以，在编程中，无穷大在程序结束时结束。
- en: 'In the outdoor light app, we had an iteration. The following diagram illustrates
    the sequence for our phone app, and here we can clearly see the iteration:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在户外光照应用中，我们进行了一次迭代。以下图表展示了我们的手机应用的顺序，并且我们可以清楚地看到迭代过程：
- en: '![Figure 7.3: The two arrows pointing at the top item indicate iteration](img/B15554_07_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：指向顶部项目的两个箭头表示迭代](img/B15554_07_03.jpg)'
- en: 'Figure 7.3: The two arrows pointing at the top item indicate iteration'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：指向顶部项目的两个箭头表示迭代
- en: The diamond shape in the diagram is a condition. If the condition is true, that
    is, the answer is yes, that we send the signal. We can also see that no matter
    whether the condition was true or false, we will go back to the beginning. This
    app will continue to repeat these steps over and over an infinite number of times,
    that is, until you close the app or turn off your phone.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中的菱形形状是一个条件。如果条件为真，也就是说，答案是肯定的，我们会发送信号。我们还可以看到，无论条件是真是假，我们都会回到开始。这个应用将不断地重复这些步骤，无限次，也就是说，直到你关闭应用或关闭手机。
- en: Sometimes, we only want to iterate a fixed number of times. Let's say that you
    are implementing an e-commerce solution, and a customer wants to check out all
    of the items that are currently in the shopping cart. You would need to iterate
    over all of the items in the cart to calculate the total price. If there were
    5 items in the cart, then you would need to iterate 5 times.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们只想迭代固定次数。比如说，如果你正在实施一个电子商务解决方案，并且一个客户想要检查购物车中当前的所有商品。你需要遍历购物车中的所有商品来计算总价。如果购物车中有5件商品，那么你需要迭代5次。
- en: Both selection and iteration use conditions, so before we look at the different
    kinds of selection and iteration statements, let's take a closer look at what
    a conditional statement is and how it works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 选择和迭代都使用条件，所以在我们查看不同类型的选择和迭代语句之前，让我们更仔细地看看条件语句是什么以及它是如何工作的。
- en: Conditional statements
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'We have covered the basics of this in several chapters already. A conditional
    statement is just a statement that can result in either true or false. The following
    is a list of examples:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在几个章节中介绍了这个基础。条件语句就是可以导致真或假的语句。以下是一些例子：
- en: It is raining today.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天下雨。
- en: Your age is below 20.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的年龄低于20岁。
- en: Your credit card has expired.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的信用卡已经过期。
- en: Your coffee cup is empty.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的咖啡杯是空的。
- en: All of these will result in either true or false. There are no maybes. It is
    either raining or not; you are either below 20 or not, and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将导致真或假。没有可能的情况。要么下雨，要么不下雨；要么你低于20岁，要么不，等等。
- en: 'We have also seen that conditional statements can be combined with logical
    AND, or logical OR, to form a new, compound conditional statement. Here are some
    examples:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，条件语句可以与逻辑AND或逻辑OR结合，形成一个新的复合条件语句。这里有一些例子：
- en: It is raining today, and I have blue shoes.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天下雨，我有一双蓝色的鞋子。
- en: Your age is below 20, or it is above 60.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的年龄低于20岁，或者高于60岁。
- en: Your credit card has expired, and you have no cash.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的信用卡已经过期，而且你没有现金。
- en: Your coffee cup is empty, and your coffee machine is broken.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的咖啡杯是空的，你的咖啡机坏了。
- en: These compound, or full, statements are made up of two individual statements.
    *It is raining today* is one part, and *I have blue shoes* is another part. The
    two now need to be combined to form a full statement that can be either true or
    false. In the preceding example, we use *and* to combine them. This means that
    both individual statements need to be true for the whole statement to be true.
    It must be raining, *and* I must have blue shoes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些复合的或完整的语句由两个单独的语句组成。*今天下雨*是其中一部分，*我有一双蓝色的鞋子*是另一部分。现在这两个需要组合成一个完整的语句，这个语句可以是真或假。在上面的例子中，我们使用*和*来组合它们。这意味着两个单独的语句都必须为真，整个语句才为真。必须下雨，*并且*我必须有一双蓝色的鞋子。
- en: If we look at the second statement, the two smaller statements are combined
    with an *or*. This means that, for the whole statement to be true, at least one
    of the parts must be true. Either your card has expired, *or* you have no cash.
    It could also be unfortunate that both are true, and then the entire statement
    will be true.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看第二个语句，两个较小的语句是通过*或*组合的。这意味着，为了整个语句为真，至少有一部分必须为真。要么你的卡已经过期，*或者*你没有现金。也可能不幸的是两者都为真，那么整个语句将为真。
- en: Now we know that we have selection and iteration statements and that they work
    with conditions, so let's see how we can write code that uses them. Let's start
    with the most common selection statement, `if`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们有选择和迭代语句，并且它们与条件一起工作，所以让我们看看我们如何编写使用它们的代码。让我们从最常见的选择语句`if`开始。
- en: Selection with the if statement
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if语句进行选择
- en: When using selection in our programs, we could argue that the application uses
    some sort of *intelligence* because it can now make decisions and do different
    things depending on various conditions. So, how can we make our applications smart?
    Well, the easiest way is with the use of `if` statements, which are, sometimes,
    just referred to as *conditions*. In most languages, they will have a similar
    structure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在程序中使用选择时，我们可以认为应用程序使用某种*智能*，因为它现在可以根据各种条件做出决定并做不同的事情。那么，我们如何使我们的应用程序变得智能呢？嗯，最简单的方法是使用`if`语句，有时它们也被称为*条件*。在大多数语言中，它们将有类似的结构。
- en: 'If we write a small program that asks the user for their age, the first part
    might look something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写一个小程序来询问用户的年龄，第一部分可能看起来像这样：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the program prints `Enter your age:` on the screen. The user then enters
    an age and presses the *Enter* key to confirm the input. The value entered will
    be stored in the `age` variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，程序会在屏幕上打印`请输入你的年龄:`。然后用户输入一个年龄并按下*Enter*键确认输入。输入的值将被存储在`age`变量中。
- en: 'Now we want to give different feedback depending on the age entered:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想根据输入的年龄给出不同的反馈：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we have the condition where we check whether the age is below `18`. If
    so, we will print the message, `You are young`. The condition is that the age
    must be below `18`. If it is `18` or above, nothing will happen, as the program
    will skip everything between them and end the `if` statement.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有检查年龄是否低于`18`的条件。如果是这样，我们将打印消息，`You are young`。条件是年龄必须低于`18`。如果是`18`或以上，什么都不会发生，因为程序将跳过它们之间的所有内容并结束`if`语句。
- en: 'If, instead, we want to check for an interval, we could create a compound conditional
    statement, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检查一个区间，我们可以创建一个复合条件语句，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we are combining the two parts that make up the condition with
    an `and`. This means that both conditions must be true for the whole condition
    to be true. The age must be greater or equal to `13`, and, at the same time, it
    must be less than or equal to `19`. This will give us a range between 13 and 19,
    with both values included. If the age falls into this range, we will enter the
    `if` statement and print the text. If it is either less than 13 or greater than
    19, nothing will happen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在用`and`将构成条件的两部分结合起来。这意味着两个条件都必须为真，整个条件才为真。年龄必须大于或等于`13`，同时它必须小于或等于`19`。这将给我们一个介于13和19之间的范围，包括这两个值。如果年龄落在这个范围内，我们将进入`if`语句并打印文本。如果它要么小于13，要么大于19，什么都不会发生。
- en: 'The `if` statement comes with an optional part. This section is called `else`
    and marks a block of code that will be executed only if the condition in the `if`
    statement is false. This is shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句包含一个可选部分。这个部分被称为`else`，它标记了一个只有在`if`语句中的条件为假时才会执行的代码块。这在上面的代码中有所展示：'
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The difference here is that, now, we will always have something printed on the
    screen. Either the condition is true, and the message will be printed, or the
    condition is false and the section between `else` and `end_if` will be executed.
    Additionally, note that the part that will be executed when the condition is true
    now ends with the `else` keyword.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于，现在，我们将在屏幕上始终打印出一些内容。要么条件为真，消息将被打印，要么条件为假，`else`和`end_if`之间的部分将被执行。此外，请注意，当条件为真时将执行的部分现在以`else`关键字结束。
- en: 'We can have more than one statement in each of the sections if we want to:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在每个部分中有多于一个语句，我们可以：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, if the age falls into the teenage range, we will print two lines. And,
    if it is false, we will still only print one line.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果年龄落在青少年范围内，我们将打印两行。如果它是假的，我们仍然只会打印一行。
- en: If we want to have more complex logic, we can have nested `if` statements. That
    means we can have new `if` statements either in the section that executes if the
    condition is true or on the part that only executes if the condition is false.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更复杂的逻辑，我们可以有嵌套的`if`语句。这意味着我们可以在条件为真时执行的代码部分或者仅在条件为假时执行的代码部分中放置新的`if`语句。
- en: 'For example, if the condition in the preceding code is false, we know that
    you are either younger or older than the teenage years. If we want to distinguish
    this further, it is in this section of the code that we can check it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果前面代码中的条件为假，我们知道你要么比青少年时期年轻，要么比青少年时期年长。如果我们想进一步区分，那么就在这个代码部分我们可以进行检查：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now the logic is a bit more complicated. If the user of our program responded
    with an age that is between 13 and 19, nothing has changed. However, if the age
    is anything else, we have a new `if` statement. As this one is located within
    the `else` section of the first one, we know that the age is either below `13`
    or above `13`. The second `if` statement checks whether it is less than `13`.
    And, if so, prints the `You are a child` message.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的逻辑稍微复杂一些。如果我们的程序的用户响应的年龄在13到19岁之间，那么什么都没有改变。然而，如果年龄是其他任何东西，我们有一个新的`if`语句。因为这个语句位于第一个`if`语句的`else`部分中，我们知道年龄要么低于`13`，要么高于`13`。第二个`if`语句检查它是否小于`13`。如果是这样，就会打印出`You
    are a child`消息。
- en: Now, think about what condition we have if we enter the second `else` section.
    First, we know that age is not between 13 and 19, or we would not be in this part
    of the program at all. We also know that the age is not below 13 because, if it
    was, we would have executed the `You are a child` part. We only have one option
    left; the age must be above 19.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一下如果我们进入第二个`else`部分，我们会遇到什么条件。首先，我们知道年龄不在13到19岁之间，否则我们根本不会在这个程序的这部分。我们还知道年龄不是低于13岁，因为如果是的话，我们会执行`You
    are a child`部分。我们只剩下一个选项了；年龄必须在19岁以上。
- en: 'To have an `if` statement directly following an `else` statement, like we just
    saw, is so common that some languages have a special construct for it, called
    `elif`. In such a language, the same code would look something like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`else`语句后面直接使用`if`语句，就像我们刚才看到的，这在某些语言中非常常见，因此有一个特殊的结构，称为`elif`。在这种语言中，相同的代码看起来可能像这样：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The logic of the program is the same, but the code is more compact. As you can
    see, we have the second condition, if the age is below 13, on the same line as
    the old `else` statement, and the `else` statement has now changed into an `elif`
    statement. The word, `elif`, is just made up of the two words, `else` and `if`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的逻辑是相同的，但代码更加紧凑。正如你所看到的，我们将在同一行上放置第二个条件，即年龄小于13岁，以及旧的`else`语句，而`else`语句现在已变为`elif`语句。`elif`这个词是由`else`和`if`这两个词组成的。
- en: Additionally, note that, in the first example, the program ended with two lines
    containing `end_if`. The second version just has one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在第一个例子中，程序以包含`end_if`的两行结束。第二个版本只有一个。
- en: 'If you look at the second program, you can now clearly see that there are three
    different sections and that only one of them will be executed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看第二个程序，你现在可以清楚地看到有三个不同的部分，并且只有一个部分会被执行：
- en: If the age is between 13 and 19, we enter the first section and execute the
    code within that block. After that, we are done, and the rest of the code will
    be skipped.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果年龄在13到19岁之间，我们将进入第一个部分并执行该块内的代码。之后，我们就完成了，其余的代码将被跳过。
- en: If the age is below 13, we will first skip the first part and go to the `elif`
    part. The condition here is true, so we will enter this part and execute the code
    within. After that, we are done and can, again, skip to the end.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果年龄小于13岁，我们将首先跳过第一部分，转到`elif`部分。这里的条件是真实的，因此我们将进入这个部分并执行其中的代码。之后，我们就完成了，可以再次跳到末尾。
- en: Finally, if the age is greater than 19, we will first skip over the first section
    and go to the `elif` part. The condition found here will also be evaluated to
    false, so we skip ahead to the `else` part. As this part does not contain any
    condition, we will always end up here if none of the preceding conditions were
    true.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果年龄大于19岁，我们将首先跳过第一个部分，转到`elif`部分。这里找到的条件也将被评估为假，因此我们将跳过前面的部分，直接进入`else`部分。由于这部分不包含任何条件，如果前面的所有条件都不成立，我们最终都会到达这里。
- en: 'Even if the language we are using does not have an `elif` statement, we can
    create the same logic anyway. Consider the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们所使用的语言没有`elif`语句，我们仍然可以创建相同的逻辑。考虑以下代码：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that the only thing that has changed here is that the `elif` statement
    has been replaced with the two words, `else` and `if`. The rest is the same and
    the logic is also unchanged.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这里唯一改变的是将`elif`语句替换为两个词，`else`和`if`。其余部分相同，逻辑也没有改变。
- en: 'To use this idea with nested `if` statements such as this can be very efficient.
    First, we must understand that we can have as many of these as we need. The structure
    can then look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个想法与嵌套的`if`语句，如这个例子，可以非常高效。首先，我们必须理解我们可以有我们需要的所有这些。结构可以看起来像这样：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you look at this structure, you can see that this looks like a fork, where
    we only can choose one of the tines:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看这个结构，你可以看到这看起来像一把叉子，我们只能选择其中的一叉：
- en: '![Figure 7.4: Nested if statements are like a fork](img/B15554_07_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：嵌套的if语句就像一个叉子](img/B15554_07_04.jpg)'
- en: 'Figure 7.4: Nested if statements are like a fork'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：嵌套的if语句就像一个叉子
- en: When we have one out of many things that can be true, we do have an option.
    It is another fork-like structure that works pretty much the same way as the nested
    `if` statement we just saw. It is called a `switch` statement. We will study this
    next.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们面对许多可能正确的事物中的一个时，我们确实有一个选择。这是一个类似分支的结构，其工作方式与刚刚看到的嵌套`if`语句几乎相同。它被称为`switch`语句。我们将在下一节学习这个内容。
- en: Selection with the switch statement
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`switch`语句进行选择
- en: One alternative, when we have one option out of many that can be true, is the
    `switch` statement. It also works with conditions even if they are not as apparent
    as they are in an `if` statement.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们面对许多可能正确的事物中的一个选项时，一个替代方案是使用`switch`语句。即使条件不如`if`语句中那么明显，它也可以与条件一起工作。
- en: Another difference is that a `switch` statement only compares values for equality.
    The reason for it is that it is not suitable for the age logic we used when we
    explored the `if` statement, as we wanted to see whether the age was between two
    values. Instead, it is perfect if we're going to match it to a value that is fixed.
    We will soon look at a real example. However, first, let's explore the structure
    of a `switch` statement.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，`switch` 语句只比较值是否相等。这样做的原因是它不适合我们在探索 `if` 语句时使用的年龄逻辑，因为我们想看看年龄是否在两个值之间。相反，如果我们打算将其与一个固定的值匹配，它就非常完美。我们很快就会看到一个真实例子。然而，首先，让我们探索
    `switch` 语句的结构。
- en: What a `switch` statement looks like depends on what language we use. What we
    will see here is a structure that is rather common, but when applying it, you
    will need to look up the correct syntax for your language.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句的样子取决于我们使用的语言。在这里我们将看到的是一个相当常见的结构，但在应用它时，你需要查找你语言的正确语法。'
- en: A `switch` statement begins by stating what variable we want to check. It is
    common for languages to use the `switch` keyword for this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句首先声明我们要检查的变量。对于这个，语言通常使用 `switch` 关键字。'
- en: 'The structure looks something like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结构看起来可能像这样：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, the name, `variable`, is just a placeholder for the actual
    variable we want to work with. Between the `switch` keyword and `end_switch`,
    we will need to specify each value we want to compare the variable to. It could
    look something like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，名称 `variable` 只是一个占位符，用于我们想要实际操作的变量。在 `switch` 关键字和 `end_switch` 之间，我们需要指定我们想要比较变量的每个值。它可能看起来像这样：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each case specifies the value that we compare the variable to. The first case
    compares it to `1`, the second to `2`, and so on. The ellipsis (`...`) marks the
    location where we will insert the code for each option. The first ellipsis is
    to indicate which code will be executed if the variable is `1`, the second for
    when the value is `2`, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个案例指定了我们比较变量的值。第一个案例比较它为 `1`，第二个为 `2`，依此类推。省略号 (`...`) 标记了我们将插入每个选项代码的位置。第一个省略号表示如果变量是
    `1`，将执行哪个代码，第二个表示当值为 `2` 时，依此类推。
- en: In many languages, we have something that is called a *fallthrough*. What this
    means is that when the right value is found, the code within that `case` statement
    will execute, but then the code in all the `case` statements that follow will
    also execute. So, if the value of the variable is `2`, the code for both `2` and
    `3` will execute. The reason it does that is so that we can have multiple `case`
    instances following each other and just one code block for them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，我们有一种称为 *fallthrough* 的东西。这意味着当找到正确的值时，该 `case` 语句内的代码将会执行，但随后所有后续的 `case`
    语句中的代码也会执行。所以，如果变量的值是 `2`，`2` 和 `3` 的代码都会执行。这样做的原因是我们可以有一个多个 `case` 实例依次排列，并且只需要一个代码块来处理它们。
- en: 'To indicate that we want the fallthrough to stop, we must give an instruction
    that we are done, and we can now jump to the end of the `switch` statement. This
    instruction is, usually, `break`. It is shown in the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示我们想要停止 fallthrough，我们必须给出一个完成的指令，然后我们可以跳转到 `switch` 语句的末尾。这个指令通常是 `break`。它将在下面的例子中展示：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Normally, we have one value for each case block, so the code will look like
    this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个案例块只有一个值，所以代码将看起来像这样：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the value of the variable is `2`, the code within that block will execute,
    and when the `break` statement is reached, the execution of the whole `switch`
    statement will end. This is good, as only one of the options can be true. So,
    if one has been executed, we know that we are done.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量的值是 `2`，那么该块内的代码将会执行，并且当遇到 `break` 语句时，整个 `switch` 语句的执行将结束。这是好的，因为只有一个选项可以是正确的。所以，如果其中一个被执行了，我们就知道我们完成了。
- en: You could argue that the `break` statement in the `case` block for the value
    of `3` is unnecessary as we don't have any more statements that we can fall through
    to. However, it is a good practice to have it there because we might add more
    options in the future, and then we wouldn't want to take the risk of forgetting
    to add that `break`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，对于值为 `3` 的 `case` 块中的 `break` 语句是不必要的，因为我们没有更多的语句可以 fallthrough。然而，这是一个好的做法，因为将来我们可能会添加更多的选项，而且我们不希望承担忘记添加那个
    `break` 的风险。
- en: '`switch` statements also have something that resembles the `else` part of an
    `if` statement, that is, a block that would execute if no other values evaluated
    to true. In a `switch` statement, this is called `default`. It usually comes at
    the very end, after all of the `case` statements. It can look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句也有类似于`if`语句的`else`部分的东西，即如果评估为真的值没有其他值，将会执行的块。在`switch`语句中，这被称为`default`。它通常位于所有`case`语句之后，非常接近末尾。它可以看起来像这样：'
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, the last `break` statement is optional, but we keep it there for consistency.
    Note that now we can appreciate that we had a break within number `3`, since,
    without it, a value of `3` would first execute the code in the `3` block and then
    fall through to the default block.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，最后的`break`语句是可选的，但我们保留它以保持一致性。注意，现在我们可以欣赏到我们在数字`3`内部有一个`break`，因为如果没有它，数字`3`会首先执行`3`块中的代码，然后跳转到默认块。
- en: Now we have all the parts of a `switch` statement in place, so let's look at
    an example of when and how it can be used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了`switch`语句的所有部分，所以让我们看看一个例子，看看何时以及如何使用它。
- en: 'Here, we will ask the user of our program to input the numeric value for a
    month, that is, `1` for January, `2` for February, and so on. We will store the
    number the user entered in a variable we call `month`. We can now use this variable
    in a `switch` statement to figure out the name that matches the number the user
    gave us. Consider the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将要求我们的程序用户输入月份的数值，即`1`代表一月，`2`代表二月，依此类推。我们将把用户输入的数字存储在我们称为`month`的变量中。现在我们可以在`switch`语句中使用这个变量，以找出与用户给出的数字匹配的名称。考虑以下代码：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, months 4 to 11 are left out, but they are repeated using
    the same pattern.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，省略了月份4到11，但它们使用了相同的模式重复。
- en: 'Let''s say the user enters `8`. The program will start at the top and check
    case `1`. If this has been an `if` statement instead of a `switch`, case `1` would
    be equivalent to this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户输入了`8`。程序将从顶部开始，检查情况`1`。如果这是一个`if`语句而不是`switch`，情况`1`将等同于以下内容：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the user entered `8` and not `1`, this is false, so the program will go
    to the next case, `case 2`, and try again. There is still no luck, so it will
    continue all the way down to `case 8`, where it finally gets a match. It will
    now enter this block and create a variable called `month_string` and assign the
    value of `August` to it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户输入了`8`而不是`1`，这是错误的，所以程序将转到下一个情况`case 2`并再次尝试。仍然没有运气，所以它将继续一直到底部到`case 8`，在那里它最终找到了匹配项。现在它将进入这个块，创建一个名为`month_string`的变量，并将`August`的值分配给它。
- en: On the next line, it hits a `break`. This means, "get me out of here," so the
    program will now skip all of the other tests because it knows that it is done.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，它遇到了一个`break`。这意味着“让我从这里出去”，所以程序现在将跳过所有其他测试，因为它知道它已经完成了。
- en: If the user entered an invalid month, say `14`, all cases will first be checked,
    but as none will be true, the code in the `default` block will execute and the
    `month_string` variable will get an `Invalid` value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了一个无效的月份，比如说`14`，所有的情况都会首先被检查，但由于没有一个是真的，`default`块中的代码将会执行，并且`month_string`变量将获得一个`Invalid`值。
- en: On the very last line, the text, `The name of the month you entered is`, will
    be printed, and the value we have in our `month_string` variable will be appended
    to the end.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，将打印文本`The name of the month you entered is`，并且我们`month_string`变量中的值将被附加到末尾。
- en: 'The execution of the program would look something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的执行过程可能看起来像这样：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the help of the selection structures, `if` and `switch`, we can build complex
    logic.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择结构`if`和`switch`，我们可以构建复杂的逻辑。
- en: 'When designing a solution, you should keep a couple of things in mind:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计解决方案时，你应该记住以下几点：
- en: 'It is easy to get a bit confused as the logic will, at times, feel entangled
    and hard to understand. It is, therefore, essential to remember what we said earlier
    in this book: try to zoom in to one small subproblem, understand it, and design
    a solution for it. When that is in place, you can zoom out a bit and examine how
    it works in a bigger context. Then, you can repeat this process. This might sound
    very abstract but keep it in the back of your mind, and try to use this approach
    when you feel that a problem is getting too complex.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于逻辑有时会显得错综复杂，难以理解，因此很容易感到困惑。因此，记住我们在这本书中早些时候说过的话是至关重要的：尝试缩小到一个小的子问题，理解它，并为它设计一个解决方案。当这个解决方案就绪时，你可以稍微放大一些，检查它在更大背景下的工作方式。然后，你可以重复这个过程。这听起来可能非常抽象，但请将其放在心中，并在感觉问题变得过于复杂时尝试使用这种方法。
- en: Always remember that the readability of your code counts. What this means is
    that if you have a solution that works but the code is very complex and hard to
    read, you should go back and try to rewrite it, making sure that it still works
    but also that another programmer (or you in the future) easily can read and understand
    what the code does.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是记住，你代码的可读性很重要。这意味着，如果你有一个可行的解决方案，但代码非常复杂且难以阅读，你应该回去尝试重写它，确保它仍然可行，同时也要确保其他程序员（或未来的你）能够轻松阅读和理解代码的功能。
- en: Now that we have covered two of the three fundamental pillars that programming
    rests upon, sequence and selection, it is time to tackle the last one, iteration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了编程建立在之上的三个基本支柱中的两个，即顺序和选择，现在是时候解决最后一个，迭代。
- en: Iteration with the for loop
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`for`循环进行迭代
- en: The first type of iteration we will look at is the `for` loop. This is a kind
    of loop when we, in one way or the other, know how many times we want to repeat
    something. This can be a fixed number of times, such as iterating over a list
    using the days of the week. We know it is always 7\. It can also be that we have
    values in an array. We might not know precisely how many items there are in the
    array at any given time; however, as we will see, there are ways to ask the array
    how many objects it is currently holding.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的第一种迭代类型是`for`循环。这是一种我们知道要重复多少次的循环。这可能是一个固定次数，比如使用一周中的日子来遍历一个列表。我们知道它总是7次。也可能是在一个数组中有值。我们可能不知道在任何给定时间数组中确切有多少项；然而，正如我们将看到的，有方法可以询问数组它当前持有多少对象。
- en: 'When using a `for` loop, we will work with a variable that keeps track of how
    many times we have iterated. We can decide what value this variable shall start
    on. It is this variable that helps us to know when to stop iterating. Let''s look
    at an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`for`循环时，我们将与一个变量一起工作，该变量跟踪我们迭代了多少次。我们可以决定这个变量应该从哪个值开始。是这个变量帮助我们知道何时停止迭代。让我们看一个例子：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we create (or declare, as a programmer would say) a variable called `i`.
    The name, `i`, is frequently used as the name for this variable since it is often
    used as an index. However, we will discuss that in more detail later. After the
    assignment operator (`=`), we say that we want to give `i` a starting value of
    `0`. We will then repeat the code within the `for` block and `i` will be increased
    by one for each iteration. The value of `10` is the stop condition. When `i` has
    reached this value, it should stop repeating and continue executing the code that
    comes after the loop.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建（或者像程序员说的那样声明）一个名为`i`的变量。名字`i`经常被用作这个变量的名字，因为它通常用作索引。然而，我们将在稍后详细讨论这一点。在赋值运算符（`=`）之后，我们说我们想要给`i`一个起始值为`0`。然后我们将重复`for`块内的代码，`i`将在每次迭代时增加一。`10`是停止条件。当`i`达到这个值时，它应该停止重复并继续执行循环之后的代码。
- en: 'If we print the value that `i` currently has inside the loop, the code will
    look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在循环内部打印`i`当前的值，代码将看起来像这样：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Most languages will print the values of 0 to 9 and not 0 to 10\. That might
    seem strange, but if we look at the logic that the `for` loop uses, we can understand
    why that is.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言会打印从0到9的值，而不是从0到10。这可能会显得有些奇怪，但如果我们看看`for`循环使用的逻辑，我们就可以理解为什么是这样。
- en: When we first hit the line with the `for` loop, the variable, `i`, is created
    and initialized with the value of `0`, since we said that we want this as our
    starting value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次遇到`for`循环的行时，变量`i`被创建并初始化为`0`的值，因为我们说这是我们想要的起始值。
- en: It will then compare the value that `i` has with the second value we gave, `10`.
    If they are equal, the loop will stop. As this is the first iteration, the value
    is 0 and they are not equal; therefore, the code inside the loop will execute.
    When we come back up to the line with the `for` loop again, the value in `i` is
    incremented by one, that is, 0 + 1 = 1\. This value is now compared to our end
    value, `10`. This is still not a match. It will continue like this until the value
    of `i` is `9`. When returning to the line with the `for` loop again, it will increase
    `i` by `1`, making it `10`. Now, when the values are compared, they will be equal
    and the `for` loop will end. So, we will never enter the loop when `i` has the
    value of `10` and that is why we only see the values of 0 to 9 printed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将比较`i`的值与我们给出的第二个值`10`。如果它们相等，循环将停止。由于这是第一次迭代，值是0，它们不相等；因此，循环内的代码将执行。当我们再次回到带有`for`循环的行时，`i`的值将增加一，即0
    + 1 = 1。这个值现在与我们的结束值`10`进行比较。这仍然不是匹配。它将继续这样进行，直到`i`的值为`9`。当我们再次回到带有`for`循环的行时，它将`i`增加`1`，使其变为`10`。现在，当值进行比较时，它们将相等，`for`循环将结束。所以，当`i`的值为`10`时，我们永远不会进入循环，这就是为什么我们只看到从`0`到`9`的值被打印出来的原因。
- en: 'As mentioned before in this book, the C programming language has had a huge
    impact on the syntax of many other languages. The way in which `for` loops are
    written is such an example. Let''s examine what the same `for` loop would look
    like in C:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书之前所述，C编程语言对许多其他语言的语法产生了巨大影响。`for`循环的编写方式就是一个例子。让我们看看相同的`for`循环在C语言中会是什么样子：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On the first line, we declare the variable, `i`, also stating that it shall
    work with the data type, `int`. In the C language, statements end with a semicolon.
    That is why we have one after the `i` variable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们声明变量`i`，并声明它将使用数据类型`int`。在C语言中，语句以分号结束。这就是为什么我们在`i`变量后面有一个分号。
- en: Then comes the `for` loop. In C, we have three sections in a `for` loop. They
    are separated using semicolons. The first is the initialization. That is where
    we say `i = 0`. This means that `i` will have a value of `0` in the first iteration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`for`循环。在C语言中，`for`循环有三个部分，它们用分号分隔。第一个是初始化。这就是我们说`i = 0`的地方。这意味着在第一次迭代中，`i`的值将是`0`。
- en: The second part is the condition that states how long we shall continue to loop.
    Here, we say `i < 10.` We can read this as *continue as long as i is less than
    10*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是循环持续的条件。在这里，我们说`i < 10`。我们可以这样理解：*只要`i`小于10，就继续循环*。
- en: The last section indicates how `i` will change in each iteration. Here, we say
    `i++`. This is C's way of saying, *take whatever is in the variable,* `i`, *right
    now and increase it by one, then store the new value in* `i`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分指示了`i`在每次迭代中如何变化。在这里，我们说`i++`。这是C语言表示“取变量`i`当前的值，增加一，然后将新值存储在`i`中”的方式。
- en: The line inside the loop might look a bit strange. But there is no need to go
    into all of the details of how C handles printing values, as it is far more complicated
    than in most languages. The only thing we need to know is that it will print the
    current value of `i`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 循环内的行可能看起来有点奇怪。但不需要深入了解C语言处理打印值的所有细节，因为它比大多数语言都要复杂得多。我们唯一需要知道的是，它将打印`i`的当前值。
- en: The output will be the same as in our earlier example, `0` to `9`. Here, we
    can see why the value of 10 is not printed because the condition says `i < 10`.
    When `i` is `10`, this is no longer true, and the loop will exit. If we, instead,
    had `i <= 10`, the value of `10` would be included.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将与我们之前的例子相同，即从`0`到`9`。在这里，我们可以看到为什么10的值没有被打印出来，因为条件是`i < 10`。当`i`为`10`时，这个条件不再成立，循环将退出。如果我们改为使用`i
    <= 10`，则`10`的值将被包含在内。
- en: The languages that use this style include C++, C#, Java, JavaScript, PHP, and
    Go. With slight variations, they all have `for` loops that use the three sections
    that we saw in the C loop.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种风格的编程语言包括C++、C#、Java、JavaScript、PHP和Go。它们都有与C循环中我们看到的三部分略有不同的`for`循环。
- en: For simplicity, we will not use the C-style loops in this book but stick to
    the first version we looked at instead. This will help us to focus on how `for`
    loops work without being distracted by the syntax for writing them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们在这本书中不会使用C风格的循环，而是坚持使用我们最初看到的版本。这将帮助我们集中精力了解`for`循环的工作原理，而不会被编写它们的语法所分散。
- en: 'If we want to change the loop variable in any other way than just increasing
    it by one, we can do that as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以除了增加一以外的任何方式更改循环变量，我们可以这样做：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we will increment the value that `i` has by `2` each time. The output
    of this program will be similar the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将每次将`i`的值增加`2`。这个程序的输出将类似于以下内容：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It still starts at 0, but as we increment by `2`, all the odd numbers will be
    skipped. Just like earlier, we are exiting the loop when `i` reaches `10`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然从0开始，但随着我们每次增加`2`，所有奇数都将被跳过。就像之前一样，当`i`达到`10`时，我们将退出循环。
- en: Sometimes, we want to put a `for` loop inside another `for` loop. This is called
    a nested `for` loop. We will need two different variables for these loops so that
    they don't interfere with each other. As an example, we might want to go over
    all 7 days of the week. We will print the days such as `day 0`, `day 1`, and so
    on. We will start at 0 for simplicity, but we could, of course, have started at
    1 if we wanted to.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们想在另一个`for`循环内部放置一个`for`循环。这被称为嵌套`for`循环。我们需要为这些循环使用两个不同的变量，以便它们不会相互干扰。例如，我们可能想要遍历一周中的所有7天。我们将打印像`day
    0`、`day 1`这样的天数。我们将从0开始以简化，当然，如果我们想的话，我们也可以从1开始。
- en: For each day, we want to print all of the hours of that day. If we think about
    it, we will need a loop for the days. When we are inside this loop, we can imagine
    that we are working with one single day. For this day, we will need to print all
    of the hours. Then, when we are done, we will need to repeat the process for the
    next day. Instead of using the variable name, `i`, we can use more meaningful
    names for the two loops. We will use `day` for the loop that handles the days
    and `hour` for the loop that controls the hours.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一天，我们想要打印该天的所有小时。如果我们考虑一下，我们需要一个循环来处理天数。当我们在这个循环内部时，我们可以想象我们正在处理一个单独的一天。对于这一天，我们需要打印所有的小时。然后，当我们完成时，我们需要为下一天重复这个过程。我们可以不用变量名`i`，而是为两个循环使用更有意义的名字。我们将使用`day`来处理天数的循环，使用`hour`来控制小时的循环。
- en: 'This is what the program should look like:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个程序应该看起来像的：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output would look something like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are leaving out parts of this long output. The parts left out are indicated
    by an ellipsis.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了这部分长输出。省略的部分用省略号表示。
- en: If we follow the logic of this program, we can see that we first start out with
    the outermost loop, that is, the one that handles the days. We have a variable
    called `day` and assign it to the starting value of `0`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循这个程序的逻辑，我们可以看到我们首先从最外层的循环开始，即处理天数的循环。我们有一个名为`day`的变量，并将其赋值为起始值`0`。
- en: Then, we print the text, `day`, and append the value stored in the variable
    named `day`. Note that `day` within quotes is a string that will be printed as
    it is, and `day` without quotes is the variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打印文本`day`，并附加名为`day`的变量的值。注意，引号内的`day`是一个字符串，将按原样打印，而引号外的`day`是一个变量。
- en: Then, we come to the innermost loop. This will handle the hours. This also starts
    out with a value of `0` and uses a variable called `hour`. It will print the current
    hour in the same way that we did with the days.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们来到最内层的循环。这个循环将处理小时。它同样从值`0`开始，并使用一个名为`hour`的变量。它将以与我们处理天数相同的方式打印当前小时。
- en: The program will run inside the inner loop until we get a value of `24` inside
    the variable, `hour`. Then, it will exit. The program will now go back to the
    beginning of the outer loop, the one handling days. It will increase the `day`
    variable by one, and check whether it is less than `7`. And, because it is, we
    will enter the loop, and the process will repeat.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将在内层循环中运行，直到变量`hour`中的值达到`24`。然后，它将退出。现在程序将回到外层循环的开始，即处理天数的循环。它将`day`变量增加一，并检查它是否小于`7`。因为它是，我们将进入循环，过程将重复。
- en: 'It is also possible to go backward in a `for` loop. We just need to switch
    the starting and end values and decrease the loop variable instead of increasing
    it. It can look something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中向后移动也是可能的。我们只需要交换起始值和结束值，并减少循环变量而不是增加它。它可以看起来像这样：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we will count down from `10` to `0`. Since we want the value of `0` to
    be printed, we have set the stop value to `-1`. We can see the stop value as the
    first value that should not be part of the range. Since we are decreasing the
    variable by `1`, the first value after `0` is `-1`. We have also changed the step
    to `-1`. This will cause the variable to decrement by 1 each time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从`10`倒数到`0`。由于我们想要打印的值是`0`，我们将停止值设置为`-1`。我们可以将停止值视为不应该包含在范围中的第一个值。由于我们是递减变量，`0`之后的第一个值是`-1`。我们还改变了步长为`-1`。这将导致变量每次递减1。
- en: Sometimes, we don't know how many times we want to repeat something. We can
    use another type of `for` loop, that is, the `while` loop. Let's explore what
    that is.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们不知道我们想要重复多少次。我们可以使用另一种类型的 `for` 循环，即 `while` 循环。让我们来探索一下这是什么。
- en: Iteration with the while loop
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `while` 循环进行迭代
- en: Let's assume that we want to write a small dice-guessing game. The user will
    need to enter a guess between 1 and 6\. The computer will then roll a dice and
    let the user know whether their guess was correct or not. The program will then
    allow the user to guess again, and again, and again. However, if the user enters
    a value of 0 as their guess, we will let them exit the game.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个小型的掷骰子猜谜游戏。用户需要输入一个介于 1 和 6 之间的猜测。然后电脑将掷骰子并告诉用户他们的猜测是否正确。程序将允许用户再次猜测，再次猜测。然而，如果用户输入
    0 作为他们的猜测，我们将允许他们退出游戏。
- en: We have no way of knowing how many times the user wants to play the game. They
    might give up after the first try or go on for hundreds of attempts (which is
    not that likely as this is a rather dull game, but you get the point).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法知道用户想要玩多少次游戏。他们可能在第一次尝试后就放弃，或者进行数百次尝试（虽然不太可能，因为这是一个相当无聊的游戏，但你应该明白这个意思）。
- en: A `for` loop would not work that well for us here as we would need to say how
    many times the user would need to play before we let them out of the loop. Instead,
    another type of loop that is perfect for this scenario is the `while` loop. This
    loop works on a condition instead of a count. If the condition is true, it will
    continue to loop.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环在这里不太适用，因为我们需要说明用户需要玩多少次才能让他们退出循环。相反，另一种非常适合这种场景的循环类型是 `while` 循环。这种循环基于条件而不是计数。如果条件为真，它将继续循环。'
- en: 'The structure looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 结构看起来像这样：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the condition is true, we will continue looping. This means that somewhere
    within the loop, the condition must be able to change or it will never get out
    of the loop.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为真，我们将继续循环。这意味着在循环的某个地方，条件必须能够改变，否则它将永远无法退出循环。
- en: 'We will still need a variable to use in the condition. For example, we could
    use a Boolean variable for this. Recall that a Boolean variable only can hold
    the values of `true` and `false`, and a condition is something that will be evaluated
    to either true or false. It can look like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要一个变量来在条件中使用。例如，我们可以使用布尔变量。回想一下，布尔变量只能持有 `true` 和 `false` 的值，而条件是会被评估为真或假的某个东西。它可能看起来像这样：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we declare a variable called `continue` and set it to `true`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为 `continue` 的变量并将其设置为 `true`。
- en: The `while` loop will look at the content of this variable, and, since it is
    `true`, it will enter the loop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环将检查这个变量的内容，由于它是 `true`，它将进入循环。'
- en: It will now continue to loop as the variable has the value of `true`. It is,
    therefore, vital that we, at some point inside the loop, assign a value of `false`
    to the variable so that we can get out of the loop.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变量具有 `true` 的值，它将继续循环。因此，在循环的某个地方，我们分配一个 `false` 值给变量，以便我们可以退出循环是非常重要的。
- en: 'Let''s now build our guessing game using a `while` loop:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 `while` 循环来构建我们的猜谜游戏：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Before going over the program and how it works, take a look at the following
    output from a potential game:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解程序及其工作原理之前，先看看以下潜在游戏的输出：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Looking at the code, we can observe the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 观察代码，我们可以观察到以下内容：
- en: We can see that we first create our variable that will keep track of when to
    stop looping. Since the `while` loop runs if something is true, we set this variable
    to `true`. If it is set to `false`, we will not enter the loop and the game will
    be over before we even had a chance to play.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到，我们首先创建了一个变量，用来跟踪何时停止循环。由于 `while` 循环在某个条件为真时运行，我们将这个变量设置为 `true`。如果它被设置为
    `false`，我们就不会进入循环，游戏在我们有机会玩之前就会结束。
- en: Then comes the actual loop. Since the variable initially is set to `true`, we
    will enter the loop.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是实际的循环。由于变量最初被设置为 `true`，我们将进入循环。
- en: The first thing that happens in the loop is that there is some text that provides
    instructions to the user. This is an excellent idea to let the user know how to
    exit the game.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环中首先发生的事情是显示一些文本，为用户提供指令。这是一个很好的主意，让用户知道如何退出游戏。
- en: We then take the input from the user and store it in a variable called `guess`.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们获取用户的输入并将其存储在一个名为 `guess` 的变量中。
- en: Now it is time to roll a virtual dice. The `random(1, 6)` will give us a random
    number between 1 and 6\. We store that random number in a variable named `dice`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在是时候掷一个虚拟骰子了。`random(1, 6)`将给我们一个介于1到6之间的随机数。我们将这个随机数存储在一个名为`dice`的变量中。
- en: Before we check whether the user made a correct guess or not, we will examine
    whether the user has entered `0` to indicate that the game is over. The reason
    we do that before we check whether the guess is correct or not is because if the
    user wants to end the game, we don't want to check their guess as we know 0 will
    indicate a wrong guess. We don't want to treat the input of `0` as a guess.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查用户是否做出了正确猜测之前，我们将检查用户是否输入了`0`以表示游戏结束。我们在检查猜测是否正确之前这样做的原因是，如果用户想要结束游戏，我们不希望检查他们的猜测，因为我们知道`0`将表示一个错误的猜测。我们不希望将`0`的输入视为一个猜测。
- en: If `guess` is equal to `0`, we want to exit the loop. We do that by assigning
    `false` to the `continue` variable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`guess`等于`0`，我们想要退出循环。我们通过将`false`赋值给`continue`变量来实现这一点。
- en: As the rest of the content of the loop is in an `else` block, we will skip that
    if the input was `0`. When we move to the line with `while`, `continue` will now
    be `false`, and we will exit the loop and print the thank you line at the end
    of the program.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于循环的其余内容都在一个`else`块中，如果输入是`0`，我们将跳过那个块。当我们移动到带有`while`的行时，`continue`现在将是`false`，我们将退出循环，并在程序末尾打印感谢的行。
- en: If the user has, instead, entered something other than `0`, we will enter the
    first `else` block.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入的不是`0`，我们将进入第一个`else`块。
- en: The first line inside of this block is where we check whether the user made
    a correct guess. If the value we store in `guess` and the value that is in the
    `dice` variable is equal, we have a winner.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块内的第一行是我们检查用户是否做出了正确猜测的地方。如果我们存储在`guess`中的值和`dice`变量中的值相等，我们就有了赢家。
- en: If so, we will print a message congratulating the user. If not, we will let
    the user know that the guess was wrong.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们将打印一条祝贺用户的消息。如果不是，我们将告知用户猜测是错误的。
- en: 'Looking at the code, we can see that the indentation of the code helps us to
    see which part belongs to which block. Note the block that starts with the following
    line:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 看看代码，我们可以看到代码的缩进有助于我们看出哪个部分属于哪个块。注意以下行开始的块：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This can only be reached if the user did not enter a value of `0` since it is
    within an `else` block.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当用户没有输入`0`的值时，才能达到这一点，因为它在一个`else`块中。
- en: As you can see, a `while` loop is a handy feature. It has a sibling, the `do
    while` loop, which is almost identical to the `while` loop but with a little twist.
    Let's examine that next.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`while`循环是一个实用的特性。它有一个兄弟，即`do while`循环，它与`while`循环几乎相同，但有一点不同。让我们接下来看看这一点。
- en: Iteration with the do while loop
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`do while`循环进行迭代
- en: The `do while` loop has the same features as the `while` loop. `do while` works
    on a condition and can be used when we don't know how many iterations we will
    need to make.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`do while`循环具有与`while`循环相同的特性。`do while`基于一个条件，可以在我们不知道需要执行多少次迭代时使用。'
- en: The difference from the `while` loop is that where a `while` loop might never
    execute because the condition could be `false` the first time we test it. In comparison,
    the `do while` loop is guaranteed to run at least once. The reason for this is
    because the condition is moved from the beginning of the loop to the end of it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`循环的不同之处在于，`while`循环可能永远不会执行，因为第一次测试条件时它可能是`false`。相比之下，`do while`循环保证至少运行一次。这是因为条件从循环的开始移动到了循环的末尾。
- en: 'This can be good for several reasons, and it can make our guessing game slightly
    less complicated. However, before we do that, we should look at what a `do while`
    loop looks like:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多个原因可能是有益的，并且可以使我们的猜谜游戏稍微简单一些。然而，在我们这样做之前，我们应该看看`do while`循环的样子：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `do` keyword marks the beginning of the loop. As you can see, there is nothing
    more on this line, so the program must run through the code inside the loop at
    least once to reach the condition at the very end.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`关键字标志着循环的开始。正如你所见，这一行没有其他内容，所以程序必须至少运行一次循环内的代码，才能达到最后的条件。'
- en: Just as with the `while` loop, we must have some code that somehow modifies
    the condition so that we can get out of the loop.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`while`循环一样，我们必须有一些代码以某种方式修改条件，这样我们才能从循环中退出。
- en: 'One interesting aspect, when compared with the `while` loop, is that we don''t
    need to create a variable outside the loop to hold a value that we can use for
    our condition. The reason for this is that, since we are checking the condition
    at the very end, we might be able to perform the condition check using a variable
    that we create inside the loop. To see this in action, let''s modify our guessing
    game to use a `do while` loop. Take a look at the following snippet:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`循环相比，一个有趣的方面是，我们不需要在循环外部创建一个变量来保存我们可以用于条件的值。原因是，由于我们是在循环的末尾检查条件，我们可能能够使用在循环内部创建的变量来执行条件检查。为了看到这一点是如何工作的，让我们修改我们的猜测游戏以使用`do
    while`循环。看一下下面的片段：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The program is a bit shorter. This is because the `continue` variable is gone.
    If you look at the condition found on the penultimate line, you will see that
    we are using the `guess` variable directly to check whether it is not `0` (remember
    that the `!=` operator means, does not equal to). This means if the user does
    not input `0`, we will repeat.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 程序变得更短了。这是因为`continue`变量已经消失了。如果你查看倒数第二行的条件，你会看到我们正在直接使用`guess`变量来检查它是否不等于`0`（记住，`!=`运算符表示不等于）。这意味着如果用户没有输入`0`，我们将重复。
- en: We have also changed the `if` statement inside the loop. It now checks whether
    the `guess` variable is not equal to `0`, and only if it is, we will treat it
    as a proper guess.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还改变了循环内的`if`语句。现在它检查`guess`变量是否不等于`0`，只有当它等于`0`时，我们才会将其视为一个正确的猜测。
- en: If we have a sequence of things, such as an array, for example, it can be handy
    to go through that sequence one item at a time. We do have a loop for that too,
    which is the `for each` loop. Let's explore how that works next.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一系列的事物，例如数组，那么逐个处理那个序列可能很有用。我们确实有一个循环来做这件事，那就是`for each`循环。让我们接下来探索它是如何工作的。
- en: Iterating over sequences using for each
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`for each`遍历序列
- en: 'When we have a sequence of things, we often want to go through it item by item.
    We can, of course, do that using a `for` loop, like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一系列的事物时，我们通常希望逐个处理它们。当然，我们可以使用`for`循环来实现这一点，如下所示：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: On the first line, we declare an array of strings containing some names. We
    are using a variable called `names` to store the values.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们声明了一个包含一些名字的字符串数组。我们使用一个名为`names`的变量来存储这些值。
- en: Then, we use a `for` loop, starting at `0`. To find out how many times we will
    iterate, we ask the array how many items it currently has stored. We do that by
    using the `names` variable, and, by using a dot, we can get what is known as a
    property from the array. This property is a value that stores how many items the
    array currently has. The way we can ask a sequence how many items it has will
    differ from language to language, but it will most likely be something like what
    we have done.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个从`0`开始的`for`循环。为了找出我们将迭代多少次，我们询问数组它目前存储了多少项。我们通过使用`names`变量，并通过使用点号，我们可以从数组中获取一个称为属性的东西。这个属性是一个存储数组当前项数的值。我们可以询问序列有多少项的方式可能因语言而异，但它很可能是我们这样做的方式。
- en: 'We need to remember two things here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要记住两件事：
- en: When using an index to retrieve a value from the array, we start at `0`. This
    means that we need to give our loop a start value of `0`, since `Anna` will be
    stored at that index.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用索引从数组中检索值时，我们从`0`开始。这意味着我们需要给我们的循环一个起始值为`0`，因为`Anna`将存储在那个索引。
- en: We need to make sure that the ending value is one that is greater than the last
    index in the `for` loop. Our array has four values, so when we ask it for its
    length, that is the value we get. However, when indexing into the array, we need
    to use the values of 0, 1, 2, and 3\. This is four values, and the counting starts
    at 0, not 1\. Since we know that the second value we give in the `for` loop is
    the ending value, and it is the next value outside the range we want, then saying
    that we want to end at `names.length` ensures that we only get the values of 0,
    1, 2, and 3.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保结束值是大于`for`循环中最后一个索引的值。我们的数组有四个值，所以当我们询问它的长度时，我们得到的就是这个值。然而，当我们索引数组时，我们需要使用0、1、2和3的值。这是四个值，计数从0开始，而不是从1开始。由于我们知道在`for`循环中给出的第二个值是结束值，它是我们想要的范围外的下一个值，那么说我们想要在`names.length`结束确保我们只得到0、1、2和3的值。
- en: Inside the loop, you can see that we are using the `loop` variable to index
    into the array. The first time, we will get `Anna`, the next time, we will get
    `Bob`, and so on.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，你可以看到我们正在使用`loop`变量来索引数组。第一次，我们将得到`Anna`，下一次，我们将得到`Bob`，依此类推。
- en: 'An easier and safer way to do this is by using something known as a `for each`
    loop. What this will do is it will go through a sequence and give us one of its
    items, one at a time. Taking the same previous code and using such a loop will
    now be like the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一个更简单、更安全的方法是使用一种称为`for each`循环的东西。这样做将会遍历一个序列，并一次给我们一个它的项目。如果我们用同样的前一个代码并使用这样的循环，现在将会像以下这样：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, this is much nicer. We can read this as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这要好看得多。我们可以这样阅读：
- en: From the sequence names, give us the first item and store its value in the `name`
    variable.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从序列名称中，给出第一个项目并将它的值存储在`name`变量中。
- en: In the first iteration, `name` will contain `Anna`. The loop keeps track of
    where it is in the sequence. So, in the next iteration,  `name` will be given
    the value of `Bob`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一次迭代中，`name`将包含`Anna`。循环会跟踪它在序列中的位置。因此，在下一个迭代中，`name`将被赋予`Bob`的值。
- en: Additionally, note that we don't need to keep track of how many things there
    are in the sequence, and we don't need to use any indexing, since indexing starts
    at 0 and not 1.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，请注意，我们不需要跟踪序列中有多少个项目，我们也不需要使用任何索引，因为索引是从0开始的，而不是从1开始。
- en: This kind of loop gives us cleaner and more readable code that also reduces
    the risk of us inserting any errors into the code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环给我们提供了更干净、更易读的代码，同时也减少了我们在代码中插入错误的风险。
- en: 'We can use this loop to iterate over any sequence. As a string is a sequence
    of characters, using this loop on a string will give us each character that the
    string is made up of. Consider the following code example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个循环遍历任何序列。由于字符串是一系列字符的序列，所以在字符串上使用这个循环将给出字符串由哪些字符组成。考虑以下代码示例：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we ask the user for a name and store the answer in a variable called `name`.
    We will then iterate through the variable, one character at the time. The current
    character will be stored in a variable called `character`. Inside the loop, we
    will just print that character.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求用户输入一个名字，并将答案存储在一个名为`name`的变量中。然后我们将遍历这个变量，一次一个字符。当前字符将被存储在一个名为`character`的变量中。在循环内部，我们只需打印这个字符。
- en: 'Running this program will give us an output like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序将给出如下输出：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have looked at four different ways to make iterations and all of them have
    their different use cases. View them as a set of tools that we have at our disposal
    and can pick and use as needed. Add to that the tools for selection that we looked
    at earlier in this chapter and the toolset will keep improving!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了四种不同的迭代方式，它们都有各自不同的用途。把它们看作是我们可以随时挑选和使用的一套工具。再加上我们在本章前面看到的工具，工具集将不断改进！
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Sequence, selection, and iteration are the three pillars that programming rests
    upon, and, in this chapter, we have covered the latter two.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 序列、选择和迭代是编程建立在之上的三个支柱，在本章中，我们已经涵盖了后两个。
- en: Selection is when we test values in variables using a condition that can be
    either true or false. If our test turns out to be true, we can let the program
    execute a block of code. If it turns out to be false, we can have another block
    that only runs if in the case. This is done with the help of `if` statements.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 选择是在变量中使用条件测试值，这个条件可以是真或假。如果我们的测试结果是正确的，我们可以让程序执行一段代码。如果结果是错误的，我们可以有一个只在那种情况下运行的另一个代码块。这是通过`if`语句来完成的。
- en: Sometimes, we have multiple options to choose from, and we need to pick one.
    We could then use a `switch` statement. Using it instead of an `if` statement
    can make your code less verbose and easier to read.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们有多个选项可供选择，我们需要从中挑选一个。然后我们可以使用`switch`语句。使用它而不是`if`语句可以使你的代码更简洁、更容易阅读。
- en: The common task of repetition can be done in at least four ways, with the most
    common being the `for` loop. This loop will let us iterate a fixed number of times.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的常见任务至少可以用四种方式完成，其中最常见的是`for`循环。这个循环将允许我们迭代固定次数。
- en: When we don't know how many times we want to iterate, we can use either a `while`
    loop or a `do while` loop. They will both iterate as long as a condition is true.
    This will let us write very flexible applications that might repeat something
    twice.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不知道要迭代多少次时，我们可以使用`while`循环或`do while`循环。它们都会在条件为真时迭代。这将使我们能够编写非常灵活的应用程序，可能需要重复两次。
- en: The difference between the `while` loop and the `do while` loop is where the
    condition is located. In a `while` loop, it comes at the beginning, and, in a
    `do while`, it comes at the end.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环和 `do while` 循环之间的区别在于条件的放置位置。在 `while` 循环中，条件位于开始处，而在 `do while`
    循环中，条件位于末尾。'
- en: If we have a sequence of something, using a `for each` loop is the best choice,
    since it will go through the sequence and give us one of its objects at a time.
    It is a safe structure to use because it makes sure that we actually get all the
    values and don't miss out on the first or the last one.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一系列的某个东西，使用 `for each` 循环是最好的选择，因为它会遍历序列，并一次给我们其中一个对象。这是一个安全的结构，因为它确保我们实际上得到了所有的值，不会错过第一个或最后一个。
- en: In the next chapter, we will structure our code with the help of functions.
    They are a great way to make our code easier to read, understand, and maintain.
    They are also perfect for helping us to reuse the code that we have written.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将借助函数来结构化我们的代码。它们是使我们的代码更容易阅读、理解和维护的绝佳方式。它们也非常适合帮助我们重用我们所编写的代码。
