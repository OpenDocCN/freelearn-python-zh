- en: Chapter 3. Enhancing Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 增强图像
- en: In the previous chapter, we learned a lot about day-to-day image processing.
    We accomplished the learning objective of performing basic image manipulation
    by working on several examples and small projects. In this chapter, we will move
    a step further by learning how to add special effects to an image. The special
    effects added to the image serve several purposes. These not only give a pleasing
    appearance to the image but may also help you to understand important information
    presented by the image.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了关于日常图像处理的大量知识。通过处理几个示例和小型项目，我们完成了通过基本图像处理来执行学习目标。在本章中，我们将进一步学习如何给图像添加特殊效果。添加到图像中的特殊效果具有多种用途。这不仅使图像看起来令人愉悦，还可能帮助你理解图像呈现的重要信息。
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn how to adjust brightness and contrast levels of an image
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何调整图像的亮度和对比度级别
- en: Add code to selectively modify the color of an image and create gray scale images
    and negatives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加代码以选择性地修改图像的颜色，并创建灰度图像和负片
- en: Use PIL functionality to combine two images together and add transparency effects
    to the image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PIL 功能将两个图像合并在一起，并为图像添加透明效果
- en: Apply various image-enhancement filters to an image to achieve effects such
    as smoothing, sharpening, embossing, and so on
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将各种图像增强过滤器应用于图像，以实现平滑、锐化、浮雕等效果
- en: Undertake a project to develop a tool to add a watermark or text or a date stamp
    to an image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承接一个项目，开发一个工具，用于向图像添加水印、文本或日期戳
- en: So let's get on with it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧。
- en: Installation and download prerequisites
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和下载先决条件
- en: The installation prerequisites for this chapter are same as the ones in [Chapter
    2](ch02.html "Chapter 2. Working with Images"), *Working with Images*. Please
    refer to that chapter for further details.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的安装先决条件与 [第二章](ch02.html "第二章. 处理图像") 中的相同，即 *处理图像*。有关更多详细信息，请参阅该章节。
- en: It is important to download all the images required for this chapter from the
    Packt website at [http://www.packtpub.com/](http://www.packtpub.com/). We will
    be using these images throughout this chapter in the image processing code. Additionally,
    please download the PDF file, `Chapter 3 Supplementary Material.pdf` from Packt
    website. This is very important if you are reading a hard copy of this book which
    is printed in black and white. In the upcoming sections such as "Tweaking Colors",
    we compare the images before and after processing. In the black and white edition,
    you won't be able to see the difference between the compared images. For example,
    the effects such as changed image color, modified contrast, and so on, won't be
    noticeable. The PDF file contains all these image comparisons. So please keep
    this file handy while working on the examples in this chapter!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要从 Packt 网站下载本章所需的所有图像，网址为 [http://www.packtpub.com/](http://www.packtpub.com/)。我们将在这章的图像处理代码中使用这些图像。此外，请从
    Packt 网站下载 PDF 文件，`Chapter 3 Supplementary Material.pdf`。如果你阅读的是黑白印刷的纸质书，这一点非常重要。在即将到来的章节，如“调整颜色”中，我们将比较处理前后的图像。在黑白版中，你将无法看到比较图像之间的差异。例如，改变图像颜色、修改对比度等效果将不明显。PDF
    文件包含所有这些图像比较。因此，在处理本章的示例时，请务必保留此文件！
- en: Adjusting brightness and contrast
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整亮度和对比度
- en: One often needs to tweak the brightness and contrast level of an image. For
    example, you may have a photograph that was taken with a basic camera, when there
    was insufficient light. How would you correct that digitally? The brightness adjustment
    helps make the image brighter or darker whereas the contrast adjustments emphasize
    differences between the color and brightness level within the image data. The
    image can be made lighter or darker using the `ImageEnhance` module in PIL. The
    same module provides a class that can auto-contrast an image.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要调整图像的亮度和对比度级别。例如，你可能有一张用基本相机拍摄的照片，当时光线不足。你将如何通过数字方式纠正它？亮度调整有助于使图像变亮或变暗，而对比度调整则强调图像数据中颜色和亮度级别之间的差异。可以使用
    PIL 中的 `ImageEnhance` 模块使图像变亮或变暗。该模块还提供了一个可以自动对比图像的类。
- en: Time for action - adjusting brightness and contrast
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 - 调整亮度和对比度
- en: Let's learn how to modify the image brightness and contrast. First, we will
    write code to adjust brightness. The `ImageEnhance` module makes our job easier
    by providing `Brightness` class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何修改图像的亮度和对比度。首先，我们将编写代码来调整亮度。`ImageEnhance` 模块通过提供 `Brightness` 类使我们的工作变得简单。
- en: Download image `0165_3_12_Before_BRIGHTENING.png` and rename it to `Before_BRIGHTENING.png`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载图像`0165_3_12_Before_BRIGHTENING.png`并将其重命名为`Before_BRIGHTENING.png`。
- en: 'Use the following code:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On line 6 in the code snippet, we created an instance of the class `Brightness`.
    It takes `Image` instance as an argument.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码片段的第6行，我们创建了一个`Brightness`类的实例。它以`Image`实例作为参数。
- en: Line 7 creates a new image `bright` by using the specified `brightness` value.
    A value between `0.0` and less than `1.0` gives a darker image, whereas a value
    greater than `1.0` makes it brighter. A value of `1.0` keeps the brightness of
    the image unchanged.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第7行通过使用指定的`brightness`值创建了一个新的图像`bright`。介于`0.0`和小于`1.0`之间的值会使图像变暗，而大于`1.0`的值会使它变亮。值为`1.0`保持图像的亮度不变。
- en: The original and resultant image are shown in the next illustration.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个插图显示了原始图像和结果图像。
- en: Comparison of images before and after brightening.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 亮化前后的图像比较。
- en: '![Time for action - adjusting brightness and contrast](img/0165_3_1.jpg)![Time
    for action - adjusting brightness and contrast](img/0165_3_2.jpg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作时间 - 调整亮度和对比度](img/0165_3_1.jpg)![操作时间 - 调整亮度和对比度](img/0165_3_2.jpg)'
- en: Let's move on and adjust the contrast of the brightened image. We will append
    the following lines of code to the code snippet that brightened the image.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续调整亮化图像的对比度。我们将向亮化图像的代码片段中添加以下行。
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Thus, similar to what we did to brighten the image, the image contrast was tweaked
    by using the `ImageEnhance.Contrast` class. A contrast value of `0.0` creates
    a black image. A value of `1.0` keeps the current contrast.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，与调整图像亮度类似，我们通过使用`ImageEnhance.Contrast`类调整了图像的对比度。对比度值为`0.0`创建一个黑色图像。值为`1.0`保持当前对比度。
- en: The resultant image is compared with the original in the following illustration.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的插图显示了结果图像与原始图像的比较。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'NOTE: As mentioned in the *Installation and Download Prerequisites* section,
    the images compared in the following illustration will appear identical if you
    are reading a hard copy of this book. Please download and refer to the supplementary
    PDF file `Chapter 3 Supplementary Material.pdf`. Here, the color images are provided,
    which will help you see the difference.'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：如*安装和下载必备条件*部分所述，如果你阅读的是这本书的纸质版，那么在下图中比较的图像将看起来完全相同。请下载并参考补充PDF文件`Chapter
    3 Supplementary Material.pdf`。在这里，提供了彩色图像，这将帮助你看到差异。
- en: The original image with the image displaying the increasing contrast.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示增加对比度的原始图像和图像。
- en: '![Time for action - adjusting brightness and contrast](img/0165_3_3.jpg)![Time
    for action - adjusting brightness and contrast](img/0165_3_4.jpg)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作时间 - 调整亮度和对比度](img/0165_3_3.jpg)![操作时间 - 调整亮度和对比度](img/0165_3_4.jpg)'
- en: In the preceding code snippet, we were required to specify a contrast value.
    If you prefer PIL for deciding an appropriate contrast level, there is a way to
    do this. The `ImageOps.autocontrast` functionality sets an appropriate contrast
    level. This function normalizes the image contrast. Let's use this functionality
    now.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们需要指定一个对比度值。如果你更喜欢使用PIL来决定合适的对比度级别，有一种方法可以做到这一点。`ImageOps.autocontrast`功能设置一个合适的对比度级别。此功能使图像对比度归一化。现在让我们使用这个功能。
- en: 'Use the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The highlighted line in the code is where contrast is automatically set. The
    `autocontrast` function computes histogram of the input image. The `cutoff` argument
    represents the percentage of lightest and darkest pixels to be trimmed from this
    histogram. The image is then remapped.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码中高亮显示的行是自动设置对比度的位置。`autocontrast`函数计算输入图像的直方图。`cutoff`参数表示从该直方图中修剪最亮和最暗像素的百分比。然后图像被重新映射。
- en: What just happened?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Using the classes and functionality in `ImageEnhance` module, we learned how
    to increase or decrease the brightness and the contrast of the image. We also
    wrote code to auto-contrast an image using functionality provided in the `ImageOps`
    module. The things we learned here will be useful in the upcoming sections in
    this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ImageEnhance`模块中的类和功能，我们学习了如何增加或减少图像的亮度和对比度。我们还编写了代码，使用`ImageOps`模块提供的功能来自动对比度图像。在这里学到的知识将在本章后续部分中很有用。
- en: Tweaking colors
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整颜色
- en: Another useful operation performed on the image is adjusting the colors within
    an image. The image may contain one or more bands, containing image data. The
    `image` mode contains information about the depth and type of the image pixel
    data. The most common modes we will use in this chapter are `RGB` (true color,
    3x8 bit pixel data), `RGBA` (true color with transparency mask, 4x8 bit) and `L`
    (black and white, 8 bit).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像上执行的其他有用操作之一是调整图像内的颜色。图像可能包含一个或多个波段，包含图像数据。`image`模式包含有关图像像素数据深度和类型的信息。在本章中我们将使用最常用的模式是`RGB`（真彩色，3x8位像素数据）、`RGBA`（带透明度蒙版的真彩色，4x8位）和`L`（黑白，8位）。
- en: In PIL, you can easily get the information about the bands data within an image.
    To get the name and number of bands, the `getbands()` method of the class `Image`
    can be used. Here, `img` is an instance of class `Image`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在PIL中，你可以轻松地获取图像内波段数据的信息。要获取波段名称和数量，可以使用`Image`类的`getbands()`方法。在这里，`img`是`Image`类的一个实例。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Time for action - swap colors within an image!
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 在图像内交换颜色！
- en: To understand some basic concepts, let's write code that just swaps the image
    band data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解一些基本概念，让我们编写代码来仅交换图像波段数据。
- en: Download the image `0165_3_15_COLOR_TWEAK.png` and rename it as `COLOR_TWEAK.png`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载图像`0165_3_15_COLOR_TWEAK.png`并将其重命名为`COLOR_TWEAK.png`。
- en: 'Type the following code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's analyze this code now. On line 2, the `Image` instance is created as usual.
    Then, we change the `mode` of the image to `RGBA`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们分析一下这段代码。在第2行，创建了一个`Image`实例，然后我们将图像的`mode`更改为`RGBA`。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Here we should check if the image already has that mode or if this conversion
    is possible. You can add that check as an exercise!
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们应该检查图像是否已经具有该模式，或者这种转换是否可行。你可以将这个检查作为练习来添加！
- en: Next, the call to `Image.split()` creates separate instances of `Image` class,
    each containing a single band data. Thus, we have four `Image` instances `r, g,
    b`, and `alpha` corresponding to red, green, and blue bands, and the alpha channel
    respectively.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，对`Image.split()`的调用创建了`Image`类的单独实例，每个实例包含单个波段数据。因此，我们有四个`Image`实例`r, g,
    b`和`alpha`，分别对应红色、绿色、蓝色波段和alpha通道。
- en: The code in line 6 does the main image processing. The first argument that `Image.merge`
    takes `mode` as the first argument whereas the second argument is a tuple of image
    instances containing band information. It is required to have same size for all
    the bands. As you can notice, we have swapped the order of band data in `Image`
    instances `r` and `g` while specifying the second argument.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第6行的代码执行主要的图像处理。`Image.merge`函数的第一个参数是`mode`，第二个参数是一个包含波段信息的图像实例的元组。所有波段必须具有相同的大小。正如你所注意到的，我们在指定第二个参数时，在`Image`实例`r`和`g`中交换了波段数据的顺序。
- en: The original and resultant image thus obtained are compared in the next illustration.
    The color of the flower now has a shade of green and the grass behind the flower
    is rendered with a shade of red.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一幅插图中所获得的原始图像和结果图像进行了比较。现在花的颜色呈现绿色调，而花后面的草以红色调呈现。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As mentioned in the *Installation and Download Prerequisites* section, the images
    compared in the following illustration will appear identical if you are reading
    a hard copy of this book. Please download and refer to the supplementary PDF file
    `Chapter 3 Supplementary Material.pdf`. Here, the color images are provided that
    will help you see the difference.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如同在*安装和下载必备条件*部分所述，如果你阅读的是这本书的纸质版，那么在下一幅插图中所比较的图像将看起来完全相同。请下载并参考补充PDF文件`Chapter
    3 Supplementary Material.pdf`。在这里，提供了彩色图像，这将帮助你看到差异。
- en: Original (left) and the color swapped image (right).
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原图（左）和颜色交换图像（右）。
- en: '![Time for action - swap colors within an image!](img/0165_3_6.jpg)![Time for
    action - swap colors within an image!](img/0165_3_5.jpg)'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动手时间 - 在图像内交换颜色！](img/0165_3_6.jpg)![动手时间 - 在图像内交换颜色！](img/0165_3_5.jpg)'
- en: What just happened?
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We accomplished creating an image with its band data swapped. We learned how
    to use PIL's `Image.split()` and `Image.merge()` to achieve this. However, this
    operation was performed on the whole image. In the next section, we will learn
    how to apply color changes to a specific color region.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功创建了一个波段数据交换的图像。我们学习了如何使用PIL的`Image.split()`和`Image.merge()`来实现这一点。然而，这个操作是在整个图像上执行的。在下一节中，我们将学习如何将颜色变化应用于特定的颜色区域。
- en: Changing individual image band
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改单个图像波段
- en: In the previous section, we saw how to change the data represented by the whole
    band. As a result of this band swapping, the color of the flower was changed to
    a shade of green and the grass color was rendered as a shade of red. What if we
    just want to change the color of the flower and keep the color of the grass unchanged?
    To do this, we will make use of `Image.point` functionality along with `Image.paste`
    operation discussed in depth in the previous chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何改变整个波段表示的数据。由于这种波段交换，花朵的颜色变成了绿色调，草地颜色被渲染成红色调。如果我们只想改变花朵的颜色，而保持草地颜色不变呢？为了做到这一点，我们将利用
    `Image.point` 功能以及上一章中深入讨论的 `Image.paste` 操作。
- en: However, note that we need to be careful in specifying the color region that
    needs to be changed. It may also depend on the image. Sometimes, it will select
    some other regions matching the specified color range, which we don't want.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们需要小心指定需要更改的颜色区域。它也可能取决于图像。有时，它将选择一些其他与指定颜色范围匹配的区域，而我们不希望这样。
- en: Time for action - change the color of a flower
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 改变花朵的颜色
- en: We will make use of the same flower image used in the previous section. As mentioned
    earlier, our task is to change the color of the flower while keeping the grass
    color unchanged.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一节中使用的相同花朵图像。如前所述，我们的任务是改变花朵的颜色，同时保持草地颜色不变。
- en: Add this code in a Python source file.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Python 源文件中添加此代码。
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lines 1 to 5 remain the same as seen earlier. On line 5, we split the original
    image, creating four `Image` instances, each holding a single band data.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1 到 5 行与之前看到的一样。在第 5 行，我们将原始图像分割，创建了四个 `Image` 实例，每个实例包含一个波段数据。
- en: A new `Image` instance 'selection' is created on line 6\. This is an important
    operation that holds the key to selectively modify color! So let's see what this
    line of code does. If you observe the original image, the flower region (well,
    most of it) is rendered with a shade of red color. So, we have called the `point(function)`
    method on `Image` instance `r`. The `point` method takes a single function and
    an argument maps the image through this function. It returns a new `Image` instance.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第 6 行创建了一个新的 `Image` 实例 'selection'。这是一个重要的操作，是选择性修改颜色的关键！让我们看看这一行代码做了什么。如果你观察原始图像，花朵区域（嗯，大部分）被渲染成红色调。因此，我们在
    `Image` 实例 `r` 上调用了 `point(function)` 方法。`point` 方法接受一个函数和一个参数，通过这个函数映射图像。它返回一个新的
    `Image` 实例。
- en: 'What does this lambda function on line 6 do? Internally, PIL''s `point` function
    does something of this sort:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第 6 行上的这个 lambda 函数做了什么？内部，PIL 的 `point` 函数做的是这样的事情：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, function is nothing but the lambda function. The no_of_bands
    for the image is 1\. Thus, line 6 is used to select a region where the red value
    is greater than 120\. The lst is a list which, in this case has the first 120
    values as False whereas the remaining values as 150\. The value of 150 plays a
    role in determining the final color when we perform the paste operation.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，函数实际上是一个 lambda 函数。图像的 `no_of_bands` 为 1。因此，第 6 行用于选择红色值大于 120 的区域。lst
    是一个列表，在这种情况下，前 120 个值是 False，其余值是 150。150 的值在我们执行粘贴操作时确定最终颜色起着作用。
- en: The image mask thus created after the application of `point` operation is shown
    in the following illustration. The white region in this image represents the region
    captured by the `point` operation that we just performed. Only the white region
    will undergo change when we perform `paste` operation next.![Time for action -
    change the color of a flower](img/0165_3_7.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用 `point` 操作后创建的图像掩码如图所示。此图像中的白色区域代表我们刚刚通过 `point` 操作捕获的区域。在执行下一个 `paste`
    操作时，只有白色区域将发生变化。![行动时间 - 改变花朵的颜色](img/0165_3_7.jpg)
- en: On line 8, we perform a `paste` operation discussed in the last chapter. Here,
    the image `g` is pasted onto image `r` using mask `selection`. As a result, the
    band data of image `r` is modified.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第 8 行，我们执行了上一章中讨论的 `paste` 操作。在这里，使用掩码 `selection` 将图像 `g` 粘贴到图像 `r` 上。结果，图像
    `r` 的波段数据被修改。
- en: Finally, a new `Image` instance is created using the `merge` operation, by making
    use of the individual `r, g, b`, and `alpha` image instances containing the new
    band information.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过使用包含新波段信息的单个 `r, g, b` 和 `alpha` 图像实例，使用 `merge` 操作创建了一个新的 `Image` 实例。
- en: The original and final processed images are compared in the next illustration.
    The new flower color looks as cool as the original color, doesn't it?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一幅插图中的原始图像和最终处理后的图像进行了比较。新的花朵颜色看起来和原始颜色一样酷，不是吗？
- en: Tip
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As mentioned in the *Installation and download prerequisites* section, the images
    compared in the following illustration will appear identical if you are reading
    a hard copy of this book. Please download and refer to the supplementary PDF file
    `Chapter 3 Supplementary Material.pdf`. The color images are provided that will
    help you see the difference.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如同在 *安装和下载必备条件* 部分所述，如果你在阅读这本书的纸质版，以下插图中的图像将看起来完全相同。请下载并参考补充的 PDF 文件 `Chapter
    3 Supplementary Material.pdf`。其中提供了彩色图像，这将帮助你看到差异。
- en: '![Time for action - change the color of a flower](img/0165_3_8.jpg)![Time for
    action - change the color of a flower](img/0165_3_9.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 改变花朵的颜色](img/0165_3_8.jpg)![行动时间 - 改变花朵的颜色](img/0165_3_9.jpg)'
- en: What just happened?
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We worked out an example that modified a selective color region. Individual
    image band data was processed to accomplish this task. With the help of `point,
    paste`, and `merge` operations in PIL's `Image` module, we accomplished changing
    the color of the flower in the provided image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了一个示例，修改了选择性的颜色区域。通过处理单个图像波段数据来完成这项任务。借助 PIL 的 `Image` 模块中的 `point`、`paste`
    和 `merge` 操作，我们成功改变了提供的图像中花朵的颜色。
- en: Gray scale images
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灰度图像
- en: 'If you want to give a nostalgic effect to an image, one of the many things
    that you can do is to convert it to gray scale. There is more than one way to
    create a gray scale image in PIL. When the mode is specified as `L`, the resultant
    image is gray scale. The basic syntax to convert color images to black and white
    is:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想给图像添加怀旧效果，你可以做的许多事情之一就是将其转换为灰度。在 PIL 中创建灰度图像有多种方法。当模式指定为 `L` 时，生成的图像是灰度的。将彩色图像转换为黑白的基本语法是：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alternatively, we can use functionality provided in the `ImageOps` module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `ImageOps` 模块提供的功能。
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you are creating the image from scratch, the syntax is:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从头开始创建图像，语法是：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following illustration shows the original and the converted gray scale images
    created using one of these techniques.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图显示了使用这些技术之一创建的原始图像和转换后的灰度图像。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please download and refer to the supplementary PDF file `Chapter 3 Supplementary
    Material.pdf`. The color images are provided that will help you see the difference
    between the following images.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请下载并参考补充的 PDF 文件 `Chapter 3 Supplementary Material.pdf`。其中提供了彩色图像，这将帮助你看到以下图像之间的差异。
- en: 'Original and gray scale images of a bridge:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 桥梁的原始图像和灰度图像：
- en: '![Gray scale images](img/0165_3_11.jpg)![Gray scale images](img/0165_3_10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![灰度图像](img/0165_3_11.jpg)![灰度图像](img/0165_3_10.jpg)'
- en: Cook up negatives
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作负片
- en: Creating a negative of an image is straightforward. We just need to invert each
    color pixel. Therefore, if you have a color `x` at a pixel, the negative image
    will have (255 `x)` at that pixel. The `ImageOps` module makes it very simple.
    The following line of code creates a negative of an image.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图像的负片非常简单。我们只需要反转每个颜色像素。因此，如果你在像素处有一个颜色 `x`，那么负片在该像素处将会有 (255 `x`)。`ImageOps`
    模块使得这个过程非常简单。以下代码行创建了一个图像的负片。
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the result of this operation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此操作的结果：
- en: Original image (left) and its negative (right).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像（左）及其负片（右）。
- en: '![Cook up negatives](img/0165_3_12.jpg)![Cook up negatives](img/0165_3_13.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![制作负片](img/0165_3_12.jpg)![制作负片](img/0165_3_13.jpg)'
- en: Blending
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合
- en: Have you ever wished to see yourself in a family photo, taken at a time when
    you were not around? Or what if you just want to see yourself at the top of Mount
    Everest at least in a picture? Well, it is possible to do this digitally, using
    the functionality provided in PIL such as blending, composite image processing,
    and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾希望看到自己在家庭照片中的样子，而那时你并不在场？或者，如果你只是想看到自己在珠穆朗玛峰顶上的样子，至少在照片中是这样？嗯，使用 PIL 提供的功能，如混合、合成图像处理等，这是可能的。
- en: In this section, we will learn how to blend images together. As the name suggests,
    blending means mixing two compatible images to create a new image. The `blend`
    functionality in PIL creates a new image using two input images of the same `size`
    and `mode`. Internally, the two input images are interpolated using a constant
    value of alpha.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何混合图像。正如其名所示，混合意味着将两个兼容的图像混合以创建一个新的图像。PIL中的`blend`功能使用两个具有相同`size`和`mode`的输入图像创建一个新的图像。内部，两个输入图像使用恒定的`alpha`值进行插值。
- en: 'In the PIL documentation, it is formulated as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在PIL文档中，它被表述为：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Looking at this formula, it is clear that `alpha = 1.0` will make the blended
    image the same as 'n_image2 whereas `alpha = 0.0` returns `in_image1` as the blended
    image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个公式，很明显`alpha = 1.0`将使混合图像与'n_image2'相同，而`alpha = 0.0`则返回`in_image1`作为混合图像。
- en: Time for action - blending two images
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 混合两个图像
- en: Sometimes, the combined effect of two images mixed together makes a big impact
    compared to viewing the same images differently. Now it's time to give way to
    your imagination by blending two pictures together. In this example, our resultant
    image shows birds flying over the Mackinac bridge in Michigan. However, where
    did they come from? The birds were not there in the original image of the bridge.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将两个图像混合在一起的综合效果与以不同的方式查看相同的图像相比，会产生很大的影响。现在，是时候通过混合两张图片来发挥你的想象力了。在这个例子中，我们的结果图像显示了密歇根州的大
    Mackinac 桥上飞翔的鸟类。然而，它们是从哪里来的？鸟类在桥梁的原始图像中并不存在。
- en: 'Download the following files from Packt website: `0165_3_28_BRIDGE2.png` and
    `0165_3_29_BIRDS2.png`. Rename these files as `BRIDGE2.png` and `BIRDS2.png` respectively.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Packt网站下载以下文件：`0165_3_28_BRIDGE2.png`和`0165_3_29_BIRDS2.png`。分别将这些文件重命名为`BRIDGE2.png`和`BIRDS2.png`。
- en: Add the following code in a Python source file.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python源文件中添加以下代码。
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next illustration shows the two images before blending, represented by `img1`
    and `img2` in the code.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个插图显示了混合前的两个图像，在代码中用`img1`和`img2`表示。
- en: Individual images of a bridge and flying birds, before blending.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 混合前的桥梁和飞翔的鸟类的单独图像。
- en: '![Time for action - blending two images](img/0165_3_14.jpg)![Time for action
    - blending two images](img/0165_3_15.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 混合两个图像](img/0165_3_14.jpg)![行动时间 - 混合两个图像](img/0165_3_15.jpg)'
- en: The lines 3 to 7 open the two input images to be blended. Notice that we have
    converted both the images `RGBA`. It need not be necessarily `RGBA` mode. We can
    specify the modes such as 'RGB' or 'L'. However, it is required to have both the
    images with same `size` and `mode`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第3到7行打开了要混合的两个输入图像。注意，我们已经将两个图像都转换为`RGBA`模式。这不必一定是`RGBA`模式。我们可以指定模式，如'RGB'或'L'。然而，要求两个图像具有相同的`size`和`mode`。
- en: The images are blended on line 9 using the `Image.blend` method in PIL. The
    first two arguments in the `blend` method are two `Image` objects representing
    the two images to be blended. The third argument defines the transparency factor
    `alpha`. In this example, the image of the bridge is the main image we want to
    focus on. Thus, the factor `alpha` is defined such that more transparency is applied
    to the image of the flying birds while creating the final image. The `alpha` factor
    can have a value between `0.0` to `1.0`. Note that, while rendering the output
    image, the second image, `img2`, is multiplied by this `alpha` value whereas the
    first image is multiplied by `1 - alpha`. This can be represented by the following
    equation.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像在第9行使用PIL中的`Image.blend`方法进行混合。`blend`方法的前两个参数是两个表示要混合的图像的`Image`对象。第三个参数定义了透明度因子`alpha`。在这个例子中，桥梁的图像是我们想要关注的主体图像。因此，`alpha`因子被定义为在创建最终图像时对飞翔的鸟类的图像应用更多的透明度。`alpha`因子可以有一个介于`0.0`到`1.0`之间的值。请注意，在渲染输出图像时，第二个图像`img2`被乘以这个`alpha`值，而第一个图像被乘以`1
    - alpha`。这可以用以下方程表示。
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Thus, if we select an alpha factor of, for instance, 0.8, it means that the
    birds will appear more opaque compared to the bridge. Try changing the alpha factor
    to see how it changes the resultant image. The resultant image with alpha = 0.3
    is:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，如果我们选择一个例如0.8的`alpha`因子，这意味着鸟类将比桥梁更不透明。尝试更改`alpha`因子以查看它如何改变结果图像。`alpha =
    0.3`的结果图像如下：
- en: Blended image showing birds flying over a bridge.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 混合图像显示鸟类在桥梁上飞翔。
- en: '![Time for action - blending two images](img/0165_3_16.jpg)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 混合两个图像](img/0165_3_16.jpg)'
- en: The picture appears a bit dull due to the transparency effect applied while
    creating the image. If you convert the input images to `mode L`, the resultant
    image will look better however, it will be rendered as gray scale. This is shown
    in the next illustration.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在创建图像时应用了透明效果，图片看起来有点单调。如果你将输入图像转换为`mode L`，结果图像将看起来更好，但它将以灰度形式呈现。这将在下一幅插图中展示。
- en: Blended gray scale image when both the input images have mode L.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当两个输入图像都具有模式L时，混合的灰度图像。
- en: '![Time for action - blending two images](img/0165_3_17.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动手时间 - 混合两个图像](img/0165_3_17.jpg)'
- en: What just happened?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: Blending is an important image enhancement feature. With the help of examples,
    we accomplished creating blended images. We learned using the `Image.blend` method
    and applied the transparency factor `alpha` to achieve this task. The technique
    learned in this chapter will be very useful throughout this chapter. In the next
    section, we will apply the blending technique to create a transparent image.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 混合是重要的图像增强功能。通过示例，我们完成了创建混合图像的任务。我们学习了使用`Image.blend`方法，并应用透明度因子`alpha`来完成这项任务。本章学到的技术在本章中将会非常有用。在下一节中，我们将应用混合技术来创建透明图像。
- en: Creating transparent images
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建透明图像
- en: In the previous section, we learned how to blend two images together. In this
    section, we will go one step further and see how the same `blend` functionality
    can be used to create a transparent image! The images with mode RGBA define an
    `alpha` band. The transparency of the image can be changed by tweaking this band
    data. `Image.putalpha()` method allows defining new data for the `alpha` band
    of an image. We will see how to perform point operation to achieve the same effect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何将两个图像混合在一起。在本节中，我们将更进一步，看看相同的`blend`功能如何用于创建透明图像！具有模式RGBA的图像定义了一个`alpha`通道。可以通过调整此通道数据来改变图像的透明度。`Image.putalpha()`方法允许为图像的`alpha`通道定义新数据。我们将看到如何执行点操作以实现相同的效果。
- en: Time for action - create transparency
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候动手创建透明效果了
- en: Let's write a few lines of code that add the transparency effects to an input
    image.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写几行代码，为输入图像添加透明效果。
- en: We will use one of the images used in [Chapter 2](ch02.html "Chapter 2. Working
    with Images"). Download `0165_3_25_SMILEY.png` and rename it to `SMILEY.png`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用[第2章](ch02.html "第2章。处理图像")中使用的其中一个图像。下载`0165_3_25_SMILEY.png`并将其重命名为`SMILEY.png`。
- en: 'Use the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the `addTransparency()` function takes the `img` instance as
    input and returns a new image instance with the desired level of transparency.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，`addTransparency()`函数接受`img`实例作为输入，并返回一个具有所需透明度级别的新图像实例。
- en: Now let's see how this function works. On line 4, we first convert the image
    mode to `RGBA`. As discussed in an earlier section, you can add a conditional
    here to see if the image is already in the `RGBA` mode.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来看看这个函数是如何工作的。在第4行，我们首先将图像模式转换为`RGBA`。如前所述，你可以在这里添加一个条件来检查图像是否已经处于`RGBA`模式。
- en: Next, we create a new `Image` class instance, `image_blender`, using the `Image.new`
    method. It has the same size and mode as the input image. The third argument represents
    the color. Here, we specify the transparency as `0`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Image.new`方法创建一个新的`Image`类实例，名为`image_blender`。它具有与输入图像相同的尺寸和模式。第三个参数代表颜色。在这里，我们指定透明度为`0`。
- en: On line 6, two images, `img` (input image) and `img_blender`, are blended together
    by applying a constant `alpha` value. The function then returns this modified
    `Image` instance.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第6行，两个图像`img`（输入图像）和`img_blender`通过应用一个常量`alpha`值混合在一起。然后函数返回这个修改后的`Image`实例。
- en: The original image and the one with the transparency effect are compared. The
    images are the screenshots of the images opened in the GIMP editor. This is done
    so that you clearly understand the effect of transparency. The checkered pattern
    in these images represents the canvas. Notice how the canvas appears in the transparent
    image.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较了原始图像和具有透明效果图像。这些图像是GIMP编辑器中打开的图像的截图。这样做是为了让你清楚地了解透明效果。这些图像中的棋盘图案代表画布。注意画布如何在透明图像中显示。
- en: There is another simple way to add transparency to an image, using the `Image.point`
    functionality! Enter the following code in a Python source file and execute it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加透明度到图像的另一种简单方法，使用`Image.point`功能！在Python源文件中输入以下代码并执行它。
- en: '[PRE15]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this new code, we split the original image into four new image instance,
    each having one of the image band data (r, `g, b`, or `alpha)`. Note that we are
    assuming here that the mode of the image is `RGBA`. If it is not, you need to
    convert this image to RGBA! As an exercise, you can add that check in the code.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这段新代码中，我们将原始图像分割成四个新的图像实例，每个实例包含一个图像通道数据（r, `g, b`, 或 `alpha`)。请注意，我们这里假设图像的模式是`RGBA`。如果不是，你需要将此图像转换为RGBA！作为一个练习，你可以在代码中添加这个检查。
- en: Next, on line 4, the `Image.point` method is called. The `lambda` function operates
    on the `alpha` band data. It sets the value as `178`. This is roughly equal to
    the `alpha` factor of 0.7 that we set earlier. It is computed here as `int(255*0.7)
    )`. In the *Changing individual image band* section, where we learned modifying
    colors within images, the point operation was thoroughly discussed.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在第4行，调用了`Image.point`方法。`lambda`函数作用于`alpha`通道数据。它将值设置为`178`。这大约等于我们之前设置的`alpha`因子0.7。这里计算为`int(255*0.7)
    )`。在*修改单个图像通道*部分，我们详细讨论了点操作。
- en: On line 5, we put back the new `alpha` band data in `img`. The resultant images
    using `blend` and `point` functionality are shown in the next illustration.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第5行，我们将新的`alpha`通道数据放回`img`中。使用`blend`和`point`功能的结果图像将在下一幅插图显示。
- en: Image before and after adding transparency.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加透明度前后的图像。
- en: '![Time for action - create transparency](img/0165_3_18.jpg)![Time for action
    - create transparency](img/0165_3_19.jpg)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 创建透明度](img/0165_3_18.jpg)![行动时间 - 创建透明度](img/0165_3_19.jpg)'
- en: What just happened?
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We accomplished adding transparency effect to an image. This is a very useful
    image enhancement that we need from time to time. We learned how to create a transparent
    image using two different techniques, namely, using `Image.blend` functionality
    and `Image.point` operation. The knowledge gained in this section will be applied
    later in this chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了向图像添加透明度效果。这是一种非常有用的图像增强，我们不时需要它。我们学习了如何使用两种不同的技术创建透明图像，即使用`Image.blend`功能和使用`Image.point`操作。在本节中获得的知识将在本章的后面应用。
- en: Making composites with image mask
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图像蒙版制作复合材料
- en: 'So far, we have already seen how to blend two images together. It was done
    using the `Image.blend` operation where the two input images were blended by using
    a constant `alpha` transparency factor. In this section, we will learn another
    technique to combine two images together. Here, instead of a constant `alpha`
    factor, an image instance that defines the transparency mask is used as the third
    argument. Another difference is that the input images need not have the same `mode`.
    For instance, the first image can be with mode `L` and the second with mode `RGBA`.
    The syntax to create composite images is:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何将两张图像混合在一起。这是通过使用`Image.blend`操作完成的，其中两个输入图像通过使用一个常数`alpha`透明度因子进行混合。在本节中，我们将学习另一种将两张图像组合在一起的技术。在这里，我们使用一个定义透明度蒙版的图像实例作为第三个参数，而不是一个常数`alpha`因子。另一个区别是输入图像不需要有相同的`mode`。例如，第一张图像可以是`L`模式，第二张是`RGBA`模式。创建合成图像的语法是：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the arguments to the composite method are `Image` instances. The mask
    is specified as `alpha`. The mode for mask image instance can be `1, L`, or `RGBA`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，复合方法的参数是`Image`实例。蒙版指定为`alpha`。蒙版图像实例的模式可以是`1, L`或`RGBA`。
- en: Time for action - making composites with image mask
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用图像蒙版制作复合材料
- en: We will mix the same two images blended in another section. Just to try out
    something different, in the composite image, we will focus on the flying birds
    instead of the bridge.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将混合在另一个部分中混合的相同两张图像。为了尝试一些不同的事情，在合成图像中，我们将聚焦于飞翔的鸟儿而不是桥梁。
- en: We will use the same set of input images as used in the *Blending* section.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用与*混合*部分相同的输入图像集。
- en: '[PRE17]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code until line 7 is identical to the one illustrated in the blending example.
    Note that the two input images need not have the same `mode`. On line 10, the
    `Image.point` method is called. The `lambda` function operates on the `alpha`
    band data. The code on lines 9 and 10 is similar to that illustrated in the section
    *Creating Transparent Images*. Please refer to that section for further details.
    The only difference is that the pixel value is set as `204`. This modifies the
    band data in the image instance `alpha`. This value of `204` is roughly equivalent
    to the `alpha` factor of `0.7` if the image were to be blended. What this implies
    is the bridge will have a fading effect and the flying birds will appear prominently
    in the composite image.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码直到第7行与混合示例中展示的代码相同。请注意，两个输入图像不需要具有相同的`mode`。在第10行，调用了`Image.point`方法。`lambda`函数作用于`alpha`通道数据。第9行和第10行的代码与*创建透明图像*部分中展示的类似。请参考该部分以获取更多详细信息。唯一的区别是像素值被设置为`204`。这修改了图像实例`alpha`中的通道数据。如果图像要混合，这个`204`的值大约相当于`alpha`因子`0.7`。这意味着桥梁将会有渐变效果，飞翔的鸟儿将在合成图像中突出显示。
- en: One thing you will notice here is we are not putting the modified `alpha` band
    data back in `img2`. Instead, on line 12, the composite image is created using
    the mask as `alpha`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到，我们并没有将修改后的`alpha`通道数据放回`img2`中。而是在第12行，使用蒙版作为`alpha`创建了合成图像。
- en: The resultant composite image is shown in the next illustration with emphasis
    on the image of the flying birds.![Time for action - making composites with image
    mask](img/0165_3_20.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个插图显示了带有飞翔鸟类图像强调的合成图像。![行动时间 - 使用图像蒙版制作合成图像](img/0165_3_20.jpg)
- en: What just happened?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We learned how to create an image combining two images, using an `alpha` mask.
    This was accomplished by using `Image.composite` functionality.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用`alpha`蒙版创建两个图像的组合图像。这是通过使用`Image.composite`功能实现的。
- en: 'Project: Watermark Maker Tool'
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目：水印制作工具
- en: 'We have now learned enough image enhancement techniques to take up a simple
    project applying these techniques. Let''s create a simple command line utility,
    a "Watermark Maker Tool". Although we call it a "Watermark Maker ", it actually
    provides some more useful features. Using this utility, you can add the date stamp
    to the image (the date on which the image was enhanced using this tool). It also
    enables embedding custom text within an image. The tool can be run on the command
    line using the following syntax:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学到了足够多的图像增强技术，可以开始一个简单的项目来应用这些技术。让我们创建一个简单的命令行工具，一个“水印制作工具”。虽然我们称之为“水印制作工具”，但实际上它提供了一些更有用的功能。使用此工具，您可以将日期戳添加到图像中（使用此工具增强图像的日期）。它还允许在图像中嵌入自定义文本。该工具可以使用以下语法在命令行上运行：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Where, the `[options]` are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`[options]`如下：
- en: '`--image1:` The file path of the main image that provides canvas.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--image1:` 提供画布的主要图像的文件路径。'
- en: '`--waterMark:` The file path of the watermark image (if any).'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--waterMark:` 水印图像的文件路径（如果有）。'
- en: '`--mark_pos:` The coordinates of top-left corner of the watermark image to
    be embedded. The values should be specified in double quotes, like **100, 50**.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--mark_pos:` 要嵌入的水印图像的左上角坐标。值应使用双引号指定，例如**100, 50**。'
- en: '`--text:` The text that should appear in the output image.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--text:` 应出现在输出图像中的文本。'
- en: '`--text_pos:` The coordinates of top-left corner of the TEXT to be embedded.
    The values should be specified in double quotes, like **100, 50**.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--text_pos:` 要嵌入的文本的左上角坐标。值应使用双引号指定，例如**100, 50**。'
- en: '`--transparency:` The transparency factor for the watermark (if any)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--transparency:` 水印的透明度因子（如果有）'
- en: '`--dateStamp:` Flag (True or `False)` that determines whether to insert date
    stamp in the image. If `True`, the date stamp at the time this image was processed
    will be inserted.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dateStamp:` 标志（True或`False`），用于确定是否在图像中插入日期戳。如果为`True`，则将插入处理此图像时的日期戳。'
- en: The following is an example that shows how to run this tool with all the options
    specified.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了如何使用所有指定选项运行此工具。
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This creates an output image file `WATERMARK.png`, with a watermark and text
    at the specified anchor point within the image.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有水印和文本的输出图像文件`WATERMARK.png`，文本位于图像指定的锚点位置内。
- en: Time for action - Watermark Maker Tool
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 水印制作工具
- en: Think about all the methods we would need to accomplish this. The first thing
    that comes to mind is a function that will process the command-line arguments
    mentioned earlier. Next, we need to write code that can add a watermark image
    to the main image. Let's call this `addWaterMark().` On similar lines, we will
    need methods that add text and date stamp to the image. We will call this `addText()`
    and `addDateStamp()` respectively. With this information, we will develop code
    to make this work. In this project, we will encapsulate this functionality in
    a class, but it is not necessary. We do so to make this tool extensible for future
    use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 想想我们需要的所有方法来完成这个任务。首先想到的是处理前面提到的命令行参数的函数。接下来，我们需要编写能够将水印图像添加到主图像中的代码。让我们称这个函数为
    `addWaterMark()`。按照类似的思路，我们还需要添加文本和日期戳到图像的方法。我们将分别称这些方法为 `addText()` 和 `addDateStamp()`。有了这些信息，我们将开发代码来实现这个功能。在这个项目中，我们将把这个功能封装在一个类中，但这不是必需的。我们这样做是为了使这个工具在未来使用时更具可扩展性。
- en: Download the file `WaterMarkMaker.py`. This has the code required in this project.
    Just keep it for further use. Some of the methods will not be discussed in this
    section. If you encounter difficulties while developing those methods, you can
    always go back and refer to this file.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载文件 `WaterMarkMaker.py`。这个文件包含在这个项目中需要的代码。只需保留它以供以后使用。本节将不会讨论一些方法。如果你在开发这些方法时遇到困难，你总是可以回过头来参考这个文件。
- en: Open a new Python source file and declare the following class and its methods.
    Just create empty methods for now. We will expand these in as we proceed along.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Python源文件，声明以下类及其方法。现在只需创建空方法即可。随着我们继续前进，我们将扩展这些方法。
- en: '[PRE20]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, we will write code in the constructor of this class.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在这个类的构造函数中编写代码。
- en: '[PRE21]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code is self-explanatory. First, all the necessary attributes are initialized
    and then the relevant methods are called to create the image with watermark and/or
    the embedded text. Let's write the methods in the order in which they are called
    in the constructor.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码是自我解释的。首先，初始化所有必要的属性，然后调用相关方法来创建带有水印和/或嵌入文本的图像。让我们按照在构造函数中调用的顺序编写这些方法。
- en: The `processArgs()` method processes the command-line arguments. You can write
    this method as an exercise. Alternatively, you can use code in the `WaterMarkMaker.py`
    file from the Packt website. The process arguments method should take the assignments
    as shown in the following table. In the reference files, `getopt` module is used
    to process these arguments. Alternatively, you can use `OptionParser` in the `optparse`
    module of Python.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`processArgs()` 方法处理命令行参数。你可以将此方法作为练习来编写。或者，你可以使用 Packt 网站上的 `WaterMarkMaker.py`
    文件中的代码。处理参数的方法应采用以下表格中所示的任务。在参考文件中，使用 `getopt` 模块来处理这些参数。或者，你也可以使用 Python 的 `optparse`
    模块中的 `OptionParser`。'
- en: '| Argument | Value | Argument | Value |'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 参数 | 值 | 参数 | 值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `image1` | `self.mainImgPath` | `text_pos` | `self.text_pos` |'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `image1` | `self.mainImgPath` | `text_pos` | `self.text_pos` |'
- en: '| `waterMark` | `self.waterMarkPath` | `transparency` | `self.t_factor` |'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `waterMark` | `self.waterMarkPath` | `transparency` | `self.t_factor` |'
- en: '| `mark_pos` | `self.mark_pos` | `dateStamp` | `self.dateStamp` |'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `mark_pos` | `self.mark_pos` | `dateStamp` | `self.dateStamp` |'
- en: '| `text` | `self.text` |   |   |'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `text` | `self.text` |   |   |'
- en: The `printUsage()` method just prints how to run this tool. You can easily write
    that method.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printUsage()` 方法只是打印如何运行这个工具。你可以轻松地编写这个方法。'
- en: Let's review the `addText()and _addTextWorker()` methods now. Note that some
    of the code comments are removed from the code samples for clarity. You can refer
    to the code in `WaterMarkMaker.py` for detailed comments.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下 `addText()` 和 `_addTextWorker()` 方法。请注意，为了清晰起见，代码示例中删除了一些注释。你可以参考
    `WaterMarkMaker.py` 中的代码以获取详细的注释。
- en: '[PRE22]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The addText() method simply calls _addTextWorker() by providing the self.text
    argument received from the command line.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addText()` 方法简单地通过提供从命令行接收到的 `self.text` 参数来调用 `_addTextWorker()`。'
- en: 'The `_addTextWorker()` does the main processing that embeds the text within
    the image. This method is used in the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_addTextWorker()` 方法执行将文本嵌入图像中的主要处理。这个方法在以下代码中使用：'
- en: '[PRE23]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In Chapter 2, we created a new image containing a text string. It read "Not
    really a fancy text ". Do you remember? Here, we have written similar code with
    some improvements. The function ImageDraw.Draw takes the self.mainImage (an Image
    instance) as an argument to create a Draw instance, imgDrawer.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二章中，我们创建了一个包含文本字符串的新图像。它读作 "Not really a fancy text "。你还记得吗？在这里，我们编写了类似的代码，并进行了一些改进。ImageDraw.Draw
    函数将 self.mainImage（一个 Image 实例）作为参数传递以创建一个 Draw 实例，imgDrawer。
- en: On line 18, the text is embedded onto the given position using a given font.
    The text() method of Draw instance takes three arguments, namely, position, text,
    and the font. In the previous chapter, we already made use of the first two arguments.
    The third argument font is an instance of class ImageFont in PIL.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第 18 行，使用给定的字体将文本嵌入到指定的位置。Draw 实例的 text() 方法接受三个参数，即位置、文本和字体。在上一章中，我们已经使用了前两个参数。第三个参数字体是
    PIL 中的 ImageFont 类的实例。
- en: On line 4, we create this instance specifying a font type (arial.ttf) and the
    font size (=50). The given text string is now added on to the main image!
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第 4 行，我们创建了这个实例，指定了字体类型（arial.ttf）和字体大小（=50）。现在给定的文本字符串被添加到主图像上！
- en: The next method we will discuss is `addDateStamp()`. It calls the same `_addTextWorker()`
    in the end. However, the placement of this date stamp is fixed at the bottom left
    corner of the image and of course we create our date string by using Python's
    `datetime` module. The code is illustrated below along with the import statement
    declared earlier.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的方法是 `addDateStamp()`。它最终调用了相同的方法 `_addTextWorker()`。然而，这个日期戳的位置固定在图像的左下角，当然我们通过使用
    Python 的 `datetime` 模块来创建我们的日期字符串。下面的代码展示了这一过程，包括之前声明的导入语句。
- en: '[PRE24]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first line of the code in this method creates a date instance `today` with
    today''s date provided as a `3-tuple`. Something like this: `datetime.date(2010,
    1, 20)`. Next, we call the `timetuple` method of `date` instance. The first three
    values in this `tuple` are `year, month`, and `day` respectively.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中的代码第一行创建了一个日期实例 `today`，提供了今天的日期作为 `3-tuple`。类似于这样的：`datetime.date(2010,
    1, 20)`。接下来，我们调用 `date` 实例的 `timetuple` 方法。这个 `tuple` 中的前三个值分别是 `year`（年）、`month`（月）和
    `day`（日）。
- en: The rest of the code is just the processing of the date stamp as a text string
    and then calling the main worker method just discussed.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的其余部分只是将日期戳作为文本字符串进行处理，然后调用前面讨论的主要工作方法。
- en: Now we will review the code in the `addWaterMark()` method. A **watermark**
    is typically a semi-transparent image that appears in the main image. There are
    two different approaches to accomplish creating a watermark. The following code
    considers both these approaches.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将回顾 `addWaterMark()` 方法中的代码。水印通常是一个半透明的图像，它出现在主图像上。有两种不同的方法来实现创建水印。下面的代码考虑了这两种方法。
- en: '[PRE25]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To add a watermark, first we make the image transparent. This is accomplished
    by calling the `addTransparency()` method. This method also changes the `mode`
    of the image to `RGBA`. This method is shown here. It is almost identical to the
    one we developed in an earlier section where an image was made transparent using
    blending functionality of PIL.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加水印，首先我们需要将图像设置为透明。这是通过调用 `addTransparency()` 方法实现的。此方法还将图像的 `mode` 改为 `RGBA`。这个方法在这里展示。它与我们在早期部分开发的方法几乎相同，当时我们使用
    PIL 的混合功能将图像设置为透明。
- en: '[PRE26]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, on line 13, we determine the anchor point on the main image, where the
    top-left corner of the watermark will appear. By default, we will match the bottom-left
    corner of the watermark with the main image. You can review the code for method
    _getMarkPosition() in the file WaterMarkMaker.py to see how this is done. Moving
    forward, the code block between lines 16-21 creates the watermark using the paste
    functionality. This is one way to create the image with a watermark. The arguments
    provided in the Image.paste function are image to be pasted, anchor point, and
    mask. The mask is selected as the watermark image itself so as to consider the
    transparency. Otherwise, the watermark image will appear opaque. The resultant
    image with and without image mask specification is compared in the following illustration.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在第 13 行，我们确定主图像上的锚点，水印的左上角将出现在这里。默认情况下，我们将水印的左下角与主图像的左下角对齐。你可以查看文件 WaterMarkMaker.py
    中方法 _getMarkPosition() 的代码来了解这是如何实现的。向前推进，第 16-21 行之间的代码块使用粘贴功能创建水印。这是创建带水印图像的一种方法。Image.paste
    函数提供的参数是待粘贴的图像、锚点以及遮罩。遮罩被选为水印图像本身，以便考虑透明度。否则，水印图像将是不透明的。以下插图比较了带有和不带有图像遮罩指定的结果图像。
- en: Resultant images using Image.paste operation created with and without mask.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Image.paste操作创建的带有和没有蒙版的最终图像。
- en: '![Time for action - Watermark Maker Tool](img/0165_3_21.jpg)![Time for action
    - Watermark Maker Tool](img/0165_3_22.jpg)'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 水印制作工具](img/0165_3_21.jpg)![行动时间 - 水印制作工具](img/0165_3_22.jpg)'
- en: Next, in the else condition block (lines 22 to 33), we use Image.composite functionality
    in PIL to embed the watermark. The dimensions of the example watermark image used
    here are 200x200 pixels, whereas the dimensions of the main image are 800x600
    pixels. To use the composite() method, we need to make these images of the same
    size, and yet, make sure to paste the watermark at the specified position. How
    to achieve this? The first thing to do is to create a canvas image to hold the
    watermark. The canvas image is of the same size as that of the main image. The
    code block 25-29 creates the canvas and pastes the watermark at an appropriate
    location.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在else条件块（第22至33行）中，我们使用PIL中的Image.composite功能嵌入水印。这里使用的示例水印图像的尺寸是200x200像素，而主图像的尺寸是800x600像素。要使用composite()方法，我们需要将这些图像调整为相同的大小，同时确保将水印粘贴到指定的位置。如何实现这一点？首先要做的是创建一个画布图像来保存水印。画布图像与主图像大小相同。代码块25-29创建了画布并在适当的位置粘贴了水印。
- en: Finally, on line 31, the composite image is created using the canvas image instance
    as the alpha mask.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在第31行，使用画布图像实例作为alpha蒙版创建了合成图像。
- en: 'Now lets run this tool! You can use your own image files for main image or
    the watermark. Alternatively, you can use the image `0165_3_34_KokanPeak_for_WATERMARK.png`
    as the main image and `0165_3_38_SMILEY_small.png` as the watermark image. The
    command-line arguments for this run are:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行这个工具！你可以使用自己的图像文件作为主图像或水印。或者，你可以使用图像`0165_3_34_KokanPeak_for_WATERMARK.png`作为主图像，`0165_3_38_SMILEY_small.png`作为水印图像。这次运行的命令行参数是：
- en: '[PRE27]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The resultant image with text, date stamp, and the watermark is shown in the
    next illustration.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有文本、日期戳和水印的最终图像将在下一幅插图显示。
- en: Final processed image with text, date stamp, and a watermark.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终处理后的图像带有文本、日期戳和水印。
- en: '![Time for action - Watermark Maker Tool](img/0165_3_23.jpg)'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 水印制作工具](img/0165_3_23.jpg)'
- en: What just happened?
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We created a very useful utility that can add a watermark and/or a text string
    and/or a date stamp to an input image. We used several of the image processing
    techniques learned in this as well as in an earlier chapter on image processing.
    Especially, image enhancement features such as blending, creating composite images,
    and adding transparency were applied to accomplish this task. Additionally we
    made use of common functionality such as pasting an image, drawing text onto the
    image, and so on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常有用的实用工具，可以将水印和/或文本字符串和/或日期戳添加到输入图像中。我们在此以及之前章节中学到的图像处理技术中也使用了这些技术。特别是，应用了图像增强功能，如混合、创建合成图像和添加透明度来完成这项任务。此外，我们还使用了常见的功能，如粘贴图像、在图像上绘制文本等。
- en: Have a go hero do more with Watermark Maker Tool
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试使用Watermark Maker Tool进行更多操作
- en: 'Our Watermark Maker tool needs an upgrade. Extend this application so that
    it supports following the features:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Watermark Maker工具需要升级。扩展此应用程序以便它支持以下功能：
- en: The text or the date stamp color is currently hardcoded. Add a new command-line
    argument so that a text color can be specified as an optional argument.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本或日期戳的颜色目前是硬编码的。添加一个新的命令行参数，以便可以将文本颜色指定为可选参数。
- en: Add some standard default options for specifying anchor position for text, date
    stamp, and the watermark image. These options can be `TOP_RIGHT, TOP_LEFT, BOTTOM_RIGHT`,
    and `BOTTOM_LEFT`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些标准默认选项，用于指定文本、日期戳和水印图像的锚点位置。这些选项可以是`TOP_RIGHT, TOP_LEFT, BOTTOM_RIGHT`和`BOTTOM_LEFT`。
- en: The command-line options list is too long. Add code so that all arguments can
    be read from a text file.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行选项列表太长了。添加代码以便所有参数都可以从文本文件中读取。
- en: Add support so that it can batch-process images to create desired effect.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加支持以便它可以批量处理图像以创建所需效果。
- en: Applying image filters
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用图像过滤器
- en: In the previous chapter, `filter` argument was used while performing the image
    resize operation. This `filter` determined the quality of the output image. However,
    there were only four `filter` options available and the scope was limited to a
    resize operation. In this section, some additional image enhancement filters will
    be introduced. These are predefined filters and can be directly used on any input
    image. Following is a basic syntax used for applying a filter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，执行图像缩放操作时使用了`filter`参数。这个`filter`决定了输出图像的质量。然而，只有四个`filter`选项可用，并且其范围仅限于缩放操作。在本节中，将介绍一些额外的图像增强滤波器。这些是预定义的滤波器，可以直接应用于任何输入图像。以下是应用滤波器的基本语法。
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we created a new image `filtered_image` by filtering image `img` . The
    `FILTER` argument can be one of the predefined filters in the `ImageFilter` module
    of PIL for filtering the image data. PIL offers several predefined image enhancement
    filters. These can be broadly classified into the following categories. With the
    help of examples, we will learn some of these in the coming sections.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过过滤图像`img`创建了一个新的图像`filtered_image`。`FILTER`参数可以是PIL的`ImageFilter`模块中预定义的滤波器之一，用于过滤图像数据。PIL提供了几个预定义的图像增强滤波器。这些可以大致分为以下几类。通过示例，我们将在接下来的章节中学习其中的一些。
- en: 'Blurring and sharpening: `BLUR, SHARPEN, SMOOTH, SMOOTH_MORE`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊和锐化：`BLUR, SHARPEN, SMOOTH, SMOOTH_MORE`
- en: 'Edge detection and enhancement: `EDGE_ENHANCE, EDGE_ENHANCE_MORE, FIND_EDGES,
    CONTOUR`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘检测和增强：`EDGE_ENHANCE, EDGE_ENHANCE_MORE, FIND_EDGES, CONTOUR`
- en: 'Distortion/special effects: `EMBOSS`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扭曲/特殊效果：`EMBOSS`
- en: The file `ImageFilter.py` in the PIL source code defines the-mentioned filter
    classes. You can create your own custom filter by tweaking various arguments in
    these filter classes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: PIL源代码中的`ImageFilter.py`文件定义了上述过滤器类。你可以通过调整这些过滤器类中的各种参数来创建自己的自定义过滤器。
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Where, `kernel` is the convolution kernel. Here, the 'convolution' is a mathematical
    operation, on the image matrix by the 'kernel' matrix to produce a resultant matrix.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`kernel`是卷积核。在这里，'卷积'是一个数学运算，通过'kernel'矩阵对图像矩阵进行操作以产生结果矩阵。
- en: The size of matrix is specified by the size argument. It is specified in the
    form (width, height). This can either be (3, 3) or (5, 5) size in the current
    PIL version. The result of each pixel is divided by `scale` argument. This is
    an optional argument. The `offset` value, if specified, has its value is added
    to the result after dividing it by the scale argument.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的大小由大小参数指定。它以（宽度，高度）的形式指定。在当前PIL版本中，这可以是（3，3）或（5，5）的大小。每个像素的结果被`scale`参数除以。这是一个可选参数。如果指定了`offset`值，则将其值加到除以`scale`参数后的结果上。
- en: In some of the image enhancement filter examples, we will create our own custom
    filter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些图像增强滤波器示例中，我们将创建自己的自定义过滤器。
- en: Smoothing
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平滑
- en: '**Smoothing** an image means reducing the noise within the image data. For
    this, certain mathematical approximation is applied on the image data to recognize
    the important patterns within the image. The `ImageFilter` module defines `class
    SMOOTH` for smoothing an image. PIL specifies the following default filter arguments
    for the image-smoothing filter.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**平滑**图像意味着减少图像数据中的噪声。为此，对图像数据应用某些数学近似以识别图像中的重要模式。`ImageFilter`模块定义了用于平滑图像的`class
    SMOOTH`。PIL为图像平滑滤波器指定了以下默认过滤器参数。'
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Time for action - smoothing an image
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践时间 - 平滑图像
- en: Let's work out an example where a smoothing filter will be applied to an image.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来演示如何对一个图像应用平滑滤波器。
- en: Download the image file `0165_3_Before_SMOOTHING.png` from the Packt website
    and save it as `Before_SMOOTHING.png`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Packt网站下载图像文件`0165_3_Before_SMOOTHING.png`并将其保存为`Before_SMOOTHING.png`。
- en: This is a low-resolution image scanned from a developed photograph. As you can
    see, there is a lot of salt-and-pepper noise in the image. We will apply smoothing
    filter to reduce some of this noise in the image data.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一张从冲洗好的照片扫描的低分辨率图像。正如你所见，图像中有很多盐和胡椒噪声。我们将应用平滑滤波器来减少图像数据中的一些噪声。
- en: Add the following code in a Python file.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个Python文件中添加以下代码。
- en: '[PRE31]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The highlighted line in the code is where the smoothing filter is applied to
    the image. The results are shown in the next illustration.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码中高亮显示的行是平滑滤波器应用于图像的位置。结果将在下一幅插图显示。
- en: 'Picture before and after smoothing:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 平滑前后的图片：
- en: '![Time for action - smoothing an image](img/0165_3_24.jpg)![Time for action
    - smoothing an image](img/0165_3_25.jpg)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 平滑图像](img/0165_3_24.jpg)![行动时间 - 平滑图像](img/0165_3_25.jpg)'
- en: To reduce the noise further down, you can use `ImageFilter.SMOOTH_MORE` or try
    reapplying the `ImageFilter.SMOOTH` multiple times until you get the desired effect.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步减少噪声，你可以使用`ImageFilter.SMOOTH_MORE`或尝试多次重新应用`ImageFilter.SMOOTH`直到你得到期望的效果。
- en: '[PRE32]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can observe in the illustration, the noise is further reduced but the
    image appears a little bit hazy. Thus, one has to determine an appropriate level
    of smoothness.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如插图所示，噪声进一步减少，但图像看起来有点模糊。因此，必须确定适当的平滑程度。
- en: Comparison of the resultant image with single and multiple smoothing filters.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将结果图像与单次和多次平滑滤镜的对比。
- en: '![Time for action - smoothing an image](img/0165_3_26.jpg)![Time for action
    - smoothing an image](img/0165_3_27.jpg)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 平滑图像](img/0165_3_26.jpg)![行动时间 - 平滑图像](img/0165_3_27.jpg)'
- en: What just happened?
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We learned how to reduce high-level noise from the image data using the smoothing
    filter in the `ImageFilter` module.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用`ImageFilter`模块中的平滑滤镜从图像数据中减少高级噪声。
- en: Sharpening
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锐化
- en: 'In the earlier section, we learned image-smoothing techniques. If you want
    to view the finer details within an image, a sharpening filter can be applied
    over the image. Like image-smoothing filters, PIL provides predefined filters
    for sharpening called `ImageFilter.SHARPEN`. The basic syntax to sharpen an image
    is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了图像平滑技术。如果你想查看图像中的更细微的细节，可以在图像上应用锐化滤镜。与图像平滑滤镜类似，PIL提供了用于锐化的预定义滤镜，称为`ImageFilter.SHARPEN`。锐化图像的基本语法如下：
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can try this filter on the image that was smoothed multiple times in the
    earlier section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面章节中平滑多次的图像上尝试这个滤镜。
- en: Blurring
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊
- en: In general, blurring makes an image lose its focus. In PIL, the predefined filter
    for this is `ImageFilter.BLUR`. This is typically useful if you want to fade out
    the background to highlight some object in the foreground. The syntax is similar
    to the one used for other filters.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模糊会使图像失去焦点。在PIL中，用于此目的的预定义滤镜是`ImageFilter.BLUR`。这通常在你想淡化背景以突出前景中的某个对象时很有用。语法与其他滤镜使用的语法类似。
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The following illustration shows the effect of this filter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图显示了此滤镜的效果。
- en: 'Image before and after application of blurring filter:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 应用模糊滤镜前后的图像对比：
- en: '![Blurring](img/0165_3_28.jpg)![Blurring](img/0165_3_29.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![模糊](img/0165_3_28.jpg)![模糊](img/0165_3_29.jpg)'
- en: Edge detection and enhancements
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘检测和增强
- en: In this section, we will learn some general edge detection and enhancement filters.
    The edge enhance filter improves the edge contrast. It increases the contrast
    of the region very close to the edge. This makes the edge stand out. The edge
    detection algorithm looks for discontinuities within the pixel data of the image.
    For example, it looks for sharp change in the brightness to identify an edge.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习一些通用的边缘检测和增强滤镜。边缘增强滤镜提高了边缘对比度。它增加了非常接近边缘区域的对比度。这使得边缘更加突出。边缘检测算法在图像的像素数据中寻找不连续性。例如，它寻找亮度中的急剧变化以识别边缘。
- en: Time for action - detecting and enhancing edges
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 检测和增强边缘
- en: Let's see how the edge detection and enhancement filters modify the data of
    a picture. The photograph that we will use is a close-up of a leaf. The original
    photo is shown in the next illustration. Applying an edge detection filter on
    this image creates a cool effect where only edges are highlighted and the remaining
    portion of the image is rendered as black.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看边缘检测和增强滤镜如何修改图片的数据。我们将使用的照片是一片叶子的特写。原始照片在下一张插图显示。在这张图像上应用边缘检测滤镜会产生一种效果，其中只有边缘被突出显示，而图像的其余部分被渲染为黑色。
- en: Download the image `0165_3_6_Before_EDGE_ENHANCE.png` from the Packt website
    and save it as `Before_EDGE_ENHANCE.png`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Packt网站下载图像`0165_3_6_Before_EDGE_ENHANCE.png`并将其保存为`Before_EDGE_ENHANCE.png`。
- en: Add the following code in a Python file.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python文件中添加以下代码。
- en: '[PRE35]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Line 14 modifies the image data using the `FIND_EDGES` filter and then the resulting
    image is saved.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第14行使用`FIND_EDGES`滤镜修改图像数据，然后将结果图像保存。
- en: Next, we modify the original image data, so that more veins within the leaf
    become visible. This is accomplished by the application of `ENHANCE_EDGES` filter
    (line 17).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们修改原始图像数据，以便使叶子中的更多叶脉变得可见。这是通过应用`ENHANCE_EDGES`滤镜（第17行）实现的。
- en: On line 20, the `FIND_EDGES` filter is applied on the edge-enhanced image. The
    resultant images are compared in the next illustration.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第20行，将`FIND_EDGES`滤镜应用于边缘增强的图像。下一幅插图显示了比较后的结果图像。
- en: 'a) First row: Images before and after application of edge enhancement filter
    b) Second row: The edges detected by ImageFilter.FIND_EDGES filter.'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 第一行：应用边缘增强滤镜前后的图像 b) 第二行：由ImageFilter.FIND_EDGES滤镜检测到的边缘。
- en: '![Time for action - detecting and enhancing edges](img/0165_3_30.jpg)![Time
    for action - detecting and enhancing edges](img/0165_3_31.jpg)![Time for action
    - detecting and enhancing edges](img/0165_3_32.jpg)![Time for action - detecting
    and enhancing edges](img/0165_3_33.jpg)'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 检测和增强边缘](img/0165_3_30.jpg)![行动时间 - 检测和增强边缘](img/0165_3_31.jpg)![行动时间
    - 检测和增强边缘](img/0165_3_32.jpg)![行动时间 - 检测和增强边缘](img/0165_3_33.jpg)'
- en: What just happened?
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We created an image with enhanced edges by applying the `EDGE_ENHANCE` filter
    in the `ImageFilter` module. We also learned how to detect edges within the image
    using the edge detection filter. In the next section, we will apply a special
    form of the edge filter that highlights or darkens the detected edges within an
    image. It is called an embossing filter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`ImageFilter`模块中应用`EDGE_ENHANCE`滤镜来创建具有增强边缘的图像。我们还学习了如何使用边缘检测滤镜在图像中检测边缘。在下一节中，我们将应用一种特殊的边缘滤波器，该滤波器可以突出显示或变暗图像中检测到的边缘。它被称为浮雕滤镜。
- en: Embossing
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮雕
- en: In image processing, embossing is a process that gives an image a 3-D appearance.
    The edges within the image appear raised above the image surface. This optical
    illusion is accomplished by highlighting or darkening edges within the image.
    The following illustration shows original and embossed images. Notice how the
    edges along the characters in the embossed image are either highlighted or darkened
    to give the desired effect.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像处理中，浮雕是一种使图像具有3D外观的过程。图像中的边缘看起来像是凸起在图像表面之上。这种视觉错觉是通过突出显示或变暗图像中的边缘来实现的。以下插图显示了原始和浮雕图像。注意，浮雕图像中字符的边缘要么被突出显示，要么被变暗，以达到预期的效果。
- en: '![Embossing](img/0165_3_34.jpg)![Embossing](img/0165_3_35.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![浮雕](img/0165_3_34.jpg)![浮雕](img/0165_3_35.jpg)'
- en: 'The `ImageFiltermodule` provides a predefined filter, `ImageFilter.EMBOSS`,
    to achieve the embossing effect for an image. The convolution kernel of this filter
    is of a (3, 3) size and the default filter arguments are:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageFilter`模块提供了一个预定义的滤镜`ImageFilter.EMBOSS`，用于为图像实现浮雕效果。此滤镜的卷积核大小为(3, 3)，默认的滤镜参数为：'
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Time for action - embossing
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 浮雕
- en: Download the image `0165_3_4_Bird_EMBOSS.png` from the Packt website and save
    it as `Bird_EMBOSS.png`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Packt网站下载图像`0165_3_4_Bird_EMBOSS.png`并将其保存为`Bird_EMBOSS.png`。
- en: 'Add the following code in a Python file:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python文件中添加以下代码：
- en: '[PRE37]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: On line 9, the embossing filter `ImageFilter.EMBOSS` is applied to the image
    object `bird`. The resultant embossed image of the bird is shown in the next illustration.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第9行，将浮雕滤镜`ImageFilter.EMBOSS`应用于图像对象`bird`。下一幅插图显示了鸟的浮雕图像。
- en: Original and embossed images of a bird using ImageFilter.EMBOSS.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用ImageFilter.EMBOSS创建的鸟的原始和浮雕图像。
- en: '![Time for action - embossing](img/0165_3_36.jpg)![Time for action - embossing](img/0165_3_37.jpg)'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 浮雕](img/0165_3_36.jpg)![行动时间 - 浮雕](img/0165_3_37.jpg)'
- en: What just happened?
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We applied an embossing filter on an image and created an embossed image. As
    seen in previous section, the filter modified the brightness of various edges
    to make them appear highlighted or darkened. This created an optical illusion
    where the image appeared raised above the surface.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对一个图像应用了浮雕滤镜，创建了一个浮雕图像。如前文所述，该滤镜通过改变各种边缘的亮度使它们看起来被突出显示或变暗。这创造了一种视觉错觉，使图像看起来像是在表面之上凸起。
- en: Adding a border
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加边框
- en: 'How would you prefer viewing a family photo? As a bare picture or enclosed
    in a nice photo frame? In `ImageOps` module, PIL provides a preliminary functionality
    to add a plain border around the image. Here is the syntax to achieve this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你更喜欢怎样查看家庭照片？是作为裸露的图片还是装在漂亮的相框里？在`ImageOps`模块中，PIL提供了在图片周围添加普通边框的初步功能。以下是实现此功能的语法：
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code creates a border around the image. Internally, PIL just creates an
    image that has dimesions such that:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在图像周围创建了一个边框。内部，PIL创建了一个具有相应尺寸的图像：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, the original image is pasted onto this new image to create the border
    effect. The `border` argument in the preceding code suggests border thickness
    in pixels. It is uniform in this example and is set to 20 pixels for left, right,
    top, and bottom borders. The `fill` argument specifies the border color. It can
    be a number in the range `0` to `255` indicating the pixel color, where `0` is
    for 'black' and `255` for 'white' border. Alternatively, you can specify a string
    representing a color, such as 'red' for red color, and so on.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将原始图像粘贴到这个新图像上以创建边框效果。前述代码中的`border`参数表示边框厚度（以像素为单位）。在这个例子中它是均匀的，设置为左、右、上、下边框均为20像素。`fill`参数指定边框颜色。它可以是一个范围在`0`到`255`之间的数字，表示像素颜色，其中`0`表示黑色边框，`255`表示白色边框。或者，你可以指定一个表示颜色的字符串，例如`red`表示红色，等等。
- en: Time for action - enclosing a picture in a photoframe
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动作 - 将图片封装在相框中
- en: Let's develop code that adds a frame around a picture.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发代码，为图片添加边框。
- en: Download the image `0165_3_15_COLOR_TWEAK.png` and rename it to `FLOWER.png`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载图像`0165_3_15_COLOR_TWEAK.png`并将其重命名为`FLOWER.png`。
- en: Add the following code in a Python source file. Make sure to modify the code
    to specify in the input and output paths appropriately.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python源文件中添加以下代码。确保修改代码以适当地指定输入和输出路径。
- en: '[PRE40]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this code snippet, three stacked borders are created. The innermost border
    layer is rendered with black color. This is intentionally chosen darker.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码片段中，创建了三个堆叠的边框。最内层的边框层以黑色渲染。这是故意选择较暗的颜色。
- en: Next, there is a middle layer of border, rendered with a lighter color (silver
    color in this case). This is done by the code on line 4\. It is thicker than the
    innermost border.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，有一个中间层的边框，以较浅的颜色（在这个例子中是银色）渲染。这是通过第4行的代码实现的。它比最内层的边框更厚。
- en: The outermost border is created by code on line 5\. It is a very thin layer
    rendered as black.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最外层的边框是通过第5行的代码创建的。它是一个非常薄的黑色层。
- en: Together, these three layers of borders create an optical illusion of a photo
    frame, by making the border appear raised above the original image.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这三个边框层共同创造了一个相框的视觉错觉，使得边框看起来比原始图像突出。
- en: The following image shows the result of adding this border to the specified
    input image it shows the image before and after enclosing in a 'photo frame'.![Time
    for action - enclosing a picture in a photoframe](img/0165_3_38.jpg)![Time for
    action - enclosing a picture in a photoframe](img/0165_3_39.jpg)
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的图像显示了将此边框添加到指定输入图像的结果，显示了在“相框”中封装前后的图像。![执行动作 - 将图片封装在相框中](img/0165_3_38.jpg)![执行动作
    - 将图片封装在相框中](img/0165_3_39.jpg)
- en: What just happened?
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We learned how to create a simple border around an image. By calling `ImageOps.expand`
    multiple times, we created a multi-layered border having each layer of variable
    thickness and color. With this, we accomplished creating an optical illusion where
    the picture appears to be enclosed within a simple photo frame.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何为图像创建一个简单的边框。通过多次调用`ImageOps.expand`，我们创建了一个多层边框，每一层的厚度和颜色都不同。通过这种方式，我们实现了图片看起来被包含在一个简单相框中的视觉错觉。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter taught us several important image enhancement techniques, specifically:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教授了我们几个重要的图像增强技术，具体包括：
- en: With the help of ample examples, we learned how to adjust the color, brightness,
    and contrast of an image.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大量示例的帮助下，我们学习了如何调整图像的颜色、亮度和对比度。
- en: We learned how to blend images together create composites using image mask and
    how to add transparency.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何混合图像，使用图像蒙版创建合成图像，以及如何添加透明度。
- en: We applied blending, pasting, and other techniques learned to develop an interesting
    tool. We implemented features in this tool that enabled inserting a watermark,
    text, or date stamp to an image.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学到的混合、粘贴和其他技术应用到开发一个有趣的小工具中。我们在该工具中实现了插入水印、文本或日期戳到图像的功能。
- en: A number of image enhancement filters were discussed. Using code snippets we
    learned how to reduce high-level noise from image, enhance edges, add sharpening
    or blurring effects, emboss an image, and so on.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了许多图像增强过滤器。通过使用代码片段，我们学习了如何从图像中减少高级噪声，增强边缘，添加锐化或模糊效果，浮雕图像，等等。
- en: We learned miscellaneous other useful image enhancements such as creating negatives
    and adding border effects to the image.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了其他一些有用的图像增强技巧，例如创建负片和为图像添加边框效果。
