- en: Fundamental Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本概念
- en: This chapter introduces the concept of network automation and familiarizes you
    with the keywords that are part of the automation framework. Before we dive into
    the details of network automation, it is important to understand why we need network
    automation and what we can achieve if we embrace the automation concepts and framework.
    This chapter also provides an insight into the traditional model of engineer and
    support operations, and shows how network automation can help bridge that gap
    for better efficiency and reliability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了网络自动化的概念，并使您熟悉自动化框架中的关键词。在我们深入探讨网络自动化的细节之前，了解为什么我们需要网络自动化以及如果我们接受自动化概念和框架，我们可以实现什么，这一点非常重要。本章还提供了对传统工程师和支持运营模式的洞察，并展示了网络自动化如何帮助缩小这一差距，以实现更高的效率和可靠性。
- en: 'Some of the topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些主题包括以下内容：
- en: What is network automation?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是网络自动化？
- en: DevOps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps
- en: Software-defined networking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件定义网络
- en: Basics of OpenFlow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenFlow基础知识
- en: Basic programming concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本编程概念
- en: Programming language choices for automation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化编程语言选择
- en: Introduction to REST framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST框架简介
- en: Network automation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络自动化
- en: Automation, as the word suggests, is a framework of automating a particular
    task by understanding, interpreting, and creating logic. This includes enhancing
    the current capabilities of the tasks that are done manually and reducing the
    error rate of those tasks while focusing on scaling the task with reduced effort.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化，正如其词义所示，是通过理解、解释和创建逻辑来自动化特定任务的框架。这包括增强手动执行的任务的当前能力，同时降低这些任务的错误率，并专注于以减少的努力来扩展任务。
- en: As an example, imagine we need to upgrade the IOS image of a Cisco router. This
    can involve multiple tasks, such as loading the image on the router, validating
    the checksum of the image, offloading traffic (if it's a production router), modifying
    the boot variable, and finally, reloading the router with the new image.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要升级一台思科路由器的IOS映像。这可能涉及多个任务，例如在路由器上加载映像、验证映像的校验和、（如果它是生产路由器）卸载流量、修改引导变量，最后，使用新映像重新加载路由器。
- en: All of this is feasible if we have only one router to upgrade. Now take a similar
    scenario and try to implement it for around 1,000 routers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要升级一台路由器，所有这些都是可行的。现在，将类似的场景应用于大约1,000台路由器。
- en: Let's say we take 30 minutes getting each router to perform the aforementioned
    tasks. It's an easy calculation of 1000*30=30,000 minutes of manual effort.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们花费30分钟让每个路由器执行上述任务。这是一个简单的计算，1000*30=30,000分钟的手动工作。
- en: Also, if we are performing tasks on each router manually, think of the errors
    that can creep in.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们手动在每个路由器上执行任务，想想可能出现的错误。
- en: Network automation would be helpful in this scenario, as it can take care of
    all the preceding aspects and perform the tasks in parallel. Hence, if it takes
    30 minutes of manual effort for one router, and in the worst case scenario the
    same 30 minutes for automation to perform the same task, then parallel execution
    would result in all 1,000 routers being upgraded within the same 30 minutes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，网络自动化将非常有帮助，因为它可以处理所有上述方面，并并行执行任务。因此，如果手动对一个路由器进行30分钟的努力，在最坏的情况下自动化执行相同任务也需要30分钟，那么并行执行将导致所有1,000台路由器在相同的30分钟内升级完成。
- en: Hence, final amount of time will be only 30 minutes, irrespective of the number
    of routers you throw at the automation framework. This also drastically reduces
    the need for manual work, and an engineer can focus on any failures in the 1,000
    network devices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终所需的时间将仅为30分钟，无论您向自动化框架投入多少台路由器。这也极大地减少了手动工作的需求，工程师可以专注于1,000台网络设备中的任何故障。
- en: In the upcoming sections, I will introduce you to some of the concepts, tools,
    and examples that will get you started with building automation frameworks and
    effectively using them in network scenarios to perform network-related activities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将向您介绍一些概念、工具和示例，这些将帮助您开始构建自动化框架，并在网络场景中有效地使用它们来执行网络相关活动。
- en: This also assumes that you have an idea of network concepts and common terminology
    used in networking.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这也假设您对网络概念和在网络中使用的常用术语有所了解。
- en: Some of the examples that I will provide assume familiarity with syslog, TACACS,
    basic router configs such as hostnames, iOS image loading, basic routing and switching
    concepts, and **Simple Network Management Protocol** (**SNMP**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提供的某些示例假设您熟悉syslog、TACACS、基本路由器配置（如主机名）、iOS镜像加载、基本路由和交换概念，以及**简单网络管理协议**（**SNMP**）。
- en: DevOps
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps
- en: Historically, there have been two specific teams in every networking department.
    One of the teams is the engineering team, which is responsible for conceiving
    new ideas to improve the network and designing, deploying, and optimizing the
    current infrastructure. This team is primarily responsible for performing tasks
    such as configuration and cabling from scratch.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，每个网络部门都有两个特定的团队。其中一个团队是工程团队，负责构思新想法以改进网络，并设计、部署和优化当前的基础设施。这个团队主要负责从头开始执行配置和布线等任务。
- en: The other team is the support team. This team, also known as the operations
    team, ensures the current deployed infrastructure is up and running and focuses
    on performing day-to-day activities such as upgrades, quick fixes, and support
    to any consumers of that network infrastructure. In a traditional model, there
    are hand-offs and knowledge transfers from the engineering team to the operations
    team for support of the current deployed infrastructure. Because of the segregation
    of the two teams, the engineer team members do not focus on writing clear documentation,
    or sometimes do not even provide adequate information to operations team members,
    causing delays in troubleshooting and fixing issues. This could even lead to a
    simple solution scaling to a bigger problem because of the different approach
    that a engineering team member would take compared to an operations team member.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个团队是支持团队。这个团队也被称为运维团队，确保当前部署的基础设施正常运行，并专注于执行日常活动，如升级、快速修复和对该网络基础设施的任何消费者的支持。在传统模型中，工程团队到运维团队之间会有交接和知识转移，以支持当前部署的基础设施。由于两个团队的分离，工程师团队成员可能不会专注于编写清晰的文档，有时甚至不会向运维团队成员提供足够的信息，导致故障排除和问题修复延迟。这甚至可能导致一个简单的解决方案因为与运维团队成员相比，工程团队成员采取的不同方法而扩大成更大的问题。
- en: Nowadays, to solve this problem, the DevOps model was conceived, which brings
    the best from both teams. Rather than being a fancy designation, a DevOps model
    is a culture that needs to be created among the current teams. In a DevOps model,
    an engineer from any team is responsible for the complete life cycle of a specific
    project. This includes creating part of the infrastructure and supporting it by
    themselves. A big benefit of this model is that because a person has created a
    part of the system and supports it, they know all the aspects of that part and
    can work on it again to make it better by understanding the challenges that arise
    from customer or user experiences. A DevOps engineer should understand the engineering
    and operations for the part of the infrastructure that they have created. By adding
    an automation skill set to the DevOps experience, an engineer can manage complex
    tasks with ease and focus on reliability and scalability in a better manner than
    engineers who are distributed in different domains in the traditional model.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了解决这个问题，提出了DevOps模型，它结合了两个团队的最佳之处。DevOps模型不仅仅是一个花哨的称号，它是一种需要在现有团队中培养的文化。在DevOps模型中，任何团队的工程师都对特定项目的完整生命周期负责。这包括创建部分基础设施并自行支持它。这个模型的一个大优点是，由于一个人创建了一部分系统并支持它，他们了解该部分的各个方面，并可以通过理解客户或用户体验中出现的挑战来再次工作，使其变得更好。DevOps工程师应该了解他们创建的基础设施部分的工程和运维。通过将自动化技能集添加到DevOps经验中，工程师可以轻松管理复杂任务，并以比传统模型中分散在不同领域的工程师更好的方式关注可靠性和可扩展性。
- en: Software-defined networking
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件定义网络
- en: As you may be aware, there have been multiple proprietary networking devices,
    such as firewalls, switches, and routers, that were made by different network
    vendors. However, owing to the proprietary information from each different vendor,
    multiple network devices might not exist in a single network infrastructure environment.
    Even if they exist together, network engineers have to focus their effort on ensuring
    that each vendor device can exist in a network path without any hiccups. There
    might be times when one routing protocol might not be compatible with all the
    network devices in a multi-vendor environment, and a lot of time is wasted ensuring
    either the removal of that protocol, or the removal of the vendor which that does
    not support that protocol. This can waste effort and time, which could be better
    spent improving the infrastructure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，存在多种专有网络设备，如防火墙、交换机和路由器，由不同的网络供应商制造。然而，由于每个不同供应商的专有信息，多个网络设备可能不会存在于单一的网络基础设施环境中。即使它们共同存在，网络工程师也必须专注于确保每个供应商设备可以在网络路径中无缝存在。有时，在多供应商环境中，一个路由协议可能不与所有网络设备兼容，这会导致大量时间被浪费在确保移除该协议或移除不支持该协议的供应商上。这可能会浪费努力和时间，而这些时间和努力本可以更好地用于改善基础设施。
- en: To solve this type of issue, **software-defined networking** (**SDN**) has been
    introduced. In an SDN scenario, a packet flow is defined from a central controller
    that in turn interacts with multi-vendor equipment to create/define rules based
    upon the required packet flow. This shifts the focus of a network engineer entirely
    to how the traffic flows, which path the packet takes, to even responding to link
    down situations through automated routing of packets by configuring some rules
    or policies on the controllers. Another advantage of SDN is that the multi-vendor
    equipment is now not the center piece of infrastructure. The focus shifts to how
    optimally the routing and traffic shaping (the process to identify the optimal
    path of traffic flow) is occurring. As part of Software driven tasks, there are
    pieces of code that are specifically written to control a specific task or goal
    (similar to functions or methods in programming). This piece of code is triggered
    by controller decisions or rules, which in turn adds, modifies, or deletes configs
    on the multi-vendor device to ensure the rule set on the controller is adhered
    to. SDN even has the ability to completely isolate a failure domain, through the
    identification of a physical link down or even a total device failure without
    affecting the flow of traffic in real time. For example, a switch can issue a
    request to the controller if it gets a packet destined for a network that it does
    not know. This would be a packet drop or route not found in a traditional network
    model, but with SDN, it is the task of a controller to provide the destination
    or path information to the switches to correctly route the packet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这类问题，**软件定义网络**（**SDN**）已被引入。在SDN场景中，数据包流是从一个中央控制器定义的，该控制器随后与多供应商设备交互，根据所需的流量定义/创建规则。这完全将网络工程师的焦点转移到如何流量流动，数据包采取哪条路径，甚至通过在控制器上配置一些规则或策略来自动路由数据包以响应链路故障情况。SDN的另一个优点是，多供应商设备现在不再是基础设施的核心。焦点转移到如何最优地执行路由和流量整形（识别流量流最优路径的过程）。作为软件驱动任务的一部分，有一些代码专门编写来控制特定任务或目标（类似于编程中的函数或方法）。这段代码由控制器决策或规则触发，进而向多供应商设备添加、修改或删除配置，以确保控制器上的规则集得到遵守。SDN甚至有能力通过识别物理链路故障或设备完全故障来完全隔离故障域，而不会影响实时流量。例如，如果交换机收到一个目的地为它所不知道的网络的数据包，它会向控制器发出请求。在传统网络模型中，这将是数据包丢失或找不到路由，但通过SDN，这是控制器的任务，为交换机提供目的地或路径信息，以正确路由数据包。
- en: This ensures the troubleshooting becomes much easier, since a network engineer
    now has full control of each path/packet flow, irrespective of the vendor-specific
    protocol or technology support. Additionally, since now we are following a standard
    set of protocols, we can even lower our costs by removing more expensive proprietary
    network devices and replacing them with open standards network gear.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了故障排除变得更加容易，因为网络工程师现在可以完全控制每条路径/数据包流，无论特定的供应商协议或技术支持如何。此外，由于我们现在遵循一套标准协议，我们甚至可以通过移除更昂贵的专有网络设备并用开放标准网络设备替换它们来降低成本。
- en: OpenFlow
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenFlow
- en: OpenFlow is a communication protocol that is used for communication between
    different vendor's equipment for the packet flow. This standard is maintained
    by a group called **Open Network Foundation** (**ONF**). OpenFlow, as the name
    suggests, is used to control the flow of packets in a network layer through a
    mix of **Access Control Lists** (**ACLs**) and routing protocols.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFlow 是一种通信协议，用于在不同厂商的设备之间进行数据包流的通信。该标准由一个名为 **开放网络基金会** （**ONF**） 的团体维护。正如其名所示，OpenFlow
    通过结合 **访问控制列表** （**ACLs**） 和路由协议来控制网络层中数据包的流动。
- en: OpenFlow primarily has two components—controllers and switches. Controllers
    are used to take decisions in terms of creating a path for the packet to flow
    across the different connected devices, and switches (or network equipment) are
    dynamically configured from the controller based upon the path that a packet needs
    to take.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFlow 主要有两个组件——控制器和交换机。控制器用于在创建数据包在不同连接设备间流动的路径方面做出决策，而交换机（或网络设备）则根据数据包需要采取的路径从控制器动态配置。
- en: Going a little more in-depth, OpenFlow controllers control the routing of packets
    in OpenFlow switch forwarding tables through the modification, addition, or deletion
    of packet matching rules as decided by the controller.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 深入一点，OpenFlow 控制器通过修改、添加或删除控制器决定的数据包匹配规则来控制 OpenFlow 交换机转发表中的数据包路由。
- en: As OpenFlow is another protocol, it runs over TCP and works on port `6653` on
    controllers. At the time of writing, OpenFlow standard 1.4 is currently active
    and being widely used in the SDN framework. OpenFlow is an additional service
    that proprietary network vendors run alongside their custom software. This, in
    general, ensures that the data forwarding or data packet handling is still part
    of proprietary switch, but the data flow or control plane tasks is now taken over
    by OpenFlow controllers. As part of SDN framework, if a participating switch receives
    a packet and does not know where to send it, it communicates with the OpenFlow
    controller for an answer. The controller, based upon its preconfigured logic,
    decides what action to take for that unknown packet and can get switches that
    it is controlling to create a separate or a specific path for that packet to flow
    across the network. Because of this behavior, this is the protocol that is currently
    being deployed across all deployments where SDN is being introduced.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OpenFlow 是另一种协议，它运行在 TCP 上，并在控制器上工作于端口 `6653`。在撰写本文时，OpenFlow 标准版本 1.4 正在活跃并广泛用于
    SDN 框架中。OpenFlow 是专有网络厂商在其定制软件旁边运行的一项附加服务。通常，这确保了数据转发或数据包处理仍然是专有交换机的一部分，但数据流或控制平面任务现在由
    OpenFlow 控制器接管。作为 SDN 框架的一部分，如果一个参与交换机收到一个数据包但不知道该将其发送到哪里，它会与 OpenFlow 控制器通信以获得答案。控制器根据其预先配置的逻辑决定对该未知数据包采取什么行动，并可以指示其控制的交换机为该数据包创建一个单独的或特定的路径以在网络中流动。正因为这种行为，这是目前在所有引入
    SDN 的部署中正在部署的协议。
- en: Program concepts
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序概念
- en: Now, as we start working upon our practical approach to automation, we need
    to understand the basics of what a program is and how to write one.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们开始着手于我们的自动化实践方法时，我们需要了解程序的基本概念以及如何编写程序。
- en: Simply explained, a program is a set of instructions that is passed to the system
    to perform a specific task. This set of instructions is based upon real-life challenges
    and tasks that need to be accomplished in an automated method. Small sets of programs
    can be combined to create an application that can be installed, deployed, and
    configured for individual or organizational requirements. Some of the key concepts
    and programming techniques that we will discuss from this point onward will be
    PowerShell and Python. These are the two most popular scripting languages that
    are used to create quick, effective, and result-oriented automation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，程序是一组传递给系统以执行特定任务的指令。这组指令基于现实生活中的挑战和需要以自动化方式完成的任务。小批次的程序可以组合起来创建一个应用程序，该应用程序可以安装、部署和配置以满足个人或组织的需求。从现在开始，我们将讨论的一些关键概念和编程技术包括
    PowerShell 和 Python。这些是最受欢迎的脚本语言，用于创建快速、有效且结果导向的自动化。
- en: 'These are some of the key concepts that I would like to introduce while creating
    a program:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在创建程序时我想介绍的一些关键概念：
- en: Variables
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Data types
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Decision makers
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策者
- en: Loops
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: Arrays
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Functions
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Best practices
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Variables
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: These are predefined, human-readable, and understandable words or letters that
    are used to store some values. At the very basis of writing a program we need
    a variable in which we will store the data or information, and based upon the
    variables, we can further enhance the programming logic. As we can see in the
    first line, an important part of creating a variable is that it should be human-readable
    and understandable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是预定义的、可读的、可理解的单词或字母，用于存储一些值。在编写程序的基础中，我们需要一个变量来存储数据或信息，并且基于变量，我们可以进一步增强编程逻辑。正如我们可以在第一行看到的那样，创建变量的一个重要部分是它应该是可读的和可理解的。
- en: 'Let us take an example: Suppose I want to store a number `2` in a variable.
    We can choose any name for a variable and define it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子：假设我想将数字 `2` 存储在一个变量中。我们可以为变量选择任何名称并定义它：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The correct answer will be `Option 2`, as we know by the variable name (`number`)
    that this variable contains a specific number. As we can see in the preceding
    example, if we keep on using random ways of defining variables as we would when
    creating a big program, the complexity would be increased substantially because
    of the unclear meanings of the variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的答案将是 `选项 2`，因为我们通过变量名（`number`）知道这个变量包含一个特定的数字。正如先前的例子所示，如果我们继续以创建大型程序时的方式定义变量，由于变量的含义不明确，复杂性将会显著增加。
- en: Different programming languages have different ways to define a variable, but
    the underlying concept of ensuring a variable is human-readable should be the
    top-most priority of the programmer or program author.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言有不同的定义变量的方式，但确保变量可读性的基本概念应该是程序员或程序作者的优先考虑。
- en: Data types
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: As the name suggests, these are the classifications of the values that we pass
    on to the variable. A variable can be defined to store a specific type of value
    that can be declared based upon the data type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，这些是我们传递给变量的值的分类。一个变量可以被定义为存储特定类型的值，该值可以根据数据类型进行声明。
- en: 'There are multiple data types, but for our initial discussion there are primarily
    four data types that need to be understood:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种数据类型，但就我们最初的讨论而言，有四种主要的数据类型需要理解：
- en: '**String**: This is a catch-all data type. Any value defined as a string is
    as simple as saying the value is plain English with characters, alphabets, special
    characters, and so on. I have referred to it as a catch-all data type because
    nearly all other data types can be converted to string format keeping the same
    values intact during conversion to string.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：这是一个通用的数据类型。任何定义为字符串的值就像说这个值是纯英文，包含字符、字母、特殊字符等。我将其称为通用数据类型，因为几乎所有其他数据类型都可以转换为字符串格式，在转换为字符串的过程中保持相同的值。'
- en: 'Consider the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This defines that a variable named `number` has a value of `2`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为 `number` 的变量具有 `2` 的值。
- en: 'Similarly, if we declare:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果我们声明：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is same as saying that a value of `2` has been now defined as string and
    stored in a variable named `string_value`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于说，值 `2` 现在已定义为字符串，并存储在名为 `string_value` 的变量中。
- en: '**Integer**: This specifies that any value that is a number needs to be defined
    with this data type. The key thing to note here is that an integer value will
    contain a whole number and not a decimal value:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**：这指定了任何数值都需要用这种数据类型来定义。这里要注意的关键点是整数值将包含一个整数，而不是小数值：'
- en: 'Consider an example as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This defines that a variable named as `integernumber` has a value of the number
    `2`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为 `integernumber` 的变量具有数字 `2` 的值。
- en: 'An incorrect assignation here would be something like:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个错误赋值可能如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would give an error in some programming languages as an integer needs to
    be interpreted as a whole number and not a decimal value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些编程语言中，这会导致错误，因为整数需要被解释为整数，而不是小数值。
- en: '**Float**: This data type removes the restriction that we saw earlier with
    integer. It simply means we can have a decimal number and can perform mathematical
    calculations and storage of decimal values in a float data type.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**：这种数据类型消除了我们之前在整数中看到的限制。这意味着我们可以有一个小数，并且可以执行数学计算和在浮点数中存储小数值。'
- en: '**Datetime**: This is an extended data type found in a lot of modern scripting
    languages. This data type ensures that the values that are being stored or retrieved
    are in date format. This is typically useful if we need to create a program that
    uses some time or date calculations. As an example, perhaps we need to find out
    how many syslogs were generated from a router in the last seven days. The last
    seven days will be stored by this data type.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期时间**：这是在许多现代脚本语言中找到的一种扩展数据类型。这种数据类型确保存储或检索的值是以日期格式。如果我们需要创建一个使用一些时间或日期计算的程序，这通常非常有用。例如，我们可能需要找出在过去七天中由路由器生成的系统日志数量。最后七天将通过这种数据类型进行存储。'
- en: Decision makers
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决策者
- en: These are one of the very critical components of a program and they can define
    the flow of the program. As the name suggests, a decision maker decides a certain
    action based upon a certain condition.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是程序中非常关键的部分，它们可以定义程序的流程。正如其名所示，决策者根据某个条件决定采取某种行动。
- en: 'Simply put, if you wanted to buy an ice cream you would go to an ice-cream
    shop, but for a coffee you would go to a coffee shop. In this case, the condition
    was whether you wanted ice cream or coffee. The action was based upon the result
    of the condition: you went to that specific shop.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果你想买冰淇淋，你会去冰淇淋店，但如果你想喝咖啡，你会去咖啡店。在这种情况下，条件是你想买冰淇淋还是咖啡。行动是基于条件的结果的：你去了那个特定的商店。
- en: These decision makers, also called **conditions**, are defined in a different
    manner in different scripting languages, but the result of each of the conditions
    decides the future flow of the program.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决策者，也称为**条件**，在不同的脚本语言中以不同的方式定义，但每个条件的最终结果决定了程序的后续流程。
- en: Generally, in a condition, two or more values are compared and either a true
    or a false is returned. Depending on the value returned, a specific set of instructions
    are executed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在条件中，两个或多个值被比较，并返回真或假。根据返回的值，执行一组特定的指令。
- en: 'Consider the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we see in the preceding example, a condition is evaluated and if `2 is greater
    than 3`, then the flow of program will be performed based upon `Option 1`, and
    in case of a false (which means 2 is not greater than 3), `Option 2` would be
    chosen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个例子所示，一个条件被评估，如果`2大于3`，则程序流程将根据`选项1`执行，如果为假（这意味着2不大于3），则选择`选项2`。
- en: If we want a bit more complexity, we can add multiple decision-making statements
    or conditions to granulize the flow of a program.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更多的复杂性，我们可以添加多个决策语句或条件，以细化程序的流程。
- en: 'Let us take an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see in this complex condition, we can easily decide the flow of a
    program based upon additional checks. In this case, I only want to buy a `Car`
    that is `red`, `Automatic`, and a `sedan`. If any of those conditions are not
    met, then I ask the dealer to meet that specific condition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以看到这个复杂条件，我们可以很容易地根据额外的检查来决定程序的流程。在这种情况下，我只想要一辆`红色`、`自动`和`轿车`的`汽车`。如果这些条件中的任何一个不满足，那么我会要求经销商满足那个具体条件。
- en: Another thing to notice in the preceding example is that the conditions are
    nested within each other, hence they are shown as nested with spaces deciding
    the sub-conditions from its parent condition. This is usually depicted within
    brackets or with simple indentation based upon the scripting language used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子中，还有一个需要注意的事情是，条件彼此嵌套，因此它们被显示为通过空格嵌套，以决定子条件与其父条件。这通常在括号内或根据使用的脚本语言进行简单缩进来表示。
- en: Sometimes, it is necessary to evaluate a value against multiple conditions and
    perform an action if it matches any of the conditions. This is called a **switch
    case** in programming.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，有必要将一个值与多个条件进行比较，并在它匹配任何条件时执行一个动作。这在编程中称为**switch case**。
- en: 'Consider an example as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we see that depending upon the variable's value, a certain type of action
    can be performed. In this case, option 1 will be performed. If we change the value
    of the `Carcolor` variable to `Blue`, then option 2 will be performed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，根据变量的值，可以执行某种类型的动作。在这种情况下，将执行选项1。如果我们更改`Carcolor`变量的值为`蓝色`，则将执行选项2。
- en: An important component of conditions are the comparison operators that we use
    to compare two values for the result. Some example operators are equal to, greater
    than, less than, and not equal to. Depending on which comparison operator we use,
    the results can vary.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 条件的一个重要组成部分是比较运算符，我们使用它们来比较两个值以获得结果。一些示例运算符包括等于、大于、小于和不等。根据我们使用的比较运算符，结果可能会有所不同。
- en: 'Let us take an example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We declare two variables named `greaternumber` and `lessernumber` and compare
    them in a condition. The conditional operator we use is `greater than`, which
    would result in option 1 if the condition is true (`greaternumber` is greater
    than `lessernumber`), or would result in option 2 if the condition is false (`greaternumber`
    is not greater than `lessernumber`).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个名为`greaternumber`和`lessernumber`的变量，并在条件中比较它们。我们使用的条件运算符是`大于`，如果条件为真（`greaternumber`大于`lessernumber`），则结果为选项1，如果条件为假（`greaternumber`不大于`lessernumber`），则结果为选项2。
- en: Additionally, we also have operators that are called logical operators, such
    as `AND`, `OR`, or `NOT`. We can combine more than one condition by using these
    logical operators. They have a similar meaning in English, which means that if,
    for example, we use the `AND` operator, we want condition 1 `AND` condition 2
    both to be true before we perform an action.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有被称为逻辑运算符的运算符，如`AND`、`OR`或`NOT`。我们可以通过使用这些逻辑运算符来组合多个条件。它们在英语中有相似的意义，这意味着如果我们使用`AND`运算符，我们希望在执行动作之前，条件1和条件2都必须为真。
- en: 'Consider an example: I want to buy a car only when the `car` is `red`, `automatic`,
    and a `sedan`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子：我想在`car`是`red`、`automatic`和`sedan`的情况下才购买一辆车：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This simply means I would evaluate all the three conditions and only if all
    of them are true, then I would perform the action `buy car`. In this case, if
    any of the conditions do not meet the values, such as the car is blue, then the
    `do not buy` action will be performed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅意味着我会评估所有三个条件，并且只有当所有这些条件都为真时，我才会执行`buy car`动作。在这种情况下，如果任何条件不符合值，比如车是蓝色的，那么就会执行`do
    not buy`动作。
- en: Loops
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: A loop, as we know in common language, is circling the same path over and over
    again. In other words, if I am asked to fetch five ice creams from the ice cream
    store, and I can carry only one ice cream at a time, I will repeat the process
    of going to the ice cream shop to purchase ice cream five times. Correlating this
    with programming, if the same set of instructions need to be performed multiple
    times, then we put those instructions inside a loop.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们通常在日常生活中所知，循环就是一遍又一遍地重复相同的路径。换句话说，如果我被要求从冰淇淋店买五份冰淇淋，而我一次只能拿一份，我会重复去冰淇淋店购买冰淇淋五次的过程。将这一点与编程联系起来，如果需要多次执行相同的指令集，那么我们就将这些指令放在循环中。
- en: A very basic loop is generally depicted as an iteration of a variable as many
    times as we want the instructions to be carried out.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常基础的循环通常被描述为根据我们希望执行指令的次数来迭代一个变量的过程。
- en: 'Let''s take an example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you see the instructions being passed, there are three separate segments
    that are depicted in a loop:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到指令被传递，在循环中有三个独立的段落被描绘出来：
- en: '`Start the loop from one`: This means that the loop should start with a value
    of one.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`从1开始循环`：这意味着循环应该从1的值开始。'
- en: '`until the loop has been repeated sixty times`: This means perform the same
    set of tasks until the loop has completed sixty turns of execution.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`直到循环重复六十次`：这意味着执行相同的任务集，直到循环完成六十次执行。'
- en: '`adding a value of 1 to the loop`: This means that we dictate that after completion
    of each round of loop, increment the loop count by 1.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`在循环中添加1的值`：这意味着我们规定在每次循环完成之后，循环计数增加1。'
- en: The result will be the same action performed sixty times, until the loop count
    reaches sixty. Additionally, a loop can used to iterate through multiple values
    stored in a variable irrespective of whether it is an integer, string, or any
    other data type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是执行相同动作六十次，直到循环计数达到六十。此外，循环可以用来遍历存储在变量中的多个值，无论它是整数、字符串还是任何其他数据类型。
- en: Arrays
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array (or list in some scripting languages) is used to store a similar set
    of multiple values inside a single variable. This helps to ensure all data types
    with similar meanings are stored in a single variable, and also we can easily
    loop through these array objects to fetch the values stored in an array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数组（或在某些脚本语言中称为列表）用于在单个变量中存储相似的多组值。这有助于确保所有具有相似意义的类型数据都存储在单个变量中，并且我们可以轻松地遍历这些数组对象以获取存储在数组中的值。
- en: 'Consider the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see in the variable declaration, now we are declaring a similar data
    type with a similar context or meaning by grouping them together and assigning
    them into a single variable. In our example, it's the country names all assigned
    to an array variable named `countries`. In the next line, we are now iterating
    using the loop method, and for every `specific country` in the list or array of
    `countries`, we will perform the action. In this case, the loop will be executed
    to perform the action for each country, from the country name `India` to the end
    of the country name `UK`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在变量声明中可以看到的，现在我们通过将它们分组并分配给单个变量，以相似的数据类型和上下文或意义来声明。在我们的例子中，是将所有国家名称分配给一个名为`countries`的数组变量。在下一行，我们现在使用循环方法进行迭代，对于`countries`列表或数组中的每个`特定国家`，我们将执行操作。在这种情况下，循环将执行以对每个国家执行操作，从国家名称`India`到国家名称`UK`的末尾。
- en: Each value stored in an array is referred to as an element of the array. Additionally,
    an array can be easily sorted, which means irrespective of the order of the elements
    in the array, we can get a sorted list or array by calling some additional programming
    tasks.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在数组中的每个值都被称为数组的元素。此外，数组可以很容易地进行排序，这意味着无论数组中元素的顺序如何，我们都可以通过调用一些额外的编程任务来获取排序后的列表或数组。
- en: 'Let''s consider an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result will be as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The sort functionality ensured that all the elements inside the array are sorted
    alphabetically and stored in the sorted order.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 排序功能确保数组内部的所有元素都按字母顺序排序并按排序顺序存储。
- en: Functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions or methods are a pre-written small set of instructions that result
    in a specific task being performed when they are called. The functions can also
    be defined as a single name for a group of programming instructions written together
    to achieve a common task.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或方法是一组预先编写的指令，当它们被调用时，会执行特定的任务。函数也可以定义为完成共同任务的一组编程指令的单一名称。
- en: Taking an example, think of driving as a function. In driving, there are multiple
    things that need to be taken care of, such as understanding traffic signals, running
    a car, and driving the car in traffic and on the road.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以驾驶作为一个函数的例子来考虑。在驾驶中，有许多事情需要关注，比如理解交通信号、驾驶汽车以及在交通和道路上驾驶汽车。
- en: All these tasks are grouped in a function named `driving`. Now, let's say we
    have two people, example 1 and example 2, who want to learn to drive. From a programming
    perspective, once we define a function, we need to call it whenever we want to
    perform the same set of tasks. Hence, we would call `driving(example 1)` and then `driving
    (example 2)`, which would ensure that both people would become a driver after going
    through the set of instructions in the `driving` function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务都被分组在一个名为`driving`的函数中。现在，假设我们有两个想要学习驾驶的人，示例1和示例2。从编程的角度来看，一旦我们定义了一个函数，我们每次想要执行相同的一组任务时都需要调用它。因此，我们会调用`driving(example
    1)`然后调用`driving (example 2)`，这将确保这两个人在经过`driving`函数中的指令集后都会成为驾驶员。
- en: 'Let us look at another example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看一个示例：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the first line, we declare an array with country names as elements. Next,
    we define a function named `hellocountry` that accepts an input of `countryname`.
    In the function itself, we simply return the value of the `countryname` that was
    passed to the function as input, preceding by the work `hello`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们声明了一个包含国家名称作为元素的数组。接下来，我们定义了一个名为`hellocountry`的函数，它接受`countryname`作为输入。在函数本身中，我们简单地返回传递给函数作为输入的`countryname`的值，并在其前面加上“hello”这个词。
- en: Now all that remains is to iterate through all the elements of countries and
    pass each `countryname` as input to the `hellocountry` function. As we can see,
    we called the same function for each element, and based upon the instructions
    declared inside the function, that specific task was now performed for each element
    in the array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是遍历所有国家的元素，并将每个`countryname`作为输入传递给`hellocountry`函数。正如我们所看到的，我们对每个元素调用了相同的函数，根据函数内部声明的指令，现在为数组中的每个元素执行了特定任务。
- en: Best practices
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: As we have now looked at the basics of some of the key components of a program,
    there is another important aspect of how to write a good program that we will
    consider.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了程序一些关键组件的基础知识，那么我们还将考虑编写良好程序的一个重要方面。
- en: From a machine's perspective, there is no understanding of how a program is
    written, as long as the instructions given in the program are in the right format
    or syntax and the machine is able to interpret each of the instructions correctly.
    For an end user, again the way the program is written might not be important as
    long as the end user gets the desired result. The person concerned with how a
    program is written is a programmer who is writing their own program, or a programmer
    or developer who needs to interpret another programmer's program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从机器的角度来看，只要程序中给出的指令格式或语法正确，并且机器能够正确解释每条指令，那么程序是如何编写的就没有理解。对于最终用户来说，只要最终用户得到期望的结果，程序是如何编写的可能并不重要。关注程序编写方式的人是编写自己程序的程序员，或者需要解释其他程序员程序的程序员或开发者。
- en: There may be multiple reasons why a programmer might need to interpret a program
    that's not been written by them. It may be to support the program while the programmer
    who wrote the program is not available, or to enhance the program by adding their
    own piece of code or programming instructions. Another reason for code readability
    is fixing bugs. Any program or set of instructions may malfunction due to incorrect
    input or incorrect logic, which can result in unexpected behavior or unexpected
    results. This is called a bug, and bugs need to be fixed to ensure the program
    does what it was written for originally.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在多个原因，使得程序员需要解释他们没有编写的程序。可能是因为在编写程序的程序员不可用时支持该程序，或者通过添加自己的代码或编程指令来增强程序。代码可读性的另一个原因是修复错误。任何程序或指令集都可能由于输入错误或不正确的逻辑而出现故障，这可能导致意外的行为或结果。这被称为错误，需要修复以确保程序按照最初编写的方式运行。
- en: Every programmer has their own set of best practices, but some of the key aspects
    of a program are readability, support information, and indentation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员都有自己的最佳实践，但程序的一些关键方面是可读性、支持信息和缩进。
- en: Readability of a program
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序的可读性
- en: This is one of the most important aspects of writing a good program. A program
    needs to be written in such a way that even a layman or a first-time reader of
    the program should be able to interpret the basics of what is happening.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编写良好程序最重要的方面之一。程序需要以这种方式编写，即使是非专业人士或程序的第一位读者也应该能够理解正在发生的基本情况。
- en: 'Variables need to be declared properly so that each variable makes it clear
    what it stores:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 变量需要正确声明，以便每个变量都清楚地表明它存储的内容：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'could have been written better like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写成这样：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here''s another example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It could be written like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以写成这样：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see in the preceding example, if we write a two- or three-line program,
    we can easily declare the variables in a random way, but things become much more
    complex, even for a programmer writing their own program, when these random variables
    are used in a longer program. Just imagine if you have declared the variables
    as `a`, `b`, `c`, and so on, and later, after using even 10 or 15 more variables,
    you need to go back to each line of the program to understand what value was declared
    in `a`, `b`, or `c`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，如果我们编写一个两行或三行的程序，我们可以很容易地以随机方式声明变量，但当这些随机变量在更长的程序中使用时，即使是编写自己程序的程序员，事情也会变得复杂得多。想象一下，如果你已经将变量声明为`a`、`b`、`c`等，然后在使用了10个或15个更多变量之后，你需要回到程序的每一行来理解`a`、`b`或`c`中声明了什么值。
- en: Another aspect of writing a good program is commenting. Different scripting
    languages provide different ways of commenting a program. Comments are necessary
    to ensure we break the flow of each program into sections, with each section having
    a comment explaining the use of that section. A very good example is if you declare
    a function. A function named `Cooking`, for example, and another function named
    `CookingPractice` might sound confusing because of their names. Now, if we add
    a comment to the `Cooking` method saying *this function is to master the art of
    cooking when you have learned how to cook*, and add a comment to `CookingPractice`
    saying *this method is to learn cooking*, this can make things very easy for someone
    reading through the program.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好程序的一个方面是注释。不同的脚本语言提供了不同的注释程序的方式。注释是必要的，以确保我们将每个程序分解为部分，每个部分都有一个注释解释该部分的使用。一个非常好的例子是如果你声明一个函数。例如，一个名为`Cooking`的函数和另一个名为`CookingPractice`的函数可能因为它们的名称而令人困惑。现在，如果我们对`Cooking`方法添加注释说“这个函数是在你学会了如何烹饪后掌握烹饪艺术”，并对`CookingPractice`添加注释说“这个方法是为了学习烹饪”，这可以使阅读程序的人更容易理解。
- en: A programmer now can easily interpret that whenever he wants to learn to cook,
    he has to call `CookingPractice` and not the `Cooking` method. Comments don't
    have any special meaning in any programming language, and they are ignored when
    the machine is trying to convert the programming language to machine instructions.
    Hence, comments are only for programmers and to make readers aware of what is
    happening in a program. A comment should also be placed with every complex condition,
    loop, and so on, to clarify the usage of that specific condition or loop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序员可以轻松理解，当他想学习烹饪时，他必须调用`CookingPractice`而不是`Cooking`方法。注释在任何编程语言中都没有特殊含义，当机器试图将编程语言转换为机器指令时，它们会被忽略。因此，注释仅针对程序员，并让读者了解程序中的情况。每个复杂的条件、循环等也应该放置注释，以阐明该特定条件或循环的使用。
- en: Support information
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持信息
- en: This, as the name suggests, is additional information, preferably added as comments,
    containing details about the program and author. As a suggestion, at the minimum
    a program should have the author info (that is, the person who created the program),
    contact details such as phone number and email address, basic usage of the program
    or the purpose of the program, and the version of the program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这是附加信息，最好以注释的形式添加，包含有关程序和作者的信息。建议至少一个程序应包含作者信息（即创建程序的人）、联系电话和电子邮件地址、程序的基本使用或程序的目的以及程序的版本。
- en: The version is specific such as starting from 1.0 and as and when we enhance
    the program or add new features, we can change it to version 1.1 (for minor changes)
    or a newer version such as version 2.0 (for major changes).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号是特定的，例如从1.0开始，随着我们增强程序或添加新功能，我们可以将其更改为1.1版本（用于小改动）或更新的版本，如2.0版本（用于重大更改）。
- en: 'Consider an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This approach ensures that everyone knows which is the latest version of the
    script and how to execute the program or script. Also, this has info about the
    contact details of the author, so if anything breaks in production, the author
    can be easily reached to rectify or fix the scripts in production.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保每个人都知道脚本的最新版本以及如何执行程序或脚本。此外，这里还包含作者的联系方式，如果生产过程中出现任何问题，作者可以轻松地被联系以纠正或修复生产中的脚本。
- en: Indentation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩进
- en: This is similar to what we do when we write in plain English. Indenting a program
    is mandatory in some scripting languages, but as a best practice it should be
    followed for any program that we write in any programming language. Indentation
    improves the readability of a program because it helps the programmer or someone
    else reading the program to quickly understand the flow of the program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们用普通英语写作时所做的类似。在某些脚本语言中，缩进是强制性的，但作为最佳实践，我们应该遵循任何编程语言中编写的任何程序。缩进可以提高程序的可读性，因为它有助于程序员或阅读程序的其他人快速理解程序的流程。
- en: Let's see an example where we have a nested condition in which we check if a
    `Car` is `Red` and if it is a `Sedan` and if it is `Automatic`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，其中我们有一个嵌套条件，检查一辆`Car`是否是`Red`，是否是`Sedan`，以及是否是`Automatic`。
- en: 'A bad way of writing this would be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 写得不好的方式可能是如下所示：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, think of adding multiple lines like this to a long program, and you will
    get easily confused by the flow of program as you read through it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下将多行代码添加到长程序中，当你阅读时，程序流程会让你容易感到困惑。
- en: 'A better and recommended way to write this is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更好且推荐的做法如下：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This provides a clear flow of the program. Only check the other conditions if
    the `Car` is `Red`; otherwise, don't check for the other conditions. This is where
    we say we are nesting the conditions inside each other, which is also called **nested
    conditions**.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了程序清晰的流程。只有当`Car`是`Red`时，才检查其他条件；否则，不要检查其他条件。这就是我们所说的条件嵌套，也称为**嵌套条件**。
- en: This also clears a lot of confusion while troubleshooting a complex program.
    We can easily identify the problematic code or instructions by quickly parsing
    through the program and understanding the flow for each segment of the program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这在调试复杂程序时也消除了很多困惑。我们可以通过快速解析程序并理解每个程序段的流程，轻松地识别出有问题的代码或指令。
- en: Sample best practice example
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样本最佳实践示例
- en: This example summarizes the best practices using all the elements that we have
    learned so far, by creating a basic program.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例通过创建一个基本程序，总结了迄今为止我们所学到的所有最佳实践。
- en: '**Problem statement**: Parse all the countries declared in an array and only
    print the names of those countries that contain the letter `I` or letter `U` in
    their names:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题陈述**：解析数组中声明的所有国家，并只打印那些名称中包含字母`I`或字母`U`的国家：'
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The program is self-explanatory, but it is worth noting the support comments
    such as author, email, and so on. The indentation ensures that any reader has
    a clear idea of the flow of program.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是自我解释的，但值得注意的是支持注释，如作者、电子邮件等。缩进确保任何读者都能清楚地了解程序的流程。
- en: Additionally, another thing to observe is the use of names that clearly depict
    the usage of the variable or name. Each variable and function name clearly specifies
    what it is being used for. The additional comment lines in between add clarity
    on what each segment is doing and the purpose of the statement or function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个需要注意的事情是使用清楚地描述变量或名称用途的名称。每个变量和函数名称都清楚地说明了它的用途。中间的附加注释行增加了对每个段做什么以及语句或函数目的的清晰度。
- en: Language choices (Python/PowerShell)
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言选择（Python/PowerShell）
- en: Moving ahead, armed with the knowledge of how to write a program and an understanding
    best practices, we will now look at some scripting languages that suffice for
    our automation scripts. A basic difference between a scripting language and a
    programming language (such as C and C++) is that a scripting language is not compiled
    but interpreted through the underlying environment in which it is executed (in
    other words, a converter is required to convert the commands written in human-readable
    format to machine format by parsing one line at a time), whereas the programming
    language is primarily compiled and hence can be executed in multiple environments
    without the use of any specific underlying environment or requirements.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前进，掌握了编写程序和理解最佳实践的知识，我们现在将探讨一些适合我们自动化脚本的脚本语言。脚本语言和编程语言（如C和C++）之间的基本区别在于，脚本语言不是编译的，而是通过它执行的底层环境进行解释（换句话说，需要一个转换器将人类可读格式的命令转换为机器格式，一次解析一行），而编程语言主要是编译的，因此可以在多个环境中执行，而无需使用任何特定的底层环境或要求。
- en: What this means is if I write a script in Python, PowerShell, or even Perl,
    I need to install that specific language in order to run the program or script
    that I have written. C or C++ code can be compiled to make an executable file
    (`.exe`) , and can run independently without the installation of any language.
    Additionally, a scripting language is less code-intensive, which means that it
    can automatically interpret some of the code written in a program depending on
    how it is called.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我用Python、PowerShell或甚至Perl编写脚本，我需要安装那种特定的语言才能运行我编写的程序。C或C++代码可以编译成可执行文件（`.exe`），可以独立运行，无需安装任何语言。此外，脚本语言代码密集度较低，这意味着它可以自动解释程序中的一些代码，具体取决于如何调用。
- en: 'Let''s consider an example. Here''s how we declare a variable in scripting
    language:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。以下是我们在脚本语言中声明变量的方式：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: OR
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: OR
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: OR
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: OR
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Whereas in a programming language, the same type of declaration would be made
    like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 而在编程语言中，声明的方式可能是这样的：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This states that depending on the value we assign to the variable, the variable
    type is automatically identified in an scripting language, whereas in a programming
    language the declarations are tightly controlled. In this case, if we declare
    a variable as a `String`, this clearly means that we cannot declare any other
    type of value in that variable unless we explicitly change the data type of that
    variable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示，根据我们分配给变量的值，脚本语言中会自动识别变量类型，而在编程语言中，声明是严格控制的。在这种情况下，如果我们声明一个变量为 `String`
    类型，这清楚地意味着除非我们明确更改该变量的数据类型，否则我们不能在该变量中声明任何其他类型的值。
- en: We have primarily three types of scripting language that are popular for creating
    programs and are mainly used for automation scripting or programming. These are
    Perl, Python, and PowerShell.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要使用三种类型的脚本语言来创建程序，这些语言主要用于自动化脚本或编程。这些是 Perl、Python 和 PowerShell。
- en: With support for the oldest language, Perl, diminishing, the focus is now on
    Python because of its open source support and on PowerShell because of its Microsoft,
    or .NET environment. Comparing both languages is not ideal because it's up to
    the reader which programming language they use to write their programs. As we
    have more than 70% of computers running Windows, and with a growing market of
    Microsoft Azure as a cloud operating system from Microsoft, PowerShell is the
    preferred language owing to the underlying .NET environment. As we create a program
    in PowerShell, it is easy to port that program and execute it on another machine
    running Windows without any special settings.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Perl 这种最古老的语言的支持减少，现在的焦点转向了 Python，因为它具有开源支持，以及 PowerShell，因为它具有微软或 .NET
    环境。比较这两种语言并不理想，因为读者可以根据自己的喜好选择使用哪种编程语言来编写程序。由于我们超过 70% 的计算机运行 Windows，并且随着微软 Azure
    作为微软的云操作系统市场的增长，PowerShell 由于其底层的 .NET 环境而成为首选语言。在我们用 PowerShell 创建程序时，很容易将该程序移植到运行
    Windows 的另一台机器上并执行，而无需任何特殊设置。
- en: Python, on the other hand, is growing in popularity because of its open source
    approach. There are thousands of developers who contribute to enhancing Python
    by adding special functions for specific tasks. For example, there is a function
    or sub-program, called `Paramiko`, that is used to log into network routers. Another
    one is `Netmiko`, which is an enhanced version of `Paramiko` that is used to log
    into network devices based upon network hardware vendor and operating systems
    (such as Cisco iOS or Cisco NXOS). Python needs to be installed before writing
    a Python program and successfully executing it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Python 由于其开源方法而越来越受欢迎。有成千上万的开发者通过添加特定任务的特殊功能来增强 Python。例如，有一个名为 `Paramiko`
    的函数或子程序，用于登录网络路由器。另一个是 `Netmiko`，它是 `Paramiko` 的增强版本，用于根据网络硬件供应商和操作系统（如 Cisco
    iOS 或 Cisco NXOS）登录网络设备。在编写并成功执行 Python 程序之前，需要安装 Python。
- en: Going forward, our focus will be on Python, with additional tips and tricks
    on how to perform the same tasks using PowerShell instead of Python.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 今后，我们的重点将是 Python，同时还会提供一些额外的技巧和窍门，介绍如何使用 PowerShell 而不是 Python 来执行相同的任务。
- en: Writing your first program
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个程序
- en: Now, because we are starting from fresh, we need to understand how to write
    our first program and execute it. PowerShell comes pre-installed on a Windows
    machine. But we need to install Python by downloading it from the web ( [https://www.python.org](https://www.python.org))
    and choosing the right version for your operating system. Once downloaded, it
    can installed just like any other application that is installed on a Windows machine.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们是从零开始，我们需要了解如何编写我们的第一个程序并执行它。PowerShell 预装在 Windows 机器上。但我们需要从网上（[https://www.python.org](https://www.python.org)）下载
    Python 并选择适合您操作系统的正确版本。下载后，它可以像在 Windows 机器上安装任何其他应用程序一样安装。
- en: On a Linux machine, the same holds true, but because of the .NET requirement,
    PowerShell will not be supported on Linux or Unix environments. Hence, if we are
    using a Unix or Linux environment, Python or Perl remain our preferences for scripting.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 机器上，情况也是如此，但由于 .NET 的要求，PowerShell 不会在 Linux 或 Unix 环境中得到支持。因此，如果我们使用
    Unix 或 Linux 环境，Python 或 Perl 仍然是我们的首选脚本语言。
- en: There are multiple **Integrated Development Environments** (**IDEs**) for both
    Python and PowerShell, but the default ones that come with these languages are
    also pretty helpful.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 和 PowerShell 都有多种 **集成开发环境**（**IDEs**），但这些语言自带的一些默认 IDE 也相当有帮助。
- en: There are multiple versions of PowerShell and Python being used. When writing
    programs in higher versions, generally the backwards support is not very good,
    so make sure you note the users and environment before choosing a version.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正在使用多个版本的PowerShell和Python。当在更高版本中编写程序时，通常向后兼容性不是很好，所以在选择版本之前请确保注意用户和环境。
- en: In our case, we will be using PowerShell 4 and Python 3 onwards for writing
    programs. Some commands might not run in older versions of PowerShell and Python,
    and some syntax or commands are different in older versions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将使用PowerShell 4和Python 3及以上版本来编写程序。一些命令可能在PowerShell和Python的旧版本中无法运行，并且一些语法或命令在旧版本中是不同的。
- en: PowerShell IDE
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell IDE
- en: 'This can be invoked by clicking on the Start button and searching for Windows
    PowerShell ISE. Once invoked, the initial screen will look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过点击开始按钮并搜索Windows PowerShell ISE来调用。一旦调用，初始屏幕将看起来像这样：
- en: '![](img/d1a7035f-9242-44f9-8f32-39a7cf7aeec0.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1a7035f-9242-44f9-8f32-39a7cf7aeec0.png)'
- en: As we can see in the preceding screenshot, a PowerShell script is saved with
    a `.ps1` extension. Once we write something in the IDE (or ISE, as it is called
    with PowerShell), it needs to be saved as `somefilename.ps1` and then executed
    to see the result.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，PowerShell脚本以`.ps1`扩展名保存。一旦我们在IDE（或称为PowerShell的ISE）中编写了一些内容，它需要保存为`somefilename.ps1`然后执行以查看结果。
- en: 'Let''s take write a program called `Hello World`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为`Hello World`的程序：
- en: '![](img/21bda357-98b9-467a-b13b-369d81b66560.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21bda357-98b9-467a-b13b-369d81b66560.png)'
- en: As we can see in our first program, we write two lines to print `Hello World`.
    In the ISE, we pass the commands to declare a variable (a variable is denoted
    by a dollar sign, `$`, in front of the variable in PowerShell), assigning the
    value `Hello World` to it. The next line is simply printing that variable by calling
    a method or function called `Write-host`, which is used to print values onscreen
    in PowerShell.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们可以在我们的第一个程序中看到，我们写入两行来打印`Hello World`。在ISE中，我们通过传递命令来声明一个变量（在PowerShell中，变量通过在变量前加美元符号`$`来表示），将值`Hello
    World`赋给它。下一行是简单地通过调用一个名为`Write-host`的方法或函数来打印这个变量，这个方法或函数用于在PowerShell中屏幕上打印值。
- en: Once we write the program and save it, the next step is execution to see our
    result.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们编写了程序并保存，下一步就是执行以查看我们的结果。
- en: The green button at the top of the ISE is used to execute the script, and the
    result of the script is shown at the bottom of the screen. In this case, it was
    a simple `Hello World` output.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISE顶部的绿色按钮用于执行脚本，脚本的结果显示在屏幕底部。在这种情况下，它是一个简单的`Hello World`输出。
- en: PowerShell scripts can also be invoked directly by the command line. As PowerShell
    is a scripting language and needs to be installed on a machine, we can directly
    call PowerShell from the Windows Command Prompt and execute the scripts and individual
    scripting commands from the PowerShell console itself.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell脚本也可以通过命令行直接调用。由于PowerShell是一种脚本语言并且需要在机器上安装，我们可以直接从Windows命令提示符调用PowerShell并从PowerShell控制台本身执行脚本和单个脚本命令。
- en: 'This is how we can find out the version of PowerShell:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何找出PowerShell的版本：
- en: '![](img/ea716274-b6ba-498c-83e4-088d366fc97a.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea716274-b6ba-498c-83e4-088d366fc97a.jpg)'
- en: As we can see in the preceding screenshot, PowerShell is invoked by calling
    `powershell` directly from the Command Prompt in Windows. When PowerShell is invoked,
    we see `PS` before the command line, which confirms that we are now inside the
    PowerShell console. To see the version, we call a system variable, `$psversiontable`,
    which shows the version of PowerShell.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，PowerShell是通过在Windows的命令提示符中直接调用`powershell`来调用的。当PowerShell被调用时，我们在命令行前看到`PS`，这确认我们现在在PowerShell控制台中。要查看版本，我们调用系统变量`$psversiontable`，它显示了PowerShell的版本。
- en: We can see that this is version 2.x (as shown in `CLRVersion`). System variables
    are special variables that have predefined values based upon the installation
    types. These special variables can be called at any time in our script to fetch
    their values and perform actions based upon the returned values.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这是2.x版本（如`CLRVersion`所示）。系统变量是具有基于安装类型的预定义值的特殊变量。这些特殊变量可以在我们的脚本中的任何时候调用以获取它们的值并基于返回值执行操作。
- en: 'The following example shows that we are using a higher version of PowerShell:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示我们正在使用PowerShell的更高版本：
- en: '![](img/96264fc8-0d2f-4604-abac-e055973e8d4e.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96264fc8-0d2f-4604-abac-e055973e8d4e.png)'
- en: As we can see, the same variable now returns a value of `4.0` for `PSVersion`,
    which confirms that this is version 4 of PowerShell.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，相同的变量现在为`PSVersion`返回值为`4.0`，这证实了这是PowerShell的4版本。
- en: PowerShell 4.0 is the default installation from Windows 8.1 onwards on client
    operating system, and Windows Server 2012 R2 in a Server environment.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 4.0是从Windows 8.1开始作为客户端操作系统的默认安装，在服务器环境中是Windows Server 2012 R2。
- en: Python IDE
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python IDE
- en: 'Similar to PowerShell, once Python is installed, it has its own IDE. It can
    be invoked by typing or calling IDLE (Python) from the Start menu:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与PowerShell类似，一旦安装了Python，它就有自己的IDE。可以通过在开始菜单中键入或调用IDLE（Python）来调用它：
- en: '![](img/95cb7e12-4d10-416f-ba20-587f04267ced.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95cb7e12-4d10-416f-ba20-587f04267ced.png)'
- en: The Python IDE, called IDLE, looks similar to the preceding screenshot when
    it is opened. The heading bar depicts the version of Python (which is 3.6.1 in
    this case) and the three greater than signs (`>>>`) show the command line, which
    is ready to accept Python commands and execute them. To write a program, we click
    on File | New File, which opens up a notepad in which we can write the program.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开时，Python IDE，称为IDLE，看起来与前面的截图相似。标题栏显示了Python的版本（在这个例子中是3.6.1）和三个大于号（`>>>`）显示了命令行，它已准备好接受Python命令并执行它们。要编写程序，我们点击文件
    | 新建文件，这将在记事本中打开，我们可以在这里编写程序。
- en: 'Lets see a similar `hello world` program in Python:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Python中的类似`hello world`程序：
- en: '![](img/93c44d8c-760b-4553-80c9-0521f62b3b4d.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93c44d8c-760b-4553-80c9-0521f62b3b4d.png)'
- en: As we write a new program, the variable used is `newvalue`, and the value assigned
    to it is `hello world`. The next line is simply calling Python's `print` function
    to print the value inside the variable during the execution of the script.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个新的程序时，所使用的变量是`newvalue`，分配给它的值是`hello world`。下一行仅仅是调用Python的`print`函数来在脚本执行期间打印变量内的值。
- en: Once we have written the program, we click on File | Save As in the window where
    we wrote the program, and save the script. The script is saved as `filename.py`,
    with the `.py` extension denoting a Python script. Once it is saved, we can press
    the *F5* button on the keyboard or select Run | Run Module in the script window
    to run that specific script. The following window is the same window that was
    invoked when we first called the IDLE application from the Start menu, but now
    it has the output of that script that we wrote.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了程序，我们就在编写程序的窗口中点击文件 | 另存为，并将脚本保存。脚本以`filename.py`保存，其中`.py`扩展名表示Python脚本。一旦保存，我们可以在键盘上按*F5*按钮或在脚本窗口中选择运行
    | 运行模块来运行该特定脚本。以下窗口是我们第一次从开始菜单调用IDLE应用程序时调用的同一窗口，但现在它有我们编写的脚本的输出。
- en: The output of `hello world` is now seen in the IDLE window. Once we are done
    with writing the script or Python commands, we can simply close the open command
    windows to close the application or Python interpreter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello world`的输出现在在IDLE窗口中可见。一旦我们完成了编写脚本或Python命令，我们只需简单地关闭打开的命令窗口来关闭应用程序或Python解释器。'
- en: 'Similar to PowerShell, we can also call `python` from the command line, as
    follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与PowerShell类似，我们也可以从命令行调用`python`，如下所示：
- en: '![](img/614c3cd1-b421-4f36-b1dd-58370f83faae.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/614c3cd1-b421-4f36-b1dd-58370f83faae.png)'
- en: One additional thing to notice here is that to exit the Python interpreter,
    we call the `exit()` function. This tells Python to stop the execution and exit
    to the Command Prompt in Windows.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个需要注意的额外事项是，要退出Python解释器，我们调用`exit()`函数。这告诉Python停止执行并退出到Windows的命令提示符。
- en: Representational State Transfer (REST) framework
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表征状态转移（REST）框架
- en: One of the most important aspects of network automation is to understand and
    leverage tools that are currently available for specific tasks. For example, this
    could be Splunk for data mining, SolarWinds for network monitoring, syslog servers,
    or even any custom applications to perform various tasks.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化最重要的方面之一是理解和利用目前可用于特定任务的工具。例如，这可能是用于数据挖掘的Splunk，用于网络监控的SolarWinds，syslog服务器，或者任何用于执行各种任务的定制应用程序。
- en: Another important aspect of writing an application is how we can utilize the
    same application for additional tasks without altering the application itself.
    In other words, let's say we buy a car for our personal use, but an enhancement
    of this would be using the same car as a taxi or in some other role.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 编写应用程序的另一个重要方面是如何在不更改应用程序本身的情况下利用同一应用程序执行额外任务。换句话说，假设我们为了个人使用买了一辆汽车，但这个增强功能是使用同一辆车作为出租车或扮演其他角色。
- en: This is we introduce the **Application Program Interface** **(API**). APIs are
    used to expose some aspect of an already written application to merge with the
    programs that we are writing so that we can easily call that specific task using
    a specific API. For example, as SolarWinds is a specialized application that is
    used for network monitoring and other purposes, we can call the API of SolarWinds
    to get the network device list in our script. Hence, we leave the specialized
    task of discovering the network devices on the network to SolarWinds, but we utilize
    its expertise in our script through the API of that application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们介绍 **应用程序编程接口** **(API**)。APIs 用于暴露已编写应用程序的一些方面，以便与我们所编写的程序合并，这样我们就可以通过特定的
    API 轻松调用特定的任务。例如，由于 SolarWinds 是一种用于网络监控和其他目的的专业应用程序，我们可以通过 SolarWinds 的 API 在我们的脚本中获取网络设备列表。因此，我们将发现网络设备的专门任务留给
    SolarWinds，但通过该应用程序的 API 在我们的脚本中利用其专业知识。
- en: Getting a bit deeper, the API is nothing more than a function (similar to the
    functions that we write in our scripts); the only difference is what values those
    functions return. An API function generally returns the values in **Extended Markup
    Language (XML**) or **JavaScript Object Notation **(**JSON**) format, which are
    industry standards of cross-environment and cross-machine information exchange.
    Think of this as similar to how we communicate with each other using English as
    a common language. Although we may have been born in different cultures, in different
    countries, we can use English to communicate with each other effectively, since
    English is the industry standard of human interaction. Similarly, irrespective
    of how a program is written, in whatever language (such as C, C++, Java, VB, C#,
    and so on), each program can talk to another program by calling its APIs and the
    results come in either XML or JSON.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 深入一点，API 仅仅是一个函数（类似于我们在脚本中编写的函数）；唯一的区别是这些函数返回的值。API 函数通常以 **扩展标记语言 (XML**) 或
    **JavaScript 对象表示法 (JSON**) 格式返回值，这些是跨环境和跨机器信息交换的行业标准。想象一下，这就像我们使用英语作为通用语言进行交流一样。尽管我们可能出生在不同的文化、不同的国家，但我们可以使用英语有效地进行交流，因为英语是人际互动的行业标准。同样，无论程序是用什么语言编写的（例如
    C、C++、Java、VB、C# 等），每个程序都可以通过调用其 API 与另一个程序进行通信，结果以 XML 或 JSON 格式返回。
- en: XML is a standard way of encoding results and sending them across to the requestor
    and, using the same standard, the requestor can decode the results. JSON is another
    way in which data interactions can happen across applications.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: XML 是一种标准的编码方式，用于将结果发送给请求者，并且使用相同的标准，请求者可以解码这些结果。JSON 是另一种数据交互可以在应用程序之间发生的方式。
- en: 'Here is sample XML:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例 XML：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first line in the preceding content depicts that whatever follows after
    that line is in XML format. The XML files are saved with extension of `.xml`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容的第一行表明，该行之后的内容是以 XML 格式。XML 文件以 `.xml` 扩展名保存。
- en: Now as we can see, if we count the number of characters returned from an XML
    result, if we add the characters, such as `<heading>Reminder</heading>`, it returns
    results within the starting tag and ending tag of `<heading>`. This means that
    the size of an XML file is greatly increased owing to the overhead character counts
    of additional closing tags.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，如果我们计算从 XML 结果返回的字符数，如果我们加上像 `<heading>Reminder</heading>` 这样的字符，它返回的结果在
    `<heading>` 的起始标签和结束标签之间。这意味着由于额外的关闭标签的字符计数开销，XML 文件的大小大大增加。
- en: 'Here''s the same example in JSON:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相同的示例以 JSON 格式呈现：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, we have got rid of those extra bulky opening and closing tags
    that we saw earlier in XML. What this means is if we are calling an API to return
    a huge amount of data in XML format, it would certainly take a longer time to
    fetch that data from the application and more consumption of resources such as
    memory and storage to temporarily or permanently store that data. To overcome
    this situation, the JSON format is now preferred to XML to exchange data through
    APIs. JSON is lightweight and less resource-intensive than XML because of differences
    in the way the data is returned. JSON files are saved with the extension `.json`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们已经摆脱了之前在 XML 中看到的那些额外的庞大开标签和闭标签。这意味着，如果我们调用 API 以 XML 格式返回大量数据，那么从应用程序获取这些数据肯定需要更长的时间，并且需要更多资源（如内存和存储）来临时或永久存储这些数据。为了克服这种情况，现在更倾向于使用
    JSON 格式而不是 XML 通过 API 交换数据。由于数据返回方式的不同，JSON 相比 XML 轻量级且资源消耗较少。JSON 文件以 `.json`
    扩展名保存。
- en: This functionality of working with APIs, back end methods, and functions written
    in a particular programming language to be called APIs, and functions returning
    values in XML or JSON format, all of which is running over web protocols such
    as HTTP or HTTPS, is cumulatively called the REST framework. The REST framework
    is the same industry standard of interacting using XML or JSON that were referenced
    earlier, with the addition of GET, POST, and other interactions happening over
    the web protocols. The HTTP requests to APIs can be GET or POST requests that
    the REST framework recognizes and, similar to HTTP GET and POST requests, interacts
    with underlying applications to perform the requested actions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种与 API、后端方法和特定编程语言编写的函数（称为 API）以及返回 XML 或 JSON 格式值的函数一起工作的功能，所有这些都在 HTTP 或
    HTTPS 等网络协议上运行，统称为 REST 框架。REST 框架是之前提到的使用 XML 或 JSON 进行交互的行业标准，增加了通过网络协议（如 GET、POST
    等）发生的交互。API 的 HTTP 请求可以是 REST 框架识别的 GET 或 POST 请求，类似于 HTTP GET 和 POST 请求，与底层应用程序交互以执行请求的操作。
- en: Scripting languages rely heavily on API calls, and applications that need to
    provide the API's functionality adhere to REST framework requirements to ensure
    they extend their capabilities to the scripts that are called to fetch or save
    data in their choice of scripting language. A big benefit of this is that cross-platform
    communication is now happening with neither party (the caller of API or the application
    providing the API's functionality) knowing which language or environment the other
    are running. Hence, a Windows application can easily work with a Unix environment
    and vice versa using this approach, with HTTP being the standard communication
    language for calling APIs, and parsing the results with industry standard XML
    or JSON formats.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本语言严重依赖于 API 调用，需要提供 API 功能的应用程序必须遵守 REST 框架的要求，以确保它们能够扩展其功能，以便调用脚本以获取或保存数据。这种做法的一个重大好处是，现在跨平台通信正在发生，双方（API
    的调用者或提供 API 功能的应用程序）都不知道对方正在运行哪种语言或环境。因此，Windows 应用程序可以轻松地与 Unix 环境协同工作，反之亦然，使用这种方法，HTTP
    是调用 API 的标准通信语言，并使用行业标准 XML 或 JSON 格式解析结果。
- en: 'The sample API REST call in PowerShell is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 中的示例 API REST 调用如下：
- en: '![](img/d2d3cee2-70b2-48c9-8c5f-820d658ae9f9.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2d3cee2-70b2-48c9-8c5f-820d658ae9f9.jpg)'
- en: As we can see in the preceding screenshot, we call the `Invoke-RestMethod` function in
    PowerShell, which is used to call the API method of the application with the default
    communication and interactions using JSON.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，我们在 PowerShell 中调用 `Invoke-RestMethod` 函数，该函数用于使用默认的通信和交互方式通过 JSON
    调用应用程序的 API 方法。
- en: The application called is in a REST framework, with access to the API with the
    URL [https://blogs.msdn.microsoft.com/powershell/feed/](https://blogs.msdn.microsoft.com/powershell/feed/).
    This uses the HTTPS protocol to communicate with the application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的应用程序位于 REST 框架中，可以通过 URL [https://blogs.msdn.microsoft.com/powershell/feed/](https://blogs.msdn.microsoft.com/powershell/feed/)
    访问 API。这使用 HTTPS 协议与应用程序进行通信。
- en: '`format-table` is a function of PowerShell that specifies that however the
    result comes, display the `title` property of each record/result returned from
    the API call. If we had not used that command, the display would have shown all
    the properties returned for each record.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`format-table` 是 PowerShell 中的一个函数，它指定无论结果如何，都显示从 API 调用返回的每个记录/结果的 `title`
    属性。如果我们没有使用该命令，显示将显示每个记录返回的所有属性。'
- en: 'Here''s an example REST call in Python:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 Python 中的示例 REST 调用：
- en: '![](img/e88588d2-a7cf-4a0d-8cd4-11737c69c46b.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e88588d2-a7cf-4a0d-8cd4-11737c69c46b.png)'
- en: In this example, we call a standard function called `requests`. The first line,
    `import requests`, means that we are referencing the `requests` function or library
    to call in our Python script. On the next line, we are calling the Google Map
    API with JSON using a `requests.get` method. In other words, we are ensuring a
    HTTP GET call to the Google API URL. Once we get the result, we call the `json()`
    method to store the value in the variable `r`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们调用一个名为 `requests` 的标准函数。第一行 `import requests` 表示我们在 Python 脚本中引用了 `requests`
    函数或库。在下一行，我们使用 `requests.get` 方法通过 JSON 调用 Google Map API。换句话说，我们确保对 Google API
    URL 进行 HTTP GET 调用。一旦我们得到结果，我们调用 `json()` 方法将值存储在变量 `r` 中。
- en: Sometimes, when we call a custom function or library of Python using `import`,
    it may give an error stating that the module has not been found. This means that
    it does not come with the standard Python installation and needs to be installed
    separately. To fix this, we can install the module manually using the `pip` or
    `easy_install` commands, which we will see in detail in upcoming chapters.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当我们使用`import`调用Python的自定义函数或库时，可能会出现一个错误，表明找不到该模块。这意味着它不包括在标准的Python安装中，需要单独安装。为了解决这个问题，我们可以使用`pip`或`easy_install`命令手动安装模块，这些内容我们将在接下来的章节中详细讨论。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of various terminology that we will use
    while performing network automation. This chapter also introduced the readers
    to some basic aspects of programming to help build the logic of a program.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了我们在执行网络自动化时将使用的各种术语的基础知识。本章还向读者介绍了编程的一些基本方面，以帮助构建程序的逻辑。
- en: This chapter also explained why to write a good program and how to write one,
    along with some reference points for scripting languages. There was also a brief
    discussion about the current scripting languages, their basic usage, and writing
    a very basic program in two of the most popular scripting languages (Python and
    PowerShell).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还解释了为什么要编写一个好的程序以及如何编写一个程序，并附带了一些关于脚本语言的参考点。还简要讨论了当前脚本语言的基本用法，以及在两种最受欢迎的脚本语言（Python和PowerShell）中编写一个非常基础的程序。
- en: Finally, we summed it all up by introducing the REST framework, which included
    a discussion about APIs, how to call them, and an explanation of XML and JSON
    as inter-platform data exchange languages.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过介绍REST框架来总结所有内容，其中包括了关于API的讨论、如何调用它们，以及XML和JSON作为跨平台数据交换语言的解释。
- en: The next chapter will go deeper into how to write scripts using Python, with
    relevant examples in PowerShell to ensure the reader becomes familiar with both
    Python and PowerShell. There will be tips and best practices as well.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更深入地探讨如何使用Python编写脚本，并附带PowerShell的相关示例，以确保读者熟悉Python和PowerShell。还将提供一些技巧和最佳实践。
