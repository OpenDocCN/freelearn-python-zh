- en: Chapter 4. User Input for Our Headlines Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。我们Headlines项目的用户输入
- en: Remember how we allowed the user to specify the publication to be viewed by
    using `<variable>` parts in our URL? Although we were effectively getting input
    from our user, it's a way of retrieving input that has some pretty heavy limitations.
    Let's look at some more powerful ways to interact with our users, and add some
    more useful information to our application. We'll be making quite a few incremental
    changes to our code files from here on, so remember that you can always refer
    to the accompanying code bundle if you need an overview at any point.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们是如何允许用户使用URL中的`<variable>`部分指定要查看的出版物的吗？尽管我们实际上是在从用户那里获取输入，但这种检索输入的方式有一些相当严重的限制。让我们看看与用户交互的更强大的方法，并向我们的应用程序添加一些更有用的信息。从现在开始，我们将对我们的代码文件进行相当多的增量更改，因此请记住，如果您需要概述，您可以随时参考附带的代码包。
- en: In this chapter, we'll look at some more flexible and powerful ways to get input.
    We'll also bump into some more advanced Git features along the way, and take a
    moment to explain how to use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一些更灵活和强大的获取输入的方法。我们还将在这个过程中遇到一些更高级的Git功能，并花点时间解释如何使用它们。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Getting user input using HTTP GET
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP GET获取用户输入
- en: Getting user input using HTTP POST
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP POST获取用户输入
- en: Adding weather and currency data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加天气和货币数据
- en: Getting user input using HTTP GET
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP GET获取用户输入
- en: 'HTTP GET requests are the simplest way of retrieving input from the user. You
    might have noticed question marks in URLs while browsing the Web. When submitting
    a term in the search box on the website, your search term will usually appear
    in the URL, and look something like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP GET请求是从用户那里检索输入的最简单方式。在浏览网页时，您可能已经注意到URL中的问号。在网站的搜索框中提交一个术语时，您的搜索术语通常会出现在URL中，看起来像这样：
- en: '`example.com/search?query=weather`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`example.com/search?query=weather`'
- en: The bit after the question mark represents a named GET argument. The name is
    `query` and the value, `weather`. Although arguments like these are usually automatically
    created through HTML input boxes, the user can also manually insert them into
    the URL, or they can be part of a clickable link that is sent to the user. HTTP
    GET is designed to get limited, non-sensitive information from the user in order
    for the server to return a page as requested by the GET arguments. By convention,
    GET requests should never modify the server state in a way that produces side
    effects, that is, the user should be able to make exactly the same request multiple
    times and always be given exactly the same results.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 问号后面的部分表示一个命名的GET参数。名称是`query`，值是`weather`。尽管这些参数通常是通过HTML输入框自动生成的，但用户也可以手动将它们插入到URL中，或者它们可以是发送给用户的可点击链接的一部分。HTTP
    GET旨在从用户那里获取有限的、非敏感的信息，以便服务器根据GET参数返回所请求的页面。按照惯例，GET请求不应该以产生副作用的方式修改服务器状态，也就是说，用户应该能够多次发出完全相同的请求，并始终得到完全相同的结果。
- en: 'GET requests are, therefore, ideal for allowing our user to specify which publication
    to view. Let''s extend our Headlines project to incorporate selecting a headline
    based on a GET request. First, let''s modify the Python code to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，GET请求非常适合让用户指定要查看的出版物。让我们扩展我们的Headlines项目，以根据GET请求选择一个标题。首先，让我们修改Python代码以执行以下操作：
- en: Import the request context from Flask
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Flask导入请求上下文
- en: Remove the dynamic URL variable
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除动态URL变量
- en: Check to see if the user has entered a valid publication as a GET argument
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户是否已输入有效的出版物作为GET参数
- en: Pass the user query and the publication to the template
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户查询和出版物传递给模板
- en: 'Update the `headlines.py` file as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新`headlines.py`文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first new change is a new import for Flask''s request context. This is
    another piece of Flask magic that makes our life easier. It provides a global
    context which our code can use to access information about the latest request
    made to our application. This is useful for us, because the GET arguments that
    our user passes along as part of a request are automatically available in `request.args`,
    from which we can access key-value pairs as we would with a Python dictionary
    (although it is immutable). The request context simplifies some other parts of
    request handling as well, which means that we don''t have to worry about threads
    or the ordering of requests. You can read more about how the request context works,
    and what it does, at the following website:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新变化是Flask请求上下文的新导入。这是Flask魔法的另一部分，使我们的生活更轻松。它提供了一个全局上下文，我们的代码可以使用它来访问关于最新请求的信息。这对我们很有用，因为用户作为请求的一部分传递的GET参数会自动在`request.args`中可用，我们可以像使用Python字典一样访问键值对（尽管它是不可变的）。请求上下文还简化了请求处理的其他部分，这意味着我们不必担心线程或请求的顺序。您可以在以下网站上阅读有关请求上下文工作原理及其功能的更多信息：
- en: '[http://flask-cn.readthedocs.org/en/latest/reqcontext/](http://flask-cn.readthedocs.org/en/latest/reqcontext/)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://flask-cn.readthedocs.org/en/latest/reqcontext/](http://flask-cn.readthedocs.org/en/latest/reqcontext/)'
- en: We check to see if this has the publication key set by using the `get()` method,
    which returns `None`. if the key doesn't exist. If the argument is there, we make
    sure that the value is valid (that is, it is accounted for by our `RSS_FEEDS`
    mapping), and if it is, we return the matching publication.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`get()`方法来检查是否已设置出版物键，如果键不存在，则返回`None`。如果参数存在，我们确保值是有效的（即它在我们的`RSS_FEEDS`映射中），如果是，则返回匹配的出版物。
- en: 'We can test out the code by visiting our URL followed by the `get` argument,
    for example: `localhost:5000/?publication=bbc`. Unfortunately, from our user''s
    experience, we''ve made the application less user-friendly, instead of more. Why
    did we do this? It turns out that our user doesn''t have to modify the URL by
    hand—with a very small change, we can have the URL arguments populated automatically
    so that the user doesn''t have to touch the URL at all. Modify the `home.html`
    template, and add the following HTML below the heading:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过访问我们的 URL 后跟 `get` 参数来测试代码，例如：`localhost:5000/?publication=bbc`。不幸的是，从我们的用户体验来看，我们使应用程序变得不太用户友好，而不是更加用户友好。为什么我们要这样做呢？原来我们的用户不必手动修改
    URL——通过一个非常小的更改，我们可以自动填充 URL 参数，这样用户根本不必触摸 URL。修改 `home.html` 模板，并在标题下方添加以下 HTML： '
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is quite straightforward, but let's pick it apart to see how it all works.
    First we create an HTML form element. By default, this will create an HTTP GET
    request when submitted, by passing any inputs as GET arguments into the URL. We
    have a single text input which has the name `publication`. This name is important
    as the GET argument will use this. The `placeholder` is optional, but it will
    give our user a better experience as the browser will use it to indicate what
    the text field is intended for. Finally, we have another input of type `submit`.
    This automatically creates a nice **Submit** button for our form which, when pressed,
    will grab any text in the input and submit it to our Python backend.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但让我们分解一下看看它是如何工作的。首先，我们创建了一个 HTML 表单元素。默认情况下，当提交时，这将创建一个 HTTP GET 请求，通过将任何输入作为
    GET 参数传递到 URL 中。我们有一个名为 `publication` 的单个文本输入。这个名称很重要，因为 GET 参数将使用它。`placeholder`
    是可选的，但它会让我们的用户有更好的体验，因为浏览器会用它来指示文本字段的用途。最后，我们有另一个类型为 `submit` 的输入。这将自动为我们的表单创建一个漂亮的**提交**按钮，当按下时，它将获取输入框中的任何文本并将其提交到我们的
    Python 后端。
- en: Save the template, and reload the page to see how it works now. You should see
    the input form at the top of the page, as seen in the following screenshot. We've
    gained a lot of functionality for four lines of HTML, and now we can see that,
    although GET arguments initially looked like they were creating more mission and
    admin, they actually make our web application much simpler and more user-friendly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 保存模板，重新加载页面以查看它现在的工作方式。您应该在页面顶部看到输入表单，如下面的截图所示。我们为四行 HTML 获得了很多功能，现在我们可以看到，尽管
    GET 参数最初看起来像是在创建更多的任务和管理员，但实际上它们使我们的 Web 应用程序更简单、更用户友好。
- en: '![Getting user input using HTTP GET](img/B04312_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![使用 HTTP GET 获取用户输入](img/B04312_04_01.jpg)'
- en: Getting user input using HTTP POST
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP POST 获取用户输入
- en: The alternative to HTTP GET is HTTP POST, and it may not always be immediately
    obvious which one to use. HTTP POST is used to post larger chunks of data or more
    sensitive data to the server. Data sent through POST requests is not visible in
    the URL, and although this does not make it inherently more secure (it does not
    by default provide encryption or validation), it does offer some security advantages.
    URLs are often cached by the browser and suggested through autocomplete features
    next time the user types in a similar URL.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP GET 的替代方法是 HTTP POST，并不总是立即明显应该使用哪一个。HTTP POST 用于向服务器发布更大的数据块或更敏感的数据。通过
    POST 请求发送的数据在 URL 中不可见，尽管这并不使其本质上更安全（它默认不提供加密或验证），但它确实提供了一些安全优势。URL 经常被浏览器缓存，并通过自动完成功能建议下次用户输入类似的
    URL 时。
- en: Data sent through GET requests may, therefore, be retained. Using POST also
    prevents someone from seeing the data by looking over the user's shoulder (shoulder
    surfing). Passwords especially are often obscured on input by using HTML password
    fields, making them appear as asterisks (********) or dots (••••••••) in the browser.
    The data would still be clearly visible in the URL if sent using GET however,
    and so POST should always be used instead.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过 GET 请求发送的数据可能会被保留。使用 POST 还可以防止他人通过窥视用户的肩膀（肩部冲浪）来查看数据。特别是密码通常在输入时通过使用
    HTML 密码字段而被遮蔽，使其在浏览器中显示为星号（********）或点（••••••••）。然而，如果使用 GET 发送，数据仍然会在 URL 中清晰可见，因此应始终使用
    POST。
- en: Although our search query is hardly confidential or excessively long, we're
    going to take a moment now to see how we'd implement the same functionality using
    POST instead of GET. If you just want to get ahead with finishing off our Headlines
    application, feel free to skip this section, but keep in mind that we'll be using
    POST requests in later projects without extended explanation. Once we're done
    with the POST example, we'll revert our application to the state it is currently
    in (using the GET request), as this is much more suitable for our use case.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的搜索查询并不是机密的或过长的，但我们现在要花点时间来看看如何使用 POST 而不是 GET 来实现相同的功能。如果您只想继续完成我们的 Headlines
    应用程序，可以跳过本节，但请记住，我们将在后续项目中使用 POST 请求而不进行详细解释。完成 POST 示例后，我们将把我们的应用程序恢复到当前状态（使用
    GET 请求），因为这更适合我们的用例。
- en: Creating a branch in Git
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Git 中创建分支
- en: 'To make a change to our code base that we''re not sure if we want, we''ll use
    Git''s branch functionality. Think of a branch as being like a fork in a road,
    except we can at any time change our mind and go back to the decision point. First,
    we need to make sure our current branch (master) is up to date—that all our local
    changes are committed. Open a terminal, and run the following commands from the
    headlines directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的代码库进行更改，我们不确定是否想要，我们将使用Git的分支功能。把分支想象成是路上的岔路口，除了我们随时可以改变主意并返回决策点。首先，我们需要确保我们当前的分支（master）是最新的——即所有本地更改都已提交。打开终端，从
    headlines 目录运行以下命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We don''t strictly need to push it to the server—Git keeps a full revision
    history locally, and our changes would still be theoretically safe without the
    push. However, our code is in a working state, so there''s no harm making the
    backup to remote. Now we''re going to create the new branch and switch to using
    it to make our next set of changes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不严格需要将其推送到服务器——Git在本地保留完整的修订历史，即使没有推送，我们的更改理论上仍然是安全的。然而，我们的代码处于工作状态，因此进行远程备份也没有坏处。现在我们将创建新的分支并切换到使用它来进行下一组更改：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We're now working in a new branch of our codebase. Usually, we'd eventually
    merge this branch back into our master branch, but in our case, we'll just abandon
    it once we're done with what we need. It's quite hard to visualize what's happening
    as Git does most things behind the scenes, so it's worth reading up about Git
    if you're interested, and are likely to use it for future projects. Otherwise,
    just think of this as a checkpoint so that we can freely experiment without the
    worry of messing up our code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在我们代码库的一个新分支上工作。通常，我们最终会将此分支合并回主分支，但在我们的情况下，一旦我们完成所需的工作，我们将放弃它。由于Git大多数操作都是在后台进行，很难将发生的事情可视化，因此如果您感兴趣并且可能会在将来的项目中使用Git，那么值得阅读有关Git的内容。否则，只需将其视为一个检查点，以便我们可以自由地进行实验，而不必担心搞乱我们的代码。
- en: Adding POST routes in Flask
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Flask中添加POST路由
- en: 'To use a POST request, we need to make some small changes to our Python and
    HTML code. In the `headlines.py` file, make the following changes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用POST请求，我们需要对Python和HTML代码进行一些小的更改。在`headlines.py`文件中，进行以下更改：
- en: Change `request.args.get` to `request.form.get`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`request.args.get`更改为`request.form.get`
- en: Change `@app.route("/")` to `@app.route("/", methods=['GET', 'POST'])`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`@app.route("/")`更改为`@app.route("/", methods=['GET', 'POST'])`
- en: 'The reason for the first change is that we are now grabbing the user data from
    a form, so Flask automatically makes this available to us in `request.form`. This
    works the same way as `request.get` except that it gathers data from POST requests
    instead of from GETs. The second change is not quite as obvious. What we haven''t
    mentioned before is that all route decorators can specify how the function can
    be accessed: either through GET requests, POST requests, or both. By default,
    only GET is permitted, but we now want our default page to be accessible by either
    GET (when we just visit the home main page and are given BBC as a default), or
    POST (for when we''ve requested the page through our form with the additional
    query data). The `methods` parameter accepts a list of HTTP methods which should
    be permitted to access that particular route of our application.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改的原因是我们现在从表单中获取用户数据，因此Flask会自动将其提供给我们的`request.form`。这与`request.get`的工作方式相同，只是它从POST请求而不是从GET请求中收集数据。第二个更改并不那么明显。我们之前没有提到的是，所有路由装饰器都可以指定函数如何被访问：通过GET请求、POST请求或两者兼有。默认情况下，只允许GET，但我们现在希望我们的默认页面可以通过GET（当我们只是访问主页并且默认给出BBC时）或POST（当我们通过带有额外查询数据的表单请求页面时）来访问。`methods`参数接受一个HTTP方法的列表，这些方法应该被允许访问我们应用程序的特定路由。
- en: Making our HTML form use POST
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使我们的HTML表单使用POST
- en: 'Our template needs similar changes. Change the opening `<form>` tag in the
    `home.html` file to read:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板需要进行类似的更改。将`home.html`文件中的开头`<form>`标签更改为：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just as with Flask, HTML forms use GET by default, so we have to explicitly
    define that we want to use POST instead. The `action` attribute isn't strictly
    necessary, but usually, when we use POST, we redirect users to a confirmation
    page or similar, and the URL for the following page would appear here. In this
    case, we're explicitly saying that we want to be redirected to the same page after
    our form has been submitted.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与Flask一样，HTML表单默认使用GET，因此我们必须明确定义我们要使用POST而不是GET。`action`属性并不是绝对必要的，但通常当我们使用POST时，我们会将用户重定向到确认页面或类似的页面，接下来的页面的URL将出现在这里。在这种情况下，我们明确表示我们希望在提交表单后重定向到同一个页面。
- en: Save the changes to the Python and HTML files, and refresh the page in your
    browser to see the changes take effect. The functionality should be exactly the
    same except that we don't see any data in the URL. This can be cleaner for many
    applications, but in our case, it is not what we want. For one, we'd like the
    search term to be cached by our users' browsers. If a user habitually makes a
    query for FOX, we want the browser to be able to autocomplete this after he begins
    typing in the URL for our application. Furthermore, we'd like our users to be
    able to easily share links that include the query.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 保存Python和HTML文件的更改，并在浏览器中刷新页面以查看更改生效。功能应该完全相同，只是我们在URL中看不到任何数据。对于许多应用程序来说，这可能更清晰，但在我们的情况下，这不是我们想要的。首先，我们希望用户的浏览器可以缓存搜索词。如果用户习惯性地查询FOX，我们希望浏览器在他开始在我们的应用程序的URL中输入时能够自动完成这一点。此外，我们希望我们的用户能够轻松地分享包括查询的链接。
- en: If a user (let's call him Bob) sees a bunch of interesting headlines after typing
    **cnn** into our application, and wants to share all of these headlines with another
    user (Jane), we don't want Bob to have to message Jane, telling her to visit our
    site, and type a specific query into the search form. Instead, Bob should be able
    to share a URL that allows Jane to directly visit the page exactly as he saw it
    (for example, `example.com/?publication=cnn`). Jane can simply click on the link
    sent by Bob and view the same headlines (assuming she visits our page before the
    RSS feed is updated).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户（让我们称之为鲍勃）在将**cnn**输入到我们的应用程序后看到一堆有趣的标题，并希望与另一个用户（简）分享所有这些标题，我们不希望鲍勃不得不给简发消息，告诉她访问我们的网站，并在搜索表单中输入特定的查询。相反，鲍勃应该能够分享一个URL，让简直接访问页面，就像他看到的那样（例如，`example.com/?publication=cnn`）。简只需点击鲍勃发送的链接，就可以查看相同的标题（假设她在RSS订阅更新之前访问我们的页面）。
- en: Reverting our Git repository
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复我们的Git存储库
- en: 'We need to revert the code to how we had it before. Because all the changes
    in the previous section were made in our experimental post-request branch, we
    don''t need to manually re-edit the lines we changed. Instead, we''ll commit our
    changes to this branch, and then switch back to our master branch, where we''ll
    find everything as we left it. In your terminal, run the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将代码恢复到之前的状态。因为上一节中的所有更改都是在我们的实验性post请求分支中进行的，所以我们不需要手动重新编辑我们更改的行。相反，我们将提交我们的更改到这个分支，然后切换回我们的主分支，在那里我们会发现一切都和我们离开时一样。在您的终端中运行以下命令：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the `headlines.py` and `templates/home.html` files to be sure, but they
    should be exactly as we left them before experimenting with POST!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`headlines.py`和`templates/home.html`文件，确保它们与我们在进行POST实验之前保持一致！
- en: Adding weather and currency data
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加天气和货币数据
- en: Now let's add some more functionality. We're showing media headlines from three
    different sources, but our user is probably interested in more than current affairs.
    We're going to see how easy it is to display the current weather and some exchange
    rates at the top of the page. For the weather data, we'll be using the OpenWeatherMap
    API, and for currency data, we'll be using Open Exchange Rates. At the time of
    writing, these APIs are freely available, although they both require registration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一些更多功能。我们正在显示来自三个不同来源的媒体头条，但我们的用户可能对更多内容感兴趣。我们将看看在页面顶部显示当前天气和一些汇率有多容易。对于天气数据，我们将使用OpenWeatherMap
    API，对于货币数据，我们将使用Open Exchange Rates。在撰写本文时，这些API是免费提供的，尽管它们都需要注册。
- en: Introducing the OpenWeatherMap API
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍OpenWeatherMap API
- en: 'In your web browser, visit the URL [http://api.openweathermap.org/data/2.5/weather?q=London,uk&units=metric&appid=cb932829eacb6a0e9ee4f38bfbf112ed](http://api.openweathermap.org/data/2.5/weather?q=London,uk&units=metric&appid=cb932829eacb6a0e9ee4f38bfbf112ed).
    You should see something that looks similar to the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中，访问URL [http://api.openweathermap.org/data/2.5/weather?q=London,uk&units=metric&appid=cb932829eacb6a0e9ee4f38bfbf112ed](http://api.openweathermap.org/data/2.5/weather?q=London,uk&units=metric&appid=cb932829eacb6a0e9ee4f38bfbf112ed)。您应该看到类似以下截图的内容：
- en: '![Introducing the OpenWeatherMap API](img/B04312_04_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![介绍OpenWeatherMap API](img/B04312_04_02.jpg)'
- en: This is the JSON weather data for London which is designed to be read automatically
    instead of by humans. Before looking at how to go about reading this data into
    our Headlines application, note that the URL we visited has an `appid` parameter.
    Even though the weather data is provided for free, every developer who accesses
    the data needs to sign up for a free account with OpenWeatherMap, and get a unique
    API key to pass as the value for the `appid` parameter. This is to prevent people
    from abusing the API by making too many requests, and hogging the available bandwidth.
    At the time of writing, OpenWeatherMap allows 60 calls to the API per minute and
    50,000 per day as part of their free access plan, so it's unlikely that we'll
    be hitting these limits for our project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是伦敦的JSON天气数据，设计成自动读取而不是人工读取。在看如何将这些数据读入我们的Headlines应用程序之前，请注意我们访问的URL有一个`appid`参数。尽管天气数据是免费提供的，但每个访问数据的开发人员都需要在OpenWeatherMap注册一个免费账户，并获取一个唯一的API密钥作为`appid`参数的值。这是为了防止人们滥用API，进行过多的请求，并占用可用的带宽。在撰写本文时，OpenWeatherMap允许每分钟对API进行60次调用，每天50000次作为他们的免费访问计划的一部分，因此我们的项目不太可能达到这些限制。
- en: Signing up with OpenWeatherMap
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册OpenWeatherMap
- en: 'You should sign up for your own API key instead of using the one published
    in this book. Generally, your API key should remain a secret, and you should avoid
    sharing it (especially avoid publishing it in a book). To get your own API key,
    head over to [www.openweathermap.org](http://www.openweathermap.org) , and complete
    their sign-up progress by clicking the sign-up link at the top of the page. Fill
    out an e-mail address, username, and password. The registration page should look
    similar to the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注册自己的API密钥，而不是使用本书中发布的密钥。通常，您的API密钥应保持秘密，并且应避免共享它（尤其是避免在书中发布它）。要获取您自己的API密钥，请转到[www.openweathermap.org](http://www.openweathermap.org)，并通过单击页面顶部的注册链接完成他们的注册流程。填写电子邮件地址，用户名和密码。注册页面应该类似于以下截图：
- en: '![Signing up with OpenWeatherMap](img/B04312_04_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![注册OpenWeatherMap](img/B04312_04_03.jpg)'
- en: Retrieving your OpenWeatherMap API key
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索您的OpenWeatherMap API密钥
- en: 'Once you''ve signed up, you''ll be able to log into OpenWeatherMap. You can
    the find your personal API key by navigating to [home.openweathermap.org](http://home.openweathermap.org)
    and scrolling down to the **API key** text box. You should see your API key as
    indicated by the red rectangle in the following image:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注册后，您将能够登录OpenWeatherMap。您可以通过导航到[home.openweathermap.org](http://home.openweathermap.org)并向下滚动到**API密钥**文本框找到您的个人API密钥。您应该在以下图像中看到您的API密钥，如红色矩形所示：
- en: '![Retrieving your OpenWeatherMap API key](img/B04312_04_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![检索您的OpenWeatherMap API密钥](img/B04312_04_04.jpg)'
- en: Copy the key to your clipboard, as we'll be using it in our Python code soon.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将密钥复制到剪贴板，因为我们很快将在我们的Python代码中使用它。
- en: Parsing JSON with Python
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python解析JSON
- en: Now we can access structured weather data over HTTP by using a URL. But doing
    so in our browser isn't much good, as we want to read this data automatically
    from our Python code. Luckily, Python has a bunch of useful standard libraries
    for exactly this use case!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用URL在HTTP上访问结构化的天气数据。但是在浏览器中这样做并没有太大用处，因为我们希望从我们的Python代码自动读取这些数据。幸运的是，Python有一堆有用的标准库，正好适用于这种用例！
- en: Introducing JSON
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍JSON
- en: JSON is a structured data format very similar to a Python dictionary, as should
    be apparent from the preceding sample. In fact, in this case it's identical, and
    we could very simply convert it to a Python dictionary to use in our Flask application
    by loading it as a string and running the built-in Python `eval` function on it.
    However, JSON is not always identical to a Python dictionary. For example, it
    uses `true` and `false` instead of `True` and `False` (note the case difference)—and
    passing anything that we don't have full control over to `eval()` is generally
    a bad idea. Therefore, we'll use the `Python json` library to safely parse it.
    We'll also use the Python `urllib2` library to download the data from the web,
    and the Python `urllib` library to correctly encode URL parameters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种结构化数据格式，非常类似于Python字典，从前面的示例中应该很明显。实际上，在这种情况下，它是相同的，我们可以非常简单地将其转换为Python字典，以便在我们的Flask应用程序中使用，方法是将其加载为字符串，然后在其上运行内置的Python
    `eval`函数。然而，JSON并不总是与Python字典相同。例如，它使用`true`和`false`而不是`True`和`False`（注意大小写的区别）-将任何我们无法完全控制的东西传递给`eval()`通常是一个坏主意。因此，我们将使用`Python
    json`库来安全地解析它。我们还将使用Python `urllib2`库从网络上下载数据，并使用Python `urllib`库正确编码URL参数。
- en: Retrieving and parsing JSON in Python
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中检索和解析JSON
- en: 'For retrieving and parsing JSON in Python, the first step is to add the three
    new imports that we need to our `headlines.py` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在Python中检索和解析JSON，第一步是向我们的`headlines.py`文件添加我们需要的三个新导入：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Style tip:**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**风格提示：**'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'For good Python style, keep the imports ordered alphabetically. You can read
    more about the conventions for ordering imports at the following site: [https://www.python.org/dev/peps/pep-0008/#imports](https://www.python.org/dev/peps/pep-0008/#imports)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了良好的Python风格，保持导入按字母顺序排列。您可以在以下网站阅读有关导入排序约定的更多信息：[https://www.python.org/dev/peps/pep-0008/#imports](https://www.python.org/dev/peps/pep-0008/#imports)
- en: Now add a new function, `get_weather()`, which will make a call to the weather
    API with a specific query. It's pretty straightforward, and looks like the following
    code. Replace the `<your-api-key-here>` placeholder with the API key that you
    copied from the OpenWeatherMap page.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加一个新函数`get_weather()`，它将使用特定查询调用天气API。这很简单，代码如下。用你从OpenWeatherMap页面复制的API密钥替换`<your-api-key-here>`占位符。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use the same URL we looked at earlier in our browser, but we make the query
    part-configurable so that the city for which we retrieve the weather data is dynamic.
    We use `urllib.quote()` on the query variable, as URLs cannot have spaces in them,
    but the names of the cities that we want to retrieve weather for may contain spaces.
    The `quote()` function handles this for us by, for example, translating a space
    to "`%20`", which is how spaces are represented in URLs. Then we load the data
    over HTTP into a Python string by using the `urllib2` library. As in our feedparsing
    example, downloading data over the Internet is always potentially unstable, and
    for a real-world application, we would need to add some exception handling, and
    retry logic here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浏览器中使用与之前相同的URL，但是我们使查询部分可配置，以便检索天气数据的城市是动态的。我们在查询变量上使用`urllib.quote()`，因为URL中不能有空格，但是我们想要检索天气的城市的名称可能包含空格。`quote()`函数通过将空格转换为"`%20`"（这是URL中表示空格的方式）来处理这个问题。然后我们使用`urllib2`库将数据通过HTTP加载到Python字符串中。与我们的feedparsing示例一样，通过互联网下载数据总是潜在不稳定的，对于真实的应用程序，我们需要在这里添加一些异常处理和重试逻辑。
- en: We then use the json library's `loads()` function (load string) to convert the
    JSON string that we downloaded into a Python dictionary. Finally, we manually
    build up a simpler Python dictionary based on the JSON one returned by the API,
    as OpenWeatherMap supplies a whole bunch of attributes that we don't need for
    our application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用json库的`loads()`函数（加载字符串）将我们下载的JSON字符串转换为Python字典。最后，我们根据API返回的JSON构建一个更简单的Python字典，因为OpenWeatherMap提供了一大堆我们不需要的属性。
- en: Using our weather code
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的天气代码
- en: 'Now make two small changes to the `get_news()` function in order to use our
    `get_weather()` function. We need to call the `get_weather()` function (for now
    we''ll just pass in London as a constant), and then pass the weather data to our
    template. The `get_news()` function should now look as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对`get_news()`函数进行两个小改动，以便使用我们的`get_weather()`函数。我们需要调用`get_weather()`函数（现在我们只会传入伦敦作为常量），然后将天气数据传递给我们的模板。`get_news()`函数现在应该如下所示：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This now loads the simplified data for London into the weather variable, and
    passes it along to our template file so that we can display the data to our users.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将伦敦的简化数据加载到天气变量中，并将其传递给我们的模板文件，以便我们可以向用户显示数据。
- en: Displaying the weather data
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示天气数据
- en: Now we just need to adapt our template to account for the extra data. We'll
    display the weather data just above the news headlines, and add some level 2 headings
    to keep the different sections of our application organized.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要调整我们的模板来适应额外的数据。我们将在新闻标题上方显示天气数据，并添加一些二级标题以保持我们应用程序的不同部分有序。
- en: 'Add the following three lines to the home.html template, right after the opening
    `<h1>` tag:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在开头的`<h1>`标签后面，向home.html模板添加以下三行：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's nothing here that we haven't seen before. We simply grab the sections
    we want out of our weather variable using braces. The funny `&#8451;` part is
    to display the symbol for degrees Celsius. If you're one of those people who is
    able to make sense of the notion of Fahrenheit, then remove the `&units=metric`
    from the API URL (which will tell OpenWeatherData to give us the temperatures
    in Fahrenheit), and display the *F* symbol for our users by using `&#8457;` in
    your template instead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有我们之前没有见过的东西。我们只需使用大括号从我们的天气变量中获取我们想要的部分。有趣的`&#8451;`部分是为了显示摄氏度符号。如果你是那些能够理解华氏度概念的人之一，那么从API
    URL中删除`&units=metric`（这将告诉OpenWeatherData以华氏度给我们温度），并在模板中使用`&#8457;`代替*F*符号来显示给我们的用户。
- en: Allowing the user to customize the city
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许用户自定义城市
- en: As mentioned earlier, we would not always want to display the weather for London.
    Let's add a second search box for city! Searching is usually hard, because data
    input by users is never consistent, and computers love consistency. Luckily, the
    API that we're using does a really good job of being flexible, so we'll just pass
    on the user's input directly, and leave the difficult bit for others to deal with.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们并不总是想显示伦敦的天气。让我们为城市添加第二个搜索框！搜索通常很困难，因为用户输入的数据从来都不一致，而计算机喜欢一致。幸运的是，我们正在使用的API非常灵活，因此我们将直接传递用户的输入，并将困难的部分留给其他人处理。
- en: Adding another search box to our template
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的模板中添加另一个搜索框
- en: We'll add the search box to our template exactly as before. This form goes directly
    under the *Current weather* heading in the `home.html` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将搜索框添加到我们的模板中，就像以前一样。这个表单直接放在“home.html”文件中“当前天气”标题下面。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The form defined in the preceding code snippet simply uses a named text input
    and a submit button, just like the one we added for the publication input.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中定义的表单简单地使用了一个命名文本输入和一个提交按钮，就像我们为出版物输入添加的那样。
- en: Using the user's city search in our Python code
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的Python代码中使用用户的城市搜索
- en: 'In our Python code, we need to look for the `city` argument in the GET request.
    Our `get_news()` function is no longer well-named, as it does more than simply
    getting the news. Let''s do a bit of refactoring. Afterwards, we''ll have a `home()`
    function that makes calls to get the news and the weather data (and later on the
    currency data), and our `get_news()` function will again only be responsible for
    getting news. We''re also going to have quite a few defaults for different things,
    so instead of hard-coding them all, we''ll add a `DEFAULTS` dictionary as a global,
    and whenever our code can''t find information in the GET arguments, it''ll fall
    back to getting what it needs from there. The changed parts of our code (excluding
    the imports, global URLs, and the main section at the end) now look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Python代码中，我们需要在GET请求中查找“city”参数。我们的“get_news（）”函数不再命名良好，因为它不仅仅是获取新闻。让我们进行一些重构。之后，我们将有一个“home（）”函数，该函数调用获取新闻和天气数据（以及以后的货币数据），我们的“get_news（）”函数将再次只负责获取新闻。我们还将有很多不同事物的默认值，因此我们将添加一个“DEFAULTS”字典作为全局变量，每当我们的代码无法在GET参数中找到信息时，它将返回到那里获取所需的信息。我们代码的更改部分（不包括导入、全局URL和最后的主要部分）现在看起来像这样：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we have a good separation of concerns—our `get_weather()` function gets
    weather data, our `get_news()` function gets news, and our `home()` function combines
    the two and handles the user's input to display customized data to our visitors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了良好的关注点分离-我们的“get_weather（）”函数获取天气数据，我们的“get_news（）”函数获取新闻，我们的“home（）”函数将两者结合起来，并处理用户的输入，向我们的访问者显示定制数据。
- en: Checking our new functionality
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查我们的新功能
- en: 'If all went well, we should now have a site that displays customizable news
    and weather data. The weather search, as mentioned, is pretty flexible. Give it
    a go with some different inputs—you should see a page similar to the following
    image:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们现在应该有一个显示可定制新闻和天气数据的网站。如前所述，天气搜索非常灵活。尝试一些不同的输入-您应该会看到一个类似以下图像的页面：
- en: '![Checking our new functionality](img/B04312_04_05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![检查我们的新功能](img/B04312_04_05.jpg)'
- en: Handling duplicate city names
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理重复的城市名称
- en: The OpenWeatherMap API handles duplicate city names well, although the defaults
    are sometimes a bit counter-intuitive. For example, if we search for Birmingham,
    we'll get the one in the USA. If we want to look for the Birmingham in the UK,
    we can search for Birmingham, UK. In order to not confuse our viewers, we'll make
    a small modification for displaying the country next to the city. Then they'll
    immediately be able to see if they get results for a city different from what
    they were expecting. If you examine the full API response from our weather call,
    you'll find the country code listed under `sys`—we'll grab that, add it to our
    custom dictionary, and then display it in our template.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWeatherMap API很好地处理了重复的城市名称，尽管默认值有时有点反直觉。例如，如果我们搜索伯明翰，我们将得到美国的那个。如果我们想要查找英国的伯明翰，我们可以搜索伯明翰，英国。为了不让观众感到困惑，我们将对显示城市旁边的国家进行小修改。然后他们将立即能够看到是否得到了与他们预期的城市不同的结果。如果您检查我们的天气调用的完整API响应，您会发现国家代码列在“sys”下-我们将获取它，添加到我们的自定义字典中，然后在我们的模板中显示它。
- en: 'In the `get_weather` function, modify the line where we build the dictionary:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在“get_weather”函数中，修改我们构建字典的行：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And in our template, modify the line where we display the city to read as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 并在我们的模板中修改显示城市的行如下：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Check that its working – if you restart the application and reload the page,
    you should see that typing `Birmingham` into to the **Current weather** search
    box now displays the country code next to the city name.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 检查它是否工作-如果您重新启动应用程序并重新加载页面，您应该会看到在“当前天气”搜索框中键入“伯明翰”现在显示城市名称旁边的国家代码。
- en: '![Handling duplicate city names](img/B04312_04_06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![处理重复的城市名称](img/B04312_04_06.jpg)'
- en: Currency
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 货币
- en: Currency data is considered more valuable than weather data. Many commercial
    services offer APIs that are frequently updated and very reliable. However, the
    free ones are a bit rare. One service that offers a limited API for free is Open
    Exchange Rates—and again, we need to register a free account to get an API key.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 货币数据被认为比天气数据更有价值。许多商业服务提供经常更新且非常可靠的API。但是，免费的API有点罕见。一个提供有限免费API的服务是Open Exchange
    Rates-再次，我们需要注册一个免费帐户以获得API密钥。
- en: Getting an API key for the Open Exchange Rates API
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取Open Exchange Rates API的API密钥
- en: Head over to [openexchangerates.com](http://openexchangerates.com), and complete
    their registration process. After clicking on the **Sign up** link, it may look
    like they only have paid plans, as these are more prominently displayed. However,
    underneath the large paid plan options, there is a single line of text describing
    their free offering with a link to select it. Click on this, and enter your details.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[openexchangerates.com](http://openexchangerates.com)，并完成他们的注册流程。 点击**注册**链接后，它可能看起来他们只有付费计划，因为这些更加突出显示。
    但是，在大型付费计划选项下方，有一行描述其免费提供的单行文本，并附有选择它的链接。 点击这个链接，并输入您的详细信息。
- en: 'If you are not automatically redirected, head over to your dashboard on their
    site, and you''ll see your **API key** (App ID) displayed. Copy this, as we''ll
    need to add it to our Python code. You can see an example of where to find your
    API key in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有自动重定向，请转到他们网站上的仪表板，您会看到您的**API密钥**（应用程序ID）显示出来。 复制这个，因为我们需要将其添加到我们的Python代码中。
    您可以在以下截图中看到如何找到您的API密钥的示例：
- en: '![Getting an API key for the Open Exchange Rates API](img/B04312_04_07.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![获取Open Exchange Rates API的API密钥](img/B04312_04_07.jpg)'
- en: Using the Open Exchange Rates API
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Open Exchange Rates API
- en: The `currency` API returns JSON just like the `weather` API, so we can integrate
    it into our Headlines application very easily. We need to add the URL as a global,
    and then add a new function to calculate rates. Unfortunately, the free version
    of the API is restricted to returning all the major currencies against the United
    States Dollar, so we will have to calculate our own approximate rates for conversions
    not involving the dollar, and rely on a perfect market to keep our information
    as accurate as possible (see [http://en.wikipedia.org/wiki/Triangular_arbitrage](http://en.wikipedia.org/wiki/Triangular_arbitrage)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`currency` API返回的JSON与`weather` API一样，因此我们可以非常容易地将其集成到我们的Headlines应用程序中。 我们需要将URL添加为全局变量，然后添加一个新函数来计算汇率。
    不幸的是，API的免费版本受限于返回所有主要货币相对于美元的汇率，因此我们将不得不为不涉及美元的转换计算我们自己的近似汇率，并依赖于一个完美的市场尽可能地保持我们的信息准确（参见[http://en.wikipedia.org/wiki/Triangular_arbitrage](http://en.wikipedia.org/wiki/Triangular_arbitrage)）。'
- en: Add the variable `CURRENCY_URL` to your globals below the existing `WEATHER_URL`,
    as seen in the following code snippet. You'll need to substitute your own App
    ID.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的`WEATHER_URL`下面的全局变量中添加变量`CURRENCY_URL`，如下面的代码片段所示。 您需要替换自己的App ID。
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the `get_rates()` function as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`get_rates()`函数如下：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note the calculation that we do at the end. If the request was from USD to any
    of the other currencies, we could simply grab the correct number from the returned
    JSON. But in this case, the calculation is simple enough, and it's therefore not
    worth adding the extra step of logic to work out if we need to do the calculation
    or not.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们在最后进行的计算。 如果请求是从美元到其他任何货币，我们可以简单地从返回的JSON中获取正确的数字。 但在这种情况下，计算是足够简单的，因此不值得添加额外的逻辑步骤来判断我们是否需要进行计算。
- en: Using our currency function
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用我们的货币功能
- en: 'Now we need to call the `get_rates()` function from our `home()` function,
    and pass the data through to our template. We also need to add default currencies
    to our `DEFAULTS` dictionary. Make the changes as indicated by the highlighted
    code that follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要从我们的`home()`函数中调用`get_rates()`函数，并将数据传递给我们的模板。 我们还需要向我们的`DEFAULTS`字典添加默认货币。
    根据以下突出显示的代码进行更改：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Displaying the currency data in our template
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的模板中显示货币数据
- en: 'Finally, we need to modify our template to display the new data. Underneath
    the weather section in `home.html`, add:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改我们的模板以显示新数据。 在`home.html`中的天气部分下面添加：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As always, check that everything is working in your browser. You should see
    the default currency data of the British Pound to US Dollar conversion as in the
    following image:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在浏览器中检查一切是否正常运行。 您应该看到英镑兑美元的默认货币数据，如下图所示：
- en: '![Displaying the currency data in our template](img/B04312_04_08.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的模板中显示货币数据](img/B04312_04_08.jpg)'
- en: Adding inputs for the user to select currency
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为用户选择货币添加输入
- en: 'Now we need to add yet another user input to customize which currencies to
    display. We could easily add another text search like we did for the previous
    two, but this gets messy. We need two bits of input from the user: the *from*
    currency and the *to* currency. We could add two inputs, or we could ask the user
    to enter both into the same input, but the former makes our page pretty cluttered,
    and the latter means we need to worry about properly splitting the user input
    data (which is almost certainly not consistent). Instead, let''s look at a different
    input element, the HTML `select`. You''ve almost certainly seen these on other
    web pages—they''re drop-down menus with a list of values that the user can choose
    from. Let''s see how to build them in HTML, and how to grab the data from them
    in Flask.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加另一个用户输入来自定义要显示的货币。 我们可以像之前两个一样轻松地添加另一个文本搜索，但这会变得混乱。 我们需要用户的两个输入：*从*货币和*到*货币。
    我们可以添加两个输入，或者我们可以要求用户将两者输入到同一个输入中，但前者会使我们的页面变得非常凌乱，而后者意味着我们需要担心正确地拆分用户输入数据（这几乎肯定不一致）。
    相反，让我们看看另一个输入元素，HTML `select`。 您几乎肯定在其他网页上看到过这些——它们是带有用户可以选择的值列表的下拉菜单。 让我们看看如何在HTML中构建它们，以及如何在Flask中抓取它们的数据。
- en: Creating an HTML select drop-down element
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建HTML选择下拉元素
- en: 'First, let''s hard-code four currencies in each drop-down menu. The code should
    be inserted right below the **Currency** heading in the `home.html` template,
    and it looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在每个下拉菜单中硬编码四种货币。 代码应该插入在`home.html`模板中**货币**标题的下方，代码如下：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The name used for the GET request argument is an attribute of the select tag
    itself (similar to the name attribute used in our `<input type="text">` tags).
    In our case, these are `currency_from` and `currency_to`, which we specified in
    our Python code earlier. The value is slightly more tricky—we have the value that's
    passed in our GET request (for example, `currency_from=EUR`), and then the value
    that is displayed to the user. In this case, we'll use the same for both—the currency
    code—but this is not compulsory. For example, we could use the full name of the
    currency, such as United States Dollar, in the display value, and the code in
    the value that's passed in the request. The argument value is specified as an
    attribute of the option tags, each a child of `<select>`. The display value is
    inserted between the opening and closing `<option>` and `</option>` tags.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 用于GET请求参数的名称是选择标签本身的属性（类似于我们在`<input type="text">`标签中使用的名称属性）。在我们的情况下，这些是`currency_from`和`currency_to`，这些是我们之前在Python代码中指定的。值稍微有些棘手——我们有在GET请求中传递的值（例如`currency_from=EUR`），然后是显示给用户的值。在这种情况下，我们将两者都使用相同的——货币代码——但这不是强制的。例如，我们可以在显示值中使用货币的全名，如美元，在请求中传递代码。参数值被指定为`<option>`标签的属性，每个都是`<select>`的子元素。显示值插入在开放和关闭的`<option>`和`</option>`标签之间。
- en: 'Test this out to make sure it''s working, by saving the template and reloading
    the page. You should see drop-down inputs appear, as in the following image:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下，确保它能正常工作，保存模板并重新加载页面。您应该会看到下拉输入框出现，如下图所示：
- en: '![Creating an HTML select drop-down element](img/B04312_04_09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建HTML选择下拉元素](img/B04312_04_09.jpg)'
- en: Adding all the currencies to the select input
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有货币添加到选择输入中
- en: 'Of course, we could do what we did in the preceding section for the full list.
    But we''re programmers, not data capturers, so we''ll make the list dynamic, insert
    the options using a `for` loop, and keep our template up-to-date and clean. To
    get the list of currencies, we can simply take the keys of our JSON `all_currency`
    object, in order to make our `get_rate()` function return a tuple—the calculated
    rate and the list of currencies. We can then pass the (sorted) list to our template,
    which can loop through them and use them to build the drop-down lists. The changes
    for this are shown as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以像前一节那样对完整列表进行操作。但是我们是程序员，不是数据捕捉者，所以我们将使列表动态化，使用`for`循环插入选项，并保持我们的模板更新和清晰。为了获取货币列表，我们可以简单地获取JSON
    `all_currency`对象的键，以便使我们的`get_rate()`函数返回一个元组——计算出的汇率和货币列表。然后我们可以将（排序后的）列表传递给我们的模板，模板可以循环遍历它们并用它们构建下拉列表。更改如下所示：
- en: 'Make the following changes in the `home()` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home()`函数中进行以下更改：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `get_rate()` function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_rate()`函数中：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And in the `home.html` template:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home.html`模板中：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Displaying the selected currency in the drop-down input
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在下拉输入中显示所选货币
- en: 'After this, we should easily be able to see the exchange rate for any currency
    we want. One minor irritation is that the dropdowns always display the top item
    by default. It would be more intuitive for our users if they displayed the currently
    selected value instead. We can do this by setting the `selected="selected"` attribute
    in our select tag and a simple, one-line Jinja `if` statement to work out which
    line to modify. Change the `for` loops for the currency inputs in our `home.html`
    template to read as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们应该能够轻松地查看任何我们想要的货币的汇率。一个小小的烦恼是下拉框总是默认显示顶部项目。如果它们显示当前选定的值会更直观。我们可以通过在我们的选择标签中设置`selected="selected"`属性和一个简单的一行Jinja
    `if`语句来实现这一点。更改我们`home.html`模板中货币输入的`for`循环如下：
- en: 'For the `currency_from` loop:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`currency_from`循环：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the `currency_to` loop:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`currency_to`循环：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Reload the application and the page, and you should now be able to select any
    of the available currencies from both select inputs, and after the page has loaded
    with the desired currency data, the select inputs should automatically display
    the current currencies as well, as seen in the following image. After clicking
    on the select input, you should also be able to type on your keyboard and select
    the option based on the first letters of what you've typed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载应用程序和页面，现在您应该能够从两个选择输入中选择任何可用的货币，并且在页面加载所需的货币数据后，选择输入应该自动显示当前货币，如下图所示。单击选择输入后，您还应该能够在键盘上输入并根据您输入的首字母选择选项。
- en: '![Displaying the selected currency in the drop-down input](img/B04312_04_10.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![在下拉输入中显示所选货币](img/B04312_04_10.jpg)'
- en: We can now see news, weather, and currency data at the same time! You can refer
    to the complete code from the code bundle of the chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以同时看到新闻、天气和货币数据！您可以从本章的代码包中参考完整的代码。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've looked at the difference between the HTTP GET and POST
    requests, and discussed where it's good to use which. Although we have no good
    use for HTTP POST at the moment, we will use it in future projects where we will
    be getting login data from our users. Luckily, the explanatory work we did with
    HTTP POST is not lost—we also took a look at some more advanced ways that Git
    can help us with version control, and our unused code is safely stored in a different
    branch of our code repository in case we need to refer back to it later. Last
    but not least, we added weather and currency data to our application, and looked
    at a few different options for allowing our user to input data into our application.
    We're nearly done with our first project!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一下HTTP GET和POST请求之间的区别，并讨论了在何时使用哪种请求。虽然目前我们没有好的用途来使用HTTP POST，但在未来的项目中，我们将从用户那里获取登录数据时使用它。幸运的是，我们对HTTP
    POST的解释工作并没有白费——我们还看了一些Git可以帮助我们进行版本控制的更高级的方法，我们未使用的代码安全地存储在代码库的不同分支中，以防以后需要参考。最后但并非最不重要的是，我们将天气和货币数据添加到了我们的应用程序中，并研究了一些不同的选项，以允许用户向我们的应用程序输入数据。我们的第一个项目快要完成了！
- en: In the next chapter, we'll do some cosmetic touch-ups, and look at remembering
    our users so that they don't have to carry out exactly the same actions every
    time they visit our site.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进行一些修饰性的润色，并考虑如何记住我们的用户，这样他们就不必每次访问我们的网站时都执行完全相同的操作。
