- en: Chapter 5. Decorators – Enabling Code Reuse by Decorating
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 装饰器 - 通过装饰实现代码重用
- en: In this chapter, you are going to learn about Python decorators. Decorators
    are essentially function/class wrappers that can be used to modify the input,
    output, or even the function/class itself before executing it. This type of wrapping
    can just as easily be achieved by having a separate function that calls the inner
    function, or via mixins. As is the case with many Python constructs, decorators
    are not the only way to reach the goal but are definitely convenient in many cases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习Python装饰器。装饰器本质上只是可以用于修改输入、输出甚至在执行之前修改函数/类本身的函数/类包装器。这种包装可以通过有一个调用内部函数的单独函数或通过混合来轻松实现。与许多Python构造一样，装饰器并不是达到目标的唯一方法，但在许多情况下确实很方便。
- en: While you can live perfectly without knowing too much about decorators, they
    give you a lot of "reuse power" and are therefore used heavily in framework libraries
    such as web frameworks. Python actually comes bundled with some useful decorators,
    most notably the `property` decorator.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以完全不了解装饰器，但它们给您带来了很多“重用能力”，因此在框架库中被广泛使用，例如Web框架。Python实际上附带了一些有用的装饰器，最著名的是`property`装饰器。
- en: 'There are, however, some particularities to take note of: wrapping a function
    creates a new function and makes it harder to reach the inner function and its
    properties. One example of this is the `help(function)` functionality of Python;
    by default, you will lose function properties such as the help text and the module
    the function exists in.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有一些需要注意的特殊情况：包装函数会创建一个新函数，并且使得难以访问内部函数及其属性。Python的一个例子是`help(function)`功能；默认情况下，您将丢失函数属性，例如帮助文本和函数存在的模块。
- en: This chapter will cover the usage of both function and class decorators as well
    as the intricate details you need to know when decorating functions within classes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖函数和类装饰器的用法，以及在类内装饰函数时需要了解的复杂细节。
- en: 'The following are the topics covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是涵盖的主题：
- en: Decorating functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰函数
- en: Decorating class functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰类函数
- en: Decorating classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰类
- en: Using classes as decorators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类作为装饰器
- en: Useful decorators in the Python standard library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python标准库中有用的装饰器
- en: Decorating functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰函数
- en: 'Essentially, a decorator is nothing more than a function or class wrapper.
    If we have a function called `spam` and a decorator called `eggs`, then the following
    would decorate `spam` with `eggs`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，装饰器只不过是一个函数或类包装器。如果我们有一个名为`spam`的函数和一个名为`eggs`的装饰器，那么以下内容将使用`eggs`装饰`spam`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To make the syntax easier to use, Python has a special syntax for this case.
    So, instead of adding a line such as the preceding one below the function, you
    can simply decorate a function using the `@` operator:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使语法更易于使用，Python对此情况有一个特殊的语法。因此，您可以使用`@`运算符简单地装饰一个函数，而不是在函数下面添加一行如上面的行：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The decorator simply receives the function and returns a—usually different—function.
    The simplest possible decorator is:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器只是接收函数并返回一个通常不同的函数。最简单的装饰器是：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Looking at the earlier example, we realize that this gets `spam` as the argument
    for `function` and returns that function again, effectively changing nothing.
    Most decorators nest functions, however. The following decorator will print all
    arguments sent to `spam` and pass them to `spam` unmodified:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的例子，我们意识到这将`spam`作为`function`的参数，并再次返回该函数，实际上什么也没有改变。但大多数装饰器会嵌套函数。以下装饰器将打印发送到`spam`的所有参数，并将它们不加修改地传递给`spam`：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This should indicate how powerful decorators can be. By modifying `*args` and
    `**kwargs`, you can add, modify and remove arguments completely. Additionally,
    the return statement can be modified as well. Instead of `return function(...)`,
    you can return something completely different if you wish.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该表明装饰器可以有多么强大。通过修改`*args`和`**kwargs`，您可以完全添加、修改和删除参数。此外，返回语句也可以被修改。您可以返回完全不同的东西，而不是`return
    function(...)`。
- en: Why functools.wraps is important
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么functools.wraps很重要
- en: 'Whenever you are writing a decorator, always be sure to add `functools.wraps`
    to wrap the inner function. Without wrapping it, you will lose all properties
    from the original function, which can lead to confusion. Take a look at the following
    code without `functools.wraps`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每当编写装饰器时，一定要确保添加`functools.wraps`来包装内部函数。如果不包装它，您将丢失原始函数的所有属性，这可能会导致混淆。看看下面的代码，没有`functools.wraps`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, our `spam` method has no documentation anymore and the name is gone. It
    has been renamed to `_eggs`. Since we are indeed calling `_eggs`, this is understandable,
    but it''s very inconvenient for code that relies on this information. Now we will
    try the same code with the minor difference; we will use `functools.wraps`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`spam`方法再也没有文档了，名称也消失了。它已被重命名为`_eggs`。由于我们确实调用了`_eggs`，这是可以理解的，但对于依赖这些信息的代码来说非常不方便。现在我们将尝试使用`functools.wraps`进行相同的代码，只有一个细微的区别：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Without any further changes, we now have documentation and the expected function
    name. The working of `functools.wraps` is nothing magical though; it simply copies
    and updates several attributes. Specifically, the following attributes are copied:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何进一步的更改，我们现在有了文档和预期的函数名称。然而，`functools.wraps`的工作并不神奇；它只是复制和更新了几个属性。具体来说，复制了以下属性：
- en: '`__doc__`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__doc__`'
- en: '`__name__`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__name__`'
- en: '`__module__`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__module__`'
- en: '`__annotations__`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__annotations__`'
- en: '`__qualname__`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__qualname__`'
- en: Additionally, `__dict__` is updated using `_eggs.__dict__.update(spam.__dict__)`,
    and a new property called `__wrapped__` is added, which contains the original
    (`spam` in this case) function. The actual `wraps` function is available in the
    `functools.py` file of your Python distribution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`_eggs.__dict__.update(spam.__dict__)`更新`__dict__`，并添加一个名为`__wrapped__`的新属性，其中包含原始（在本例中为`spam`）函数。实际的`wraps`函数可以在Python分发的`functools.py`文件中找到。
- en: How are decorators useful?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器有什么用？
- en: The use cases for decorators are plentiful, but some of the most useful cases
    are with debugging. More extensive examples of this will be covered in [Chapter
    11](ch11.html "Chapter 11. Debugging – Solving the Bugs"), *Debugging – Solving
    the Bugs* but I can give you a sneak preview of how to use decorators to keep
    track of what your code is doing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的用例很多，但其中一些最有用的用例是调试。关于这一点的更多详细示例将在[第11章](ch11.html "第11章。调试 - 解决错误")中进行介绍，*调试
    - 解决错误*，但我可以给你一个小窥探，看看如何使用装饰器来跟踪代码的运行情况。
- en: Let's assume you have a bunch of functions that may or may not be called, and
    you're not entirely sure what kind of input and output each of these is getting.
    In this case, you could, of course, modify the function and add some print statements
    at the beginning and the end to print the output. This quickly gets tedious, however,
    and it's one of those cases where a simple decorator will make it easy to do the
    same thing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一堆可能被调用或可能不被调用的函数，并且你并不完全确定每个函数的输入和输出是什么。在这种情况下，你当然可以修改函数，并在开始和结束时添加一些打印语句来打印输出。然而，这很快就会变得乏味，这是一个简单的装饰器可以让你轻松做同样的事情的情况之一。
- en: 'For this example, we are using a very simple function, but we all know that
    in real life, we''re not always that lucky:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们使用了一个非常简单的函数，但我们都知道在现实生活中，我们并不总是那么幸运：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s take our simple `spam` function and add some output so that we can see
    what happens internally:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿我们简单的`spam`函数，并添加一些输出，这样我们就可以看到内部发生了什么：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While this works, wouldn't it be far nicer to have a little decorator that takes
    care of this problem?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做是有效的，但是有一个小装饰器来解决这个问题会不会更好呢？
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we have a decorator that we can easily reuse for any function that prints
    the input, output, and function name. This type of decorator can also be very
    useful for logging applications, as we will see in [Chapter 10](ch10.html "Chapter 10. Testing
    and Logging – Preparing for Bugs"), *Testing and Logging – Preparing for Bugs*.
    It should be noted that you can use this example even if you are not able to modify
    the module containing the original code. We can wrap the function locally and
    even monkey-patch the module if needed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个装饰器，可以轻松地重用于打印输入、输出和函数名称的任何函数。这种类型的装饰器在日志应用程序中也非常有用，我们将在[第10章](ch10.html
    "第10章。测试和日志 - 为错误做准备")中看到，*测试和日志 - 为错误做准备*。值得注意的是，即使无法修改包含原始代码的模块，也可以使用此示例。我们可以在本地包装函数，甚至在需要时对模块进行monkey-patch：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Naturally, monkey-patching is not a good idea in production code, but it can
    be very useful when debugging.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在生产代码中使用monkey-patching并不是一个好主意，但在调试时可能非常有用。
- en: Memoization using decorators
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用装饰器进行记忆化
- en: 'Memoization is a simple trick for making some code run a bit faster. The basic
    trick here is to store a mapping of the input and expected output so that you
    have to calculate a value only once. One of the most common examples of this technique
    is when demonstrating the naïve (recursive) Fibonacci function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是使某些代码运行速度更快的一个简单技巧。这里的基本技巧是存储输入和期望输出的映射，这样你只需要计算一次值。这种技术最常见的示例之一是演示天真（递归）的斐波那契函数：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While this example would work just fine without any memoization, for larger
    numbers, it would kill the system. For `n=2`, the function would execute `fibonacci(n
    - 1)` and `fibonacci(n - 2)` recursively, effectively giving an exponential time
    complexity. Also, effectively for `n=30`, the Fibonacci function is called 2,692,537
    times which is still doable nonetheless. At `n=40`, it is going to take you quite
    a very long time to calculate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子在没有任何记忆化的情况下也可以正常工作，但对于更大的数字，它会使系统崩溃。对于`n=2`，函数将递归执行`fibonacci(n - 1)`和`fibonacci(n
    - 2)`，有效地给出指数时间复杂度。此外，对于`n=30`，斐波那契函数被调用了2,692,537次，尽管这仍然是可以接受的。在`n=40`时，计算将需要很长时间。
- en: The memoized version, however, doesn't even break a sweat and only needs to
    execute `31` times for `n=30`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记忆化版本甚至不费吹灰之力，只需要执行`31`次，`n=30`。
- en: This decorator also shows how a context can be attached to a function itself.
    In this case, the cache property becomes a property of the internal (wrapped `fibonacci`)
    function so that an extra `memoize` decorator for a different object won't clash
    with any of the other decorated functions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器还展示了如何将上下文附加到函数本身。在这种情况下，cache属性成为内部（包装的`fibonacci`）函数的属性，因此不同对象的额外`memoize`装饰器不会与任何其他装饰的函数发生冲突。
- en: Note, however, that implementing the memoization function yourself is generally
    not that useful anymore since Python introduced `lru_cache` (least recently used
    cache) in Python 3.2\. The `lru_cache` is similar to the preceding memoize function
    but a bit more advanced. It only maintains a fixed (`128` by default) cache size
    to save memory and uses some statistics to check whether the cache size should
    be increased.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，自己实现记忆化函数通常不再那么有用，因为Python在Python 3.2中引入了`lru_cache`（最近最少使用缓存）。`lru_cache`类似于前面的memoize函数，但更加先进。它只保持一个固定的（默认为128）缓存大小以节省内存，并使用一些统计数据来检查是否应增加缓存大小。
- en: 'To demonstrate how `lru_cache` works internally, we will calculate `fibonacci(100)`,
    which would keep our computer busy until the end of the universe without any caching.
    Moreover, to make sure that we can actually see how many times the `fibonacci`
    function is being called, we''ll add an extra decorator that keeps track of the
    count, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`lru_cache`的内部工作原理，我们将计算`fibonacci(100)`，这将使我们的计算机忙到宇宙的尽头，而没有任何缓存。此外，为了确保我们实际上可以看到`fibonacci`函数被调用的次数，我们将添加一个额外的装饰器来跟踪计数，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You might wonder why we need only 101 calls with a cache size of `3`. That's
    because we recursively require only `n - 1` and `n - 2`, so we have no need of
    a larger cache in this case. With others, it would still be useful though.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么在缓存大小为`3`的情况下我们只需要调用101次。这是因为我们递归地只需要`n - 1`和`n - 2`，所以在这种情况下我们不需要更大的缓存。对于其他情况，它仍然是有用的。
- en: Additionally, this example shows the usage of two decorators for a single function.
    You can see these as the layers of an onion. The first one is the outer layer
    and it works towards the inside. When calling `fibonacci`, `lru_cache` will be
    called first because it's the first decorator in the list. Assuming there is no
    cache available yet, the `counter` decorator will be called. Within the counter,
    the actual `fibonacci` function will be called.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此示例显示了对单个函数使用两个装饰器的用法。您可以将这些视为洋葱的层。第一个是外层，它朝向内部工作。在调用`fibonacci`时，将首先调用`lru_cache`，因为它是列表中的第一个装饰器。假设尚未有缓存可用，将调用`counter`装饰器。在计数器内部，将调用实际的`fibonacci`函数。
- en: Returning the values works in the reverse order, of course; `fibonacci` returns
    its value to `counter`, which passes the value along to `lru_cache`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值当然是按相反的顺序工作的；`fibonacci`将其值返回给`counter`，后者将该值传递给`lru_cache`。
- en: Decorators with (optional) arguments
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带（可选）参数的装饰器
- en: 'The previous examples mostly used simple decorators without any arguments.
    As we have already seen with `lru_cache`, decorators can accept arguments as well
    since they are just regular functions, but this adds an extra layer to a decorator.
    This means that adding an argument can be as simple as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的示例大多使用了没有任何参数的简单装饰器。正如我们已经在`lru_cache`中看到的那样，装饰器也可以接受参数，因为它们只是常规函数，但这会给装饰器增加一个额外的层。这意味着添加参数可以像下面这样简单：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Optional arguments are a different matter, however, because they make the extra
    function layer optional. With arguments, you need three layers, but without arguments,
    you need only two layers. Since decorators are essentially regular functions that
    return functions, the difference would be to return the sub-function or the sub-sub-function,
    based on the parameters. This leaves just one issue—detecting whether the parameter
    is a function or a regular parameter. To illustrate, with the parameters the actual
    call looks like the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可选参数是另一回事，因为它们使额外的函数层变得可选。有参数时，您需要三层，但没有参数时，您只需要两层。由于装饰器本质上是返回函数的常规函数，区别在于返回子函数或子子函数，取决于参数。这只留下一个问题——检测参数是函数还是常规参数。举例说明，使用参数的实际调用如下所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Whereas the call without arguments would look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数的调用将如下所示：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To detect whether the decorator was called with a function or a regular argument
    as a parameter, we have several options, none of which are completely ideal in
    my opinion:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测装饰器是使用函数还是常规参数作为参数调用的，我们有几种选择，但在我看来都不是完全理想的：
- en: Using keyword arguments for decorator arguments so that the regular argument
    will always be the function
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关键字参数作为装饰器参数，以便常规参数始终是函数
- en: Detecting whether the first and only argument is callable
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测第一个且唯一的参数是否可调用
- en: In my opinion, the first one—using keyword arguments—is the better of the two
    options because it is somewhat more explicit and leaves less room for confusion.
    The second option could be problematic if, for some reason, your argument is callable
    as well.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，第一种使用关键字参数的方法是两种选项中更好的，因为它有点更明确，留下的混淆空间较少。如果您的参数也是可调用的话，第二种选项可能会有问题。
- en: 'Using the first method, the normal (non-keyword) argument has to be the decorated
    function and the other two checks can still apply. We can still check whether
    the function is indeed callable and whether there is only a single argument available.
    Here is an example using a modified version of the previous example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一种方法，普通（非关键字）参数必须是装饰函数，其他两个检查仍然适用。我们仍然可以检查函数是否确实可调用，以及是否只有一个可用参数。以下是使用先前示例的修改版本的示例：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Whenever you have the choice available, I recommend that you either have a decorator
    with arguments or without them, instead of having optional arguments. However,
    if you have a really good reason for making the arguments optional, then you have
    a relatively safe method of making this possible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您有选择时，我建议您要么有带参数的装饰器，要么没有，而不是使用可选参数。但是，如果您有一个真正充分的理由使参数可选，那么您有一种相对安全的方法来实现这一点。
- en: Creating decorators using classes
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类创建装饰器
- en: 'Similar to how we create regular function decorators, it is also possible to
    create decorators using classes instead. After all, a function is just a callable
    object and a class can implement the callable interface as well. The following
    decorator works similarly to the `debug` decorator we used earlier, but uses a
    class instead of a regular function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建常规函数装饰器的方式类似，也可以使用类来创建装饰器。毕竟，函数只是一个可调用对象，类也可以实现可调用接口。以下装饰器与我们之前使用的`debug`装饰器类似，但使用的是类而不是常规函数：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only notable difference between functions and classes is that `functools.wraps`
    is now replaced with `functools.update_wrapper` in the `__init__` method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和类之间唯一显著的区别是，在`__init__`方法中，`functools.wraps`现在被`functools.update_wrapper`替换了。
- en: Decorating class functions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰类函数
- en: 'Decorating class functions is very similar to regular functions, but you need
    to be aware of the required first argument, `self`—the class instance. You have
    most likely already used a few class function decorators. The `classmethod`, `staticmethod`,
    and `property` decorators for example, are used in many different projects. To
    explain how all this works, we will build our own versions of the `classmethod`,
    `staticmethod`, and `property` decorators. First, let''s look at a simple decorator
    for class functions to show the difference from regular decorators:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰类函数与常规函数非常相似，但您需要注意所需的第一个参数`self`——类实例。您很可能已经使用了一些类函数装饰器。例如，`classmethod`、`staticmethod`和`property`装饰器在许多不同的项目中都被使用。为了解释所有这些是如何工作的，我们将构建自己版本的`classmethod`、`staticmethod`和`property`装饰器。首先，让我们看一个简单的用于类函数的装饰器，以展示与常规装饰器的区别：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As is the case with regular functions, the class function decorator now gets
    passed along `self` as the instance. Nothing unexpected!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规函数一样，类函数装饰器现在会将`self`作为实例传递。没有什么意外的！
- en: Skipping the instance – classmethod and staticmethod
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过实例 - 类方法和静态方法
- en: The difference between a `classmethod` and a `staticmethod` is fairly simple.
    The `classmethod` passes a class object instead of a class instance (`self`),
    and `staticmethod` skips both the class and the instance entirely. This effectively
    makes `staticmethod` very similar to a regular function outside of a class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`classmethod`和`staticmethod`之间的区别非常简单。`classmethod`传递的是类对象而不是类实例（`self`），而`staticmethod`完全跳过了类和实例。这使得`staticmethod`在类外部非常类似于常规函数。'
- en: 'Before we recreate `classmethod` and `staticmethod`, we need to take a look
    at the expected behavior of these methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新创建`classmethod`和`staticmethod`之前，我们需要了解这些方法的预期行为：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that calling `some_instancemethod` without an instance results in an error
    whereby `self` is missing. As expected (since we didn't instantiate the class
    in that case), for the version with the arguments, it seems to work but it is
    actually broken. This is because the first argument is now assumed to be `self`.
    This is obviously incorrect in this case, where you pass an integer, but if you
    had passed along some other class instance, this could be a source of very strange
    bugs. Both `classmethod` and `staticmethod` handle this correctly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果在没有实例的情况下调用`some_instancemethod`，会导致缺少`self`的错误。正如预期的那样（因为在这种情况下我们没有实例化类），对于带有参数的版本，它似乎可以工作，但实际上是有问题的。这是因为现在假定第一个参数是`self`。在这种情况下显然是不正确的，因为您传递的是一个整数，但如果您传递了其他类实例，这可能是非常奇怪的错误的根源。`classmethod`和`staticmethod`都可以正确处理这种情况。
- en: 'Before we can continue with decorators, you need to be aware of how Python
    descriptors function. Descriptors can be used to modify the binding behavior of
    object attributes. This means that if a descriptor is used as the value of an
    attribute, you can modify which value is being set, get, and deleted when these
    operations are called on the attribute. Here is a basic example of this behavior:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用装饰器之前，您需要了解Python描述符的工作原理。描述符可用于修改对象属性的绑定行为。这意味着如果将描述符用作属性的值，您可以修改在对属性进行这些操作时设置、获取和删除的值。以下是这种行为的基本示例：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, whenever we set or get values from `more_spam`, it actually
    calls `__get__` or `__set__` on `MoreSpam`. A very useful feat for automatic conversions
    and type checking, the `property` decorator we will see in the next paragraph
    is just a more convenient implementation of this technique.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，无论我们从`more_spam`中设置或获取值，实际上都会调用`MoreSpam`上的`__get__`或`__set__`。对于自动转换和类型检查非常有用，我们将在下一段中看到的`property`装饰器只是这种技术的更方便的实现。
- en: 'Now that we know how descriptors work, we can continue with creating the `classmethod`
    and `staticmethod` decorators. For these two, we simply need to modify `__get__`
    instead of `__call__` so that we can control which type of instance (or none at
    all) is passed along:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了描述符是如何工作的，我们可以继续创建`classmethod`和`staticmethod`装饰器。对于这两个装饰器，我们只需要修改`__get__`而不是`__call__`，以便我们可以控制传递哪种类型的实例（或根本不传递）：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ClassMethod` decorator still features a sub-function to actually produce
    a working decorator. Looking at the function, you can most likely guess how it
    functions. Instead of passing `instance` as the first argument to `self.method`,
    it passes `cls`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassMethod`装饰器仍然具有一个子函数来实际生成一个可工作的装饰器。看看这个函数，你很可能猜到它的功能。它不是将`instance`作为`self.method`的第一个参数传递，而是传递`cls`。'
- en: '`StaticMethod` is even simpler, because it completely ignores both the `instance`
    and the `cls`. It can just return the original method unmodified. Because it returns
    the original method without any modifications, we have no need for the `functools.wraps`
    call either.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticMethod`更简单，因为它完全忽略了`instance`和`cls`。它可以直接返回原始方法而不进行任何修改。因为它返回原始方法而不进行任何修改，我们也不需要`functools.wraps`调用。'
- en: Properties – smart descriptor usage
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性 - 智能描述符用法
- en: 'The `property` decorator is probably the most used decorator in Python land.
    It allows you to add getters/setters to existing instance properties so that you
    can add validators and modify your values before setting them to your instance
    properties. The `property` decorator can be used both as an assignment and as
    a decorator. The following example shows both syntaxes so that we know what to
    expect from the `property` decorator:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`property`装饰器可能是Python中最常用的装饰器。它允许您向现有实例属性添加getter/setter，以便您可以在将它们设置为实例属性之前添加验证器和修改值。`property`装饰器可以用作赋值和装饰器。下面的示例展示了这两种语法，以便我们知道从`property`装饰器中可以期望到什么：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `property` decorator works only if the class inherits `object`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`property`装饰器仅在类继承`object`时才起作用。
- en: 'Similar to how we implemented the `classmethod` and `staticmethod` decorators,
    we need the Python descriptors again. This time, we require the full power of
    the descriptors, however—not just `__get__` but `__set__` and `__delete__` as
    well:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们实现`classmethod`和`staticmethod`装饰器的方式类似，我们再次需要Python描述符。这一次，我们需要描述符的全部功能，而不仅仅是`__get__`，还有`__set__`和`__delete__`：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, most of the `Property` implementation is simply an implementation
    of the descriptor methods. The `getter`, `setter`, and `deleter` functions are
    simply shortcuts for making the usage of the decorator possible, which is why
    we have to `return self` if no `instance` is available.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，大部分`Property`实现只是描述符方法的实现。`getter`、`setter`和`deleter`函数只是使装饰器的使用变得可能的快捷方式，这就是为什么如果没有`instance`可用，我们必须`return
    self`。
- en: 'Naturally, there are more methods of achieving this effect. In the previous
    paragraph, we saw the bare descriptor implementation, and in our previous example,
    we saw the property decorator. A somewhat more generic solution for a class is
    to implement `__getattr__` or `__getattribute__`. Here''s a simple demonstration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多实现这种效果的方法。在前面的段落中，我们看到了裸描述符的实现，在我们之前的例子中，我们看到了属性装饰器。一个更通用的类的解决方案是实现 `__getattr__`
    或 `__getattribute__`。这里有一个简单的演示：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `__getattr__` method looks for the key in `instance.__dict__` first and
    is called only if it does not exist. That's why we never see a `__getattr__` for
    the registry attribute. The `__getattribute__` method is called in all cases,
    which makes it a bit more dangerous to use. With the `__getattribute__` method,
    you will need a specific exclusion for `registry` since it will be executed recursively
    if you try to access `self.registry`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattr__` 方法首先在 `instance.__dict__` 中查找键，并且只有在键不存在时才会被调用。这就是为什么我们从来没有看到
    `registry` 属性的 `__getattr__`。`__getattribute__` 方法在所有情况下都会被调用，这使得它使用起来更加危险。使用
    `__getattribute__` 方法时，你需要对 `registry` 进行特定的排除，因为如果你尝试访问 `self.registry`，它将会被递归执行。'
- en: There is rarely a need to look at descriptors, but they are used by several
    internal Python processes, such as the `super()` method when inheriting classes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 很少需要查看描述符，但它们被几个内部 Python 进程使用，比如在继承类时使用 `super()` 方法。
- en: Decorating classes
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰类
- en: Python 2.6 introduced the class decorator syntax. As is the case with the function
    decorator syntax, this is not really a new technique either. Even without the
    syntax, a class can be decorated simply by executing `DecoratedClass = decorator(RegularClass)`.
    After the previous paragraphs, you should be familiar with writing decorators.
    Class decorators are no different from regular ones, except for the fact that
    they take a class instead of a function. As is the case with functions, this happens
    at declaration time and *not* at instantiating/calling time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.6 引入了类装饰器语法。与函数装饰器语法一样，这实际上也不是一种新技术。即使没有语法，一个类也可以通过简单地执行 `DecoratedClass
    = decorator(RegularClass)` 来装饰。在前面的段落中，你应该已经熟悉了编写装饰器。类装饰器与常规装饰器没有什么不同，只是它们接受一个类而不是一个函数。与函数一样，这发生在声明时而不是在实例化/调用时。
- en: Because there are quite a few alternative ways to modify how classes work, such
    as standard inheritance, mixins, and metaclasses (more about that in [Chapter
    8](ch08.html "Chapter 8. Metaclasses – Making Classes (Not Instances) Smarter"),
    *Metaclasses – Making Classes (Not Instances) Smarter*), class decorators are
    never strictly needed. This does not reduce their usefulness, but it does offer
    an explanation of why you will most likely not see too many examples of class
    decorating in the wild.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有很多修改类工作方式的替代方法，比如标准继承、混入和元类（关于这一点在[第8章](ch08.html "第8章。元类 - 使类（而不是实例）更智能")中有更多介绍，*元类
    - 使类（而不是实例）更智能*），类装饰器从来都不是绝对必需的。这并不减少它们的用处，但它确实解释了为什么你很可能不会在野外看到太多类装饰的例子。
- en: Singletons – classes with a single instance
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例 - 只有一个实例的类
- en: 'Singletons are classes that always allow only a single instance to exist. So,
    instead of getting an instance specifically for your call, you always get the
    same one. These can be very useful for things such as a database connection pool,
    where you don''t want to keep opening connections all of the time but want to
    reuse the original ones:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是始终只允许存在一个实例的类。因此，你总是得到相同的实例，而不是为你的调用获取一个特定的实例。这对于诸如数据库连接池之类的事物非常有用，你不想一直打开连接，而是想重用原始连接。
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see in the `a is b` comparison, both objects have the same identity,
    so we can conclude that they are indeed the same object. As is the case with regular
    decorators, due to the `functools.wraps` functionality, we can still access the
    original class through `Spam.__wrapped__` if needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 `a is b` 比较中看到的，两个对象具有相同的标识，所以我们可以得出它们确实是同一个对象。与常规装饰器一样，由于 `functools.wraps`
    功能，如果需要，我们仍然可以通过 `Spam.__wrapped__` 访问原始类。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `is` operator compares objects by identity, which is implemented as the
    memory address in CPython. If `a is b` returns `True`, we can conclude that both
    `a` and `b` are the same instance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`is` 运算符通过标识比较对象，这在 CPython 中是以内存地址实现的。如果 `a is b` 返回 `True`，我们可以得出结论，`a` 和
    `b` 都是同一个实例。'
- en: Total ordering – sortable classes the easy way
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全排序 - 简单的可排序类
- en: 'At some point or the other, you have probably needed to sort data structures.
    While this is easily achievable using the key parameter to the `sorted` function,
    there is a more convenient way if you need to do this often—by implementing the
    `__gt__`, `__ge__`, `__lt__`, `__le__`, and `__eq__` functions. That seems a bit
    verbose, doesn''t it? If you want the best performance, it''s still a good idea,
    but if you can take a tiny performance hit and some slightly more complicated
    stack traces, then `total_ordering` might be a nice alternative. The `total_ordering`
    class decorator can implement all required sort functions based on a class that
    possesses an `__eq__` function and one of the comparison functions (`__lt__`,
    `__le__`, `__gt__`, or `__ge__`). This means you can seriously shorten your function
    definitions. Let''s compare the regular one and the one using the `total_ordering`
    decorator:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能需要对数据结构进行排序。虽然可以使用 `sorted` 函数的 key 参数轻松实现这一点，但如果你经常需要这样做，还有一种更方便的方法
    - 通过实现 `__gt__`、`__ge__`、`__lt__`、`__le__` 和 `__eq__` 函数。这似乎有点冗长，不是吗？如果你想要最佳性能，这仍然是一个好主意，但如果你可以承受一点性能损失和一些稍微复杂的堆栈跟踪，那么
    `total_ordering` 可能是一个不错的选择。`total_ordering` 类装饰器可以基于具有 `__eq__` 函数和比较函数之一（`__lt__`、`__le__`、`__gt__`
    或 `__ge__`）的类实现所有必需的排序函数。这意味着你可以严重缩短你的函数定义。让我们比较常规的函数和使用 `total_ordering` 装饰器的函数：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, you might be wondering, "Why isn''t there a class decorator to make a
    class sortable using a specified key property?" Well, that might indeed be a good
    idea for the `functools` library but it isn''t there yet. So let''s see how we
    would implement something like it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想，“为什么没有一个类装饰器来使用指定的键属性使类可排序？”嗯，这确实可能是`functools`库的一个好主意，但它还没有。所以让我们看看我们如何实现类似的东西：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Certainly, this greatly simplifies the making of a sortable class. And if you
    would rather have your own key function instead of `getattr`, it's even easier.
    Simply replace the `getattr(self, attr)` call with `key_function(self)`, do that
    for `other` as well, and change the argument for the decorator to your function.
    You can even use that as the base function and implement `sort_by_attribute` by
    simply passing a wrapped `getattr` function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这极大地简化了可排序类的制作。如果你宁愿使用自己的键函数而不是`getattr`，那就更容易了。只需用`key_function(self)`替换`getattr(self,
    attr)`调用，对`other`也这样做，并将装饰器的参数更改为你的函数。你甚至可以将其用作基本函数，并通过简单地传递一个包装的`getattr`函数来实现`sort_by_attribute`。
- en: Useful decorators
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的装饰器
- en: In addition to the ones already mentioned in this chapter, Python comes bundled
    with a few other useful decorators. There are some that aren't in the standard
    library (yet?).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章已经提到的之外，Python还捆绑了一些其他有用的装饰器。还有一些不在标准库中的（还没有？）。
- en: Single dispatch – polymorphism in Python
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的单分派——多态
- en: If you've used C++ or Java before, you're probably used to having ad hoc polymorphism
    available—different functions being called depending on the argument types. Python
    being a dynamically typed language, most people would not expect the possibility
    of a single dispatch pattern. Python, however, is a language that is not only
    dynamically typed but also strongly typed, which means we can rely on the type
    we receive.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前使用过C++或Java，你可能已经习惯了可用的特定多态性——根据参数类型调用不同的函数。Python作为一种动态类型语言，大多数人不会期望存在单分派模式的可能性。然而，Python不仅是一种动态类型的语言，而且是一种强类型的语言，这意味着我们可以依赖我们收到的类型。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A dynamically typed language does not require strict type definitions. On the
    other hand, a language such as C would require the following to declare an integer:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型的语言不需要严格的类型定义。另一方面，像C这样的语言需要以下内容来声明一个整数：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Python simply accepts that your value has a type:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Python只是接受你的值有一个类型：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As opposed to languages such as JavaScript and PHP, however, Python does very
    little implicit type conversion. In Python, the following will return an error,
    whereas JavaScript would execute it without any problems:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与JavaScript和PHP等语言相反，Python几乎不进行隐式类型转换。在Python中，以下内容将返回错误，而在JavaScript中将无任何问题地执行：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In Python, the result is a `TypeError`. In Javascript, it's `'spam5'`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，结果是`TypeError`。在Javascript中，是`'spam5'`。
- en: The idea of single dispatch is that depending on the type you pass along, the
    correct function is called. Since `str + int` results in an error in Python, this
    can be very convenient to automatically convert your arguments before passing
    them to your function. This can be useful to separate the actual workings of your
    function from the type conversions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 单分派的想法是，根据你传递的类型，调用正确的函数。由于在Python中`str + int`会导致错误，这可以非常方便地在将参数传递给函数之前自动转换你的参数。这对于将函数的实际工作与类型转换分离开来非常有用。
- en: 'Since Python 3.4, there is a decorator that makes it easily possible to implement
    the single dispatch pattern in Python. For one of those cases that you need to
    handle a specific type different from the normal execution. Here is the basic
    example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.4以来，有一个装饰器可以轻松实现Python中的单分派模式。对于那些需要处理与正常执行不同的特定类型的情况之一。这是一个基本的例子：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See how, depending on the type, the other functions were called? This pattern
    can be very useful for reducing the complexity of a single function that takes
    several types of argument.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了吗，根据类型，其他函数被调用了吗？这种模式对于减少接受多种类型参数的单个函数的复杂性非常有用。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When naming the functions, make sure that you do not overwrite the original
    `singledispatch` function. If we had named `str_printer` as just `printer`, it
    would overwrite the initial `printer` function. This would make it impossible
    to access the original `printer` function and make all `register` operations after
    that fail as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名函数时，请确保不要覆盖原始的`singledispatch`函数。如果我们将`str_printer`命名为`printer`，它将覆盖最初的`printer`函数。这将使得无法访问原始的`printer`函数，并且在此之后的所有`register`操作也将失败。
- en: 'Now, a slightly more useful example—differentiating between a filename and
    a file handler:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个稍微更有用的例子——区分文件名和文件处理程序：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So now we have a single `write_as_json` function; it calls the right code depending
    on the type. If it's an `str` or `bytes` object, it will automatically open the
    file and call the regular version of `write_as_json`, which accepts file objects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们有了一个单一的`write_as_json`函数；它根据类型调用正确的代码。如果是`str`或`bytes`对象，它将自动打开文件并调用`write_as_json`的常规版本，该版本接受文件对象。
- en: Writing a decorator that does this is not that hard to do, of course, but it's
    still quite convenient to have it in the base library. It most certainly beats
    a couple of `isinstance` calls in your function. To see which function will be
    called, you can use the `write_as_json.dispatch` function with a specific type.
    When passing along an `str`, you will get the `write_as_json_filename` function.
    It should be noted that the name of the dispatched functions is completely arbitrary.
    They are accessible as regular functions, of course, but you can name them anything
    you like.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，编写一个能够做到这一点的装饰器并不难，但在基本库中拥有它仍然非常方便。这肯定比在函数中进行几次`isinstance`调用要好。要查看将调用哪个函数，可以使用特定类型的`write_as_json.dispatch`函数。传递一个`str`时，将得到`write_as_json_filename`函数。应该注意，分派函数的名称是完全任意的。它们当然可以像常规函数一样访问，但你可以随意命名它们。
- en: 'To check the registered types, you can access the registry, which is a dictionary,
    through `write_as_json.registry`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查已注册的类型，可以通过`write_as_json.registry`访问字典注册表：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Contextmanager, with statements made easy
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器，简化了with语句
- en: 'Using the `contextmanager` class, we can make the creation of a context wrapper
    very easy. Context wrappers are used whenever you use a `with` statement. One
    example is the open function, which works as a context wrapper as well, allowing
    you to use the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`contextmanager`类，我们可以很容易地创建上下文包装器。上下文包装器在使用`with`语句时使用。一个例子是`open`函数，它也可以作为上下文包装器工作，允许你使用以下代码：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s just assume for now that the `open` function is not usable as a context
    manager and that we need to build our own function to do this. The standard method
    of creating a context manager is by creating a class that implements the `__enter__`
    and `__exit__` methods, but that''s a bit verbose. We can have it shorter and
    simpler:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时假设`open`函数不能作为上下文管理器使用，我们需要构建自己的函数来实现这一点。创建上下文管理器的标准方法是创建一个实现`__enter__`和`__exit__`方法的类，但这有点冗长。我们可以让它更短更简单：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Simple, right? However, I should mention that for this specific case—the closing
    of objects—there is a dedicated function in `contextlib`, and it is even easier
    to use. Let''s demonstrate it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？然而，我应该提到，对于这种特定情况——对象的关闭——在`contextlib`中有一个专门的函数，它甚至更容易使用。让我们来演示一下：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For a `file` object, this is of course not needed since it already functions
    as a context manager. However, some objects such as requests made by `urllib`
    don't support automatic closing in that manner and benefit from this function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`file`对象，这当然是不需要的，因为它已经作为上下文管理器起作用。然而，一些对象，比如`urllib`发出的请求，不支持以这种方式自动关闭，并且从这个函数中受益。
- en: 'But wait; there''s more! In addition to being usable in a `with` statement,
    the results of a `contextmanager` are actually usable as decorators since Python
    3.2\. In older Python versions, it was simply a small wrapper, but since Python
    3.2 it''s based on the `ContextDecorator` class, which makes it a decorator. The
    previous decorator isn''t really suitable for that task since it yields a result
    (more about that in [Chapter 6](ch06.html "Chapter 6. Generators and Coroutines
    – Infinity, One Step at a Time"), *Generators and Coroutines – Infinity, One Step
    at a Time*), but we can think of other functions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等；还有更多！除了可以在`with`语句中使用之外，`contextmanager`的结果实际上也可以作为装饰器使用，自Python 3.2起。在较早的Python版本中，它只是一个小包装器，但自Python
    3.2起，它基于`ContextDecorator`类，这使它成为一个装饰器。之前的装饰器并不适合这个任务，因为它产生了一个结果（关于这一点，可以在[第6章](ch06.html
    "第6章. 生成器和协程-无限，一步一步")中了解更多，*生成器和协程-无限，一步一步*），但我们可以考虑其他函数：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There are quite a few nice use cases for this, but at the very least, it's just
    a convenient way to wrap a function in a context without all the (nested) `with`
    statements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多很好的用例，但至少，它是一个方便的方式来在上下文中包装一个函数，而不需要所有（嵌套的）`with`语句。
- en: Validation, type checks, and conversions
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证、类型检查和转换
- en: 'While checking for types is usually not the best way to go in Python, at times
    it can be useful if you know that you will need a specific type (or something
    that can be cast to that type). To facilitate this, Python 3.5 introduces a type
    hinting system so that you can do the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Python中检查类型通常不是最佳选择，但有时如果你知道你需要一个特定的类型（或者可以转换为该类型的东西），它可能是有用的。为了方便起见，Python
    3.5引入了类型提示系统，这样你就可以这样做：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since Python 3.5 is not that common yet, here''s a decorator that achieves
    the same with more advanced type checking. To allow for this type of checking,
    some magic has to be used, specifically the usage of the `inspect` module. Personally,
    I am not a great fan of inspecting code to perform tricks like these, as they
    are easy to break. This piece of code actually breaks when a regular decorator
    (one that doesn''t copy `argspec`) is used between the function and this decorator,
    but it''s a nice example nonetheless:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python 3.5还不太常见，这里有一个装饰器，它实现了更高级的类型检查。为了允许这种类型的检查，必须使用一些魔法，特别是使用`inspect`模块。就我个人而言，我不太喜欢检查代码来执行这样的技巧，因为它们很容易被破坏。这段代码实际上在函数和这个装饰器之间使用一个常规装饰器（不复制`argspec`）时会出错，但它仍然是一个很好的例子：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Because of the `inspect` magic, I''m still not sure whether I would recommend
    using the decorator like this. Instead, I would opt for a simpler version that
    uses no `inspect` whatsoever and simply parses the arguments from `kwargs`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`inspect`的魔法，我仍然不确定是否推荐像这样使用装饰器。相反，我会选择一个更简单的版本，它完全不使用`inspect`，只是从`kwargs`中解析参数：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: However, as demonstrated, supporting both `args` and `kwargs` is not impossible
    as long as you keep in mind that `__signature__` is not copied by default. Without
    `__signature__`, the inspect module won't know which parameters are allowed and
    which aren't.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如所示，支持`args`和`kwargs`并不是不可能的，只要记住默认情况下不会复制`__signature__`。没有`__signature__`，inspect模块就不知道哪些参数是允许的，哪些是不允许的。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The missing `__signature__` issue is currently being discussed and might be
    solved in a future Python version:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的`__signature__`问题目前正在讨论中，可能会在未来的Python版本中得到解决：
- en: '[http://bugs.python.org/issue23764](http://bugs.python.org/issue23764).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bugs.python.org/issue23764](http://bugs.python.org/issue23764)。'
- en: Useless warnings – how to ignore them
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无用的警告-如何忽略它们
- en: 'Generally when writing Python, warnings are very useful the first time when
    you''re actually writing the code. When executing it, however, it is not useful
    to get that same message every time you run your script/application. So, let''s
    create some code that allows easy hiding of the expected warnings, but not all
    of them so that we can easily catch new ones:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在编写Python代码时，警告在你第一次编写代码时非常有用。但在执行代码时，每次运行脚本/应用程序时得到相同的消息是没有用的。因此，让我们创建一些代码，可以轻松隐藏预期的警告，但不是所有的警告，这样我们就可以轻松地捕获新的警告：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using this method, we can catch the first (expected) warning and still see the
    second (not expected) warning.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以捕获第一个（预期的）警告，并且仍然可以看到第二个（不期望的）警告。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter showed us some of the places where decorators can be used to make
    our code simpler and add some fairly complex behavior to very simple functions.
    Truthfully, most decorators are more complex than the regular function would have
    been by simply adding the functionality directly, but the added advantage of applying
    the same pattern to many functions and classes is generally well worth it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了装饰器可以用于简化代码并向非常简单的函数添加一些相当复杂的行为的一些地方。事实上，大多数装饰器比直接添加功能的常规函数更复杂，但将相同的模式应用于许多函数和类的附加优势通常是非常值得的。
- en: 'Decorators have so many uses to make your functions and classes smarter and
    more convenient to use:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器有很多用途，可以使您的函数和类更智能、更方便使用：
- en: Debugging
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Validation
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Argument convenience (pre-filling or converting arguments)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数方便（预填充或转换参数）
- en: Output convenience (converting the output to a specific type)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出方便（将输出转换为特定类型）
- en: The most important takeaway of this chapter should be to never forget `functools.wraps`
    when wrapping a function. Debugging decorated functions can be rather difficult
    because of (unexpected) behavior modification, but losing attributes as well can
    make that problem much worse.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的收获应该是在包装函数时永远不要忘记`functools.wraps`。由于（意外的）行为修改，调试装饰函数可能会非常困难，但丢失属性也会使这个问题变得更糟。
- en: The next chapter will show us how and when to use `generators` and `coroutines`.
    This chapter has already shown us the usage of the `with` statement slightly,
    but `generators` and `coroutines` go much further with this. We will still be
    using decorators often though, so make sure you have a good understanding of how
    they work.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将向我们展示如何以及何时使用`生成器`和`协程`。本章已经向我们展示了`with`语句的使用，但`生成器`和`协程`在这方面更进一步。尽管如此，我们仍然经常使用装饰器，所以确保你对它们的工作原理有很好的理解。
