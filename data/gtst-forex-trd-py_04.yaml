- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: 'Trading Application: What’s Inside?'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易应用：里面有什么？
- en: Almost any application that implements a trading strategy has a number of more
    or less standard components. Let’s first have a quick look at a somewhat generalized
    architecture of a typical trading application and then go into greater detail
    on specific points related to the development of a trading strategy using Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何实现交易策略的应用程序都有一些或多或少标准的组件。让我们首先快速看一下典型交易应用的一种较为通用的架构，然后我们将更详细地探讨与使用Python开发交易策略相关的具体点。
- en: In [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014)*, Developing Trading Strategies
    – Why They Are Different*, we saw a very generalized diagram of a typical trading
    application. Now, we are going to consider its blocks in greater detail. We will
    learn how to connect our application to data sources and trading venues, how to
    retrieve data and check its consistency, and consider important points about trading
    logic and orders.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B19145_01.xhtml#_idTextAnchor014)*，开发交易策略——为什么它们不同*中，我们看到了一个典型的交易应用的非常通用的图。现在，我们将更详细地考虑其模块。我们将学习如何将我们的应用程序连接到数据源和交易场所，如何检索数据并检查其一致性，以及考虑有关交易逻辑和订单的重要点。
- en: By the end of this chapter, you will understand how to develop the main components
    of a trading application that is efficient, maintainable, and scalable, and how
    to avoid typical serious problems that arise due to incorrect market data processing,
    mistakes in trading logic, and insufficient understanding of the trade mechanics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何开发高效、可维护和可扩展的交易应用的主要组件，以及如何避免由于市场数据处理错误、交易逻辑错误和对交易机制理解不足而出现的典型严重问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Have your app talk to the world – the gloomy world of communication protocols
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的应用与世界对话——那阴暗的通信协议世界
- en: Retrieving data – garbage in, garbage out
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索数据——垃圾进，垃圾出
- en: Trading logic – this is where a small mistake may cost a fortune
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易逻辑——这里的一个小错误可能代价巨大
- en: Risk management – your safety belt
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风险管理——你的安全带
- en: Ordering interfaces – make sure you are understood correctly
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单接口——确保你被正确理解
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need Python 3.9 or above to run the code in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要Python 3.9或更高版本来运行本章中的代码。
- en: Have your app talk to the world – the gloomy world of communication protocols
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让你的应用与世界对话——那阴暗的通信协议世界
- en: Well, actually, in this section, I could just say, *“in the world of FX automated
    trading every setup is unique, so go ask your broker.”* Of course, I am not going
    to do this but when it comes to connecting your app to a market maker, **electronic
    communication network** (**ECN**), or any other trading venue, always keep in
    mind what I said at the beginning of this section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上，在这一节中，我可以说，“在FX自动化交易的世界里，每个设置都是独特的，所以去问你的经纪人。”当然，我不会这样做，但当涉及到将您的应用程序连接到做市商、**电子通信网络**（**ECN**）或任何其他交易场所时，请始终记住我在本节开头所说的话。
- en: As you remember from the previous chapter, the FX market is still the most fragmented
    one from the trading standpoint; so there should be no surprise that its computerized
    infrastructure is also very fragmented. Even though there’s a standard for exchanging
    financial information, many trading venues use their own dialects, which simply
    means extra work in cases where you want to use your application with a different
    broker. At the same time, many trading venues offer their own APIs and protocols
    not compatible with anything else so developers never lose their jobs and are
    perpetually adapting their applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上一章所记得的，外汇市场在交易方面仍然是分割最严重的；因此，其计算机化基础设施也非常分割。尽管有交换金融信息的标准，但许多交易场所使用自己的方言，这意味着如果您想使用您的应用程序与不同的经纪人合作，将需要额外的工作。同时，许多交易场所提供自己的API和协议，这些协议与其他任何东西都不兼容，因此开发者永远不会失业，并且永远在适应他们的应用程序。
- en: Having said all that, let’s start with something that is generally considered
    the only industry standard for communication used in trading applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们从通常被认为是用于交易应用中唯一的行业标准通信开始。
- en: FIX – universal but too flexible
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FIX – 通用但过于灵活
- en: In my opinion, despite its hard-to-read syntax, **financial information exchange**
    (**FIX**) is the best choice to start diving into trading communications because
    its messages can at least be read by a human – thus, debugging and learning our
    own mistakes will ensure the steepest learning curve.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，尽管其语法难以阅读，**金融信息交换**（**FIX**）仍然是开始深入研究交易通信的最佳选择，因为其消息至少可以被人类阅读——因此，调试和学习我们的错误将确保学习曲线最陡峭。
- en: Unfortunately, FIX is considered a protocol mostly for professional use and
    is not available out of the box to any trader from any broker. One of the possible
    reasons for this discrimination is that FIX allows you to send any instructions
    and the receiving server checks only syntax but not the meaning of the message.
    So, potentially, it may damage not only the trader’s account but even the market
    itself. Therefore, most of the biggest market makers, brokers, and banks require
    professional status from the trader to allow them to use FIX.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，FIX被认为主要是一种专业用途的协议，并且任何经纪商的任何交易者都无法直接使用。这种歧视的一个可能原因是FIX允许你发送任何指令，而接收服务器只检查语法，而不检查消息的含义。因此，它可能不仅会损害交易者的账户，甚至可能损害市场本身。因此，大多数最大的做市商、经纪商和银行都要求交易者具有专业状态，才能允许他们使用FIX。
- en: 'However, there’s good news: many smaller but ambitious FX brokers today offer
    a lot of formerly institutional-only services to retail traders. This doesn’t
    mean that the quality of their business is low: they simply need turnover and
    it’s clear that automated trading strategies generate it way better than manual
    traders. So, in reality, anyone can get access to institutional liquidity from
    an ECN using FIX.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有好消息：如今，许多规模虽小但雄心勃勃的FX经纪商向零售交易者提供了许多以前仅限于机构的交易服务。这并不意味着他们的服务质量低：他们只是需要交易量，而很明显，自动化交易策略比人工交易者能更好地产生交易量。因此，实际上，任何人都可以通过ECN使用FIX获取机构流动性。
- en: Besides that, who knows, maybe one day you will find yourself working with a
    bank or an investment fund, and then even a general understanding of FIX will
    help you a lot to further your career.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，谁知道呢，也许有一天你会发现自己在与银行或投资基金合作，那时即使对FIX的一般了解也会对你的职业发展大有裨益。
- en: So, what is FIX anyway?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，FIX究竟是什么呢？
- en: FIX is an attempt to create a really universal standard that could be used in
    virtually any situation when you need to transfer financial-related information.
    It is used by banks, brokers, information agencies, and even insurance companies,
    along with many others. Of course, such a wide variety of use cases assumes a
    great degree of flexibility to customize FIX the way you need, and this degree
    of flexibility paradoxically makes FIX less standard than it aimed to be.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: FIX试图创建一个真正通用的标准，几乎在任何需要传输金融相关信息的场合都可以使用。它被银行、经纪商、信息机构甚至保险公司等许多其他机构使用。当然，如此广泛的应用场景假设了极大的灵活性，以便根据需要定制FIX，而这种灵活性反讽地使得FIX不如它所期望的那样标准化。
- en: For example, some trading venues may require various tags (basic elements of
    the FIX protocol) as mandatory while others don’t. Some trading venues support
    limit and stop orders, while others acknowledge only market orders. So, it will
    require some refactoring if you want to port your trading app from one broker
    to another because FIX doesn’t *require* any particular order type to be accepted.
    The list may continue but, in essence, the problem is that FIX aims to support
    *any* market but trading venues use only a *subset* of its tags that are relevant
    to their market, frequently adapting the standard to their needs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一些交易场所可能要求各种标签（FIX协议的基本元素）为强制性的，而其他则不要求。一些交易场所支持限价和止损订单，而其他只认可市价订单。因此，如果你想将你的交易应用从一个经纪商迁移到另一个经纪商，可能需要进行一些重构，因为FIX并不*要求*接受任何特定的订单类型。列表可以继续，但本质上问题是FIX旨在支持*任何*市场，但交易场所只使用其标签的*子集*，这些标签与其市场相关，经常根据他们的需求调整标准。
- en: I think that it’s best to consider FIX not only as a protocol or API but rather
    as a special language with a simple syntax that allows you to convey virtually
    any meaning. You can also consider it as a framework used to build messages rather
    than applications and the meaning of the message will depend on the context and
    environment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最好将FIX不仅仅视为一种协议或API，而更应将其视为一种具有简单语法的特殊语言，它允许你传达几乎任何含义。你也可以将其视为一个用于构建消息而不是应用的框架，而消息的含义将取决于上下文和环境。
- en: Let’s look at FIX as a protocol in the first place and consider its layers.
    It will help you understand the way we work with FIX connections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看FIX作为一种协议，并考虑其层。这将帮助你理解我们如何与FIX连接工作。
- en: Basic connection
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本连接
- en: On the transport layer, FIX requires a standard socket connection. Again, as
    I mentioned at the beginning of this section, everything is very individual because
    various brokers and trading venues may have different requirements for the way
    clients connect to them. Normally, you must provide the broker or the trading
    venue with an IP address (or range of addresses) to whitelist and connect using
    a **Transmission Control Protocol socket** (**TCP socket**). Others may require
    complex authorization mechanisms and even the mandatory use of a VPN. So, you
    may want to consult your broker or trading venue for details.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输层，FIX需要一个标准的套接字连接。再次，正如我在本节开头提到的，一切都非常个性化，因为不同的经纪人和交易场所可能对客户端连接到他们的方式有不同的要求。通常，你必须向经纪商或交易场所提供一个IP地址（或地址范围）以进行白名单并使用**传输控制协议套接字**（**TCP套接字**）进行连接。其他人可能需要复杂的授权机制，甚至强制使用VPN。因此，你可能需要咨询你的经纪商或交易场所以获取详细信息。
- en: Learning basic low-level networking such as how to establish a socket connection
    in Python is not the goal of this book, so if you have never done that before
    I’d recommend starting with an excellent guide from Real Python ([https://realpython.com/python-sockets](https://realpython.com/python-sockets)),
    or if you prefer a *dive or swim* approach based on language in action with lots
    of live examples, you can watch this tutorial from Geeks for Geeks ([https://www.geeksforgeeks.org/socket-programming-python/](https://www.geeksforgeeks.org/socket-programming-python/)).
    The point is, establishing a socket connection in Python is not rocket science
    but rather a simple routine procedure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 学习基本的低级网络，例如如何在Python中建立套接字连接，并不是这本书的目标，所以如果你以前从未做过，我建议从Real Python的一个优秀指南开始（[https://realpython.com/python-sockets](https://realpython.com/python-sockets)），或者如果你更喜欢基于实际操作语言并包含大量实例的“深入”或“游泳”方法，你可以观看Geeks
    for Geeks的这篇教程（[https://www.geeksforgeeks.org/socket-programming-python/](https://www.geeksforgeeks.org/socket-programming-python/)）。重点是，在Python中建立套接字连接并不是火箭科学，而是一个简单的常规程序。
- en: Tags
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签
- en: 'Once a socket connection is established, we’re ready to send and receive some
    meaningful information over it. As with many other protocols, FIX is based on
    messages. A FIX message is a plain text (ASCII) string that in turn consists of
    blocks (substrings) delimited by a non-printable character 0x01 (`SOH`) without
    any special ending characters such as `\n` or `\r`. Each block between delimiters
    follows a simple syntax:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了套接字连接，我们就可以通过它发送和接收一些有意义的信息。与许多其他协议一样，FIX基于消息。FIX消息是一个纯文本（ASCII）字符串，它由非打印字符0x01（`SOH`）分隔的块（子字符串）组成，没有像`\n`或`\r`这样的特殊结束字符。每个分隔符之间的块遵循简单的语法：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A **tag** is a number and its value can be any string that cannot contain the
    0x01 character for obvious reasons: it will be interpreted as a delimiter. There
    is one important exception though: in the case that the tag means retrieving data,
    any value used as data may be an arbitrary sequence of bytes.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签**是一个数字，其值可以是任何不包含0x01字符的字符串，这是出于明显的理由：它将被解释为分隔符。不过，有一个重要的例外：如果标签意味着检索数据，那么用作数据的任何值都可以是任意字节序列。'
- en: For example, `55=EUR/USD` represents a currency pair, instrument, or symbol
    (remember, they are all synonyms). `40=Limit` means that the message contains
    a limit order (see [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044)*, FX Market
    Overview from a Developer’s Standpoint*, for an explanation of types of orders).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`55=EUR/USD`代表一个货币对、工具或符号（记住，它们都是同义词）。`40=Limit`表示消息包含一个限价订单（参见[*第3章*](B19145_03.xhtml#_idTextAnchor044)*，从开发者的角度来看的FX市场概述*，以了解订单类型）。
- en: 'Since the delimiter character 0x01 is non-printable, many authors use special
    characters to divide tags in a FIX message visually. I’m sure you’ll agree that
    it is easier to read a string that is structured as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分隔符字符0x01是非打印的，许多作者使用特殊字符在FIX消息中视觉上分隔标签。我相信你会同意，以下结构的字符串更容易阅读：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Whereas, reading the following string is more difficult:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，阅读以下字符串更困难：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, do not ever use any other delimiter than 0x01 in real FIX messages!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在真实的FIX消息中，永远不要使用除0x01之外的任何其他分隔符！
- en: Message structure
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息结构
- en: 'Any FIX message is composed of the following three logical parts:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何FIX消息都由以下三个逻辑部分组成：
- en: Standard header
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准头
- en: Body
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体
- en: Standard trailer
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准尾迹
- en: 'The standard header always consists of the following three tags sent in this
    very order and not any other:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标准头始终由以下三个标签按此顺序发送，而不是其他任何顺序：
- en: '`tag 8` – means that the message begins and it contains the version of the
    FIX protocol used by both parties'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签8` – 表示消息开始，并包含双方使用的FIX协议版本。'
- en: '`tag 9` – the message body length'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签9` – 消息体长度'
- en: '`tag 35` – the message type (for example, `request for quote`, `order`, `logon`,
    or `logout`)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签35` – 消息类型（例如，`报价请求`、`订单`、`登录`或`登出`）'
- en: The standard trailer always ends with tag 10, whose value is the message checksum.
    A checksum is a small piece of data that is returned by a hash function – a function
    that processes all bits of a meaningful block of data and compresses it according
    to a special algorithm. Checksums are used to make sure that a block of data (a
    message in our case) was delivered without errors. If you want to learn more about
    checksums, hash functions, and related matters, I’d recommend starting with an
    excellent article on Wikipedia ([https://en.wikipedia.org/wiki/Checksum](https://en.wikipedia.org/wiki/Checksum))
    that also has references for further reading.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 标准拖车总是以标签10结束，其值是消息校验和。校验和是哈希函数返回的一小段数据——一种处理有意义数据块的所有位并根据特殊算法压缩它的函数。校验和用于确保数据块（在我们的情况下是消息）在无错误的情况下被传递。如果您想了解更多关于校验和、哈希函数和相关内容的信息，我建议从维基百科上一篇优秀的文章开始，该文章还提供了进一步阅读的参考文献（[https://en.wikipedia.org/wiki/Checksum](https://en.wikipedia.org/wiki/Checksum)）。
- en: According to the FIX standard, a tag must have only one occurrence per message.
    Messages with multiple occurrences of the same tag will be rejected by the target
    computer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据FIX标准，每个标签在每个消息中只能出现一次。具有相同标签多次出现的消息将被目标计算机拒绝。
- en: Tags must have a value. In case no value is specified for any tag, the entire
    message will be rejected as well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 标签必须有一个值。如果没有为任何标签指定值，整个消息将被拒绝。
- en: Sessions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话
- en: 'Working with FIX is organized in sessions. A session assumes there are two
    computers involved: the one that sends the message (*sender*, the respective tag
    is called `SenderCompID`) and the one that receives the message (*target*, the
    respective tag is called `TargetCompID`). Normally, the session is initiated by
    a client connecting to a server, for example, a trader connecting to the broker
    or a bank connecting to an ECN.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FIX进行工作是有组织的会话。会话假设有两个计算机参与：发送消息的计算机（*发送方*，相应的标签称为`SenderCompID`）和接收消息的计算机（*目标*，相应的标签称为`TargetCompID`）。通常，会话是由客户端连接到服务器开始的，例如，交易员连接到经纪人或银行连接到ECN。
- en: 'A session starts by sending a handshake message from the sender’s computer
    to the target computer. In cases where there is a reply from the target computer,
    this message initiates the session. This message type (tag 35) is `Logon (A)`.
    A sample handshake message header will look as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是通过从发送方的计算机向目标计算机发送握手消息开始的。在目标计算机有回复的情况下，这条消息启动会话。这种消息类型（标签35）是`登录（A）`。一个示例握手消息头将如下所示：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding message, `XX` stands for the entire message length (see an
    explanation of tag 9 in the *Message* section).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的消息中，`XX`代表整个消息长度（见*消息*部分中标签9的解释）。
- en: Now, we have come to the point where my initial thesis (go and ask your broker
    for details) becomes apparent. The problem is that, apart from these three mandatory
    tags and the ending tag 10, all other tags in a logon message are optional. This
    means that I cannot tell you what you should include there; nor can any other
    author – except for your broker because it is they who decide what should be sent
    and in which sequence. So, the best way of learning it is by referring to the
    documentation obtained from the very trading venue to which you want to send your
    messages.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经到了一个地方，我的初步论点（去询问你的经纪人详情）变得明显。问题是，除了这三个强制标签和结束标签10之外，登录消息中的所有其他标签都是可选的。这意味着我无法告诉你应该包括什么；也没有其他作者可以告诉你——除非是你的经纪人，因为是他们决定应该发送什么以及发送的顺序。所以，最好的学习方法是参考从你想要发送消息的交易所获得的文档。
- en: 'Any FIX session ends with a `Logout (5)` message, which in its minimal form
    looks as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 任何FIX会话都以`登出（5）`消息结束，其最小形式如下所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Constructing messages
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造消息
- en: At this point, I would like to warn you against making a very common mistake
    made by many developers of trading strategies. They think that there’s only a
    limited set of FIX messages that their application may generate; therefore, they
    hardcode them as strings and pick the appropriate one when they need to send an
    order.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我想警告你避免许多交易策略开发者犯的一个非常常见的错误。他们认为他们的应用程序可能生成的FIX消息集是有限的；因此，他们将它们作为字符串硬编码，并在需要发送订单时选择合适的消息。
- en: 'Do not do this! Here are the following reasons why you shouldn’t do this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做！以下是不应该这样做的原因：
- en: First, this approach makes your code non-scalable. In cases where you need to
    add a new tag for a new order type, you need to re-write the entire application.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，这种方法使得你的代码不可扩展。在需要为新的订单类型添加新标签的情况下，你需要重写整个应用程序。
- en: Second, this makes your code non-portable. In cases where you want to use it
    with another broker, this broker can require a particular set of tags in a logon
    message or anywhere else, and again – you will have to re-write your app.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，这使得你的代码不可移植。在你想用另一个经纪人使用它的情况下，这个经纪人可能需要在登录消息或任何其他地方要求特定的标签集，再次——你将不得不重写你的应用程序。
- en: Finally, even though you may think that you remember the meaning of every FIX
    tag by heart, believe me, this is a dangerous self-delusion!
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，即使你认为你能够记住每个FIX标签的含义，相信我，这只是一个危险的自我欺骗！
- en: 'So, the reasonable way of constructing a FIX message in Python would be to
    build it block by block using explicit, human-readable names of tags instead of
    just numbers. We’re going to use a native Python dictionary for this purpose:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Python中构建FIX消息的合理方式是分块构建，使用标签的显式、可读性强的名称而不是仅仅使用数字。我们将为此目的使用原生的Python字典：
- en: 'Let’s start by forming a basic FIX dictionary that associates tags with their
    respective names. We will use names as keys and tag numbers as values because
    this is the way we want to build our messages:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从构建一个基本的FIX字典开始，将标签与它们相应的名称关联起来。我们将使用名称作为键，标签号作为值，因为这是我们构建消息的方式：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need a function that binds tags together in a message. Don’t forget
    that messages may differ significantly in the number of included tags so we will
    want to use one of Python’s most powerful features – *arbitrary* *keyword argument*:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个函数来在消息中将标签绑定在一起。不要忘记，消息中包含的标签数量可能会有很大差异，因此我们希望使用Python最强大的功能之一——*任意*
    *关键字参数*：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we assume that we pass keyword arguments as pairs of `<tag_name>=VALUE`
    and then use the dictionary to replace human-readable names with standard FIX
    tag numbers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设我们将关键字参数作为`<tag_name>=VALUE`的配对传递，然后使用字典将可读性强的名称替换为标准的FIX标签号。
- en: 'Let’s test our code with the following instruction:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用以下指令测试我们的代码：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will get the following result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下结果：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that SOH characters are not visible in this output but if we explicitly
    request the value of the `message` variable, it will return the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，SOH字符在此输出中不可见，但如果我们明确请求`message`变量的值，它将返回以下输出：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the non-printable character is clearly visible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不可打印的字符清晰可见。
- en: However, it is not reasonable to pass the standard header manually each time
    we need to compose the message. So, we need to include it in the function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每次我们需要组合消息时手动传递标准头是不合理的。因此，我们需要将其包含在函数中。
- en: With the first tag, `8`, it’s simple. We can store the value in a special variable
    and add it at the last stage of the process of composing a message. The first
    tag always contains only the version of the FIX protocol. But anyway, we should
    calculate the length of the message body and the checksum and include them (the
    length and the checksum) in tags `9` and `10`, respectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个标签`8`，很简单。我们可以在一个特殊变量中存储值，并在消息组合过程的最后阶段添加它。第一个标签总是只包含FIX协议的版本。但无论如何，我们应该计算消息体的长度和校验和，并将它们（长度和校验和）分别包含在标签`9`和`10`中。
- en: Important
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Do not confuse the message body with the message itself! Tag `9` means the length
    of only the message body, that is, between tag `9` and tag `10`. In our example,
    the message body length is `5` (not `4` because the body consists of characters
    `3`, `5`, `=`, `A`, and one non-printable 0x01).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将消息体与消息本身混淆！标签`9`表示只有消息体的长度，即从标签`9`到标签`10`。在我们的例子中，消息体的长度是`5`（不是`4`，因为主体由字符`3`、`5`、`=`、`A`和一个不可打印的0x01组成）。
- en: 'The easiest way of implementing the calculation of the body length is restricting
    provision tags in `**kwargs` to just the message body. This can be done in a variety
    of ways:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实现计算消息体长度的最简单方法是将 `**kwargs` 中的提供标签限制仅为消息体。这可以通过多种方式完成：
- en: 'Let’s start by using a list that we will call `fix_exceptions`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先使用一个我们将称之为 `fix_exceptions` 的列表：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will then add tags to our composing message only when they are not in the
    list of exceptions:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只有在标签不在异常列表中时才会将标签添加到我们的编写消息中：
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the new version of our message-composing function will look like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们消息编写函数的新版本将看起来像这样：
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we test it using the preceding parameters, we will get the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面的参数进行测试，我们将得到以下输出：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tags 8, 9, and 10 are now ignored because they are in the list of exceptions.
    Since tags related to the standard header and standard trailer are ignored, whatever
    is not ignored remains in the message body.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 标签8、9和10现在被忽略，因为它们在异常列表中。由于与标准头和标准尾相关的标签被忽略，因此未被忽略的内容保留在消息体中。
- en: 'Great, we can now calculate its length and add it to the message:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了，我们现在可以计算它的长度并将其添加到消息中：
- en: '[PRE27]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let’s add tag `8`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加标签 `8`：
- en: '[PRE28]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, in the following code we sum all ASCII codes of all characters in
    the string, then divide this sum by 256 and take the remainder (we will use the
    `reduce` function here, which is part of `functools`, so should be imported as
    `from functools` `import reduce`):'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在以下代码中，我们计算字符串中所有字符的ASCII码之和，然后将这个和除以256并取余数（这里我们将使用 `reduce` 函数，它是 `functools`
    的一部分，因此应该作为 `from functools import reduce` 导入）：
- en: '[PRE29]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will then add it to the message:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将它添加到消息中：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s now see the entire upgraded code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看整个升级后的代码：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s test it with the following input:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下输入来测试它：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will still get the correct output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会得到正确的结果：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that all tags found in the list of exceptions are ignored and their ridiculous
    values are not included in the message – which is great because otherwise such
    a message will be rejected (in the best case). Moreover, now we can safely omit
    all tags but the body when we call the following function, which will give us
    exactly the same result as before:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，列表中找到的所有标签都被忽略，并且它们的荒谬值不会包含在消息中——这很好，因为否则这样的消息将被拒绝（在最好的情况下）。此外，现在当我们调用以下函数时，我们可以安全地省略除消息体之外的所有标签，这将给出与之前完全相同的结果：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What to do next
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来要做什么
- en: If you work with FIX, you definitely need a reference that has a comprehensive
    dictionary of all tags with explanations of their meaning. One of the best resources
    is OnixS (they develop SDKs for direct market access, so no wonder FIX plays the
    central role in their products), which can be found at [https://www.onixs.biz/fix-dictionary.html](https://www.onixs.biz/fix-dictionary.html).
    If you plan to work with FIX professionally, I definitely recommend visiting the
    official website of the FIX community at [https://www.fixtrading.org](https://www.fixtrading.org)
    and checking the *Standards* section, where you can find information on technical
    standards, specifications, and a link to FIX GitHub.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与FIX一起工作，你肯定需要一个包含所有标签的全面字典及其含义解释的参考。其中一个最好的资源是OnixS（他们开发直接市场接入的SDK，因此FIX在他们产品中扮演核心角色毫不奇怪），可以在[https://www.onixs.biz/fix-dictionary.html](https://www.onixs.biz/fix-dictionary.html)找到。如果你计划专业地与FIX一起工作，我强烈建议访问FIX社区官方网站[https://www.fixtrading.org](https://www.fixtrading.org)，并检查“标准”部分，在那里你可以找到有关技术标准、规范以及FIX
    GitHub的链接。
- en: When it comes to professional utilization of FIX, the most important and de
    facto industry-standard solution is QuickFIX ([https://quickfixengine.org](https://quickfixengine.org)).
    It features implementations of the FIX protocol for many languages, including
    Python, and simplifies the development of messaging and data retrieval for trading
    applications by relieving the developer of the burden of low-level composing FIX
    messages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到FIX的专业应用时，最重要且事实上的行业标准解决方案是QuickFIX ([https://quickfixengine.org](https://quickfixengine.org))。它为包括Python在内的许多语言实现了FIX协议，通过减轻开发者编写低级FIX消息的负担，简化了交易应用的消息和数据检索开发。
- en: There are also several ready-made FIX implementations for Python, of which Simplefix
    ([https://pypi.org/project/simplefix/](https://pypi.org/project/simplefix/)) is
    probably the most straightforward. It doesn’t implement a socket connection or
    any other transport layer functionality, nor does it support logging or ensure
    message persistence. It only serves as a convenient wrapper for encoding and decoding
    FIX messages with easy-to-read functions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python，也有几个现成的FIX实现，其中Simplefix ([https://pypi.org/project/simplefix/](https://pypi.org/project/simplefix/))
    可能是最直接的。它不实现套接字连接或任何其他传输层功能，也不支持日志记录或确保消息持久性。它仅作为编码和解码FIX消息的方便包装器，提供易于阅读的函数。
- en: It’s also worth mentioning another protocol built on top of FIX. It is called
    **FAST**, which stands for **FIX Adapted for STreaming**. In simple terms, this
    protocol is designed to facilitate fast and a large volume of messaging without
    generating excessive processing overhead or latency. If you’re interested in learning
    more about FAST, I’d recommend starting with the official documentation ([https://www.fixtrading.org/standards/fast/](https://www.fixtrading.org/standards/fast/))
    and also having a look at a FIX Fast tutorial at [https://jettekfix.com/education/fix-fast-tutorial/](https://jettekfix.com/education/fix-fast-tutorial/).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是另一个建立在FIX之上的协议。它被称为**FAST**，代表**FIX Adapted for STreaming**。简单来说，这个协议旨在在不产生过多的处理开销或延迟的情况下，促进快速和大量消息的传输。如果你对学习更多关于FAST感兴趣，我建议从官方文档([https://www.fixtrading.org/standards/fast/](https://www.fixtrading.org/standards/fast/))开始，并查看[https://jettekfix.com/education/fix-fast-tutorial/](https://jettekfix.com/education/fix-fast-tutorial/)上的FIX
    Fast教程。
- en: Now that you know how to compose FIX messages, you just need to fill them with
    meaning. That is, you need to add any trading logic that is most likely based
    on market data, generate orders, transform them into FIX messages, and send them
    to the broker, an ECN, or elsewhere. You also need to be able to receive and understand
    replies to your messages. For example, your broker may respond with `8=8` in the
    message body, which means that your order is successfully filled (message type
    8 means order execution report and value 8 means *order filled*). The broker may
    send you back `8=5` which will mean that your order is rejected and your code
    should be able to handle situations of this kind.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何编写FIX消息，你只需要填充它们的意义。也就是说，你需要添加任何基于市场数据的交易逻辑，生成订单，将它们转换为FIX消息，并发送给经纪人、ECN或其他地方。你还需要能够接收并理解对你消息的回复。例如，你的经纪人可能在消息体中响应`8=8`，这意味着你的订单已成功成交（消息类型8表示订单执行报告，值8表示*订单成交*）。经纪人可能会发送`8=5`给你，这意味着你的订单被拒绝，你的代码应该能够处理这种情况。
- en: What if your broker doesn’t support FIX or doesn’t provide non-professional
    traders with access to it? At this point, we, unfortunately, return to my statement
    at the very beginning of this chapter*, “in the world of FX automated trading,
    every setup is unique so go ask your broker.”* As we saw previously, even in a
    highly standardized FIX protocol, there is still a certain degree of flexibility
    so it’s always best to read the documentation provided by the very trading venue
    to which you plan to send orders. With proprietary protocols, it’s even worse
    because there is no standard and every broker offers their own API designed the
    way they think is best.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的经纪人不支持FIX或不向非专业交易者提供访问权限怎么办？在这种情况下，我们不幸地回到了本章开头我的声明，“在FX自动化交易的世界里，每个设置都是独特的，所以去问问你的经纪人。”*正如我们之前看到的，即使在高度标准化的FIX协议中，仍然存在一定程度上的灵活性，因此最好阅读你计划发送订单的交易所提供的文档。对于专有协议，情况更糟，因为没有标准，每个经纪人都会提供他们自己设计的API，他们认为这是最好的方式。
- en: However, the most important thing for you to conclude from this section is that
    any protocol, any API, and any framework only serves to deliver a certain message,
    in most cases a trading order, and to receive the reply. If you design your trading
    application so that you have independent interfaces between data processing, trading
    logic, risk management, and ordering modules, you will be able to switch from
    one protocol to another without rewriting the entire application – and this is
    what we’re going to learn more about in this book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从本节中最重要的结论是，任何协议、任何API和任何框架都只用于传递某种信息，在大多数情况下是交易订单，并接收回复。如果你设计你的交易应用，使得数据处理、交易逻辑、风险管理以及订单模块之间有独立的接口，你将能够从一种协议切换到另一种协议，而无需重写整个应用——这正是本书将要深入探讨的内容。
- en: Now that we are more familiar with the means of exchanging information between
    your application and a trading venue, it’s time to learn *what* we can send and
    retrieve from there. Let’s start with market data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对您的应用程序和交易场所之间交换信息的方式更加熟悉，是时候学习我们可以发送和从那里检索什么了。让我们从市场数据开始。
- en: Retrieving data – garbage in, garbage out
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据——垃圾进，垃圾出
- en: The FIX protocol is universal by design and thus can be used not only for ordering
    but also for data retrieval. However, in most cases, it is not actually used for
    market data transfer; instead, trading venues provide their own proprietary APIs
    to retrieve data from there.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: FIX协议在设计上具有通用性，因此不仅可以用于订单，还可以用于数据检索。然而，在大多数情况下，它实际上并不用于市场数据传输；相反，交易场所提供自己的专有API来从那里检索数据。
- en: As always, in this *gloomy world* of communication protocols, everything is
    individual and each trading venue offers its own API. However, in general, all
    broker APIs are implemented as REST or Websockets. The former is convenient for
    occasional requests for quotes, while the latter is best for continuous subscriptions
    that allow receiving real-time market data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 始终如一，在这个通信协议的*阴暗世界*中，一切都是个性化的，每个交易场所都提供自己的API。然而，总的来说，所有经纪商的API都是实现为REST或Websockets。前者适用于偶尔的报价请求，而后者最适合连续订阅，以便接收实时市场数据。
- en: The following examples I provide are taken from the API of LMAX, one of the
    key ECNs in the FX market. They are not only great because of their openness to
    any client, big or small, but also because they are one of the very few trading
    venues that publicly disseminate real-time market data – and they do it completely
    free of charge.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我提供的以下示例是从FX市场中的关键ECN之一LMAX的API中提取的。它们之所以出色，不仅是因为它们对任何客户，无论大小都开放，而且还因为它们是极少数公开传播实时市场数据的交易场所之一——而且他们完全免费。
- en: 'Before you start working with FX market data you should understand and always
    remember one important thing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始使用FX市场数据之前，你应该理解和始终记住一个重要的事情：
- en: '*Data in demo environments is always different from that in a* *live environment.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*演示环境中的数据始终与真实环境中的数据不同。*'
- en: 'This means that if you receive public data or open a demo account with an ECN
    to receive market data from there, you should be ready to see quotes that are
    slightly different from the *real* market. The good news is that this difference
    is not significant; in our particular example with LMAX, it is normally 0.1 to
    0.5 pips with a probable slight increase in difference closer to the New York
    bank settlement time (5 P.M. New York time – see the *Trading the FX market: what
    and how* section in [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044)*, FX Market
    Overview from a Developer’s Standpoint*). So, even this publicly available data
    is good for most development and even for live trading.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你从ECN接收公开数据或开设一个演示账户以从那里接收市场数据，你应该准备好看到与*真实*市场略有不同的报价。好消息是这种差异并不显著；在我们的特定例子中，LMAX通常是0.1到0.5个点，在纽约银行结算时间（纽约时间下午5点）附近可能会有轻微的差异增加（参见[*第3章*](B19145_03.xhtml#_idTextAnchor044)*，从开发者的角度来看的*FX市场概述*）。因此，即使是公开可用的数据，对于大多数开发和甚至实时交易来说都是好的。
- en: In cases where you need only a quote here and a quote there from time to time,
    then mostly LMAX's REST API is the way to go for you.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在你需要时不时地获取这里和那里的报价的情况下，那么LMAX的REST API通常是你的选择。
- en: As with any regular REST API, it supports a few endpoints that allow retrieving
    market price data both as the last trade price and as the top of the order book.
    It also supports retrieving information about all instruments (symbols) supported
    by the LMAX demo server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何常规REST API一样，它支持一些端点，允许以最后交易价格和订单簿顶部价格的形式检索市场价格数据。它还支持检索LMAX演示服务器支持的所有工具（符号）的信息。
- en: 'In order to retrieve such a list, let’s execute the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索这样一个列表，让我们执行以下操作：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The response will deliver us a JSON with the list of available instruments:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将为我们提供一个包含可用工具列表的JSON：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I removed the remainder of the JSON to keep it compact but the rest is just
    repetitions of similar records for other instruments. Let’s parse this answer
    to understand its components:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我移除了剩余的JSON以保持其紧凑性，但其余部分只是其他工具的类似记录的重复。让我们解析这个答案来了解其组成部分：
- en: '`instrument_id`: This is the name of the FX instrument supported by the LMAX
    demo server in the correct notation (note that no slashes **/** are allowed in
    the names, so they are replaced with a dash **-**).'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instrument_id`：这是 LMAX 演示服务器支持的 FX 工具的正确名称（注意，名称中不允许有斜杠 **/**，因此它们被替换为破折号
    **-**）。'
- en: '`asset_class`: Most of the instruments traded at this ECN are currencies but
    there are also **contracts for difference** (**CFDs**) on metals and energies,
    so be careful.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asset_class`：在这个 ECN 上交易的大多数工具是货币，但也有金属和能源的**差价合约**（**CFDs**），所以请小心。'
- en: '`quantity_increment`: This is the minimum `quant` of the order size; an increment
    of 1,000.000 euros means that you can send an order to buy or sell 1,003,000 euros
    for just 2,000 EURUSD, but not 1,003,300 or 1,100,301 euros.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity_increment`：这是订单大小的最小`quant`；1,000.000 欧元的增量意味着你可以发送一个价值 1,003,000
    欧元的买卖订单，只需 2,000 EURUSD，但不能是 1,003,300 或 1,100,301 欧元。'
- en: '`price_increment`: This is the minimum price fluctuation. 0.00001 means that
    the minimum change can be in the fifth digit to the right of the decimal point
    and the amount of this change is 1 (so-called **fractional pip**).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`price_increment`：这是最小的价格波动。0.00001 意味着最小变化可以是在小数点右边的第五位，这种变化的数量是 1（所谓**分数点**）。'
- en: '`ticker_enabled`: This means that the symbol is available for ordering.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ticker_enabled`：这意味着该符号可用于下单。'
- en: 'To retrieve the entire order book information for the particular symbol, we
    can use the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索特定符号的整个订单簿信息，我们可以使用以下方法：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The response will contain the list of bids and asks for the depth allowed by
    LMAX for demo accounts again in the form of a plain JSON.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将包含 LMAX 为演示账户允许的深度内的买卖报价列表，以纯 JSON 格式呈现。
- en: 'If you want to receive continuous data from the ECN, you may want to use WebSockets
    instead of REST:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从 ECN 接收连续数据，你可能想使用 WebSockets 而不是 REST：
- en: 'First, you will need to install WebSockets, which you can do using pip:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要安装 WebSockets，你可以使用 pip 来做这件事：
- en: '[PRE38]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you use Python with an Anaconda distribution, you can use the following
    code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Anaconda 分发的 Python，你可以使用以下代码：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'First of all, we need to import the WebSocket module:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入 WebSocket 模块：
- en: '[PRE40]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, set the URL to which we’re going to subscribe:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置我们将要订阅的 URL：
- en: '[PRE41]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, create the WebSocket and connect it:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建 WebSocket 并连接它：
- en: '[PRE42]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, form the request as a regular JSON:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将请求以常规 JSON 格式形成：
- en: '[PRE44]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Send the request:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求：
- en: '[PRE45]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Watch the response:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 观察响应：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you did all the steps correctly, you’re going to see something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地完成了所有步骤，你将看到类似这样的内容：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This response means that the subscription has been set up and that the subscribed
    instruments are the euro for the entire order book and the Japanese yen for the
    last price data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应意味着订阅已经设置，并且订阅的工具是整个订单簿的欧元和最后价格数据的日元。
- en: As this book is not a tutorial on WebSockets, I recommend reading the very comprehensive
    tutorial at [https://websockets.readthedocs.io/en/stable/intro/index.html](https://websockets.readthedocs.io/en/stable/intro/index.html)
    if you are not familiar with this kind of network connection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书不是关于 WebSockets 的教程，如果你不熟悉这种网络连接，我建议阅读非常全面的教程[https://websockets.readthedocs.io/en/stable/intro/index.html](https://websockets.readthedocs.io/en/stable/intro/index.html)。
- en: You can find all supported REST API endpoints and WebSocket requests in the
    LMAX official documentation at [https://docs.lmax.com/public-data-api/](https://docs.lmax.com/public-data-api/).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 LMAX 官方文档中找到所有支持的 REST API 端点和 WebSocket 请求[https://docs.lmax.com/public-data-api/](https://docs.lmax.com/public-data-api/)。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please don’t forget that the preceding examples are for illustrative purposes
    only. I would like to keep this book as broker-agnostic as possible so I can’t
    really recommend any particular broker or an ECN. The example with LMAX is provided
    here only because they have one of the most simple and easy-to-use APIs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要忘记，前面的例子只是为了说明目的。我希望这本书尽可能不涉及任何经纪商，因此我无法真正推荐任何特定的经纪商或 ECN。这里提供 LMAX 的例子，仅仅是因为他们有一个最简单且易于使用的
    API。
- en: Other brokers and trading venues may have different APIs that are sometimes
    more complex but the key principles of subscribing to data remain the same.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其他经纪商和交易场所可能有不同的 API，有时更复杂，但订阅数据的根本原则是相同的。
- en: 'So, now that we know how to get data from the trading venue, here comes the
    most important part: **data handling**. All procedures you perform with data in
    your trading applications must ensure data consistency.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经知道了如何从交易场所获取数据，接下来就是最重要的部分：**数据处理**。你在交易应用中对数据进行的所有操作都必须确保数据一致性。
- en: 'By data consistency in market data, we assume the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过市场数据的一致性，我们假设以下情况：
- en: If tick A is received prior to tick B, then the timestamp of tick A should precede
    that of tick B
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果接收到的tick A早于tick B，那么tick A的时间戳应该早于tick B的时间戳。
- en: If there is a gap in time between two adjacent ticks that is substantially greater
    than the average, there must be a clear logical explanation for it
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个相邻tick之间的时间间隔显著大于平均值，那么对此必须有明确的逻辑解释。
- en: If there is a gap in price between two adjacent ticks that is substantially
    greater than the average, there must be again a clear logical explanation for
    it
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个相邻tick之间的价格差距显著大于平均值，那么对此必须有明确的逻辑解释。
- en: Let’s consider each point in detail in the following sub-sections.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下子节中详细考虑每个点。
- en: Tick sequence
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tick序列
- en: When you start working with real market data, you will be impressed by the number
    of ticks with incorrect timestamps. There are several explanations for this phenomenon;
    the most understandable is probably that the number of ticks (and we remember
    from [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014) that a tick is an update
    in price, either a new bid, a new ask, or a new trade) is so huge that the exchange’s
    or ECN’s own servers can’t really process all of them in the correct sequence
    and assign the same timestamps to batches of ticks. There are also other reasons
    that are more related to the latency between the exchange’s servers and trading
    servers or client computers. Anyway, regardless of the reason, incorrect timestamps
    are a real problem and before we start working with data, we always have to perform
    a check and correct the timestamps if there’s any inconsistency in them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始处理真实市场数据时，你会对具有错误时间戳的tick数量印象深刻。这种现象有几个解释；最容易被理解的可能是因为tick的数量（我们记得从[*第一章*](B19145_01.xhtml#_idTextAnchor014)中，tick是价格更新，无论是新的出价、新的要价还是新的交易）如此巨大，以至于交易所或ECN自己的服务器实际上无法正确地按顺序处理所有这些，并为一批tick分配相同的时间戳。还有其他一些原因，这些原因更多地与交易所服务器和交易服务器或客户端计算机之间的延迟有关。无论如何，无论原因如何，错误的时间戳都是一个真正的问题，在我们开始处理数据之前，我们总是必须进行检查，并在其中存在任何不一致时纠正时间戳。
- en: There are several techniques that allow fixing the timestamp issue and we will
    consider them in detail in the very next chapter, which is completely dedicated
    to processing and storing market data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种技术可以解决时间戳问题，我们将在下一章详细讨论这些技术，这一章完全致力于处理和存储市场数据。
- en: Time gaps
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间间隔
- en: Basically, a time gap is a situation when no market data is received for a considerable
    amount of time. Of course, the question is how to define this *considerable amount*.
    How much is it? A second? A minute? An hour? If there’s no market data update
    in 5 minutes, does it mean that the connection is lost or that there’s simply
    no activity in the market?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，时间间隔是指在一定时间内没有接收到市场数据的情况。当然，问题是如何定义这个“一定时间”。是多长时间？一秒？一分钟？一小时？如果5分钟内没有市场数据更新，这意味着连接丢失，还是市场根本没有任何活动？
- en: If you receive data as live quotes this problem can be solved relatively easily
    by adding heartbeat messages to your implementation of market data retrieval.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以实时报价的形式接收数据，可以通过在你的市场数据检索实现中添加心跳消息来相对容易地解决这个问题。
- en: 'A *heartbeat message* is somewhat similar to *ping*: a message with dummy content
    is sent to the server and the server just replies with something that means *“OK,
    I am still alive and can hear you well.”* Such a message is sent automatically
    at equal intervals and is a simple yet robust method of checking the health of
    your connection.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*心跳消息*与*ping*有些相似：发送一个内容为假的消息到服务器，服务器只是回复一些表示“好的，我还活着，并且可以很好地听到你。”的消息。这样的消息会自动以相等的间隔发送，这是一种简单而稳健的检查连接健康状况的方法。
- en: If you work with FIX, this protocol natively supports heartbeat (message type
    0, tag 35=0). If you work with other APIs – well... as always in this chapter,
    you should refer to your broker’s documentation regarding how they implement heartbeat
    (and what they expect you to use). If no special heartbeat message is reserved
    by the broker, you may want to use any neutral request, such as a request for
    a quote from time to time, and check the response.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用FIX，这个协议原生支持心跳（消息类型0，标签35=0）。如果你使用其他API——嗯……正如本章一贯的，你应该参考你的经纪商的文档，了解他们如何实现心跳（以及他们期望你使用什么）。如果经纪商没有保留特殊的心跳消息，你可能想不时地使用任何中性的请求，例如偶尔请求报价，并检查响应。
- en: The key advantage of using a special heartbeat message is that it works any
    time the server is up. Even when the market is actually closed and any attempt
    to receive a market quote fails, heartbeat messages will go through and will be
    responded to. So, using heartbeat messages is always the preferred way to go.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊心跳消息的关键优势是它在服务器运行时任何时候都有效。即使市场实际上关闭，并且尝试接收市场报价失败，心跳消息也会通过并得到响应。因此，使用心跳消息始终是首选的方法。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If your broker or a trading venue does support heartbeat messages, you may want
    to refrain from using any other type of request just to make sure the connection
    is alive. In certain cases, such an activity can be a reason for a ban with certain
    ECNs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的经纪商或交易场所支持心跳消息，你可能想避免使用任何其他类型的请求，以确保连接是活跃的。在某些情况下，这种活动可能是某些ECN禁止的原因。
- en: So, with live quotes, the problem of time gaps can be solved relatively easily
    by adding heartbeat messages. But what do we do in cases where we work with *historical
    data,* that is, not the data representing what’s going on in the market now but
    data indicating what *was going on* in the market some time ago? In this case,
    no heartbeat message is recorded into it (at least I am not aware of any single
    example suggesting otherwise) and if we see two ticks with a pause of 1 hour between
    them, there is always a question of whether this data is consistent.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于实时报价，通过添加心跳消息可以相对容易地解决时间间隔的问题。但在我们处理*历史数据*的情况下，即不是代表现在市场状况的数据，而是表示过去某个时间市场状况的数据，我们该怎么办？在这种情况下，没有记录心跳消息（至少我不了解任何单一个例子表明情况相反），如果我们看到两个时间点之间有1小时的暂停，总会有一个问题是这些数据是否一致。
- en: 'Normally, such a consistency check is performed in two stages:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种一致性检查分为两个阶段：
- en: First, we identify the time gaps. The main problem here is how to decide that
    the pause between ticks is long enough to become suspicious. We will look into
    this problem in detail in the next chapter. For now, let’s just assume that any
    pause that is greater than the average plus two sigmas (sigma here stands for
    standard deviation, we consider it in [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101)*,
    Basics of Fundamental Analysis and its Possible Use in FX Trading*) is considered
    *suspicious*.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们识别时间间隔。这里的主要问题是如何判断两个时间点之间的暂停是否足够长，以至于变得可疑。我们将在下一章详细探讨这个问题。现在，我们只需假设任何大于平均数加两个标准差（这里的sigma代表标准差，我们将在[*第6章*](B19145_06.xhtml#_idTextAnchor101)*，基本分析及其在FX交易中的可能用途*)的暂停都被认为是*可疑的*。
- en: Next, all *suspicious* pauses are checked against the list of known situations
    when market data can indeed be paused. We exclude all weekends, pauses before
    and after the bank settlement, and the opening of the bank day for some currencies,
    and check the rest against a schedule for known events such as releases of important
    economic news that also may cause interruptions in market quotes.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，所有*可疑的*暂停都将与已知市场数据可以暂停的情况列表进行核对。我们排除所有周末、银行结算前后的暂停，以及某些货币银行日的开盘，并将剩余的与已知事件的时间表进行核对，例如重要经济新闻的发布，这也可能导致市场报价的中断。
- en: If the remaining list of time gap issues is insignificant (let’s assume for
    clarity that it is at least 10 times as small as the original list), then we believe
    that overall this data is satisfactory to work with. If the amount of unidentified
    time gaps is still significant, it would be best to refrain from using this data.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果剩余的时间间隔问题列表不显著（为了清晰起见，我们假设它至少是原始列表的10倍小），那么我们认为这些数据总体上是可用的。如果未识别的时间间隔数量仍然很大，最好避免使用这些数据。
- en: Price gaps
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 价格间隔
- en: A gap in price is a situation where two adjacent ticks have an abnormal difference
    in price. Of course, like with time gaps, the question is how we define this to
    be *abnormal*. Here, we can use similar techniques as those we used with time
    gaps. If the difference in the price of two adjacent ticks is greater than the
    average plus 2 sigma, then this is a potential price gap.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 价格缺口是指两个相邻的tick之间存在异常的价格差异。当然，就像时间间隔一样，问题是我们如何定义这种差异为**异常**。在这里，我们可以使用与时间间隔相似的技术。如果两个相邻tick的价格差异大于平均值加2个标准差，那么这可能是潜在的价格缺口。
- en: In cases of price gaps, we frequently use 3 sigmas and more because the goal
    is not really to catch every situation when the price jumps quickly (in the real
    market this may happen quite often, at least a few times a day) but to isolate
    and filter out **non-market prices**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在价格缺口的情况下，我们经常使用3个标准差以上，因为目标并不是真正捕捉到价格快速跳动的每一个情况（在真实市场中这种情况可能相当常见，至少每天发生几次），而是隔离和过滤掉**非市场价格**。
- en: Maybe you remember the illustration of what non-market price looked like in
    [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014)? So, a non-market price is something
    that lies completely, totally outside of any reasonable range, so we can easily
    consider 10, 20, and sometimes even 100 sigmas to filter out these erroneous quotes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得[*第一章*](B19145_01.xhtml#_idTextAnchor014)中非市场价格示意图。所以，非市场价格是指完全、完全超出任何合理范围的东西，因此我们可以很容易地考虑10、20，有时甚至100个标准差来过滤掉这些错误的报价。
- en: 'You may wonder about the source of these non-market prices. There can be multiple
    reasons for non-market prices:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这些非市场价格的来源。非市场价格可能有多个原因：
- en: The most common reason is a so-called **fat finger effect**, simply a mistake
    in the bid or offer sent to the market. Typically, it is 10 times greater or 10
    times less than the previous market price because of an extra 0 in the quote or
    a missing digit. Trades done at these prices are normally reversed in hindsight,
    but the quotes are recorded in the data stream and stored as historical data.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常见的原因是所谓的**大拇指效应**，简单地说就是发送到市场的要价或出价中的错误。通常，由于报价中的额外0或缺失的数字，它可能是前一个市场价格的大10倍或小10倍。在事后看来，以这些价格进行的交易通常会被撤销，但这些报价会被记录在数据流中并存储为历史数据。
- en: Some data providers include data not related to trading; for example, I saw
    a case where the exchange included transfers to an insurance fund as market price
    data. Luckily they recorded these *ticks* at zero price – luckily because it is
    then very easy to filter out.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些数据提供商包括与交易无关的数据；例如，我见过一个案例，交易所将转移到保险基金的资金记录为市场价格数据。幸运的是，他们以零价格记录了这些*ticks*——幸运的是，因为这使得过滤变得非常容易。
- en: In rare cases, there can be glitches in the data provider’s database, software,
    or hardware – erroneous quotes caused by this reason are the hardest to find and
    filter.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在罕见的情况下，数据提供商的数据库、软件或硬件可能会出现故障——由这种原因造成的错误报价是最难找到和过滤的。
- en: 'After you have successfully connected to the data source, received data, and
    filtered it, it’s time to do something meaningful with it: that is, analyze the
    data and make some trading decisions. This is what we’re going to consider in
    the next section.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在你成功连接到数据源、接收数据并过滤它之后，是时候用它做一些有意义的事情了：即分析数据并做出一些交易决策。这就是我们将在下一节考虑的内容。
- en: Trading logic – this is where a small mistake may cost a fortune
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易逻辑——这里一个小错误可能会损失一大笔财富
- en: Trading logic is obviously the core of the entire trading app. It is the very
    component that analyzes the market data in search of any pre-defined price-time
    patterns (sometimes other data such as volume and open interest is included, but
    this data is typically not available for the spot market) and generates orders.
    Almost all of the rest of the book will be dedicated to trading logic and various
    approaches to developing trading algorithms but we can’t really move on without
    considering one very typical mistake that already costs many traders millions,
    if not billions, of dollars. I mean the **peek** **ahead** issue.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 交易逻辑显然是整个交易应用的核心。它是分析市场数据以寻找任何预定义的价格-时间模式（有时还包括其他数据，如成交量和对冲头寸，但这些数据通常在现货市场不可用）并生成订单的组件。本书的大部分内容都将致力于交易逻辑以及开发交易算法的各种方法，但我们不能不考虑一个已经让许多交易者损失数百万甚至数十亿美元的错误——我指的是**前瞻性**问题。
- en: 'The phenomenon of peeking ahead is specific to only the development phase of
    the project when the trading algorithm is optimized or trained using past market
    data, which is called historical data. As you remember from the previous section,
    historical data is something pre-recorded either by yourself or a third party
    such as an exchange, a broker, a data vendor, and so on. This data may contain
    ticks or may be compressed down to 1-second or 1-minute snapshots. Regardless
    of data compression, all data in a cleaned-up dataset is sorted by timestamp and
    there is no situation when any *future* data would go before the *past* data –
    or vice versa, when any past data would be recorded after any future data. Let’s
    look at the following example to see what this means:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 提前查看的现象仅限于项目的开发阶段，当交易算法使用历史数据进行优化或训练时，这被称为历史数据。正如你从上一节中记得的那样，历史数据是由你自己或第三方（如交易所、经纪人、数据供应商等）预先记录的。这些数据可能包含tick，也可能被压缩成1秒或1分钟的快照。无论数据压缩如何，清洗后的数据集中的所有数据都是按时间戳排序的，不存在任何*未来的数据会出现在过去数据之前*的情况，或者相反，任何过去的数据会在未来数据之后被记录。让我们看看以下例子来了解这意味着什么：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, the timestamps are in the correct order. This piece of data
    means that the closing price of the instrument (which can be found in the sixth
    position of each record) was *first* `1.12941`, *then* `1.12965`, *then* `1.12883`,
    *then* `1.12894,` and *finally* `1.12925`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，时间戳是正确的顺序。这块数据意味着该工具的收盘价（可以在每条记录的第六个位置找到）最初是`1.12941`，然后是`1.12965`，然后是`1.12883`，然后是`1.12894`，最后是`1.12925`。
- en: When we develop and test a trading algorithm, we *simulate* trading by processing
    past data and making a trading decision based on it. Normally, the simulation
    engine processes pieces of data from a file, a list, or a pandas DataFrame one
    by one to simulate what *would have happened* if our algorithm traded *at that
    time.* So, we *must* make sure that at no point our trading algorithm can receive
    data *from* *the future*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发和测试一个交易算法时，我们通过处理历史数据并据此做出交易决策来*模拟*交易。通常，模拟引擎会逐个处理来自文件、列表或pandas DataFrame的数据块，以模拟如果我们的算法在那个时间进行交易会发生什么。因此，我们必须确保在任何时候我们的交易算法都不能接收*来自未来*的数据。
- en: 'Let’s again look at the preceding example. Imagine that we simulated the behavior
    of our trading algorithm at 13:32\. All we and the algorithm may know at this
    step is that the closing price at that time was 1.12883\. We *cannot* know – and
    the algorithm *cannot* know – that the closing price *would be* 1.12894 one minute
    later. However, if you store prices in a list (or a pandas DataFrame) it is easy
    to refer to the *future* price just by its index. So, I could potentially write
    something such as this (the following example assumes that `current_position`
    is the pointer which iterates through the dataset and `price_data` is the dataset
    itself):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看前面的例子。想象一下，我们在13:32时模拟了我们的交易算法的行为。在这个步骤中，我们和算法可能知道的信息只是当时的收盘价是1.12883。我们*不能*知道——算法*也不能*知道一分钟后的收盘价*将会是*1.12894*。然而，如果你将价格存储在列表（或pandas
    DataFrame）中，很容易通过索引引用未来的价格。所以，我可能写出如下这样的代码（以下示例假设`current_position`是遍历数据集的指针，而`price_data`是数据集本身）：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this code, we assume that the `buy` and `sell` methods generate buy and sell
    orders respectively. If we run a simulation using this code, we will have *100%
    of winning trades.* Not a single one will lose money because we compare a price
    *from the future* (lines 2 and 4) with the real price that exists *at the moment
    of simulation*. In our example, it would mean that at 13:32, I *already know what
    the price will be at 13:33* and compare it to the current price. Well, if I really
    could know that... Anyway, no one can see the future and you should make sure
    your algos are no exception.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们假设`buy`和`sell`方法分别生成买入和卖出订单。如果我们使用此代码运行模拟，我们将拥有*100%的盈利交易*。没有任何一笔会亏损，因为我们比较的是*未来的价格*（第2行和第4行）与模拟时刻存在的真实价格。在我们的例子中，这意味着在13:32时，我已经*知道13:33时的价格*并将其与当前价格进行比较。好吧，如果我真的能知道的话...无论如何，没有人能预知未来，你应该确保你的算法也不例外。
- en: Note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Always make sure you refer to prices one by one without peeking ahead. Use queues
    or refer to timestamps but always avoid referring to data by the index.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要确保你逐个引用价格，不要提前查看。使用队列或引用时间戳，但始终避免通过索引引用数据。
- en: Alright, we now know, at least at a surface glance, how to communicate with
    the market, how to retrieve data and make sure it’s consistent, and even how to
    avoid the greatest mistake that systematic trading strategies developers can make
    in the trading logic. Now, we should be able to send trading orders and protect
    ourselves against numerous adverse situations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们现在至少从表面上看知道了如何与市场沟通，如何检索数据并确保其一致性，甚至如何避免系统交易策略开发者可能在交易逻辑中犯的最大错误。现在，我们应该能够发送交易订单并保护自己免受众多不利情况的影响。
- en: Risk management – your safety belt
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风险管理——您的安全带
- en: 'After your algorithm has generated a trading signal, it should go past risk
    management. While trading logic answers the question *to trade or not to trade*,
    risk management answers another question: how much should be put at stake?'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的算法生成交易信号后，它应该通过风险管理。当交易逻辑回答“是否交易”的问题时，风险管理回答另一个问题：应该投入多少？
- en: In basic terms, risk management involves analysis of the potential maximum adverse
    excursion per trade, account size, leverage and margin as financial components
    of risk, and macro-economic factors and political events as external and non-market
    risk. Just to give you an example, it would be wise to just switch off trading
    before the Swiss National Bank decision in January 2015 or the presidential elections
    in the US in 2016.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，风险管理包括分析每笔交易可能的最大不利波动、账户规模、杠杆和保证金作为风险财务组成部分，以及宏观经济因素和政治事件作为外部和非市场风险。仅举一例，在2015年1月瑞士国家银行决策之前或2016年美国总统选举之前关闭交易是明智的。
- en: The topic of risk management is really vast and we will go into detail on this
    later in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171)*, Types of Orders and
    Their Simulation in Python*, after we have learned more about types of trading
    strategies and orders.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 风险管理的话题非常广泛，我们将在学习更多关于交易策略和订单类型之后，在[*第10章*](B19145_10.xhtml#_idTextAnchor171)*，Python中的订单类型及其模拟*中详细讨论这个问题。
- en: Ordering – make sure you are understood correctly
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单——确保您被正确理解
- en: 'Last, but by far not least, your trading application will have an ordering
    module. This module performs the following functions:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，您的交易应用将有一个订单模块。此模块执行以下功能：
- en: It maintains the connection to the execution server keeping it alive.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它保持与执行服务器的连接，使其保持活跃。
- en: It transforms trading signals passed by the risk management module into actual
    orders – using FIX or any proprietary API.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将风险管理模块传递的交易信号转换为实际订单——使用FIX或任何专有API。
- en: It handles all types of responses from the broker or trading venue. These responses
    range from just *OK* to partial fills and rejects.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理来自经纪人或交易场所的所有类型响应。这些响应范围从仅仅是*OK*到部分成交和拒绝。
- en: It decides what to do in cases where your order was rejected or filled partially.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它决定在您的订单被拒绝或部分成交的情况下应采取什么措施。
- en: It resubmits orders, full or in parts, in case it is favored by the trading
    logic.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果交易逻辑青睐它，它会重新提交全部或部分订单。
- en: You may have noticed that one of the responsibilities of the ordering module
    is maintaining connections – quite like the data handling module. Yes, there’s
    no mistake here, it is absolutely normal that a trading app uses **different**
    connections for data and for orders. Moreover, it is very frequent when data is
    obtained from a data vendor and orders are executed at an exchange or obtained
    from an exchange and executed with a market maker, and so on – in any possible
    combination. So, the ordering module also maintains the connection because this
    connection is different and separate.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，订单模块的一个职责是维护连接——就像数据处理模块一样。是的，这里没有错误，一个交易应用使用**不同**的连接来处理数据和订单是完全正常的。此外，当数据从数据供应商那里获取，而订单在交易所执行，或者从交易所获取并执行与市场做市商等时，这种情况非常常见——任何可能的组合。因此，订单模块也维护连接，因为这种连接是不同且独立的。
- en: As with risk management, we will go into the details of ordering along with
    risk management in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171)*, Types of
    Orders and Their Simulation* *in Python*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与风险管理一样，我们将在[*第10章*](B19145_10.xhtml#_idTextAnchor171)*，Python中的订单类型及其模拟*中，与风险管理一起详细讨论订单问题。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to connect to a broker or data vendor, retrieve
    live market data, understand the requirements for the quality of this data, and
    know all the five core logical blocks of which our future trading application
    will consist.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何连接到经纪商或数据供应商，检索实时市场数据，了解这些数据质量的要求，以及了解我们未来交易应用将包含的五个核心逻辑块。
- en: In the next chapter, we will move on to discuss the specifics of how we can
    efficiently handle *historical* market data because this is exactly what is required
    for the research and development phase.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论如何高效地处理*历史*市场数据的细节，因为这正是研究和开发阶段所必需的。
