- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Answers to the Questions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案到问题
- en: 'Chapter 2: Introduction to Algorithm Design'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：算法设计简介
- en: Question 1
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题1
- en: 'Find the time complexity of the following Python snippets:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 求以下Python代码片段的时间复杂度：
- en: '[PRE0]'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The complexity will be `O(log(n))`.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复杂度将是`O(log(n))`。
- en: As we are multiplying the integer `i` by `2` in each step there will be exactly
    `log(n)` steps. (`1`, `2`, `4`, …… till `n`).
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每一步中，我们将整数`i`乘以`2`，因此将会有恰好`log(n)`步。（`1`，`2`，`4`，……直到`n`）。
- en: The complexity will be `O(log(n))`.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复杂度将是`O(log(n))`。
- en: As we are dividing the integer `i` by `2` in each step there will be exactly
    `log(n)` steps. (`n`, `n`/`2`, `n`/`4`, …… till `1`).
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每一步中，我们将整数`i`除以`2`，因此将会有恰好`log(n)`步。（`n`，`n/2`，`n/4`，……直到`1`）。
- en: The outer loop will run `n` times for each `i` in the outer loop, while the
    inner `while` loop will run `log(i)` times because we are multiplying each of
    the `j` values by `2` until it is less than `n`. Hence, there will be a maximum
    of `log(n)` steps in the inner loop. Therefore, the overall complexity will `be`
    `O(nlog(n))`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外层循环将为每个外层循环中的`i`运行`n`次，而内层`while`循环将运行`log(i)`次，因为我们正在将每个`j`值乘以`2`，直到它小于`n`。因此，内层循环中最多将有`log(n)`步。因此，整体复杂度将是`O(nlog(n))`。
- en: '[PRE4]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`2, 4, 16, 256, ... n`'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`2, 4, 16, 256, ... n`'
- en: We can see that the number of times the loop is executing is log[2](log[2](n))
    for a given value of `n`. So, for this series there will be exactly log[2](log[2](n))
    executions of the loop. Hence the time complexity will be O(log[2](log[2](n)).
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，对于给定的`n`值，循环执行的次数是log[2](log[2](n))。因此，对于这个序列，循环将恰好执行log[2](log[2](n))次。因此，时间复杂度将是O(log[2](log[2](n)))。
- en: 'Chapter 3: Algorithm Design Techniques and Strategies'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：算法设计技术和策略
- en: Question 1
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题1
- en: Which of the following options will be correct when a top-down approach of dynamic
    programming is applied to solve a given problem related to the space and time
    complexity?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自顶向下的动态规划方法解决与空间和时间复杂度相关的问题时，以下哪个选项将是正确的？
- en: It will increase both time and space complexity
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将同时增加时间和空间复杂度
- en: It will increase the time complexity, and decrease the space complexity
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将增加时间复杂度，并降低空间复杂度
- en: It will increase the space complexity, and decrease the time complexity
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将增加空间复杂度，并降低时间复杂度
- en: It will decrease both time and space complexities
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将同时降低时间和空间复杂度
- en: Solution
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Option c is correct.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 选项c是正确的。
- en: Since the top-down approach of dynamic programming uses the memoization technique,
    which stores the pre-calculated solution of a subproblem. It avoids recalculation
    of the same subproblem that decreases the time complexity, but at the same time,
    the space complexity will increase because of storing the extra solutions of the
    subproblems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自顶向下的动态规划方法使用记忆化技术，它存储子问题的预计算解，这避免了重复计算相同的子问题，从而降低了时间复杂度，但同时也因为存储额外的子问题解而增加了空间复杂度。
- en: Question 2
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题2
- en: What will be the sequence of nodes in the following edge-weighted directed graph
    using the greedy approach (assume node **A** as the source)?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用贪心算法，以下边权有向图中的节点序列将是什么（假设节点**A**为源节点）？
- en: '![](img/B17217_15_01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_15_01.png)'
- en: 'Figure A.1: A weighted directed graph'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1：加权有向图
- en: Solution
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: A, B, C, F, E, D
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: A, B, C, F, E, D
- en: In Dijkstra’s algorithm, at each, point we choose the smallest weight edge,
    which starts from any one of the vertices in the shortest path found so far, and
    add it to the shortest path.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在迪杰斯特拉算法中，在每一步，我们选择权重最小的边，它从迄今为止找到的最短路径中的任何一个顶点开始，并将其添加到最短路径中。
- en: Question 3
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题3
- en: Consider the weights and values of the items in *Table 3.8*. Note that there
    is only one unit of each item.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑*表3.8*中的物品的重量和价值。注意，每种物品只有一个单位。
- en: '| **Item** | **Weight** | **Value** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **物品** | **重量** | **价值** |'
- en: '| A | 2 | 10 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| A | 2 | 10 |'
- en: '| B | 10 | 8 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| B | 10 | 8 |'
- en: '| C | 4 | 5 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| C | 4 | 5 |'
- en: '| D | 7 | 6 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| D | 7 | 6 |'
- en: 'Table A.1: The weights and values of different items'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.1：不同物品的重量和价值
- en: We need to maximize the value; the maximum weight should be 11 kg. No item may
    be split. Establish the values of the items using a greedy approach.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要最大化价值；最大重量应为11公斤。不允许分割任何物品。使用贪心算法确定物品的价值。
- en: Solution
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Firstly, we picked item A (weight 2 kg) as the value is the maximum (10). The
    second highest value is for item B, but as the total weight becomes 12 kg, this
    violates the given condition, so we cannot pick it. The next highest value is
    item D, and now the total weight becomes 2+7 = 9 kg (item A + item D). The next
    remaining item, C, cannot be picked because after adding it, the total weight
    condition will be violated.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择了项目 A（重量 2 公斤），因为其值是最大的（10）。第二高的值是项目 B，但由于总重量达到 12 公斤，这违反了给定的条件，因此我们不能选择它。下一个最高的值是项目
    D，现在总重量变为 2+7 = 9 公斤（项目 A + 项目 D）。下一个剩余的项目 C 不能选择，因为添加它后，总重量条件将被违反。
- en: So, the total value of the items picked up using the greedy approach = 10 +
    6 = 16
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用贪婪方法选择的物品的总价值 = 10 + 6 = 16
- en: 'Chapter 4: Linked Lists'
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：链表
- en: Question 1
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 1
- en: What will be the time complexity when inserting a data element after an element
    that is being pointed to by a pointer in a linked list?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表中插入数据元素后，指向该元素的指针的时间复杂度是多少？
- en: Solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: It will be `O(1)`, since there is no need to traverse the list to reach the
    desired location where a new element is to be added. A pointer is pointing to
    the current location, and a new element can be directly added by linking it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是 `O(1)`，因为不需要遍历列表以到达要添加新元素的目标位置。有一个指针指向当前位置，可以直接通过链接添加新元素。
- en: Question 2
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 2
- en: What will be the time complexity when ascertaining the length of the given linked
    list?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 确定给定链表长度的时间复杂度是多少？
- en: Solution
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '`O(n)`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(n)`。'
- en: In order to find out the length, each node of the list has to be traversed,
    which will take `O(n)`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出长度，必须遍历列表中的每个节点，这将花费 `O(n)`。
- en: Question 3
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 3
- en: What will be the worst-case time complexity for searching a given element in
    a singly linked list of length n?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在长度为 n 的单链表中搜索给定元素的最坏情况时间复杂度是多少？
- en: Solution
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '`O(n)`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(n)`.'
- en: In the worst case, the data element to be searched will be at the end of the
    list, or will not be present in the list. In that case, there will be a total
    `n` number of comparisons, thus making the worst-case time complexity `O(n)`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，要搜索的数据元素将在列表的末尾，或者根本不在列表中。在这种情况下，将进行总共 `n` 次比较，从而使最坏情况下的时间复杂度为 `O(n)`。
- en: Question 4
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 4
- en: For a given linked list, assuming it has only one `head` pointer that points
    to the starting point of the list, what will be the time complexity for the following
    operations?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的链表，假设它只有一个指向列表起始点的 `head` 指针，以下操作的时间复杂度是多少？
- en: Insertion at the front of the linked list
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链表前插入
- en: Insertion at the end of the linked list
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链表末尾插入
- en: Deletion of the front node of the linked list
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除链表的前节点
- en: Deletion of the last node of the linked list
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除链表的最后一个节点
- en: Solution
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '`O(1)`. This operation can be performed directly through the head node.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`O(1)`. 这个操作可以通过头节点直接执行。'
- en: '`O(n)`. It will require traversing the list to reach the end of the list.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`O(n)`. 需要遍历列表以到达列表的末尾。'
- en: '`O(1)`. This operation can be performed directly through the head node.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`O(1)`. 这个操作可以通过头节点直接执行。'
- en: '`O(n)`. It will require traversing the list to reach the end of the list.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`O(n)`. 需要遍历列表以到达列表的末尾。'
- en: Question 5
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 5
- en: Find the n^(th) node from the end of a linked list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从链表末尾找到第 n 个节点。
- en: Solution
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: In order to find out the n^(th) node from the end of the linked list, we can
    use two pointers – `f``irst` and `second`. Firstly, move the second pointer to
    `n` nodes from the starting point. Then, move both the pointers one step at a
    time until the second pointer reaches the end of the list. At that time, the first
    pointer will point to the n^(th) node from the end of the list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从链表末尾找到第 n 个节点，我们可以使用两个指针——`first` 和 `second`。首先，将第二个指针移动到起始点的第 n 个节点。然后，每次移动两个指针一步，直到第二个指针到达列表的末尾。那时，第一个指针将指向链表末尾的第
    n 个节点。
- en: Question 6
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 6
- en: How can you establish whether there is a loop (or circle) in a given linked
    list?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何确定给定链表中是否存在循环（或环）？
- en: Solution
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: To find out the loop in a linked list, it is most efficient to use **Floyd’s
    cycle-finding algorithm**. In this approach, two pointers are used to detect the
    loop – let’s say the first and second pointers. We start moving both the pointers
    from the starting point of the list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到链表中的循环，最有效的方法是使用**弗洛伊德循环查找算法**。在这种方法中，使用两个指针来检测循环——比如说第一个和第二个指针。我们从列表的起始点开始移动这两个指针。
- en: We move the first and second pointers by one and two nodes at a time. If these
    two pointers meet at the same node, that indicates that there is a loop, otherwise,
    there is no loop in the given linked list.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每次将第一个和第二个指针各移动一个和两个节点。如果这两个指针在同一个节点相遇，那么这表明存在一个循环，否则，给定的链表中不存在循环。
- en: 'The process is shown in the below figure with an example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图例展示了这个过程的一个示例：
- en: '![](img/B17217_15_02.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_15_02.png)'
- en: 'Figure A.2: Loop in a singly linked list'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.2：单链表中的循环
- en: Question 7
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题7
- en: How can you ascertain the middle element of the linked list?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如何确定链表的中间元素？
- en: Solution
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: It can be done with two pointers, say, the first and second pointers. Start
    moving these two pointers from the starting node. The first and second pointers
    should move one and two nodes at a time, respectively. When the second node reaches
    the end of the list, the first node will point to the middle element of the singly
    linked list.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两个指针来完成，比如，第一个和第二个指针。从起始节点开始移动这两个指针。第一个和第二个指针应该分别每次移动一个和两个节点。当第二个指针到达列表的末尾时，第一个指针将指向单链表的中间元素。
- en: 'Chapter 5: Stacks and Queues'
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：栈和队列
- en: Question 1
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题1
- en: Which of the following options is a true queue implementation using linked lists?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个选项是使用链表实现的正确队列实现？
- en: If, in the enqueue operation, new data elements are added at the start of the
    list, then the dequeue operation must be performed from the end.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在入队操作中，新的数据元素被添加到列表的起始位置，那么出队操作必须从列表的末尾执行。
- en: If, in the enqueue operation, new data elements are added to the end of the
    list, then the enqueue operation must be performed from the start of the list.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在入队操作中，新的数据元素被添加到列表的末尾，那么入队操作必须从列表的起始位置执行。
- en: Both of the above.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个都是。
- en: None of the above.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不对。
- en: Solution
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: B is correct. The queue data structure follows a FIFO order, hence data elements
    must be added to the end of the list, and then removed from the front.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: B是正确的。队列数据结构遵循FIFO顺序，因此数据元素必须添加到列表的末尾，然后从前面移除。
- en: Question 2
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题2
- en: Assume a queue is implemented using a singly linked list that has `head` and
    `tail` pointers. The enqueue operation is implemented at `head`, and the dequeue
    operation is implemented at the `tail` of the queue. What will be the time complexity
    of the enqueue and dequeue operations?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个队列使用一个具有`head`和`tail`指针的单链表实现。入队操作在`head`处实现，出队操作在队列的`tail`处实现。入队和出队操作的时间复杂度将是什么？
- en: Solution
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The time complexity of the enqueue operation will be `O(1)` and `O(n)` for the
    dequeue operation. As for the enqueue operation, we only need to delete the `head`
    node, which can be achieved in `O(1)` for a singly linked list. For the dequeue
    operation, to delete the `tail`, we need to traverse the whole list first to the
    `tail`, and then we can delete it. For this we need linear, `O(n)`, time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 入队操作的时间复杂度将是`O(1)`，出队操作的时间复杂度是`O(n)`。至于入队操作，我们只需要删除`head`节点，对于单链表来说，这可以在`O(1)`时间内完成。对于出队操作，为了删除`tail`，我们需要先遍历整个列表到`tail`，然后才能删除它。为此，我们需要线性时间，`O(n)`。
- en: Question 3
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题3
- en: What is the minimum number of stacks required to implement a queue?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个队列需要多少个栈？
- en: Solution
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Two stacks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 两个栈。
- en: Using two stacks and the enqueue operation, the new element is entered at the
    top of `stack1`. In the dequeue process, if `stack2` is empty, all the elements
    are moved to `stack2`, and finally, the top of `stack2` is returned.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个栈和入队操作，新元素被添加到`stack1`的顶部。在出队过程中，如果`stack2`为空，则将所有元素移动到`stack2`，最后返回`stack2`的顶部。
- en: Question 4
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题4
- en: The enqueue and dequeue operations in a queue are implemented efficiently using
    an array. What will be the time complexity for both of these operations?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列中使用数组高效地实现了入队和出队操作。这两个操作的时间复杂度将是多少？
- en: Solution
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: '`O(1)` for both operations.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 两个操作都是`O(1)`。
- en: If we use a circular array for the implementation of a queue, then we do not
    need to shift the elements, just the pointers, so we can implement both the enqueue
    and dequeue operations in `O(1)` time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用循环数组来实现队列，那么我们不需要移动元素，只需要移动指针，因此我们可以以`O(1)`的时间复杂度实现入队和出队操作。
- en: Question 5
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题5
- en: How can we print the data elements of a queue data structure in reverse order?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以相反的顺序打印队列数据结构的数据元素？
- en: Solution
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Make an empty stack, then enqueue each of the elements from the queue and push
    them into the stack. After the queue is empty, start popping out the elements
    from the stack and then printing them one by one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空栈，然后将队列中的每个元素从队列中取出并推入栈中。当队列为空时，开始从栈中弹出元素并逐个打印。
- en: 'Chapter 6: Trees'
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章：树
- en: Question 1
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 1
- en: 'Which of the following is true about binary trees:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于二叉树以下哪个说法是正确的：
- en: Every binary tree is either complete or full
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每棵二叉树要么是完全二叉树，要么是满二叉树
- en: Every complete binary tree is also a full binary tree
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每棵完全二叉树也都是满二叉树
- en: Every full binary tree is also a complete binary tree
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个满二叉树也都是一个完全二叉树
- en: No binary tree is both complete and full
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有二叉树既是完全二叉树又是满二叉树
- en: None of the above
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不对
- en: Solution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Option A is incorrect since it is not compulsory that a binary tree should be
    complete or full.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 A 是错误的，因为二叉树不一定是完全二叉树或满二叉树。
- en: Option B is incorrect since a complete binary tree can have some nodes that
    are not filled in the last level, so a complete binary tree will not always be
    a full binary tree.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 B 是错误的，因为完全二叉树可以有某些节点在最后一层未填充，所以完全二叉树不一定是满二叉树。
- en: 'Option C is incorrect, as it is not always true, the following figure is a
    full binary tree, but not a complete binary tree:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 C 是错误的，因为这不总是正确的，以下图是一个满二叉树，但不是完全二叉树：
- en: '![](img/B17217_15_03.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_15_03.png)'
- en: 'Figure A.3: A binary tree that is full, but not complete'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.3：一棵是满二叉树但不是完全二叉树的二叉树
- en: 'Option D is incorrect, as it is not always true. The following tree is both
    a complete and full binary tree:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 D 是错误的，因为这不总是正确的。以下树既是完全二叉树，也是满二叉树：
- en: '![](img/B17217_15_04.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_15_04.png)'
- en: 'Figure A.4: A binary tree, that is full and complete'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.4：一棵既是满二叉树又是完全二叉树的二叉树
- en: Question 2
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 2
- en: Which of the tree traversal algorithms visit the root node last?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种树遍历算法最后访问根节点？
- en: Solution
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: '`postorder` traversal.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`后序遍历`.'
- en: Using `postorder` traversal, we first visit the left subtree, then the right
    subtree, and finally we visit the `root` node.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `后序遍历`，我们首先访问左子树，然后是右子树，最后访问 `根` 节点。
- en: Question 3
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 3
- en: 'Consider this binary search tree:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个二叉搜索树：
- en: '![](img/B17217_15_05.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_15_05.png)'
- en: 'Figure A.5: Sample binary search tree'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.5：示例二叉搜索树
- en: Suppose we remove the root node `8`, and we wish to replace it with any node
    from the left subtree then what will be the new root?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们移除根节点 `8`，并希望用左子树中的任何节点替换它，那么新的根节点将是什么？
- en: Solution
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The new node will be node `6`. To maintain the properties of the binary search
    tree, the maximum value from the left subtree should be the new root.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点将是节点 `6`。为了保持二叉搜索树的性质，左子树中的最大值应该是新的根。
- en: Question 4
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 4
- en: What will be the `inorder`, `postorder`, and `preorder` traversal of the following
    tree?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下树的 `中序`、`后序`和 `前序`遍历将是什么？
- en: '![](img/B17217_15_06.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_15_06.png)'
- en: 'Figure A.6: Example tree'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.6：示例树
- en: Solution
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The `preorder` traversal will be `7`-`5`-`1`-`6`-`8`-`9`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`前序遍历`将是 `7`-`5`-`1`-`6`-`8`-`9`。'
- en: The `inorder` traversal will be `1`-`5`-`6`-`7`-`8`-`9`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`中序遍历`将是 `1`-`5`-`6`-`7`-`8`-`9`。'
- en: The `postorder` traversal will be `1`-`6`-`5`-`9`-`8`-`7`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`后序遍历`将是 `1`-`6`-`5`-`9`-`8`-`7`。'
- en: Question 5
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 5
- en: How do you find out if two trees are identical?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何判断两棵树是否相同？
- en: Solution
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: In order to find out if two binary trees are identical or not, both of the trees
    should have exactly the same data and element arrangement. This can be done by
    traversing both of the trees with any of the traversal algorithms (it should be
    the same for both trees) and matching them element by element. If all the elements
    are the same in traversing both of the trees, then the trees are identical.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出两棵二叉树是否相同，这两棵树应该有完全相同的数据和元素排列。这可以通过使用任何遍历算法（对于两棵树应该是相同的）遍历这两棵树并逐个匹配元素来实现。如果在遍历两棵树的过程中所有元素都相同，那么这两棵树是相同的。
- en: Question 6
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 6
- en: How many leaves are there in the tree mentioned in *question 4*?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题 4 中提到的树中有多少个叶子节点？
- en: Solution
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Three, nodes `1`, `6`, and `9`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 三个节点 `1`、`6` 和 `9`。
- en: Question 7
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 7
- en: What is the relation between a perfect binary tree’s height and the number of
    nodes in that tree?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完美二叉树的高度与该树中的节点数之间有什么关系？
- en: Solution
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: '`log[2](n+1) = h.`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`log[2](n+1) = h.`'
- en: 'The number of nodes in each level:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层的节点数：
- en: 'Level `0`: `2`⁰ = 1 nodes'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '层级 `0`: `2`⁰ = 1 个节点'
- en: 'Level `1`: `2`¹ = 2 nodes'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '层级 `1`: `2`¹ = 2 个节点'
- en: 'Level `2`: `2`² = 4 nodes'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '层级 `2`: `2`² = 4 个节点'
- en: 'Level `3`: `2`³ = 8 nodes'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '层级 `3`: `2`³ = 8 个节点'
- en: 'The total nodes at level `h` can be computed by adding all nodes in each level:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将每一层的所有节点相加来计算第 `h` 层的总节点数：
- en: n = 2⁰ + 2¹ + 2² + 2³ + ……. 2^(h-1) = 2^h - 1
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: n = 2⁰ + 2¹ + 2² + 2³ + …… 2^(h-1) = 2^h - 1
- en: 'So, the relationship between `n` and `h` is: `n = 2`^h - 1'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`n` 和 `h` 之间的关系是：`n = 2`^h - 1
- en: = log (n+1) = log2^h
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: = log (n+1) = log2^h
- en: = log[2] (n+1) = h
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: = log[2] (n+1) = h
- en: 'Chapter 7: Heaps and Priority Queues'
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：堆和优先队列
- en: Question 1
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 1
- en: What will be the time complexity for deleting an arbitrary element from the
    `min-heap`?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `min-heap` 中删除任意元素的时间复杂度是多少？
- en: Solution
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: To delete any element from the `heap`, we first have to search the element that
    is to be deleted, and then we delete the element.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `heap` 中删除任何元素，我们首先必须搜索要删除的元素，然后删除该元素。
- en: Total time complexity = Time for searching the element + Deleting the element
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总时间复杂度 = 搜索元素的时间 + 删除元素的时间
- en: = `O(n)` + `O(log n)`
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: = `O(n)` + `O(log n)`
- en: = `O(n)`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: = `O(n)`
- en: Question 2
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 2
- en: What will be the time complexity for finding the k^(th) smallest element from
    the `min-heap`?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `min-heap` 中找到第 `k` 个最小元素的时间复杂度是多少？
- en: Solution
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The k^(th) element can be found out from the `min-heap` by performing `delete`
    operations k times. For each `delete` operation, the time complexity is `O(logn)`.
    So, the total time complexity for finding out the k^(th) smallest element will
    be `O(klogn)`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行 `delete` 操作 `k` 次来从 `min-heap` 中找到第 `k` 个元素。对于每次 `delete` 操作，时间复杂度是 `O(logn)`。因此，找到第
    `k` 个最小元素的总时间复杂度将是 `O(klogn)`。
- en: Question 3
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 3
- en: What will be the time complexity to make a `max-heap` that combines two `max-heap`
    each of size `n`?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个大小为 `n` 的 `max-heap` 合并成一个 `max-heap` 的时间复杂度是多少？
- en: Solution
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: '`O(n)`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(n)`。'
- en: Since the time complexity of creating a `heap` from `n` elements is `O(n)`,
    creating a `heap` of `2n` elements will also be `O(n)`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从 `n` 个元素创建 `heap` 的时间复杂度是 `O(n)`，因此创建 `2n` 个元素的 `heap` 也将是 `O(n)`。
- en: Question 4
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 4
- en: What will be the worst-case time complexity for ascertaining the smallest element
    from a binary max-heap and binary min-heap?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 确定二叉最大堆和二叉最小堆中最小元素的最坏情况时间复杂度是多少？
- en: Solution
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: In a max-heap, the smallest element will always be present at a leaf node. So,
    in order to find out the smallest element, we have to search all the leaf nodes.
    So, the worst-case complexity will be `O(n)`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在最大堆中，最小的元素始终位于叶节点。因此，为了找到最小的元素，我们必须搜索所有的叶节点。因此，最坏情况复杂度将是 `O(n)`。
- en: The worst-case time complexity to find out the smallest element in the min-heap
    will be `O(1)` since it will always be present at the root node.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小堆中找到最小元素的最坏情况时间复杂度将是 `O(1)`，因为它始终位于根节点。
- en: Question 5
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 5
- en: The level order traversal of `max-heap` is `12`, `9`, `7`, `4`, `2`. After inserting
    new elements `1` and `8`, what will be the final `max-heap` and level order traversal
    of the final `max-heap`?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`max-heap` 的层序遍历是 `12`, `9`, `7`, `4`, `2`。在插入新元素 `1` 和 `8` 之后，最终的 `max-heap`
    和最终 `max-heap` 的层序遍历将是什么？'
- en: Solution
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: 'The `max-heap` after the insertion of element `1` is shown in the below figure:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 插入元素 `1` 后的 `max-heap` 如下图所示：
- en: '![](img/B17217_15_07.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_15_07.png)'
- en: 'Figure A.7: The max-heap before insertion of element 8'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.7：插入元素 8 之前的最大堆
- en: 'The final `max-heap` after the insertion of element `8` is shown in the below
    figure:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 插入元素 `8` 后的最终 `max-heap` 如下图所示：
- en: '![](img/B17217_15_08.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_15_08.png)'
- en: 'Figure A.8: The max-heap after the insertion of elements 1 and 8'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.8：插入元素 1 和 8 后的最大堆
- en: The level order traversal of the final `max-heap` will be `12`, `9`, `8`, `4`,
    `2`, `1`, `7`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最终 `max-heap` 的层序遍历将是 `12`, `9`, `8`, `4`, `2`, `1`, `7`。
- en: Question 6
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 6
- en: Which of the following is a binary `max-heap`?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个是二叉 `max-heap`？
- en: '![](img/B17217_15_09.1.png)![](img/B17217_15_09.2.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_15_09.1.png)![](img/B17217_15_09.2.png)'
- en: 'Figure A.9: Example trees'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.9：示例树
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: B.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: B.
- en: A binary `max-heap` should be a complete binary tree and all the levels should
    be filled, except the last level. The value of the parent should be greater or
    equal to the values of its children.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个二叉 `max-heap` 应该是一个完整的二叉树，除了最后一层之外的所有层都应该被填满。父节点的值应该大于或等于其子节点的值。
- en: Option A is not correct because it is not a complete binary tree. Options C
    and D are not correct because they are not fulfilling the `heap` property. Option
    B is correct because it is complete and fulfills the `heap` property.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 A 是不正确的，因为它不是一个完整的二叉树。选项 C 和 D 是不正确的，因为它们没有满足 `heap` 属性。选项 B 是正确的，因为它既完整又满足
    `heap` 属性。
- en: 'Chapter 8: Hash Tables'
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：哈希表
- en: Question 1
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 1
- en: There is a hash table with 40 slots and there are 200 elements stored in the
    table. What will be the load factor of the hash table?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该哈希表有40个槽位，表中存储了200个元素。哈希表的负载因子是多少？
- en: Solution
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The load factor of the hash table = (no. of elements) / (no. of table slots)
    = 200/40 = 5.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的负载因子 = (元素数量) / (表槽位数量) = 200/40 = 5。
- en: Question 2
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题2
- en: What is the worst-case search time of hashing using a separate chaining algorithm?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独链接算法进行哈希的最坏情况搜索时间是多少？
- en: Solution
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The worst-case time complexity for searching in a separate chaining algorithm
    using linked lists is `O(n)`, because in the worst case, all the items will be
    added to `index 1` in a linked list, searching an item will work similarly to
    a linked list.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链表进行单独链接算法搜索的最坏情况时间复杂度是`O(n)`，因为在最坏的情况下，所有项目都将添加到链表的`index 1`，搜索一个项目的工作方式将与链表类似。
- en: Question 3
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题3
- en: Assume a uniform distribution of keys in the hash table. What will be the time
    complexities for the `search`/`insert`/`delete` operations?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设哈希表中的键均匀分布。`搜索`/`插入`/`删除`操作的时间复杂度将是什么？
- en: Solution
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The index of the hash table is computed from the key in `O(1)` time when the
    keys are uniformly distributed in the hash table. The creation of the table will
    take `O(n)` time, and other operations such as `search`, `insert`, and `delete`
    operations will take `O(1)` time because all the elements are uniformly distributed,
    hence, we directly get the required element.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当哈希表中的键均匀分布时，哈希表的索引在`O(1)`时间内从键中计算出来。创建表将花费`O(n)`时间，而其他操作如`搜索`、`插入`和`删除`操作将花费`O(1)`时间，因为所有元素都是均匀分布的，因此，我们可以直接获取所需元素。
- en: Question 4
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题4
- en: What will be the worst-case complexity for removing the duplicate characters
    from an array of characters?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符数组中删除重复字符的最坏情况复杂度是多少？
- en: Solution
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The brute force algorithm starts with the first character and searches linearly
    with all the characters of the array. If a duplicate character is found, then
    that character should be swapped with the last character and then the length of
    the string should be decremented by one. The same process is repeated until all
    characters are processed. The time complexity of this process is O(n²).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力算法从第一个字符开始，与数组的所有字符进行线性搜索。如果找到重复字符，则应将该字符与最后一个字符交换，然后字符串的长度应减少一个。重复此过程，直到所有字符都被处理。此过程的时间复杂度是O(n²)。
- en: It can be implemented more efficiently using a hash table in `O(n)` time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用哈希表以`O(n)`的时间复杂度更有效地实现。
- en: Using this method, we start with the first character of the array and store
    it in the hash table according to the hash value. We do it for all the characters.
    If there is any collision, then that character can be ignored, otherwise, the
    character is stored in the hash table.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们从数组的第一个字符开始，根据哈希值将其存储在哈希表中。我们对所有字符都这样做。如果有任何冲突，则可以忽略该字符，否则，该字符将被存储在哈希表中。
- en: 'Chapter 9: Graphs and Algorithms'
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：图和算法
- en: Question 1
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题1
- en: What is the maximum number of edges (without self-loops) possible in an undirected
    simple graph with five nodes?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有五个节点的无向简单图中，可能的最大边数（不包括自环）是多少？
- en: Solution
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: 'Each node can be connected to every other node in the graph. So, the first
    node can be connected to `n-1` nodes, the second node can be connected to `n-2`
    nodes, the third node can be connected to `n-3` nodes, and so on. The total number
    of nodes will be:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点可以连接到图中的其他每个节点。因此，第一个节点可以连接到`n-1`个节点，第二个节点可以连接到`n-2`个节点，第三个节点可以连接到`n-3`个节点，以此类推。节点的总数将是：
- en: '*[(n-1)+(n-2)+ … +3+2+1] = n(n-1)/2.*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*[(n-1)+(n-2)+…+3+2+1] = n(n-1)/2.*'
- en: Question 2
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题2
- en: What do we call a graph in which all the nodes have an equal degree?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称所有节点具有相等度数的图为什么？
- en: Solution
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: A complete graph.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完全图。
- en: Question 3
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题3
- en: Explain what cut vertices are and identify the cut vertices in the given graph?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 解释什么是割点，并识别给定图中的割点？
- en: '![](img/B17217_15_10.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_15_10.png)'
- en: 'Figure A.10: Sample graph'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.10：示例图
- en: Solution
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Cut vertices also known as articulation points. These are the vertices in the
    graph, after removal of which, the graph splits in two disconnected components.
    In the given graph, the vertices `B`, and `C` are cut vertices since after removal
    of node `B`, the graph will split into `{A,D}`, `{C,E}` vertices. And, after removal
    of node `C`, the graph will split into `{A,B,D}`, `{E}` vertices.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 割点也称为连通点。这些是在图中，移除后图将分成两个不连通部分的顶点。在给定的图中，顶点 `B` 和 `C` 是割点，因为移除节点 `B` 后，图将分成
    `{A,D}`、`{C,E}` 顶点。同样，移除节点 `C` 后，图将分成 `{A,B,D}`、`{E}` 顶点。
- en: Question 4
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 4
- en: Assuming a graph `G` of order `n`, what will be the maximum number of cut vertices
    possible in graph `G`?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个阶数为 n 的图 G，图 G 中可能的最大割点数是多少？
- en: Solution
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: 'It will be `n-2`, since the first and last vertices will not be cut vertices,
    except those two nodes, all nodes can split the graph into two disconnected graphs.
    See the below graph:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将是 `n-2`，因为第一个和最后一个顶点不会是割点，除了这两个节点，所有节点都可以将图分割成两个不连通的图。请参见下面的图：
- en: '![](img/B17217_15_11.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_15_11.png)'
- en: 'Figure A.11: A graph G'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.11：图 G
- en: 'Chapter 10: Searching'
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：搜索
- en: Question 1
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 1
- en: On average, how many comparisons are required in a linear search of `n` elements?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在平均情况下，对 n 个元素的线性搜索需要多少次比较？
- en: Solution
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The average number of comparisons in linear search will be as follows. When
    a search element is found at the `1`^(st) position, `2`^(nd) position, `3`^(rd)
    position, and similarly at the `n`^(th) position, correspondingly, it will require
    `1`, `2`, `3`… `n` number of comparisons.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索的平均比较次数如下。当搜索元素在第一个位置、第二个位置、第三个位置，以及类似地在第 n 个位置找到时，相应地，它将需要 1、2、3…n 次比较。
- en: Total average number of comparisons
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 总平均比较次数
- en: = ![](img/B17217_15_001.png)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: = ![图片](img/B17217_15_001.png)
- en: = ![](img/B17217_15_002.png)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: = ![图片](img/B17217_15_002.png)
- en: = ![](img/B17217_15_003.png)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: = ![图片](img/B17217_15_003.png)
- en: Question 2
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 2
- en: Assume there are eight elements in a sorted array. What is the average number
    of comparisons that will be required if all the searches are successful and if
    the binary search algorithm is used?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个排序数组中有八个元素。如果所有搜索都成功并且使用二分搜索算法，平均需要多少次比较？
- en: Solution
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Average number of comparisons = (1+2+2+3+3+3+3+4)/8
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 平均比较次数 = (1+2+2+3+3+3+3+4)/8
- en: = 21/8
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: = 21/8
- en: = 2.625
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: = 2.625
- en: '![](img/B17217_15_12.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_15_12.png)'
- en: 'Figure A.12: Demonstration of number of the comparisons in the given array'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 A.12：给定数组中比较次数的演示](img/B17217_15_003.png)'
- en: Question 3
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 3
- en: What is the worst-case time complexity of the binary search algorithm?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索算法的最坏情况时间复杂度是多少？
- en: Solution
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: '`O(logn)`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(logn)`。'
- en: The worst-case scenario of the binary search algorithm will occur when the desired
    element is present in the first position or at the last position. In that case,
    `log(n)` comparisons will be required. Hence the worst-case complexity will be
    `O(logn)`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索算法的最坏情况将在所需元素位于第一个位置或最后一个位置时发生。在这种情况下，需要 `log(n)` 次比较。因此，最坏情况的复杂度将是 `O(logn)`。
- en: Question 4
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 4
- en: When should the interpolation search algorithm perform better than the binary
    search algorithm?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下插值搜索算法的性能应该优于二分搜索算法？
- en: Solution
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The interpolation search algorithm performs better than the binary search algorithm
    when the data items in the array are uniformly distributed.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组中的数据项均匀分布时，插值搜索算法的性能优于二分搜索算法。
- en: 'Chapter 11: Sorting'
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章：排序
- en: Question 1
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 1
- en: If an array `arr = {55, 42, 4, 31}` is given and bubble sort is used to sort
    the array elements, then how many passes will be required to sort the array?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定一个数组 `arr = {55, 42, 4, 31}` 并使用冒泡排序对数组元素进行排序，那么需要多少次遍历才能对数组进行排序？
- en: '3'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3'
- en: '2'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2'
- en: '1'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '0'
- en: Solution
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The answer is a. To sort `n` elements, the bubble sort algorithm requires (`n-1`)
    iterations (passes), where `n` is the number of elements in the given array. Here
    in the question, the value of `n` = `4`, so `4`-`1` = `3` iterations will be required
    to sort the given array.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 a。为了对 n 个元素进行排序，冒泡排序算法需要 (`n-1`) 次迭代（遍历），其中 n 是给定数组中的元素数量。在此问题中，n 的值为 `4`，所以需要
    `4-1` = `3` 次迭代来排序给定的数组。
- en: Question 2
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 2
- en: What is the worst-case complexity of bubble sort?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序的最坏情况复杂度是多少？
- en: O(nlogn)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: O(nlogn)
- en: O(logn)
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: O(logn)
- en: O(n)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: O(n)
- en: O(n²)
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: O(n²)
- en: Solution
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The answer is d. The worst case appears when the given array is in reverse order.
    In that case, the time complexity of bubble sort would be O(n²).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 d。最坏情况出现在给定数组是逆序的情况下。在这种情况下，冒泡排序的时间复杂度将是 O(n²)。
- en: Question 3
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 3
- en: Apply quicksort to the sequence (`56`, `89`, `23`, `99`, `45`, `12`, `66`, `78`,
    `34`). What is the sequence after the first phase, and what pivot is the first
    element?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将快速排序应用于序列 (`56`, `89`, `23`, `99`, `45`, `12`, `66`, `78`, `34`)。第一阶段后的序列是什么，第一个元素是什么支点？
- en: 45, 23, 12, 34, 56, 99, 66, 78, 89
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 45, 23, 12, 34, 56, 99, 66, 78, 89
- en: 34, 12, 23, 45, 56, 99, 66, 78, 89
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 34, 12, 23, 45, 56, 99, 66, 78, 89
- en: 12, 45, 23, 34, 56, 89, 78, 66, 99
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 12, 45, 23, 34, 56, 89, 78, 66, 99
- en: 34, 12, 23, 45, 99, 66, 89, 78, 56
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 34, 12, 23, 45, 99, 66, 89, 78, 56
- en: Solution
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: b.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: b.
- en: After the first phase, `56` would be in the right position so that all the elements
    smaller than `56` will be on the left side of it, and elements bigger than `56`
    will be on the right side of it. Further, quicksort is applied recursively to
    the left subarray and right subarray. The process of the quicksort for the given
    sequence, as shown in the below figure.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段后，`56` 将处于正确的位置，以便所有小于 `56` 的元素都将位于其左侧，而大于 `56` 的元素都将位于其右侧。进一步，快速排序递归地应用于左子数组和右子数组。如图所示，对给定序列进行快速排序的过程。
- en: '![](img/B17217_15_13.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_15_13.png)'
- en: 'Figure A.13: Demonstration of the quicksort algorithm'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.13：快速排序算法的演示
- en: Question 4
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 4
- en: Quicksort is a ___________
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是一种 ___________
- en: Greedy algorithm
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贪心算法
- en: Divide-and-conquer algorithm
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分而治之算法
- en: Dynamic programming algorithm
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态规划算法
- en: Backtracking algorithm
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回溯算法
- en: Solution
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The answer is b. Quicksort is a divide-and-conquer algorithm. Quick sort first
    partitions a large array into two smaller sub arrays and then recursively sorts
    the sub-arrays. Here, we find the pivot element such that all elements to the
    left side of the pivot element would be smaller than the pivot element and create
    the first subarray. The elements to the right side of the pivot element are greater
    than the pivot element and create the second subarray. Thus, the given problem
    is reduced into two smaller sets. Now, sort these two subarrays again, finding
    the pivot element in each subarray, i.e. apply quicksort on each subarray.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 b。快速排序是一种分而治之算法。快速排序首先将一个大数组分成两个较小的子数组，然后递归地对子数组进行排序。在这里，我们找到支点元素，使得支点元素左侧的所有元素都小于支点元素，并创建第一个子数组。支点元素右侧的元素都大于支点元素，并创建第二个子数组。因此，给定问题被简化为两个较小的集合。现在，再次对这些两个子数组进行排序，在每个子数组中找到支点元素，即在每个子数组上应用快速排序。
- en: Question 5
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 5
- en: Consider a situation where a `swap` operation is very costly. Which of the following
    sorting algorithms should be used so that the number of `swap` operations is minimized?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种情况，`swap` 操作非常昂贵。以下哪种排序算法应该被使用，以便最小化 `swap` 操作的数量？
- en: Heap sort
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆排序
- en: Selection sort
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择排序
- en: Insertion sort
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Merge sort
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归并排序
- en: Solution
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: b. In the selection sort algorithm, in general, we identify the largest element,
    and then swap it with the last element so that in each iteration, only one `swap`
    is required. For `n` elements, the total (`n-1`) swaps will be required, which
    is the lowest in comparison to all other algorithms.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: b. 在选择排序算法中，通常我们识别最大的元素，然后将其与最后一个元素交换，以便在每次迭代中只需要一个 `swap`。对于 `n` 个元素，总共需要 (`n-1`)
    次 `swap`，这是与其他所有算法相比最低的。
- en: Question 6
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 6
- en: 'If the input array `A = {15, 9, 33, 35, 100, 95, 13, 11, 2, 13}` is given,
    using selection sort, what would be the order of the array after the fifth `swap`?
    (Note: it counts regardless of whether they exchange or remain in the same position.)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的输入数组 `A = {15, 9, 33, 35, 100, 95, 13, 11, 2, 13}`，使用选择排序，第五次 `swap` 后数组的顺序是什么？（注意：无论它们是否交换或保持在同一位置，都计算在内。）
- en: 2, 9, 11, 13, 13, 95, 35, 33, 15, 100
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2, 9, 11, 13, 13, 95, 35, 33, 15, 100
- en: 2, 9, 11, 13, 13, 15, 35, 33, 95, 100
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2, 9, 11, 13, 13, 15, 35, 33, 95, 100
- en: 35, 100, 95, 2, 9, 11, 13, 33, 15, 13
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 35, 100, 95, 2, 9, 11, 13, 33, 15, 13
- en: 11, 13, 9, 2, 100, 95, 35, 33, 13, 13
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 11, 13, 9, 2, 100, 95, 35, 33, 13, 13
- en: Solution
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The answer is a. In selection sort, select the smallest element. Start the comparison
    from the beginning of the array and swap the smallest element with the first greatest
    element. Now, exclude the previous element that was chosen as the smallest element,
    as it has been put in the right place.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 a。在选择排序中，选择最小的元素。从数组的开始处开始比较，并将最小的元素与第一个最大的元素交换。现在，排除之前选为最小的元素，因为它已经被放在了正确的位置。
- en: '![](img/B17217_15_14.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_15_14.png)'
- en: 'Figure A.14: Demonstration of insertion sort on the given sequence'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.14：给定序列上插入排序的演示
- en: Question 7
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 7
- en: What will be the number of iterations to sort the elements `{44, 21, 61, 6,
    13, 1}` using insertion sort?
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用插入排序对元素 `{44, 21, 61, 6, 13, 1}` 进行排序需要多少次迭代？
- en: '6'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5'
- en: '7'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7'
- en: '1'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: Solution
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: The answer is a. Suppose there are `N` keys in an input list, then it requires
    `N` iterations to sort the entire list using insertion sort.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 a。假设输入列表中有 `N` 个键，那么使用插入排序对整个列表进行排序需要 `N` 次迭代。
- en: Question 8
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 8
- en: How will the array elements `A= [35, 7, 64, 52, 32, 22]` look after the second
    iteration, if the elements are sorted using insertion sort?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用插入排序对数组元素 `A= [35, 7, 64, 52, 32, 22]` 进行排序，那么在第二次迭代后数组元素将如何排列？
- en: 7, 22, 32, 35, 52, 64
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7, 22, 32, 35, 52, 64
- en: 7, 32, 35, 52, 64, 22
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7, 32, 35, 52, 64, 22
- en: 7, 35, 52, 64, 32, 22
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7, 35, 52, 64, 32, 22
- en: 7, 35, 64, 52, 32, 22
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7, 35, 64, 52, 32, 22
- en: Solutions
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: d. Here `N` = `6`. In the first iteration, the first element, that is, `A[1]`
    `=` `35`, is inserted into array `B`, which is initially empty. In the second
    iteration, `A[2] = 7` is compared with the elements in `B` starting from the rightmost
    element of `B` to find its place. So, after the second iteration, the input array
    would be `A = [7, 35, 64, 52, 32, 22]`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: d. 在这里 `N` = `6`。在第一次迭代中，第一个元素，即 `A[1]` `=` `35`，被插入到初始为空的数组 `B` 中。在第二次迭代中，`A[2]
    = 7` 与 `B` 的最右侧元素开始比较，以找到其位置。因此，在第二次迭代后，输入数组将是 `A = [7, 35, 64, 52, 32, 22]`。
- en: 'Chapter 12: Selection Algorithm'
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章：选择算法
- en: Question 1
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 1
- en: What will be the output if the quickselect algorithm is applied to the given
    array `arr=[3, 1, 10, 4, 6, 5]` with `k` given as 2?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将快速选择算法应用于给定的数组 `arr=[3, 1, 10, 4, 6, 5]` 并给定 `k` 为 2，输出将是什么？
- en: Solution
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: 'Given the initial array: `[3, 1, 10, 4, 6, 5]`, we can find the median of medians:
    `4` (index = `3`).'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定初始数组：`[3, 1, 10, 4, 6, 5]`，我们可以找到中位数的中位数：`4`（索引 = `3`）。
- en: 'We swap the pivot element with the first element: `[4, 1, 3, 10, 6, 5]`.'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将枢轴元素与第一个元素交换：`[4, 1, 3, 10, 6, 5]`。
- en: 'We will move the pivot element to its correct position: `[1, 3, 4, 10, 6, 5]`.'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将枢轴元素移动到其正确的位置：`[1, 3, 4, 10, 6, 5]`。
- en: Now we get a split index equal to `2` but the value of `k` is also equal to
    `2`, hence the value at index `2` will be our output. Hence the output will be
    `4`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们得到一个分割索引等于 `2`，但 `k` 的值也等于 `2`，因此索引 `2` 的值将是我们的输出。因此，输出将是 `4`。
- en: Question 2
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 2
- en: Can quickselect find the smallest element in an array with duplicate values?
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 快速选择算法能否在具有重复值的数组中找到最小元素？
- en: Solution
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Yes, it works. By the end of every iteration, we have all elements less than
    the current pivot stored to the left of the pivot. Let’s consider when all elements
    are the same. In this case, every iteration ends up putting a pivot element to
    the left of the array. And the next iteration will continue with one element shorter
    in the array.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它有效。在每个迭代的结束时，我们都有所有小于当前枢轴的元素存储在枢轴的左侧。让我们考虑当所有元素都相同的情况。在这种情况下，每个迭代都会在数组的左侧放置一个枢轴元素。下一个迭代将继续使用数组中少一个元素的数组。
- en: Question 3
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 3
- en: What is the difference between the quicksort algorithm and the quickselect algorithm?
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法与快速选择算法之间的区别是什么？
- en: Solution
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: In quickselect, we do not sort the array, and it is specifically for finding
    the k^(th) smallest element in the array. The algorithm repeatedly divides the
    array into two sections based on the value of the pivot element. As we know, the
    pivot element will be placed such that all the elements to its left are smaller
    than the pivot element, and all the elements to the right are larger than the
    pivot element. Thus, we can select any one of the segments of the array based
    on the target value. This way, the size of the operable range of our array keeps
    on reducing. This reduces the complexity from O(nlog[2](n)) to O(n).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速选择算法中，我们不对数组进行排序，它专门用于在数组中找到第 k 个最小的元素。该算法根据枢轴元素的值将数组反复分为两个部分。正如我们所知，枢轴元素将被放置，使得其左侧的所有元素都小于枢轴元素，而其右侧的所有元素都大于枢轴元素。因此，我们可以根据目标值选择数组的任意一个部分。这样，我们数组可操作的范围不断缩小。这降低了复杂度从
    O(nlog[2](n)) 到 O(n)。
- en: Question 4
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 4
- en: What is the main difference between the deterministic selection algorithm and
    the quickselect algorithm?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性选择算法与快速选择算法的主要区别是什么？
- en: Solution
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: In the `quickselect` algorithm, we find the k^(th) smallest element in an unordered
    list based on picking up the pivot element randomly. Whereas, in the deterministic
    selection algorithm, which is also used for finding the k^(th) smallest element
    from an unordered list, but in this algorithm, we choose a pivot element by using
    median of medians, instead of taking any random pivot element.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `quickselect` 算法中，我们根据随机选择的枢轴元素在无序列表中找到第 k 小的元素。而，在确定性选择算法中，该算法也用于从无序列表中找到第
    k 小的元素，但在这个算法中，我们通过中位数的中位数来选择枢轴元素，而不是随机选择任何枢轴元素。
- en: Question 5
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 5
- en: What triggers the worst-case behavior of the selection algorithm?
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 什么触发了选择算法的最坏情况行为？
- en: Solution
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Continuously picking the largest or smallest element on each iteration triggers
    the worst-case behavior of the selection algorithm.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中连续选择最大或最小元素会触发选择算法的最坏情况行为。
- en: 'Chapter 13: String Matching Algorithms'
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章：字符串匹配算法
- en: Question 1
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 1
- en: Show the KMP `prefix` function for the pattern `"aabaabcab"`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 展示模式 `"aabaabcab"` 的 KMP `prefix` 函数。
- en: Solution
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: 'The `prefix` function values are given below:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 `prefix` 函数值如下：
- en: '| **pattern** | a | a | b | a | a | b | c | a | b |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | a | a | b | a | a | b | c | a | b |'
- en: '| `prefix_function` ![](img/Appendix_02.png) | 0 | 1 | 0 | 1 | 2 | 3 | 0 |
    1 | 0 |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `prefix_function` ![附录_02.png](img/Appendix_02.png) | 0 | 1 | 0 | 1 | 2 |
    3 | 0 | 1 | 0 |'
- en: 'Table A.2: Prefix function for the given patten'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.2：给定模式的预置函数
- en: Question 2
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 2
- en: If the expected number of valid shifts is small and the modulus is larger than
    the length of the pattern, then what is the matching time of the Rabin-Karp algorithm?
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果期望的有效位移数很小，并且模数大于模式长度，那么 Rabin-Karp 算法的匹配时间是多少？
- en: Theta (`m`)
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Theta (`m`)
- en: Big O (`n+m`)
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Big O (`n+m`)
- en: Theta (`n-m`)
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Theta (`n-m`)
- en: Big O (`n`)
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Big O (`n`)
- en: Solution
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Big O (`n+m`)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Big O (`n+m`)
- en: Question 3
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 3
- en: How many spurious hits does the Rabin-Karp string matching algorithm encounter
    in the text `T = "3141512653849792"` when looking for all occurrences of the pattern
    `P = "26"`, working modulo `q = 11` and over the alphabet set `Σ = {0, 1, 2,...,
    9}`?
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当在文本 `T = "3141512653849792"` 中寻找模式 `P = "26"` 的所有出现时，Rabin-Karp 字符串匹配算法遇到多少虚假匹配，工作在模
    `q = 11` 和字母表集 `Σ = {0, 1, 2,..., 9}` 上？
- en: Solution
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: '2.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Question 4
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 4
- en: What is the basic formula applied in the Rabin-Karp algorithm to get the computation
    time as Theta (m)?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin-Karp 算法中用于获得计算时间为 Theta (m) 的基本公式是什么？
- en: Halving rule
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二分法
- en: Horner’s rule
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Horner 规则
- en: Summation lemma
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求和引理
- en: Cancellation lemma
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抵消引理
- en: Solution
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: Horner’s rule.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Horner 规则。
- en: Question 5
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题 5
- en: The Rabin-Karp algorithm can be used for discovering plagiarism in text documents.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin-Karp 算法可用于在文本文档中检测剽窃。
- en: 'True'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Solution
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: True, the Rabin-Karp algorithm is a string matching algorithm, and it can be
    used for detecting plagiarism in text documents.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 真的，Rabin-Karp 算法是一种字符串匹配算法，它可以用于检测文本文档中的剽窃。
- en: Join our community on Discord
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1421249772551223062.png)'
