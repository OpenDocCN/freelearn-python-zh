- en: Deploying Answerly
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Answerly
- en: In the preceding chapter, we learned about Django's testing API and wrote some
    tests for Answerly. As the final step, let's deploy Answerly on an Ubuntu 18.04
    (Bionic Beaver) server using the Apache web server and mod_wsgi.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们了解了Django的测试API，并为Answerly编写了一些测试。作为最后一步，让我们使用Apache Web服务器和mod_wsgi在Ubuntu
    18.04（Bionic Beaver）服务器上部署Answerly。
- en: This chapter assumes that you have the code on your server under `/answerly`
    and are able to push updates to that code. You will make some changes to your
    code in this chapter. Despite making changes, you will need to avoid developing
    the habit of making direct changes in production. For example, you might be using
    a version control system (such as git) to track changes in your code. Then, you
    can make changes on your local workstation, push them to a remote repository (for
    example, hosted on GitHub or GitLab), and pull them on your server. This code
    is available in version control on GitHub ([https://github.com/tomarayn/Answerly](https://github.com/tomarayn/Answerly)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您的服务器上有代码位于`/answerly`下，并且能够推送更新到该代码。您将在本章中对代码进行一些更改。尽管进行了更改，但您需要避免养成直接在生产环境中进行更改的习惯。例如，您可能正在使用版本控制系统（如git）来跟踪代码的更改。然后，您可以在本地工作站上进行更改，将其推送到远程存储库（例如，托管在GitHub或GitLab上），并在服务器上拉取它们。这些代码在GitHub的版本控制中可用（[https://github.com/tomarayn/Answerly](https://github.com/tomarayn/Answerly)）。
- en: 'In this chapter, we will do the following things:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Organize our configuration code to separate production and development settings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织我们的配置代码以分离生产和开发设置
- en: Prepare our Ubuntu Linux server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备我们的Ubuntu Linux服务器
- en: Deploy our project using Apache and mod_wsgi
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache和mod_wsgi部署我们的项目
- en: Take a look at how Django lets us deploy our projects as twelve-factor apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看Django如何让我们将项目部署为十二要素应用程序
- en: Let's start by organizing our configuration to separate development and production
    settings.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始组织我们的配置，将开发和生产设置分开。
- en: Organizing configuration for production and development
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织生产和开发的配置
- en: Up until now, we've kept a single `requirements` file and a single `settings.py`.
    This has made development convenient. However, we can't use our development settings
    in production.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直保留了一个`requirements`文件和一个`settings.py`。这使得开发变得方便。但是，我们不能在生产中使用我们的开发设置。
- en: The current best practice is to have a separate file for each environment. Each
    environment's file then imports a common file with shared values. We'll use this
    pattern for our requirements and settings files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的最佳实践是为每个环境单独创建一个文件。然后，每个环境的文件都导入具有共享值的公共文件。我们将使用这种模式来处理我们的要求和设置文件。
- en: Let's start by splitting up our requirements file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先拆分我们的要求文件。
- en: Splitting our requirements file
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分我们的要求文件
- en: 'First, let''s create `requirements.common.txt` at the root of our project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在项目的根目录创建`requirements.common.txt`：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Regardless of our environment, these are our common requirements, which we'll
    need to run Answerly. However, this `requirements` file is never used directly.
    Our development and production requirements files will reference.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的环境如何，这些都是我们运行Answerly所需的共同要求。然而，这个`requirements`文件从未直接使用过。我们的开发和生产要求文件将会引用它。
- en: 'Next, let''s list our development requirements in `requirements.development.txt`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`requirements.development.txt`中列出我们的开发要求：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding file will install everything from `requirements.common.txt` (thanks
    to `-r`) as well as our testing packages (`coverage`, `factory-boy`, and `selenium`).
    We’re putting these files in our development file because we don't expect to run
    these tests in our production environment. If we were running tests in production,
    then we’d probably move them to `requirements.common.txt`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件将安装`requirements.common.txt`中的所有内容（感谢`-r`），以及我们的测试包（`coverage`，`factory-boy`和`selenium`）。我们将这些文件放在我们的开发文件中，因为我们不希望在生产环境中运行这些测试。如果我们在生产环境中运行测试，那么我们可能会将它们移动到`requirements.common.txt`中。
- en: 'For production, our `requirements.production.txt` file is very simple:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，我们的`requirements.production.txt`文件非常简单：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Answerly doesn't need any special packages. However, we will still create one
    for clarity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Answerly不需要任何特殊的软件包。但是，为了清晰起见，我们仍将创建一个。
- en: 'To install packages in production, we now execute the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要在生产环境中安装软件包，我们现在执行以下命令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, let's split up the settings file along similar lines.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按类似的方式拆分设置文件。
- en: Splitting our settings file
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分我们的设置文件
- en: 'Again, we will follow the current Django best practice of splitting our settings
    file into three files: `common_settings.py`, `production_settings.py`, and `dev_settings.py`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将遵循当前Django最佳实践，将我们的设置文件分成三个文件：`common_settings.py`，`production_settings.py`和`dev_settings.py`。
- en: Creating common_settings.py
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建common_settings.py
- en: We'll create `common_settings.py` by renaming our current `settings.py` file
    and then making some changes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过重命名我们当前的`settings.py`文件并进行一些更改来创建`common_settings.py`。
- en: Let's change `DEBUG = False` so that no new settings file can *accidentally*
    be in debug mode. Then, let's change the secret key to be obtained from an environment
    variable by updating `SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`DEBUG = False`更改为不会*意外*处于调试模式的新设置文件。然后，让我们通过更新`SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')`来从环境变量中获取密钥。
- en: 'Let''s also add a new setting, `STATIC_ROOT`. `STATIC_ROOT` is the directory
    where Django will collect all the static files from across our installed apps
    to make it easier to serve them:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还添加一个新的设置，`STATIC_ROOT`。`STATIC_ROOT`是Django将从我们安装的应用程序中收集所有静态文件的目录，以便更容易地提供它们：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the database config, we can remove all the credentials and keep the `ENGINE` value
    (to make it clear that we intend to use Postgres everywhere):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库配置中，我们可以删除所有凭据并保留`ENGINE`的值（以明确表明我们打算在任何地方使用Postgres）：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, let's create a development settings file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个开发设置文件。
- en: Creating dev_settings.py
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建dev_settings.py
- en: Our development settings will be in `django/config/dev_settings.py`. Let's build
    it incrementally.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发设置将在`django/config/dev_settings.py`中。让我们逐步构建它。
- en: 'First, we will import everything from `common_settings`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`common_settings`中导入所有内容：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we''ll override some settings:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将覆盖一些设置：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In development, we always want to run in debug mode. Also, we can feel safe
    hardcoding a secret key, as we know it won''t be used in production:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中，我们总是希望以调试模式运行。此外，我们可以放心地硬编码一个密钥，因为我们知道它不会在生产中使用：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since our development database is local, we can hardcode the values in our settings
    to make the settings simpler. If your database is not local, avoid checking passwords
    into version control and use `os.getenv()` like in production.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的开发数据库是本地的，我们可以在设置中硬编码值，以使设置更简单。如果您的数据库不是本地的，请避免将密码检入版本控制，并像在生产中一样使用`os.getenv()`。
- en: We can also add more settings that our development-only apps may require. For
    example, in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml), *Deploying
    with Docker*, we had settings for caches and the Django Debug Toolbar app. Answerly
    doesn't use those right now, so we won't include those settings.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加我们的开发专用应用程序可能需要的更多设置。例如，在[第5章](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml)中，*使用Docker部署*，我们有缓存和Django
    Debug Toolbar应用程序的设置。Answerly目前不使用这些，所以我们不会包含这些设置。
- en: Next, let's add production settings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加生产设置。
- en: Creating production_settings.py
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建production_settings.py
- en: Let's create our production settings in `django/config/production_settings.py`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/config/production_settings.py`中创建我们的生产设置。
- en: '`production_settings.py` is similar to `dev_settings.py` but often uses `os.getenv()`
    to get values from environment variables. This helps us to keep secrets (for example,
    passwords, API tokens, and so on) out of version control and decouples settings
    from particular servers. We''ll touch on this again in the *Factor 3 – config*
    section:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`production_settings.py`类似于`dev_settings.py`，但通常使用`os.getenv()`从环境变量中获取值。这有助于我们将机密（例如密码、API令牌等）排除在版本控制之外，并将设置与特定服务器分离。我们将在*Factor
    3 – config*部分再次提到这一点。'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we import the common settings. Out of an abundance of caution, we ensure
    that the debug mode is off.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入通用设置。出于谨慎起见，我们确保调试模式关闭。
- en: Having a `SECRET_KEY` set is vital to our system staying secure. We `assert`
    to prevent Django from starting up without `SECRET_KEY`. The `common_settings.py` file should
    have already set it from an environment variable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`SECRET_KEY`对于我们的系统保持安全至关重要。我们使用`assert`来防止Django在没有`SECRET_KEY`的情况下启动。`common_settings.py`文件应该已经从环境变量中设置了它。
- en: A production website will be accessed on a domain other than `localhost`. We
    will tell Django what other domains we're serving by appending the `DJANGO_ALLOWED_HOSTS` environment
    variable to the `ALLOWED_HOSTS` list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 生产网站将在`localhost`之外的域上访问。我们将通过将`DJANGO_ALLOWED_HOSTS`环境变量附加到`ALLOWED_HOSTS`列表来告诉Django我们正在提供哪些其他域。
- en: 'Next, let''s update the database configuration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新数据库配置：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We updated the database configuration using values from environment variables.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用环境变量的值更新了数据库配置。
- en: Now that we have our settings sorted, let's prepare our server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的设置已经整理好了，让我们准备我们的服务器。
- en: Preparing our server
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备我们的服务器
- en: Now that our code is ready to go into production, let's prepare our server.
    In this chapter, we will use Ubuntu 18.04 (Bionic Beaver). If you're running another
    distribution, then some package names may be different, but the steps we'll take
    will be the same.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码已经准备好投入生产，让我们准备我们的服务器。在本章中，我们将使用Ubuntu 18.04（Bionic Beaver）。如果您使用其他发行版，则某些软件包名称可能不同，但我们将采取的步骤将是相同的。
- en: 'To prepare our server, we will perform the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备我们的服务器，我们将执行以下步骤：
- en: Installing the required operating system packages
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所需的操作系统软件包
- en: Setting up Elasticsearch
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Elasticsearch
- en: Creating the database
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库
- en: Let's start by installing the packages we need.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装我们需要的软件包开始。
- en: Installing required packages
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装所需的软件包
- en: To run Answerly on our server, we will need to ensure that the correct software
    is running.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的服务器上运行Answerly，我们需要确保正确的软件正在运行。
- en: 'Let''s create a list of packages we will need in `ubuntu/packages.txt`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个我们将在`ubuntu/packages.txt`中需要的软件包列表：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code will install packages for the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将为以下内容安装软件包：
- en: Full Python 3 support
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全支持Python 3
- en: The Apache HTTP Server
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache HTTP服务器
- en: mod_wsgi, the Apache HTTP module for running Python web apps
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mod_wsgi，用于运行Python Web应用程序的Apache HTTP模块
- en: The PostgreSQL database server and client
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL数据库服务器和客户端
- en: Java 8, required for Elasticsearch
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8，Elasticsearch所需
- en: 'To install the packages, run the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装软件包，请运行以下命令：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we''ll install our Python packages to a virtual environment:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把我们的Python软件包安装到虚拟环境中：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Great! Now that we have all the packages, we will need to set up Elasticsearch.
    Unfortunately, Ubuntu doesn't ship with a recent version of Elasticsearch, so
    we'll install it directly from Elastic instead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有了所有的软件包，我们需要设置Elasticsearch。不幸的是，Ubuntu没有提供最新版本的Elasticsearch，所以我们将直接从Elastic安装它。
- en: Configuring Elasticsearch
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Elasticsearch
- en: We will get Elasticsearch directly from Elastic. Elastic makes this simple by
    running a server with Ubuntu-compatible `.deb` packages that we can add to our
    server (Elastic also ships and supports RPMs, if that’s more convenient for you).
    Finally, we have to remember to rebind Elasticsearch to localhost or we will have
    an unsecured server running on an open public port.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接从Elastic获取Elasticsearch。Elastic通过在具有Ubuntu兼容的`.deb`软件包的服务器上运行来简化此过程（如果对您更方便，Elastic还提供并支持RPM）。最后，我们必须记住将Elasticsearch重新绑定到localhost，否则我们将在开放的公共端口上运行一个不安全的服务器。
- en: Installing Elasticsearch
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Elasticsearch
- en: 'Let''s add Elasticsearch to our list of trusted repositories by running the
    following three commands:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下三个命令将Elasticsearch添加到我们信任的存储库中：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding commands perform the following four steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令执行以下四个步骤：
- en: Add the Elastic GPG key to the list of trusted GPG keys
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Elastic GPG密钥添加到受信任的GPG密钥列表中
- en: Ensure that `apt` gets packages over `HTTPS` by installing the `apt-transport-https`
    package
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过安装`apt-transport-https`软件包，确保`apt`通过`HTTPS`获取软件包
- en: Add a new sources file that lists the Elastic package server so that `apt` knows
    how to get the Elasticsearch package from Elastic
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的源文件，列出Elastic软件包服务器，以便`apt`知道如何从Elastic获取Elasticsearch软件包
- en: Update the list of available packages (which will now include Elasticsearch)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新可用软件包列表（现在将包括Elasticsearch）
- en: 'Now that we have the Elasticsearch available, let''s install it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Elasticsearch，让我们安装它：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, let's configure Elasticsearch.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置Elasticsearch。
- en: Running Elasticsearch
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Elasticsearch
- en: By default, Elasticsearch is configured to bind to a public IP address and includes
    no authentication.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Elasticsearch配置为绑定到公共IP地址，并且不包括身份验证。
- en: 'To change the address Elasticsearch is running on, let''s edit `/etc/elasticsearch/elasticsearch.yml`.
    Find the line with `network.host` and update it, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改Elasticsearch运行的地址，让我们编辑`/etc/elasticsearch/elasticsearch.yml`。找到带有`network.host`的行并更新如下：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you don't change the `network.host` setting, then you'll be running Elasticsearch
    with no authentication and on a public IP. Your server getting hacked becomes
    inevitable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不更改`network.host`设置，那么您将在公共IP上运行没有身份验证的Elasticsearch。您的服务器被黑客攻击将是不可避免的。
- en: 'Finally, we want to make sure that Ubuntu starts Elasticsearch and keeps it
    running. To accomplish that, we need to tell systemd to start Elasticsearch:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们要确保Ubuntu启动Elasticsearch并保持其运行。为了实现这一点，我们需要告诉systemd启动Elasticsearch：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding commands perform the following three steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令执行以下三个步骤：
- en: Fully reload systemd, which will then become aware of the newly installed Elasticsearch
    service
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全重新加载systemd，然后它将意识到新安装的Elasticsearch服务
- en: Enable the Elasticsearch service so that it starts when the server boots (in
    case of reboots or shutdown)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Elasticsearch服务，以便在服务器启动时启动（以防重新启动或关闭）
- en: Start Elasticsearch
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Elasticsearch
- en: 'If you need to stop the Elasticsearch service, you can use `systemctl`: `sudo
    systemctl stop elasticsearch.service`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要停止Elasticsearch服务，可以使用`systemctl`：`sudo systemctl stop elasticsearch.service`。
- en: Now that we have Elasticsearch running, let’s configure the database.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了Elasticsearch，让我们配置数据库。
- en: Creating the database
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库
- en: Django has support for migrations but cannot create the database or database
    user by itself. We’ll write a script to do this for us now.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Django支持迁移，但不能自行创建数据库或数据库用户。我们现在将编写一个脚本来为我们执行这些操作。
- en: 'Let''s add the database creation script to our project in `postgres/make_database.sh`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将数据库创建脚本添加到我们的项目中的`postgres/make_database.sh`：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To create the database, let''s run the following commands:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据库，请运行以下命令：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding commands do the following three things:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令执行以下三件事：
- en: Switch us to be the `postgres` user, who is trusted to connect to the Postgres
    database without any additional credentials.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`postgres`用户，该用户被信任可以连接到Postgres数据库而无需任何额外的凭据。
- en: Set environment variables, describing our new database user and schema. **Remember
    to change the `password` value to a strong password.**
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置环境变量，描述我们的新数据库用户和模式。**记得将`password`的值更改为一个强密码。**
- en: Execute the `make_database.sh` script.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`make_database.sh`脚本。
- en: Now that we have our server configured, let's deploy Answerly using Apache and
    mod_wsgi.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了服务器，让我们使用Apache和mod_wsgi部署Answerly。
- en: Deploying Answerly with Apache
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apache部署Answerly
- en: We will deploy Answerly using Apache and mod_wsgi. mod_wsgi is an open source
    Apache module that lets Apache host Python programs that implement the **Web Server
    Gateway Interface** (**WSGI**) specification.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Apache和mod_wsgi部署Answerly。mod_wsgi是一个开源的Apache模块，允许Apache托管实现**Web服务器网关接口**（**WSGI**）规范的Python程序。
- en: The Apache web server is one of the many great options for deploying Django
    projects. Many organizations have an operations team who deploy Apache servers,
    so using Apache can remove some organizational hurdles in using Django for a project.
    Apache (with mod_wsgi) also knows how to run multiple web apps and route requests
    between them, unlike our previous configuration in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*, where we needed a reverse proxy (NGINX) and web server
    (uWSGI). The downside of using Apache is that it uses more memory than uWSGI.
    Also, Apache doesn't have a way of passing environment variables to our WSGI process.
    On the whole, deploying with Apache can be a really useful and important tool
    in a Django developer's belt.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Apache web服务器是部署Django项目的众多优秀选项之一。许多组织都有一个运维团队，他们部署Apache服务器，因此使用Apache可以消除在项目中使用Django时的一些组织障碍。Apache（带有mod_wsgi）还知道如何运行多个web应用程序并在它们之间路由请求，与我们在[第5章](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml)中的先前配置不同，*使用Docker部署*，我们需要一个反向代理（NGINX）和web服务器（uWSGI）。使用Apache的缺点是它比uWSGI使用更多的内存。此外，Apache没有一种将环境变量传递给我们的WSGI进程的方法。总的来说，使用Apache进行部署可以成为Django开发人员工具中非常有用和重要的一部分。
- en: 'To deploy, we will do the following things:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署，我们将执行以下操作：
- en: Create a virtual host config
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建虚拟主机配置
- en: Update `wsgi.py`
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`wsgi.py`
- en: Create an environment config file
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个环境配置文件
- en: Collect the static files
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集静态文件
- en: Migrate the database
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移数据库
- en: Enable the virtual host
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用虚拟主机
- en: Let's start creating a virtual host config for our Apache web server.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的Apache web服务器开始创建一个虚拟主机配置。
- en: Creating the virtual host config
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建虚拟主机配置
- en: A single Apache web server can host many websites using different technologies
    from different locations. To keep each website separate, Apache provides the capacity
    to define a virtual host. Each virtual host is a logically separate site that
    serves one or more domains and ports.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Apache web服务器可以使用来自不同位置的不同技术托管许多网站。为了保持每个网站的独立性，Apache提供了定义虚拟主机的功能。每个虚拟主机是一个逻辑上独立的站点，可以为一个或多个域和端口提供服务。
- en: Since Apache has already been a great web server, we will use it to serve our
    static files. The web server serving the static files and our mod_wsgi process
    won't be competing, because they will run as separate processes, thanks to mod_wsgi's
    daemon mode. mod_wsgi daemon mode means that Answerly will run in separate processes
    from the rest of Apache. Apache will still be responsible for starting/stopping
    these processes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Apache已经是一个很好的Web服务器，我们将使用它来提供静态文件。提供静态文件的Web服务器和我们的mod_wsgi进程不会竞争，因为它们将作为独立的进程运行，这要归功于mod_wsgi的守护进程模式。mod_wsgi守护进程模式意味着Answerly将在与Apache的其余部分分开的进程中运行。Apache仍然负责启动/停止这些进程。
- en: 'Let''s add the Apache virtual host config to our project under `apache/answerly.apache.conf`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目的`apache/answerly.apache.conf`下添加Apache虚拟主机配置：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s look at the some of these instructions more closely:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下其中的一些指令：
- en: '`<VirtualHost *:80>`: This instructs Apache that everything until the closing
    `</VirtualHost>` tag is part of the virtual host definition.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<VirtualHost *:80>`：这告诉Apache，直到关闭的`</VirtualHost>`标签之前的所有内容都是虚拟主机定义的一部分。'
- en: '`WSGIDaemonProcess`: This configures mod_wsgi to run in daemon mode. The daemon
    process will be named `answerly`. The `python-home` option defines the virtual
    environment for the Python process that the daemon will use. The  `python-path` option lets
    us add our modules to the daemon''s python so that they can be imported. The `processes`
    and `threads` options tell Apache how many of each to maintain.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WSGIDaemonProcess`：这配置mod_wsgi以守护进程模式运行。守护进程将被命名为`answerly`。`python-home`选项定义了守护进程将使用的Python进程的虚拟环境。`python-path`选项允许我们将我们的模块添加到守护进程的Python中，以便它们可以被导入。`processes`和`threads`选项告诉Apache要维护多少个进程和线程。'
- en: '`WSGIProcessGroup`: This associates this virtual host with the Answerly mod_wsgi
    daemon. Remember that you keep the `WSGIDaemonProcess` name and the `WSGIProcessGroup`
    name the same.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WSGIProcessGroup`：这将虚拟主机与Answerly mod_wsgi守护进程关联起来。记住要保持`WSGIDaemonProcess`名称和`WSGIProcessGroup`名称相同。'
- en: '`WSGIScriptAlias`: This describes which requests should be routed to which
    WSGI script. In our case, all requests should go to Answerly''s WSGI script.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WSGIScriptAlias`：这描述了应该将哪些请求路由到哪个WSGI脚本。在我们的情况下，所有请求都应该转到Answerly的WSGI脚本。'
- en: '`<Directory /answerly/django/config>`: This block gives all users permission
    to access our WSGI script.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Directory /answerly/django/config>`：这个块允许所有用户访问我们的WSGI脚本。'
- en: '`Alias /static/ /answerly/django/static_root`: This routes any request that
    begins with `/static/` not to mod_wsgi but to our static file root.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Alias /static/ /answerly/django/static_root`：这将任何以`/static/`开头的请求路由到我们的静态文件根目录，而不是mod_wsgi。'
- en: '`<Directory /answerly/django/static_root>`: This block gives users permission
    to access files in `static_root`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Directory /answerly/django/static_root>`：这个块允许用户访问`static_root`中的文件。'
- en: '`ErrorLog` and `CustomLog`: They describe where Apache should send its logs
    for this virtual host. In our case, we want to log it in the Apache `log` directory
    (commonly, `/var/log/apache`).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorLog`和`CustomLog`：它们描述了Apache应该将其日志发送到这个虚拟主机的位置。在我们的情况下，我们希望将其记录在Apache的`log`目录中（通常是`/var/log/apache`）。'
- en: We have now configured Apache to run Answerly. However, if you compare your
    Apache configuration and your uWSGI configuration from [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*, you'll notice a difference. In the uWSGI configuration,
    we provided the environment variables that our `production_settings.py` relies
    on. However, mod_wsgi doesn't offer us such a facility. Instead, we will update
    `django/config/wsgi.py` to provide the environment variables that `production_settings.py`
    needs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经配置Apache来运行Answerly。然而，如果你比较一下你的Apache配置和[第5章](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml)中的uWSGI配置，*使用Docker部署*，你会注意到一个区别。在uWSGI配置中，我们提供了我们的`production_settings.py`依赖的环境变量。然而，mod_wsgi并没有为我们提供这样的功能。相反，我们将更新`django/config/wsgi.py`，以提供`production_settings.py`需要的环境变量。
- en: Updating wsgi.py to set environment variables
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新wsgi.py以设置环境变量
- en: Now, we will update `django/config/wsgi.py` to provide the environment variables
    that `production_settings.py` wants but mod_wsgi can't provide. We will also update
    `wsgi.py` to read a configuration file on startup and then set the environment
    variables itself. This way, our production settings aren't coupled to mod_wsgi
    or a config file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新`django/config/wsgi.py`，以提供`production_settings.py`想要的环境变量，但mod_wsgi无法提供。我们还将更新`wsgi.py`，在启动时读取配置文件，然后自己设置环境变量。这样，我们的生产设置不会与mod_wsgi或配置文件耦合。
- en: 'Let''s update `django/config/wsgi.py`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`django/config/wsgi.py`：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the updated `wsgi.py`, we check whether there is a `DJANGO_SETTINGS_MODULE`
    environment variable. If it is absent, we parse our config file and set environment
    variables. Our `for` loop transforms the names of the variables to ensure that
    they are uppercase since `ConfigParser` makes them `lowercase` by default.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新的`wsgi.py`中，我们检查是否有`DJANGO_SETTINGS_MODULE`环境变量。如果没有，我们解析我们的配置文件并设置环境变量。我们的`for`循环将变量的名称转换为大写，因为`ConfigParser`默认会将它们转换为`小写`。
- en: Next, let's create our environment config file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的环境配置文件。
- en: Creating the environment config file
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建环境配置文件
- en: We’ll store our environment config under `/etc/answerly/answerly.ini`. We don't
    want it stored under `/answerly` because it's not part of our code. This file
    describes the settings for *just* this server. We should never check this file
    into version control.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把环境配置存储在`/etc/answerly/answerly.ini`下。我们不希望它存储在`/answerly`下，因为它不是我们代码的一部分。这个文件描述了*只有*这台服务器的设置。我们永远不应该将这个文件提交到版本控制中。
- en: 'Let''s create `/etc/answerly/answerly.ini` on our server:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在服务器上创建`/etc/answerly/answerly.ini`：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following are the two things to remember about this file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个文件的两件事需要记住的：
- en: Remember to set `DJANGO_DB_PASSWORD` to the same value you set in when you ran
    the `make_database.sh` script. *Remember to make sure that this password is strong
    and secret*.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记得将`DJANGO_DB_PASSWORD`设置为你在运行`make_database.sh`脚本时设置的相同值。*记得确保这个密码是强大和保密的*。
- en: Remember to set a strong `DJANGO_SECRET_KEY` value.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记得设置一个强大的`DJANGO_SECRET_KEY`值。
- en: We should now have our environment set up for Apache. Next, let's migrate the
    database.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该已经为Apache设置好了环境。接下来，让我们迁移数据库。
- en: Migrating the database
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移数据库
- en: We created the database for Answerly in a previous step, but we didn't create
    the tables. Let's now migrate the database using Django's built-in migration tools.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的步骤中为Answerly创建了数据库，但我们没有创建表。现在让我们使用Django内置的迁移工具迁移数据库。
- en: 'On the server, we want to execute the following commands:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，我们希望执行以下命令：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `django/config/production_settings.py` will require us to provide `DJANGO_SECRET_KEY`
    with a value, but it won't be used in this case. However, providing the correct
    value for `DJANGO_DB_PASSWORD` and the other `DJANGO_DB` variables is critical.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`django/config/production_settings.py`将要求我们提供带有值的`DJANGO_SECRET_KEY`，但在这种情况下不会使用它。但是，为`DJANGO_DB_PASSWORD`和其他`DJANGO_DB`变量提供正确的值至关重要。
- en: Once our `migrate` command returns successful, then our database will have all
    the tables we need.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`migrate`命令返回成功，那么我们的数据库将拥有我们需要的所有表。
- en: Next, let's make our static (JavaScript/CSS/image) files available to our users.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们让我们的静态（JavaScript/CSS/图像）文件对我们的用户可用。
- en: Collecting static files
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集静态文件
- en: In our virtual host config, we configured Apache to serve our static (JS, CSS,
    image, and so on) files. For Apache to serve these files, we need to collect them
    all under one parent directory. Let's use Django's built-in `manage.py collectstatic`
    command to do just that.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的虚拟主机配置中，我们配置了Apache来提供我们的静态（JS，CSS，图像等）文件。为了让Apache提供这些文件，我们需要将它们全部收集到一个父目录下。让我们使用Django内置的`manage.py
    collectstatic`命令来做到这一点。
- en: 'On the server, let''s run the following commands:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，让我们运行以下命令：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding commands will copy static files from all our installed apps into
    `/answerly/django/static_root` (per our `STATIC_ROOT` definition in `production_settings.py`).
    Our virtual host config tells Apache to serve these files directly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将从所有已安装的应用程序复制静态文件到`/answerly/django/static_root`（根据`production_settings.py`中的`STATIC_ROOT`定义）。我们的虚拟主机配置告诉Apache直接提供这些文件。
- en: Now, let's tell Apache to start serving Answerly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们告诉Apache开始提供Answerly。
- en: Enabling the Answerly virtual host
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用Answerly虚拟主机
- en: To have Apache serve Answerly to users, we will need to enable the virtual host
    config we created the preceding section, creating the virtual host config. To
    enable a virtual host in Apache, we will add a soft link point at the virtual
    host config to Apache's `site-enabled` directory and tell Apache to reload its
    configuration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Apache向用户提供Answerly，我们需要启用我们在上一节创建的虚拟主机配置，创建虚拟主机配置。要在Apache中启用虚拟主机，我们将在虚拟主机配置上添加一个软链接指向Apache的`site-enabled`目录，并告诉Apache重新加载其配置。
- en: 'First, let''s add our soft link to the Apache `site-enabled` directory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将我们的软链接添加到Apache的`site-enabled`目录：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We prefix our softlink with `001` to control what our config gets loaded. Apache
    loads site configs by filename in character ordinal order (for example, `B` comes
    before `a` in Unicode/ASCII encoding). The prefix is used to make the order more
    obvious.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`001`作为软链接的前缀来控制我们的配置加载顺序。Apache按字符顺序加载站点配置文件（例如，在Unicode/ASCII编码中，`B`在`a`之前）。前缀用于使顺序更加明显。
- en: Apache is frequently packaged with a default site. Check out `/etc/apache/sites-enabled/`
    for sites you don't want to run. Since everything in there should be a soft link,
    they should be safe to delete.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Apache经常与默认站点捆绑在一起。查看`/etc/apache/sites-enabled/`以查找不想运行的站点。由于其中的所有内容都应该是软链接，因此可以安全地删除它们。
- en: 'To activate the virtual host, we will need to reload Apache''s configuration:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活虚拟主机，我们需要重新加载Apache的配置：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Congratulations! You've deployed Answerly on your server.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经在服务器上部署了Answerly。
- en: A quick review of the section
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾本节
- en: In this chapter so far, we've looked at how to deploy Django with Apache and
    mod_wsgi. First, we configured our server by installing packages from Ubuntu and
    Elastic (for Elasticsearch). Then, we configured Apache to run Answerly as a virtual
    host. Our Django code will be executed by mod_wsgi.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经了解了如何使用Apache和mod_wsgi部署Django。首先，我们通过从Ubuntu和Elastic（用于Elasticsearch）安装软件包来配置了我们的服务器。然后，我们配置了Apache以将Answerly作为虚拟主机运行。我们的Django代码将由mod_wsgi执行。
- en: At this point, we've seen two very different deployment, one using Docker and
    one using Apache and mod_wsgi. Despite being very different environments, we've
    followed many similar practices. Let's look at how Django best practices come
    out of the popular twelve-factor app methodology.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两种非常不同的部署方式，一种使用Docker，一种使用Apache和mod_wsgi。尽管是非常不同的环境，但我们遵循了许多相似的做法。让我们看看Django最佳实践是如何符合流行的十二要素应用方法论的。
- en: Deploying Django projects as twelve-factor apps
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Django项目部署为十二要素应用
- en: The *twelve-factor app* document explains a methodology to develop web apps
    and services. These principles were documented in 2011 by Adam Wiggins and others
    primarily on their experience at Heroku (a popular Platform as a Service, PaaS,
    provider). Heroku was one of the first PaaS that helped developers build easy-to-scale
    web applications and services. Since being posted, the principles of twelve-factor
    apps have shaped a lot of the thinking about how to build and deploy SaaS apps—like
    web apps.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*十二要素应用*文档解释了一种开发Web应用和服务的方法论。这些原则是由Adam Wiggins和其他人在2011年主要基于他们在Heroku（一家知名的平台即服务提供商）的经验而记录的。Heroku是最早帮助开发人员构建易于扩展的Web应用和服务的PaaS之一。自发布以来，十二要素应用的原则已经塑造了很多关于如何构建和部署SaaS应用（如Web应用）的思考。'
- en: 'The twelve-factors provide many benefits, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素提供了许多好处，如下：
- en: Easing automation and onboarding using declarative formats
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声明性格式来简化自动化和入职
- en: Emphasizing portability across deployed environments
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调在部署环境中的可移植性
- en: Encouraging production/development environment parity and continuous deployment
    and integration
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼓励生产/开发环境的一致性和持续部署和集成
- en: Simplifying scaling without requiring re-architecting
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化扩展而无需重新架构
- en: However, when evaluating the twelve factors, it's important to remember that
    they are strongly coupled to Heroku's approach to deployment. Not all platforms
    (or PaaS providers) have exactly the same approach. This doesn't make the twelve
    factors right and other approaches wrong, nor vice versa. Rather the twelve factors
    are useful principles to keep in mind. You should adapt them to help your projects,
    just as you would with any methodology.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在评估十二因素时，重要的是要记住它们与Heroku的部署方法紧密相关。并非所有平台（或PaaS提供商）都有完全相同的方法。这并不是说十二因素是正确的，其他方法是错误的，反之亦然。相反，十二因素是要牢记的有用原则。您应该根据需要调整它们以帮助您的项目，就像您对待任何方法论一样。
- en: 'The twelve factor use of the word *app* is different to Django''s usability:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 单词*应用程序*的十二因素用法与Django的可用性不同：
- en: A Django project is the equivalent of a twelve factor app
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django项目相当于十二因素应用程序
- en: A Django app is the equivalent of a twelve factor library
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django应用程序相当于十二因素库
- en: In this section, we will examine what each of the twelve-factors means and how
    they can be applied to your Django projects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究十二个因素的每个含义以及它们如何应用到您的Django项目中。
- en: Factor 1 – Code base
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因素1 - 代码库
- en: '"One codebase tracked in revision control, many deploys" – [12factor.net](http://12factor.net)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: “一个代码库在修订控制中跟踪，多个部署” - [12factor.net](http://12factor.net)
- en: 'This factor emphasizes the following two things:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个因素强调了以下两点：
- en: All code should be tracked in a version-controlled code repository (repo)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代码都应该在版本控制的代码存储库（repo）中进行跟踪
- en: Each deployment should be able to reference a single version/commit in that
    repo
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次部署都应该能够引用该存储库中的单个版本/提交
- en: This means that when we experience a bug, we know exactly the version of the
    code that is responsible for that. If our project spans multiple repos, the twelve-factor
    approach requires that shared code be refactored into libraries and tracked as
    dependencies (refer to the *Factor 2 – Dependencies* section). If multiple projects
    use the same repository, then they should be refactored into separate repositories
    (sometimes called *multi repo*). Over the years since twelve-factor was first
    published, multirepo versus monorepo (where a single repo is used for multiple
    projects) has become increasingly debated. Some large projects have found benefits
    to using a mono repo. Other projects have found success with multiple repos.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们遇到错误时，我们确切地知道是哪个代码版本负责。如果我们的项目跨越多个存储库，十二因素方法要求共享代码被重构为库并作为依赖项进行跟踪（参见*因素2
    - 依赖关系*部分）。如果多个项目使用同一个存储库，那么它们应该被重构为单独的存储库（有时称为*多存储库*）。自十二因素首次发布以来，多存储库与单存储库（一个存储库用于多个项目）的使用已经越来越受到争议。一些大型项目发现使用单存储库有益处。其他项目通过多个存储库取得了成功。
- en: Fundamentally, this factor strives to ensure that we know what is running in
    which environment.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个因素努力确保我们知道在哪个环境中运行什么。
- en: We can write our Django apps in a reusable way so that they can be hosted as
    libraries that are installed with `pip` (multirepo style). Alternatively, you
    can host all your Django projects and apps in the same repo (monorepo) by modifying
    the Python path of your Django project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以可重用的方式编写我们的Django应用程序，以便它们可以作为使用`pip`安装的库进行托管（多存储库样式）。或者，您可以通过修改Django项目的Python路径，将所有Django项目和应用程序托管在同一个存储库（单存储库）中。
- en: Factor 2 – Dependencies
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因素2 - 依赖关系
- en: '"Explicitly declare and isolate dependencies" – [12 factor.net](https://12factor.net)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: “明确声明和隔离依赖关系” - [12 factor.net](https://12factor.net)
- en: A twelve-factor app shouldn't assume anything about its environment. The libraries
    and tools a project uses must be declared by the project and installed as part
    of the deployment (refer to *Factor 5 – Build, release, and run* section). All
    running twelve-factor apps should be isolated from each other.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 十二因素应用程序不应假设其环境的任何内容。项目使用的库和工具必须由项目声明并作为部署的一部分安装（参见*因素5 - 构建、发布和运行*部分）。所有运行的十二因素应用程序都应该相互隔离。
- en: Django projects benefit from Python's rich toolset. “In Python there are two
    separate tools for these steps – Pip is used for declaration and Virtualenv for
    isolation” ([https://12factor.net/dependencies](https://12factor.net/dependencies)). In
    Answerly, we also used a list of Ubuntu packages that we installed with `apt`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目受益于Python丰富的工具集。 “在Python中，这些步骤有两个单独的工具 - Pip用于声明，Virtualenv用于隔离”（[https://12factor.net/dependencies](https://12factor.net/dependencies)）。在Answerly中，我们还使用了一系列我们用`apt`安装的Ubuntu软件包。
- en: Factor 3 – Config
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因素3 - 配置
- en: '"Store config in the environment" – [12factor.net](http://12factor.net)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置存储在环境中 - [12factor.net](http://12factor.net)
- en: 'The twelve-factor app methodology provides a useful definition of a config:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 十二因素应用程序方法提供了一个有用的配置定义：
- en: '"An app''s config is everything that is likely to vary between deploys (staging,
    production, developer environments, etc)" – [https://12factor.net/config](https://12factor.net/config)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: “应用程序的配置是在部署之间可能变化的所有内容（暂存、生产、开发环境等）” - [https://12factor.net/config](https://12factor.net/config)
- en: The twelve-factor app methodology also encourages the use of environment variables
    for communicating config values to our code. This means that if there's a problem,
    we can test exactly the code that was deployed (provided by Factor 1) with the
    exact config used. We can also check whether an error is a config issue or a code
    issue by deploying the same code with a different config.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 十二因素应用程序方法还鼓励使用环境变量来传递配置值给我们的代码。这意味着如果出现问题，我们可以测试确切部署的代码（由因素1提供）以及使用的确切配置。我们还可以通过使用不同的配置部署相同的代码来检查错误是配置问题还是代码问题。
- en: In Django, our config is referenced by our `settings.py` files. In both MyMDB
    and Answerly, we’ve seen common config values such as `SECRET_KEY`, database credentials,
    and API keys (for example, AWS keys) passed by environment variables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，我们的配置由我们的`settings.py`文件引用。在MyMDB和Answerly中，我们看到了一些常见的配置值，如`SECRET_KEY`、数据库凭据和API密钥（例如AWS密钥），通过环境变量传递。
- en: However, this is an area where Django best practices differ from the strictest
    reading of a twelve-factor app. Django projects generally create a separate settings
    file for staging, production, and local development with most settings hardcoded.
    It's primarily credentials and secrets which are passed as environment variables.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个领域，Django最佳实践与十二要素应用的最严格解读有所不同。Django项目通常为分别用于分阶段、生产和本地开发的设置文件创建一个单独的设置文件，大多数设置都是硬编码的。主要是凭据和秘密作为环境变量传递。
- en: Factor 4 – Backing services
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Factor 4 – 后备服务
- en: '"Treat backing services as attached resources" – [12factor.net](https://12factor.net)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '"将后备服务视为附加资源" – [12factor.net](https://12factor.net)'
- en: A twelve-factor app should not care where a backing service (for example, database)
    is located and should always access it via a URL. The benefit of this is that
    our code is not coupled to a particular environment. This approach also permits
    each piece of our architecture to scale independently.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用不应关心后备服务（例如数据库）的位置，并且应始终通过URL访问它。这样做的好处是我们的代码不与特定环境耦合。这种方法还允许我们架构的每个部分独立扩展。
- en: Answerly, as deployed in this chapter, is located on the same server as its
    database. However, we don't use a local authentication mechanism but instead provide
    Django with a host, port, and credentials. This way, we could move our database
    to another server and no code would have to be changed. We would simply update
    our config.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中部署的Answerly与其数据库位于同一服务器上。然而，我们没有使用本地身份验证机制，而是向Django提供了主机、端口和凭据。这样，我们可以将数据库移动到另一台服务器上，而不需要更改任何代码。我们只需要更新我们的配置。
- en: Django is written with the assumption that we will treat most services as attached
    resources (for example, most database documentation assumes this). We still need
    to practice this principle when working with third-party libraries.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Django的编写假设我们会将大多数服务视为附加资源（例如，大多数数据库文档都是基于这一假设）。在使用第三方库时，我们仍然需要遵循这一原则。
- en: Factor 5 – Build, release, and run
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Factor 5 – 构建、发布和运行
- en: '"Strictly separate build and run stages" – [12factor.net](https://12factor.net)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '"严格分离构建和运行阶段" – [12factor.net](https://12factor.net)'
- en: 'The twelve-factor approach encourages a deployment to be divided into three
    distinct steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素方法鼓励将部署分为三个明确的步骤：
- en: '**Build**: Where the code and dependencies are gathered into a single bundle
    (a *build*)'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建**：代码和依赖项被收集到一个单一的捆绑包中（一个*构建*）'
- en: '**Release**: Where the build is combined with a config and ready for execution'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发布**：构建与配置组合在一起，准备执行'
- en: '**Run**: Where the combined build and config are executed'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行**：组合构建和配置的执行位置'
- en: A twelve-factor app further requires each release to have a unique ID so that
    it can be identified.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用还要求每个发布都有一个唯一的ID，以便可以识别它。
- en: This level of deployment detail is beyond Django's scope, and there's a variety
    of levels of adherence to this strict three-step model. A project that uses Django
    and Docker, as seen in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*, may adhere to it very closely. MyMDB had a clear build
    with all the dependencies bundled in the Docker image. However, in this chapter,
    we never made a bundled build. Instead, we installed dependencies (running `pip
    install`) after our code was already on our server. Many projects succeed with
    this simple model. However, as the project scales, this may cause complications.
    Answerly's deployment shows how twelve-factor principles may be bent and still
    work for some projects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种部署细节已经超出了Django的范围，对这种严格的三步模型的遵循程度有各种各样。在[第5章](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml)中看到的使用Django和Docker的项目可能会非常严格地遵循这一原则。MyMDB有一个清晰的构建，所有依赖项都捆绑在Docker镜像中。然而，在本章中，我们从未进行捆绑构建。相反，我们在代码已经在服务器上之后安装依赖项（运行`pip
    install`）。许多项目都成功地使用了这种简单的模型。然而，随着项目规模的扩大，这可能会引起复杂性。Answerly的部署展示了十二要素原则如何可以被弯曲，但对于某些项目仍然有效。
- en: Factor 6 – Processes
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Factor 6 – 进程
- en: '"Execute the app as one or more stateless processes" – [12factor.net](https://12factor.net)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '"将应用程序作为一个或多个无状态进程执行" – [12factor.net](https://12factor.net)'
- en: The focus of this factor is that app processes should be *stateless*. Each task
    is executed without relying on a previous task having left data behind. Instead,
    state should be stored in backing services (refer to *Factor 4 – Backing services*
    section), such as a database or external cache. This enables an app to scale easily,
    because all processes are equally eligible to process a request.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这一因素的重点是应用进程应该是*无状态*的。每个任务都是在不依赖前一个任务留下数据的情况下执行的。相反，状态应该存储在后备服务中（参见*Factor 4
    – 后备服务*部分），比如数据库或外部缓存。这使得应用能够轻松扩展，因为所有进程都同样有资格处理请求。
- en: Django is built around this assumption. Even sessions, where a user's login
    state is stored, isn't saved in a process but in the database by default. Instances
    of view classes are never reused. The only place where Django comes close to violating
    this is one of the cache backends (local memory cache). However, as we discussed,
    that's an inefficient backend. Generally, Django projects use a backing service
    (for example, memcached) for their caches.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Django是围绕这一假设构建的。即使是会话，用户的登录状态也不是保存在进程中，而是默认保存在数据库中。视图类的实例永远不会被重用。Django接近违反这一点的唯一地方是缓存后端之一（本地内存缓存）。然而，正如我们讨论过的，那是一个低效的后端。通常，Django项目会为它们的缓存使用一个后备服务（例如memcached）。
- en: Factor 7 – Port binding
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Factor 7 – 端口绑定
- en: '"Export services via port binding" – [12factor.net](https://12factor.net)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '"通过端口绑定导出服务" – [12factor.net](https://12factor.net)'
- en: The focus of this factor is that our process should be accessed directly through
    its port. Accessing a project should be a matter of sending a properly formed
    request to `app.example.com:1234`. Further, a twelve-factor app should not be
    run as an Apache module or web server container. If our project needs to parse
    HTTP requests, it should use library (refer to *Factor 2 – Dependencies* section)
    to parse them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个因素的重点是我们的进程应该通过其端口直接访问。访问一个项目应该是向`app.example.com:1234`发送一个正确形成的请求。此外，十二要素应用程序不应该作为Apache模块或Web服务器容器运行。如果我们的项目需要解析HTTP请求，应该使用库（参见*因素2-依赖*部分）来解析它们。
- en: Django follows parts of this principle. Users access a Django project over an
    HTTP port using HTTP. One aspect of Django that diverges from twelve-factors is
    that it's almost always run as a child process of a web server (whether Apache,
    uWSGI, or something else). It’s the web server, not Django, that performs the
    port binding. However, this minor difference has not kept Django projects from
    scaling effectively.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Django遵循这个原则的部分。用户通过HTTP端口使用HTTP访问Django项目。与十二要素有所不同的是，Django的一个方面几乎总是作为Web服务器的子进程运行（无论是Apache、uWSGI还是其他什么）。进行端口绑定的是Web服务器，而不是Django。然而，这种微小的差异并没有阻止Django项目有效地扩展。
- en: Factor 8 – Concurrency
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因素8-并发
- en: '"Scale out via the process model" – [12factor.net](https://12factor.net)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: “通过进程模型扩展”- [12factor.net](https://12factor.net)
- en: The twelve-factor app principles are focused on scaling (a vital concern for
    a PaaS provider like Heroku). In factor 8, we saw how the trade-offs and decisions
    made previously come together to help a project scale.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用程序的原则侧重于扩展（对于像Heroku这样的PaaS提供商来说是一个重要的关注点）。在因素8中，我们看到之前做出的权衡和决策如何帮助项目扩展。
- en: Since a project runs as a stateless process (refer to *Factor 6 – Processes*
    section) available as a port (refer to *Factor 7 – Port binding* section), concurrency
    is just a matter of having more processes (across one or more machines). The processes
    don't need to care whether they're on the same machine or not since any state
    (like a question's answer) is stored in a backing service (refer to *Factor 4
    – Backing services* section) such as a database. Factor 8 tells us to trust the
    Unix process model for running services instead of daemonizing or creating PID
    files.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目作为无状态进程运行（参见*因素6-进程*部分），作为端口（参见*因素7-端口绑定*部分）可用，并发性只是拥有更多进程（跨一个或多个机器）的问题。进程不需要关心它们是否在同一台机器上，因为任何状态（比如问题的答案）都存储在后备服务（参见*因素4-后备服务*部分）中，比如数据库。因素8告诉我们要相信Unix进程模型来运行服务，而不是创建守护进程或创建PID文件。
- en: Since Django projects run as child processes of a web server, they often adapt
    this principle. Django projects that need to scale often use a combination of
    reverse proxy (for example, Nginx) and lightweight web server (for example, uWSGI
    or Gunicorn). Django projects don't directly concern themselves with how processes
    are managed, but follow the best practice for the web server they’re using.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Django项目作为Web服务器的子进程运行，它们经常遵循这个原则。需要扩展的Django项目通常使用反向代理（例如Nginx）和轻量级Web服务器（例如uWSGI或Gunicorn）的组合。Django项目不直接关注进程的管理方式，而是遵循它们正在使用的Web服务器的最佳实践。
- en: Factor 9 – Disposability
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因素9-可处置性
- en: '"Maximize robustness with fast startup and graceful shutdown" – [12factor.net](https://12factor.net)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: “通过快速启动和优雅关闭来最大限度地提高鲁棒性”- [12factor.net](https://12factor.net)
- en: The disposibility factor has two parts. Firstly, a twelve-factor app should
    be able to start processing requests on its port soon after the process starts.
    Remember that all its dependencies (refer to *Factor 2 – Dependencies* section)
    have already been installed (refer to *Factor 5 – Build, release, and run* section).
    A twelve-factor app should handle a process stopping or shutting gracefully. The
    process shouldn't put a twelve-factor app into an invalid state.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可处置性因素有两个部分。首先，十二要素应用程序应该能够在进程启动后不久开始处理请求。记住，所有它的依赖关系（参见*因素2-依赖*部分）已经被安装（参见*因素5-构建、发布和运行*部分）。十二要素应用程序应该处理进程停止或优雅关闭。进程不应该使十二要素应用程序处于无效状态。
- en: Django projects are able to shut down gracefully because Django wraps each request
    in an atomic transaction by default. If a Django process (whether managed by uWSGI,
    Apache, or anything else) is stopped while a request is only partially processed,
    the transaction will never be committed. The database will discard the transaction.
    When we're dealing with other backing services (for example, S3 or Elasticsearch)
    that don't support transactions, we have to make sure that we consider this in
    our design.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目能够优雅地关闭，因为Django默认会将每个请求包装在一个原子事务中。如果一个Django进程（无论是由uWSGI、Apache还是其他任何东西管理的）在处理请求时停止，事务将永远不会被提交。数据库将放弃该事务。当我们处理其他后备服务（例如S3或Elasticsearch）不支持事务时，我们必须确保在设计中考虑到这一点。
- en: Factor 10 – Dev/prod parity
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因素10-开发/生产对等性
- en: '"Keep development, staging, and production as similar as possible" – [12factor.net](https://12factor.net)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: “尽量使开发、分期和生产尽可能相似”- [12factor.net](https://12factor.net)
- en: All environments that a twelve-factor app run in should be as similar as possible.
    This is much easier when a twelve-factor app is a simple process (refer to *Factor
    6 – Processes* section). This also includes the backing services the twelve-factor
    app uses (refer to *Factor 4 – Backing services* section). For example, a twelve-factor
    app's development environment should include the same database as the production
    environment. Tools such as Docker and Vagrant can make this much easier to accomplish
    today.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用程序运行的所有环境应尽可能相似。当十二要素应用程序是一个简单的进程时（参见*因素6-进程*部分），这就容易得多。这还包括十二要素应用程序使用的后备服务（参见*因素4-后备服务*部分）。例如，十二要素应用程序的开发环境应该包括与生产环境相同的数据库。像Docker和Vagrant这样的工具可以使今天实现这一点变得更加容易。
- en: The general Django best practice is to use the same database (and other backing
    services) in development and production. In this book, we've striven to do so.
    However, the Django community often uses the `manage.py runserver` command in
    development, as opposed to running uWSGI or Apache.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Django的一般最佳实践是在开发和生产中使用相同的数据库（和其他后端服务）。在本书中，我们一直在努力做到这一点。然而，Django社区通常在开发中使用`manage.py
    runserver`命令，而不是运行uWSGI或Apache。
- en: Factor 11 – Logs
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11因素 - 日志
- en: '"Treat logs as event streams" – [12factor.net](https://12factor.net)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '"将日志视为事件流" - [12factor.net](https://12factor.net)'
- en: Logs should be just output as an unbuffered `stdout` stream, and a *twelve-factor
    app never concerns itself with routing or storage of its output stream* ([https://12factor.net/logs](https://12factor.net/logs)). When
    the process runs, it should just output unbuffered content to `stdout`. Whoever
    starts the process (whether a developer or a production server's init process)
    can then redirect that stream appropriately.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 日志应该只作为无缓冲的`stdout`流输出，*十二因素应用程序永远不会关心其输出流的路由或存储*（[https://12factor.net/logs](https://12factor.net/logs)）。当进程运行时，它应该只输出无缓冲的内容到`stdout`。然后启动进程的人（无论是开发人员还是生产服务器的init进程）可以适当地重定向该流。
- en: A Django project generally uses Python's logging module. This can support writing
    to a log file or outputting an unbuffered stream. Generally, Django projects append
    to a file. That file may be processed or rotated separately (for example, using
    the `logrotate` utility).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目通常使用Python的日志模块。这可以支持写入日志文件或输出无缓冲流。一般来说，Django项目会追加到一个文件中。该文件可以单独处理或旋转（例如，使用`logrotate`实用程序）。
- en: Factor 12 – Admin processes
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12因素 - 管理流程
- en: '"Run admin/management tasks as one-off processes" – [12factor.net](https://12factor.net)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '"将管理/管理任务作为一次性进程运行" - [12factor.net](https://12factor.net)'
- en: All projects require a one-off task to be run from time to time (for example,
    database migration). When a twelve-factor app's one-off task is run, it should
    be run as a separate process from the processes that handle regular requests.
    However, the one-off process should run with the same environment as all other
    processes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所有项目都需要不时运行一次性任务（例如，数据库迁移）。当十二因素应用程序的一次性任务运行时，它应该作为一个独立的进程运行，而不是处理常规请求的进程。但是，一次性进程应该与所有其他进程具有相同的环境。
- en: In Django that means using the same virtual environment, settings file, and
    environment variables for running our `manage.py` tasks as our normal process.
    This is what we did earlier when we migrated the database.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，这意味着在运行我们的`manage.py`任务时使用相同的虚拟环境、设置文件和环境变量作为我们的正常进程。这就是我们之前迁移数据库时所做的。
- en: A quick review of the section
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速审查本节
- en: After reviewing all the principles of a twelve-factor app, we will take a look
    at how Django projects are able to follow these principles to help make our project
    easy to deploy, scale, and automate.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了十二因素应用程序的所有原则之后，我们将看看Django项目如何遵循这些原则，以帮助我们的项目易于部署、扩展和自动化。
- en: The main difference between a Django project and a strict twelve-factor app
    is that Django apps are run by a web server rather than as separate processes
    (Factor 6). However, as long as we avoid complicated web server configurations
    (as we do in this book), we can continue to gain the benefits of being a twelve-factor
    app.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目和严格的十二因素应用程序之间的主要区别在于，Django应用程序是由Web服务器而不是作为独立进程运行的（因素6）。然而，只要我们避免复杂的Web服务器配置（就像在本书中所做的那样），我们就可以继续获得作为十二因素应用程序的好处。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on deploying Django to a Linux server running Apache
    and mod_wsgi. We've also reviewed the principles of a twelve factor app and how
    a Django app can use them to be easy to deploy, scale, and automate.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于将Django部署到运行Apache和mod_wsgi的Linux服务器上。我们还审查了十二因素应用程序的原则以及Django应用程序如何使用它们来实现易于部署、扩展和自动化。
- en: Congratulations! You've launched Answerly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经推出了Answerly。
- en: In the next chapter, we'll look at creating a mailing list management app called
    MailApe.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何创建一个名为MailApe的邮件列表管理应用程序。
