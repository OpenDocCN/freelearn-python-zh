- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: The SOLID Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: 'In this chapter, we will continue to explore concepts of clean design applied
    to Python. In particular, we will review the **SOLID** principles and how to implement
    them in a Pythonic way. These principles entail a series of good practices to
    achieve better-quality software. In case some of you aren''t aware of what SOLID
    stands for, here it is:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨应用于Python的清洁设计概念。特别是，我们将回顾**SOLID**原则以及如何在Python中以Pythonic的方式实现它们。这些原则包含一系列良好的实践，以实现更高质量的软件。如果有些人不知道SOLID代表什么，这里就是：
- en: '**S**: Single responsibility principle'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 单一职责原则'
- en: '**O**: Open/closed principle'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 开放/封闭原则'
- en: '**L**: Liskov''s substitution principle'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: Liskov替换原则'
- en: '**I**: Interface segregation principle'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 接口隔离原则'
- en: '**D**: Dependency inversion principle'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 依赖倒置原则'
- en: 'The goals of this chapter are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To become acquainted with SOLID principles for software design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解软件设计的SOLID原则
- en: To design software components that follow the single responsibility principle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计遵循单一职责原则的软件组件
- en: To achieve more maintainable code through the open/closed principle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过开放/封闭原则实现更易于维护的代码
- en: To implement proper class hierarchies in object-oriented design, by complying
    with Liskov's substitution principle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过遵守Liskov替换原则在面向对象设计中实现适当的类层次结构
- en: To design with interface segregation and dependency inversion
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过接口隔离和依赖倒置进行设计
- en: The single responsibility principle
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The **single responsibility principle** (**SRP**) states that a software component
    (in general, a class) must have only one responsibility. The fact that the class
    has a sole responsibility means that it is in charge of doing just one concrete
    thing, and as a consequence of that, we can conclude that it must have only one
    reason to change.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）指出，软件组件（通常，一个类）必须只有一个职责。类只有一个职责的事实意味着它只负责做一件具体的事情，因此我们可以得出结论，它必须只有一个改变的理由。'
- en: 'Only if one thing on the domain problem changes will the class have to be updated.
    If we have to make modifications to a class for different reasons, it means the
    abstraction is incorrect, and that the class has too many responsibilities. This
    is probably an indication that there is at least one abstraction missing: more
    objects need to be created to address the extra responsibility that''s overloading
    the current class in question.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当领域问题中的某个事物发生变化时，类才需要更新。如果我们必须因为不同原因对类进行修改，这意味着抽象是不正确的，并且该类有太多的职责。这可能是至少缺少一个抽象的迹象：需要创建更多的对象来处理当前类所承受的额外职责。
- en: As introduced in *Chapter 2*, *Pythonic Code*, this design principle helps us
    build more cohesive abstractions—objects that do one thing, and just one thing,
    well, following the Unix philosophy. What we want to avoid in all cases is having
    objects with multiple responsibilities (often called **God objects**, because
    they know too much, or more than they should). These objects group different (mostly
    unrelated) behaviors, thus making them harder to maintain.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第2章*Pythonic代码*中所述，这个设计原则帮助我们构建更内聚的抽象——只做一件事，并且做得很好，遵循Unix哲学。我们希望避免所有情况下都有多个职责的对象（通常称为**上帝对象**，因为它们知道太多，或者比应该知道的还多）。这些对象组合了不同的（大多数是无关的）行为，这使得它们更难维护。
- en: Again, the smaller the class, the better.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类越小越好。
- en: The SRP is closely related to the idea of cohesion in software design, which
    we already explored in *Chapter 3*, *General Traits of Good Code*, when we discussed
    the separation of concerns in software. What we strive to achieve here is that
    classes are designed in such a way that most of their properties and their attributes
    are used by their methods, most of the time. When this happens, we know they are
    related concepts, and therefore it makes sense to group them under the same abstraction.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SRP与软件设计中的内聚性概念密切相关，我们已经在*第3章*，*良好代码的一般特性*中探讨了软件的关注点分离。我们在这里努力实现的是，类的设计方式使得它们的大部分属性和属性通常由其方法使用。当这种情况发生时，我们知道它们是相关概念，因此将它们归入同一抽象之下是有意义的。
- en: In a way, this idea is somewhat analogous to the concept of normalization in
    relational database design. When we detect that there are partitions on the attributes
    or methods of the interface of an object, they might as well be moved somewhere
    else—it is a sign that they are two or more different abstractions mixed into
    one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，这个想法与关系数据库设计中的规范化概念有些类似。当我们检测到对象的属性或方法接口上有分区时，它们可能最好被移动到其他地方——这是它们被混合成一个的多个不同抽象的迹象。
- en: There is another way of looking at this principle. If, when looking at a class,
    we find methods that are mutually exclusive and do not relate to each other, they
    are the different responsibilities that have to be broken down into smaller classes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一种看待这个原则的方法。如果我们查看一个类时发现方法相互排斥且彼此不相关，那么它们就是需要分解成更小类的不同职责。
- en: A class with too many responsibilities
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 职责过多的类
- en: In this example, we are going to create a case for an application that is in
    charge of reading information about events from a source (this could be log files,
    a database, or many more sources), and identify the actions corresponding to each
    particular log.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将为负责从源（这可能是日志文件、数据库或许多其他源）读取事件信息的应用程序创建一个案例，并确定每个特定日志对应的行为。
- en: 'A design that fails to conform to the SRP would look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未能符合SRP（单一职责原则）的设计可能看起来像这样：
- en: '![Picture 2](img/B16567_04_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2](img/B16567_04_01.png)'
- en: 'Figure 4.1: A class with too many responsibilities'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：职责过多的类
- en: 'Without considering the implementation, the code for the class might look as
    in the following listing:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不考虑实现，类的代码可能看起来如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The problem with this class is that it defines an interface with a set of methods
    that correspond to actions that are orthogonal: each one can be done independently
    of the rest.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的问题在于它定义了一个接口，其中包含一组对应于正交操作的方法：每个操作都可以独立于其他操作完成。
- en: This design flaw makes the class rigid, inflexible, and error-prone because
    it is hard to maintain. In this example, each method represents a responsibility
    of the class. Each responsibility entails a reason why the class might need to
    be modified. In this case, each method represents one of the various reasons why
    the class will have to be modified.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计缺陷使类变得僵化、不灵活且易于出错，因为它难以维护。在这个例子中，每个方法代表类的职责。每个职责都包含一个可能需要修改类的原因。在这种情况下，每个方法代表类需要修改的多种原因之一。
- en: Consider the loader method, which retrieves the information from a particular
    source. Regardless of how this is done (we can abstract the implementation details
    here), it will have its own sequence of steps, for instance, connecting to the
    data source, loading the data, parsing it into the expected format, and so on.
    If we need to change something (for example, we want to change the data structure
    used for holding the data), the `SystemMonitor` class will need to change. Ask
    yourself whether this makes sense. Does a system monitor object have to change
    because we changed the representation of the data? No.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑加载方法，它从特定的源检索信息。无论这是如何完成的（我们在这里可以抽象实现细节），它将有自己的步骤序列，例如，连接到数据源、加载数据、将其解析成期望的格式等。如果我们需要更改某些内容（例如，我们想要更改用于存储数据的结构），`SystemMonitor`类将需要更改。问问自己这是否有意义。系统监控对象是否必须因为改变了数据的表示而改变？不是。
- en: The same reasoning applies to the other two methods. If we change how we fingerprint
    events, or how we deliver them to another data source, we end up making changes
    to the same class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的推理也适用于其他两个方法。如果我们更改事件指纹的方法，或者将它们传递给另一个数据源的方式，我们最终会对同一个类进行更改。
- en: It should be clear by now that this class is rather fragile and not very maintainable.
    There are lots of different reasons that will impact changes in this class. Instead,
    we want external factors to impact our code as little as possible. The solution,
    again, is to create smaller and more cohesive abstractions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该很清楚这个类相当脆弱，且不易维护。有很多不同的原因会影响这个类的变更。相反，我们希望外部因素尽可能少地影响我们的代码。解决方案，再次强调，是创建更小、更紧密的抽象。
- en: Distributing responsibilities
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配职责
- en: 'To make the solution more maintainable, we separate every method into a different
    class. This way, each class will have a single responsibility:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使解决方案更易于维护，我们将每个方法分离到不同的类中。这样，每个类将只有一个职责：
- en: '![](img/B16567_04_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B16567_04_02](img/B16567_04_02.png)'
- en: 'Figure 4.2: Distributing responsibilities throughout classes'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：在类之间分配职责
- en: The same behavior is achieved by using an object that interacts with instances
    of these new classes, using those objects as collaborators, but the idea remains
    that each class encapsulates a specific set of methods that are independent of
    the rest. The idea now is that changes to any of these classes do not impact the
    rest, and all of them have a clear and specific meaning. If we need to change
    something in how we load events from the data sources, the alert system is not
    even aware of these changes, so we do not have to modify anything on the system
    monitor (as long as the contract is still preserved), and the data target is also
    unmodified.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用与这些新类的实例交互的对象，使用这些对象作为协作者，实现了相同的行为，但理念仍然是每个类封装了一组独立于其他类的特定方法。现在的想法是，对任何这些类的更改都不会影响其他类，并且它们都具有清晰和具体的意义。如果我们需要更改从数据源加载数据的方式，警报系统甚至都不会意识到这些更改，所以我们不需要在系统监控器上做任何修改（只要合同仍然保持不变），数据目标也没有被修改。
- en: Changes are now local, the impact is minimal, and each class is easier to maintain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的变化是局部的，影响最小，每个类都更容易维护。
- en: The new classes define interfaces that are not only more maintainable but also
    reusable. Imagine that now, in another part of the application, we also need to
    read the activity from the logs, but for different purposes. With this design,
    we can simply use objects of the `ActivityWatcher` type (which would actually
    be an interface, but for the purposes of this section, that detail is not relevant
    and will be explained later for the next principles). This would make sense, whereas
    it would not have made sense in the previous design, because attempts to reuse
    the only class we had defined would have also carried extra methods (such as `identify_events()`
    or `stream_events()`) that were not needed at all.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类定义了不仅更易于维护而且可重用的接口。想象一下，现在在应用程序的另一个部分，我们也需要从日志中读取活动，但出于不同的目的。在这个设计中，我们可以简单地使用`ActivityWatcher`类型的对象（实际上这将是一个接口，但为了本节的目的，这个细节并不重要，将在下一个原则中解释）。这将是合理的，而在之前的设计中则不会，因为尝试重用我们定义的唯一类也会携带一些额外的方法（如`identify_events()`或`stream_events()`），而这些方法根本不需要。
- en: One important clarification is that the principle does not mean at all that
    each class must have a single method. Any of the new classes might have extra
    methods, as long as they correspond to the same logic that that class is in charge
    of handling.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的澄清是，这个原则根本不意味着每个类都必须有一个单独的方法。任何新的类都可能有多余的方法，只要它们对应于该类负责处理相同的逻辑。
- en: An interesting observation of most (if not all) of the principles we're exploring
    in this chapter is that we shouldn't try to get them right from the very first
    design. The idea is to design software that can be easily extended and changed,
    and that can evolve toward a more stable version.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索的大多数（如果不是所有）原则的一个有趣观察是，我们不应该试图从一开始的设计就使其完全正确。想法是设计出易于扩展和更改的软件，并且能够向更稳定的版本进化。
- en: 'In particular, you can use the SRP as a thought process. For example, if you''re
    designing a component (let''s say a class), and there are a lot of different things
    that need to be done (as in the previous example), right from the beginning you
    can anticipate that this will not end well, and that you need to separate responsibilities.
    That''s a good start, but then the question is: what are the right boundaries
    to separate responsibilities? So, to understand this, you can start writing a
    monolithic class, in order to understand what the internal collaborations are
    and how responsibilities are distributed. This will help you get a clearer picture
    of the new abstractions that need to be created.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是你可以将SRP（单一职责原则）作为一个思考过程。例如，如果你正在设计一个组件（比如说一个类），并且有很多不同的事情需要完成（就像之前的例子那样），从一开始你就可以预见到这不会有一个好的结果，你需要分离职责。这是一个好的开始，但接下来问题是：如何正确地划分职责的边界？为了理解这一点，你可以从编写一个单体类开始，以便理解内部协作以及职责是如何分配的。这将帮助你更清晰地了解需要创建的新抽象。
- en: The open/closed principle
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: The **open/closed principle** (**OCP**) states that a module should be both
    open and closed (but with respect to different aspects).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放/封闭原则**（OCP）表明，一个模块应该是开放的和封闭的（但针对不同的方面）。'
- en: When designing a class, for instance, we should carefully encapsulate the implementation
    details, so that it has good maintenance, meaning that we want it to be open to
    extension but closed to modification.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在设计一个类时，我们应该仔细封装实现细节，以便它具有良好的可维护性，这意味着我们希望它易于扩展但不易修改。
- en: What this means in simple terms is that, of course, we want our code to be extensible,
    to adapt to new requirements or changes in the domain problem. That means when
    something new appears on the domain problem, we only want to add new things to our
    model, not change anything existing that is closed to modification.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这意味着我们当然希望我们的代码是可扩展的，以适应新的需求或领域问题的变化。这意味着当领域问题中出现新事物时，我们只想向我们的模型中添加新事物，而不是改变任何现有的、不易修改的部分。
- en: If for some reason, when something new has to be added we find ourselves modifying
    the code, then that logic is probably poorly designed. Ideally, when requirements
    change, we want to just have to extend the module with the new behavior, but without
    having to alter the current logic significantly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因为某种原因，当我们需要添加新事物时，发现自己需要修改代码，那么这个逻辑可能设计得不好。理想情况下，当需求变化时，我们只想通过扩展模块来添加新的行为，而不需要显著改变当前的逻辑。
- en: This principle applies to several software abstractions. It could be a class
    or even a module we're talking about, but the idea remains the same. We will see
    examples of each one in the following two subsections.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则适用于多个软件抽象。这可能是一个类，甚至是一个模块，但我们讨论的想法是相同的。在接下来的两个小节中，我们将看到每个的示例。
- en: Example of maintainability perils for not following the OCP
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不遵循OCP原则的可维护性风险示例
- en: Let's begin with an example of a system that is designed in such a way that
    does not follow the OCP, in order to see the maintainability problems this carries,
    and the inflexibility of such a design.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这样一个系统的例子开始，这个系统设计得并不遵循OCP原则，以便看到它带来的可维护性问题以及这种设计的僵化性。
- en: The idea is that we have a part of the system that is in charge of identifying
    events as they occur in another system, which is being monitored. At each point,
    we want this component to identify the type of event, correctly, according to
    the values of the data that was previously gathered (for simplicity, we will assume
    it is packaged into a dictionary, and was previously retrieved through another
    means such as logs, queries, and many more). We have a class that, based on this
    data, will retrieve the event, which is another type with its own hierarchy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是这样的：我们有一个系统的一部分，负责识别在另一个被监控的系统发生的事件。在每一个点上，我们希望这个组件能够根据之前收集到的数据值（为了简单起见，我们假设它被包装到一个字典中，并且之前通过日志、查询等多种方式检索到）正确地识别事件类型。我们有一个基于这些数据的类，它将检索事件，这是一个具有自己层次结构的新类型。
- en: 'From the class diagram in *Figure 4.3*, we see an object that works with an
    interface (a base class, with several subclasses that can be used polymorphically):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图4.3*的类图中，我们看到一个与接口（一个基类，有多个可以多态使用的子类）一起工作的对象：
- en: '![](img/B16567_04_03.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16567_04_03.png)'
- en: 'Figure 4.3: A design that''s not closed for modification'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：一个不封闭修改的设计
- en: 'At first glance this might look like it''s an extensible design: adding a new
    event would be about creating a new subclass of `Event`, and then the system monitor
    should be able to work with them. However, this is not quite accurate, as it all
    depends on the actual implementation within the method used in the system monitor
    class.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 初看这似乎像是一个可扩展的设计：添加一个新事件大概就是创建一个新的`Event`子类，然后系统监控器应该能够处理它们。然而，这并不完全准确，因为这完全取决于系统监控器类中使用的方法的实际实现。
- en: 'A first attempt to solve this problem might look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一次尝试可能看起来像这样：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the expected behavior of the preceding code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码预期行为的描述：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice the hierarchy of event types, and some business logic to construct them.
    For instance, when there was no previous flag for a session, but there is now,
    we identify that record as a login event. Conversely, when the opposite happens,
    it means that it was a logout event. If it was not possible to identify an event,
    an event of type unknown is returned. This is to preserve polymorphism by following
    the `null` object pattern (instead of returning `None`, it retrieves an object
    of the corresponding type with some default logic). The `null` object pattern
    is described in *Chapter 9*, *Common Design Patterns*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事件类型的层次结构以及一些构建它们的业务逻辑。例如，当会话没有之前的标志，但现在有标志时，我们将其识别为登录事件。相反，当情况相反时，这意味着它是注销事件。如果无法识别事件，则返回未知类型的事件。这是通过遵循`null`对象模式来保持多态性的（而不是返回`None`，它检索具有一些默认逻辑的相应类型的对象）。`null`对象模式在*第9章*，*常见设计模式*中描述。
- en: This design has some problems. The first issue is that the logic for determining
    the types of events is centralized inside a monolithic method. As the number of
    events we want to support grows, this method will as well, and it could end up
    being a very long method, which is bad because, as we have already discussed,
    it will not be doing just one thing and one thing well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计存在一些问题。第一个问题是确定事件类型的逻辑集中在一个单体方法中。随着我们想要支持的事件数量的增加，此方法也将增加，最终可能成为一个非常长的方法，这是不好的，因为我们已经讨论过，它将不会只做一件事并且做得很好。
- en: On the same line, we can see that this method is not closed for modification.
    Every time we want to add a new type of event to the system, we will have to change
    something in this method (not to mention that the chain of `elif` statements will
    be a nightmare to read!).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以看到此方法不是对修改封闭的。每次我们想要向系统中添加新类型的事件时，我们都需要更改此方法中的某些内容（更不用说`elif`语句链将是一个噩梦般的阅读体验了！）。
- en: We want to be able to add new types of events without having to change this
    method (closed for modification). We also want to be able to support new types
    of events (open for extension) so that when a new event is added, we only have
    to add code, not change the code that already exists.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在不改变此方法的情况下添加新类型的事件（对修改封闭）。我们还希望能够支持新类型的事件（对扩展开放），这样当添加新事件时，我们只需要添加代码，而不需要更改现有的代码。
- en: Refactoring the events system for extensibility
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新设计事件系统以实现可扩展性
- en: The problem with the previous example was that the `SystemMonitor` class was
    interacting directly with the concrete classes it was going to retrieve.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例的问题在于`SystemMonitor`类直接与它将要检索的具体类进行交互。
- en: In order to achieve a design that honors the open/closed principle, we have
    to design towards abstractions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个符合开放/封闭原则的设计，我们必须面向抽象进行设计。
- en: 'A possible alternative would be to think of this class as it collaborates with
    the events, and then we delegate the logic for each particular type of event to
    its corresponding class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的替代方案是将此类视为它与事件协作，然后我们将每个特定类型事件的逻辑委托给其对应的类：
- en: '![](img/B16567_04_04.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16567_04_04.png)'
- en: 'Figure 4.4: A design that follows the OCP'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：遵循OCP的设计
- en: Then we have to add a new (polymorphic) method to each type of event with the
    single responsibility of determining if it corresponds to the data being passed
    or not, and we also have to change the logic to go through all events, finding
    the right one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须为每种事件类型添加一个新的（多态的）方法，该方法的单一职责是确定它是否对应于传递的数据，并且我们还需要更改逻辑以遍历所有事件，找到正确的一个。
- en: 'The new code should look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码应该看起来像这样：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how the interaction is now oriented towards an abstraction (in this case,
    it would be the generic base class `Event`, which might even be an abstract base
    class or an interface, but for the purposes of this example it is enough to have
    a concrete base class). The method no longer works with specific types of events,
    but just with generic events that follow a common interface—they are all polymorphic
    with respect to the `meets_condition` method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在交互是如何面向抽象的（在这种情况下，将是通用的基类`Event`，它甚至可能是一个抽象基类或接口，但为了本例的目的，有一个具体的基类就足够了）。该方法不再与特定类型的事件一起工作，而是与遵循通用接口的通用事件一起工作——它们在`meets_condition`方法上都是多态的。
- en: Notice how events are discovered through the `__subclasses__()` method. Supporting
    new types of events is now just about creating a new class for that event that
    has to extend `Event` and implement its own `meets_condition()` method, according
    to its particular criteria.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事件是如何通过 `__subclasses__()` 方法被发现的。支持新类型的事件现在只需要为该事件创建一个新的类，这个类必须扩展 `Event`
    并实现它自己的 `meets_condition()` 方法，根据其特定的标准。
- en: This example relies on the `__subclasses__()` method, because it's enough to
    illustrate the idea of an extensible design. Other alternatives can be used as
    well, such as registering classes using the `abc` module, or creating our own
    registry, but the main idea is the same, and the relationship between the objects
    wouldn't change.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子依赖于 `__subclasses__()` 方法，因为它足以说明可扩展设计的理念。也可以使用其他替代方案，例如使用 `abc` 模块注册类，或者创建我们自己的注册表，但主要思想是相同的，对象之间的关系不会改变。
- en: 'With this design, the original `identify_event` method is closed: it doesn''t
    have to be modified when we add a new type of event to our domain. Conversely,
    the hierarchy of events is open for extension: when a new event appears in the
    domain, we only need to create a new entity and define its criteria according
    to the interface it implements.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，原始的 `identify_event` 方法是封闭的：当我们向我们的领域添加新类型的事件时，它不需要被修改。相反，事件层次结构对新类型的扩展是开放的：当领域中出现新事件时，我们只需要创建一个新的实体，并定义其根据接口实现的准则。
- en: Extending the events system
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展事件系统
- en: Now, let's prove that this design is actually as extensible as we wanted it
    to be. Imagine that a new requirement arises, and we have to also support events
    that correspond to transactions that the user executed on the monitored system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们证明这个设计实际上是我们想要的那么可扩展。想象一下，出现了一个新的需求，我们还需要支持用户在监控系统中执行的事务对应的事件。
- en: 'The class diagram for the design has to include this new event type, as shown
    in *Figure 4.5*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 设计的类图必须包括这个新的事件类型，如图 *4.5* 所示：
- en: '![](img/B16567_04_05.png)Figure 4.5: The design extended'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5：设计扩展](img/B16567_04_05.png)图 4.5：设计扩展'
- en: We create the new class, implement the criteria on its `meets_condition` method,
    and the rest of the logic should continue to work as before (with the new behavior
    included).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建新的类，在它的 `meets_condition` 方法上实现准则，其余的逻辑应该继续按之前的方式工作（包括新的行为）。
- en: 'Assuming all the rest of the previous definitions don''t change, here''s the
    code for the new class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设之前的所有定义都没有改变，以下是新类的代码：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can verify that the previous cases work as before and that the new event
    is also correctly identified:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证之前的案例仍然按预期工作，并且新的事件也被正确识别：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the `SystemMonitor.identify_event()` method did not change at all
    when we added the new event type. We therefore say that this method is closed
    with respect to new types of events.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到当我们添加新的事件类型时，`SystemMonitor.identify_event()` 方法完全没有改变。因此，我们说这个方法对新类型的事件是封闭的。
- en: Conversely, the `Event` class allowed us to add a new type of event when we
    were required to do so. We then say that events are open for an extension with
    respect to new types.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当需要添加新类型的事件时，`Event` 类允许我们这样做。因此，我们说事件对新类型的扩展是开放的。
- en: This is the true essence of this principle—when something new appears on the
    domain problem, we only want to add new code, not modify any existing code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个原则的真正本质——当领域问题中出现新事物时，我们只想添加新代码，而不是修改任何现有代码。
- en: Final thoughts about the OCP
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 OCP 的最后思考
- en: As you might have noticed, this principle is closely related to the effective
    use of polymorphism. We want to work towards designing abstractions that respect
    a polymorphic contract that the client can use, to a structure that is generic
    enough that extending the model is possible, as long as the polymorphic relationship
    is preserved.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，这个原则与多态的有效使用密切相关。我们希望致力于设计遵守多态契约的抽象，该契约客户端可以使用，以一个足够通用的结构，只要保持多态关系，扩展模型就是可能的。
- en: 'This principle tackles an important problem in software engineering: maintainability.
    The perils of not following the OCP are ripple effects and problems in the software
    where a single change triggers changes all over the code base, or risks breaking
    other parts of the code.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则解决了一个重要的软件工程问题：可维护性。不遵循 OCP 的危险是连锁反应和软件中的问题，其中单个更改会触发整个代码库中的更改，或者有破坏代码其他部分的风险。
- en: One important final note is that, in order to achieve this design in which we
    do not change the code to extend behavior, we need to be able to create proper
    closure against the abstractions we want to protect (in this example, new types
    of events). This is not always possible in all programs, as some abstractions
    might collide (for example, we might have a proper abstraction that provides closure
    against a requirement but does not work for other types of requirements). In these
    cases, we need to be selective and apply a strategy that provides the best closure
    for the types of requirements that require being the most extensible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个重要的注意事项是，为了实现这种设计，我们不需要更改代码来扩展行为，我们需要能够创建适当的封闭来保护我们想要保护的抽象（在这个例子中，是新的事件类型）。在所有程序中，这并不总是可能的，因为一些抽象可能会冲突（例如，我们可能有一个提供对要求封闭的正确抽象，但不适用于其他类型的要求）。在这些情况下，我们需要有选择性，并应用一种策略，为需要最可扩展的类型提供最佳的封闭。
- en: Liskov's substitution principle
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: '**Liskov''s substitution principle** (**LSP**) states that there is a series
    of properties that an object type must hold to preserve the reliability of its
    design.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Liskov替换原则**（**LSP**）表明，一个对象类型必须保持一系列属性以保持其设计的可靠性。'
- en: The main idea behind LSP is that, for any class, a client should be able to
    use any of its subtypes indistinguishably, without even noticing, and therefore
    without compromising the expected behavior at runtime. That means that clients
    are completely isolated and unaware of changes in the class hierarchy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: LSP背后的主要思想是，对于任何类，客户端都应该能够无差别地使用其任何子类型，甚至没有注意到，因此不会在运行时破坏预期的行为。这意味着客户端完全隔离并且对类层次结构的变化一无所知。
- en: 'More formally, this is the original definition (LISKOV 01) of LSP: if *S* is
    a subtype of *T*, then objects of type *T* may be replaced by objects of type
    *S*, without breaking the program.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，这是LSP的原始定义（LISKOV 01）：如果*S*是*T*的子类型，那么*T*类型的对象可以被*S*类型的对象替换，而不会破坏程序。
- en: This can be understood with the help of a generic diagram such as the following
    one. Imagine that there is some client class that requires (includes) objects
    of another type. Generally speaking, we will want this client to interact with
    objects of some type, namely, it will work through an interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下通用图表来理解。想象有一个客户端类需要（包含）另一个类型的对象。一般来说，我们希望这个客户端与某些类型的对象交互，也就是说，它将通过接口工作。
- en: 'Now, this type might as well be just a generic interface definition, an abstract
    class or an interface, not a class with the behavior itself. There may be several
    subclasses extending this type (described in *Figure 4.6* with the name `Subtype`,
    up to `N`). The idea behind this principle is that if the hierarchy is correctly
    implemented, the client class has to be able to work with instances of any of
    the subclasses without even noticing. These objects should be interchangeable,
    as *Figure 4.6* shows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个类型可能只是一个通用的接口定义，一个抽象类或一个接口，而不是具有行为本身的类。可能有几个子类扩展这个类型（如*图4.6*中名为`Subtype`的描述，直到`N`）。这个原则背后的思想是，如果层次结构实现正确，客户端类必须能够与任何子类的实例一起工作，甚至没有注意到。这些对象应该是可互换的，如*图4.6*所示：
- en: '![Picture 6](img/B16567_04_06.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](img/B16567_04_06.png)'
- en: 'Figure 4.6: A generic subtypes hierarchy'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：一个通用的子类型层次结构
- en: This is related to other design principles we have already visited, like designing
    for interfaces. A good class must define a clear and concise interface, and as
    long as subclasses honor that interface, the program will remain correct.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他我们已经探讨过的设计原则相关，如面向接口的设计。一个好的类必须定义一个清晰简洁的接口，只要子类遵守这个接口，程序就会保持正确。
- en: As a consequence of this, the principle also relates to the ideas behind designing
    by contract. There is a contract between a given type and a client. By following
    the rules of LSP, the design will make sure that subclasses respect the contracts
    as they are defined by parent classes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，这个原则也与设计合同背后的思想相关。给定类型和客户端之间存在一个合同。通过遵循LSP的规则，设计将确保子类尊重由父类定义的合同。
- en: Detecting LSP issues with tools
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工具检测LSP问题
- en: There are some scenarios so notoriously wrong with respect to the LSP that they
    can be easily identified by the tools we have learned to configure in *Chapter
    1*, *Introduction, Code Formatting, and Tools* (mainly `mypy` and `pylint`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有些场景与LSP的关系非常明显是错误的，以至于我们可以通过我们在*第一章*，“介绍、代码格式化和工具”中学习到的工具轻松识别（主要是`mypy`和`pylint`）。
- en: Using mypy to detect incorrect method signatures
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用mypy检测不正确的方法签名
- en: By using type annotations (as recommended previously in *Chapter 1*, *Introduction,
    Code Formatting, and Tools*), throughout our code, and configuring `mypy`, we
    can quickly detect some basic errors early, and check basic compliance with LSP
    for free.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类型注解（如之前在*第一章*，*介绍、代码格式化和工具*中推荐的那样），并在整个代码中配置`mypy`，我们可以快速检测到一些基本错误，并免费检查对LSP的基本合规性。
- en: 'If one of the subclasses of the `Event` class were to override a method in
    an incompatible fashion, `mypy` would notice this by inspecting the annotations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Event`类的某个子类以不兼容的方式覆盖了一个方法，`mypy`将通过检查注解来注意到这一点：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run `mypy` on this file, we will get an error message saying the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在该文件上运行`mypy`时，我们将得到一个错误消息，如下所示：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The violation to LSP is clear—since the derived class is using a type for the
    `event_data` parameter that is different from the one defined on the base class,
    we cannot expect them to work equally. Remember that, according to this principle,
    any caller of this hierarchy has to be able to work with `Event` or `LoginEvent`
    transparently, without noticing any difference. Interchanging objects of these
    two types should not make the application fail. Failure to do so would break the
    polymorphism on the hierarchy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对LSP的违反是明显的——因为派生类为`event_data`参数使用了一个与基类定义不同的类型，我们无法期望它们能够同等工作。记住，根据这个原则，任何调用这个层次结构的调用者都必须能够透明地与`Event`或`LoginEvent`一起工作，而不会注意到任何差异。交换这两种类型的对象不应该使应用程序失败。未能做到这一点将破坏层次结构上的多态性。
- en: The same error would have occurred if the return type was changed for something
    other than a `Boolean` value. The rationale is that clients of this code are expecting
    a `Boolean` value to work with. If one of the derived classes changes this return
    type, it would be breaking the contract, and again, we cannot expect the program
    to continue working normally.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将返回类型更改为除布尔值`Boolean`以外的其他类型，同样会出现相同的错误。其理由是，使用此代码的客户端期望得到一个`Boolean`值来工作。如果其中一个派生类更改了此返回类型，这将破坏契约，再次，我们无法期望程序能正常工作。
- en: 'A quick note about types that are not the same but share a common interface:
    even though this is just a simple example to demonstrate the error, it is still
    true that both dictionaries and lists have something in common; they are both
    iterables. This means that in some cases, it might be valid to have a method that
    expects a dictionary and another one expecting to receive a list, as long as both
    treat the parameters through the iterable interface. In this case, the problem
    would not lie in the logic itself (LSP might still apply), but in the definition
    of the types of the signature, which should read neither `list` nor `dict`, but
    a union of both. Regardless of the case, something has to be modified, whether
    it is the code of the method, the entire design, or just the type annotations,
    but in no case should we silence the warning and ignore the error given by `mypy`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不同但共享公共接口的类型的一个快速说明：尽管这只是一个简单的示例来展示错误，但确实，字典和列表都有一些共同点；它们都是可迭代的。这意味着在某些情况下，可能有一个期望接收字典的方法和另一个期望接收列表的方法是有效的，只要两者都通过迭代器接口处理参数。在这种情况下，问题不在于逻辑本身（LSP可能仍然适用），而在于签名类型的定义，它应该读取既不是`list`也不是`dict`，而是两者的联合。无论哪种情况，都必须进行修改，无论是方法的代码、整个设计还是类型注解，但无论如何都不应该忽略由`mypy`给出的警告和错误。
- en: 'Do not ignore errors such as this by using `# type: ignore` or something similar.
    Refactor or change the code to solve the real problem. The tools are reporting
    an actual design flaw for a valid reason.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '不要通过使用`# type: ignore`或类似的方式来忽略此类错误。重构或更改代码以解决真正的问题。工具正在报告一个实际的设计缺陷，这是有充分理由的。'
- en: This principle also makes sense from an object-oriented design perspective.
    Remember that subclassing should create more specific types, but each subclass
    must be what the parent class declares. With the example from the previous section,
    the system monitor wants to be able to work with any of the event types interchangeably.
    But each of these event types is an event (a `LoginEvent` must be an `Event`,
    and so must the rest of the subclasses). If any of these objects break the hierarchy
    by not implementing a message from the base `Event` class, implementing another
    public method not declared in this one, or changing the signature of the methods,
    then the `identify_event` method might no longer work.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则从面向对象设计的角度来看也是合理的。记住，子类化应该创建更具体的类型，但每个子类都必须是父类声明的。以上一节中的例子为例，系统监控器希望能够与任何事件类型交互使用。但每个这些事件类型都是一个事件（一个`LoginEvent`必须是一个`Event`，其他子类也是如此）。如果这些对象中的任何一个通过没有实现基类`Event`的消息、实现这个类中没有声明的另一个公共方法或更改方法的签名来破坏层次结构，那么`identify_event`方法可能就不再起作用。
- en: Detecting incompatible signatures with pylint
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`pylint`检测不兼容的签名
- en: Another strong violation of LSP is when, instead of varying the types of the
    parameters on the hierarchy, the signatures of the methods differ completely.
    This might seem like quite a blunder, but detecting it might not always be so
    easy to remember; Python is interpreted, so there is no compiler to detect these
    types of errors early on, and therefore they will not be caught until runtime.
    Luckily, we have static code analyzers such as `mypy` and `pylint` to catch errors
    such as this one early on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: LSP的另一个强烈违反情况是，当不是通过改变层次结构中参数的类型，而是方法签名完全不同时。这看起来可能相当明显，但检测它可能并不总是那么容易记住；Python是解释型语言，所以没有编译器在早期检测这些类型的错误，因此它们直到运行时才会被发现。幸运的是，我们有像`mypy`和`pylint`这样的静态代码分析器来早期捕获这类错误。
- en: While `mypy` will also catch these types of errors, it is a good idea to also
    run `pylint` to gain more insight.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`mypy`也会捕获这些类型的错误，但运行`pylint`以获得更多见解是个好主意。
- en: 'In the presence of a class that breaks the compatibility defined by the hierarchy
    (for example, by changing the signature of the method, adding an extra parameter,
    and so on) such as the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在破坏层次结构兼容性的类（例如，通过更改方法的签名、添加额外的参数等）的情况下，如下所示：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`pylint` will detect it, printing an informative error:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`pylint`会检测到它，并打印出有信息的错误：'
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once again, like in the previous case, do not suppress these errors. Pay attention
    to the warnings and errors the tools give and adapt the code accordingly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，就像在先前的案例中一样，不要抑制这些错误。注意工具给出的警告和错误，并相应地调整代码。
- en: More subtle cases of LSP violations
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LSP违规的更微妙情况
- en: In other cases, however, the way LSP is broken is not so clear or obvious that
    a tool can automatically identify it for us, and we have to rely upon careful
    code inspection when doing a code review.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在其他情况下，LSP被破坏的方式并不那么清晰或明显，以至于工具可以自动为我们识别它，我们必须在代码审查时依靠仔细的代码检查。
- en: Cases where contracts are modified are particularly harder to detect automatically.
    Given that the entire idea of LSP is that subclasses can be used by clients just
    like their parent class, it must also be true that contracts are correctly preserved
    on the hierarchy.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 合约被修改的情况尤其难以自动检测。鉴于LSP的整个想法是子类可以被客户像父类一样使用，这也必须意味着合约在层次结构中得到了正确保留。
- en: Remember from *Chapter 3*, *General Traits of Good Code*, when designing by
    contract, the contract between the client and supplier sets some rules—the client
    must provide the preconditions to the method, which the supplier might validate,
    and it returns some result to the client that it will check in the form of postconditions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记住来自**第3章**，**良好代码的一般特性**，在设计合约时，客户和供应商之间的合约设定了一些规则——客户必须向方法提供前置条件，供应商可能会验证这些条件，并返回一些结果给客户，客户将以后置条件的形式进行检查。
- en: 'The parent class defines a contract with its clients. Subclasses of this one
    must respect such a contract. This means that for example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 父类定义了一个与客户的合约。这个父类的子类必须遵守这样的合约。这意味着例如：
- en: A subclass can never make preconditions stricter than they are defined on the parent
    class
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类永远不能使前置条件比在父类中定义的更严格
- en: A subclass can never make postconditions weaker than they are defined on the
    parent class
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类永远不能使后置条件比在父类中定义的更弱
- en: Consider the example of the events hierarchy defined in the previous section,
    but now with a change to illustrate the relationship between LSP and DbC.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上一节中定义的事件层次结构示例，但现在有一个变化来展示LSP和DbC之间的关系。
- en: This time, we are going to assume a precondition for the method that checks
    the criteria based on the data, that the provided parameter must be a dictionary
    that contains both keys `"before"` and `"after"`, and that their values are also
    nested dictionaries. This allows us to encapsulate even further, because now the
    client does not need to catch the `KeyError` exception, but instead just calls
    the precondition method (assuming that it is acceptable to fail if the system
    is operating under the wrong assumptions).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将假设一个基于数据检查标准的方法的先决条件，即提供的参数必须是一个包含 `"before"` 和 `"after"` 两个键的字典，并且它们的值也是嵌套字典。这允许我们进一步封装，因为现在客户端不需要捕获
    `KeyError` 异常，而是只需调用先决条件方法（假设如果系统在错误的假设下运行，失败是可以接受的）。
- en: As a side note, it is good that we can remove this from the client, as now,
    `SystemMonitor` does not need to know which types of exceptions the methods of
    the collaborator class might raise (remember that exceptions weaken encapsulation,
    as they require the caller to know something extra about the object they are calling).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们能够从客户端移除这部分内容是好事，因为现在 `SystemMonitor` 不需要知道协作类的方法可能会抛出哪些类型的异常（记住，异常会削弱封装性，因为它们要求调用者了解关于被调用对象的一些额外信息）。
- en: 'Such a design might be represented with the following changes in the code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的设计可以通过以下代码中的以下更改来表示：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And now the code that tries to detect the correct event type just checks the
    precondition once, and proceeds to find the right type of event:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试检测正确事件类型的代码只是检查一次先决条件，然后继续寻找正确的事件类型：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The contract only states that the top-level keys `"before"` and `"after"` are
    mandatory and that their values should also be dictionaries. Any attempt in the
    subclasses to demand a more restrictive parameter will fail.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 合同仅声明顶级键 `"before"` 和 `"after"` 是必需的，并且它们的值也应该是字典。任何在子类中尝试要求更严格参数的尝试都将失败。
- en: 'The class for the transaction event was originally correctly designed. Look
    at how the code does not impose a restriction on the internal key named `"transaction"`;
    it only uses its value if it is there, but this is not mandatory:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事务事件的类最初设计得正确。看看代码是如何不对内部键 `"transaction"` 施加限制的；它只有在存在时才使用其值，但这不是必需的：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, the original two methods are not correct, because they demand the presence
    of a key named `"session"`, which is not part of the original contract. This breaks
    the contract, and now the client cannot use these classes in the same way it uses
    the rest of them because it will raise `KeyError`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，原始的两个方法是不正确的，因为它们要求存在一个名为 `"session"` 的键，而这个键不是原始合同的一部分。这违反了合同，现在客户端不能像使用其他类一样使用这些类，因为它将引发
    `KeyError`。
- en: 'After fixing this (changing the square brackets for the `.get()` method), the
    order on the LSP has been reestablished, and polymorphism prevails:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复了这个问题（将 `.get()` 方法的方括号更改为正确形式）之后，LSP 上的顺序已经重新建立，多态性占主导地位：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is unreasonable to expect automated tools (regardless of how good and helpful
    they are) to detect cases such as this one. We have to be careful when designing
    classes that we do not accidentally change the input or output of the methods
    in a way that would be incompatible with what the clients are originally expecting.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 期望自动化工具（无论它们多么好和有帮助）检测此类情况是不合理的。在设计类时，我们必须小心，不要意外地更改方法输入或输出，使其与客户端最初期望的不兼容。
- en: Remarks on the LSP
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于LSP的备注
- en: The LSP is fundamental to good object-oriented software design because it emphasizes
    one of its core traits—polymorphism. It is about creating correct hierarchies
    so that classes derived from a base one are polymorphic along the parent one,
    with respect to the methods on their interface.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: LSP 对于良好的面向对象软件设计至关重要，因为它强调了其核心特性之一——多态性。它关乎创建正确的层次结构，使得从基类派生的类在父类中具有多态性，相对于它们接口上的方法。
- en: It is also interesting to notice how this principle relates to the previous
    one—if we attempt to extend a class with a new one that is incompatible, it will
    fail, the contract with the client will be broken, and as a result such an extension
    will not be possible (or, to make it possible, we would have to break the other
    end of the principle and modify code in the client that should be closed for modification,
    which is completely undesirable and unacceptable).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 也很有趣地注意到这个原则如何与先前的原则相关联——如果我们尝试用一个与之不兼容的新类扩展一个类，它将失败，与客户端的合同将被破坏，因此这样的扩展将不可能实现（或者，为了使其可能，我们不得不打破原则的另一端，并修改客户端应该关闭修改的代码，这是完全不可接受和不接受的）。
- en: Carefully thinking about new classes in the way that LSP suggests helps us to
    extend the hierarchy correctly. We could then say that LSP contributes to the
    OCP.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 按照LSP建议的方式仔细思考新的类，有助于我们正确地扩展层次结构。然后我们可以说LSP有助于OCP。
- en: Interface segregation
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口分离
- en: 'The **interface segregation principle** (**ISP**) provides some guidelines
    for an idea that we have revisited quite repeatedly already: that interfaces should
    be small.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口分离原则**（**ISP**）为我们已经反复思考过的一个观点提供了一些指导：即接口应该是小的。'
- en: In object-oriented terms, an **interface** is represented by the set of methods
    and properties an object exposes. That is to say that all the messages that an
    object is able to receive or interpret constitute its interface, and this is what
    other clients can request. The interface separates the definition of the exposed
    behavior for a class from its implementation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象术语中，一个**接口**由对象公开的方法和属性集表示。也就是说，一个对象能够接收或解释的所有消息构成了它的接口，这也是其他客户端可以请求的。接口将类的公开行为定义与其实现分离。
- en: In Python, interfaces are implicitly defined by a class according to its methods.
    This is because Python follows the so-called **duck typing** principle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，接口根据其方法隐式地由一个类定义。这是因为Python遵循所谓的**鸭子类型**原则。
- en: Traditionally, the idea behind duck typing was that any object is really represented
    by the methods it has, and by what it is capable of doing. This means that, regardless
    of the type of the class, its name, docstring, class attributes, or instance attributes,
    what ultimately defines the essence of the object are the methods it has. The
    methods defined in a class (what it knows how to do) are what determines what
    that object will be. It was called duck typing because of the idea that "If it
    walks like a duck, and quacks like a duck, it must be a duck."
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，鸭子类型背后的想法是，任何对象实际上都由它拥有的方法和它能够做什么来表示。这意味着，无论类的类型、名称、文档字符串、类属性还是实例属性如何，最终定义对象本质的是它拥有的方法。在类中定义的方法（它知道如何做）决定了那个对象将是什么。它被称为鸭子类型，因为有一个想法：“如果它像鸭子走路，像鸭子嘎嘎叫，那么它一定是一只鸭子。”
- en: For a long time, duck typing was the sole way interfaces were defined in Python.
    Later on, PEP-3119 introduced the concept of abstract base classes as a way to
    define interfaces in a different way. The basic idea of abstract base classes
    is that they define a basic behavior or interface that some derived classes are
    responsible for implementing. This is useful in situations where we want to make
    sure that certain critical methods are actually overridden, and it also works
    as a mechanism for overriding or extending the functionality of methods such as
    `isinstance()`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间里，鸭子类型是Python中定义接口的唯一方式。后来，PEP-3119引入了抽象基类的概念，作为以不同方式定义接口的方法。抽象基类的基本思想是，它们定义了一个基本行为或接口，一些派生类负责实现。这在我们要确保某些关键方法实际上被重写的情况下很有用，它也作为重写或扩展如`isinstance()`等方法功能的一种机制。
- en: The introduction of abstract base classes was done to provide a useful and powerful
    tool for developers to indicate things that must actually be implemented. For
    example, and considering the previous principle exposed (LSP), if we have a generic
    `Event` class, we don't want to use that class itself (because by its own it doesn't
    mean anything), so we probably want to deal with one of the actual events (the
    subclasses, like `LoginEvent`, for example). In this case we could define `Event`
    as an abstract base class, to make this explicit. Then the system monitor works
    with a type of event, and the `Event` class acts like an interface (as a way of
    saying "any object that has this kind of behavior"). We can go further and decide
    that the default implementation of the `meets_condition` method is not enough
    (or that sometimes, an implementation can't be provided by the interface), and
    force each derived class to implement it. For this, we would use an `@abstractmethod`
    decorator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 引入抽象基类是为了为开发者提供一个有用的强大工具，以指示必须实际实现的事情。例如，考虑到之前提出的原理（LSP），如果我们有一个通用的 `Event`
    类，我们不希望直接使用这个类（因为它本身并没有什么意义），所以我们可能想处理实际的事件之一（例如 `LoginEvent` 这样的子类）。在这种情况下，我们可以将
    `Event` 定义为一个抽象基类，以使这一点明确。然后系统监控器与事件类型一起工作，而 `Event` 类则充当接口（作为一种表示“任何具有这种行为的对象”）的方式。我们可以更进一步，并决定
    `meets_condition` 方法的默认实现不够（或者有时，接口无法提供实现），并强制每个派生类实现它。为此，我们将使用 `@abstractmethod`
    装饰器。
- en: The `abc` module also contains a way of registering some types as part of a
    hierarchy, in what is called a virtual subclass. The idea is that this extends
    the concept of duck typing a little bit further by adding a new criterion—walks
    like a duck, quacks like a duck, or... it says it is a duck.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc` 模块还包含一种将某些类型注册为层次结构一部分的方法，这被称为虚拟子类。这个想法是通过添加一个新的标准——像鸭子一样走路，像鸭子一样嘎嘎叫，或者……它说它是鸭子，来进一步扩展鸭子类型的概念。'
- en: These notions of how Python interprets interfaces are important for understanding
    this principle and the next one.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关于 Python 如何解释接口的概念对于理解这个原则和下一个原则非常重要。
- en: In abstract terms, the ISP states that when we define an interface that provides
    multiple methods, it is better to instead break it down into multiple ones, each
    one containing fewer methods (preferably just one), with a very specific and accurate
    scope. By separating interfaces into the smallest possible units, to favor code
    reusability, each class that wants to implement one of these interfaces will most
    likely be highly cohesive given that it has a quite definite behavior and set
    of responsibilities.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象地说，ISP 声明，当我们定义一个提供多个方法的接口时，最好是将其分解成多个接口，每个接口包含较少的方法（最好是只有一个），具有非常具体和准确的范围。通过将接口分解成尽可能小的单元，以促进代码重用，每个想要实现这些接口的类很可能具有高度的内聚性，因为它们具有相当明确的行为和责任集。
- en: An interface that provides too much
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供过多功能的界面
- en: 'Now, we want to be able to parse an event from several data sources, in different
    formats (XML and JSON, for instance). Following good practices, we decide to target an
    interface as our dependency instead of a concrete class, and something like the
    following is devised:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望能够从多个数据源中解析事件，这些数据源有不同的格式（例如 XML 和 JSON）。遵循良好的实践，我们决定将接口作为我们的依赖项，而不是一个具体的类，并设计出如下内容：
- en: '![Picture 7](img/B16567_04_07.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7](img/B16567_04_07.png)'
- en: 'Figure 4.7: An interface providing too many disjoint capabilities'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：提供过多不相关功能的接口
- en: In order to create this as an interface in Python, we would use an abstract
    base class and define the methods (`from_xml()` and `from_json()`) as abstract,
    to force derived classes to implement them. Events that derive from this abstract
    base class and implement these methods would be able to work with their corresponding
    types.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Python 中创建这个接口，我们将使用抽象基类，并将方法（`from_xml()` 和 `from_json()`）定义为抽象的，以强制派生类实现它们。从这个抽象基类派生并实现这些方法的实体将能够与它们对应类型一起工作。
- en: But what if a particular class does not need the XML method, and can only be
    constructed from a JSON? It would still carry the `from_xml()` method from the
    interface, and since it does not need it, it will have to pass. This is not very
    flexible as it creates coupling and forces clients of the interface to work with
    methods that they do not need.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果某个特定的类不需要 XML 方法，而只能从 JSON 中构建呢？它仍然会携带接口中的 `from_xml()` 方法，由于它不需要它，它将不得不跳过。这并不灵活，因为它创建了耦合，并迫使接口的客户端使用他们不需要的方法。
- en: The smaller the interface, the better
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口越小越好
- en: 'It would be better to separate this into two different interfaces, one for
    each method. We can still achieve the same functionality by making our event parser
    class implement both interfaces (because interfaces or abstract base classes are
    just regular classes with some enhanced constraints, and Python supports multiple
    inheritance). The difference now is that we have each method declared in a more
    specific interface that we can reuse should we need it somewhere else in our code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将其分为两个不同的接口，每个方法一个接口会更好。我们仍然可以通过让我们的事件解析器类实现这两个接口来达到相同的功能（因为接口或抽象基类只是具有一些增强约束的常规类，Python支持多重继承）。现在的不同之处在于，我们可以在更具体的接口中声明每个方法，如果我们需要在代码的其他地方重用它：
- en: '![](img/B16567_04_08.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16567_04_08.png)'
- en: 'Figure 4.8: The same functionality achieved through separate interfaces'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：通过单独的接口实现相同的功能
- en: With this design, objects that derive from `XMLEventParser` and implement the
    `from_xml()` method will know how to be constructed from an XML, and the same
    for a JSON file, but most importantly, we maintain the orthogonality of two independent
    functions, and preserve the flexibility of the system without losing any functionality
    that can still be achieved by composing new smaller objects.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设计中，从`XMLEventParser`派生并实现`from_xml()`方法的对象将知道如何从XML构建，对于JSON文件也是如此，但最重要的是，我们保持了两个独立函数的正交性，并保留了系统的灵活性，而没有失去任何可以通过组合新的较小对象实现的功能。
- en: 'This is how the code might look for the representation of *Figure 4.8*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码可能看起来像代表*图4.8*的方式：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that the abstract methods required by the interface must be implemented
    in the concrete class (their actual implementation is not relevant for the example
    though). If we weren''t to implement them, a runtime error would trigger, for
    example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，接口所需的抽象方法必须在具体类中实现（尽管实际实现对于本例来说并不相关）。如果我们不实现它们，就会触发运行时错误，例如：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is some resemblance to the SRP, but the main difference is that here we
    are talking about interfaces, so it is an abstract definition of behavior. There
    is no reason to change because there is nothing there until the interface is actually
    implemented. However, failure to comply with this principle will create an interface
    that will be coupled with orthogonal functionality, and this derived class will
    also fail to comply with the SRP (it will have more than one reason to change).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这与SRP（单一责任原则）有些相似，但主要区别在于这里我们谈论的是接口，因此这是一个行为的抽象定义。没有理由改变，因为直到接口实际实现之前，那里什么都没有。然而，未能遵守这一原则将创建一个与正交功能耦合的接口，并且这个派生类也将未能遵守SRP（它将有多于一个的理由去改变）。
- en: How small should an interface be?
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口应该有多小？
- en: The point made in the previous section is valid, but it also needs a warning—avoid
    a dangerous path if it's misunderstood or taken to the extreme.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中提到的观点是有效的，但同时也需要警告——如果被误解或走向极端，会是一条危险的道路。
- en: A base class (abstract or not) defines an interface for all the other classes
    to extend it. The fact that this should be as small as possible has to be understood
    in terms of cohesion—it should do one thing. That doesn't mean it must necessarily
    have one method. In the previous example, it was by coincidence that both methods
    were doing disjointed things; hence it made sense to separate them into different
    classes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 基类（抽象或不抽象）为所有其他类定义了一个扩展它的接口。这个接口应该尽可能小，这一点必须从内聚性的角度来理解——它应该做一件事。这并不意味着它必须必然只有一个方法。在先前的例子中，两个方法都是做不相关的事情，因此将它们分开到不同的类中是有意义的。
- en: 'But it could be the case that more than one method rightfully belongs to the
    same class. Imagine that you want to provide a mixin class that abstracts certain
    logic in a context manager so that all classes derived from that mixin gain that
    context manager logic for free. As we already know, a context manager entails
    two methods: `__enter__` and `__exit__`. They must go together, or the outcome
    will not be a valid context manager at all!'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但也可能存在多个方法合理地属于同一个类。想象一下，你想要提供一个混合类，该类抽象了上下文管理器中的某些逻辑，以便所有从该混合类派生的类都能免费获得上下文管理器逻辑。正如我们已经知道的，上下文管理器涉及两个方法：`__enter__`和`__exit__`。它们必须一起使用，否则结果将根本不是一个有效的上下文管理器！
- en: Failure to place both methods in the same class will result in a broken component
    that is not only useless but also dangerous. Hopefully, this exaggerated example
    works as a counterbalance to the one in the previous section, and together you
    can get a more accurate picture of designing interfaces.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有将这两种方法放在同一个类中，会导致一个损坏的组件，不仅无用，而且危险。希望这个夸张的例子可以作为前一个章节中例子的平衡，这样你们可以更准确地了解设计接口。
- en: Dependency inversion
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置
- en: This is a really powerful idea that will come up again later when we explore
    some design patterns in *Chapter 9*, *Common Design Patterns*, and *Chapter 10*,
    *Clean Architecture*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的想法，我们将在第9章“常见设计模式”和第10章“整洁架构”中再次探讨一些设计模式时再次提到。
- en: 'The **dependency inversion principle** (**DIP**) proposes an interesting design
    principle by which we protect our code by making it independent of things that
    are fragile, volatile, or out of our control. The idea of inverting dependencies
    is that our code should not adapt to details or concrete implementations, but
    rather the other way around: we want to force whatever implementation or detail
    to adapt to our code via a sort of API.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）通过提出一种有趣的设计原则，通过使我们的代码独立于脆弱、易变或不受我们控制的事物来保护我们的代码。依赖倒置的想法是，我们的代码不应该适应细节或具体实现，而应该是相反的：我们希望强制任何实现或细节通过某种API来适应我们的代码。'
- en: Abstractions have to be organized in such a way that they do not depend on details,
    but rather the other way around—the details (concrete implementations) should
    depend on abstractions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象必须以这种方式组织，它们不依赖于细节，而应该是相反的——细节（具体实现）应该依赖于抽象。
- en: 'Imagine that two objects in our design need to collaborate, *A* and *B*. *A*
    works with an instance of *B*, but as it turns out, our module doesn''t control
    *B* directly (it might be an external library, or a module maintained by another
    team, and so on). If our code heavily depends on *B*, when this changes the code
    will break. To prevent this, we have to invert the dependency: make *B* have to
    adapt to *A*. This is done by presenting an interface and forcing our code not
    to depend on the concrete implementation of *B*, but rather on the interface we
    have defined. It is then *B*''s responsibility to comply with that interface.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的设计中需要两个对象协作，*A* 和 *B*。*A* 与 *B* 的一个实例一起工作，但结果是我们的模块并没有直接控制 *B*（它可能是一个外部库，或者由另一个团队维护的模块等）。如果我们的代码高度依赖于
    *B*，当 *B* 发生变化时，代码就会崩溃。为了防止这种情况，我们必须倒置依赖：让 *B* 适应 *A*。这是通过提供一个接口并强制我们的代码不依赖于 *B*
    的具体实现，而是依赖于我们定义的接口来实现的。然后，*B* 就有责任遵守该接口。
- en: In line with the concepts explored in previous sections, abstractions also come
    in the form of interfaces (or abstract base classes in Python).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几节中探讨的概念一致，抽象也可以以接口（或Python中的抽象基类）的形式出现。
- en: In general, we could expect concrete implementations to change much more frequently
    than abstract components. It is for this reason that we place abstractions (interfaces)
    as flexibility points where we expect our system to change, be modified, or extended
    without the abstraction itself having to be changed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们预计具体实现比抽象组件变化得更频繁。正因为如此，我们将抽象（接口）放在我们期望系统变化、修改或扩展的地方，而无需改变抽象本身。
- en: A case of rigid dependencies
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格依赖的案例
- en: 'The last part of our event''s monitoring system is to deliver the identified
    events to a data collector to be further analyzed. A naïve implementation of such
    an idea would consist of having an event streamer class that interacts with a
    data destination, for example, `Syslog`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们事件监控系统最后一部分的任务是将识别出的事件发送到数据收集器进行进一步分析。这种想法的一个简单实现可能包括一个事件流类与数据目的地交互，例如，`Syslog`：
- en: '![Picture 9](img/B16567_04_09.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片9](img/B16567_04_09.png)'
- en: 'Figure 4.9: A class that has a strong dependency on another'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：一个对另一个有强依赖的类
- en: However, this design is not very good, because we have a high-level class (`EventStreamer`)
    depending on a low-level one (`Syslog` is an implementation detail). If something
    changes in the way we want to send data to `Syslog`, `EventStreamer` will have
    to be modified. If we want to change the data destination for a different one
    or add new ones at runtime, we are also in trouble because we will find ourselves
    constantly modifying the `stream()` method to adapt it to these requirements.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种设计并不很好，因为我们有一个高级类（`EventStreamer`）依赖于一个低级类（`Syslog`是一个实现细节）。如果我们想要以我们想要的方式向`Syslog`发送数据的方式发生变化，`EventStreamer`将需要被修改。如果我们想在运行时更改数据目标或添加新的目标，我们也会遇到麻烦，因为我们将发现自己需要不断修改`stream()`方法以适应这些要求。
- en: Inverting the dependencies
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转依赖关系
- en: 'The solution to these problems is to make `EventStreamer` work with an interface,
    rather than a concrete class. This way, implementing this interface is up to the
    low-level classes that contain the implementation details:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法是让`EventStreamer`与一个接口而不是一个具体类一起工作。这样，实现这个接口的责任就交给了包含实现细节的低级类：
- en: '![Picture 10](img/B16567_04_10.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10](img/B16567_04_10.png)'
- en: 'Figure 4.10: The functionality refactored by inverting the dependencies.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：通过反转依赖关系重构的功能。
- en: Now there is an interface that represents a generic data target where data is
    going to be sent. Notice how the dependencies have now been inverted since `EventStreamer`
    does not depend on a concrete implementation of a particular data target, it does
    not have to change in line with changes on this one, and it is up to every particular
    data target to implement the interface correctly and adapt to changes if necessary.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个表示通用数据目标的界面，数据将发送到这个目标。注意，由于`EventStreamer`不依赖于特定数据目标的实现，因此它的依赖关系已经反转，它不需要随着这个目标的改变而改变，并且每个特定的数据目标都必须正确实现接口并在必要时适应变化。
- en: In other words, the original `EventStreamer` of the first implementation only
    worked with objects of type `Syslog`, which was not very flexible. Then we realized
    that it could work with any object that could respond to a `.send()` message,
    and identified this method as the interface that it needed to comply with. Now,
    in this version, `Syslog` is actually extending the abstract base class named
    `DataTargetClient`, which defines the `send()` method. From now on, it is up to
    every new type of data target (email, for instance) to extend this abstract base
    class and implement the `send()` method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，第一个实现中的原始`EventStreamer`只与`Syslog`类型的对象一起工作，这并不灵活。然后我们意识到它可以与任何可以响应`.send()`消息的对象一起工作，并确定这个方法是需要遵守的接口。现在，在这个版本中，`Syslog`实际上扩展了名为`DataTargetClient`的抽象基类，该类定义了`send()`方法。从现在起，每个新的数据目标类型（例如电子邮件）都必须扩展这个抽象基类并实现`send()`方法。
- en: 'We can even modify this property at runtime for any other object that implements
    a `send()` method, and it will still work. This is the reason why it is often
    called **dependency injection**: because the dependency can be provided (injected)
    dynamically.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在运行时修改这个属性，对于任何实现了`send()`方法的其它对象，它仍然可以正常工作。这就是为什么它通常被称为**依赖注入**：因为依赖关系可以动态提供（注入）。
- en: 'The astute reader might be wondering why this is necessary. Python is flexible
    enough (sometimes too flexible) and will allow us to provide an object like `EventStreamer`
    with any particular data target object, without this one having to comply with
    any interface because it is dynamically typed. The question is this: why do we
    need to define the abstract base class (interface) at all when we can simply pass
    an object with a `send()` method to it?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能会想知道为什么这是必要的。Python 足够灵活（有时过于灵活），它允许我们向`EventStreamer`对象提供任何特定的数据目标对象，而无需这个对象遵守任何接口，因为它具有动态类型。问题是这样的：当我们可以直接传递一个具有`send()`方法的对象时，为什么我们还需要定义抽象基类（接口）呢？
- en: In all fairness, this is true; there is actually no need to do that, and the
    program will work just the same. After all, polymorphism does not mean (or require)
    inheritance has to work. However, defining the abstract base class is a good practice
    that comes with some advantages, the first one being duck typing. Together with
    duck typing, we can mention the fact that the models become more readable—remember
    that inheritance follows the rule of **is a**, so by declaring the abstract base
    class and extending from it, we are saying that, for instance, `Syslog` is `DataTargetClient`,
    which is something users of your code can read and understand (again, this is
    duck typing).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，这是真的；实际上没有必要这样做，程序将正常工作。毕竟，多态并不意味着（或要求）继承必须工作。然而，定义抽象基类是一种良好的实践，它带来了一些优势，首先是鸭子类型。与鸭子类型一起，我们可以提到模型变得更加可读——记住，继承遵循“是”的规则，因此通过声明抽象基类并从它扩展，我们是在说，例如，`Syslog`是`DataTargetClient`，这是你的代码的用户可以阅读和理解的东西（再次强调，这是鸭子类型）。
- en: All in all, it is not mandatory to define the abstract base class, but it is
    desirable in order to achieve a cleaner design. This is one of the things this
    book is for—to help programmers avoid easy-to-make mistakes, just because Python
    is too flexible, and we can get away with it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，定义抽象基类并不是强制性的，但为了实现更干净的设计，这是可取的。这正是本书的目的之一——帮助程序员避免因为Python过于灵活而容易犯的错误，并且我们可以侥幸逃脱。
- en: Dependency injection
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'The concept explored in the previous section gave us a powerful idea: instead
    of making our code dependent on a specific and concrete implementation, let''s
    create a powerful abstraction that acts as a layer in between. In the example,
    we discussed how depending on `Syslog` would lead to a rigid design, so we created
    an interface for all clients, and decided that `Syslog` just happens to be one
    of them, because it implements the `DataTargetClient` interface. This opens up
    the door to more clients we want to add in the future: just create a new class
    that implements the interface and defines the `send` method. The design is now
    open for extension and closed for modification (we''re starting to see how the
    principles relate to each other).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中探讨的概念给我们提供了一个强大的想法：而不是让我们的代码依赖于特定的具体实现，让我们创建一个强大的抽象，它作为中间层。在示例中，我们讨论了依赖于`Syslog`会导致设计僵化，因此我们为所有客户端创建了一个接口，并决定`Syslog`恰好是其中之一，因为它实现了`DataTargetClient`接口。这为未来想要添加的更多客户端打开了大门：只需创建一个新的实现该接口并定义`send`方法的类。现在，设计是可扩展的，对修改是封闭的（我们开始看到这些原则是如何相互关联的）。
- en: Now, how would the collaboration among these objects be? In this part, we explore
    how the dependency is provided to the object that actually needs it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些对象之间的协作将如何进行？在本部分，我们探讨如何将依赖提供给真正需要它的对象。
- en: 'One way of doing it would be to just declare that the event streamer works
    by directly creating the object it needs, in this case a `Syslog`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实现它的一个方法就是直接声明事件流器通过直接创建它需要的对象来工作，在这种情况下是一个`Syslog`对象：
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, this is not a very flexible design, and it doesn''t take full advantage
    of the interface we have created. Note that this design is also harder to test:
    if you were to write a unit test for this class you would have to either patch
    the creation of the `Syslog` object or override it after it has just been created.
    If the `Syslog` has side effects at creation time (not good practice in general,
    but okay in some cases, for example, when you might want to establish a connection),
    then these side effects are carried to this initialization as well. It''s true
    that this can be overcome by using a lazy property, but the inflexibility of actually
    controlling the object we provide is still there.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种设计并不灵活，并且没有充分利用我们创建的接口。请注意，这种设计也难以测试：如果你要为这个类编写单元测试，你将不得不修补`Syslog`对象的创建，或者在它刚刚创建之后覆盖它。如果`Syslog`在创建时具有副作用（通常不是好的做法，但在某些情况下是可以接受的，例如，当你可能想要建立连接时），那么这些副作用也会带到这个初始化中。确实，这可以通过使用延迟属性来克服，但实际上控制我们提供的对象的不灵活性仍然存在。
- en: 'A better design will use dependency injection, and let the target be provided
    to the event streamer:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的设计将使用依赖注入，并让目标提供给事件流器：
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This makes use of the interface and enables polymorphism. Now we can pass any
    object that implements this interface at initialization time, and it also makes
    it more explicit that an event streamer works with this kind of object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了接口并实现了多态。现在我们可以在初始化时传递任何实现了这个接口的对象，这也更明确地表明事件流器与这类对象一起工作。
- en: As opposed to the previous case, this version is also simpler to test. If we
    don't want to deal with `Syslog` in our unit tests, we can provide a test double
    (just a new class that complies with the interface and is useful for whatever
    we need to test).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一种情况相反，这个版本也更容易测试。如果我们不想在我们的单元测试中处理`Syslog`，我们可以提供一个测试替身（只是一个符合接口的新类，对我们需要测试的内容有用）。
- en: Don't force the creation of dependencies in the initialization method. Instead,
    let your users define the dependencies in a more flexible way, by using an argument
    in the `__init__` method.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在初始化方法中强制创建依赖关系。相反，让你的用户通过在`__init__`方法中使用参数以更灵活的方式定义依赖关系。
- en: In some cases, when the objects have a more complicated initialization (more
    arguments), or there are many of them, it could be a good idea to declare the
    interaction between your objects in a dependency graph, and then let a library
    do the actual creation of the objects for you (that is, to remove the boilerplate
    of the glue code that binds different objects).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当对象有更复杂的初始化（更多参数）或有很多对象时，在依赖图中声明你的对象之间的交互可能是个好主意，然后让库为你实际创建对象（即，移除绑定不同对象的粘合代码的样板）。
- en: 'An example of such a library can be `pinject` ([https://github.com/google/pinject](https://github.com/google/pinject)),
    which lets you declare how the objects interact. In our simple example, one possibility
    would be to write the code like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的库的一个例子是`pinject` ([https://github.com/google/pinject](https://github.com/google/pinject))，它允许你声明对象之间的交互方式。在我们的简单示例中，一种可能的做法是编写如下代码：
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the same definition of our class as before, we can define a binding specification,
    which is an object that knows how the dependencies are injected. In this object,
    any method named as provide`_<dependency>` should return the dependency with that
    name as the suffix (we settled for `Syslog` in our simple example).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前对类的定义相同，我们可以定义一个绑定规范，这是一个知道如何注入依赖关系的对象。在这个对象中，任何命名为`provide_<dependency>`的方法都应该返回具有该名称后缀的依赖关系（在我们的简单示例中，我们选择了`Syslog`）。
- en: Then we create the `graph` object, which we will use to get objects with the
    dependencies already provided; for example
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建`graph`对象，我们将使用它来获取已经提供依赖关系的对象；例如
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: will give us an `event_streamer` object, whose target is an instance of `Syslog`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将给我们一个`event_streamer`对象，其目标是`Syslog`的一个实例。
- en: When you have multiple dependencies or interrelations among objects, it's probably
    a good idea to write them declarative and let a tool handle the initialization
    for you. In this case, the idea is that for these kinds of objects, we define
    how they're created in a single place, and let the tool do that for us (in that
    sense it is similar to a factory object).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有多重依赖关系或对象之间的相互关系时，将它们声明化并让工具为你处理初始化可能是个好主意。在这种情况下，我们的想法是，对于这类对象，我们在一个地方定义它们是如何被创建的，然后让工具为我们完成这个工作（从这个意义上讲，它类似于一个工厂对象）。
- en: Keep in mind that this doesn't lose the flexibility originally obtained from
    our design. The object graph is an object that knows how to build other entities
    based on the definitions made, but we still are in full control of the `EventStreamer`
    class we've created, and can use it just as before, by passing any object in the
    initialization method that complies with the required interface.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这并不会失去我们从设计中获得的原始灵活性。对象图是一个知道如何根据定义构建其他实体的对象，但我们仍然完全控制着我们创建的`EventStreamer`类，并且可以像以前一样使用它，通过在初始化方法中传递任何符合所需接口的对象。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The SOLID principles are key guidelines for good object-oriented software design.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是良好面向对象软件设计的核心指导原则。
- en: Building software is an incredibly hard task—the logic of the code is complex,
    its behavior at runtime is hard (if even possible, sometimes) to predict, requirements
    change constantly as well as the environment, and there are multiple things that
    can go wrong.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件是一项极其困难的任务——代码的逻辑复杂，其运行时的行为难以预测（有时甚至不可能），需求不断变化，环境也在变化，而且有多个可能出错的地方。
- en: In addition, there are multiple ways of constructing software with different
    techniques, paradigms, or tools, which can work together to solve a particular
    problem in a specific manner. However, not all of these approaches will prove
    to be correct as time passes, and requirements change or evolve. However, by this
    time, it will already be too late to do something about an incorrect design, as
    it is rigid, inflexible, and therefore hard to change a refactor into the proper
    solution.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有多种不同的技术、范式或工具构建软件的方法，它们可以协同工作，以特定方式解决特定问题。然而，随着时间的推移，并非所有这些方法都会证明是正确的，因为需求会变化或发展。然而，到那时，对于错误的设计，已经太晚去做出改变了，因为它是僵化的、缺乏弹性的，因此很难将其重构为正确的解决方案。
- en: This means that, if we get the design wrong, it will cost us a lot in the future.
    How can we then achieve a good design that will eventually pay off? The answer
    is that we do not know for sure. We are dealing with the future, and the future
    is uncertain—there is no way to determine if our design will be correct and if
    our software will be flexible and adaptable for years to come. It is precisely
    for that reason that we have to stick to principles.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们设计错误，将来会付出很大的代价。那么我们如何才能实现一个最终会带来回报的良好设计呢？答案是，我们并不确定。我们正在处理未来，未来是不确定的——没有办法确定我们的设计是否正确，我们的软件是否将在未来几年内保持灵活和适应性强。正是出于这个原因，我们必须坚持原则。
- en: This is where the SOLID principles come into play. They are not a magic rule
    (after all, there are no silver bullets in software engineering), but they provide
    good guidelines to follow that have been proven to work in past projects and will
    make our software much more likely to succeed. The idea isn't to get all the requirements
    right from the very first version, but to achieve a design that's extensible and
    flexible enough to change, so that we can adapt it as needed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里，SOLID原则发挥了作用。它们不是一条魔法规则（毕竟，在软件工程中没有银弹），但它们提供了良好的指导方针，这些方针在过去的项目中已被证明是有效的，并将使我们的软件更有可能成功。我们的目标不是从第一个版本就完全正确地满足所有需求，而是实现一个可扩展和灵活的设计，足以适应变化，这样我们就可以根据需要对其进行调整。
- en: In this chapter, we have explored the SOLID principles with the goal of understanding
    clean design. In the following chapters, we will continue to explore details of
    the language, and see in some cases how these tools and features can be used with
    these principles.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了SOLID原则，目的是为了理解清晰的设计。在接下来的章节中，我们将继续探讨语言的具体细节，并在某些情况下看看这些工具和特性如何与这些原则结合使用。
- en: '*Chapter 5*, *Using Decorators to Improve Our Code*, explores how we can improve
    our code by taking advantage of decorators. Unlike this chapter, which was more
    focused on abstract ideas of software engineering, *Chapter 5*, *Using Decorators
    to Improve Our Code*, will be more Python-focused, but we''ll use the principles
    we''ve just learned.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*第五章*，*利用装饰器改进我们的代码*，探讨了如何通过利用装饰器来改进我们的代码。与本章更侧重于软件工程的抽象概念不同，*第五章*，*利用装饰器改进我们的代码*将更侧重于Python，但我们仍将使用我们刚刚学到的原则。'
- en: References
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Here is a list of information you may refer to:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份你可能需要参考的信息列表：
- en: '*SRP 01*: *The Single Responsibility Principle* ([https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html](https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html))'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SRP 01*：*单一职责原则*([https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html](https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html))'
- en: '*PEP-3119*: *Introducing Abstract Base Classes* ([https://www.python.org/dev/peps/pep-3119/](https://www.python.org/dev/peps/pep-3119/))'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-3119*：*引入抽象基类*([https://www.python.org/dev/peps/pep-3119/](https://www.python.org/dev/peps/pep-3119/))'
- en: '*Object-Oriented Software Construction*, *Second Edition*, written by *Bertrand
    Meyer*'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向对象软件构造*，*第二版*，由*伯特兰·迈耶*编写'
- en: '*LISKOV 01*: A paper written by *Barbara Liskov* called *Data Abstraction and
    Hierarchy* ([https://www.cs.tufts.edu/~nr/cs257/archive/barbara-liskov/data-abstraction-and-hierarchy.pdf](https://www.cs.tufts.edu/~nr/cs257/archive/barbara-liskov/data-abstraction-and-hierarchy.pdf))'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LISKOV 01*：由*芭芭拉·利斯科夫*撰写的论文*数据抽象与层次结构*([https://www.cs.tufts.edu/~nr/cs257/archive/barbara-liskov/data-abstraction-and-hierarchy.pdf](https://www.cs.tufts.edu/~nr/cs257/archive/barbara-liskov/data-abstraction-and-hierarchy.pdf))'
