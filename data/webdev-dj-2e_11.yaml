- en: 11\. Advanced Templating and Class-Based Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 高级模板和基于类的视图
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to use Django's templating API to create
    custom template tags and filters. You will also write **class-based views** that
    will help you perform CRUD operations. By the end of this chapter, you will have
    a clear understanding of how Django handles advanced templating and how you can
    build custom views that support CRUD-based operations. You will be able to use
    classes to define views inside Django and be able to build custom tags and filters
    to complement the powerful templating engine provided by Django.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用 Django 的模板 API 创建自定义模板标签和过滤器。你还将编写 **基于类的视图**，这将帮助你执行 CRUD 操作。到本章结束时，你将清楚地了解
    Django 如何处理高级模板，以及你如何构建支持 CRUD 操作的自定义视图。你将能够使用类在 Django 中定义视图，并能够构建自定义标签和过滤器来补充
    Django 提供的强大模板引擎。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In *Chapter 3*, *URL Mapping, Views, and Templates*, we learned how to build
    views and create templates in Django. Then, we learned how to use those views
    to render the templates we built. In this chapter, we will build upon our knowledge
    of developing views by using `if-else` conditions to successfully handle the different
    types of HTTP request methods. In contrast, class-based views allow us to define
    separate methods for every HTTP request method we want to handle. Then, based
    on the type of request received, Django takes care of calling the correct method
    in the class-based view.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 章*，*URL 映射、视图和模板* 中，我们学习了如何在 Django 中构建视图和创建模板。然后，我们学习了如何使用这些视图来渲染我们构建的模板。在本章中，我们将通过使用
    `if-else` 条件来构建视图的知识，成功处理不同类型的 HTTP 请求方法。相比之下，基于类的视图允许我们为每个我们想要处理的 HTTP 请求方法定义单独的方法。然后，根据接收到的请求类型，Django
    会负责调用基于类的视图中的正确方法。
- en: Beyond the ability to build views based on different development techniques,
    Django also comes packed with a powerful templating engine. This engine allows
    developers to build reusable templates for their web applications. This reusability
    of the templating engine is further enhanced by using **template tags** and **filters**,
    which help easily implement commonly used features inside templates, features
    such as iterating over lists of data, formatting the data in a given style, extracting
    a piece of text from a variable to display, and overriding the content in a specific
    block of a template. All these features also expand the reusability of a Django
    template.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅能够根据不同的开发技术构建视图，Django 还内置了一个强大的模板引擎。这个引擎允许开发者为他们的网络应用程序构建可重用的模板。通过使用 **模板标签**
    和 **过滤器**，这种模板引擎的可重用性得到了进一步增强，它们有助于在模板中轻松实现常用功能，例如遍历数据列表、以特定样式格式化数据、从变量中提取文本以显示，以及覆盖模板特定块的内容。所有这些功能也扩展了
    Django 模板的可重用性。
- en: As we go through this chapter, we will look at how we can expand the default
    set of template filters and template tags provided by Django by leveraging Django's
    ability to define our own custom template tags and filters. These custom template
    tags and filters can then be used to implement some common features in a reusable
    fashion across our web application. For example, while building a user profile
    badge that can be shown in several places inside a web application, it is better
    to leverage the ability to write a custom template inclusion tag that just inserts
    the template of the badge in any of the views we desire, rather than rewriting
    the entire code for the badge template or by introducing additional complexity
    to the templates.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习本章内容的过程中，我们将探讨如何通过利用 Django 定义自定义模板标签和过滤器的能力来扩展 Django 提供的默认模板过滤器和模板标签集。这些自定义模板标签和过滤器可以以可重用的方式在我们的网络应用程序中实现一些常见功能。例如，在构建可以在网络应用程序的多个位置显示的用户个人资料徽章时，利用编写自定义模板包含标签的能力，只需将徽章模板插入我们想要的任何视图中，而不是重写整个徽章模板的代码或引入模板的额外复杂性，这会更好。
- en: Template Filters
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板过滤器
- en: While developing templates, developers often just want to change the value of
    a template variable before rendering it to the user. For example, consider that
    we are building a profile page for a Bookr user. There, we want to show the number
    of books the user has read. Below that, we also want to show a table listing the
    books they have read.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模板时，开发者通常只想在将模板变量渲染给用户之前更改其值。例如，考虑我们正在为 Bookr 用户构建一个个人资料页面。在那里，我们想显示用户已阅读的书籍数量。下面，我们还想显示一个列出他们已阅读的书籍的表格。
- en: 'To achieve this, we can pass two separate variables from our view to the HTML
    template. One can be named `books_read`, which denotes the number of books read
    by the user. The other can be `book_list`, containing the list of names of the
    books read by the user, for example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们可以从我们的视图传递两个独立的变量到HTML模板中。一个可以命名为`books_read`，表示用户阅读的书籍数量。另一个可以是`book_list`，包含用户阅读的书籍名称列表，例如：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Or we can use **Template filters**. Template filters in Django are simple Python-based
    functions that accept a variable as an argument (and any additional data in the
    context of the variable), change its value as per our requirements, and then render
    the changed value.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用**模板过滤器**。Django中的模板过滤器是简单的基于Python的函数，它接受一个变量作为参数（以及变量上下文中的任何附加数据），根据我们的要求更改其值，然后渲染更改后的值。
- en: 'Now, the same outcome from writing the previous snippet can also be obtained
    without the use of two separate variables by using template filters in Django,
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过使用Django中的模板过滤器，我们可以不使用两个独立的变量就获得前面代码片段的相同结果，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we used the built-in `length` filter provided by Django. The use of this
    filter causes the length of the `book_list` variable to be evaluated and returned,
    which is then inserted into our HTML template during rendering.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了Django提供的内置`length`过滤器。使用此过滤器会导致`book_list`变量的长度被评估并返回，然后在渲染过程中将其插入到我们的HTML模板中。
- en: Like `length`, there are a lot of other template filters that come pre-packaged
    with Django and that are ready to be used. For example, the `lowercase` filter
    converts the text to all lowercase format, the `last` filter can be used to return
    the last item in the list, and the `json_script` filter can be used to output
    a Python object passed to the template as a JSON value wrapped in a `<script>`
    tag in your template.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与`length`一样，Django还预包装了许多其他模板过滤器，可以直接使用。例如，`lowercase`过滤器将文本转换为全部小写格式，`last`过滤器可以用来返回列表中的最后一个项目，而`json_script`过滤器可以用来输出作为JSON值包裹在`<script>`标签中的传递给模板的Python对象。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can refer to Django''s official documentation for the complete list of
    template filters offered by Django: [https://docs.djangoproject.com/en/3.1/ref/templates/builtins/](https://docs.djangoproject.com/en/3.1/ref/templates/builtins/).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考Django的官方文档以获取Django提供的完整模板过滤器列表：[https://docs.djangoproject.com/en/3.1/ref/templates/builtins/](https://docs.djangoproject.com/en/3.1/ref/templates/builtins/)。
- en: Custom Template Filters
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义模板过滤器
- en: Django supplies a lot of useful filters that we can use in our templates while
    we are working on our projects. But what if someone wants to format a specific
    piece of text and render it with different fonts? Or say if someone wants to translate
    an error code to a user-friendly error message based on the mapping of the error
    code in the backend. In these cases, predefined filters do not suffice, and we
    would like to write our own filter that we can reuse across the project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Django为我们提供了许多有用的过滤器，我们可以在项目开发过程中使用。但如果有人想要格式化一段特定的文本并使用不同的字体渲染它？或者如果有人想要根据后端中错误代码的映射将错误代码翻译成用户友好的错误消息。在这些情况下，预定义的过滤器不足以满足需求，我们希望编写自己的过滤器，以便在整个项目中重用。
- en: Luckily, Django supplies an easy-to-use API that we can use to write custom
    filters. This API provides developers with some useful decorator functions that
    can be used to quickly register a Python function as a custom template filter.
    Once a Python function is registered as a custom filter, a developer can start
    using the function in templates.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Django提供了一个易于使用的API，我们可以用它来编写自定义过滤器。这个API为开发者提供了一些有用的装饰器函数，可以用来快速将Python函数注册为自定义模板过滤器。一旦Python函数被注册为自定义过滤器，开发者就可以开始在模板中使用该函数。
- en: 'An instance of this `template` library method is required to access these filters.
    This instance can be created by instantiating the `Library()` class in Django
    from Django''s `template` module, as shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 访问这些过滤器需要一个`template`库方法的实例。这个实例可以通过从Django的`template`模块中实例化`Library()`类来创建，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the instance is created, we can now use the filter decorator from the template
    library instance to register our filters.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了实例，我们现在可以使用模板库实例中的过滤器装饰器来注册我们的过滤器。
- en: Template Filters
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板过滤器
- en: To create custom template filters, there are a couple of steps we need to take.
    Let's try to understand what these steps are and how they help us with the creation
    of a custom template filter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义模板过滤器，我们需要采取几个步骤。让我们尝试理解这些步骤以及它们如何帮助我们创建自定义模板过滤器。
- en: Setting Up the Directory for Storing Template Filters
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置存储模板过滤器的目录
- en: It is important to note that when creating a custom template filter or template
    tag, we need to put them in a directory named `templatetags` under the application
    directory. This requirement arises because Django is internally configured to
    look for custom template tags and filters when loading a web application. A failure
    to name the directory as `templatetags` will result in Django not loading the
    custom template filters and tags created by us.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在创建自定义模板过滤器或模板标签时，我们需要将它们放在应用程序目录下的名为`templatetags`的目录中。这个要求是因为Django内部配置为在加载Web应用程序时寻找自定义模板标签和过滤器。如果目录名称不是`templatetags`，将导致Django无法加载我们创建的自定义模板过滤器和标签。
- en: 'To create this directory, first, navigate to the application folder inside
    which you want to create custom template filters, and then run the following command
    in the terminal:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此目录，首先，导航到您想要创建自定义模板过滤器的应用程序文件夹内，然后在终端中运行以下命令：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the directory is created, the next step is to create a new file inside
    the `templatetags` directory to store the code for our custom filters. This can
    be done by executing the following command inside the `templatetags` directory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了目录，下一步是在`templatetags`目录内创建一个新的文件来存储我们的自定义过滤器的代码。这可以通过在`templatetags`目录内执行以下命令来完成：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The aforementioned command won't work on Windows. You can, however, navigate
    to the desired directory and create a new file using Windows Explorer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在Windows上无法工作。然而，您可以使用Windows Explorer导航到所需的目录并创建一个新文件。
- en: Alternatively, this can be done by using the GUI interface provided by PyCharm.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用PyCharm提供的GUI界面来完成此操作。
- en: Setting Up the Template Library
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置模板库
- en: 'Once the file for storing the code for the custom filter is created, we can
    now start working on implementing our custom filter code. For custom filters to
    work in Django, they need to be registered to Django''s template library before
    they can be used inside templates. To that end, the first step is to set up an
    instance of the template library, which will be used to register our custom filters.
    For this, inside the `custom_filters.py` file we created in the previous section,
    we first need to import the template module from the Django project:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了存储自定义过滤器代码的文件，我们现在可以开始实现我们的自定义过滤器代码。为了在Django中使用自定义过滤器，它们需要在模板中使用之前注册到Django的模板库中。为此，在上一节中创建的`custom_filters.py`文件中，我们首先需要从Django项目中导入模板模块：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the import is resolved, the next step is to create an instance of the
    template library by adding the following line of code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入被解决，下一步是创建模板库的实例，通过添加以下代码行：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Library` class from Django's template module is implemented as a **Singleton**
    class that returns the same object that is only initialized once at the start
    of the application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Django模板模块中的`Library`类实现为一个**单例**类，它在应用程序开始时只初始化一次并返回相同的对象。
- en: Once the template library instance is set up, we are now good to proceed with
    implementing our custom filter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了模板库实例，我们现在可以继续实现我们的自定义过滤器。
- en: Implementing the Custom Filter Function
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义过滤器函数
- en: 'Custom filters inside Django are nothing more than simple Python functions
    that essentially take the following parameters:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Django中的自定义过滤器实际上只是简单的Python函数，本质上需要以下参数：
- en: The value on which the filter is being applied (mandatory)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤器应用的价值（必需）
- en: Any additional parameters (zero or more) that need to be passed to the filter (optional)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要传递给过滤器的任何附加参数（零个或多个）（可选）
- en: 'To behave as template filters, these functions need to be decorated with the
    `filter` attribute from Django''s template library instance. For example, the
    generic implementation of a custom filter will look like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了作为模板过滤器工作，这些函数需要使用Django模板库实例的`filter`属性进行装饰。例如，自定义过滤器的通用实现将如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this, we have learned the basics of how to implement custom filters. Before
    we head to our first exercise, let's quickly learn how to use them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经学习了如何实现自定义过滤器的基础知识。在我们开始第一个练习之前，让我们快速学习如何使用它们。
- en: Using Custom Filters inside Templates
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中使用自定义过滤器
- en: 'Once the filter is created, it''s simple to start using it inside our templates.
    To do that, the filter first needs to be imported into the template. This can
    be easily done by adding the following line to the top of the template file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了过滤器，就可以简单地在我们的模板中使用它。为此，过滤器首先需要被导入到模板中。这可以通过在模板文件顶部添加以下行轻松完成：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When Django's templating engine is parsing the template files, the preceding
    line is automatically resolved by Django to find the correct module specified
    under the `templatetags` directory. Consequently, all the filters mentioned inside
    the `custom_filter` module are automatically made available inside the template.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Django 的模板引擎解析模板文件时，前一行会自动由 Django 解析以找到在 `templatetags` 目录下指定的正确模块。因此，`custom_filter`
    模块中提到的所有过滤器都会自动在模板中可用。
- en: 'Using our custom filter inside the template is as simple as adding the following
    line:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中使用我们的自定义过滤器就像添加以下行一样简单：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Equipped with this knowledge, let's now create our first custom filter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有了这些知识，现在让我们创建我们的第一个自定义过滤器。
- en: 'Exercise 11.01: Creating a Custom Template Filter'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.01：创建自定义模板过滤器
- en: 'In this exercise, you will write a custom filter named `explode`, which, when
    provided with a string and a user-supplied separator, returns a list of strings.
    For example, consider the following string:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个名为 `explode` 的自定义过滤器，当提供一个字符串和一个用户提供的分隔符时，它会返回一个字符串列表。例如，考虑以下字符串：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will apply the following filter to this string:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将应用以下过滤器到这个字符串上：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output after applying this filter should be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此过滤器后的输出应如下所示：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a new application inside the `bookr` project that you can use for demo purposes:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bookr` 项目内创建一个新的应用程序，你可以用它来进行演示：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding command will set up a new application inside your Django project.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令将在你的 Django 项目中设置一个新的应用程序。
- en: 'Now, create a new directory named `templatetags` inside your `filter_demo`
    application directory to store the code for your custom template filters. To create
    the directory, run the following command from inside the `filter_demo` directory
    from the terminal app or command prompt:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `filter_demo` 应用程序目录内创建一个名为 `templatetags` 的新目录来存储你的自定义模板过滤器的代码。为了创建目录，从终端应用或命令提示符中在
    `filter_demo` 目录内运行以下命令：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the directory is created, create a new file named `explode_filter.py` inside
    the `templatetags` directory.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了目录，就在 `templatetags` 目录内创建一个名为 `explode_filter.py` 的新文件。
- en: 'Open the file and add the following lines to it:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件并添加以下行：
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code creates an instance of the Django library that can be used
    to register our custom filter with Django.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码创建了一个 Django 库的实例，可以用来将我们的自定义过滤器注册到 Django 中。
- en: 'Add the following code to implement the `explode` filter:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以实现 `explode` 过滤器：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `explode` filter takes two arguments; one is `value` on which the filter
    was used, and the second is `separator` passed from the template to the filter.
    The filter will use this separator to convert the string into a list.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`explode` 过滤器接受两个参数；一个是 `value`，即过滤器所使用的值，另一个是从模板传递给过滤器的 `separator`。过滤器将使用此分隔符将字符串转换为列表。'
- en: 'With the custom filter ready, create a template where this filter can be applied.
    For this, first, create a new folder named `templates` under the `filter_demo`
    directory and then create a new file named `index.html` inside it with the following
    contents:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义过滤器准备就绪后，创建一个模板，以便应用此过滤器。为此，首先在 `filter_demo` 目录下创建一个名为 `templates` 的新文件夹，然后在其中创建一个名为
    `index.html` 的新文件，内容如下：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, with the template created, the next thing is to create a Django view that
    can render this template and pass the `name` variable to the template. For this,
    open the `views.py` file and add the following highlighted code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，模板创建完成后，接下来需要创建一个 Django 视图来渲染这个模板并将 `name` 变量传递给模板。为此，打开 `views.py` 文件并添加以下高亮代码：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now map the view to a URL that can then be used to render the results in the
    browser. To do this, create a new file named `urls.py` inside the `filter_demo`
    directory and add the following code to it:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将视图映射到一个 URL，然后可以使用该 URL 在浏览器中渲染结果。为此，在 `filter_demo` 目录内创建一个名为 `urls.py`
    的新文件，并将以下代码添加到其中：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the `filter_demo` application to the project URL mapping. To do this, open
    `urls.py` in the `bookr` project directory and add the following highlighted line
    inside `urlpatterns`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `filter_demo` 应用程序添加到项目的 URL 映射中。为此，打开 `bookr` 项目目录下的 `urls.py`，并在 `urlpatterns`
    中添加以下高亮行：
- en: '[PRE20]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, add the application under the `INSTALLED_APPS` section under `settings.py`
    of the `bookr` project:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `bookr` 项目的 `settings.py` 中的 `INSTALLED_APPS` 部分下添加应用程序：
- en: '[PRE21]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To view whether the custom filter works, run the following command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看自定义过滤器是否工作，请运行以下命令：
- en: '[PRE22]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, navigate to the following page in your browser: `http://localhost:8000/filter_demo`
    (or `127.0.0.1` instead of `localhost`).'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中导航到以下页面：`http://localhost:8000/filter_demo`（或使用 `localhost` 而不是 `127.0.0.1`）。
- en: 'This page should appear as shown in *Figure 11.1*:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此页面应显示为 *图 11.1* 所示：
- en: '![Figure 11.1: Index page displayed by using the explode filter](img/B15509_11_01.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.1：使用爆炸过滤器显示的索引页面](img/B15509_11_01.jpg)'
- en: 'Figure 11.1: Index page displayed by using the explode filter'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：使用爆炸过滤器显示的索引页面
- en: With this, we saw how we can quickly create a custom filter inside Django and
    then use it in our templates. Now, let's take a look at another type of filter,
    namely, string filters, which work solely on string type values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们看到了如何在 Django 中快速创建一个自定义过滤器，然后将其用于我们的模板中。现在，让我们看看另一种类型的过滤器，即字符串过滤器，它仅对字符串类型的值起作用。
- en: String Filters
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串过滤器
- en: In *Exercise 11.01*, *Creating a Custom Template Filter*, we built a custom
    filter, which allowed us to split a provided string with a separator and generate
    a list from it. This filter can take any kind of variable and split it as a list
    of values based on a delimiter provided. But what if we wanted to restrict our
    filter to work only with strings and not with any other type of values, such as
    integers?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *练习 11.01*，*创建自定义模板过滤器* 中，我们构建了一个自定义过滤器，它允许我们使用分隔符分割提供的字符串并从中生成一个列表。这个过滤器可以接受任何类型的变量，并根据提供的分隔符将其分割成值的列表。但如果我们想限制我们的过滤器只处理字符串，而不是任何其他类型的值，比如整数呢？
- en: To develop filters that work only on *strings*, we can use the `stringfilter`
    decorator provided by Django's template library. When the `stringfilter` decorator
    is used to register a Python method as a filter in Django, the framework ensures
    that the value being passed to the filter is converted to a string before the
    filter executes. This reduces any potential issues that may arise when non-string
    values are passed to our filter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发仅对 *字符串* 有效的过滤器，我们可以使用 Django 模板库提供的 `stringfilter` 装饰器。当使用 `stringfilter`
    装饰器将 Python 方法注册为 Django 中的过滤器时，框架确保在过滤器执行之前将传递给过滤器的值转换为字符串。这减少了当传递非字符串值给我们的过滤器时可能出现的任何潜在问题。
- en: 'The steps to implement a `     custom_filter.py` file we created in the *Setting Up the Directory for Storing
    Template Filters* section? We can add a new Python function inside it that will
    act as our string filter.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *设置存储模板过滤器目录* 部分中我们创建的 `custom_filter.py` 文件中实现步骤？我们可以在其中添加一个新的 Python 函数，该函数将作为我们的字符串过滤器。
- en: 'Before we can implement a string filter though, we first need to import the
    `stringfilter` decorator, which demarcates a custom filter function as a string
    filter. We can add this decorator by adding the following `import` statement inside
    the `custom_filters.py` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够实现字符串过滤器之前，我们首先需要导入 `stringfilter` 装饰器，该装饰器将自定义过滤器函数标记为字符串过滤器。我们可以在 `custom_filters.py`
    文件中添加以下 `import` 语句来实现这一点：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, to implement our custom string filter, the following syntax can be used:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要实现我们的自定义字符串过滤器，可以使用以下语法：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this approach, we can build as many string filters as we want and use them
    just like any other filter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以构建尽可能多的字符串过滤器，并像使用任何其他过滤器一样使用它们。
- en: Template Tags
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板标签
- en: Template tags are a powerful feature of Django's templating engine. They allow
    developers to build powerful templates by generating HTML through the evaluation
    of certain conditions and help avoid the repetitive writing of common code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 模板标签是 Django 模板引擎的一个强大功能。它们允许开发者通过评估某些条件来生成 HTML，从而构建强大的模板，并有助于避免重复编写常见代码。
- en: One example where we may use template tags is the sign up/login options in the
    navigation bar of a website. In this case, we can use template tags to evaluate
    whether the visitor on the current page is logged in. Based on that, we can render
    either a profile banner or a sign up/login banner.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能使用模板标签的一个例子是网站导航栏中的注册/登录选项。在这种情况下，我们可以使用模板标签来评估当前页面的访问者是否已登录。基于这一点，我们可以渲染一个个人横幅或注册/登录横幅。
- en: 'Tags are also a common occurrence while developing templates. For example,
    consider the following line of code, which we used to import the custom filters
    inside our templates in *Exercise 11.01*, *Creating a Custom Template Filter*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模板时，标签也是一个常见的现象。例如，考虑以下代码行，我们在 *练习 11.01*，*创建自定义模板过滤器* 中使用它来在我们的模板中导入自定义过滤器：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This uses a template tag known as `load`, which is responsible for loading the
    `explode` filter into the template. Template tags are much more powerful compared
    to filters. While filters have access only to the values they are operating on,
    template tags have access to the context of the whole template and hence they
    can be used to build a lot of complex functionalities inside a template.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个名为 `load` 的模板标签，它负责将 `explode` 过滤器加载到模板中。与过滤器相比，模板标签功能更强大。虽然过滤器只能访问它们正在操作的价值，但模板标签可以访问整个模板的上下文，因此它们可以用来在模板内构建很多复杂的功能。
- en: Let's look at the different types of template tags that are supported by Django
    and how we can build our own custom template tags.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Django 支持的模板标签的不同类型，以及我们如何构建我们自己的自定义模板标签。
- en: Types of Template Tags
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板标签类型
- en: 'Django majorly supports two types of template tags:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Django 主要支持两种类型的模板标签：
- en: '**Simple tags**: These are the tags that operate on the variable data provided
    (and any additional variables to them) and render in the same template they have
    been called in. For example, one such use case can include the rendering of a
    custom welcome message to the user based on their username or displaying the last
    login time of the user based on their username.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单标签**：这些标签在提供的变量数据（以及任何附加的变量）上操作，并在它们被调用的同一模板中渲染。例如，一个这样的用例可能包括根据用户的用户名渲染自定义欢迎消息，或者根据用户名显示用户的最后登录时间。'
- en: '**Inclusion tags**: These tags take in the provided data variables and generate
    an output by rendering another template. For example, the tag can take in a list
    of objects and iterate over them to generate an HTML list.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含标签**：这些标签接收提供的数据变量，并通过渲染另一个模板来生成输出。例如，标签可以接收一个对象列表，并遍历它们以生成一个 HTML 列表。'
- en: In the next sections, we will take a look at how we can create these different
    types of tags and use them in our application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何创建这些不同类型的标签，并在我们的应用程序中使用它们。
- en: Simple Tags
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单标签
- en: Simple tags provide a way for developers to build template tags that take in
    one or more variables from the template, process them, and return a response.
    The response returned from the template tag is used to replace the template tag
    definition provided inside the HTML template. These kinds of tags can be used
    to build several useful functionalities, for example, the parsing of dates, or
    displaying any active alerts, if there are any, that we want to show to the user.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 简单标签为开发者提供了一种构建模板标签的方法，这些标签可以从模板中接收一个或多个变量，处理它们，并返回一个响应。从模板标签返回的响应用于替换 HTML
    模板内提供的模板标签定义。这类标签可以用来构建多种有用的功能，例如，解析日期，或者显示任何我们想要向用户展示的活跃警报（如果有的话）。
- en: The simple tags can be created easily using the `simple_tag` decorator provided
    by the template library, by decorating the Python method that should act as a
    template tag. Now, let us look at how we can implement a custom simple tag using
    Django's template library.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 简单标签可以通过模板库提供的 `simple_tag` 装饰器轻松创建，通过装饰应该作为模板标签起作用的 Python 方法。现在，让我们看看如何使用
    Django 的模板库实现一个自定义简单标签。
- en: How to Create a Simple Template Tag
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何创建一个简单模板标签
- en: Creating simple template tags follows the same conventions we discussed in the
    *Custom Template Filters* section, with some subtle differences. Let us go over
    the process of understanding how template tags can be created for use in our Django templates.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建简单的模板标签遵循我们在 *自定义模板过滤器* 部分讨论的相同约定，有一些细微的差别。让我们回顾一下理解如何为在 Django 模板中使用而创建模板标签的过程。
- en: Setting Up the Directory
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置目录
- en: 'Just like custom filters, custom template tags also need to be created inside
    the same `templatetags` directory to make them discoverable by Django''s templating
    engine. The directory can be created either directly using the PyCharm GUI or
    by running the following command inside the application directory where we want
    to create our custom tags:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像自定义过滤器一样，自定义模板标签也需要在同一个 `templatetags` 目录内创建，以便让 Django 的模板引擎能够发现它们。这个目录可以直接使用
    PyCharm 图形界面创建，或者通过在我们要创建自定义标签的应用程序目录内运行以下命令来创建：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once this is done, we can now create a new file that will store the code for
    our custom template tags by using the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们现在可以创建一个新的文件来存储我们的自定义模板标签的代码，使用以下命令：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The aforementioned command won't work on Windows. You can, however, create a
    new file using Windows Explorer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在 Windows 上将无法工作。然而，您可以使用 Windows 资源管理器创建一个新文件。
- en: Setting Up the Template Library
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置模板库
- en: 'Once the directory structure is set up and we have a file in place for keeping
    the code for our custom template tags, we can now proceed and start creating our
    template tags. But before that, we need to set up an instance of Django''s template
    library as we did earlier. This can be done by adding the following lines of code
    to our `custom_tag.py` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好目录结构并且我们已经有一个文件用于存放自定义模板标签的代码，我们现在可以继续创建我们的模板标签。但在那之前，我们需要设置 Django 模板库的一个实例，就像我们之前做的那样。这可以通过向我们的
    `custom_tag.py` 文件中添加以下几行代码来完成：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Like custom filters, the template library instance is used here to register
    the custom template tags for use inside Django templates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义过滤器一样，模板库实例在这里用于注册自定义模板标签以供 Django 模板使用。
- en: Implementing a Simple Template Tag
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现简单模板标签
- en: 'Simple template tags inside Django are Python functions that can take any number
    of arguments as desired by us. These Python functions need to be decorated with
    the `simple_tag` decorator from the template library such that those functions
    are registered as simple template tags. The following snippet of code shows how
    a simple template tag is implemented:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Django 中的简单模板标签是我们想要的任何数量的参数的 Python 函数。这些 Python 函数需要使用模板库中的 `simple_tag` 装饰器进行装饰，以便这些函数被注册为简单模板标签。以下代码片段展示了如何实现一个简单模板标签：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using Simple Tags inside Templates
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模板中使用简单标签
- en: 'Using simple tags inside Django templates is quite easy. Inside the template
    file, we need to first make sure that we have the tag imported inside the template
    by adding the following to the top of the template file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Django 模板中使用简单标签相当简单。在模板文件中，我们需要首先确保我们已将标签导入到模板中，方法是在模板文件顶部添加以下内容：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding statement will load all the tags from the `custom_tag.py` file
    we defined earlier and make them available inside our template. Then we can use
    our custom simple tag by adding the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将加载我们之前定义的 `custom_tag.py` 文件中的所有标签，并在我们的模板中使它们可用。然后我们可以通过添加以下命令来使用我们的自定义简单标签：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let's put this knowledge into practice and create our first custom simple tag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个知识应用到实践中，创建我们的第一个自定义简单标签。
- en: 'Exercise 11.02: Creating a Custom Simple Tag'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.02：创建自定义简单标签
- en: 'In this exercise, you will create a simple tag that will take in two arguments:
    the first one will be a greeting message, and the second will be the name of the
    user. This tag will print a formatted greeting message:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个简单标签，它将接受两个参数：第一个将是问候消息，第二个将是用户的姓名。此标签将打印一个格式化的问候消息：
- en: 'Following up on the example shown in *Exercise 11.01*, *Creating a Custom Template
    Filter*, let us re-use the same directory structure to store the code for the
    simple tag inside. So, first, create a new file named `simple_tag.py` under the
    `filter_demo/template_tags` directory. Inside this file, add the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 *练习 11.01* 中所示的示例，*创建自定义模板过滤器*，让我们重用相同的目录结构来存储简单标签的代码。因此，首先，在 `filter_demo/template_tags`
    目录下创建一个名为 `simple_tag.py` 的新文件。在这个文件中，添加以下代码：
- en: '[PRE32]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, you create a new Python method, `greet_user()`, which takes in
    two arguments, `message`, the message to use for the greeting, and `username`,
    the name of the user who should be greeted. This method is then decorated with
    `@register.simple_tag`, which indicates that this method is a simple tag and can
    be used as a template tag in the templates.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，您创建一个新的 Python 方法 `greet_user()`，它接受两个参数，`message` 是用于问候的消息，`username`
    是要问候的用户的姓名。然后，该方法使用 `@register.simple_tag` 装饰器进行装饰，这表示该方法是一个简单标签，可以在模板中使用。
- en: 'Now, create a new template that will use your simple tag. For this, create
    a new file named `simple_tag_template.html` under the `filter_demo/templates`
    directory and add the following code to it:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的模板，该模板将使用您的简单标签。为此，在 `filter_demo/templates` 目录下创建一个名为 `simple_tag_template.html`
    的新文件，并将以下代码添加到其中：
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code snippet, you just created a bare-bones HTML page that
    will use your custom simple tag. The semantics of loading a custom template tag
    is similar to that of loading a custom template filter and requires the use of
    a `{% load %}` tag in the template. The process will look for the `simple_tag.py`
    module under the `templatetags` directory and, if found, will load the tags that
    have been defined under the module.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你只是创建了一个使用你的自定义简单标签的裸骨 HTML 页面。加载自定义模板标签的语义与加载自定义模板过滤器类似，需要在模板中使用`{%
    load %}`标签。这个过程将在`templatetags`目录下寻找`simple_tag.py`模块，如果找到，将加载在该模块下定义的标签。
- en: 'The following line shows how you can use the custom template tag:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下行显示了如何使用自定义模板标签：
- en: '[PRE34]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this, you first used Django's tag specifier, `{% %}`, and inside it, the
    first argument you passed is the name of the tag that needs to be used, followed
    by the first argument, `Hey there`, which is the greeting message, and the second
    argument, `username`, which will be passed to the template from the view function.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你首先使用了 Django 的标签指定符`{% %}`，在其中，你传递的第一个参数是需要使用的标签的名称，后面跟着第一个参数`Hey there`，这是问候信息，以及第二个参数`username`，它将从视图函数传递到模板中。
- en: 'With the template created, the next step involves creating a view that will
    render your template. For this, add the following code under the `views.py` file
    under the `filter_demo` directory:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模板后，下一步是创建一个视图来渲染你的模板。为此，在`filter_demo`目录下的`views.py`文件中添加以下代码：
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code snippet, you created a simple function-based view, which
    will render your `simple_tag_template` defined in *step 2* and pass the value
    `'jdoe'` to the variable called `username`.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你创建了一个基于简单函数的视图，它将渲染你在*步骤 2*中定义的`simple_tag_template`，并将值`'jdoe'`传递给名为`username`的变量。
- en: 'With the view created, the next step is to map it to a URL endpoint in your
    application. To do this, open the `urls.py` file under the `filter_demo` directory
    and add the following inside the `urlpatterns` list:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建视图后，下一步是将它映射到应用中的 URL 端点。为此，打开`filter_demo`目录下的`urls.py`文件，并在`urlpatterns`列表中添加以下内容：
- en: '[PRE36]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this, `greeting_view` is now mapped to the URL endpoint `/greet` for your
    `filter_demo` application.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这种方式，`greeting_view`现在被映射到你的`filter_demo`应用的 URL 端点`/greet`。
- en: 'To see the custom tag in action, start your web server by running the following command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看到自定义标签的实际效果，通过运行以下命令启动你的 web 服务器：
- en: '[PRE37]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After visiting `http://localhost:8000/filter_demo/greet` in the browser (or
    `127.0.0.1` instead of `localhost`), you should see the following page:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在浏览器中访问`http://localhost:8000/filter_demo/greet`（或使用`localhost`代替`127.0.0.1`），你应该看到以下页面：
- en: '![Figure 11.2: Greeting message generated with the help of the custom simple
    tag](img/B15509_11_02.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.2：使用自定义简单标签生成的问候信息](img/B15509_11_02.jpg)'
- en: 'Figure 11.2: Greeting message generated with the help of the custom simple
    tag'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：使用自定义简单标签生成的问候信息
- en: With this, we have created our first custom template tag and used it successfully
    to render our template, as shown in *Figure 11.2*. Now, let's look at another
    important aspect of simple tags, which is associated with passing the context
    variables available in the template to the template tag.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经创建了我们的第一个自定义模板标签，并成功将其用于渲染模板，如*图 11.2*所示。现在，让我们看看简单标签的另一个重要方面，即与将模板中可用的上下文变量传递给模板标签相关。
- en: Passing the Template Context in a Custom Template Tag
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在自定义模板标签中传递模板上下文
- en: In the previous exercise, we created a simple tag to which we passed two arguments,
    namely, the greeting message and the username. But what if we wanted to pass a
    large number of variables to the tag? Or simply, what if we did not want to pass
    the username of the user explicitly to the tag?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们创建了一个简单标签，我们向其中传递了两个参数，即问候信息和用户名。但如果我们想向标签传递大量变量呢？或者简单地说，如果我们不想明确将用户的用户名传递给标签呢？
- en: There are times when developers would like to have access to all the variables
    and data that is present in the template to be available inside the custom tag.
    Fortunately for us, this is easy to implement.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，开发者希望访问模板中所有存在的变量和数据，以便在自定义标签内部可用。幸运的是，这很容易实现。
- en: Using our previous example of the `greet_user` tag, let's create a new tag named
    `contextual_greet_user` and see how we can pass the data available in the template
    directly to the tag instead of passing it manually as an argument.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们之前的`greet_user`标签为例，让我们创建一个新的标签名为`contextual_greet_user`，并看看我们如何可以直接将模板中可用的数据传递给标签，而不是手动作为参数传递。
- en: 'The first modification we need to make is to modify our decorator to look like
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一个修改是修改我们的装饰器，使其看起来如下：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With this, we tell Django that when our `contextual_greet_user` tag is used,
    Django should also pass it the template context, which has all the data that is
    passed from the view to the template. With this addition done, the next thing
    we need to do is to change our `contextual_greet_user` implementation to accept
    the added context as an argument. The following code shows the modified form of
    the `contextual_greet_user` tag, which uses our template context to render a greeting
    message:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们告诉Django，当我们的`contextual_greet_user`标签被使用时，Django也应该传递它模板上下文，其中包含从视图传递到模板的所有数据。完成这个添加后，接下来我们需要做的是将我们的`contextual_greet_user`实现修改为接受添加的上下文作为参数。以下代码显示了修改后的`contextual_greet_user`标签形式，它使用我们的模板上下文来渲染问候消息：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code example, we can see how the `contextual_greet_user()`
    method was modified to accept the passed context as the first argument, followed
    by the greeting message passed by the user.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到`contextual_greet_user()`方法是如何修改的，以接受传递的上下文作为第一个参数，然后是用户传递的问候消息。
- en: 'To leverage this modified template tag, all we need to do is to change our
    call to the `contextual_greet_user` tag inside `simple_tag_template.html` under
    `filter_demo` to look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这个修改后的模板标签，我们只需要将`filter_demo`下的`simple_tag_template.html`中的`contextual_greet_user`标签的调用更改如下：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Then, when we reload our Django web application, the output at `http://localhost:8000/filter_demo/greet`
    should look similar to what was shown in *step 5* of *Exercise 11.02*, *Creating
    a Custom Simple Tag*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们重新加载我们的Django Web应用程序时，`http://localhost:8000/filter_demo/greet`的输出应该类似于*练习11.02*的第*5步*中显示的输出，*创建自定义简单标签*。
- en: With this, we got to know how we can build a simple tag and handle passing the
    template context to the tag. Now, let us look at how we can build an inclusion
    tag that can be used to render data in a certain format as described by another
    template.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们了解了如何构建一个简单的标签并处理将模板上下文传递给标签。现在，让我们看看如何构建一个包含标签，它可以用来以另一个模板描述的格式渲染数据。
- en: Inclusion Tags
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含标签
- en: Simple tags allow us to build tags that accept one or more input variables,
    do some processing on them, and return an output. This output is then inserted
    at the place where the simple tag was used.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 简单标签允许我们构建接受一个或多个输入变量的标签，对它们进行一些处理，并返回一个输出。然后，这个输出被插入到简单标签被使用的地方。
- en: But what if we wanted to build tags that, instead of returning text output,
    return an HTML template, which can then be used to render the parts of the page.
    For example, a lot of web applications allow users to add custom widgets to their
    profiles. These individual widgets can be built as an inclusion tag and rendered
    over independently. This kind of approach keeps the code for the base page template
    and the individual templates separate and hence allows for easy reuse as well
    as refactoring.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想构建标签，这些标签不是返回文本输出，而是返回一个HTML模板，然后可以用来渲染页面的部分。例如，许多Web应用程序允许用户向他们的个人资料添加自定义小部件。这些单独的小部件可以作为包含标签构建并独立渲染。这种方法将基础页面模板和单独的模板的代码分开，因此允许易于重用以及重构。
- en: Developing custom inclusion tags is a similar process to how we develop our
    simple tags. This involves the use of the `inclusion_tag` decorator provided by
    the template library. So, let's take a look at how we can do it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 开发自定义包含标签的过程与我们开发简单标签的过程类似。这涉及到使用模板库提供的`inclusion_tag`装饰器。因此，让我们看看我们如何做到这一点。
- en: Implementing Inclusion Tags
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现包含标签
- en: Inclusion tags are those tags that are used for rendering a template as a response
    to their usage inside a template. These tags can be implemented in a similar manner
    to how other custom template tags are implemented, with some minor modifications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 包含标签是那些在模板内部使用时作为响应渲染模板的标签。这些标签可以以与其他自定义模板标签类似的方式实现，只需进行一些小的修改。
- en: Inclusion tags are also simple Python functions that can take multiple parameters,
    where each parameter maps to an argument passed from the template where the tag
    was called. These tags are decorated using the `inclusion_tag` decorator from
    Django's template library. The `inclusion_tag` decorator takes a single parameter,
    the name of the template, which should be rendered as a response to the processing
    of the inclusion tag.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 包含标签也是简单的 Python 函数，可以接受多个参数，其中每个参数映射到从调用标签的模板传递的参数。这些标签使用 Django 模板库中的 `inclusion_tag`
    装饰器进行装饰。`inclusion_tag` 装饰器接受一个参数，即模板的名称，该名称应在包含标签的处理过程中作为响应进行渲染。
- en: 'A generic implementation of an inclusion tag will look like the one shown in
    the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 包含标签的通用实现将类似于以下代码片段所示：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice the return value in this case. An inclusion tag is supposed to return
    a dictionary of values that will be used to render the `template_file.html` file
    specified as an argument in the `inclusion_tag` decorator.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个例子中的返回值。包含标签应该返回一个字典，该字典将用于渲染 `template_file.html` 文件，该文件作为 `inclusion_tag`
    装饰器中的参数指定。
- en: Using an Inclusion Tag inside a Template
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模板中使用包含标签
- en: 'An inclusion tag can easily be used inside a template file. This can be done
    by first importing the tag as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 包含标签可以轻松地用于模板文件中。为此，首先按照以下方式导入标签：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And then by using the tag like any other tag:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过像使用其他标签一样使用该标签：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The response of the rendering of this tag will be a sub-template that will be
    rendered inside our primary template where the inclusion tag was used.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此标签的渲染响应将是一个子模板，它将在包含标签被使用的我们的主模板内进行渲染。
- en: 'Exercise 11.03: Building a Custom Inclusion Tag'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.03：构建自定义包含标签
- en: 'In this exercise, we are going to build a custom `inclusion` tag, which will
    render the list of books read by a user:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建一个自定义的 `inclusion` 标签，该标签将渲染用户阅读的书籍列表：
- en: 'For this exercise, you will continue to use the same demo folders as in earlier
    exercises. First, create a new file named `inclusion_tag.py` under the `filter_demo/templatetags`
    directory and write the following code inside it:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，你将继续使用之前练习中相同的演示文件夹。首先，在 `filter_demo/templatetags` 目录下创建一个名为 `inclusion_tag.py`
    的新文件，并在其中编写以下代码：
- en: '[PRE44]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `@register.inclusion_tag` decorator is used to mark the method as a custom
    inclusion tag. This decorator takes the name of the template as an argument that
    should be used to render the data returned by the tag function.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `@register.inclusion_tag` 装饰器来标记方法作为自定义包含标签。此装饰器接受模板名称作为参数，该参数应用于渲染标签函数返回的数据。
- en: 'After the decorator, you define a function that implements the logic of your
    custom inclusion tag. This function takes a single argument called `books`. This
    argument will be passed from the template file and will contain a list of books
    that the reader has read (in the form of a `Python` dictionary). Inside the definition,
    you convert the dictionary into a Pythonic list of book names. The key in the
    dictionary is mapped to the name of the book and the value is mapped to the author:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在装饰器之后，您定义一个函数来实现自定义包含标签的逻辑。此函数接受一个名为 `books` 的单个参数。此参数将从模板文件传递，并包含读者已阅读的书籍列表（以
    `Python` 字典的形式）。在定义内部，您将字典转换为 Pythonic 的书籍名称列表。字典中的键映射到书籍名称，值映射到作者：
- en: '[PRE45]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once the list is formed, the following code returns the list as a context for
    the template passed to the inclusion tag (in this example, `book_list.html`):'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦列表形成，以下代码将列表作为上下文返回，传递给包含标签的模板（在本例中为 `book_list.html`）：
- en: '[PRE46]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The value returned by this method will be passed by Django to the `book_list.html`
    template and the contents will then be rendered.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法返回的值将被 Django 传递给 `book_list.html` 模板，然后内容将被渲染。
- en: 'Next, create the actual template, which will contain the rendering structure
    for the template tag. For this, create a new template file, `book_list.html`,
    under the `filter_demo/templates` directory, and add the following content to
    it:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建实际的模板，它将包含模板标签的渲染结构。为此，在 `filter_demo/templates` 目录下创建一个名为 `book_list.html`
    的新模板文件，并向其中添加以下内容：
- en: '[PRE47]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, in the new template file, you created an unordered list that will hold
    the list of books a user has read. Next, using the `for` template tag, you iterate
    over the values within `book_list` that will be provided by the custom template function:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，在您创建的新模板文件中，您创建了一个无序列表，该列表将包含用户已阅读的书籍列表。接下来，使用 `for` 模板标签，您遍历 `book_list`
    中的值，这些值将由自定义模板函数提供：
- en: '[PRE48]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This iteration results in the creation of several list items, as defined by
    the following:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此迭代会产生几个列表项，如下定义：
- en: '[PRE49]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The list item is generated with the contents from `book_list`, which was passed
    to the template. The `for` tag executes as many times as the number of items present
    in `book_list`.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表项是通过从`book_list`传递的内容生成的，该内容被传递到模板中。`for`标签会根据`book_list`中项目数量执行多次。
- en: 'With the template defined for the `book_list` tag, modify the existing greeting
    template to make this tag available inside it and use it to show a list of books
    that the user has read. For this, modify the `simple_tag_template.html` file under
    the `filter_demo/templates` directory and change the code to look as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`book_list`标签定义了模板后，修改现有的问候模板，使其内部可用此标签，并使用它来显示用户已阅读的书籍列表。为此，修改`filter_demo/templates`目录下的`simple_tag_template.html`文件，并将代码修改如下：
- en: '[PRE50]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this snippet, the first thing you did was load the `inclusion_tag` module
    by writing the following:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个片段中，您首先通过编写以下代码加载了`inclusion_tag`模块：
- en: '[PRE51]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the tag is loaded, you can now use it anywhere in the template. To use
    it, you added the `book_list` tag in the following format:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标签加载后，您现在可以在模板的任何位置使用它。要使用它，您以以下格式添加了`book_list`标签：
- en: '[PRE52]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This tag takes a single argument, which is a dictionary of the books, inside
    which the key is the book title and the value of the key is the author of the
    book. At this point, you can even customize the greeting message; in this step,
    we have gone with a simple "`Hey`" instead of "`Hey there`".
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此标签接受一个参数，即包含书籍的字典，其中键是书籍标题，键的值是书籍的作者。在此阶段，您甚至可以自定义问候信息；在这个步骤中，我们选择了简单的"`Hey`"而不是"`Hey
    there`"。
- en: 'With the template now modified, the final step involves passing the required
    data to the template. To achieve this, modify `views.py` in the `filter_demo`
    directory and change the greeting view function to look like this:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板现在已修改，最后一步是将所需数据传递给模板。为了实现这一点，修改`filter_demo`目录下的`views.py`文件，并将问候视图函数修改如下：
- en: '[PRE53]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, you modified the `greeting_view` function to add a dictionary of books
    and their authors and then you passed it to the `simple_tag_template` context.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，您修改了`greeting_view`函数，添加了书籍及其作者的字典，并将其传递给`simple_tag_template`上下文。
- en: 'With the preceding changes implemented, it''s time to render the modified template.
    To do this, restart your Django application server by running the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实施上述更改后，现在是时候渲染修改后的模板了。为此，通过运行以下命令重新启动您的Django应用程序服务器：
- en: '[PRE54]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Navigate to `http://localhost:8080/filter_demo/greet`, which should now render
    a page similar to the following screenshot:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:8080/filter_demo/greet`，现在应该会渲染一个类似于以下截图的页面：
- en: '![Figure 11.3: List of books read by a user when they visit the greeting endpoint](img/B15509_11_03.jpg)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图11.3：用户访问问候端点时阅读的书籍列表](img/B15509_11_03.jpg)'
- en: 'Figure 11.3: List of books read by a user when they visit the greeting endpoint'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：用户访问问候端点时阅读的书籍列表
- en: The page shows the list of books read by a user when they visit the greeting
    endpoint. The list you see on the page is rendered using inclusion tags. The template
    for listing these books is created separately first and then, using the inclusion
    tag, it is added to the page.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 页面显示了用户访问问候端点时阅读的书籍列表。您在页面上看到的列表是使用内联标签渲染的。首先单独创建列出这些书籍的模板，然后使用内联标签将其添加到页面上。
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Our work with the `filter_demo` app is complete. You can continue to customize
    this app further if you wish to practice the concepts you learned. Since the app
    was created solely to explain the concepts of custom template filters and template
    tags, and is unrelated to the `bookr` app we're building, you won't find it included
    in the `final/bookr` application folder on the GitHub repository.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`filter_demo`应用程序的工作已经完成。如果您想进一步定制此应用程序以练习您学到的概念，您可以继续这样做。由于该应用程序仅用于解释自定义模板过滤器和模板标签的概念，并且与我们要构建的`bookr`应用程序无关，因此您不会在GitHub存储库的`final/bookr`应用程序文件夹中找到它。
- en: With this, we now have the foundations on which we can build highly complex
    template filters or custom tags that can be helpful in the development of the
    projects we want to work on.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有了构建高度复杂的模板过滤器或自定义标签的基础，这些标签可以帮助我们开发想要工作的项目。
- en: Now, let's revisit Django views and dive into a new territory of views called
    **Class-Based Views**. Provided by Django, these help us leverage the power of
    object-oriented programming and allow the re-use of code for the rendering of
    a view.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新审视Django视图，并深入到一个新的视图领域，称为**基于类的视图**。由Django提供，这些视图帮助我们利用面向对象编程的力量，并允许代码的重用以渲染视图。
- en: Django Views
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django视图
- en: To recall, a view in Django is a piece of Python code that allows a request
    to be taken in, performs an action based on the request, and then returns a response
    to the user, and hence forms an important part of our Django applications.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Django中的视图是一段Python代码，它允许接收请求，根据请求执行操作，然后向用户返回响应，因此构成了我们Django应用程序的重要部分。
- en: 'Inside Django, we have the option of building our views by following two different
    methodologies, one of which we have already seen in the preceding examples and
    is known as function-based views, while the other one, which we will be covering
    soon, is known as class-based views:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django内部，我们有两种不同的方法来构建我们的视图，其中一种我们在前面的示例中已经看到，被称为基于函数的视图，而另一种我们很快就会介绍，被称为基于类的视图：
- en: '`HTTPRequest` type object as their first positional parameter and return an
    `HTTPResponse` type object, which corresponds to the action the view wants to
    perform once the request is processed by it. In the preceding exercise, `index()`
    and `greeting_view()` were examples of FBVs.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPRequest`类型对象作为它们的第一位置参数，并返回一个`HTTPResponse`类型对象，这对应于视图在处理请求后想要执行的操作。在前面的练习中，`index()`和`greeting_view()`是FBV的例子。'
- en: '**Class-Based Views** (**CBVs**): CBVs are views that closely adhere to the
    Python object-oriented principles and allow mapping of the view calls in a class-based
    representation. These views are specialized in nature and a given type of CBV
    performs a specific operation. The benefits that CBVs provide include easy extensibility
    of the view and the re-use of code, which may turn out to be a complex task with
    FBVs.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于类的视图**（**CBV**）：CBV是紧密遵循Python面向对象原则的视图，并允许在基于类的表示中映射视图调用。这些视图在本质上具有专业性，并且给定的CBV执行特定的操作。CBV提供的优势包括视图的易于扩展性和代码的重用，这在FBV中可能是一个复杂的任务。'
- en: Now, with the basic definitions clear, and with knowledge of FBVs already in
    our arsenal, let's look at CBVs and see what they have in store for us.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基本定义已经明确，并且我们已经掌握了FBV的知识，让我们来看看CBV（基于类的视图）并看看它们为我们准备了什么。
- en: Class-Based Views
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于类的视图
- en: Django provides different ways in which developers can write views for their
    applications. One way is to map a Python function to act as a view function to
    create FBVs. Another way of creating views is to use Python object instances (which
    are based on top of Python classes). These are known as CBVs. An important question
    that arises is, what is the need for a CBV when we can already create views using
    the FBV approach?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了不同的方式，让开发者可以为他们的应用程序编写视图。一种方式是将Python函数映射为视图函数以创建FBV。另一种创建视图的方式是使用基于Python类的Python对象实例。这些被称为CBV。一个重要的问题是，当我们已经可以使用FBV方法创建视图时，为什么还需要CBV？
- en: The idea here, when creating FBVs, is that at times, we may be replicating the
    same logic again and again, for example, the processing of certain fields, or
    logic for handling certain request types. Although it is completely possible to
    create logically separate functions that handle a particular piece of logic, the
    task becomes difficult to manage as the complexity of the application increases.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建FBV（基于函数的视图）时，我们的想法是，有时我们可能需要反复复制相同的逻辑，例如处理某些字段或处理某些请求类型的逻辑。尽管创建逻辑上分离的函数来处理特定的逻辑是完全可能的，但随着应用程序复杂性的增加，这项任务变得难以管理。
- en: 'This is where CBVs come in handy, where they abstract away implementation of
    the common repetitive code that we need to write to handle certain tasks, such
    as the rendering of templates. At the same time, they also make it easy to re-use
    pieces of code through the use of inheritance and mix-ins. For example, the following
    code snippet shows the implementation of a CBV:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是CBV（基于类的视图）派上用场的地方，它们抽象出了我们需要编写的常见重复代码的实现，例如模板的渲染。同时，它们也通过使用继承和混入使代码的重用变得容易。例如，以下代码片段显示了CBV的实现：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding example, we built a simple CBV by inheriting from the built-in
    view class, which is provided by Django.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们通过继承Django提供的内置视图类构建了一个简单的CBV。
- en: 'Using these CBVs is also quite easy. For example, let''s say we wanted to map
    `IndexView` to a URL endpoint in our application. In this case, all we need to
    do is to add the following line to our `urlpatterns` list inside the `urls.py`
    file of the application:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些CBV（基于类的视图）也很简单。例如，假设我们想在应用程序中将`IndexView`映射到一个URL端点。在这种情况下，我们只需要在应用程序的`urls.py`文件中的`urlpatterns`列表中添加以下行：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this, as we can observe, we used the `as_view()` method of the CBV we created.
    Every CBV implements the `as_view()` method, which allows the view class to be
    mapped to a URL endpoint by returning the instance of the view controller from
    the view class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，正如我们可以观察到的，我们使用了CBV的`as_view()`方法。每个CBV都实现了`as_view()`方法，这使得视图类可以通过返回视图控制器实例来映射到URL端点。
- en: 'Django provides a couple of built-in CBVs that provide the implementation of
    a lot of common tasks, such as how to render a template, or how to process a particular
    request. The built-in CBVs help to avoid the rewriting of code from scratch when
    handling basic functionality, thereby enabling the reusability of code. Some of
    these in-built views include the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一些内置的CBV，它们提供了许多常见任务的实现，例如如何渲染模板，或者如何处理特定的请求。内置的CBV有助于在处理基本功能时避免从头开始重写代码，从而实现代码的可重用性。以下是一些内置视图的示例：
- en: '`Request` methods, such as `GET`, `POST`, `PUT`, and `DELETE`, and the view
    will automatically delegate the call to the method that is responsible for handling
    the request based on the type of request received.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`请求`方法，例如`GET`、`POST`、`PUT`和`DELETE`，视图将自动根据接收到的请求类型委托给负责处理该请求的方法。'
- en: '**TemplateView**: A view that can be used to render a template based on the
    parameters for the template data provided in the URL of the call. This allows
    developers to easily render a template without writing any logic related to how
    the rendering should be handled.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TemplateView**：一个视图，可以根据调用URL中提供的模板数据参数来渲染模板。这允许开发者轻松渲染模板，而无需编写任何与渲染处理相关的逻辑。'
- en: '**RedirectView**: A view that can be used to automatically redirect a user
    to the correct resource based on the request they have made.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RedirectView**：一个视图，可以根据用户请求自动将用户重定向到正确的资源。'
- en: '**DetailView**: A view that is mapped to a Django model and can be used to
    render the data obtained from the model using a template of choice.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DetailView**：一个映射到Django模型并可以使用选择的模板渲染从模型获取的数据的视图。'
- en: The preceding views are just some of the built-in views that Django provides
    by default and we will cover more of them as we move through the chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的视图只是Django默认提供的内置视图的一部分，随着我们进入本章，我们将介绍更多。
- en: Now, to better understand how CBVs work inside Django, let's try to build our
    first CBV.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地理解CBV在Django中的工作方式，让我们尝试构建我们的第一个CBV。
- en: 'Exercise 11.04: Creating a Book Catalog Using a CBV'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.04：使用CBV创建图书目录
- en: In this exercise, you will create a class-based form view that will help build
    a book catalog. This catalog will consist of the name of the book and the name
    of the author of the book.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个基于类的表单视图，这将帮助你构建一个图书目录。这个目录将包括书的名称和书的作者名称。
- en: Note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To understand the concept of class-based views, we will create a separate application
    inside Bookr with its own set of models and forms such that our existing code
    from previous exercises is not affected. Just like `filter_demo`, we won't be
    including this app in the `final/bookr` folder on our GitHub repo.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解类视图的概念，我们将在Bookr中创建一个单独的应用程序，它有自己的模型和表单，这样我们的现有代码就不会受到影响。就像`filter_demo`一样，我们不会将此应用程序包含在我们的GitHub仓库的`final/bookr`文件夹中。
- en: 'To get started, create a new application inside our `bookr` project and name
    it `book_management`. This can be done by simply running the following command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，在我们的`bookr`项目中创建一个新的应用程序，并将其命名为`book_management`。这可以通过简单地运行以下命令来完成：
- en: '[PRE57]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, before building the book catalog, you first need to define a Django model
    that will help you store the records inside the database. To do this, open the
    `models.py` file under the `book_management` app you just created and define a
    new model named `Book`, as shown here:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在构建图书目录之前，你首先需要定义一个Django模型，这将帮助你将记录存储在数据库中。为此，打开你刚刚创建的`book_management`应用下的`models.py`文件，并定义一个新的名为`Book`的模型，如下所示：
- en: '[PRE58]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The model contains two fields, the name of the book and the name of the author.
    With the model in place, you'll need to migrate the model to your database such
    that you can start storing your data inside the database.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模型包含两个字段，即书名和作者名。有了模型，你需要将其迁移到数据库中，这样你就可以开始在数据库中存储你的数据。
- en: 'Once all the preceding steps are complete, add your book_management application
    to the `INSTALLED_APPS` list such that it can be discovered by Django and you
    can use your model properly. For this, open the `settings.py` file under the bookr
    directory and add the following code at the final position in the `INSTALLED_APPS`
    section:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成所有前面的步骤，将你的`book_management`应用程序添加到`INSTALLED_APPS`列表中，这样Django就可以发现它，你就可以正确使用你的模型。为此，打开`bookr`目录下的`settings.py`文件，并在`INSTALLED_APPS`部分的最后位置添加以下代码：
- en: '[PRE59]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Migrate your model to the database by running the following two commands. These
    will first create a Django migrations file and then create a table in your database:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下两个命令将你的模型迁移到数据库中。这些命令首先创建一个Django迁移文件，然后在你的数据库中创建一个表：
- en: '[PRE60]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, with the database model in place, let''s create a new form that we will
    use to capture information about the books, such as the book title, author, and
    ISBN. For this, create a new file named `forms.py` under the `book_management`
    directory and add the following code inside it:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，数据库模型已经就绪，让我们创建一个新的表单，我们将使用它来捕捉有关书籍的信息，例如书名、作者和ISBN。为此，在`book_management`目录下创建一个名为`forms.py`的新文件，并在其中添加以下代码：
- en: '[PRE61]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the preceding code snippet, you first imported Django''s forms module, which
    will allow you to easily create forms and will also provide the rendering capability
    for the form. The next line imports the model that will store the data for the form:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你首先导入了Django的表单模块，这将允许你轻松创建表单，并也将提供表单的渲染能力。下一行导入了将存储表单数据的模型：
- en: '[PRE62]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the next line, you created a new class named `BookForm`, which inherits
    from the `ModelForm`. This is nothing but a class that maps the fields of the
    model to the form. To successfully achieve this mapping between the model and
    the form, you defined a new subclass named `Meta` under the `BookForm` class and
    set the attribute model to point to the `Book` model and the attribute fields
    to the list of fields that you want to display in the form:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一行中，你创建了一个名为`BookForm`的新类，它继承自`ModelForm`。这只是一个将模型的字段映射到表单的类。为了成功实现模型和表单之间的这种映射，你在`BookForm`类下定义了一个新的子类`Meta`，并将属性model指向`Book`模型，将属性fields设置为要在表单中显示的字段列表：
- en: '[PRE63]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This allows for `ModelForm` to render the correct form HTML when expected to
    do so. The `ModelForm` class provides a built-in `Form.save()` method, which,
    when used, writes the data in the form to the database, and so helps avoid having
    to write redundant code.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许`ModelForm`在需要时渲染正确的表单HTML。`ModelForm`类提供了一个内置的`Form.save()`方法，当使用时，将表单中的数据写入数据库，从而帮助避免编写冗余代码。
- en: 'Now that you have both your model and the form ready, go ahead and implement
    a view that will render the form and accept input from the user. For this, open
    `views.py` under the book_management directory and add the following lines of
    code to the file:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经准备好了模型和表单，继续实现一个视图，该视图将渲染表单并接受用户的输入。为此，打开`book_management`目录下的`views.py`文件，并向文件中添加以下代码行：
- en: '[PRE64]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding code snippet, you created two major views, one being `BookRecordFormView`,
    which is also responsible for rendering the book catalog entry form, and the other
    being `FormSuccessView`, which you will use to render the success message if the
    form data is saved successfully. Let's now look at both the views individually
    and understand what we are doing.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你创建了两个主要视图，一个是`BookRecordFormView`，它还负责渲染书籍目录表单，另一个是`FormSuccessView`，你将使用它来渲染如果表单数据成功保存的成功消息。现在让我们分别查看这两个视图，并了解我们在做什么。
- en: 'First, you created a new view named the `BookRecordFormView` CBV, which inherits
    from `FormView`:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，你创建了一个名为`BookRecordFormView`的新视图CBV，它继承自`FormView`：
- en: '[PRE65]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `FormView` class allows you to easily create views that deal with forms.
    To this class, you need to provide certain parameters, such as the name of the
    template it will render to show the form, the form class that it should use to
    render the form, and the success URL to redirect to when the form is processed
    successfully:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FormView`类允许你轻松创建处理表单的视图。为此类，你需要提供某些参数，例如它将渲染以显示表单的模板名称、它应该用于渲染表单的表单类，以及当表单处理成功时重定向到的成功URL：'
- en: '[PRE66]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `FormView` class also provides a `form_valid()` method, which is called
    when the form successfully finishes the validation. Inside the `form_valid()`
    method, we can decide what we want to do. For our use case, when the form validation
    completes successfully, we first call the `form.save()` method, which persists
    the data for our form into the database, and then call the base class `form_valid()`
    method, which will cause the form view to redirect to the successful URL if form
    validation was a success:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FormView`类还提供了一个`form_valid()`方法，当表单成功完成验证时被调用。在`form_valid()`方法中，我们可以决定要做什么。对于我们的用例，当表单验证成功完成时，我们首先调用`form.save()`方法，将表单数据持久化到数据库中，然后调用基类的`form_valid()`方法，如果表单验证成功，这将导致表单视图重定向到成功URL：'
- en: '[PRE67]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inside this class, we override the `get()` method, which will be rendered when
    the form is saved successfully. Inside the `get()` method, we render a simple
    success message by returning a new `HttpResponse`:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个类中，我们重写了`get()`方法，当表单成功保存时将调用此方法。在`get()`方法中，通过返回一个新的`HttpResponse`来渲染一个简单的成功消息：
- en: '[PRE68]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, create a template that will be used to render the form. For this, create
    a new `templates` folder under the `book_management` directory and create a new
    file named `book_form.html`. Add the following lines of code inside the file:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个将用于渲染表单的模板。为此，在`book_management`目录下创建一个新的`templates`文件夹，并创建一个名为`book_form.html`的新文件。在文件内添加以下代码行：
- en: '[PRE69]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Inside this code snippet, two important things need to be discussed.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，需要讨论两个重要的事情。
- en: The first is the use of the `{% csrf_token %}` tag. This tag is inserted to
    prevent the form from running into `csrf_token` tag is one of the built-in template
    tags provided by Django to avoid such attacks. It does so by generating a unique
    token for every form instance that is rendered.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一点是使用`{% csrf_token %}`标签。此标签被插入以防止表单遇到`csrf_token`问题。这是Django提供的一个内置模板标签，用于避免此类攻击。它通过为每个渲染的表单实例生成一个唯一的令牌来实现。
- en: The second is the use of the `{{ form.as_p }}` template variable. The data for
    this variable is provided by our `FormView`-based view automatically. The `as_p`
    call causes the form fields to be rendered inside the `<p></p>` tags.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二点是使用`{{ form.as_p }}`模板变量。此变量的数据由基于`FormView`的视图自动提供。`as_p`调用使得表单字段被渲染在`<p></p>`标签内。
- en: 'With the CBVs now built, go ahead and map them to URLs, such that you can start
    using them to add new book records. To do this, create a new file named `urls.py`
    under the book_management directory and add the following code to it:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经构建了CBVs（类视图），接下来将它们映射到URL上，这样你就可以开始使用它们来添加新的图书记录。为此，在`book_management`目录下创建一个新的名为`urls.py`的文件，并将以下代码添加到其中：
- en: '[PRE70]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Most parts of the preceding snippet are similar to the ones that you have written
    earlier, but there is one thing different in the way we map our CBVs under the
    URL patterns. When using CBVs, instead of directly adding the function name, we
    use the class name and use its `as_view` method, which maps the class object to
    the view. For example, to map `BookRecordFormView` as a view, we will use `BookRecordFormView.as_view()`.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码片段的大部分与之前你编写的类似，但在将CBVs映射到URL模式的方式上有一点不同。当使用CBVs时，我们不是直接添加函数名，而是使用类名并使用它的`as_view`方法，该方法将类对象映射到视图。例如，要将`BookRecordFormView`映射为一个视图，我们将使用`BookRecordFormView.as_view()`。
- en: 'With the URLs added to our `urls.py` file, the next thing is to add our application
    URL mapping to our `bookr` project. To do this, open the `urls.py` file under
    the `bookr` application and add the following line to `urlpatterns`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`urls.py`文件中添加了URL后，接下来要添加我们的应用程序URL映射到`bookr`项目中。为此，打开`bookr`应用下的`urls.py`文件，并将以下行添加到`urlpatterns`中：
- en: '[PRE71]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, start your development server by running the following command:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令启动你的开发服务器：
- en: '[PRE72]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Then, visit `http://localhost:8080/book_management/new_book_record` (or `127.0.0.1`
    instead of `localhost`.)
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，访问`http://localhost:8080/book_management/new_book_record`（或者使用`127.0.0.1`代替`localhost`。）
- en: 'If everything works fine, you will see a page as shown here:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将看到如下所示的页面：
- en: '![Figure 11.4: View for adding a new book to the database](img/B15509_11_04.jpg)'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图11.4：添加新书籍到数据库的视图](img/B15509_11_04.jpg)'
- en: 'Figure 11.4: View for adding a new book to the database'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：添加新书籍到数据库的视图
- en: 'Upon clicking `Save record`, your record will be written to the database and
    the following page will show up:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“保存记录”后，您的记录将被写入数据库，并显示以下页面：
- en: '![Figure 11.5: Template rendered when the record is successfully inserted](img/B15509_11_05.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5：记录成功插入时渲染的模板](img/B15509_11_05.jpg)'
- en: 'Figure 11.5: Template rendered when the record is successfully inserted'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：记录成功插入时渲染的模板
- en: With this, we have created our own CBV, which allows us to save records for
    new books. With our knowledge of CBVs in tow, let's now take a look at how we
    can perform Create, Read, Update, Delete (CRUD) operations with the help of CBVs.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们创建了自己的CBV（类视图），这使得我们能够为新书籍保存记录。带着我们对CBV的知识，现在让我们看看如何借助CBV执行创建、读取、更新、删除（CRUD）操作。
- en: CRUD Operations with CBVs
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CBV进行CRUD操作
- en: While working with Django models, one of the most common patterns we run into
    involves the creation, reading, updating, and deletion of objects that are stored
    inside our database. The Django admin interface allows us to achieve these CRUD
    operations easily, but what if we wanted to build custom views to give us the
    same capability?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在与Django模型一起工作时，我们遇到的最常见的模式之一涉及在数据库中存储的对象的创建、读取、更新和删除。Django管理界面使我们能够轻松地实现这些CRUD操作，但如果我们想构建自定义视图以获得相同的功能呢？
- en: As it turns out, Django's CBVs allow us to achieve this quite easily. All we
    need to do is to write our custom CBVs and inherit from the built-in base classes
    provided by Django. Building on our existing example of book record management,
    let's see how we can build CRUD-based views in Django.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Django的CBV允许我们非常容易地实现这一点。我们只需要编写我们的自定义CBV，并从Django提供的内置基类中继承。基于我们现有的书籍记录管理示例，让我们看看如何在Django中构建基于CRUD的视图。
- en: Create View
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'To build a view that helps in object creation, we''ll need to open the `view.py`
    file under the `book_management` directory and add the following lines of code
    to it:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个帮助进行对象创建的视图，我们需要打开位于`book_management`目录下的`view.py`文件，并向其中添加以下代码行：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With this, we have created our `CreateView` for the book resource. Before we
    can use it, we will need to map it to a URL. To do this, we can open the `urls.py`
    file under the book_management directory and add the following entry under the
    `urlpatterns` list:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经为书籍资源创建了`CreateView`。在我们能够使用它之前，我们需要将其映射到一个URL。为此，我们可以打开位于`book_management`目录下的`urls.py`文件，并在`urlpatterns`列表下添加以下条目：
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, when we visit `http://127.0.0.1:8000/book_management/book_record_create`,
    we will be greeted with the following page:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们访问`http://127.0.0.1:8000/book_management/book_record_create`时，我们将看到以下页面：
- en: '![Figure 11.6: A view to insert a new book record based on Create view](img/B15509_11_06.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6：基于创建视图插入新书籍记录的视图](img/B15509_11_06.jpg)'
- en: 'Figure 11.6: A view to insert a new book record based on Create view'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：基于创建视图插入新书籍记录的视图
- en: This looks similar to the one that we got when using the Form view. On filling
    in the data and clicking `Save record`, Django will save the data to the database.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与使用表单视图时得到的结果相似。在填写数据并点击“保存记录”后，Django会将数据保存到数据库中。
- en: Update View
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新视图
- en: 'In this view, we want to update the data for a given record. To do this, we
    would need to open the `view.py` file under the `book_management` directory and
    add the following lines of code to it:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，我们想要更新特定记录的数据。为此，我们需要打开位于`book_management`目录下的`view.py`文件，并向其中添加以下代码行：
- en: '[PRE75]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the preceding code snippet, we have used the built-in `UpdateView` template,
    which allows us to update the stored records. The fields attribute here should
    take in the name of the fields that we would like to allow the user to update.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了内置的`UpdateView`模板，它允许我们更新存储的记录。这里的字段属性应该接受我们希望允许用户更新的字段名称。
- en: 'Once the view is created, the next step is to add the URL mapping. To do this,
    we can open the `urls.py` file under the `book_management` directory and add the
    following lines of code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 视图创建完成后，下一步是添加URL映射。为此，我们可以打开位于`book_management`目录下的`urls.py`文件，并向其中添加以下代码行：
- en: '[PRE76]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this example, we have appended `<int:pk>` to the URL field. This signifies
    the field input we are going to have to retrieve the record for. Inside Django
    models, Django inserts a primary key of the integer type, which is used to uniquely
    identify the records. Inside the URL mapping, this is the field that we have been
    asking to insert.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将`<int:pk>`附加到URL字段。这表示我们将要输入的字段以检索记录。在Django模型中，Django插入一个整型主键，用于唯一标识记录。在URL映射中，这是我们要求插入的字段。
- en: 'Now, when we try to open `http://127.0.0.1:8000/book_management/book_record_update/1`,
    it should show us a record of the first record that we inserted into our database
    and allow us to edit it:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试打开`http://127.0.0.1:8000/book_management/book_record_update/1`时，它应该显示我们插入到数据库中的第一条记录，并允许我们编辑它：
- en: '![Figure 11.7: View displaying the book record update template based on the
    Update view](img/B15509_11_07.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7：基于更新视图显示书籍记录更新模板的视图](img/B15509_11_07.jpg)'
- en: 'Figure 11.7: View displaying the book record update template based on the Update
    view'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：基于更新视图显示书籍记录更新模板的视图
- en: Delete View
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除视图
- en: 'Delete view, as the name suggests, is a view that deletes the record from our
    database. To implement such a view for our `Book` model, you will need to open
    the `views.py` file under the `book_management` directory and add the following
    code snippet to it:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 删除视图，正如其名所示，是一个从我们的数据库中删除记录的视图。为了为我们的`Book`模型实现此类视图，您需要打开`book_management`目录下的`views.py`文件，并将其中的以下代码片段添加到该文件中：
- en: '[PRE77]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'With this, we have just created a Delete view for our book records. As we can
    see, this view uses a different template where all we would like to confirm from
    the user is, do they really want to delete the record or not? To achieve this,
    you can create a new template file, `book_delete_form.html`, and add the following
    code to it:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们刚刚为我们的书籍记录创建了一个删除视图。正如我们所见，此视图使用了一个不同的模板，我们希望从用户那里确认的是，他们是否真的想要删除记录？为了实现这一点，你可以创建一个新的模板文件`book_delete_form.html`，并将其中的以下代码添加到该文件中：
- en: '[PRE78]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then we can add a mapping for our Delete view by modifying the `urlpatterns`
    list inside the `urls.py` file under the `book_management` directory as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过修改`book_management`目录下的`urls.py`文件中的`urlpatterns`列表来为我们的删除视图添加映射，如下所示：
- en: '[PRE79]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, when visiting `http://127.0.0.1:8000/book_management/book_record_delete/1`,
    we should be greeted with the following page:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当访问`http://127.0.0.1:8000/book_management/book_record_delete/1`时，我们应该看到以下页面：
- en: '![Figure 11.8: Delete Book Record view based on the Delete view class](img/B15509_11_08.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8：基于删除视图类的删除书籍记录视图](img/B15509_11_08.jpg)'
- en: 'Figure 11.8: Delete Book Record view based on the Delete view class'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：基于删除视图类的删除书籍记录视图
- en: Upon clicking the `Delete record` button, the record will be deleted from the
    database and the Deletion success page will be rendered.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“删除记录”按钮后，记录将从数据库中删除，并渲染删除成功页面。
- en: Read View
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取视图
- en: 'In this view, we would like to see a list of records that our database stores
    for the books. To achieve this, we are going to build a view named `DetailView`,
    which will render details about the book we are requesting. To build this view,
    we can add the following lines of code to our `views.py` file under the `book_management`
    directory:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，我们希望看到数据库中存储的书籍记录列表。为了实现这一点，我们将在`book_management`目录下的`views.py`文件中添加以下代码行来构建一个名为`DetailView`的视图，该视图将渲染我们请求的书籍的详细信息。构建此视图，我们可以在`book_management`目录下的`views.py`文件中添加以下代码行：
- en: '[PRE80]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In the preceding code snippet, we are creating `DetailView`, which will help
    us to render the details about the book ID we are asking for. The Detail view
    internally queries our database model with the book ID we provide to it and, if
    a record is found, renders the template with the data stored inside the record
    by passing it as an object variable inside the template context.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个`DetailView`，它将帮助我们渲染我们请求的书籍ID的详细信息。详细视图内部使用我们提供的书籍ID查询我们的数据库模型，如果找到记录，则通过将存储在记录中的数据作为对象变量传递到模板上下文中来渲染模板。
- en: 'Once this is done, the next step is to create the template for our book details.
    For this we''ll need to create a new template file named `book_detail.html` under
    our `templates` directory inside the `book_management` application with the following contents:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，下一步是创建我们的书籍详细信息的模板。为此，我们需要在`book_management`应用程序的`templates`目录下创建一个名为`book_detail.html`的新模板文件，其内容如下：
- en: '[PRE81]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, with the template created, the last thing we need to do is to add a URL
    mapping for the Detail view. This can be done by appending the following to the
    `urlpatterns` list under the `urls.py` file of the `book_management` application:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了模板，我们最后需要做的是为 Detail 视图添加 URL 映射。这可以通过将以下内容追加到 `book_management` 应用程序的
    `urls.py` 文件中的 `urlpatterns` 列表来完成：
- en: '[PRE82]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, with all of this configured, if we now go and open `http://127.0.0.1:8000/book_management/book_record_detail/1`,
    we will get to see the details pertaining to our book, as shown here:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些配置完成后，如果我们现在打开 `http://127.0.0.1:8000/book_management/book_record_detail/1`，我们将看到有关我们书籍的详细信息，如图所示：
- en: '![Figure 11.9: View rendered when we try to access a previously stored book
    record](img/B15509_11_09.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9：尝试访问先前存储的书籍记录时渲染的视图](img/B15509_11_09.jpg)'
- en: 'Figure 11.9: View rendered when we try to access a previously stored book record'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：尝试访问先前存储的书籍记录时渲染的视图
- en: With the preceding examples, we just enabled CRUD operations for our `Book`
    model, and all of that while using CBVs.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的示例，我们只是为我们的 `Book` 模型启用了 CRUD 操作，而且这一切都是在使用 CBVs（类视图）的同时完成的。
- en: 'Activity 11.01: Rendering Details on the User Profile Page Using Inclusion
    Tags'
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01：使用包含标签在用户个人资料页面渲染详细信息
- en: In this activity, you will create a custom inclusion tag that helps to develop
    a user profile page that renders not only the users' details but also lists the
    books they have read.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，您将创建一个自定义包含标签，该标签有助于开发一个渲染用户详细信息以及他们阅读的书籍列表的用户个人资料页面。
- en: 'The following steps should help you to complete this activity successfully:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤应有助于您成功完成此活动：
- en: Create a new `templatetags` directory under the `reviews` application inside
    the `bookr` project to provide a place where you can create your custom template
    tags.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bookr` 项目的 `reviews` 应用程序下创建一个新的 `templatetags` 目录，以提供一个可以创建自定义模板标签的地方。
- en: Create a new file named `profile_tags.py`, which will store the code for your
    inclusion tag.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `profile_tags.py` 的新文件，该文件将存储包含标签的代码。
- en: Inside the `profile_tags.py` file, import Django's template library and use
    it to initialize an instance of the template library class.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `profile_tags.py` 文件中，导入 Django 的模板库并使用它来初始化模板库类的实例。
- en: Import the `Review` model from the reviews application to fetch the reviews
    written by a user. This will be used to filter the reviews for the current user
    to render on the user profile page.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `reviews` 应用程序导入 `Review` 模型以获取用户的评论。这将用于过滤当前用户的评论以在用户个人资料页面渲染。
- en: Next, create a new Python function named `book_list`, which will contain the
    logic for your inclusion tag. This function should only take a single parameter,
    the username of the currently logged-in user.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `book_list` 的新 Python 函数，该函数将包含包含标签的逻辑。此函数应仅接受一个参数，即当前登录用户的用户名。
- en: Inside the body of the `book_list` function, add the logic for fetching the
    reviews for this user and extract the name of the books this user has read. Assume
    that a user has read all those books for which they have provided a review.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `book_list` 函数的主体中，添加获取此用户评论的逻辑并提取此用户阅读的书籍名称。假设用户已经阅读了他们提供评论的所有书籍。
- en: Decorate this `book_list` function with the `inclusion_tag` decorator and provide
    it with a template name `book_list.html`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `inclusion_tag` 装饰器装饰此 `book_list` 函数，并为其提供一个模板名称 `book_list.html`。
- en: Create a new template file named `book_list.html`, which was specified to the
    inclusion tag decorator in *step 7*. Inside this file, add code to render a list
    of books. This can be done by using a `for` loop construct and rendering HTML
    list tags for every item inside the list provided.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `book_list.html` 的新模板文件，该文件在 *步骤 7* 中被指定为包含标签装饰器。在这个文件中，添加代码以渲染书籍列表。这可以通过使用
    `for` 循环结构和为列表中的每个项目渲染 HTML 列表标签来实现。
- en: Modify the existing `profile.html` file under the `templates` directory, which
    will be used to render the user profile. Inside this template file, include the
    custom template tag and use it to render the list of books read by the user.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `templates` 目录下现有的 `profile.html` 文件，该文件将用于渲染用户个人资料。在这个模板文件中，包含自定义模板标签并使用它来渲染用户阅读的书籍列表。
- en: 'Once you implement all the aforementioned steps, starting the application server
    and visiting the user profile page should render a page that is similar to the
    one shown in *Figure 11.10*:'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦实现了上述所有步骤，启动应用程序服务器并访问用户个人资料页面应该会渲染一个类似于 *图 11.10* 中所示的页面：
- en: '![Figure 11.10: User profile page with the list of books read by the user](img/B15509_11_10.jpg)'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.10：用户个人资料页面，列出了用户阅读过的书籍](img/B15509_11_10.jpg)'
- en: 'Figure 11.10: User profile page with the list of books read by the user'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：用户个人资料页面，列出了用户阅读过的书籍
- en: Note
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在[http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ)找到。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the advanced templating concepts in Django
    and understood how we can create custom template tags and filters to fit a myriad
    of use cases and support the reusability of components across the application.
    We then looked at how Django provides us with the flexibility to implement FBVs
    and CBVs to render our responses.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Django 的高级模板概念，并了解了我们如何创建自定义模板标签和过滤器来适应各种用例，并支持应用程序中组件的可重用性。然后我们探讨了
    Django 如何提供灵活性，使我们能够实现 FBVs（函数视图）和 CBVs 来渲染我们的响应。
- en: While exploring CBVs, we learned how they can help us avoid code duplication
    and how we can leverage the built-in CBVs to render forms that save data, help
    us update existing records, and implement CRUD operations on our database resources.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 CBVs（类视图）的过程中，我们学习了它们如何帮助我们避免代码重复，以及我们如何利用内置的 CBVs 来渲染保存数据的表单，帮助我们更新现有记录，并在我们的数据库资源上实现
    CRUD 操作。
- en: As we move to the next chapter, we will now utilize our knowledge of building
    CBVs to work on implementing REST APIs in Django. This will allow us to perform
    well-defined HTTP operations on our data inside our Bookr application without
    maintaining any state inside the application.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入下一章，我们现在将利用我们构建 CBVs 的知识来实施 Django 中的 REST APIs。这将使我们能够在 Bookr 应用程序内部对数据进行定义良好的
    HTTP 操作，而不需要在应用程序内部维护任何状态。
