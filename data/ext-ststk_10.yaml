- en: Chapter 10. Monitoring with Beacons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 监控信标
- en: '**Beacons** are a newer type of module in Salt which are designed to watch
    resources on a Minion, and report to the Master when those resources fall out
    of alignment with what you expect them to look like. In this chapter, we will
    discuss:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**信标**是Salt中的一种新型模块，旨在监视Minion上的资源，并在这些资源与您期望它们看起来不一致时向主节点报告。在本章中，我们将讨论：'
- en: Monitoring external systems with Salt
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Salt监控外部系统
- en: Troubleshooting beacons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信标故障排除
- en: Watching for data
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视数据
- en: 'There are two basic types of monitoring services: those that record data, and
    those that trigger alerts based on that data. On the surface, beacons may look
    like the second type. They run on a regular interval (as frequently as every second,
    by default) and when they find data that is important, they send it up to the
    Master.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 监控服务有两种基本类型：那些记录数据的，以及基于那些数据触发警报的。表面上，信标可能看起来像是第二种类型。它们以常规间隔运行（默认情况下每秒运行一次）并且当它们发现重要的数据时，会将这些数据发送到主节点。
- en: However, because beacons have access to execution modules on the Minion that
    they are running on, they can interact with any program on the Minion that an
    execution module can.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于信标可以访问它们运行的Minion上的执行模块，它们可以与Minion上任何执行模块可以交互的程序进行交互。
- en: Keeping an eye on things
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注事物
- en: Let's go ahead and put together a beacon that monitors `nspawn` containers.
    It doesn't need to be very complex; indeed, beacons should be as simple as possible,
    since they are expected to run so often. All that our beacon needs to do is keep
    an eye on containers that should be running, and those that should be absent.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建一个监控`nspawn`容器的信标。它不需要非常复杂；实际上，信标应该尽可能简单，因为它们预计会频繁运行。我们的信标只需要关注应该运行和应该不存在的容器。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Containers have become very popular in the modern data center, thanks in large
    part to Docker and LXC. systemd has its own containering system called `nspawn`,
    which is a very powerful system in its own right. A number of Linux distributions
    now ship with systemd, which means that you may already have `nspawn` installed.
    You can find a more complete discussion of `nspawn` itself on Lennart Pottering''s
    blog at:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在现代数据中心中变得非常流行，这很大程度上归功于Docker和LXC。systemd有自己的容器系统，称为`nspawn`，它本身就是一个非常强大的系统。现在许多Linux发行版都预装了systemd，这意味着您可能已经安装了`nspawn`。您可以在Lennart
    Pottering的博客上找到关于`nspawn`的更完整讨论：
- en: '[http://0pointer.net/blog/systemd-for-administrators-part-xxi.html](http://0pointer.net/blog/systemd-for-administrators-part-xxi.html)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://0pointer.net/blog/systemd-for-administrators-part-xxi.html](http://0pointer.net/blog/systemd-for-administrators-part-xxi.html)'
- en: 'First, we need to set up our `__virtual__()` function. Since `nspawn` is part
    of `systemd`, and not every Minion will have `systemd` on it, we need to perform
    a check for it. However, since we''re going to use the `nspawn` execution module
    that ships with Salt, and it already contains a `__virtual__()` function, all
    that we really need to do is make sure it is present:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置我们的`__virtual__()`函数。由于`nspawn`是`systemd`的一部分，并不是每个Minion都安装了`systemd`，因此我们需要对其进行检查。然而，由于我们将使用随Salt一起提供的`nspawn`执行模块，并且它已经包含了一个`__virtual__()`函数，我们真正需要做的只是确保它存在：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It makes sense to check specifically for `nspawn.list_running`, since that is
    the only function that we'll be using here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有针对性地检查`nspawn.list_running`是有意义的，因为这是我们在这里唯一会使用的函数。
- en: Validating configuration
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证配置
- en: Beacons will not run unless they know which data to watch for. You probably
    saw the configuration example in the preceding docstring. The `validate()` function
    checks the configuration that was passed to this beacon, to make sure that it
    has been formatted in the correct way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 信标不知道要监视哪些数据时不会运行。您可能在前面的文档字符串中看到了配置示例。`validate()`函数检查传递给此信标的配置，以确保其格式正确。
- en: 'If we were going to be minimalistic about this, then we would just check to
    make sure that the correct type of data has been passed in. In our case, we''re
    expecting a dictionary, so we could get away with just checking for that:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要对此进行极简处理，那么我们只需检查确保已经传递了正确的数据类型。在我们的例子中，我们期望的是一个字典，所以我们只需检查这一点即可：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But we''ll go ahead and add just a little more, to make sure that, at the very
    least, the containers listed are set to one of the required values: `running`
    or `absent`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将添加一点更多，以确保至少容器列表被设置为所需的值之一：`running`或`absent`：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can skip this function if you need to; if it's not there, then Salt will
    skip over it. However, it is a good idea to have it there, to help keep bad configuration
    from causing the beacon to crash with a stacktrace.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要这个函数，可以跳过它；如果没有它，Salt 会跳过它。然而，保留它是一个好主意，以帮助防止不良配置导致信标崩溃并带有堆栈跟踪。
- en: The beacon() function
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: beacon() 函数
- en: As with some of the other types of modules, beacons have a function that is
    required, since Salt will look for it when trying to use the module. Not surprisingly,
    this function is called `beacon()`. It is passed the same `config` data as the
    `validate()` function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些类型的模块一样，信标有一个必需的函数，因为 Salt 在尝试使用模块时会查找它。不出所料，这个函数叫做 `beacon()`。它传递与 `validate()`
    函数相同的 `config` 数据。
- en: 'Our beacon''s only job is to use `machinectl` to report which containers are
    currently running on the Minion. Its output looks something like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们信标的唯一任务是使用 `machinectl` 报告当前在 Minion 上运行的容器。它的输出看起来像以下这样：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We could call this manually and parse the output ourselves, but as I said before,
    there is already an `nspawn` execution module that ships with Salt, and it has
    a `list_running()` function that does all of that for us.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动调用它并解析输出，但正如我之前说的，Salt 已经附带了一个 `nspawn` 执行模块，它有一个 `list_running()` 函数，可以为我们做所有这些事情。
- en: 'All that we have to do then is get a list of the nodes that are reported as
    running, and then match it against the list of nodes in the `config` dictionary:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的就是获取报告为正在运行的节点列表，然后将其与 `config` 字典中的节点列表进行匹配：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Rather than stepping through the list of running nodes, we iterate through the
    list of nodes that were configured. If a node that should be absent shows up in
    the running list, then we mark it as running. If it should be running but doesn't
    show up, then we mark it as absent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是逐个检查正在运行的节点列表，而是遍历已配置的节点列表。如果一个本应不存在的节点出现在运行列表中，我们就将其标记为正在运行。如果一个节点应该运行但未出现，我们就将其标记为不存在。
- en: That last `else` statement will notify us if something that wasn't marked as
    running or absent showed up in the list. Since we already did that check in the
    `validate()` function, this shouldn't be needed. But it's not a bad idea to keep
    this kind of check in there, just in case your `validate()` function missed something.
    If you start seeing events from this module that have nodes set to `False`, then
    you know you need to go back and check the `validate()` function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `else` 语句会通知我们如果列表中出现了一些未被标记为正在运行或不存在的东西。由于我们已经在 `validate()` 函数中进行了这个检查，所以这不应该需要。但保留这种检查并不是一个坏主意，以防你的
    `validate()` 函数错过了什么。如果你开始看到这个模块的事件，节点被设置为 `False`，那么你就知道你需要回去检查 `validate()`
    函数。
- en: 'If you''ve been following along and have already started testing this module,
    then you may notice something, well, obnoxious. By default, beacons are executed
    once a second. You can change that interval on a per-module basis:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟进并已经开始了这个模块的测试，你可能注意到了一些，嗯，令人讨厌的事情。默认情况下，信标每秒执行一次。你可以根据每个模块来更改这个间隔：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With that configuration, the `nspawn` beacon will only be executed once every
    five seconds, instead of every second. That will cut down on the chatter, but
    also means that your beacon won't necessarily be watching as often as you'd like.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种配置，`nspawn` 信标将每五秒执行一次，而不是每秒执行一次。这将减少噪音，但也意味着你的信标不一定能像你希望的那样频繁地监视。
- en: 'Let''s go ahead and add some code, which will allow the beacon to run as often
    as you''d like, but send updates on a less regular basis. Let''s say that you
    have your beacon tied into a monitoring service (through the event reactor), and
    you want up-to-the-second monitoring, but you don''t need to be told more than
    once every five minutes that, "oh, by the way, the container is still down":'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些代码，这将允许信标以你想要的频率运行，但以不那么规律的频率发送更新。假设你的信标已经与监控服务（通过事件反应器）绑定，并且你想要实时的监控，但不需要每五分钟被告知一次，“哦，顺便说一下，容器仍然处于关闭状态”：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we set up an alert interval called `nspawn_alert_interval`, and default
    it to `360` seconds (or, every five minutes). Because we used `config.get` to
    look for it, we can configure it in either the `master` or `minion` configuration
    files, or in a grain or a pillar for the Minion.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置了一个名为 `nspawn_alert_interval` 的警报间隔，并将其默认设置为 `360` 秒（或者说，每五分钟一次）。因为我们使用了
    `config.get` 来查找它，所以我们可以在这 `master` 或 `minion` 配置文件中，或者在 Minion 的一个 grain 或 pillar
    中进行配置。
- en: Then we make a note of the current time using Python's own `time.time()` function.
    This function reports the number of seconds since the epoch, which is perfect
    for our purposes, since our alert interval is also configured in seconds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用Python自带的`time.time()`函数记录当前时间。这个函数报告自纪元以来的秒数，这对于我们的目的来说非常完美，因为我们的警报间隔也是以秒为单位的。
- en: As we iterate through the list of configured nodes, we check to see when the
    last notification was sent out. This is stored in a grain called `nspawn_last_notify`.
    This isn't a grain that your users will be updating; this is one that the beacon
    will keep track of.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历配置的节点列表时，我们检查最后一次发送通知的时间。这存储在一个名为`nspawn_last_notify`的grain中。这不是用户会更新的grain；这是信标会跟踪的。
- en: In fact, you will see that happen for each of the branches in the `if` statement.
    Whenever the beacon detects that an alert should be sent, it first checks to see
    if an alert has already been sent during the specified interval. If not, then
    it sets up an event to be returned.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你会在`if`语句的每个分支中看到这种情况发生。每当信标检测到应该发送警报时，它首先检查在指定的时间间隔内是否已经发送了警报。如果没有，那么它设置一个要返回的事件。
- en: Watching for beacons
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视信标
- en: 'Beacons use Salt''s event bus to send notifications to the Master. You can
    use the `event` function in the `state` runner to watch the beacons come in on
    the event bus. The return from this particular beacon module will look like the
    following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 信标使用Salt的事件总线向Master发送通知。您可以使用`state`运行器中的`event`函数来监视事件总线上的信标。这个特定信标模块的返回值将如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Take note of the tag, which contains `salt/beacon/`, followed by the ID of the
    Minion (`alton`) that fired the beacon, and then the name of the beacon itself
    (`nspawn`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意标签，它包含`salt/beacon/`，然后是触发信标的Minion（`alton`）的ID，然后是信标本身的名称（`nspawn`）。
- en: The final beacon module
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后一个信标模块
- en: 'When all is said and done, our final beacon module will look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一切结束后，我们的最终信标模块将如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Troubleshooting beacons
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信标故障排除
- en: 'Beacons are a type of module that require both a running Master and a running
    Minion. Running the `salt-master` service in the foreground won''t give you much
    insight, since the code will be running on the Minion, but running the `salt-minion`
    service in the foreground will be very helpful:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 信标是一种需要运行中的Master和运行中的Minion的模块。在前景运行`salt-master`服务不会给你太多洞察力，因为代码将在Minion上运行，但在前景运行`salt-minion`服务将非常有帮助：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Set aside a Minion that only has your beacon configured and no others. By default,
    these beacons will run every second, and that can generate very noisy logs indeed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 预留一个只配置了信标而没有其他配置的Minion。默认情况下，这些信标每秒运行一次，这确实会生成非常嘈杂的日志：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Imagine several beacons running at once, each logging its own data for what
    it's currently doing. That will get old fast.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下同时运行多个信标，每个信标都记录它当前正在做什么的数据。这会很快变得无聊。
- en: 'You will also want to keep an event listener open on the Master:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你还希望在Master上保持一个事件监听器打开：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Fortunately, beacons are not the sort of thing that you really need to wait
    around for; just make the machine exhibit the kind of behavior that you're looking
    for, and then start up the `salt-minion` process. Just make sure to test for any
    variation of the behavior that you expect to find, whether or not it is expected
    to return an event.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，信标不是那种你需要等待的东西；只需让机器表现出你想要的行为，然后启动`salt-minion`进程。只需确保测试你期望找到的任何行为的变化，无论它是否预期返回一个事件。
- en: Summary
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Beacons give Minions the ability to raise events based on monitored conditions.
    A `validate()` function is helpful for ensuring that the configuration is correct,
    but it is not required. A `beacon()` function is required, as it is the function
    that performs the actual monitoring. Use execution modules when possible to perform
    the heavy lifting. Beacons can run at very short intervals, but by having them
    store data in grains, you can set notifications at longer intervals.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 信标赋予Minion根据监控条件触发事件的能力。一个`validate()`函数有助于确保配置正确，但不是必需的。一个`beacon()`函数是必需的，因为它是执行实际监控的函数。尽可能使用执行模块来执行繁重的工作。信标可以在非常短的时间间隔内运行，但通过让它们在grains中存储数据，您可以设置更长的时间间隔的通知。
- en: 'Now that we have all of the Minion-side modules in the book out of the way,
    let''s go back and finish up with some Master-side modules. Next up: extending
    the Master.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将书中所有的Minion端模块处理完毕，让我们回到Master端模块，完成剩余的工作。接下来：扩展Master。
