- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Organizing Our Code with Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类组织我们的代码
- en: Things are going great with your data entry form! Your boss and coworkers and
    excited to see the progress you've made and are already coming up with some ideas
    of what other features could be added. This makes you a little nervous, to be
    honest! While they see a professional-looking form, you know that the code underneath
    is getting bulky and repetitive. You've got some warts in there too, like a global
    variable and a very cluttered global namespace. Before you start adding more features,
    you'd like to get a handle on this code and start breaking it down into some manageable
    chunks. For this, you'll need to create **classes**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据输入表单进展顺利！你的老板和同事对你的进步感到兴奋，并且已经开始提出一些可以添加的其他功能的想法。说实话，这让你有点紧张！虽然他们看到一个看起来专业的表单，但你清楚底下的代码正变得越来越庞大和重复。你还有一些瑕疵，比如全局变量和一个非常杂乱的全球命名空间。在你开始添加更多功能之前，你希望掌握这段代码，并开始将其分解成一些可管理的块。为此，你需要创建**类**。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: In *A primer on Python classes*, we'll review how to create Python classes and
    subclasses.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Python类的入门指南* 中，我们将回顾如何创建Python类和子类。
- en: In *Using classes with Tkinter*, we'll discover ways to utilize classes effectively
    in Tkinter code.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *使用Tkinter的类* 中，我们将发现如何有效地在Tkinter代码中使用类。
- en: In *Rewriting our application using classes*, we'll apply these techniques to
    the ABQ Data Entry application.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *使用类重写我们的应用程序* 中，我们将将这些技术应用到ABQ数据输入应用程序中。
- en: A primer on Python classes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python类的入门指南
- en: While the concept of a class is simple enough on the surface, classes bring
    with them a number of terms and concepts that confuse many beginners. In this
    section, we'll discuss the advantages of using classes, explore the different
    features of classes, and review the syntax for creating classes in Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类的基本概念表面上看起来很简单，但类带来了一系列术语和概念，这些概念常常让许多初学者感到困惑。在本节中，我们将讨论使用类的优点，探讨类的不同特性，并回顾在Python中创建类的语法。
- en: The advantages of using classes
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类的优点
- en: Many beginners and even intermediate Python coders avoid or dismiss the use
    of classes in Python; unlike functions or variables, classes do not have obvious
    uses in short, simple scripts. As our application code grows, however, classes
    become an indispensable tool for organizing our code into manageable units. Let's
    look at some ways classes can help us build cleaner code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者甚至中级Python程序员避免或忽视Python中类的使用；与函数或变量不同，类在简短的简单脚本中没有明显的用途。然而，随着我们的应用程序代码的增长，类成为组织我们的代码成可管理单元的不可或缺的工具。让我们看看类如何帮助我们构建更干净的代码。
- en: Classes are an integral part of Python
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类是Python的组成部分
- en: 'A class is essentially a blueprint for creating an **object**. What is an object?
    In Python, *everything* is an object: integers, strings, floats, lists, dictionaries,
    Tkinter widgets, and even functions are all objects. Each of these types of objects
    is defined by a class. You can see this easily at a Python prompt if you use the
    `type` command, like so:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类本质上是一个创建**对象**的蓝图。什么是对象？在Python中，*一切*都是对象：整数、字符串、浮点数、列表、字典、Tkinter小部件，甚至函数都是对象。这些对象类型都是由类定义的。如果你在Python提示符下使用`type`命令，就可以很容易地看到这一点，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `type` function shows you what class was used to construct the object in
    question. When an object is built from a particular class, we say it is an **instance**
    of that class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`函数显示了你用来构建特定对象的类。当一个对象由特定的类构建时，我们称它为该类的**实例**。'
- en: '*Instance* and *object* are often used interchangeably, because every object
    is an instance of some class.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例*和*对象*经常可以互换使用，因为每个对象都是某个类的实例。'
- en: Because everything in Python is a class, creating our own classes allows us
    to work with custom objects using the same syntax we use with built-in objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python中的所有东西都是类，所以创建我们自己的类允许我们使用与内置对象相同的语法来处理自定义对象。
- en: Classes make relationships between data and functions explicit
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类使数据与函数之间的关系明确
- en: Often, in code, we have a set of data that all relates to the same thing. For
    example, in a multiplayer game, you might have variables for each player's score,
    health, or progress. Functions that operate on these variables would need to be
    sure to operate on the variables that refer to the same player. Classes would
    allow us to create an explicit relationship between these variables and the functions
    that operate on them, so that we can more easily keep them organized as a unit.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在代码中，我们有一组所有相关联的数据。例如，在一个多人游戏中，你可能会有每个玩家的分数、健康或进度等变量。操作这些变量的函数需要确保操作的是指向同一玩家的变量。类允许我们创建这些变量和操作它们的函数之间的显式关系，这样我们就可以更容易地将它们作为一个单元组织起来。
- en: Classes help create reusable code
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类有助于创建可重用的代码
- en: Classes are a great tool for reducing code redundancy. Suppose we have a set
    of forms that have similar behavior on submission, but different input fields.
    Using class inheritance, we can create a base form with the desired common behaviors;
    then, we can derive the individual form classes from that, only having to implement
    what is unique in each form.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类是减少代码冗余的强大工具。假设我们有一组在提交时具有相似行为但输入字段不同的表单。使用类继承，我们可以创建一个具有所需共同行为的基表单；然后，我们可以从这个基表单派生出单个表单类，只需要实现每个表单中独特的内容。
- en: Syntax of class creation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类创建的语法
- en: 'Creating a class is very similar to creating a function, except that we use
    the `class` keyword, like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类与创建一个函数非常相似，只是我们使用`class`关键字，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we've also included a **docstring**, which is used by Python tools
    (such as the built-in `help` function) to generate documentation about the class.
    Class names in Python traditionally use **Pascal Case**, meaning the first letter
    of each word is capitalized; sometimes, third-party libraries will use other conventions,
    however.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还包含了一个**文档字符串**，它被Python工具（如内置的`help`函数）用于生成有关类的文档。在Python中，类名传统上使用**帕斯卡大小写**，即每个单词的首字母大写；有时，第三方库会使用其他约定，但通常不会。
- en: 'Once we have defined a class, we can create instances of the class by calling
    it, just like a function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了一个类，我们就可以通过调用它来创建类的实例，就像调用一个函数一样：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, `my_banana` is an object that is an instance of the `Banana` class.
    Of course, a more useful class will have some things defined inside the class
    body; specifically, we can define **attributes** and **methods**, which are collectively
    known as **members**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`my_banana`是一个`Banana`类的实例对象。当然，更有用的类将在类体内部定义一些内容；具体来说，我们可以定义**属性**和**方法**，这些统称为**成员**。
- en: Attributes and methods
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性和方法
- en: 'Attributes are simply variables, and they can be either **class attributes**
    or **instance attributes**. A class attribute is defined in the top scope of the
    class body, like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 属性仅仅是变量，它们可以是**类属性**或**实例属性**。类属性是在类体顶部的范围内定义的，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Class attributes are shared by all instances of the class, and are usually used
    for setting defaults, constants, and other read-only values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性被类的所有实例共享，通常用于设置默认值、常量和其他只读值。
- en: Note that unlike class names, member names, by convention, use **snake case**,
    where lowercase words are separated by underscores.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与类名不同，成员名称按照惯例使用**蛇形命名法**，即单词之间用下划线分隔。
- en: 'Instance attributes store values specific to a single instance of the class;
    to create one, we need access to an instance. We could do it like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实例属性存储特定于类单个实例的值；要创建一个实例属性，我们需要访问一个实例。我们可以这样做：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, it would be more ideal if we could define some instance attributes
    inside our class definition, instead of doing it externally like that. In order
    to do so, we need a reference to the instance of the class inside the class definition.
    This can be done with an **instance method**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们能在类定义内部定义一些实例属性，而不是像那样外部定义，那将更加理想。为了做到这一点，我们需要在类定义内部对类的实例有一个引用。这可以通过一个**实例方法**来实现。
- en: 'Methods are simply functions attached to the class. An instance method is a
    method that automatically receives a reference to the instance as its first argument.
    We can define one like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是附加到类上的函数。实例方法是一种自动接收实例引用作为其第一个参数的方法。我们可以这样定义一个：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, defining an instance method is simply defining a function inside
    the class body. The first argument that this function will receive is a reference
    to the instance of the class; it can be called anything you like, but by long-standing
    Python convention, we name it `self`. Inside the function, `self` can be used
    to do operations on the instance, such as assigning an instance attribute.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，定义一个实例方法就是简单地在类体内定义一个函数。这个函数将接收的第一个参数是类的实例的引用；你可以称它为你喜欢的任何名字，但根据长期以来的Python约定，我们称它为`self`。在函数内部，`self`可以用来对实例进行操作，例如分配实例属性。
- en: 'Note that the instance (`self`) also has access to class attributes (for example,
    `self.colors`), as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实例（`self`）也可以访问类属性（例如，`self.colors`），如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we use an instance method, we do not explicitly pass `self`; it''s passed
    implicitly, like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用实例方法时，我们不显式传递`self`；它是隐式传递的，如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The implicit passing of `self` often leads to confusing error messages when
    you pass the wrong number of arguments. For example, if you called `my_banana.peel(True)`,
    you'd get an exception saying that one argument was expected but two were passed.
    From your point of view, you only passed one argument, but the method got two
    because the instance reference was automatically added.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`的隐式传递通常会在传递错误数量的参数时导致令人困惑的错误信息。例如，如果你调用`my_banana.peel(True)`，你会得到一个异常，表明期望一个参数但传递了两个。从你的角度来看，你只传递了一个参数，但方法接收到了两个，因为实例引用被自动添加了。'
- en: In addition to instance methods, classes can have **class methods** and **static
    methods**. Unlike instance methods, these methods do not have access to the instance
    of the class and cannot read or write instance attributes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例方法之外，类还可以有**类方法**和**静态方法**。与实例方法不同，这些方法没有访问类的实例，并且不能读取或写入实例属性。
- en: 'Class methods are created using a **decorator** just before the method definition,
    like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法是在方法定义之前使用**装饰器**创建的，如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Just as an instance method is implicitly passed a reference to the instance,
    a class method is implicitly passed a reference to the class as the first argument.
    Once again, you can call that argument anything you like, but conventionally it
    is called `cls`. Class methods are usually used for interaction with class variables.
    For example, in the `check_color()` method above, the method needs a reference
    to the class variable `colors`. Class methods are also used as convenience functions
    for geneating specifically configured instances of the class; for example, the
    `make_greenie()` method above uses its class reference to create instances of
    `Banana` with the color pre-set to `green`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如实例方法隐式地传递了实例的引用一样，类方法也隐式地传递了类的引用作为第一个参数。同样，你可以称那个参数为你喜欢的任何名字，但传统上我们称之为`cls`。类方法通常用于与类变量交互。例如，在上面的`check_color()`方法中，该方法需要引用类变量`colors`。类方法也用作生成特定配置的类实例的便利函数；例如，上面的`make_greenie()`方法使用其类引用创建颜色预设置为`green`的`Banana`实例。
- en: 'A **static method** is also a function that''s attached to the class, but it
    does not get any implicit arguments, and the code within the method has no access
    to the class or instance. Just like the class methods, we use a decorator to define
    a static method, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态方法**也是一个附加到类上的函数，但它不接收任何隐式参数，方法内的代码也无法访问类或实例。就像类方法一样，我们使用装饰器来定义静态方法，如下所示：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Static methods are often used for defining algorithms or utility functions used
    internally by the class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法通常用于定义类内部使用的算法或实用函数。
- en: Class and static methods can be called on the class itself; for example, we
    could call `Banana.estimate_calories()` or `Banana.check_color()` without actually
    creating an instance of `Banana`. Instance methods, however, *must* be called
    on an instance of the class. It would make no sense to call `Banana.set_color()`
    or `Banana.peel()`, since these methods are meant to operate on an instance. Instead,
    we should create an instance and call those methods on it (for example, `my_banana.peel()`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类和静态方法可以直接在类本身上调用；例如，我们可以调用`Banana.estimate_calories()`或`Banana.check_color()`而不实际创建`Banana`的实例。然而，实例方法*必须*在类的实例上调用。调用`Banana.set_color()`或`Banana.peel()`是没有意义的，因为这些方法旨在操作实例。相反，我们应该创建一个实例，并在其上调用那些方法（例如，`my_banana.peel()`）。
- en: Magic attributes and methods
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 魔法属性和方法
- en: All Python objects automatically get a set of attributes called **magic attributes**
    and a set of methods called **magic methods**, also called special methods or
    *dunder methods*, because they are indicated by double underscores around the
    attribute or method name ("dunder" is a portmanteau of "double under").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Python对象都自动获得一组称为**魔法属性**的属性和一组称为**魔法方法**的方法，也称为特殊方法或*dunder方法*，因为它们由属性或方法名周围的两个下划线指示（“dunder”是“double
    under”的混合词）。
- en: 'Magic attributes generally store metadata about the object. For example, the
    `__class__` attribute of any object stores a reference to the object''s class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法属性通常存储关于对象的元数据。例如，任何对象的`__class__`属性存储了对对象类的引用：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Magic methods define how a Python object responds to operators (like `+`, `%`,
    or `[]`) or built-in functions (like `dir()` or `setattr()`). For example, the
    `__str__()` method defines what an object returns when passed to the `str()` function
    (either explicitly or implicitly, by being passed to `print()`, for example):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法方法定义了Python对象如何响应运算符（如`+`、`%`或`[]`）或内置函数（如`dir()`或`setattr()`）。例如，`__str__()`方法定义了当对象传递给`str()`函数（无论是显式还是隐式，例如通过传递给`print()`）时返回的内容：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we're not only accessing the instance's `color` attribute, but using the
    `__class__` attribute to retrieve its class, and then using the class object's
    `__name__` attribute to get the class name.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不仅访问实例的`color`属性，还使用`__class__`属性来检索其类，然后使用类对象的`__name__`属性来获取类名。
- en: As confusing as it is, the *class* is also an *object*. It's an instance of
    the `type` class. Remember, everything in Python is an object, and all objects
    are instances of some class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它很令人困惑，但**类**也是一个**对象**。它是`type`类的一个实例。记住，Python中的所有东西都是对象，所有对象都是某个类的实例。
- en: 'Thus, when a `Banana` object is printed, it looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当打印`Banana`对象时，它看起来是这样的：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By far the most important magic method is the **initializer** method, `__init__()`.
    This method is executed whenever we call the class object to create an instance,
    and the arguments we define for it become the arguments we can pass in when creating
    the instance. For example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最重要的魔法方法是**初始化器**方法，`__init__()`。每当调用类对象以创建实例时，该方法都会执行，我们为其定义的参数成为创建实例时可以传递的参数。例如：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we''ve created the initializer with an optional argument called `color`,
    allowing us to set the `Banana` object''s color value when creating the object.
    Thus, we can create a new `Banana` like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个带有可选参数`color`的初始化器，允许我们在创建对象时设置`Banana`对象的颜色值。因此，我们可以这样创建一个新的`Banana`：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Ideally, any instance attributes used in the class should be created within
    `__init__()`, so that we can ensure they exist for all instances of the class.
    For example, we should create our `peeled` attribute like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，任何在类中使用的实例属性都应该在`__init__()`中创建，这样我们就可以确保它们对于类的所有实例都存在。例如，我们应该这样创建我们的`peeled`属性：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we didn't define this attribute here, it would not exist until the `peel()`
    method is called. Code looking for the value of `my_banana.peel` before that method
    was called would raise an exception.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在这里定义这个属性，它将不会存在，直到调用`peel()`方法。在调用该方法之前寻找`my_banana.peel`值的代码将引发异常。
- en: Ultimately, the initializer should leave the object in a state where it is ready
    to be used by the program.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，初始化器应该使对象处于一个程序可以使用它的状态。
- en: In other object-oriented languages, the method that sets up a class object is
    known as the **constructor**, which not only initializes the new object but returns
    it as well. Sometimes, Python developers will casually refer to `__init__()` as
    a constructor. However, the actual constructor method for Python objects is `__new__()`,
    which we generally leave untouched in Python classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他面向对象的语言中，设置类对象的那个方法被称为**构造函数**，它不仅初始化新对象，还返回它。有时，Python开发者会随意将`__init__()`称为构造函数。然而，Python对象的实际构造方法为`__new__()`，我们通常在Python类中保持其不变。
- en: Public, private, and protected members
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共、私有和受保护的成员
- en: 'Classes are a powerful tool for *abstraction* – that is, taking a complicated
    object or process and providing a simple, high-level interface to the rest of
    the application. To help them do that, Python programmers use some naming conventions
    to distinguish between public, private, and protected members:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类是用于**抽象**的强大工具——也就是说，将复杂对象或过程简化为一个简单、高级的接口，供应用程序的其他部分使用。为了帮助它们做到这一点，Python程序员使用一些命名约定来区分公共、私有和受保护的成员：
- en: '**Public members** are those intended to be read or called by code outside
    the class. They use ordinary member names.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共成员**是那些打算由类外部的代码读取或调用的成员。它们使用普通的成员名称。'
- en: '**Protected members** are meant only for use inside the class or its subclasses.
    They are prefixed with a single underscore.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护成员**仅用于类内部或其子类。它们以单个下划线为前缀。'
- en: '**Private members** are meant only for use within the class. They''re prefixed
    with double underscores.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有成员**仅用于类内部。它们以双下划线为前缀。'
- en: Python does not actually enforce any distinction between public, protected,
    and private members; these are merely conventions that are understood by other
    programmers to indicate which parts of the class can be accessed externally, and
    which ones are part of the internal implementation and not meant for use outside
    the class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python实际上并不强制区分公共、受保护和私有成员；这些只是其他程序员理解并用来指示哪些部分可以外部访问，哪些是类内部实现的一部分且不打算在类外使用的规定。
- en: Python *will* assist in enforcing private members by automatically changing
    their names to `_classname__member_name`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python **会**通过自动将它们的名称更改为 `_classname__member_name` 来协助强制私有成员。
- en: 'For example, let''s add this code to the `Banana` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将以下代码添加到 `Banana` 类中：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `__ripe_colors` is a private attribute. If you tried to access `my_banana.__ripe_colors`,
    Python would raise an `AttributeError` exception because it has implicitly renamed
    this property to `my_banana._Banana__ripe_colors`. The method `_is_ripe()` is
    a protected member but, unlike the private member, Python does not alter its name.
    It could be executed as `my_banana._is_ripe()`, but programmers using your class
    would understand that this method is meant for internal use and not to be relied
    upon in external code. Instead, the `can_eat()` method, which is public, should
    be called.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`__ripe_colors` 是一个私有属性。如果你尝试访问 `my_banana.__ripe_colors`，Python 会抛出一个 `AttributeError`
    异常，因为它隐式地将这个属性重命名为 `my_banana._Banana__ripe_colors`。方法 `_is_ripe()` 是一个受保护成员，但与私有成员不同，Python
    不会更改它的名称。它可以作为 `my_banana._is_ripe()` 执行，但使用你的类的程序员会理解这个方法是为了内部使用，而不是在外部代码中依赖。相反，应该调用公共的
    `can_eat()` 方法。
- en: There are a variety of reasons why you'd want to indicate a member as private
    or protected, but in general, it's because the member is part of some internal
    process and would be either meaningless, unreliable, or lacking in context for
    use in outside code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因会让你想要将成员标记为私有或受保护，但通常是因为该成员是某些内部过程的一部分，对于外部代码的使用可能是无意义、不可靠或缺乏上下文。
- en: Although the words *private* and *protected* seem to indicate a security feature,
    that is not their intention, and using them does not provide any security to the
    class. The intention is simply to distinguish the public interface of the class
    (which outside code should use) from the internal machinery of the class (which
    should be left alone).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单词“私有”和“受保护”似乎表明了一种安全特性，但这并不是它们的意图，使用它们也不会为类提供任何安全性。意图仅仅是区分类的公共接口（外部代码应该使用）和类的内部机制（应该保持不变）。
- en: Inheritance and subclasses
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承和子类
- en: Building our own classes is a powerful tool indeed, but since everything in
    Python is an object built from a class, wouldn't it be nice if we could take one
    of those existing classes and simply alter it to fit our needs? That way, we wouldn't
    have to start from scratch every time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构建我们自己的类确实是一个强大的工具，但鉴于Python中的一切都是从一个类构建的对象，如果我们能够简单地修改其中一个现有类以适应我们的需求，那岂不是很好？这样我们就不必每次都从头开始了。
- en: 'Fortunately, we can! When we create a class, Python allows us to derive it
    from an existing class, like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以！当我们创建一个类时，Python 允许我们从现有类中派生它，如下所示：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ve created the class `RedBanana` as a **child class** or **subclass** of
    `Banana`. `Banana` is known as the **parent class** or **superclass** in this
    case. Initially, `RedBanana` is an exact copy of `Banana` and will behave identically,
    but we can modify it by simply defining members, like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了 `RedBanana` 类作为 `Banana` 的 **子类** 或 **派生类**。在这种情况下，`Banana` 被称为 **父类**
    或 **超类**。最初，`RedBanana` 是 `Banana` 的一个精确副本，将表现得完全相同，但我们可以通过简单地定义成员来修改它，如下所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Specifying existing members, like `colors` and `set_color`, will mask the superclass
    versions of those members. Thus, calling `set_color()` on a `RedBanana` instance
    will call the `RedBanana` version of the method, which, in turn, will consult
    the `RedBanana` version of `colors` when `self.colors` is referenced. We can also
    add new members, such as the `botanical_name` a ttribute, which will only exist
    in the subclass.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 指定现有成员，如`colors`和`set_color`，将掩盖超类中这些成员的版本。因此，在`RedBanana`实例上调用`set_color()`将调用`RedBanana`版本的方法，然后，当引用`self.colors`时，它将咨询`RedBanana`版本的`colors`。我们还可以添加新成员，如`botanical_name`属性，它将仅在子类中存在。
- en: 'In some cases, we might want our subclass method to add to the superclass method,
    but still execute the code in the superclass version of the method. We could copy
    the superclass code into our subclass code, but there''s a better way: using `super()`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望子类方法添加到超类方法中，但仍然执行超类方法版本中的代码。我们可以将超类代码复制到子类代码中，但有一个更好的方法：使用`super()`。
- en: 'Inside an instance method, `super()` gives us a reference to the superclass
    version of our instance, like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例方法内部，`super()`给我们提供了对超类版本实例的引用，如下所示：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, calling `super().peel()` causes the code in `Banana.peel()` to
    be executed on our `RedBanana` instance. Then, we can add additional code to our
    subclass version of `peel()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，调用`super().peel()`会导致在`RedBanana`实例上执行`Banana.peel()`中的代码。然后，我们可以在子类版本的`peel()`中添加额外的代码。
- en: As you'll see in the next section, `super()` is often used in the `__init__()`
    method to run the superclass's initializer. This is especially true for Tkinter
    GUI classes, which do a lot of critical external setup in their initializer methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一节中看到的，`super()`通常在`__init__()`方法中使用，以运行超类初始化器。这对于Tkinter GUI类来说尤其正确，因为它们在初始化方法中执行了很多关键的外部设置。
- en: There is much more to Python classes than we have discussed here, including
    the concept of **multiple inheritance**, which we will learn about in *Chapter
    5*, *Reducing User Error with Validation and Automation*. What we've learned so
    far, however, is more than enough to apply to our Tkinter code. Let's see how
    classes can help us in a GUI context.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Python类，我们在这里讨论的还有很多，包括**多重继承**的概念，我们将在第5章“通过验证和自动化减少用户错误”中学习到。然而，到目前为止我们所学的已经足够我们应用到Tkinter代码中。让我们看看类如何在GUI环境中帮助我们。
- en: Using classes with Tkinter
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter中的类
- en: 'GUI frameworks and object-oriented code go hand in hand. While Tkinter, more
    than most frameworks, allows you to create GUIs using procedural programming,
    we miss out on a great deal of organizational power in doing so. Although we''ll
    find many ways to use classes in our Tkinter code throughout this book, we''ll
    look at three primary ways of using them here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: GUI框架和面向对象代码是相辅相成的。虽然Tkinter比大多数框架都更允许你使用过程式编程创建GUI，但这样做我们会失去很多组织上的优势。尽管在这本书的整个过程中，我们会找到许多在Tkinter代码中使用类的方法，但在这里我们将探讨三种主要的类使用方法：
- en: Improving or expanding Tkinter classes for more power
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升或扩展Tkinter类以获得更多功能
- en: Creating **compound widgets** to save repetitive typing
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**复合小部件**以节省重复输入
- en: Organizing our application into self-contained **comp****onents**
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的应用程序组织成自包含的**组件**
- en: Improving Tkinter classes
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升Tkinter类
- en: 'Let''s face it: some Tkinter objects are a little lacking in functionality.
    We can fix that by subclassing Tkinter classes and making our own improved versions.
    For instance, while we''ve seen that Tkinter control variable classes are useful,
    hey are limited to string, integer, double, and Boolean types. What if we wanted
    the functionality of these variables, but for more complex objects like dictionaries
    or lists? We can, with subclassing and some help from JSON.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实：一些Tkinter对象在功能上有些不足。我们可以通过子类化Tkinter类并创建自己的改进版本来解决这个问题。例如，虽然我们已经看到Tkinter控制变量类很有用，但它们仅限于字符串、整数、双精度和布尔类型。如果我们想要这些变量的功能，但针对更复杂的对象，如字典或列表呢？我们可以通过子类化和一些JSON的帮助来实现。
- en: '**JavaScript Object Notation** (**JSON**) is a standardized format for representing
    lists, dictionaries, and other compound objects as strings. The Python standard
    library comes with a `json` library, which allows us to convert such objects to
    string format and back again. We''ll use JSON more in *Chapter 7*, *Creating Menus
    with Menu and Tkinter Dialogs*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）是一种标准化的格式，用于将列表、字典和其他复合对象表示为字符串。Python标准库自带了一个`json`库，它允许我们将这些对象转换为字符串格式，然后再转换回来。我们将在第7章“使用菜单和Tkinter对话框创建菜单”中更多地使用JSON。'
- en: 'Open a new script called `tkinter_classes_demo.py`, and let''s begin with some
    imports, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个名为 `tkinter_classes_demo.py` 的新脚本，让我们从一些导入开始，如下所示：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition to Tkinter, we''ve imported the standard library `json` module.
    This module contains two functions that we''ll use to implement our variable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Tkinter，我们还导入了标准库中的 `json` 模块。此模块包含两个函数，我们将使用它们来实现我们的变量：
- en: '`json.dumps()` takes a Python object like a list, dictionary, string, int,
    or float, and returns a string in JSON format.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json.dumps()` 接收一个 Python 对象，如列表、字典、字符串、整数或浮点数，并返回一个 JSON 格式的字符串。'
- en: '`json.loads()` takes a JSON string and returns a Python object like a list,
    dict, or string, depending on what was stored in the JSON string.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json.loads()` 接收一个 JSON 字符串并返回一个 Python 对象，如列表、字典或字符串，具体取决于 JSON 字符串中存储的内容。'
- en: 'Begin the new variable class by creating a subclass of `tk.StringVar` called
    `JSONVar`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `JSONVar` 的 `tk.StringVar` 子类来开始新的变量类：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To make our `JSONVar` work, we need to intercept the `value` argument wherever
    it is passed to the object and convert it into a JSON string using the `json.dumps()`
    method. The first such place is in `__init__()`, which we''ll override like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 `JSONVar` 正常工作，我们需要拦截任何传递给对象的 `value` 参数，并使用 `json.dumps()` 方法将其转换为 JSON
    字符串。第一个需要拦截 `value` 参数的地方是在 `__init__()` 方法中，我们将像这样覆盖它：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we're simply retrieving the `value` argument from the keywords and converting
    it into a string using `json.dumps()`. The converted string will overwrite the
    `value` argument, which will then be passed to the superclass initializer. In
    the event that a `value` argument isn't provided (remember, it is an optional
    argument), `kwargs.get()` will return `None`, which will be converted into a JSON
    `null` value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是从关键字参数中检索 `value` 参数，并使用 `json.dumps()` 将其转换为字符串。转换后的字符串将覆盖 `value`
    参数，然后将其传递给超类初始化器。如果未提供 `value` 参数（记住，它是一个可选参数），`kwargs.get()` 将返回 `None`，这将被转换为
    JSON `null` 值。
- en: When overriding methods in a class you didn't write, it's always a good idea
    to include `*args` and `**kwargs` to catch any arguments that you don't explicitly
    list. That way, the method will continue to allow all the arguments that the superclass
    version did, but you won't have to explicitly enumerate them all.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖你未编写的类中的方法时，始终包含 `*args` 和 `**kwargs` 是一个好主意，以捕获任何未明确列出的参数。这样，该方法将继续允许所有与超类版本相同的参数，但你不必明确列出它们。
- en: 'The next place we need to intercept the value is in the `set()` method, like
    this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要拦截 `value` 参数的下一个地方是在 `set()` 方法中，如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once again, we've intercepted the `value` argument and converted it into a JSON
    string before passing it to the superclass version of `set()`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次拦截了 `value` 参数，并在将其传递给超类版本的 `set()` 方法之前将其转换为 JSON 字符串。
- en: 'Last of all, let''s fix `get()`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们修复 `get()` 方法：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we''ve done the opposite of the other two methods: first, we got the
    string from the superclass, and then converted it back into an object using `json.loads()`.
    With that done, we''re ready! What we now have is a variable that can store and
    retrieve a list or dictionary, just like any other Tkinter variable.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做了与前两种方法相反的操作：首先，我们从超类中获取了字符串，然后使用 `json.loads()` 将其转换回对象。完成这些操作后，我们就准备好了！我们现在有一个可以存储和检索列表或字典的变量，就像任何其他
    Tkinter 变量一样。
- en: 'Let''s test it out:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, subclassing Tkinter objects opens up a whole new range of possibilities
    for our code. We'll apply this same concept to widget classes both later in this
    chapter and more extensively in *Chapter 5*, *Reducing User Error with Validation
    and Automation**.* First, though, let's look at two more ways we can use classes
    with Tkinter code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，子类化 Tkinter 对象为我们代码打开了全新的可能性。我们将在本章后面以及在第 5 章 *通过验证和自动化减少用户错误* 中更广泛地应用这一概念。不过，首先，让我们看看我们还可以用类与
    Tkinter 代码结合的两种方法。
- en: Creating compound widgets
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建复合小部件
- en: Many GUIs (particularly data entry forms) contain patterns that require a lot
    of repetitive boilerplate code. For example, input widgets usually have an accompanying
    label to tell the user what they need to enter. This often requires several lines
    of code to create and configure each object and add them to the form. We can not
    only save time, but ensure better consistency of output by creating a reusable
    **compound widget** that combines both into a single class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 许多GUI（尤其是数据输入表单）包含需要大量重复模板代码的模式。例如，输入小部件通常有一个伴随的标签来告诉用户他们需要输入什么。这通常需要几行代码来创建和配置每个对象并将它们添加到表单中。我们不仅可以节省时间，而且通过创建一个可重用的**复合小部件**将两者结合成一个单一类，还可以确保输出的一致性。
- en: 'Let''s combine an input widget and label by creating a `LabelInput` class,
    starting with this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个`LabelInput`类来组合输入小部件和标签，开始如下：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `tk.Frame` widget, a bare widget with nothing on it, is an ideal class to
    subclass for a compound widget. After starting our class definition, the next
    thing we need to do is think through all the pieces of data our widget will need,
    and make sure those can be passed into the `__init__()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`tk.Frame`小部件，一个没有任何内容的基础小部件，是一个理想的类，可以用来创建复合小部件。在开始我们的类定义之后，接下来我们需要做的是思考我们的小部件将需要哪些数据，并确保这些数据可以通过`__init__()`方法传递。'
- en: 'For a basic widget, the minimal set of arguments might look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个基本小部件，可能的最小参数集看起来可能如下所示：
- en: The parent widget
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父小部件
- en: The text for the label
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签的文本
- en: The type of input widget to use
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用的输入小部件类型
- en: A dictionary of arguments to pass to the input widget
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要传递给输入小部件的参数字典
- en: 'Let''s implement that in our `LabelInput` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`LabelInput`类中实现这一点：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first thing we do here is call the superclass initializer so that the `Frame`
    widget can be constructed. Note that we pass along the `parent` argument, since
    that will be the parent widget of the `Frame` itself; the parent widget for the
    `Label` and input widget is `self` – that is, the `LabelInput` object itself.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们首先调用超类初始化器，以便构建`Frame`小部件。请注意，我们传递了`parent`参数，因为这将成为`Frame`本身的父小部件；`Label`和输入小部件的父小部件是`self`——即`LabelInput`对象本身。
- en: Don't confuse "parent class" and "parent widget." "Parent class" refers to the
    superclass from which our subclass inherits its members. "Parent widget" refers
    to the widget (of a probably unrelated class) to which our widget is attached.
    To help avoid confusion, we'll stick to the super/subclass terminology in this
    book when speaking of class inheritance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆“父类”和“父小部件”。“父类”指的是我们的子类从中继承其成员的超类。“父小部件”指的是我们的小部件（可能属于一个无关的类）所附加的小部件。为了避免混淆，当我们在本书中讨论类继承时，我们将坚持使用超/子类术语。
- en: 'After creating our `label` and `input` widgets, we can arrange them on the
    `Frame` however we wish; for example, we might want labels next to the input,
    like so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的`label`和`input`小部件之后，我们可以根据需要将它们排列在`Frame`上；例如，我们可能希望标签位于输入旁边，如下所示：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or, we might prefer labels above our input widgets, as implemented here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能更喜欢在输入小部件上方使用标签，如下所示：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In either case, if we create all the inputs on our form using a `LabelInput`,
    we have the power to change the layout of *the entire form* using only three lines
    of code. We could conceivably add an initializer argument to configure the layout
    individually for each instance as well.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，如果我们使用`LabelInput`创建表单上的所有输入，我们就有能力仅用三行代码来改变整个表单的布局。我们还可以考虑添加一个初始化器参数，以便为每个实例单独配置布局。
- en: 'Let''s see this class in action. Since our `inp_args` argument is going to
    be expanded directly into our call to the `inp_cls` initializer, we can populate
    it with any arguments we''d like our input widget to receive, like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个类在实际中的应用。由于我们的`inp_args`参数将被直接扩展到对`inp_cls`初始化器的调用中，我们可以填充任何我们希望输入小部件接收到的参数，如下所示：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can even pass in a variable to bind to the widget:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将一个变量传递给绑定到小部件：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The compound widget saves us a few lines of code, but more importantly, it raises
    our input form code to a higher-level description of what's going on. Instead
    of being full of details about how each label is placed in relation to each widget,
    we can think about the form in terms of these larger components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 复合小部件为我们节省了一些代码，但更重要的是，它将我们的输入表单代码提升到对正在发生的事情的更高层次的描述。我们不必关注每个标签相对于每个小部件的放置细节，我们可以从这些更大的组件的角度来考虑表单。
- en: Building encapsulated components
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建封装的组件
- en: Creating compound widgets is useful for structures we plan to reuse in our application,
    but the same concept can be applied beneficially to larger pieces of our application,
    even if they only appear once.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建复合小部件对于我们在应用程序中计划重用的结构很有用，但同样的概念可以有益地应用于我们应用程序的更大块，即使它们只出现一次。
- en: Doing so allows us to attach methods to the components of our application to
    build self-contained units of functionality that are more easily managed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做使我们能够将方法附加到应用程序的组件上，以构建功能自包含的单元，这些单元更容易管理。
- en: 'For example, let''s create a `MyForm` class to hold a simple form:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个`MyForm`类来保存一个简单的表单：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Just as we did with the compound wiget, we've subclassed `tk.Frame` and defined
    a new initializer method. The `parent`, `*args`, and `**kwargs` arguments will
    get passed on to the superclass's initializer, but we'll also take a `data_var`
    argument, which will be an instance of our new `JSONVar` type. We'll use this
    argument to communicate the form data back out of the form.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们处理复合小部件一样，我们已经从`tk.Frame`派生子类并定义了一个新的初始化方法。`parent`、`*args`和`**kwargs`参数将被传递给超类初始化器，但我们还将接受一个`data_var`参数，它将是我们新`JSONVar`类型的实例。我们将使用此参数将表单数据传回表单。
- en: 'Next, we''ll create some internal control variables to bind to our form widgets:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些内部控制变量以绑定到我们的表单小部件：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we've already seen in our data entry application, keeping our form data variables
    in a dictionary will make it simple to extract data from them later. Rather than
    using a global variable, however, we've created the dictionary as a protected
    instance variable by adding it to `self` and prefixing it with an underscore.
    That's because this dictionary is meant for our form's internal use only.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在数据输入应用程序中已经看到的，将表单数据变量保存在字典中将使以后从它们中提取数据变得简单。然而，我们不是使用全局变量，而是通过将其添加到`self`并使用下划线作为前缀来创建字典作为受保护的实例变量。这是因为这个字典仅用于我们表单的内部使用。
- en: 'Now, let''s put our `LabelInput` class to work to create the actual widgets
    for our form:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们的`LabelInput`类来创建表单的实际小部件：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can see that `LabelInput` has trimmed our GUI-building code considerably!
    Now, let''s add a submit button for our form:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`LabelInput`大大减少了我们的GUI构建代码！现在，让我们为我们的表单添加一个提交按钮：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The submit button is configured to call a protected instance method named `_on_submit`.
    This shows us a powerful feature of using classes for our GUI components: by binding
    our button to an instance method, that method will have access to all the other
    instance members. For example, it can access our `_vars` dictionary:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 提交按钮被配置为调用名为`_on_submit`的保护实例方法。这展示了使用类为我们GUI组件提供的一个强大功能：通过将按钮绑定到实例方法，该方法将能够访问所有其他实例成员。例如，它可以访问我们的`_vars`字典：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Without using a class, we would have had to rely on global variables, such as
    we did in the `data_entry_app.py` application we wrote in *Chapter 3*, *Creating
    Basic Forms with Tkinter and Ttk Widgets*. Instead, our callback method needs
    only the implicitly passed `self` object to have access to all the objects that
    it needs. In this case, we're using a **dictionary comprehension** to extract
    all the data frm our widgets and, then storing the resulting dictionary in our
    `JSONVar` object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用类，我们就必须依赖于全局变量，就像我们在*第3章*中编写的`data_entry_app.py`应用程序中所做的那样。相反，我们的回调方法只需要隐式传递的`self`对象来访问它需要的所有对象。在这种情况下，我们使用**字典推导**从我们的小部件中提取所有数据，然后将结果字典存储在我们的`JSONVar`对象中。
- en: 'A dictionary comprehension is similar to a list comprehension, but creates
    a dictionary instead; the syntax is `{ key: value for expression in iterator }`.
    For example, if you wanted to create a dictionary of numbers with their squares,
    you could write `{ n: n**2 for n in range(100) }`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '字典推导类似于列表推导，但它创建一个字典；语法是`{ key: value for expression in iterator }`。例如，如果您想创建一个包含数字及其平方的字典，您可以编写`{
    n: n**2 for n in range(100) }`。'
- en: Thus, whenever the submit button is clicked, the `data_var` object will be updated
    with the current contents of the input widgets.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当点击提交按钮时，`data_var`对象将使用当前输入小部件的内容进行更新。
- en: Subclassing Tk
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 派生Tk
- en: We can extend this concept of component building all the way up to our top window,
    the `Tk` object. By subclassing `Tk` and building our other application components
    in their own classes, we can compose our application's layout and behavior in
    a high-level way.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将组件构建的概念扩展到顶级窗口`Tk`对象。通过从`Tk`派生子类并在它们自己的类中构建其他应用程序组件，我们可以以高级方式组合应用程序的布局和行为。
- en: 'Let''s try this with our current demo script:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们当前的演示脚本试一试：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember that the `Tk` object is not just our top-level window, but also represents
    the core of our application itself. Therefore we've named our subclass `Application`
    to indicate that it represents the foundation of our entire application. Our initializer
    method begins with the obligatory call to `super().__init__()`, passing along
    any arguments to the `Application.__init__()` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`Tk`对象不仅是我们顶级窗口，还代表了我们应用程序的核心。因此，我们将其子类命名为`Application`，以表明它代表了我们整个应用程序的基础。我们的初始化方法以必要的调用`super().__init__()`开始，并将任何参数传递给`Application.__init__()`方法。
- en: 'Next, we''ll create some variables to keep track of the data in our application:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些变量来跟踪我们应用程序中的数据：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `JSONVar`, as you might expect, will be passed into our `MyForm` object
    to handle its data. The `output_var` is just a `StringVar` we''ll use to display
    some output. Let''s next add some widgets to our window:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，`JSONVar`将被传递到我们的`MyForm`对象中，以处理其数据。`output_var`只是一个`StringVar`，我们将用它来显示一些输出。接下来，让我们向我们的窗口添加一些小部件：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we've added a simple header label for the form, a `MyForm` object, and
    another label to display the output. We've also configured the frame so that the
    first (and only) column expands into the extra space, and the second row (the
    one containing the form) expands into extra vertical space.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为表单添加了一个简单的标题标签，一个`MyForm`对象，以及另一个用于显示输出的标签。我们还配置了框架，使得第一列（也是唯一的一列）可以扩展到额外空间，第二行（包含表单的那一行）可以扩展到额外的垂直空间。
- en: 'Since a submission of `MyForm` updates the `JSONVar` object we passed to it,
    we''ll need a way to execute a submission-handling callback whenever the variable
    contents are changed. We can do this by setting a **trace** on `jsonvar`, like
    this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`MyForm`的提交会更新我们传递给它的`JSONVar`对象，我们需要一种方法在变量内容更改时执行提交处理回调。我们可以通过在`jsonvar`上设置一个**跟踪**来实现这一点：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `trace_add()` method can be used on any Tkinter vaiable (or variable subclass)
    to execute a callback function whenever a variable-related event occurs. Let's
    take a moment to examine it in more detail
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace_add()`方法可以用在任何一个Tkinter变量（或变量子类）上，在变量相关事件发生时执行回调函数。让我们花点时间更详细地考察它。'
- en: 'The first argument to `trace_add()` specifies the event that the trace will
    trigger on; it can be one of the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace_add()`的第一个参数指定了触发跟踪的事件；它可以是以下之一：'
- en: '`read`: The variable value is read (by a `get()` call, for example).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`：变量的值被读取（例如通过`get()`调用）。'
- en: '`write`: The variable value is modified (by a `set()` call, for example).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`：变量的值被修改（例如通过`set()`调用）。'
- en: '`unset`: The variable is deleted.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unset`：删除变量。'
- en: '`array`: This is an artifact of Tcl/Tk, not really meaningful in Python, but
    still valid syntax. You will likely never use it.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`：这是Tcl/Tk的一个遗迹，在Python中并不真正有意义，但仍然是有效的语法。你很可能永远不会用到它。'
- en: 'The second argument specifies a callback for the event, which, in this case,
    is the instance method `_on_data_change()`, which will be triggered whenever `jsonvar`
    is updated. We''ll handle it like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数指定了事件的回调函数，在这种情况下，是实例方法`_on_data_change()`，它将在`jsonvar`更新时被触发。我们将这样处理它：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method simply iterates through the values in the dictionary retrieved from
    `jsonvar`, and then joins them together into a single formatted string. Finally,
    the formatted string is passed into `output_var`, which will update the label
    at the bottom of the main window to display our values from the form. In a real
    application, you might save the retrieved data to a file or use them as parameters
    to a batch operation, for example.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法简单地遍历从`jsonvar`检索到的字典中的值，然后将它们组合成一个格式化的字符串。最后，将格式化的字符串传递给`output_var`，这将更新主窗口底部的标签以显示我们的表单值。在实际应用程序中，你可能会将检索到的数据保存到文件中，或者将它们用作批量操作的参数，例如。
- en: When should you use an instance variable (for example, `self.jsonvar`), and
    when should you use regular variables (for example, `data`), in an instance method?
    Regular variables in a method are **local** in their scope, meaning they are destroyed
    as soon as the method returns. In addition, they cannot be referenced by other
    methods in the class. Instance variables stay in scope for the lifetime of the
    instance itself, and are available for any other instance method to read or write.
    In the case of the `Application` class, the `data` variable was only needed inside
    the `_on_data_change()` method, whereas `jsonvar` needed to be accessed in both
    `__init__()` and `_on_datachange()`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例方法中，何时应该使用实例变量（例如，`self.jsonvar`），何时应该使用常规变量（例如，`data`）？方法中的常规变量在其作用域内是 **局部**
    的，这意味着一旦方法返回，它们就会被销毁。此外，它们不能被类中的其他方法引用。实例变量在其实例本身的整个生命周期内保持作用域，并且可供任何其他实例方法读取或写入。在
    `Application` 类的情况下，`data` 变量仅在 `_on_data_change()` 方法内部需要，而 `jsonvar` 需要在 `__init__()`
    和 `_on_datachange()` 中访问。
- en: 'Since we''ve subclassed `Tk`, we should no longer start our script with the
    line `root = tk.Tk()`. Make sure to delete that line, and also to delete the previous
    lines of the code that reference `root`. Instead, we''ll execute our application
    like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经从 `Tk` 继承了子类，我们不应再以 `root = tk.Tk()` 这行开始我们的脚本。请确保删除该行，以及删除引用 `root` 的代码的上一行。相反，我们将这样执行我们的应用程序：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that these lines, our class definitions, and our imports are the only top-level
    code we're executing. That cleans up our global scope considerably, isolating
    the finer details of our code to a more limited scope.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些行、我们的类定义和我们的导入是我们唯一执行的最高级代码。这大大清理了我们的全局作用域，将代码的更详细细节限制在一个更小的范围内。
- en: In Python, `if __name__ == "__main__":` is a common idiom to check if a script
    is being run directly, such as when we type `python3 tkinter_classes_demo.py`
    at a command prompt. If we were to import this file as a module into another Python
    script, this check would be false and the code inside the block would not be run.
    It's a good practice to put your program's main execution code below this check
    so that you can safely reuse your classes and functions in larger applications.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`if __name__ == "__main__":` 是一个常见的惯用语，用于检查脚本是否被直接运行，例如，当我们在一个命令提示符中键入
    `python3 tkinter_classes_demo.py` 时。如果我们将此文件作为模块导入到另一个 Python 脚本中，此检查将为假，并且该块内的代码将不会运行。将程序的主要执行代码放在此检查下面是一个好习惯，这样你就可以安全地在更大的应用程序中重用你的类和函数。
- en: Rewriting our application using classes
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类重写我们的应用程序
- en: 'Now that we''ve learned these techniques for using classes in our code, let''s
    apply it to our ABQ Data Entry application. We''ll start with a fresh file called
    `data_entry_app.py` and add in our import statements, like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了在代码中使用类的方法，让我们将其应用到我们的 ABQ 数据录入应用程序中。我们将从一个名为 `data_entry_app.py` 的新文件开始，并添加我们的导入语句，如下所示：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, let's see how we can apply some class-based techniques to rewrite a cleaner
    version of our application code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何应用一些基于类的技术来重写我们应用程序代码的更简洁版本。
- en: Adding a StringVar to the Text widget
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 Text 小部件添加 StringVar
- en: 'One annoyance we discovered in creating our application was that the `Text`
    widget does not allow the use of a `StringVar` to store its content, requiring
    us to treat it differently than all our other widgets. There *is* a good reason
    for this: the Tkinter `Text` widget is far more than just a multi-line `Entry`
    widget, capable of containing rich text, images, and other things that a lowly
    `StringVar` cannot store. That said, we''re not using any of those features, so
    it would be better for us to have a more limited `Text` widget that can be bound
    to a variable.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的应用程序时，我们发现的一个烦恼是 `Text` 小部件不允许使用 `StringVar` 来存储其内容，这迫使我们不得不与其他所有小部件不同地处理它。这确实有一个很好的原因：Tkinter
    的 `Text` 小部件远不止是一个多行 `Entry` 小部件，它可以包含富文本、图像和其他低级 `StringVar` 无法存储的东西。话虽如此，我们并没有使用这些功能，因此对我们来说，有一个更有限的
    `Text` 小部件，它可以绑定到一个变量上会更好。
- en: 'Let''s create a subclass called `BoundText` to solve this problem; start with
    this code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `BoundText` 的子类来解决这个问题；从以下代码开始：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our class needs to add three things to the `Text` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类需要向 `Text` 类添加三件事情：
- en: It needs to allow us to pass in a `StringVar`, which it will be bound to.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要允许我们传入一个 `StringVar`，它将被绑定到。
- en: It needs to update the widget contents whenever the variable is updated; for
    example, if it were loaded in from a file or changed by another widget.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要在变量更新时更新小部件内容；例如，如果它从文件中加载或被另一个小部件更改。
- en: It needs to update the variable contents whenever the widget is updated; for
    example, when the user types or pastes content into the widget.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要在小部件更新时更新变量内容；例如，当用户在控件中键入或粘贴内容时。
- en: Passing in a variable
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递一个变量
- en: 'We''ll begin by overriding the initializer to allow a control variable to be
    passed in:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先覆盖初始化器，以便传递一个控制变量：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In keeping with Tkinter convention, we'll use the `textvariable` argument to
    pass in the `StringVar` object. Having passed the remaining arguments to `super().__init__()`,
    we store the variable as a protected member of the class.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Tkinter的惯例，我们将使用`textvariable`参数传递`StringVar`对象。在将剩余参数传递给`super().__init__()`之后，我们将变量存储为类的保护成员。
- en: 'Next, if the user has provided a variable, we''ll go ahead and insert its contents
    into the widget (this takes care of any default value assigned to the variable):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果用户提供了变量，我们将将其内容插入到小部件中（这解决了分配给变量的任何默认值）：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that, if a variable was not passed in, `textvariable` (and consequently
    `self._variable`) will be `None`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有传递变量，`textvariable`（以及因此`self._variable`）将是`None`。
- en: Synchronizing the widget to the variable
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将小部件与变量同步
- en: The next thing we need to do is bind modifications of the control variable to
    an instance method that will update the widget.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要将控制变量的修改绑定到一个将更新小部件的实例方法。
- en: 'Still working in the `__init__()` method, let''s add a trace inside the `if`
    block we just created, like so:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`__init__()`方法中工作，让我们在刚刚创建的`if`块内添加一个跟踪，如下所示：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The callback for our trace is a protected member function called `_set_content()`,
    which will update the content of the widget with the contents of the variable.
    Let''s go ahead and create that callback:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跟踪的回调是一个名为`_set_content()`的保护成员函数，它将更新小部件的内容，以变量的内容为准。让我们继续创建这个回调：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, note that the argument list of our callback includes `*_`. This notation
    simply wraps up any positional arguments passed to the function in a variable
    called `_` (underscore). A single underscore, or series of underscores, is a conventional
    way of naming Python variables that we need to provide but don't intend to use.
    In this case, we're using it to consume any additional arguments that Tkinter
    will pass to this function when it calls it in response to an event. You'll see
    this same technique used in other callback methods whenever we intend to bind
    them to Tkinter events.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意我们的回调函数的参数列表中包含`* _`。这种表示法简单地将传递给函数的任何位置参数包装在一个名为`_`（下划线）的变量中。单个下划线或一系列下划线是我们用来命名Python变量的一种传统方式，我们提供这些变量但不打算使用它们。在这种情况下，我们使用它来消耗Tkinter在响应事件调用此函数时传递给此函数的任何额外参数。您将在我们打算将它们绑定到Tkinter事件的其他回调方法中看到这种技术被使用。
- en: Inside the method, we'll simply modify the widget contents using its `delete()`
    and `insert()` methods.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，我们将简单地使用其`delete()`和`insert()`方法修改小部件的内容。
- en: Synchronizing the variable to the widget
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将变量与小部件同步
- en: Updating the variable when the widget is modified is slightly more involved.
    We need to find an event that will fire whenever the `Text` widget is edited to
    bind to our callback. We could use the `<Key>` event, which fires whenever a key
    is pressed, but it won't capture mouse-based edits such as a paste operation.
    The `Text` widget does, however, have a `<<Modified>>` event that is emitted when
    it is first modified.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当小部件被修改时更新变量稍微复杂一些。我们需要找到一个事件，每当`Text`小部件被编辑时就会触发，以便绑定到我们的回调。我们可以使用`<Key>`事件，它在按键时触发，但它不会捕获基于鼠标的编辑，如粘贴操作。然而，`Text`小部件确实有一个`<<Modified>>`事件，它在第一次修改时发出。
- en: 'We can start with that; add another line to the end of our `if` statement in
    `__init__()`, as shown here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这里开始；在`__init__()`方法中`if`语句的末尾添加另一行，如下所示：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Rather unintuitively, though, `<<Modified>>` only fires the first time the widget
    is modified. After that, we'll need to reset the event by changing the widget's
    modified flag. We can do this using the `Text` widget's `edit_modified()` method,
    which also allows us to retrieve the state of the modified flag.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`<<Modified>>`事件仅在第一次修改小部件时触发。之后，我们需要通过更改小部件的修改标志来重置事件。我们可以使用`Text`小部件的`edit_modified()`方法来完成此操作，该方法还允许我们检索修改标志的状态。
- en: 'To see how this will work, let''s write the `_set_var()` callback:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这将如何工作，让我们编写`_set_var()`回调：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this method, we begin by checking if the widget has been modified by calling
    `edit_modified()`. If it has, we'll retrieve the content using the widget's `get()`
    method. Notice that the ending index for get is `end-1chars`. This means "one
    character before the end of the content." Recall that the `Text` widget's `get()`
    method automatically appends a newline to the end of the content, so by using
    this index, we can eliminate the extra newline.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先通过调用 `edit_modified()` 来检查小部件是否已被修改。如果是，我们将使用小部件的 `get()` 方法检索内容。请注意，`get`
    的结束索引为 `end-1chars`。这意味着“内容结束前的一个字符。”回想一下，`Text` 小部件的 `get()` 方法会自动将换行符追加到内容的末尾，因此通过使用此索引，我们可以消除额外的换行符。
- en: After retrieving the contents of the widget, we need to reset the modified flag
    by passing `False` into the `edit_modified()` method. That way, it is ready to
    fire the `<<Modified>>` event the next time the user interacts with the widget.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索小部件的内容后，我们需要通过将 `False` 传递给 `edit_modified()` 方法来重置已修改标志。这样，它就准备好在用户下次与小部件交互时触发
    `<<Modified>>` 事件。
- en: Creating a more advanced LabelInput()
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个更高级的 LabelInput()
- en: The `LabelInput` class we created earlier under *Creating compound widgets*
    seems useful, but if we want to use it in our program, it's going to require some
    more fleshing out.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *创建复合小部件* 下创建的 `LabelInput` 类似乎很有用，但如果我们想在程序中使用它，它将需要更多的完善。
- en: 'Let''s start, once again, with our class definition and initializer method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次从类定义和初始化方法开始：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As before, we've got arguments for the parent widget, label text, input class,
    and input arguments. Since every widget we want to use can now have a variable
    bound to it, we'll also go ahead and accept that as a required argument, and we'll
    add an optional argument for a dictionary of arguments to pass to the label widget,
    should we need that. We're defaulting `input_class` to `ttk.Entry`, since we have
    several of those.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，我们有父小部件、标签文本、输入类和输入参数的参数。由于我们现在想要使用的每个小部件都可以绑定一个变量，我们将接受它作为必需参数，并且如果需要，我们将添加一个可选参数来传递给标签小部件的参数字典。我们将
    `input_class` 默认设置为 `ttk.Entry`，因为我们有几个这样的小部件。
- en: Note that the default values for the `input_args` and `label_args` arguments
    are `None`, and that we make them dictionaries inside the method if they are `None`.
    Why not just use empty dictionaries as default arguments? In Python, default arguments
    are evaluated when the function definition is first run. This means that a dictionary
    object created in the function signature will be the same object every time the
    function is run, rather than a fresh, empty dictionary each time. Since we want
    a fresh, empty dictionary each time, we create the dictionaries inside the function
    body rather than the argument list. The same holds for lists and other mutable
    objects.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`input_args` 和 `label_args` 参数的默认值是 `None`，并且如果它们是 `None`，我们在方法内部将它们作为字典。为什么不直接使用空字典作为默认参数呢？在
    Python 中，默认参数是在函数定义首次运行时评估的。这意味着在函数签名中创建的字典对象将在每次函数运行时都是相同的对象，而不是每次都是一个新的空字典。由于我们希望每次都是一个新的空字典，所以我们将在函数体内部而不是在参数列表中创建字典。对于列表和其他可变对象也是如此。
- en: Inside the method, we call `super().__init__()` as usual, and then ensure that
    `input_args` and `label_args` are dictionaries. Finally, we'll save the `input_var`
    to an instance variable, and save the label widget itself as a property of the
    variable object. Doing this means we won't have to store references to our `LabelInput`
    objects; we can just access them through the variable object if we need to.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，我们像往常一样调用 `super().__init__()`，然后确保 `input_args` 和 `label_args` 是字典。最后，我们将
    `input_var` 保存到实例变量中，并将标签小部件本身保存为变量对象的属性。这样做意味着我们不需要存储 `LabelInput` 对象的引用；如果我们需要，我们可以通过变量对象来访问它们。
- en: 'Next, it''s time to set up the label, like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是设置标签的时候了：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`Checkbutton` and `Button` widgets have a label built into them, so we don''t
    want to have a separate label hanging around. Instead, we''ll just set the `text`
    argument of the widget to whatever is passed in. (`Radiobutton` objects also have
    a label built in, but we''ll handle those slightly differently, as you''ll see
    in a moment). For all other widgets, we''ll add a `Label` widget to the first
    row and column of the `LabelInput`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Checkbutton` 和 `Button` 小部件内部已经集成了标签，所以我们不希望有一个单独的标签悬挂在那里。相反，我们将只设置小部件的 `text`
    参数为传入的任何内容。（`Radiobutton` 对象也内置了标签，但我们会稍作不同处理，你将在下一刻看到）。对于所有其他小部件，我们将在 `LabelInput`
    的第一行和第一列中添加一个 `Label` 小部件。'
- en: 'Next, we need to set up the input arguments so that the input''s control variable
    will be passed in with the correct argument name:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置输入参数，以便输入的控制变量将以正确的参数名称传递：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Recall that button classes use `variable` as the argument name, while all others
    use `textvariable`. By handling this inside the class, we won't need to worry
    about that distinction when building our form.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 记得按钮类使用 `variable` 作为参数名称，而所有其他类使用 `textvariable`。通过在类内部处理这个问题，我们就不必在构建我们的表单时担心这种区别。
- en: Now, let's set up the input widget. Most widgets will be simple to set up, but
    for `Radiobutton`, we need to do something different. We need to create a `Radiobutton`
    widget for each possible value that's passed in (using the `values` key in `input_args`).
    Remember that we link the buttons by having them share the same variable, which
    we'll do here.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置输入小部件。大多数小部件的设置都很简单，但对于 `Radiobutton`，我们需要做些不同的事情。我们需要为传递的每个可能的值创建一个
    `Radiobutton` 小部件（使用 `input_args` 中的 `values` 键）。记住，我们通过让按钮共享相同的变量来链接它们，我们在这里也会这样做。
- en: 'We''ll add it like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样添加：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: First, we create a `Frame` object to hold the buttons; then, for each value
    passed into `values`, we add a `Radiobutton` widget to the `Frame` layout. Note
    that we call the `pop()` method to get the `values` item from the `input_args`
    dict. `dict.pop()` is nearly identical to `dict.get()`, returning the value of
    the given key if it exists, or the second argument if it does not. The difference
    is that `pop()` also deletes the retrieved item from the dictionary. We're doing
    this because `values` isn't a valid argument for `Radiobutton`, so we need to
    remove it before passing `input_args` to the `Radiobutton` initializer. The remaining
    items in `input_args` should be valid keyword arguments to the widget.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `Frame` 对象来容纳按钮；然后，对于传递给 `values` 的每个值，我们向 `Frame` 布局中添加一个 `Radiobutton`
    小部件。注意，我们调用 `pop()` 方法从 `input_args` 字典中获取 `values` 项。`dict.pop()` 几乎与 `dict.get()`
    相同，如果给定键存在，则返回该键的值，如果不存在，则返回第二个参数。区别在于 `pop()` 还会从字典中删除检索到的项。我们这样做是因为 `values`
    不是 `Radiobutton` 的有效参数，所以在将 `input_args` 传递给 `Radiobutton` 初始化器之前，我们需要将其删除。`input_args`
    中剩余的项应该是小部件的有效关键字参数。
- en: 'In the case of non-`Radiobutton` widgets, it''s pretty straightforward:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非 `Radiobutton` 小部件的情况，操作相当直接：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We simply call whatever `input_class` class has been passed in with the `input_args`.
    Now that we have `self.input` created, we just need to add it to the `LabelInput`
    layout:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需调用带有 `input_args` 参数的任何 `input_class` 类。现在我们已经创建了 `self.input`，我们只需将其添加到
    `LabelInput` 布局中：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The final call to `columnconfigure` tells the `LabelWidget` widget to fill its
    entire width with column `0`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次调用 `columnconfigure` 命令是告诉 `LabelWidget` 小部件填充其整个宽度至列 `0`。
- en: 'One convenient thing we can do when creating our own widgets (either a custom
    subclass or compound widget) is to set some reasonable defaults for the geometry
    layout. For example, we''re going to want all our `LabelInput` widgets to stick
    to the left- and right-hand sides of their container so that they fill the maximum
    width available. Rather than having to pass in `sticky=(tk.E + tk.W)` every single
    time we position a `LabelInput` widget, let''s make it the default, like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建自己的小部件时（无论是自定义子类还是复合小部件），我们可以为几何布局设置一些合理的默认值。例如，我们希望所有 `LabelInput` 小部件都紧贴其容器的左右两侧，以便它们填充最大可用宽度。而不是每次定位
    `LabelInput` 小部件时都必须传递 `sticky=(tk.E + tk.W)`，让我们将其设置为默认值，如下所示：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We've overridden `grid` and simply passed on the arguments to the superclass
    version but added a default for `sticky`. We can still override it if needed,
    but it will save us a lot of clutter to make that default.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了 `grid` 并将参数传递给了超类版本，但为 `sticky` 添加了一个默认值。如果需要，我们仍然可以覆盖它，但这将节省我们很多麻烦。
- en: Our `LabelInput` is fairly robust now; time to put it to work!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `LabelInput` 现在相当稳健了；是时候让它派上用场了！
- en: Creating a form class
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表单类
- en: 'Now that our building blocks are ready, it''s time to build the major components
    of our application. Breaking the application into sensible components requires
    some thinking about what might constitute a reasonable division of responsibilities.
    Initially, it seems like our application could be broken into two components:
    the data entry form and the root application itself. But which features go where?'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了构建块，是时候构建我们应用程序的主要组件了。将应用程序分解成合理的组件需要考虑什么可能构成合理的职责划分。最初，我们的应用程序似乎可以分解成两个组件：数据输入表单和根应用程序本身。但哪些功能放在哪里呢？
- en: 'One reasonable assessment might be as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一种合理的评估可能如下：
- en: The data entry form itself should contain all the widgets, of course. It should
    also hold the Save and Reset buttons, since these make no sense being separate
    from the form.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据输入表本身当然应该包含所有的小部件。它还应该包含保存和重置按钮，因为这些按钮与表分开没有意义。
- en: The application title and status bar belong at a universal level, since they
    will apply to all parts of the application. File saving could go with the form,
    but it also has to interact with some application-level items like the status
    bar or `records_saved` variable. It's a tricky call, but we'll put it with the
    application object for now.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序标题和状态栏属于通用级别，因为它们将适用于应用程序的所有部分。文件保存可以与表一起进行，但它还必须与一些应用程序级别的项目（如状态栏或`records_saved`变量）交互。这是一个棘手的选择，但我们将它暂时放在应用程序对象中。
- en: 'Let''s begin by building our data entry form class, `DataRecordForm`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建我们的数据输入表类`DataRecordForm`开始：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As always, we begin by subclassing `Frame` and calling the superclass's initializer
    method. We don't really need to add any custom arguments at this point.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们首先通过继承`Frame`并调用超类初始化方法来开始。在这个阶段，我们实际上不需要添加任何自定义参数。
- en: 'Now, let''s create a dictionary to hold all our variable objects:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个字典来保存所有我们的变量对象：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is just straight out of our data dictionary. Note that, thanks to our
    `BoundText` class, we can assign a `StringVar` object to Notes. Now, we''re ready
    to start adding widgets to our GUI. In the current version of our application,
    we added a `LabelFrame` widget for each section of the application using a chunk
    of code like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是直接从我们的数据字典中提取的。请注意，多亏了我们的`BoundText`类，我们可以将`StringVar`对象分配给注释。现在，我们准备开始向我们的GUI添加小部件。在我们的应用程序当前版本中，我们使用类似这样的代码块为应用程序的每个部分添加了一个`LabelFrame`小部件：
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This code was repeated for each frame, with only a change to the variable name
    and label text. To avoid this repetition, we can abstract this process into an
    instance method. Let''s create a method that can add a new label frame for us;
    add this code just above the `__init__()` definition:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为每个框架重复了一次，只是变量名和标签文本有所变化。为了避免这种重复，我们可以将这个过程抽象成一个实例方法。让我们创建一个可以为我们添加新的标签框架的方法；将此代码添加到`__init__()`定义之上：
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This method simply redefines the earlier code in a generic way, so we can just
    pass in the label text and, optionally, a number of columns. Scroll back down
    to where we were in the `DataRecordForm.__init__()` method, and let''s put this
    method to use by making a Record Information section, like so:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是以前面的代码以通用方式重新定义，这样我们就可以传入标签文本，以及可选的列数。回滚到我们在`DataRecordForm.__init__()`方法中的位置，让我们使用这个方法创建一个记录信息部分，如下所示：
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we have our frame, let''s give `LabelInput` a try and start building
    the first section of the form, like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了框架，让我们尝试使用`LabelInput`并开始构建表的第一部分，如下所示：
- en: '[PRE63]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, `LabelInput` has saved us a lot of redundant clutter already!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`LabelInput`已经为我们节省了很多冗余的杂乱。
- en: 'Let''s continue with the second line:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续第二行：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Remember that to use `RadioButton` widgets with `LabelInput`, we need to pass
    in a list of values to the input arguments, just as we do for `Combobox`. Having
    finished the `Record Information` section, let''s continue with the next section,
    `Environmental Data`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了使用与`LabelInput`一起的`RadioButton`小部件，我们需要将值列表传递给输入参数，就像我们对`Combobox`做的那样。完成`记录信息`部分后，让我们继续下一个部分，`环境数据`：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Again, we have added and configured a `LabelFrame` using our `_add_frame()`
    method, populating it with the four `LabelInput` widgets.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用我们的`_add_frame()`方法添加并配置了一个`LabelFrame`，并用四个`LabelInput`小部件填充它。
- en: 'Now, let''s add the `Plant Data` sections:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加`植物数据`部分：
- en: '[PRE66]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We''re almost done; let''s add our `Notes` section next:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了；让我们接下来添加我们的`注释`部分：
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we're taking advantage of our `BoundText` object so we can attach a variable.
    Otherwise, this looks like all the other calls to `LabelInput`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用我们的`BoundText`对象来附加一个变量。否则，这看起来就像对`LabelInput`的所有其他调用一样。
- en: 'Now, it''s time for the buttons:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加按钮了：
- en: '[PRE68]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As before, we've added our button widgets on a `Frame`. This time, though, we're
    going to pass in some instance methods as callback commands for the buttons. The
    `Reset` button will get an instance method we'll define in this class, but since
    we decided that saving a file was the application object's responsibility, we're
    binding the `Save` button to an instance method on the parent object (accessed
    through this object's `master` attribute).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们在`Frame`上添加了我们的按钮小部件。不过，这一次，我们将传递一些实例方法作为按钮的回调命令。`重置`按钮将获得我们在本类中定义的实例方法，但由于我们决定保存文件是应用程序对象的责任，我们将`保存`按钮绑定到父对象的实例方法（通过这个对象的`master`属性访问）。
- en: Binding GUI objects directly to commands on other objects is not a good way
    to approach the problem of inter-object communication, but for now it will do
    the job. In *Chapter 6*, *Planning for the Expansion of Our Application*, we'll
    learn a more elegant way to accomplish this.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将GUI对象直接绑定到其他对象的命令上不是解决对象间通信问题的好方法，但就目前而言，它将完成这项工作。在*第6章*，*为应用程序的扩展做准备*，我们将学习一种更优雅的方法来完成这项工作。
- en: 'That wraps up our `__init__()` method, but we''re going to need a couple more
    methods on this class before we''re done. First, we need to implement the `reset()`
    method that handles our form reset; it will look like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就结束了我们的`__init__()`方法，但在我们完成之前，这个类还需要几个更多的方法。首先，我们需要实现`reset()`方法来处理表单重置；它看起来是这样的：
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Essentially, we just need to set all our variables to an empty string. In the
    case of `BooleanVar` objects, though, this will raise an exception, so we need
    to set it to `False` to uncheck our checkbox.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们只需要将所有变量设置为空字符串。然而，对于`BooleanVar`对象，这样做将会引发异常，因此我们需要将其设置为`False`来取消选中复选框。
- en: 'Finally, we need a method that will allow the application object to retrieve
    data from the form so that it can save the data. In keeping with Tkinter convention,
    we''ll call this method `get()`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个方法，使得应用程序对象能够从表单中检索数据，以便它可以保存数据。按照Tkinter的约定，我们将这个方法命名为`get()`：
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The code here is very similar to the data retrieval code in the `on_save()`
    function of our previous version of the application, with a couple of differences.
    First, we're retrieving data from `self._vars` rather than a global variables
    dictionary. Secondly, in the event of an error, we're creating an error message
    and re-raising a `ValueError` rather than directly updating the GUI. We'll have
    to make sure that code that calls this method is written to handle a `ValueError`
    exception. Finally, rather than saving the data as we did in the previous version
    of the application, we're merely returning it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码与我们之前版本应用程序中`on_save()`函数的数据检索代码非常相似，但有几点不同。首先，我们从`self._vars`而不是全局变量字典中检索数据。其次，在发生错误的情况下，我们创建一个错误消息并重新抛出一个`ValueError`，而不是直接更新GUI。我们必须确保调用此方法的代码能够处理`ValueError`异常。最后，与之前版本的应用程序中保存数据的方式不同，我们只是返回数据。
- en: That completes the form class! Now all that remains is to code an application
    to keep it in.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了表单类的创建！现在剩下的只是编写一个应用程序来保持它。
- en: Creating an application class
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序类
- en: 'Our application class is going to handle application-level functionality as
    well as being our top-level window. GUI-wise, it needs to contain:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序类将处理应用程序级别的功能，同时也是我们的顶级窗口。在GUI方面，它需要包含：
- en: A title label
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题标签
- en: An instance of our `DataRecordForm` class
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们`DataRecordForm`类的一个实例
- en: A status bar
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态栏
- en: It will also need a method to save the data in the form to a CSV.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 它还需要一个方法将表单中的数据保存到CSV文件中。
- en: 'Let''s begin our class:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的类：
- en: '[PRE71]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Nothing new here, except that now we're subclassing `Tk` instead of `Frame`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的内容，只是现在我们正在继承`Tk`而不是`Frame`。
- en: 'Let''s set up some window parameters:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一些窗口参数：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As with the procedural version of the program, we''ve set the window title
    and configured the first column of the grid to expand. Now, we''ll create the
    title label:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序的程序性版本一样，我们已经设置了窗口标题并配置了网格的第一列以扩展。现在，我们将创建标题标签：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Nothing is really different here, except note that the parent object is now
    `self` – there isn't going to be a `root` object anymore; `self` is our `Tk` instance
    inside this class.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么真正不同的地方，只是要注意，父对象现在是`self`——将不再有`root`对象；`self`是这个类内部的`Tk`实例。
- en: 'Let''s create a record form:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个记录表单：
- en: '[PRE74]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Despite the size and complexity of `DataRecordForm`, adding it to the application
    is just like adding any other widget.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`DataRecordForm`的大小和复杂性，将其添加到应用程序中就像添加任何其他小部件一样简单。
- en: 'Now, for the status bar:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看状态栏：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Again, this is just like the procedural version, except that our `status` variable
    is an instance variable. This means it will be accessible to any of the methods
    in our class.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这和过程式版本非常相似，只是我们的`status`变量是一个实例变量。这意味着它将可以访问我们类中的任何方法。
- en: 'Finally, let''s create a protected instance variable to hold the number of
    records saved:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个受保护的实例变量来保存已保存的记录数：
- en: '[PRE76]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'With `__init__()` finished up, we can now write the last method: _`on_save()`.
    This method will be very close to the procedural function we wrote previously:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了`__init__()`方法后，我们现在可以编写最后一个方法：`_on_save()`。这个方法将非常接近我们之前编写的过程式函数：
- en: '[PRE77]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Once again, this function generates the filename using the current date, and
    then opens the file in append mode. This time, though, we can get our data by
    simply calling `self.recordform.get()`, which abstracts the process of getting
    data from its variables. Remember that we do have to handle `ValueError` exceptions
    in case there is bad data in the form, which we've done here. In the case of bad
    data, we simply display the error in the status bar and exit before the method
    attempts to save the data. If there is no exception, the data is saved, so we
    increment the `_records_saved` attribute and update the status.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个函数使用当前日期生成文件名，然后以追加模式打开文件。不过，这次我们可以通过简单地调用`self.recordform.get()`来获取我们的数据，这抽象了从变量获取数据的过程。记住，我们确实必须处理`ValueError`异常，以防表中有不良数据，我们在这里已经做到了。如果数据不良，我们只需在方法尝试保存数据之前在状态栏中显示错误并退出。如果没有异常，数据将被保存，因此我们增加`_records_saved`属性并更新状态。
- en: 'The final thing we need to make this application run is to create an instance
    of our `Application` object and start its `mainloop`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个应用程序运行的最后一件事情是创建我们的`Application`对象实例并启动其`mainloop`：
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note that, other than our class definitions and module imports, these two lines
    are the only ones being executed in the top-level scope. Also, because `Application`
    takes care of building the GUI and other objects, we can execute it and the `mainloop()`
    call together at the end of the application using the `if __name__ == "__main__"`
    guard.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了我们的类定义和模块导入之外，这两行是唯一在顶层作用域中执行的。另外，因为`Application`负责构建GUI和其他对象，所以我们可以使用`if
    __name__ == "__main__"`保护来一起在应用程序的末尾执行它和`mainloop()`调用。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned to take advantage of the power of Python classes.
    You learned to create your own classes, to define attributes and methods, and
    the function of magic methods. You also learned how to extend the functionality
    of existing classes with subclassing.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何利用Python类的强大功能。你学习了如何创建自己的类，定义属性和方法，以及魔术方法的功能。你还学习了如何通过子类化扩展现有类的功能。
- en: We explored how these techniques can be applied powerfully to Tkinter classes,
    to extend their functionality, build compound widgets, and organize our application
    into components.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何将这些技术有力地应用于Tkinter类，以扩展其功能，构建复合小部件，并将我们的应用程序组织成组件。
- en: In the next chapter, we'll learn about Tkinter's validation features, and further
    employ subclassing to make our widgets more intuitive and robust. We'll also learn
    how to automate input to save users time and ensure consistent data entry.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Tkinter的验证功能，并进一步使用子类化使我们的小部件更加直观和健壮。我们还将学习如何自动化输入以节省用户时间并确保数据输入的一致性。
