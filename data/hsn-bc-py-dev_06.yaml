- en: Interacting with Smart Contracts Using Web3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web3与智能合约交互
- en: In this chapter, you're going to learn how to connect to a smart contract programmatically.
    Here, you'll use the Python programming language to execute a method in a smart
    contract. To achieve that, you will use the `web3.py` library. In the previous
    chapter, you built a smart contract and deployed it to the Ethereum blockchain.
    You also used Vyper to write a smart contract. To interact with that smart contract,
    you fired up the Truffle console and typed in a number of commands. Those commands
    are sent to the smart contract in the blockchain. Depending on what command you
    type in, this could either read the state of the smart contract or change it. In
    this chapter, you are going to move beyond the Truffle console.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何以编程方式连接到智能合约。在这里，您将使用Python编程语言来执行智能合约中的方法。为了实现这一点，您将使用`web3.py`库。在上一章中，您构建了一个智能合约并将其部署到以太坊区块链上。您还使用Vyper编写了一个智能合约。为了与该智能合约交互，您启动了Truffle控制台并输入了许多命令。这些命令被发送到区块链中的智能合约。根据您输入的命令，这可能会读取智能合约的状态或更改状态。在本章中，您将超越Truffle控制台。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to decentralized applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化应用介绍
- en: Geth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Geth
- en: Understanding the `web3.py` library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`web3.py`库
- en: Interacting with smart contracts using `web3.py`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`web3.py`与智能合约交互
- en: Introduction to decentralized applications
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化应用介绍
- en: You'll build a program using Python to execute methods in a smart contract programmatically,
    and we call this program a decentralized application. So, there's a smart contract,
    and there's a decentralized application. A smart contract written with the Vyper
    or Solidity programming languages lives in an Ethereum blockchain. This means
    that if you deploy your smart contract to the Ethereum production blockchain,
    the bytecode of your smart contract is written in every Ethereum node. So, if
    we have 10,000 Ethereum nodes in this world, your smart contract is duplicated
    10,000 times.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用Python构建一个程序，以编程方式执行智能合约中的方法，我们称这个程序为去中心化应用。因此，有一个智能合约，还有一个去中心化应用。使用Vyper或Solidity编程语言编写的智能合约存在于以太坊区块链中。这意味着如果您将智能合约部署到以太坊生产区块链上，您的智能合约的字节码将写入每个以太坊节点。因此，如果我们在这个世界上有1万个以太坊节点，您的智能合约将被复制1万次。
- en: However, a decentralized application doesn't live in Ethereum blockchain. It
    lives in your computer, in your neighbor's computer, in a cloud, but it does not
    live on the blockchain, and it does not have to be duplicated all over the world
    in the same way as a smart contract. People build a decentralized application
    using various programming languages. In the case of Ethereum, the most popular
    programming languages for building a decentralized application are Javascript
    in the Node.js environment and Python. In our case, we are going to use Python
    to build a decentralized application. To do this, we need a library. In the case
    of Javascript , we need a `web3.js` library. In our case, which is Python, we
    need a `web3.py` library. All of the library names include the word web3.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，去中心化应用并不存储在以太坊区块链中。它存在于您的计算机中，邻居的计算机中，云中，但它并不存储在区块链上，并且不必像智能合约一样在全世界复制。人们使用各种编程语言构建去中心化应用。在以太坊的情况下，构建去中心化应用的最流行的编程语言是Node.js环境中的Javascript和Python。在我们的情况下，我们将使用Python来构建去中心化应用。为此，我们需要一个库。在Javascript的情况下，我们需要一个`web3.js`库。在我们的情况下，也就是Python，我们需要一个`web3.py`库。所有这些库的名称都包含了web3这个词。
- en: 'People like to think of web3 as a third version of the internet: a decentralized
    internet. So, if this is the third version, what are the first and second ones,
    you ask? The first version of the internet is the internet that you use to consume
    content passively (think static websites.) The second version of the internet
    is the social one, where you generate content and co-create experiences (think
    Facebook, Twitter, or Instagram):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 人们喜欢把web3看作是互联网的第三个版本：一个去中心化的互联网。那么，如果这是第三个版本，你会问第一个和第二个版本是什么？互联网的第一个版本是您用来被动消费内容的互联网（想想静态网站）。互联网的第二个版本是社交互联网，您在其中生成内容并共同创造体验（想想Facebook、Twitter或Instagram）：
- en: '![](assets/bb53afe9-871e-481e-b2ca-e482b52ca024.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bb53afe9-871e-481e-b2ca-e482b52ca024.png)'
- en: In the preceding screenshot, we can see that the Vyper or Solidity bytecode
    lives (duplicated) in many Ethereum nodes (system). But a program using the `web3`
    library can live in a single computer (such as a laptop or smartphone).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到Vyper或Solidity字节码存在（复制）于许多以太坊节点（系统）中。但是使用`web3`库的程序可以存在于单个计算机（例如笔记本电脑或智能手机）中。
- en: Installing web3
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装web3
- en: 'Without further ado, let''s install the `web3` library. Create a virtual environment
    with Python 3.6 as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们安装`web3`库。创建一个带有Python 3.6的虚拟环境如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Activate the virtual environment and install Vyper as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 激活虚拟环境并安装Vyper如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, install the `web3.py` library using `pip`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`pip`安装`web3.py`库：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, verify whether it works as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，验证它是否按以下方式工作：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you don''t encounter any errors, it works. Let''s connect to the Ganache
    blockchain with `web3`. To do this, first fire up Ganache, and then go back to
    your Python Command Prompt:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有遇到任何错误，那就可以了。让我们使用`web3`连接到Ganache区块链。要做到这一点，首先启动Ganache，然后返回到您的Python命令提示符：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What we have done here is connecting to Ganache blockchain with the `web3` library.
    We can retrieve the information on the blockchain, such as how many blocks have
    been mined on this particular blockchain. Because we are using Ganache, a development
    blockchain, `w3.eth.blockNumber` returns `0` because we have not created any transaction
    on Ganache.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是使用`web3`库连接到Ganache区块链。我们可以检索区块链上的信息，比如在这个特定区块链上挖掘了多少个区块。因为我们使用的是Ganache，一个开发区块链，`w3.eth.blockNumber`返回`0`，因为我们在Ganache上没有创建任何交易。
- en: Geth
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Geth
- en: '**Go Ethereum** (**Geth**) is an implementation of the Ethereum protocol written
    in Go. You can use Geth to sync an Ethereum node, or even build a private Ethereum
    blockchain. If you want to be a miner, this is a software that you would use.
    Your Ethereum node is a gateway and a part of Ethereum blockchain. Your program
    with the `web3` library requires the Ethereum node to be able to interact with
    a smart contract that lives inside the blockchain.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Go Ethereum**（**Geth**）是用Go语言编写的以太坊协议的实现。您可以使用Geth来同步以太坊节点，甚至构建私有以太坊区块链。如果您想成为矿工，这是您将使用的软件。您的以太坊节点是以太坊区块链的网关和一部分。您的程序与`web3`库需要以太坊节点才能与存储在区块链中的智能合约进行交互。'
- en: Using Ganache is all fine and dandy. But Ganache is a fake blockchain. There
    are no miners, so it's hard to simulate some situations that we would encounter
    on real Ethereum blockchain. As a result, let's step up our game. We don't need
    to use Ethereum production blockchain now, but we can use something in between
    development and production blockchain—the **Rinkeby network**. If the Ethereum
    production blockchain is akin to a production server, the Rinkeby network is like
    a staging server. In DevOps lingua franca, a staging server is a test server that
    mimics a production server as closely as possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ganache是很好的。但Ganache是一个假的区块链。没有矿工，因此很难模拟我们在真实以太坊区块链上可能遇到的一些情况。因此，让我们提高我们的游戏水平。我们现在不需要使用以太坊生产区块链，但我们可以使用介于开发和生产区块链之间的东西——Rinkeby网络。如果以太坊生产区块链类似于生产服务器，那么Rinkeby网络就像一个暂存服务器。在DevOps的语言中，暂存服务器是尽可能模拟生产服务器的测试服务器。
- en: 'So, Rinkeby is not a software like Ganache. It lives on the internet. As a
    result, using the Rinkeby network, we can get a feel for what it is like to deal
    with the Ethereum production blockchain. One of the situations you could encounter
    in Etherum blockchain in the Rinkeby network is that it takes time to confirm
    a transaction. In Ganache, it takes a fraction of a second to confirm a transaction.
    In the Rinkeby network, it takes maybe 20-30 seconds, or even a minute, to confirm
    a transaction, so you need to get used to it. Of course, not everything in the
    Ethereum production blockchain can be replicated on the Rinkeby network. Another situation
    that specifically happens in the Ethereum production blockchain is that it includes
    the high traffic that the Ethereum production blockchain sometimes gets. For example,
    a decentralized application named Cryptokitties slowed down the Ethereum network
    because there are many users interacting with the application, as can be seen
    here: [https://techcrunch.com/2017/12/03/people-have-spent-over-1m-buying-virtual-cats-on-the-ethereum-blockchain/](https://techcrunch.com/2017/12/03/people-have-spent-over-1m-buying-virtual-cats-on-the-ethereum-blockchain/).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Rinkeby不像Ganache那样是一个软件。它存在于互联网上。因此，使用Rinkeby网络，我们可以感受到与以太坊生产区块链打交道是什么感觉。在以太坊区块链的Rinkeby网络中，您可能会遇到的情况之一是确认交易需要时间。在Ganache中，确认交易只需要一小部分秒数。在Rinkeby网络中，确认交易可能需要20-30秒，甚至一分钟，因此您需要习惯。当然，并非以太坊生产区块链中的所有情况都可以在Rinkeby网络上复制。在以太坊生产区块链中特别发生的另一种情况是，它包括以太坊生产区块链有时会出现的高流量。例如，一个名为Cryptokitties的去中心化应用程序减慢了以太坊网络，因为有许多用户与该应用程序进行交互，可以在这里看到：[https://techcrunch.com/2017/12/03/people-have-spent-over-1m-buying-virtual-cats-on-the-ethereum-blockchain/](https://techcrunch.com/2017/12/03/people-have-spent-over-1m-buying-virtual-cats-on-the-ethereum-blockchain/)。
- en: There is another Ethereum testing network similar to the Rinkeby network—the
    **Ropsten network**. The difference here is that the Rinkeby network uses **Proof-of-Authority**
    (**PoA**) in confirming transactions, while the Ropsten network uses **Proof-of-Work**
    (**PoW**). Right now, there is no need to worry about this difference, since using
    the Rinkeby network is similar to using the Ropsten network.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个类似于Rinkeby网络的以太坊测试网络——Ropsten网络。这里的区别在于Rinkeby网络在确认交易时使用**权威证明**（**PoA**），而Ropsten网络使用**工作量证明**（**PoW**）。现在不需要担心这种区别，因为使用Rinkeby网络类似于使用Ropsten网络。
- en: There are two ways to connect to this kind of Ethereum blockchain—by running
    Ethereum node yourself, or by using other people's nodes. Each method comes with
    its own advantages and disadvantages. Running an Ethereum node takes up a lot
    of storage. A node connecting to the Rinkeby network requires around 6 GB of storage.
    As regards the Ethereum production network, it requires a whopping 150 GB of storage.
    Depending on your internet connection, to be fully operational, you need a night
    or a couple of days to make the node fully synchronized with all other nodes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到这种类型的以太坊区块链有两种方法——自己运行以太坊节点，或者使用其他人的节点。每种方法都有其优点和缺点。运行一个以太坊节点需要大量存储空间。连接到Rinkeby网络的节点需要大约6GB的存储空间。至于以太坊生产网络，需要高达150GB的存储空间。根据您的互联网连接，要完全运行，您需要一晚或几天时间，使节点与所有其他节点完全同步。
- en: Another method is to use someone else's node. Some people build a web service
    to connect to their Ethereum node, so you can use an API to connect to their Ethereum
    node. One of the most popular services for this is Infura. All you need to do
    here is register on their website to get their API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用其他人的节点。有些人构建了一个连接到他们的以太坊节点的网络服务，因此您可以使用API连接到他们的以太坊节点。其中最受欢迎的服务之一是Infura。在这里，您只需要在他们的网站上注册以获取他们的API。
- en: To run our own Ethereum node for the Rinkeby network, go to [https://geth.ethereum.org/downloads/](https://geth.ethereum.org/downloads/)
    to download the software for your operating system. For Ubuntu Linux, this is
    in `tar.gz` format, so you have to extract it. Then, put the binary file somewhere
    convenient (something such as `/opt/bin` or `/home/yourusername/Program` or `/user/local/bin`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Rinkeby网络上运行我们自己的以太坊节点，请转到[https://geth.ethereum.org/downloads/](https://geth.ethereum.org/downloads/)下载适用于您的操作系统的软件。对于Ubuntu
    Linux，这是以`tar.gz`格式，因此您需要解压缩它。然后，将二进制文件放在方便的位置（例如`/opt/bin`或`/home/yourusername/Program`或`/user/local/bin`）。
- en: 'After doing this, synchronize the node as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，按以下方式同步节点：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can use a different data directory. By default, Geth stores the data in
    the `~/.ethereum` directory:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用不同的数据目录。默认情况下，Geth将数据存储在`~/.ethereum`目录中：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In my case, this takes a night. Your experience may be different depending on
    how fast your internet connection is.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，这需要一个晚上。你的经验可能会因你的互联网连接速度而有所不同。
- en: 'If it is fully synced (you know this is the case when the output no longer
    changes that often), then you can run Python inside the `web3-venv` virtual environment
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它完全同步（当输出不再经常更改时，你就知道这种情况），那么你可以在`web3-venv`虚拟环境中运行Python，如下所示：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are using a different provider to the one we used in the previous example.
    With the Ganache example, we use an HTTP provider. Remember that Ganache uses
    `http://localhost:7545` and you use this information in the Truffle configuration.
    However, in our case, when we connect to the Ethereum node, we use **Inter Process
    Communication provider** (**IPC**). You can also see a parameter of `IPCProvider` ,
    which is a file path. So your Python program communicates with the Ethereum node
    by means of that file. In computer science, that file is called a `pipe`. You
    just search where the `geth.ipc` file lives on your local computer. Remember that `geth.ipc`
    only shows up if you run `geth` software. If you stop it, the `geth.ipc` file will
    disappear.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了与之前示例中不同的提供者。在Ganache示例中，我们使用HTTP提供者。请记住，Ganache使用`http://localhost:7545`，你需要在Truffle配置中使用这些信息。然而，在我们的情况下，当我们连接到以太坊节点时，我们使用**进程间通信提供者**（**IPC**）。你还可以看到`IPCProvider`的一个参数，它是一个文件路径。因此，你的Python程序通过那个文件与以太坊节点通信。在计算机科学中，那个文件被称为`pipe`。你只需搜索`geth.ipc`文件在你的本地计算机上的位置。请记住，只有在运行`geth`软件时，`geth.ipc`才会出现。如果你停止它，`geth.ipc`文件将消失。
- en: 'Then, before you run business as usual, you need to inject something into the
    web3 middleware. This should be done because the block size in the Ethereum production
    blockchain is different to the block size in the Rinkeby blockchain:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你像往常一样运行业务之前，你需要向web3中间件注入一些东西。这应该这样做，因为以太坊生产区块链中的区块大小与Rinkeby区块链中的区块大小不同：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, you can test it, as shown in the following code block:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以测试它，如下面的代码块所示：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output you got is the information regarding the latest block of blockchain
    in the Rinkeby network. There are a couple of things that you can learn from the
    block of blockchain. You can find all the transactions that have been confirmed
    in this block; the gas used, the gas limit, and so on. In the Rinkeby network,
    the miner is always the zero address (`0x0000000000000000000000000000000000000000`),
    because blockchain in the Rinkeby network uses proof of authority. But in mainnet
    (production network), you can find out who got the reward to confirm the blockchain.
    You can find the information from the latest block in mainnet (the Ethereum production
    network) from [https://etherscan.io/blocks](https://etherscan.io/blocks). Of course,
    you could find the same information from the Ethereum production node if you are
    willing to sync the node.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的输出是Rinkeby网络区块链的最新区块的信息。你可以从区块链的区块中学到一些东西。你可以找到在这个区块中已确认的所有交易；使用的燃气，燃气限制等等。在Rinkeby网络中，矿工始终是零地址（`0x0000000000000000000000000000000000000000`），因为Rinkeby网络中的区块链使用权威证明。但在主网（生产网络）中，你可以找出谁获得了确认区块链的奖励。你可以从主网（以太坊生产网络）的最新区块中找到这些信息。当然，如果你愿意同步节点，你也可以从以太坊生产节点中找到相同的信息。
- en: Geth console
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Geth控制台
- en: 'Before we continue to use the `web3` library, let''s play around with Geth
    software. Geth software can act like the Truffle console:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用`web3`库之前，让我们先尝试一下Geth软件。Geth软件可以像Truffle控制台一样工作：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The keyword is `console` in that statement, but in order to make it a more
    pleasant experience, you should add another `--verbosity` flag with a value of `0`.
    This will prevent you from getting bogged down with a lot of output from the `geth`
    software:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在该语句中，关键字是`console`，但为了使体验更愉快，你应该添加另一个`--verbosity`标志，值为`0`。这将防止你从`geth`软件中获得大量输出。
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the Geth console, you can do anything that you can do in the Truffle console.
    However, we now want to create an Ethereum account. When you launch Ganache, you
    are equipped with 10 accounts that are ready to be used. However, this is not
    the case in the Rinkeby blockchain. You need to create an account manually in
    Rinkeby:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Geth控制台中，你可以做任何你在Truffle控制台中可以做的事情。然而，我们现在想要创建一个以太坊账户。当你启动Ganache时，你会得到10个可以使用的账户。但在Rinkeby区块链中情况并非如此。你需要在Rinkeby中手动创建一个账户：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the command to create a new Ethereum account. You need to supply a password
    to create an account in the Geth console. Don't forget the password for this account,
    as there is no option to recover it. The output of this command is your account's
    public address.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建一个新的以太坊账户的命令。你需要提供一个密码来在Geth控制台中创建一个账户。不要忘记这个账户的密码，因为没有恢复它的选项。该命令的输出是你账户的公共地址。
- en: 'The private key is encrypted in a file inside the following directory: `/home/yourusername/.geth/rinkeby/keystore`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥被加密在以下目录的文件中：`/home/yourusername/.geth/rinkeby/keystore`。
- en: 'The file name is something like this: `UTC—2018-10-12T09-30-20.687898000Z—28f5b56b035da966afa609f65fd8f7d71ff68327`.
    This is a combination of a timestamp and public key. You can open it, but you
    will not be able to find the private key inside it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名类似于`UTC—2018-10-12T09-30-20.687898000Z—28f5b56b035da966afa609f65fd8f7d71ff68327`。这是时间戳和公钥的组合。你可以打开它，但你将无法在其中找到私钥。
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To decrypt it, you can use the `web3` library. Name the script `extract_private_key.py`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密它，你可以使用`web3`库。将脚本命名为`extract_private_key.py`：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you execute the script, you will see your private key, which can be used
    in another situation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行该脚本，你将看到你的私钥，它可以在其他情况下使用：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Please do not use this account in a production setting any more because the
    private key is already exposed. Use it for development purposes only.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要再在生产环境中使用这个账户，因为私钥已经暴露。只能用于开发目的。
- en: 'This private key is in `bytes` format. If you want to convert it to a hex string,
    you can do it like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此私钥以`bytes`格式。如果要将其转换为十六进制字符串，可以这样做：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Understanding the web3.py library
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解web3.py库
- en: 'Now, let''s write a decentralized application with this library. The simplest
    decentralized application script would be sending money from one account to another.
    Name the script `send_money_ganache.py`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个库编写一个去中心化的应用程序。最简单的去中心化应用程序脚本将是从一个账户向另一个账户发送资金。将脚本命名为`send_money_ganache.py`：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before you execute this script, launch Ganache first. After doing so, take
    any public address you like and put it into the `to` field in the transaction
    dictionary. This account will be the receiver. Then find another account, look
    at its private key, and input the value in the `private_key` variable:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此脚本之前，首先启动Ganache。这样做后，选择任何您喜欢的公共地址，并将其放入交易字典中的`to`字段。这个账户将成为接收者。然后找到另一个账户，查看其私钥，并将值输入到`private_key`变量中：
- en: '![](assets/2cef175b-2047-433c-b849-69d84d925d92.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2cef175b-2047-433c-b849-69d84d925d92.png)'
- en: Put one ether in the `value` field. This means you want to send 1 ether to another
    account. This is a simple script to illustrate how sending a transaction works.
    It does not show best practice because you shouldn't put a private key embedded
    in the code like this. You could read a private key from the file with restricted
    permission, for example, or you could request the private key from the standard
    input.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`value`字段中放入一个以太。这意味着您想向另一个账户发送1个以太。这是一个简单的脚本，用来说明如何发送交易。它并不展示最佳实践，因为您不应该像这样将私钥嵌入代码中。例如，您可以从受限制的权限文件中读取私钥，或者可以从标准输入请求私钥。
- en: 'If you execute this script, you would notice that the receiver''s balance would
    increase by 1 ETH, while the sender''s balance would decrease by 1 ETH:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行此脚本，您会注意到接收者的余额会增加1个ETH，而发送者的余额会减少1个ETH：
- en: '![](assets/79c28369-b896-4f17-b5d0-454b93a5a90e.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/79c28369-b896-4f17-b5d0-454b93a5a90e.png)'
- en: 'Here is the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](assets/f653adc0-e03c-4fc7-93ba-885e22a7c240.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f653adc0-e03c-4fc7-93ba-885e22a7c240.png)'
- en: Gas and gas price
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gas和gas价格
- en: As you will know, Ethereum blockchain is not free; someone has to maintain it.
    I am not talking about developers who write Ethereum software, but miners who
    run Ethereum nodes to confirm transactions. They are rewarded with money (ETH)
    from Ethereum software itself. On top of that, they are rewarded with the fee
    of the transaction. This fee is the gas and gas price.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，以太坊区块链并不是免费的；有人必须维护它。我不是在谈论编写以太坊软件的开发人员，而是运行以太坊节点以确认交易的矿工。他们从以太坊软件本身获得ETH的报酬。此外，他们还从交易的费用中获得报酬。这个费用就是gas和gas价格。
- en: Why do we need a fee on top of a reward in Ethereum software? This is to prevent
    spam from users. If a transaction is free, a troller could set up two accounts,
    sending the money back and forth between them. In addition, this gives high priority
    to users who want to pay more. If there are two similar transactions, but the
    first transaction is backed with more gas, it would be of higher priority in a
    miner's to-do list. The transaction with less gas will be confirmed in the end;
    it just needs to wait a little bit longer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么以太坊软件需要在奖励之上收取费用？这是为了防止用户滥发垃圾信息。如果交易是免费的，滥发者可以设置两个账户，之间来回发送资金。此外，这会给愿意支付更多的用户高优先级。如果有两个类似的交易，但第一笔交易使用的gas更多，它将在矿工的待办事项列表中具有更高的优先级。使用更少gas的交易最终会得到确认；它只需要等待更长一点时间。
- en: 'So there is gas and there is a gas price. Gas is the amount of gas you are
    willing to allocate in this transaction. In a previous script, you allocate 20,000
    gas to create a transaction to send the money. For a more complex transaction,
    such as executing a complex method in a smart contract, it could require more
    gas. If you don''t allocate enough gas, your transaction would be rejected and
    you could lose gas as well. But if you put more than enough gas, if your transaction
    is successful, the remaining gas would be returned to you. So, you would think:
    Why not just set gas aside as much as possible? There is a catch. If, somehow,
    your call of a method in a smart contract fails assertion (for example: assert
    1 == 2), you would lose all the gas you use up until the assertion line (but the
    remaining gas will be refunded). So you need to hit the middle ground.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此有gas和gas价格。Gas是您愿意在此交易中分配的gas数量。在先前的脚本中，您分配了20,000 gas来创建一个发送资金的交易。对于更复杂的交易，比如执行智能合约中的复杂方法，可能需要更多的gas。如果您没有分配足够的gas，您的交易将被拒绝，您也可能会损失gas。但是，如果您放入的gas超过了所需量，如果您的交易成功，剩余的gas将退还给您。因此，您可能会想：为什么不尽可能多地设置gas？有一个陷阱。如果一些方法在智能合约中失败了断言（例如：assert
    1 == 2），您将失去直到断言行之前使用的所有gas（但剩余的gas将被退还）。因此，您需要找到折中之道。
- en: Gas price is the price of the gas, so gas is not free. It's separated from Ethereum
    itself. You buy gas with the ETH you have. You could check the gas price in historical
    transactions. In the Ethereum production blockchain, you could check the price
    of the gas in [https://www.ethgasstation.info/](https://www.ethgasstation.info/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Gas价格是gas的价格，因此gas不是免费的。它与以太坊本身分开。您可以用您拥有的ETH购买gas。您可以在历史交易中查看gas价格。在以太坊生产区块链中，您可以在[https://www.ethgasstation.info/](https://www.ethgasstation.info/)上查看gas价格。
- en: 'How do you estimate the gas you need for your transaction? You need to learn
    all the intricacy of the Solidity or Vyper programming languages. If I allocate
    a variable of integer with 256 bits and store it in storage, how much would it
    cost? What about looping? What about constructing a struct? This sounds complicated,
    but luckily, the `web3` library has a method to estimate gas usage. First, create
    a script named `estimate_gas.py`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何估计交易所需的gas？您需要了解Solidity或Vyper编程语言的所有复杂性。如果我分配一个256位整数变量并将其存储在存储器中，会花费多少？循环呢？构造一个结构呢？这听起来很复杂，但幸运的是，`web3`库有一个估算gas使用量的方法。首先，创建一个名为`estimate_gas.py`的脚本：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You would get this output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you find an error related to nonce, change nonce to 1 or higher until it
    works. Well talk about nonce in the following section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现与随机数相关的错误，请将随机数更改为1或更高，直到它起作用。我们将在下一节讨论随机数。
- en: Nonce
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机数
- en: You may have observed that you get errors related to nonce if you try to execute
    the sending money script more than once. If you haven't, try it. You have to increase
    nonce to make it work again. Nonce is like an indicator of how many transactions
    you have made with an account. For the first transaction (just after creating
    a new account), you put zero value in nonce. Then, for the second transaction,
    you put a value of 1 in nonce. Then, for the third transaction, you put a value
    of 2 in nonce.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，如果尝试多次执行发送资金脚本，会出现与随机数相关的错误。如果您还没有尝试，请尝试一下。您必须增加随机数才能使其再次工作。随机数就像是您使用一个账户进行了多少笔交易的指示器。对于第一笔交易（在创建新账户后），您在随机数中放入零值。然后，对于第二笔交易，您在随机数中放入1的值。然后，对于第三笔交易，您在随机数中放入2的值。
- en: 'But keeping track of the nonce value becomes silly, especially if you want
    to use an old account on which you don''t know how high the nonce value is. Fortunately,
    there is a way of obtaining the latest nonce value from Ethereum blockchain. Create
    a script named `get_latest_nonce.py`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是跟踪随机数值变得愚蠢，特别是如果您想使用一个旧账户，而您不知道随机数值有多高。幸运的是，有一种方法可以从以太坊区块链中获取最新的随机数值。创建一个名为`get_latest_nonce.py`的脚本：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Try to send money again with a higher nonce, and then execute this script. Do
    it again. This will show you the value tallies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用更高的随机数再次发送资金，然后执行此脚本。再做一次。这将显示给您价值总额。
- en: With this new knowledge, you must be careful to create a transaction in Ethereum
    blockchain. In the real world, transactions could take time to be confirmed. Imagine
    you create two different transactions in parallel with the same nonce. If both
    transactions are valid, only one of them will be recorded on Ethereum blockchain.
    The other one will be rejected because of a nonce issue. Which transaction of
    these two will be confirmed? It would be quite random.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新知识，您必须小心创建以太坊区块链上的交易。在现实世界中，交易可能需要时间才能得到确认。想象一下，您同时创建了两笔不同的交易，它们的随机数相同。如果这两笔交易都有效，只有其中一笔会被记录在以太坊区块链上。另一笔将被拒绝，因为存在随机数问题。这两笔交易中的哪一笔将得到确认？这将是相当随机的。
- en: Instead, you must decide which transaction you want to be confirmed first. Give
    it a lower nonce. For the second transaction, you accord a higher nonce. However,
    if the first transaction fails, the second transaction will be rejected because
    the nonce is too high (the nonce skips one number). This is something you need
    to bear in mind.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您必须决定要先确认哪笔交易。给它一个较低的随机数。对于第二笔交易，您给予一个较高的随机数。但是，如果第一笔交易失败，第二笔交易将被拒绝，因为随机数太高（随机数跳过一个数字）。这是您需要牢记的事情。
- en: So why all of this nonce bureaucracy? It is to prevent the same transaction
    from happening again. Imagine you broadcast a transaction where you send one ETH
    to your neighbor. I could copy this transaction and broadcast it again. Since
    this transaction is validated with your signature, I could drain your account.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么要有这些随机数官僚主义？这是为了防止相同的交易再次发生。想象一下，您广播了一笔交易，向您的邻居发送了1个ETH。我可以复制这笔交易并再次广播。由于这笔交易是通过您的签名验证的，我可以清空您的账户。
- en: Creating a transaction on Rinkeby
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rinkeby上创建交易
- en: Now that you have had fun with Ganache, let's try to create a transaction on
    the Rinkeby network. You may notice a problem here—unlike Ganache, where you get
    10 accounts each with a 100 ETH balance, here you get nothing. You have to create
    an account by default. Creating 10 accounts is easy. But what about the balance?
    Each account you created on the Rinkeby network with Geth software comes with
    a balance of 0 ETH. But sending money requires well, money, to pay the transaction
    fee.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在Ganache上玩得很开心了，让我们尝试在Rinkeby网络上创建一笔交易。您可能会注意到一个问题——与Ganache不同，您在这里什么都没有。您必须默认创建一个账户。创建10个账户很容易。但是余额呢？您在Rinkeby网络上使用Geth软件创建的每个账户都带有0
    ETH的余额。但是发送资金需要资金来支付交易费。
- en: In the Ethereum production blockchain, you get ETH from the cryptocurrency exchange
    or from mining. But in the Rinkeby network, you get money by begging. And here's
    how to do it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊生产区块链中，您可以从加密货币交易所或挖矿中获得ETH。但在Rinkeby网络中，您通过乞讨来获得资金。以下是如何做到这一点。
- en: 'Go to [https://faucet.rinkeby.io/](https://faucet.rinkeby.io/), and then, using
    one of the social media platforms, such as Twitter, Google+, or Facebook, you
    create a post containing your public address in the Rinkeby network. Then, post
    your social media post in the form on the Rinkeby faucet website. You have three
    options: 3 ethers in 8 hours, 7.5 ethers in 1 day, or 18.5 ethers in 3 days:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[https://faucet.rinkeby.io/](https://faucet.rinkeby.io/)，然后使用Twitter、Google+或Facebook等社交媒体平台之一，在Rinkeby网络中创建一个包含您的公共地址的帖子。然后，在Rinkeby水龙头网站的表单中发布您的社交媒体帖子。您有三个选择：8小时内的3个以太币，1天内的7.5个以太币，或3天内的18.5个以太币：
- en: '![](assets/fb0d293b-a32c-4021-8366-bbc1c44016c0.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb0d293b-a32c-4021-8366-bbc1c44016c0.png)'
- en: 'To make sure you got the balance, you can check the balance from the Geth software.
    Sync it first. As I said before, this process could take a long time, perhaps
    several hours, or one night in my case:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您获得了余额，您可以从Geth软件中检查余额。首先同步它。正如我之前所说，这个过程可能需要很长时间，也许几个小时，或者在我这种情况下需要一整夜：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After your local blockchain node is fully synced with the Rinkeby network,
    kill the `geth` process first and launch `geth` again, but with different flags:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本地区块链节点与Rinkeby网络完全同步之后，首先终止`geth`进程，然后再次启动`geth`，但使用不同的标志：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute this command inside the `geth` console:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`geth`控制台中执行此命令：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Change this address to your address. You should get some ETH from the faucet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将此地址更改为您的地址。您应该从水龙头中获得一些ETH。
- en: 'Assuming you have the ETH already, you can create a transaction in the Rinkeby
    network. Here is the script to send ethers in the Rinkeby network. You can refer
    to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/send_money_rinkeby.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/send_money_rinkeby.py):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经拥有ETH，您可以在Rinkeby网络中创建一个交易。以下是在Rinkeby网络中发送以太币的脚本。您可以在以下GitLab链接上引用完整代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/send_money_rinkeby.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/send_money_rinkeby.py)：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Change the account receiver's address, your private key encrypted file location,
    your password, and the `geth.ipc` file location according to your situation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的情况，更改接收账户地址、您的私钥加密文件位置、您的密码和`geth.ipc`文件位置。
- en: 'Remember that our private key is encrypted in a file. So we read that file,
    and then unlock it with a password. Remember, you should not embed the password
    in the code directly. Then you can check your destination account''s balance in
    the `geth` console after waiting a couple of minutes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的私钥是加密在一个文件中的。因此我们读取该文件，然后用密码解锁。请记住，您不应该直接将密码嵌入代码中。然后您可以在等待几分钟后在`geth`控制台中检查您目标账户的余额：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You send a transaction by signing it with a private key. This is the most versatile
    way to create a transaction in Ethereum. But there is another way, which involves
    using just a password.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用私钥对其进行签名来发送交易。这是在以太坊中创建交易的最通用方式。但还有另一种方式，涉及仅使用密码。
- en: 'You can use a private key like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样使用私钥：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Or, instead, you can use a password when signing a transaction, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在签署交易时使用密码，如下所示：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using password can only be done when you control the node because it requires
    an encrypted private key file. I have created a couple of accounts in my Ethereum
    node. I can only use a password when signing a transaction for these accounts
    only. But with a private key, I can use any account.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您控制节点时才能使用密码，因为它需要一个加密的私钥文件。我在我的以太坊节点中创建了一些账户。我只能在为这些账户签署交易时使用密码。但是使用私钥，我可以使用任何账户。
- en: Interacting with smart contracts using web3.py
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用web3.py与智能合约进行交互
- en: You've sent ethers using a Python script with the `web3` library in Ganache
    and the Rinkeby network. Now, let's create a script to interact with a smart contract.
    But before doing that, you need to learn how to launch a smart contract with `geth`
    and a Python script with the `web3` library. Previously, in [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml),
    *Implementing Smart Contracts Using Vyper*, you launched a smart contract using
    Truffle.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用`web3`库在Ganache和Rinkeby网络中使用Python脚本发送了以太币。现在，让我们创建一个与智能合约交互的脚本。但在这之前，您需要学习如何使用`geth`和`web3`库的Python脚本启动智能合约。在[第3章](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml)中，*使用Vyper实现智能合约*，您使用Truffle启动了一个智能合约。
- en: Launching a smart contract with Geth
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Geth启动智能合约
- en: 'In the next section, we are going to connect to a smart contract with `web3`.
    Here''s how to deploy a smart contract to the Rinkeby blockchain:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用`web3`连接到一个智能合约。以下是如何将智能合约部署到Rinkeby区块链的方法：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `geth` console, list all of your accounts with Geth software:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`geth`控制台中，使用Geth软件列出所有您的账户：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'All of these accounts come from the keystore files you created with this command:
    `personal.newAccount("password")`. Say you want to unlock the first account, then
    you can use the `personal.unlockAccount` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些账户都来自您使用此命令创建的keystore文件：`personal.newAccount("password")`。假设您想要解锁第一个账户，那么您可以使用`personal.unlockAccount`方法：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, get  `bytecode` and put it in a variable. Remember that you get  `bytecode`
    when you compile the source code with the Vyper compiler:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，获取`bytecode`并将其放入一个变量中。请记住，当您使用Vyper编译器编译源代码时，您会得到`bytecode`：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, check whether your smart contract has been confirmed on the blockchain:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检查您的智能合约是否已在区块链上得到确认：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If it has been confirmed, then you should get the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已确认，则应该获得以下输出：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Launching a smart contract with web3
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用web3启动智能合约
- en: 'You can also launch a smart contract using a Python script with the `web3`
    library. Name this script `deploy_smart_contract_to_ganache.py`. You can refer
    to the code file on the following GitLab link for the full code, [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_ganache.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_ganache.py):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`web3`库使用Python脚本启动智能合约。将此脚本命名为`deploy_smart_contract_to_ganache.py`。您可以在以下GitLab链接上引用完整代码文件，[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_ganache.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_ganache.py)：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the script. But make sure you have Ganache running. You should get the
    following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本。但请确保Ganache正在运行。您应该获得以下输出：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'First, you create a smart contract object with this statement:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用此语句创建一个智能合约对象：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, in order to deploy a smart contract, you just have to use the `constructor`
    method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了部署一个智能合约，您只需要使用`constructor`方法：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The final step is quite important, which is to wait for the transaction to be
    confirmed. It's important because you need to get the smart contract's address
    after the transaction has been confirmed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步非常重要，那就是等待交易得到确认。这很重要，因为您需要在交易得到确认后获得智能合约的地址。
- en: 'If you want to deploy a smart contract to the Rinkeby network, you need to
    modify this script. Create a new file named `deploy_smart_contract_to_rinkeby.py`. You
    can refer to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_rinkeby.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_rinkeby.py):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将智能合约部署到Rinkeby网络，需要修改此脚本。创建一个名为`deploy_smart_contract_to_rinkeby.py`的新文件。您可以在以下GitLab链接上参考完整代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_rinkeby.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_rinkeby.py)：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The difference (other than using `IPCProvider` instead of `HTTPProvider`) when
    deploying a smart contract to the Rinkeby network is that you have to set `gas`,
    `gasPrice`, and `nonce` as well. On top of that, you use the `buildTransaction`
    method, get the `transaction` object, and sign it with a private key. Because
    this script runs in the Rinkeby network, you need to make sure you've allocated
    sufficient gas. It's a common mistake to deploy a smart contract to the Rinkeby
    network with insufficient gas. Then, developers are confused as to why the smart
    contract can't be accessed afterward. When you deploy this smart contract to the
    Rinkeby network, you need to wait a while.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将智能合约部署到Rinkeby网络时的区别（除了使用`IPCProvider`而不是`HTTPProvider`）是您还需要设置`gas`、`gasPrice`和`nonce`。此外，您使用`buildTransaction`方法，获取`transaction`对象，并使用私钥对其进行签名。因为此脚本在Rinkeby网络中运行，所以需要确保您已分配足够的gas。在Rinkeby网络上部署智能合约时，犯的一个常见错误是gas不足。然后，开发人员会困惑为什么之后无法访问智能合约。当您将此智能合约部署到Rinkeby网络时，需要等待一段时间。
- en: Playing with a smart contract
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转智能合约
- en: 'In the previous chapter, we have developed a simple smart contract using Vyper
    named `hello.vy`. Let''s create a script using `web3` to interact with this smart
    contract. If you have forgotten the content of `hello.vy`, here is the content
    of the file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Vyper开发了一个名为`hello.vy`的简单智能合约。让我们使用`web3`创建一个与此智能合约交互的脚本。如果您忘记了`hello.vy`的内容，这是文件的内容：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Compile it and deploy it to Ganache or the Rinkeby network. Now, depending on
    whether you want to connect to your smart contract in Ganache or Rinkeby, choose
    one of the following options.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并部署到Ganache或Rinkeby网络。现在，根据您是要连接到Ganache还是Rinkeby中的智能合约，选择以下选项之一。
- en: 'The first script is for interacting with the smart contract in the Rinkeby
    network. Name the script `play_with_smart_contract_in_rinkeby.py`. You can refer
    to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_rinkeby.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_rinkeby.py):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本是用于与Rinkeby网络中的智能合约进行交互。将脚本命名为`play_with_smart_contract_in_rinkeby.py`。您可以在以下GitLab链接上参考完整代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_rinkeby.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_rinkeby.py)：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The second script is to interact with the smart contract in Ganache. Name the
    script `play_with_smart_contract_in_ganache.py`. You can refer to the code file
    on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_ganache.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_ganache.py):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本是用于与Ganache中的智能合约进行交互。将脚本命名为`play_with_smart_contract_in_ganache.py`。您可以在以下GitLab链接上参考完整代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_ganache.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_ganache.py)：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll discuss the code line by line to understand the concept better:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐行讨论代码以更好地理解概念：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This part of the script is designed to get the `abi` and `bytecode` of the
    smart contract:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分脚本旨在获取智能合约的`abi`和`bytecode`：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This script is for the Rinkeby network option. You get the `web3` connection
    object and the private key. Then, you initialize the smart contract object based
    on the `abi` and the address from the deploying smart contract script:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本适用于Rinkeby网络选项。您获取`web3`连接对象和私钥。然后，根据部署智能合约脚本中的`abi`和地址初始化智能合约对象：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This script is for the Ganache option. You get the `web3` connection object
    and set the private key. Then, you initialize the smart contract object based
    on the `abi` and the `address` from the deploying smart contract script.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本适用于Ganache选项。您获取`web3`连接对象并设置私钥。然后，根据部署智能合约脚本中的`abi`和`address`初始化智能合约对象。
- en: 'In both (Ganache and Rinkeby) scripts, you set the value to `w3.eth.defaultAccount`.
    If you set the address to `w3.eth.defaultAccount`, this means that this address
    is the account that is going to broadcast transactions. It will also execute methods
    in a smart contract. If you remember what you did in Truffle console, you specified
    the account that will execute methods in a smart contract with the `from` parameter,
    as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个（Ganache和Rinkeby）脚本中，将值设置为`w3.eth.defaultAccount`。如果将地址设置为`w3.eth.defaultAccount`，这意味着该地址将广播交易。它还将执行智能合约中的方法。如果您还记得在Truffle控制台中所做的，您使用`from`参数指定将执行智能合约中的方法的账户，如下所示：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you don''t use the default account, you would need to specify the `from`
    field, too, when you build a transaction:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用默认账户，则在构建交易时需要指定`from`字段。
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To obtain the value from a public variable or public method that does not change
    the state of the smart contract, you use the contract object’s `functions` method,
    followed by the public variable and public method (both must be executed using
    `()`), followed by executing the `call` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取公共变量或不改变智能合约状态的公共方法的值，您需要使用合约对象的`functions`方法，然后是公共变量和公共方法（两者都必须使用`()`执行），最后执行`call`方法：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you remember what to do with nonce, it is necessary to get the updated one.
    For a transaction that is going to change the state of the smart contract, instead
    of `call`, you use `buildTransaction`, which supplies parameters that you recognize
    already: `gas`, `gasPrice`, and `nonce`. If you don''t use `w3.eth.defaultAccount`,
    then you need to add another parameter here: `from`. If you want to send some
    ethers to the smart contract (for example, the `donate` method in Donation Smart
    Contract), you add another parameter as well: `value`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得如何处理nonce，那么有必要获取更新后的nonce。对于将改变智能合约状态的交易，您需要使用`buildTransaction`，它提供了您已经认识的参数：`gas`、`gasPrice`和`nonce`。如果您不使用`w3.eth.defaultAccount`，那么您需要在这里添加另一个参数：`from`。如果您想向智能合约发送一些以太币（例如Donation智能合约中的`donate`方法），您还需要添加另一个参数：`value`。
- en: 'If you notice, the `gas` and `gasPrice` parameters in the script for the Rinkeby
    network are much higher:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，Rinkeby网络脚本中的`gas`和`gasPrice`参数要高得多：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In Ganache, you can get away with 70,000 gas and a gas price set to `1 gwei`.
    In the Rinkeby network, however, you must be careful. To be safe, I bumped up
    the gas and the gas price when interacting with a smart contract in the Rinkeby
    network. If you fail to change the state of the smart contract in the Rinkeby
    network, sometimes it means you haven''t allocated sufficient gas and the gas
    price is not high enough:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ganache中，您可以使用70,000 gas和`1 gwei`的燃气价格。然而，在Rinkeby网络中，您必须小心。为了安全起见，在与Rinkeby网络中的智能合约交互时，我提高了燃气和燃气价格。如果您在Rinkeby网络中未能改变智能合约的状态，有时意味着您没有分配足够的燃气，燃气价格也不够高：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You sign this transaction with your private key. However, in Ganache, you don''t
    have to do this. Instead, you could make a transaction directly without a private
    key:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用私钥对此交易进行签名。然而，在Ganache中，您不必这样做。相反，您可以直接进行交易而无需私钥：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In contrast, for the Rinkeby network or the Ethereum production blockchain,
    you have to sign your transaction:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在Rinkeby网络或以太坊生产区块链中，您必须对交易进行签名：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, you broadcast your transaction:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您广播您的交易：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In Ganache, the execution of the method will be very fast, but in Rinkeby,
    it could take a few minutes. In a proper decentralized application, you would
    handle this with asynchronous programming or threading:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ganache中，方法的执行速度会非常快，但在Rinkeby中可能需要几分钟。在一个合适的去中心化应用程序中，您可以使用异步编程或线程来处理这个问题：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The last line is there to ensure that it has changed the `name` variable in
    the smart contract.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是为了确保它已经改变了智能合约中的`name`变量。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to install a `web3` library. This is the library
    that is designed to connect to a smart contract. On top of that, you learned how
    to run an Ethereum node on the Rinkeby network. You configured `web3` to connect
    to the Ethereum blockchain on the Rinkeby network. You also learned how to tell
    `web3` to connect to an Ethereum testing network, such as Ganache. In addition,
    you created a script to send ethers from one account to another. Finally, you
    created a script to execute methods on a smart contract, either to read the value
    of public variables or to change the state of the smart contract.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何安装`web3`库。这个库是设计用来连接智能合约的。除此之外，您还学会了如何在Rinkeby网络上运行以太坊节点。您配置了`web3`以连接到Rinkeby网络上的以太坊区块链。您还学会了如何告诉`web3`连接到以太坊测试网络，比如Ganache。此外，您创建了一个脚本，用于从一个账户发送以太币到另一个账户。最后，您创建了一个脚本来执行智能合约的方法，无论是读取公共变量的值还是改变智能合约的状态。
- en: In the next chapter, you are going to use a smart contract development framework
    called **Populus** that takes care of the manual work you've undertaken in relation
    to a smart contract, such as compiling the code and deploying it. In addition,
    the Populus framework offers an integrated way to test the smart contract.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将使用一个名为**Populus**的智能合约开发框架，它会处理与智能合约相关的手动工作，比如编译代码和部署代码。此外，Populus框架提供了一种集成的方式来测试智能合约。
