- en: Chapter 2. Relational Databases with SQLAlchemy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用SQLAlchemy的关系数据库
- en: Relational databases are the bedrock upon which almost every modern Web application
    is built. Learning to think about your application in terms of tables and relationships
    is one of the keys to a clean, well-designed project. As you will see in this
    chapter, the data model you choose early on will affect almost every facet of
    the code that follows. We will be using SQLAlchemy, a powerful object relational
    mapper that allows us to abstract away the complexities of multiple database engines,
    to work with the database directly from within Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库是几乎每个现代Web应用程序构建的基石。学会以表和关系的方式思考你的应用程序是一个干净、设计良好的项目的关键之一。正如你将在本章中看到的，你早期选择的数据模型将影响代码的几乎每个方面。我们将使用SQLAlchemy，一个强大的对象关系映射器，允许我们在Python内部直接与数据库交互，抽象出多个数据库引擎的复杂性。
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Present a brief overview of the benefits of using a relational database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要概述使用关系数据库的好处
- en: Introduce SQLAlchemy, the Python SQL Toolkit and Object Relational Mapper
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍SQLAlchemy，Python SQL工具包和对象关系映射器
- en: Configure our Flask application to use SQLAlchemy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置我们的Flask应用程序使用SQLAlchemy
- en: Write a model class to represent blog entries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个模型类来表示博客条目
- en: Learn how to save and retrieve blog entries from the database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何从数据库保存和检索博客条目
- en: Perform queries – sorting, filtering, and aggregation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行查询-排序、过滤和聚合
- en: Build a tagging system for blog entries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为博客条目构建标记系统
- en: Create schema migrations using Alembic
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Alembic创建模式迁移
- en: Why use a relational database?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用关系数据库？
- en: Our application's database is much more than a simple record of things that
    we need to save for future retrieval. If all we needed to do was save and retrieve
    data, we could easily use flat text files. The fact is, though, that we want to
    be able to perform interesting queries on our data. What's more, we want to do
    this efficiently and without reinventing the wheel. While non-relational databases
    (sometimes known as NoSQL databases) are very popular and have their place in
    the world of the web, relational databases long ago solved the common problems
    of filtering, sorting, aggregating, and joining tabular data. Relational databases
    allow us to define sets of data in a structured way that maintains the consistency
    of our data. Using relational databases also gives us, the developers, the freedom
    to focus on the parts of our app that matter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的数据库远不止是我们需要保存以备将来检索的东西的简单记录。如果我们只需要保存和检索数据，我们可以轻松地使用纯文本文件。事实上，我们希望能够对我们的数据执行有趣的查询。而且，我们希望能够高效地做到这一点，而不需要重新发明轮子。虽然非关系数据库（有时被称为NoSQL数据库）非常受欢迎，并且在Web世界中有其位置，但关系数据库早就解决了过滤、排序、聚合和连接表格数据的常见问题。关系数据库允许我们以结构化的方式定义数据集，从而保持数据的一致性。使用关系数据库还赋予我们开发人员自由，可以专注于我们应用程序中重要的部分。
- en: 'In addition to efficiently performing ad hoc queries, a relational database
    server will also do the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了高效执行特别查询外，关系数据库服务器还会执行以下操作：
- en: Ensure that our data conforms to the rules set forth in the schema
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们的数据符合模式中规定的规则
- en: Allow multiple people to access the database concurrently, while at the same
    time guaranteeing the consistency of the underlying data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许多人同时访问数据库，同时保证底层数据的一致性
- en: Ensure that data, once saved, is not lost even in the event of an application
    crash
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据一旦保存，即使应用程序崩溃也不会丢失
- en: Relational databases and SQL, the programming language used with relational
    databases, are topics worthy of an entire book. Because this book is devoted to
    teaching you how to build apps with Flask, I will show you how to use a tool that
    has been widely adopted by the Python community for working with databases, namely,
    SQLAlchemy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库和SQL，与关系数据库一起使用的编程语言，是值得一整本书来讨论的话题。因为这本书致力于教你如何使用Flask构建应用程序，我将向你展示如何使用一个被Python社区广泛采用的用于处理数据库的工具，即SQLAlchemy。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SQLAlchemy abstracts away many of the complications of writing SQL queries,
    but there is no substitute for a deep understanding of SQL and the relational
    model. For that reason, if you are new to SQL, I would recommend that you check
    out the colorful book *Learn SQL the Hard Way*, *Zed Shaw* available online for
    free at [http://sql.learncodethehardway.org/](http://sql.learncodethehardway.org/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy抽象了许多编写SQL查询的复杂性，但深入理解SQL和关系模型是无法替代的。因此，如果你是SQL的新手，我建议你查看在线免费提供的色彩丰富的书籍*Learn
    SQL the Hard Way*，*Zed Shaw*，网址为[http://sql.learncodethehardway.org/](http://sql.learncodethehardway.org/)。
- en: Introducing SQLAlchemy
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍SQLAlchemy
- en: 'SQLAlchemy is an extremely powerful library for working with relational databases
    in Python. Instead of writing SQL queries by hand, we can use normal Python objects
    to represent database tables and execute queries. There are a number of benefits
    to this approach, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy是一个在Python中处理关系数据库非常强大的库。我们可以使用普通的Python对象来表示数据库表并执行查询，而不是手动编写SQL查询。这种方法有许多好处，如下所示：
- en: Your application can be developed entirely in Python.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序可以完全使用Python开发。
- en: Subtle differences between database engines are abstracted away. This allows
    you to do things just like a lightweight database, for instance, use SQLite for
    local development and testing, then switch to the databases designed for high
    loads (such as PostgreSQL) in production.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库引擎之间的微小差异被抽象掉了。这使你可以像使用轻量级数据库一样做事情，例如，在本地开发和测试时使用SQLite，然后在生产环境中切换到为高负载设计的数据库（如PostgreSQL）。
- en: 'Database errors are less common because there are now two layers between your
    application and the database server: the Python interpreter itself (this will
    catch the obvious syntax errors), and SQLAlchemy, which has well-defined APIs
    and its own layer of error-checking.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库错误更少，因为现在在你的应用程序和数据库服务器之间有两层：Python解释器本身（这将捕捉明显的语法错误）和SQLAlchemy，它有明确定义的API和自己的错误检查层。
- en: Your database code may become more efficient, thanks to SQLAlchemy's unit-of-work
    model that helps reduce unnecessary round-trips to the database. SQLAlchemy also
    has facilities for efficiently pre-fetching related objects known as eager loading.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于SQLAlchemy的工作单元模型有助于减少不必要的数据库往返，所以您的数据库代码可能会变得更加高效。SQLAlchemy还有用于高效预取相关对象的设施，称为急加载。
- en: '**Object Relational Mapping** (**ORM**) makes your code more maintainable,
    an aspiration known as **don''t repeat yourself**, (**DRY**). Suppose you add
    a column to a model. With SQLAlchemy it will be available whenever you use that
    model. If, on the other hand, you had hand-written SQL queries strewn throughout
    your app, you would need to update each query, one at a time, to ensure that you
    were including the new column.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象关系映射**（**ORM**）使您的代码更易于维护，这是一种被称为**不要重复自己**（**DRY**）的愿望。假设您向模型添加了一个列。使用SQLAlchemy，每当您使用该模型时，该列都将可用。另一方面，如果您在整个应用程序中手写SQL查询，您将需要逐个更新每个查询，以确保包含新列。'
- en: SQLAlchemy can help you avoid SQL injection vulnerabilities.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy可以帮助您避免SQL注入漏洞。
- en: 'Excellent library support: As you will see in later chapters, there are a multitude
    of useful libraries that can work directly with your SQLAlchemy models to provide
    things such as maintenance interfaces and RESTful APIs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出色的库支持：正如您将在后面的章节中看到的，有许多有用的库可以直接与您的SQLAlchemy模型一起工作，提供诸如维护界面和RESTful API之类的功能。
- en: I hope you're excited after reading this list. If all the items in this list
    don't make sense to you right now, don't worry. As you work through this chapter
    and the subsequent ones, these benefits will become more apparent and meaningful.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您在阅读完这个列表后感到兴奋。如果这个列表中的所有项目现在对您来说都没有意义，不要担心。当您阅读本章和后续章节时，这些好处将变得更加明显和有意义。
- en: Now that we have discussed some of the benefits of using SQLAlchemy, let's install
    it and start coding.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了使用SQLAlchemy的一些好处，让我们安装它并开始编码。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you'd like to learn more about SQLAlchemy, there is a chapter devoted entirely
    to its design in *The Architecture of Open-Source Applications*, available online
    for free at [http://aosabook.org/en/sqlalchemy.html](http://aosabook.org/en/sqlalchemy.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于SQLAlchemy的信息，在*开源应用程序的架构*中有一整章专门讨论了它的设计，可以免费在线阅读，网址是[http://aosabook.org/en/sqlalchemy.html](http://aosabook.org/en/sqlalchemy.html)。
- en: Installing SQLAlchemy
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装SQLAlchemy
- en: 'We will use `pip` to install SQLAlchemy into the blog app''s virtualenv. As
    you will recall from the previous chapter, to activate your virtualenv, change
    directories to `source` the `activate` script as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pip`将SQLAlchemy安装到博客应用的虚拟环境中。正如您在上一章中所记得的，要激活您的虚拟环境，只需切换到`source`并执行`activate`脚本：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can check if your installation succeeded by opening a Python interpreter
    and checking the SQLAlchemy version; note that your exact version number is likely
    to differ.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开Python解释器并检查SQLAlchemy版本来检查您的安装是否成功；请注意，您的确切版本号可能会有所不同。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using SQLAlchemy in our Flask app
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的Flask应用中使用SQLAlchemy
- en: 'SQLAlchemy works very well with Flask on its own, but the author of Flask has
    released a special Flask extension named **Flask-SQLAlchemy** that provides helpers
    with many common tasks, and can save us from having to re-invent the wheel later
    on. Let''s use `pip` to install this extension:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在Flask上运行得非常好，但Flask的作者发布了一个名为**Flask-SQLAlchemy**的特殊Flask扩展，它提供了许多常见任务的辅助功能，并可以避免我们以后不得不重新发明轮子。让我们使用`pip`来安装这个扩展：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Flask provides a standard interface for the developers who are interested in
    building extensions. As the framework has grown in popularity, the number of high-quality
    extensions has increased. If you'd like to take a look at some of the more popular
    extensions, there is a curated list available on the Flask project website at
    [http://flask.pocoo.org/extensions/](http://flask.pocoo.org/extensions/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Flask为对构建扩展感兴趣的开发人员提供了一个标准接口。随着这个框架的流行，高质量的扩展数量也在增加。如果您想查看一些更受欢迎的扩展，可以在Flask项目网站上找到一个精选列表，网址是[http://flask.pocoo.org/extensions/](http://flask.pocoo.org/extensions/)。
- en: Choosing a database engine
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择数据库引擎
- en: SQLAlchemy supports a multitude of popular database dialects, including SQLite,
    MySQL, and PostgreSQL. Depending on the database you would like to use, you may
    need to install an additional Python package containing a database driver. Listed
    next are several popular databases supported by SQLAlchemy and the corresponding
    pip-installable driver. Some databases have multiple driver options, so I have
    listed the most popular one first.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy支持多种流行的数据库方言，包括SQLite、MySQL和PostgreSQL。根据您想要使用的数据库，您可能需要安装一个包含数据库驱动程序的额外Python包。下面列出了SQLAlchemy支持的一些流行数据库以及相应的pip-installable驱动程序。一些数据库有多个驱动程序选项，所以我首先列出了最流行的一个。
- en: '| Database | Driver Package(s) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | 驱动程序包 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| SQLite | Not needed, part of the Python standard library since version 2.5
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| SQLite | 不需要，自Python 2.5版本起已包含在Python标准库中 |'
- en: '| MySQL | MySQL-python, PyMySQL (pure Python), OurSQL |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| MySQL | MySQL-python, PyMySQL（纯Python），OurSQL |'
- en: '| PostgreSQL | psycopg2 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL | psycopg2 |'
- en: '| Firebird | fdb |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Firebird | fdb |'
- en: '| Microsoft SQL Server | pymssql, PyODBC |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft SQL Server | pymssql, PyODBC |'
- en: '| Oracle | cx-Oracle |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| Oracle | cx-Oracle |'
- en: SQLite comes as standard with Python and does not require a separate server
    process, so it is perfect for getting up-and-running quickly. For simplicity in
    the examples that follow, I will demonstrate how to configure the blog app for
    use with SQLite. If you have a different database in mind that you would like
    to use for the blog project, feel free to use `pip` to install the necessary driver
    package at this time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite与Python一起标准提供，并且不需要单独的服务器进程，因此非常适合快速启动。在接下来的示例中，为了简单起见，我将演示如何配置博客应用以使用SQLite。如果您有其他数据库想法，并且希望在博客项目中使用它，请随时使用`pip`在此时安装必要的驱动程序包。
- en: Connecting to the database
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'Using your favorite text editor, open the `config.py` module for our blog project
    (`~/projects/blog/app/config.py`). We are going to add a SQLAlchemy-specific setting
    to instruct Flask-SQLAlchemy how to connect to our database. The new lines are
    highlighted in the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器，打开我们博客项目（`~/projects/blog/app/config.py`）的`config.py`模块。我们将添加一个特定于SQLAlchemy的设置，以指示Flask-SQLAlchemy如何连接到我们的数据库。以下是新的行：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `SQLALCHEMY_DATABASE_URI` comprises the following parts:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLALCHEMY_DATABASE_URI`包括以下部分：'
- en: '`dialect+driver://username:password@host:port/database`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`dialect+driver://username:password@host:port/database`'
- en: 'Because SQLite databases are stored in local files, the only information we
    need to provide is the path to the database file. On the other hand, if you wanted
    to connect to PostgreSQL running locally, your URI might look something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因为SQLite数据库存储在本地文件中，我们需要提供的唯一信息是数据库文件的路径。另一方面，如果您想连接到本地运行的PostgreSQL，您的URI可能看起来像这样：
- en: '`postgresql://postgres:secretpassword@localhost:5432/blog_db`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`postgresql://postgres:secretpassword@localhost:5432/blog_db`'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you''re having trouble connecting to your database, try consulting the SQLAlchemy
    documentation on database URIs: [http://docs.sqlalchemy.org/en/rel_0_9/core/engines.html](http://docs.sqlalchemy.org/en/rel_0_9/core/engines.html).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在连接到数据库时遇到问题，请尝试查阅SQLAlchemy关于数据库URI的文档：[http://docs.sqlalchemy.org/en/rel_0_9/core/engines.html](http://docs.sqlalchemy.org/en/rel_0_9/core/engines.html)。
- en: 'Now that we''ve specified how to connect to the database, let''s create the
    object responsible for actually managing our database connections. This object
    is provided by the Flask-SQLAlchemy extension and is conveniently named `SQLAlchemy`.
    Open `app.py` and make the following additions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了如何连接到数据库，让我们创建一个负责实际管理我们数据库连接的对象。这个对象由Flask-SQLAlchemy扩展提供，并且方便地命名为`SQLAlchemy`。打开`app.py`并进行以下添加：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These changes instruct our Flask app, and in turn SQLAlchemy, how to communicate
    with our application's database. The next step will be to create a table for storing
    blog entries and, to do so, we will create our first model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改指示我们的Flask应用程序，进而指示SQLAlchemy如何与我们应用程序的数据库通信。下一步将是创建一个用于存储博客条目的表，为此，我们将创建我们的第一个模型。
- en: Creating the Entry model
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Entry模型
- en: A **model** is the data representation of a table of data that we want to store
    in the database. These models have attributes called **columns** that represent
    the data items in the data. So, if we were creating a `Person` model, we might
    have columns for storing the first and last name, date of birth, home address,
    hair color, and so on. Since we are interested in creating a model to represent
    blog entries, we will have columns for things like the title and body content.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**是我们想要存储在数据库中的数据表的数据表示。这些模型具有称为**列**的属性，表示数据中的数据项。因此，如果我们要创建一个`Person`模型，我们可能会有用于存储名字、姓氏、出生日期、家庭地址、头发颜色等的列。由于我们有兴趣创建一个模型来表示博客条目，我们将为标题和正文内容等内容创建列。'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we don't say a `People` model or `Entries` model – models are singular
    even though they commonly represent many different objects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不说`People`模型或`Entries`模型 - 即使它们通常代表许多不同的对象，模型是单数。
- en: 'With SQLAlchemy, creating a model is as easy as defining a class and specifying
    a number of attributes assigned to that class. Let''s start with a very basic
    model for our blog entries. Create a new file named `models.py` in the blog project''s
    `app/` directory and enter the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy，创建模型就像定义一个类并指定分配给该类的多个属性一样简单。让我们从我们博客条目的一个非常基本的模型开始。在博客项目的`app/`目录中创建一个名为`models.py`的新文件，并输入以下代码：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is a lot going on, so let's start with the imports and work our way down.
    We begin by importing the standard library `datetime` and `re` modules. We will
    be using `datetime` to get the current date and time, and `re` to do some string
    manipulation. The next import statement brings in the `db` object that we created
    in `app.py`. As you recall, the `db` object is an instance of the `SQLAlchemy`
    class, which is a part of the Flask-SQLAlchemy extension. The `db` object provides
    access to the classes that we need to construct our `Entry` model, which is just
    a few lines ahead.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情要做，所以让我们从导入开始，然后逐步进行。我们首先导入标准库`datetime`和`re`模块。我们将使用`datetime`获取当前日期和时间，使用`re`进行一些字符串操作。接下来的导入语句引入了我们在`app.py`中创建的`db`对象。您可能还记得，`db`对象是`SQLAlchemy`类的一个实例，它是Flask-SQLAlchemy扩展的一部分。`db`对象提供了访问我们需要构建`Entry`模型的类的功能，这只是前面几行。
- en: Before the `Entry` model, we define a helper function `slugify`, which we will
    use to give our blog entries some nice URLs (used in [Chapter 3](ch03.html "Chapter 3. Templates
    and Views"), *Templates and Views*). The `slugify` function takes a string such
    as *A post about Flask* and uses a regular expression to turn a string that is
    human-readable in to a URL, and so returns *a-post-about-flask*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Entry`模型之前，我们定义了一个辅助函数`slugify`，我们将使用它为我们的博客条目提供一些漂亮的URL（在[第3章](ch03.html
    "第3章。模板和视图")中使用，*模板和视图*）。`slugify`函数接受一个字符串，比如*关于Flask的帖子*，并使用正则表达式将可读的字符串转换为URL，因此返回*a-post-about-flask*。
- en: Next is the `Entry` model. Our `Entry` model is a normal class that extends
    `db.Model`. By extending `db.Model`, our `Entry` class will inherit a variety
    of helpers that we'll use to query the database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Entry`模型。我们的`Entry`模型是一个普通的类，扩展了`db.Model`。通过扩展`db.Model`，我们的`Entry`类将继承各种我们将用于查询数据库的帮助程序。
- en: 'The attributes of the `Entry` model, are a simple mapping of the names and
    data that we wish to store in the database and are listed as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entry`模型的属性是我们希望存储在数据库中的名称和数据的简单映射，并列在下面：'
- en: '`id`: This is the primary key for our database table. This value is set for
    us automatically by the database when we create a new blog entry, usually an auto-incrementing
    number for each new entry. While we will not explicitly set this value, a primary
    key comes in handy when you want to refer one model to another, as you''ll see
    later in the chapter.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是我们数据库表的主键。当我们创建一个新的博客条目时，数据库会自动为我们设置这个值，通常是每个新条目的自增编号。虽然我们不会明确设置这个值，但当你想要引用一个模型到另一个模型时，主键会派上用场，这一点你将在本章后面看到。'
- en: '`title`: The title for a blog entry, stored as a `String` column with a maximum
    length of 100.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：博客条目的标题，存储为具有最大长度为100的`String`列。'
- en: '`slug`: The URL-friendly representation of the title, stored as a `String`
    column with a maximum length of 100\. This column also specifies `unique=True`,
    so that no two entries can share the same slug.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slug`：标题的URL友好表示，存储为具有最大长度为100的`String`列。该列还指定了`unique=True`，因此没有两个条目可以共享相同的slug。'
- en: '`body`: The actual content of the post, stored in a `Text` column. This differs
    from the `String` type of the `Title` and `Slug` as you can store as much text
    as you like in this field.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：帖子的实际内容，存储在`Text`列中。这与`Title`和`Slug`的`String`类型不同，因为你可以在这个字段中存储任意多的文本。'
- en: '`created_timestamp`: The time a blog entry was created, stored in a `DateTime`
    column. We instruct SQLAlchemy to automatically populate this column with the
    current time by default when an entry is first saved.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_timestamp`：博客条目创建的时间，存储在`DateTime`列中。我们指示SQLAlchemy在首次保存条目时自动填充这一列的当前时间。'
- en: '`modified_timestamp`: The time a blog entry was last updated. SQLAlchemy will
    automatically update this column with the current time whenever we save an entry.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modified_timestamp`：博客条目上次更新的时间。当我们保存一个条目时，SQLAlchemy会自动使用当前时间更新这个列。'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For short strings such as titles or names of things, the `String` column is
    appropriate, but when the text may be especially long it is better to use a `Text`
    column, as we did for the entry body.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标题或事物名称等短字符串，`String`列是合适的，但当文本可能特别长时，最好使用`Text`列，就像我们为条目正文所做的那样。
- en: We've overridden the constructor for the class (`__init__`) so that, when a
    new model is created, it automatically sets the slug for us based on the title.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重写了类的构造函数（`__init__`），这样，当创建一个新模型时，它会根据标题自动为我们设置slug。
- en: The last piece is the `__repr__` method that is used to generate a helpful representation
    of instances of our `Entry` class. The specific meaning of `__repr__` is not important
    but allows you to reference the object that the program is working with, when
    debugging.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是`__repr__`方法，用于生成我们的`Entry`类实例的有用表示。`__repr__`的具体含义并不重要，但允许你在调试时引用程序正在处理的对象。
- en: 'A final bit of code needs to be added to main.py, the entry-point to our application,
    to ensure that the models are imported. Add the highlighted changes to main.py
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要添加一小段代码到main.py，这是我们应用程序的入口点，以确保模型被导入。将以下突出显示的更改添加到main.py中：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating the Entry table
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Entry表
- en: 'In order to start working with the `Entry` model, we first need to create a
    table for it in our database. Luckily, Flask-SQLAlchemy comes with a nice helper
    for doing just this. Create a new sub-folder named `scripts` in the blog project''s
    `app` directory. Then create a file named `create_db.py`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用`Entry`模型，我们首先需要在我们的数据库中为它创建一个表。幸运的是，Flask-SQLAlchemy带有一个很好的辅助程序来做这件事。在博客项目的`app`目录中创建一个名为`scripts`的新子文件夹。然后创建一个名为`create_db.py`的文件：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code to the `create_db.py` module. This function will automatically
    look at all the code that we have written and create a new table in our database
    for the `Entry` model based on our models:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`create_db.py`模块中。这个函数将自动查看我们编写的所有代码，并根据我们的模型在数据库中为`Entry`模型创建一个新表：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Execute the script from inside the `app/` directory. Make sure the virtualenv
    is active. If everything goes successfully, you should see no output.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从`app/`目录内执行脚本。确保虚拟环境是激活的。如果一切顺利，你应该看不到任何输出。
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you encounter errors while creating the database tables, make sure you are
    in the app directory, with the virtualenv activated, when you run the script.
    Next, ensure that there are no typos in your `SQLALCHEMY_DATABASE_URI` setting.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建数据库表时遇到错误，请确保你在app目录中，并且在运行脚本时虚拟环境是激活的。接下来，确保你的`SQLALCHEMY_DATABASE_URI`设置中没有拼写错误。
- en: Working with the Entry model
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Entry模型
- en: Let's experiment with our new `Entry` model by saving a few blog entries. We
    will be doing this from the Python interactive shell. At this stage let's install
    **IPython**, a sophisticated shell with features such as tab-completion (that
    the default Python shell lacks).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过保存一些博客条目来尝试我们的新`Entry`模型。我们将在Python交互式shell中进行此操作。在这个阶段，让我们安装**IPython**，这是一个功能强大的shell，具有诸如制表符补全（默认的Python
    shell没有的功能）。
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now check whether we are in the `app` directory and let''s start the shell
    and create a couple of entries as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查我们是否在`app`目录中，让我们启动shell并创建一些条目，如下所示：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are familiar with the normal Python shell but not IPython, things may
    look a little different at first. The main thing to be aware of is that `In[]`
    refers to the code you type in, and `Out[]` is the output of the commands you
    put into the shell.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉普通的Python shell但不熟悉IPython，一开始可能会有点不同。要注意的主要事情是`In[]`指的是你输入的代码，`Out[]`是你放入shell的命令的输出。
- en: IPython has a neat feature that allows you to print detailed information about
    an object. This is done by typing in the object's name followed by a question-mark
    (?). Introspecting the `Entry` model provides a bit of information, including
    the argument signature and the string representing that object (known as the `docstring`)
    of the constructor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: IPython有一个很棒的功能，允许你打印关于对象的详细信息。这是通过输入对象的名称后跟一个问号（?）来完成的。内省`Entry`模型提供了一些信息，包括参数签名和表示该对象的字符串（称为`docstring`）的构造函数。
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can create `Entry` objects by passing column values in as the keyword-arguments.
    In the preceding example, it uses `**kwargs`; this is a shortcut for taking a
    `dict` object and using it as the values for defining the object, as shown next:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将列值作为关键字参数传递来创建“Entry”对象。在前面的示例中，它使用了“**kwargs”；这是一个快捷方式，用于将“dict”对象作为定义对象的值，如下所示：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order to save our first entry, we will to add it to the database session.
    The session is simply an object that represents our actions on the database. Even
    after adding it to the session, it will not be saved to the database yet. In order
    to save the entry to the database, we need to commit our session:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存我们的第一个条目，我们将其添加到数据库会话中。会话只是表示我们在数据库上的操作的对象。即使将其添加到会话中，它也不会立即保存到数据库中。为了将条目保存到数据库中，我们需要提交我们的会话：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see from the preceding code examples, once we commit the session,
    a unique id will be assigned to our first entry and the `created_timestamp` will
    be set to the current time. Congratulations, you've created your first blog entry!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码示例中可以看出，一旦我们提交了会话，将为我们的第一个条目分配一个唯一的id，并将“created_timestamp”设置为当前时间。恭喜，您已创建了您的第一个博客条目！
- en: Try adding a few more on your own. You can add multiple entry objects to the
    same session before committing, so give that a try as well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己添加几个。在提交之前，您可以将多个条目对象添加到同一个会话中，因此也可以尝试一下。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At any point while you are experimenting, feel free to delete the `blog.db`
    file and re-run the `create_db.py` script to start over with a fresh database.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在您进行实验的任何时候，都可以随时删除“blog.db”文件，并重新运行“create_db.py”脚本，以便使用全新的数据库重新开始。
- en: Making changes to an existing entry
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对现有条目进行更改
- en: 'In order to make changes to an existing `Entry`, simply make your edits and
    then commit. Let''s retrieve our `Entry` using the id that was returned to us
    earlier, make some changes, and commit it. SQLAlchemy will know that it needs
    to be updated. Here is how you might make edits to the first entry:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 修改现有的“Entry”时，只需进行编辑，然后提交。让我们使用之前返回给我们的id检索我们的“Entry”，进行一些更改，然后提交。SQLAlchemy将知道需要更新它。以下是您可能对第一个条目进行编辑的方式：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And just like that your changes are saved.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就像那样，您的更改已保存。
- en: Deleting an entry
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除条目
- en: Deleting an entry is just as easy as creating one. Instead of calling `db.session.add`,
    we will call `db.session.delete` and pass in the `Entry` instance that we wish
    to remove.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 删除条目与创建条目一样简单。我们将调用`db.session.delete`而不是调用`db.session.add`，并传入我们希望删除的“Entry”实例。
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Retrieving blog entries
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索博客条目
- en: While creating, updating, and deleting are fairly straightforward operations,
    the real fun starts when we look at ways to retrieve our entries. We'll start
    with the basics, and then work our way up to more interesting queries.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建、更新和删除操作相当简单，但当我们查看检索条目的方法时，真正有趣的部分开始了。我们将从基础知识开始，然后逐渐深入到更有趣的查询。
- en: 'We will use a special attribute on our model class to make queries: `Entry.query`.
    This attribute exposes a variety of APIs for working with the collection of entries
    in the database.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用模型类上的特殊属性进行查询：“Entry.query”。该属性公开了各种API，用于处理数据库中条目的集合。
- en: 'Let''s simply retrieve a list of all the entries in the `Entry` table:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单地检索“Entry”表中所有条目的列表：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, in this example the query returns a list of `Entry` instances
    that we created. When no explicit ordering is specified, the entries are returned
    to us in an arbitrary order chosen by the database. Let''s specify that we want
    the entries returned to us in an alphabetical order by title:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在此示例中，查询返回了我们创建的“Entry”实例的列表。当未指定显式排序时，条目将以数据库选择的任意顺序返回给我们。让我们指定我们希望以标题的字母顺序返回给我们条目：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Shown next is how you would list your entries in reverse-chronological order,
    based on when they were last updated:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是如何按照最后更新时间的逆序列出您的条目：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Filtering the list of entries
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤条目列表
- en: It is very useful to be able to retrieve the entire collection of blog entries,
    but what if we want to filter the list? We could always retrieve the entire collection
    and then filter it in Python using a loop, but that would be very inefficient.
    Instead we will rely on the database to do the filtering for us, and simply specify
    the conditions for which entries should be returned. In the following example,
    we will specify that we want to filter by entries where the title equals `'First
    entry'`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 能够检索整个博客条目集合非常有用，但是如果我们想要过滤列表怎么办？我们可以始终检索整个集合，然后在Python中使用循环进行过滤，但那将非常低效。相反，我们将依赖数据库为我们进行过滤，并简单地指定应返回哪些条目的条件。在以下示例中，我们将指定要按标题等于“First
    entry”进行过滤的条目。
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If this seems somewhat magical to you, it's because it really is! SQLAlchemy
    uses operator overloading to convert expressions such as `<Model>.<column> ==
    <some value>` into an abstracted object called `BinaryExpression`. When you are
    ready to execute your query, these data-structures are then translated into SQL.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对您来说似乎有些神奇，那是因为它确实如此！SQLAlchemy使用操作符重载将诸如`<Model>.<column> == <some value>`的表达式转换为称为“BinaryExpression”的抽象对象。当您准备执行查询时，这些数据结构然后被转换为SQL。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `BinaryExpression` is simply an object that represents the logical comparison
    and is produced by over riding the standards methods that are typically called
    on an object when comparing values in Python.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: “BinaryExpression”只是一个表示逻辑比较的对象，并且是通过重写通常在Python中比较值时调用的标准方法而生成的。
- en: 'In order to retrieve a single entry, you have two options: `.first()` and `.one()`.
    Their differences and similarities are summarized in the following table:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索单个条目，您有两个选项：`.first()`和`.one()`。它们的区别和相似之处总结在以下表中：
- en: '| Number of matching rows | first() behavior | one() behavior |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 匹配行的数量 | first()行为 | one()行为 |'
- en: '| --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Return the object | Return the object |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 返回对象 | 返回对象 |'
- en: '| 0 | Return `None` | Raise `sqlalchemy.orm.exc.NoResultFound` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 返回“None” | 引发“sqlalchemy.orm.exc.NoResultFound” |'
- en: '| 2+ | Return the first object (based on either explicit ordering or the ordering
    chosen by the database) | Raise `sqlalchemy.orm.exc.MultipleResultsFound` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 2+ | 返回第一个对象（基于显式排序或数据库选择的排序） | 引发`sqlalchemy.orm.exc.MultipleResultsFound`
    |'
- en: 'Let''s try the same query as before but, instead of calling `.all(),` we will
    call `.first()` to retrieve a single `Entry` instance:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试与之前相同的查询，但是，而不是调用`.all()`，我们将调用`.first()`来检索单个`Entry`实例：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how previously `.all()` returned a list containing the object, whereas
    `.first()` returned just the object itself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以前的`.all()`返回包含对象的列表，而`.first()`只返回对象本身。
- en: Special lookups
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊查找
- en: In the previous example we tested for equality, but there are many other types
    of lookups possible. In the following table, we have listed some that you may
    find useful. A complete list can be found in the SQLAlchemy documentation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们测试了相等性，但还有许多其他类型的查找可能。在下表中，我们列出了一些您可能会发现有用的查找。完整列表可以在SQLAlchemy文档中找到。
- en: '| Example | Meaning |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 意义 |'
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Entry.title == ''The title'' | Entries where the title is "The title", case-sensitive.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| Entry.title == ''The title'' | 标题为“The title”的条目，区分大小写。 |'
- en: '| Entry.title != ''The title'' | Entries where the title is not "The title".
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Entry.title != ''The title'' | 标题不是“The title”的条目。 |'
- en: '| Entry.created_timestamp < datetime.date(2014, 1, 25) | Entries created before
    January 25, 2014\. For less than or equal, use <=. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Entry.created_timestamp < datetime.date(2014, 1, 25) | 2014年1月25日之前创建的条目。要使用小于或等于，使用<=。
    |'
- en: '| Entry.created_timestamp > datetime.date(2014, 1, 25) | Entries created after
    January 25, 2014\. For greater than or equal, use >=. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Entry.created_timestamp > datetime.date(2014, 1, 25) | 2014年1月25日之后创建的条目。要使用大于或等于，使用>=。
    |'
- en: '| Entry.body.contains(''Python'') | Entries where the body contains the word
    "Python", case-sensitive. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| Entry.body.contains(''Python'') | 正文包含单词“Python”的条目，区分大小写。 |'
- en: '| Entry.title.endswith(''Python'') | Entries where the title ends with the
    string "Python", case-sensitive. Note that this will also match titles that end
    with the word "CPython", for example. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Entry.title.endswith(''Python'') | 标题以字符串“Python”结尾的条目，区分大小写。请注意，这也将匹配以单词“CPython”结尾的标题，例如。
    |'
- en: '| Entry.title.startswith(''Python'') | Entries where the title starts with
    the string "Python", case-sensitive. Note that this will also match titles such
    as "Pythonistas". |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| Entry.title.startswith(''Python'') | 标题以字符串“Python”开头的条目，区分大小写。请注意，这也将匹配标题如“Pythonistas”。
    |'
- en: '| Entry.body.ilike(''%python%'') | Entries where the body contains the word
    "python" anywhere in the text, case-insensitive. The "%" character is a wild card.
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Entry.body.ilike(''%python%'') | 正文包含单词“python”的条目，文本中任何位置，不区分大小写。百分号“%”是通配符。
    |'
- en: '| Entry.title.in_([''Title one'', ''Title two'']) | Entries where the title
    is in the given list, either ''Title one'' or ''Title two''. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| Entry.title.in_([''Title one'', ''Title two'']) | 标题在给定列表中的条目，要么是''Title
    one''要么是''Title two''。 |'
- en: Combining expressions
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合表达式
- en: 'The expressions listed in the preceding table can be combined using bitwise
    operators to produce arbitrarily complex expressions. Let''s say we want to retrieve
    all blog entries that have the word `Python` or `Flask` in the title. To accomplish
    this, we will create two `contains` expressions, then combine them using Python''s
    bitwise `OR` operator, which is a pipe `|` character, unlike a lot of other languages
    that use a double pipe `||` character:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面表格中列出的表达式可以使用位运算符组合，以生成任意复杂的表达式。假设我们想要检索所有博客条目中标题包含`Python`或`Flask`的条目。为了实现这一点，我们将创建两个`contains`表达式，然后使用Python的位`OR`运算符进行组合，这是一个管道`|`字符，不像其他许多使用双管`||`字符的语言：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using bitwise operators, we can come up with some pretty complex expressions.
    Try to figure out what the following example is asking for:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位运算符，我们可以得到一些非常复杂的表达式。试着弄清楚以下示例在询问什么：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you probably guessed, this query returns all entries where the title contains
    either `Python` or `Flask`, and that were created within the last 30 days. We
    are using Python''s bitwise `OR` and `AND` operators to combine the sub-expressions.
    For any query you produce, you can view the generated SQL by printing the query
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经猜到，此查询返回所有标题包含`Python`或`Flask`的条目，并且在过去30天内创建。我们使用Python的位`OR`和`AND`运算符来组合子表达式。对于您生成的任何查询，可以通过打印查询来查看生成的SQL，如下所示：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Negation
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 否定
- en: 'There is one more piece to discuss, which is **negation**. If we wanted to
    get a list of all blog entries that did not contain `Python` or `Flask` in the
    title, how would we do that? SQLAlchemy provides two ways to create these types
    of expressions, using either Python''s unary negation operator (`~`) or by calling
    `db.not_()`. This is how you would construct this query with SQLAlchemy:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点要讨论，那就是**否定**。如果我们想要获取所有标题中不包含`Python`或`Flask`的博客条目列表，我们该怎么做呢？SQLAlchemy提供了两种方法来创建这些类型的表达式，一种是使用Python的一元否定运算符（`~`），另一种是调用`db.not_()`。以下是如何使用SQLAlchemy构建此查询的方法：
- en: 'Using unary negation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一元否定：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using `db.not_()`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`db.not_()`：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Operator precedence
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: 'Not all operations are considered equal to the Python interpreter. This is
    like in math class, where we learned that expressions such as *2 + 3 * 4* are
    equal to *14* and not *20*, because the multiplication operation occurs first.
    In Python, bitwise operators all have a higher precedence than things such as
    equality tests, so this means that, when you are building your query expression,
    you have to pay attention to the parentheses. Let''s look at some example Python
    expressions and see the corresponding query:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有操作都被Python解释器视为相等。这就像在数学课上学习的那样，我们学到类似*2 + 3 * 4*的表达式等于*14*而不是*20*，因为乘法运算首先发生。在Python中，位运算符的优先级都高于诸如相等性测试之类的东西，这意味着在构建查询表达式时，您必须注意括号。让我们看一些示例Python表达式，并查看相应的查询：
- en: '| Expression | Result |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 结果 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| (Entry.title == ''Python'' &#124; Entry.title == ''Flask'') | Wrong! SQLAlchemy
    throws an error because the first thing to be evaluated is actually the ''Python''
    &#124; Entry.title! |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| (Entry.title == ''Python'' &#124; Entry.title == ''Flask'') | 错误！SQLAlchemy会抛出错误，因为首先要评估的实际上是''Python''
    &#124; Entry.title! |'
- en: '| (Entry.title == ''Python'') &#124; (Entry.title == ''Flask'') | Right. Returns
    entries where the title is either "Python" or "Flask". |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| (Entry.title == ''Python'') &#124; (Entry.title == ''Flask'') | 正确。返回标题为“Python”或“Flask”的条目。
    |'
- en: '| ~Entry.title == ''Python'' | Wrong! SQLAlchemy will turn this into a valid
    SQL query, but the results will not be meaningful. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| ~Entry.title == ''Python'' | 错误！SQLAlchemy会将其转换为有效的SQL查询，但结果将没有意义。 |'
- en: '| ~(Entry.title == ''Python'') | Right. Returns entries where the title is
    not equal to "Python". |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| ~(Entry.title == ''Python'') | 正确。返回标题不等于“Python”的条目。 |'
- en: If you find yourself struggling with operator precedence, it's a safe bet to
    put parentheses around any comparison that uses `==`, `!=`, `<`, `<=`, `>`, and
    `>=`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己在操作符优先级方面有困难，最好在使用`==`、`!=`、`<`、`<=`、`>`和`>=`的任何比较周围加上括号。
- en: Building a tagging system
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建标记系统
- en: Tags are a lightweight taxonomy system that is perfect for blogs. Tags allow
    you to apply multiple categories to a blog post and allow multiple posts to be
    related to one another outside their category. On my own blog I use tags to organize
    the posts, so that people interested in reading my posts about Flask need only
    look under the "Flask" tag and find all the relevant posts. As per the spec that
    we discussed in [Chapter 1](ch01.html "Chapter 1. Creating Your First Flask Application"),
    *Creating Your First Flask Application*, each blog entry can have as few or as
    many tags as you want, so a post about Flask might be tagged with both Flask and
    Python. Similarly, each tag (for example, Python) can have multiple entries associated
    with it. In database parlance, this is called a many-to-many relationship.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是一个轻量级的分类系统，非常适合博客。标签允许您将多个类别应用于博客文章，并允许多篇文章在其类别之外相互关联。在我的博客上，我使用标签来组织帖子，这样对于想阅读我关于Flask的帖子的人，只需在“Flask”标签下查找即可找到所有相关的帖子。根据我们在[第1章](ch01.html
    "第1章。创建您的第一个Flask应用程序")中讨论的规范，*创建您的第一个Flask应用程序*，每个博客条目可以有多少个标签都可以，因此关于Flask的帖子可能会被标记为Flask和Python。同样，每个标签（例如Python）可以与多个条目相关联。在数据库术语中，这称为多对多关系。
- en: 'In order to model this, we must first create a model to store tags. This model
    will store the names of tags we use, so after we''ve added a few tags the table
    might look something like the following one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对此进行建模，我们必须首先创建一个模型来存储标签。这个模型将存储我们使用的标签名称，因此在我们添加了一些标签之后，表可能看起来像下面这样：
- en: '| id | tag |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| id | tag |'
- en: '| --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Python |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Python |'
- en: '| 2 | Flask |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Flask |'
- en: '| 3 | Django |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Django |'
- en: '| 4 | random-thoughts |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 4 | random-thoughts |'
- en: 'Let''s open `models.py` and add a definition for the `Tag` model. Add the following
    class at the end of the file, below the `Entry` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`models.py`并为`Tag`模型添加一个定义。在文件末尾添加以下类，位于`Entry`类下方：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You've seen all of this before. We've added a primary key, which will be managed
    by the database, and a single column to store the name of the tag. The `name`
    column is marked as unique, so each tag will only be represented by a single row
    in this table, regardless of how many blog entries it appears on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您以前见过所有这些。我们添加了一个主键，这将由数据库管理，并添加了一个列来存储标签的名称。`name`列被标记为唯一，因此每个标签在这个表中只会被一行表示，无论它出现在多少个博客条目中。
- en: 'Now that we have models for both blog entries and tags, we need a third model
    to store the relationships between the two. When we wish to signify that a blog
    entry is tagged with a particular tag, we will store a reference in this table.
    The following is a diagram of what is happening at the database table level:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们既有博客条目模型，也有标签模型，我们需要一个第三个模型来存储两者之间的关系。当我们希望表示博客条目被标记为特定标签时，我们将在这个表中存储一个引用。以下是数据库表级别上正在发生的事情的图示：
- en: '![Building a tagging system](img/1709_02_01.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![构建标记系统](img/1709_02_01.jpg)'
- en: 'Since we will never be accessing this intermediary table directly (SQLAlchemy
    will handle it for us transparently), we will not create a model for it but will
    simply specify a table to store the mapping. Open `models.py` and add the following
    highlighted code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们永远不会直接访问这个中间表（SQLAlchemy会透明地处理它），我们不会为它创建一个模型，而是简单地指定一个表来存储映射。打开`models.py`并添加以下突出显示的代码：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By creating the `entry_tags` table, we have established a link between the
    `Entry` and `Tag` models. SQLAlchemy provides a high-level API for working with
    this relationship, the aptly-named `db.relationship` function. This function creates
    a new property on the `Entry` model that allows us to easily read and write the
    tags for a given blog entry. There is a lot going on in these two lines of code
    so let''s take a closer look:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建`entry_tags`表，我们已经建立了`Entry`和`Tag`模型之间的链接。SQLAlchemy提供了一个高级API来处理这种关系，名为`db.relationship`函数。这个函数在`Entry`模型上创建了一个新属性，允许我们轻松地读取和写入给定博客条目的标签。这两行代码中有很多内容，让我们仔细看一下：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are setting the tags attribute of the `Entry` class equal to the return value
    of the `db.relationship` function. The first two arguments, `'Tag'` and `secondary=entry_tags`,
    instruct SQLAlchemy that we are going to be querying the `Tag` model via the `entry_tags`
    table. The third argument creates a back-reference, allowing us to go from the
    `Tag` model back to the associated list of blog entries. By specifying `lazy='dynamic',`
    we instruct SQLAlchemy that, instead of it loading all the associated entries
    for us, we want a Query object instead.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Entry`类的标签属性设置为`db.relationship`函数的返回值。前两个参数`'Tag'`和`secondary=entry_tags`指示SQLAlchemy我们将通过`entry_tags`表查询`Tag`模型。第三个参数创建了一个反向引用，允许我们从`Tag`模型返回到相关的博客条目列表。通过指定`lazy='dynamic'`，我们指示SQLAlchemy，我们不希望它为我们加载所有相关的条目，而是想要一个查询对象。
- en: Adding and removing tags from entries
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向条目添加和删除标签
- en: 'Let''s use the IPython shell to see how this works. Close your current shell
    and re-run the `scripts/create_db.py` script. This step is necessary since we
    added two new tables. Now re-open IPython:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用IPython shell来看看这是如何工作的。关闭当前的shell并重新运行`scripts/create_db.py`脚本。由于我们添加了两个新表，这一步是必要的。现在重新打开IPython：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are currently no tags in the database, so let''s create a couple of them:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 目前数据库中没有标签，所以让我们创建一些标签：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now let''s load up some example entries. In my database there are four:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们加载一些示例条目。在我的数据库中有四个：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In IPython, you can use an underscore (`_`) to reference the return-value of
    the previous line.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPython中，您可以使用下划线(`_`)来引用上一行的返回值。
- en: To add tags to an entry, simply assign them to the entry's `tags` attribute.
    It's that easy!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要向条目添加标签，只需将它们分配给条目的`tags`属性。就是这么简单！
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can work with an entry''s list of tags just like a normal Python list, so
    the usual `.append()` and `.remove()` methods will also work:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理普通的Python列表一样处理条目的标签列表，因此通常的`.append()`和`.remove()`方法也可以使用：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using backrefs
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用backrefs
- en: When we created the `tags` attribute on the `Entry` model, you will recall we
    passed in a `backref` argument. Let's use IPython to see how the back-reference
    is used.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Entry`模型上的`tags`属性时，您会回忆起我们传入了`backref`参数。让我们使用IPython来看看后向引用是如何使用的。
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unlike the `Entry.tags` reference, the back-reference is specified as `lazy='dynamic'`.
    This means that, unlike `entry.tags,` which gives us a list of tags, we will not
    receive a list of entries every time we access `tag.entries`. Why is this? Typically,
    when the result-set is larger than a few items, it is more useful to treat the
    `backref` argument as a query, which can be filtered, ordered, and so on. For
    example, what if we wanted to show the latest entry tagged with `python`?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Entry.tags`引用不同，后向引用被指定为`lazy='dynamic'`。这意味着，与给出标签列表的`entry.tags`不同，我们每次访问`tag.entries`时都不会收到条目列表。为什么呢？通常，当结果集大于几个项目时，将`backref`参数视为查询更有用，可以进行过滤、排序等操作。例如，如果我们想显示最新的标记为`python`的条目会怎样？
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The SQLAlchemy documentation contains an excellent overview of the various values
    that you can use for the lazy argument. You can find them online at [http://docs.sqlalchemy.org/en/rel_0_9/orm/relationships.html#sqlalchemy.orm.relationship.params.lazy](http://docs.sqlalchemy.org/en/rel_0_9/orm/relationships.html#sqlalchemy.orm.relationship.params.lazy)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy文档包含了可以用于lazy参数的各种值的优秀概述。您可以在[http://docs.sqlalchemy.org/en/rel_0_9/orm/relationships.html#sqlalchemy.orm.relationship.params.lazy](http://docs.sqlalchemy.org/en/rel_0_9/orm/relationships.html#sqlalchemy.orm.relationship.params.lazy)上找到它们。
- en: Making changes to the schema
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对模式进行更改
- en: The final topic we will discuss in this chapter is how to make modifications
    to an existing Model definition. From the project specification, we know we would
    like to be able to save drafts of our blog entries. Right now we don't have any
    way to tell whether an entry is a draft or not, so we will need to add a column
    that lets us store the status of our entry. Unfortunately, while `db.create_all()`
    works perfectly for creating tables, it will not automatically modify an existing
    table; to do this we need to use migrations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后要讨论的主题是如何对现有的模型定义进行修改。根据项目规范，我们希望能够保存博客条目的草稿。现在我们没有办法知道一个条目是否是草稿，所以我们需要添加一个列来存储条目的状态。不幸的是，虽然`db.create_all()`用于创建表非常完美，但它不会自动修改现有的表；为了做到这一点，我们需要使用迁移。
- en: Adding Flask-Migrate to our project
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Flask-Migrate添加到我们的项目中
- en: 'We will use Flask-Migrate to help us automatically update our database whenever
    we change the schema. In the blog virtualenv, install Flask-Migrate using `pip`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Flask-Migrate来帮助我们在更改模式时自动更新数据库。在博客虚拟环境中，使用`pip`安装Flask-Migrate：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The author of SQLAlchemy has a project called alembic; Flask-Migrate makes use
    of this and integrates it with Flask directly, making things easier.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的作者有一个名为alembic的项目；Flask-Migrate使用它并直接将其与Flask集成，使事情变得更容易。
- en: 'Next we will add a `Migrate` helper to our app. We will also create a script
    manager for our app. The script manager allows us to execute special commands
    within the context of our app, directly from the command-line. We will be using
    the script manager to execute the `migrate` command. Open `app.py` and make the
    following additions:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的应用程序添加一个`Migrate`助手。我们还将为我们的应用程序创建一个脚本管理器。脚本管理器允许我们在应用程序的上下文中直接从命令行执行特殊命令。我们将使用脚本管理器来执行`migrate`命令。打开`app.py`并进行以下添加：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to use the manager, we will add a new file named `manage.py` along
    with `app.py`. Add the following code to `manage.py`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用管理器，我们将在`app.py`旁边添加一个名为`manage.py`的新文件。将以下代码添加到`manage.py`中：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This looks very similar to `main.py`, the key difference being, instead of calling
    `app.run(),` we are calling `manager.run()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与`main.py`非常相似，关键区别在于，我们不是调用`app.run()`，而是调用`manager.run()`。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Django has a similar, although auto-generated, `manage.py` file that serves
    a similar function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Django有一个类似的，尽管是自动生成的`manage.py`文件，起着类似的功能。
- en: Creating the initial migration
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建初始迁移
- en: Before we can start changing our schema, we need to create a record of its current
    state. To do this, run the following commands from inside your blog's `app` directory.
    The first command will create a migrations directory inside the `app` folder that
    will track the changes we make to our schema. The second command `db migrate`
    will create a snapshot of our current schema so that future changes can be compared
    to it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更改模式之前，我们需要创建其当前状态的记录。为此，请从博客的`app`目录内运行以下命令。第一个命令将在`app`文件夹内创建一个迁移目录，用于跟踪我们对模式所做的更改。第二个命令`db
    migrate`将创建我们当前模式的快照，以便将来的更改可以与之进行比较。
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we will run `db upgrade` to run the migration that will indicate to
    the migration system that everything is up-to-date:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将运行`db upgrade`来运行迁移，以指示迁移系统一切都是最新的：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Adding a status column
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加状态列
- en: 'Now that we have a snapshot of our current schema, we can start making changes.
    We will be adding a new column, named `status`, that will store an integer value
    corresponding to a particular status. Although there are only two statuses at
    the moment (`PUBLIC` and `DRAFT`), using an integer instead of a Boolean gives
    us the option to easily add more statuses in the future. Open `models.py` and
    make the following additions to the `Entry` model:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了当前模式的快照，我们可以开始进行更改。我们将添加一个名为`status`的新列，该列将存储与特定状态对应的整数值。尽管目前只有两种状态（`PUBLIC`和`DRAFT`），但使用整数而不是布尔值使我们有可能在将来轻松添加更多状态。打开`models.py`并对`Entry`模型进行以下添加：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From the command-line, we will once again be running `db migrate` to generate
    the migration script. You can see from the command's output that it found our
    new column!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，我们将再次运行`db migrate`来生成迁移脚本。您可以从命令的输出中看到它找到了我们的新列！
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Because we have blog entries in the database, we need to make a small modification
    to the auto-generated migration to ensure the statuses for the existing entries
    are initialized to the proper value. To do this, open up the migration file (mine
    is `migrations/versions/2c8e81936cad_.py`) and change the following line:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在数据库中有博客条目，所以我们需要对自动生成的迁移进行小修改，以确保现有条目的状态被初始化为正确的值。为此，打开迁移文件（我的是`migrations/versions/2c8e81936cad_.py`）并更改以下行：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Replacing `nullable=True` with `server_default='0'` tells the migration script
    to not set the column to null by default, but instead to use `0`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将`nullable=True`替换为`server_default='0'`告诉迁移脚本不要将列默认设置为null，而是使用`0`。
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, run `db upgrade` to run the migration and create the status column.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行`db upgrade`来运行迁移并创建状态列。
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Congratulations, your `Entry` model now has a status field!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您的`Entry`模型现在有了一个状态字段！
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: By now you should be familiar with using SQLAlchemy to work with a relational
    database. We covered the benefits of using a relational database and an ORM, configured
    a Flask application to connect to a relational database, and created SQLAlchemy
    models. All this allowed us to create relationships between our data and perform
    queries. To top it off, we also used a migration tool to handle future database
    schema changes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该熟悉使用SQLAlchemy来处理关系数据库。我们介绍了使用关系数据库和ORM的好处，配置了一个Flask应用程序来连接到关系数据库，并创建了SQLAlchemy模型。所有这些都使我们能够在数据之间创建关系并执行查询。最重要的是，我们还使用了迁移工具来处理未来的数据库模式更改。
- en: In [Chapter 3](ch03.html "Chapter 3. Templates and Views"), *Templates and Views*
    we will set aside the interactive interpreter and start creating views to display
    blog entries in the web browser. We will put all our SQLAlchemy knowledge to work
    by creating interesting lists of blog entries, as well as a simple search feature.
    We will build a set of templates to make the blogging site visually appealing,
    and learn how to use the Jinja2 templating language to eliminate repetitive HTML
    coding. It will be a fun chapter!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。模板和视图")中，*模板和视图*，我们将搁置交互式解释器，开始创建视图以在Web浏览器中显示博客条目。我们将利用我们所有的SQLAlchemy知识创建有趣的博客条目列表，以及一个简单的搜索功能。我们将构建一组模板，使博客网站在视觉上更具吸引力，并学习如何使用Jinja2模板语言来消除重复的HTML编码。这将是一个有趣的章节！
