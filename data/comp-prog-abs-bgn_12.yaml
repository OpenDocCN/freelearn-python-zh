- en: '*Chapter 10:* Programming Paradigms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第十章：编程范例*'
- en: If we look at all the programming languages, we can see patterns and similarities
    between them, and we can use these to classify them into different paradigms.
    The word **paradigm** means a typical example or pattern of something, and this
    is precisely what we are looking for in programming languages when grouping them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看所有编程语言，我们可以看到它们之间有模式和相似之处，我们可以利用这些来将它们分类到不同的范例中。单词**范例**意味着某物的典型例子或模式，这正是我们在对编程语言进行分组时寻找的东西。
- en: The reason we want to do this classification is because the way we write a program
    in one of these groups will differ significantly from how we do so in languages
    belonging to another group.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要进行这种分类的原因是因为我们在这些组中的一个中编写程序的方式将与我们使用属于另一组语言的程序的方式有显著差异。
- en: A computer program will almost always, in one way or another, model something
    in the real world. We are solving real-world problems using software. The question
    is how best we can model and represent real-world things in code and how best
    we can structure the solution we have to this real-world problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序几乎总是以某种方式或另一种方式模拟现实世界中的事物。我们使用软件解决现实世界的问题。问题是我们在代码中如何最好地模拟和表示现实世界的事物，以及我们如何最好地构建解决这个现实世界问题的解决方案。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Understanding structured programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解结构化编程
- en: Understanding object-oriented programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解面向对象编程
- en: Understanding functional programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: Understanding logic programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解逻辑编程
- en: Understanding other paradigms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解其他范例
- en: Understanding multi-paradigm languages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多范例语言
- en: 'Let''s begin with the paradigm that we are most familiar with: structured programming.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们最熟悉的范例开始：结构化编程。
- en: Understanding structured programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解结构化编程
- en: Structured programming is what we have looked at in this book. Loops, conditionals,
    and functions define the flow of a program that uses this paradigm. If you have
    read the previous chapters of this book, then they should all be familiar to you
    by now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化编程是我们在本书中讨论的内容。循环、条件和函数定义了使用此范例的程序流程。如果你已经阅读了本书的前几章，那么现在它们都应该很熟悉了。
- en: Structured programming is a branch of a family of paradigms called **imperative
    programming**. Languages that use the concepts of imperative programming use statements
    to change the program's state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化编程是称为**命令式编程**的范例家族的一个分支。使用命令式编程概念的编程语言使用语句来改变程序的状态。
- en: If we look at that definition, we must first learn what statements and program
    state are.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看那个定义，我们必须首先了解语句和程序状态是什么。
- en: Statements
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: In the first part of this definition, we'll talk about statements. A statement,
    as described in [*Chapter 5*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081),
    *Sequence – The Basic Building Block of a Computer Program*, in the *Understanding
    statements* section, this can be viewed as a command that we give to the application.
    In natural language, we have something that is called the imperative mood. The
    imperative mood is something that forms a command, such as *Move!*, *Don't be
    late!*, or *Work hard!*. In imperative programming, we give instructions to the
    computer with something that is like the imperative mood; that is, a command that
    is expressed in the form of a statement.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义的第一部分，我们将讨论语句。正如在[*第五章*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081)中描述的，“序列
    – 计算机程序的基本构建块”，在“理解语句”部分，这可以被视为我们向应用程序下达的命令。在自然语言中，我们有一种称为祈使语气的表达方式。祈使语气是一种形成命令的东西，例如“移动！”，“不要迟到！”或“努力工作！”。在命令式编程中，我们用类似祈使语气的东西向计算机下达指令；也就是说，以语句形式表达出的命令。
- en: That is the first half of the definition of imperative programming. The second
    part talks about changing the program's state.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令式编程定义的前半部分。后半部分讨论的是改变程序的状态。
- en: Program state
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序状态
- en: A program is said to have a state if it remembers previous events that have
    occurred. A program stores data in variables. At any given point, during the program's
    execution, we can look at the data that is currently in all the variables we have
    defined. The combined value in all these variables is what makes up the state
    of the program.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序能够记住之前发生的事件，那么我们就说它具有状态。程序在变量中存储数据。在任何给定的程序执行点，我们可以查看所有已定义变量中当前的数据。所有这些变量的组合值构成了程序的状态。
- en: If we change one variable, the state of the program will also change. When we
    are talking about imperative programming, we mean that as soon as a statement
    changes the content of a variable, it has changed the program state.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变一个变量，程序的状态也会改变。当我们谈论命令式编程时，我们的意思是，一旦一个语句改变了变量的内容，它就改变了程序状态。
- en: This is what forms the memory of preceding events. When an event – a statement,
    in our case – occurs and it changes a variable, it will affect the behavior of
    the program. If we have an application that will launch a rocket, we might have
    a function that takes care of the countdown. To keep track of what number we are
    currently at, we need to have a variable. Changing this variable during the countdown
    will change the state of the application. When the variable reaches zero, it will
    trigger the event of sending the start signal to the rocket.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是形成先前事件记忆的方式。当一个事件——在我们的例子中是一个语句——发生并改变一个变量时，它将影响程序的行为。如果我们有一个将发射火箭的应用程序，我们可能有一个负责倒计时的函数。为了跟踪我们目前处于哪个数字，我们需要有一个变量。在倒计时过程中改变这个变量将改变应用程序的状态。当变量达到零时，它将触发向火箭发送启动信号的触发事件。
- en: If this is imperative programming, how are things different in structured programming?
    Let's compare them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是命令式编程，那么在结构化编程中有什么不同呢？让我们来比较一下。
- en: Comparing imperative and structured programming
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较命令式编程和结构化编程
- en: Programs written in assembly language use a concept known as GOTOs. It is a
    technique that's used to control the flow in a program. To use them, we insert
    labels into the code, and we can then instruct the program to jump to one such
    label and resume its execution there.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用汇编语言编写的程序使用一种称为GOTOs的概念。这是一种用于控制程序流程的技术。要使用它们，我们在代码中插入标签，然后可以指示程序跳转到这样的标签并从那里继续执行。
- en: 'A small code snippet of assembly language can illustrate this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一段简短的汇编语言代码片段可以说明这一点：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have a label called `exit`. On the first line, we move the value `3`
    into a register (remember that a register in an assembly is like a variable) called
    `eax`. On the second line, we do an unconditional jump to our label, `exit`. The
    jump being unconditional means that we will always do this jump. In the assembly
    language, there are also conditional jumps where we only jump if a register is
    equal to, less than, or higher than some value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`exit`的标签。在第一行，我们将值`3`移动到一个名为`eax`的寄存器（记住，汇编语言中的寄存器就像一个变量）。在第二行，我们无条件地跳转到我们的标签`exit`。无条件跳转意味着我们总是会执行这个跳转。在汇编语言中，也有条件跳转，只有当寄存器的值等于、小于或大于某个值时才会跳转。
- en: Since the jump is unconditional, line three will never execute as we will always
    jump past this line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跳转是无条件的，第三行永远不会执行，因为我们总是会跳过这一行。
- en: 'Many languages that came into existence in the 60s and 70s also had the same
    concept of an unconditional jump. Here, we can find languages such as BASIC and
    C. In these languages, it is not called a jump. Instead, the term *GOTO* is used.
    The programming language C++ is based upon C, so it also uses GOTO. The same program
    written in C++ will look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代和70年代出现的许多语言也具有相同的不条件跳转概念。在这里，我们可以找到像BASIC和C这样的语言。在这些语言中，它不被称为跳转。相反，使用*GOTO*这个术语。编程语言C++基于C，因此它也使用GOTO。用C++编写的相同程序将看起来像这样：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Today, it is, under most circumstances, considered a bad practice to use GOTOs
    as the code will be hard to read, understand, and maintain. There is hardly ever
    any need to perform a GOTO as languages such as BASIC and C support constructs
    that can let us achieve the same result and maintain good code quality.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，在大多数情况下，被认为使用GOTOs是一种不好的做法，因为代码将难以阅读、理解和维护。几乎很少需要执行GOTO，因为像BASIC和C这样的语言支持可以让我们达到相同结果并保持良好的代码质量的结构。
- en: Using this style of programming was what first defined imperative programming.
    As programming languages developed and we got other tools, such as loops, `if`
    statements, and functions, there was a need to distinguish these more modern languages
    from the older style. Even though these programming languages use the same ideas
    as assembly language, these statements will change the state of the program. This
    is because they no longer rely on jumps or GOTOs to accomplish this. This was
    when we got the definition structured programming. A language that supports structured
    programming is a language that modifies the state of the program using statements
    and has functions, loops, and `if` statements as tools to accomplish this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种编程风格最初定义了命令式编程。随着编程语言的发展以及我们获得了其他工具，如循环、`if`语句和函数，就有必要区分这些更现代的语言和较老的风格。尽管这些编程语言使用与汇编语言相同的思想，但这些语句会改变程序的状态。这是因为它们不再依赖于跳转或GOTO来完成这个任务。这就是我们得到结构化编程定义的时候。支持结构化编程的语言是使用语句来修改程序状态的语言，并且有函数、循环和`if`语句作为完成这一任务的工具。
- en: We will sometimes also hear the terms *procedural* and *modular* languages.
    There is no need to go into the details of what the difference is between these
    as this is mostly academic. We can safely consider all these the same thing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时也会听到*过程式*和*模块化*语言的术语。没有必要深入了解这些术语之间的区别，因为这主要是学术性的。我们可以安全地认为这些都是同一件事。
- en: 'Some well-known languages that support structured programming or their relatives,
    procedural and imperative programming, are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一些支持结构化编程或其相关语言（过程式和命令式编程）的知名语言如下：
- en: Ada
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ada
- en: ALGOL
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ALGOL
- en: BASIC
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BASIC
- en: C
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: C++
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: C#
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: COBOL
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COBOL
- en: Fortran
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fortran
- en: Go
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Java
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: JavaScript
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: Pascal
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pascal
- en: Perl
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perl
- en: PHP
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Python
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Ruby
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby
- en: Rust
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust
- en: Swift
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift
- en: Visual Basic
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Basic
- en: Structured programming is a popular paradigm, as this long list of languages
    proves. In the 90s, another paradigm gained popularity and is still one of the
    essential paradigms in use. It is called object-oriented programming. Let's see
    what this is about.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化编程是一种流行的范式，如这份长长的语言列表所证明的那样。在90年代，另一种范式获得了流行，并且仍然是当前使用的主要范式之一。它被称为面向对象编程。让我们看看这是怎么回事。
- en: Understanding object-orientated programming
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向对象编程
- en: The main idea within object-oriented programming is to model the code in the
    same way as we as humans look at the world.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的主要思想是以我们人类看待世界的方式对代码进行建模。
- en: Even if you've never thought about it, we are always classifying things and
    grouping things together using abstraction. We can talk about vehicles, and we
    have shared knowledge of what is included in this group. Cars, bicycles, boats,
    and airplanes are, while pencils, ducks, and swimsuits are not.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有想过，我们总是在使用抽象对事物进行分类和分组。我们可以谈论车辆，并且我们对这个群体中包含的内容有共同的知识。汽车、自行车、船只和飞机是，而铅笔、鸭子和泳衣则不是。
- en: I could say, *I need to go to town. Can anyone lend me a vehicle?*
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以说，“我需要去镇上。有人能借我一辆车吗？”
- en: You will interpret this in such a way that the actual kind does not matter,
    but it must be something that can transport me to town. It could just as well
    be a car as it could be a skateboard.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你会这样理解，实际的种类不重要，但它必须是我能去镇上的东西。它可能就像一辆车一样，也可能是一块滑板。
- en: Grouping things into these abstractions make our lives easier as we will not
    go into details every single time, we talk about something. I can ask for a vehicle
    instead of describing that I need a device that can transport me from my current
    location to town.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将事物分组到这些抽象中使我们的生活更轻松，因为我们不必每次谈论某事时都深入细节。我可以要求一辆车，而不是描述我需要一个能把我从当前位置带到镇上的设备。
- en: Things within such an abstraction can be very different, but if they share some
    key characteristics, we will understand it. Take a look at the following image.
    Here, we have two items that can both be grouped into something that we can call
    remote controls.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的抽象内部，事物可能非常不同，但如果它们有一些关键特征，我们就会理解它们。看看下面的图片。在这里，我们有两个可以归入我们称之为遥控器的东西。
- en: 'One of them will control your TV and let you change channels and change the
    volume. The other one will let you lock and unlock your car:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个将控制你的电视，让你换频道和调节音量。另一个将让你锁上和打开你的车：
- en: '![Figure 10.1 – Remote controls](img/Fig_10.1_B15554.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 遥控器](img/Fig_10.1_B15554.jpg)'
- en: Figure 10.1 – Remote controls
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 遥控器
- en: Even though they work with different devices and the result of pushing their
    buttons will be very different, they share the behavior in that they control something
    from a distance wirelessly. We have labeled these devices remote controls to make
    our communication more convenient.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管他们使用不同的设备，按按钮的结果也会非常不同，但他们共享的行为是在无线远程控制某物。我们把这些设备称为遥控器，以使我们的沟通更加方便。
- en: What if we could do the same when writing software? This is where object orientation
    comes in. It will let us use the same approach.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在编写软件时做同样的事情，这就是面向对象出现的地方。它将让我们使用相同的方法。
- en: If we are going to write a program that keeps track of the warehouse inventory
    and we want to do so object-oriented style, we can look at a real warehouse and
    describe it just as we see it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要编写一个跟踪仓库库存的程序，并且想以面向对象的方式来做，我们可以看看一个真正的仓库，并像我们看到的那样描述它。
- en: 'In the warehouse, we have things such as the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库里，我们有如下一些东西：
- en: Products
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Shelves
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货架
- en: A coffee machine
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台咖啡机
- en: Warehouse employees
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库员工
- en: A dead flower in the window
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗户里的枯萎花朵
- en: Our system will need to know about some of these things, but not all of them.
    In the preceding list, we can ignore the flower and the coffee machine, but the
    other three are good candidates for making it into our program.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统需要了解一些这些事物，但不是全部。在先前的列表中，我们可以忽略花朵和咖啡机，但其他三个是将其纳入我们程序的好候选。
- en: If we look at one of these products, we will see that it can be several things,
    all the way from tiny screws and bolts to machines or devices of some sort. But
    from the perspective of a warehouse, they share the same characteristics. They
    are all items that we store, and we can describe them using the same attributes.
    They have a name, a weight, and manufacturer; we have a certain amount of them;
    and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这些产品之一，我们会看到它可以是几件事情，从小螺丝和螺栓到某种机器或设备。但从仓库的角度来看，它们具有相同的特征。它们都是我们存储的物品，我们可以使用相同的属性来描述它们。它们有一个名字、重量和制造商；我们有它们的一定数量；等等。
- en: In object-oriented programming, we try to preserve this way of describing things
    and represent them in a way that is not too different from how we just described
    them here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们试图保留这种描述事物的方式，并以与我们刚才描述的方式不太不同的方式来表示它们。
- en: To understand how object-oriented programming works, we will need to break it
    down into some main concepts that we will need to understand. Let's check them
    out.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解面向对象编程是如何工作的，我们需要将其分解为一些主要概念，这些概念是我们需要理解的。让我们来看看它们。
- en: Classes and objects
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象
- en: In object-orientated programming, a class is like a blueprint, or description,
    of something. Let's take the concept of a person as an example. How can we describe
    a person? We can start to make a list of things that apply to all people. It might
    look something like this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，一个类就像一个蓝图或描述，让我们以人的概念为例。我们如何描述一个人？我们可以开始列出一个适用于所有人的事物的清单。它可能看起来像这样。
- en: 'A person has the following attributes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人有以下属性：
- en: A name
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名字
- en: An age
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个年龄
- en: A gender
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个性别
- en: Height
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身高
- en: Weight
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体重
- en: Hair color
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头发颜色
- en: Eye color
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 眼睛颜色
- en: Shoe size
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鞋码
- en: Nationality
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国籍
- en: Address
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址
- en: Telephone number
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码
- en: The list can go on. We can now decide that these are things that apply to all
    people. If we think about it, this is all data about a person. We have not described
    any behavior. We could make another list that describes things a person can do.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以继续。我们现在可以决定这些是适用于所有人的事物。如果我们仔细想想，这些都是关于个人的数据。我们还没有描述任何行为。我们可以再列一个清单，描述一个人可以做的事情。
- en: 'A person can do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可以做以下事情：
- en: Jump
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳跃
- en: Run
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跑步
- en: Walk
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行走
- en: Sit
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐下
- en: Stand
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 站立
- en: Sleep
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 睡眠
- en: Chill
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休息
- en: Work
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作
- en: Play
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩耍
- en: Dance
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳舞
- en: The same thing applies here – this list can be very long.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于这里——这个列表可以非常长。
- en: 'If we are going to represent a person in a program, we won''t need all the
    available data and behavior. Instead, we need to make an abstract of a person
    in such a way that we can represent them with the things that are interesting
    for us. Name, age, and sex might all be such things, but shoe size will most likely
    not be unless we are writing an application for a shoe store. Let''s focus on
    the data and pick some things that might be interesting enough to implement in
    an application. We might pick the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算在程序中表示一个人，我们不需要所有可用的数据和行为。相反，我们需要以某种方式抽象出一个人，这样我们就可以用对我们感兴趣的东西来表示他们。姓名、年龄和性别可能都是这样的东西，但除非我们正在编写鞋店的程序，否则鞋码很可能不是。让我们专注于数据，并挑选一些可能足够有趣以在应用程序中实现的东西。我们可能会选择以下内容：
- en: Name
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名
- en: Age (most likely in the form of date of birth)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄（很可能是出生日期的形式）
- en: Gender
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性别
- en: Address
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址
- en: Nationality
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国籍
- en: Phone number
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码
- en: Email address
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址
- en: Now, we'll learn how to define a blueprint – called a class in object-oriented
    programming – for a person since we have a list of data that applies to all people.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何定义一个蓝图——在面向对象编程中称为类——用于表示人，因为我们有一份适用于所有人的数据列表。
- en: 'We give it a descriptive name and list the things we are interested in. It
    might look something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给它一个描述性的名字，并列出我们感兴趣的东西。它可能看起来像这样：
- en: '![Figure 10.2 – A class called person](img/Fig_10.2_B15554.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 一个名为person的类](img/Fig_10.2_B15554.jpg)'
- en: Figure 10.2 – A class called person
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 一个名为person的类
- en: The preceding image depicts a class in a simplified way; that is, a rectangle
    with three sections. In the top section, we have the name that we have given this
    class. In the middle section, we've described the data we want to use to describe
    a person. The last section is for behavior, which is something we will come back
    to soon.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像以简化的方式描述了一个类；即一个有三个部分的矩形。在上部部分，我们有我们给这个类起的名字。在中间部分，我们描述了我们想要用来描述人的数据。最后一部分是用于行为，这是我们很快会回到的地方。
- en: Object-oriented programming is very focused around data, so when we're deciding
    what a class will look like, this is often where we start. The data that makes
    it into our class will often dictate what kind of behavior we want it to have.
    This behavior often dictates the operations we need to perform on the data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程非常关注数据，因此当我们决定一个类的样子时，这通常是我们的起点。进入我们类中的数据通常会决定我们希望它有什么样的行为。这种行为通常决定了我们需要在数据上执行的操作。
- en: The behavior we identified for a person earlier, such as jump, run, and sleep,
    will most likely not be something we will need to represent. Instead, we will
    usually find things that will modify the data, such as changing the address.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前为一个人识别的行为，如跳跃、奔跑和睡眠，可能不是我们需要表示的东西。相反，我们通常会找到会修改数据的东西，比如更改地址。
- en: For now, we will leave the third section of the class empty, but we will come
    back to it later.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将留空类的第三部分，但我们会稍后回来。
- en: Now, we have a class and the blueprint for a person, but we haven't represented
    any actual people yet. A representation of a thing – in our case, a person – is
    called an *object*. An object will always belong to a class. Now that we have
    a class, we can create an object from it, and each object will represent one person.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个人的类和蓝图，但还没有表示任何实际的人。在我们的例子中，一个事物（人）的表示称为*对象*。一个对象始终属于一个类。既然我们有了类，我们就可以从中创建一个对象，每个对象将代表一个人。
- en: 'If we have a group of people that we want to represent in our application,
    a representation of them could look as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在应用程序中表示一组人，他们的表示可能如下所示：
- en: '![Figure 10.3 – Four objects from the person class](img/Fig_10.3_B15554.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – person类中的四个对象](img/Fig_10.3_B15554.jpg)'
- en: Figure 10.3 – Four objects from the person class
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – person类中的四个对象
- en: As we can see in the preceding diagram, all four objects have their own set
    of data; a name, a date of birth, a gender, an address, a nationality, a phone
    number, and an email address. The data in one object is independent of the data
    in other objects that belong to the same class. If we change the address in one
    object, it will not affect any other object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的图中可以看到，所有四个对象都有自己的数据集；姓名、出生日期、性别、地址、国籍、电话号码和电子邮件地址。一个对象中的数据与其他属于同一类的对象中的数据是独立的。如果我们更改一个对象中的地址，它将不会影响任何其他对象。
- en: To summarize this, we can state that a class is a model or the blueprint for
    the objects. The data that is defined within the class is often referred to as
    **member variables** or **attributes**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这一点，我们可以说，一个类是对象的一个模型或蓝图。在类中定义的数据通常被称为**成员变量**或**属性**。
- en: Member variables
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成员变量
- en: 'A member variable is just like any other variable, with one key difference:
    it lives inside of an object.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 成员变量就像任何其他变量一样，有一个关键的区别：它存在于对象内部。
- en: 'To illustrate this, we can consider a very minimal class for a person. It could
    look something like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们可以考虑一个关于人的非常简单的类。它可能看起来像这样：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we''re defining a class called `Person`. It has two variables inside
    it: `name` and `age`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`Person`的类。它里面有两个变量：`name`和`age`。
- en: At this point, no actual variables exist in the computer's memory as this is
    just a blueprint for what a person object will look like. To make them come into
    existence, we need to create objects, often referred to as instances, from this
    class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，计算机内存中还没有实际的变量存在，因为这只是一个关于人对象外观的蓝图。为了使它们存在，我们需要从这个类中创建对象，通常被称为实例。
- en: 'This can be done like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以这样完成：
- en: '[PRE3]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This creates two objects. We use the variable names `p1` and `p2` to reference
    them. The interesting part is what happens when we create these objects. If we
    take a closer look at line one, we will see that a chain of events will occur:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了两个对象。我们使用变量名`p1`和`p2`来引用它们。有趣的部分是当我们创建这些对象时会发生什么。如果我们仔细看看第一行，我们会看到一系列事件将会发生：
- en: The first thing that happens is that, somewhere in the computer's memory, an
    object from the `Person` class is created with a set of two variables called `name`
    and `age`, as shown in the following image![Figure 10.4 – An object from the person
    class](img/Fig_10.4_B15554.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发生的事情是，在计算机内存的某个地方，从`Person`类创建了一个包含两个变量`name`和`age`的对象，如下面的图像所示：![图10.4 – 来自人类的对象](img/Fig_10.4_B15554.jpg)
- en: Figure 10.4 – An object from the person class
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.4 – 来自人类的对象
- en: The next step is that the member variables get initialized with the data we
    passed in when we created the object. This is illustrated in the following image:![Figure
    10.5 – The member variables in the object are initialized](img/Fig_10.5_B15554.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是成员变量被初始化，这些初始化数据是在我们创建对象时传递的。这在上面的图像中得到了说明：![图10.5 – 对象中的成员变量被初始化](img/Fig_10.5_B15554.jpg)
- en: Figure 10.5 – The member variables in the object are initialized
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.5 – 对象中的成员变量被初始化
- en: 'The last step is that the `p1` variable now points out where in memory this
    object is located, as illustrated in the following image:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是`p1`变量现在指向内存中这个对象的位置，如下面的图像所示：
- en: '![Figure 10.6 – The object is referenced by the p1 variable](img/Fig_10.6_B15554.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 对象通过p1变量被引用](img/Fig_10.6_B15554.jpg)'
- en: Figure 10.6 – The object is referenced by the p1 variable
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 对象通过p1变量被引用
- en: 'Then, this process is repeated for the object that contains the name `Manfred`.
    By doing this, we get something that looks similar to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个过程被重复用于包含名称`Manfred`的对象。通过这样做，我们得到以下类似的结果：
- en: '![Figure 10.7 – Two objects from the Person class](img/Fig_10.7_B15554.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 来自Person类的两个对象](img/Fig_10.7_B15554.jpg)'
- en: Figure 10.7 – Two objects from the Person class
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 来自Person类的两个对象
- en: Now that we have two objects, we can see that we have two variables called `name`
    and `age`. One of each is inside the `p1` object and the `p2` object. For every
    object we create from the `Person` class, we will get a new set of these two.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个对象，我们可以看到我们有两个名为`name`和`age`的变量。每个变量都包含在`p1`对象和`p2`对象中。对于从`Person`类创建的每个对象，我们都会得到这两组变量中的一组。
- en: 'We will soon change this class, but as it looks now, we can access these variables
    like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会改变这个类，但就目前来看，我们可以像这样访问这些变量：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will give us the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE5]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Object-oriented programming states that member data should be encapsulated within
    its object and that direct access to this data from the outside should be prevented.
    Let's see why this is a critical concept in object orientation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程指出，成员数据应该封装在其对象内部，并且应该阻止从外部直接访问这些数据。让我们看看为什么这是面向对象中的一个关键概念。
- en: Understanding encapsulation
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解封装
- en: Encapsulation, also known as information hiding, is a concept where the object's
    internal implementation is hidden from everything outside the object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 封装，也称为信息隐藏，是一个概念，其中对象的内部实现被隐藏在对象之外的所有事物中。
- en: 'Encapsulation can be described in many ways. The American computer engineers
    James Rumbaugh and Michael Blaha described it like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 封装可以用多种方式来描述。美国计算机工程师詹姆斯·鲁姆巴格和迈克尔·布莱哈这样描述它：
- en: '*"One design goal is to treat classes as "black boxes," whose external interface
    is public but whose internal details are hidden from view. Hiding internal information
    permits implementation of a class to be changed without requiring any clients
    of the class to modify code."*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '"一个设计目标是把类视为“黑盒”，其外部接口是公开的，但其内部细节对视图隐藏。隐藏内部信息允许在不要求类的任何客户端修改代码的情况下更改类的实现。"'
- en: The vital key here is the *interface*. An interface is what we use to communicate
    with an object. Look at the remote controls in *Figure 10.1*. The buttons we can
    push is the interface. We use them to communicate with the internal logic inside
    the device.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是*接口*。接口是我们用来与对象通信的东西。看看*图10.1*中的遥控器。我们可以按的按钮是接口。我们用它们与设备内部的内部逻辑进行通信。
- en: The remote control object is a *black box* as we can't see the internals of
    the remote, and there is no need for us to either. The only thing we need to understand
    to be able to use the object is the interface. If the remote is not working correctly,
    we can take it to someone who understands the inner workings of it, and they can
    repair it. If they don't change the interface, the buttons, and what functionality
    that is associated with them, we won't need to change the way we use the remote
    before and after the modification.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 遥控器对象是一个*黑盒*，因为我们看不到遥控器的内部，我们也不需要这样做。我们唯一需要理解以能够使用对象的是接口。如果遥控器工作不正常，我们可以把它带给了解其内部工作原理的人，他们可以修理它。如果他们没有改变接口、按钮以及与之相关的功能，我们就不需要改变在修改前后使用遥控器的方式。
- en: One thing we should hide from the outside world is the data. No, wait! If the
    data is hidden inside an object, how could we then use it? Let's look at an example
    to see what we mean by hiding the data inside an object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从外部世界隐藏的一件事是数据。不，等等！如果数据被隐藏在一个对象内部，我们如何使用它呢？让我们通过一个例子来看看我们所说的在对象内部隐藏数据是什么意思。
- en: 'If you walk down the street and you meet another person, you cannot, just by
    observing that person, see things such as the person''s name, what they had for
    breakfast, their age, and where they live. This data is encapsulated inside the
    object:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你走在街上，遇到另一个人，仅通过观察那个人，你无法看到诸如人的名字、他们早餐吃了什么、他们的年龄以及他们住在哪里等信息。这些数据被封装在对象内部：
- en: '![Figure 10.8 – Data encapsulated inside a real-world object](img/Fig_10.8_B15554.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 数据封装在现实世界对象内部](img/Fig_10.8_B15554.jpg)'
- en: Figure 10.8 – Data encapsulated inside a real-world object
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 数据封装在现实世界对象内部
- en: 'To get this information, we will need to ask the person. We say that objects
    communicate by passing messages to each other. This looks something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取这些信息，我们需要询问那个人。我们说对象通过相互传递消息进行通信。这看起来就像这样：
- en: '![Figure 10.9 – Two objects communicating by sending messages](img/Fig_10.9_B15554.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 通过发送消息进行通信的两个对象](img/Fig_10.9_B15554.jpg)'
- en: Figure 10.9 – Two objects communicating by sending messages
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 通过发送消息进行通信的两个对象
- en: We will need to modify our class so that the data is hidden and we have a way
    to communicate with it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改我们的类，以便数据被隐藏，并且我们有与它通信的方式。
- en: 'We can hide the data by using the `private` keyword. The class will now look
    something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`private`关键字来隐藏数据。现在类看起来可能像这样：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By declaring `name` and `age` as private, we can no longer access them from
    outside the class. This means that the lines where we printed the name and age
    of the two objects will no longer work.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`name`和`age`声明为私有，我们不能再从类外部访问它们。这意味着我们打印两个对象的名字和年龄的行将不再工作。
- en: The class, as it looks now, is useless as we can create an object and assign
    values to its variables, but there is no way for us to do anything with this data
    after this point as it is hidden from us. We will need to create an interface,
    such as the buttons on the remote control, that will let us work with the data.
    We will do that with the help of class methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的类看起来是无用的，因为我们可以创建一个对象并为其变量赋值，但在此之后我们无法对这些数据进行任何操作，因为它们对我们来说是隐藏的。我们需要创建一个接口，比如遥控器上的按钮，这样我们就可以与这些数据交互。我们将通过类方法来完成这个任务。
- en: Class methods
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法
- en: A class method is nothing but a function that belongs to a class. The reason
    we have a different name for these functions is so that we can distinguish between
    a function that is part of a class and one that is not. As soon as you hear someone
    mention a method, you know that it is a function that belongs to a class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法实际上就是一个属于类的函数。我们之所以为这些函数使用不同的名称，是为了能够区分一个属于类的函数和一个不属于类的函数。一旦你听到有人提到方法，你就知道这是一个属于类的函数。
- en: Two popular methods that we will find in classes are what are called *getters*
    and *setters*. A getter is a method that returns the value of a private member
    variable, while a setter is a method that lets us change its value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中我们通常会找到两种流行的方法，被称为*getter*和*setter*。getter是一个返回私有成员变量值的函数，而setter是一个允许我们更改其值的函数。
- en: 'To make a method available outside the class, we can use the `public` keyword.
    To this, we can add getters and setters for our class, and it will then look like
    this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使方法在类外可用，我们可以使用`public`关键字。为此，我们可以为我们的类添加getter和setter，然后它看起来就像这样：
- en: '[PRE7]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will give us access to the member variables. We can now create objects,
    get the private data stored inside of them, and change their value if needed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够访问成员变量。现在我们可以创建对象，获取它们内部存储的私有数据，并在需要时更改它们的值。
- en: 'It will look something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来可能像这样：
- en: '[PRE8]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will produce the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE9]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A natural question at this point is why we need to bother having these getters
    and setters. Why can't we just say that `name` and `age` are `public` and let
    anyone read and change them as they want? The reason is that keeping the data
    private and controlling access to it through methods will give us control.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，一个自然的问题是我们为什么需要费心去有这些getter和setter。为什么我们不能简单地说`name`和`age`是`public`的，并让任何人随意读取和更改它们呢？原因在于，保持数据私有并通过方法控制对它的访问将给我们带来控制权。
- en: If a stranger walks up to you and asks for your name, you will have some options.
    You could respond with your actual name, you could tell them that it is none of
    their business, or you could lie and tell them a different name. You have control
    over the access to your private data, just as the class will have control over
    the access to its private data with the help of these methods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个陌生人走到你面前并询问你的名字，你将有一些选择。你可以回答你的真实姓名，你也可以告诉他们这不关他们的事，或者你可以撒谎并告诉他们一个不同的名字。你对自己的私人数据有控制权，正如类可以通过这些方法对其私有数据进行控制一样。
- en: 'When the `set_age` method is called, we could, for example, check the value
    that is being passed in to make sure that it is within a valid range. We could,
    for example, refuse to set the age if it is a negative number or higher than any
    expected human age. We could make use of exceptions, which we covered in [*Chapter
    9*](B15554_09_Final_NM_ePub.xhtml#_idTextAnchor127), *When Things Go Wrong – Bugs
    and  Exceptions*, in the *Working with exceptions* section. The `set_age` method
    would then look something like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`set_age`方法时，例如，我们可以检查传入的值以确保它在有效范围内。例如，如果年龄是一个负数或高于任何预期的正常人类年龄，我们可以拒绝设置年龄。我们可以使用异常，这在[*第9章*](B15554_09_Final_NM_ePub.xhtml#_idTextAnchor127)中有所介绍，即*当事情出错
    – 错误和异常*，在*处理异常*部分。`set_age`方法可能看起来像这样：
- en: '[PRE10]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will now get an exception if the value that's being passed to the method
    is below `0` or greater than `130`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给方法的值低于`0`或大于`130`，我们将得到一个异常。
- en: 'Now, we can add some class methods to the diagram we looked at previously in
    *Figure 10.2* . In the following image, we can see that we''re making use of the
    lower part of the rectangle for this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在之前在*图10.2*中看到的图中添加一些类方法。在下面的图像中，我们可以看到我们正在使用矩形的下半部分来完成这个任务：
- en: '![Figure 10.10 – A class with member variables and methods](img/Fig_10.10_B15554.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 具有成员变量和方法的一个类](img/Fig_10.10_B15554.jpg)'
- en: Figure 10.10 – A class with member variables and methods
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 具有成员变量和方法的一个类
- en: 'A class can, of course, have methods other than just getters and setters. It
    is up to us to decide what methods we want our class to have. Our `Person` class
    could, for example, have a method called `birthday` where we increase the age
    of a person by one, as shown in the following code snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类当然可以拥有除了获取器和设置器之外的其他方法。我们决定我们的类需要哪些方法。例如，我们的`Person`类可以有一个名为`birthday`的方法，通过这个方法我们可以将一个人的年龄增加一岁，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We could now use it like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以这样使用它：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of this program will be the same as it was previously:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序输出的结果将与之前相同：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, the power of object-oriented programming is that objects are
    self-contained entities that control their data. But object-oriented programming
    has another powerful feature that will let us reuse code, and that is the concept
    of inheritance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，面向对象编程的强大之处在于对象是自包含的实体，它们控制着自己的数据。但面向对象编程还有一个强大的功能，那就是代码重用的概念，即继承。
- en: Inheritance
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'If I asked you if I could borrow your phone to make a call, it would not matter
    if you gave me your smartphone, an old mobile phone from 2005, or even access
    to a landline telephone. They all share some of the same features, with one of
    them being the ability to make phone calls. We could define this with a chain
    of statements, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我问你能否借用你的手机打电话，无论是给你智能手机、2005年的旧手机，还是提供座机电话的使用，这都无关紧要。它们都有一些共同的特征，其中之一就是能够打电话。我们可以用一系列陈述来定义这一点，如下所示：
- en: A smartphone is a mobile phone
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能手机是移动电话
- en: A mobile phone is a telephone
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动电话是电话
- en: A telephone can make phone calls
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话可以打电话
- en: A smartphone can, therefore, make phone calls
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，智能手机可以打电话
- en: 'We could say that we have several levels of abstractions where we have a relationship
    between the levels. This is what we call an *is-a* relation. We can illustrate
    this with the following diagram:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，我们有几个抽象级别，它们之间存在关系。我们称之为“是”关系。我们可以用以下图表来表示这一点：
- en: '![Figure 10.11 – Is-a relations between telephones](img/Fig_10.11_B15554.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 电话之间的“是”关系](img/Fig_10.11_B15554.jpg)'
- en: Figure 10.11 – Is-a relations between telephones
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 电话之间的“是”关系
- en: We can say that because a smartphone is a mobile phone, it can do anything a
    mobile phone can. We also know that a smartphone can do things that an old-style
    mobile phone can't, such as allowing us to use the GPS together with a map app
    to help us navigate.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，因为智能手机是移动电话，所以它可以做任何移动电话能做的事情。我们还知道，智能手机可以做老式移动电话做不到的事情，比如允许我们使用GPS和地图应用一起导航。
- en: A mobile phone, on the other hand, can do everything the landline telephone
    can; that is, make and receive calls. But it can also do other things, such as
    allow us to send text messages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，移动电话可以做固定电话能做的所有事情；也就是说，可以拨打电话和接听电话。但它还可以做其他事情，比如允许我们发送短信。
- en: We can also view this relationship as a parent-child relationship. The smartphone
    is a child of the mobile phone, and the mobile phone is its parent. This also
    means that a child will inherit from its parent. This is how inheritance works
    in object-oriented programming.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这种关系视为一种父子关系。智能手机是移动电话的子类，而移动电话是其父类。这也意味着子类将继承其父类的特性。这就是面向对象编程中继承的工作原理。
- en: 'A class can inherit another class, and by that, get everything that is defined
    in the parent class and just add the things that make this class unique.  To see
    what this might look like, we will need two classes. We can have a `Person` class
    that is defined like the one we saw in *figure 10.10*. It might look something
    like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以继承另一个类，通过这种方式，它将继承父类中定义的所有内容，并添加使这个类独特的东西。为了看到这可能是什么样子，我们需要两个类。我们可以有一个`Person`类，就像我们在*图10.10*中看到的那样定义。它可能看起来像这样：
- en: '[PRE14]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this class, we define all the member variables as private members of the
    class, and all the getters and setters are defined as public.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们将所有成员变量定义为类的私有成员，所有获取器和设置器都定义为公共的。
- en: 'The information used here applies to all people, but we might have some people
    that we need to store additional information for. This could, for example, be
    employees. They are people, and by that, all the information we store about a
    person will apply to them as well, but we have additional data that we want to
    store about employees. This could be things such as salary and department. We
    don''t want to define them, however, as shown in the following image:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的信息适用于所有人，但我们可能需要存储一些人的额外信息。例如，可能是员工。他们是人，因此，我们存储的关于个人的所有信息也将适用于他们，但我们还想存储关于员工的额外数据。这可能包括薪资和部门。然而，我们不想像以下图像所示那样定义它们：
- en: '![Figure 10.12 – Two classes not using inheritance](img/Fig_10.12_B15554.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 未使用继承的两个类](img/Fig_10.12_B15554.jpg)'
- en: Figure 10.12 – Two classes not using inheritance
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 未使用继承的两个类
- en: 'Here, we can see that everything we have in the `Person` class is repeated
    in the `Employee` class. The only difference is that we have added `Employee`
    class will inherit from the `Person` class and, by that, they automatically get
    everything that is defined in `Person`. This will look something like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`Person`类中的所有内容都在`Employee`类中重复出现。唯一的区别是我们添加了`Employee`类将继承自`Person`类，通过这种方式，它们自动获得`Person`中定义的所有内容。这看起来可能像这样：
- en: '![Figure 10.13 – Employee inheriting from Person](img/Fig_10.13_B15554_New.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 员工从 Person 继承](img/Fig_10.13_B15554_New.jpg)'
- en: Figure 10.13 – Employee inheriting from Person
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 员工从 Person 继承
- en: Here, the `Employee` c;ass will inherit everything from `Person`. The only thing
    we will need to define in the `Employee` class is the things that make this class
    unique. Just as we usually represent classes with the rectangle with three sections,
    inheritance is visualized with a hollow, arrow-like symbol, as shown in the preceding
    image.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Employee`类将继承`Person`类中的所有内容。我们只需要在`Employee`类中定义使这个类独特的东西。正如我们通常用有三个部分的矩形来表示类一样，继承用空心箭头符号来表示，如图所示。
- en: 'When implementing this inheritance in code, we don''t need to make any changes
    to the `Person` class. So, the `Employee` class will look like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中实现这种继承时，我们不需要对`Person`类做任何修改。因此，`Employee`类将看起来像这样：
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even though we only have code for the salary and department in this class, from
    the first line we can say that we inherit the `Person` class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个类中我们只有薪资和部门这两个代码，但从第一行代码我们就可以看出我们继承了`Person`类。
- en: Exactly how object-oriented programming is implemented differs from language
    to language. Languages that support object-orientation will also sometimes have
    slightly different rules for how object-orientation is used. As always, we will
    need to learn how the language we are using has defined the object-oriented principles.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的具体实现方式因语言而异。支持面向对象的语言有时也会对面向对象的使用规则有所不同的规定。一如既往，我们需要学习我们所使用的语言是如何定义面向对象原则的。
- en: 'The following is a list of some popular languages that support object orientation,
    either entirely or as an option:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些支持面向对象（完全或作为选项）的流行语言列表：
- en: C++
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: C#
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: Java
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: JavaScript
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: Object-C
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C
- en: PHP
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Python
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Ruby
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby
- en: Scala
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala
- en: Swift
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift
- en: 'Object orientation is one of the major paradigms. It has many fans who like
    it and think it is a good way to structure code. The next paradigm we will look
    at has been around for a long time but has gained in popularity in the last few
    years: functional programming. It is now considered one of the more interesting
    paradigms by many programmers.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象是主要的编程范式之一。它拥有众多粉丝，他们喜欢它并认为这是一种很好的代码结构方式。接下来我们将探讨的下一个范式已经存在很长时间，但在过去几年中其受欢迎程度有所上升：函数式编程。现在，许多程序员认为它是一种更有趣的范式。
- en: Understanding functional programming
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: Functional programming is a paradigm that has gained popularity. It is not new;
    we can trace its roots back to Lambda calculus, which was introduced in the 1930s.
    In the 1950s, the programming language Lisp was developed and implemented this
    paradigm.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种越来越受欢迎的范式。它并不新鲜；我们可以追溯到20世纪30年代提出的Lambda演算。在20世纪50年代，编程语言Lisp被开发并实现了这种范式。
- en: As we will see, this paradigm has a very different approach to how programs
    are structured and implemented. You will need to rethink the way you look at programming
    and code structure to be able to understand the strength of this paradigm.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，这种范式在程序的结构和实现方式上有着非常不同的方法。为了理解这种范式的优势，您需要重新思考您看待编程和代码结构的方式。
- en: We will begin by looking at a definition of functional programming. The definition
    will, itself, be hard to understand, so we will also need to look at some parts
    of it to understand what this is all about.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看函数式编程的定义开始。这个定义本身可能很难理解，因此我们还需要查看其中的一些部分来理解这是关于什么的。
- en: 'One definition is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一个定义如下：
- en: '*"Functional programming is a way of structuring a computer program that treats
    computation as the evaluation of mathematical functions and avoids changing the
    state of the program and the use of mutable data."*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*"函数式编程是一种构建计算机程序的方式，它将计算视为数学函数的评估，并避免改变程序的状态和可变数据的使用。"*'
- en: Let's start by deciphering this definition. The *treats computation as the evaluation
    of mathematical functions* part might sound scary. If we look closely at this,
    we will see that this is rather straightforward. Let's look at two mathematical
    functions and see how we can use and understand them in order to understand what
    the definition of functional programming is talking about.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从解读这个定义开始。其中“将计算视为数学函数的评估”的部分可能听起来有些吓人。如果我们仔细观察，我们会发现这其实相当直接。让我们看看两个数学函数，看看我们如何使用和理解它们，以便理解函数式编程的定义在说什么。
- en: Pure functions
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'We will start simple with the following function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下简单的函数开始：
- en: '![](img/Formula_10_001.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_10_001.png)'
- en: 'Here, *x* is the input we provide to the function and *y* is the result. This
    simple function just states that whatever we pass a value to it, it will also
    be returned.  A diagram for this function looks as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x`是我们提供给函数的输入，`y`是结果。这个简单的函数只是表明，无论我们传递什么值给它，它都会返回相同的值。这个函数的示意图如下：
- en: '![Figure 10.14 – Diagram for y = x](img/Fig_10.14_B15554.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – y = x的示意图](img/Fig_10.14_B15554.jpg)'
- en: Figure 10.14 – Diagram for y = x
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – y = x的示意图
- en: Here, we can see that if **x** is **1**, **y** is also **1** and that if **x**
    is **-3**, **y** is also **-3**. What's even more essential for us to understand
    regarding what the definition talks about is the fact that the same input to **x**
    will always yield the same value as a result in **y**. If we input **5** for **x**,
    we will always get **5** for **y**.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如果`x`是`1`，则`y`也是`1`，如果`x`是`-3`，则`y`也是`-3`。关于定义所谈论的内容，我们还需要理解的一个更基本的事实是，相同的输入到`x`将始终产生相同的`y`作为结果。如果我们为`x`输入`5`，我们总是会得到`y`为`5`。
- en: 'Let''s look at another function to see if the same thing is true:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个函数，看看是否同样成立：
- en: '![](img/Formula_10_002.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_10_002.png)'
- en: 'This is a function for a straight line. The value of `2` and `3`, we will get
    the following diagram:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示直线的函数。当值为`2`和`3`时，我们将得到以下示意图：
- en: '![Figure 10.15 –  Diagram for y = mx + c when m = 2 and c = 3](img/Fig_10.15_B15554.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 当m = 2且c = 3时，y = mx + c的示意图](img/Fig_10.15_B15554.jpg)'
- en: Figure 10.15 –  Diagram for y = mx + c when m = 2 and c = 3
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 当m = 2且c = 3时，y = mx + c的示意图
- en: Again, the most important thing to learn from this is that the result, the value
    of `3` if `0`, and always be `1` if `-1`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，从这个例子中我们学到最重要的东西是结果，即当`0`时`3`的值，以及当`-1`时总是`1`。
- en: 'When talking about mathematical functions in terms of functional programming,
    it is this fact that is the crucial thing: a function with the same input will
    always return the same answer. In functional programming, this is known as a *pure
    function*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当从函数式编程的角度谈论数学函数时，这是关键的事实：具有相同输入的函数总是会返回相同的答案。在函数式编程中，这被称为*纯函数*。
- en: 'But isn''t this always true for any function? Look at the following function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但这难道不是任何函数都始终成立的吗？看看下面的函数：
- en: '[PRE16]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s call this function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称这个函数为：
- en: '[PRE17]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On calling the function, we will always get the following response:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数时，我们总是会得到以下响应：
- en: '[PRE18]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can say that this is a pure function. But what happens when we call this
    function from the `math` module?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说这是一个纯函数。但是，当我们从`math`模块调用这个函数时会发生什么呢？
- en: '[PRE19]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the output might look like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出可能看起来是这样的：
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Calling the random function with the same arguments (none in our case) will
    not give us the same answer. This is not a pure function. This is the meaning
    of evaluating mathematical functions in the preceding definition.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的参数（在我们的情况下没有参数）调用随机函数不会给出相同的答案。这不是一个纯函数。这就是在先前的定义中评估数学函数的含义。
- en: Next up is the second part of the definition, *avoids changing the state of
    the program and the use of mutable data*. Changing the state is something we recognize
    from when we talked about structured programming. There, we said that *structured
    programming uses statements to change the program's state*. It seems like functional
    programming is talking about the absolute opposite of what structured programming
    did. We said that the state the program is in is defined by the combination of
    the data stored in all its variables at any given time. Changing the value of
    one variable will change the state of the program.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是定义的第二部分，*避免改变程序状态和可变数据的使用*。改变状态是我们从结构化编程中讨论的内容时认识到的。在那里，我们说*结构化编程使用语句来改变程序的状态*。这似乎是功能编程在谈论结构化编程所做事情的绝对反面。我们说程序的状态是由在任何给定时间存储在其所有变量中的数据的组合所定义的。改变一个变量的值将改变程序的状态。
- en: 'What would it mean if a program avoids changing its state? Would we not be
    able to change any variables? The answer to this is yes, and that is what is part
    of the final part of the definition: that it also avoids the use of mutable data.
    What does mutable data mean? We''ll see what this is about in the next section.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序避免改变其状态，这意味着我们无法改变任何变量吗？对这个问题的答案是肯定的，这也是定义的最后一部分：它也避免使用可变数据。可变数据是什么意思？我们将在下一节中看到这一点。
- en: Mutable and immutable data
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变和不可变数据
- en: 'Mutable means liable to change, while immutable means unable to be changed.
    The term *mutable data* means that we have data that we can change. We know that
    we store data in variables and that we can change it as we please, as shown in
    the following code block:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 可变意味着可能改变，而不可变意味着无法改变。术语*可变数据*意味着我们可以改变的数据。我们知道我们可以在变量中存储数据，并且我们可以随意更改它，如下面的代码块所示：
- en: '[PRE21]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we first assign the value `10` to the `x` variable and then assign the
    value `20` to the `y` variable. On the last line, we change the value of `x` so
    that it's the same as `y`, which is `20`. We could say that `x` is mutable as
    we can change it. But is this proof that `x` is mutable? In some languages, it
    is, but in others, this is not true at all, even if the final value in `x` will
    always be `20`. How is it possible that `x` changes its value from `10` to `20`
    if we cannot change it? This sounds impossible.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将值`10`赋给`x`变量，然后将值`20`赋给`y`变量。在最后一行，我们改变`x`的值，使其与`y`相同，即`20`。我们可以这样说，`x`是可变的，因为我们能改变它。但这能证明`x`是可变的吗？在某些语言中是这样的，但在其他语言中，这根本不是真的，即使`x`中的最终值始终是`20`。如果我们不能改变它，`x`如何从`10`变为`20`？这听起来是不可能的。
- en: The answer is in the way a language treats its variables. If we just think of
    a variable like a box where we can store a value and, at any time, replace it
    with another value, it is changeable, but if instead we treat a variable like
    something that is pointing out a value somewhere in the computer's memory, things
    will be slightly different.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于语言处理其变量的方式。如果我们只是把变量想象成一个可以存储值并且可以在任何时候用另一个值替换它的盒子，它是可变的，但如果我们把变量想象成指向计算机内存中某个位置的值，事情就会有所不同。
- en: 'Let''s perform a little thought experiment. We can start with the two variables,
    `x` and `y`, and again assign the values `10` and `20` to them, as we did previously:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个小型的思维实验。我们可以从两个变量`x`和`y`开始，并再次将它们赋值为`10`和`20`，就像我们之前做的那样：
- en: '[PRE22]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following diagram illustrates what it may look like if `x` and `y` reference
    a memory location:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了如果`x`和`y`引用两个内存位置可能看起来像什么：
- en: '![Figure 10.16 – Two variables referencing two memory locations](img/Fig_10.16_B15554.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 两个变量引用两个内存位置](img/Fig_10.16_B15554.jpg)'
- en: Figure 10.16 – Two variables referencing two memory locations
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 两个变量引用两个内存位置
- en: As we can see, the values `10` and `20` are not stored inside the variables.
    Instead, the variables are pointing out where these values are located in memory.
    What will happen if we change the value `x` references from `10` to `20`?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，值`10`和`20`并没有存储在变量中。相反，变量是指向这些值在内存中的位置。如果我们改变`x`引用的值从`10`到`20`会发生什么？
- en: 'It will look something like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来可能像这样：
- en: '![Figure 10.17 – Two variables that reference the same memory location](img/Fig_10.17_B15554.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – 指向相同内存位置的变量](img/Fig_10.17_B15554.jpg)'
- en: Figure 10.17 – Two variables that reference the same memory location
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – 指向相同内存位置的变量
- en: 'Now, let''s consider what would happen if the value at the memory location
    can be changed if we change one of the variables if we, for example, run this
    line of code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑如果内存位置上的值可以被改变，如果我们改变其中一个变量会发生什么，例如，如果我们运行这一行代码：
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We would then have a situation similar to the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会有一个类似以下的情况：
- en: '![Figure 10.18 – Changing the value of one variable reference](img/Fig_10.18_B15554.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18 – 改变一个变量引用的值](img/Fig_10.18_B15554.jpg)'
- en: Figure 10.18 – Changing the value of one variable reference
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – 改变一个变量引用的值
- en: 'Now, let''s print the value of the `x` reference, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打印`x`引用的值，如下所示：
- en: '[PRE24]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We would get the following result:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到以下结果：
- en: '[PRE25]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Even if we never assigned `22` to `x`, it would have that value as we allowed
    `y` to change the content of the memory location of both references.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有给`x`赋值`22`，它也会具有那个值，因为我们允许`y`改变两个引用的内存位置的内容。
- en: 'If we instead make the memory location immutable, what would happen when we
    assign `22` to `y`? We would get something like the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改为使内存位置不可变，当我们给`y`赋值`22`时会发生什么？我们会得到如下所示的结果：
- en: '![Figure 10.19 – Assigning a new value to an immutable variable](img/Fig_10.19_B15554.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图10.19 – 给不可变变量赋新值](img/Fig_10.19_B15554.jpg)'
- en: Figure 10.19 – Assigning a new value to an immutable variable
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 – 给不可变变量赋新值
- en: As we can see, the value did not change at all. Instead, `y` is now referencing
    a new memory location. If `y` was redeclared, we would get a new fresh variable
    with the same name as the old `y` variable.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，值根本没有任何变化。相反，`y`现在引用了一个新的内存位置。如果重新声明`y`，我们会得到一个与旧`y`变量同名的新鲜变量。
- en: This is how immutability works. The variables are not changed. Instead, a new
    value is created in another location in memory. As we cannot change any variables,
    we can't change the state of the program either.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是不可变性的工作方式。变量不会被改变。相反，在内存的另一个位置创建了一个新值。由于我们不能改变任何变量，因此我们也不能改变程序的状态。
- en: But why is it important that our variables are immutable and that we can't change
    the state of the program? The answer is called side effects.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们的变量是不可变的，而且我们无法改变程序的状态这么重要呢？答案就是副作用。
- en: Avoiding side effects
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免副作用
- en: 'A side effect in computer programming is when an expression modifies some values
    in the variables that are outside its local environment. To understand this, let''s
    look at an example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机编程中的副作用是指表达式修改了其局部环境之外的变量中的某些值。为了理解这一点，让我们看一个例子：
- en: '[PRE26]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First, this program is very naïve, but it illustrates the point we need to
    make. Here, we have a variable, `x`, and a function called `some_func`. The variable
    is declared outside of the function but is modified inside it. We can now use
    the following expression:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个程序非常简单，但它说明了我们需要说明的观点。在这里，我们有一个变量`x`和一个名为`some_func`的函数。变量在函数外部声明，但在函数内部被修改。我们现在可以使用以下表达式：
- en: '[PRE27]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is modifying a value outside its environment, and the body of the function
    is the environment that expression lives in.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在修改其环境之外的价值，函数体是表达式存在的环境。
- en: This is true if the language we are using has defined `x` as mutable so that
    we can change it. But in a language where `x` is immutable, there would be no
    change. Instead, we would get a new `x` variable that only exists inside of the
    function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这在如果我们使用的语言已经将`x`定义为可变，以便我们可以改变它是正确的。但在一个`x`不可变的语言中，将不会有任何变化。相反，我们会得到一个新的`x`变量，它只存在于函数内部。
- en: 'What would the disadvantage be if we did this in a language where `x` was mutable?
    To see this, we can call the function twice and print its result, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个`x`是可变性的语言中这样做，会有什么缺点呢？为了看到这一点，我们可以调用函数两次并打印其结果，如下所示：
- en: '[PRE28]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output will look as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE29]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is not a good behavior as calling the function with the same arguments
    should always return the same value. Here, it does not, and the reason this happens
    is because the program has side effects. This is because the result the function
    returns is dependent on what happened in previous calls to the function.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个好的行为，因为用相同的参数调用函数应该始终返回相同的值。在这里，它没有，而且这种情况发生的原因是程序有副作用。这是因为函数返回的结果取决于函数之前的调用发生了什么。
- en: If we have a program that has no side effects, it will be very predictable what
    will happen when the program runs. If we think about the previous small program,
    we saw that it will be almost impossible for us to predict what a call to the
    function will result in as the result will depend on previous calls, as well as
    what data we provided as arguments in these calls.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个没有副作用（side effects）的程序，那么程序运行时会发生什么将会非常可预测。如果我们思考之前的小程序，我们会看到要预测函数调用的结果几乎是不可能的，因为结果将取决于之前的调用，以及在这些调用中我们提供的参数数据。
- en: The next principle of functional programming is called declarative programming.
    Let's see what it's all about.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的下一个原则被称为声明式编程。让我们看看它到底是什么。
- en: Declarative programming
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式编程
- en: To understand what declarative programming is, we can compare it to something
    we know, and that is imperative programming. In imperative programming, we focus
    on describing how something will be done. In declarative programming, on the other
    hand, the focus is on what we want to achieve.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解命令式编程是什么，我们可以将其与我们已知的事物进行比较，那就是命令式编程。在命令式编程中，我们专注于描述如何完成某事。而在命令式编程中，另一方面，我们的焦点在于我们想要实现的目标。
- en: To understand this, we will look at some real-world examples. If you go to a
    restaurant, you can either be an imperative or declarative guest.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，我们将查看一些现实世界的例子。如果你去餐厅，你可以要么是一个命令式客人，要么是一个声明式客人。
- en: 'The imperative guest would make an order like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式客人会下这样的订单：
- en: '*"I would like the cod, please. First, bake it in the oven for 10 to 12 minutes.
    In the end, check it regularly so it won''t overcook. While the cod is in the
    oven, please boil the potatoes. To prepare the cream sauce, first, melt some butter
    in a medium-sized pan over medium heat. Slowly add corn starch and stir for about
    a minute. While constantly whisking, slowly add whipping cream and milk. Finally,
    add some parmesan cheese. Let the sauce reduce on a low heat while you whisk occasionally."*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: “请给我一份鳕鱼。首先，在烤箱里烤10到12分钟。最后，要经常检查，以免烤焦。当鳕鱼在烤箱里时，请煮土豆。为了准备奶油酱，首先，在中号平底锅中用中火融化一些黄油。慢慢加入玉米淀粉，搅拌大约一分钟。在不断地搅拌的同时，慢慢加入打发奶油和牛奶。最后，加入一些帕尔玛干酪。在小火上慢慢煮酱汁，偶尔搅拌。”
- en: 'If, on the other hand, you are a declarative restaurant guest, you would say
    something like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是命令式餐厅客人，你可能会这样说：
- en: '*"I would like the cod, please."*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: “请给我一份鳕鱼。”
- en: The first guest answers the question of how, while the second one focuses on
    what.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第一位客人回答了如何做的问题，而第二位客人则关注了是什么。
- en: 'An excellent example of something declarative in computer science is **SQL**.
    It is an abbreviation of **Structured Query Language** and is used to store and
    retrieve data from databases. If we want to get the first and last name of all
    the customers stored in the customer''s table, we could write the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中一个优秀的声明式例子是**SQL**。它是**结构化查询语言**的缩写，用于存储和检索数据库中的数据。如果我们想获取存储在客户表中的所有客户的姓名和姓氏，我们可以编写以下代码：
- en: '[PRE30]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is declarative as we say what we want – the first and last names of the
    customers – but we say nothing about how the data will be retrieved. Somewhere
    in the underlying database system, some parts must know how this will be done,
    but if we are using SQL, we don't need to understand how this is done.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种声明式，因为我们说了我们想要什么——客户的姓名和姓氏——但我们没有说关于如何检索数据的事情。在底层数据库系统中，某些部分必须知道如何完成这件事，但如果我们使用SQL，我们不需要了解它是如何完成的。
- en: Python is a programming language where we can write both imperative and declarative
    programs. Let's look at two programs that perform the same thing, one in an imperative
    way and one in a declarative way.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种编程语言，我们可以在其中编写命令式和声明式程序。让我们看看两个执行相同任务的程序，一个是以命令式方式，另一个是以声明式方式。
- en: 'First is a short program that has been written in an imperative style:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是一个用命令式风格编写的简短程序：
- en: '[PRE31]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'From the preceding code, we can observe the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以观察到以下情况：
- en: On the first line, we define a list of strings. Each string contains a two-digit
    number. Values below 10 will be prefixed with a 0.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，我们定义了一个字符串列表。每个字符串包含一个两位数。小于10的值将用0作为前缀。
- en: On the second line, we declare an empty list. We will convert the numbers in
    the first list from strings into integer values and store them in this array.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二行，我们声明了一个空列表。我们将把第一个列表中的数字从字符串转换为整数值，并存储在这个数组中。
- en: We will then enter a `for` loop. In each iteration of this loop, a value from
    the first list will be assigned to the `value` variable. The first time it will
    be `06`, the second time it will be `68`, and so on.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将进入一个 `for` 循环。在这个循环的每次迭代中，第一个列表中的一个值将被分配给 `value` 变量。第一次将是 `06`，第二次将是
    `68`，依此类推。
- en: We then have an `if` statement. It will convert the value into an integer and
    compare it to zero. If that is false – that is, it is anything but zero – we will
    enter the `if` block.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有一个 `if` 语句。它将值转换为整数并与零进行比较。如果这是假的——也就是说，它不是零——我们将进入 `if` 块。
- en: Inside this block, we will append the value we converted into an integer to
    the list numbers.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个块内部，我们将把我们将值转换为整数后添加到 `numbers` 列表中。
- en: 'When we have gone through all the values in the first list, we print the contents
    of the second list and get the following output:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们遍历完第一个列表中的所有值后，我们打印第二个列表的内容，得到以下输出：
- en: '[PRE32]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the zero prefixes we had for the first value are now gone as
    these are integers, and 06 is just 6\. Also, the value that had a double zero
    is not in the list at all as it made the `if` statement false, and the line where
    we appended the value was skipped in that iteration.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们为第一个值保留的零前缀现在没有了，因为这些是整数，06 就是 6。另外，那个有双重零的值根本不在列表中，因为它使 `if` 语句为假，并且在这个迭代中跳过了添加值的行。
- en: 'The second version of this program is written in a declarative style and looks
    as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的第二个版本是用声明式风格编写的，看起来如下所示：
- en: '[PRE33]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This program does the same thing as the previous one, but the way it is written
    is very different. It uses something called a *list comprehension*. It is the
    part after `numbers =`. If you look closely, you can see a `for` loop in the middle
    of this expression. It looks just like the `for` loop in the other example. Following
    this loop, we can see an `if`, and it looks just like the `if` statement in the
    first program. An `if` at this location in a comprehension serves as a filter.
    If this is evaluated as true, the current value will be passed to the front of
    this expression. Here, we convert the value into an integer. This converted value
    will be part of a list called `numbers`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与上一个程序做的是同样的事情，但它的编写方式非常不同。它使用了一种叫做 *列表推导* 的东西。这是 `numbers =` 后面的部分。如果你仔细看，你可以在这个表达式的中间看到一个
    `for` 循环。它看起来就像其他示例中的 `for` 循环。在这个循环之后，我们可以看到一个 `if` 语句，它看起来就像第一个程序中的 `if` 语句。在这个推导中的这个位置的
    `if` 语句充当一个过滤器。如果这个表达式评估为真，当前值将被传递到这个表达式的开头。在这里，我们将值转换为整数。这个转换后的值将成为一个名为 `numbers`
    的列表的一部分。
- en: This is declarative because we don't say how this value will get into the new
    list, we just say what will go into the list.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种声明式，因为我们没有说明这个值是如何进入新列表的，我们只是说什么会进入列表。
- en: The final principle used by functional programming that we will cover is called
    first-class functions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的函数式编程的最后一个原则被称为一等函数。
- en: First-class functions
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一等函数
- en: Functional programming uses the principle of first-class functions. A function
    is said to be first-class if it is treated as a first-class citizen of the programming
    language in question. A first-class citizen is something that we can modify, pass
    as an argument to a function, return from a function, and so on.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程使用一等函数的原则。如果一个函数被当作编程语言中的一等公民来对待，那么它就被说成是一等函数。一等公民是可以被修改的、可以作为函数参数传递、可以从函数返回等。
- en: 'In a programming language that supports first-class functions, we can do things
    such as the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持一等函数的编程语言中，我们可以做如下事情：
- en: '[PRE34]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This program declares two functions, `formal_greeter` and `informal_greeter`.
    Both accept a `name` as its argument and will return a greeting with the name
    appended.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序声明了两个函数，`formal_greeter` 和 `informal_greeter`。两者都接受一个 `name` 作为参数，并将返回带有名称的问候语。
- en: We then have a function called `greeter`. This function accepts a reference
    to a function as its first argument and a name as its second. The two last lines
    in the program are calling the `greeter` function. The first one is passing a
    reference to the formal greeter function, while the second is passing one to the
    informal greeter.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `greeter` 的函数。这个函数接受一个函数引用作为其第一个参数和一个名称作为其第二个参数。程序中的最后两行是调用 `greeter`
    函数。第一行传递的是正式的 `greeter` 函数的引用，而第二行传递的是非正式的 `greeter` 函数的引用。
- en: 'The `greeter` function will use the function passed to it, so the two calls
    will result in the following output:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeter` 函数将使用传递给它的函数，因此这两个调用将产生以下输出：'
- en: '[PRE35]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Being able to work with functions like this has several benefits. Let's look
    at an example. Earlier in this chapter, we talked about object-oriented programming,
    and we defined a class called `Person`. We saw that we could create several objects
    from this class, each one representing one person.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用这样的函数有几个好处。让我们看看一个例子。在本章的早期，我们讨论了面向对象编程，并定义了一个名为 `Person` 的类。我们看到我们可以从这个类创建几个对象，每个对象代表一个人。
- en: Later in this chapter, we will see that programming languages can use more than
    one paradigm, and if we use one that lets us define classes and use functions
    as first-class citizens, we can do something very useful.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将看到编程语言可以使用多种范式，如果我们使用一种允许我们定义类并将函数作为一等公民使用的范式，我们可以做一些非常有用的事情。
- en: 'If we create a couple of person objects with `name` and `age` and insert them
    into a list structure, this might look something like the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一些具有 `name` 和 `age` 的 `Person` 对象并将它们插入到列表结构中，这可能会看起来像以下这样：
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We now have four person objects stored in a list called `persons`. If we want
    to sort the list, we can use a sorting function provided by the language. But
    there is a problem. The sorting function will not know what we want to sort on;
    that is, `name` or `age`. It does not even know anything about `Person` objects
    as they are defined by a class that we have written. What it knows is how to sort
    a list, but it needs the help of a function that can receive two objects from
    the `Person` class, and which returns `true` if the first object is larger than
    the second and `false` if it is not. We will need to write that function and,
    in it, define what makes one object larger than the other one. We can decide if
    it should be `name` or `age`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个名为 `persons` 的列表中存储了四个 `Person` 对象。如果我们想对这个列表进行排序，我们可以使用语言提供的排序函数。但是有一个问题。排序函数不知道我们想要根据什么来排序；也就是说，是
    `name` 还是 `age`。它甚至不知道 `Person` 对象，因为它们是由我们编写的类定义的。它所知道的是如何排序一个列表，但它需要函数的帮助，这个函数可以从
    `Person` 类接收两个对象，并在第一个对象大于第二个对象时返回 `true`，否则返回 `false`。我们需要编写这个函数，并在其中定义什么使得一个对象比另一个对象大。我们可以决定是按
    `name` 还是 `age` 来排序。
- en: 'If we want to sort the objects by their `age`, we could do the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要按 `age` 排序对象，我们可以这样做：
- en: '[PRE37]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we have a function called `compare`. It will accept two `person` objects
    as its arguments. If the age of the first person is greater than the age of the
    second person, this function will return `true`. Otherwise, it returns `false`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个名为 `compare` 的函数。它将接受两个 `person` 对象作为其参数。如果第一个人的年龄大于第二个人的年龄，这个函数将返回
    `true`。否则，它返回 `false`。
- en: The `sort` function accepts as its first argument a reference to this function.
    When it is performing the sort, it will need to compare two different objects
    to determine in what order it should place them in the sorted list.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 函数将其第一个参数作为对这个函数的引用。在执行排序时，它需要比较两个不同的对象以确定它们在排序列表中的顺序。'
- en: In our example, it will first pass `Dipika`, who is `34`, and `Manfred`, who
    is `58`, to the function. The `compare` function will return `false` since the
    age of `Manfred` is greater than the age of `Dipika`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，它首先将 `Dipika`（34岁）和 `Manfred`（58岁）传递给函数。由于 `Manfred` 的年龄大于 `Dipika`
    的年龄，`compare` 函数将返回 `false`。
- en: The `sort` function will now take the winner from the last round, `Manfred`,
    and pass this object along with Ahmed's object. This time, `Manfred` will be passed
    first, so he will be the `person1` object in the function, while `Ahmed` will
    be `person2`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`sort` 函数将取上轮比赛的胜者 `Manfred`，并将这个对象与 Ahmed 的对象一起传递。这次，`Manfred` 将首先传递，因此他将是函数中的
    `person1` 对象，而 Ahmed 将是 `person2`。
- en: This time, the first object has an age that is greater than the second one,
    so the function returns `true`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，第一个对象的年龄大于第二个对象，因此函数返回 `true`。
- en: This is how the `sort` function can use a function that we provide to fulfill
    its task to sort the list. If we want to sort on the names instead, we will only
    need to change the `compare` function so that it compares the names instead of
    the ages.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `sort` 函数如何使用我们提供的函数来完成其排序列表的任务。如果我们想按名称排序，我们只需要更改 `compare` 函数，使其比较名称而不是年龄。
- en: 'If we print the `sorted_persons` list, which contains the sorted list, we will
    get this result if we sort on age:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印包含排序列表的 `sorted_persons` 列表，如果我们按年龄排序，我们会得到以下结果：
- en: '[PRE38]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If, instead, we sort on the names, we will get the following result:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按名称排序，我们会得到以下结果：
- en: '[PRE39]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First-class functions are a compelling feature that let us write functions that
    are more general-purpose as we can pass another function that will do parts of
    its job, just as the sort function works.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 首类函数是一个令人信服的特性，它让我们能够编写更通用的函数，因为我们可以传递另一个函数来完成其部分工作，就像排序函数那样工作。
- en: Functional programming has several concepts that are both powerful and let us
    write higher quality code. That is the reason why functional programming is constantly
    gaining popularity and why many non-functional programming languages are borrowing
    functional concepts.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程有几个既强大又让我们能够编写更高品质代码的概念。这就是为什么函数式编程一直在不断获得人气，以及为什么许多非函数式编程语言正在借用函数式概念的原因。
- en: 'The following is a list of some popular languages that support functional programming,
    either as its primary paradigm or are using many concepts from functional programming:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些支持函数式编程的流行语言的列表，这些语言要么将其作为主要范式，要么使用了函数式编程的许多概念：
- en: C++ (since C++ 11)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++（自C++ 11版本起）
- en: C#
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: Clojure
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure
- en: Common Lisp
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Common Lisp
- en: Erlang
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 艾拉朗
- en: F#
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#
- en: Haskell
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell
- en: JavaScript
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: Python
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Ruby
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby
- en: Functional programming is not only a very interesting paradigm, but it is also
    influencing many established languages to incorporate functional concepts. The
    next paradigm is not as widely used as the ones we have looked at so far, but
    it has some interesting concepts.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程不仅是一个非常有趣的范式，而且它还在影响许多已建立的语言，使它们能够吸收函数式概念。下一个范式不像我们之前看到的那些范式那样广泛使用，但它有一些有趣的概念。
- en: Understanding logic programming
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解逻辑编程
- en: This paradigm is based on formal logic. A program written in a language that
    implements this paradigm is constructed of a set of sentences in a logical form
    that will express facts and rules about a specific problem domain.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这种范式基于形式逻辑。用实现这种范式的语言编写的程序由一组逻辑形式的句子组成，这些句子将表达特定问题域的事实和规则。
- en: 'This might sound complicated and strange, but as we will see, the basic concepts
    of this paradigm are rather simple. Consider the following diagram:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂和奇怪，但正如我们将看到的，这个范式的核心概念相当简单。考虑以下图示：
- en: '![](img/Fig_10.20_B15554.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Fig_10.20_B15554.jpg)'
- en: Figure 10.20 – A family tree
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 – 一个家谱
- en: 'In the preceding diagram, we can see a family tree. Looking at it, we can see
    the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个家谱。看着它，我们可以看到以下内容：
- en: Anna and Bob have a child, Lisa.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安娜和鲍勃有一个孩子，莉萨。
- en: Lisa and Fred have a child, Karen.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 莉萨和弗雷德有一个孩子，卡伦。
- en: Fred and Sue have a child, John.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弗雷德和苏有一个孩子，约翰。
- en: Karen's grandparents are Anna and Bob.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡伦的祖父母是安娜和鲍勃。
- en: 'In a programming language that uses logic programming, we can define this family
    tree using something called *predicates*. This will look something like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用逻辑编程的编程语言中，我们可以使用称为*谓词*的东西来定义这个家谱。这看起来可能像这样：
- en: '[PRE40]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: They might seem to come in an odd order, but most logic languages want us to
    group all predicates of the same kind together so, in this case, we first define
    all the mothers and, after that, all the fathers.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可能看起来顺序有些奇怪，但大多数逻辑语言都希望我们将同一类的所有谓词放在一起，所以在这种情况下，我们首先定义所有的母亲，然后是所有的父亲。
- en: On the first line, we can see that `Anna` is the mother of Lisa, while on the
    fourth line, we can see that `Bob` is the father of `Lisa`. The names are called
    *atoms* because they represent a single value, and atoms need to be defined by
    lowercase letters only.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们可以看到`Anna`是莉萨的母亲，而在第四行，我们可以看到`Bob`是莉萨的父亲。这些名字被称为*原子*，因为它们代表一个单一值，并且原子只能用小写字母定义。
- en: 'We can now define some rules that dictate what makes someone a parent and grandparent.
    It might look like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义一些规则，这些规则规定了什么使某人成为父母和祖父母。它可能看起来像这样：
- en: '[PRE41]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `X`, `Y`, and `Z` are variables. Variables are defined with an initial
    capital letter. We can read this as
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`X`、`Y`和`Z`是变量。变量用首字母大写来定义。我们可以这样读
- en: '*For any X, Y, Z,*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于任何`X`、`Y`、`Z`，*'
- en: If X is a parent of Y, and Y is a parent of Z
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`X`是`Y`的父母，且`Y`是`Z`的父母
- en: Then X is the grandparent of Z
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`X`是`Z`的祖父母
- en: The two last rows define what a parent is. It is either if `X` is the father
    of `Y` or if `X` is the mother of `Y`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行定义了什么是父母。要么是`X`是`Y`的父亲，要么是`X`是`Y`的母亲。
- en: 'We can now use this to ask questions like this:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个来提出如下问题：
- en: '[PRE42]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This question will produce the following answer:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题将产生以下答案：
- en: '[PRE43]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is true as `Anna` is the grandmother of `Karen`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这对`Anna`是`Karen`的外祖母来说是正确的。
- en: 'We can also ask who Karen''s grandparents are, as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以询问卡伦的祖父母是谁，如下所示：
- en: '[PRE44]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, `Q` is a variable, and we will get the following response:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Q`是一个变量，我们将得到以下响应：
- en: '[PRE45]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We could also ask who the grandchild of Anna is:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以问Anna的孙子是谁：
- en: '[PRE46]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will tell us that it is `Karen`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉我们它是`Karen`：
- en: '[PRE47]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There are, of course, more things that you can do in a logic programming language,
    but this was a little taste of what logic programming can look like.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在逻辑编程语言中你可以做更多的事情，但这只是逻辑编程可能看起来的一部分。
- en: 'The following is a list of some languages that support logic programming:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些支持逻辑编程的语言列表：
- en: ALF
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ALF
- en: Curry
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Curry
- en: Fril
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fril
- en: Janus
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Janus
- en: Prolog
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prolog
- en: The way we structure the code in logic programming is very different from all
    other paradigms, making it an interesting *outsider*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑编程中，我们结构代码的方式与其他所有范式非常不同，使其成为一个有趣的*局外人*。
- en: We have now looked at the leading players in the paradigm field. But before
    we leave these paradigms behind, let's just mention a few more to get a more complete
    picture.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了范式领域的领先者。但在我们离开这些范式之前，让我们简单提一下更多的一些，以获得更完整的图景。
- en: Other paradigms
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他范式
- en: The paradigms we have covered so far in this chapter are the most commonly used,
    but there are several others. Let's have a quick look at some of them.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论的范式是目前最常用的，但还有几个其他的。让我们快速看一下其中的一些。
- en: Function-level
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数级
- en: In function-level programming, we have no variables at all. Instead, programs
    are built from elementary functions, combined with function-to-function operations,
    sometimes referred to as *functionals* or *functional forms*.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数级编程中，我们根本没有任何变量。相反，程序是由基本函数构建的，结合函数到函数的操作，有时被称为*泛函*或*函数形式*。
- en: 'Languages that implement this paradigm are built around the following hierarchy:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种范式的语言是围绕以下层次结构构建的：
- en: Atoms are the data that the functions operate on. They will only appear as input
    or output to the programs and will never be found inside the actual program.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子是函数操作的数据。它们只会作为程序的输入或输出出现，永远不会在程序的实际内部找到。
- en: Functions will convert atoms into other atoms. The programming language will
    define a set of functions, and the programmer can create new ones using functional
    forms. The program itself is also a function.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数将原子转换为其他原子。编程语言将定义一组函数，程序员可以使用函数形式创建新的函数。程序本身也是一个函数。
- en: Functional forms are used to convert functions into other functions. They can
    be used by the programmer to create new forms.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数形式被用来将函数转换为其他函数。程序员可以使用它们来创建新的形式。
- en: Array programming
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组编程
- en: In array programming, operations will be performed on an entire set of values
    at once. These solutions are commonly used for scientific and engineering applications.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组编程中，操作将同时对整个值集进行。这些解决方案通常用于科学和工程应用。
- en: Operations are generalized to apply to both scalars and arrays. In this book,
    we have encountered scalars in the form of variables that can only hold one single
    value at a time. We have also looked at arrays. If you need a refresh your memory
    on variables and arrays, you can read more about them in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 操作被推广到可以应用于标量和数组。在这本书中，我们已经遇到了以变量的形式出现的标量，它们一次只能持有单个值。我们也已经看过数组。如果你需要刷新关于变量和数组的记忆，你可以在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)
    *处理数据 – 变量*中了解更多。
- en: The *a + b* operation will act differently if *a* and *b* are scalars and if
    they are arrays. If they are scalars, the result will be the sum of adding the
    two values. If they are arrays, the result will be the sum of all values stored
    in the two arrays.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当*a*和*b*是标量或数组时，*a + b*操作将会有不同的行为。如果它们是标量，结果将是两个值的和。如果它们是数组，结果将是两个数组中存储的所有值的总和。
- en: Array programming can simplify programming at the cost of efficiency. This means
    that it can be easier to use these kinds of languages when we write the code but
    running them might take a longer time than if the program is written in a language
    that uses another paradigm.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 数组编程可以在牺牲效率的情况下简化编程。这意味着当我们编写代码时，使用这些语言可能更容易，但运行它们可能比用使用其他范式的语言编写的程序花费更长的时间。
- en: Quantum programming
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子编程
- en: This is the paradigm of the future. To be able to use this paradigm, we will
    need quantum computers. A quantum computer uses the quantum-mechanical properties
    particles defined in quantum physics. These particles have a superposition, meaning
    that before we observe them, they will be in any possible position. A quantum
    computer will use this by defining something known as a *qubit*. A normal computer
    has bits that can either be 0 or 1\. A qubit will be both, and using this property,
    a quantum computer will be able to calculate all possible results of any given
    input in a fraction of the time it takes to perform the same calculations with
    the kind of computers we are using today.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们未来的范式。要能够使用这个范式，我们需要量子计算机。量子计算机利用量子物理学中定义的粒子量子力学特性。这些粒子具有叠加性，这意味着在我们观察它们之前，它们将处于任何可能的位置。量子计算机将通过定义一种称为*量子比特*的东西来利用这一点。普通计算机的比特可以是0或1。量子比特将同时是这两种状态，利用这一特性，量子计算机将能够在极短的时间内计算出任何给定输入的所有可能结果，这比我们今天使用的计算机进行相同计算的时间要短得多。
- en: 'Quantum programming is not a paradigm per se, but to be able to write programs
    for quantum computers, we will need languages that will support other kinds of
    operations than the ones we are using today:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 量子编程本身不是一个范式，但为了能够为量子计算机编写程序，我们需要支持比我们今天使用的操作更多的语言：
- en: '![Figure 10.21 – Part of a quantum computer built at IBM Research in Zurich.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.21 – 瑞士苏黎世IBM研究实验室建造的量子计算机的一部分。'
- en: Photo by IBM Zurich Lab, cc-by-2.0.](img/Fig_10.21_B15554.jpg)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由IBM苏黎世实验室提供，cc-by-2.0。（img/Fig_10.21_B15554.jpg）
- en: Figure 10.21 – Part of a quantum computer built at IBM Research in Zurich. Photo
    by IBM Zurich Lab, cc-by-2.0.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21 – 瑞士苏黎世IBM研究实验室建造的量子计算机的一部分。照片由IBM苏黎世实验室提供，cc-by-2.0。
- en: Even though we are just seeing the first quantum computers slowly take form,
    several languages that we can use for them are already defined. They are built
    upon already existing paradigms, such as imperative and functional programming.
    When we have fully functional and accessible quantum computers, we will see an
    explosion of new languages that will utilize the powers of these computers.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只是看到量子计算机的第一批缓慢成形，但我们已经定义了可以用于它们的几种语言。它们建立在现有的范式之上，如命令式编程和函数式编程。当我们拥有完全功能化和可访问的量子计算机时，我们将看到利用这些计算机力量的新语言的爆炸式增长。
- en: Multi-paradigm languages
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多范式语言
- en: 'Most programming languages will not stick to just one paradigm but instead
    use several. This is why they are called *multi-paradigm languages*. We can make
    a table of some of the most popular languages to see what paradigms they support:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言不会仅仅坚持一种范式，而是使用多种。这就是为什么它们被称为*多范式语言*。我们可以制作一张表格，列出一些最受欢迎的语言以及它们支持哪些范式：
- en: '![Table 10.1](img/B15554_Table_10.1.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![表10.1](img/B15554_Table_10.1.jpg)'
- en: Table 10.1
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1
- en: It can always be argued how much a paradigm influences a programming language.
    Here, I have looked at the main paradigms we have looked at in this chapter and
    how the documentation of the languages describes themselves.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 总是可以说一个范式对编程语言的影响有多大。在这里，我研究了本章中我们探讨的主要范式以及语言的文档如何描述自己。
- en: A language that is marked with *Some* has implemented some concepts of this
    paradigm. A language that has a *Yes* in the column for a paradigm might not have
    this paradigm as its main one but has implemented many of its features.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为*Some*的语言已实现该范式的某些概念。在某一范式的列中有*Yes*的语言可能不是该范式的主体，但已实现了许多其特性。
- en: Summary
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at some of the most popular programming paradigms.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了最流行的编程范式。
- en: The first two that we looked at, structured and object-oriented programming,
    are the two paradigms that have dominated programming over the last 35-40 years.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探讨的前两种，结构化编程和面向对象编程，是过去35-40年主导编程的两种范式。
- en: In structured programming, the program state is modified using statements, and
    the flow of the program is controlled using loops and selections, such as if statements.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构化编程中，程序状态是通过语句修改的，程序流程是通过循环和选择（如if语句）控制的。
- en: Object-oriented programming builds upon the ideas of structured programming,
    but the code is organized using concepts known to us humans, such as classifying
    things that have similar data and behavior. This is described in classes that
    act as blueprints for objects that represent real-world things, such as people
    or bank accounts.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程建立在结构化编程的思想之上，但代码的组织是使用我们人类所熟知的概念，例如将具有相似数据和行为的对象进行分类。这通过类来实现，类作为代表现实世界中事物（如人或银行账户）的对象的蓝图。
- en: Functional programming is the oldest of the paradigms we covered in this book
    but has gained popularity in the last decade. In functional programming, we don't
    want to modify the state of the program and are using the concept of pure functions
    to achieve this. Writing programs using this paradigm can reduce errors in the
    code and make our applications more stable.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是我们在本书中介绍的最古老的范式，但在过去十年中却获得了流行。在函数式编程中，我们不希望修改程序的状态，并使用纯函数的概念来实现这一点。使用这种范式编写程序可以减少代码中的错误，并使我们的应用程序更加稳定。
- en: In logical programming, we define predicates that will define rules that we
    can use to answer logical questions. Compared to the other three paradigms, local
    programming is far less popular.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑编程中，我们定义谓词，这些谓词将定义规则，我们可以使用这些规则来回答逻辑问题。与其他三种范式相比，局部编程的流行度要低得多。
- en: There are many other paradigms available, and they are often rather specialized
    or used by a few obscure languages.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他范式可供选择，它们通常相当专业化或被一些鲜为人知的语言所使用。
- en: Most programming languages are multi-paradigm in that they use concepts from
    more than one paradigm.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都是多范式的，即它们使用来自多个范式的概念。
- en: In the next chapter, we will see that our work, as programmers, is not done
    when the code is written.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到，作为程序员，我们的工作并不在编写代码时就结束了。
