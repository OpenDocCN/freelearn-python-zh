- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Generators and Coroutines – Infinity, One Step at a Time
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器和协程 – 一次一步，无限可能
- en: Generator functions are functions that behave like iterators by generating the
    return values one by one. While traditional methods build and return a `list` or
    `tuple` of items with a fixed length, a generator will `yield` a single value
    only when requested by the caller. The side effect is that these generators can
    be infinitely large because you can keep yielding forever.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数是一种通过逐个生成返回值来表现得像迭代器的函数。当传统方法构建并返回一个具有固定长度的`list`或`tuple`时，生成器只有在被调用者请求时才会`yield`单个值。副作用是，这些生成器可以无限大，因为你可以永远地持续生成。
- en: In addition to generators, there is a variation to the generator’s syntax that
    creates coroutines. Coroutines are functions that allow multitasking without requiring
    multiple threads or processes. Whereas generators can only yield values to the
    caller based on the initial arguments, coroutines enable two-way communication
    with the calling function while running. The modern implementation of coroutines
    in Python is through the `asyncio` module, which is covered extensively in *Chapter
    13,* *asyncio – Multithreading without Threads*, but the basics stem from the
    coroutines discussed in this chapter. If coroutines or `asyncio` work for your
    case, they can offer a tremendous performance improvement.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成器之外，还有对生成器语法的变体，它创建协程。协程是允许在不要求多个线程或进程的情况下进行多任务的函数。与生成器只能根据初始参数向调用者`yield`值不同，协程在运行时允许与调用函数进行双向通信。Python中协程的现代实现是通过`asyncio`模块，这在第13章“*asyncio
    – 无线程的多线程*”中有详细说明，但其基础源于本章讨论的协程。如果协程或`asyncio`适用于你的情况，它们可以提供巨大的性能提升。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Advantages and disadvantages of generators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器的优缺点
- en: The characteristics and quirks of generators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器的特性和怪癖
- en: Creating generators using regular functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常规函数创建生成器
- en: Generator comprehensions similar to `list`, `dict`, and `set` comprehensions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于`list`、`dict`和`set`的生成器推导式
- en: Creating generators using classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类创建生成器
- en: Generators bundled with Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python附带生成器
- en: A basic implementation of coroutines and a few of their quirks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程的基本实现及其一些怪癖
- en: Generators
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: Generators are a very useful tool but they come with a set of rules to keep
    in mind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一个非常有用的工具，但它们附带一些需要记住的规则。
- en: 'First, let’s explore the advantages of generators:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来探索生成器的优势：
- en: Generators are often simpler to write than list-generating functions. Instead
    of having to declare a `list`, `list.append(value)`, and `return`, you only need
    `yield value`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器通常比生成列表的函数更容易编写。你不需要声明`list`、使用`list.append(value)`和`return`，你只需要`yield value`。
- en: Memory usage. Items can be processed one at a time, so there is generally no
    need to keep the entire list in memory.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用。项目可以一次处理一个，因此通常不需要在内存中保留整个列表。
- en: Results can depend on outside factors. Instead of having a static list, you
    generate the value when it is being requested. Think of processing a queue/stack,
    for example.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果可能依赖于外部因素。而不是有一个静态的列表，你将在请求时生成值。例如，考虑处理队列/栈。
- en: Generators are lazy. This means that if you’re using only the first five results
    of a generator, the rest won’t even be calculated. Additionally, between fetching
    the items, the generator is completely frozen.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器是惰性的。这意味着如果你只使用生成器的前五个结果，其余的结果甚至不会被计算。此外，在获取项目之间，生成器是完全冻结的。
- en: 'The most important disadvantages are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的缺点是：
- en: Results are available only once. After processing the results of a generator,
    it cannot be used again.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果只能使用一次。在处理生成器的结果后，它不能再被使用。
- en: The size is unknown. Until you are done processing, you cannot get any information
    about the size of the generator. It might even be infinite. This makes `list(some_infinite_generator)`
    a dangerous operation. It can quickly crash your Python interpreter or even your
    entire system.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小未知。在你完成处理之前，你无法获取生成器的大小信息。它甚至可能是无限的。这使得`list(some_infinite_generator)`成为一个危险的操作。它可能会迅速崩溃你的Python解释器，甚至整个系统。
- en: Slicing is not possible, so `some_generator[10:20]` will not work. You can work
    around this using `itertools.islice` as you will see later in this chapter, but
    that effectively discards the unused indices.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法进行切片操作，所以`some_generator[10:20]`将不会工作。你可以使用`itertools.islice`来解决这个问题，就像你将在本章后面看到的那样，但这实际上会丢弃未使用的索引。
- en: 'Indexing generators, similar to slicing, is also not possible. This means that
    the following will not work: `some_generator[5]`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与切片类似，索引生成器也是不可能的。这意味着以下操作将不起作用：`some_generator[5]`。
- en: Now that you know what to expect, let’s create a few generators.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了可以期待什么，让我们创建一些生成器。
- en: Creating generators
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建生成器
- en: The simplest generator is a function containing a `yield` statement instead
    of a `return` statement. The key difference with regular functions containing
    a `return` is that you can have many `yield` statements in your function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的生成器是一个包含`yield`语句而不是`return`语句的函数。与包含`return`的常规函数的关键区别在于，你的函数中可以有多个`yield`语句。
- en: 'An example of a generator with a few fixed `yield` statements and how it behaves
    with several operations is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含几个固定`yield`语句的生成器示例以及它在几个操作中的表现：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A few of the downsides of generators become immediately apparent in this example.
    The `result` does not offer much meaningful information when looking at its `repr()`,
    getting `len()` (length), or slicing. And trying to do `list()` to get the values
    a second time does not work because the generator is already exhausted.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，生成器的一些缺点立即显现出来。当查看其`repr()`、获取`len()`（长度）或切片时，`result`并不提供多少有意义的 信息。而且尝试再次使用`list()`来获取值是不起作用的，因为生成器已经耗尽。
- en: 'Additionally, you may have noticed that the `return` value of the function
    appears to have completely disappeared. This is actually not the case; the value
    of `return` is still used, but as the value for the `StopIteration` exception
    raised by the generator to indicate that the generator has been exhausted:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能已经注意到函数的`return`值似乎完全消失了。实际上并非如此；`return`的值仍然被使用，但作为生成器抛出的`StopIteration`异常的值，以指示生成器已耗尽：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following example demonstrates the lazy execution of generators:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了生成器的惰性执行：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see in this example, the code after the `yield` isn’t executed.
    This is caused by the `StopIteration` exception; if we properly catch this exception,
    the code will be executed:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本例中所见，`yield`之后的代码没有执行。这是由`StopIteration`异常引起的；如果我们正确地捕获这个异常，代码将会执行：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To properly handle generators, you always need to either catch the `StopIteration`
    yourself, or use a loop or another structure that handles the `StopIteration`
    implicitly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确处理生成器，你总是需要自己捕获`StopIteration`，或者使用循环或其他隐式处理`StopIteration`的结构。
- en: Creating infinite generators
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建无限生成器
- en: Creating an endless generator (such as the `itertools.count` iterator discussed
    in *Chapter 5*, *Functional Programming – Readability Versus Brevity*) is easy
    as well. If, instead of having the fixed `yield <value>` lines like in the previous
    function, we `yield` from inside of an infinite loop, we can easily make an infinite
    generator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个无限生成器（如第5章中讨论的`itertools.count`迭代器，*函数式编程 – 可读性与简洁性*）同样简单。如果我们不在函数中像上一个函数那样有固定的`yield
    <value>`行，而是在无限循环中`yield`，我们就可以轻松地创建一个无限生成器。
- en: 'As opposed to the `itertools.count()` generator, we will add a `stop` parameter
    to make testing easier:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与`itertools.count()`生成器相反，我们将添加一个`stop`参数以简化测试：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Due to the potentially infinite nature of generators, caution is required. Without
    the `stop` variable, simply doing `list(count())` would result in an infinite
    loop that results in an out-of-memory situation quite fast.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成器的潜在无限性，需要谨慎。如果没有`stop`变量，简单地执行`list(count())`会导致无限循环，这会很快导致内存不足的情况。
- en: So, how does this work? Essentially it is just a normal loop, but the big difference
    between this and the regular method of returning a list of items is that the `yield` statement
    returns the items one at a time, which means you only have to calculate the requested
    items and you don’t have to keep all results in memory.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是怎么工作的呢？本质上它只是一个普通的循环，但与返回项目列表的常规方法相比，`yield`语句一次返回一个项目，这意味着你只需要计算所需的项目，而不需要将所有结果都保存在内存中。
- en: Generators wrapping iterables
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装可迭代对象的生成器
- en: 'While generators are already quite useful when generating values from scratch,
    the real power comes when wrapping other iterables. To illustrate this, we will
    create a generator that automatically squares all numbers from the given input:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当从零开始生成值时，生成器已经非常有用，但真正的力量在于包装其他可迭代对象。为了说明这一点，我们将创建一个生成器，它会自动平方给定输入的所有数字：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Naturally, there is nothing stopping you from adding extra `yield` statements
    outside of the loop:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，您不能阻止您在循环之外添加额外的`yield`语句：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Because these generators are iterable, you can chain them together by wrapping
    them as many times as you like. A basic example of chaining a `square()` and an
    `odd()` generator together is:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些生成器是可迭代的，您可以通过多次包装它们来将它们链接在一起。将`square()`和`odd()`生成器链接在一起的基本示例是：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we analyze how the code is executed, we need to start from the inside to
    the outside:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析代码的执行方式，我们需要从内部到外部开始：
- en: The `range(10)` statement generates 10 numbers for us.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`range(10)`语句为我们生成10个数字。'
- en: The `odd()` generator filters the input values, so from the `[0, 1, 2 … ]` values
    it only returns `[1, 3, 5, 7, 9]`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`odd()`生成器过滤输入值，所以从`[0, 1, 2 … ]`值中只返回`[1, 3, 5, 7, 9]`。'
- en: The `square()` function squares the given input, which is the list of odd numbers
    as generated by `odd()`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`square()`函数对给定的输入进行平方，这是由`odd()`生成的奇数列表。'
- en: The real power of chaining is that the generators will only do something when
    we request a value. If we request a single value with `next()` instead of `list()`,
    it will mean that only the first iteration of the loop in `square()` will be run.
    For `odd()` and `range()`, however, it will have to process two values because
    `odd()` will discard the first value given by `range()` and not `yield` anything.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的真正力量在于，生成器只有在请求值时才会执行操作。如果我们用`next()`而不是`list()`请求单个值，这意味着只有`square()`中的第一个循环迭代会被运行。然而，对于`odd()`和`range()`，它必须处理两个值，因为`odd()`会丢弃`range()`给出的第一个值，并且不会`yield`任何内容。
- en: Generator comprehensions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器推导式
- en: 'In the previous chapters, you saw `list`, `dict`, and `set` comprehensions,
    which generate collections. With a generator comprehension we can make similar
    collections, but make them lazy so they are only evaluated as needed. The basic
    premise is identical to the `list` comprehension but using round brackets/parentheses
    instead of square brackets:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您已经看到了`list`、`dict`和`set`的推导式，它们可以生成集合。使用生成器推导式，我们可以创建类似的集合，但使它们变得懒加载，这样它们只会在需要时才被评估。基本前提与`list`推导式相同，但使用圆括号/括号而不是方括号：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is very useful when you need to wrap the results of a different generator
    because it only calculates the values you asked for:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要包装不同生成器的结果时，这非常有用，因为它只计算您请求的值：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can probably surmise from this result, this can be dangerous with infinite-sized
    generators such as `itertools.count()`. The order of operations is very important
    because the `itertools.islice()` function slices the result at that point, not
    the original generator. This means that if we replace `odd()` with a function
    that never evaluates to `True` for the given collection, it will run forever because
    it will never `yield` any results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经从结果中推断出，这对于无限大小的生成器，如`itertools.count()`，可能是危险的。操作顺序非常重要，因为`itertools.islice()`函数在该点切片结果，而不是原始生成器。这意味着如果我们用永远不会对给定集合求值为`True`的函数替换`odd()`，它将永远运行，因为它永远不会`yield`任何结果。
- en: Class-based generators and iterators
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于类的生成器和迭代器
- en: In addition to creating generators as regular functions and through generator
    comprehensions, we can also create generators using classes. This can be beneficial
    for more complex generators where you need to remember the state or where inheritance
    can be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过常规函数和生成器推导式创建生成器之外，我们还可以使用类来创建生成器。这对于需要记住状态或可以使用继承的更复杂的生成器来说是有益的。
- en: 'First, let’s look at an example of creating a basic generator `class` that
    mimics the behavior of `itertools.count()` with an added `stop` parameter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看创建一个基本的生成器`class`的示例，该类模仿了`itertools.count()`的行为，并添加了`stop`参数：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let’s convert the generator class into an iterator with more features:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将生成器类转换为具有更多功能的迭代器：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The most important distinction between the generator and the iterator is that
    instead of a simple iterable object, we now have a fully fledged class that acts
    as an iterator, which means we can also expand it beyond the capabilities of regular
    generators.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器和迭代器之间最重要的区别是，我们现在有一个完整的类，它充当迭代器，这意味着我们也可以将其扩展到常规生成器的功能之外。
- en: 'A few of the limitations of regular generators are that they don’t have a length
    and we cannot slice them. With an iterator, we can explicitly define the behavior
    in these scenarios if needed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正常生成器的一些限制是它们没有长度，我们无法对它们进行切片。使用迭代器，我们可以在需要的情况下显式定义这些场景的行为：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have our advanced count iterator with support for features such
    as `len()`, `in`, and `repr()`, we can test to see if it works as expected:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了支持 `len()`、`in` 和 `repr()` 等功能的先进计数迭代器，我们可以测试它是否按预期工作：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In addition to working around some of the limitations, in the last example,
    you can also see a very useful feature of generators. We can exhaust the items
    one by one and stop/start whenever we want. And since we still have full access
    to the object, we could alter `count.i` to restart the iterator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解决一些限制之外，在最后一个示例中，您还可以看到生成器的一个非常有用的功能。我们可以逐个耗尽项目，并随时停止/开始。由于我们仍然可以完全访问该对象，我们可以更改
    `count.i` 来重新启动迭代器。
- en: Generator examples
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器示例
- en: Now that you know how generators can be created, let’s look at a few useful
    generators and examples of how to use them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了如何创建生成器，让我们看看一些有用的生成器和它们的使用示例。
- en: Before you start writing a generator for your project, always make sure to look
    at the Python `itertools` module. It features a host of useful generators that
    cover a vast array of use cases. The following sections show some custom generators
    and a few of the most useful generators in the standard library.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始为项目编写生成器之前，请务必查看 Python 的 `itertools` 模块。它包含大量有用的生成器，涵盖了广泛的使用案例。以下部分展示了几个自定义生成器和标准库中最有用的生成器。
- en: These generators work on all iterables, not just generators. So, you could also
    apply them to a `list`, `tuple`, `string`, or other kinds of iterables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成器适用于所有可迭代对象，而不仅仅是生成器。因此，您也可以将它们应用于 `list`、`tuple`、`string` 或其他类型的可迭代对象。
- en: Breaking an iterable up into chunks/groups
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将可迭代对象拆分成块/组
- en: When executing large amounts of queries in a database or when running tasks
    via multiple processes, it is often more efficient to chunk the operations. Having
    a single huge operation could result in out-of-memory issues; having many tiny
    operations can be slow due to start-up/teardown sequences.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数据库中执行大量查询或在多个进程中运行任务时，通常更高效的做法是将操作分块。单个巨大的操作可能会导致内存不足的问题；由于启动/拆除序列，许多微小的操作可能会很慢。
- en: 'To make things more efficient, a good method is to split the input into chunks.
    The Python documentation ([https://docs.python.org/3/library/itertools.html?highlight=chunk#itertools-recipes](https://docs.python.org/3/library/itertools.html?highlight=chunk#itertools-recipes))
    already comes with an example of how to do this by using `itertools.zip_longest()`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，一个很好的方法是按块拆分输入。Python 文档([https://docs.python.org/3/library/itertools.html?highlight=chunk#itertools-recipes](https://docs.python.org/3/library/itertools.html?highlight=chunk#itertools-recipes))已经提供了一个使用
    `itertools.zip_longest()` 来实现此操作的示例：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code is a very nice example of how easy it is to chunk your data, but
    it has to hold the entire chunk in memory. To work around that, we can create
    a version that generates sub-generators for the chunks:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个很好的例子，说明了如何轻松地将数据分块，但它必须将整个块保留在内存中。为了解决这个问题，我们可以创建一个版本，为块生成子生成器：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because we need to catch the `StopIteration` exceptions, this example does not
    look very pretty in my opinion. Part of the code could be improved by using `itertools.islice()`
    (which is covered next) but that will still leave us with the problem that we
    cannot know when we have reached the end.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要捕获 `StopIteration` 异常，这个例子在我看来并不好看。部分代码可以通过使用 `itertools.islice()`（将在下一部分介绍）来改进，但这仍然会留下我们无法知道何时达到末尾的问题。
- en: 'If you are interested, an implementation using `itertools.islice()` and `itertools.chains()`
    can be found on this book’s GitHub: [https://github.com/mastering-python/code_2](https://github.com/mastering-python/code_2).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感兴趣，可以使用 `itertools.islice()` 和 `itertools.chains()` 在本书的 GitHub 上找到的实现：[https://github.com/mastering-python/code_2](https://github.com/mastering-python/code_2)。
- en: itertools.islice – Slicing iterables
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: itertools.islice – 可迭代对象的切片
- en: One limitation of generators is that they cannot be sliced. You can work around
    this by converting the generator into a `list` before slicing, but that is not
    possible with infinite generators, and it can be inefficient if you only need
    a few values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的一个限制是它们不能被切片。您可以通过在切片之前将生成器转换为 `list` 来解决这个问题，但对于无限生成器来说这是不可能的，如果您只需要几个值，这可能会很低效。
- en: 'To solve this, the `itertools` library has an `islice()` function, which can
    slice any iterable object. The function is the generator version of the slicing
    operators and similarly to slicing supports a `start`, `stop`, and `step` parameter.
    The following illustrates how regular slicing and `itertools.islice()` compare:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，`itertools`库有一个`islice()`函数，它可以切片任何可迭代对象。该函数是切片操作符的生成器版本，类似于切片，支持`start`、`stop`和`step`参数。以下说明了常规切片和`itertools.islice()`的比较：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is very important to note that while the output is identical, these methods
    are far from equivalent internally. Regular slicing only works on objects that
    are sliceable; effectively, this means the object has to implement the `__getitem__(self,
    slice)` method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管输出是相同的，但这些方法在内部并不等价。常规切片仅适用于可切片的对象；实际上，这意味着对象必须实现`__getitem__(self,
    slice)`方法。
- en: Additionally, we expect that slicing objects is a fast and efficient operation.
    For `list` and `tuple` this is certainly the case, but for a given generator this
    might not be the case.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们期望切片对象是一个快速且高效的操作。对于`list`和`tuple`来说，这当然是对的，但对于给定的生成器来说可能并非如此。
- en: If for a list with size `n=1000` we take any slice of any `k=10` elements, we
    can expect the time complexity of that to be only `O(k)`; that is, 10 steps. It
    doesn’t matter whether we do `some_list[:10]` or `some_list[900:920:2]`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对于大小为`n=1000`的列表，我们取任何`k=10`个元素的切片，我们可以期望其时间复杂度仅为`O(k)`；也就是说，10步。我们做`some_list[:10]`或`some_list[900:920:2]`都无关紧要。
- en: For `itertools.islice()` this is not the case because the only assumption it
    makes is that the input is iterable. That means that getting the first 10 items
    is easy; simply loop through the items, return the first 10, and stop. So `itertools.islice(some_list,
    10)` also takes 10 steps. Getting items 900 to 920, however, means walking through
    and discarding the first 900 items, and only returning 10 of the next 20 items.
    So that is 920 steps instead.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`itertools.islice()`来说，情况并非如此，因为它所做的唯一假设是输入是可迭代的。这意味着获取前10个元素很容易；只需遍历元素，返回前10个，然后停止。因此，`itertools.islice(some_list,
    10)`也需要10步。然而，获取第900到第920个元素意味着需要遍历并丢弃前900个元素，然后只返回接下来的20个元素中的10个。因此，这是920步。
- en: 'To illustrate this, here’s a slightly simplified implementation of `itertools.islice()`
    that expects to always have a `stop` available:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，这里有一个对`itertools.islice()`的略微简化的实现，它期望始终有一个`stop`可用：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, both the `start` and the `step` sections discard items that
    are not needed. This does not mean you should not use `itertools.islice()`, but
    be wary of the internals. Also, as you might expect, this generator does not support
    negative values for the indices and expects all values to be positive.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`start`和`step`部分都丢弃了不需要的元素。这并不意味着您不应该使用`itertools.islice()`，但要注意其内部机制。同样，如您所预期的那样，这个生成器不支持索引为负值，并期望所有值都是正数。
- en: itertools.chain – Concatenating multiple iterables
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: itertools.chain – 连接多个可迭代对象
- en: 'The `itertools.chain()` generator is one of the simplest yet one of the most
    useful generators in the Python library. It simply returns every item from every
    passed iterable in sequential order and can be implemented in just three lines:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.chain()`生成器是Python库中最简单但最有用的生成器之一。它简单地按顺序返回每个传递的可迭代对象的每个元素，并且可以用仅仅三行代码实现：'
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you might notice, this also introduces a feature not yet discussed: the
    `yield from` expression. `yield from` does exactly what you can expect from the
    name and yields all items from the given iterable. So `itertools.chain()` can
    also be replaced with the slightly more verbose:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能注意到的，这也引入了一个尚未讨论的功能：`yield from`表达式。`yield from`确实如您从其名称中可以预期的那样，从给定的可迭代对象中产生所有元素。因此，`itertools.chain()`也可以用稍微冗长的形式替换：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Interestingly, this method is more powerful than adding the collections because
    it doesn’t care about the types as long as they are iterable—duck typing at its
    finest.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这种方法比添加集合更强大，因为它不关心类型，只要它们是可迭代的——这就是鸭子类型的最纯粹形式。
- en: itertools.tee – Using an output multiple times
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: itertools.tee – 使用输出多次
- en: As mentioned before, one of the biggest disadvantages of generators is that
    the results are usable only once. Luckily, Python has a function that allows you
    to copy the output to several generators. The name `tee` might be familiar to
    you if you are used to working in a Linux/Unix command-line shell. The `tee` program
    allows you to write outputs to both the screen and a file, so you can store an
    output while still maintaining a live view of it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，生成器最大的缺点之一是结果只能使用一次。幸运的是，Python有一个函数允许你将输出复制到多个生成器。如果你习惯于在Linux/Unix命令行shell中工作，`tee`这个名字可能对你来说很熟悉。`tee`程序允许你将输出写入屏幕和文件，这样你就可以在保持实时查看的同时存储输出。
- en: The Python version, `itertools.tee()`, does a similar thing except that it returns
    several iterators, allowing you to process the results separately.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本中的`itertools.tee()`做类似的事情，但它返回几个迭代器，允许你分别处理结果。
- en: 'By default, `tee` will split your generator into a tuple containing two different
    generators, which is why tuple unpacking works nicely here. By passing along the `n` parameter,
    you can tell `itertools.tee()` to create more than two generators. Here is an
    example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tee`会将你的生成器拆分为一个包含两个不同生成器的元组，这就是为什么在这里使用元组解包工作得很好。通过传递`n`参数，你可以告诉`itertools.tee()`创建超过两个生成器。以下是一个示例：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After seeing this code, you might be wondering about the memory usage of `tee`.
    Does it need to store the entire list for you? Luckily, no. The `tee` function
    is pretty smart in handling this. Assume you have a generator that contains 1,000
    items, and you read the first 100 items from `a` and the first `75` items from `b` simultaneously.
    Then `tee` will only keep the difference (`100 - 75 = 25` items) in memory and
    drop the rest while you are iterating the results.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到这段代码后，你可能会对`tee`的内存使用情况感到好奇。它是否需要为你存储整个列表？幸运的是，不需要。`tee`函数在处理这个问题上相当聪明。假设你有一个包含1,000个元素的生成器，你同时从`a`中读取前100个元素和从`b`中读取前75个元素。然后`tee`将只保留差异（`100
    - 75 = 25`个元素）在内存中，并在迭代结果时丢弃其余部分。
- en: Whether `tee` is the best solution in your case or not depends, of course. If
    instance `a` is read from the beginning to (nearly) the end before instance `b` is
    read, then it would not be a great idea to use `tee`. Simply converting the generator
    into a `list` would be faster since it involves much fewer operations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 是否`tee`是你情况下的最佳解决方案取决于情况。如果实例`a`在读取实例`b`之前（几乎）从开始到结束都被读取，那么使用`tee`可能不是一个好主意。简单地将生成器转换为`list`会更快，因为它涉及的操作要少得多。
- en: contextlib.contextmanager – Creating context managers
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: contextlib.contextmanager – 创建上下文管理器
- en: You have already seen context managers in *Chapter 5*, *Functional Programming
    – Readability Versus Brevity*, and *Chapter 6*, *Decorators – Enabling Code Reuse
    by Decorating*, but there are many more useful things to be done with context
    managers. While the `contextlib.contextmanager()` generator is not meant to be
    a result-generating generator like the examples you saw earlier in this chapter,
    it does use `yield`, so it’s a nice example of non-standard generator usage.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在*第五章*，*函数式编程 – 可读性与简洁性之间的权衡*和*第六章*，*装饰器 – 通过装饰实现代码重用*中看到了上下文管理器，但还有许多其他有用的东西可以用上下文管理器来完成。虽然`contextlib.contextmanager()`生成器并不是像本章前面看到的例子那样用于生成结果的生成器，但它确实使用了`yield`，所以它是一个非标准生成器使用的良好示例。
- en: 'Some useful examples to log your output to a file and measure function execution
    time are:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有用的示例是将输出记录到文件并测量函数执行时间：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This all works perfectly, but the code could be prettier. Having three levels
    of context managers tends to get a bit unreadable, which is something you could
    generally solve using decorators, as covered in *Chapter 6*. In this case, however,
    we need the output from one context manager as the input for the next, which would
    make for a more complicated decorator setup.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都工作得很好，但代码可以更漂亮。有三个级别的上下文管理器往往难以阅读，这通常可以通过装饰器来解决，如*第六章*中所述。然而，在这种情况下，我们需要一个上下文管理器的输出作为下一个上下文管理器的输入，这将使装饰器设置更加复杂。
- en: 'That’s where the `ExitStack` context manager comes in. It allows the easy combining
    of multiple context managers without increasing the indentation level:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`ExitStack`上下文管理器发挥作用的地方。它允许轻松组合多个上下文管理器，而不会增加缩进级别：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Looks a bit simpler, doesn’t it? While this example is still reasonably legible
    without the `ExitStack` context manager, the convenience of `ExitStack` becomes
    quickly apparent when you need to do specific teardowns. In addition to the automatic
    handling, as seen before, it’s also possible to transfer the contexts to a new `ExitStack` to
    manually handle the closing:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来简单一些，不是吗？虽然这个例子在没有 `ExitStack` 上下文管理器的情况下仍然相当易于阅读，但当需要执行特定的清理操作时，`ExitStack`
    的便利性很快就会变得明显。除了之前看到的自动处理之外，还可以将上下文转移到新的 `ExitStack` 中以手动处理关闭：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Most of the `contextlib` functions have extensive documentation available in
    the Python manual. `ExitStack` in particular is documented using many examples
    at [https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack](https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack).
    I recommend keeping an eye on the `contextlib` documentation as it is improving
    greatly with every Python version.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `contextlib` 函数在 Python 手册中都有详细的文档。特别是 `ExitStack`，它使用许多示例进行了文档说明，可以在 [https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack](https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack)
    找到。我建议关注 `contextlib` 文档，因为它随着每个 Python 版本的更新而不断改进。
- en: Now that we have covered regular generators, it is time to continue with coroutines.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了常规生成器，是时候继续介绍协程了。
- en: Coroutines
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: Coroutines are subroutines that offer non-pre-emptive multitasking through multiple
    entry points. The basic premise is that coroutines allow two functions to communicate
    with each other while running within a single thread. Normally, this type of communication
    is reserved only for multitasking or multithreading solutions, but coroutines
    offer a relatively simple way of achieving this at almost no added performance
    cost.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是通过多个入口点提供非抢占式多任务处理的子程序。基本前提是协程允许两个函数在单个线程中运行时相互通信。通常，这种类型的通信仅限于多任务或多线程解决方案，但协程提供了一种相对简单的方法来实现这一点，而几乎不需要额外的性能开销。
- en: Since generators are lazy by default, you might be able to guess how coroutines
    function. Until a result is consumed, the generator sleeps; but while consuming
    a result, the generator becomes active. The difference between regular generators
    and coroutines is that with coroutines the communication goes both ways; the coroutine
    can receive values as well as `yield` them to the calling function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成器默认是惰性的，你可能能够猜到协程是如何工作的。直到结果被消费，生成器会处于休眠状态；但在消费结果时，生成器变得活跃。常规生成器和协程之间的区别在于，使用协程时，通信是双向的；协程不仅可以接收值，还可以将值
    `yield` 给调用函数。
- en: If you are familiar with `asyncio` you might notice a strong similarity between
    `asyncio` and coroutines. That is because `asyncio` is built on the idea of coroutines
    and has evolved from a little bit of syntactic sugar into a whole ecosystem. For
    practical purposes I would suggest using `asyncio` instead of the coroutine syntax
    explained here; for educational purposes, however, it is very useful to understand
    how they work. The `asyncio` module is under very active development and has a
    much less awkward syntax.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 `asyncio`，你可能会注意到 `asyncio` 和协程之间有很强的相似性。这是因为 `asyncio` 是基于协程的概念构建的，并且已经从一点语法糖发展成为一个完整的生态系统。出于实用目的，我建议使用
    `asyncio` 而不是这里解释的协程语法；然而，出于教育目的，了解它们是如何工作的非常有用。`asyncio` 模块正在非常活跃地开发中，并且拥有一个不那么笨拙的语法。
- en: A basic example
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个基本示例
- en: 'In the previous sections, you saw how regular generators can `yield` values.
    But generators can do more; they can actually receive values through `yield` as
    well. The basic usage is fairly simple:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到了常规生成器如何 `yield` 值。但生成器可以做更多；它们实际上可以通过 `yield` 接收值。基本用法相当简单：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And that’s all there is to it. The function is frozen until the `send` method
    is called, at which point it will process up to the next `yield` statement. One
    limitation you can see from this is that the coroutine can’t wake up by itself.
    The value exchanges can only happen when the calling code runs `next(generator)`
    or `generator.send()`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。函数会在 `send` 方法被调用之前保持冻结状态，此时它将处理到下一个 `yield` 语句。从这个限制中你可以看到一个限制是协程不能自己醒来。值交换只能在调用代码运行
    `next(generator)` 或 `generator.send()` 时发生。
- en: Priming
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预激
- en: 'Since generators are lazy, you can’t just send a value to a brand-new generator.
    Before a value can be sent to the generator, either a result must be fetched using `next()` or
    a `send(None)` has to be issued so that the code is actually reached. This is
    understandable, but a bit tedious at times. Let’s create a simple decorator to
    omit the need for this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成器是惰性的，你不能直接向一个全新的生成器发送一个值。在值可以发送到生成器之前，必须使用`next()`获取结果，或者发出`send(None)`以便代码实际上能够执行。这是可以理解的，但有时会有些繁琐。让我们创建一个简单的装饰器来省略这个需求：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you’ve probably noticed, even though the generator is still lazy, it now
    automatically executes all of the code until it reaches the `yield` statement
    again. At that point, it will stay dormant until new values are sent.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，尽管生成器仍然是惰性的，但它现在会自动执行所有代码，直到再次遇到`yield`语句。到那时，它将保持休眠状态，直到发送新的值。
- en: Note that the `coroutine` decorator will be used throughout this chapter from
    this point onward. For brevity, the coroutine function definition will be omitted
    from the following examples.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从现在开始，本章将一直使用`coroutine`装饰器。为了简洁，以下示例中将省略协程函数的定义。
- en: Closing and throwing exceptions
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭和抛出异常
- en: Unlike regular generators, which simply exit as soon as the input sequence is exhausted,
    coroutines generally employ infinite `while` loops, which means that they won’t
    be torn down the normal way. That’s why coroutines also support both the `close` and `throw` methods,
    which will exit the function. The important thing here is not the closing but
    the possibility of adding a teardown method. Essentially, it is very comparable
    to how context wrappers function with an `__enter__` and `__exit__` method, but
    with coroutines in this case.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规生成器不同，一旦输入序列耗尽，生成器就会立即退出，而协程通常使用无限`while`循环，这意味着它们不会以常规方式被销毁。这就是为什么协程也支持`close`和`throw`方法，这些方法可以退出函数。这里重要的是关闭的可能性，而不是关闭本身。本质上，这与上下文包装器使用`__enter__`和`__exit__`方法非常相似，但在这个情况下是协程。
- en: 'The following example shows a coroutine with normal and exception exit cases
    using the `coroutine` decorator from the previous paragraph:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用上一段中的`coroutine`装饰器的协程，包括正常和异常退出情况：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This `simple_coroutine()` function can show us some of the internal flow of
    coroutines and how they are interrupted. The `try`/`finally` behavior might surprise
    you in particular:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`simple_coroutine()`函数可以向我们展示协程的一些内部流程以及它们是如何被中断的。特别是`try`/`finally`行为可能会让你感到惊讶：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Most of this output is as you would expect, but as was the case with the `StopIteration`
    in generators, you have to catch the exception to be sure the teardown is handled
    correctly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分输出都是你预期的，但就像生成器中的`StopIteration`一样，你必须捕获异常以确保正确处理清理。
- en: Mixing generators and coroutines
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合生成器和协程
- en: 'While generators and coroutines appear to be very similar due to the `yield`
    statements, they are somewhat different beasts. Let’s create a two-way pipeline
    to process the given input and pass this along to multiple coroutines along the
    way:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管生成器和协程由于`yield`语句而看起来非常相似，但它们实际上是两种不同的生物。让我们创建一个双向管道来处理给定的输入，并在过程中传递给多个协程：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Given this example, you might be wondering why we are now printing the value
    instead of yielding it. We can `yield` the value, but remember that generators
    freeze until a value is yielded. Let’s see what will happen if we simply `yield` the
    value instead of calling `print`. By default, you might be tempted to do this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个示例，你可能想知道为什么我们现在打印值而不是产生它。我们可以`yield`这个值，但记住，生成器在产生值之前会冻结。让我们看看如果我们简单地`yield`值而不是调用`print`会发生什么。默认情况下，你可能会倾向于这样做：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Half of the values have disappeared now; our “`really really new`" line has
    disappeared. Notice that the second `yield` isn’t storing the results, and that
    `yield` effectively makes this a generator and not a coroutine. We need to store
    the results from that `yield` as well:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经消失了一半的值；我们的“`really really new`"行已经消失了。注意第二个`yield`没有存储结果，并且`yield`实际上使这个函数成为一个生成器而不是协程。我们需要从那个`yield`存储结果：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But even this is far from optimal. We are essentially using coroutines to mimic
    the behavior of generators right now. It works, but it is a bit pointless and
    offers no real benefit.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还远远不够优化。我们实际上正在使用协程来模仿生成器的行为。它确实有效，但有点多余，并且没有带来真正的益处。
- en: 'Let’s make a real pipeline this time where the coroutines send the data to
    the next coroutine or coroutines. This demonstrates the real power of coroutines,
    which is being able to chain multiple coroutines together:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这次创建一个真正的管道，其中协程将数据发送到下一个协程或协程。这展示了协程的真正力量，即能够将多个协程链接在一起：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have our coroutine functions, let’s see how we can link these together:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的协程函数，让我们看看我们如何将这些函数链接在一起：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This makes the code much simpler and more readable and shows how you can send
    a single input source to multiple destinations simultaneously. At first glance,
    this example does not look that exciting, but the exciting part is that even though
    we split the input using `tee()` and processed it through two separate `replace()`
    instances, we still ended up at the same `print_()` function with the same state.
    This means that it’s possible to route and modify your data along whichever way
    is convenient for you while still having it end up at the same endpoint with no
    effort whatsoever.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这使代码更加简单和易于阅读，并展示了如何将单个输入源同时发送到多个目的地。乍一看，这个例子并不那么令人兴奋，但令人兴奋的部分是，尽管我们使用 `tee()`
    分割了输入并通过两个独立的 `replace()` 实例进行处理，但我们最终仍然到达了具有相同状态的同一个 `print_()` 函数。这意味着你可以根据你的方便来路由和修改你的数据，同时几乎不需要任何努力就能到达同一个终点。
- en: For now, the most important takeaway is that mixing generators and coroutines
    is not a good idea in most cases since it can have very strange side effects if
    used incorrectly. Even though both use the `yield` statement, they are significantly
    different creatures with different behavior. The next section will demonstrate
    one of the few cases where mixing coroutines and generators can be useful.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 目前来说，最重要的收获是，在大多数情况下，混合生成器和协程不是一个好主意，因为如果使用不当，可能会产生非常奇怪的副作用。尽管两者都使用 `yield`
    语句，但它们是显著不同的实体，具有不同的行为。下一节将演示混合协程和生成器可以有用的一小部分情况。
- en: Using the state
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用状态
- en: 'Now that you know how to write basic coroutines and which pitfalls you have
    to take care of, how about writing a function where remembering the state is required?
    That is, a function that always gives you the average value of all sent values.
    This is one of the few cases where it is still relatively safe and useful to combine
    the coroutine and generator syntax:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何编写基本的协程以及需要注意哪些陷阱，那么写一个需要记住状态的函数怎么样？也就是说，一个总是给你所有发送值的平均值的函数。这是少数几种仍然相对安全和有用的结合协程和生成器语法的情况之一：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It still requires some extra logic to work properly, though. We need to prime
    our coroutine using `yield`, but we don’t send any data at that point because
    the first `yield` is the primer and is executed before we get the value. Once
    that’s all set up, we can easily yield the average value while summing. It’s not
    all that bad, but the pure coroutine version is slightly simpler to understand
    since we only have a single execution path because we don’t have to worry about
    priming. To illustrate this, here is the pure coroutine version:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，它仍然需要一些额外的逻辑才能正常工作。我们需要使用 `yield` 来初始化我们的协程，但在那个时刻我们不发送任何数据，因为第一个 `yield`
    是初始化器，在我们得到值之前执行。一旦一切准备就绪，我们就可以轻松地在求和的同时产生平均值。这并不那么糟糕，但纯协程版本稍微简单一些，因为我们只有一个执行路径，因为我们不必担心初始化。为了说明这一点，这里是有纯协程版本：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'While that example is a few lines longer than the version that includes a generator,
    it is much easier to understand. Let’s analyze it to make sure the workings are
    clear:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子比包含生成器的版本多几行，但它更容易理解。让我们分析它以确保工作原理清晰：
- en: We set `total` to `0` to start counting.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `total` 设置为 `0` 以开始计数。
- en: We keep track of the measurement count by using `itertools.count()`, which we
    configure to start counting from 1.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用 `itertools.count()` 来跟踪测量次数，我们将其配置为从 1 开始计数。
- en: We fetch the next value using `yield`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `yield` 来获取下一个值。
- en: We send the average to the given coroutine instead of returning the value to
    make the code less confusing.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将平均值发送给给定的协程，而不是返回值，以使代码更易于理解。
- en: 'Another nice example is `itertools.groupby`, which is also quite simple to
    recreate using coroutines. For comparison, I will once again show both the generator
    coroutine and the pure coroutine version:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的例子是 `itertools.groupby`，它也相当简单，可以使用协程来重新创建。为了比较，我将继续展示生成器协程和纯协程版本：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, this function uses a few tricks. Firstly, we store the previous `key` and `value` so
    that we can detect when the group (`key`) changes. Secondly, we obviously cannot
    recognize a group until the group has changed, so only after the group has changed
    will the results be returned. This means that the last group will be sent only
    if a different group is sent after it, hence the `(None, None)`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个函数使用了一些技巧。首先，我们存储了之前的`key`和`value`，这样我们就可以检测到组（`key`）何时发生变化。其次，我们显然不能在组发生变化之前识别一个组，因此只有在组发生变化之后才会返回结果。这意味着只有当在最后一个组之后发送了不同的组时，才会发送最后一个组，这就是为什么有`(None,
    None)`。
- en: The example uses tuple unpacking for the string, splitting `'a1'` into group
    `'a'` and value `'1'`. Alternatively, you could also use `grouper.send(('a', 1))`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用字符串的元组解包，将`'a1'`拆分为组`'a'`和值`'1'`。或者，您也可以使用`grouper.send(('a', 1))`。
- en: 'Now here is the pure coroutine version:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是纯协程版本：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While the functions are fairly similar, the coroutine version has a less complex
    control path and only needs to `yield` in one spot. This is because we don’t have
    to think about priming and potentially losing values.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些函数相当相似，但协程版本的控制路径更简单，只需要在一个地方`yield`。这是因为我们不必考虑初始化和可能丢失值的问题。
- en: Exercises
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Generators have a multitude of uses so you can probably start using them in
    your own code right away. Nevertheless, the following exercises might help you
    understand the features and the limitations a bit better:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器有各种各样的用途，您可能可以直接在自己的代码中使用它们。尽管如此，以下练习可能有助于您更好地理解其特性和局限性：
- en: Create a generator similar to `itertools.islice()` that allows for a negative
    step so you can execute `some_list[20:10:-1]`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个类似于`itertools.islice()`的生成器，允许使用负步长，以便您可以执行`some_list[20:10:-1]`。
- en: Create a class that wraps a generator so it becomes sliceable by using `itertools.islice()`
    internally.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个类，它包装一个生成器，使其可以通过内部使用`itertools.islice()`来切片。
- en: Write a generator for the Fibonacci numbers.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个生成斐波那契数的生成器。
- en: Write a generator that uses the sieve of Eratosthenes to generate prime numbers.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个使用欧几里得筛法生成素数的生成器。
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](https://github.com/mastering-python/exercises).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](https://github.com/mastering-python/exercises)。鼓励您提交自己的解决方案，并从他人的替代方案中学习。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showed you how to create generators and both the strengths and
    weaknesses that they possess. Additionally, it should now be clear how to work
    around their limitations and the implications of doing so.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了如何创建生成器以及它们所具有的优缺点。此外，现在应该很清楚如何克服它们的局限性及其影响。
- en: In general, I would always recommend the use of generators over traditional
    collection-generating functions. They are easier to write, consume less memory,
    and, if needed, the downsides can be mitigated by replacing `some_generator()`
    with `list(some_generator())`, or a decorator that handles that for you.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我总是推荐使用生成器而不是传统的集合生成函数。它们更容易编写，消耗的内存更少，如果需要，可以通过将`some_generator()`替换为`list(some_generator())`或一个为您处理该问题的装饰器来减轻其缺点。
- en: While the paragraphs about coroutines provided some insights into what they
    are and how they can be used, they were just a mild introduction to coroutines.
    Both the pure coroutines and the coroutine generator combinations are still somewhat
    clunky, which is why the `asyncio` library was created. *Chapter 13,* *- asyncio
    – Multithreading without Threads,* covers `asyncio` in detail and also introduces
    the `async` and `await` statements, which make coroutine usage much more intuitive
    compared to `yield`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于协程的段落提供了一些关于它们是什么以及如何使用的见解，但这只是对协程的温和介绍。纯协程和协程生成器组合仍然有些笨拙，这就是为什么创建了`asyncio`库。第13章，“*asyncio
    – 无线程的多线程*”，详细介绍了`asyncio`，并介绍了`async`和`await`语句，这使得协程的使用比`yield`更加直观。
- en: In the previous chapter, you saw how we can modify classes using class decorators.
    In the next chapter, we will cover the creation of classes using metaclasses.
    Using metaclasses, you can modify classes during the creation of the class itself.
    Note that I am not talking about the instances of the class, but the actual class
    object. Using this technique, you can create automatically registering plugin
    systems, add extra attributes to classes, and more.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了我们如何使用类装饰器来修改类。在下一章中，我们将介绍如何使用元类来创建类。使用元类，你可以在创建类本身的过程中修改类。请注意，我所说的不是类的实例，而是实际的类对象。使用这种技术，你可以创建自动注册的插件系统，向类添加额外的属性，等等。
- en: Join our community on Discord
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code156081100001293319171.png)'
