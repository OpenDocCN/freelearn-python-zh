- en: Chapter 1. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 入门
- en: Any software available over the Internet, usually accessed with a web browser,
    can be addressed as a web application. Social networks, e-commerce sites, e-mail
    clients, online games are just a few examples of a trend known as web 2.0, which
    was started in the late 1990s and emerged in the past few years. Today, if we
    want to provide a service for multiple clients and multiple users, we will likely
    end in with writing a web application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可通过互联网访问的软件，通常通过网页浏览器访问，都可以被视为网络应用程序。社交网络、电子商务网站、电子邮件客户端、在线游戏只是被称为 Web 2.0
    的趋势的几个例子，这一趋势始于 1990 年代末，并在过去几年中兴起。今天，如果我们想为多个客户和多个用户提供服务，我们很可能会编写一个网络应用程序。
- en: 'Web applications come with an endless list of benefits from a developer''s
    point of view but there is one major drawback to face every time we want to make
    our software available to other users: we need a remote server connected to the
    Internet to host the application. This server must be constantly available and
    respond to clients in a reasonable amount of time, irrespective of the number
    of clients, or the application won''t be usable.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，网络应用程序带来了无数的好处，但每次我们想要让我们的软件对其他用户可用时，都会面临一个主要缺点：我们需要一个连接到互联网的远程服务器来托管应用程序。这个服务器必须始终可用，并在合理的时间内响应用户，无论用户数量多少，否则应用程序将无法使用。
- en: A noteworthy solution to the hosting problem is cloud computing, which is a
    rather generic term that usually refers to the opportunity to run applications
    and services on someone else's infrastructure at a reasonable cost and in a way
    that is simple and quick for the needed resources to be provisioned and released.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 解决托管问题的值得注意的解决方案是云计算，这是一个相当通用的术语，通常指的是以合理的成本、简单快捷的方式在他人基础设施上运行应用程序和服务的机遇，并且能够快速配置和释放所需资源。
- en: In this first chapter we will define in detail the term cloud computing and
    then introduce the model provided by Google, focusing on the elements that are
    important to us, as developers, and use them to run our first application using
    the Google Cloud Platform and Google App Engine.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细定义云计算这一术语，然后介绍谷歌提供的模型，重点关注对我们这些开发者来说重要的元素，并使用它们在谷歌云平台和谷歌 App Engine
    上运行我们的第一个应用程序。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: A detailed introduction to Google Cloud Platform and Google App Engine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对谷歌云平台和谷歌 App Engine 的详细介绍
- en: Setting up an App Engine code environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 App Engine 代码环境
- en: Writing a simple application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的应用程序
- en: Loading and running the application on a remote server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程服务器上加载和运行应用程序
- en: Using the administration console
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管理控制台
- en: The cloud computing stack – SaaS, PaaS, and IaaS
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算堆栈 – SaaS、PaaS 和 IaaS
- en: We can choose to outsource our applications and the hardware they run on, still
    being responsible for the whole software stack, including the operating system;
    or, we can simply use existing applications available from another vendor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择外包我们的应用程序及其运行的硬件，同时仍然负责整个软件栈，包括操作系统；或者，我们可以简单地使用来自其他供应商的现有应用程序。
- en: 'We can represent cloud computing as a stack of three different categories:
    **Software** **as** **a** **Service** (**SaaS**), **Platform** **as** **a** **Service**
    (**PaaS**), and **Infrastructure as a Service** (**IaaS**) as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将云计算表示为三个不同类别的堆栈：**软件即服务**（**SaaS**）、**平台即服务**（**PaaS**）和**基础设施即服务**（**IaaS**）如下：
- en: '![The cloud computing stack – SaaS, PaaS, and IaaS](img/8194OS_01_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![云计算堆栈 – SaaS、PaaS 和 IaaS](img/8194OS_01_01.jpg)'
- en: In the first case, the cloud computing model is defined as IaaS and we basically
    outsource hardware and every inherent service such as power supply, cooling, networking,
    and storage systems. We decide how to allocate resources, how many web applications,
    or database servers we need, whether or not we need to use a load balancer, how
    to manage backups and so on; the installation, monitoring, and maintenance are
    under our responsibilities. A notable example of IaaS services are EC2 from Amazon
    and Rackspace Cloud Hosting.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，云计算模型被定义为 IaaS，我们基本上外包了硬件以及所有固有的服务，如电源供应、冷却、网络和存储系统。我们决定如何分配资源，需要多少网络应用程序或数据库服务器，是否需要使用负载均衡器，如何管理备份等等；安装、监控和维护是我们的责任。IaaS
    服务的显著例子包括亚马逊的 EC2 和 Rackspace 云托管。
- en: In the second case, the cloud computing model is defined as SaaS and is the
    opposite of IaaS since we simply use a turnkey software provided by a third-party
    vendor, who has no technical knowledge of the infrastructure it runs on; the vendor
    is responsible for the reliability and security of the product. Notable examples
    of SaaS are Gmail from Google and Salesforce.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，云计算模型被定义为SaaS，与IaaS相反，因为我们只是使用第三方供应商提供的现成软件，该供应商对其运行的基础设施没有技术知识；供应商负责产品的可靠性和安全性。SaaS的显著例子包括谷歌的Gmail和Salesforce。
- en: Between IaaS and SaaS we find the PaaS model, which seems to be the most interesting
    solution from a developer's point of view. A PaaS system provides a platform with
    which we can build and run our application without worrying about the underlying
    levels, both hardware and software.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在IaaS和SaaS之间，我们发现PaaS模型，这似乎是从开发者角度来看最有趣的解决方案。PaaS系统提供了一个平台，我们可以用它来构建和运行我们的应用程序，而无需担心底层，无论是硬件还是软件。
- en: Google Cloud Platform
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Platform
- en: Google Cloud Platform is designed to offer developers tools and services needed
    to build and run web applications on Google's reliable and highly scalable infrastructure.
    The platform consists of several cloud computing products that can be composed
    and used according to our needs, so it's important to know what these building
    blocks can do for us, as developers, and how they do so.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Platform旨在为开发者提供构建和运行基于谷歌可靠且高度可扩展基础设施的Web应用程序所需的工具和服务。该平台由几个云计算产品组成，可以根据我们的需求进行组合和使用，因此了解这些构建块能为开发者做什么以及它们是如何做到这一点的是非常重要的。
- en: 'As we can learn from the main documentation page at [https://cloud.google.com](https://cloud.google.com),
    Google classifies Google Cloud Platform''s components into four groups: Hosting
    + Compute, Storage, Big Data, and services.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从[https://cloud.google.com](https://cloud.google.com)的主文档页面了解到的，谷歌将Google
    Cloud Platform的组件分为四组：托管 + 计算、存储、大数据和各项服务。
- en: Hosting + Compute
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托管 + 计算
- en: 'There are two options if we want to host an application on Google Cloud Platform:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在Google Cloud Platform上托管一个应用程序，有两种选择：
- en: '**Google App Engine**: This is Google''s PaaS and it will be covered in detail
    later in this chapter.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google App Engine**：这是谷歌的PaaS平台，将在本章后面详细介绍。'
- en: '**Google Compute Engine**: This is Google''s IaaS and lets users run virtual
    machines on Google''s infrastructure with a variety of hardware and software configurations.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Compute Engine**：这是谷歌的IaaS，允许用户在谷歌的基础设施上运行具有各种硬件和软件配置的虚拟机。'
- en: Storage
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储
- en: 'Google Cloud Platform provides several options to store and access users''
    data:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Platform提供了几种存储和访问用户数据的选择：
- en: '**Google Cloud Storage**: This is a highly available and scalable file storage
    service with versioning and caching. We will learn how to use Cloud Storage in
    [Chapter 3](ch03.html "Chapter 3. Storing and Processing Users'' Data"), *Storing
    and Processing User''s Data*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud Storage**：这是一个高度可用和可扩展的文件存储服务，具有版本控制和缓存功能。我们将在[第3章](ch03.html
    "第3章。存储和处理用户数据")，*存储和处理用户数据*中学习如何使用Cloud Storage。'
- en: '**Google Cloud SQL**: This is a fully managed MySQL relational database; replication,
    security and availability are Google''s responsibilities. [Chapter 5](ch05.html
    "Chapter 5. Storing Data in Google Cloud SQL"), *Storing Data in Google Cloud
    SQL*, is entirely dedicated to this service.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud SQL**：这是一个完全托管的MySQL关系型数据库；复制、安全和可用性是谷歌的责任。[第5章](ch05.html "第5章。在Google
    Cloud SQL中存储数据")，*在Google Cloud SQL中存储数据*完全致力于这项服务。'
- en: '**Google Cloud Datastore**: This is a managed schemaless database that stores
    nonrelational data objects called entities; it scales automatically, supports
    transactions, and can be queried with SQL-like syntax. We will start using it
    in [Chapter 2](ch02.html "Chapter 2. A More Complex Application"), *A More Complex
    Application*, and learn how to get the most out of it in [Chapter 4](ch04.html
    "Chapter 4. Improving Application Performance"), *Improving Application Performance*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud Datastore**：这是一个托管的无模式数据库，存储称为实体的非关系型数据对象；它自动扩展，支持事务，并可以使用类似SQL的语法进行查询。我们将在[第2章](ch02.html
    "第2章。一个更复杂的应用")，*一个更复杂的应用*中开始使用它，并在[第4章](ch04.html "第4章。提高应用性能")，*提高应用性能*中学习如何充分利用它。'
- en: BigQuery
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BigQuery
- en: '**BigQuery** is a tool provided by Google Cloud Platform that allows to perform
    queries using an SQL-like syntax against a huge amount of data in a matter of
    seconds. Before it can be analyzed, data must be streamed into BigQuery through
    its API or uploaded to Google Cloud Storage.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**BigQuery** 是由 Google Cloud Platform 提供的工具，允许使用类似 SQL 的语法在几秒钟内对大量数据进行查询。在进行分析之前，数据必须通过其
    API 流入 BigQuery 或上传到 Google Cloud Storage。'
- en: Services
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: 'Instead of writing code from scratch, we can easily add functionalities to
    our applications using some of Google''s services through APIs that are very well
    integrated within Google Cloud Platform:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必从头编写代码，而可以通过 Google 的一些服务轻松地向我们的应用程序添加功能，这些服务通过 Google Cloud Platform 内部高度集成的
    API 实现：
- en: '**The Translate API**: This can translate text between dozens of languages
    programmatically, from within our applications.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**翻译 API**：这个 API 可以在程序中实现将文本翻译成多种语言，从我们的应用程序内部进行。'
- en: '**The Prediction API**: This predicts future trends using Google''s machine
    learning algorithms and can be used from within our applications or through a
    **Representational State Transfer** (**REST**) API. REST is a stateless architecture
    style that describes how a system can communicate with another through a network;
    we will delve into more details on REST in [Chapter 8](ch08.html "Chapter 8. Exposing
    a REST API with Google Cloud Endpoints"), *Exposing a REST API with Google Cloud
    Endpoints*.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测 API**：这个 API 使用 Google 的机器学习算法预测未来趋势，可以从我们的应用程序内部或通过 **表示状态转换**（REST）API
    使用。REST 是一种无状态架构风格，描述了一个系统如何通过网络与另一个系统通信；我们将在第 8 章 [使用 Google Cloud Endpoints
    暴露 REST API](ch08.html "第 8 章。使用 Google Cloud Endpoints 暴露 REST API") 中深入了解 REST。'
- en: '**Google Cloud Endpoints**: Using this tool, it''s easy to create applications
    that expose REST services, providing also **Denial-of-Service** (**DoS**) protection
    and **OAuth2** authentication. We will learn how to use them in [Chapter 8](ch08.html
    "Chapter 8. Exposing a REST API with Google Cloud Endpoints"), *Exposing a REST
    API with Google Cloud Endpoints*.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud Endpoints**：使用这个工具，可以轻松创建暴露 REST 服务的应用程序，同时提供 **拒绝服务**（DoS）保护和
    **OAuth2** 认证。我们将在第 8 章 [暴露 REST API 的 Google Cloud Endpoints](ch08.html "第 8
    章。使用 Google Cloud Endpoints 暴露 REST API") 中学习如何使用它们。'
- en: '**Google Cloud DNS**: This is global **Domain Name System** (**DNS**) service
    that runs on Google''s infrastructure and provides high volume serving that is
    programmable from within our applications.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud DNS**：这是一个全球性的域名系统（DNS）服务，运行在 Google 的基础设施上，并从我们的应用程序内部提供可编程的高容量服务。'
- en: '**Google Cloud Pub/Sub**: This is middleware that provides many-to-many, asynchronous
    messaging between services that either run on Google Cloud Platform or externally.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud Pub/Sub**：这是一个中间件，提供在运行在 Google Cloud Platform 或外部服务之间进行多对多、异步消息传递。'
- en: All the tools and services provided by Google Cloud Platform are billed with
    a pay-per-use model so that applications can scale up or down as needed and we
    only pay for resources we actually use. A handy calculator is provided to have
    a precise idea of the costs depending on the services and resources we think we
    will need. Google Cloud Platform offers a certain amount of resources we can use
    without paying anything; usually, these free quotas are well suited to host web
    applications with low traffic at no cost.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Platform 提供的所有工具和服务都采用按使用付费的模式，这样应用程序可以根据需要扩展或缩减，我们只为实际使用的资源付费。提供了一个方便的计算器，以便我们能够精确地了解根据我们认为将需要的服务和资源而产生的成本。Google
    Cloud Platform 提供了一定数量的资源，我们可以免费使用；通常，这些免费配额非常适合免费托管流量较低的 Web 应用程序。
- en: What Google App Engine does
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google App Engine 的作用
- en: As mentioned earlier, App Engine is a PaaS, which means that we have the benefits
    of SaaS products but with an augmented flexibility as we have complete control
    over the code. We also have the benefits of an IaaS solution but without the hassle
    of maintaining and configuring the software environment needed to run applications
    on a raw hardware system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，App Engine 是一个平台即服务（PaaS），这意味着我们享有 SaaS 产品的优势，同时由于我们对代码拥有完全控制权，因此具有增强的灵活性。我们还有
    IaaS 解决方案的优势，但无需烦恼维护和配置在原始硬件系统上运行应用程序所需的软件环境。
- en: 'Developers are the favored users of a PaaS product such as App Engine because
    the platform helps them in two ways: it provides an easy way to deploy, scale,
    tune, and monitor web applications without the need for a system administrator
    and it offers a set of tools and services that speed up the software development
    process. Let''s explore these two aspects in detail.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员是PaaS产品（如App Engine）的首选用户，因为该平台以两种方式帮助他们：它提供了一种简单的方法来部署、扩展、调整和监控Web应用程序，而无需系统管理员，并且它提供了一套工具和服务，可以加快软件开发过程。让我们详细探讨这两个方面。
- en: The runtime environment
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时环境
- en: App Engine runs on computing units that are completely managed called instances.
    We can (and should) ignore which operating system is running on an instance because
    we interact solely with the runtime environment, which is an abstraction of the
    operating system that provides resource allocation, computation management, request
    handling, scaling, and load balancing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine运行在完全管理的计算单元上，称为实例。我们可以（并且应该）忽略实例上运行的操作系统，因为我们只与运行时环境交互，该环境是操作系统的抽象，提供资源分配、计算管理、请求处理、扩展和负载均衡。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Developers can choose among four different programming languages to write applications
    on App Engine: Python, Java, Hypertext Preprocessor (PHP), and Go but we will
    focus on the Python environment.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以在App Engine上使用四种不同的编程语言编写应用程序：Python、Java、超文本预处理程序（PHP）和Go，但我们将重点关注Python环境。
- en: Every time a client contacts an application that runs on App Engine, a component
    of the runtime environment called scheduler selects an instance that can provide
    a fast response, initializes it with application data if needed, and executes
    the application with a Python interpreter in a safe, sandboxed environment. The
    application receives the HTTP request, performs its work, and sends an HTTP response
    back to the environment. Communication between the runtime environment and the
    application is performed using the **Web Server Gateway Interface** (**WSGI**)
    protocol; this means that developers can use any WSGI-compatible web framework
    in their application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每当客户端联系运行在App Engine上的应用程序时，运行时环境中的一个组件，称为调度器，会选择一个能够提供快速响应的实例，如果需要，则用应用程序数据初始化它，并在一个安全、沙箱化的环境中使用Python解释器执行应用程序。应用程序接收HTTP请求，执行其工作，并将HTTP响应发送回环境。运行时环境与应用程序之间的通信使用**Web
    Server Gateway Interface**（**WSGI**）协议进行；这意味着开发人员可以在其应用程序中使用任何WSGI兼容的Web框架。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: WSGI is a specification that describes how a web server communicates with web
    applications written in Python. It was originally described in PEP-0333 and later
    updated in PEP-3333, mainly to improve usability under the Python 3.0 release.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI是一个描述Web服务器如何与用Python编写的Web应用程序通信的规范。它最初在PEP-0333中描述，后来在PEP-3333中更新，主要是为了在Python
    3.0发布下提高可用性。
- en: The runtime environment is sandboxed to improve security and provide isolation
    between applications running on the same instance. The interpreter can execute
    any Python code, import other modules, and access the standard library, provided
    that it doesn't violate sandbox restrictions. In particular, the interpreter will
    raise an exception whenever it tries to write to the filesystem, perform network
    connections, or import extension modules written in the C language. Another isolation
    mechanism we must be aware of that is provided by sandboxing, prevents an application
    from overusing an instance by raising an exception whenever the entire request/response
    cycle lasts more than 60 seconds.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时环境被沙箱化以提高安全性并提供在同一实例上运行的应用程序之间的隔离。解释器可以执行任何Python代码，导入其他模块，并访问标准库，前提是它不违反沙箱限制。特别是，每当解释器尝试写入文件系统、执行网络连接或导入用C语言编写的扩展模块时，它都会引发异常。我们还必须注意的另一种隔离机制是由沙箱提供的，它通过在请求/响应周期整个持续超过60秒时引发异常，防止应用程序过度使用实例。
- en: Thanks to sandboxing, the runtime can decide at any given time whether to run
    an application on one instance or many instances, with requests being spread across
    all of them depending on the traffic. This capability, together with load balancing
    and scheduler settings is what makes App Engine really scalable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了沙箱化，运行时可以在任何给定时间决定是否在一个实例或多个实例上运行应用程序，请求根据流量分布到所有这些实例上。这种能力，加上负载均衡和调度器设置，使得App
    Engine真正具有可扩展性。
- en: Users can easily tune an application's performance by increasing its responsiveness
    or optimizing costs with a simple and interactive administrative console. We can
    specify instance performance in terms of memory and CPU limits, the number of
    idle instances always ready to satisfy a request, and the number of instances
    dynamically started when the traffic increases. We can also specify the maximum
    amount of time in milliseconds we tolerate for a pending request and let App Engine
    adjust the settings automatically.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过简单的交互式管理控制台，通过提高应用的响应性或优化成本来轻松调整应用程序的性能。我们可以指定实例性能，以内存和 CPU 限制、始终准备满足请求的空闲实例数量以及流量增加时动态启动的实例数量来衡量。我们还可以指定我们容忍的挂起请求的最大时间（以毫秒为单位），并让
    App Engine 自动调整设置。
- en: The services
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: At first sight, restrictions imposed by the runtime environment might seem too
    restrictive. In the end, how can developers make something useful without being
    able to write data on disk, receive incoming network connections, fetch resources
    from external web applications, or start utility services such as a cache? This
    is why App Engine provides a set of higher-level APIs/services that can be used
    by developers to store and cache data or communicate over the Internet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，运行时环境施加的限制可能显得过于严格。最终，开发者如果不能在磁盘上写入数据、接收传入的网络连接、从外部 Web 应用程序获取资源或启动缓存等实用服务，他们如何能够创建有用的东西呢？这就是为什么
    App Engine 提供了一组高级 API/服务，开发者可以使用这些 API/服务来存储和缓存数据或通过互联网进行通信。
- en: Some of these services are provided by the Google Cloud Platform as standalone
    products and are smoothly integrated into App Engine, while some others are only
    available from within the runtime environment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些服务由 Google Cloud Platform 作为独立产品提供，并且可以无缝集成到 App Engine 中，而另一些服务则仅可在运行时环境中使用。
- en: 'The list of available services changes quite often as Google releases new APIs
    and tools; the following is a subset of tools we will use later in the book in
    addition to the Datastore, Google Cloud Endpoints, Google Cloud SQL, and Google
    Cloud Storage services we introduced earlier:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可用服务的列表经常变化，因为 Google 发布了新的 API 和工具；以下是我们将在本书后面部分使用的一些工具的子集，除了我们之前介绍的数据存储、Google
    Cloud Endpoints、Google Cloud SQL 和 Google Cloud Storage 服务外：
- en: '**Channel**: This API allows applications to create persistent connections
    with the clients and push data through such connections in real time instead of
    using polling strategies. Clients must use some JavaScript code to interact with
    the server. We will learn how to use Channels in [Chapter 6](ch06.html "Chapter 6. Using
    Channels to Implement a Real-time Application"), *Using Channels to Implement
    a Real-time Application*.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：此 API 允许应用程序与客户端建立持久连接，并通过这些连接实时推送数据，而不是使用轮询策略。客户端必须使用一些 JavaScript
    代码与服务器交互。我们将在第 6 章 [使用通道实现实时应用](ch06.html "第 6 章。使用通道实现实时应用") 中学习如何使用通道。'
- en: '**Datastore backup/restore**: At any given time, it''s possible to perform
    a backup of the entities contained in the Datastore or restore them from a previous
    backup; management operations are very easy as they can be performed interactively
    from the administrative console. We will see backup and restore procedures in
    detail in [Chapter 4](ch04.html "Chapter 4. Improving Application Performance"),
    *Improving Application Performance*.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储备份/还原**：在任何给定时间，都可以对 Datastore 中的实体执行备份或从以前的备份中还原它们；管理操作非常简单，因为它们可以从管理控制台交互式执行。我们将在第
    4 章 [提高应用性能](ch04.html "第 4 章。提高应用性能") 中详细了解备份和还原程序。'
- en: '**Images**: This API lets developers access and manipulate image data provided
    by the application or loaded from Google Cloud Storage. We can get information
    about the format, size, and colors and perform operations such as resizing, rotating,
    and cropping and we can convert images between different formats and apply some
    basic filters provided by the API. We will use some of the features provided by
    the Images API in [Chapter 3](ch03.html "Chapter 3. Storing and Processing Users''
    Data"), *Storing and Processing Users'' Data*.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**：此 API 允许开发者访问和操作由应用程序提供或从 Google Cloud Storage 加载的图像数据。我们可以获取有关格式、大小和颜色的信息，并执行诸如调整大小、旋转和裁剪等操作，我们还可以在
    API 提供的不同格式之间转换图像并应用一些基本过滤器。我们将在第 3 章 [存储和处理用户数据](ch03.html "第 3 章。存储和处理用户数据")
    中使用 Images API 提供的一些功能。'
- en: '**Mail**: This service allows applications to send e-mails on behalf of the
    administrators or users who are logged in with a Google Account and to receive
    e-mail messages sent to certain addresses and routed to the application. We will
    use both these features provided by the service in [Chapter 3](ch03.html "Chapter 3. Storing
    and Processing Users'' Data"), *Storing and Processing Users'' Data*.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邮件**: 此服务允许应用程序代表管理员或使用Google账户登录的用户发送电子邮件，并接收发送到某些地址并路由到应用程序的电子邮件消息。我们将在[第3章](ch03.html
    "第3章。存储和处理用户数据")*存储和处理用户数据*中使用服务提供的这两个功能。'
- en: '**Memcache**: This is a general-purpose, distributed memory caching system
    that can be used to dramatically improve application performance, serving frequently
    accessed data way faster than accessing a database or an API. We will see how
    to use Memcache in [Chapter 4](ch04.html "Chapter 4. Improving Application Performance"),
    *Improving Application Performance*.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Memcache**: 这是一个通用、分布式内存缓存系统，可用于显著提高应用程序性能，以比访问数据库或API更快的方式提供频繁访问的数据。我们将在[第4章](ch04.html
    "第4章。提高应用程序性能")*提高应用程序性能*中看到如何使用Memcache。'
- en: '**Modules**: These are used to split applications into logical components that
    can communicate and share their state with each other. They can be extremely useful
    as each of them can have different versions and performance and scaling settings,
    which provide developers with a great level of flexibility when tuning an application.
    We will see how to use Modules in [Chapter 4](ch04.html "Chapter 4. Improving
    Application Performance"), *Improving Application Performance*.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**: 这些用于将应用程序拆分为可以相互通信并共享其状态的逻辑组件。它们非常有用，因为每个模块都可以有不同的版本和性能以及扩展设置，这为开发者在调整应用程序时提供了极大的灵活性。我们将在[第4章](ch04.html
    "第4章。提高应用程序性能")*提高应用程序性能*中看到如何使用模块。'
- en: '**Scheduled tasks**: This is how App Engine implements the cron jobs. Developers
    can schedule a job to be executed at a defined date or at regular intervals. Schedules
    are defined in an English-like format: for example, `every Friday 20:00` is a
    valid schedule we can use to send weekly reports to our users. We will see how
    to use scheduled tasks in [Chapter 3](ch03.html "Chapter 3. Storing and Processing
    Users'' Data"), *Storing and Processing Users'' Data*.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划任务**: 这就是App Engine实现cron作业的方式。开发者可以安排一个作业在指定的日期或定期执行。计划以类似英语的格式定义：例如，`每周五20:00`是一个有效的计划，我们可以用它向用户发送周报。我们将在[第3章](ch03.html
    "第3章。存储和处理用户数据")*存储和处理用户数据*中看到如何使用计划任务。'
- en: '**Task Queue**: As mentioned earlier, the entire request/response cycle of
    an application running on App Engine must last at most 60 seconds, making it impossible
    to perform long operations. This is why the Task Queue API exists––it can perform
    work outside the user request so that long operations can be executed later in
    background with 10 minutes to finish. We will see how to use a task queue in [Chapter
    3](ch03.html "Chapter 3. Storing and Processing Users'' Data"), *Storing and Processing
    Users'' Data*.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务队列**: 如前所述，运行在App Engine上的应用程序的整个请求/响应周期最长为60秒，这使得执行长时间操作成为不可能。这就是为什么存在Task
    Queue API的原因——它可以在用户请求之外执行工作，这样长时间的操作就可以在后台稍后执行，并在10分钟内完成。我们将在[第3章](ch03.html
    "第3章。存储和处理用户数据")*存储和处理用户数据*中看到如何使用任务队列。'
- en: '**URL Fetch**: As we already know, the runtime environment prevents our application
    from performing any kind of network connection but accessing external resources
    through HTTP requests is a common requirement for a web application. This limitation
    can be overcome using the URL Fetch API to issue HTTP or HTTPS requests and retrieve
    a response in a scalable and efficient manner.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL Fetch**: 正如我们所知，运行时环境阻止我们的应用程序执行任何类型的网络连接，但通过HTTP请求访问外部资源是Web应用程序的一个常见需求。这种限制可以通过使用URL
    Fetch API来发出HTTP或HTTPS请求，并以可扩展和高效的方式检索响应来克服。'
- en: '**Users**: We can authenticate users within our applications using Google Accounts,
    accounts in a Google Apps domain, or through OpenID identifiers. Using the Users
    API our application can determine whether a user is logged in and redirect them
    to the login page or access their e-mail otherwise. Using this API, developers
    can delegate to Google or to the OpenID provider the responsibility of creating
    accounts and verifying the user''s data.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：我们可以在应用程序中使用 Google 帐户、Google Apps 域中的帐户或通过 OpenID 标识来验证用户。使用 Users
    API，我们的应用程序可以确定用户是否已登录，并将他们重定向到登录页面或访问他们的电子邮件。使用此 API，开发者可以将创建帐户和验证用户数据的责任委托给
    Google 或 OpenID 提供商。'
- en: For more information on the tools and services provided by Google that we can
    use from within the App Engine environment, refer to [https://developers.google.com/appengine/features/](https://developers.google.com/appengine/features/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有关我们可以在 App Engine 环境中使用并由 Google 提供的工具和服务的更多信息，请参阅 [https://developers.google.com/appengine/features/](https://developers.google.com/appengine/features/)。
- en: Making our first Python application
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作我们的第一个 Python 应用程序
- en: We have now have an idea of the features Google Cloud Platform can provide us
    with and we are ready to put App Engine in action, but before we can start writing
    some code, we need to set up our workstation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了 Google Cloud Platform 可以为我们提供哪些功能，并且我们准备将 App Engine付诸实践，但在我们开始编写代码之前，我们需要设置我们的工作站。
- en: Download and installation
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载和安装
- en: To get started, we need to install the Google App Engine SDK for Python for
    the platform of our choice. The SDK contains all the libraries needed to develop
    an application and a set of tools to run and test the application in the local
    environment and deploy it in the production servers. On some platforms, administrative
    tasks can be performed through a GUI, the Google App Engine Launcher, on other
    platforms we can use a comprehensive set of command line tools. We will see Google
    App Engine Launcher in detail later in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要为我们的选择平台安装 Google App Engine SDK for Python。SDK 包含开发应用程序所需的所有库，以及一套在本地环境中运行和测试应用程序以及将其部署到生产服务器的工具。在某些平台上，可以通过图形用户界面（Google
    App Engine Launcher）执行管理任务，在其他平台上，我们可以使用一套全面的命令行工具。我们将在本章后面详细讨论 Google App Engine
    Launcher。
- en: 'Before installing the SDK, we have to check whether a working installation
    of Python 2.7 (version 2.7.8 is the latest at the time of writing this book) is
    available on our system; we need this specific version of Python because, with
    2.5 deprecated now, it is the only version supported by the App Engine platform.
    If we are using Linux or Mac OS X, we can check the Python version from the terminal
    that issues the command (notice the capital letter `V`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 SDK 之前，我们必须检查我们的系统上是否有可用的 Python 2.7（在撰写本书时，2.7.8 是最新版本）的安装；我们需要这个特定的 Python
    版本，因为 2.5 已经弃用，它是 App Engine 平台唯一支持的版本。如果我们使用 Linux 或 Mac OS X，我们可以从发出命令的终端中检查
    Python 版本（注意大写字母 `V`）：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output should look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果应如下所示：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we are on Windows, we can just ensure the right version of Python is listed
    in the **Programs** section within the **Control Panel**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Windows 上，我们只需确保在 **控制面板** 的 **程序** 部分列出了正确的 Python 版本即可。
- en: 'The official App Engine download page contains links for all the available
    SDKs. The following link points directly to the Python version: [https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python](https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的 App Engine 下载页面包含所有可用 SDK 的链接。以下链接直接指向 Python 版本：[https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python](https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python)。
- en: We have to choose the right package for our platform, download the installer,
    and proceed with the installation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为我们的平台选择正确的软件包，下载安装程序，然后继续安装。
- en: Installing on Windows
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上安装
- en: To install the SDK on Windows we have to download the `.msi` file from the App
    Engine download page, double-click it to launch the installation wizard, and follow
    the instructions on the screen. Once the install is complete, a shortcut to Google
    App Engine Launcher will be placed on the desktop as well as an item within the
    **Start** menu. The Windows version of the SDK does not provide any command-line
    tool, so we will always use Launcher to manage our applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上安装 SDK，我们必须从 App Engine 下载页面下载 `.msi` 文件，双击它以启动安装向导，并遵循屏幕上的说明。安装完成后，Google
    App Engine 启动器的快捷方式将被放置在桌面上，以及 **开始** 菜单中的一个项目。SDK 的 Windows 版本不提供任何命令行工具，因此我们将始终使用启动器来管理我们的应用程序。
- en: Installing on Mac OS X
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Mac OS X 上安装
- en: To install the SDK on Mac OS X, we have to download the `.dmg` file from the
    App Engine download page, double-click it to open the disk image, and drag the
    App Engine icon into the `Applications` folder. It is convenient to keep a shortcut
    to Launcher in our Dock; to do so, we just have to just drag the App Engine icon
    again from the `Applications` folder to the dock. The command-line tools will
    also be installed and during the first execution of Launcher, a pop-up dialog
    will prompt us as to whether we want to create the symlinks needed to make the
    tools available system-wide, so they can be executed from any terminal window
    without further configuration.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Mac OS X 上安装 SDK，我们必须从 App Engine 下载页面下载 `.dmg` 文件，双击它以打开磁盘映像，然后将 App Engine
    图标拖到 `Applications` 文件夹中。在 Dock 中保留启动器的快捷方式很方便；为此，我们只需再次将 App Engine 图标从 `Applications`
    文件夹拖到 Dock 中。命令行工具也将被安装，并在启动器首次执行时，会弹出一个对话框询问我们是否想要创建必要的符号链接，以便使工具在系统范围内可用，这样就可以在任何终端窗口中执行，而无需进一步配置。
- en: Installing on Linux
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装
- en: To install the SDK on Linux and more generally on POSIX-compliant systems, we
    have to download the `.zip` file from the App Engine download page and extract
    its contents in a directory of our choice. The archive contains a folder named
    `google_appengine` that contains the runtime and the command-line tools, and we
    have to add it to our shell's `PATH` environment variable to make the tools available
    from within any terminal. The Linux version of the SDK does not include Launcher.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 和更广泛的 POSIX 兼容系统上安装 SDK，我们必须从 App Engine 下载页面下载 `.zip` 文件，并将其内容提取到我们选择的目录中。该存档包含一个名为
    `google_appengine` 的文件夹，其中包含运行时和命令行工具，我们必须将其添加到我们的 shell 的 `PATH` 环境变量中，以便在任何终端中都可以使用这些工具。SDK
    的 Linux 版本不包括启动器。
- en: App Engine Launcher
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: App Engine 启动器
- en: The Windows and OS X versions of the SDK ships with a graphical user interface
    tool called Launcher that we can use to perform administrative tasks such as creating
    and managing multiple applications.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 的 Windows 和 OS X 版本附带了一个名为启动器的图形用户界面工具，我们可以使用它来执行创建和管理多个应用程序等管理任务。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Launcher is a very handy tool but bear in mind that while every single task
    we can accomplish through Launcher can be performed by command-line tools as well,
    the contrary isn't true. There are tasks that can be performed only from the command
    line using the proper tools as we will see later in the book.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 启动器是一个非常方便的工具，但请记住，虽然我们可以通过启动器完成的每个任务都可以通过命令行工具执行，但反之则不然。有些任务只能通过使用适当的工具从命令行执行，正如我们将在本书后面看到的那样。
- en: 'The following screenshot shows the Launcher window in OS X:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 OS X 中的启动器窗口：
- en: '![App Engine Launcher](img/8194OS_01_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![App Engine 启动器](img/8194OS_01_02.jpg)'
- en: 'We can see the Launcher in Windows in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们可以看到 Windows 中的启动器：
- en: '![App Engine Launcher](img/8194OS_01_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![App Engine 启动器](img/8194OS_01_03.jpg)'
- en: Before we start using the Launcher it's important to check whether it is using
    the right Python version. This is very important if we have more than one Python
    installation in our system. To check the Python version used by Launcher and to
    change it, we can open the **Preferences...** dialog by clicking the appropriate
    menu depending on our platform and set the Python path value. In the same dialog
    we can specify which text editor Launcher will open by default when we need to
    edit application files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用启动器之前，检查它是否使用正确的 Python 版本非常重要。如果我们系统中安装了多个 Python，这一点尤为重要。要检查启动器使用的 Python
    版本并更改它，我们可以根据我们的平台点击相应的菜单打开 **首选项...** 对话框，并设置 Python 路径值。在同一个对话框中，我们可以指定当需要编辑应用程序文件时，启动器将默认打开哪个文本编辑器。
- en: To create a new application we can click **New Application** in the **File**
    menu or click the button with a plus sign icon in the bottom-left corner of the
    Launcher window. Launcher will prompt for the application name and the path to
    the folder that will contain all the project files; once created, the application
    will be listed in the main window of Launcher.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新应用程序，我们可以在**文件**菜单中点击**新建应用程序**或点击启动器窗口左下角的带有加号图标按钮。启动器将提示输入应用程序名称和包含所有项目文件的文件夹路径；一旦创建，应用程序将列在启动器的主窗口中。
- en: We can start the local development server by clicking the **Run** button on
    the Launcher toolbar or clicking **Run** in the **Control** menu. Once the server
    is started, we can stop it by clicking on the **Stop** button or the **Stop**
    entry in the **Control** menu. Clicking the **Browse** button or the **Browse**
    entry in the **Control** menu opens the default browser at the home page of the
    selected application. To browse the logs produced by the development server, we
    can open the **Log Console** window by clicking the **Logs** button on the toolbar
    or the **Logs** entry in the **Control** menu. The **SDK Console** button on the
    toolbar and the **SDK Console** action on the **Control** menu will open the default
    browser at the URL that serves the Developer Console, a built-in application to
    interact with the local development server, which we will explore in detail later
    in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在启动器工具栏上点击**运行**按钮或在**控制**菜单中点击**运行**来启动本地开发服务器。一旦服务器启动，我们可以通过点击**停止**按钮或在**控制**菜单中的**停止**选项来停止它。点击**浏览**按钮或在**控制**菜单中的**浏览**选项将在默认浏览器中打开所选应用程序的主页。要浏览开发服务器生成的日志，我们可以通过点击工具栏上的**日志**按钮或在**控制**菜单中的**日志**选项来打开**日志控制台**窗口。工具栏上的**SDK控制台**按钮和**控制**菜单中的**SDK控制台**操作将在默认浏览器中打开服务于开发者控制台的URL，这是一个与本地开发服务器交互的内置应用程序，我们将在本章后面详细探讨。
- en: The **Edit** button will open the configuration file for the selected application
    in an external text editor, maybe the one we specified in the **Preferences...**
    dialog; the same happens when we click the **Open in External Editor** action
    in the **Edit** menu.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**编辑**按钮将在外部文本编辑器中打开所选应用程序的配置文件，可能是我们在**首选项...**对话框中指定的那个；当我们点击**编辑**菜单中的**在外部编辑器中打开**操作时，也会发生同样的事情。'
- en: To deploy and upload the selected application to App Engine we can click the
    **Deploy** button on the toolbar or click the **Deploy** action in the **Control**
    menu. The **Dashboard** button on the toolbar and the **Dashboard** action in
    the **Control** menu will open the default browser at the URL of App Engine Administrative
    Console.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署和上传所选应用程序到App Engine，我们可以在工具栏上点击**部署**按钮或在**控制**菜单中点击**部署**操作。工具栏上的**仪表板**按钮和**控制**菜单中的**仪表板**操作将在默认浏览器中打开App
    Engine管理控制台的URL。
- en: Using Launcher we can set additional flags for the local development server
    and customize some parameters such as the TCP port number to which listens. To
    do so we have to click the **Application Settings...** entry in the **Edit** menu
    and make the desired adjustments in the settings dialog.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用启动器，我们可以为本地开发服务器设置额外的标志并自定义一些参数，例如监听的TCP端口号。为此，我们必须点击**编辑**菜单中的**应用程序设置...**选项并在设置对话框中进行所需的调整。
- en: Launcher can also handle existing applications created from scratch through
    the command line or checked out from an external repository. To add an existing
    application to the Launcher, we can click the **Add Existing Application...**
    entry in the **File** menu and specify the application path.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 启动器还可以处理从头开始通过命令行创建或从外部仓库签出的现有应用程序。要将现有应用程序添加到启动器，我们可以在**文件**菜单中点击**添加现有应用程序...**选项并指定应用程序路径。
- en: Creating the application
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: The first step to create an application is pick a name for it. According to
    the tradition we're going to write an application that will print **"Hello, World!"**
    so we can choose `helloword` as the application name. We already know how to create
    an application from Launcher, the alternative is to do it manually from the command
    line.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序的第一步是为它选择一个名称。根据传统，我们将编写一个打印**"Hello, World!"**的应用程序，因此我们可以选择`helloword`作为应用程序名称。我们已经知道如何从启动器创建应用程序，另一种选择是手动从命令行进行操作。
- en: At the simplest, a working Python application consists of a folder called application
    root that contains an `app.yaml` configuration file and a Python module with the
    code needed to handle HTTP requests. When we create an application within Launcher,
    it takes care of generating those files and the `root` folder for us, but let's
    see how can we can accomplish the same result from the command line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，一个工作的 Python 应用程序由一个名为应用程序根的文件夹组成，该文件夹包含一个 `app.yaml` 配置文件和一个包含处理 HTTP
    请求所需代码的 Python 模块。当我们通过 Launcher 创建应用程序时，它会为我们生成这些文件和 `root` 文件夹，但让我们看看我们如何可以从命令行完成相同的结果。
- en: The app.yaml configuration file
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.yaml 配置文件
- en: 'When we start creating the `root` folder, it doesn''t matter how we name it
    but to be consistent with Launcher we can use the application''s name:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始创建 `root` 文件夹时，我们如何命名并不重要，但为了与 Launcher 保持一致，我们可以使用应用程序的名称：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then create an `app.yaml` file that contains the following `YAML` code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `app.yaml` 文件，其中包含以下 `YAML` 代码：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**YAML** (**a recursive acronym for YAML Ain''t Markup Language**) is a human-readable
    serialization format that is suitable for configuration files that have to be
    accessed and manipulated both from users and programmatically.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAML**（YAML Ain''t Markup Language 的递归缩写）是一种适合于既需要用户访问又需要程序访问和操作配置文件的易于阅读的序列化格式。'
- en: 'The first section of the previous code defines some setup parameters for the
    application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的第一个部分定义了一些应用程序的设置参数：
- en: '**The** `application` **parameter**: This is the application name; later in
    the chapter, we''ll see how important it is.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序参数**：这是应用程序名称；在本书的后续部分，我们将看到它有多么重要。'
- en: '**The** `version` **parameter**: This is a string that specifies the version
    of the application. App Engine retains a copy of each version deployed and we
    can run them selectively, a very useful feature for testing an application before
    making it public.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本参数**：这是一个指定应用程序版本的字符串。App Engine 保留每个部署版本的副本，并且我们可以选择性地运行它们，这是一个在公开之前测试应用程序的非常有用的功能。'
- en: '**The** `runtime` **parameter**: At the time of writing this book, Python 27
    is the only runtime available for newly created applications as Python 25 was
    deprecated.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时参数**：在撰写本书时，Python 2.7 是为新创建的应用程序提供的唯一运行时，因为 Python 2.5 已被弃用。'
- en: '**The** `api_version` **parameter**: This is the version of the API for the
    current runtime environment. At the time writing this, 1 is the only API version
    available for the Python 27 runtime.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 版本参数**：这是当前运行时环境的 API 版本。在撰写本书时，1 是 Python 2.7 运行时唯一可用的 API 版本。'
- en: '**The** `threadsafe` **parameter**: This specifies whether our application
    can handle requests concurrently in separate threads or not.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程安全参数**：这指定了我们的应用程序是否可以处理并发请求的单独线程。'
- en: 'The next section of the `app.yaml` file lists the URLs we want to match in
    the form of a regular expression; the `script` property specifies the handler
    for each URL. A handler is a procedure App Engine invokes to provide a response
    when an application receives a request. There are two types of handlers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.yaml` 文件的下一部分列出了我们想要匹配的 URL，形式为正则表达式；`script` 属性指定了每个 URL 的处理器。处理器是 App
    Engine 调用以在应用程序收到请求时提供响应的程序。有两种类型的处理器：'
- en: '**The** `script` **handlers**: These handlers run the Python code provided
    by the application'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本处理器**：这些处理器运行应用程序提供的 Python 代码'
- en: '**The** `static file` **handlers**: These handlers return the content of a
    static resource such as an image or a file that contain the JavaScript code'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态文件处理器**：这些处理器返回静态资源的内容，例如图像或包含 JavaScript 代码的文件'
- en: 'In this case, we are using a `script` handler, a Python callable addressed
    with a dot notation import string: App Engine will match any URL and invoke the
    `app` object contained in the `main` module.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了一个 `script` 处理器，一个使用点符号导入的 Python 可调用对象 `string`：App Engine 将匹配任何
    URL 并调用 `main` 模块中包含的 `app` 对象。
- en: The final section lists the name and version of third-party modules provided
    by App Engine we want to use from our application, and in this case we only need
    the latest version of the webapp2 web framework. We might wonder why we need something
    complex such as a web framework to simply print a **"Hello, World!"** message,
    but as we already know, our handler must implement a WSGI-compliant interface
    and this is exactly one of the features provided by webapp2\. We will see how
    to use it in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个部分列出了我们想要从App Engine应用程序中使用的第三方模块的名称和版本，在这种情况下，我们只需要webapp2网络框架的最新版本。我们可能会想知道为什么我们需要像网络框架这样复杂的东西来简单地打印一个**"Hello,
    World!"**消息，但正如我们已经知道的，我们的处理程序必须实现一个符合WSGI接口，这正是webapp2提供的一个功能。我们将在下一节中看到如何使用它。
- en: The main.py application script
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`main.py`应用程序脚本'
- en: 'Now that the application is configured, we need to provide logic, so we create
    a file named `main.py` in the application root folder that will contain the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已经配置好了，我们需要提供逻辑，因此我们在应用程序根目录中创建一个名为`main.py`的文件，该文件将包含以下内容：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the first line of the previous code we import the `webapp2` package into
    our code, and then we proceed to define a class named `MainHandler` that is derived
    from the `RequestHandler` class provided by the framework. The base class implements
    a behavior that makes it very easy to implement a handler for HTTP requests; all
    we have to do is to define a method named after the HTTP action we want to handle.
    In this case, we implement the `get()` method that will be automatically invoked
    whenever the application receives a request of the type `GET`. The `RequestHandler`
    class also provides a `self.response` property we can use to access the response
    object that will be returned to the application server. This property is a file-like
    object that supports a `write()` method we can use to add content to the body
    of the HTTP response; in this case we write a string inside the response body
    with the default content type `text/html` so that it will be shown inside the
    browser.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码的第一行中，我们将`webapp2`包导入到我们的代码中，然后继续定义一个名为`MainHandler`的类，该类是从框架提供的`RequestHandler`类派生出来的。基类实现了一种行为，使得实现HTTP请求的处理程序变得非常容易；我们只需要定义一个以我们想要处理的HTTP操作命名的函数。在这种情况下，我们实现了`get()`方法，该方法将在应用程序接收到类型为`GET`的请求时自动调用。`RequestHandler`类还提供了一个`self.response`属性，我们可以使用它来访问将返回给应用程序服务器的响应对象。这个属性是一个类似文件的对象，它支持一个`write()`方法，我们可以使用它向HTTP响应体中添加内容；在这种情况下，我们在响应体中写入一个字符串，使用默认的内容类型`text/html`，以便在浏览器中显示。
- en: 'Right after the `MainHandler` class definition we create the `app` object,
    which is an instance of the `WSGIApplication` class provided by webapp2 that implements
    the WSGI-compliant callable entry point we specified in `app.yaml` with the import
    string `main.app`. We pass two parameters to the class constructor, a list of
    URL patterns, and a Boolean flag stating whether the application should run in
    debug mode or not. URL patterns are tuples that contain two elements: a regular
    expression that matches requested URLs and a class object derived from `webapp2.RequestHandler`
    class that will be instantiated to handle requests. URL patterns are processed
    one by one in the order they are in the list until one matches and the corresponding
    handler is called.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainHandler`类定义之后，我们创建了`app`对象，这是一个由webapp2提供的`WSGIApplication`类的实例，该类实现了我们在`app.yaml`中指定的符合WSGI的调用入口。我们向类构造函数传递两个参数，一个是URL模式列表，另一个是一个布尔标志，表示应用程序是否应该以调试模式运行。URL模式是包含两个元素的元组：一个匹配请求URL的正则表达式和一个从`webapp2.RequestHandler`类派生出来的类对象，该对象将被实例化以处理请求。URL模式按列表中的顺序逐个处理，直到匹配并调用相应的处理程序。
- en: As we may notice, URL mappings take place twice—firstly in the `app.yaml` file,
    where a URL is routed to a WSGI compatible application in our code and then in
    the `WSGIApplication` class instance, where an URL is routed to a request handler
    object. We can freely choose how to use these mappings, that is either route all
    URLs in the `app.yaml` file to a single webapp2 application where they are dispatched
    to handlers or to different URLs to different, smaller webapp2 applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所注意到的，URL映射发生了两次——首先是在`app.yaml`文件中，将一个URL路由到我们代码中的符合WSGI的应用程序，然后在`WSGIApplication`类实例中，将一个URL路由到请求处理程序对象。我们可以自由选择如何使用这些映射，即要么将`app.yaml`文件中的所有URL路由到单个webapp2应用程序，在那里它们被分发到处理程序，要么将不同的URL路由到不同的、更小的webapp2应用程序。
- en: Running the development server
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行开发服务器
- en: 'The App Engine SDK provides an extremely useful tool called **development server**
    that runs on our local system emulating the runtime environment we will find in
    production. This way, we can test our applications locally as we write them. We
    already know how to start the development server from Launcher. To launch it from
    the command line instead, we run the `dev_appserver.py` command tool passing the
    root folder of the application we want to execute as an argument. For example,
    if we''re already inside the root folder of our `helloworld` application, to start
    the server, we can run this command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine SDK提供了一个极其有用的工具，称为**开发服务器**，它在我们本地系统上运行，模拟我们在生产环境中找到的运行环境。这样，我们可以在编写应用程序的同时在本地测试它们。我们已经知道如何从启动器启动开发服务器。要从命令行启动它，我们运行`dev_appserver.py`命令工具，并将我们想要执行的应用程序根目录作为参数传递。例如，如果我们已经位于`helloworld`应用程序的根目录中，要启动服务器，我们可以运行以下命令：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The development server will print some status information on the shell and will
    then start listen at the local host to the default TCP ports 8000 and 8080, serving
    the admin console and the application respectively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 开发服务器将在shell上打印一些状态信息，然后开始在本地的默认TCP端口8000和8080上监听，分别服务于管理控制台和应用程序。
- en: While the server is running, we can open a browser, point it at `http://localhost:8080`
    and see our first web application serving content.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器正在运行时，我们可以打开浏览器，将其指向`http://localhost:8080`，并看到我们的第一个Web应用程序正在提供内容。
- en: 'The following screenshot shows the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![Running the development server](img/8194OS_01_04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![运行开发服务器](img/8194OS_01_04.jpg)'
- en: If we are using Launcher, we can simply press the **Browse** button and the
    browser will be opened automatically at the right URL.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用启动器，我们可以简单地按下**浏览**按钮，浏览器会自动在正确的URL打开。
- en: 'The development server automatically restarts application instances whenever
    it detects that some content on the application root folder has changed. For example,
    while the server is running we can try to change the Python code that alters the
    string we write in the response body:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开发服务器会在检测到应用程序根目录中的某些内容发生变化时自动重启应用程序实例。例如，当服务器正在运行时，我们可以尝试更改Python代码，该代码会改变我们写入响应体的字符串：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After saving the file, we can refresh the browser and immediately see the changes
    without reloading the server, as shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，我们可以刷新浏览器，立即看到更改，而无需重新加载服务器，如下面的截图所示：
- en: '![Running the development server](img/8194OS_01_05.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![运行开发服务器](img/8194OS_01_05.jpg)'
- en: We can now move our application to a production server on App Engine and make
    it available through the Internet.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将应用程序移动到App Engine的生产服务器上，并通过互联网使其可用。
- en: Uploading the application to App Engine
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传应用程序到App Engine
- en: Every application running on App Engine is uniquely identified by its name within
    the Google Cloud Platform. That is why sometimes we find parts of the documentation
    and tools referring to that as application ID. When working on a local system,
    we can safely pick any name we want for an application as the local server does
    not enforce any control on the application ID; but, if we want to deploy an application
    in production, the application ID must be validated and registered through App
    Engine Admin Console.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在App Engine上运行的应用程序通过其在Google Cloud Platform中的名称唯一标识。这就是为什么有时我们在文档和工具中看到部分内容将其称为应用程序ID。当在本地系统上工作时，我们可以安全地为应用程序选择任何我们想要的名称，因为本地服务器不对应用程序ID施加任何控制；但是，如果我们想在生产中部署应用程序，应用程序ID必须通过App
    Engine管理控制台进行验证和注册。
- en: Admin Console can be accessed at [https://appengine.google.com/](https://appengine.google.com/)
    and log in with a valid Google user account or a Google apps account for custom
    domains. If we are using Application Launcher, clicking the **Dashboard** button
    will open the browser at the right address for us. Once logged in, we can click
    the **Create Application** button to access the application creation page. We
    have to provide an application ID (the console will tell us whether it is valid
    and available) and a title for the application and we're done. For now, we can
    accept the default values for the remaining options; clicking on **Create Application**
    again will finally register the application's ID for us.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 管理控制台可以通过 [https://appengine.google.com/](https://appengine.google.com/) 访问，并使用有效的
    Google 用户账户或 Google apps 账户（用于自定义域名）登录。如果我们使用应用程序启动器，点击**仪表板**按钮将为我们打开正确的浏览器地址。一旦登录，我们可以点击**创建应用程序**按钮以访问应用程序创建页面。我们必须提供一个应用程序
    ID（控制台将告诉我们它是否有效且可用），以及应用程序的标题，然后我们就完成了。目前，我们可以接受剩余选项的默认值；再次点击**创建应用程序**按钮将最终为我们注册应用程序的
    ID。
- en: 'Now we have to change the dummy application ID we provided for our application
    with the one registered on App Engine. Open the `app.yaml` configuration file
    and change the `application` property accordingly:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将为我们应用程序提供的虚拟应用程序 ID 更改为在 App Engine 上注册的 ID。打开 `app.yaml` 配置文件并相应地更改
    `application` 属性：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are now ready to deploy the application on App Engine. If we are using Application
    Launcher, all we have to do is click on the **Deploy** button in the toolbar.
    Launcher will ask for our Google credentials and then the log window will open
    showing the deployment status. If everything went fine the last line shown should
    be something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好在 App Engine 上部署应用程序。如果我们使用应用程序启动器，我们只需在工具栏中点击**部署**按钮。启动器将要求我们提供 Google
    凭据，然后日志窗口将打开，显示部署状态。如果一切顺利，最后显示的行应该是这样的：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Deploying from the command line is just as easy; from the application root
    directory, we issue the command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行部署同样简单；从应用程序根目录，我们发出以下命令：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will be prompted for our Google account credentials, and then the deployment
    will proceed automatically.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将被提示输入我们的 Google 账户凭据，然后部署将自动进行。
- en: Every App Engine application running in production can be accessed via `http://the_registered_application_ID.appspot.com/`,
    so we can tell whether the application is actually working by accessing this URL
    from a browser and checking whether the output is the same as that produced by
    the local development server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在生产中运行的 App Engine 应用程序都可以通过 `http://the_registered_application_ID.appspot.com/`
    访问，因此我们可以通过从浏览器访问此 URL 并检查输出是否与本地开发服务器产生的输出相同来判断应用程序是否实际工作。
- en: 'Google App Engine allow us to serve content over **HTTPS** (**HTTP Secure**)
    connections on top of the **Secure Sockets Layer** (**SSL**) protocol, which means
    that data transferred from and to the server is encrypted. When using the `appspot.com`
    domain, this option is free of charge. To enable secure connections between clients
    and the App Engine server, all we have to do is add the `secure` option to the
    URLs listed in the `app.yaml` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Google App Engine 允许我们在 **HTTPS**（**HTTP Secure**）协议之上通过 **Secure Sockets Layer**（**SSL**）协议提供内容服务，这意味着从服务器传输到服务器和从服务器传输到服务器的数据是加密的。当使用
    `appspot.com` 域名时，此选项免费。为了在客户端和 App Engine 服务器之间启用安全连接，我们只需将 `secure` 选项添加到 `app.yaml`
    文件中列出的 URL：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On the local development server we will still use regular HTTP connections,
    but in production we will access `https://the_registered_application_ID.appspot.com/`
    in a secure manner over HTTPS connections.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发服务器上，我们仍然会使用常规的 HTTP 连接，但在生产环境中，我们将通过 HTTPS 连接以安全的方式访问 `https://the_registered_application_ID.appspot.com/`。
- en: If we want to access the application over HTTPS through a custom domain instead,
    such as `example.com`, we have to configure App Engine so that the platform can
    use our certificates by following the instructions at [https://cloud.google.com/appengine/docs/ssl](https://cloud.google.com/appengine/docs/ssl).
    This service has a fee and we will be charged monthly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过自定义域名（如 `example.com`）而不是 HTTPS 访问应用程序，我们必须按照 [https://cloud.google.com/appengine/docs/ssl](https://cloud.google.com/appengine/docs/ssl)
    中的说明配置 App Engine，以便平台可以使用我们的证书。此服务需要付费，并且我们将按月收费。
- en: Google Developer Console
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google 开发者控制台
- en: Before Google Cloud Platform was released, Admin Console was the only tool available
    to developers to perform administrative and monitoring tasks on App Engine applications.
    Admin Console provides a lot of functionalities and it's still powerful enough
    to manage App Engine applications of any size. However, it's not the right tool
    if we extensively use the new range of services offered by the Google Cloud Platform,
    especially if we store data on Google Cloud Storage or our database server is
    Google Cloud SQL; in this case, to collect information such as billing data and
    usage history we have to interact with other tools.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Cloud Platform发布之前，管理员控制台是开发者可用的唯一工具，用于在App Engine应用程序上执行管理和监控任务。管理员控制台提供了许多功能，并且仍然足够强大，可以管理任何规模的App
    Engine应用程序。然而，如果我们广泛使用Google Cloud Platform提供的新服务系列，特别是如果我们存储数据在Google Cloud Storage或我们的数据库服务器是Google
    Cloud SQL的情况下，它就不是合适的工具；在这种情况下，为了收集诸如账单数据和使用历史等信息，我们必须与其他工具交互。
- en: Recently Google released **Developer Console**, a comprehensive tool to manage
    and monitor services, resources, authentication, and billing information for Google
    Cloud Platform, including App Engine applications. We can access the Developer
    Console at [https://console.developers.google.com/](https://console.developers.google.com/)
    and log in with a valid Google user account or a Google apps account for custom
    domains.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Google发布了**开发者控制台**，这是一个综合性的工具，用于管理和监控Google Cloud Platform的服务、资源、身份验证和账单信息，包括App
    Engine应用程序。我们可以在[https://console.developers.google.com/](https://console.developers.google.com/)访问开发者控制台，并使用有效的Google用户账户或自定义域的Google
    apps账户登录。
- en: 'To emphasize the concept that developers can combine various pieces coming
    from Google''s cloud infrastructure to build complex applications, Developer Console
    introduces the notion of cloud projects. A project is a set of functionally grouped
    cloud products that share the same team and billing information. At the core of
    a project there is always an App Engine application: every time we create a project,
    an App Engine application pops up in Admin Console. Simultaneously, when we register
    an application in Admin Console, a corresponding project is created and listed
    in Developer Console. Every project is identified by a descriptive name, which
    is a unique identifier called project ID that is also the ID of the related App
    Engine application and another unique identifier that is automatically generated
    called project number.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调开发者可以将来自Google云基础设施的各个部分组合起来构建复杂应用程序的概念，开发者控制台引入了云项目的概念。项目是一组功能分组云产品，它们共享相同的团队和账单信息。项目的核心总是一个App
    Engine应用程序：每次我们创建一个项目时，一个App Engine应用程序就会在管理员控制台中弹出。同时，当我们向管理员控制台注册应用程序时，一个相应的项目就会被创建并在开发者控制台中列出。每个项目都有一个描述性的名称，这是一个唯一的标识符，称为项目ID，它也是相关App
    Engine应用程序的ID，以及另一个自动生成的唯一标识符，称为项目编号。
- en: 'Beside creating and deleting projects, the developer console also let us do
    the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建和删除项目之外，开发者控制台还允许我们执行以下操作：
- en: '**Manage project members**: When we create a project we become the owner of
    that project. As owners, we can add or remove members and set their permissions.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理项目成员**：当我们创建一个项目时，我们成为该项目的所有者。作为所有者，我们可以添加或删除成员并设置他们的权限。'
- en: '**Manage APIs**: We can add or remove API services provided by Google Cloud
    Platform, set up billing, and monitor data.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理API**：我们可以添加或删除由Google Cloud Platform提供的API服务，设置账单，并监控数据。'
- en: '**Manage applications identity**: We can tie requests to specific projects
    so that we can monitor specific traffic and billing and enforce quotas if needed.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理应用程序身份**：我们可以将请求与特定项目关联起来，这样我们就可以监控特定的流量和账单，并在需要时实施配额。'
- en: '**Manage applications security**: We can set up OAuth2 for our applications
    or provide API keys to authorize requests.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理应用程序安全**：我们可以为我们的应用程序设置OAuth2或提供API密钥以授权请求。'
- en: '**Filter and cap services**: We can allow requests coming only from authorized
    hosts or IP addresses and limit the amount of requests allowed for each user every
    second or every day for all the users.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤和限制服务**：我们可以允许只有来自授权主机或IP地址的请求，并限制每个用户每秒或每天允许的请求数量。'
- en: For every service of Google Cloud Platform, Developer Console provides us with
    handy tools to perform maintenance operations through the web interface. For example,
    we can add or remove Google Cloud SQL instances, perform queries on Google Cloud
    Datastore, browse and manipulate the content of Google Cloud Storage, and manage
    virtual machines running on Google Compute Engine. We will use several parts of
    Developer Console later in the book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Google Cloud Platform的每一项服务，开发者控制台都为我们提供了通过网页界面执行维护操作的便捷工具。例如，我们可以添加或删除Google
    Cloud SQL实例，对Google Cloud Datastore进行查询，浏览和操作Google Cloud Storage的内容，以及管理在Google
    Compute Engine上运行的虚拟机。本书后面我们将使用开发者控制台的一些部分。
- en: Development Console
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者控制台
- en: When we are on the local development server we can still access a tool to browse
    and manage Datastore, task queues, cron jobs, and other App Engine emulated components
    running locally. This tool is called **Development Console** and is accessible
    at `http://localhost:8000` when the local server is active.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本地开发服务器上时，我们仍然可以访问一个工具来浏览和管理Datastore、任务队列、cron作业以及本地运行的App Engine模拟组件。这个工具被称为**开发者控制台**，当本地服务器处于活动状态时，可以通过`http://localhost:8000`访问。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter we have learned what Google Cloud Platform is, the tools and
    services it provides, and how we can use them to develop and run fast and scalable
    web applications written in Python.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Google Cloud Platform是什么，它提供哪些工具和服务，以及我们如何使用它们来开发和运行用Python编写的快速和可扩展的Web应用程序。
- en: We explored what tools we need to start developing with Python for the App Engine
    platform, how to run an application locally with the development server, and how
    fast and easy it is to upload it in a production server, ready to be served through
    the Internet.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了开始使用Python为App Engine平台开发所需的工具，如何使用开发服务器本地运行应用程序，以及将其上传到生产服务器是多么快速和简单，使其准备好通过互联网提供服务。
- en: The simple example we used in the chapter, although a fully functional App Engine
    application, is quite simple and it doesn't make use of anything provided by the
    platform besides the runtime environment. In the next chapter, we will start from
    scratch with a new, more useful application, exploring the webapp2 framework and
    taking advantage of Cloud Datastore.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们使用的简单示例，虽然是一个功能齐全的App Engine应用程序，但相当简单，除了运行环境之外，没有利用平台提供的任何其他功能。在下一章中，我们将从头开始，使用一个新的、更有用的应用程序，探索webapp2框架，并利用Cloud
    Datastore。
