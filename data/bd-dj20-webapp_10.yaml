- en: Starting Mail Ape
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Mail Ape
- en: In this chapter, we'll begin building Mail Ape, a mailing list manager that
    will let users start mailing lists, sign up for mailing lists, and then message
    people. Subscribers will have to confirm their subscription to a mailing list
    and be able to unsubscribe. This will help us to ensure that Mail Ape isn't used
    to serve spam to users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建Mail Ape，一个邮件列表管理器，让用户可以开始邮件列表、注册邮件列表，然后给人发消息。订阅者必须确认他们对邮件列表的订阅，并且能够取消订阅。这将帮助我们确保Mail
    Ape不被用来向用户发送垃圾邮件。
- en: 'In this chapter, we will build the core Django functionality of Mail Ape:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建Mail Ape的核心Django功能：
- en: We'll build models that describe Mail Ape, including `MailingList` and `Subscriber`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将构建描述Mail Ape的模型，包括`MailingList`和`Subscriber`
- en: We'll use Django's Class-Based Views to create web pages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用Django的基于类的视图来创建网页
- en: We'll use Django's built-in authentication functionality to let users log in
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用Django内置的身份验证功能让用户登录
- en: We'll make sure that only the owner of a `MailingList` model instance can email
    its subscribers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将确保只有`MailingList`模型实例的所有者才能给其订阅者发送电子邮件
- en: We'll create templates to generate the HTML to display the forms to subscribe
    and email to our users
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建模板来生成HTML以显示订阅和给用户发送电子邮件的表单
- en: We'll run Mail Ape locally using Django's built-in development server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用Django内置的开发服务器在本地运行Mail Ape
- en: The code for this project is available online at [https://github.com/tomaratyn/MailApe](https://github.com/tomaratyn/MailApe).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码可在[https://github.com/tomaratyn/MailApe](https://github.com/tomaratyn/MailApe)上找到。
- en: Django follows the **Model View Template** (**MVT**) pattern to separate model,
    control, and presentation logic and encourage reusability. Models represent the
    data we'll store in the database. Views are responsible for handling a request
    and returning a response. Views should not have HTML. Templates are responsible
    for the body of a response and defining the HTML. This separation of responsibilities
    has proven to make it easy to write code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Django遵循**模型视图模板**（**MVT**）模式，以分离模型、控制和表示逻辑，并鼓励可重用性。模型代表我们将在数据库中存储的数据。视图负责处理请求并返回响应。视图不应该包含HTML。模板负责响应的主体和定义HTML。这种责任的分离已被证明使编写代码变得容易。
- en: Let's start by creating the Mail Ape project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建Mail Ape项目。
- en: Creating the Mail Ape project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Mail Ape项目
- en: 'In this section, we will create the MailApe project:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建MailApe项目：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All the paths in this part of the book will be relative to this directory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有路径都将相对于此目录。
- en: Listing our Python dependencies
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出我们的Python依赖项
- en: 'Next, let''s create a `requirements.txt` file to track our Python dependencies:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个`requirements.txt`文件来跟踪我们的Python依赖项：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we know our requirements, we can install them, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的需求，我们可以按照以下方式安装它们：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will install the following four libraries:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装以下四个库：
- en: '`Django`: Our favorite web app framework'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Django`：我们最喜欢的Web应用程序框架'
- en: '`psycopg2`: The Python PostgreSQL library; we''ll use PostgreSQL in both production
    and development'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psycopg2`：Python PostgreSQL库；我们将在生产和开发中都使用PostgreSQL'
- en: '`django-markdownify`: A library that makes it easy to render markdown in a
    Django template'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-markdownify`：一个使在Django模板中呈现markdown变得容易的库'
- en: '`django-crsipy-forms`: A library that makes it easy to create Django forms
    in templates'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-crsipy-forms`：一个使在模板中创建Django表单变得容易的库'
- en: With Django installed, we can use the `django-admin` utility to create our project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Django安装，我们可以使用`django-admin`实用程序来创建我们的项目。
- en: Creating our Django project and apps
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的Django项目和应用程序
- en: A Django project is composed of a configuration directory and one or more Django
    apps. The actual functionality of a project is encapsulated by the installed apps.
    By default, the configuration directory is named after the project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目由配置目录和一个或多个Django应用程序组成。已安装的应用程序封装了项目的实际功能。默认情况下，配置目录以项目命名。
- en: 'A web app is often composed of much more than just the Django code that is
    executed. We need configuration files, system dependencies, and documentation.
    To help future developers (including our future selves), we will strive to label
    each directory clearly:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序通常由远不止执行的Django代码组成。我们需要配置文件、系统依赖和文档。为了帮助未来的开发人员（包括我们未来的自己），我们将努力清晰地标记每个目录：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this approach, our directory structure is clear about the location of our
    Django code and configuration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们的目录结构清楚地指明了我们的Django代码和配置的位置。
- en: 'Next, let''s create the apps that will encapsulate our functionality:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建将封装我们功能的应用程序：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For each app, we should create a URLConf. A URLConf ensures that requests get
    routed to the right view. A URLConf is a list of paths, the view that serves the
    path, and the name for the path. One great thing about URLConfs is that they can
    include each other. When a Django project is created, it gets a root URLConf (ours
    is at `django/config/urls.py`). Since a URLConf may include other URLConfs, the
    name provides a vital way to reference a URL path to a view without knowing the
    full URL path to the view.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个应用程序，我们应该创建一个URLConf。URLConf确保请求被路由到正确的视图。URLConf是路径列表，提供路径的视图和路径的名称。URLConfs的一个很棒的功能是它们可以相互包含。当创建Django项目时，它会得到一个根URLConf（我们的在`django/config/urls.py`）。由于URLConf可能包含其他URLConfs，名称提供了一种重要的方式来引用URL路径到视图，而不需要知道视图的完整URL路径。
- en: Creating our app's URLConfs
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们应用的URLConfs
- en: 'Let''s create a URLConf for the `mailinglist` app in `django/mailinglist/urls.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`mailinglist`应用程序创建一个URLConf，位于`django/mailinglist/urls.py`中：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `app_name` variable is used to scope the paths in case of name collisions.
    When resolving a pathname, we can prefix it with `mailinglist:` to ensure that
    it's from this app. As we build our views, we'll add `path` s to the `urlpatterns`
    list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`app_name`变量用于在名称冲突的情况下限定路径。在解析路径名时，我们可以使用`mailinglist:`前缀来确保它来自此应用程序。随着我们构建视图，我们将向`urlpatterns`列表添加`path`。'
- en: 'Next, let''s create another URLConf in the `user` app by creating `django/user/urls.py`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过创建`django/user/urls.py`为`user`应用程序创建另一个URLConf：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Great! Now, let''s include them in the root ULRConf that''s located in `django/config/urls.py`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，让我们将它们包含在位于`django/config/urls.py`中的根ULRConf中：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The root URLConf is just like our app''s URLConfs. It has a list of `path()` objects.
    The `path()` objects in the root URLConfs usually don''t have views but `include()`
    other URLConfs. Let''s take a look at the two new functions here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根URLConf就像我们应用程序的URLConfs一样。它有一个`path()`对象的列表。根URLConfs中的`path()`对象通常没有视图，而是`include()`其他URLConfs。让我们来看看这里的两个新函数：
- en: '`path()`: This takes a string and either a view or the result of `include()`.
    Django will iterate over the `path()`s in a URLConf until it finds one that matches
    the path of a request. Django will then pass the request to that view or URLConf.
    If it''s a URLConf, then that list of `path()`s is checked.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path()`: 这需要一个字符串和一个视图或`include()`的结果。Django将在URLConf中迭代`path()`，直到找到与请求路径匹配的路径。然后Django将请求传递给该视图或URLConf。如果是URLConf，则会检查`path()`的列表。'
- en: '`include()`: This takes a URLConf and a namespace name. A namespace isolates
    a URLConfs from each other so that we can prevent name collisions, ensuring that
    we can differentiate `appA:index` from `appB:index`. `include()` returns a tuple;
    the object at `admin.site.urls` has been already a correctly formatted tuple,
    so we don''t have to use `include()`. Generally, we always use `include()`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include()`: 这需要一个URLConf和一个命名空间名称。命名空间将URLConfs相互隔离，以便我们可以防止名称冲突，确保我们可以区分`appA:index`和`appB:index`。`include()`返回一个元组；`admin.site.urls`上的对象已经是一个正确格式的元组，所以我们不必使用`include()`。通常，我们总是使用`include()`。'
- en: If Django can't find a `path()` object that matches a request's path, then it
    will return a 404 response.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Django找不到与请求路径匹配的`path()`对象，那么它将返回404响应。
- en: 'The result of this URLConf is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URLConf的结果如下：
- en: Any request starting with `admin/` will be routed to the admin app's URLConf
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何以`admin/`开头的请求将被路由到管理员应用的URLConf
- en: Any request starting with `mailinglist/` will be routed to the `mailinglist`
    app's URLConf
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何以`mailinglist/`开头的请求将被路由到`mailinglist`应用的URLConf
- en: Any request starting with `user/` will be routed to the `user` app's URLConf
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何以`user/`开头的请求将被路由到`user`应用的URLConf
- en: Installing our project's apps
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装我们项目的应用程序
- en: 'Let''s update `django/config/settings.py` to install our apps. We''ll change
    the `INSTALLED_APPS` setting as shown in the following code snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`django/config/settings.py`以安装我们的应用程序。我们将更改`INSTALLED_APPS`设置，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have our project and apps configured, let's create models for our
    `mailinglist` app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了我们的项目和应用程序，让我们为我们的`mailinglist`应用创建模型。
- en: Creating the mailinglist models
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建邮件列表模型
- en: 'In this section, we''ll create the models for our `mailinglist` app. Django
    provides a rich and powerful ORM that will let us define our models in Python
    without having to deal with the database directly. The ORM converts our Django
    classes, fields, and objects into relational database concepts:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将为我们的`mailinglist`应用创建模型。Django提供了丰富而强大的ORM，让我们能够在Python中定义我们的模型，而不必直接处理数据库。ORM将我们的Django类、字段和对象转换为关系数据库概念：
- en: A model class maps to a relational database table
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型类映射到关系数据库表
- en: A field maps to a relational database column
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段映射到关系数据库列
- en: A model instance maps to a relational database row
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型实例映射到关系数据库行
- en: Each model also comes with a default manager available in the `objects` attribute.
    A manager provides a starting point for running queries on a model. One of the
    most important methods a manager has is `create()`. We can use `create()` to create
    an instance of the model in our database. A manager is also the starting point
    to get a `QuerySet` for our model.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型还带有一个默认的管理器，可在`objects`属性中使用。管理器提供了在模型上运行查询的起点。管理器最重要的方法之一是`create()`。我们可以使用`create()`在数据库中创建模型的实例。管理器也是获取模型的`QuerySet`的起点。
- en: A `QuerySet` represents a database query for models. `QuerySet`s are lazy and
    only execute when they're iterated or converted to a `bool`. A `QuerySet` API
    offers most the functionality of SQL without being tied a particular database.
    Two particularly useful methods are `QuerySet.filter()` and `QuerySet.exclude()`.
    `QuerySet.filter()` lets us filter the results of the `QuerySet` to only those
    matching the provided criteria. `QuerySet.exclude()` lets us exclude results that
    don't match the criteria.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuerySet`代表模型的数据库查询。`QuerySet`是惰性的，只有在迭代或转换为`bool`时才执行。`QuerySet` API提供了大部分SQL的功能，而不与特定的数据库绑定。两个特别有用的方法是`QuerySet.filter()`和`QuerySet.exclude()`。`QuerySet.filter()`让我们将`QuerySet`的结果过滤为只匹配提供的条件的结果。`QuerySet.exclude()`让我们排除不匹配条件的结果。'
- en: Let's start with the first model, `MailingList`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个模型`MailingList`开始。
- en: Creating the MailingList model
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建邮件列表模型
- en: Our `MailingList` model will represent a mailing list that one of our users
    has created. This will be an important model for our system because many other
    models will be referring to it. We can also anticipate that the `id` of a `MailingList` will
    have to be publicly exposed in order to relate subscribers back to it. To avoid
    letting users enumerate all the mailing lists in Mail Ape, we want to make sure
    that our `MailingList` IDs are nonsequential.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MailingList`模型将代表我们的一个用户创建的邮件列表。这将是我们系统中的一个重要模型，因为许多其他模型将引用它。我们还可以预期`MailingList`的`id`将需要公开暴露，以便将订阅者关联回来。为了避免让用户枚举Mail
    Ape中的所有邮件列表，我们希望确保我们的`MailingList` ID是非顺序的。
- en: 'Let''s add our `MailingList` model to `django/mailinglist/models.py`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的`MailingList`模型添加到`django/mailinglist/models.py`中：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s take a closer look at our `MailingList` model:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们的`MailingList`模型：
- en: '`class MailingList(models.Model):`: All Django models must inherit from the
    `Model` class.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class MailingList(models.Model):`：所有Django模型都必须继承自`Model`类。'
- en: '`id = models.UUIDField`: This is the first time we''ve specified the `id` field
    for a model. Usually, we let Django provide one for us automatically. In this
    case, we wanted nonsequential IDs, so we used a field that provides **Universally
    Unique Identifiers** (**UUIDs**). Django will create the proper database field
    when we generate the migrations (refer to the *Creating database migrations* section).
    However, we have to generate the UUID in Python. To generate new UUIDs for each
    new model, we used the `default` argument and Python''s `uuid4` function. To tell
    Django that our `id` field is the primary key, we used the `primary_key` argument.
    We further passed `editable=False` to prevent changes to the `id` attribute.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id = models.UUIDField`: 这是我们第一次为模型指定`id`字段。通常，我们让Django自动为我们提供一个。在这种情况下，我们想要非顺序的ID，所以我们使用了一个提供**通用唯一标识符**（**UUID**）的字段。Django将在我们生成迁移时创建适当的数据库字段（参考*创建数据库迁移*部分）。然而，我们必须在Python中生成UUID。为了为每个新模型生成新的UUID，我们使用了`default`参数和Python的`uuid4`函数。为了告诉Django我们的`id`字段是主键，我们使用了`primary_key`参数。我们进一步传递了`editable=False`以防止对`id`属性的更改。'
- en: '`name = models.CharField`: This will represent the mailing list''s name. A
    `CharField` will get converted to a `VARCHAR` column, so we must provide it with
    a `max_length` argument.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name = models.CharField`: 这将代表邮件列表的名称。`CharField`将被转换为`VARCHAR`列，所以我们必须为它提供一个`max_length`参数。'
- en: '`owner = models.ForeignKey`: This is a foreign key to Django''s user model.
    In our case, we will use the default `django.contrib.auth.models.User` class.
    We follow the Django best practice of avoiding hardcoding this model. By referencing
    `settings.AUTH_USER_MODEL`, we don''t couple our app to the project too tightly.
    This encourages future reuse. The `on_delete=models.CASCADE` argument means that
    if a user is deleted, all their `MailingList` model instances will be deleted
    too.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner = models.ForeignKey`: 这是对Django用户模型的外键。在我们的情况下，我们将使用默认的`django.contrib.auth.models.User`类。我们遵循Django避免硬编码这个模型的最佳实践。通过引用`settings.AUTH_USER_MODEL`，我们不会将我们的应用程序与项目过于紧密地耦合。这鼓励未来的重用。`on_delete=models.CASCADE`参数意味着如果用户被删除，他们的所有`MailingList`模型实例也将被删除。'
- en: '`def __str__(self)`: This defines how to convert a mailing list to a `str`.
    Both Django and Python will use this when a `MailingList` needs to be printed
    out or displayed.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def __str__(self)`: 这定义了如何将邮件列表转换为`str`。当需要打印或显示`MailingList`时，Django和Python都会使用这个方法。'
- en: '`def get_absolute_url(self)`: This is a common method on Django models. `get_absolute_url()`
    returns a URL path that represents the model. In our case, we return the management
    page for this mailing list. We don''t hardcode the path. Instead, we use `reverse()`
    to resolve the path at runtime by providing the name of the URL. We''ll look at
    named URLs in the *Creating the URLConf* section.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def get_absolute_url(self)`: 这是Django模型上的一个常见方法。`get_absolute_url()`返回代表模型的URL路径。在我们的情况下，我们返回这个邮件列表的管理页面。我们不会硬编码路径。相反，我们使用`reverse()`在运行时解析路径，提供URL的名称。我们将在*创建URLConf*部分讨论命名URL。'
- en: '`def user_can_use_mailing_list(self, user)`: This is a method we''ve added
    for our own convenience. It checks whether a user can use (meaning view-related
    items and/or send messages) to this mailing list. Django''s *Fat models* philosophy
    encourages placing code for decisions like this in models rather than in views.
    This gives us a central place for decisions, ensuring that you **Don''t Repeat
    Yourself** (**DRY**).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def user_can_use_mailing_list(self, user)`: 这是我们为自己方便添加的一个方法。它检查用户是否可以使用（查看相关项目和/或发送消息）到这个邮件列表。Django的*Fat
    models*哲学鼓励将这样的决策代码放在模型中，而不是在视图中。这为我们提供了一个决策的中心位置，确保**不要重复自己**（**DRY**）。'
- en: We now have our `MailingList` model. Next, let's create a model to capture the
    mailing list's subscribers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`MailingList`模型。接下来，让我们创建一个模型来捕获邮件列表的订阅者。
- en: Creating the Subscriber model
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`Subscriber`模型
- en: In this section, we will create a `Subscriber` model. A `Subscriber` model can
    only belong to one `MailingList` and must confirm their subscription. Since we'll
    need to reference a subscriber for their confirm and unsubscribe pages, we'll
    want their `id` instance to also be nonsequential.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个`Subscriber`模型。`Subscriber`模型只能属于一个`MailingList`，并且必须确认他们的订阅。由于我们需要引用订阅者以获取他们的确认和取消订阅页面，我们希望他们的`id`实例也是非顺序的。
- en: 'Let''s create the `Subscriber` model in `django/mailinglist/models.py`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/models.py`中创建`Subscriber`模型。
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Subscriber` model has some similarities to the `MailingList` model. The
    base class and `UUIDField` function the same. Let''s take a look at some of the
    differences:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscriber`模型与`MailingList`模型有一些相似之处。基类和`UUIDField`的功能相同。让我们看看一些不同之处：'
- en: '`models.EmailField()`: This is a specialized `CharField` but does extra validation
    to ensure that the value is a valid email address.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.EmailField()`: 这是一个专门的`CharField`，但会进行额外的验证，以确保值是一个有效的电子邮件地址。'
- en: '`models.BooleanField(default=False)`: This lets us store `True`/`False` values.
    We need to use to this to track whether a user really intends to subscribe to
    a mailing list.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.BooleanField(default=False)`: 这让我们存储`True`/`False`值。我们需要使用这个来跟踪用户是否真的打算订阅邮件列表。'
- en: '`models.ForeignKey(to=MailingList...)`: This lets us create a foreign key between
    `Subscriber` and `MailingList` model instances.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.ForeignKey(to=MailingList...)`: 这让我们在`Subscriber`和`MailingList`模型实例之间创建一个外键。'
- en: '`unique_together`: This is an attribute of the `Meta` inner class of `Subscriber`.
    A `Meta` inner class lets us specify information on the table. For example, `unique_together`
    lets us add an additional unique constraint on a table. In this case, we prevent
    a user from signing up twice with the same email.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_together`: 这是`Subscriber`的`Meta`内部类的一个属性。`Meta`内部类让我们可以在表上指定信息。例如，`unique_together`让我们在表上添加额外的唯一约束。在这种情况下，我们防止用户使用相同的电子邮件地址注册两次。'
- en: Now that we can track `Subscriber` model instances, let's track the messages
    our users want to send to their `MailingList`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以跟踪`Subscriber`模型实例了，让我们跟踪用户想要发送到他们的`MailingList`的消息。
- en: Creating the Message model
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`Message`模型
- en: Our users will want to send messages to their `Subscriber` model instances of
    `MailingList`. In order to know what to send to these subscribers, we will need
    to store the messages as a Django model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户将希望向他们的`MailingList`的`Subscriber`模型实例发送消息。为了知道要发送给这些订阅者什么，我们需要将消息存储为Django模型。
- en: A `Message` should belong to a `MailingList` and have a nonsequential `id`.
    We need to save the subject and body of these messages. We will also want to track
    when the sending began and completed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`应该属于`MailingList`并具有非连续的`id`。我们需要保存这些消息的主题和正文。我们还希望跟踪发送开始和完成的时间。'
- en: 'Let''s add the `Message` model to `django/mailinglist/models.py`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`Message`模型添加到`django/mailinglist/models.py`中：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Again, the `Message` model is very similar to our preceding models in its base
    class and fields. We do see some new fields in this model. Let''s take a closer
    look at these new fields:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`Message`模型在其基类和字段上与我们之前的模型非常相似。我们在这个模型中看到了一些新字段。让我们更仔细地看看这些新字段：
- en: '`models.TextField()`: This is used to store arbitrarily long character data.
    All major databases have a `TEXT` column type. This is useful to store the `body` attribute
    of our user''s `Message`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.TextField()`: 用于存储任意长的字符数据。所有主要数据库都有`TEXT`列类型。这对于存储用户的`Message`的`body`属性非常有用。'
- en: '`models.DateTimeField(default=None, null=True)`: This is used to store date
    and time values. In Postgres, this becomes a `TIMESTAMP` column. The `null` argument
    tells Django that this column should be able to accept a `NULL` value. By default,
    all fields have a `NOT NULL` constraint on them.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.DateTimeField(default=None, null=True)`: 用于存储日期和时间值。在Postgres中，这将成为`TIMESTAMP`列。`null`参数告诉Django该列应该能够接受`NULL`值。默认情况下，所有字段都对它们有一个`NOT
    NULL`约束。'
- en: We now have our models. Let's create them in our database with database migrations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了我们的模型。让我们使用数据库迁移在我们的数据库中创建它们。
- en: Using database migrations
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库迁移
- en: 'Database migrations describe how to get a database to a particular state. In
    this section, we will do the following things:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移描述了如何将数据库转换为特定状态。在本节中，我们将做以下事情：
- en: Create a database migration for our `mailinglist` app models
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的`mailinglist`应用程序模型创建数据库迁移
- en: Run the migration on a Postgres database
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Postgres数据库上运行迁移
- en: When we make a change to our models, we can have Django generate the code for
    creating those tables, fields, and constraints. The migrations that Django generates
    are created using an API that is also available to Django developers. If we need
    to do a complicated migration, we can write a migration ourselves. Remember that
    a proper migration includes code for both applying and reverting a migration.
    If there's a problem, we want to have a way to undo our migration. When Django
    generates a migration, it always generates both migrations for us.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对模型进行更改时，我们可以让Django生成用于创建这些表、字段和约束的代码。Django生成的迁移是使用Django开发人员也可以使用的API创建的。如果我们需要进行复杂的迁移，我们可以自己编写迁移。请记住，正确的迁移包括应用和撤消迁移的代码。如果出现问题，我们希望有一种方法来撤消我们的迁移。当Django生成迁移时，它总是为我们生成两个迁移。
- en: Let's start by configuring Django to connect to our PostgreSQL database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先配置Django连接到我们的PostgreSQL数据库。
- en: Configuring the database
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据库
- en: 'To configure Django to connect to our Postgres database, we will need to update
    the `DATABASES` setting in `django/config/settings.py`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Django连接到我们的Postgres数据库，我们需要更新`django/config/settings.py`中的`DATABASES`设置：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should not hardcode the password to a production database in your `settings.py` file.
    If you're connecting to a shared or online instance, set the username, password,
    and host using environment variables and access them using `os.getenv()`, like
    we did in our previous production deployment chapters ([Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml), *Deploying
    with Docker*, and [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml), *Deploying
    Answerly*).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该在`settings.py`文件中将密码硬编码到生产数据库中。如果您连接到共享或在线实例，请使用环境变量设置用户名、密码和主机，并使用`os.getenv()`访问它们，就像我们在之前的生产部署章节中所做的那样（[第5章](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml)，“使用Docker部署”和[第9章](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)，*部署Answerly*）。
- en: Django cannot create a database and users by itself. We must do that ourselves.
    You can find a script for doing this in the code for this chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Django不能自行创建数据库和用户。我们必须自己做。您可以在本章的代码中找到执行此操作的脚本。
- en: Next, let's create the migrations for models.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为模型创建迁移。
- en: Creating database migrations
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库迁移
- en: 'To create our database migrations, we will use the `manage.py` script that
    Django put at the top of the Django project (`django/manage.py`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的数据库迁移，我们将使用Django放在Django项目顶部的`manage.py`脚本（`django/manage.py`）：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Great! Now that we have the migrations, we can run them on our local development
    database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们有了迁移，我们可以在我们的本地开发数据库上运行它们。
- en: Running database migrations
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行数据库迁移
- en: 'We use `manage.py` to apply our database migrations to a running database.
    On the command line, execute the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`manage.py`将我们的数据库迁移应用到正在运行的数据库。在命令行上执行以下操作：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we run `manage.py migrate` without providing an app, it will run all migrations
    on all installed Django apps. Our database now has the tables for the `mailinglist`
    app models and the `auth` app's models (including the `User` model).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`manage.py migrate`而不提供应用程序时，它将在所有安装的Django应用程序上运行所有迁移。我们的数据库现在具有`mailinglist`应用程序模型和`auth`应用程序模型（包括`User`模型）的表。
- en: Now that we have our models and database set up, let's make sure that we can
    validate the user's input for these models using Django's forms API.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的模型和数据库设置，让我们确保我们可以使用Django的表单API验证这些模型的用户输入。
- en: MailingList forms
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件列表表单
- en: One of the common issues that developers have to solve is how to validate a
    user input. Django provides input validation through its forms API. The forms
    API can be used to describe an HTML form using an API very similar to the models
    API. If we want to create a form that describes a Django model, then the Django
    form's `ModelForm` offers us a shortcut. We only have to describe what we're changing
    from the default form representation for the model.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员必须解决的一个常见问题是如何验证用户输入。Django通过其表单API提供输入验证。表单API可用于使用与模型API非常相似的API描述HTML表单。如果我们想创建描述Django模型的表单，那么Django表单的`ModelForm`为我们提供了一种快捷方式。我们只需要描述我们从默认表单表示中更改的内容。
- en: 'When a Django form is instantiated, it can be provided with any of the three
    following arguments:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化Django表单时，可以提供以下三个参数中的任何一个：
- en: '`data`: The raw input that the end users request'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：最终用户请求的原始输入'
- en: '`initial`: The known safe initial values that we may set for a form'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial`：我们可以为表单设置的已知安全初始值'
- en: '`instance`: The instance the form is describing, only on `ModelForm`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instance`：表单描述的实例，仅在`ModelForm`中'
- en: If a form has been provided `data`, then it is called a bound form. Bound forms
    can validate their `data` by calling `is_valid()`. A validated form's safe-to-use
    data is available under the `cleaned_data` dictionary (keyed on the field's name).
    Errors are available via the `errors` property, which returns a dictionary. A
    bound `ModelForm` can also create or update its model instance with the `save()` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单提供了`data`，那么它被称为绑定表单。绑定表单可以通过调用`is_valid()`来验证它们的`data`。经过验证的表单的安全数据可以在`cleaned_data`字典下使用（以字段名称为键）。错误可以通过`errors`属性获得，它返回一个字典。绑定的`ModelForm`也可以使用`save()`方法创建或更新其模型实例。
- en: Even if none of the arguments are provided, a form is still able to print itself
    out as HTML, making our templates much simpler. This mechanism helps us achieve
    the goal of *dumb templates*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有提供任何参数，表单仍然能够以HTML形式打印自己，使我们的模板更简单。这种机制帮助我们实现了“愚蠢模板”的目标。
- en: Let's start creating our forms by creating the `SubscriberForm` class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建`SubscriberForm`类来开始创建我们的表单。
- en: Creating the Subscriber form
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建订阅者表单
- en: An important task Mail Ape must perform is to accept emails of a new `Subscriber` for
    a `MailingList`. Let's create a form to do that validation for us.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Mail Ape必须执行的一个重要任务是接受新的`Subscriber`的邮件，用于`MailingList`。让我们创建一个表单来进行验证。
- en: '`SubscriberForm` must be able to validate input as a valid email. We also want
    it to save our new `Subscriber` model instance and associate it with the proper
    `MailingList` model instance.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubscriberForm`必须能够验证输入是否为有效的电子邮件。我们还希望它保存我们的新`Subscriber`模型实例并将其与适当的`MailingList`模型实例关联起来。'
- en: 'Let''s create that form in `django/mailinglist/forms.py`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/forms.py`中创建该表单：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s take a closer look at our `SubscriberForm`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看我们的`SubscriberForm`：
- en: '`class SubscriberForm(forms.ModelForm):`: This shows that our form is derived
    from `ModelForm`. `ModelForm` knows to check our inner `Meta` class for information
    on the model and fields that can be used as the basis of this form.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class SubscriberForm(forms.ModelForm):`：这表明我们的表单是从`ModelForm`派生的。`ModelForm`知道要检查我们的内部`Meta`类，以获取关于可以用作此表单基础的模型和字段的信息。'
- en: '`mailing_list = forms.ModelChoiceField`: This tells our form to use our custom
    configured `ModelChoiceField` instead of the default that the forms API would
    use. By default, Django will show a `ModelChoiceField` that would render as a
    drop-down box. A user could use the dropdown to pick the associated model. In
    our case, we don''t want the user to be able to make that choice. When we show
    a rendered `SubscriberForm`, we want it be configured for a particular mailing
    list. To this end, we change the `widget` argument to be a `HiddenInput` class
    and mark the field as `disabled`. Our form needs to know the `MailingList` model
    instances that are valid for this form. We provide a `QuerySet` object that matches
    all `MailingList` model instances.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mailing_list = forms.ModelChoiceField`：这告诉我们的表单使用我们自定义配置的`ModelChoiceField`，而不是表单API默认使用的。默认情况下，Django将显示一个`ModelChoiceField`，它将呈现为下拉框。用户可以使用下拉框选择相关的模型。在我们的情况下，我们不希望用户能够做出选择。当我们显示一个渲染的`SubscriberForm`时，我们希望它配置为特定的邮件列表。为此，我们将`widget`参数更改为`HiddenInput`类，并将字段标记为`disabled`。我们的表单需要知道对于该表单有效的`MailingList`模型实例。我们提供一个匹配所有`MailingList`模型实例的`QuerySet`对象。'
- en: '`model = Subscriber`: This tells the form''s `Meta` inner class that this form
    is based on the `Subscriber` model.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model = Subscriber`：这告诉表单的`Meta`内部类，这个表单是基于`Subscriber`模型的。'
- en: '`fields = [''mailing_list'', ''email'', ]`: This tells the form to only include
    the following fields from the model in the form.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields = [''mailing_list'', ''email'', ]`：这告诉表单只包括模型中的以下字段。'
- en: Next, let's make a form for capturing the `Message`s that our users want to
    send to their `MailingList`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个表单，用于捕获我们的用户想要发送到他们的`MailingList`的`Message`。
- en: Creating the Message Form
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建消息表单
- en: Our users will want to send `Message`s to their `MailingList`s. We'll provide
    a web page with a form where users can create these messages. Before we can create
    the page, let's create the form.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户将希望向他们的`MailingList`发送`Message`。我们将提供一个网页，用户可以在其中创建这些消息的表单。在我们创建页面之前，让我们先创建表单。
- en: 'Let''s add our `MessageForm` class to `django/mailinglist/forms.py`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的`MessageForm`类添加到`django/mailinglist/forms.py`中：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you may have noticed in the preceding code, `MessageForm` works just like
    `SubscriberFrom`. The only difference is that we've listed a different model and
    different fields in the `Meta` inner class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所注意到的，`MessageForm`的工作方式与`SubscriberFrom`相同。唯一的区别是我们在`Meta`内部类中列出了不同的模型和不同的字段。
- en: Next, let's create the `MailingListForm` class, which we'll use to accept input
    for the name of the mailing list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`MailingListForm`类，我们将用它来接受邮件列表的名称的输入。
- en: Creating the MailingList form
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建邮件列表表单
- en: Now, we'll create a `MailingListForm`, which will accept the name and owner
    of a mailing list. We will use the same `HiddenInput` and `disabled` field pattern
    as before but this time on the `owner` field. We want to make sure that a user
    can't change the owner of the mailing list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`MailingListForm`，它将接受邮件列表的名称和所有者。我们将在`owner`字段上使用与之前相同的`HiddenInput`和`disabled`字段模式。我们希望确保用户无法更改邮件列表的所有者。
- en: 'Let''s add our form to `django/mailinglist/forms.py`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的表单添加到`django/mailinglist/forms.py`中：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `MailingListForm` is very similar to our previous forms, but introduces
    a new function, `get_user_model()`. We need to use `get_user_model()` because
    we don't want to couple ourselves to a particular user model, but we need access
    to that model's manager to get a `QuerySet`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailingListForm`与我们之前的表单非常相似，但引入了一个新的函数`get_user_model()`。我们需要使用`get_user_model()`，因为我们不想将自己与特定的用户模型耦合在一起，但我们需要访问该模型的管理器以获取`QuerySet`。'
- en: Now that we have our forms, we can create the views for our `mailinglist` Django
    app.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的表单，我们可以为我们的`mailinglist` Django应用程序创建视图。
- en: Creating MailingList views and templates
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建邮件列表视图和模板
- en: In the preceding section, we created forms that we can use to collect and validate
    user input. In this section, we will create the views and templates that actually
    communicate with the user. A template defines the HTML of a document.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们创建了可以用来收集和验证用户输入的表单。在本节中，我们将创建实际与用户通信的视图和模板。模板定义了文档的HTML。
- en: Fundamentally, a Django view is a function that accepts a request and returns
    a response. While we won't be using these **Function-Based Views** (**FBVs**)
    in this book, it's important to remember that all a view needs to do is meet those
    two responsibilities. If processing a view also causes another action to occur
    (for example, sending an email), then we should put that code in a service module
    rather than directly in the view.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Django视图是一个接受请求并返回响应的函数。虽然我们在本书中不会使用这些**基于函数的视图**（**FBVs**），但重要的是要记住，一个视图只需要满足这两个责任。如果处理视图还导致其他操作发生（例如，发送电子邮件），那么我们应该将该代码放在服务模块中，而不是直接放在视图中。
- en: A lot of the work that web developers face is repetitive (for example, processing
    a form, showing a particular model, listing all instances of that model, and so
    on). Django's battery included philosophy means that it includes tools to make
    these kinds of repetitive tasks easier.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Web开发人员面临的许多工作是重复的（例如，处理表单，显示特定模型，列出该模型的所有实例等）。Django的“电池包含”哲学意味着它包含了工具，使这些重复的任务更容易。
- en: Django makes common web developer tasks easier by offering a rich suite of **class-based
    views** (**CBVs**). CBVs use the principles of **Object-Oriented Programming**
    (**OOP**) to increase code reuse. Django comes with a rich suite of CBVs that
    makes it easy to process a form or show an HTML page for a model instance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Django通过提供丰富的**基于类的视图**（**CBVs**）使常见的Web开发人员任务更容易。CBVs使用**面向对象编程**（**OOP**）的原则来增加代码重用。Django提供了丰富的CBV套件，使处理表单或为模型实例显示HTML页面变得容易。
- en: The HTML view returns come from rendering a template. Templates in Django are
    generally written in Django's template language. Django can also support other
    template languages (for example, Jinja). Generally, each view is associated with
    a template.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: HTML视图返回的内容来自于渲染模板。Django中的模板通常是用Django的模板语言编写的。Django也可以支持其他模板语言（例如Jinja）。通常，每个视图都与一个模板相关联。
- en: Let's start by creating some resources many of our views will need.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建许多视图将需要的一些资源。
- en: Common resources
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见资源
- en: 'In this section, we will create some common resources that our views and templates
    will need:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一些我们的视图和模板将需要的常见资源：
- en: We'll create a base template, which all our other templates can extend. Using
    the same base template across all our pages will give Mail Ape a unifying look
    and feel.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建一个基础模板，所有其他模板都可以扩展。在所有页面上使用相同的基础模板将给Mail Ape一个统一的外观和感觉。
- en: We'll create a `MailingListOwnerMixin` class, which will let us protect mailing
    lists messages from unauthorized access.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建一个`MailingListOwnerMixin`类，它将让我们保护邮件列表消息免受未经授权的访问。
- en: Let's start by creating a base template.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个基础模板开始。
- en: Creating a base template
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基础模板
- en: Let's create a base template for Mail Ape. This template will be used by all
    our pages to give our entire web app a consistent look.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为Mail Ape创建一个基础模板。这个模板将被我们所有的页面使用，以给我们整个Web应用程序一个一致的外观。
- en: 'The **Django template language** (**DTL**) lets us write our HTML (or other
    text-based format) and lets us use *tags*, *variables*, and *filters* to execute
    code to customize the HTML. Let''s take a closer look at those three concepts:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django模板语言**（**DTL**）让我们编写HTML（或其他基于文本的格式），并让我们使用*标签*、*变量*和*过滤器*来执行代码以定制HTML。让我们更仔细地看看这三个概念：'
- en: '*tags*: They are surrounded by `{% %}` and may (`{% block body%}{% endblock
    %}`) or may not (`{% url "myurl" %}`) contain a body.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标签*：它们被`{% %}`包围，可能（`{% block body%}{% endblock %}`）或可能不（`{% url "myurl" %}`）包含一个主体。'
- en: '*variables*: They are surrounded by `{{ }}` and must be set in the template''s
    context (for example, `{{ mailinglist }}`). Though DTL variables are like Python
    variables, there are differences. The two most critical ones are around executables
    and dictionaries. Firstly, DTL does not have a syntax to pass arguments to an
    executable (you never have to use `{{foo(1)}}`). If  you reference a variable
    and it is callable (for example, a function), then the Django template language
    will call it and return the result (for example, `{{mailinglist.get_absolute_url}}`).
    Secondly, DTL doesn''t distinguish among object attributes, items in a list, and
    items in a dictionary. All three are accessed using a dot: `{{mailinglist.name}}`,
    `{{mylist.1}}`, and `{{mydict.mykey}}`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*variables*：它们被`{{ }}`包围，并且必须在模板的上下文中设置（例如，`{{ mailinglist }}`）。尽管DTL变量类似于Python变量，但也有区别。最关键的两个区别在于可执行文件和字典。首先，DTL没有语法来传递参数给可执行文件（你永远不必使用`{{foo(1)}}`）。如果你引用一个变量并且它是可调用的（例如，一个函数），那么Django模板语言将调用它并返回结果（例如，`{{mailinglist.get_absolute_url}}`）。其次，DTL不区分对象属性、列表中的项目和字典中的项目。所有这三个都使用点来访问：`{{mailinglist.name}}`，`{{mylist.1}}`和`{{mydict.mykey}}`。'
- en: '*filters*: They follow a variable and modify its value (for example, `{{ mailinglist.name
    | upper}}` will return the mailing lists'' name in uppercase).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*filters*：它们跟随一个变量并修改其值（例如，`{{ mailinglist.name | upper}}`将以大写形式返回邮件列表的名称）。'
- en: We'll take a look at examples of all three as we continue creating Mail Ape.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在继续创建Mail Ape时查看这三个示例。
- en: 'Let''s create a common templates directory—`django/templates`—and put our template
    in `django/templates/base.html`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个公共模板目录—`django/templates`—并将我们的模板放在`django/templates/base.html`中：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our base template, we will note examples of the following three tags:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基本模板中，我们将注意以下三个标签的示例：
- en: '`{% url ... %}`: This returns the path to a view. This works just like the
    `reverse()` function we saw earlier but in a Django template.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% url ... %}`：这返回到视图的路径。这与我们之前看到的`reverse()`函数在Django模板中的工作方式相同。'
- en: '`{% if ... %} ... {% else %} ... {% endif %}`: This works just like a Python
    developer would expect. The `{% else %}` clause is optional. The Django template
    language also supports `{% elif ... %}` if we need to choose among multiple choices.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% if ... %} ... {% else %} ... {% endif %}`：这与Python开发人员期望的工作方式相同。`{% else
    %}`子句是可选的。Django模板语言还支持`{% elif ... %}`，如果我们需要在多个选择中进行选择。'
- en: '`{% block ... %}`: This defines a block that a template, which extends `base.html`,
    can replace with its own content. We have two blocks, `body` and `title`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% block ... %}`：这定义了一个块，一个扩展`base.html`的模板可以用自己的内容替换。我们有两个块，`body`和`title`。'
- en: We now have a base template that our other templates can use by just providing
    body and title blocks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个基本模板，我们的其他模板可以通过提供body和title块来使用。
- en: Now that we have our template, we have to tell Django where to find it. Let's
    update `django/config/settings.py` to let Django know about our new `django/templates`
    directory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了模板，我们必须告诉Django在哪里找到它。让我们更新`django/config/settings.py`，让Django知道我们的新`django/templates`目录。
- en: 'In `django/config/settings.py`, find the line that starts with `Templates`.
    We will need to add our `templates` directory to the list under the `DIRS` key:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`django/config/settings.py`中，找到以`Templates`开头的行。我们需要将我们的`templates`目录添加到`DIRS`键下的列表中：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Django lets us avoid hardcoding the path to `django/templates` by calculating
    the path to `django` at runtime as `BASE_DIR`. This way, we can use the same setting
    across environments.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Django让我们通过在运行时计算`BASE_DIR`来避免将路径硬编码到`django/templates`中。这样，我们可以在不同的环境中使用相同的设置。
- en: Another important setting we just saw was `APP_DIRS`. This setting tells Django
    to check each installed app for a `templates` directory when Django is looking
    for a template. It means that we don't have to update the `DIRS` key for each
    installed app and lets us isolate our templates under our apps (increasing reusability).
    Finally, it's important to remember that apps are searched in the order they appear
    in `INSTALLED_APPS`. If there's a template name collision (for example, two apps
    provide a template called `registration/login.html`), then the one listed first
    in `INSTALLED_APPS` will be used.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的另一个重要设置是`APP_DIRS`。这个设置告诉Django在查找模板时检查每个安装的应用程序的`templates`目录。这意味着我们不必为每个安装的应用程序更新`DIRS`键，并且让我们将模板隔离在我们的应用程序下（增加可重用性）。最后，重要的是要记住应用程序按照它们在`INSTALLED_APPS`中出现的顺序进行搜索。如果有模板名称冲突（例如，两个应用程序提供名为`registration/login.html`的模板），那么将使用`INSTALLED_APPS`中列出的第一个。
- en: Next, let's configure our project to use Bootstrap 4 when rendering forms in
    HTML.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置我们的项目在呈现HTML表单时使用Bootstrap 4。
- en: Configuring Django Crispy Forms to use Bootstrap 4
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Django Crispy Forms以使用Bootstrap 4
- en: In our base template, we included the Bootstrap 4 css template. To make it easy
    to render a form and style it using Bootstrap 4, we will use a third-party Django
    app called Django Crispy Forms. However, we must configure Django Crispy Forms
    to tell it to use Bootstrap 4.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基本模板中，我们包含了Bootstrap 4的css模板。为了方便使用Bootstrap 4呈现表单并为其设置样式，我们将使用一个名为Django
    Crispy Forms的第三方Django应用程序。但是，我们必须配置Django Crispy Forms以告诉它使用Bootstrap 4。
- en: 'Let''s add a new setting to the bottom of `django/config/settings.py`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/config/settings.py`的底部添加一个新的设置：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, Django Crispy Forms is configured to use Bootstrap 4 when rendering a form.
    We'll take a look at it later in this chapter, in sections covering rendering
    a form in a template.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Django Crispy Forms配置为在呈现表单时使用Bootstrap 4。我们将在本章后面的部分中查看它，在涵盖在模板中呈现表单的部分。
- en: Next, let's create a mixin that ensures that only the owners of a mailing list
    can affect them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个mixin，确保只有邮件列表的所有者才能影响它们。
- en: Creating a mixin to check whether a user can use the mailing list
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个mixin来检查用户是否可以使用邮件列表
- en: Django uses **class-based views** (**CBVs**) to make it easier to reuse code,
    simplifying repetitive tasks. One of the repetitive tasks we'll have to do in
    the `mailinglist` app is protect `MailingList` s and their related models from
    being tampered with by other users. We’ll create a mixin that provides protection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用**基于类的视图**（**CBVs**）使代码重用更容易，简化重复的任务。在`mailinglist`应用程序中，我们将不得不做的重复任务之一是保护`MailingList`及其相关模型，以免被其他用户篡改。我们将创建一个mixin来提供保护。
- en: A mixin is a class that provides a limited functionality that is meant to be
    used in conjunction with other classes. We've previously seen the `LoginRequired`
    mixin, which can be used in conjunction with a view class to protect a view from
    unauthenticated access. In this section, we will create a new mixin.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: mixin是一个提供有限功能的类，旨在与其他类一起使用。我们之前见过`LoginRequired` mixin，它可以与视图类一起使用，以保护视图免受未经身份验证的访问。在本节中，我们将创建一个新的mixin。
- en: 'Let''s create our `UserCanUseMailingList` mixin in a new file at `django/mailinglist/mixins.py`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/mixins.py`中创建我们的`UserCanUseMailingList` mixin：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our class defines a single method, `get_object(self, queryset=None)`. This method
    has the same signature as `SingleObjectMixin.get_object()`, which is used by many
    of Django's built-in CBVs (for example, `DetailView`). Our `get_object()` implementation
    doesn't do any work to retrieve an object. Instead, our `get_object` just checks
    the object that a parent retrieved to check whether it is, or has, a `MailingList`
    and confirms that the logged in user can use the mailing list.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类定义了一个方法，`get_object(self, queryset=None)`。这个方法与`SingleObjectMixin.get_object()`具有相同的签名，许多Django内置的CBV（例如`DetailView`）使用它。我们的`get_object()`实现不做任何工作来检索对象。相反，我们的`get_object`只是检查父对象检索到的对象，以检查它是否是或者拥有`MailingList`，并确认已登录的用户可以使用邮件列表。
- en: One surprising thing about a mixin is that it relies on a super class but doesn't
    inherit from one. In `get_object()`, we explicitly call `super()`, but `UserCanUseMailingList`
    doesn't have any base classes. Mixin classes aren't expected to be used by themselves.
    Instead, they will be used by classes, which subclass them *and* one or more other
    classes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: mixin的一个令人惊讶的地方是它依赖于一个超类，但不继承自一个。在`get_object()`中，我们明确调用`super()`，但`UserCanUseMailingList`没有任何基类。mixin类不希望单独使用。相反，它们将被类使用，这些类子类化它们*和*一个或多个其他类。
- en: We'll take a look at how this works in the next few sections.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几节中看看这是如何工作的。
- en: Creating MailingList views and templates
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MailingList视图和模板
- en: Now, we'll take a look at the views that will process the user's requests and
    return responses that show a UI created from our templates.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看将处理用户请求并返回从我们的模板创建的UI的响应的视图。
- en: Let's start by creating a view to list of all our `MailingList`s.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个列出所有我们的`MailingList`的视图。
- en: Creating the MailingListListView view
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MailingListListView视图
- en: We will create a view that shows the mailing lists a user owns.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个视图，显示用户拥有的邮件列表。
- en: 'Let''s create our `MailingListListView` in `django/mailinglist/views.py`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/views.py`中创建我们的`MailingListListView`：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our view is derived from two views, `LoginRequiredMixin` and `ListView`. `LoginRequiredMixin`
    is a mixin that ensures that a request made by an unauthenticated user is redirected
    to a login view instead of being processed. To help the `ListView` know *what*
    to list, we will override the `get_queryset()` method and return a `QuerySet`
    that includes only the `MailingList` s owned by the currently logged in user.
    To display the result, `ListView` will try to render a template at `appname/modelname_list.html`.
    In our case, `ListView` will try to render `mailinglist/mailinglist_list.html`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点源自两个视图，`LoginRequiredMixin`和`ListView`。`LoginRequiredMixin`是一个mixin，确保未经身份验证的用户发出的请求被重定向到登录视图，而不是被处理。为了帮助`ListView`知道*要*列出什么，我们将重写`get_queryset()`方法，并返回一个包含当前登录用户拥有的`MailingList`的`QuerySet`。为了显示结果，`ListView`将尝试在`appname/modelname_list.html`渲染模板。在我们的情况下，`ListView`将尝试渲染`mailinglist/mailinglist_list.html`。
- en: 'Let''s create that template in `django/mailinglist/templates/mailinglist/mailinglist_list.html`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/templates/mailinglist/mailinglist_list.html`中创建该模板：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our template extends `base.html`. When a template extends another template,
    it can only put HTML into the `block`s that have been previously defined. We will
    also see a lot of new Django template tags. Let''s take a closer look at them:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板扩展了`base.html`。当一个模板扩展另一个模板时，它只能将HTML放入先前定义的`block`中。我们还将看到许多新的Django模板标签。让我们仔细看看它们：
- en: '`{% extends "base.html" %}`: This tells the Django template language which
    template that we''re extending.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% extends "base.html" %}`：这告诉Django模板语言我们正在扩展哪个模板。'
- en: '`{% block title %}… {% endblock %}`: This tells Django that we''re providing
    new code that it should place in the extended template''s `title` block. The previous
    code in that block (if any) is replaced.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% block title %}… {% endblock %}`：这告诉Django我们正在提供新的代码，它应该放在扩展模板的`title`块中。该块中的先前代码（如果有）将被替换。'
- en: '`{% for mailinglist in mailinglist_list %} ... {% endfor %}`: This provides
    a for loop for each item in the list.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% for mailinglist in mailinglist_list %} ... {% endfor %}`：这为列表中的每个项目提供了一个循环。'
- en: '`{% url … %}`: The `url` tag will produce a URL path for the named `path`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% url … %}`：`url`标签将为命名的`path`生成URL路径。'
- en: '`{% url ... pk=...%}`: This works just like the preceding point, but, in some
    cases, a `path` may take arguments (for example, the primary key of the `MailingList`
    to display). We can specify these extra arguments in the `url` tag after the name
    of the `path`.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% url ... pk=...%}`：这与前面的点一样工作，但在某些情况下，`path`可能需要参数（例如要显示的`MailingList`的主键）。我们可以在`url`标签中指定这些额外的参数。'
- en: We now have a view and template that work together.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以一起使用的视图和模板。
- en: 'The final step with any view is adding the app''s URLConf to it. Let''s update
    `django/mailinglist/urls.py`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 任何视图的最后一步都是将应用的URLConf添加到其中。让我们更新`django/mailinglist/urls.py`：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Given how we configured our root URLConf earlier, any request sent to `/mailinglist/`
    will be routed to our `MailingListListView`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们之前如何配置了根URLConf，任何发送到`/mailinglist/`的请求都将被路由到我们的`MailingListListView`。
- en: Next, let's add a view to create new `MailingList`s.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个视图来创建新的`MailingList`。
- en: Creating the CreateMailingListView and template
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CreateMailingListView和模板
- en: We will create a view to create mailing lists. When our view receives a `GET`
    request, the view will show our users a form for entering the name of the mailing
    list. When our view receives a `POST` request, the view will validate the form
    and either redisplay the form with errors or create the mailing list and redirect
    the user to the list's management page.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个视图来创建邮件列表。当我们的视图接收到`GET`请求时，视图将向用户显示一个表单，用于输入邮件列表的名称。当我们的视图接收到`POST`请求时，视图将验证表单，要么重新显示带有错误的表单，要么创建邮件列表并将用户重定向到列表的管理页面。
- en: 'Let''s create the view now in `django/mailinglist/views.py`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`django/mailinglist/views.py`中创建视图：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`CreateMailingListView` is derived from two classes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateMailingListView`派生自两个类：'
- en: '`LoginRequiredMixin` redirects requests that are not associated with a logged
    in user from being processed (we''ll configure this later in this chapter, in
    the *Creating the user app* section)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginRequiredMixin`会重定向未与已登录用户关联的请求，使其无法被处理（我们将在本章后面的*创建用户应用*部分进行配置）'
- en: '`CreateView` knows how to work with the form indicated in `form_class` and
    render it using the template listed in `template_name`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateView`知道如何处理`form_class`中指定的表单，并使用`template_name`中列出的模板进行渲染'
- en: '`CreateView` is the class that does most of the work here without us needing
    to provide almost any extra information. Processing a form, validating it, and
    saving it are always the same, and `CreateView` has the code to do it. If we need
    to change some of the behavior, we can override one for the hooks that `CreateView`
    provides, as we do with `get_initial()`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateView`是在不需要提供几乎任何额外信息的情况下完成大部分工作的类。处理表单，验证它，并保存它总是相同的，而`CreateView`有代码来执行这些操作。如果我们需要更改某些行为，我们可以重写`CreateView`提供的钩子之一，就像我们在`get_initial()`中所做的那样。'
- en: When `CreateView` instantiates our `MailingListForm`, `CreateView` calls its
    `get_initial()` method to get the `initial` data (if any) for the form. We use
    this hook to make sure that the form's owner is set to the logged in user's `id`.
    Remember that `MailingListForm` has its `owner` field disabled, so the form will
    ignore any data provided by the user.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CreateView`实例化我们的`MailingListForm`时，`CreateView`调用其`get_initial()`方法来获取表单的`initial`数据（如果有的话）。我们使用这个钩子来确保表单的所有者设置为已登录用户的`id`。请记住，`MailingListForm`的`owner`字段已被禁用，因此表单将忽略用户提供的任何数据。
- en: 'Next, let''s create the template for our `CreateView` in `django/mailinglist/templates/mailinglist/mailinglist_form.html`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`django/mailinglist/templates/mailinglist/mailinglist_form.html`中创建我们的`CreateView`的模板：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our template extends `base.html`. When a template extends another template,
    it can only put HTML into the blocks that have been previously defined by the
    extended template(s). We also take a lot of new Django template tags. Let''s take
    a closer look at them:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板扩展了`base.html`。当一个模板扩展另一个模板时，它只能在已被扩展模板定义的块中放置HTML。我们还使用了许多新的Django模板标签。让我们仔细看看它们：
- en: '`{% load crispy_forms_tags %}`: This tells Django to load a new template tag
    library. In this case, we will load `crispy_from_tags` from the Django Crispy
    Forms app that we have installed. This provides us with the `crispy` filter we''ll
    see later in this section.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% load crispy_forms_tags %}`：这告诉Django加载一个新的模板标签库。在这种情况下，我们将加载我们安装的Django
    Crispy Forms应用的`crispy_from_tags`。这为我们提供了稍后在本节中将看到的`crispy`过滤器。'
- en: '`{% csrf_token %}`: Any form that Django processes must have a valid CSRF token
    to prevent CSRF attacks (refer to [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml),
    *Posters, Headshots, and Security*). The `csrf_token` tag returns a hidden input
    tag with the correct CSRF token. Remember that Django generally won''t process
    a POST request without a CSRF Token.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% csrf_token %}`：Django处理的任何表单都必须具有有效的CSRF令牌，以防止CSRF攻击（参见[第3章](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml)，*海报、头像和安全*）。`csrf_token`标签返回一个带有正确CSRF令牌的隐藏输入标签。请记住，通常情况下，Django不会处理没有CSRF令牌的POST请求。'
- en: '`{{ form | crispy }}`: The `form` variable is a reference to the form instance
    that our view is processing and is passed into this template''s context by our
    `CreateView`. `crispy` is a filter provided by the `crispy_form_tags` tag library
    and will output the form using HTML tags and CSS classes used in Bootstrap 4.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ form | crispy }}`：`form`变量是我们的视图正在处理的表单实例的引用，并且通过我们的`CreateView`将其传递到这个模板的上下文中。`crispy`是由`crispy_form_tags`标签库提供的过滤器，将使用HTML标签和Bootstrap
    4中使用的CSS类输出表单。'
- en: We now have a view and template that work together. The view is able to use
    the template to create a user interface to enter data into the form. The view
    is then able to process the form’s data and create a `MailingList` model from
    valid form data or redisplay the form if the data has a problem. The Django Crispy
    Forms library renders the form using the HTML and CSS from the Bootstrap 4 CSS
    Framework.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个视图和模板可以一起使用。视图能够使用模板创建用户界面以输入表单中的数据。然后视图能够处理表单的数据并从有效的表单数据创建`MailingList`模型，或者如果数据有问题，则重新显示表单。Django
    Crispy Forms库使用Bootstrap 4 CSS框架的HTML和CSS渲染表单。
- en: 'Finally, let''s add our view to the `mailinglist` app''s URLConf. In `django/mailinglist/urls.py`,
    let''s add a new `path()` object to the URLConf:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将我们的视图添加到`mailinglist`应用的URLConf中。在`django/mailinglist/urls.py`中，让我们向URLConf添加一个新的`path()`对象：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Given how we configured our root URLConf earlier, any request sent to `/mailinglist/new`
    will be routed to our `CreatingMailingListView`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们之前如何配置了根URLConf，任何发送到`/mailinglist/new`的请求都将被路由到我们的`CreatingMailingListView`。
- en: Next, let's make a view to delete a `MailingList`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个视图来删除`MailingList`。
- en: Creating the DeleteMailingListView view
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建DeleteMailingListView视图
- en: Users will want to delete `MailingList` s after they stop being useful. Let's
    create a view that will prompt the user for confirmation on a `GET` request and
    delete the `MailingList` on a `POST`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在`MailingList`不再有用后会想要删除它们。让我们创建一个视图，在`GET`请求上提示用户进行确认，并在`POST`上删除`MailingList`。
- en: 'We''ll add our view to `django/mailinglist/views.py`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的视图添加到`django/mailinglist/views.py`中：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s take a closer look at the classes that `DeleteMailingListView` is derived
    from:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看`DeleteMailingListView`从中派生的类：
- en: '`LoginRequiredMixin`: This serves the same function as in the preceding code,
    ensuring that requests from an unauthenticated user aren''t processed. The user
    is just redirected to the login page.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginRequiredMixin`：这与前面的代码具有相同的功能，确保未经身份验证的用户的请求不被处理。用户只是被重定向到登录页面。'
- en: '`UserCanUseMailingList`: This is the mixin we created in the preceding code.
    `DeleteView` uses the `get_object()` method to retrieve the model instance to
    be deleted. By mixing `UserCanUseMailingList` into the `DeleteMailingListView`
    class, we protect each user''s `MailingList`s from being deleted by unauthorized
    users.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserCanUseMailingList`：这是我们在前面的代码中创建的mixin。`DeleteView`使用`get_object()`方法来检索要删除的模型实例。通过将`UserCanUseMailingList`混合到`DeleteMailingListView`类中，我们保护了每个用户的`MailingList`不被未经授权的用户删除。'
- en: '`DeleteView`: This is a Django view that knows how to render a confirmation
    template on a `GET` request and delete the related model on `POST`.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteView`：这是一个Django视图，它知道如何在`GET`请求上呈现确认模板，并在`POST`上删除相关的模型。'
- en: In order for Django's `DeleteView` to function properly, we will need to configure
    it properly. `DeleteView` knows which model to delete from its `model` attribute.
    `DeleteView` requires that we provide a `pk` argument when we route requests to
    it. To render the confirmation template, `DeleteView` will try to use `appname/modelname_confirm_delete.html`.
    In the case of `DeleteMailingListView`, the template will be `mailinglist/mailinglist_confirm_delete.html`.
    If the model is successfully deleted, then `DeleteView` will redirect to the `success_url` value.
    We've avoided hardcoding the `success_url` and instead used `reverse_lazy()` to
    refer to the URL by name. The `reverse_lazy()` function returns a value that won't
    resolve until it's used to create a `Response` object.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Django的`DeleteView`正常工作，我们需要正确配置它。`DeleteView`知道从其`model`属性中删除哪个模型。当我们路由请求到它时，`DeleteView`要求我们提供一个`pk`参数。为了呈现确认模板，`DeleteView`将尝试使用`appname/modelname_confirm_delete.html`。在`DeleteMailingListView`的情况下，模板将是`mailinglist/mailinglist_confirm_delete.html`。如果成功删除模型，那么`DeleteView`将重定向到`success_url`值。我们避免了硬编码`success_url`，而是使用`reverse_lazy()`来引用名称的URL。`reverse_lazy()`函数返回一个值，直到用它来创建一个`Response`对象时才会解析。
- en: 'Let''s create the template that `DeleteMailingListView` requires in `django/mailinglist/templates/mailinglist/mailinglist_confirm_delete.html`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`DeleteMailingListView`在`django/mailinglist/templates/mailinglist/mailinglist_confirm_delete.html`中需要的模板：
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this template, we don't use any forms because there isn't any input to validate.
    The form submission itself is the confirmation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们不使用任何表单，因为没有任何输入需要验证。表单提交本身就是确认。
- en: 'The last step will be adding our view to the `urlpatterns` list in `django/mailinglist/urls.py`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步将是将我们的视图添加到`django/mailinglist/urls.py`中的`urlpatterns`列表中：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This `path` looks different than the previous `path()` calls we've seen. In
    this `path`, we're including a named argument that will be parsed out of the path
    and passed to the view. We specify `path` named arguments using the `<converter:name>` format.
    A converter knows how to match a part of the path (for example, the `uuid` converter
    knows how to match a UUID; `int` knows how to match a number; `str` will match
    any non-empty string except `/`). The matched text is then passed to the view
    as a key word argument with the provided name. In our case, to route a request
    to `DeleteMailingListView`, it has to have a path like this: `/mailinglist/bce93fec-f9c6-4ea7-b1aa-348d3bed4257/delete`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`path`看起来不同于我们之前见过的`path()`调用。在这个`path`中，我们包含了一个命名参数，它将被解析出路径并传递给视图。我们使用`<converter:name>`格式来指定`path`命名参数。转换器知道如何匹配路径的一部分（例如，`uuid`转换器知道如何匹配UUID；`int`知道如何匹配数字；`str`将匹配除了`/`之外的任何非空字符串）。然后匹配的文本将作为关键字参数传递给视图，并提供名称。在我们的情况下，要将请求路由到`DeleteMailingListView`，它必须有这样的路径：`/mailinglist/bce93fec-f9c6-4ea7-b1aa-348d3bed4257/delete`。
- en: Now that we can list, create, and delete `MailingList`s, let's create a view
    to manage its `Subscriber`s and `Message`s.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以列出、创建和删除`MailingList`，让我们创建一个视图来管理其`Subscriber`和`Message`。
- en: Creating MailingListDetailView
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MailingListDetailView
- en: Let’s create a view that will list all the `Subscriber`s and `Message`s related
    to a `MailingList`. We want also need a place to show our users the `MailingList`s
    subscription page link. Django can make it easy to create a view that represents
    a model instance.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个视图，列出与`MailingList`相关的所有`Subscriber`和`Message`。我们还需要一个地方来向用户显示`MailingList`的订阅页面链接。Django可以很容易地创建一个表示模型实例的视图。
- en: 'Let''s create our `MailingListDetailView` in `django/mailinglist/views.py`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/views.py`中创建我们的`MailingListDetailView`：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We're using the `LoginRequiredMixin` and `UserCanUseMailingList` the same way
    and for the same purpose as before. This time, we're using them with `DetailView`,
    which is one of the simplest views. It simply renders a template for an instance
    of the model it's been configured for. It retrieves the model instance by receiving
    a `pk` argument from `path` just like `DeleteView`. Also, we don't have to explicitly
    configure the template it will use because, by convention, it uses `appname/modelname_detail.html`.
    In our case, it will be `mailinglist/mailinglist_detail.html`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与之前相同的方式使用`LoginRequiredMixin`和`UserCanUseMailingList`，并且目的也是相同的。这次，我们将它们与`DetailView`一起使用，这是最简单的视图之一。它只是为其配置的模型实例呈现模板。它通过从`path`接收`pk`参数来检索模型实例，就像`DeleteView`一样。此外，我们不必显式配置它将使用的模板，因为按照惯例，它使用`appname/modelname_detail.html`。在我们的情况下，它将是`mailinglist/mailinglist_detail.html`。
- en: 'Let''s create our template in `django/mailinglist/templates/mailinglist/mailinglist_detail.html`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/templates/mailinglist/mailinglist_detail.html`中创建我们的模板：
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code template introduces only one new item (the `yesno` filter),
    but really shows how all the tools of Django's template language come together.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码模板只介绍了一个新项目（`yesno`过滤器），但确实展示了Django模板语言的所有工具是如何结合在一起的。
- en: The `yesno` filter takes a value and returns `yes` if the value evaluates to
    `True`, `no` if it evaluates to `False`, and `maybe` if it is `None`. In our case,
    we've passed an argument that tells `yesno` to return `confirmed` if `True` and
    `unconfirmed` if `False`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`yesno`过滤器接受一个值，如果该值评估为`True`，则返回`yes`，如果评估为`False`，则返回`no`，如果为`None`，则返回`maybe`。在我们的情况下，我们传递了一个参数，告诉`yesno`如果为`True`则返回`confirmed`，如果为`False`则返回`unconfirmed`。'
- en: 'The `MailingListDetailView` class and template illustrate how Django lets us
    concisely complete a common web developer task: display a page for a row in a
    database.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailingListDetailView`类和模板说明了Django如何简洁地完成常见的Web开发人员任务：显示数据库中行的页面。'
- en: 'Next, let''s create a new `path()` object to our view in the `mailinglist` URLConf:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`mailinglist`的URLConf中为我们的视图创建一个新的`path()`对象：
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, let's create views for our `Subscriber` model instances.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的`Subscriber`模型实例创建视图。
- en: Creating Subscriber views and templates
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Subscriber视图和模板
- en: In this section we'll create views and templates to let users interact with
    our `Subscriber` model. One of the main differences between these views and the
    `MailingList` and `Message` views is that they will not need any mixins because
    they will be exposed publicly. Their main protection from tampering is that `Subscriber`s
    are identified by a UUID which has a large key space, meaning that tampering is
    unlikely.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建视图和模板，让用户与我们的`Subscriber`模型进行交互。这些视图与`MailingList`和`Message`视图的主要区别之一是，它们不需要任何混合，因为它们将被公开。它们免受篡改的主要保护是`Subscriber`由UUID标识，具有大的密钥空间，这意味着篡改是不太可能的。
- en: Let's start with `SubscribeToMailingListView`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`SubscribeToMailingListView`开始。
- en: Creating SubscribeToMailingListView and template
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SubscribeToMailingListView和模板
- en: 'We need a view to collect `Subscriber`s to `MailingList`s. Let''s create a
    `SubscribeToMailingListView` class with `django/mailinglist/views.py`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个视图来收集`Subscriber`到`MailingList`。让我们在`django/mailinglist/views.py`中创建一个`SubscribeToMailingListView`类。
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our `SubscribeToMailingListView` is similar to `CreateMailingListView` but
    overrides a couple of new methods:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SubscribeToMailingListView`类似于`CreateMailingListView`，但覆盖了一些新方法：
- en: '`get_success_url()`: This is called by `CreateView` to get a URL to redirect
    the user to the model that has been created. In `CreateMailingListView`, we didn''t
    need to override it because the default behavior uses the model''s `get_absolute_url`.
    We use the `reverse()` function resolve the path to the thank you page.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_success_url()`: 这是由`CreateView`调用的，用于获取重定向用户到已创建模型的URL。在`CreateMailingListView`中，我们不需要覆盖它，因为默认行为使用模型的`get_absolute_url`。我们使用`reverse()`函数解析路径到感谢页面。'
- en: '`get_context_data()`: This lets us add new variables to the template''s context.
    In this case, we need access to the `MailingList` the user may subscribe to show
    the `MailingList`''s name. We use Django''s `get_object_or_404()` shortcut function
    to retrieve the `MailingList` by its ID or raise a 404 exception. We''ll have
    this view''s `path` parse the `mailinglist_id` out of our request''s path (refer
    to to the , at the end of this section).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_context_data()`: 这让我们向模板的上下文中添加新变量。在这种情况下，我们需要访问用户可能订阅的`MailingList`以显示`MailingList`的名称。我们使用Django的`get_object_or_404()`快捷函数通过其ID检索`MailingList`或引发404异常。我们将这个视图的`path`从我们请求的路径中解析出`mailinglist_id`（参见本节末尾的内容）。'
- en: 'Next, let''s create our template in `mailinglist/templates/mailinglist/subscriber_form.html`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`mailinglist/templates/mailinglist/subscriber_form.html`中创建我们的模板：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This template doesn't introduce any tags but shows another example of how we
    can use Django's template language and the Django Crispy Forms API to quickly
    build a pretty HTML form. We extend `base.html`, as before, to give our page a
    consistent look and feel. `base.html` also provides the blocks we're going to
    put our content into. Outside of any block, we `{% load %}` the Django Crispy
    Forms tag library so that we can use the `crispy` filter on our form to generate
    the Bootstrap 4 compatible HTML.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板没有引入任何标签，但展示了另一个例子，说明我们如何使用Django的模板语言和Django Crispy Forms API快速构建漂亮的HTML表单。我们像以前一样扩展`base.html`，以使我们的页面具有一致的外观和感觉。`base.html`还提供了我们要放入内容的块。在任何块之外，我们使用`{%
    load %}`加载Django Crispy Forms标签库，以便我们可以在我们的表单上使用`crispy`过滤器来生成兼容Bootstrap 4的HTML。
- en: 'Next, let''s make sure that Django knows how to route requests to our new view
    by adding a `path()` to `SubscribeToMailingListView` to the `mailinglist` app''s
    URLConf''s `urlpatterns` list:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确保Django知道如何将请求路由到我们的新视图，通过向`mailinglist`应用的URLConf的`urlpatterns`列表添加一个`path()`：
- en: '[PRE36]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this `path()`, we need to match the `uuid` parameter that we pass to our
    view as `mailinglist_pk`. This is the keyword argument that our `get_context_data()`
    method referenced.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`path()`中，我们需要匹配我们作为`mailinglist_pk`传递给视图的`uuid`参数。这是我们的`get_context_data()`方法引用的关键字参数。
- en: Next, let's create a thank you page to thank users for subscribing to a mailing
    list.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个感谢页面，感谢用户订阅邮件列表。
- en: Creating a thank you for subscribing view
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建感谢订阅视图
- en: After a user subscribes to a mailing list, we want to show them a *thank you*
    page. This page can be the same for all users who subscribe to the same mailing
    list since all it will show is the name of the mailing list (not the subscriber's
    email). To create this view, we're going to use the `DetailView` we've seen before
    but this time without any additional mixing (there's no information to protect
    here).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 用户订阅邮件列表后，我们希望向他们显示一个*感谢*页面。这个页面对于订阅相同邮件列表的所有用户来说是相同的，因为它将显示邮件列表的名称（而不是订阅者的电子邮件）。为了创建这个视图，我们将使用之前看到的`DetailView`，但这次没有额外的混合（这里没有需要保护的信息）。
- en: 'Let''s create our `ThankYouForSubscribingView` in `django/mailinglist/views.py`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/views.py`中创建我们的`ThankYouForSubscribingView`：
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Django does all the work for us in the `DetailView` as long as we provide a
    `model` attribute. The `DetailView` knows how to look up a model and then render
    a template for that model. We also provide a `template_name` attribute because
    the `mailinglist/mailinglist_detail.html` template (which `DetailView` would use
    by default) is already being used by `MailingListDetailView`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Django在`DetailView`中为我们完成所有工作，只要我们提供`model`属性。`DetailView`知道如何查找模型，然后为该模型呈现模板。我们还提供了`template_name`属性，因为`mailinglist/mailinglist_detail.html`模板（`DetailView`默认使用的）已经被`MailingListDetailView`使用。
- en: 'Let''s create our template in `django/mailinglist/templates/mailinglist/subscription_thankyou.html`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/templates/mailinglist/subscription_thankyou.html`中创建我们的模板：
- en: '[PRE38]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our template just shows a thank you and the template name.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板只是显示一个感谢和模板名称。
- en: 'Finally, let''s add a `path()` to `ThankYouForSubscribingView` to the `mailinglist`
    app''s URLConf''s `urlpatterns` list:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在`mailinglist`应用的URLConf的`urlpatterns`列表中添加一个`path()`到`ThankYouForSubscribingView`：
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Our `path` needs to match a UUID in order to route a request to `ThankYouForSubscribingView`.
    The UUID will be passed into the view as the keyword argument `pk`. This `pk`
    will be used by `DetailView` to find the correcting `MailingList`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`path`需要匹配UUID，以便将请求路由到`ThankYouForSubscribingView`。UUID将作为关键字参数`pk`传递到视图中。这个`pk`将被`DetailView`用来找到正确的`MailingList`。
- en: Next, we will need to let a user confirm that they want to receive emails at
    this address.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要让用户确认他们是否要在这个地址接收电子邮件。
- en: Creating a subscription confirmation view
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建订阅确认视图
- en: To prevent spammers from abusing our service, we will need to send an email
    to our subscribers to confirm that they really want to subscribe to one of our
    users' mailing lists. We'll cover sending those emails, but we'll create the confirmation
    page now.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止垃圾邮件发送者滥用我们的服务，我们需要向我们的订阅者发送一封电子邮件，确认他们确实想要订阅我们用户的邮件列表之一。我们将涵盖发送这些电子邮件，但现在我们将创建确认页面。
- en: This confirmation page will behave a little strangely. Simply visiting the page
    will modify `Subscriber.confirmed` to `True`. This is standard for how mailing
    list confirmation pages work (we want to avoid creating extra work for our subscribers)
    but strange according to the HTTP spec, which says that `GET` requests should
    not modify a resource.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个确认页面的行为会有点奇怪。简单地访问页面将会将`Subscriber.confirmed`修改为`True`。这是邮件列表确认页面的标准行为（我们希望避免为我们的订阅者创建额外的工作），但根据HTTP规范来说有点奇怪，因为`GET`请求不应该修改资源。
- en: 'Let''s create our `ConfirmSubscriptionView` in `django/mailinglist/views.py`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/views.py`中创建我们的`ConfirmSubscriptionView`：
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`ConfirmSubscriptionView` is another `DetailView` since it shows a single model
    instance. In this case, we override the `get_object()` method in order to modify
    the object before returning it. Since `Subscriber`s are not required to be users
    of our system, we don''t need to use `LoginRequiredMixin`. Our view is protected
    from brute force enumeration because the key space of `Subscriber.id` is large
    and assigned non-sequentially.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfirmSubscriptionView`是另一个`DetailView`，因为它显示单个模型实例。在这种情况下，我们重写`get_object()`方法以在返回之前修改对象。由于`Subscriber`不需要成为我们系统的用户，我们不需要使用`LoginRequiredMixin`。我们的视图受到暴力枚举的保护，因为`Subscriber.id`的密钥空间很大，并且是非顺序分配的。'
- en: 'Next, let''s create our template in `django/mailinglist/templates/mailinglist/confirm_subscription.html`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`django/mailinglist/templates/mailinglist/confirm_subscription.html`中创建我们的模板：
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Our template uses the blocks defined in `base.html` to simply notify the user
    of their confirmed subscription.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板使用在`base.html`中定义的块，简单地通知用户他们已确认订阅。
- en: 'Finally, let''s add a `path()` to `ConfirmSubscriptionView` to the `mailinglist`
    app''s URLConf''s `urlpatterns` list:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在`mailinglist`应用的URLConf的`urlpatterns`列表中添加一个`path()`到`ConfirmSubscriptionView`：
- en: '[PRE42]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our `confirm_subscription` path defines the path to match in order to route
    a request to our view. Our matching expression includes the requirement of a UUID,
    which will be passed to our `ConfirmSubscriptionView` as the keyword argument
    `pk`. The parent (`DetailView`) of `ConfirmSubscriptionView` will then use that
    to retrieve the correct `Subscriber`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`confirm_subscription`路径定义了要匹配的路径，以便将请求路由到我们的视图。我们的匹配表达式包括UUID的要求，这将作为关键字参数`pk`传递给我们的`ConfirmSubscriptionView`。`ConfirmSubscriptionView`的父类（`DetailView`）将使用它来检索正确的`Subscriber`。
- en: Next, let's allow `Subscribers` to unsubscribe themselves.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们允许`Subscribers`自行取消订阅。
- en: Creating UnsubscribeView
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建UnsubscribeView
- en: Part of being an ethical mailing provider is letting our `Subscriber`s unsubscribe.
    Next, we'll create an `UnsubscribeView`, which will delete a `Subscriber` model
    instance after they've confirmed they definitely want to unsubscribe.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 作为道德邮件提供者的一部分，让我们的`Subscriber`取消订阅。接下来，我们将创建一个`UnsubscribeView`，在`Subscriber`确认他们确实想要取消订阅后，将删除`Subscriber`模型实例。
- en: 'Let''s add our view to `django/mailinglist/views.py`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的视图添加到`django/mailinglist/views.py`中：
- en: '[PRE43]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Our `UnsubscribeView` lets Django's built-in `DeleteView` implement to render
    the template and find and delete the correct `Subscriber`. `DeleteView` requires
    that it receive a `pk` for the `Subscriber` as a keyword argument parsed from
    the path (much like a `DetailView`). When the delete succeeds, we'll redirect
    the user to the subscription page with the `get_success_url()` method. When `get_success_url()`
    is executing, our `Subscriber` instance will already be deleted from the database,
    but a copy of the respective object will be available under `self.object`. We
    will use that still in memory (but not in the database) instance to get the `id` attribute
    of the related mailing list.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`UnsubscribeView`让Django内置的`DeleteView`实现来呈现模板，并找到并删除正确的`Subscriber`。`DeleteView`要求它接收一个`pk`作为关键字参数，从路径中解析出`Subscriber`的`pk`（就像`DetailView`一样）。当删除成功时，我们将使用`get_success_url()`方法将用户重定向到订阅页面。在执行`get_success_url()`时，我们的`Subscriber`实例已经从数据库中删除，但相应对象的副本将在`self.object`下可用。我们将使用内存中的（但不在数据库中的）实例来获取相关邮件列表的`id`属性。
- en: 'To render the confirmation form, we will need to create a template in `django/mailinglist/templates/mailinglist/unsubscribe.html`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要呈现确认表单，我们需要在`django/mailinglist/templates/mailinglist/unsubscribe.html`中创建一个模板：
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This template renders a `POST` form, which will act as confirmation of the desire
    of the `subscriber` to be unsubscribed.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板呈现了一个`POST`表单，它将作为`subscriber`希望取消订阅的确认。
- en: 'Next, let''s add a `path()` to `UnsubscribeView` to the `mailinglist` app''s
    URLConf''s `urlpatterns` list:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们向`mailinglist`应用的URLConf的`urlpatterns`列表中添加一个`path()`到`UnsubscribeView`：
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When dealing with views that derive from `DetailView` or `DeleteView`, it's
    vital to remember to name the path matcher `pk`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理从`DetailView`或`DeleteView`派生的视图时，要记住将路径匹配器命名为`pk`是至关重要的。
- en: Great, now, let's allow the user to start creating `Message`s that they will
    send to their `Subscriber`s.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们允许用户开始创建他们将发送给他们的`Subscriber`的`Message`。
- en: Creating Message Views
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建消息视图
- en: We track the emails that our users want to send to their `Subscriber`s in the
    `Message` model. To make sure we have an accurate log of what users send to their
    `Subscribers`, we will restrict the operations available on `Message`s. Our users
    will only be able to create and view `Message`s. It doesn't make sense to support
    editing since an email that's been sent can't be modified. We also won't support
    deleting messages so that both we and the users have an accurate log of what was
    requested to be sent when.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Message`模型中跟踪我们的用户想要发送给他们的`Subscriber`的电子邮件。为了确保我们有一个准确的日志记录用户发送给他们的`Subscribers`的内容，我们将限制`Message`上可用的操作。我们的用户只能创建和查看`Message`。支持编辑是没有意义的，因为已发送的电子邮件无法修改。我们也不会支持删除消息，这样我们和用户都有一个准确的日志记录请求发送的内容。
- en: Let's start with making a `CreateMessageView`!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建`CreateMessageView`开始！
- en: Creating CreateMessageView
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CreateMessageView
- en: Our `CreateMessageView` is going to follow a pattern similar to the markdown
    forms that we created for Answerly. The user will get a form that they can submit
    to either save or preview. If the submit is a preview, then the form will render
    along with the preview of the rendered markdown of the `Message`. If the user
    chooses save, then they will create their new message.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CreateMessageView`将遵循类似于我们为Answerly创建的markdown表单的模式。用户将获得一个表单，他们可以提交以保存或预览。如果提交是预览，那么表单将与`Message`的渲染markdown预览一起呈现。如果用户选择保存，那么他们将创建他们的新消息。
- en: Since we're creating a new model instance, we will use Django's `CreateView`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个新的模型实例，我们将使用Django的`CreateView`。
- en: 'Let''s create our view in `django/mailinglist/views.py`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/views.py`中创建我们的视图：
- en: '[PRE46]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our view inherits from `CreateView` and `LoginRequiredMixin`. We use the `LoginRequiredMixin`
    to prevent unauthenticated users from sending messages to mailing lists. To prevent
    logged in but unauthorized users from sending messages, we will create a central `get_mailing_list()`
    method, which checks that the logged in user can use this mailing list. `get_mailing_list()`
    expects that the `mailinglist_pk` will be provided as a keyword argument to the
    view.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图继承自`CreateView`和`LoginRequiredMixin`。我们使用`LoginRequiredMixin`来防止未经身份验证的用户向邮件列表发送消息。为了防止已登录但未经授权的用户发送消息，我们将创建一个中心的`get_mailing_list()`方法，该方法检查已登录用户是否可以使用此邮件列表。`get_mailing_list()`期望`mailinglist_pk`将作为关键字参数提供给视图。
- en: 'Let''s take a closer look at the `CreateMessageView` to see how this all works
    together:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看`CreateMessageView`，看看这些是如何一起工作的：
- en: '`form_class = MessageForm`: This is the form that we want `CreateView` to render,
    validate, and use to create our `Message` model.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form_class = MessageForm`：这是我们希望`CreateView`渲染、验证和用于创建我们的`Message`模型的表单。'
- en: '`template_name = ''mailinglist/message_form.html''`: This is the template that
    we''ll create next.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template_name = ''mailinglist/message_form.html''`：这是我们接下来要创建的模板。'
- en: '`def get_success_url()`: After a `Message` is successfully created, we''ll
    redirect our users to the management page of the `MailingList`.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def get_success_url()`: 在成功创建`Message`后，我们将重定向用户到`MailingList`的管理页面。'
- en: '`def get_initial():`: Our `MessageForm` has its `mailing_list` field disabled
    so that users can''t try to surreptitiously create a `Message` for another user''s
    `MailingList`. Instead, we use our `get_mailing_list()` method to get the mailing
    list based on the `mailinglist_pk` argument. Using `get_mailing_list()`, we check
    whether the logged in user can use the `MailingList`.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def get_initial():`：我们的`MessageForm`将其`mailing_list`字段禁用，以防用户试图偷偷地为另一个用户的`MailingList`创建`Message`。相反，我们使用我们的`get_mailing_list()`方法来根据`mailinglist_pk`参数获取邮件列表。使用`get_mailing_list()`，我们检查已登录用户是否可以使用`MailingList`。'
- en: '`def get_context_data()`: This provides extra variables to the template''s
    context. We provide the `MailingList` as well as the save and preview constants.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def get_context_data()`: 这提供了额外的变量给模板的上下文。我们提供了`MailingList`以及保存和预览的常量。'
- en: '`def form_valid()`: This defines the behavior if the form is valid. We override
    the default behavior of `CreateView` to check the `action` POST argument. `action`
    will tell us whether to render a preview of the `Message` or to let `CreateView`
    save a new `Message` model instance. If we''re previewing the message, then we
    pass an unsaved `Message` instance built by our form to the template''s context.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def form_valid()`: 这定义了表单有效时的行为。我们重写了`CreateView`的默认行为来检查`action` POST参数。`action`将告诉我们是要渲染`Message`的预览还是让`CreateView`保存一个新的`Message`模型实例。如果我们正在预览消息，那么我们将通过我们的表单构建一个未保存的`Message`实例传递给模板的上下文。'
- en: 'Next, let''s make our template in `django/mailinglist/templates/mailinglist/message_form.html`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`django/mailinglist/templates/mailinglist/message_form.html`中制作我们的模板：
- en: '[PRE47]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This template loads the third party Django Markdownify tag library and the Django
    Crispy Forms tag library. The former gives us the `markdownify` filter and the
    latter gives us the `crispy` filter. The `markdownify` filter will convert the
    markdown text it receives into HTML. We previously used Django Markdownify in
    our Answerly project in part 2.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板加载了第三方的Django Markdownify标签库和Django Crispy Forms标签库。前者给我们提供了`markdownify`过滤器，后者给我们提供了`crispy`过滤器。`markdownify`过滤器将接收到的markdown文本转换为HTML。我们之前在我们的Answerly项目的第二部分中使用了Django
    Markdownify。
- en: This template form has two submit buttons, one to save the form and one to preview
    the form. The preview block is only rendered if we pass in `message` to preview.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板表单有两个提交按钮，一个用于保存表单，一个用于预览表单。只有在我们传入`message`来预览时，预览块才会被渲染。
- en: 'Now that we have our view and template, let''s add a `path()` to `CreateMessageView`
    in the `mailinglist` app''s URLConf:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了视图和模板，让我们在`mailinglist`应用的URLConf中为`CreateMessageView`添加一个`path()`：
- en: '[PRE48]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we can create messages, let's make a view to view messages we've already
    created.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建消息了，让我们创建一个查看我们已经创建的消息的视图。
- en: Creating the Message DetailView
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建消息DetailView
- en: To let users view the `Message`s they have sent to their `Subscriber`s we need
    a `MessageDetailView`. This view will simply display a `Message` but should only
    let users who are logged in and can use the `Message`'s `MailingList` access the
    view.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户查看他们发送给他们的`Subscriber`的`Message`，我们需要一个`MessageDetailView`。这个视图将简单地显示一个`Message`，但应该只允许已登录并且可以使用`Message`的`MailingList`的用户访问该视图。
- en: 'Let''s create our view in `django/mailinglist/views.py`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/views.py`中创建我们的视图：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As the name implies, we're going to use the Django's `DetailView`. To provide
    the protection we need, we'll add Django's `LoginRequiredMixin` and our `UserCanUseMailingList`
    mixin. As we've seen before, we don't need to specify the name of the template
    because `DetailView` will assume it based on the name of the app and model. In
    our case, `DetailView` wants the template to be called `mailinglist/message_detail.html`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，我们将使用Django的`DetailView`。为了提供我们需要的保护，我们将添加Django的`LoginRequiredMixin`和我们的`UserCanUseMailingList`混合。正如我们以前看到的那样，我们不需要指定模板的名称，因为`DetailView`将根据应用和模型的名称假定它。在我们的情况下，`DetailView`希望模板被称为`mailinglist/message_detail.html`。
- en: 'Let''s create our template in `mailinglist/message_detail.html`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`mailinglist/message_detail.html`中创建我们的模板：
- en: '[PRE50]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our template extends `base.html` and shows the message in the `body` block.
    When showing the `Message.body`, we use the third party Django Markdownify tag
    library's `markdownify` filter to render any markdown text as HTML.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板扩展了`base.html`并在`body`块中显示消息。在显示`Message.body`时，我们使用第三方Django Markdownify标签库的`markdownify`过滤器将任何markdown文本呈现为HTML。
- en: 'Finally, we need to add a `path()` to `MessageDetailView` to the `mailinglist`
    app''s URLConf''s `urlpatterns` list:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要向`mailinglist`应用的URLConf的`urlpatterns`列表中添加一个`path()`到`MessageDetailView`：
- en: '[PRE51]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We've now completed our `mailinglist` app's models, views, and templates. We've
    even created a `UserCanUseMailingList` to let our views easily prevent unauthorized
    access to a `MailingList` or one of its related views.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了我们的`mailinglist`应用的模型、视图和模板。我们甚至创建了一个`UserCanUseMailingList`来让我们的视图轻松地阻止未经授权的用户访问`MailingList`或其相关视图。
- en: Next, we'll create a `user` app to encapsulate user registration and authentication.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`user`应用来封装用户注册和身份验证。
- en: Creating the user app
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户应用
- en: To create a `MailingList` in Mail Ape, the user needs to have an account and
    be logged in. In this section, we will write the code for our `user` Django app,
    which will encapsulate everything to do with a user. Remember that the Django
    app should be tightly scoped. We don't want to put this behavior in our `mailinglist`
    app, as these are two discrete concerns.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Mail Ape中创建一个`MailingList`，用户需要拥有一个帐户并已登录。在本节中，我们将编写我们的`user` Django应用的代码，它将封装与用户有关的一切。请记住，Django应用应该范围严密。我们不希望将这种行为放在我们的`mailinglist`应用中，因为这是两个不同的关注点。
- en: Our `user` app is going to be very similar to the `user` app seen in MyMDB (Part
    1) and Answerly (Part 2). Due to this similarity, we will gloss over some topics.
    For a deeper examination of the topic, refer to [Chapter 2](7b88cc16-ca29-4aea-9895-7120422e8642.xhtml),
    *Adding Users to MyMDb*.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`user`应用将与MyMDB（第1部分）和Answerly（第2部分）中看到的`user`应用非常相似。由于这种相似性，我们将略过一些主题。要深入研究该主题，请参阅[第2章](7b88cc16-ca29-4aea-9895-7120422e8642.xhtml)，*将用户添加到MyMDb*。
- en: Django makes managing users and authentication easier with its built-in `auth`
    app (`django.contrib.auth`). The `auth` app offers a default user model, a `Form`
    for creating new users, as well as log in and log out views. This means that our
    `user` app only needs to fill in a few blanks before we have complete user management
    working locally.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Django通过其内置的`auth`应用（`django.contrib.auth`）使用户和身份验证管理变得更加容易。`auth`应用提供了默认的用户模型、用于创建新用户的`Form`，以及登录和注销视图。这意味着我们的`user`应用只需要填写一些空白，就可以在本地完全实现用户管理。
- en: 'Let''s start by creating a URLConf for our `user` app in `django/user/urls.py`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在`django/user/urls.py`中为我们的`user`应用创建一个URLConf：
- en: '[PRE52]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our URLConf is made up of three views:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的URLConf由三个视图组成：
- en: '`LoginView.as_view()`: This is the `auth` app''s login view. The `auth` app
    provides a view for accepting credentials but doesn''t have a template. We''ll
    need to create a template with the name `registration/login.html`. By default,
    it will redirect a user to `settings.LOGIN_REDIRECT_URL` on login. We can also
    pass a `next` `GET` parameter to supersede the setting.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginView.as_view()`: 这是`auth`应用的登录视图。`auth`应用提供了一个接受凭据的视图，但没有模板。我们需要创建一个名为`registration/login.html`的模板。默认情况下，它会在登录时将用户重定向到`settings.LOGIN_REDIRECT_URL`。我们还可以传递一个`next`的`GET`参数来取代该设置。'
- en: '`LogoutView.as_view()`: This is the auth app''s logout view. `LogoutView` is
    one of the few views that modifies state on a `GET` request, logging the user
    out. The view returns a redirect response. We can use `settings.LOGOUT_REDIRECT_URL`
    to configure where our user will be redirected to during log out. Again, we use
    the `GET` parameter `next` to customize this behavior.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogoutView.as_view()`: 这是`auth`应用的注销视图。`LogoutView`是少数在`GET`请求上修改状态的视图之一，它会注销用户。该视图返回一个重定向响应。我们可以使用`settings.LOGOUT_REDIRECT_URL`来配置用户在注销时将被重定向到的位置。同样，我们可以使用`GET`参数`next`来自定义此行为。'
- en: '`user.views.RegisterView.as_view()`: This is the user registration view we
    will write. Django provides us with a `UserCreationForm` but not a view.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user.views.RegisterView.as_view()`: 这是我们将编写的用户注册视图。Django为我们提供了`UserCreationForm`，但没有视图。'
- en: 'We also need to add a few settings to make Django use our `user` view properly.
    Let''s update `django/config/settings.py` with some new settings:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一些设置，让Django正确使用我们的`user`视图。让我们在`django/config/settings.py`中更新一些新设置：
- en: '[PRE53]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'These three settings tell Django how to redirect the user in different authentication
    scenarios:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个设置告诉Django如何在不同的身份验证场景下重定向用户：
- en: '`LOGIN_URL`: When an unauthenticated user tries to access a page that requires
    authentication, `LoginRequiredMixin` uses this setting.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGIN_URL`：当未经身份验证的用户尝试访问需要身份验证的页面时，`LoginRequiredMixin`使用此设置。'
- en: '`LOGIN_REDIRECT_URL`: When a user logs in, where should we redirect them to?
    Often, we redirect them to a profile page; in our case, the page that shows a
    list of `MailingList`s.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGIN_REDIRECT_URL`：当用户登录时，我们应该将他们重定向到哪里？通常，我们将他们重定向到一个个人资料页面；在我们的情况下，是显示`MailingList`列表的页面。'
- en: '`LOGOUT_REDIRECT_URL`: When a user logs out, where should we redirect them
    to? In our case, the login page.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGOUT_REDIRECT_URL`：当用户注销时，我们应该将他们重定向到哪里？在我们的情况下，是登录页面。'
- en: 'We now have two more tasks left:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还有两项任务：
- en: Creating the login template
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建登录模板
- en: Creating the user registration view and template
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户注册视图和模板
- en: Let's start by making the login template.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从制作登录模板开始。
- en: Creating the login template
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录模板
- en: 'Let''s make our login template in `django/user/templates/registration/login.html`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/user/templates/registration/login.html`中制作我们的登录模板：
- en: '[PRE54]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This form follows all the practices of our previous forms. We use `csrf_token`
    to protect against a CSRF attack. We use the `crsipy` filter to print the form
    using Bootstrap 4 style tags and classes.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单遵循了我们之前表单的所有做法。我们使用`csrf_token`来防止CSRF攻击。我们使用`crsipy`过滤器使用Bootstrap 4样式标签和类打印表单。
- en: Remember, we didn't need to make a view to process our login requests because
    we're using the one that comes with `django.contrib.auth`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们不需要创建一个视图来处理我们的登录请求，因为我们正在使用`django.contrib.auth`中提供的视图。
- en: Next, let's create a view and template to register new users.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个视图和模板来注册新用户。
- en: Creating the user registration view
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户注册视图
- en: Django doesn't come with a view for creating new users, but it does offer a
    form for capturing a new user's registration. We can combine the `UserCreationForm`
    with a `CreateView` to quickly create a `RegisterView`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Django没有为创建新用户提供视图，但它提供了一个用于捕获新用户注册的表单。我们可以将`UserCreationForm`与`CreateView`结合使用，快速创建一个`RegisterView`。
- en: 'Let''s add our view to `django/user/views.py`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/user/views.py`中添加我们的视图：
- en: '[PRE55]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is a very simple `CreateView`, like we've seen a few times in this chapter
    already.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的`CreateView`，就像我们在本章中已经看到的几次一样。
- en: 'Let''s create our template in `django/user/templates/user/register.html`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/user/templates/user/register.html`中创建我们的模板：
- en: '[PRE56]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Again, the template follows the same pattern as our previous `CreateView` templates.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，该模板遵循了我们之前`CreateView`模板的相同模式。
- en: Now, we're ready to run Mail Ape locally.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备在本地运行Mail Ape。
- en: Running Mail Ape locally
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行Mail Ape
- en: Django comes with a development server. This server is not suitable for production
    (or even staging) deployment, but is suitable for local development.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Django自带开发服务器。这个服务器不适合生产（甚至是暂存）部署，但适合本地开发。
- en: 'Let''s start the server using our Django project''s `manage.py` script:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们Django项目的`manage.py`脚本启动服务器：
- en: '[PRE57]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can now access our server on `http://127.0.0.1:8000`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`http://127.0.0.1:8000`上访问我们的服务器。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started our Mail Ape project. We created the Django project
    and started two Django apps. The `mailinglist` app contains our models, views,
    and templates for the mailing list code. The `user` app holds views and templates
    related to users. The `user` app is much simpler because it leverages Django's
    `django.contrib.auth` app.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们启动了Mail Ape项目。我们创建了Django项目并启动了两个Django应用程序。`mailinglist`应用程序包含了我们的邮件列表代码的模型、视图和模板。`user`应用程序包含了与用户相关的视图和模板。`user`应用程序要简单得多，因为它利用了Django的`django.contrib.auth`应用程序。
- en: Next, we'll build an API so that users can integrate with Mail Ape easily.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个API，以便用户可以轻松地与Mail Ape集成。
