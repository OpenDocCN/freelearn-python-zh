- en: Chapter 2. Syntax Best Practices – below the Class Level
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。语法最佳实践-类级别以下
- en: The ability to write an efficient syntax comes naturally with time. If you take
    a look back at your first program, you will probably agree with this. The right
    syntax will appear to your eyes as a good-looking piece of code, and the wrong
    syntax as something disturbing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高效的语法能力随着时间自然而然地产生。如果你回顾一下你的第一个程序，你可能会同意这一点。正确的语法会让你眼前一亮，而错误的语法会让人感到不安。
- en: Besides the algorithms that are implemented and the architectural design for
    your program, taking great care over how it is written weighs heavily on how it
    will evolve. Many programs are ditched and rewritten from scratch because of their
    obtuse syntax, unclear APIs, or unconventional standards.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现的算法和程序的架构设计，对程序的编写方式进行精心设计对其未来的发展至关重要。许多程序因其晦涩的语法、不清晰的API或非常规的标准而被抛弃并从头开始重写。
- en: But Python has evolved a lot in the last few years. So, if you were kidnapped
    for a while by your neighbor (a jealous guy from the local Ruby developers user
    group) and kept away from the news, you will probably be astonished by its new
    features. From the earliest version to the current one (3.5 at this time), a lot
    of enhancements have been made to make the language clearer, cleaner, and easier
    to write. Python basics have not changed drastically, but the tools to play with
    them are now a lot more ergonomic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Python在过去几年里发生了很大的变化。因此，如果你被邻居（当地Ruby开发者用户组的一个嫉妒的家伙）绑架了一段时间并远离了新闻，你可能会对它的新功能感到惊讶。从最早的版本到当前版本（此时为3.5），已经进行了许多增强，使语言更加清晰、干净和易于编写。Python的基础并没有发生根本性的变化，但现在玩耍它们的工具更加人性化。
- en: 'This chapter presents the most important elements of modern syntax and tips
    on their usage:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了现代语法的最重要元素以及有关它们使用的提示：
- en: List comprehensions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导式
- en: Iterators and generators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器和生成器
- en: Descriptors and properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述符和属性
- en: Decorators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: '`with` and `contextlib`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`和`contextlib`'
- en: The code performance tips for speed improvement or memory usage are covered
    in [Chapter 11](ch11.html "Chapter 11. Optimization – General Principles and Profiling
    Techniques"), *Optimization – General Principles and Profiling Techniques*, and
    [Chapter 12](ch12.html "Chapter 12. Optimization – Some Powerful Techniques"),
    *Optimization – Some Powerful Techniques*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有关代码性能提升或内存使用的速度改进的提示在[第11章](ch11.html "第11章。优化-一般原则和分析技术") *优化-一般原则和分析技术*和[第12章](ch12.html
    "第12章。优化-一些强大的技术") *优化-一些强大的技术*中有所涉及。
- en: Python's built-in types
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的内置类型
- en: Python provides a great set of datatypes. This is true for both numeric types
    and also collections. Regarding the numeric types, there is nothing special about
    their syntax. There are, of course, some differences for defining literals of
    every type and some (maybe) not well-known details regarding operators, but there
    aren't a lot of choices left for developers. Things change when it comes to collections
    and strings. Despite the "there should be only one way to do something" mantra,
    the Python developer is really left with plenty of choices. Some of the code patterns
    that seem intuitive and simple to beginners are often considered non-*Pythonic*
    by experienced programmers because they are either inefficient or simply too verbose.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一组很棒的数据类型。这对于数字类型和集合类型都是如此。关于数字类型，它们的语法没有什么特别之处。当然，对于每种类型的字面量定义和一些（也许）不太为人所知的运算符细节有一些差异，但对于开发人员来说，选择余地并不多。当涉及到集合和字符串时情况就不同了。尽管"应该只有一种方法来做某事"的信条，但Python开发人员确实有很多选择。对于初学者来说，一些看起来直观简单的代码模式经常被有经验的程序员认为是非*Pythonic*的，因为它们要么效率低下，要么太啰嗦。
- en: Such *Pythonic* patterns for solving common problems (by many programmers called
    idioms) may often seem like only aesthetics. This cannot be more wrong. Most of
    the idioms are driven by the fact how Python is implemented internally and on
    how built-in structures and modules work. Knowing more of such details is essential
    for a good understanding of the language. Also, the community itself is not free
    from myths and stereotypes about how things in Python work. Only by digging deeper
    yourself, will you be able to tell which of the popular statements about Python
    are really true.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 解决常见问题的*Pythonic*模式（许多程序员称之为习语）通常看起来只是美学。这是完全错误的。大多数习语是由Python内部实现以及内置结构和模块的工作方式驱动的。了解更多这样的细节对于对语言的深入理解至关重要。此外，社区本身也不乏关于Python工作原理的神话和刻板印象。只有通过自己深入挖掘，你才能判断关于Python的流行说法中哪些是真的。
- en: Strings and bytes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串和字节
- en: The topic of strings may provide some confusion for programmers that are used
    to programming only in Python 2\. In Python 3, there is only one datatype capable
    of storing textual information. It is `str` or, simply, string. It is an immutable
    sequence that stores Unicode code points. This is the major difference from Python
    2, where `str` represents byte strings—something that is now handled by the `bytes`
    objects (but not exactly in the same way).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只习惯于在Python 2中编程的程序员来说，字符串可能会带来一些困惑。在Python 3中，只有一种数据类型能够存储文本信息。它是`str`或者简单地说，字符串。它是一个存储Unicode码点的不可变序列。这是与Python
    2的主要区别，其中`str`表示字节字符串-现在由`bytes`对象处理（但处理方式并不完全相同）。
- en: Strings in Python are sequences. This single fact should be enough to include
    them in the section covering other container types, but they differ from other
    container types in one important detail. Strings have very specific limitations
    on what type of data they can store, and that is Unicode text.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的字符串是序列。这一事实应该足以将它们包括在涵盖其他容器类型的部分中，但它们与其他容器类型在一个重要的细节上有所不同。字符串对它们可以存储的数据类型有非常具体的限制，那就是Unicode文本。
- en: '`bytes` and its mutable alternative (`bytearray`) differs from `str` by allowing
    only bytes as a sequence value—integers in the range `0 <= x < 256`. This may
    be confusing at the beginning, since when printed, they may look very similar
    to strings:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`字节`及其可变替代品（`bytearray`）与`str`的不同之处在于只允许字节作为序列值——范围在`0 <= x < 256`的整数。这可能会在开始时造成困惑，因为打印时它们可能看起来与字符串非常相似：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The true nature of `bytes` and `bytearray` is revealed when it is converted
    to another sequence type like `list` or `tuple`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`bytes`和`bytearray`转换为另一种序列类型（如`list`或`tuple`）时，它们的真实性质就显露出来了：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A lot of Python 3 controversy was about breaking the backwards compatibility
    for string literals and how Unicode is dealt with. Starting from Python 3.0, every
    un-prefixed string literal is Unicode. So, literals enclosed by single quotes
    (`''`), double quotes (`"`), or groups of three quotes (single or double) without
    any prefix represent the `str` datatype:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3的许多争议都是关于打破字符串字面量的向后兼容性以及如何处理Unicode。从Python 3.0开始，每个未加前缀的字符串字面量都是Unicode。因此，用单引号（`'`）、双引号（`"`）或三引号（单引号或双引号）括起来的字面量代表`str`数据类型：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In Python 2, the Unicode literals required the `u` prefix (like `u"some string"`).
    This prefix is still allowed for backward compatibility (starting from Python
    3.3), but does not hold any syntactic meaning in Python 3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2中，Unicode字面量需要`u`前缀（如`u"some string"`）。这个前缀仍然允许用于向后兼容（从Python 3.3开始），但在Python
    3中没有任何语法意义。
- en: 'Bytes literals were already presented in some of the previous examples, but
    let''s explicitly present its syntax for the sake of consistency. Bytes literals
    are also enclosed by single quotes, double quotes, or triple quotes, but must
    be preceded by a `b` or `B` prefix:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的一些示例中已经介绍了字节字面量，但为了保持一致，让我们明确介绍其语法。字节字面量也可以用单引号、双引号或三引号括起来，但必须以`b`或`B`前缀开头：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that there is no `bytearray` literals in the Python syntax.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python语法中没有`bytearray`字面量。
- en: 'Last but not least, Unicode strings contain "abstract" text that is independent
    from the byte representation. This makes them unable to be saved on the disk or
    sent over the network without encoding to binary data. There are two ways to encode
    string objects into byte sequences:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，Unicode字符串包含与字节表示独立的“抽象”文本。这使它们无法在磁盘上保存或在网络上传输而不进行编码为二进制数据。有两种方法可以将字符串对象编码为字节序列：
- en: Using the `str.encode(encoding, errors)` method, which encodes the string using
    a registered codec for encoding. Codec is specified using the `encoding` argument,
    and, by default, it is `'utf-8'`. The second errors argument specifies the error
    handling scheme. It can be `'strict'` (default), `'ignore'`, `'replace'`, `'xmlcharrefreplace'`,
    or any other registered handler (refer to the built-in `codecs` module documentation).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`str.encode(encoding, errors)`方法，使用注册的编解码器对字符串进行编码。编解码器使用`encoding`参数指定，默认为`'utf-8'`。第二个errors参数指定错误处理方案。它可以是`'strict'`（默认值）、`'ignore'`、`'replace'`、`'xmlcharrefreplace'`或任何其他已注册的处理程序（参考内置`codecs`模块文档）。
- en: Using the `bytes(source, encoding, errors)` constructor, which creates a new
    bytes sequence. When the source is of the `str` type, then the `encoding` argument
    is obligatory and it does not have a default value. The usage of the `encoding`
    and `errors` arguments is the same as for the `str.encode()` method.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bytes(source, encoding, errors)`构造函数创建一个新的字节序列。当源是`str`类型时，`encoding`参数是必需的，且没有默认值。`encoding`和`errors`参数的使用与`str.encode()`方法相同。
- en: 'Binary data represented by `bytes` can be converted to a string in the analogous
    ways:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由`bytes`表示的二进制数据可以以类似的方式转换为字符串：
- en: Using the `bytes.decode(encoding, errors)` method, which decodes the bytes using
    the codec registered for encoding. The arguments of this method have the same
    meaning and defaults as the arguments of `str.encode()`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bytes.decode(encoding, errors)`方法，使用为编码注册的编解码器对字节进行解码。此方法的参数与`str.encode()`的参数具有相同的含义和默认值。
- en: Using the `str(source, encoding, error)` constructor, which creates a new string
    instance. Similar to the `bytes()` constructor, the `encoding` argument in the
    `str()` call has no default value and must be provided if the bytes sequence is
    used as a source.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`str(source, encoding, error)`构造函数创建一个新的字符串实例。与`bytes()`构造函数类似，`str()`调用中的`encoding`参数没有默认值，如果字节序列用作源，则必须提供。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Naming – bytes versus byte string**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名——字节与字节字符串**'
- en: Due to changes made in Python 3, some people tend to refer to the `bytes` instances
    as byte strings. This is mostly due to historic reasons—`bytes` in Python 3 is
    the sequence type that is the closest one to the `str` type from Python 2 (but
    not the same). Still, the `bytes` instance is a sequence of bytes and also does
    not need to represent textual data. So, in order to avoid any confusion, it is
    advisable to always refer to them as either `bytes` or a byte sequence despite
    their similarities to strings. The concept of strings is reserved for textual
    data in Python 3 and this is now always `str`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python 3中的更改，一些人倾向于将`bytes`实例称为字节字符串。这主要是由于历史原因——Python 3中的`bytes`是与Python
    2中的`str`类型最接近的序列类型（但不完全相同）。但是，`bytes`实例是字节序列，也不需要表示文本数据。因此，为了避免混淆，最好总是将它们称为`bytes`或字节序列，尽管它们与字符串相似。在Python
    3中，字符串的概念是保留给文本数据的，现在始终是`str`。
- en: Implementation details
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现细节
- en: Python strings are immutable. This is also true to byte sequences. This is an
    important fact because it has both advantages and disadvantages. It also affects
    the way strings should be handled in Python efficiently. Thanks to immutability,
    strings can be used as dictionary keys or `set` collection elements because once
    initialized, they will never change their value. On the other hand, whenever a
    modified string is required (even with only tiny modification), a completely new
    instance needs to be created. Fortunately, `bytearray` as a mutable version of
    `bytes` does not introduce such an issue. Byte arrays can be modified in-place
    (without the need of new object creation) through item assignments and can be
    dynamically resized exactly like lists—using appends, pops, inserts, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串是不可变的。这也适用于字节序列。这是一个重要的事实，因为它既有优点又有缺点。它还影响了在Python中高效处理字符串的方式。由于不可变性，字符串可以用作字典键或`set`集合元素，因为一旦初始化，它们将永远不会改变其值。另一方面，每当需要修改字符串（即使只有微小的修改）时，都需要创建一个全新的实例。幸运的是，`bytearray`作为`bytes`的可变版本不会引入这样的问题。字节数组可以通过项目赋值进行就地修改（无需创建新对象），并且可以像列表一样动态调整大小
    - 使用附加、弹出、插入等。
- en: String concatenation
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接
- en: 'Knowing the fact that Python strings are immutable imposes some problems when
    multiple string instances need to be joined together. As stated before, concatenating
    any immutable sequences result in the creation of a new sequence object. Consider
    that a new string is built by the repeated concatenation of multiple strings,
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 知道Python字符串是不可变的这个事实会在需要连接多个字符串实例时带来一些问题。如前所述，连接任何不可变序列都会导致创建一个新的序列对象。考虑到通过多个字符串的重复连接构建新字符串，如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will result in a quadratic runtime cost in the total string length. In
    other words, it is highly inefficient. For handling such situations, there is
    the `str.join()` method available. It accepts iterable of strings as the argument
    and returns a joined string. Because it is the method, the actual idiom uses the
    empty string literal as a source of method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致总字符串长度的二次运行时成本。换句话说，这是非常低效的。为了处理这种情况，有`str.join()`方法可用。它接受字符串的可迭代对象作为参数并返回一个连接的字符串。因为它是方法，实际的习惯用法使用空字符串文字作为方法的来源：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The string providing this method will be used as a separator between joined
    substrings; consider the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 提供此方法的字符串将用作连接的子字符串之间的分隔符；请考虑以下示例：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is worth remembering that just because it is faster (especially for large
    lists), it does not mean that the `join()` method should be used in every situation
    where two strings need to be concatenated. Despite being a widely recognized idiom,
    it does not improve code readability – and readability counts! There are also
    some situations where `join()` may not perform as well as ordinary concatenation
    through addition. Here some examples of them:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，仅仅因为它更快（特别是对于大型列表），并不意味着在每个需要连接两个字符串的情况下都应该使用`join()`方法。尽管它是一个广泛认可的习惯用法，但它并不会提高代码的可读性
    - 可读性很重要！还有一些情况下，`join()`可能不如普通的加法连接表现得好。以下是一些例子：
- en: If the number of substrings is small and they are not contained already by some
    iterable—in some cases, an overhead of creating a new sequence just to perform
    concatenation can overshadow the gain of using `join()`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子字符串的数量很少，并且它们尚未被某个可迭代对象包含 - 在某些情况下，创建新序列的开销可能会掩盖使用`join()`的收益。
- en: When concatenating short literals, thanks to constant folding in CPython, some
    complex literals (not only strings) such as `'a' + 'b' + 'c'` to `'abc'` can be
    translated to a shorter form at compile time. Of course, this is enabled only
    for constants (literals) that are relatively short.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在连接短文字时，由于CPython中的常量折叠，一些复杂的文字（不仅仅是字符串），例如`'a' + 'b' + 'c'`到`'abc'`可以在编译时转换为更短的形式。当然，这仅对相对较短的常量（文字）启用。
- en: Ultimately, the best readability of string concatenation if the number of strings
    is known beforehand is ensured by proper string formatting, by either using the
    `str.format()` method or the `%` operator. In code sections where the performance
    is not critical or gain from optimizing string concatenation is very little, string
    formatting is recommended as the best alternative.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如果字符串连接的数量事先已知，最佳的可读性是通过适当的字符串格式化来确保的，可以使用`str.format()`方法或`%`运算符。在性能不是关键或优化字符串连接的收益非常小的代码部分，建议使用字符串格式化作为最佳选择。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Constant folding and peephole optimizer**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**常量折叠和窥孔优化器**'
- en: CPython uses the peephole optimizer on compiled source code in order to improve
    performance. This optimizer implements a number of common optimizations directly
    on Python's byte code. As mentioned, constant folding is one such feature. The
    resulting constants are limited in length by a hardcoded value. In Python 3.5,
    it is still invariably equal to 20\. Anyway, this particular detail is rather
    a curiosity than a thing that can be relied on in day-to-day programming. Information
    of other interesting optimizations performed by peephole optimizer can be found
    in the `Python/peephole.c` file of Python's source code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CPython在编译源代码上使用窥孔优化器以提高性能。该优化器直接在Python的字节码上实现了许多常见的优化。如前所述，常量折叠就是其中之一。生成的常量受硬编码值的长度限制。在Python
    3.5中，它仍然不变，等于20。无论如何，这个特定的细节更像是一个好奇心，而不是日常编程中可以依赖的东西。有关窥孔优化器执行的其他有趣优化的信息可以在Python源代码的`Python/peephole.c`文件中找到。
- en: Collections
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'Python provides a good selection of built-in data collections that allows you
    to efficiently solve many problems if you choose wisely. Types that you probably
    already know are those that have dedicated literals:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一系列内置的数据集合，如果选择得当，可以有效地解决许多问题。您可能已经知道的类型是那些具有专用文字的类型：
- en: Lists
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Tuples
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Dictionaries
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Sets
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Python is of course not limited to these four and it extends the list of possible
    choices through its standard library. In many cases, the solution to a problem
    may be as simple as making a good choice for data structure. This part of the
    book aims to ease such a decision by providing deeper insight into the possible
    options.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Python不仅限于这四种选择，并通过其标准库扩展了可能的选择列表。在许多情况下，解决问题的解决方案可能就像为数据结构做出良好选择一样简单。本书的这一部分旨在通过深入了解可能的选择来简化这样的决定。
- en: Lists and tuples
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表和元组
- en: The two most basic collection types in Python are lists and tuples, and they
    both represent sequences of objects. The basic difference between them should
    be obvious for anyone who has spent more than a few hours with Python—lists are
    dynamic so can change their size, while tuples are immutable (they cannot be modified
    after they are created).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python中最基本的两种集合类型是列表和元组，它们都表示对象的序列。它们之间的基本区别对于任何花费了几个小时以上的Python用户来说应该是显而易见的—列表是动态的，因此可以改变其大小，而元组是不可变的（它们在创建后无法修改）。
- en: Tuples, despite having many various optimizations that makes allocation/deallocation
    of small objects fast, are the recommended datatype for structures where the position
    of the element is information by itself. For example, tuple may be a good choice
    for storing a pair of (x, y) coordinates. Anyway, details regarding tuples are
    rather uninteresting. The only important thing about them in the scope of this
    chapter is that `tuple` is **immutable** and thus **hashable**. What this means
    will be covered later in a *Dictionaries* section. More interesting than tuple
    is its dynamic counterpart, `list`, how it really works, and how to deal with
    it efficiently.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管元组具有许多各种优化，使得小对象的分配/释放变得快速，但它们是存储元素位置本身信息的推荐数据类型。例如，元组可能是存储一对(x, y)坐标的良好选择。无论如何，关于元组的细节都相当无聊。在本章的范围内，它们唯一重要的事情是`tuple`是**不可变的**，因此**可散列的**。这意味着什么将在*字典*部分中介绍。比元组更有趣的是它的动态对应物`list`，它是如何工作的，以及如何有效地处理它。
- en: Implementation details
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现细节
- en: Many programmers easily confuse Python's `list` type with the concept of linked
    lists found often in standard libraries of other languages such as C, C++, or
    Java. In fact, CPython lists are not lists at all. In CPython, lists are implemented
    as variable length arrays. This should also be true for other implementations
    such as Jython and IronPython, although such implementation details are often
    not documented in these projects. The reasons for such confusion are clear. This
    datatype is named **list** and also has an interface that could be expected from
    any linked list implementation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员很容易将Python的`list`类型与其他语言的标准库中经常找到的链表概念混淆，比如C、C++或Java。实际上，在CPython中，列表根本不是列表。在CPython中，列表是作为可变长度数组实现的。尽管这些实现细节通常在这些项目中没有记录，但这对于Jython和IronPython等其他实现也是正确的。造成这种混淆的原因很明显。这种数据类型被命名为**list**，并且还具有可以从任何链表实现中预期的接口。
- en: Why is it important and what does it mean? Lists are one of the most popular
    data structures and the way they are used greatly affects every application's
    performance. Also, CPython is the most popular and used implementation, so knowing
    its internal implementation details is crucial.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么重要，意味着什么？列表是最流行的数据结构之一，它们的使用方式极大地影响了每个应用程序的性能。此外，CPython是最流行和使用最广泛的实现，因此了解其内部实现细节至关重要。
- en: 'In detail, lists in Python is a contiguous array of references to other objects.
    The pointer to this array and the length is stored in a lists head structure.
    This means that every time an item is added or removed, the array of references
    needs to be resized (reallocated). Fortunately, in Python, these arrays are created
    with exponential over-allocation, so not every operation requires a resize. This
    is how the amortized cost of appending and popping elements can be low in terms
    of complexity. Unfortunately, some other operations that are considered "cheap"
    in ordinary linked lists have relatively high computational complexity in Python:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，Python中的列表是对其他对象的连续数组的引用。指向此数组的指针和长度存储在列表头结构中。这意味着每次添加或删除项目时，都需要调整引用数组的大小（重新分配）。幸运的是，在Python中，这些数组是以指数过分分配创建的，因此不是每个操作都需要调整大小。这就是为什么在复杂度方面，附加和弹出元素的摊销成本可以很低。不幸的是，在Python中，一些在普通链表中被认为是“便宜”的其他操作具有相对较高的计算复杂度：
- en: Inserting an item at arbitrary place using the `list.insert` method—complexity
    O(n)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`list.insert`方法在任意位置插入项目—复杂度为O(n)
- en: Deleting an item using `list.delete` or using `del`—complexity O(n)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`list.delete`或使用`del`删除项目—复杂度为O(n)
- en: 'Here, *n* is the length of a list. At least retrieving or setting an element
    using index is an operation that cost is independent of the list''s size. Here
    is a full table of average time complexities for most of the list operations:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*n*是列表的长度。至少使用索引检索或设置元素是一个与列表大小无关的操作。以下是大多数列表操作的平均时间复杂度的完整表格：
- en: '| Operation | Complexity |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 复杂度 |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '- --- | --- |'
- en: '| Copy | O(n) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '- 复制 | O(n) |'
- en: '| Append | O(1) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '- 添加 | O(1) |'
- en: '| Insert | O(n) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '- 插入 | O(n) |'
- en: '| Get item | O(1) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '- 获取项目 | O(1) |'
- en: '| Delete item | O(n) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '- 删除项目 | O(n) |'
- en: '| Iteration | O(n) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '- 迭代 | O(n) |'
- en: '| Get slice of length *k* | O(k) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '- 获取长度为*k*的切片 | O(k) |'
- en: '| Del slice | O(n) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '- 删除切片 | O(n) |'
- en: '| Set slice of length *k* | O(k+n) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '- 设置长度为*k*的切片 | O(k+n) |'
- en: '| Extend | O(k) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '- 扩展 | O(k) |'
- en: '| Multiply by *k* | O(nk) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '- 乘以*k* | O(nk) |'
- en: '| Test existence (`element in list`) | O(n) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '- 测试存在性（`element in list`） | O(n) |'
- en: '| `min()`/`max()` | O(n) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '- `min()`/`max()` | O(n) |'
- en: '| Get length | O(1) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '- 获取长度 | O(1) |'
- en: For situations where a real linked list is needed (or simply, a data structure
    that has `appends` and `pop` at each side at O(1) complexity), Python provides
    `deque` in `collections` built-in module. This is a generalization of stacks and
    queues and should work fine anywhere where a doubly linked list is required.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要真正的链表（或者简单地说，具有`appends`和`pop`的数据结构，复杂度为O(1)）的情况下，Python在`collections`内置模块中提供了`deque`。这是栈和队列的一般化，应该在需要双向链表的任何地方都能正常工作。
- en: List comprehensions
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表推导
- en: 'As you probably know, writing a piece of code such as this is painful:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能知道的，编写这样的代码是痛苦的：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This may work for C, but it actually makes things slower for Python because:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于C语言可能有效，但实际上对于Python来说会使事情变慢，因为：
- en: It makes the interpreter work on each loop to determine what part of the sequence
    has to be changed
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使解释器在每次循环中工作，以确定序列的哪一部分必须被更改
- en: It makes you keep a counter to track what element has to be treated
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使您保持一个计数器来跟踪哪个元素必须被处理
- en: It requires an additional function lookup to be performed at every iteration
    because `append()` is a list's method
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要在每次迭代时执行额外的函数查找，因为`append()`是列表的方法
- en: 'A list comprehension is the correct answer to this pattern. It uses wired features
    that automate parts of the previous syntax:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导是这种模式的正确答案。它使用了自动化前一种语法的部分的奇怪特性：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Besides the fact that this writing is more efficient, it is way shorter and
    involves fewer elements. In a bigger program, this means fewer bugs and code that
    is easier to read and understand.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种写法更有效外，它更短，涉及的元素更少。在更大的程序中，这意味着更少的错误和更容易阅读和理解的代码。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**List comprehensions and internal array resize**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表推导和内部数组调整**'
- en: There is a myth among some Python programmers that the list comprehensions can
    be a workaround for the fact that the internal array representing the list object
    must be resized with every few additions. Some say that the array will be allocated
    once in just the right size. Unfortunately, this isn't true.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种迷思在一些Python程序员中流传，即列表推导可以是内部数组代表列表对象必须在每次添加时调整大小的一种变通方法。有人说数组将在恰到好处的大小时只分配一次。不幸的是，这是不正确的。
- en: The interpreter during evaluation of the comprehension can't know how big the
    resulting container will be and it can't preallocate the final size of the array
    for it. Due to this, the internal array is reallocated in the same pattern as
    it would be in the `for` loop. Still, in many cases, list creation using comprehensions
    is both cleaner and faster than using ordinary loops.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算推导时，解释器无法知道最终容器的大小，也无法为其预分配数组的最终大小。因此，内部数组的重新分配与`for`循环中的模式相同。然而，在许多情况下，使用推导创建列表既更清晰又更快，而不是使用普通循环。
- en: Other idioms
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他习惯用法
- en: 'Another typical example of a Python idiom is the usage of `enumerate`. This
    built-in function provides a convenient way to get an index when a sequence is
    used in a loop. Consider the following piece of code as an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Python习惯用法的另一个典型例子是使用`enumerate`。这个内置函数提供了一种方便的方法，在循环中使用序列时获得索引。考虑以下代码片段作为例子：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This can be replaced by the following code, which is shorter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被以下更短的代码替换：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the elements of multiple lists (or any iterables) need to be aggregated
    in a one-by-one fashion, then the built-in `zip()` function may be used. This
    is a very common pattern for uniform iteration over two same-sized iterables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将多个列表（或任何可迭代对象）的元素以一对一的方式聚合时，可以使用内置的`zip()`函数。这是对两个相同大小的可迭代对象进行统一迭代的非常常见的模式：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that the results of `zip()` can be reversed by another `zip()` call:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`zip()`的结果可以通过另一个`zip()`调用进行反转：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another popular syntax element is sequence unpacking. It is not limited to
    lists and tuples and will work with any sequence type (even strings and byte sequences).
    It allows you to unpack a sequence of elements into another set of variables as
    long as there are as many variables on the left-hand side of the assignment operator
    as the number of elements in the sequence:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的语法元素是序列解包。它不仅限于列表和元组，而且适用于任何序列类型（甚至字符串和字节序列）。它允许您将一系列元素解包到另一组变量中，只要在赋值运算符的左侧有与序列中元素数量相同的变量：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unpacking also allows you to capture multiple elements in a single variable
    using starred expressions as long as it can be interpreted unambiguously. Unpacking
    can also be performed on nested sequences. This can come in handy especially when
    iterating on some complex data structures built of sequences. Here are some examples
    of more complex unpacking:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 解包还允许您使用星号表达式捕获单个变量中的多个元素，只要它可以被明确解释。解包也可以在嵌套序列上执行。当在由序列构建的一些复杂数据结构上进行迭代时，这可能会很方便。以下是一些更复杂解包的示例：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Dictionaries
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: 'Dictionaries are one of the most versatile data structures in Python. `dict`
    allows to map a set of unique keys to values as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是Python中最通用的数据结构之一。`dict`允许将一组唯一的键映射到值，如下所示：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Dictionary literals are a very basic thing and you should already know them.
    Anyway, Python allows programmers to also create a new dictionary using comprehensions
    similar to the list comprehensions mentioned earlier. Here is a very simple example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 字典文字是一件非常基本的事情，你应该已经知道它们。无论如何，Python允许程序员使用类似于前面提到的列表推导的推导来创建一个新的字典。这是一个非常简单的例子：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What is important is that the same benefits of using list comprehensions apply
    to dictionary comprehensions. So, in many cases, they are more efficient, shorter,
    and cleaner. For more complex code, when many `if` statements or function calls
    are required to create a dictionary, the simple `for` loop may be a better choice,
    especially if it improves the readability.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，使用列表推导的相同好处也适用于字典推导。因此，在许多情况下，它们更有效、更短、更清晰。对于更复杂的代码，当需要许多`if`语句或函数调用来创建字典时，简单的`for`循环可能是更好的选择，特别是如果它提高了可读性。
- en: 'For Python programmers new to Python 3, there is one important note about iterating
    over dictionary elements. The dictionary methods: `keys()`, `values()`, and `items()`
    no longer have lists as their return value types. Also, their counterparts `iterkeys()`,
    `itervalues()`, and `iteritems()` that returned iterators instead are missing
    in Python 3\. Instead, what `keys()`, `values()`, and `items()` return now are
    view objects:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 3中的Python程序员，有一个关于迭代字典元素的重要说明。字典方法：`keys()`、`values()`和`items()`不再具有列表作为它们的返回值类型。此外，它们的对应方法`iterkeys()`、`itervalues()`和`iteritems()`在Python
    3中已经消失，而不是返回迭代器。现在，`keys()`、`values()`和`items()`返回的是视图对象：
- en: '`keys()`: This returns the `dict_keys` object that provides a view on all the
    keys of a dictionary'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys()`: 这返回`dict_keys`对象，提供了字典的所有键的视图'
- en: '`values()`: This returns the `dict_values` object that provides views on all
    the values of a dictionary'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`: 这返回`dict_values`对象，提供了字典的所有值的视图'
- en: '`items()`: This returns the `dict_items` object providing views on all `(key,
    value)` two tuples of a dictionary'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items()`: 这返回`dict_items`对象，提供了字典的所有`(key, value)`两个元组的视图'
- en: 'View objects provide a view on the dictionary content in a dynamic way, so
    every time the dictionary changes, the views will reflect these changes, as shown
    in this example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 视图对象以动态方式查看字典内容，因此每次字典发生更改，视图都会反映这些更改，如下例所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: View objects join the behavior of lists returned by implementation of old methods
    with iterators returned by their "iter" counterparts. Views do not need to redundantly
    store all values in memory (like lists do), but still allow getting their length
    (using `len`) and testing membership (using the `in` clause). Views are, of course,
    iterable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 视图对象将旧方法的返回列表的行为与它们的“iter”对应方法返回的迭代器相结合。视图不需要在内存中冗余存储所有值（像列表一样），但仍然允许获取它们的长度（使用`len`）和测试成员资格（使用`in`子句）。视图当然是可迭代的。
- en: The last important thing is that both views returned by the `keys()` and `values()`
    methods ensure the same order of keys and values. In Python 2, you could not modify
    the dictionary content between these two calls if you wanted to ensure the same
    order of retrieved keys and values. `dict_keys` and `dict_values` are now dynamic
    so even if the content of a dictionary will change between `keys()` and `values()`
    calls, the order of iteration is consistent between these two views.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要的事情是`keys()`和`values()`方法返回的两个视图确保了相同的键和值顺序。在Python 2中，如果要确保检索到的键和值的顺序相同，你不能在这两个调用之间修改字典内容。`dict_keys`和`dict_values`现在是动态的，因此即使在`keys()`和`values()`调用之间更改字典的内容，迭代的顺序也在这两个视图之间保持一致。
- en: Implementation details
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现细节
- en: CPython uses hash tables with pseudo-random probing as an underlying data structure
    for dictionaries. It seems like a very deep implementation detail, but it is very
    unlikely to change in the near future, so it is also a very interesting fact for
    the programmer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: CPython使用伪随机探测的哈希表作为字典的底层数据结构。这似乎是一个非常深入的实现细节，但在不久的将来很不可能改变，因此对于程序员来说也是一个非常有趣的事实。
- en: 'Due to this implementation detail, only objects that are **hashable** can be
    used as a dictionary key. An object is hashable if it has a hash value that never
    changes during its lifetime and can be compared to different objects. Every Python''s
    built-in type that is immutable is also hashable. Mutable types such as list,
    dictionaries, and sets are not hashable and so they cannot be used as dictionary
    keys. Protocol that defines if a type is hashable consists of two methods:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个实现细节，只有**可哈希**的对象才能用作字典键。如果一个对象是可哈希的，那么它在其生命周期内的哈希值永远不会改变，并且可以与不同的对象进行比较。每个Python的内置类型都是不可变的，因此也是可哈希的。可变类型，如列表、字典和集合，是不可哈希的，因此不能用作字典键。定义类型是否可哈希的协议由两个方法组成：
- en: '`__hash__`: This provides the hash value (as an integer) that is needed by
    the internal `dict` implementation. For objects that are instances of user-defined
    classes, it is derived from their `id()`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__hash__`: 这提供了内部`dict`实现所需的哈希值（作为整数）。对于用户定义类的实例对象，它是从它们的`id()`派生的。'
- en: '`__eq__`: This compares if two objects that have the same value. All objects
    that are instances of user-defined classes compare unequal, by default, except
    for themselves.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__eq__`: 这比较具有相同值的两个对象。默认情况下，所有用户定义类的实例对象都不相等，除了它们自己。'
- en: Two objects that are compared equal must have the same hash value. The reverse
    does not need to be true. This means collisions of hashes are possible—two objects
    with the same hash may not be equal. It is allowed, and every Python implementation
    must be able to resolve hash collisions. CPython uses **open addressing** to resolve
    such collisions ([https://en.wikipedia.org/wiki/Open_addressing](https://en.wikipedia.org/wiki/Open_addressing)).
    Still, the probability of collisions greatly affects performance, and if it is
    high, the dictionary will not benefit from its internal optimizations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 相等的两个对象必须具有相同的哈希值。反之则不需要成立。这意味着哈希碰撞是可能的——具有相同哈希的两个对象可能不相等。这是允许的，每个Python实现都必须能够解决哈希碰撞。CPython使用**开放寻址**来解决这种碰撞（[https://en.wikipedia.org/wiki/Open_addressing](https://en.wikipedia.org/wiki/Open_addressing)）。然而，碰撞的概率极大地影响性能，如果碰撞概率很高，字典将无法从其内部优化中受益。
- en: 'While three basic operations: adding, getting, and deleting an item have an
    average time complexity equal to O(1), their amortized worst case complexities
    are a lot higher—O(n), where *n* is the current dictionary size. Additionally,
    if user-defined class objects are used as dictionary keys and they are hashed
    improperly (with a high risk of collisions), then this will have a huge negative
    impact on the dictionary performance. The full table of CPyhton''s time complexities
    for dictionaries is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然三个基本操作：添加、获取和删除项目的平均时间复杂度为O(1)，但它们的摊销最坏情况复杂度要高得多——O(n)，其中*n*是当前字典大小。此外，如果将用户定义的类对象用作字典键，并且它们的哈希不当（存在高风险的碰撞），那么这将对字典的性能产生巨大的负面影响。CPython字典的完整时间复杂度表如下：
- en: '| Operation | Average complexity | Amortized worst case complexity |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 平均复杂度 | 分摊最坏情况复杂度 |'
- en: '| --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Get item | O(1) | O(n) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 获取项 | O(1) | O(n) |'
- en: '| Set item | O(1) | O(n) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 集合项 | O(1) | O(n) |'
- en: '| Delete item | O(1) | O(n) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 删除项 | O(1) | O(n) |'
- en: '| Copy | O(n) | O(n) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 复制 | O(n) | O(n) |'
- en: '| Iteration | O(n) | O(n) |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 迭代 | O(n) | O(n) |'
- en: It is also important to know that the *n* number in worst-case complexities
    for copying and iterating the dictionary is the maximum size that the dictionary
    ever achieved, rather than the current item count. In other words, iterating over
    the dictionary that once was huge but has greatly shrunk in time may take a surprisingly
    long time. So, in some cases, it may be better to create a new dictionary object
    if it has to be iterated often instead of just removing elements from the previous
    one.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点很重要，那就是复制和迭代字典的最坏情况复杂度中的*n*是字典曾经达到的最大大小，而不是当前的项数。换句话说，迭代曾经很大但在时间上大大缩小的字典可能需要花费出乎意料的长时间。因此，在某些情况下，如果需要经常迭代，可能最好创建一个新的字典对象，而不是仅仅从以前的字典中删除元素。
- en: Weaknesses and alternatives
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 弱点和替代方案
- en: 'One of the common pitfalls of using dictionaries is that they do not preserve
    the order of elements in which new keys were added. In some scenarios, when dictionary
    keys use consecutive keys whose hashes are also consecutive values (for example,
    using integers), the resulting order might be the same due to the internal implementation
    of dictionaries:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典的一个常见陷阱是它们不保留添加新键的顺序。在某些情况下，当字典键使用连续的键，其哈希值也是连续的值（例如使用整数）时，由于字典的内部实现，结果顺序可能是相同的：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Still, using other datatypes which hash differently shows that the order is
    not preserved. Here is an example in CPython:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用其他哈希方式不同的数据类型表明顺序不会被保留。以下是CPython的一个例子：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As shown in the preceding code, the resulting order is both dependent on the
    hashing of the object and also on the order in which the elements were added.
    This is not what can be relied on because it can vary with different Python implementations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，结果顺序既取决于对象的哈希，也取决于添加元素的顺序。这是不可靠的，因为它可能会随着不同的Python实现而变化。
- en: 'Still, in some cases, the developer might need dictionaries that preserve the
    order of additions. Fortunately, the Python standard library provides an ordered
    dictionary called `OrderedDict` in the `collections` module. It optionally accepts
    an iterable as the initialization argument:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，开发人员可能需要保留添加顺序的字典。幸运的是，Python标准库在`collections`模块中提供了一个有序字典`OrderedDict`。它可以选择接受一个可迭代对象作为初始化参数：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It also has some additional features such as popping items from both ends using
    the `popitem()` method or moving the specified element to one of the ends using
    the `move_to_end()` method. A full reference on that collection is available in
    the Python documentation (refer to [https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它还具有一些额外的功能，比如使用`popitem()`方法从两端弹出项，或者使用`move_to_end()`方法将指定的元素移动到其中一个端点。有关该集合的完整参考，请参阅Python文档（参见[https://docs.python.org/3/library/collections.html](https://docs.python.org/3/library/collections.html)）。
- en: The other important note is that in very old code bases, `dict` may be used
    as a primitive set implementation that ensures the uniqueness of elements. While
    this will give proper results, this should be omitted unless Python versions lower
    than 2.3 are targeted. Using dictionaries this way is wasteful in terms of resources.
    Python has a built-in `set` type that serves this purpose. In fact, it has a very
    similar internal implementation to dictionaries in CPython, but offers some additional
    features as well as specific set-related optimizations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的注意事项是，在非常古老的代码库中，`dict`可能被用作保证元素唯一性的原始集合实现。虽然这会给出正确的结果，但除非针对的是低于2.3的Python版本，否则应该避免这样做。以这种方式使用字典在资源方面是浪费的。Python有一个内置的`set`类型来实现这个目的。实际上，它在CPython中有一个非常相似的内部实现，但也提供了一些额外的功能以及特定的与集合相关的优化。
- en: Sets
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'Sets are a very robust data structure that are useful mostly in situations
    where the order of elements is not as important as their uniqueness and efficiency
    of testing if an element is contained by a collection. They are very similar to
    analogous mathematic concepts. Sets are provided as built-in types in two flavors:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一种非常健壮的数据结构，主要在元素的顺序不如它们的唯一性和测试效率重要的情况下非常有用。它们与类似的数学概念非常相似。集合以两种形式作为内置类型提供：
- en: '`set()`: This is a mutable, non-ordered, finite collection of unique, immutable
    (hashable) objects'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set()`: 这是一个可变的、无序的、有限的唯一不可变（可哈希）对象的集合'
- en: '`frozenset()`: This is an immutable, hashable, non-ordered collection of unique,
    immutable (hashable) objects'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frozenset()`: 这是一个不可变的、可哈希的、无序的唯一不可变（可哈希）对象的集合'
- en: 'The immutability of `frozenset()` makes it possible to be used as dictionary
    keys and also other `set()` and `frozenset()` elements. A plain mutable `set()`
    cannot be used within another set or frozenset content as this will raise `TypeError`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`frozenset()`的不可变性使其可以用作字典键，也可以用作其他`set()`和`frozenset()`元素。普通的可变`set()`不能在另一个集合或frozenset内容中使用，否则会引发`TypeError`：'
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following set initializations are completely correct:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的集合初始化是完全正确的：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Mutable sets can be created in three ways:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可变集合可以通过三种方式创建：
- en: Using a `set()` call that accepts optional iterable as the initialization argument,
    such as `set([0, 1, 2])`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接受可选可迭代对象作为初始化参数的`set()`调用，比如`set([0, 1, 2])`
- en: Using a set comprehension such as `{element for element in range(3)}`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合推导，例如`{element for element in range(3)}`
- en: Using set literals such as `{1, 2, 3}`
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合字面量，例如`{1, 2, 3}`
- en: Note that using literals and comprehensions for sets requires extra caution
    because they are very similar in form to dictionary literals and comprehensions.
    Also, there is no literal for empty set objects—empty curly brackets `{}` are
    reserved for empty dictionary literals.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于集合，使用文字和理解需要额外小心，因为它们在形式上与字典文字和理解非常相似。此外，空集对象没有文字 - 空花括号`{}`保留用于空字典文字。
- en: Implementation details
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现细节
- en: Sets in CPython are very similar to dictionaries. As a matter of fact, they
    are implemented like dictionaries with dummy values, where only keys are actual
    collection elements. Also, sets exploit this lack of values in mapping for additional
    optimizations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPython中，集合与字典非常相似。事实上，它们是使用虚拟值实现的字典，其中只有键是实际的集合元素。此外，集合利用映射中缺少值的优化。
- en: Thanks to this, sets allow very fast additions, deletions, and checking for
    element existence with the average time complexity equal to O(1). Still, since
    the implementation of sets in CPython relies on a similar hash table structure,
    the worst-case complexity for these operations is O(n), where *n* is the current
    size of a set.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点，集合允许非常快速的添加、删除和检查元素是否存在，平均时间复杂度为O(1)。然而，由于CPython中集合的实现依赖于类似的哈希表结构，这些操作的最坏情况复杂度为O(n)，其中*n*是集合的当前大小。
- en: Other implementation details also apply. The item to be included in a set must
    be hashable, and if instances of user-defined classes in a set are hashed poorly,
    this will have a negative impact on the performance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 其他实现细节也适用。要包含在集合中的项目必须是可散列的，如果用户定义类的实例在集合中的哈希值很差，这将对性能产生负面影响。
- en: Beyond basic collections – the collections module
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本集合之外 - collections模块
- en: 'Every data structure has its shortcomings. There is no single collection that
    can suit every problem and four basic types of them (tuple, list, set, and dictionary)
    is still not a wide range of choices. These are the most basic and important collections
    that have a dedicated literal syntax. Fortunately, Python provides a lot more
    options in its standard library through the `collections` built-in module. One
    of them was already mentioned (`deque`). Here are the most important collections
    provided by this module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每种数据结构都有其缺点。没有单一的集合可以适用于每个问题，而且四种基本类型（元组、列表、集合和字典）仍然不是一种广泛的选择。这些是最基本和重要的集合，具有专用的文字语法。幸运的是，Python在其标准库中提供了更多选项，通过`collections`内置模块。其中一个已经提到了（`deque`）。以下是此模块提供的最重要的集合：
- en: '`namedtuple()`: This is a factory function for creating tuple subclasses whose
    indexes can be accessed as named attributes'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namedtuple()`：这是一个用于创建元组子类的工厂函数，其索引可以作为命名属性访问'
- en: '`deque`: This is a double-ended queue, list-like generalization of stacks and
    queues with fast appends and pops on both ends'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deque`：这是一个双端队列，类似于堆栈和队列的列表泛化，可以在两端快速添加和弹出'
- en: '`ChainMap`: This is a dictionary-like class to create a single view of multiple
    mappings'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChainMap`：这是一个类似字典的类，用于创建多个映射的单个视图'
- en: '`Counter`: This is a dictionary subclass for counting hashable objects'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`：这是一个用于计算可散列对象的字典子类'
- en: '`OrderedDict`: This is a dictionary subclass that preserves the order the entries
    were added in'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`：这是一个保留条目添加顺序的字典子类'
- en: '`defaultdict`: This is a dictionary subclass that can supply missing values
    with a provided default'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`：这是一个字典子类，可以使用提供的默认值提供缺失的值'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More details on selected collections from the collections module and some advice
    on where it is worth using them are provided in [Chapter 12](ch12.html "Chapter 12. Optimization
    – Some Powerful Techniques"), *Optimization – Some Powerful Techniques*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有关来自collections模块的选定集合的更多详细信息以及在何处值得使用它们的建议，请参见[第12章](ch12.html "第12章。优化 - 一些强大的技术")，“优化
    - 一些强大的技术”。
- en: Advanced syntax
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级语法
- en: 'It is hard to objectively tell which element of language syntax is advanced.
    For the purpose of this chapter on advanced syntax elements, we will consider
    the elements that do not directly relate to any specific built-in datatypes and
    which are relatively hard to grasp at the beginning. The most common Python features
    that may be hard to understand are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 客观地说，很难判断语言语法的哪个元素是先进的。对于本章关于高级语法元素的目的，我们将考虑那些与任何特定的内置数据类型没有直接关系，并且在开始时相对难以理解的元素。可能难以理解的最常见的Python特性是：
- en: Iterators
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Generators
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Decorators
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Context managers
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: Iterators
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'An **iterator** is nothing more than a container object that implements the
    iterator protocol. It is based on two methods:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器**只不过是实现迭代器协议的容器对象。它基于两种方法：'
- en: '`__next__`: This returns the next item of the container'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__next__`：这返回容器的下一个项目'
- en: '`__iter__`: This returns the iterator itself'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__iter__`：这返回迭代器本身'
- en: 'Iterators can be created from a sequence using the `iter` built-in function.
    Consider the following example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`iter`内置函数从序列创建迭代器。考虑以下示例：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the sequence is exhausted, a `StopIteration` exception is raised. It makes
    iterators compatible with loops since they catch this exception to stop cycling.
    To create a custom iterator, a class with a `__next__` method can be written,
    as long as it provides the special method `__iter__` that returns an instance
    of the iterator:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当序列耗尽时，会引发`StopIteration`异常。它使迭代器与循环兼容，因为它们捕获此异常以停止循环。要创建自定义迭代器，可以编写一个具有`__next__`方法的类，只要它提供返回迭代器实例的特殊方法`__iter__`：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is example usage of such iterator:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这种迭代器的示例用法：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Iterators themselves are a low-level feature and concept, and a program can
    live without them. But they provide the base for a much more interesting feature,
    generators.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器本身是一个低级特性和概念，程序可以没有它们。但是它们为一个更有趣的特性 - 生成器提供了基础。
- en: The yield statement
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: yield语句
- en: Generators provide an elegant way to write simple and efficient code for functions
    that return a sequence of elements. Based on the `yield` statement, they allow
    you to pause a function and return an intermediate result. The function saves
    its execution context and can be resumed later, if necessary.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器提供了一种优雅的方式来编写返回元素序列的简单高效的代码。基于`yield`语句，它们允许您暂停函数并返回中间结果。函数保存其执行上下文，如果必要的话可以稍后恢复。
- en: 'For instance, the Fibonacci series can be written with an iterator (this is
    the example provided in the PEP about iterators):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，斐波那契数列可以用迭代器编写（这是关于迭代器的PEP中提供的示例）：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can retrieve new values from generators as if it were iterators, so using
    `next()` function or `for` loops:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像使用`next()`函数或`for`循环一样从生成器中检索新值：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function returns a `generator` object, a special iterator, which knows
    how to save the execution context. It can be called indefinitely, yielding the
    next element of the suite each time. The syntax is concise, and the infinite nature
    of the algorithm does not disturb the readability of the code anymore. It does
    not have to provide a way to make the function stoppable. In fact, it looks similar
    to how the series would be designed in pseudocode.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个`generator`对象，一个特殊的迭代器，它知道如何保存执行上下文。它可以被无限调用，每次产生套件的下一个元素。语法简洁，算法的无限性不再影响代码的可读性。它不必提供一种使函数可停止的方法。事实上，它看起来类似于伪代码中设计系列的方式。
- en: In the community, generators are not used so often because the developers are
    not used to thinking this way. The developers have been used to working with straight
    functions for years. Generators should be considered every time you deal with
    a function that returns a sequence or works in a loop. Returning the elements
    one at a time can improve the overall performance, when they are passed to another
    function for further work.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在社区中，生成器并不经常使用，因为开发人员不习惯以这种方式思考。开发人员多年来一直习惯于使用直接函数。每当处理返回序列的函数或在循环中工作时，都应该考虑使用生成器。逐个返回元素可以提高整体性能，当它们被传递给另一个函数进行进一步处理时。
- en: In that case, the resources used to work out one element are most of the time
    less important than the resources used for the whole process. Therefore, they
    can be kept low, making the program more efficient. For instance, the Fibonacci
    sequence is infinite, and yet the generator that generates it does not require
    an infinite amount of memory to provide the values one at a time. A common use
    case is to stream data buffers with generators. They can be paused, resumed, and
    stopped by third-party code that plays over the data, and all the data does not
    need to be loaded before starting the process.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用于计算一个元素的资源大部分时间不那么重要，而用于整个过程的资源更为重要。因此，它们可以保持较低，使程序更加高效。例如，斐波那契数列是无限的，但生成它的生成器不需要无限的内存来一次提供值。一个常见的用例是使用生成器流式传输数据缓冲区。它们可以被第三方代码暂停、恢复和停止，而不需要在开始处理之前加载所有数据。
- en: 'The `tokenize` module from the standard library, for instance, generates tokens
    out of a stream of text and returns an `iterator` for each treated line that can
    be passed along to some processing:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，标准库中的`tokenize`模块可以从文本流中生成标记，并为每个处理的行返回一个`iterator`，可以传递给某些处理：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we can see that `open` iterates over the lines of the file and `generate_tokens`
    iterates over them in a pipeline, doing additional work. Generators can also help
    in breaking the complexity and raising the efficiency of some data transformation
    algorithms that are based on several suites. Thinking of each suite as an `iterator`,
    and then combining them into a high-level function is a great way to avoid a big,
    ugly, and unreadable function. Moreover, this can provide a live feedback to the
    whole processing chain.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`open`迭代文件的行，`generate_tokens`在管道中迭代它们，执行额外的工作。生成器还可以帮助打破复杂性，并提高基于几个套件的一些数据转换算法的效率。将每个套件视为`iterator`，然后将它们组合成一个高级函数是避免一个庞大、丑陋和难以阅读的函数的好方法。此外，这可以为整个处理链提供实时反馈。
- en: 'In the following example, each function defines a transformation over a sequence.
    They are then chained and applied. Each function call processes one element and
    returns its result:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，每个函数定义了对序列的转换。然后它们被链接并应用。每个函数调用处理一个元素并返回其结果：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the possible result of using these generators together:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这些生成器的可能结果：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Keep the code simple, not the data**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**保持代码简单，而不是数据**'
- en: It is better to have a lot of simple iterable functions that work over sequences
    of values than a complex function that computes the result for entire collection
    at once.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最好有很多简单的可迭代函数，可以处理值序列，而不是一次计算整个集合的复杂函数。
- en: 'Another important feature available in Python regarding `generators` is the
    ability to interact with the code called with the `next` function. `yield` becomes
    an expression, and a value can be passed along with a new method called `send`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`generators`，Python中另一个重要的功能是能够使用`next`函数与代码进行交互。`yield`变成了一个表达式，可以通过一个称为`send`的新方法传递一个值：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is an example session with our `psychologist()` function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用我们的`psychologist()`函数的示例会话：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`send` acts like `next`, but makes `yield` return the value passed to it inside
    of the function definition. The function can, therefore, change its behavior depending
    on the client code. Two other functions were added to complete this behavior—`throw`
    and `close`. They raise an error into the generator:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`的作用类似于`next`，但使`yield`返回函数定义内传递的值。因此，函数可以根据客户端代码改变其行为。为了完成这种行为，还添加了另外两个函数——`throw`和`close`。它们将错误引发到生成器中：'
- en: '`throw`: This allows the client code to send any kind of exception to be raised.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw`：这允许客户端代码发送任何类型的异常来引发。'
- en: '`close`: This acts in the same way, but raises a specific exception, `GeneratorExit`.
    In that case, the generator function must raise `GeneratorExit` again, or `StopIteration`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close`：这样做的方式相同，但会引发特定的异常`GeneratorExit`。在这种情况下，生成器函数必须再次引发`GeneratorExit`或`StopIteration`。'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Generators are the basis of other concepts available in Python—coroutines and
    asynchronous concurrency, which are covered in [Chapter 13](ch13.html "Chapter 13. Concurrency"),
    *Concurrency*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是Python中其他概念的基础——协程和异步并发，这些概念在[第13章](ch13.html "第13章.并发")中有所涵盖，*并发*。
- en: Decorators
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'Decorators were added in Python to make function and method wrapping (a function
    that receives a function and returns an enhanced one) easier to read and understand.
    The original use case was to be able to define the methods as class methods or
    static methods on the head of their definition. Without the decorator syntax,
    it would require a rather sparse and repetitive definition:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Python中添加装饰器是为了使函数和方法包装（接收一个函数并返回一个增强的函数）更易于阅读和理解。最初的用例是能够在其定义的头部将方法定义为类方法或静态方法。没有装饰器语法，这将需要一个相当稀疏和重复的定义：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the decorator syntax is used for the same purpose, the code is shorter and
    easier to understand:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果装饰器语法用于相同的目的，代码会更短，更容易理解：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: General syntax and possible implementations
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一般语法和可能的实现
- en: The decorator is generally a named object (`lambda` expressions are not allowed)
    that accepts a single argument when called (it will be the decorated function)
    and returns another callable object. "Callable" is used here instead of "function"
    with premeditation. While decorators are often discussed in the scope of methods
    and functions, they are not limited to them. In fact, anything that is callable
    (any object that implements the `__call__` method is considered callable), can
    be used as a decorator and often objects returned by them are not simple functions
    but more instances of more complex classes implementing their own `__call__` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器通常是一个命名对象（不允许`lambda`表达式），在调用时接受一个参数（它将是装饰的函数），并返回另一个可调用对象。这里使用“可调用”而不是“函数”是有预谋的。虽然装饰器经常在方法和函数的范围内讨论，但它们并不局限于它们。事实上，任何可调用的东西（任何实现`__call__`方法的对象都被认为是可调用的）都可以用作装饰器，而且它们返回的对象通常不是简单的函数，而是更复杂的类的实例，实现了自己的`__call__`方法。
- en: 'The decorator syntax is simply only a syntactic sugar. Consider the following
    decorator usage:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器语法只是一种语法糖。考虑以下装饰器的用法：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This can always be replaced by an explicit decorator call and function reassignment:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这总是可以被显式的装饰器调用和函数重新分配替代：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, the latter is less readable and also very hard to understand if multiple
    decorators are used on a single function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，后者不太可读，而且如果在单个函数上使用多个装饰器，很难理解。
- en: Tip
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Decorator does not even need to return a callable!**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器甚至不需要返回一个可调用对象！**'
- en: As a matter of fact, any function can be used as a decorator because Python
    does not enforce the return type of decorators. So, using some function as a decorator
    that accepts a single argument but does not return callable, let's say `str`,
    is completely valid in terms of syntax. This will eventually fail if the user
    tries to call an object decorated this way. Anyway, this part of decorator syntax
    creates a field for some interesting experimentation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，任何函数都可以用作装饰器，因为Python不强制装饰器的返回类型。因此，使用一些函数作为装饰器，它接受一个参数但不返回可调用的，比如`str`，在语法上是完全有效的。如果用户尝试以这种方式调用装饰过的对象，最终会失败。无论如何，装饰器语法的这一部分为一些有趣的实验创造了一个领域。
- en: As a function
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 作为一个函数
- en: There are many ways to write custom decorators, but the simplest way is to write
    a function that returns a subfunction that wraps the original function call.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多编写自定义装饰器的方法，但最简单的方法是编写一个返回包装原始函数调用的子函数的函数。
- en: 'The generic patterns is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通用模式如下：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As a class
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 作为类
- en: While decorators almost always can be implemented using functions, there are
    some situations when using user-defined classes is a better option. This is often
    true when the decorator needs complex parametrization or it depends on a specific
    state.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然装饰器几乎总是可以使用函数来实现，但在某些情况下，使用用户定义的类是更好的选择。当装饰器需要复杂的参数化或依赖于特定状态时，这通常是正确的。
- en: 'The generic pattern for a nonparametrized decorator as a class is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 作为类的非参数化装饰器的通用模式如下：
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Parametrizing decorators
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数化装饰器
- en: 'In real code, there is often a need to use decorators that can be parametrized.
    When the function is used as a decorator, then the solution is simple—a second
    level of wrapping has to be used. Here is a simple example of the decorator that
    repeats the execution of a decorated function the specified number of times every
    time it is called:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码中，通常需要使用可以带参数的装饰器。当函数用作装饰器时，解决方案很简单——必须使用第二层包装。这是装饰器的一个简单示例，它重复执行装饰函数指定的次数，每次调用时：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The decorator defined this way can accept parameters:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式定义的装饰器可以接受参数：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that even if the parametrized decorator has default values for its arguments,
    the parentheses after its name is required. The correct way to use the preceding
    decorator with default arguments is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使带有默认值的参数化装饰器，其名称后面的括号也是必需的。使用具有默认参数的前述装饰器的正确方法如下：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Missing these parentheses will result in the following error when decorated
    function is called:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略这些括号，当调用装饰函数时将导致以下错误：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Introspection preserving decorators
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保留内省的装饰器
- en: Common pitfalls of using decorators is not preserving function metadata (mostly
    docstring and original name) when using decorators. All the previous examples
    have this issue. They created a new function by composition and returned a new
    object without any respect to the identity of the original one. This makes the
    debugging of functions decorated that way harder and will also break most of the
    auto-documentation tools that may be used because the original docstrings and
    function signatures are no longer accessible.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器的常见陷阱是在使用装饰器时不保留函数元数据（主要是文档字符串和原始名称）。所有先前的示例都有这个问题。它们通过组合创建了一个新函数，并返回了一个新对象，而没有尊重原始函数的身份。这使得以这种方式装饰的函数的调试更加困难，并且也会破坏大多数可能使用的自动文档工具，因为原始文档字符串和函数签名不再可访问。
- en: 'But let''s see this in detail. Assume that we have some dummy decorator that
    does nothing more than decorating and some other functions decorated with it:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们详细看一下。假设我们有一些虚拟装饰器，除了装饰和一些其他函数被装饰以外，什么都不做：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we inspect `function_with_important_docstring()` in a Python interactive
    session, we can notice that it has lost its original name and docstring:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Python交互会话中检查`function_with_important_docstring()`，我们会注意到它已经失去了原始名称和文档字符串：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A proper solution to this problem is to use the built-in `wraps()` decorator
    provided by the `functools` module:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个合适的方法是使用`functools`模块提供的内置`wraps()`装饰器：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With the decorator defined in such a way, the important function metadata is
    preserved:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式定义的装饰器，重要的函数元数据得到了保留：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Usage and useful examples
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法和有用的示例
- en: Since decorators are loaded by the interpreter when the module is first read,
    their usage should be limited to wrappers that can be generically applied. If
    a decorator is tied to the method's class or to the function's signature it enhances,
    it should be refactored into a regular callable to avoid complexity. In any case,
    when the decorators are dealing with APIs, a good practice is to group them in
    a module that is easy to maintain.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于装饰器在模块首次读取时由解释器加载，它们的使用应该限于可以通用应用的包装器。如果装饰器与方法的类或增强的函数签名相关联，应将其重构为常规可调用对象以避免复杂性。无论如何，当装饰器处理API时，一个良好的做法是将它们分组在一个易于维护的模块中。
- en: 'The common patterns for decorators are:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的常见模式有：
- en: Argument checking
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数检查
- en: Caching
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Proxy
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Context provider
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文提供者
- en: Argument checking
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数检查
- en: Checking the arguments that a function receives or returns can be useful when
    it is executed in a specific context. For example, if a function is to be called
    through XML-RPC, Python will not be able to directly provide its full signature
    as in the statically-typed languages. This feature is needed to provide introspection
    capabilities, when the XML-RPC client asks for the function signatures.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 检查函数接收或返回的参数在特定上下文中执行时可能是有用的。例如，如果一个函数要通过XML-RPC调用，Python将无法像静态类型语言那样直接提供其完整签名。当XML-RPC客户端请求函数签名时，需要此功能来提供内省能力。
- en: Tip
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The XML-RPC protocol**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML-RPC协议**'
- en: The XML-RPC protocol is a lightweight **Remote Procedure Call** protocol that
    uses XML over HTTP to encode its calls. It is often used instead of SOAP for simple
    client-server exchanges. Unlike SOAP, which provides a page that lists all callable
    functions (WSDL), XML-RPC does not have a directory of available functions. An
    extension of the protocol that allows discovering the server API was proposed,
    and Python's `xmlrpc` module implements it (refer to [https://docs.python.org/3/library/xmlrpc.server.html](https://docs.python.org/3/library/xmlrpc.server.html)).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: XML-RPC协议是一种轻量级的**远程过程调用**协议，它使用XML通过HTTP来编码调用。它经常用于简单的客户端-服务器交换而不是SOAP。与提供列出所有可调用函数的页面的SOAP不同，XML-RPC没有可用函数的目录。提出了一种允许发现服务器API的协议扩展，并且Python的`xmlrpc`模块实现了它（参考[https://docs.python.org/3/library/xmlrpc.server.html](https://docs.python.org/3/library/xmlrpc.server.html)）。
- en: 'A custom decorator can provide this type of signature. It can also make sure
    that what goes in and comes out respects the defined signature parameters:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义装饰器可以提供这种类型的签名。它还可以确保输入和输出符合定义的签名参数：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The decorator registers the function into a global dictionary and keeps a list
    of the types for its arguments and for the returned values. Note that the example
    was highly simplified to demonstrate argument-checking decorators.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器将函数注册到全局字典中，并保留其参数和返回值的类型列表。请注意，示例被大大简化以演示参数检查装饰器。
- en: 'A usage example is as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用示例如下：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When it is read, this class definition populates the `rpc_infos` dictionary
    and can be used in a specific environment, where the argument types are checked:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当它被读取时，这个类定义会填充`rpc_infos`字典，并且可以在特定环境中使用，其中检查参数类型：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Caching
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存
- en: The caching decorator is quite similar to argument checking, but focuses on
    those functions whose internal state does not affect the output. Each set of arguments
    can be linked to a unique result. This style of programming is the characteristic
    of **functional programming** (refer to [http://en.wikipedia.org/wiki/Functional_programming](http://en.wikipedia.org/wiki/Functional_programming))
    and can be used when the set of input values is finite.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存装饰器与参数检查非常相似，但侧重于那些内部状态不影响输出的函数。每组参数都可以与唯一的结果相关联。这种编程风格是**函数式编程**的特征（参考[http://en.wikipedia.org/wiki/Functional_programming](http://en.wikipedia.org/wiki/Functional_programming)），并且可以在输入值集合是有限的情况下使用。
- en: 'Therefore, a caching decorator can keep the output together with the arguments
    that were needed to compute it, and return it directly on subsequent calls. This
    behavior is called **memoizing** (refer to [http://en.wikipedia.org/wiki/Memoizing](http://en.wikipedia.org/wiki/Memoizing))
    and is quite simple to implement as a decorator:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，缓存装饰器可以将输出与计算所需的参数一起保留，并在后续调用时直接返回。这种行为称为**记忆化**（参考[http://en.wikipedia.org/wiki/Memoizing](http://en.wikipedia.org/wiki/Memoizing)），作为装饰器实现起来非常简单：
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A `SHA` hash key is built using the ordered argument values, and the result
    is stored in a global dictionary. The hash is made using a pickle, which is a
    bit of a shortcut to freeze the state of all objects passed as arguments, ensuring
    that all arguments are good candidates. If a thread or a socket is used as an
    argument, for instance, a `PicklingError` will occur. (Refer to [https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html).)
    The `duration` parameter is used to invalidate the cached value when too much
    time has passed since the last function call.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有序参数值构建`SHA`哈希键，并将结果存储在全局字典中。哈希是使用pickle制作的，这是一个冻结传递的所有对象状态的快捷方式，确保所有参数都是良好的候选者。例如，如果线程或套接字被用作参数，将会发生`PicklingError`。（参见[https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)。）`duration`参数用于在上次函数调用后经过太长时间后使缓存值无效。
- en: 'Here''s an example of the usage:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用示例：
- en: '[PRE51]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Caching expensive functions can dramatically increase the overall performance
    of a program, but it has to be used with care. The cached value could also be
    tied to the function itself to manage its scope and life cycle, instead of a centralized
    dictionary. But in any case, a more efficient decorator would use a specialized
    cache library based on advanced caching algorithm.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存昂贵的函数可以显著提高程序的整体性能，但必须小心使用。缓存的值也可以与函数本身绑定，以管理其范围和生命周期，而不是集中的字典。但无论如何，一个更有效的装饰器会使用基于高级缓存算法的专用缓存库。
- en: Note
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Chapter 12](ch12.html "Chapter 12. Optimization – Some Powerful Techniques"),
    *Optimization – Some Powerful Techniques*, provides detailed information and techniques
    on caching.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。优化-一些强大的技术")，*优化-一些强大的技术*，提供了关于缓存的详细信息和技术。'
- en: Proxy
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代理
- en: 'Proxy decorators are used to tag and register functions with a global mechanism.
    For instance, a security layer that protects the access of the code, depending
    on the current user, can be implemented using a centralized checker with an associated
    permission required by the callable:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 代理装饰器用于标记和注册具有全局机制的函数。例如，一个保护代码访问的安全层，取决于当前用户，可以使用一个带有可调用的关联权限的集中检查器来实现。
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This model is often used in Python web frameworks to define the security over
    publishable classes. For instance, Django provides decorators to secure function
    access.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型经常被用在Python的web框架中来定义可发布类的安全性。例如，Django提供了装饰器来保护函数的访问。
- en: 'Here''s an example, where the current user is kept in a global variable. The
    decorator checks his or her roles when the method is accessed:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，其中当前用户保存在全局变量中。装饰器在访问方法时检查他或她的角色：
- en: '[PRE53]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Context provider
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 上下文提供程序
- en: 'A context decorator makes sure that the function can run in the correct context,
    or run some code before and after the function. In other words, it sets and unsets
    a specific execution environment. For example, when a data item has to be shared
    among several threads, a lock has to be used to ensure that it is protected from
    multiple access. This lock can be coded in a decorator as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文装饰器确保函数可以在正确的上下文中运行，或在函数之前和之后运行一些代码。换句话说，它设置并取消特定的执行环境。例如，当一个数据项必须在多个线程之间共享时，必须使用锁来确保它受到多重访问的保护。这个锁可以编码在装饰器中，如下所示：
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Context decorators are more often being replaced by the usage of the context
    managers (the `with` statement) that are also described later in this chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文装饰器更多地被上下文管理器（`with`语句）的使用所取代，这也在本章后面描述。
- en: Context managers – the with statement
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器-`with`语句
- en: 'The `try...finally` statement is useful to ensure some cleanup code is run
    even if an error is raised. There are many use cases for this, such as:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`try...finally`语句对于确保一些清理代码即使发生错误也会运行是有用的。有许多这样的用例，比如：'
- en: Closing a file
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭文件
- en: Releasing a lock
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放锁
- en: Making a temporary code patch
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作临时代码补丁
- en: Running protected code in a special environment
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特殊环境中运行受保护的代码
- en: 'The `with` statement factors out these use cases by providing a simple way
    to wrap a block of code. This allows you to call some code before and after block
    execution even if this block raises an exception. For example, working with a
    file is usually done like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句通过提供一种简单的方式来包装一段代码来因素化这些用例。这允许您在块执行之前和之后调用一些代码，即使这个块引发异常。例如，通常是这样处理文件的：'
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is specific to Linux since it reads the host file located in `etc`,
    but any text file could have been used here in the same way.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是特定于Linux的，因为它读取位于`etc`中的主机文件，但任何文本文件都可以以同样的方式在这里使用。
- en: 'By using the `with` statement, it can be rewritten like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`with`语句，可以重写成这样：
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding example, `open` used as a context manager ensures that the
    file will be closed after executing the `for` loop and even if some exception
    will occur.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`open`作为上下文管理器确保在执行`for`循环后文件将被关闭，即使发生异常。
- en: 'Some other items that are compatible with this statement are classes from the
    `threading` module:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 与此语句兼容的其他项目是`threading`模块中的类：
- en: '`threading.Lock`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.Lock`'
- en: '`threading.RLock`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.RLock`'
- en: '`threading.Condition`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.Condition`'
- en: '`threading.Semaphore`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.Semaphore`'
- en: '`threading.BoundedSemaphore`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.BoundedSemaphore`'
- en: General syntax and possible implementations
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一般语法和可能的实现
- en: 'The general syntax for the `with` statement in the simplest form is:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单形式的`with`语句的一般语法是：
- en: '[PRE57]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Additionally, if the context manager provides a context variable, it can be
    stored locally using the `as` clause:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果上下文管理器提供一个上下文变量，可以使用`as`子句在本地存储它：
- en: '[PRE58]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Note that multiple context managers can be used at once, as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可以同时使用多个上下文管理器，如下所示：
- en: '[PRE59]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is equivalent to nesting them, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于将它们嵌套，如下所示：
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As a class
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 作为一个类
- en: 'Any object that implements the **context manager protocol** can be used as
    a context manager. This protocol consists of two special methods:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现**上下文管理器协议**的对象都可以用作上下文管理器。这个协议包括两个特殊方法：
- en: '`__enter__(self)`: More on this can be found at [https://docs.python.org/3.3/reference/datamodel.html#object.__enter__](https://docs.python.org/3.3/reference/datamodel.html#object.__enter__)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__enter__(self)`：更多信息可以在[https://docs.python.org/3.3/reference/datamodel.html#object.__enter__](https://docs.python.org/3.3/reference/datamodel.html#object.__enter__)找到'
- en: '`__exit__(self, exc_type, exc_value, traceback)`: More on this can be found
    at [https://docs.python.org/3.3/reference/datamodel.html#object.__exit__](https://docs.python.org/3.3/reference/datamodel.html#object.__exit__)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__exit__(self, exc_type, exc_value, traceback)`：更多信息可以在[https://docs.python.org/3.3/reference/datamodel.html#object.__exit__](https://docs.python.org/3.3/reference/datamodel.html#object.__exit__)找到'
- en: 'In short, the execution of the `with` statement proceeds as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`with`语句的执行如下：
- en: The `__enter__` method is invoked. Any return value is bound to target the specified
    as clause.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__enter__`方法被调用。任何返回值都绑定到指定为子句的目标。'
- en: The inner block of code is executed.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行内部代码块。
- en: The `__exit__` method is invoked.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__exit__`方法被调用。'
- en: '`__exit__` receives three arguments that are filled when an error occurs within
    the code block. If no error occurs, all three arguments are set to `None`. When
    an error occurs, `__exit__` should not re-raise it, as this is the responsibility
    of the caller. It can prevent the exception being raised though, by returning
    `True`. This is provided to implement some specific use cases, such as the `contextmanager`
    decorator that we will see in the next section. But for most use cases, the right
    behavior for this method is to do some cleaning, like what would be done by the
    `finally` clause; no matter what happens in the block, it does not return anything.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit__`接收三个参数，当代码块内发生错误时会填充这些参数。如果没有发生错误，所有三个参数都设置为`None`。当发生错误时，`__exit__`不应重新引发它，因为这是调用者的责任。它可以通过返回`True`来防止异常被引发。这是为了实现一些特定的用例，比如我们将在下一节中看到的`contextmanager`装饰器。但对于大多数用例，这个方法的正确行为是做一些清理，就像`finally`子句所做的那样；无论在块中发生了什么，它都不返回任何东西。'
- en: 'The following is an example of some context manager that implements this protocol
    to better illustrate how it works:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个实现了这个协议的一些上下文管理器的示例，以更好地说明它是如何工作的：
- en: '[PRE61]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When run without exceptions raised, the output is as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有引发异常时，输出如下：
- en: '[PRE62]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When the exception is raised, the output is as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当引发异常时，输出如下：
- en: '[PRE63]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As a function – the contextlib module
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 作为函数-上下文管理器模块
- en: 'Using classes seems to be the most flexible way to implement any protocol provided
    in the Python language but may be too much boilerplate for many use cases. A `contextlib`
    module was added to the standard library to provide helpers to use with context
    managers. The most useful part of it is the `contextmanager` decorator. It allows
    you to provide both `__enter__` and `__exit__` parts in a single function, separated
    by a `yield` statement (note that this makes the function a generator). The previous
    example written with this decorator would look like the following code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似乎是实现Python语言中提供的任何协议的最灵活的方式，但对于许多用例来说可能是太多的样板文件。标准库中添加了一个`contextlib`模块，提供了一些与上下文管理器一起使用的帮助器。它最有用的部分是`contextmanager`装饰器。它允许您在单个函数中提供`__enter__`和`__exit__`部分，中间用`yield`语句分隔（请注意，这会使函数成为生成器）。使用这个装饰器编写的前面的示例将如下所示：
- en: '[PRE64]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If any exception occurs, the function needs to re-raise it in order to pass
    it along. Note that the `context_illustration` could have some arguments if needed,
    as long as they are provided in the call. This small helper simplifies the normal
    class-based context API exactly as generators do with the classed-based iterator
    API.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生任何异常，函数需要重新引发它以便传递它。请注意，`context_illustration`如果需要的话可以有一些参数，只要它们在调用中提供。这个小助手与基于类的迭代器API一样简化了正常的基于类的上下文API。
- en: 'The three other helpers provided by this module are:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块提供的另外三个帮助器是：
- en: '`closing(element)`: This returns the context manager that calls the element''s
    close method on exit. This is useful for classes that deal with streams, for instance.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closing(element)`：这会返回一个上下文管理器，在退出时调用元素的close方法。这对于处理流的类非常有用。'
- en: '`supress(*exceptions)`: This suppresses any of the specified exceptions if
    they occur in the body of the with statement.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supress(*exceptions)`：如果在with语句的主体中发生指定的任何异常，则抑制它们。'
- en: '`redirect_stdout(new_target)` and `redirect_stderr(new_target)`: This redirects
    the `sys.stdout` or `sys.stderr` output of any code within the block to another
    file of the file-like object.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect_stdout(new_target)`和`redirect_stderr(new_target)`：这将代码块内的`sys.stdout`或`sys.stderr`输出重定向到另一个文件或类文件对象。'
- en: Other syntax elements you may not know yet
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他你可能还不知道的语法元素
- en: 'There are some elements of the Python syntax that are not popular and rarely
    used. It is because they either provide very little gain or their usage is simply
    hard to memorize. Due to this, many Python programmers (even with years of experience)
    simply do not know about their existence. The most notable examples of such features
    are as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Python语法中有一些不太流行且很少使用的元素。这是因为它们要么提供的收益很少，要么它们的使用方法很难记住。因此，许多Python程序员（即使有多年的经验）根本不知道它们的存在。这些特性的最显著的例子如下：
- en: The `for … else` clause
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for … else`子句'
- en: Function annotations
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数注释
- en: The for … else … statement
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for … else …`语句'
- en: 'Using the `else` clause after the `for` loop allows you to execute a code of
    block only if the loop ended "naturally" without terminating with the `break`
    statement:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环之后使用`else`子句允许您仅在循环以“自然”方式结束而不是用`break`语句终止时执行代码块：
- en: '[PRE65]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This comes in handy in some situations because it helps to remove some "sentinel"
    variables that may be required if the user wants to store information if a `break`
    occurred. This makes the code cleaner but can confuse programmers not familiar
    with such syntax. Some say that such meaning of the `else` clause is counterintuitive,
    but here is an easy tip that helps you to remember how it works—memorize that
    `else` clause after the `for` loop simply means "no break".
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这很方便，因为它有助于消除可能需要的一些“标记”变量，如果用户想要存储信息，以确定是否发生了`break`。这使得代码更清晰，但可能会让不熟悉这种语法的程序员感到困惑。有人说`else`子句的这种含义是违反直觉的，但这里有一个简单的提示，可以帮助您记住它的工作原理-记住`for`循环后的`else`子句只是表示“没有break”。
- en: Function annotations
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数注释
- en: Function annotation is one of the most unique features of Python 3\. The official
    documentation states that *annotations are completely optional metadata information
    about the types used by user-defined functions*, but in fact, they are not restricted
    to type hinting, and also there is no single feature in Python and its standard
    library that leverages such annotations. This is why this feature is unique—it
    does not have any syntactic meaning. Annotations can simply be defined for a function
    and can be retrieved in runtime, but that is all. What to do with them is left
    to the developers.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 函数注释是Python 3最独特的功能之一。官方文档指出*注释是关于用户定义函数使用的类型的完全可选的元数据信息*，但实际上，它们并不局限于类型提示，Python及其标准库也没有利用这样的注释。这就是为什么这个功能是独特的-它没有任何语法意义。注释可以简单地为函数定义，并且可以在运行时检索，但仅此而已。如何处理它们留给开发人员。
- en: The general syntax
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一般语法
- en: 'A slightly modified example from the Python documentation shows best how to
    define and retrieve function annotations:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Python文档中略微修改的示例最好地展示了如何定义和检索函数注释：
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As presented, parameter annotations are defined by the expression evaluating
    to the value of the annotation preceded by a colon. Return annotations are defined
    by the expression between the colon denoting the end of the `def` statement and
    literal `->` that follows the parameter list.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，参数注释由表达式定义，该表达式评估为注释值，并在冒号之前。返回注释由冒号后的`def`语句结束和参数列表后面的`->`之间的表达式定义。
- en: Once defined, annotations are available in the `__annotations__` attribute of
    the function object as a dictionary and can be retrieved during application runtime.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，注释将作为函数对象的`__annotations__`属性以字典的形式可用，并且可以在应用运行时检索。
- en: 'The fact that any expression can be used as the annotation and it is located
    just near the default arguments allows to create some confusing function definitions
    as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 任何表达式都可以用作注释，并且它位于默认参数旁边，这允许创建一些令人困惑的函数定义，如下所示：
- en: '[PRE67]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: However, such usage of annotations serves no other purpose than obfuscation
    and even without them it is relatively easy to write code that is hard to read
    and maintain.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种注释的用法除了混淆之外没有其他目的，即使没有它们，编写难以阅读和维护的代码也相对容易。
- en: The possible uses
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可能的用途
- en: 'While annotations have a great potential, they are not widely used. An article
    explaining new features added to Python 3 (refer to [https://docs.python.org/3/whatsnew/3.0.html](https://docs.python.org/3/whatsnew/3.0.html))
    says that the intent of this feature was "to encourage experimentation through
    metaclasses, decorators, or frameworks". On the other hand, **PEP 3107** that
    officially proposed function annotations lists the following set of possible use
    cases:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管注释具有巨大潜力，但它们并不被广泛使用。一篇解释Python 3新增功能的文章（参见[https://docs.python.org/3/whatsnew/3.0.html](https://docs.python.org/3/whatsnew/3.0.html)）表示，这一功能的目的是“通过元类、装饰器或框架鼓励实验”。另一方面，正式提出函数注释的**PEP
    3107**列出了以下一系列可能的用例：
- en: Providing typing information
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供类型信息
- en: Type checking
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查
- en: Let IDEs show what types a function expects and returns
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让IDE显示函数期望和返回的类型
- en: Function overloading / generic functions
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载/通用函数
- en: Foreign-language bridges
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外语桥梁
- en: Adaptation
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应
- en: Predicate logic functions
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谓词逻辑函数
- en: Database query mapping
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库查询映射
- en: RPC parameter marshaling
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPC参数编组
- en: Other information
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他信息
- en: Documentation for parameters and return values
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数和返回值的文档
- en: Although the function annotations are as old as Python 3, it is still very hard
    to find any popular and actively maintained package that uses them for something
    else than type checking. So function annotations are still mostly good only for
    experimentation and playing—the initial purpose why they were included in initial
    release of Python 3.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数注释与Python 3一样古老，但仍然很难找到任何流行且积极维护的软件包，除了类型检查之外还使用它们。因此，函数注释仍然主要用于实验和玩耍-这是它们被包含在Python
    3的初始版本中的初衷。
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered various best syntax practices that do not directly relate
    to Python classes and object-oriented programming. The first part of the chapter
    was dedicated to syntax features around Python sequences and collections, strings
    and byte-related sequences were also discussed. The rest of the chapter covered
    independent syntax elements of two groups—those that are relatively hard to understand
    for beginners (such as iterators, generators, and decorators) and those that are
    simply less known (the `for…else` clause and function annotations).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了与Python类和面向对象编程无直接关系的各种最佳语法实践。本章的第一部分专门讨论了围绕Python序列和集合的语法特性，还讨论了字符串和字节相关序列。本章的其余部分涵盖了两组独立的语法元素-相对于初学者来说相对难以理解的元素（如迭代器、生成器和装饰器）和相对较少知名的元素（`for…else`子句和函数注释）。
