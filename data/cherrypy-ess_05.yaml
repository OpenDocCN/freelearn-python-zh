- en: Chapter 5. A Photoblog Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：相册博客应用程序
- en: In this chapter, we are going to explain what the next few chapters will put
    in place to develop a photoblog application. In the first half of this chapter,
    we will review the goals and features of this application from a high-level perspective
    without going into too much detail. In the second half, we will define the entities
    that our application will manipulate and introduce the concept of object-relational
    mappers, which aim at reducing the impedance mismatch between relational database
    and object-oriented software design. We will briefly present the most common Python
    ORMs and then develop our application data access layer based on the Dejavu ORM.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释接下来几章将要建立的内容，以开发一个相册博客应用程序。在本章的前半部分，我们将从高层次的角度回顾此应用程序的目标和功能，而不会过多地深入细节。在后半部分，我们将定义我们的应用程序将操作的对象以及介绍对象关系映射的概念，该概念旨在减少关系数据库和面向对象软件设计之间的阻抗不匹配。我们将简要介绍最常用的Python
    ORM，然后基于Dejavu ORM开发我们的应用程序数据访问层。
- en: A Photoblog Application
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相册博客应用程序
- en: In the previous chapters, we have reviewed CherryPy's design and features in
    detail but we haven't demonstrated its use in the context of a web application.
    The next few chapters will undertake this task by going through the development
    of a photoblog application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经详细审查了CherryPy的设计和功能，但尚未在Web应用程序的上下文中展示其使用。接下来的几章将通过开发一个相册博客应用程序来完成这项任务。
- en: A photoblog is like a regular blog except that the principal content is not
    text but photographs. The main reason for choosing a photoblog is that the range
    of features to be implemented is small enough so that we can concentrate on their
    design and implementation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相册博客就像一个普通的博客，只不过主要内容不是文本而是照片。选择相册博客的主要原因是因为要实现的功能范围足够小，这样我们就可以集中精力进行设计和实现。
- en: 'The goals behind going through this application are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个应用程序背后的目标是以下内容：
- en: To see how to slice the development of a web application into meaningful layers
    and therefore show that a web application is not very different from a rich application
    sitting on your desktop.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解如何将一个Web应用程序的发展切割成有意义的层次，从而展示Web应用程序与您桌面上的富应用程序并没有太大的不同。
- en: To show that the separation of concerns can also be applied to the web interface
    itself by using principles grouped under the name of Ajax.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要展示关注点的分离也可以通过使用名为Ajax的原则应用于Web界面本身。
- en: To introduce common Python packages for dealing with common aspects of web development
    such as database access, HTML templating, JavaScript handling, etc.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍用于处理Web开发常见方面的常见Python包，例如数据库访问、HTML模板、JavaScript处理等。
- en: Photoblog Entities
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相册博客实体
- en: As mentioned earlier, the photoblog will try to stay as simple as possible in
    order to focus on the other aspects of developing a web application. In this section,
    we will briefly describe the entities our photoblog will manipulate as well as
    their attributes and relations with each other.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，相册博客将尽可能保持简单，以便专注于Web应用程序开发的其它方面。在本节中，我们将简要描述我们的相册博客将操作的对象以及它们的属性和相互关系。
- en: 'In a nutshell our photoblog application will use the following entities and
    they will be associated as shown in the following figure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们的相册博客应用程序将使用以下实体，并且它们将按照以下图示关联：
- en: '![Photoblog Entities](img/1848_05_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![相册博客实体](img/1848_05_01.jpg)'
- en: This figure is not what our application will look like but it shows the entities
    our application will manipulate. One photoblog will contain several albums, which
    in turn will host as many films as required, which will carry the photographs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此图并不是我们的应用程序将看起来是什么样子，但它显示了我们的应用程序将操作的对象。一个相册博客将包含多个相册，而每个相册又可以包含所需数量的影片，这些影片将携带照片。
- en: 'In other words, we will design our application with the following entity structure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们将按照以下实体结构设计我们的应用程序：
- en: '**Entity:** Photoblog'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体：** 相册博客'
- en: '**Role:** This entity will be the root of the application.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色：** 此实体将是应用程序的根。'
- en: '**Attributes:**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: '`name:` A unique identifier for the blog'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称：` 博客的唯一标识符'
- en: '`title:` A public label for the blog'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题：` 博客的公共标签'
- en: '**Relations:**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系：**'
- en: One photoblog will have zero to many albums
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个相册博客可以有零个或多个相册
- en: '**Entity:** Album'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体：** 相册'
- en: '**Role:** An album carries a story told by the photographs as an envelope.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色：** 相册作为照片讲述故事的外壳。'
- en: '**Attributes:**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: '`name:` A unique identifier for the album'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称：` 相册的唯一标识符'
- en: '`title:` A public label for the album'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title:` 专辑的公共标签'
- en: '`author:` The name of the album''s author'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author:` 专辑的作者姓名'
- en: '`description:` A simple description of the album used in feeds'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description:` 在源中使用的专辑的简单描述'
- en: '`story:` A story attached to the album'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`story:` 与专辑关联的故事'
- en: '`created:` A timestamp of when the album is being created'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created:` 专辑创建的时间戳'
- en: '`modified:` A timestamp of when the album is being modified'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modified:` 专辑修改的时间戳'
- en: '`blog_id:` A reference to the blog handling the album'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog_id:` 处理专辑的博客的引用'
- en: '**Relations:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系：**'
- en: One album will reference zero to several films
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张专辑可以参考零到多部电影
- en: '**Entity:** Film'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体：** 电影'
- en: '**Role:** A film gathers a set of photographs.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色：** 一部电影汇集了一组照片。'
- en: '**Attributes:**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: '`name:` A unique identifier for the film'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name:` 电影的唯一标识符'
- en: '`title:` A public label for the film'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title:` 电影的公共标签'
- en: '`created:` A timestamp of when the film is being created'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created:` 电影创建的时间戳'
- en: '`modified:` A timestamp of when the film is being modified'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modified:` 电影修改的时间戳'
- en: '`album_id:` A reference to the album'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`album_id:` 对专辑的引用'
- en: '**Relations:**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系：**'
- en: A film will reference zero to several photographs
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一部电影可以参考零到多张照片
- en: '**Entity:** Photo'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体：** 照片'
- en: '**Role:** The unit of our application is a photograph.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色：** 我们应用程序的单位是一张照片。'
- en: '**Attributes:**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: '`name:` A unique identifier for the photo'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name:` 照片的唯一标识符'
- en: '`legend:` A legend associated with the photograph'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`legend:` 与照片关联的图例'
- en: '`filename:` The base name of the photograph on the hard-disk'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename:` 硬盘上照片的基本名称'
- en: '`filesize:` The size in bytes of the photograph'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filesize:` 照片的字节数大小'
- en: '`width:` Width of the photograph in pixels'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width:` 照片的像素宽度'
- en: '`height:` Height of the photograph in pixels'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height:` 照片的像素高度'
- en: '`created:` A timestamp of when the photograph is being created'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created:` 照片创建的时间戳'
- en: '`modified:` A timestamp of when the photograph is being modified'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modified:` 照片修改的时间戳'
- en: '`film_id:` A reference to the film carrying the photograph'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`film_id:` 指向携带照片的电影的引用'
- en: '**Relations:** None'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系：** 无'
- en: 'Functionally, the photoblog application will provide APIs to manipulate those
    entities via the traditional **CRUD** interface: **Create, Retrieve, Update**,
    and **Delete**. We will elaborate more on this in[Chapter 6](ch06.html "Chapter 6. Web
    Services").'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，照片博客应用程序将通过传统的**CRUD**接口（**创建、检索、更新**和**删除**）提供API来操作这些实体。我们将在[第6章](ch06.html
    "第6章。网络服务")中对此进行更详细的阐述。
- en: Now that we have briefly introduced what kind of application we will be developing
    throughout the following chapters we can move on to the next section and start
    reviewing our options to handle the database aspect of the application. But first
    a quick glossary of the terms this chapter will use.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要介绍了接下来几章我们将开发的应用程序类型，我们可以继续到下一节，并开始审查处理应用程序数据库方面的选项。但在开始之前，让我们快速了解一下本章将使用的术语表。
- en: Vocabulary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词汇
- en: 'Here is a list of the terms we will be using:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要使用的术语列表：
- en: 'Persistence: Persistence is the concept of data items outliving the execution
    of programs manipulating them. Simply put, it is the process of storing data in
    long lasting memory medium such as a disk.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性：持久性是数据项在操作它们的程序执行后仍然存在的概念。简单来说，它是在持久存储介质（如磁盘）中存储数据的过程。
- en: 'Database: A database is a collection of organized data. There are different
    organization models: hierarchical, network, relational, object-oriented, etc.
    A database holds the logical representation of its data.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库：数据库是有组织的数据集合。有不同类型的组织模型：层次型、网络型、关系型、面向对象型等。数据库持有其数据的逻辑表示。
- en: 'Database Management System (DBMS): A DBMS is a group of related software applications
    to manipulate data in a database. A DBMS platform should offer the following among
    other features:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库管理系统（DBMS）：DBMS是一组相关的软件应用程序，用于在数据库中操作数据。DBMS平台应在其他功能中提供以下功能：
- en: Persistence of the data
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的持久性
- en: A query language to manipulate data
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于操作数据的查询语言
- en: Concurrency control
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发控制
- en: Security control
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全控制
- en: Integrity control
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性控制
- en: Transaction capabilities
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务能力
- en: We will use **DBMSes** as the plural of DBMS.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**DBMSes**作为DBMS的复数形式。
- en: DBMSes Overview
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DBMS概述
- en: In this section, we will quickly review the different kinds of existing DBMSes.
    The goal is to quickly introduce their main characteristics.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速回顾现有的不同类型的数据库管理系统（DBMS）。目标是快速介绍它们的主要特性。
- en: Relational Database Management System (RDBMS)
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统（RDBMS）
- en: Of all DBMSes, the RDBMS is the most common, whether it is in small applications
    or multi-national infrastructure. An RDBMS comes with a database based on the
    concepts of the relational model, a mathematical model that permits the logical
    representation of a collection of data through relations. A relational database
    should be a concrete implementation of the relational model. However, modern relational
    databases follow the model only to a certain degree.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有数据库管理系统（DBMS）中，关系数据库管理系统（RDBMS）是最常见的，无论是小型应用还是跨国基础设施。RDBMS包含基于关系模型概念的数据库，这是一个允许通过关系逻辑表示数据集合的数学模型。关系数据库应该是关系模型的具体实现。然而，现代的关系数据库只遵循该模型到一定程度。
- en: The following table shows the correlation between the terms of the relational
    model and the relational database implementation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了关系模型术语与关系数据库实现之间的关联。
- en: '| Relational Model | Relational Database |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 关系模型 | 关系数据库 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Relation | Table |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 关系 | 表 |'
- en: '| Attribute | Column |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 列 |'
- en: '| Tuple | Row |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 元组 | 行 |'
- en: Relational databases support a set of types to define the domain of scope a
    column can use. However, there are only a limited number of supported types, which
    can be an issue with complex data types as allowed in objected-oriented design.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库支持一组类型来定义列可以使用的域范围。然而，支持的类型数量有限，这可能会在面向对象设计中允许的复杂数据类型中成为一个问题。
- en: '**Structure Query Language** more commonly known as **SQL** is the language
    used to define, manipulate, or control data within a relational database.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化查询语言**，更常被称为**SQL**，是用于定义、操作或控制关系数据库中数据的语言。'
- en: The following table is a quick summary of SQL keywords and their contexts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下表是SQL关键字及其上下文的快速总结。
- en: '| Context | Keywords |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 上下文 | 关键字 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Data manipulation | SELECT, INSERT, UPDATE, DELETE |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 数据操作 | SELECT, INSERT, UPDATE, DELETE |'
- en: '| Data definition | CREATE, DROP, ALTER |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 数据定义 | CREATE, DROP, ALTER |'
- en: '| Data control | GRANT, REVOKE |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 数据控制 | GRANT, REVOKE |'
- en: '| Transaction | START, COMMIT, ROLLBACK |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 事务 | START, COMMIT, ROLLBACK |'
- en: A construction of these keywords is called an SQL statement. When executed,
    an SQL statement returns a collection of rows of the data matching the query or
    nothing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字的组合称为SQL语句。当执行时，一个SQL语句返回与查询匹配的数据行集合或无结果。
- en: The relational model algebra uses the relation composition to compose operations
    across different sets; this is translated in the relational database context by
    **joins**. Joining tables allows complex queries to be shaped to filter out data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关系模型代数使用关系组合来组合不同集合的操作；这在关系数据库上下文中通过**连接**来实现。连接表允许复杂的查询被塑形以过滤数据。
- en: 'SQL provides the following three kinds of joins:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: SQL提供了以下三种类型的连接：
- en: '| Union Type | Description |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 联合类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| INNER JOIN | Intersection between two tables. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| INNER JOIN | 两个表之间的交集。|'
- en: '| LEFT OUTER JOIN | Limits the result set by the left table. So all results
    from the left table will be returned with their matching result in the right table.
    If no matching result is found, it will return a NULL value. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| LEFT OUTER JOIN | 通过左表限制结果集。因此，左表的所有结果都将与右表中的匹配结果一起返回。如果没有找到匹配的结果，它将返回一个NULL值。|'
- en: '| RIGHT OUTER JOIN | Same as the LEFT OUTER JOIN except that the tables are
    reversed. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| RIGHT OUTER JOIN | 与LEFT OUTER JOIN相同，只是表顺序相反。|'
- en: There is no RDBMS written in Python but most RDBMSes can be accessed via a corresponding
    Python library.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 没有用Python编写的RDBMS，但大多数RDBMS可以通过相应的Python库访问。
- en: Object-Oriented Database Management System (OODBMS)
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象数据库管理系统（OODBMS）
- en: An OODBMS uses the object-oriented model to organize and store information.
    In other words, an OODBMS allows objects to be stored without having to be mapped
    into a different data structure like the relational database. This implies a great
    consistency between the database persisting the data and the application layers
    encapsulating it. In fact, the persistence mechanism is unobtrusive to the developer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个面向对象的数据库管理系统（OODBMS）使用面向对象模型来组织和存储信息。换句话说，OODBMS允许对象被存储，而无需映射到不同的数据结构，如关系数据库。这意味着数据库持久化数据和封装它的应用层之间具有很高的一致性。事实上，持久化机制对开发者来说是不可见的。
- en: XML Database Management System (XMLDBMS)
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML数据库管理系统（XMLDBMS）
- en: '**Native XML Databases** (**NXDs**) use XML documents as the unit of data they
    store and manipulate. XMLDBMSes on top of NXDs are optimized in this sense and
    provide native support for standard XML selection and querying languages such
    as XPath and XQuery. Some modern RDBMSes offer XML support through transparent
    conversion between the XML and relational data model leveraging the introduction
    of an XML database requirement.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**原生XML数据库**（**NXDs**）使用XML文档作为它们存储和操作的数据单元。基于NXDs的XML数据库管理系统（XMLDBMSes）在这方面进行了优化，并提供了对标准XML选择和查询语言（如XPath和XQuery）的原生支持。一些现代RDBMS通过引入XML数据库要求，利用XML和关系数据模型之间的透明转换来提供XML支持。'
- en: Object-Relational Mapping
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象关系映射
- en: For the last fifteen years the software industry has moved towards a generalized
    use of the object-oriented modeling paradigm in the different layers of software
    application development. One of the last bastions that have resisted against this
    wave has been the database domain. Nonetheless, over the years quite an important
    amount of work has been conducted with success in order to develop OODBMSes for
    filling the gap of managing data. In spite of that OODBMSes have not taken off
    enough to steal RDBMS's thunder.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十五年里，软件行业已经转向在软件应用开发的各个层次上普遍使用面向对象建模范式。一直抵抗这一浪潮的最后堡垒之一是数据库领域。尽管如此，多年来已经进行了相当重要且成功的工作，以开发面向对象数据库管理系统（OODBMSes）来填补管理数据的空白。尽管如此，OODBMSes还没有足够地起飞，以至于能够抢走RDBMS的风头。
- en: 'There are several factors behind this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后有几个因素：
- en: Cost of changing the market. For decades RDBMSes have been the DBMSes of predilection
    to store and organize data. Most businesses have built their infrastructure around
    RDBMSes and changing that state is an immense task and only few are ready to pay
    for such a risk.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变市场的成本。几十年来，关系型数据库管理系统（RDBMS）一直是存储和组织数据的首选数据库管理系统。大多数企业已经围绕RDBMS构建了他们的基础设施，改变这种状态是一项巨大的任务，而且只有少数人愿意为这种风险付费。
- en: Cost of migrating existing data. Even if a company is ready to step into that
    direction for new projects, it is unlikely it will for the existing infrastructure
    as the cost of migration and integration would be too high.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移现有数据的成本。即使一家公司准备进入新项目的新方向，它也不太可能对现有基础设施进行迁移，因为迁移和集成的成本会太高。
- en: Lack of unified query language.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏统一的查询语言。
- en: Lack of third-party software such as reporting tools based on OODBMS.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏第三方软件，例如基于OODBMS的报告工具。
- en: Lack of experts. Finding a database administrator for a RDBMS is much easier
    than for an ODBMS.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏专家。找到一个RDBMS的数据库管理员比找到一个ODBMS的数据库管理员容易得多。
- en: '**Object-Relational Mappers** (**ORMs**) succeeded because they were an efficient
    and cost-effective answer to some of the enumerated issues. The principle behind
    object-relational mapping is to reduce the impedance mismatch between the two
    models with minimum intrusion. ORMs allow the database designer and administrator
    to keep their beloved RDBMSes while proposing an objected-oriented interface to
    a certain extent to the software developer. ORM is an extra layer between the
    database and the application which translates an object into a database row and
    vice versa.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射器**（**ORMs**）之所以成功，是因为它们是针对一些列举问题的有效且经济的解决方案。对象关系映射背后的原则是通过最小侵入来减少两种模型之间的阻抗不匹配。ORM允许数据库设计者和管理员保持他们钟爱的关系型数据库管理系统（RDBMS），同时在一定程度上向软件开发者提供一个面向对象的接口。ORM是数据库和应用程序之间的一层额外层，它将对象转换为数据库行，反之亦然。'
- en: It is important to bear in mind though that ORM can alleviate the problem only
    to a certain degree and that in some cases the differences between the relational
    and object design cannot be met without some compromise on both sides. For example,
    most ORMs correlate a database table into a class, which works fine when the number
    of entities and their relationships stay at a basic level. Unfortunately, this
    one-to-one relationship between a table and a class does not always work well
    in more complex object-oriented design. In such cases the impedance mismatch between
    the relational and object-oriented models may force designers to make concessions
    that could have negative impacts in the long run in regards to extending and maintaining
    the software.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要记住，ORM 只能在一定程度上缓解这个问题，并且在某些情况下，关系和对象设计之间的差异可能无法在没有双方妥协的情况下得到满足。例如，大多数
    ORM 将数据库表关联到一个类中，这在实体和它们的关系保持基本水平时工作得很好。不幸的是，这种表和类之间的一对一关系在更复杂的面向对象设计中并不总是工作得很好。在这种情况下，关系和面向对象模型之间的阻抗不匹配可能迫使设计者做出让步，这可能会在长期扩展和维护软件时产生负面影响。
- en: Python Object-Relational Mappers
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 对象关系映射器
- en: This section will introduce three ORMs in a very basic example in order to provide
    a basic understanding of how they work and their differences. The purpose is not
    to declare one of these ORMs the winner but to give you an idea of their design
    and features.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将通过一个非常基本的示例介绍三个 ORM，以便提供对它们如何工作及其差异的基本理解。目的不是宣布其中一个 ORM 为胜者，而是给你一个关于它们设计和功能的想法。
- en: 'The three ORMs we will cover are:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的三个 ORM 是：
- en: SQLObject from Ian Bicking
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLObject 来自伊恩·比京克
- en: SQLAlchemy from Michael Bayer
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy 来自迈克尔·贝耶
- en: Dejavu from Robert Brewer
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dejavu 来自罗伯特·布鲁尔
- en: Although great care has been taken in this section, it may happen that by the
    time you read this chapter these products might have changed a bit. You will have
    to refer to their official documentation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这一节中已经非常小心谨慎，但当你阅读这一章时，这些产品可能已经有所变化。你将需要参考它们的官方文档。
- en: 'In the following example we will map the following entities:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将映射以下实体：
- en: 'Artist: An artist is made of a name. An artist can have zero or several albums.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 艺术家：艺术家由一个名称组成。艺术家可以有零个或多个专辑。
- en: 'Album: An album is made of a title and a release year. An album is associated
    to an artist and can have zero or more songs.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑：专辑由标题和发行年份组成。专辑与艺术家相关联，可以包含零个或多个歌曲。
- en: 'Song: A song is made of a name and a position within the album. A song is associated
    to an album.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 歌曲：一首歌由一个名称和在专辑中的位置组成。一首歌与一个专辑相关联。
- en: This example should be seen as a stripped down version of our photoblog entity
    set that we defined at the start of this chapter in order to focus on the actual
    features of each ORM rather than on the entities themselves.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应该被视为我们在本章开头定义的 photoblog 实体集的一个简化版本，以便专注于每个 ORM 的实际功能，而不是实体本身。
- en: 'Step 1: **Mapping the entities**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步：**映射实体**
- en: '**SQLObject**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLObject**'
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first point to note is that SQLObject does not require a separate declaration
    of the mapping that is done within the class itself. Each class must inherit from
    the unobtrusive `SQLObject` class to be manageable by SQLObject and the attributes
    will be mapped transparently by SQLObject into the table's columns. SQLObject
    automatically adds an attribute `id` to hold the unique identifier of each object.
    This means that every table mapped by SQLObject must have a primary key.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的第一点是，SQLObject 不需要单独声明在类内部进行的映射。每个类都必须继承自无侵入性的 `SQLObject` 类，以便由 SQLObject
    管理，并且属性将由 SQLObject 透明地映射到表的列中。SQLObject 自动添加一个 `id` 属性来保存每个对象的唯一标识符。这意味着由 SQLObject
    映射的每个表都必须有一个主键。
- en: '`ForeignKey` or `MultipleJoin` are examples of how to define the relationships
    between entities. Note that they need the name of the class as a string and not
    the class object itself. This allows the declaration of relationships without
    the prior existence of each class within the scope of the module. In other words
    `Artist` and `Album` could be declared in two different modules without the problem
    of cross imports.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForeignKey` 或 `MultipleJoin` 是定义实体之间关系的一个例子。请注意，它们需要一个字符串形式的类名，而不是类对象本身。这允许在不每个类在模块作用域内先存在的情况下声明关系。换句话说，`Artist`
    和 `Album` 可以在两个不同的模块中声明，而不会出现交叉导入的问题。'
- en: SQLObject offers a useful feature when specifying `alternateID` as a parameter
    in one of the class attributes. By using it, SQLObject adds a new method to the
    class of the form `byAttributeName` as shown in the example above. Note also how
    you can specify at that level the way rows must be ordered when being retrieved.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当在类的一个属性中将`alternateID`指定为参数时，SQLObject提供了一个有用的功能。通过使用它，SQLObject向类添加了一个新方法，形式如上例所示。注意您也可以在那个级别上指定检索行时必须如何排序。
- en: Finally bear in mind that by default SQLObject auto-commits to the database
    each modification made to an attribute, which can increase the network overhead
    as well as break the database integrity if an error occurs. To work around this
    behavior SQLObject offers the `set` method on an SQLObject object that performs
    one single `UPDATE` query for all the modifications limiting the required bandwidth.
    Moreover, SQLObject supports the concept of transactions, allowing us to ensure
    that operations are atomic to the database and can then be rolled back if an error
    occurs. Note that the transactions have to be explicitly requested by the developer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后请注意，默认情况下，SQLObject会对每个修改过的属性自动提交到数据库，这可能会增加网络开销，如果在发生错误时破坏数据库完整性。为了解决这个问题，SQLObject提供了一个在SQLObject对象上的`set`方法，它为所有修改执行一个单一的`UPDATE`查询，从而限制所需的带宽。此外，SQLObject支持事务的概念，允许我们确保操作对数据库是原子的，如果发生错误，则可以回滚。请注意，事务必须由开发者显式请求。
- en: '**SQLAlchemy**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLAlchemy**'
- en: '[PRE1]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: SQLAlchemy uses a declarative mapping style as you can see. The first step is
    to express tables into their Python syntax counterpart. Then we need to declare
    the class our application will manipulate. Note how they don't need to inherit
    from an `SQLAlchemy` class even though they must inherit from the built-in Python
    object class. Eventually, we map both aspects through the `mapper` function, which
    also allows us to inform SQLAlchemy of the relationships between entities.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy使用您可以看到的声明式映射风格。第一步是将表表达为其Python语法的对应物。然后我们需要声明应用程序将操作的那个类。注意它们不需要从`SQLAlchemy`类继承，尽管它们必须从内置的Python对象类继承。最终，我们通过`mapper`函数将这两个方面映射，该函数还允许我们通知SQLAlchemy实体之间的关系。
- en: You will notice how the identifier of each table is explicitly declared unlike
    SQLObject and Dejavu. Similarly you do not specify at that level how fetched rows
    must be ordered as this will be specified at the query level.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，与SQLObject和Dejavu不同，每个表的标识符都是显式声明的。同样，您在那个级别上不指定如何排序检索到的行，因为这将在查询级别指定。
- en: '**Dejavu**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dejavu**'
- en: '[PRE2]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Like SQLObject, Dejavu does lots of work under the hood. Each class participating
    in the mapping must inherit from `Unit`. The attributes of the class represent
    the columns of the table. Only the relationship between the entities is done through
    a more declarative interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与SQLObject类似，Dejavu在底层做了很多工作。每个参与映射的类都必须继承自`Unit`。类的属性代表表的列。实体之间的关系是通过一个更声明式的接口来完成的。
- en: One difference between Dejavu and the other two is that it does not provide
    the cascade delete feature. This means that this has to be accomplished from the
    class itself by defining an `on_forget()` method and specifying what tasks should
    be done when deleting a unit. This might look at first sight like a drawback but
    offers, in fact, a fine granularity on how you propagate a cascade delete.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Dejavu与其他两个的区别在于它不提供级联删除功能。这意味着这必须通过定义一个`on_forget()`方法并在删除单元时指定应执行哪些任务来自类本身来完成。这乍一看可能像是一个缺点，但实际上提供了如何传播级联删除的良好粒度。
- en: 'Step 2: **Setting up the access to the database**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步：**设置数据库访问**
- en: '**SQLObject**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLObject**'
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**SQLAlchemy**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLAlchemy**'
- en: '[PRE4]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Dejavu**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dejavu**'
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Step 3: **Manipulating tables**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步：**操作表**
- en: '**SQLObject**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLObject**'
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**SQLAlchemy**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLAlchemy**'
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Dejavu**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dejavu**'
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Step 4: **Loading data**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步：**加载数据**
- en: '**SQLObject**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLObject**'
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**SQLAlchemy**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLAlchemy**'
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note the fact that each object is created independently from the other and their
    relationship is fulfilled in a second step, e.g. the `append()` method on the
    `grace.songs` object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个对象都是独立于其他对象创建的，并且它们的关系是在第二步中完成的，例如`grace.songs`对象的`append()`方法。
- en: In the same declarative spirit as above SQLAlchemy does not commit automatically
    by default to the database. Instead it delays the operation until you `flush`
    the current session of work.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述声明式精神相同，SQLAlchemy默认不会自动提交到数据库。相反，它将操作延迟到您`flush`当前工作会话时。
- en: '**Dejavu**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dejavu**'
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Dejavu provides the concept of sandboxes in which you can isolate the entities
    you manipulate. Also note that newly created units do not exist for their relatives
    until you call the `sandbox.memorize()` method, which puts the unit into the sandbox.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Dejavu 提供了沙盒的概念，在其中你可以隔离你操作的实体。此外，请注意，新创建的单位在你调用 `sandbox.memorize()` 方法之前并不存在于它们的相对者中，这个方法将单位放入沙盒中。
- en: Like SQLAlchemy, Dejavu delays the commit operation until you explicitly call
    the `sandbox.flush_all()` method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQLAlchemy 类似，Dejavu 会延迟提交操作，直到你显式调用 `sandbox.flush_all()` 方法。
- en: 'Step 5: **Manipulating data**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5 步：**操作数据**
- en: First we define a function that will take an artist and display the albums'
    songs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数，它将接受一个艺术家并显示专辑的歌曲。
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**SQLObject**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLObject**'
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**SQLAlchemy**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLAlchemy**'
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Dejavu**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dejavu**'
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Choosing an object-relational mapper is a difficult task as it is usually after
    using one for a while that you can really measure the impact it has on the development
    design and process. As previously stated, it is critical to acknowledge that ORMs
    do not remove the impedance mismatch between the relational and object-oriented
    model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 选择对象关系映射器是一个困难的任务，因为通常只有在使用了一段时间之后，你才能真正衡量它对开发设计和流程的影响。如前所述，承认 ORM 不能消除关系模型和面向对象模型之间的阻抗不匹配是至关重要的。
- en: SQLObject has a low-learning curve and quite a big community, which makes it
    suitable for developers debuting in the use of ORM. The project is aiming at its
    next version, which will fix a fair number of bad design decisions made in its
    early life while slowly abandoning the current version.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: SQLObject 具有较低的学习曲线和相当大的社区，这使得它适合那些刚开始使用 ORM 的开发者。该项目正致力于其下一个版本，该版本将修复其在早期生活中做出的许多不良设计决策，同时逐渐放弃当前版本。
- en: SQLAlchemy has based its design on the Hibernate ORM from the Java world and
    has thus avoided lots of pitfalls that SQLObject has not. Its declarative syntax
    will not please every pythoner but its flexibility and good documentation have
    placed SQLAlchemy as a very serious candidate in the field.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 基于来自 Java 世界的 Hibernate ORM 进行设计，因此避免了 SQLObject 没有避免的许多陷阱。它的声明性语法可能不会让每个
    Python 程序员都满意，但它的灵活性和良好的文档使 SQLAlchemy 成为该领域一个非常严肃的候选人。
- en: Dejavu is a fairly unknown ORM and thus has a small community. It is well documented
    and comes with relevant example cases. Its strength resides in its capacity to
    move away from the underlying relational database layer by providing a very high-level
    interface using common Python idioms.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Dejavu 是一个相对不太为人所知的 ORM，因此拥有一个较小的社区。它有很好的文档，并附带相关的示例案例。它的优势在于能够通过提供一个非常高级的接口，使用常见的
    Python 习惯用法，从而摆脱底层的关系数据库层。
- en: For instance, SQLObject and SQLAlchemy do use terms such as `table, column`,
    or `select` while Dejavu refers to `storage` and `unit` providing a better abstraction
    to the underlying mechanisms.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，SQLObject 和 SQLAlchemy 使用诸如`table`、`column`或`select`之类的术语，而 Dejavu 则使用`storage`和`unit`，这为底层机制提供了更好的抽象。
- en: This is also true when it comes to the process of building queries. Unlike SQLObject
    and SQLAlchemy, which stay very close to SQL by providing a Python interface to
    SQL statements, Dejavu provides an interface independent of SQL. Review the section
    on manipulating data for an example.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构建查询的过程时，这也是正确的。与提供 Python 接口到 SQL 语句并非常接近 SQL 的 SQLObject 和 SQLAlchemy
    不同，Dejavu 提供了一个独立于 SQL 的接口。查看关于操作数据的部分以获取示例。
- en: These are the reasons why our photoblog application will use Dejavu instead
    of SQLObject or SQLAlchemy. However, keep in mind that they are all good and powerful
    ORMs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这些原因，我们的 photoblog 应用程序将使用 Dejavu 而不是 SQLObject 或 SQLAlchemy。然而，请记住，它们都是优秀且强大的
    ORM。
- en: Photoblog Application Entity Modeling
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Photoblog 应用实体建模
- en: First we define what we will call a `storage` module providing a simple interface
    to some common operations like the connection to the database.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个我们将称之为`存储`模块的东西，它提供了一个简单的接口来执行一些常见操作，如连接到数据库。
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, we import the `dejavu` module and we create one global instance
    of the `Arena` class. The `arena` will be our interface between the underlying
    storage manager and the business logic layer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们导入`dejavu`模块，并创建一个全局的`Arena`类实例。`arena`将是底层存储管理器和业务逻辑层之间的接口。
- en: The `connect` function adds a storage manager to the `arena` object for a PostgreSQL
    RDBMS and then registers all imported entities so that the `arena` object knows
    what entities it will manage. (Please refer to the Dejavu documentation for a
    list of supported database managers and how to declare them within the `add_store()`
    method.) Once we have this module we can start mapping entities.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 函数将存储管理器添加到 PostgreSQL RDBMS 的 `arena` 对象中，然后注册所有导入的实体，以便 `arena`
    对象知道它将管理哪些实体。（请参阅 Dejavu 文档以获取支持的数据库管理器列表以及如何在 `add_store()` 方法中声明它们。）一旦我们有了这个模块，我们就可以开始映射实体。'
- en: Mapping Entities
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射实体
- en: 'Mapping the entities is done through the following process:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的映射是通过以下过程完成的：
- en: Creating a class that inherits from `Unit`
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建继承自 `Unit` 的类
- en: Adding attributes using the `UnitProperty` class
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UnitProperty` 类添加属性
- en: Setting up the relationship between units
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单位之间的关系
- en: '**Entity:** Photoblog'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体：** 照片博客'
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Entity:** Album'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体：** 专辑'
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Entity:** Film'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体：** 电影'
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Entity:** Photo'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体：** 照片'
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Units and UnitProperties
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单位和单位属性
- en: In the previous section, we mapped our entities into units that Dejavu will
    manage. All our classes inherit from the `Unit` base class. This class does not
    provide much apart from automatically adding an `ID` property to the class, which
    is the reason why we do not explicitly provide one in any of our units. Nonetheless
    by inheriting from the `Unit` class you allow Dejavu to register and handle your
    class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将我们的实体映射到 Dejavu 将管理的单位。我们所有的类都继承自 `Unit` 基类。这个类除了自动为类添加一个 `ID` 属性之外，没有提供太多功能，这也是为什么我们在任何单位中都没有显式提供它的原因。尽管如此，通过继承
    `Unit` 类，你允许 Dejavu 注册和处理你的类。
- en: 'The next step is obviously to add properties to your classes via the `UnitProperty`
    class, which has the following signature:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步显然是使用 `UnitProperty` 类添加属性到你的类中，该类具有以下签名：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `type` parameter is a Python type. Dejavu takes care of translating it into
    the appropriate SQL equivalent type transparently.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type` 参数是 Python 类型。Dejavu 会透明地将它转换为适当的 SQL 等价类型。'
- en: The `index` parameter indicates whether the column should be indexed by the
    RDBMS if it supports it.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index` 参数表示如果 RDBMS 支持，列是否应该被索引。'
- en: 'The `hints` parameter is a dictionary to help Dejavu storage managers to optimize
    the creation of the column. Dejavu has three built-in hints but you can provide
    yours if you create your own storage manager:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hints` 参数是一个字典，用于帮助 Dejavu 存储管理器优化列的创建。Dejavu 有三个内置提示，但如果你创建了自己的存储管理器，你也可以提供自己的提示：'
- en: '`bytes:` Indicates the number of bytes to be used for a unicode property, 0
    meaning unlimited.'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes:` 表示用于 unicode 属性的字节数，0 表示无限。'
- en: '`scale:` Number of digits to the right of the decimal point in a numeric column.'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale:` 数值列小数点右边的数字数量。'
- en: '`precision:` Total number of digits in a numeric column.'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precision:` 数值列中的数字总数。'
- en: The `key` parameter is the property canonical name.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key` 参数是属性的规范名称。'
- en: The `default` parameter indicates the default value to be used.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default` 参数表示要使用的默认值。'
- en: Properties will map into the columns of a table in the relational database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 属性将映射到关系数据库表中的列。
- en: Associating Units
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联单位
- en: Associating units is the means of giving a shape to your design. Entities are
    bricks, relations are the mortar.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 关联单位是赋予你的设计形状的手段。实体是砖块，关系是灰泥。
- en: 'Dejavu supports the following common relationships:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Dejavu 支持以下常见关系：
- en: One to one (1, 1)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一（1, 1）
- en: One to many (1, n)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对多（1, n）
- en: Many to one (n, 1)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对一（n, 1）
- en: 'In each case you provide the signature as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，你提供以下签名：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Therefore the relation between `Film` and `Photo` is:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Film` 和 `Photo` 之间的关系是：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `nearClass` is `Film`, the `nearKey` is `ID` (property of the `nearClass`),
    the `farClass` is `Photo`, and the `farKey` is `film_id` (property of the `farClass`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`nearClass` 是 `Film`，`nearKey` 是 `ID`（`nearClass` 的属性），`farClass` 是 `Photo`，`farKey`
    是 `film_id`（`farClass` 的属性）。'
- en: Dejavu does not provide a native many-to-many relationship but this is achievable
    through a third unit class and a one-to-one relationship.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Dejavu 不提供原生的多对多关系，但可以通过第三个单位类和一对一关系来实现。
- en: The Sandbox Interface
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沙盒接口
- en: The `sandbox` object manages memory dedicated to units in a protected way. A
    `sandbox` is where units spend their life. There are two ways to create `sandboxes:`
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`sandbox` 对象以受保护的方式管理分配给单位的内存。`sandbox` 是单位度过其生命的地方。有两种创建 `sandbox` 的方法：'
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The former version is the most common and is the one we will use throughout
    this book.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前者是最常见的版本，也是我们将在整本书中使用的版本。
- en: 'Let''s review a few key methods of the `sandbox` interface:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`sandbox`接口的一些关键方法：
- en: '`memorize:` When you create a new instance of a unit, it exists only in memory
    and is separated from the storage manager. You need to call the `memorize` method
    to make it part of the `sandbox`. This will also set the `ID` of the unit. Additionally
    this will reserve a place in the underlying database by issuing an `INSERT INTO
    SQL` statement.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memorize:` 当你创建一个单元的新实例时，它只存在于内存中，并且与存储管理器分离。你需要调用`memorize`方法使其成为`sandbox`的一部分。这将也会设置单元的`ID`。此外，这还会通过发出一个`INSERT
    INTO SQL`语句在底层数据库中预留一个位置。'
- en: '`forget:` In order to tell the store manager to stop managing a unit you must
    call the `forget` method. This will delete it from the `sandbox` and from the
    storage manager.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forget:` 为了告诉存储管理器停止管理一个单元，你必须调用`forget`方法。这将把它从`sandbox`和存储管理器中删除。'
- en: '`repress:` In some cases you may wish to clear the unit from the `sandbox`
    but not from the store manager. In such cases you should use the `repress` method.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repress:` 在某些情况下，你可能希望从`sandbox`中清除单元，但不是从存储管理器中。在这种情况下，你应该使用`repress`方法。'
- en: '`recall, xrecall:` These two methods allow you to retrieve units based on filters
    (as we will explain in the section *Querying Units)*. The difference between `recall`
    and `xrecall` is that the latter yields results in an iterating fashion whereas
    the former loads everything into a list at once.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recall, xrecall:` 这两个方法允许你根据过滤器检索单元（正如我们将在*单元查询*部分中解释的）。`recall`和`xrecall`之间的区别在于后者以迭代方式产生结果，而前者一次性将所有内容加载到列表中。'
- en: '`unit:` Both the previous methods are powerful ones to retrieve a set of data
    but they can be heavy when you simply look for one unit based on a value of its
    properties. This is what the `unit` method provides.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unit:` 这两个先前的方法都是强大的数据集检索方法，但当你仅仅基于属性值查找一个单元时，它们可能会很重。这就是`unit`方法提供的内容。'
- en: '`flush_all:` Once you have manipulated your units you have to call `flush_all`
    in order to make those changes to the physical back end.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flush_all:` 一旦你操作了你的单元，你必须调用`flush_all`以使这些更改应用到物理后端。'
- en: As you can see, the interface provided by the `Sandbox` class is quite simple,
    straightforward, and yet powerful as the next section will demonstrate.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Sandbox`类提供的接口相当简单、直接，而且非常强大，下一节将演示这一点。
- en: Querying Units
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元查询
- en: We have seen so far how to map our entities into units as well as how to manipulate
    those units. This section will explain in detail how to query the storage manager
    for units based on criteria.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将我们的实体映射到单元以及如何操作这些单元。本节将详细解释如何根据标准查询存储管理器中的单元。
- en: Within Dejavu querying is done through an `Expression` instance. The `Expression`
    class is a filter for units. Let's take an example to explain how this works.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dejavu中，查询是通过一个`Expression`实例完成的。`Expression`类是单元的过滤器。让我们通过一个例子来解释它是如何工作的。
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first step is to create a function that returns a `bool`. That function
    is usually a `lambda` as there is no need to pollute the Python namespace with
    meaningless names. Then we pass it to one of the `sandbox` methods such as `recall`
    or `xrecall`, which will create a `logic.Expression` instance and apply it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个返回`bool`值的函数。这个函数通常是`lambda`，因为没有必要用无意义的名称污染Python命名空间。然后我们将其传递给`sandbox`方法之一，如`recall`或`xrecall`，这将创建一个`logic.Expression`实例并应用它。
- en: Expressions show their value when filtering against complex queries such as
    the one involving JOIN. For example, if you want to join between units you would
    use Python operators between the units themselves.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式在过滤复杂查询时显示其值，例如涉及JOIN的查询。例如，如果你想在不同单元之间进行连接，你会在单元本身之间使用Python运算符。
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the first parameter of the method takes an aggregation of the
    unit classes that will take part in the join. Dejavu gives you the opportunity
    of using Python operators to declare aggregation between units.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，方法的第一个参数接受一个将参与连接的单元类的聚合。Dejavu给你使用Python运算符来声明单元之间聚合的机会。
- en: When composing between units, the order is important while constructing the
    `filter` function. In the previous example the `lambda` function parameters will
    match the order of the composed units. This behavior is mirrored by the result
    returned by the `recall()` method, which will provide a list of `Album` and `Photo`
    items.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元之间组合时，构建`filter`函数的顺序很重要。在先前的例子中，`lambda`函数的参数将与组合单元的顺序相匹配。这种行为通过`recall()`方法返回的结果得到了反映，该方法将提供一个包含`Album`和`Photo`项的列表。
- en: Below are the Dejavu representations of SQL JOINs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Dejavu表示的SQL JOIN。
- en: '| Join Type | Operator | Description |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 连接类型 | 操作符 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Inner | & or + | All related pairs of both classes will be returned. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 内连接 | & 或 + | 将返回两个类中所有相关联的配对。 |'
- en: '| Left Outer | << | All related pairs of both classes will be returned. In
    addition, if any Unit in class1 has no match in class2, we return a single row
    with Unit1 and a **null Unit** (a Unit, all of whose properties are None). |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 左外连接 | << | 将返回两个类中所有相关联的配对。此外，如果类1中的任何单元在类2中没有匹配项，我们将返回一个包含单元1和一个**空单元**（一个所有属性都是None的单元）的单行。'
- en: '| Right Outer | >> | All related pairs of both classes will be returned. In
    addition, if any Unit in class2 has no match in class1, we return a single row
    with a null Unit (a Unit, all of whose properties are None) and Unit2. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 右外连接 | >> | 将返回两个类中所有相关联的配对。此外，如果类2中的任何单元在类1中没有匹配项，我们将返回一个包含空单元（一个所有属性都是None的单元）和单元2的单行。'
- en: 'There is no limitation from Dejavu regarding the aggregation you build. For
    instance you can write:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Dejavu对您构建的聚合没有限制。例如，您可以编写：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Extending the Data Access Layer
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展数据访问层
- en: In the previous sections, we have defined the mapping between our entities and
    the classes our application will manipulate. As they stand these classes are not
    very useful; in this section we will see how to extend them to provide more functionalities.
    To keep this section concise, we will only discuss the `Album` class.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经定义了我们的实体与我们的应用程序将要操作的类之间的映射。就目前而言，这些类并不是非常有用；在本节中，我们将看到如何扩展它们以提供更多功能。为了使本节简明扼要，我们只讨论`Album`类。
- en: 'Methods to be added to the Album class:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加到专辑类中的方法：
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the `Album` class now contains enough methods to allow manipulation
    of `Album` instances. The other photoblog entities share the same idea and will
    provide similar interfaces.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Album`类现在包含足够的方法，允许操作`Album`实例。其他照片博客实体采用相同的概念，并将提供类似的接口。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter has introduced the backbone of our photoblog application through
    the description of its entities and how they are mapped in their Python counterparts.
    Our next chapter will review how to manipulate those entities from our CherryPy
    handlers to build the external interface of our application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过描述我们的照片博客应用程序的实体及其在Python中的映射，介绍了我们应用程序的骨架。我们下一章将回顾如何从我们的CherryPy处理器中操作这些实体，以构建我们应用程序的外部接口。
