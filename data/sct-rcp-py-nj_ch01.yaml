- en: Working with Python Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 模块
- en: 'In this chapter, we will talk about Python modules, specifically covering the
    following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Python 模块，具体涵盖以下主题：
- en: Using and importing modules and namespaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和导入模块及命名空间
- en: Implementing virtual Python environments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现虚拟 Python 环境
- en: Python package installation options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 包安装选项
- en: Utilizing requirement files and resolving conflicts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用需求文件和解决冲突
- en: Using local patches and constraint files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地补丁和约束文件
- en: Working with packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包
- en: Creating wheels and bundles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和打包
- en: Comparing source code to bytecode
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较源代码与字节码
- en: How to create and reference module packages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和引用模块包
- en: Operating system-specific binaries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统特定的二进制文件
- en: How to upload programs to PyPI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何上传程序到 PyPI
- en: Project packaging
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目打包
- en: Uploading to PyPI
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传到 PyPI
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Python modules are the highest-level components of Python programs. As suggested
    by their name, modules are modular, capable of being plugged in with other modules
    as part of an overall program to provide better separation of code while combining
    together to create a cohesive application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 模块是 Python 程序的最高级组件。正如其名称所暗示的，模块是模块化的，可以作为整体程序的一部分与其他模块连接，以提供更好的代码分离，同时结合在一起创建一个统一的程序。
- en: Modules allow easy reuse of code, and provide separate namespaces to prevent
    variable shadowing between blocks of code. Variable shadowing involves having
    duplicate variables in different namespaces, possibly causing the interpreter
    to use an incorrect variable. Each Python file a developer creates is considered
    a separate module, allowing different files to be imported into a single, overall
    file that forms the final application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模块允许轻松重用代码，并提供独立的命名空间以防止代码块之间的变量阴影。变量阴影涉及在不同命名空间中具有重复的变量，可能会导致解释器使用错误的变量。开发人员创建的每个
    Python 文件都被视为一个单独的模块，允许不同的文件被导入到一个单一的、整体的文件中，该文件构成了最终的应用程序。
- en: Realistically, any Python file can be made a module by simply removing the `.py`
    extension; this is most commonly seen when importing libraries. Python packages
    are collections of modules; what makes a package special is the inclusion of an
    `__init__.py` file. We will cover the differences in detail later, so for now
    just recognize that there are several names for the same items.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，任何 Python 文件都可以通过简单地删除 `.py` 扩展名来成为一个模块；这通常在导入库时看到。Python 包是模块的集合；使包特殊的是包含一个
    `__init__.py` 文件。我们将在稍后详细讨论这些差异，所以现在只需认识到同一项物品有多个名称。
- en: Using and importing modules and namespaces
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用和导入模块及命名空间
- en: A key point with modules is that they produce separate namespaces. A namespace
    (also called a **scope**) is simply the domain of control that a module, or component
    of a module, has. Normally, objects within a module are not visible outside that
    module, that is, attempting to call a variable located in a separate module will
    produce an error.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的一个关键点是它们产生独立的命名空间。命名空间（也称为**作用域**）只是一个模块或模块组件的控制域。通常，模块内的对象在模块外部不可见，也就是说，尝试调用位于不同模块中的变量将产生错误。
- en: Namespaces are also used to segregate objects within the same program. For example,
    a variable defined within a function is only visible for use while operating within
    that function. Attempting to call that variable from another function will result
    in an error. This is why global variables are available; they can be called by
    any function and interacted with. This is also why global variables are frowned
    upon as a best practice because of the possibility of modifying a global variable
    without realizing it, causing a breakage later on in the program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间也用于隔离同一程序内的对象。例如，在函数内定义的变量仅在操作该函数时可见。尝试从另一个函数调用该变量将导致错误。这就是为什么全局变量是可用的；它们可以被任何函数调用并与之交互。这也是为什么全局变量不被推荐为最佳实践，因为可能会在不经意间修改全局变量，导致程序后续部分出现故障。
- en: 'Scope essentially works inside-out. If a variable is called for use in a function,
    the Python interpreter will first look within that function for the variable''s
    declaration. If it''s not there, Python will move up the stack and look for a
    globally-defined variable. If not found there, Python will look in the built-in
    libraries that are always available. If still not found, Python will throw an
    error. In terms of flow, it looks something like this: *local scope* -> *global
    scope* -> *built-in module* -> *error*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域基本上是自内而外工作的。如果一个变量在函数中使用，Python解释器会首先在该函数内查找该变量的声明。如果找不到，Python会向上查找栈，寻找全局定义的变量。如果在那里也找不到，Python会在始终可用的内置库中查找。如果仍然找不到，Python会抛出一个错误。从流程的角度来看，它看起来像这样：*局部作用域*
    -> *全局作用域* -> *内置模块* -> *错误*。
- en: One slight change to the scope discovery process comes when importing modules.
    Imported modules will be examined for object calls as well, with the caveat that
    an error will still be generated unless the desired object is explicitly identified
    via dot-nomenclature.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入模块时，作用域发现过程的一个小变化是，导入的模块也会被检查是否有对象调用，但有一个前提是，除非通过点命名法明确指定所需的对象，否则仍然会生成错误。
- en: 'For example, if you want to generate a random number between 0 and 1,000, you
    can''t just call the `randint()` function without importing the `random` library.
    Once a module is imported, any publicly available classes, methods, functions,
    and variables can be used by expressly calling them with `<module_name>` and `<object_name>`*.*
    Following is an example of this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想生成一个介于0到1,000之间的随机数，你不能不导入`random`库就调用`randint()`函数。一旦导入了一个模块，就可以通过明确调用它们来使用任何公开可用的类、方法、函数和变量，格式为`<module_name>.<object_name>`。以下是一个例子：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, `randint()` is first called on its own. Since it is
    not part of the normal Python built-in functions, the interpreter knows nothing
    about it, thus throwing an error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，首先单独调用了`randint()`。由于它不是Python内置函数的一部分，解释器对此一无所知，因此抛出了错误。
- en: However, after importing the `random` library that actually contains the various
    random number generation functions, `randint()` can then be explicitly called
    via dot-nomenclature, that is, `random.randint()`. This tells the Python interpreter
    to look for `randint()` within the `random` library, resulting in the desired
    result.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在导入包含各种随机数生成函数的`random`库之后，可以通过点命名法显式调用`randint()`，即`random.randint()`。这告诉Python解释器在`random`库中查找`randint()`，从而得到期望的结果。
- en: 'To clarify, when importing modules into a program, Python assumes some things
    about namespaces. If a normal import is performed, that is, `import foo`, then
    both the main program and `foo` maintain their separate namespaces. To use a function
    within the `foo` module, you have to expressly identify it using dot-nomenclature:
    `foo.bar()`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，当将模块导入程序时，Python对命名空间有一些假设。如果执行了正常导入，即`import foo`，那么主程序和`foo`保持它们各自的命名空间。要使用`foo`模块中的函数，必须使用点命名法明确指定它：`foo.bar()`。
- en: 'On the other hand, if part of a module is imported, for example, `from foo
    import bar`, then that imported component becomes a part of the main program''s
    namespace. This also happens if all components are imported using a wildcard:
    `from foo import *`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果只导入模块的一部分，例如，`from foo import bar`，那么导入的组件就成为了主程序作用域的一部分。如果使用通配符导入所有组件，也会发生这种情况：`from
    foo import *`。
- en: 'The following example shows these properties in action:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下例子展示了这些属性的实际应用：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, the `randint()` function from the `random` module
    is expressly imported by itself; this importation puts `randint()` within the
    main program's namespace. This allows `randint()` to be called without having
    to clarify it as `random.randint()`. However, when attempting to do the same thing
    with the `randrange()` function, an error occurs because it wasn't imported.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`random`模块中的`randint()`函数是明确单独导入的；这种导入方式使得`randint()`位于主程序的作用域内。这允许直接调用`randint()`而不需要明确指出它是`random.randint()`。然而，当尝试用`randrange()`函数做同样的事情时，会出现错误，因为它没有被导入。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To illustrate scope, we will create nested functions, where a function is defined
    and then called within an enclosing function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明作用域，我们将创建嵌套函数，其中在一个封装函数内定义并调用函数：
- en: '`nested_functions.py` includes a nested function, and ends with calling the
    nested function:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nested_functions.py`包含一个嵌套函数，并以调用嵌套函数结束：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, call the parent function and checks the results:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，调用父函数并检查结果：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, call the nested function directly and notice that an error is received:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，直接调用嵌套函数，并注意会收到一个错误：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To work with another module, import the desired module:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用另一个模块，导入所需的模块：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Below, we call the `sin()` function from within the module in the form `<module>.<function>`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面，我们以 `<module>.<function>` 的形式在模块内部调用 `sin()` 函数：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Try calling a function, as demonstrated below, without using the dot-nomenclature
    to specify its library package results in an error:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试像下面这样调用一个函数，不使用点命名法来指定其库包，会导致错误：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, the example below shows how to import all items from a module
    using the `*` wildcard to place the items within the current program''s namespace:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，下面的例子展示了如何使用 `*` 通配符将模块中的所有项导入到当前程序的命名空间中：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A common way to run modules as scripts is to simply call the module explicitly
    from the command line, providing any arguments as necessary. This can be set up
    by configuring the module to accept command-line arguments, as shown in `print_funct.py`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块作为脚本运行的一种常见方式是简单地从命令行显式调用模块，提供必要的任何参数。这可以通过配置模块以接受命令行参数来实现，如 `print_funct.py`
    所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`print_mult_args.py` shows that, if more than one argument is expected, and
    the quantity is known, each one can be specified using its respective index values
    in the arguments list:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`print_mult_args.py` 展示了，如果预期多个参数，且数量已知，每个参数都可以使用其在参数列表中的相应索引值来指定：'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, where the function can capture multiple arguments but the quantity
    is unknown, the `*args` parameter can be used, as shown below:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，当函数可以捕获多个参数但数量未知时，可以使用下面的 `*args` 参数，如下所示：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The location of a named assignment within the code determines its namespace
    visibility. In the preceding example, steps 1-3, if you directly call `second_funct()`
    immediately after calling `first_funct()`, you'll get an error stating `second_funct()`
    is not defined. This is true, because globally, the second function doesn't exist;
    it's nested within the first function and can't be seen outside the first function's
    scope. Everything within the first function is part of its namespace, just as
    the value for `x` within the second function can't be called directly but has
    to use the `second_funct()` call to get its value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中命名赋值的定位决定了其命名空间的可见性。在先前的例子中，步骤 1-3，如果在调用 `first_funct()` 后立即直接调用 `second_funct()`，你会得到一个错误，表明
    `second_funct()` 未定义。这是真的，因为全局上，第二个函数不存在；它是嵌套在第一个函数中的，并且不能在第一个函数的作用域之外被看到。第一个函数内部的所有内容都是其命名空间的一部分，就像第二个函数中的
    `x` 的值不能直接调用，而必须使用 `second_funct()` 调用来获取其值。
- en: In the preceding examples, step 4-7, the `math` module is imported in its entirety,
    but it keeps its own namespace. Thus, calling `math.sin()` provides a result,
    but calling `sin()` by itself results in an error.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，步骤 4-7，整个 `math` 模块被导入，但它保持了自己的命名空间。因此，调用 `math.sin()` 会得到一个结果，但单独调用
    `sin()` 会引发错误。
- en: Then, the `math` module is imported using a wildcard. This tells the Python
    interpreter to import all the functions into the main namespace, rather than keeping
    them within the separate `math` namespace. This time, when `sin()` is called by
    itself, it provides the correct answer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用通配符导入 `math` 模块。这告诉 Python 解释器将所有函数导入到主命名空间，而不是将它们保留在单独的 `math` 命名空间中。这次，当单独调用
    `sin()` 时，它会提供正确的答案。
- en: This demonstrates the point that namespaces are important to keep code separated
    while allowing the use of the same variables and function names. By using dot-nomenclature,
    the exact object can be called with no fear of name shadowing causing the wrong
    result to be provided.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了命名空间对于在允许使用相同的变量和函数名称的同时保持代码分离的重要性。通过使用点命名法，可以无惧名称遮蔽导致提供错误结果的风险。
- en: In preceding examples, steps 7-10, using `sys.argv()` allows Python to parse
    command-line arguments and places them in a list for use. `sys.argv([0])` is always
    the name of the program taking the arguments, so it can be safely ignored. All
    other arguments are stored in a list and can, therefore, be accessed by their
    index value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，步骤 7-10，使用 `sys.argv()` 允许 Python 解析命令行参数并将它们放置在列表中以供使用。`sys.argv([0])`
    总是接受参数的程序名称，因此可以安全地忽略。所有其他参数都存储在列表中，因此可以通过它们的索引值访问。
- en: Using `*args` tells Python to accept any number of arguments, allowing the program
    to accept a varying number of input values. An alternative version, `**kwargs`,
    does the same thing but with keyword:value pairs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `*args` 告诉 Python 接受任意数量的参数，允许程序接受不同数量的输入值。一个替代版本，`**kwargs`，做同样的事情，但使用关键字：值对。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In addition to knowing about namespaces, there are some other important terms
    to know about when installing and working with modules:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了了解命名空间之外，在安装和使用模块时，还有一些其他重要的术语需要了解：
- en: '[https://pypi.python.org/pypi](https://pypi.python.org/pypi) is the primary
    database for third-party Python packages.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.python.org/pypi](https://pypi.python.org/pypi) 是第三方 Python 包的主要数据库。'
- en: '`pip` is the primary installer program for third-party modules and, since Python
    3.4, has been included by default with Python binary installations.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip` 是第三方模块的主要安装程序，自 Python 3.4 以来，它已默认包含在 Python 二进制安装中。'
- en: A virtual Python environment allows packages to be installed for a particular
    application's development, rather than being installed system-wide.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟 Python 环境允许为特定应用程序的开发安装包，而不是系统范围内安装。
- en: '`venv` has been the primary tool for creating virtual Python environments since
    Python 3.3\. With Python 3.4, it automatically installs `pip` and `setuptools`
    in all virtual environments.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venv` 自 Python 3.3 以来一直是创建虚拟 Python 环境的主要工具。从 Python 3.4 开始，它会在所有虚拟环境中自动安装
    `pip` 和 `setuptools`。'
- en: 'The following are common terms for Python files: module, package, library,
    and distribution. While they have distinct definitions ([https://packaging.python.org/glossary/](https://packaging.python.org/glossary/)),
    this book will use them interchangeably at times.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一些常见的 Python 文件术语：模块、包、库和发行版。虽然它们有明确的定义（[https://packaging.python.org/glossary/](https://packaging.python.org/glossary/)），但本书有时会交替使用它们。
- en: 'The following is part of `dice_roller.py`, an example of embedded tests from
    one of the first Python programs this author wrote when first learning Python:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 `dice_roller.py` 中提取的部分，这是作者在最初学习 Python 时编写的第一个 Python 程序中嵌入测试的一个示例：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we are simply creating a random number generator that simulates
    rolling different polyhedral dice (commonly used in role-playing games). The `random`
    library is imported, then the function defining how the dice rolls are generated
    is created. For each die roll, the integer provided indicates how many sides the
    die has. With this method, any number of possible values can be simulated with
    a single integer input.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是创建了一个随机数生成器，该生成器模拟掷不同多面体骰子（常用于角色扮演游戏）。导入 `random` 库，然后创建定义骰子如何掷出的函数。对于每次掷骰子，提供的整数表示骰子有多少面。使用这种方法，可以通过单个整数输入模拟任何数量的可能值。
- en: The key part of this program is at the end. The part `if __name__ == "__main__"`
    tells Python that, if the namespace for the module is `main`, that is, it is the
    main program and not imported into another program, then the interpreter should
    run the code below this line. Otherwise, when imported, only the code above this
    line is available to the main program. (It's also worth noting that this line
    is necessary for cross-platform compatibility with Windows.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的关键部分在末尾。部分 `if __name__ == "__main__"` 告诉 Python，如果模块的命名空间是 `main`，即它是主程序而不是被导入到另一个程序中，那么解释器应该运行此行以下的代码。否则，当导入时，只有此行以上的代码对主程序可用。（也值得注意，这一行对于与
    Windows 的跨平台兼容性是必要的。）
- en: 'When this program is called from the command line, the `sys` library is imported.
    Then, the first argument provided to the program is read from the command line
    and passed into the `randomNumGen()` function as an argument. The result is printed
    to the screen. Following are some examples of results from this program:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当从命令行调用此程序时，会导入 `sys` 库。然后，从命令行读取提供给程序的第一个参数，并将其作为参数传递给 `randomNumGen()` 函数。结果会被打印到屏幕上。以下是此程序的一些结果示例：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Configuring a module in this manner is an easy way to allow a user to interface
    directly with the module on a stand-alone basis. It is also a great way to run
    tests on the script; the tests are only run when the file is called as a stand-alone,
    otherwise the tests are ignored. `dice_roller_tests.py` is the full dice-rolling
    simulator that this author wrote:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式配置模块是允许用户直接以独立方式与模块交互的简单方法。这也是运行脚本测试的好方法；只有当文件作为独立文件调用时才会运行测试，否则测试会被忽略。`dice_roller_tests.py`
    是作者编写的完整的掷骰子模拟器：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This program builds on the previous random-dice program by allowing multiple
    dice to be added together. In addition, the `test()` function only runs when the
    program is called by itself to provide a sanity check of the code. The `test`
    function would probably be better if it wasn''t in a function with the rest of
    the code, as it is still accessible when the module is imported, as shown below:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序基于之前的随机骰子程序，允许将多个骰子相加。此外，`test()` 函数仅在程序自己调用时运行，以提供代码的合理性检查。如果 `test` 函数不在包含其余代码的函数中，它可能会更好，因为它仍然在模块导入时可以访问，如下所示：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, if you have any code you don't want to be accessible when the module is
    imported, make sure to include it *below the line*, as it were.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你有任何不希望在模块导入时被访问的代码，请确保将其放在 *下面一行*，就像这样。
- en: Implementing virtual Python environments
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现虚拟 Python 环境
- en: As touched on previously, Python virtual environments create separate Python
    environments, much like virtual machines allow multiple but separate operating
    systems. Python virtual environments are particularly useful when installing multiple
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python 虚拟环境创建了独立的 Python 环境，就像虚拟机允许多个但独立的操作系统一样。Python 虚拟环境在安装多个模块时特别有用。
- en: instances of the same module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 相同模块的实例。
- en: For example, assume you are working on a project that requires version 1.2 of
    a particular library module for legacy support. Now assume you download a Python
    program that uses version 2.2 of the same library. If you install everything in
    the default global location on your hard drive, for example, `/usr/lib/python3.6/site-packages`,
    the new program will install the updated library into the same location, overwriting
    the legacy software. Since you were using an old library for legacy support, there's
    a good chance that the updated library will break your application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在处理一个需要特定库模块 1.2 版本以支持旧版的项目。现在假设你下载了一个使用相同库 2.2 版本的 Python 程序。如果你在硬盘的默认全局位置，例如
    `/usr/lib/python3.6/site-packages`，安装所有内容，新程序将把更新的库安装到同一位置，覆盖旧软件。由于你正在使用旧库以支持旧版，更新后的库很可能破坏你的应用程序。
- en: Also, on shared systems (especially if you don't have admin rights), there is
    a strong possibility that you simply can't install modules on the system, at least
    not in the default global `site-packages` directory. You may luck out and be able
    to install software for your account but, if you can't, you have to either request
    permission to install it or go without.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在共享系统（尤其是如果你没有管理员权限）上，你很可能无法在系统上安装模块，至少不能在默认的全局 `site-packages` 目录中安装。你可能运气好，能够为你的账户安装软件，但如果你不能，你必须请求安装权限或者不安装。
- en: This is where virtual Python environments come into play. Each environment has
    its own installation directories and there is no sharing of libraries between
    environments. This means that each version of a module within an environment stays
    the same, even if you update global libraries. It also means you can have multiple
    versions of modules installed on your computer at the same time without having
    conflicts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是虚拟 Python 环境发挥作用的地方。每个环境都有自己的安装目录，并且环境之间不共享库。这意味着环境内模块的每个版本都保持不变，即使你更新了全局库。这也意味着你可以在电脑上同时安装多个模块版本，而不会发生冲突。
- en: Virtual environments have their own shells as well, allowing access to an OS
    shell that is independent of any other environment or the underlying operating
    system. This recipe also shows how to spawn a new Python shell from `pipenv`.
    Doing this ensures all commands will have access to the installed packages within
    the virtual environment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境也有它们自己的外壳，允许访问一个独立于任何其他环境或底层操作系统的操作系统外壳。这个配方还展示了如何从 `pipenv` 中启动一个新的 Python
    外壳。这样做确保所有命令都将能够访问虚拟环境内安装的包。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The old way to manage virtual environments was with the `venv` tool. To install
    it, use the command `sudo apt install python3-venv`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以前管理虚拟环境的方式是使用 `venv` 工具。要安装它，使用命令 `sudo apt install python3-venv`。
- en: To manage virtual environments in a modern way, the `pipenv` module ([https://docs.pipenv.org/](https://docs.pipenv.org/))
    was developed; it automatically creates and manages virtual environments for projects,
    as well as adding and removing packages from `Pipfile` when you install/uninstall
    packages. It can be installed using `pip install pipenv`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以现代方式管理虚拟环境，开发了 `pipenv` 模块（[https://docs.pipenv.org/](https://docs.pipenv.org/)）；它自动为项目创建和管理虚拟环境，以及当您安装/卸载包时从
    `Pipfile` 中添加和删除包。它可以通过 `pip install pipenv` 安装。
- en: '`Pipfile` is an alternative to `requirements.txt`, which is used to specify
    exact versions of modules to include in a program. `Pipfile` actually comprises
    two separate files: `Pipfile` and (optionally) `Pipfile.lock`. `Pipfile` is simply
    a listing of the source location of imported modules, the module names themselves
    (defaulting to the most recent version), and any development packages that are
    required. `pipfile.py`, below, is an example of a `Pipfile` from the Pipenv site
    ([https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock](https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock)):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pipfile` 是 `requirements.txt` 的替代品，用于指定程序中要包含的模块的确切版本。实际上，`Pipfile` 由两个独立的文件组成：`Pipfile`
    和（可选的）`Pipfile.lock`。下面的 `pipfile.py` 是来自 Pipenv 网站的 `Pipfile` 示例（[https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock](https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock)）：'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Pipfile.lock` takes the `Pipfile` and sets actual version numbers to all the
    packages, as well as identifying specific hashes for those files. Hashed values
    are beneficial to minimize security risks; that is, if a particular module version
    has a vulnerability, its hash value allows it to be easily identified, rather
    than having to search by version name or some other method. `pipfile_lock.py`,
    below, is an example of a `Pipfile.lock` file from the Pipenv site ([https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock](https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock)):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pipfile.lock` 从 `Pipfile` 中获取并设置所有包的实际版本号，以及为这些文件识别特定的哈希值。哈希值有助于最小化安全风险；也就是说，如果某个模块版本存在漏洞，其哈希值允许它被轻松识别，而不是通过版本名称或其他方法搜索。下面的
    `pipfile_lock.py` 是来自 Pipenv 网站的 `Pipfile.lock` 文件示例（[https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock](https://docs.pipenv.org/basics/#example-pipfile-pipfile-lock)）：'
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The original, normal way to create a virtual environment comprises three separate
    steps. First, the virtual environment is created:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建虚拟环境的原始、常规方法包括三个独立的步骤。首先，创建虚拟环境：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, the virtual environment is activated so it can be used:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，激活虚拟环境以便使用：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, `pip` is used to install the necessary module:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `pip` 安装必要的模块：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To make this process easier, `pipenv` combines the `pip` and `venv` calls,
    so first we have to move to the desired directory where the virtual environment
    will be placed:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个过程更简单，`pipenv` 将 `pip` 和 `venv` 调用结合起来，因此我们首先需要移动到虚拟环境将要放置的目标目录：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we simply call `pipenv` to create the environment and install the desired
    module:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需调用 `pipenv` 来创建环境并安装所需的模块：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use `pipenv` to call the `shell` command and wait for the shell to be created.
    Observe that a virtual environment has been created and the command prompt is
    now activated within the environment. The following screenshot includes the commands
    from the previous steps, for clarity:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pipenv` 调用 `shell` 命令并等待创建 shell。观察到一个虚拟环境已经创建，并且命令提示符现在在环境中被激活。以下截图包含了之前步骤的命令，以便于理解：
- en: '![](img/b58c3a4e-9285-46d1-aa4d-57aa5414ef5b.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b58c3a4e-9285-46d1-aa4d-57aa5414ef5b.png)'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding `pipenv` example shows the developer changing to the desired directory
    for the project, and then invoking `pipenv` to simultaneously create the virtual
    environment, activate it, and install the desired module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `pipenv` 示例显示了开发者切换到项目所需的目标目录，然后调用 `pipenv` 以同时创建虚拟环境、激活它并安装所需的模块。
- en: 'In addition to creating the virtual environment, once you have created your
    Python program, you can run the program using `pipenv` as well:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建虚拟环境之外，一旦您创建了您的 Python 程序，您也可以使用 `pipenv` 运行程序：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Doing this ensures all installed packages in the virtual environment are available
    to your program, thus reducing the likelihood of unexpected errors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做确保虚拟环境中安装的所有包都可用于您的程序，从而降低意外错误的可能性。
- en: When launching a `pipenv shell`, a new virtual environment is created, with
    indications of where the environment is created in the file system. In this case,
    two environment executables are created, referencing both the Python 3.6 command
    and the default Python command. (Depending on the systems, these may actually
    reference different versions of Python. For example, the default Python command
    may call the Python 2.7 environment instead of Python 3.6.)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动 `pipenv shell` 时，会创建一个新的虚拟环境，并在文件系统中显示环境创建的位置。在这种情况下，创建了两个环境可执行文件，分别引用了
    Python 3.6 命令和默认的 Python 命令。（根据系统不同，这些可能实际上引用了不同的 Python 版本。例如，默认的 Python 命令可能调用
    Python 2.7 环境而不是 Python 3.6。）
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: On a side note, the `-m` option indicates that Python is to run the module as
    a stand-alone script, that is, its contents will be ran within the `__main__`
    namespace. Doing this means you don't have to know the full path to the module,
    as Python will look for the script in `sys.path`. In other words, for modules
    that you would normally import into another Python file can be run directly from
    the command line.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`-m` 选项表示 Python 将模块作为独立脚本运行，也就是说，其内容将在 `__main__` 命名空间内执行。这样做意味着你不需要知道模块的完整路径，因为
    Python 会查找 `sys.path` 中的脚本。换句话说，对于你通常导入到其他 Python 文件中的模块，可以直接从命令行运行。
- en: In the example of running `pipenv`, the command takes advantage of the fact
    that Python allows the `-m` option to run a module directly or allow it to be
    imported; in this case, `pipenv` imports `venv` to create the virtual environment
    as part of the creation process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `pipenv` 的示例中，命令利用了 Python 允许使用 `-m` 选项直接运行模块或允许它被导入的事实；在这种情况下，`pipenv`
    在创建过程中导入 `venv` 以创建虚拟环境。
- en: Python package installation options
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 包安装选项
- en: Installing packages normally happens by looking at [http://pypi.python.org/pypi](http://pypi.python.org/pypi)
    for the desired module, but `pip` supports installing from version control, local
    projects, and from distribution files as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过查看 [http://pypi.python.org/pypi](http://pypi.python.org/pypi) 中的所需模块来安装包，但
    `pip` 支持从版本控制、本地项目和分发文件安装。
- en: Python *wheels* are pre-built archives that can speed up the package installation
    process compared to installing from source files. They can be compared to installing
    pre-made binary applications for an operating system rather than building and
    installing source files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 *wheels* 是预构建的存档，与从源文件安装相比，可以加快包安装过程。它们可以与为操作系统安装预制的二进制应用程序相比，而不是构建和安装源文件。
- en: Wheels were developed to replace Python *eggs*, which performed wheels' functions
    before the new packaging standards were developed. Wheels improve on eggs by specifying
    the `.dist-info` directory (a database of installed Python packages that is very
    close to the on-disk format) and by implementing package metadata (which helps
    identify software dependencies).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Wheels 是为了取代 Python 的 *eggs* 而开发的，在新的打包标准开发之前，它们执行了 wheels 的功能。Wheels 通过指定 `.dist-info`
    目录（一个与磁盘格式非常接近的已安装 Python 包数据库）以及实现包元数据（这有助于识别软件依赖项）来改进 eggs。
- en: '`pip` installs from wheels whenever possible, though this feature can be disabled
    using `pip install --no-binary`. If wheel files aren''t available, `pip` will
    look for source files. Wheels can be downloaded from PyPI manually or pulled from
    a local repository; just tell `pip` where the local file is located.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip` 尽可能从 wheels 安装，尽管可以使用 `pip install --no-binary` 禁用此功能。如果 wheel 文件不可用，`pip`
    将查找源文件。可以从 PyPI 手动下载 wheels 或从本地仓库拉取；只需告诉 `pip` 本地文件的位置即可。'
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use `pip` to pull the latest version of the package directly from PyPI:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pip` 直接从 PyPI 拉取包的最新版本：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternately, a specific version of the package can be downloaded:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，可以下载特定版本的包：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is an example of downgrading `pygments` from our earlier install in `pipenv`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在 `pipenv` 中降级 `pygments` 的示例：
- en: '![](img/87e27597-4810-43b6-832b-eebcbe09d104.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87e27597-4810-43b6-832b-eebcbe09d104.png)'
- en: 'As a final option, a minimum version of a package can be downloaded; this is
    common when a package has a significant change between versions:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一个选项，可以下载包的最小版本；这在包在不同版本之间有重大变化时很常见：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If a PyPI package has a wheel file available, `pip` will automatically download
    the wheel; otherwise, it will pull the source code and compile it.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 PyPI 包有 wheel 文件可用，`pip` 将自动下载 wheel；否则，它将拉取源代码并编译它。
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To install a local wheel file, provide the full path to the file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装本地轮文件，提供文件的完整路径：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The wheel file name format breaks down to `<package_name>-<version>-<language_version>-<abi_tag>-<platform_tag>.whl`.
    The package name is the name of the module to be installed, followed by the version
    of this particular wheel file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 轮文件名格式分解为 `<package_name>-<version>-<language_version>-<abi_tag>-<platform_tag>.whl`。包名是要安装的模块的名称，后面跟着这个特定轮文件的版本。
- en: The language version refers to Python 2 or Python 3; it can be as specific as
    necessary, such as `py27` (any Python 2.7.x version) or `py3` (any Python 3.x.x
    version).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 语言版本指的是 Python 2 或 Python 3；它可以具体到必要的程度，例如 `py27`（任何 Python 2.7.x 版本）或 `py3`（任何
    Python 3.x.x 版本）。
- en: The **ABI** tag refers to the **Application Binary Interface**. In the past,
    the underlying C API (**Application Programming Interface**) that the Python interpreter
    relies on changed with every release, typically by adding API features rather
    than changing or removing existing APIs. The Windows OS is particularly affected,
    where each Python feature release creates a new name for the Python Window's DLL.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**ABI** 标签指的是 **应用程序二进制接口**。在过去，Python 解释器依赖的底层 C API（**应用程序编程接口**）在每次发布时都会改变，通常是通过添加
    API 功能而不是更改或删除现有 API。Windows 操作系统尤其受到影响，每个 Python 功能发布都会为 Python Window 的 DLL
    创建一个新的名称。'
- en: The ABI refers to Python's binary compatibility. While changes to Python structure
    definitions may not break API compatibility, ABI compatibility may be affected.
    Most ABI issues occur from changes in the in-memory structure layout.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ABI 指的是 Python 的二进制兼容性。虽然对 Python 结构定义的更改可能不会破坏 API 兼容性，但 ABI 兼容性可能会受到影响。大多数
    ABI 问题都源于内存结构布局的变化。
- en: Since version 3.2, a limited set of API features has been guaranteed to be stable
    for the ABI. Specifying an ABI tag allows the developer to specify which Python
    implementations a package is compatible with, for example, PyPy versus CPython.
    Generally speaking, this tag is set to `none`, implying there is no specific ABI
    requirement.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 自 3.2 版本以来，一组有限的 API 功能已被保证对 ABI 稳定。指定 ABI 标签允许开发者指定包兼容的 Python 实现，例如 PyPy 与
    CPython。一般来说，此标签设置为 `none`，表示没有特定的 ABI 要求。
- en: The platform tag specifies which OS and CPU the `wheel` package is designed
    to run. This is normally `any`, unless the wheel's developer had a particular
    reason to limit the package to a specific system type.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 平台标签指定了 `wheel` 包设计运行的操作系统和 CPU。这通常是 `any`，除非轮的开发者有特定的理由将包限制在特定的系统类型上。
- en: Utilizing requirement files and resolving conflicts
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用需求文件和解决冲突
- en: As mentioned previously, a requirements file, `requirements.txt`, can be created
    to provide a list of packages to install all at once, via `pip install -r requirements.txt`.
    The requirements file can specify specific or minimum versions, or simply specify
    the library name and the latest version will be installed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可以通过 `pip install -r requirements.txt` 创建一个需求文件 `requirements.txt`，一次性提供要安装的包列表。需求文件可以指定特定或最低版本，或者简单地指定库的名称和最新版本将被安装。
- en: It should be noted that files pulled from the requirements file aren't necessarily
    installed in a particular order. If you require certain packages to be installed
    prior to others, you will have to take measures to ensure that the installation
    is sequential, such as having multiple `pip install` calls.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，从需求文件中拉取的文件不一定按特定顺序安装。如果您需要某些包在安装其他包之前安装，您将不得不采取措施确保安装顺序，例如使用多个 `pip
    install` 调用。
- en: Requirements files can specify version numbers of packages explicitly. For example,
    two different modules (*m1* and *m2*) both depend on a third module (*m3*). The
    module *m1* requires *m3* to be at least version 1.5, but *m2* requires it to
    be no later than version 2.0; the current version of *m3* is 2.3\. In addition,
    the latest version of *m2* (version 1.7) is known to contain a bug.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 需求文件可以明确指定包的版本号。例如，两个不同的模块（*m1* 和 *m2*）都依赖于第三个模块（*m3*）。模块 *m1* 要求 *m3* 至少是版本
    1.5，但 *m2* 要求它不超过版本 2.0；*m3* 的当前版本是 2.3。此外，已知最新版本的 *m2*（版本 1.7）存在一个错误。
- en: Hash digests can be used in requirements files to verify downloaded packages
    to guard against a compromise of the PyPI database or the HTTPS certificate chain.
    This is actually a good thing, as in 2017 ten Python libraries ([https://www.bleepingcomputer.com/news/security/ten-malicious-libraries-found-on-pypi-python-package-index/](https://www.bleepingcomputer.com/news/security/ten-malicious-libraries-found-on-pypi-python-package-index/))
    uploaded to PyPI were found to be hosting malicious files.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希摘要可以在需求文件中使用，以验证下载的包，防止 PyPI 数据库或 HTTPS 证书链被破坏。这实际上是一件好事，因为在 2017 年，有十种 Python
    库 ([https://www.bleepingcomputer.com/news/security/ten-malicious-libraries-found-on-pypi-python-package-index/](https://www.bleepingcomputer.com/news/security/ten-malicious-libraries-found-on-pypi-python-package-index/))
    被发现托管在 PyPI 上，这些库包含恶意文件。
- en: Because PyPI does not perform any security checks or code auditing when packages
    are uploaded, it is actually very easy to upload malicious software.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PyPI 在上传包时不会执行任何安全检查或代码审计，因此上传恶意软件实际上非常容易。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Manually create `requirements.txt` by typing in the packages to include in
    the project. The following is an example from [https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format](https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format):'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过手动输入项目需要包含的包来创建 `requirements.txt`。以下是一个来自 [https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format](https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format)
    的示例：
- en: '![](img/db110b1a-6544-408d-aad7-f5c16a4952eb.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db110b1a-6544-408d-aad7-f5c16a4952eb.png)'
- en: Alternatively, run `pip freeze > requirements.txt`. This automatically directs
    the currently installed packages to a properly formatted requirements file.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，运行 `pip freeze > requirements.txt`。这会自动将当前安装的包导出到一个格式正确的需求文件中。
- en: 'To implement hash-checking mode, simply include the digest with the package
    name in the requirements file, demonstrated below:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现哈希校验模式，只需在需求文件中将摘要与包名称一起包含，如下所示：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note: Supported hash algorithms include: md5, sha1, sha224, sha384, sha256,
    and sha512.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：支持的哈希算法包括：md5、sha1、sha224、sha384、sha256 和 sha512。
- en: 'If there are module conflicts, or special versioning is needed, provide the
    first module required:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在模块冲突或需要特殊版本，提供所需的第一模块：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Indicate the second module, but ensure the version installed pre-dates the
    known bad version:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指明第二个模块，但确保安装的版本早于已知的坏版本：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Provide the third module, ensuring it is at least equal to the minimum version
    required, but no greater than the maximum version that can be used:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供第三个模块，确保它至少等于所需的最小版本，但不超过可以使用的最大版本：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'While the preceding screenshot shows some version specifier requirements, here
    is an example showing some of the different ways to specify module versions in
    `requirements.txt`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的截图显示了某些版本指定要求，但以下是一个示例，展示了在 `requirements.txt` 中指定模块版本的不同方法：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, module `m1` is specified as a requirement, but the version
    number doesn't matter; in this case, `pip` will install the latest version. However,
    because of the bug in the latest version of `m2`, an earlier version is specified
    to be installed. Finally, `m3` must be a version between 1.5 and 2.0 to satisfy
    the installation. Naturally, if one of these conditions can't be met, the installation
    will fail and the offending library and version numbers will be displayed for
    further troubleshooting.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，模块 `m1` 被指定为需求，但版本号并不重要；在这种情况下，`pip` 将安装最新版本。然而，由于 `m2` 最新版本的错误，指定了一个更早的版本来安装。最后，`m3`
    必须是介于 1.5 和 2.0 之间的版本以满足安装要求。当然，如果这些条件中有一个无法满足，安装将失败，并且会显示有问题的库和版本号以供进一步故障排除。
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's worth noting that `pip` doesn't have true dependency resolution; it will
    simply install the first file specified. Thus, it is possible to have dependency
    conflicts or a sub-dependency that doesn't match the actual requirement. This
    is why a requirements file is useful, as it alleviates some dependency problems.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`pip` 并没有真正的依赖关系解析；它只会安装第一个指定的文件。因此，可能会出现依赖冲突或不符合实际要求的子依赖。这就是为什么需求文件很有用，因为它可以缓解一些依赖问题。
- en: Verifying hashes also ensures that a package can't be changed without its version
    number changing as well, such as in an automated server deployment. This is an
    ideal situation for efficiency, as it eliminates the need for a private index
    server that maintains only approved packages.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 验证哈希值也确保了在版本号不改变的情况下，无法更改软件包，例如在自动化的服务器部署中。这对于效率来说是一个理想的情况，因为它消除了维护仅包含批准软件包的私有索引服务器的需求。
- en: Using local patches and constraint files
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地补丁和约束文件
- en: The benefit of open-source software is the ability to view and modify source
    code. If you are working on a project and create a local version of a PyPI module,
    such as customizing for a project or creating a patch, `requirements.txt` can
    be used to override the normal download of the file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件的好处是能够查看和修改源代码。如果你正在处理一个项目并创建 PyPI 模块的本地版本，例如为项目定制或创建补丁，可以使用 `requirements.txt`
    来覆盖文件的正常下载。
- en: Constraints files are a modification of requirements files that simply indicate
    what version of a library is installed, but they don't actually control the installation
    of files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 约束文件是对需求文件的修改，仅指示已安装库的版本，但它们实际上并不控制文件的安装。
- en: One example of using a constraints file is when using a local patched version
    of a PyPI module, for example, **ReqFile**. Some software packages downloaded
    from PyPI rely on ReqFile, but other packages don't. Rather than writing a requirements
    file for every single package from PyPI that depends on ReqFile, a constraints
    file can be created as a master record and implemented across all Python projects.
    Any package being installed that requires ReqFile will see the constraints file
    and install from the local repository, rather than from PyPI.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用约束文件的一个例子是当使用 PyPI 模块的本地修补版本时，例如，**ReqFile**。一些从 PyPI 下载的软件包依赖于 ReqFile，但其他软件包则不依赖。与其为
    PyPI 上每个依赖 ReqFile 的软件包编写一个需求文件，不如创建一个作为主记录的约束文件，并在所有 Python 项目中实施。任何需要安装 ReqFile
    的软件包都会看到约束文件，并从本地存储库安装，而不是从 PyPI 安装。
- en: In this manner, a single file can be used by every developer and it no longer
    matters what a PyPI package depends on; the correct version will either be pulled
    down from PyPI, or the local version will be used as needed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，单个文件可以被每个开发者使用，并且不再重要 PyPI 软件包依赖于什么；正确的版本要么从 PyPI 拉取，要么在需要时使用本地版本。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Tag the in-house version of the file. Assuming you are using Git, a tag is
    generated by using the following:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对文件的内屋版本进行标记。假设你正在使用 Git，可以使用以下方式生成标签：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Upload it to the version control system.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其上传到版本控制系统。
- en: 'Indicate the local version in the `requirements.txt` file, as shown in the
    following example:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `requirements.txt` 文件中指明本地版本，如下面的示例所示：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Write the `constraints.txt` file in the same manner as a `requirements.txt`
    file. The following example comes from [https://github.com/mldbai/mldb](https://github.com/mldbai/mldb)
    (this was released under the Apache v2.0 license by MLDB.ai):'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照 `requirements.txt` 文件的方式编写 `constraints.txt` 文件。以下示例来自 [https://github.com/mldbai/mldb](https://github.com/mldbai/mldb)（由
    MLDB.ai 以 Apache v2.0 许可证发布）：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, run the command, `pip install -c constraints.txt`, to make the file available
    to Python.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行命令 `pip install -c constraints.txt`，使文件对 Python 可用。
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the preceding example, `<vcs>` is the version control system being used;
    it could be a local server or an online service such as, GitHub. `<tag_name>`
    is the version control tag used to identify this particular update to the control
    system.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`<vcs>` 是正在使用的版本控制系统；它可能是一个本地服务器或如 GitHub 这样的在线服务。`<tag_name>` 是用于识别控制系统中特定更新的版本控制系统标签。
- en: If a required dependency was a top-level requirement for the project, then that
    particular line in the requirements file can simply be replaced. If it is a sub-dependency
    of another file, then the above command would be added as a new line.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所需的依赖项是项目的顶层需求，那么需求文件中的该特定行可以直接替换。如果是另一个文件的子依赖项，那么上述命令将作为新行添加。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Constraints files differ from requirements files in one key way: putting a
    package in the constraints file does not cause the package to be installed, whereas
    a requirements file will install all packages listed. Constraints files are simply
    requirements files that control which version of a package will be installed,
    but provide no control over the actual installation.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 约束文件与需求文件在一点上有所不同：将一个包放入约束文件中不会导致该包被安装，而需求文件则会安装列出的所有包。约束文件实际上是控制要安装的包的版本的需求文件，但不会对实际安装进行控制。
- en: Working with packages
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与包一起工作
- en: There are a variety of utilities available to work with Python packages. Every
    so often, a developer needs to uninstall Python packages from a system. Uninstalling
    packages is as easy as installing them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多实用工具可用于与 Python 包一起工作。开发者时不时地需要从系统中卸载 Python 包。卸载包与安装包一样简单。
- en: As it is easy to install packages and forget what has been installed in the
    past, `pip` provides the ability to list all currently installed packages, as
    well as indicating which ones are out of date. The examples in the next section
    are from the Python list ([https://pip.pypa.io/en/stable/reference/pip_list/](https://pip.pypa.io/en/stable/reference/pip_list/))
    and show documentation pages ([https://pip.pypa.io/en/stable/reference/pip_show/](https://pip.pypa.io/en/stable/reference/pip_show/)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安装包很容易，而且很容易忘记过去安装了什么，`pip` 提供了列出所有当前已安装包的能力，以及指示哪些包已过时。下一节中的示例来自 Python 列表
    ([https://pip.pypa.io/en/stable/reference/pip_list/](https://pip.pypa.io/en/stable/reference/pip_list/))，并展示了文档页面
    ([https://pip.pypa.io/en/stable/reference/pip_show/](https://pip.pypa.io/en/stable/reference/pip_show/))。
- en: Finally, when looking for packages to install, rather than opening a browser
    and navigating to PyPI directly, it is possible to find packages from the command
    line.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当寻找要安装的包时，而不是打开浏览器直接导航到 PyPI，可以从命令行找到包。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To uninstall packages, run the `pip uninstall <package_name>` command. This
    will uninstall most packages on the system.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要卸载包，请运行 `pip uninstall <package_name>` 命令。这将卸载系统上的大多数包。
- en: Requirements files can be used to remove a number of packages at once, by using
    the `-r` option, such as `pip uninstall -r <requirements_file>`. The `-y` option
    allows for automatic confirmation of file removal.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 `-r` 选项一次性删除多个包，例如 `pip uninstall -r <requirements_file>`。`-y` 选项允许自动确认文件删除。
- en: List currently installed packages by running `pip list`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `pip list` 列出当前已安装的包。
- en: '![](img/bc2f7bb7-c3d1-4b11-96de-b440ccfc91a3.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc2f7bb7-c3d1-4b11-96de-b440ccfc91a3.png)'
- en: 'To show packages that are outdated, use `pip list --outdated`, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示过时的包，请使用 `pip list --outdated`，如下所示：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'While it is possible to update all outdated packages at once, this is not available
    within `pip` itself. There are two primary options: the first involves using `sed`, `awk`,
    or `grep` to walk through the list of packages, find the outdated packages, and
    update them. Alternatively, install the package `pip-review` to see outdated packages
    and update them. In addition, a number of other tools have been created by different
    developers, as well as instructions on how to do it yourself, so you should decide
    which works best for you.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以一次性更新所有过时的包，但这在 `pip` 本身中不可用。有两种主要选项：第一个选项涉及使用 `sed`、`awk` 或 `grep` 遍历包列表，找到过时的包并更新它们。或者，安装包
    `pip-review` 来查看过时的包并更新它们。此外，还有许多其他由不同开发者创建的工具，以及如何自己做的说明，所以你应该决定哪个最适合你。
- en: 'Note: Automatically upgrading all Python packages can break dependencies. You
    should only update packages on an as-needed basis.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：自动升级所有 Python 包可能会破坏依赖关系。你应该仅在需要时更新包。
- en: 'Details of a particular installed package can be shown using `pip show <package_name>`,
    as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pip show <package_name>` 可以显示特定已安装包的详细信息，如下所示：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the command `pip search "query_string"`. The example below comes from [https://pip.pypa.io/en/stable/reference/pip_search/](https://pip.pypa.io/en/stable/reference/pip_search/),
    and shows how the output looks:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令 `pip search "查询字符串"`。以下示例来自 [https://pip.pypa.io/en/stable/reference/pip_search/](https://pip.pypa.io/en/stable/reference/pip_search/)，展示了输出结果：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When searching for packages, the query can be a package name or simply a word,
    as `pip` will find all packages with that string in the package name or in the
    package description. This is a useful way to locate a package if you know what
    you want to do but don't know the actual name of the package.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索包时，查询可以是包名或只是一个单词，例如`pip`会找到所有包名或包描述中包含该字符串的包。如果你知道你想做什么但不知道包的实际名称，这是一种查找包的有用方法。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Packages installed with `python setup.py install`, and program wrappers that
    were installed using `python setup.py develop`, cannot be uninstalled via `pip`,
    as they do not provide metadata about which files were installed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`python setup.py install`安装的包和通过`python setup.py develop`安装的程序包装器不能通过`pip`卸载，因为它们不提供有关已安装文件的元数据。
- en: A number of other options are available for listing files, such as listing only
    non-global packages, beta versions of packages, outputting the list in columns,
    and other tools that may prove useful.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他选项可用于列出文件，例如仅列出非全局包、包的beta版本、按列输出列表以及其他可能有用的工具。
- en: 'Additional information can be shown by using the `--verbose` option, as shown
    in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`--verbose`选项显示附加信息，如下面的截图所示：
- en: '![](img/3c79380c-48e9-427f-8f87-518368985821.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c79380c-48e9-427f-8f87-518368985821.png)'
- en: The verbose option shows the same information as the default mode, but also
    includes such information as the classifier information that would found on the
    package's PyPI page. While this information could obviously be found simply by
    going to the PyPI site, if you are on a stand-alone computer or otherwise unable
    to connect to the internet, this can be useful when figuring out whether a package
    is supported by our current environment or when looking for similar packages within
    a particular topic.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 详细选项显示与默认模式相同的信息，但还包括在包的PyPI页面上可以找到的分类器信息。显然，这些信息可以通过访问PyPI网站简单地找到，但如果你在独立的计算机上或无法连接到互联网的情况下，这可以在确定包是否受我们当前环境支持或寻找特定主题内的类似包时很有用。
- en: Creating wheels and bundles
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建轮子和捆绑包
- en: '`pip wheel` allows the developer to bundle all project dependencies, along
    with any compiled files, into a single archive file. This is useful for installing
    when index servers aren''t available, and eliminates recompiling code. However,
    recognize that compiled packages are normally OS- and architecture-specific, as
    they are normally C code, meaning they are generally not portable across different
    systems without recompiling. This is also a good use of hash-checking to ensure
    future wheels are built with identical packages.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip wheel`允许开发者将所有项目依赖项以及任何编译文件打包成一个单独的存档文件。这在索引服务器不可用的情况下安装时很有用，并消除了重新编译代码的需要。然而，编译包通常是操作系统和架构特定的，因为它们通常是C代码，这意味着它们通常在不同系统之间不可移植，除非重新编译。这也是使用哈希检查以确保未来轮子使用相同包构建的好方法。'
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create an archive (from the official documentation: [https://pip.pypa.io/en/latest/user_guide/#installation-bundles)](https://pip.pypa.io/en/latest/user_guide/#installation-bundles)),
    perform the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个存档（来自官方文档：[https://pip.pypa.io/en/latest/user_guide/#installation-bundles](https://pip.pypa.io/en/latest/user_guide/#installation-bundles)），请执行以下操作：
- en: 'Create a temporary directory:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时目录：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a wheel file:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个轮子文件：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let the OS know where to place the archive file:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让操作系统知道存档文件放置的位置：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Change to the temporary directory and create the archive file:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到临时目录并创建存档文件：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To install from an archive, do the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从存档安装，请执行以下操作：
- en: 'Create a temporary directory:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时目录：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Change to the temporary directory and unarchive the file:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到临时目录并解压文件：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use `pip` to install the unarchived files:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip`安装未存档的文件：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first example (creating an archive), a temporary directory is first made,
    then the wheel is created using a requirements file and placed in the temporary
    directory. Next, the `cwd` variable is created and set equal to the present working
    directory (`pwd`). Finally, a combined command is issued, changing to the temporary
    directory, and creating an archive file in `cwd` of all the files in the temporary
    directory.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例（创建存档）中，首先创建一个临时目录，然后使用需求文件创建轮子并将其放置在临时目录中。接下来，创建`cwd`变量并将其设置为当前工作目录（`pwd`）。最后，发出一个组合命令，切换到临时目录，并在`cwd`中创建一个包含临时目录中所有文件的存档文件。
- en: In the second example (installing from an archive), a temporary directory is
    created. Then, a combined command is given to change to that temporary directory
    and extract the files that make up the archive file. Then, using `pip`, the bundled
    files are used to install the Python program onto the computer in the temporary
    directory.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例（从存档安装）中，会创建一个临时目录。然后，给出一个组合命令以切换到该临时目录并提取构成存档文件的文件。接着，使用`pip`，将这些打包文件安装到临时目录中的计算机上。
- en: There's more...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`--force-reinstall` will reinstall all packages when upgrading, even if they
    are already current. `--ignore-installed` forces a reinstall, ignoring whether
    the packages are already present. `--upgrade` upgrades all specified packages
    to the newest version available. `--no-index` ignores the package index and only
    looks at at URLs to parse for archives. `--no-deps` ensures that no package dependencies
    are installed.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`--force-reinstall`在升级时将重新安装所有包，即使它们已经是最新版本。`--ignore-installed`强制重新安装，忽略包是否已经存在。`--upgrade`将所有指定的包升级到最新版本。`--no-index`忽略包索引，只解析存档的URL。`--no-deps`确保不安装任何包依赖项。'
- en: Comparing source code to bytecode
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较源代码和字节码
- en: Interpreted languages, such as Python, typically take raw source code and generate
    bytecode. Bytecode is encoded instructions that are on a lower level than source
    code but not quite as optimized as machine code, that is, assembly language.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '解释性语言，如Python，通常将原始源代码转换为字节码。字节码是低于源代码但又不完全像机器代码（即汇编语言）优化的编码指令。 '
- en: Bytecode is often executed within the interpreter (which is a type of virtual
    machine), though it can also be compiled further into assembly language. Bytecode
    is used primarily to allow easy, cross-platform compatibility. Python, Java, Ruby,
    Perl, and similar languages, are examples of languages that use bytecode interpreters
    for different architectures while the source code stays the same.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码通常在解释器（这是一种虚拟机类型）中执行，尽管它也可以进一步编译成汇编语言。字节码主要用于实现跨平台的兼容性。Python、Java、Ruby、Perl和类似的语言是使用字节码解释器进行不同架构的例子，而源代码保持不变。
- en: While Python automatically compiles source code into bytecode, there are some
    options and features that can be used to modify how the interpreter works with
    bytecode. These options can improve the performance of Python programs, a key
    feature as interpreted languages are, by nature, slower than compiled languages
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python会自动将源代码编译成字节码，但有一些选项和功能可以用来修改解释器与字节码交互的方式。这些选项可以通过提高解释性语言的性能来改善Python程序，因为解释性语言本质上比编译性语言慢。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To create bytecode, simply execute a Python program via `python <program>.py`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建字节码，只需通过`python <program>.py`执行Python程序。
- en: When running a Python command from the command line, there are a couple of switches
    that can reduce the size of the compiled bytecode. Be aware that some programs
    may expect the statements that are removed from the following examples to function
    correctly, so only use them if you know what to expect.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从命令行运行Python命令时，有几个开关可以减小编译后的字节码的大小。请注意，某些程序可能期望从以下示例中删除的语句能够正确执行，因此只有在你了解预期结果的情况下才使用它们。
- en: -O removes `assert` statements from the compiled code. These statements provide
    some debugging help when testing the program, but generally aren't required for
    production code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`-O`从编译后的代码中移除`assert`语句。这些语句在测试程序时提供一些调试帮助，但在生产代码中通常不是必需的。'
- en: -OO removes both `assert` and `__doc__` strings for even more size reduction.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`-OO`移除`assert`和`__doc__`字符串，以进一步减小大小。'
- en: Loading programs from bytecode into memory is faster than with source code,
    but actual program execution is no faster (due to the nature of the Python interpreter).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字节码将程序加载到内存中比使用源代码更快，但实际程序执行的速度并没有加快（由于Python解释器的特性）。
- en: The `compileall` module can generate bytecode for all modules within a directory.
    More information on the command can be found at [https://docs.python.org/3.6/library/compileall.html](https://docs.python.org/3.6/library/compileall.html).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`compileall`模块可以为目录中的所有模块生成字节码。有关该命令的更多信息，请参阅[https://docs.python.org/3.6/library/compileall.html](https://docs.python.org/3.6/library/compileall.html)。'
- en: How it works...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When source code (`.py`) is read by the Python interpreter, the bytecode is
    generated and stored in `__pycache__` as `<module_name>.<version>.pyc`. The `.pyc`
    extension indicates that it is compiled Python code. This naming convention is
    what allows different versions of Python code to exist simultaneously on the system.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当源代码（`.py`）被 Python 解释器读取时，会生成字节码并存储在 `__pycache__` 中，格式为 `<module_name>.<version>.pyc`。`.pyc`
    扩展名表示它是编译后的 Python 代码。这种命名约定允许系统上同时存在不同版本的 Python 代码。
- en: When source code is modified, Python will automatically check the date with
    the compiled version in cache and, if it's out of date, will automatically recompile
    the bytecode. However, a module that is loaded directly from the command line
    will not be stored in `__pycache__` and is recompiled every time. In addition,
    if there is no source module, the cache can't be checked, that is, a bytecode-only
    package won't have a cache associated with it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当源代码被修改时，Python 会自动检查与缓存中编译版本的日期，如果日期过时，则会自动重新编译字节码。然而，直接从命令行加载的模块不会被存储在 `__pycache__`
    中，并且每次都会重新编译。此外，如果没有源模块，缓存无法进行检查，也就是说，仅包含字节码的包不会与其关联缓存。
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Because bytecode is platform-independent (due to being run through the platform's
    interpreter), Python code can be released either as `.py` source files or as `.pyc`
    bytecode. This is where bytecode-only packages come into play; to provide a bit
    of obfuscation and (subjective) security, Python programs can be released without
    the source code and only the pre-compiled `.pyc` files are provided. In this case,
    the compiled code is placed in the source directory rather than the source-code
    files.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字节码是平台无关的（因为它是通过平台的解释器运行的），Python 代码可以以 `.py` 源文件或 `.pyc` 字节码的形式发布。这就是字节码包发挥作用的地方；为了提供一点混淆和（主观的）安全性，Python
    程序可以没有源代码，只提供预编译的 `.pyc` 文件。在这种情况下，编译后的代码放在源目录中，而不是源代码文件中。
- en: How to create and reference module packages
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建和引用模块包
- en: 'We have talked about modules and packages, using the terms interchangeably.
    However, there is a difference between a module and a package: packages are actually
    collections of modules and they include a `__init__.py` file, which can just be
    an empty file.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了模块和包，使用了可互换的术语。然而，模块和包之间是有区别的：包实际上是模块的集合，并且包含一个 `__init__.py` 文件，这可以是一个空文件。
- en: The dot-nomenclature used in modules to access specific functions or variables
    is also used in packages. This time, dotted names allow multiple modules within
    a package to be accessed without having name conflicts; each package creates its
    own namespace, and all the modules have their own namespaces.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中用于访问特定函数或变量的点命名法也用于包。这次，点名称允许在包内访问多个模块而不会发生名称冲突；每个包创建自己的命名空间，所有模块都有自己的命名空间。
- en: 'When packages contain sub-packages (as in the following example), importing
    modules can be done with either absolute or relative paths. For example, to import
    the `sepia.py` module, one could import it with an absolute path: `from video.effects.specialFX
    import sepia`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当包包含子包（如下面的示例所示）时，导入模块可以使用绝对路径或相对路径。例如，要导入 `sepia.py` 模块，可以使用绝对路径导入：`from video.effects.specialFX
    import sepia`。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: When making a package, follow the normal filesystem hierarchy in terms of directory
    structure; that is, modules that relate to each other should be placed in their
    own directory.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建包时，按照目录结构中的正常文件系统层次结构进行；也就是说，相互关联的模块应该放在它们自己的目录中。
- en: 'A possible package for a video file handler is shown in `package_tree.py`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个视频文件处理器的可能包在 `package_tree.py` 中展示：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But, what happens if you were already in the `specialFX/` directory and wanted
    to import from another package? Use relative paths to walk the directory and import
    using dots, just like changing directories on the command-line:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，如果你已经在 `specialFX/` 目录中，并想从另一个包中导入，会发生什么？使用相对路径遍历目录，并使用点来导入，就像在命令行中更改目录一样：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, the whole `video` package comprises two sub-packages, video
    formats and video effects, with video effects having several sub-packages of its
    own. Within each package, each `.py` file is a separate module. During module
    importation, Python looks for packages on `sys.path`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，整个 `video` 包包含两个子包，视频格式和视频效果，其中视频效果有自己的几个子包。在包内部，每个 `.py` 文件都是一个独立的模块。在模块导入期间，Python
    在 `sys.path` 上查找包。
- en: The inclusion of the `__init__.py` files is necessary so Python will treat the
    directories as packages. This prevents directories with common names from shadowing
    Python modules further along the search path. They also allow calling modules
    as stand-alone programs via the `-m` option, when calling Python programs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `__init__.py` 文件是必要的，这样 Python 会将目录视为包。这可以防止具有常见名称的目录在搜索路径中覆盖 Python 模块。它们还允许通过
    `-m` 选项将模块作为独立程序调用，当调用 Python 程序时。
- en: Initialization files are normally empty but can contain initialization code
    for the package. They can also contain an `__all__` list, which is a Python list
    of modules that should be imported whenever `from <package> import *` is used.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化文件通常是空的，但可以包含包的初始化代码。它们还可以包含一个 `__all__` 列表，这是一个 Python 列表，其中包含在 `from <package>
    import *` 被使用时应该导入的模块。
- en: The reason for `__all__` is for the developer to explicitly indicate which files
    should be imported. This is to prevent excessive delay from importing all modules
    within a package that aren't necessarily needed for other developers. It also
    limits the chance of undesired side-effects when a module is inadvertently imported.
    The catch is, the developer needs to update the `__all__` list every time the
    package is updated.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`__all__` 的原因是为了让开发者明确指出哪些文件应该被导入。这是为了防止导入包中所有模块（这些模块可能对其他开发者不是必需的）导致的过度延迟。它还限制了意外导入模块时出现不期望副作用的机会。需要注意的是，每当包更新时，开发者都需要更新
    `__all__` 列表。'
- en: Relative imports are based on the name of the current module. As the main module
    for a program always has the name `"__main__"`, any modules that will be the main
    module of an application must use absolute imports.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 相对导入基于当前模块的名称。由于程序的主模块总是具有 `"__main__"` 的名称，因此任何将成为应用程序主模块的模块都必须使用绝对导入。
- en: To be honest, it is generally safer to use absolute imports just to make sure
    you know exactly what you're importing; with most development environments nowadays
    providing suggestions for paths, it is just as easy to write out the auto-populated
    path as it is to use relative paths.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，为了确保你确切知道你要导入的内容，通常使用绝对导入更安全；如今大多数开发环境都提供路径建议，写出自动填充的路径与使用相对路径一样容易。
- en: There's more...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If `__all__` is not defined in `__init__.py`, then `import *` only imports the
    modules within the specified package, not all sub-packages or their modules. For
    example, `from video.formats import *` only imports the video formats; the modules
    in the `effects/` directory will not be included.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `__init__.py` 中没有定义 `__all__`，那么 `import *` 只会导入指定包内的模块，而不是所有子包或它们的模块。例如，`from
    video.formats import *` 只会导入视频格式；`effects/` 目录中的模块将不会被包括。
- en: 'This is a best practice for Python programmers: as the Zen of Python ([https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/))
    states, explicit is better than implicit. Thus, importing a specific sub-module
    from a package is a good thing, whereas `import *` is frowned upon because of
    the possibility of variable name conflicts.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Python 程序员的一个最佳实践：正如 Python 的禅宗（[https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/））所述，明确优于隐含。因此，从包中导入特定的子模块是好事，而
    `import *` 则因为可能存在变量名冲突而被不推荐。
- en: Packages have the `__path__` attribute, which is rarely used. This attribute
    is a list that has the name of the directory where the package's `__init__.py`
    file is located. This location is accessed before the rest of the code for the
    file is run.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 包具有 `__path__` 属性，这个属性很少使用。该属性是一个列表，包含包的 `__init__.py` 文件所在的目录名称。在运行文件的其他代码之前，会访问此位置。
- en: Modifying the package path affects future searches for modules and sub-packages
    within the package. This is useful when it is necessary to extend the number of
    modules found during a package search.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 修改包路径会影响包内模块和子包的将来搜索。这在需要扩展包搜索期间找到的模块数量时很有用。
- en: Operating system-specific binaries
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统特定的二进制文件
- en: Python programs are normally provided in source code or wheel files. However,
    there are times when a developer wants to provide OS-specific files, such as a
    Windows `.exe`, for ease of installation. Python has a number of options for developers
    to create stand-alone executable files.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序通常以源代码或 wheel 文件的形式提供。然而，有时开发者想要提供针对特定操作系统的文件，例如 Windows 的 `.exe` 文件，以简化安装过程。Python
    为开发者提供了多种选项来创建独立可执行文件。
- en: '**py2exe** ([https://pypi.python.org/pypi/py2exe/](https://pypi.python.org/pypi/py2exe/))
    is one option for creating Windows-specific files. Unfortunately, it is difficult
    to tell how maintained this project is, as the last release on [https://pypi.python.org/pypi/py2exe/0.9.2.2](https://pypi.python.org/pypi/py2exe/0.9.2.2)
    was in 2014, while [http://www.py2exe.org](http://www.py2exe.org/) references
    a release from 2008\. It also appears to be only available for Python 3.4 and
    older versions. However, if you believe this program may be useful, it does convert
    Python scripts into Windows executables without requiring the installation of
    Python.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**py2exe** ([https://pypi.python.org/pypi/py2exe/](https://pypi.python.org/pypi/py2exe/))
    是创建特定于 Windows 文件的选项之一。不幸的是，很难判断这个项目的维护情况，因为最后一个版本是在 2014 年发布的 [https://pypi.python.org/pypi/py2exe/0.9.2.2](https://pypi.python.org/pypi/py2exe/0.9.2.2)，而
    [http://www.py2exe.org](http://www.py2exe.org/) 引用了 2008 年的版本。它似乎也只适用于 Python
    3.4 及更早版本。然而，如果你认为这个程序可能有用，它可以将 Python 脚本转换为 Windows 可执行文件，而无需安装 Python。'
- en: '**py2app** ([https://py2app.readthedocs.io/en/latest/](https://py2app.readthedocs.io/en/latest/))
    is the primary tool for creating stand-alone Mac bundles. This tool is still maintained
    at [https://bitbucket.org/ronaldoussoren/py2app](https://bitbucket.org/ronaldoussoren/py2app),
    and the latest release came out in January 2018\. Building is much like with `py2exe`,
    but there are several library dependencies required, listed at [https://py2app.readthedocs.io/en/latest/dependencies.html](https://py2app.readthedocs.io/en/latest/dependencies.html).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**py2app** ([https://py2app.readthedocs.io/en/latest/](https://py2app.readthedocs.io/en/latest/))
    是创建独立 Mac 打包的主要工具。这个工具仍然在 [https://bitbucket.org/ronaldoussoren/py2app](https://bitbucket.org/ronaldoussoren/py2app)
    上维护，最新的版本发布于 2018 年 1 月。构建过程与 `py2exe` 类似，但需要几个库依赖项，可以在 [https://py2app.readthedocs.io/en/latest/dependencies.html](https://py2app.readthedocs.io/en/latest/dependencies.html)
    中找到。'
- en: There are more cross-platform tools for making OS-specific executable programs
    than there are for specific operating systems. This is good, as many developers
    use Linux as their development environment and may not have access to a Windows
    or Mac machine.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 制作特定操作系统可执行程序的跨平台工具比针对特定操作系统的工具要多。这是好事，因为许多开发者使用 Linux 作为他们的开发环境，可能无法访问 Windows
    或 Mac 机器。
- en: For developers who don't want to set up multiple operating systems themselves,
    there are several online services that allow you to rent operating systems online.
    For example, [http://virtualmacosx.com](http://virtualmacosx.com) allows you access
    to a hosted Mac environment, while there are multiple options for Windows hosting,
    from Amazon Web Services to regular web hosts.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不想自己设置多个操作系统的开发者，有几个在线服务允许你在线租用操作系统。例如，[http://virtualmacosx.com](http://virtualmacosx.com)
    允许你访问托管 Mac 环境，而 Windows 托管有多个选项，从亚马逊云服务到常规网络主机。
- en: For those desiring local control of binary execution, cx_Freeze ([https://anthony-tuininga.github.io/cx_Freeze/](https://anthony-tuininga.github.io/cx_Freeze/))
    is one of the more popular executable creation programs for Python. It only works
    with Python 2.7 or newer, but that shouldn't be a problem for most developers.
    However, if you want to use it with Python 2 code, you will have to use **cx_Freeze**
    version 5; starting with version 6, support for Python 2 code has been dropped.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于希望对二进制执行进行本地控制的开发者，cx_Freeze ([https://anthony-tuininga.github.io/cx_Freeze/](https://anthony-tuininga.github.io/cx_Freeze/))
    是 Python 中更受欢迎的可执行文件创建程序之一。它只适用于 Python 2.7 或更新的版本，但这对于大多数开发者来说不应该是个问题。然而，如果你想用它与
    Python 2 代码一起使用，你必须使用 **cx_Freeze** 版本 5；从版本 6 开始，已经放弃了 Python 2 代码的支持。
- en: The modules created by cx_Freeze are stored in ZIP files. Packages, by default,
    are stored in the file system but can be included in the same ZIP files, if desired.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Freeze 创建的模块存储在 ZIP 文件中。默认情况下，包存储在文件系统中，但如果需要，也可以包含在相同的 ZIP 文件中。
- en: '**PyInstaller** ([http://www.pyinstaller.org](http://www.pyinstaller.org))
    has, as its main goal, compatibility with third-party packages, requiring no user
    intervention to make external packages work during binary creation. It is available
    for Python 2.7 and newer versions.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyInstaller** ([http://www.pyinstaller.org](http://www.pyinstaller.org))
    的主要目标是与第三方包兼容，在创建二进制文件时无需用户干预即可使外部包工作。它适用于 Python 2.7 及更新的版本。'
- en: 'PyInstaller provides multiple ways to package your Python code: as a single
    directory (containing the executable as well as all necessary modules), as a single
    file (self-contained and requiring no external dependencies), or in custom mode.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: PyInstaller提供了多种打包Python代码的方式：作为一个单独的目录（包含可执行文件以及所有必要的模块），作为一个单独的文件（自包含且不需要外部依赖），或者以自定义模式。
- en: The majority of third-party packages will work with PyInstaller with no additional
    configuration required. Conveniently, a list, located at [https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages,](https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages)
    is provided for packages known to work with PyInstaller; if there are any limitations,
    for example, only working on Windows, these are noted as well.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数第三方包无需额外配置即可与PyInstaller一起使用。方便的是，提供了一个列表，位于[https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages](https://github.com/pyinstaller/pyinstaller/wiki/Supported-Packages)，列出了已知与PyInstaller兼容的包；如果有任何限制，例如仅在Windows上工作，这些也会被注明。
- en: '**Cython** ([http://cython.org](http://cython.org)) is actually a superset
    of Python, designed to give C-like performance to Python code. This is done by
    allowing types to be added to the Python code; whereas Python is normally dynamically
    typed, Cython allows static typing of variables. The resulting code is compiled
    into C code, which can be executed by the normal Python interpreter as normal,
    but at the speed of compiled C code.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cython** ([http://cython.org](http://cython.org)) 实际上是Python的超集，旨在为Python代码提供类似C的性能。这是通过允许向Python代码中添加类型来实现的；而Python通常是动态类型，Cython允许变量的静态类型。生成的代码被编译成C代码，可以像正常一样由Python解释器执行，但速度可以达到编译C代码的速度。'
- en: While normally used to create extensions for Python, or to speed up Python processing,
    using the `--embed` flag with the `cpython` command will create a C file, which
    can then be compiled to a normal application file.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常用于创建Python的扩展或加速Python处理，但使用`cpython`命令的`--embed`标志将创建一个C文件，然后可以将其编译成普通的应用程序文件。
- en: Naturally, this takes more knowledge of using `gcc` or your compiler of choice,
    as you have to know how to import the Python headers during compilation, and which
    other directories need to be included. As such, Cython isn't recommended for developers
    unfamiliar with C code, but it can be a powerful way to make full-featured applications
    by utilizing both Python and C languages.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这需要更多关于使用`gcc`或你选择的编译器的知识，因为你必须知道如何在编译时导入Python头文件，以及哪些其他目录需要包含。因此，Cython不推荐不熟悉C代码的开发者使用，但它可以通过利用Python和C语言两种语言来制作功能齐全的应用程序。
- en: '**Nuitka** ([http://nuitka.net](http://nuitka.net)) is a relatively new Python
    compiler program. It is compatible with Python 2.6 and later, but also requires
    `gcc` or another C compiler. The latest version, 0.5.29, is beta-ware, but the
    author claims it is able to compile every Python construct currently available
    without a problem.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**Nuitka** ([http://nuitka.net](http://nuitka.net)) 是一个相对较新的Python编译器程序。它与Python
    2.6及以后的版本兼容，但也需要`gcc`或其他C编译器。最新版本0.5.29是测试版，但作者声称它能够无问题地编译目前所有可用的Python构造。'
- en: Nuitka functions much like Cython, in that it uses a C compiler to convert Python
    code into C code, and make executable files. Entire programs can be compiled,
    with the modules embedded in the file, but individual modules can be compiled
    by themselves, if desired.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Nuitka的功能与Cython相似，因为它使用C编译器将Python代码转换为C代码，并生成可执行文件。整个程序可以编译，模块嵌入到文件中，但如果需要，也可以单独编译模块。
- en: By default, the resulting binary requires Python to be installed, plus the necessary
    C extension modules. However, it is possible to create true stand-alone executables
    by using the `--stand-alone` flag.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成的二进制文件需要安装Python以及必要的C扩展模块。然而，通过使用`--stand-alone`标志，可以创建真正的独立可执行文件。
- en: How to do it...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Write your Python program.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写你的Python程序。
- en: 'To create a Windows `.exe` file, create a `setup.py` file to tell the libraries
    what you want to do. This is mainly importing the `setup()` function from the
    `Distutils` library, importing `py2exe`, and then calling `setup` and telling
    it what type of application it is making, for example, a console, and what the
    main Python file is. `py2exe_setup.py`, following, is an example from the documentation
    of a `setup.py` file:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建Windows的`.exe`文件，创建一个`setup.py`文件来告诉库你想要做什么。这主要是从`Distutils`库中导入`setup()`函数，导入`py2exe`，然后调用`setup`并告诉它它正在制作的应用程序类型，例如控制台，以及主Python文件是什么。以下是从`setup.py`文件文档中的一个示例：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the setup script by calling `python setup.py py2exe`. This creates two
    directories: `build/` and `dist/`. The `dist/` directory is where the new files
    are placed, while `build/` is used for temporary files during the creation process.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `python setup.py py2exe` 运行设置脚本。这将创建两个目录：`build/` 和 `dist/`。`dist/` 目录用于放置新文件，而
    `build/` 用于创建过程中的临时文件。
- en: Test the application by moving to the `dist/` directory and running the `.exe`
    file located there.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过移动到 `dist/` 目录并运行该目录中的 `.exe` 文件来测试应用程序。
- en: To make a macOS `.app` file, create the `setup.py` file. Any icons or data files
    required for the application need to be included during this step.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建 macOS `.app` 文件，创建 `setup.py` 文件。在此步骤中，需要包含应用程序所需的任何图标或数据文件。
- en: Clean up the `build/` and `dist/` directories to ensure there are no files that
    may be accidentally included.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理 `build/` 和 `dist/` 目录，以确保没有可能意外包含的文件。
- en: Use Alias mode to build the application in-place, that is, not ready for distribution.
    This allows you to test the program before bundling for delivery.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用别名模式就地构建应用程序，即不是为分发准备就绪。这允许你在捆绑交付之前测试程序。
- en: Test the application and verify it works correctly in alias mode.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试应用程序并验证其在别名模式下是否正确工作。
- en: Clean up the `build/` and `dist/` directories again.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次清理 `build/` 和 `dist/` 目录。
- en: Run `python setup.py py2app` to create the distributable `.app` file.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `python setup.py py2app` 以创建可分发 `.app` 文件。
- en: 'For cross-platform files, the easiest way to use cx_Freeze is to use the `cxfreeze`
    script:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于跨平台文件，使用 cx_Freeze 最简单的方法是使用 `cxfreeze` 脚本：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Other options are available for this command, such as compressing the bytecode,
    setting an initialization script, or even excluding modules.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令还有其他选项可用，例如压缩字节码、设置初始化脚本或甚至排除模块。
- en: 'If more functionality is required, a `distutils` setup script can be created.
    The command `cxfreeze-quickstart` can be used to generate a simple setup script;
    the cx_Freeze documentation provides an example `setup.py` file (`cxfreeze_setup.py`):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多功能，可以创建 `distutils` 设置脚本。可以使用 `cxfreeze-quickstart` 命令生成简单的设置脚本；cx_Freeze
    文档提供了一个示例 `setup.py` 文件 (`cxfreeze_setup.py`)：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To run the setup script, run the command: `python setup.py build`. This will
    create the directory `build/`, which contains the subdirectory `exe.xxx`, where
    `xxx` is the platform-specific executable binary indicator:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行设置脚本，请运行命令：`python setup.py build`。这将创建 `build/` 目录，其中包含子目录 `exe.xxx`，其中
    `xxx` 是特定平台的可执行二进制文件指示符：
- en: For developers who need even more control, or are looking at creating C scripts
    for extending or embedding Python, manually working with the classes and modules
    within the cx_Freeze program is possible.
  id: totrans-308
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于需要更多控制或正在考虑创建用于扩展或嵌入 Python 的 C 脚本的开发者，可以在 cx_Freeze 程序中手动处理类和模块。
- en: 'If using PyInstaller, its use is like most other Python programs,  and is a
    simple command:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用 PyInstaller，其使用方式类似于大多数其他 Python 程序，并且是一个简单的命令：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This generates the binary bundle in the `dist/` subdirectory. Naturally, there
    many other options available when running this command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `dist/` 子目录中生成二进制包。当然，在运行此命令时还有许多其他选项可用：
- en: Optionally, UPX ([https://upx.github.io/](https://upx.github.io/)) can be used
    to compress the executable files and libraries. When used, UPX compresses the
    files and wraps them in a self-decompressing file. When executed, the UPX wrapper
    decompresses the enclosed files and the resulting binary is executed normally.
  id: totrans-312
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，可以使用 UPX ([https://upx.github.io/](https://upx.github.io/)) 来压缩可执行文件和库。当使用时，UPX
    会压缩文件并将它们包装在一个自解压文件中。当执行时，UPX 包装器会解压包含的文件，并且生成的二进制文件会正常执行。
- en: To create multiple Python environments for a single operating system, it is
    recommended you to create virtual Python environments for each Python version
    to be generated. Then, install PyInstaller in each environment and build the binary
    within each environment.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为单个操作系统创建多个 Python 环境，建议为要生成的每个 Python 版本创建虚拟 Python 环境。然后，在每个环境中安装 PyInstaller
    并在每个环境中构建二进制文件。
- en: Like cx_Freeze, to create binaries for different operating systems, the other
    OSes must be available and PyInstaller used on each one.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于 cx_Freeze，为了为不同的操作系统创建二进制文件，必须确保其他操作系统可用，并且在每个操作系统上使用 PyInstaller。
- en: Create your Python file; save it with the extension `.pyx`. For example, `helloworld.pyx`.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的 Python 文件；将其保存为 `.pyx` 扩展名。例如，`helloworld.pyx`。
- en: 'When working with Cython, create a `setup.py` file that looks similar to `cython_setup.py` from
    [http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html#the-basics-of-cython](http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html#the-basics-of-cython):'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用Cython工作时，创建一个类似于`cython_setup.py`的`setup.py`文件，可以从[http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html#the-basics-of-cython](http://docs.cython.org/en/latest/src/tutorial/cython_tutorial.html#the-basics-of-cython)获取：
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create the Cython file by running the following:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建Cython文件：
- en: '[PRE54]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This creates a file in the local directory: `helloworld.so` on *nix and `helloworld.pyd`
    on Windows.'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在本地目录中创建一个文件：*nix上的`helloworld.so`和Windows上的`helloworld.pyd`。
- en: To use the binary, simply import it into Python as normal.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用二进制文件，只需将其导入Python中，就像平常一样。
- en: If your Python program doesn't require additional C libraries or a special build
    configuration, you can use the `pyximport` library. The `install()` function from
    this library allows loading `.pyx` files directly when imported, rather than having
    to rerun `setup.py` every time the code changes.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的Python程序不需要额外的C库或特殊的构建配置，你可以使用`pyximport`库。该库的`install()`函数允许在导入时直接加载`.pyx`文件，而不是每次代码更改时都必须重新运行`setup.py`。
- en: 'To compile a program using Nuitka with all modules embedded, use the following
    command:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Nuitka编译包含所有模块的程序，使用以下命令：
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To compile a single module, use the following command:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译单个模块，使用以下命令：
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To compile an entire package and embed all modules, the previous commands are
    combined into a similar format:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译整个包并嵌入所有模块，之前的命令被组合成类似格式：
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To make a truly cross-platform binary, use the option `--standalone`, copy the
    `<program>.dist` directory to the destination system, and then run the `.exe`
    file inside that directory.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个真正跨平台的二进制文件，使用选项`--standalone`，将`<program>.dist`目录复制到目标系统，然后在该目录中运行`.exe`文件。
- en: There's more...
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Depending on a user's system configuration, you may need to provide the Microsoft
    Visual C runtime DLL. The `py2exe` documentation provides different files to choose
    from, depending on the version of Python you are working with.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的系统配置，你可能需要提供Microsoft Visual C运行时DLL。`py2exe`文档提供了根据你使用的Python版本选择的不同文件。
- en: In addition, `py2exe` does not create the installation builder, that is, installation
    wizard. While it may not be necessary for your application, Windows users generally
    expect a wizard to be available when running an `.exe` file. A number of free,
    open-source, and proprietary installation builders are available.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`py2exe`不会创建安装构建器，即安装向导。虽然这可能对你的应用程序不是必需的，但Windows用户通常期望在运行`.exe`文件时有一个向导可用。有许多免费、开源和专有安装构建器可供选择。
- en: One benefit of building Mac binaries is that they are simple to pack for distribution;
    once the `.app` file is generated, right-click on the file and choose Create Archive.
    After that, your application is ready to be shipped out.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Mac二进制文件的一个好处是它们很容易打包分发；一旦生成了`.app`文件，右键单击文件并选择创建存档。之后，你的应用程序就准备好分发。
- en: A common problem with cx_Freeze is that the program doesn't automatically detect
    a file that needs to be copied. This frequently occurs if you are dynamically
    importing modules into your program, for example, a plugin system.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Freeze的一个常见问题是程序不会自动检测需要复制的文件。如果你在程序中动态导入模块，例如插件系统，这种情况经常发生。
- en: Binaries created by cx_Freeze are generated for the OS it was run on; for instance,
    to create a Windows `.exe` file, cx_Freeze has to be used on a Windows computer.
    Thus, to make a truly cross-platform Python program that is distributed as executable
    binaries, you must have access to other operating systems. This can be alleviated
    by using virtual machines, cloud hosts, or simply purchasing the relevant systems.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: cx_Freeze创建的二进制文件是为它运行的操作系统生成的；例如，要创建Windows的`.exe`文件，cx_Freeze必须在Windows计算机上使用。因此，要创建一个真正跨平台的Python程序，并以可执行二进制文件的形式分发，你必须能够访问其他操作系统。这可以通过使用虚拟机、云主机或简单地购买相关系统来缓解。
- en: When PyInstaller is run, it analyzes the supplied Python program and creates
    a `<program>.spec` file in the same folder as the Python program. In addition,
    the `build/` subdirectory is placed in the same location.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行PyInstaller时，它会分析提供的Python程序，并在Python程序相同的文件夹中创建一个`<program>.spec`文件。此外，`build/`子目录也被放置在同一位置。
- en: The `build/` directory contains log files and the working files used to actually
    create the binary. After the executable file is generated, a `dist/` directory
    is placed in the same location as the Python program, and the binary is placed
    in the `dist/` directory.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`build/`目录包含日志文件和用于实际创建二进制文件的临时文件。在生成可执行文件后，将在Python程序相同的目录下放置一个`dist/`目录，并将二进制文件放置在`dist/`目录中。'
- en: The executable file generated by Nuitka will have the `.exe` extension on all
    platforms. It is still usable on non-Windows OSes, but it is recommended to change
    the extension to a system-specific one to avoid confusion.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Nuitka生成的可执行文件在所有平台上都将具有`.exe`扩展名。它仍然可以在非Windows操作系统上使用，但建议将其扩展名更改为系统特定的扩展名，以避免混淆。
- en: The binary files created with any of the commands previously shown require Python
    to be installed on the end system, as well as any C extension modules that are
    used.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前显示的任何命令创建的二进制文件都需要在目标系统上安装Python，以及任何使用的C扩展模块。
- en: How to upload programs to PyPI
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何上传程序到PyPI
- en: If you have developed a package and want to post it on PyPI for distribution,
    there are several things you need to do to ensure the proper uploading and registration
    of your project. While this section will highlight some of the key features of
    configuring your packages for distribution on PyPI, it is not all-inclusive. Make
    sure you look at the documentation on the PyPI site to ensure you have the latest
    information.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经开发了一个包并想在PyPI上发布以供分发，您需要做一些事情来确保项目的正确上传和注册。虽然本节将突出配置您的包以在PyPI上分发的关键特性，但并非详尽无遗。请确保查看PyPI网站上的文档，以确保您拥有最新的信息。
- en: One of the first things to do is install the `twine` package into your Python
    environment. `twine` is a collection of utilities for interacting with PyPI. The
    prime reason for its use is that is authenticates your connection to the database
    using HTTPS; this ensures your username and password are encrypted when interacting
    with PyPI. While some people may not care whether a malicious entity captures
    their login credentials for a Python repository, a number of people use the same
    login name and password for multiple sites, meaning that someone learning the
    PyPI login information could potentially access other sites as well.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是将`twine`包安装到您的Python环境中。`twine`是与PyPI交互的一组实用工具。使用它的主要原因是通过HTTPS验证您与数据库的连接；这确保了在与PyPI交互时，您的用户名和密码被加密。虽然有些人可能不在乎恶意实体捕获他们的Python仓库的登录凭证，但许多人使用相同的登录名和密码登录多个网站，这意味着学习PyPI登录信息的人可能也能访问其他网站。
- en: '`twine` also allows you to pre-create your distribution files, that is, you
    can test your package files before releasing them to ensure everything works.
    As part of this, you can upload any packing format, including wheels, to PyPI.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`twine`还允许您预先创建分发文件，也就是说，在发布之前，您可以测试您的包文件以确保一切正常工作。作为这个过程的一部分，您可以上传任何打包格式，包括wheel文件，到PyPI。'
- en: Finally, it allows you to digitally pre-sign your files and pass the `.asc`
    files to the command line when uploading the files. This ensures data security
    by verifying you are passing your credentials into the GPG application, and not
    something else.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它允许您在文件上传时预先对文件进行数字签名，并将`.asc`文件传递到命令行。这通过验证您是否将凭证传递到GPG应用程序，而不是其他东西，来确保数据安全。
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Your project files need to be configured in the proper way so they are of use
    to other developers, and are listed properly on PyPI. The most important step
    of this process is setting up the `setup.py` file, which sits in the root of your
    project's directory.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目文件需要以正确的方式配置，以便对其他开发者有用，并在PyPI上正确列出。这个过程最重要的步骤是设置项目目录根目录下的`setup.py`文件。
- en: '`setup.py` contains configuration data for your project, particularly the `setup()`
    function, which defines the details of the project. It is also the command-line
    interface for running commands related to the packaging process.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`包含项目的配置数据，特别是`setup()`函数，它定义了项目的详细信息。它也是与打包过程相关的命令行接口。'
- en: A license (`license.txt`) should be included with the package. This file is
    important because, in some areas, a package without an explicit license cannot
    be legally used or distributed by anyone but the copyright holder. Including the
    license ensures both the creator and users are legally protected against copyright
    infringement issues.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将许可证（`license.txt`）包含在包中。此文件很重要，因为在某些地区，没有明确许可证的包不能被除版权所有者以外的任何人合法使用或分发。包含许可证确保创作者和用户在版权侵权问题上都得到法律保护。
- en: How to do it...
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a manifest file.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个清单文件。
- en: Configure `setup.py` by defining the options for the `distutils setup()` function.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义 `distutils setup()` 函数的选项来配置 `setup.py`。
- en: How it works...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A manifest file is also important if you need to package files that aren''t
    automatically included in the source distribution. By default, the following files
    are included in the package when generated (known as the standard include set):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要打包源代码分发中未自动包含的文件，清单文件也很重要。默认情况下，在生成包时以下文件会被包含（称为标准包含集）：
- en: All Python source files implied by the `py_modules` and `packages` options
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有由 `py_modules` 和 `packages` 选项隐含的 Python 源文件
- en: All C source files listed in `ext_modules` or `libraries` options
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ext_modules` 或 `libraries` 选项中列出的所有 C 源文件
- en: Any scripts identified with the `scripts` option
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何使用 `scripts` 选项标识的脚本
- en: Any test scripts, for instance, anything that looks like `test*.py`
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何测试脚本，例如，任何看起来像 `test*.py` 的文件
- en: 'Setup and readme files: `setup.py`, `setup.cfg`, and `README.txt`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和说明文件：`setup.py`、`setup.cfg` 和 `README.txt`
- en: All files that match the `package_data` and `data_files` metadata
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有匹配 `package_data` 和 `data_files` 元数据的文件
- en: Any files that don't meet these criteria, such as a license file, need to be
    included in a `MANIFEST.ini` template file. The manifest template is a list of
    instructions on how to generate the actual manifest file that lists the exact
    files to include in the source distribution.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不符合这些标准的文件，例如许可证文件，需要包含在 `MANIFEST.ini` 模板文件中。清单模板是一系列指令，用于生成实际的清单文件，该文件列出了源代码分发中应包含的确切文件。
- en: 'The manifest template can include or exclude any desired files; wildcards are
    available as well. For example, `manifest_template.py` from the `distutils` package
    shows one way to list files:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 清单模板可以包含或排除任何所需的文件；也可以使用通配符。例如，`manifest_template.py` 来自 `distutils` 包的示例展示了如何列出文件：
- en: '[PRE58]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This example indicates that all `.txt` files in the root directory should be
    included, as well as all `.txt` and `.py` files in the `examples/` subdirectory.
    In addition, all directories that match `examples/sample?/build` will be excluded
    from the package.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例表明，应包含根目录中的所有 `.txt` 文件，以及 `examples/` 子目录中的所有 `.txt` 和 `.py` 文件。此外，所有匹配
    `examples/sample?/build` 的目录都将从包中排除。
- en: The manifest file is processed after the defaults above are considered, so if
    you want to exclude files from the standard include set, you can explicitly list
    them in the manifest. If, however, you want to completely ignore all defaults
    in the standard set, you can use the `--no-defaults` option to completely disable
    the standard set.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 清单文件在考虑上述默认值之后进行处理，因此如果您想从标准包含集中排除文件，可以在清单中明确列出它们。如果您想完全忽略标准集中的所有默认值，可以使用 `--no-defaults`
    选项完全禁用标准集。
- en: The order of commands in the manifest template is important. After the standard
    include set is processed, the template commands are processed in order. Once that
    is done, the final resulting command set is processed; all files to be pruned
    are removed. The resulting list of files is written to the manifest file for future
    reference; the manifest file is then used to build the source distribution archive.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 清单模板中命令的顺序很重要。在处理完标准包含集之后，模板命令按顺序处理。一旦完成，处理最终的命令集；所有要删除的文件都会被移除。生成的文件列表将被写入清单文件以供将来参考；然后使用清单文件来构建源代码分发存档。
- en: It is important to note that the manifest template does not affect binary distributions,
    such as wheels. It is only for use in source-file packaging.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，清单模板不会影响二进制分发，如 wheels。它仅用于源文件打包。
- en: As mentioned previously, `setup.py` is a key file for the packaging process,
    and the `setup()` function is what enables the details of the project to be defined.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`setup.py` 是打包过程中的关键文件，而 `setup()` 函数则允许定义项目的详细信息。
- en: 'There are a number of arguments that can be provided to the `setup()` function,
    some of which will be covered in the following list. A good example of this is
    shown is the *Listing Packages* section:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向 `setup()` 函数提供多个参数，以下列表中会介绍其中的一些。一个很好的例子可以在 *列出包* 部分找到：
- en: '**name**: The name of the project, as it will be listed on PyPI. Only ASCII
    alphanumeric characters, underscores, hyphens, and periods are acceptable. Must
    also start and end with an ASCII character. This is a required field.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: 项目的名称，它将在 PyPI 上列出。仅接受 ASCII 字母数字字符、下划线、连字符和点。名称必须以 ASCII 字符开头和结尾。这是一个必填字段。'
- en: Project names are case-insensitive when pulled via `pip`, that is, `My.Project
    = My-project = my-PROJECT`, so make sure the name itself is unique, not just a
    different capitalization compared to another project.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当通过 `pip` 拉取项目名称时，名称是不区分大小写的，即 `My.Project = My-project = my-PROJECT`，所以请确保名称本身是唯一的，而不仅仅是与其他项目的大小写不同。
- en: '**version**: The current version of your project. This is used to tell users
    whether they have the latest version installed, as well as indicating which specific
    versions they''ve tested their software against. This is a required field.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**: 你项目的当前版本。这用于告诉用户他们是否安装了最新版本，以及他们测试软件时针对哪些特定版本进行了测试。这是一个必填字段。'
- en: 'There is actually a document on PEP 440 ([https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)) that
    indicates how to write your version numbers. `versioning.py` is an example of
    versioning a project:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有一个关于 PEP 440 ([https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/))
    的文档，它说明了如何编写你的版本号。`versioning.py` 是一个对项目进行版本化的示例：
- en: '[PRE59]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**description**: A short and long description of your project. These will be
    displayed on PyPI when the project is published. The short description is required
    but the long description is optional.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**: 项目的简短和详细描述。这些将在项目发布到 PyPI 时显示。简短描述是必填的，但详细描述是可选的。'
- en: '**url**: The homepage URL for your project. This is an optional field.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网址**: 你项目的首页 URL。这是一个可选字段。'
- en: '**author**: The developer name(s) or organization name. This is an optional
    field.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作者**: 开发者名称或组织名称。这是一个可选字段。'
- en: '**author_email***:* The email address for the author listed above. Obfuscating
    the email address by spelling out the special characters, for example, `your_name`
    at `your_organization` dot com, is discouraged as this is a computer-readable
    field; use `your_name@your_organization.com`. This is an optional field.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作者邮箱**: 上列作者的电子邮件地址。不建议通过拼写特殊字符来混淆电子邮件地址，例如，`your_name` at `your_organization`
    dot com，因为这个字段是计算机可读的；请使用 `your_name@your_organization.com`。这是一个可选字段。'
- en: '**classifiers**: These categorize your project to help users find it on PyPI.
    There is a list of classifiers ([https://pypi.python.org/pypi?%3Aaction=list_classifiers](https://pypi.python.org/pypi?%3Aaction=list_classifiers))
    that can be used, but they are optional. Some possible classifiers include: development
    status, framework used, intended use case, license, and so on.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类器**: 这些分类器用于将你的项目分类，以帮助用户在 PyPI 上找到它。可以使用一个分类器列表（[https://pypi.python.org/pypi?%3Aaction=list_classifiers](https://pypi.python.org/pypi?%3Aaction=list_classifiers)），但这些是可选的。一些可能的分类器包括：开发状态、使用的框架、预期用例、许可证等。'
- en: '**keywords**: List of keywords that describe your project. It is suggested
    you to use keywords that might be used by a user searching for your project. This
    is an optional field.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键词**: 描述你的项目的关键词列表。建议使用用户可能用于搜索你的项目的关键词。这是一个可选字段。'
- en: '**packages**: List of packages used in your project. The list can be manually
    entered, but `setuptools.find_packages()` can be used to locate them automatically.
    A list of excluded packages can also be included to ignore packages that are not
    intended for release. This is a required field.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包名**: 在你的项目中使用的包的列表。该列表可以手动输入，但可以使用 `setuptools.find_packages()` 自动定位它们。也可以包含一个排除包的列表，以忽略不打算发布的包。这是一个必填字段。'
- en: An optional method for listing packages is to distribute a single Python file,
    which to change the `packages` argument to `py_modules`, which then expects `my_module.py`
    to exist in the project.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列出包的一个可选方法是分发一个单独的 Python 文件，将 `packages` 参数更改为 `py_modules`，然后期望在项目中存在 `my_module.py`。
- en: '**install_requires**: Specifies the minimum dependencies for the project to
    run. `pip` uses this argument to automatically identify dependencies, so these
    packages must be valid, existing projects. This is an optional field.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**install_requires**：指定项目运行所需的最小依赖项。`pip` 使用此参数来自动识别依赖项，因此这些包必须是有效的、现有的项目。这是一个可选字段。'
- en: '**python_requires**: Specifies the Python versions the project will run on.
    This will prevent `pip` from installing the project on invalid versions. This
    is an optional field.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**python_requires**：指定项目将运行的 Python 版本。这将防止 `pip` 在无效版本上安装项目。这是一个可选字段。'
- en: This is a relatively recent feature; `setuptools` version 24.2.0 is the minimum
    version required for creating source distributions and wheels to ensure `pip`
    properly recognizes this field. In addition, `pip` version 9.0.0 or newer is required;
    earlier versions will ignore this field and install the package regardless of
    Python version.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个相对较新的功能；`setuptools` 版本 24.2.0 是创建源分布和轮子的最低版本要求，以确保 `pip` 正确识别此字段。此外，还需要
    `pip` 版本 9.0.0 或更高版本；早期版本将忽略此字段，并无论 Python 版本如何都安装包。
- en: '**package_data**: This is used to indicate additional files to be installed
    in the package, such as other data files or documentation. This argument is a
    dictionary mapping the package name to a list of relative path names. This is
    an optional field.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package_data**：用于指示要安装到包中的额外文件，例如其他数据文件或文档。此参数是将包名称映射到相对路径名称列表的字典。这是一个可选字段。'
- en: '**data_fields**: While `package_data` is the preferred method for identifying
    additional files, and is normally sufficient for the purpose, there are times
    when data files need to be placed outside your project package, for example, configuration
    files that need to be stored in a particular location in the file system. This
    is an optional field.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**data_fields**：虽然 `package_data` 是识别额外文件的首选方法，并且通常足够用于此目的，但在某些情况下，数据文件需要放置在项目包外部，例如，需要存储在文件系统特定位置的配置文件。这是一个可选字段。'
- en: '**py_modules**: List of names for single-file modules that are included in
    the project. This is a required field.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**py_modules**：包含在项目中的单文件模块的名称列表。这是一个必填字段。'
- en: '**entry_points**: Dictionary of executable scripts, such as plugins, that are
    defined within your project or that your project depends upon. Entry points provide
    cross-platform support and allow `pip` to create the appropriate executable form
    for the target platform. Because of these capabilities, entry points should be
    used in lieu of the *scripts* argument. This is an optional field.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**entry_points**：字典形式的可执行脚本，如插件，这些脚本是在您的项目内定义的或您的项目所依赖的。入口点提供跨平台支持，并允许 `pip`
    为目标平台创建适当的可执行形式。由于这些功能，入口点应替代 `*scripts*` 参数。这是一个可选字段。'
- en: Project packaging
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目打包
- en: Everything we have talked about so far is just the basics required to get your
    project configured and set up for packaging; we haven't actually packaged it yet.
    To actually create a package that can be installed from PyPI or another package
    index, you need to run the `setup.py` script.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所讨论的一切只是配置和设置项目以进行打包所需的基本知识；我们还没有真正打包它。要创建一个可以从 PyPI 或其他包索引安装的包，您需要运行
    `setup.py` 脚本。
- en: How to do it...
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a source code-based distribution. The minimum required for a package
    is a source distribution. A source distribution provides the metadata and essential
    source code files needed by `pip` for installation. A source distribution is essentially
    raw code and requires a build step prior to installation to build out the installation
    metadata from `setup.py`. A source distribution is created by running `python
    setup.py sdist`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建基于源代码的分布。对于一个包来说，最低要求是源代码分布。源代码分布提供了 `pip` 安装所需的所有元数据和基本源代码文件。源代码分布基本上是原始代码，需要在安装之前进行构建步骤，从
    `setup.py` 中构建安装元数据。源代码分布是通过运行 `python setup.py sdist` 创建的。
- en: While source distributions are a necessity, it is more convenient to create
    wheels. Wheel packages are highly recommended, as they are pre-built packages
    that can be installed without waiting for the build process. This means installation
    is significantly faster compared to working with a source distribution.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然源代码分布是必需的，但创建轮子更为方便。轮子包被高度推荐，因为它们是预构建的包，可以不等待构建过程即可安装。这意味着与使用源代码分布相比，安装速度要快得多。
- en: 'There are several types of wheels, depending on whether the project is pure
    Python and whether it natively supports both Python 2 and 3\. To build wheels,
    you must first install the wheel package: `pip install wheel`.'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据项目是否是纯 Python 以及是否原生支持 Python 2 和 3，存在几种类型的轮。要构建轮，您必须首先安装 wheel 包：`pip install
    wheel`。
- en: The preferred wheel package is a universal wheel. Universal wheels are pure
    Python, that is, do not contain C-code compiled extensions, and natively support
    both Python 2 and 3 environments. Universal wheels can be installed anywhere using
    `pip`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首选的轮包是通用轮。通用轮是纯 Python，即不包含编译的 C 代码扩展，并原生支持 Python 2 和 3 环境。通用轮可以使用 `pip` 安装到任何地方。
- en: 'To build a universal wheel, the following command is used:'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要构建通用轮，请使用以下命令：
- en: '[PRE60]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`--universal` should only be used when there are no C extensions in use and
    the Python code runs on both Python 2 and Python 3 without needing modifications,
    such as running `2to3`.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`--universal` 应仅在没有使用 C 扩展且 Python 代码在 Python 2 和 Python 3 上运行而不需要修改（例如运行 `2to3`）时使用。'
- en: '`bdist_wheel` signifies that the distribution is a binary one, as opposed to
    a source distribution. When used in conjunction with `--universal`, it does not
    check to ensure that it is being used correctly, so no warnings will be provided
    if the criteria are not met.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`bdist_wheel` 表示该分发是一个二进制分发，而不是源分发。当与 `--universal` 一起使用时，它不会检查是否正确使用，因此如果不符合条件，则不会提供警告。'
- en: The reason universal wheels shouldn't be used with C extensions is because `pip`
    prefers wheels over source distributions. Since an incorrect wheel will mostly
    likely prevent the C extension from being built, the extension won't be available
    for use.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 通用轮不应与 C 扩展一起使用的原因是 `pip` 更喜欢轮而不是源分发。由于错误的轮很可能会阻止 C 扩展的构建，因此扩展将不可用。
- en: Alternatively, pure Python wheels can be used. Pure Python wheels are created
    when the Python source code doesn't natively support both Python 2 and 3 functionality.
    If the code can be modified for use between the two versions, such as via `2to3`,
    you can manually create wheels for each version.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，可以使用纯 Python 轮。当 Python 源代码不原生支持 Python 2 和 3 功能时，会创建纯 Python 轮。如果代码可以通过
    `2to3` 等方式修改以在两个版本之间使用，则可以手动为每个版本创建轮。
- en: 'To build a wheel, use the following command:'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要构建轮，请使用以下命令：
- en: '[PRE61]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`bdist_wheel` will identify the code and build a wheel that is compatible for
    any Python installation with the same major version number, that is, 2.x or 3.x.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`bdist_wheel` 将识别代码并构建一个与任何具有相同主版本号的 Python 安装兼容的轮，即 2.x 或 3.x。'
- en: Finally, platform wheels can be used when making packages for specific platforms.
    Platform wheels are binary builds specific to a certain platform/architecture
    due to the inclusion of compiled C extensions. Thus, if you need to make a program
    that is only used on macOS, a platform wheel must be used.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在为特定平台制作包时可以使用平台轮。由于包含编译的 C 扩展，平台轮是针对特定平台/架构的二进制构建。因此，如果您需要制作仅在 macOS 上使用的程序，则必须使用平台轮。
- en: The same command as a pure Python wheel is used, but `bdist_wheel` will detect
    that the code is not pure Python code and will build a wheel whose name will identify
    it as only usable on a specific platform. This is the same tag as referenced in
    the *Installing from Wheels* section.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用与纯 Python 轮相同的命令，但 `bdist_wheel` 会检测到代码不是纯 Python 代码，并将构建一个名称标识它只能在特定平台上使用的轮。这与
    *从轮安装* 部分中引用的相同标签。
- en: Uploading to PyPI
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传到 PyPI
- en: When `setup.py` is run, it creates the new directory `dist/` in your project's
    root directory. This is where the distribution files are placed for uploading.
    These files are only created when the build command is run; any changes to the
    source code or configuration files require rebuilding the distribution files.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 `setup.py` 时，它会在项目的根目录中创建新的目录 `dist/`。这是放置上传的分发文件的地点。这些文件仅在运行构建命令时创建；对源代码或配置文件的任何更改都需要重新构建分发文件。
- en: Getting ready
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before uploading to the main PyPI site, there is a PyPI test site ([https://testpypi.python.org/pypi](https://testpypi.python.org/pypi))
    you can practice with. This allows developers the opportunity to ensure they know
    what they are doing with the entire building and uploading process, so they don't
    break anything on the main site. The test site is cleaned up on a semi-regular
    basis, so it shouldn't be relied on as a storage site while developing.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传到主PyPI站点之前，有一个PyPI测试站点（[https://testpypi.python.org/pypi](https://testpypi.python.org/pypi)）你可以练习使用。这允许开发者有机会确保他们知道整个构建和上传过程，这样他们就不会在主站点上破坏任何东西。测试站点会定期清理，所以在开发时不应将其作为存储站点依赖。
- en: In addition, check the long and short descriptions in your `setup.py` to ensure
    they are valid. Certain directives and URLs are forbidden and stripped during
    uploading; this is one reason why it is good to test your project on the PyPI
    test site to see if there are any problems with your configuration.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查你的`setup.py`中的长描述和短描述，以确保它们有效。某些指令和URL在上传过程中被禁止并删除；这也是为什么在PyPI测试站点上测试你的项目以查看是否存在配置问题是一个好主意的原因。
- en: Before uploading to PyPI, you need to create a user account. Once you have manually
    created an account on the web site, you can create a `$HOME/.pypirc` file to store
    your username and password. This file will be referenced when uploading so you
    won't have to manually enter it every time. However, be aware that your PyPI password
    is stored in plaintext, so if you are concerned about that you will have to manually
    provide it for every upload.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传到PyPI之前，你需要创建一个用户账户。一旦你在网站上手动创建了账户，你就可以创建一个`$HOME/.pypirc`文件来存储你的用户名和密码。在上传时，此文件将被引用，因此你不必每次都手动输入。然而，请注意，你的PyPI密码以纯文本形式存储，所以如果你担心这一点，你将不得不为每次上传手动提供它。
- en: Once you have a created a PyPI account, you can upload your distributions to
    PyPI via `twine`; for new distributions, `twine` will automatically handle the
    registration of the project on the site. Install `twine` as normal using `pip`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个PyPI账户，你就可以通过`twine`将你的发行版上传到PyPI；对于新的发行版，`twine`将自动处理在网站上项目的注册。使用`pip`正常安装`twine`。
- en: How to do it...
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create your distributions:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的发行版：
- en: '[PRE62]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Register your project (if for a first upload):'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册你的项目（如果是首次上传）：
- en: '[PRE63]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Upload distributions:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传发行版：
- en: '[PRE64]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following error indicates you need to register your package:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下错误表明你需要注册你的包：
- en: '[PRE65]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works...
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`twine` securely authenticates users to the PyPI database using HTTPS. The
    older way of uploading packages to PyPI was using `python setup.py upload`; this
    was insecure as the data was transferred via unencrypted HTTP, so your login credentials
    could be sniffed. With `twine`, connections are made through verified TLS to prevent
    credential theft.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`twine`使用HTTPS安全地验证用户对PyPI数据库的访问。上传包到PyPI的旧方法是通过`python setup.py upload`；这不够安全，因为数据是通过未加密的HTTP传输的，所以你的登录凭证可能会被窃取。使用`twine`，连接是通过验证的TLS进行的，以防止凭证被盗。'
- en: This also allows a developer to pre-create distribution files, whereas `setup.py
    upload` only works with distributions that are created at the same time. Thus,
    using `twine`, a developer is able to test files prior to uploading them to PyPI,
    to ensure they work.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这也允许开发者预先创建发行版文件，而`setup.py upload`仅适用于同时创建的发行版。因此，使用`twine`，开发者能够在上传到PyPI之前测试文件，以确保它们可以正常工作。
- en: Finally, you can pre-sign your uploads with digital signatures and attach the
    `.asc` certification files to the `twine` upload. This ensures the developer's
    password is entered into GPG and not some other software, such as malware.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用数字签名预先签名你的上传，并将`.asc`认证文件附加到`twine`上传中。这确保开发者的密码输入到GPG而不是其他软件，例如恶意软件。
