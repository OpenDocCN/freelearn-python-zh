- en: Chapter 10. Tools to Improve Test-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。提高测试驱动开发的工具
- en: Up to this point, we have mostly been looking at how to write and run tests.
    In this chapter, we will turn our attention to integrating the tests with the
    wider development environment. Having tests integrated into the development environment
    is important because it allows us to set up an automated process through which
    tests are executed regularly. We will also look at other tools that can improve
    the way we do TDD—from other test runners to libraries that make asserting easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注的是如何编写和运行测试。在本章中，我们将把注意力转向将测试与更广泛的开发生态集成。将测试集成到开发环境中很重要，因为它允许我们设置一个自动化的流程，通过该流程定期执行测试。我们还将探讨其他可以提高我们进行
    TDD 方式效率的工具——从其他测试运行器到使断言更容易的库。
- en: TDD tools
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD 工具
- en: We looked at the nose2 test runner earlier in this book. Python has other popular
    third-party test runners. Python also has a number of libraries to make assertions
    more flexible and readable. These libraries can be used with both `unittest` compatible
    tests and the function style tests supported by third-party test runners. Let
    us take a look at some of these TDD tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我们探讨了 nose2 测试运行器。Python 有其他流行的第三方测试运行器。Python 还有一系列库，可以使断言更加灵活和可读。这些库可以与
    `unittest` 兼容的测试以及第三方测试运行器支持的函数式测试一起使用。让我们看看这些 TDD 工具中的一些。
- en: py.test
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: py.test
- en: 'Like nose2, py.test is another popular third-party test runner. py.test supports
    many features like the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与 nose2 一样，py.test 也是另一个流行的第三方测试运行器。py.test 支持许多功能，如下所示：
- en: Writing tests as ordinary functions.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试编写为普通函数。
- en: Using Python's `assert` statement to perform asserts.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 的 `assert` 语句进行断言。
- en: Ability to skip tests or mark tests as expected failures.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过测试或标记测试为预期失败的能力。
- en: Fixtures with setup and teardown support.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持设置和清理的固定值。
- en: Extensible plugin framework, with plugins available to do popular functionality
    such as XML output, coverage reporting, and running tests in parallel across multiple
    processors or cores.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的插件框架，提供插件以执行流行的功能，例如 XML 输出、覆盖率报告以及在多个处理器或核心上并行运行测试。
- en: Tag tests with attributes.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性标记测试。
- en: Integration with popular tools.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成流行的工具。
- en: 'One of py.test''s most unique features is funcargs. Take a look at the following
    code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: py.test 最独特的特点之一是 funcargs。看看以下代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, the `test_stock_update` function takes a parameter called `goog`.
    Additionally, we have a function called `goog`, which is marked with the `pytest.fixture`
    decorator. PyTest will match these two, call the appropriate fixture, and pass
    in the return value as a parameter to the test.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`test_stock_update` 函数接受一个名为 `goog` 的参数。此外，我们还有一个名为 `goog` 的函数，该函数带有 `pytest.fixture`
    装饰器。PyTest 将匹配这两个，调用适当的固定值，并将返回值作为参数传递给测试。
- en: 'This solves the following two problems:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了以下两个问题：
- en: It enables us to pass fixture values to function style test cases without having
    to resort to globals.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使我们能够在不使用全局变量的情况下，将固定值传递给函数式测试用例。
- en: Instead of writing a large fixture, we can create many small ones, and the test
    cases only use the fixtures that they need. This makes it easier to read test
    cases as we don't have to look at a large fixture setup that has different lines
    of setup meant for different tests.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建许多小的固定值，而不是编写一个大的固定值，测试用例只使用它们需要的固定值。这使得阅读测试用例更容易，因为我们不需要查看一个大的设置，其中包含为不同测试准备的不同设置行。
- en: The above example only scratches the surface of funcargs. `py.test` supports
    a number of other usage scenarios with funcargs. Definitely check out this popular
    test runner.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例只是对 funcargs 的表面了解。`py.test` 支持许多其他使用场景。绝对要检查这个流行的测试运行器。
- en: py.test versus nose2
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: py.test 与 nose2 的比较
- en: There isn't a lot to choose between nose2 and py.test. nose2 has a unique feature
    in writing tests using layers, while py.test has a unique feature in funcargs.
    Apart from that, both support running of `unittest` test cases, both have a robust
    plugin framework, and both can be integrated with all the tools we discuss in
    this chapter. The decision between them really comes down to a personal choice
    between layers versus funcargs, or if one supports a particular plugin that we
    really want. Definitely take a look at py.test at its homepage at [http://pytest.org/latest/](http://pytest.org/latest/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在nose2和py.test之间没有太多选择。nose2在编写使用层来编写测试方面具有独特功能，而py.test在funcargs方面具有独特功能。除此之外，两者都支持运行`unittest`测试用例，两者都有强大的插件框架，并且都可以与本章中讨论的所有工具集成。两者之间的选择实际上取决于个人对层与funcargs之间的选择，或者是否支持我们真正想要的特定插件。绝对建议查看py.test的主页[http://pytest.org/latest/](http://pytest.org/latest/)。
- en: Trial
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试
- en: Trial is a unit test runner that was originally built for testing Python's Twisted
    framework. Trial supports running vanilla unit tests written using the `unittest`
    module, as well as advanced features specifically for supporting applications
    based on network programming—clients, servers, and the like. The most important
    of these is support for asynchronous programming models, where a method might
    return immediately, but the actual return value is received later on. This is
    usually done using a concept called `Deferred`. Since this is a deep and niche
    topic, we won't go into a detailed discussion in this book. Just keep in mind
    that if you are doing anything with network programming, event-based systems,
    or asynchronous programming, then you should check out Trial at its homepage at
    [http://twistedmatrix.com/trac/wiki/TwistedTrial](http://twistedmatrix.com/trac/wiki/TwistedTrial).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Trial是一个单元测试运行器，最初是为测试Python的Twisted框架而构建的。Trial支持运行使用`unittest`模块编写的纯单元测试，以及专门针对基于网络编程的应用程序（如客户端、服务器等）的高级功能。其中最重要的是对异步编程模型的支持，其中方法可能立即返回，但实际的返回值是在稍后接收的。这通常使用一个称为`Deferred`的概念来完成。由于这是一个深奥且专业的话题，我们不会在本书中进行详细讨论。只需记住，如果你在进行任何网络编程、基于事件系统或异步编程的工作，那么你应该查看Trial的主页[http://twistedmatrix.com/trac/wiki/TwistedTrial](http://twistedmatrix.com/trac/wiki/TwistedTrial)。
- en: Sure
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当然
- en: Sure is a Python library to help write assertions that are easier to read. It
    is a Python port of the should.js JavaScript library.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Sure是一个Python库，旨在帮助编写易于阅读的断言。它是should.js JavaScript库的Python版本。
- en: 'With Sure, we can take the following test:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sure，我们可以进行以下测试：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And, rewrite it to look like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其重写为以下形式：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how the assert has been replaced with a statement that reads like regular
    English. Sure adds a bunch of attributes to all objects to allow us to write asserts
    like this.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到断言已被替换为类似常规英语的语句。Sure向所有对象添加了大量属性，使我们能够编写这样的断言。
- en: 'The following is how our float test would look like in Sure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在Sure中查看我们的浮点测试：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, the following is how we would check for expected exceptions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下是如何检查预期异常的方法：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sure also supports using Python''s `assert` statement as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Sure还支持使用Python的`assert`语句如下：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Sure supports a large number of expressions like the one above to express a
    multitude of assertion conditions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Sure支持大量如上所述的表达式，以表达多种断言条件。
- en: Sure uses some monkey patching to add these attributes to all objects. The monkey
    patching is done once the `import sure` statement is executed. For this reason,
    be careful to use Sure only on unit test files and not in any production file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Sure使用一些猴子补丁来将这些属性添加到所有对象中。猴子补丁是在执行`import sure`语句后完成的。因此，请务必仅在单元测试文件上使用Sure，而不要在任何生产文件中使用。
- en: 'Monkey patching can be disabled by setting the `SURE_DISABLE_NEW_SYNTAX` environment
    variable to true before running tests. When monkey patching is disabled, Sure
    supports an alternate syntax using the expect function as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在运行测试之前将`SURE_DISABLE_NEW_SYNTAX`环境变量设置为true来禁用猴子补丁。当猴子补丁被禁用时，Sure支持使用expect函数的以下替代语法：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Full details on all available methods and syntax are available on the Sure homepage
    at [http://falcao.it/sure/intro.html](http://falcao.it/sure/intro.html).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用方法和语法的完整详情可在Sure主页[http://falcao.it/sure/intro.html](http://falcao.it/sure/intro.html)找到。
- en: Since assertions are plain functions, we can use this library even when writing
    function style tests supported by nose2 and py.test.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于断言是普通函数，因此我们可以在编写nose2和py.test支持的函数式测试时使用此库。
- en: PyHamcrest
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyHamcrest
- en: PyHamcrest is a Python port of the Java Hamcrest library. This is another library
    to enable us to write cleaner and more flexible asserts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: PyHamcrest是Java Hamcrest库的Python端口。这是另一个库，使我们能够编写更干净、更灵活的断言。
- en: 'PyHamcrest defines its own `assert_that` function and a number of matchers
    such as `equal_to`. Using them, we can write a test like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PyHamcrest定义了自己的`assert_that`函数和多个匹配器，如`equal_to`。使用它们，我们可以编写如下测试：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'PyHamcrest also has a system for writing custom matchers by inheriting from
    the `BaseMatcher` class. The following is a custom matcher that checks whether
    a stock has the crossover signal returning a particular value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PyHamcrest还有一个通过从`BaseMatcher`类继承来编写自定义匹配器的系统。以下是一个自定义匹配器，它检查股票是否具有返回特定值的交叉信号：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The class defines two methods: `_matches` and `describe_to`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了两个方法：`_matches`和`describe_to`。
- en: The `_matches` method takes the first parameter for the `assert_that` function
    call and returns whether it matches the given condition or not. In this case,
    we call the `get_crossover_signal` method and check whether it matches the signal
    that we were expecting.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`_matches`方法接受`assert_that`函数调用的第一个参数，并返回它是否匹配给定的条件。在这种情况下，我们调用`get_crossover_signal`方法并检查它是否匹配我们期望的信号。'
- en: The `describe_to` method returns a text description that is used for the message
    displayed when the assertion fails.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe_to`方法返回一个文本描述，用于在断言失败时显示的消息。'
- en: 'We also define a convenience function `is_buy_on`, which returns a matcher
    to match the `StockSignal.buy` signal as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个便利函数`is_buy_on`，它返回一个匹配器来匹配`StockSignal.buy`信号，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this, we can write a test like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以编写如下测试：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Like Sure, PyHamcrest assertions are plain functions and are suitable for use
    in function style tests supported by nose2 and py.test. You can visit PyHamcrest's
    homepage at [https://github.com/hamcrest/PyHamcrest](https://github.com/hamcrest/PyHamcrest).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与Sure一样，PyHamcrest断言是纯函数，适用于nose2和py.test支持的功能测试风格。您可以在PyHamcrest的主页[https://github.com/hamcrest/PyHamcrest](https://github.com/hamcrest/PyHamcrest)上查看。
- en: Integrating with build tools
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与构建工具集成
- en: It just takes a single line to execute our test cases. Then why would we want
    to integrate with build tools? Build tools support pre-requisites, so by integrating
    with such tools, we can ensure the tests are run before performing a critical
    task. An example would be to run all the tests before deploying the code to production.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试用例只需一行代码。那么，为什么我们想要与构建工具集成呢？构建工具支持先决条件，因此通过集成此类工具，我们可以确保在执行关键任务之前运行测试。一个例子是在将代码部署到生产之前运行所有测试。
- en: Paver
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Paver
- en: Paver is a popular Python-based build tool. It is built around the concept of
    tasks. Tasks are a sequence of commands that perform a particular action, such
    as building the application or running unit tests. Tasks are coded in regular
    Python and placed in a file called `pavement.py` in the project root.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Paver是一个基于Python的流行构建工具。它围绕任务的概念构建。任务是一系列执行特定操作的命令，例如构建应用程序或运行单元测试。任务使用常规Python编写，并放置在项目根目录下的名为`pavement.py`的文件中。
- en: 'We want to create a task that will run our unit tests. The following is how
    we can do that in Paver:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个运行我们的单元测试的任务。以下是在Paver中如何做到这一点：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The task above simply runs a command to execute the `unittest` module. We use
    the `@consume_args` decorator, which tells Paver to take all the command line
    parameters and pass it to this task.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述任务简单地运行一个命令来执行`unittest`模块。我们使用`@consume_args`装饰器，它告诉Paver接受所有命令行参数并将它们传递给此任务。
- en: 'To run this Paver task, we simply execute the following on the command line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此Paver任务，我们只需在命令行上执行以下操作：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we are using nose2, then we can modify the task as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用nose2，则可以修改任务如下：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we have the task, then we can use it in other tasks like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有任务，我们就可以在其他任务中使用它，如下所示：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will run the `test` task every time the `deploy` task is executed. Only
    if the tests pass will the deployment of the code take place.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行`deploy`任务时，都会运行`test`任务。只有当测试通过时，才会进行代码的部署。
- en: Integrating with packaging tools
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与打包工具集成
- en: Packaging refers to how Python packages are generally distributed to users.
    Unless we are writing proprietary commercial software, we will want to distribute
    the unit tests along with the code and allow the end user to run the tests and
    verify that everything is working.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 打包指的是Python软件包通常如何分发给用户。除非我们正在编写专有商业软件，否则我们希望将单元测试与代码一起分发，并允许最终用户运行测试以验证一切是否正常工作。
- en: Packaging tools have been one of the most confusing parts of the Python ecosystem.
    There have been a number of different frameworks that, at different points, have
    been "the right way" to do things. As this book is being written, setuptools is
    the recommended way to package Python modules, so let us take a look at that first.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 打包工具一直是Python生态系统中最令人困惑的部分之一。曾经有多个不同的框架，在不同的时间点，被认为是“正确”做事的方式。当这本书正在编写时，setuptools是推荐的打包Python模块的方式，因此让我们首先看看它。
- en: Setuptools
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Setuptools
- en: 'Setuptools supports a test command for running the test suite. All we need
    to do is to configure it. We do this by specifying the `test_suite` parameter
    in `setup.py` as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Setuptools支持一个测试命令来运行测试套件。我们只需要配置它。我们通过在`setup.py`中指定`test_suite`参数来完成此操作，如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we do this, setuptools will pick up and run all the tests with the following
    command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，setuptools将使用以下命令获取并运行所有测试：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The configuration above will only run the `unittest` compatible tests. We can''t
    run any nose2 tests nor can we use nose2 plugins. Fortunately, nose2 also supports
    integration with setuptools. The `nose2.collector.collector` function returns
    a compatible test suite which setuptools can run. The following test suite executes
    all the tests found by nose2:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的配置只会运行与`unittest`兼容的测试。我们无法运行任何nose2测试，也无法使用nose2插件。幸运的是，nose2也支持与setuptools集成。`nose2.collector.collector`函数返回一个兼容的测试套件，setuptools可以运行。以下测试套件执行了nose2找到的所有测试：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `tests_require` parameter can be set to the packages that are required for
    running tests. We put `nose2` here, so even if the end user doesn't have nose2
    installed, setuptools will install it for us before running the tests. If we use
    any third-party nose2 plugins, we can add those to the list here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests_require`参数可以设置为运行测试所需的包。我们将`nose2`放在这里，这样即使最终用户没有安装nose2，setuptools也会在我们运行测试之前为我们安装它。如果我们使用任何第三方nose2插件，我们也可以将它们添加到列表中。'
- en: We can't pass any parameters when running tests this way. All configuration
    needs to be done in `nose2.cfg`. If there are some special settings that we would
    like to use only with the `setuptools` test command, we can put those in a special
    `setup.cfg` file. The settings in this file are used only when the nose tests
    are run via setuptools.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式运行测试时，我们无法传递任何参数。所有配置都需要在`nose2.cfg`中完成。如果我们有一些只想与`setuptools`测试命令一起使用的特殊设置，我们可以将这些设置放在一个特殊的`setup.cfg`文件中。此文件中的设置仅在通过setuptools运行nose测试时使用。
- en: To integrate py.test with setuptools, we need to use the `cmdclass` technique
    that we use in the `distutils` integration in the following.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要将py.test与setuptools集成，我们需要使用以下`distutils`集成中使用的`cmdclass`技术。
- en: Distutils
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Distutils
- en: Python comes bundled with its own packaging system called **distutils**. Although
    setuptools is the preferred way, we might sometimes want to stick with distutils
    because it is bundled in the standard library.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了一个名为**distutils**的打包系统。虽然setuptools是首选方式，但我们有时可能想坚持使用distutils，因为它包含在标准库中。
- en: 'Distutils supports adding custom commands to setup.py. We''re going to use
    that feature to add a command that will run our tests. The following is what it
    looks like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Distutils支持向setup.py添加自定义命令。我们将使用该功能添加一个将运行我们的测试的命令。以下是如何实现它的样子：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `cmdclass` option allows us to pass in a dict containing command names mapped
    to a command class. We configure the test command and map it to our `TestCommand`
    class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmdclass`选项允许我们传递一个包含命令名称映射到命令类的字典。我们配置测试命令并将其映射到我们的`TestCommand`类。'
- en: 'The `TestCommand` class inherits from distutil''s `Command` class. The `Command`
    class is an abstract base class; subclasses will need to create the `user_options`
    list as well as implement three methods: `initialize_options`, `finalize_options`,
    and `run`. We don''t need to do anything in the first two methods, so we keep
    them empty.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestCommand`类继承自distutil的`Command`类。`Command`类是一个抽象基类；子类需要创建`user_options`列表以及实现三个方法：`initialize_options`、`finalize_options`和`run`。我们不需要在前两个方法中做任何事情，所以我们将它们保持为空。'
- en: The only method we need for our command is the `run` method. This method is
    called by distutils when the command is to be executed, and our implementation
    simply runs the shell command and returns the appropriate exit value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的唯一方法是`run`方法。当命令要被执行时，distutils会调用此方法，我们的实现简单地运行shell命令并返回适当的退出值。
- en: The same technique can be used to run the nose2 tests or py.test tests as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术也可以用来运行nose2测试或py.test测试。
- en: Integrating with continuous integration tools
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与持续集成工具集成
- en: Continuous integration tools allow us to validate the integrity of our application
    by running the test suite on every commit. We can configure them to raise an alert
    if any of the tests are failing, or even if the test coverage level drops too
    low.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成工具允许我们在每次提交时运行测试套件，以验证我们应用程序的完整性。我们可以配置它们，如果任何测试失败，或者测试覆盖率太低，则发出警报。
- en: Jenkins
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jenkins
- en: Jenkins is a popular Java-based continuous integration system. Integrating with
    Jenkins requires the nose2 runner because we will need to get output in an XML
    format.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个流行的基于Java的持续集成系统。与Jenkins集成需要nose2运行器，因为我们需要以XML格式获取输出。
- en: 'The first thing we need to do is to configure Jenkins to run the unit tests
    as a part of the build. To do this, we add a shell step to the build and enter
    the command to run the tests. We need to enable the JUnit XML plugin and get coverage
    in XML format, as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是配置Jenkins在构建过程中运行单元测试。为此，我们在构建中添加一个shell步骤并输入运行测试的命令。我们需要启用JUnit
    XML插件并获取XML格式的覆盖率，如下面的截图所示：
- en: '![Jenkins](img/3125_10_01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins](img/3125_10_01.jpg)'
- en: 'We then need to tell Jenkins where to find the unit test results. Select the
    **Publish JUnit test result report** checkbox and enter the location of the nose2
    unit test XML file, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要告诉Jenkins在哪里可以找到单元测试结果。选择**发布JUnit测试结果报告**复选框，并输入nose2单元测试XML文件的位置，如下面的截图所示：
- en: '![Jenkins](img/3125_10_02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins](img/3125_10_02.jpg)'
- en: Enable the **Publish Cobertura Coverage Report** and select the location of
    the coverage XML output file, as shown in the following screenshot. The plugin
    also allows us to set alert limits for Line coverage. This will fail the build
    if coverage levels drop below the threshold specified here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 启用**发布Cobertura覆盖率报告**并选择覆盖率XML输出文件的位置，如下面的截图所示。该插件还允许我们设置行覆盖率的警报限制。如果覆盖率低于此处指定的阈值，这将导致构建失败。
- en: '![Jenkins](img/3125_10_03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins](img/3125_10_03.jpg)'
- en: 'Once the configuration is done, Jenkins will run tests on every build, and
    give us a nice trend report of the unit tests as well as coverage statistics,
    as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成配置，Jenkins将在每次构建时运行测试，并为我们提供一个漂亮的单元测试趋势报告以及覆盖率统计信息，如下面的截图所示：
- en: '![Jenkins](img/3125_10_04.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins](img/3125_10_04.jpg)'
- en: 'We can also dig in deeper to see details about specific suites or tests from
    within Jenkins, as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以深入了解Jenkins中特定套件或测试的详细信息，如下面的截图所示：
- en: '![Jenkins](img/3125_10_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins](img/3125_10_05.jpg)'
- en: Travis CI
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Travis CI
- en: 'Travis CI is the hot new kid on the block, becoming very popular in the Python
    community for open source packages, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI是新兴的热门工具，在Python社区中非常受欢迎，特别是在开源软件包方面，如下面的截图所示：
- en: '![Travis CI](img/3125_10_06.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Travis CI](img/3125_10_06.jpg)'
- en: 'As a hosted service, it doesn''t require any installation. Configuring Travis
    to run our unit tests is a breeze. All we need to do is to add the command to
    run the tests into the `script` section of the `.travis.yml` configuration file
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项托管服务，它不需要任何安装。配置Travis以运行我们的单元测试非常简单。我们只需要将运行测试的命令添加到`.travis.yml`配置文件的`script`部分，如下所示：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's it. Now Travis will execute the command with every commit and let us
    know if the tests fail for any reason.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在Travis将在每次提交时执行命令，并通知我们是否由于任何原因测试失败。
- en: Other tools
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工具
- en: tox
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tox
- en: tox is a framework for maintaining a Python package across multiple versions
    of Python. For example, we can easily test that everything is working in Python
    2.6 and Python 3.4\. It works by creating virtual environments for each version
    and then running the unit tests under that environment.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: tox是一个用于维护Python包跨多个Python版本的框架。例如，我们可以轻松地测试Python 2.6和Python 3.4是否一切正常。它是通过为每个版本创建虚拟环境并在该环境中运行单元测试来工作的。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: tox uses the virtualenv tool for creating virtual environments. This tool is
    bundled in the standard library with Python 3.4 and can be installed from PyPi
    for older version of Python. We don't cover this tool in this book, but if you
    aren't using it already, then do take a look at it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: tox使用virtualenv工具创建虚拟环境。这个工具包含在Python 3.4的标准库中，并且可以从PyPi为旧版本的Python安装。我们在这本书中不介绍这个工具，但如果您还没有使用它，那么请务必查看一下。
- en: 'A typical `tox` configuration file looks like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的`tox`配置文件如下所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The configuration includes the list of Python versions to test against. Each
    environment can have its own dependencies installed that we require to run the
    tests as well as the command required to run the tests. This command can be the
    vanilla `unittest` command, or a third-party runner such as nose2 or py.test.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 配置包括要测试的 Python 版本列表。每个环境都可以安装我们运行测试所需的依赖项，以及运行测试所需的命令。这个命令可以是普通的 `unittest`
    命令，或者像 nose2 或 py.test 这样的第三方运行器。
- en: When tox is executed, it creates a virtual environment for each of the Python
    versions, installs the required dependencies, and runs our tests in that environment.
    tox can be integrated with continuous integration systems so that compatibility
    is maintained with each commit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当 tox 执行时，它会为每个 Python 版本创建一个虚拟环境，安装所需的依赖项，并在该环境中运行我们的测试。tox 可以与持续集成系统集成，以确保每个提交的兼容性。
- en: Sphinx
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sphinx
- en: Sphinx is a documentation framework commonly used with Python projects. Sphinx
    supports embedding snippets of code examples within the documentation. Sphinx
    also has `sphinx.ext.doctest` plugin that can extract these code examples as doctests
    and run them to ensure that the documentation doesn't break.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 是一个常用的文档框架，通常与 Python 项目一起使用。Sphinx 支持在文档中嵌入代码示例片段。Sphinx 还有一个 `sphinx.ext.doctest`
    插件，可以提取这些代码示例作为 doctests 并运行它们，以确保文档不会中断。
- en: The `sphinx.ext.doctest` plugin supports doctest fixtures for setup and teardown,
    and doctest options. Sphinx with the doctest plugin is a good option when our
    application requires a full-blown documentation system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`sphinx.ext.doctest` 插件支持设置和清理的 doctest 固定值，以及 doctest 选项。当我们的应用程序需要完整的文档系统时，带有
    doctest 插件的 Sphinx 是一个不错的选择。'
- en: IDE integration
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE 集成
- en: We haven't talked about IDE integration yet. This is because most of the popular
    Python IDEs have built-in support for running unit tests from within the IDE.
    It is almost a basic feature these days. In addition, there are plugins available
    for popular text editors such as vim, emacs, and Sublime Text 3\. We won't cover
    each and every one of these since they are too numerous. It only takes a quick
    online search to get the configuration or plugins we need to run tests from within
    our favorite IDE or text editor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论 IDE 集成。这是因为大多数流行的 Python IDE 都内置了对在 IDE 内运行单元测试的支持。这在当今几乎是一个基本功能。此外，还有适用于流行的文本编辑器（如
    vim、emacs 和 Sublime Text 3）的插件。我们不会涵盖每一个，因为它们太多了。只需进行一次快速的在线搜索，就可以找到我们需要的配置或插件，以便在我们的首选
    IDE 或文本编辑器中运行测试。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you looked at some popular third-party tools to help us improve
    our TDD practice. Some of the tools such as `py.test` and `trial` are test runners
    with some unique features. Others such as `sure` and `pyhamcrest` are libraries
    that help us write cleaner tests. You looked at how we can integrate our unit
    tests into the wider development process: from putting them into the build environment
    and integrating with continuous integration tools, to enabling the `test` command
    when packaging our code. We then took a look at how we can maintain a package
    against multiple versions of Python and integrating tests into Sphinx so that
    our documentation doesn''t break.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了一些流行的第三方工具，帮助我们改进我们的 TDD 实践。其中一些工具，如 `py.test` 和 `trial`，是具有独特功能的测试运行器。其他如
    `sure` 和 `pyhamcrest` 的工具是库，帮助我们编写更干净的测试。你了解了如何将我们的单元测试集成到更广泛的开发生成过程中：从将它们放入构建环境，与持续集成工具集成，到在打包我们的代码时启用
    `test` 命令。然后我们探讨了如何针对多个 Python 版本维护一个包，以及如何将测试集成到 Sphinx 中，以确保我们的文档不会中断。
- en: Appendix A. Answers to Exercises
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 练习答案
- en: This Appendix contains answers to the exercises presented throughout this book.
    Keep in mind that there is no single correct solution for any of these exercises.
    There are many possible solutions, each with their own advantages and disadvantages.
    Wherever possible, I have mentioned why I took a certain path, so that you can
    see my reasoning and compare the pros and cons with the solution that you have
    come up with.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录包含本书中提出的练习的答案。请记住，对于这些练习中的任何一个，都没有唯一的正确答案。有许多可能的解决方案，每个都有其自身的优缺点。在可能的情况下，我已经提到了我选择某种路径的原因，这样你就可以看到我的推理，并比较你提出的解决方案的优缺点。
- en: Red-Green-Refactor – The TDD Cycle
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红绿重构 – TDD 循环
- en: This exercise asks us to add support for updates which come out of order, that
    is, a newer update is followed by an older update. We need to use the timestamp
    to determine which update is newer and which is older.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习要求我们添加对顺序不正确的更新的支持，即，较新的更新后面跟着较旧的更新。我们需要使用时间戳来确定哪个更新较新，哪个更新较旧。
- en: 'The following is a test case for this requirement:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对此要求的测试用例：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the test above, we first give the update for February 13, followed by the
    update for February 12\. We then assert that the price attribute returns the latest
    price (for February 13). The test fails of course.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的测试中，我们首先给出了2月13日的更新，然后是2月12日的更新。然后我们断言价格属性返回最新的价格（对于2月13日）。当然，测试失败了。
- en: In order to make this test pass, we can't simply add the latest update to the
    end of the `price_history` list. We need to check the timestamp and insert it
    accordingly into the list, keeping it sorted by timestamp.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们不能简单地将最新的更新添加到 `price_history` 列表的末尾。我们需要检查时间戳并相应地将其插入列表中，保持按时间戳排序。
- en: 'The `bisect` module provided in the Python standard library contains the `insort_left`
    function that inserts into a sorted list. We can use this function as follows
    (remember to import bisect at the top of the file):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中提供的 `bisect` 模块包含 `insort_left` 函数，该函数可以将元素插入到有序列表中。我们可以如下使用此函数（记住在文件顶部导入
    bisect）：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to have a sorted list, the `price_history` list needs to keep a list
    of tuples, with the timestamp as the first element. This will keep the list sorted
    by the timestamp. When we make this change, it breaks our other methods that expect
    the list to contain the price alone. We need to modify them as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个有序的列表，`price_history` 列表需要保持一个元组的列表，其中时间戳作为第一个元素。这将使列表按时间戳排序。当我们进行这个更改时，它破坏了其他期望列表只包含价格的方法。我们需要按照以下方式修改它们：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the above changes, all our existing tests as well as the new test start
    passing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 经过上述更改，我们所有的现有测试以及新的测试都开始通过。
- en: 'Now that we have the tests passing, we can look at refactoring the code to
    make it easier to read. Since the `price_history` list now contains tuples, we
    have to refer to the price element by tuple index, leading to statements list
    `price_history[-1][1]`, which are not very clear. We can make this clearer by
    using a named tuple that allows us to assign names to the tuple values. Our refactored
    Stock class now looks like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了通过测试，我们可以看看重构代码以使其更容易阅读。由于 `price_history` 列表现在包含元组，我们必须通过元组索引来引用价格元素，导致语句列表
    `price_history[-1][1]`，这并不太清晰。我们可以通过使用允许我们为元组值分配名称的命名元组来使这更清晰。我们的重构后的 Stock 类现在看起来如下：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the change, we run the tests to ensure that everything still works.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改后，我们运行测试以确保一切仍然正常工作。
- en: Code Smells and Refactoring
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码异味和重构
- en: This exercise asks us to refactor the `Stock` class and extract all the moving
    average related calculations into a new class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习要求我们重构 `Stock` 类，并将所有与移动平均相关的计算提取到一个新的类中。
- en: 'The following is the code that we start with:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们开始时的代码：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, there are a number of calculations relating to identifying the
    moving average window and then calculating the moving average value. These calculations
    really deserve to be in their own class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有许多与识别移动平均窗口和计算移动平均值相关的计算。这些计算真的值得放在它们自己的类中。
- en: 'To start with, we create an empty `MovingAverage` class as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个空的 `MovingAverage` 类，如下所示：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we need to make a design decision on how we want this class to be used.
    Let us decide that the class should take an underlying timeseries and should be
    able to compute the moving average at any point based on that timeseries. With
    this design, the class needs to take the timeseries and the duration of the moving
    average as parameters, as shown in the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做出设计决策，决定我们希望这个类如何被使用。让我们决定这个类应该接受一个基础的时间序列，并且应该能够根据该时间序列在任何一点计算移动平均。根据这个设计，这个类需要接受时间序列和移动平均的持续时间作为参数，如下所示：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now extract the moving average calculation into this class as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将移动平均计算提取到这个类中，如下所示：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the same moving average calculation code from `Stock.get_signal_crossover`.
    The only notable point is that an exception is raised if there is not enough data
    to perform the calculation. Let us define this exception in the `timeseries.py`
    file as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`Stock.get_signal_crossover`中相同的移动平均计算代码。唯一值得注意的是，如果数据不足以进行计算，则会引发异常。让我们在`timeseries.py`文件中定义此异常，如下所示：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now use this method in `Stock.get_signal_crossover` as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`Stock.get_signal_crossover`中使用此方法，如下所示：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the tests, and all 21 tests should pass.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，所有21个测试应该通过。
- en: 'Once we extract the calculation to a class, we find that the temporary variables
    that we created during *Replace Calculation with Temporary Variable* section in
    [Chapter 3](ch03.html "Chapter 3. Code Smells and Refactoring"), *Code Smells
    and Refactoring* are not really required. The code is equally self-explanatory
    without them, so we can now get rid of them, as shown in the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将计算提取到类中，我们会发现，在[第3章](ch03.html "第3章。代码异味和重构")的“用临时变量替换计算”部分中创建的临时变量实际上并不是必需的。没有它们，代码同样具有自解释性，因此我们现在可以去掉它们，如下所示：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A final cleanup: now that we have moving average classes, we can replace the
    parameters to the `_is_crossover_below_to_above` method to take the moving average
    class instead of the individual values. The method now becomes as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的清理：现在我们有了移动平均类，我们可以将`_is_crossover_below_to_above`方法的参数替换为移动平均类，而不是单个值。现在该方法如下所示：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And we can change the `get_crossover_signal` method to call this with the new
    parameters as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`get_crossover_signal`方法修改为使用以下新参数调用：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this, our Extract Class refactoring is complete.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的提取类重构就完成了。
- en: The `get_crossover_signal` class is now extremely easy to read and understand.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_crossover_signal`类现在非常易于阅读和理解。'
- en: Notice how the design for the `MovingAverage` class builds on top of the `TimeSeries`
    class that we extracted earlier. As we refactor code and extract classes, we often
    find that the many classes get reused in other contexts. This is the advantage
    of having small classes with a single responsibility.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`MovingAverage`类的设计是如何建立在之前提取的`TimeSeries`类之上的。当我们重构代码并提取类时，我们经常发现许多类在其他上下文中被重复使用。这是拥有具有单一职责的小类的好处。
- en: The refactoring into a separate class also allowed us to remove the temporary
    variables that we had created earlier, and made the parameters for the crossover
    condition much simpler. Again, these are side effects of having small classes
    with single responsibilities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将重构到单独的类还允许我们删除之前创建的临时变量，并使交叉条件参数变得更加简单。再次强调，这些都是拥有具有单一职责的小类的副作用。
- en: Appendix B. Working with Older Python Versions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B.处理旧版Python版本
- en: This book has been written for Python 3.4\. The version of `unittest` that comes
    with the Python 2.x standard library is an older version that doesn't support
    all the features that we discussed in this book. Additionally, the `mock` library
    was only made a part of the standard library from Python 3.3 onward.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是为Python 3.4编写的。Python 2.x标准库中包含的`unittest`版本是一个较旧的版本，它不支持本书中讨论的所有功能。此外，`mock`库直到Python
    3.3才开始成为标准库的一部分。
- en: 'Fortunately, all the features present in the newer versions of Python have
    been backported under the `unittest2` library. We can install this version from
    PyPi with the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python新版本中所有现有的功能都已经通过`unittest2`库回滚。我们可以使用以下命令从PyPi安装此版本：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once installed, we have to use the `unittest2` library in all references like
    the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们必须在所有如下引用中使用`unittest2`库：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With these changes, we will be able to use all the features that we have been
    discussing in this book in all versions from Python 2.5 onward.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改，我们将能够使用本书中讨论的所有功能，从Python 2.5版本开始的所有版本。
- en: 'The same goes for the mocking library as well. The `mock` library was only
    added to the standard library with Python 3.3\. The current mock library has been
    backported and is also available from PyPi. We can install it with the following
    command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于mock库也是如此。`mock`库是在Python 3.3中添加到标准库的。当前的mock库已经回滚，并且可以从PyPi获取。我们可以使用以下命令安装它：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And we import it with the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令来导入它：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can then use all the mocking goodness discussed in this book with earlier
    versions of Python as well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用本书中讨论的所有mock功能，以及Python的早期版本。
- en: Writing code that is compatible across versions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写跨版本兼容的代码
- en: Many Python modules these days are designed to run under multiple Python versions,
    especially supporting Python 2.x as well as Python 3.x versions. We will want
    to run the same tests in both versions, and to do this, we will need to write
    our code in such a way that the tests are compatible with both the versions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多Python模块被设计为在多个Python版本下运行，特别是同时支持Python 2.x和Python 3.x版本。我们希望在两个版本中都运行相同的测试，为此，我们需要以使测试与两个版本兼容的方式编写我们的代码。
- en: 'Python''s import mechanism gives us the flexibility we need to do this. At
    the top of the file, we import `unittest` like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Python的导入机制为我们提供了执行此操作的灵活性。在文件顶部，我们像以下这样导入`unittest`：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What this does is to first try and import `unittest2`. If we are running Python
    2.x, then we should have installed this already. If it succeeds, then the module
    is imported and the module reference is renamed to `unittest`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的首先是尝试导入`unittest2`。如果我们正在运行Python 2.x，那么我们应该已经安装了它。如果成功，则模块被导入，模块引用被重命名为`unittest`。
- en: If we get an `ImportError`, then we are running Python 3.x, in which case we
    can import the `unittest` module bundled in the standard library.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到`ImportError`，则表示我们正在运行Python 3.x，在这种情况下，我们可以导入标准库中捆绑的`unittest`模块。
- en: Later in the code, we can just reference the `unittest` module and it will work
    normally.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的后续部分，我们只需引用`unittest`模块，它就会正常工作。
- en: This mechanism depends on the `unittest2` module being always installed when
    using Python 2.x version. This is easily achieved by putting the `unittest2` module
    as a dependency for only Python 2.x in our pip requirements file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制依赖于在Python 2.x版本中使用时始终安装`unittest2`模块。这可以通过将`unittest2`模块作为pip需求文件中仅针对Python
    2.x的依赖项来实现。
- en: 'A similar approach works for mocks as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模拟，可以使用类似的方法：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we first try to import the `mock` library provided as a part of the `unittest`
    standard library module. This is available in Python 3.3 onward. If the import
    succeeds, then the mock library is imported. If it fails, it means that we are
    running an older Python version, so we directly import the `mock` library that
    we installed from PyPi.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先尝试导入作为`unittest`标准库模块一部分提供的`mock`库。这从Python 3.3版本开始可用。如果导入成功，则表示已成功导入`mock`库。如果失败，则意味着我们正在运行较旧的Python版本，因此我们直接导入从PyPi安装的`mock`库。
- en: Note how we use the line `from unittest import mock` instead of `import unittest.mock`.
    This is so that we end up with the same module reference name in both the cases.
    Once the import is done, we can reference the `mock` module in our code and it
    will work across Python versions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`from unittest import mock`这一行，而不是`import unittest.mock`。这样做是为了确保在两种情况下模块引用名称相同。一旦完成导入，我们就可以在我们的代码中引用`mock`模块，并且它将在Python各个版本中正常工作。
- en: Running tests from the command line
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行运行测试
- en: 'Throughout the book, we have used the following syntax to run our tests:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用了以下语法来运行我们的测试：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The ability to directly run a module with the `-m` flag was only introduced
    with Python 2.7\. This syntax will not work if we are using an older version of
    Python. Instead, the `unittest2` module from PyPi contains a `unit2` script that
    mimics this behavior. The command line parameters remain the same, so we get the
    following the command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用`-m`标志直接运行模块的功能是在Python 2.7中引入的。如果我们使用的是较旧的Python版本，则此语法将不起作用。相反，PyPi中的`unittest2`模块包含一个`unit2`脚本，它模拟了这种行为。命令行参数保持不变，因此我们得到以下命令：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And the above command now becomes:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令现在变为：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we use a build tool, it becomes fairly simple to check the version of Python
    and execute the appropriate command, thereby allowing the developer to run the
    tests in a uniform way, irrespective of the Python version being used.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用构建工具，检查Python版本并执行适当的命令就变得相当简单，从而允许开发者以统一的方式运行测试，无论使用的是哪个Python版本。
- en: With these changes in place, we will be able to use all the features described
    in this book, while being able to support Python 2.x and Python 3.x uniformly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，我们将能够使用本书中描述的所有功能，同时能够统一支持Python 2.x和Python 3.x。
- en: Running the examples in this book
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行本书中的示例
- en: The code examples in this book have been written for Python 3.4\. They use some
    syntax that is not available in older versions of Python. Therefore, there are
    a few places we will need to change the code if we want to run the examples in,
    say, Python 2.6.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码示例是为 Python 3.4 编写的。它们使用了在 Python 较旧版本中不可用的某些语法。因此，如果我们想在 Python 2.6 等版本上运行示例，我们需要对代码进行一些更改。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The entire source code with all the changes below is available online at [https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python).
    Get this code if you would like to run the example code in this book under Python
    2.6, 2.7, 3.0, 3.1, 3.2, or 3.3
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有更改的完整源代码可在网上找到，链接为 [https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python)。如果您想在此书中的
    Python 2.6、2.7、3.0、3.1、3.2 或 3.3 版本下运行示例代码，请获取此代码。
- en: 'The following changes are required:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 需要以下更改：
- en: '`Enum`: The `Enum` library is not in the standard library with older Python
    versions. It has been backported and can be installed from PyPi. Install the `Enum34`
    library to use this feature.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enum`：在较老的 Python 版本中，`Enum` 库不是标准库的一部分。它已经被回滚并可以从 PyPi 安装。要使用此功能，请安装 `Enum34`
    库。'
- en: '`set` syntax: Newer versions of Python support the single curly braces shorthand
    syntax to create `set` objects like`{"MSFT"}`. In older versions, we will need
    to explicitly create sets with this equivalent longhand syntax: `set(["MSFT"])`.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` 语法：Python 的新版本支持使用单花括号简写语法创建 `set` 对象，如 `{"MSFT"}`。在较老的版本中，我们需要使用等效的长句语法显式创建集合：`set(["MSFT"])`。'
- en: '`print` statement: `print` is defined as a statement in Python 2.x, so we cannot
    call it as a function, neither can we mock it out. We can get around this by adding
    the line `from __future__ import print_function` to the top of all the files that
    use `print`.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print` 语句：在 Python 2.x 中，`print` 被定义为一条语句，因此我们不能将其作为函数调用，也不能对其进行模拟。我们可以通过在所有使用
    `print` 的文件顶部添加一行 `from __future__ import print_function` 来解决这个问题。'
- en: '`builtins`: The `builtins` module is called `__builtin__` in Python 2.x. Therefore,
    we need to use `__builtin__.print` or `__builtin__.open` when we want to mock
    the `print` or `open` functions.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builtins`：在 Python 2.x 中，`builtins` 模块被称为 `__builtin__`。因此，当我们想要模拟 `print`
    或 `open` 函数时，我们需要使用 `__builtin__.print` 或 `__builtin__.open`。'
- en: '`yield from` expression: This expression is not available in older Python versions.
    It has to be replaced with an iteration.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield from` 表达式：此表达式在较老的 Python 版本中不可用。它必须被替换为迭代。'
- en: '`mock_open`: This mock helper only mocks the `read` method in the backported
    version. It doesn''t support mocking iteration on the file object. So, we need
    to change the implementation to not use iteration.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock_open`：此模拟辅助函数仅在回滚版本中模拟 `read` 方法。它不支持在文件对象上模拟迭代。因此，我们需要更改实现，使其不使用迭代。'
- en: With these changes, the examples in this book will work on Python 2.6 onward.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，本书中的示例将能在 Python 2.6 及以上版本上运行。
