- en: Chapter 8. Working with File Input/Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。处理文件输入/输出
- en: 'In this chapter, we''ll be looking at ways to get custom data in and out of
    Maya via scripting:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨通过脚本将自定义数据导入和导出Maya的方法：
- en: Using the fileDialog2 command to navigate the file system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fileDialog2命令导航文件系统
- en: Reading text files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文本文件
- en: Writing text files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入文本文件
- en: Writing binary data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入二进制数据
- en: Reading binary data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取二进制数据
- en: Reading multiple types of files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取多种类型的文件
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Although Maya is an incredibly powerful tool, it's almost always just one step
    in a larger toolchain. Whether you're using Maya to create prerendered animation
    for film and video or creating assets for use in real-time applications, you'll
    generally always need to interface Maya or the content you create within it, with
    other applications. Very often, this takes the form of either reading or writing
    data of a specific format.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Maya是一个非常强大的工具，但它几乎总是更大工具链中的一步。无论你是使用Maya为电影和视频创建预渲染动画，还是创建用于实时应用的资产，你通常都需要将Maya或其中创建的内容与其他应用程序接口。这通常表现为读取或写入特定格式的数据。
- en: In this chapter, we'll be looking at how to work with custom data formats, both
    text-based and binary, and to both read and write data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何处理自定义数据格式，包括基于文本和二进制的数据，以及读取和写入数据。
- en: Using the fileDialog2 command to navigate the file system
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fileDialog2命令导航文件系统
- en: Loading and saving files will almost always require prompting the user for a
    file location. In this example, we'll look at how to do that. We'll also see how
    to work with directories, including creating new ones.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和保存文件几乎总是需要提示用户文件位置。在本例中，我们将探讨如何做到这一点。我们还将了解如何处理目录，包括创建新的目录。
- en: We'll create a script that will allow the user to browse the files in a `customData`
    folder within the current project directory. If that folder doesn't exist, it
    will be created the first time the script is run.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，允许用户浏览当前项目目录中的`customData`文件夹中的文件。如果该文件夹不存在，则在脚本第一次运行时创建它。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file and add the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll be presented with a file browser dialog. And, while the dialog won't
    actually do anything just yet, if you check your project directory, you'll find
    that it now contains a folder named `customData`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个文件浏览器对话框。虽然对话框目前实际上不会做任何事情，但如果你检查你的项目目录，你会发现它现在包含一个名为`customData`的文件夹。
- en: How it works...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing to note about this script is that we add an additional import
    statement to the start of the script:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个脚本的第一点是我们在脚本开始处添加了一个额外的导入语句：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The os library (short for "operating system") offers a variety of functionality
    related to the operating system of the host machine, including the ability to
    work with directories. We'll be using both to check to see whether a directory
    exists and to create it if it doesn't exist. More on this will be explained later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: os库（简称"操作系统"）提供了与宿主机的操作系统相关的各种功能，包括处理目录的能力。我们将使用它来检查目录是否存在，如果不存在则创建它。关于这方面的更多内容将在后面进行解释。
- en: For this script, we'll want to start by finding out what the current project
    directory is. For that, we can use the `internalVar` command. The `internalVar`
    command can be used to get access to various directories related to the current
    user's environment. It cannot be used to set any of those directories, only to
    query them. However, note that we don't actually use it in the query mode (Maya's
    commands aren't always the most consistent). Instead, we set the value of the
    flag we want the value of to true.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们首先需要找出当前的项目目录。为此，我们可以使用`internalVar`命令。`internalVar`命令可以用来访问与当前用户环境相关的各种目录。它不能用来设置这些目录，只能用来查询它们。然而，请注意，我们实际上并没有在查询模式下使用它（Maya的命令并不总是最一致的）。相反，我们将我们想要获取值的标志的值设置为true。
- en: 'In this case, we''re asking for the `userWorkspaceDir`, which will provide
    us with the current project directory:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们请求`userWorkspaceDir`，这将为我们提供当前项目目录：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we want to test to see if there''s the `customData` folder within the
    current workspace. To do this, we''ll start by creating the full path to that
    directory (if it exists) by adding "customData" to the value that `internalVar`
    returned. We *could* do it with string manipulation, but that gets a bit tricky,
    since different platforms can use different characters to indicate separations
    between directories. Linux-based platforms (including Macintosh) use "/", whereas
    Windows machines use "\". A safer (and therefore better) way to go about it is
    to use Python''s `os.path.join` method, which is guaranteed to be safe, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要测试当前工作空间内是否存在`customData`文件夹。为此，我们将首先创建该目录的完整路径（如果它存在），通过将"customData"添加到`internalVar`返回的值中来实现。我们*可以*通过字符串操作来完成它，但这有点复杂，因为不同的平台可以使用不同的字符来表示目录之间的分隔符。基于Linux的平台（包括Macintosh）使用"/"，而Windows机器使用"\"。一个更安全（因此更好的）方法是使用Python的`os.path.join`方法，它保证是安全的，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we have the full path to the `customData` folder, but it might not actually
    exist. We can use another function from `os.path`, `os.path.exists`, to check
    that, and to create it if it doesn''t:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`customData`文件夹的完整路径，但它可能实际上并不存在。我们可以使用`os.path`模块中的另一个函数`os.path.exists`来检查它是否存在，如果不存在则创建它：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we find that the path, in fact, does not exist, we use `os.makedirs` to
    create it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现路径实际上不存在，我们使用`os.makedirs`来创建它：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, we can finally invoke the `fileDialog2` command to present the
    user with a file browser dialog. In order to make sure that it starts out in the
    `customData` directory, we set the `startingDirectory` flag to our `newDir` variable:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们终于可以调用`fileDialog2`命令来向用户展示一个文件浏览器对话框。为了确保它从`customData`目录开始，我们将`startingDirectory`标志设置为`newDir`变量：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that we use `fileDialog2`, which might look a bit odd. There is also a
    `fileDialog` command, but it's deprecated (along with the `fileBrowserDialog`
    command). As a result, we're left needing to use the somewhat awkwardly named
    `fileDialog2`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的是`fileDialog2`，它可能看起来有点奇怪。还有一个`fileDialog`命令，但它已被弃用（连同`fileBrowserDialog`命令）。因此，我们不得不使用这个有些不雅的名称`fileDialog2`。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `fileDialog2` command has a number of other options that we'll see in later
    examples. The `internalVar` command also has a number of additional locations
    that it can provide. One that is often useful is the `userScriptDir` option, which
    will provide the user's script directory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileDialog2`命令还有许多其他选项，我们将在后面的例子中看到。`internalVar`命令也有许多其他可以提供的位置。其中一个经常有用的选项是`userScriptDir`，它将提供用户的脚本目录。'
- en: 'If you wanted to get a list of all of the scripts currently in the user''s
    script directory, for example, you could use the following snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要获取用户脚本目录中当前所有脚本的列表，例如，你可以使用以下代码片段：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `os.listdir` command will provide an array of all the files in a given directory.
    In this case, we might want to create GUI with a button for each script, providing
    an easy way for users to select and run scripts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.listdir`命令将提供一个给定目录中所有文件的数组。在这种情况下，我们可能想要创建一个GUI，为每个脚本提供一个按钮，为用户提供一个方便的方式来选择和运行脚本。'
- en: Reading text files
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文本文件
- en: In this example, we'll be reading a text file and using the contents to create
    some geometry in our scene.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将读取一个文本文件，并使用其内容在我们的场景中创建一些几何形状。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to do any kind of file input/output, the first thing you''ll need
    to do is to understand the file format that you''re wanting to read (or create).
    In both this example and the one involving writing to text files, we''ll be using
    an example file format—the "foo" file. "Foo" files are text-based files, and each
    line represents a geometric primitive of a given type, at a given location. The
    type of geometric primitive is represented by a three-letter string, with "spr"
    meaning a sphere and "cub" meaning a cube. The type string is then followed by
    three numbers representing the X, Y, and Z position of the item. So, an example
    `.foo` file might look something like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行任何类型的文件输入/输出，你首先需要了解你想要读取（或创建）的文件格式。在这个例子以及涉及写入文本文件的例子中，我们将使用一个示例文件格式——“foo”文件。“Foo”文件是基于文本的文件，每一行代表一个给定类型的几何原语，位于给定位置。几何原语类型由一个三字母字符串表示，其中“spr”表示球体，“cub”表示立方体。类型字符串后面跟着三个数字，分别代表项目的X、Y和Z位置。因此，一个示例`.foo`文件可能看起来像以下这样：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Although this is certainly not a particularly useful format, it shares similarities
    with many common text-based formats. The OBJ format, for example, is a common
    standard for 3D models that uses a similar approach—each line consists of an identifier
    for the type of information it holds, followed by details on that entry. For example,
    a line indicating that there is a vertex located at 2, 3, and 4 would look like
    the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这肯定不是一个特别有用的格式，但它与许多常见的基于文本的格式有相似之处。例如，OBJ 格式是一个常见的 3D 模型标准，它使用类似的方法——每一行都包含一个标识符，表示它所包含的信息类型，后面跟着该条目的详细信息。例如，表示有一个位于
    2、3 和 4 的顶点的行看起来如下：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, our "foo" files, while intentionally very simple, will be read and processed
    in much the same way as many *real* file formats.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的“foo”文件，虽然故意设计得非常简单，但将以与许多 *真实* 文件格式相同的方式进行读取和处理。
- en: 'Before you run the script for this example, make sure that you''ve created
    a `.foo` file. To do that, create a new text file and add some number of lines
    that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此示例的脚本之前，请确保你已经创建了一个 `.foo` 文件。为此，创建一个新的文本文件并添加一些行，这些行：
- en: Begin with either "spr" (for sphere) or "cub" (for cube)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 "spr"（代表球体）或 "cub"（代表立方体）开始
- en: Are followed with three numbers (for X, Y, and Z positions), each separated
    by a space
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后面跟着三个数字（代表 X、Y 和 Z 位置），每个数字之间用空格分隔
- en: Be sure to save the file as a `.foo` file, rather than `.txt`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将文件保存为 `.foo` 文件，而不是 `.txt` 文件。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file and add the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the file, and you will be presented with a file dialog that will let you
    find a `.foo` file. Once you specify a file with valid FOO file data, you should
    see some number of spheres and cubes created.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行文件，你将看到一个文件对话框，允许你找到 `.foo` 文件。一旦指定了一个包含有效 FOO 文件数据的文件，你应该会看到一些球体和立方体被创建。
- en: '![How to do it...](img/4657_08_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/4657_08_01.jpg)'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing we do in the script is to invoke the `fileDialog2` command
    in order to let the user specify a file. We set the `fileMode` flag to 1 to indicate
    that we want to read (rather than write) a file. We also make use of the `fileFilter`
    flag in order to point the user at our custom file format. This is totally optional,
    but it can be a nice way to prevent the user from giving you the wrong kind of
    data. To do that, we''ll want to provide Maya with two things:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们首先调用 `fileDialog2` 命令，以便让用户指定一个文件。我们将 `fileMode` 标志设置为 1，表示我们想要读取（而不是写入）文件。我们还使用了
    `fileFilter` 标志，以便将用户指向我们的自定义文件格式。这是完全可选的，但它可以是一种防止用户给你错误类型数据的好方法。为此，我们需要向 Maya
    提供两样东西：
- en: A short description of the file type to show the user, and
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简短的文件类型描述，以显示给用户，以及
- en: One or more file extensions, with a wildcard character ("*")
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个文件扩展名，后面跟着一个通配符字符（"*"）
- en: 'So in this case, we''ll want to limit the user to "FOO files", and we''ll identify
    those as anything that ends in either `.foo` or `.fo`. The final value of the
    string to pass in looks like:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，我们希望限制用户只能打开“FOO”文件，并将这些文件识别为以 `.foo` 或 `.fo` 结尾的任何内容。要传递的字符串的最终值如下：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we could also allow the user to open other kinds of files as well,
    by separating the strings for each with a double semicolon. Let''s say that we
    wanted to allow the user to open text (`.txt`) files as well. For that, our call
    to `fileDialog2` would look like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也可以允许用户打开其他类型的文件，通过用双分号分隔每个字符串来实现。假设我们想要允许用户打开文本（`.txt`）文件。为此，我们的 `fileDialog2`
    调用将如下所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you allow the user to open files of more than one type, each type will be
    available in the dropdown in the bottom of the file dialog. By selecting an option
    from the dropdown, the user can change which types of files the dialog will accept.
    Now that we've covered specifying the file type, let's go back to our regularly
    scheduled example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你允许用户打开多种类型的文件，每种类型都会在文件对话框底部的下拉菜单中可用。通过从下拉菜单中选择一个选项，用户可以更改对话框将接受的文件类型。现在我们已经涵盖了指定文件类型，让我们回到我们的常规示例。
- en: 'We store the output of the `fileDialog` to a variable. We also check to make
    sure that the variable is not None before proceeding. This way, we''ll ensure
    that we don''t proceed with the script if the user has clicked on the "cancel"
    button:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `fileDialog` 的输出存储到一个变量中。在继续之前，我们还会检查该变量是否不为空。这样，我们就能确保如果用户点击了“取消”按钮，我们不会继续执行脚本：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we''re ready to actually open the file. To do it, we use Python''s `open`
    command, with the first argument being the full path to the file we want to open,
    and the second argument indicating the mode to open the file in, with `"r"` meaning
    "read":'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备实际打开文件。为了做到这一点，我们使用Python的`open`命令，第一个参数是我们想要打开的文件的完整路径，第二个参数指示以何种模式打开文件，其中`"r"`表示“读取”：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that `filePath` is an array, so we'll need to feed in the first element
    into the open command. The return value of open, which we store in our `fileRef`
    variable, is a reference to the file that we can use to read in data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`filePath`是一个数组，因此我们需要将第一个元素传递给open命令。open的返回值，我们将其存储在`fileRef`变量中，是对文件的引用，我们可以用它来读取数据。
- en: 'For most types of text-based files (with FOO files being no exception), we''ll
    want to read the file in line by line. We''ll start by reading a single line from
    our file reference:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数基于文本的文件类型（FOO文件也不例外），我们希望逐行读取文件。我们首先从文件引用中读取一行：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we''ve done that, we want to:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做了这些，我们想要：
- en: Process the information in the line we just read
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理我们刚刚读取的行中的信息
- en: Read the next line from the file
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取下一行
- en: Continue until we've read the entire file
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续读取直到我们阅读完整个文件
- en: 'That''s easily done with a while loop. The processing will be handled by a
    separate function, which we''ll get to next:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个while循环轻松完成。处理将由一个单独的函数来处理，我们将在下一部分看到：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we get to the end of the file, our line variable will be empty, and the
    while loop will terminate. The last thing we do is a bit of housekeeping, that
    is, we close the reference to the file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达文件的末尾，我们的行变量将为空，while循环将终止。我们最后要做的事情是做一些清理工作，即关闭对文件的引用：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s take a closer look at how we process the data, in our `processFooLine`
    function. We start off by breaking the line up into parts, using Python''s `split`
    function. That will take the input string and break it up into an array of strings,
    separated (by default) based on whitespaces:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看我们如何在`processFooLine`函数中处理数据。我们首先使用Python的`split`函数将行拆分成部分。这将把输入字符串拆分成一个字符串数组，默认情况下是根据空白字符分隔的：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because our FOO file specification states that each line should be a short
    string, followed by three numbers, we throw an error if our parts array has fewer
    than four entries. If it does have at least four, we convert the second, third,
    and fourth entries to floats and store them into variables for the *x*, *y*, and
    *z* position:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的FOO文件规范指出，每一行应该是一个简短的字符串，后面跟着三个数字，所以如果我们的部分数组少于四个条目，我们会抛出一个错误。如果它至少有四个条目，我们将第二个、第三个和第四个条目转换为浮点数并将它们存储到变量中，用于*x*、*y*和*z*位置：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we create the object, either a sphere or a cube based on the first entry
    in the parts array:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们根据部件数组中的第一个条目创建对象，要么是一个球体，要么是一个立方体：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we move the object we just created to the position indicated in our
    `x`, `y`, and `z` variables:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们刚刚创建的对象移动到我们的`x`、`y`和`z`变量所指示的位置：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although the FOO format specification is intentionally simplistic, we could
    easily extend it to store more information or possibly optional information. For
    example, we might also have an optional fifth entry to indicate the size of the
    object to be created (for example, face width for cubes and radius for spheres).
    If you would like to see what a format that is superficially similar to FOO files,
    but more useful, looks like, I encourage you to take a look at the OBJ file format.
    Not only is it widely used in 3D, but it's also a relatively simple format to
    understand and as such is a great introduction to file parsing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管FOO格式规范有意简化，但我们很容易扩展它来存储更多信息或可能的可选信息。例如，我们可能还有一个可选的第五项来指示要创建的对象的大小（例如，立方体的面宽和球体的半径）。如果您想看看一个表面上类似于FOO文件但更有用的格式，我鼓励您查看OBJ文件格式。它不仅在3D中广泛使用，而且相对简单易懂，因此是文件解析的绝佳入门。
- en: Writing text files
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写文本文件
- en: In the previous example, we looked at how to read a custom data file format
    and use it to create geometry in a scene. In this example, we'll do the inverse,
    in that we'll examine our scene for polygonal cubes and NURBS spheres, and write
    the position of each one we find out to a new FOO file. In the process, we'll
    see how to write data to custom text-based formats.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们探讨了如何读取自定义数据文件格式并使用它来创建场景中的几何形状。在这个例子中，我们将做相反的事情，即检查我们的场景中的多边形立方体和NURBS球体，并将我们找到的每个对象的坐标写入一个新的FOO文件。在这个过程中，我们将看到如何将数据写入自定义文本格式。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before running this example, make sure that you have a scene with some number
    of (NURBS) spheres and polygonal cubes in it. Make sure that you create the cubes
    and spheres with construction history enabled, otherwise our script won't be able
    to correctly identify the geometry.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此示例之前，请确保场景中包含一些（NURBS）球体和多边形立方体。请确保创建的立方体和球体启用了构建历史，否则我们的脚本将无法正确识别几何形状。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new file and add the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start off by prompting the user to specify a file. As in the file reading
    example, we set the `fileFilter` flag so that the dialog is limited to .foo files.
    This time, though, we set the `fileMode` flag to 0 to indicate that we want to
    write a file (instead of a value of 1, indicating reading):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提示用户指定一个文件。与文件读取示例一样，我们设置 `fileFilter` 标志，以便对话框仅限于 .foo 文件。不过，这次我们将 `fileMode`
    标志设置为 0，表示我们想要写入文件（而不是值为 1，表示读取）：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the result of the `fileDialog2` command is empty (indicating that the user
    canceled), we stop. Otherwise, we continue with the script and open the specified
    file for writing. Again, note that the `fileDialog2` command returned an array,
    meaning that we need to pass in its first entry to the open command. We also set
    the second argument to `"w"`, indicating that we want to write to the file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `fileDialog2` 命令的结果为空（表示用户取消了），我们停止。否则，我们继续执行脚本并打开指定的文件进行写入。再次注意，`fileDialog2`
    命令返回了一个数组，这意味着我们需要将其第一个条目传递给 open 命令。我们还设置了第二个参数为 `"w"`，表示我们想要写入文件：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we need to find all of the cubes and spheres in our scene. To do that,
    we start off by getting all of the transform nodes in the scene.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找到场景中的所有立方体和球体。为此，我们首先获取场景中的所有变换节点。
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For each object, we want to find out if it's a sphere or a cube. One way to
    do it is to examine the construction history of the object and see if there's
    a `makeNurbSphere` or `polyCube` node. To keep things nice and neat, we'll wrap
    that in a separate function, `checkHistory`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个对象，我们想知道它是否是球体或立方体。一种方法是通过检查对象的构建历史，看看是否有 `makeNurbSphere` 或 `polyCube`
    节点。为了保持事情整洁有序，我们将它封装在一个单独的函数 `checkHistory` 中。
- en: 'To get the history for a given object, we can use the `listHistory` command,
    which will give us the construction history as an array:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取给定对象的 历史，我们可以使用 `listHistory` 命令，它将以数组的形式返回构建历史：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we''ve done that, we''re ready to run through the history and see if we
    can find the geometry that we''re looking for. But first, we set up a variable
    to hold the geometry type and initialize it to an empty string:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个，我们就准备好遍历历史记录，看看我们是否能找到我们正在寻找的几何形状。但首先，我们设置一个变量来保存几何类型，并将其初始化为空字符串：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the object in question *is* one of the types we're looking for, it will have
    either the `makeNurbSphere` or `polyCube` node in its history. However, in either
    case, the node will have a number at the end of its name. So, we'll need to use
    Python's `startswith` command to perform the check, instead of just testing for
    direct equality.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所讨论的对象确实是我们要寻找的类型之一，它在其历史记录中将有 `makeNurbSphere` 或 `polyCube` 节点。然而，在两种情况下，节点名称的末尾都将有一个数字。因此，我们需要使用
    Python 的 `startswith` 命令来进行检查，而不是仅仅测试直接相等。
- en: 'If we find either of the geometry creation nodes we''re looking for, we''ll
    set our `geoType` string to the appropriate abbreviation (based on the FOO file
    format specification):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到了我们正在寻找的几何创建节点之一，我们将我们的 `geoType` 字符串设置为适当的缩写（基于 FOO 文件格式规范）：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we return the `geoType` variable:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回 `geoType` 变量：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The upshot of all that is that we'll have either "spr" or "cub" for the objects
    that we want to export, and an empty string for everything else. With this, we
    can turn our attention back to our main function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的结果是，我们将为想要导出的对象有 "spr" 或 "cub"，而对于其他所有内容则为空字符串。有了这个，我们可以将注意力转回到我们的主函数。
- en: 'Armed with out `checkHistory` function, we''re now ready to loop through all
    of the objects in the scene, testing each one to see if it''s the geometry we''re
    interested in:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 带着我们的 `checkHistory` 函数，我们现在准备好遍历场景中的所有对象，测试每个对象以查看它是否是我们感兴趣的几何形状：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If the value returned from `checkHistory` is *not* an empty string, we know
    that we have something that we want to write out to our file. We already know
    the geometry type, but we still need to get the world-space position. For that,
    we use the `xform` command, in query mode.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`checkHistory`返回的值**不是**空字符串，我们知道我们有一些东西想要写入我们的文件。我们已经知道几何类型，但仍然需要获取世界空间位置。为此，我们使用`xform`命令，以查询模式。
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we''re finally ready to write our data out to our file. We''ll want to
    build up a string with the following format:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好将数据写入我们的文件了。我们需要构建一个具有以下格式的字符串：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ll start by creating a string from the position we received from `xform`.
    The position starts out as an array of floating-point numbers, which we''ll want
    to convert into a single string. This means that we need to do two things:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`xform`接收到的位置创建一个字符串。位置最初是一个浮点数数组，我们需要将其转换成一个单一的字符串。这意味着我们需要做两件事：
- en: Convert the numbers to strings.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字转换为字符串。
- en: Join the strings together into a single string.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串连接成一个单一的字符串。
- en: 'If we have an array of strings, we can join them together using Python''s `join`
    command. The syntax for that is a bit odd, but it''s easy enough to use; we start
    with a string that holds whatever it is that we would like to use as a separator.
    In this case (as in most cases), we''ll want to use a space. We then call join
    on that string, passing in the list of elements that we want to join. So, if the
    position array contained strings, we could do the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个字符串数组，我们可以使用Python的`join`命令将它们连接起来。该命令的语法有点奇怪，但使用起来足够简单；我们从一个字符串开始，该字符串包含我们想要用作分隔符的内容。在这种情况下（以及大多数情况下），我们想要使用一个空格。然后我们调用该字符串上的join，传入我们想要连接的元素列表。所以，如果位置数组包含字符串，我们可以这样做：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, it''s not quite that easy because the position array contains floating-point
    values. So, before we can run join, we need to first convert the numerical values
    to strings. If that''s all we want to do, we could do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事情并不那么简单，因为位置数组包含浮点值。因此，在我们运行join之前，我们需要首先将数值转换为字符串。如果我们只想做这件事，我们可以这样做：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, we use Python's `map` function to apply the first argument
    (the `str` or string function) to each element of the second (the position array).
    That translates the position array into an array of strings, which can then be
    passed to the join function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用Python的`map`函数将第一个参数（`str`或字符串函数）应用于第二个参数（位置数组）的每个元素。这把位置数组转换成了一个字符串数组，然后我们可以将其传递给join函数。
- en: 'However, we may want more control over the formatting of our floats, which
    brings us to the line that we''re actually using, namely:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能想要对浮点数的格式化有更多的控制，这让我们来到了我们实际使用的行，即：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is a bit similar to the map-based example, in that we apply a function
    to the position array before passing the contents into the join function. However,
    in this case, we use the `format` function, which allows us more control over
    the specifics of how floats are formatted. In this case, we're limiting the precision
    of the values to three decimal places.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这与基于map的例子有点相似，我们在将内容传递给join函数之前，先对位置数组应用一个函数。然而，在这种情况下，我们使用`format`函数，这让我们对浮点数格式化的具体细节有更多的控制。在这种情况下，我们限制值的精度为三位小数。
- en: At this point, we have the full position of the object at hand as a string.
    To finish it off, we need to add the geometry type identifier (as specified in
    our FOO file format spec). We'll also want to add a newline (`\n`) character at
    the end, to ensure that each piece of geometry has a separate line for its data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经有了一个字符串，表示当前对象的全位置。为了完成它，我们需要添加几何类型标识符（如我们的FOO文件格式规范中指定）。我们还想在末尾添加一个换行符（`\n`），以确保每条几何数据都有单独的一行。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you open the created file in notepad on a Windows machine, you'll
    see that all of your data appear as a single line. That's because unix-like systems
    (including Mac) use `\n` as the newline character, whereas Windows uses `\r\n`.
    The `\r` is the carriage return character, whereas `\n` is the newline character.
    Using both is a byproduct of the old days when typewriters would perform two actions
    to move to the next line—move the paper all the way to the right (`\r`) and move
    it up (`\n`). If you're working on Windows, you might want to add `\r\n` instead
    of just `\n`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你在Windows机器上的记事本中打开创建的文件，你会看到所有数据都显示为单行。这是因为类Unix系统（包括Mac）使用`\n`作为换行符，而Windows使用`\r\n`。`\r`是回车符，而`\n`是换行符。使用两者是打字机在旧时代移动到下一行时执行两个动作的副产品——将纸张完全移到右边（`\r`）并将其向上移动（`\n`）。如果你在Windows上工作，你可能想添加`\r\n`而不是仅仅`\n`。
- en: 'This gives us the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we''re finally ready to write the data to our file. That''s easily done
    with a call to `write()` on our file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好将数据写入文件了。这可以通过调用我们文件的`write()`方法轻松完成：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once we''ve finished our loop through all the objects and saved out all our
    data, we finish off by closing the file reference:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了对所有对象的循环遍历并保存了所有数据，我们通过关闭文件引用来完成操作：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The example presented in this section may seem a bit artificial, but exporting
    positional data is a fairly common need. Very often, it can be easier for your
    art team to use Maya to position objects that are later used in some programmatic
    way, such as (in the case of games) spawn points or item pickup locations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提供的示例可能看起来有点人为，但导出位置数据是一个相当常见的需求。通常情况下，对于艺术团队来说，使用Maya定位后来以编程方式使用的对象（例如，在游戏的情况下，生成点或物品拾取位置）可能更容易。
- en: In this example, we identified the objects to export by examining their construction
    history. This can work, but it's easily broken if construction history is ever
    deleted. Because deleting history is a common thing to do, it's good to have alternative
    means to identify nodes for export.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过检查它们的构建历史来识别要导出的对象。这可以工作，但如果构建历史被删除，它很容易被破坏。由于删除历史记录是常见的事情，因此拥有识别导出节点的替代方法是个好主意。
- en: One very reliable way to go about it is to add a custom attribute to nodes that
    should be exported and to use that when looping through objects. For example,
    we might be using polygonal cubes to indicate where certain types of item pickups
    are in a game level. To better prepare for exporting the data, we could add a
    `pickupType` attribute to each cube.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常可靠的方法是为应该导出的节点添加自定义属性，并在遍历对象时使用它。例如，我们可能使用多边形立方体来指示游戏关卡中某些类型物品拾取的位置。为了更好地准备导出数据，我们可以在每个立方体上添加一个`pickupType`属性。
- en: 'We could easily wrap that in a nice function to add the attribute and set its
    value, as in the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将它包装在一个漂亮的函数中，以添加属性并设置其值，如下所示：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code would add a keyable `pickupType` attribute to a given object
    and set its value. Note that we check to see whether the `pickupType` attribute
    exists on the node before adding it because adding an attribute that already exists
    will generate an error. To check for the attribute, we first get a list of all
    the user-defined attributes, then test to see if `pickupType` exists in that array.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将为指定的对象添加一个可键控的`pickupType`属性并设置其值。请注意，我们在添加属性之前检查节点上是否存在`pickupType`属性，因为添加已存在的属性将生成错误。为了检查属性，我们首先获取所有用户定义属性的列表，然后测试`pickupType`是否存在于该数组中。
- en: 'When we''re ready to export our data, we can use the same trick to identify
    the objects for which we want to export data. If we wanted to write out data for
    every object that possesses the `pickupType` attribute, we could do the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好导出数据时，我们可以使用同样的技巧来识别我们想要导出数据的对象。如果我们想为具有`pickupType`属性的每个对象写入数据，我们可以这样做：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We start by creating a new list to hold our pickups, then grabbing all of the
    transform nodes in the scene. For each transform, we grab all of the custom attributes
    added to it and check to see whether any of them are named `pickupType`. If that's
    the case, we add the object to our list. Once we've finished with the loop, we
    return the list, for use elsewhere (perhaps to write out their locations).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的列表来保存我们的拾取，然后获取场景中所有的变换节点。对于每个变换，我们获取添加到它上的所有自定义属性，并检查是否有任何属性被命名为`pickupType`。如果是这样，我们将对象添加到我们的列表中。一旦我们完成循环，我们就返回列表，以便在其他地方使用（可能用于写入它们的位置）。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For a quick overview of the FOO file format, be sure to take a look at the previous
    example regarding reading text-based data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FOO文件格式的快速概述，请务必查看有关读取基于文本数据的先前示例。
- en: Writing binary data
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入二进制数据
- en: So far in this chapter, we've looked at reading and writing text-based data
    formats. This will allow you to work with many types of data (and to easily create
    your own formats), but it's only half of the picture. In this example, we'll look
    at the other half-binary formats.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已查看读取和写入基于文本的数据格式。这将允许您处理许多类型的数据（并轻松创建自己的格式），但这只是问题的一半。在本例中，我们将查看另一半——二进制格式。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll be writing out a binary version of our FOO file. We'll
    call such files FOB (foo, binary). As was the case with FOO files, FOB files are
    a scaled-down example of the types of things that are often encountered in real
    formats. FOB files will contain the same data we saw in FOO files, namely a list
    of object types and positions, but stored in a way common to binary formats.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写我们的FOO文件的二进制版本。我们将这样的文件称为FOB（foo，二进制）。与FOO文件一样，FOB文件是真实格式中常见类型的一个简化示例。FOB文件将包含我们在FOO文件中看到的数据，即对象类型和位置的列表，但以二进制格式常见的方式存储。
- en: 'Most binary files consist of two main parts:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数二进制文件由两个主要部分组成：
- en: A header, which is a fixed-size chunk that describes the nature of the rest
    of the document.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题，它是一个固定大小的块，描述了文档其余部分的内容。
- en: Entries that are read according to the data layout specified in the header.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据标题中指定的数据布局读取的条目。
- en: 'In the case of our FOB files, our header will contain the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的FOB文件的情况下，我们的标题将包含以下内容：
- en: An integer (1 byte) that specifies how many characters are used for the geometry
    type specification per entry (our "spr" or "cub").
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数（1字节），指定每个条目用于几何类型指定的字符数（我们的“spr”或“cub”）。
- en: An integer (1 byte) that specifies the maximum number of attributes per object
    (X, Y, and Z position at a minimum, possibly more data).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数（1字节），指定每个对象的最大属性数（至少是X、Y和Z位置，可能还有更多数据）。
- en: An integer (1 byte) that specifies the number of bytes per attribute.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数（1字节），指定每个属性的字节数。
- en: 'So, a specific FOB file might say that we''re using three bytes for the geometry
    type, with a maximum number of four data values (X, Y, Z position and size), each
    of which uses four bytes. This would give us a header like the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个特定的FOB文件可能声明我们使用三个字节来表示几何类型，最大数据值数量为四个（X、Y、Z位置和大小），每个值使用四个字节。这将给我们一个如下所示的标题：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After the header, there would be some number of entries, each of which would
    consist of 19 bytes (3 for the geometry type, plus 4 * 4, or 16 bytes for the
    data).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题之后，将有一些条目，每个条目由19字节组成（3个用于几何类型，加上4 * 4，即16个字节的用于数据）。
- en: Before you run the example, make sure that you have one or more NURBS spheres
    and/or polygonal cubes in your scene and that they were created with construction
    history enabled (the default option).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例之前，请确保您的场景中有一个或多个NURBS球体和/或多边形立方体，并且它们是在启用构造历史记录的情况下创建的（默认选项）。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new file and add the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing to note is that we have an additional import statement at the
    start of the script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们在脚本的开始处有一个额外的导入语句：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `struct` library provides functions that we'll be using to properly format
    data to write to binary. More on that in a bit. Onto the script itself...
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`库提供了我们将用于正确格式化数据以写入二进制的函数。更多内容将在稍后介绍。接下来是脚本本身...'
- en: 'First off, we ask the user to specify a file, just as we''ve done in the previous
    examples. The only difference is that we change the `fileFilter` argument a bit
    to specify files of type "FOO Binary", with a `.fob` extension:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要求用户指定一个文件，就像我们在前面的示例中所做的那样。唯一的区别是我们稍微改变了`fileFilter`参数，以指定具有`.fob`扩展名的“FOO二进制”类型的文件：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We check to make sure that our `filePath` variable has an actual value (that
    the user didn''t cancel out) and stop the script if it doesn''t. We then open
    the file for writing:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查以确保`filePath`变量有一个实际值（用户没有取消），如果没有，则停止脚本。然后我们打开文件进行写入：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we're using `"wb"` instead of `"w"` as an argument to the open command;
    this tells Python that we want to open the file for writing (`"w"`) in binary
    mode (`"b"`).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`"wb"`而不是`"w"`作为open命令的参数；这告诉Python我们想要以二进制模式（`"b"`）打开文件进行写入（`"w"`）。
- en: Now we're ready to start writing to our file. Before we can write any data though,
    we'll need to write the header. In the case of FOB files, all that is three integers—one
    to hold the number of characters for the geometry identifier, one to hold the
    number of data points per object, and one to hold the number of bytes per data
    points.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始写入我们的文件。在我们能够写入任何数据之前，我们需要写入标题。在FOB文件的情况下，所有这些都是三个整数——一个用于存储几何标识符的字符数，一个用于存储每个对象的数据点数，一个用于存储每个数据点的字节数。
- en: 'To actually write the data, we''ll use the pack function of the `struct` library.
    The pack function will create a sequence of bytes containing data of a given format,
    as specified in a format string. The format string is a sequence of characters,
    with each one representing the type of data that is to be written. The characters
    can be any of the following as well as many others:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际写入数据，我们将使用`struct`库的pack函数。pack函数将创建一个包含指定格式的数据的字节序列，该格式由格式字符串指定。格式字符串是一系列字符，其中每个字符代表要写入的数据类型。字符可以是以下任何一种以及许多其他类型：
- en: '| i | integer |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| i | 整数 |'
- en: '| f | float |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| f | 浮点数 |'
- en: '| c | char |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| c | 字符 |'
- en: For a full list, refer to Python's documentation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整列表，请参阅Python的文档。
- en: 'In this case, we''ll want to store three integers, so our format string will
    need to consist of three Is, as in:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望存储三个整数，因此我们的格式字符串需要由三个I组成，如下所示：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We pass the format string into the `struct.pack` function, followed by the
    values we want to encode (in this case, three integers). In this case, we''ll
    want three characters for our geometry identifier length (to accommodate "spr"
    and "cub"), three points of data (the X, Y, and Z positions), and four bytes for
    each piece of data. Putting that all together gives us the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将格式字符串传递给`struct.pack`函数，后面跟着我们想要编码的值（在这种情况下，三个整数）。在这种情况下，我们希望为我们的几何标识符长度保留三个字符（以容纳"spr"和"cub"），三个数据点（X、Y和Z位置），以及每个数据点四个字节。将这些全部放在一起，我们得到以下内容：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once we have the data packed up, we write it to our file with `write`. We wrap
    all of that in a nice function as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将数据打包，我们就使用`write`将其写入我们的文件。我们将所有这些封装在一个漂亮的功能中，如下所示：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we've written our header to the file, we're ready to write the data
    for our objects. We run through the scene and find all of the spheres and cubes
    in exactly the same way that we did in the example on saving text data. For each
    object we find, we write the data to our file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将标题写入文件，我们准备写入我们的对象数据。我们遍历场景，以与示例中保存文本数据相同的方式找到所有球体和立方体。对于我们找到的每个对象，我们将数据写入我们的文件。
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Our `writeObjData` function takes the object itself, the object type string
    (as determined by our `checkHistory` function from the text output example and
    a reference to the file we're writing to.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`writeObjData`函数接受对象本身、对象类型字符串（由我们的`checkHistory`函数从文本输出示例中确定）以及我们正在写入的文件的引用。
- en: 'Within the `writeObjData` function, we start out by grabbing the position of
    the object in world space using the `xform` command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`writeObjData`函数中，我们首先使用`xform`命令获取对象在世界空间中的位置：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We then write the geometry type identifier (either "spr" or "cub") to the file.
    Writing text to binary files is easy—we just write the values directly. This will
    result in a single byte for each character being written to the file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将几何类型标识符（"spr"或"cub"）写入文件。向二进制文件写入文本很容易——我们只需直接写入值。这将导致写入文件中的每个字符都是一个字节。
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we write the position data to the file, once again using the struct.pack
    function. This time, however, we want to write floating-point values, so we use
    three fs as the format string:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次使用`struct.pack`函数将位置数据写入文件。然而，这次我们想要写入浮点值，因此我们使用三个fs作为格式字符串：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Finally, and back in our main function, we close our file, which now contains
    both the header and all of our data.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回到我们的main函数中，我们关闭我们的文件，该文件现在包含标题和所有我们的数据。
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There's more...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We could easily write out more than just position data for each object. If
    we wanted to write out a radius value for each sphere, we would need to do a few
    things, namely:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地写出每个对象除了位置数据之外的数据。如果我们想要为每个球体写出半径值，我们需要做一些事情，即：
- en: Change our header to specify four values per object, instead of just three.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的标题更改为指定每个对象四个值，而不是仅仅三个。
- en: Change the format string passed in to pack to have four fs instead of three.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传递给pack的格式字符串中的三个fs改为四个。
- en: Note that even though a radius value doesn't make sense in the case of a cube,
    we would still need to write *something* in that place in order to ensure that
    each entry occupies the same number of bytes. Since binary files are generally
    processed by reading in a set number of bytes at a time, having a byte width that
    changes from entry to entry would interfere with that.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管在立方体的情况下半径值没有意义，我们仍然需要在那个位置写上*某些东西*，以确保每个条目占用相同数量的字节。由于二进制文件通常通过一次读取一定数量的字节来处理，因此从条目到条目字节宽度发生变化将会干扰这个过程。
- en: If you think that it's a limitation, you're right. Binary formats tend to be
    much stricter than text-based formats, and they are generally only worth it if
    you really need to create very compact files. In general, if you're considering
    creating a custom format, text is almost always going to be a better choice. Reserve
    binary output for situations where you find yourself having to output data to
    an existing format that happens to be binary.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这是一个限制，你是对的。二进制格式通常比基于文本的格式要严格得多，而且只有在你需要创建非常紧凑的文件时才值得。一般来说，如果你在考虑创建自定义格式，文本几乎总是更好的选择。将二进制输出保留在需要将数据输出到现有格式且该格式恰好是二进制的情况。
- en: Reading binary data
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取二进制数据
- en: In this example, we'll look at how to read in binary data. We'll use our same
    example format, the "FOO binary" format, which consists of a header with three
    integers, followed by one or more entries, each of which has a string identifying
    a type of object and three or more numbers indicating its position (and possibly
    additional data).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将查看如何读取二进制数据。我们将使用相同的示例格式，即"FOO二进制"格式，该格式包含一个包含三个整数的头部，后面跟着一个或多个条目，每个条目都有一个标识对象类型的字符串和三个或更多表示其位置的数字（以及可能的其他数据）。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to run this example, you'll need to have a `.fob` file at the ready.
    Creating binary files manually is a bit of a hassle, so I recommend using the
    example explained earlier to generate one for you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个示例，你需要准备好一个`.fob`文件。手动创建二进制文件有点麻烦，所以我建议使用前面解释的示例为你生成一个。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new file and add the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Run the script, point it at a valid .fob file, and you should see some number
    of spheres and/or cubes in your scene.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，指向一个有效的.fob文件，你应该在你的场景中看到一些球体和/或立方体。
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, we''ll also be using the struct library (to unpack our data),
    so we need to make sure that we import it:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们还将使用struct库（来解包我们的数据），因此我们需要确保我们导入了它：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We start out by using the `fileDialog2` command to prompt the user to specify
    a .fob file and exiting the script if nothing was given:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`fileDialog2`命令提示用户指定一个.fob文件，如果没有提供任何内容，则退出脚本：
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If we have a file to open, we open it using the `open` command, passing in
    `"rb"` for the mode (`"r"` for reading and `"b"` for binary):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有文件要打开，我们使用`open`命令打开它，传递`"rb"`作为模式（`"r"`表示读取和`"b"`表示二进制）：
- en: '[PRE57]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once we have the file open, we grab all of the data at once, using the `read`
    function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件打开，我们一次性读取所有数据，使用`read`函数：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This will result in data holding an array of all of the bytes in the file.
    Once we''ve done that, we''re ready to start parsing our content. For each bit
    of data we read, we''ll be doing the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致数据包含文件中所有字节的数组。一旦我们完成这个操作，我们就可以开始解析我们的内容了。对于读取的每份数据，我们将执行以下操作：
- en: Reading some number of bytes from our data variable.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的数据变量中读取一些字节。
- en: Passing the bytes into `struct.unpack`, along with a format string indicating
    what type of data it should be interpreted as.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字节传递给`struct.unpack`，同时传递一个格式字符串，指示它应该解释为哪种类型的数据。
- en: 'The first thing we''ll need to do is to read the file''s header. In the case
    of .fob files, that''s guaranteed to always be exactly 12 bytes—3 integers, at
    4 bytes each. So, we start by reading the first 12 bytes in the data array and
    passing that to `struct.unpack`. The format string we use will be "iii", indicating
    that the bytes should be interpreted as three integers:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要读取文件的头部。在.fob文件的情况下，这保证总是正好12字节——3个整数，每个4字节。因此，我们首先读取数据数组中的前12字节，并将其传递给`struct.unpack`。我们使用的格式字符串将是"iii"，表示字节应该被解释为三个整数：
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output of the `unpack` function is an array containing the data. In this
    case, we have the number of bytes per geometric identifier, the number of data
    points per entry, and the number of bytes per data point. To make things easier
    on ourselves (and the code more readable), we store each element in its own, named
    variable:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpack` 函数的输出是一个包含数据的数组。在这种情况下，我们有几何标识符的每个字节数、每个条目的数据点数以及每个数据点的字节数。为了使事情更容易（并且代码更易于阅读），我们将每个元素存储在其自己的、命名的变量中：'
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once we''ve done that, we do one more thing for the sake of clarity in what
    comes next—we calculate the total number of bytes per entry as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个步骤，为了使接下来的内容更加清晰，我们还会做一件事——按照以下方式计算每个条目所需的字节数：
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once we have that, we can determine the total number of entries in the file
    by dividing the total number of bytes (minus those consumed by the header) by
    the number of bytes per entry:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们可以通过将总字节数（减去头部长度消耗的字节数）除以每个条目的字节数来确定文件中的条目总数：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'There''s one more detail to take care of before we read the data; we''ll want
    to create a format string for use with `struct.unpack`. In the case of `.fob`
    files, everything after the geometric identifier string will be a float, but we
    want to make sure that we take into account the number of entries, as specified
    in the header. So, if we have three entries per object, we''ll want "fff", but
    if we have four, we would want "ffff". Python makes creating a string from a given
    number of repeated characters as easy as multiplying, which gives us the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取数据之前，我们还需要处理一个细节；我们希望创建一个用于 `struct.unpack` 的格式字符串。在 `.fob` 文件的情况下，几何标识符字符串之后的所有内容都将是一个浮点数，但我们需要确保考虑到头中指定的条目数量。因此，如果我们每个对象有三个条目，我们将需要
    "fff"，但如果我们有四个，我们则需要 "ffff"。Python 通过乘法轻松地从给定数量的重复字符创建字符串，这给我们以下结果：
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And with that, we''re done with the prep work and we''re ready to move on to
    actually reading our data. We start with a loop that runs for the number of entries
    that we found earlier:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了准备工作，可以继续实际读取我们的数据。我们从一个循环开始，循环次数为我们之前找到的条目数量：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The math to calculate the indices we'll need to read isn't particularly complicated,
    but it would get confusing, so we use a couple of variables to break it out onto
    separate lines.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 计算所需读取的索引的数学运算并不复杂，但可能会变得混乱，因此我们使用几个变量将它们拆分到单独的行上。
- en: 'The starting byte for each entry is simply the number of entries we''ve read
    so far multiplied by the total length per entry and offset by the length of the
    header. The end index is the start plus the length of the header:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条目的起始字节是到目前为止读取的条目数量乘以每个条目的总长度，然后减去头部长度。结束索引是起始字节加上头部长度：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Reading the geometric identifier is easy, since it''s just text, with each
    byte corresponding to a single letter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 读取几何标识符很容易，因为它只是文本，每个字节对应一个字母：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now we set out start and end variables to new values to read the position (and
    possibly other) data. We set the start to the previous value of end. This works,
    because when reading a range of indices from a Python array, the values read start
    at the first number and read up to (but not including) the second.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将起始和结束变量设置为新的值来读取位置（以及可能的其他）数据。我们将起始设置为结束的前一个值。这是因为当从 Python 数组中读取一系列索引时，读取的值从第一个数字开始，读取到（但不包括）第二个数字。
- en: 'The ending index for the data is the start plus the total number of bytes for
    the data (`numData * bytesPerData`):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的结束索引是起始字节加上数据的总字节数（`numData * bytesPerData`）：
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And with this, we can finally read our object''s data. We index into our data
    array and pass the result to `struct.unpack`, along with our previously created
    format string (`dataStr`):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有了这个，我们最终可以读取我们对象的 数据。我们在数据数组中进行索引，并将结果传递给 `struct.unpack`，同时附带我们之前创建的格式字符串（`dataStr`）：
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Once we have both the geometry type (`geoType`) and the position (`pos`), we
    pass both into a function to actually create the geometry we want:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了几何类型（`geoType`）和位置（`pos`），我们就将两者传递到一个函数中，以实际创建我们想要的几何形状：
- en: '[PRE69]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `makeObject` function is pretty straightforward—we use the `geoType` argument
    to create one of two possible objects and, if that worked, we move the created
    object to the position given in the `pos` array:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeObject` 函数相当直接——我们使用 `geoType` 参数创建两种可能的对象之一，如果成功，我们将创建的对象移动到 `pos` 数组中指定的位置：'
- en: '[PRE70]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Till now, we''ve only read (or written) binary data of a single type, such
    as integers (for our header) and floats (for the data). The `struct.pack` and
    `struct.unpack` functions can also be used with mixed types, as long as you use
    the proper format string. For example, if we knew that our header contained three
    floats and one integer, we could use the following to read it in:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只读取（或写入）了单一类型的二进制数据，例如整数（用于我们的标题）和浮点数（用于数据）。`struct.pack`和`struct.unpack`函数也可以与混合类型一起使用，只要你使用正确的格式字符串。例如，如果我们知道我们的标题包含三个浮点数和一个整数，我们可以使用以下代码来读取它：
- en: '[PRE71]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that the preceding code uses 0 and 16 as the start and end indices, which
    might seem like we're grabbing 17 bytes. However, Python interprets ranges as
    from the start up to (but not including) the second. So, what we're really saying
    is to use indices from 0 to (16-1), or 15.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码使用0和16作为起始和结束索引，这可能会让人觉得我们在抓取17个字节。然而，Python将范围解释为从开始到（但不包括）第二个。所以，我们真正说的是使用从0到（16-1），即15的索引。
- en: Reading multiple types of files
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取多种类型的文件
- en: Sometimes, you might want to have a single script that is capable of reading
    in multiple file types. For example, if you were building a complex system to
    build character rigs, you might want to have one custom format that holds information
    about default bone layouts and another type that stores information about animation
    settings, allowing the user to mix and match any two files.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要一个能够读取多种文件类型的单一脚本。例如，如果你正在构建一个复杂的系统来构建角色骨架，你可能希望有一个自定义格式来保存默认骨骼布局的信息，另一个类型来存储动画设置的信息，使用户能够混合和匹配任意两个文件。
- en: In such cases, you might want your script to handle files with multiple extensions—one
    for each type of data. In this example, we'll look at how to do that by creating
    a script that can be used to read either FOO (our example text-based format) or
    FOB (our example binary format).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可能希望你的脚本能够处理具有多个扩展名的文件——每个类型一个。在这个例子中，我们将通过创建一个可以用来读取FOO（我们的示例基于文本的格式）或FOB（我们的示例二进制格式）的脚本来查看如何做到这一点。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have at least one file of each type. For FOO files, you can
    just create them directly in a text editor. For FOB files, it's best to use the
    script in the writing binary files example.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你至少有一个每种类型的文件。对于FOO文件，你可以在文本编辑器中直接创建它们。对于FOB文件，最好使用写作二进制文件的示例中的脚本。
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a new file and add the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE72]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that the preceding code makes use of two functions that we haven't defined,
    namely `readFOOFile` and `readFOBFile`. I've left those out for the sake of brevity,
    but they both use the same code as we discussed in the previous examples on reading
    text and binary files, respectfully.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码使用了两个我们尚未定义的函数，即`readFOOFile`和`readFOBFile`。为了简洁，我省略了这些函数，但它们都使用了我们在之前示例中讨论的读取文本和二进制文件的相同代码。
- en: If you run the script, you'll be able to select FOO files or, by selecting "FOO
    binary files" from the drop-down list of file types, FOB files. Either way, you
    should see the corresponding collection of spheres and cubes added to the scene.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个脚本，你将能够选择FOO文件，或者通过从文件类型下拉列表中选择“FOO二进制文件”，选择FOB文件。无论哪种方式，你应该能看到相应的球体和立方体集合被添加到场景中。
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing that we have to do in order to read multiple files is to add
    two or more types to the `fileFilter` argument, separating them with a double
    semicolon, as in:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取多个文件，我们首先必须将两种或更多类型添加到`fileFilter`参数中，用双分号分隔，如下所示：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Other than this, the `fileDialog2` command is used as we've used it in the past.
    Once we have the result from the command, we store the first entry (the path the
    used selected) into a `filePath` variable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，`fileDialog2`命令的使用方式与我们过去使用的方式相同。一旦我们得到命令的结果，我们将第一个条目（用户选择的路径）存储到`filePath`变量中。
- en: 'Once we''ve done that, we want to examine the file extension of the file chosen
    by the user. We could do that with string functions, but it''s a bit safer to
    rely on Python''s `os.path.splitext` function, which is specifically designed
    to separate extensions from paths, with the return being an array consisting of
    first the path (including filename) and then the extension:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个，我们希望检查用户选择的文件扩展名。我们可以使用字符串函数来做这件事，但依靠Python的`os.path.splitext`函数会更安全一些，该函数专门设计用来从路径中分离扩展名，返回的是一个包含路径（包括文件名）和扩展名的数组：
- en: '[PRE74]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Once we have the extension, we test it against all of the types we want to
    process, calling the appropriate function for each:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了扩展名，我们就将其与我们要处理的全部类型进行测试，为每种类型调用相应的函数：
- en: '[PRE75]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: For each file type, we invoke a function to handle the actual processing, passing
    in the path to the file. We finish off by throwing an error, in the event that
    the user somehow managed to choose a file of a type that we don't handle.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种文件类型，我们调用一个函数来处理实际的文件处理，传入文件的路径。如果用户意外地选择了一个我们不处理的文件类型，我们通过抛出错误来结束操作。
- en: There's more...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can certainly extend this approach to handle a wide range of file types
    in a single script, though if you have a large number of types, selecting the
    proper one from the dropdown might prove tiring for the user.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以将这种方法扩展到单个脚本中处理多种文件类型，尽管如果你有很多种类型，从下拉菜单中选择合适的类型可能会让用户感到疲惫。
- en: In such cases, you might want to just leave out the `fileFilter` altogether,
    and just allow the script to accept all file types, relying on the extension-filtering
    logic to filter out any types that you didn't want to process.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能只想完全省略`fileFilter`，让脚本接受所有文件类型，并依赖扩展过滤逻辑来过滤掉你不想处理的任何类型。
- en: In practice, however, if you're really dealing with a large number of different
    file types, it's likely that your script is trying to do too many things. Consider
    breaking it up into smaller components, with each one focused on a specific subset
    of the process you're building them for.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，如果你确实在处理大量不同的文件类型，你的脚本可能试图做太多事情。考虑将其拆分成更小的组件，每个组件都专注于为你构建的特定过程子集。
