- en: Improving Our API and Adding Authentication to it with Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Flask 改进我们的 API 并为其添加身份验证
- en: 'In this chapter, we will improve the capabilities of the RESTful API that we
    started in the previous chapter and we will add authentication-related security
    to it. We will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将改进上一章开始构建的 RESTful API 的功能，并为其添加与身份验证相关的安全功能。我们将执行以下操作：
- en: Improve unique constraints in the models
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进模型中的唯一约束
- en: Understand the differences between the `PUT` and the `PATCH` methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `PUT` 和 `PATCH` 方法之间的区别
- en: Update fields for a resource with the `PATCH` method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `PATCH` 方法更新资源的字段
- en: Code a generic pagination class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个通用的分页类
- en: Add pagination features to the API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 API 添加分页功能
- en: Understand the steps to add authentication and permissions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解添加身份验证和权限的步骤
- en: Add a user model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用户模型
- en: Create a schema to validate, serialize, and deserialize users
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模式来验证、序列化和反序列化用户
- en: Add authentication to resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为资源添加身份验证
- en: Create resource classes to handle users
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于处理用户的资源类
- en: Run migrations to generate the user table
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行迁移以生成用户表
- en: Compose requests with the necessary authentication
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用必要的身份验证来编写请求
- en: Improving unique constraints in the models
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进模型中的唯一约束
- en: When we coded the `NotificationCategory` model in the previous chapter, we specified
    the `True` value for the `unique` argument in the creation of the `orm.Column`
    instance named `name`. As a result, the migrations process generated the necessary
    unique constraint to make sure that the `name` field has unique values in the
    `notification_category` table. This way, the PostgreSQL database won't allow us
    to insert duplicate values for the `notification_category.name` column. However,
    the error message generated when we try to do so is not clear. The message includes
    details about the database structure that shouldn't be mentioned in the error
    message.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中我们编码了 `NotificationCategory` 模型时，我们在创建名为 `name` 的 `orm.Column` 实例时，为 `unique`
    参数指定了 `True` 值。因此，迁移过程生成了必要的唯一约束，以确保 `notification_category` 表中的 `name` 字段具有唯一值。这样，PostgreSQL
    数据库将不允许我们为 `notification_category.name` 列插入重复值。然而，当我们尝试这样做时生成的错误消息并不清晰。该消息包含了不应该在错误消息中提到的数据库结构详情。
- en: Run the following command to create a category with a duplicate ...
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个具有重复 ... 的类别
- en: Understanding the differences between the PUT and the PATCH methods
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 PUT 和 PATCH 方法之间的区别
- en: The HTTP `PUT` and `PATCH` methods have different purposes. The HTTP `PUT` method
    is meant to replace an entire resource. The HTTP `PATCH` method is meant to apply
    a delta to an existing resource.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 的 `PUT` 和 `PATCH` 方法有不同的目的。HTTP 的 `PUT` 方法旨在替换整个资源。HTTP 的 `PATCH` 方法旨在对现有资源应用一个增量。
- en: Our API is able to update a single field for an existing resource, and therefore,
    we provide an implementation for the `PATCH` method. For example, we can use the
    `PATCH` method to update an existing notification and set the value for its `displayed_once`
    and `displayed_times` fields to `true` and `1`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 API 能够更新现有资源的单个字段，因此我们提供了 `PATCH` 方法的实现。例如，我们可以使用 `PATCH` 方法来更新现有的通知，并将它的
    `displayed_once` 和 `displayed_times` 字段的值设置为 `true` 和 `1`。
- en: We don't want to use the `PUT` method to update two fields because this method
    is meant to replace an entire notification. The `PATCH` method is meant to apply
    a delta to an existing notification, and therefore, it is the appropriate method
    to just change the value of those two fields.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想使用 `PUT` 方法来更新两个字段，因为这个方法旨在替换整个通知。`PATCH` 方法旨在对现有通知应用一个增量，因此它是仅更改这两个字段值的适当方法。
- en: Updating fields for a resource with the PATCH method
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PATCH 方法更新资源的字段
- en: 'Now we will compose and send an HTTP request to update an existing notification,
    specifically, to update the value of the `displayed_once` and `displayed_times`
    fields. Because we just want to update two fields, we will use the `PATCH` method
    instead of `PUT`. Make sure you replace `2` with the ID or primary key of an existing
    notification in your configuration. The code file for the sample is included in
    the `restful_python_2_03_01` folder, in the `Flask01/cmd307.txt` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写并发送一个 HTTP 请求来更新现有的通知，具体来说，是更新 `displayed_once` 和 `displayed_times` 字段的值。因为我们只想更新两个字段，所以我们将使用
    `PATCH` 方法而不是 `PUT`。确保将 `2` 替换为您配置中现有通知的 ID 或主键。示例代码文件包含在 `restful_python_2_03_01`
    文件夹中的 `Flask01/cmd307.txt` 文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd308.txt
    ...`
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例代码文件包含在`restful_python_2_03_01`文件夹中，位于`Flask01/cmd308.txt ...`
- en: Coding a generic pagination class
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写通用分页类
- en: Right now, the table that persists the notifications in the database has just
    a few rows. However, after we start working with our API encapsulated in a microservice
    in a real-life production environment, we will have hundreds of notifications,
    and therefore, we will have to deal with large result sets. We don't want an HTTP
    `GET` request to retrieve 1,000 notifications in a single call. Thus, we will
    create a generic pagination class and we will use it to easily specify how we
    want large results sets to be split into individual pages of data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在数据库中持久化通知的表只有几行。然而，在我们开始在真实的生产环境中使用封装在微服务中的API后，我们将有数百条通知，因此，我们必须处理大量结果集。我们不希望HTTP
    `GET`请求在一次调用中检索1,000条通知。因此，我们将创建一个通用分页类，并使用它来轻松指定我们想要如何将大量结果集拆分为单个数据页。
- en: 'First, we will compose and send HTTP `POST` requests to create nine notifications
    that belong to one of the notification categories we have created: `Information`.
    This way, we will have a total of 12 messages persisted in the database. We had
    three messages and we add nine more. The code file for the sample is included
    in the `restful_python_2_03_01` folder, in the `Flask01/cmd309.txt` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写并发送HTTP `POST`请求来创建属于我们已创建的通知类别之一（`Information`）的九条通知。这样，我们将总共在数据库中保留12条消息。我们原本有三条消息，然后又添加了九条。示例代码文件包含在`restful_python_2_03_01`文件夹中，位于`Flask01/cmd309.txt`文件中：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following are the equivalent `curl` commands. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd310.txt`
    file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例代码文件包含在`restful_python_2_03_01`文件夹中，位于`Flask01/cmd310.txt`文件中。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous commands will compose and send nine HTTP `POST` requests with the
    specified JSON key-value pairs. The requests specify `/service/notifications/`,
    and therefore, they will match `'/notifications/'` and run the `NotificationListResource.post`
    method, that is, the `post` method for the `NotificationListResource` class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将编写并发送九个HTTP `POST`请求，这些请求指定了具有指定JSON键值对的JSON键值对。请求指定了`/service/notifications/`，因此，它们将匹配`'/notifications/'`并运行`NotificationListResource.post`方法，即`NotificationListResource`类的`post`方法。
- en: After running the previous commands, we will have 12 notifications persisted
    in our PostgreSQL database. However, we don't want to retrieve the 12 messages
    when we compose and send an HTTP `GET` request to `/service/notifications/`. We
    will create a customizable generic pagination class to include a maximum of four
    resources in each individual page of data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令后，我们将在我们的PostgreSQL数据库中保留12条通知。然而，当我们向`/service/notifications/`发送HTTP
    `GET`请求以编写和发送消息时，我们不想检索这12条消息。我们将创建一个可定制的通用分页类，以在每个数据页中包含最多四个资源。
- en: Open the `config.py` file within the `service` folder and add the following
    lines that declare two variables that configure the global pagination settings.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于`service`文件夹中的`config.py`文件，并添加以下行以声明两个变量，这些变量用于配置全局分页设置。
- en: 'Open the `service/config.py` file and add the following lines that declare
    two variables that configure the global pagination settings. The code file for
    the sample is included in the `restful_python_2_03_01` folder, in the `Flask01/service/config.py`
    file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`service/config.py`文件，并添加以下行以声明两个变量，这些变量用于配置全局分页设置。示例代码文件包含在`restful_python_2_03_01`文件夹中，位于`Flask01/service/config.py`文件中：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The value for the `PAGINATION_PAGE_SIZE` variable specifies a global setting
    with the default value for the page size, also known as limit. The value for `PAGINATION_PAGE_ARGUMENT_NAME`
    specifies a global setting with the default value for the argument name that we
    will use in our requests to specify the page number we want to retrieve.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`PAGINATION_PAGE_SIZE`变量的值指定了一个全局设置，即页面大小的默认值，也称为限制。`PAGINATION_PAGE_ARGUMENT_NAME`变量的值指定了一个全局设置，即我们将在请求中使用的默认参数名称，以指定我们想要检索的页面号。'
- en: 'Create a new `helpers.py` file within the `service` folder. The following lines
    show the code that creates a new `PaginationHelper` class. The code file for the
    sample is included in the `restful_python_2_03_01` folder, in the `Flask01/service/helpers.py`
    file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `service` 文件夹内创建一个新的 `helpers.py` 文件。以下行显示了创建新的 `PaginationHelper` 类的代码。示例代码文件包含在
    `restful_python_2_03_01` 文件夹中的 `Flask01/service/helpers.py` 文件中：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `PaginationHelper` class declares a constructor, that is, the `__init__`
    method, which receives the following arguments and uses them to initialize the
    attributes with the same names:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`PaginationHelper` 类声明了一个构造函数，即 `__init__` 方法，该方法接收以下参数并使用它们来初始化具有相同名称的属性：'
- en: '`request`: The Flask request object that will allow the `paginate_query` method
    to retrieve the page number value specified with the HTTP request'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`：Flask 请求对象，它将允许 `paginate_query` 方法检索通过 HTTP 请求指定的页码值'
- en: '`query`: The SQLAlchemy query that the `paginate_query` method has to paginate'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query`：`paginate_query` 方法必须分页的 SQLAlchemy 查询'
- en: '`resource_for_url`: A string with the resource name that the `paginate_query`
    method will use to generate the full URLs for the previous page and the next page'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource_for_url`：一个字符串，表示 `paginate_query` 方法将使用该资源名来生成上一页和下一页的完整 URL'
- en: '`key_name`: A string with the key name that the `paginate_query` method will
    use to return the serialized objects'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key_name`：一个字符串，表示 `paginate_query` 方法将使用该键名来返回序列化对象'
- en: '`schema`: The Flask-Marshmallow `Schema` subclass that the `paginate_query`
    method must use to serialize the objects'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schema`：`paginate_query` 方法必须使用的 Flask-Marshmallow `Schema` 子类来序列化对象'
- en: In addition, the constructor reads and saves the values for the configuration
    variables we added to the `config.py` file in the `page_size` and `page_argument_name`
    attributes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，构造函数读取并保存了添加到 `config.py` 文件中的配置变量的值，并将它们保存在 `page_size` 和 `page_argument_name`
    属性中。
- en: The class declares the `paginate_query` method. First, the code retrieves the
    page number specified in the request and saves it in the `page_number` variable.
    If no page number is specified, the code assumes that the request requires the
    first page. Then, the code calls the `self.query.paginate` method to retrieve
    the page number specified by `page_number` of the paginated result of objects
    from the database, with a number of results per page indicated by the value of
    the `self.page_size` attribute. The next line saves the paginated items from the
    `paginated_object.items` attribute in the `objects` variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了 `paginate_query` 方法。首先，代码检索请求中指定的页码并将其保存到 `page_number` 变量中。如果没有指定页码，代码假设请求需要第一页。然后，代码调用
    `self.query.paginate` 方法来检索数据库中对象的分页结果中指定的 `page_number` 页码，每页的结果数量由 `self.page_size`
    属性的值指示。下一行将 `paginated_object.items` 属性中的分页项保存到 `objects` 变量中。
- en: If the value for the `paginated_objects.has_prev` attribute is `True`, it means
    that there is a previous page available. In this case, the code calls the `flask.url_for`
    function to generate the full URL for the previous page with the value of the
    `self.resource_for_url` attribute. The `_external` argument is set to `True` because
    we want to provide the full URL.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `paginated_objects.has_prev` 属性的值为 `True`，则表示存在上一页。在这种情况下，代码调用 `flask.url_for`
    函数来生成带有 `self.resource_for_url` 属性值的上一页的完整 URL。`_external` 参数设置为 `True`，因为我们想提供完整的
    URL。
- en: If the value for the `paginated_objects.has_next` attribute is `True`, it means
    that there is a next page available. In this case, the code calls the `flask.url_for`
    function to generate the full URL for the next page with the value of the `self.resource_for_url`
    attribute.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `paginated_objects.has_next` 属性的值为 `True`，则表示存在下一页。在这种情况下，代码调用 `flask.url_for`
    函数来生成带有 `self.resource_for_url` 属性值的下一页的完整 URL。
- en: Then, the code calls the `self.schema.dump` method to serialize the partial
    results previously saved in the `objects` variable, with the `many` argument set
    to `True`. The `dumped_objects` variable saves the reference to the `data` attribute
    of the results returned by the call to the `dump` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码调用 `self.schema.dump` 方法来序列化之前保存在 `objects` 变量中的部分结果，将 `many` 参数设置为 `True`。`dumped_objects`
    变量保存了对调用 `dump` 方法返回的结果的 `data` 属性的引用。
- en: 'Finally, the method returns a dictionary with the following key-value pairs:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法返回一个包含以下键值对的字典：
- en: '| Key | Value |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 键 | 值 |'
- en: '| `self.key_name` | The serialized partial results saved in the `dumped_objects`
    variable. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `self.key_name` | 保存于 `dumped_objects` 变量中的序列化部分结果。 |'
- en: '| `''previous''` | The full URL for the previous page saved in the `previous_page_url`
    variable. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `''previous''` | 存储在 `previous_page_url` 变量中的上一页的完整 URL。|'
- en: '| `''next''` | The full URL for the next page saved in the `next_page_url`
    variable. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `''next''` | 存储在 `next_page_url` 变量中的下一页的完整 URL。|'
- en: '| `''count''` | The total number of objects available in the complete result
    set retrieved from the `paginated_objects.total` attribute. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `''count''` | 从 `paginated_objects.total` 属性检索的完整结果集中可用的对象总数。|'
- en: Adding pagination features
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分页功能
- en: 'Open the `views.py` file within the `service` folder and replace the code for
    the `NotificationListResource.get` method with the highlighted lines in the next
    listing. In addition, make sure that you add the highlighted import statement.
    The code file for the sample is included in the `restful_python_2_03_01` folder,
    in the `Flask01/service/views.py` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `service` 文件夹中的 `views.py` 文件，并将 `NotificationListResource.get` 方法的代码替换为下一列表中突出显示的行。此外，请确保添加突出显示的导入语句。示例代码文件包含在
    `restful_python_2_03_01` 文件夹中，位于 `Flask01/service/views.py` 文件：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The new code for the ...
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码为...
- en: Understanding the steps to add authentication and permissions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解添加身份验证和权限的步骤
- en: Our current version of the API processes all the incoming requests without requiring
    any kind of authentication. We will use a Flask extension and other packages to
    use an HTTP authentication scheme to identify the user that originated the request
    or the token that signed the request. Then, we will use these credentials to apply
    the permissions that will determine whether the request must be permitted or not.
    Unluckily, neither Flask nor Flask-RESTful provide an authentication framework
    that we can easily plug and configure. Thus, we will have to write code to perform
    many tasks related to authentication and permissions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的 API 版本在不需要任何类型的身份验证的情况下处理所有传入的请求。我们将使用 Flask 扩展和其他包来使用 HTTP 身份验证方案来识别发起请求的用户或签名请求的令牌。然后，我们将使用这些凭据来应用权限，以确定请求是否必须被允许。不幸的是，Flask
    和 Flask-RESTful 都没有提供我们可以轻松插入和配置的身份验证框架。因此，我们将不得不编写代码来执行与身份验证和权限相关的许多任务。
- en: We want to be able to create a new user without any authentication. However,
    all the other API calls are only going to be available for authenticated users.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在没有任何身份验证的情况下创建新用户。然而，所有其他 API 调用都只对经过身份验证的用户可用。
- en: First, we will install the `Flask-HTTPAuth` Flask extension to make it easier
    for us to work with HTTP authentication and the `passlib` package to allow us
    to hash a password and check whether a provided password is valid or not.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装 `Flask-HTTPAuth` Flask 扩展，以便我们更容易地处理 HTTP 身份验证，并使用 `passlib` 包来允许我们对密码进行散列并检查提供的密码是否有效。
- en: We will create a new `User` model that will represent a user. The model will
    provide methods to allow us to hash a password and verify whether a password provided
    for a user is valid or not. We will create a `UserSchema` class to specify how
    we want to serialize and deserialize a user.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 `User` 模型，该模型将代表一个用户。该模型将提供方法，使我们能够对密码进行散列，并验证提供给用户的密码是否有效。我们将创建一个
    `UserSchema` 类来指定我们想要如何序列化和反序列化用户。
- en: Then, we will configure the Flask extension to work with our `User` model to
    verify passwords and set the authenticated user associated with a request. We
    will make changes to the existing resources to require authentication and we will
    add new resources to allow us to retrieve existing users and create a new one.
    Finally, we will configure the routes for the resources related to users.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将配置 Flask 扩展以与我们的 `User` 模型一起工作，以验证密码并设置与请求关联的已认证用户。我们将对现有资源进行更改以要求身份验证，并将添加新资源以允许我们检索现有用户并创建一个新用户。最后，我们将配置与用户相关的资源的路由。
- en: Once we have completed the previously mentioned tasks, we will run the migrations
    process to generate the new table that persists the users in the database. Then,
    we will compose and send HTTP requests to understand how the authentication and
    permissions work with our new version of the API.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了之前提到的任务，我们将运行迁移过程以生成新的表，该表将持久化数据库中的用户。然后，我们将编写并发送 HTTP 请求以了解我们的新版本 API
    中的身份验证和权限是如何工作的。
- en: Make sure you quit Flask's development server. You just need to press Ctrl +
    C in the Terminal or Command Prompt window in which it is running.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您退出 Flask 的开发服务器。您只需在运行它的终端或命令提示符窗口中按 Ctrl + C 即可。
- en: Now, we will install many additional packages. Make sure you have activated
    the virtual environment we have created in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*, and we named `Flask01`.
    After you activate the virtual environment, it is time to run many commands that
    will be the same for either macOS, Linux, or Windows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将安装许多附加包。请确保您已激活我们在 [第 1 章](dbf75cef-4962-4e40-8192-03873b774c48.xhtml)，“使用
    Flask 1.0.2 开发 RESTful API 和微服务”，中创建的虚拟环境，我们命名为 `Flask01`。激活虚拟环境后，就是运行许多命令的时候了，这些命令对
    macOS、Linux 或 Windows 都是一样的。
- en: Now we will edit the existing `requirements.txt` file to specify the additional
    set of packages that our application requires to be installed in any supported
    platform. This way, it will be extremely easy to repeat the installation of the
    specified packages with their versions in any new virtual environment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑现有的 `requirements.txt` 文件，以指定我们的应用程序在任何支持的平台中需要安装的附加包集。这样，在任意新的虚拟环境中重复安装指定包及其版本将变得极其容易。
- en: 'Use your favorite editor to edit the existing text file named `requirements.txt`
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional packages and the versions that our new
    version of the API requires. The code file for the sample is included in the `restful_python_2_03_02`
    folder, in the `Flask01/requirements.txt` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器编辑虚拟环境根文件夹中名为 `requirements.txt` 的现有文本文件。在最后一行之后添加以下行，以声明我们的 API 新版本所需的附加包及其版本。示例的代码文件包含在
    `restful_python_2_03_02` 文件夹中，在 `Flask01/requirements.txt` 文件中：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each additional line added to the `requirements.txt` file indicates the package
    and the version that needs to be installed. The following table summarizes the
    packages and the version numbers that we specified as additional requirements
    to the previously included packages:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到 `requirements.txt` 文件中的每一行都表示需要安装的包及其版本。以下表格总结了我们作为附加要求指定的包及其版本号：
- en: '| Package name | Version to be installed |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 包名 | 要安装的版本 |'
- en: '| `Flask-HTTPAuth` | 3.2.4 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `Flask-HTTPAuth` | 3.2.4 |'
- en: '| `passlib` | 1.7.1 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `passlib` | 1.7.1 |'
- en: 'Now we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions explained in the previous table with
    `pip` by using the recently edited `requirements.txt` file. Make sure you are
    in the folder that has the `requirements.txt` file before running the command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须在 macOS、Linux 或 Windows 上运行以下命令来安装之前表格中解释的附加包及其版本，使用最近编辑的 `requirements.txt`
    文件通过 `pip` 进行安装。在运行命令之前，请确保您位于包含 `requirements.txt` 文件的文件夹中：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last lines for the output will indicate that all the new packages and their
    dependencies have been successfully installed. If you downloaded the source code
    for the example and you didn''t work with the previous version of the API, `pip`
    will also install the other packages included in the `requirements.txt` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有新包及其依赖项已成功安装。如果您下载了示例的源代码，并且您没有使用 API 的先前版本，`pip` 也会安装 `requirements.txt`
    文件中包含的其他包：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding a user model
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户模型
- en: 'Now we will create the model that we will use to represent and persist a user.
    Open the `models.py` file within the `service` folder and add the following lines
    after the declaration of the `ResourceAddUpdateDelete` class. Make sure that you
    add the highlighted import statements. The code file for the sample is included
    in the `restful_python_2_03_02` folder, in the `Flask01/service/models.py` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个模型，我们将使用它来表示和持久化用户。打开 `service` 文件夹中的 `models.py` 文件，并在 `ResourceAddUpdateDelete`
    类声明之后添加以下行。请确保您添加了高亮的导入语句。示例的代码文件包含在 `restful_python_2_03_02` 文件夹中，在 `Flask01/service/models.py`
    文件中：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating schemas to validate, serialize, and deserialize users
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于验证、序列化和反序列化用户的模式
- en: 'Now we will create the Flask-Marshmallow schema that we will use to validate,
    serialize, and deserialize the previously declared `User` model. Open the `models.py`
    file within the `service` folder and add the following code after the existing
    lines. The code file for the sample is included in the `restful_python_2_03_02`
    folder, in the `Flask01/service/models.py` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建 Flask-Marshmallow 模式，我们将使用它来验证、序列化和反序列化之前声明的 `User` 模型。打开 `service`
    文件夹中的 `models.py` 文件，并在现有行之后添加以下代码。示例的代码文件包含在 `restful_python_2_03_02` 文件夹中，在
    `Flask01/service/models.py` 文件中：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code declares the `UserSchema` schema, specifically a subclass of the `ma.Schema`
    class. Remember that the previous code we wrote for the `service/models.py` file
    created a `flask_marshmallow.Mashmallow` instance named `ma`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了`UserSchema`模式，具体是`ma.Schema`类的子类。记住，我们之前为`service/models.py`文件编写的代码创建了一个名为`ma`的`flask_marshmallow.Mashmallow`实例。
- en: We declare the attributes that represent fields as instances of the appropriate
    class declared in the `marshmallow.fields` module. The `UserSchema` class declares
    the `name` attribute as an instance of `fields.String`. The `required` argument
    is set to `True` to specify that the field cannot be an empty string. The `validate`
    argument is set to `validate.Length(5)` to specify that the field must have a
    minimum length of five characters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表示字段的属性声明为`marshmallow.fields`模块中声明的适当类的实例。`UserSchema`类将`name`属性声明为`fields.String`的实例。`required`参数设置为`True`，以指定该字段不能为空字符串。`validate`参数设置为`validate.Length(5)`，以指定该字段必须至少有五个字符长。
- en: The validation for the password isn't included in the schema. We will use the
    `check_password_strength_and_hash_if_ok` method defined in the `User` class to
    validate the password.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 密码的验证没有包含在模式中。我们将使用在`User`类中定义的`check_password_strength_and_hash_if_ok`方法来验证密码。
- en: Adding authentication to resources
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为资源添加认证
- en: 'Now we will perform the following tasks:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将执行以下任务：
- en: Configure the `Flask-HTTPAuth` extension to work with our `User` model to verify
    passwords and set the authenticated user associated with a request.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`Flask-HTTPAuth`扩展以与我们的`User`模型一起工作，以验证密码并设置与请求关联的已验证用户。
- en: Declare a custom function that the `Flask-HTTPAuth` extension will use as a
    callback to verify a password.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个自定义函数，该函数将被`Flask-HTTPAuth`扩展用作回调以验证密码。
- en: Create a new base class for our resources that will require authentication.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的资源创建一个新的基类，该基类将需要认证。
- en: 'Open the `views.py` file within the `service` folder and add the following
    code after the last line that uses the `import` statement and before the lines
    that declare the `Blueprint` instance named `service_blueprint`. The code file
    for the sample is included in the `restful_python_2_03_02` folder, in the `Flask01/service/views.py`
    file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`service`文件夹内的`views.py`文件，在最后一个使用`import`语句的行之后和声明名为`service_blueprint`的`Blueprint`实例之前添加以下代码。示例的代码文件包含在`restful_python_2_03_02`文件夹中，在`Flask01/service/views.py`文件中：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating resource classes to handle users
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于处理用户的资源类
- en: We just want to be able to create users and use them to authenticate requests.
    Thus, we will just focus on creating resource classes with just a few methods.
    We won't create a complete user management system.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想能够创建用户并使用它们来验证请求。因此，我们将只关注创建具有几个方法的资源类。我们不会创建一个完整的用户管理系统。
- en: 'We will create the resource classes that represent the user and the collection
    of users. First, we will create a `UserResource` class, which we will use to represent
    a user resource. Open the `views.py` file within the `service` folder and add
    the following lines after the line that creates the `Api` instance named `service`
    and before the declaration of the `NotificationResource` class. The code file
    for the sample is included in the `restful_python_2_03_02` folder, in the `Flask01/service/views.py`
    file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建代表用户和用户集合的资源类。首先，我们将创建一个`UserResource`类，我们将使用它来表示用户资源。打开`service`文件夹内的`views.py`文件，在创建名为`service`的`Api`实例的行之后和声明`NotificationResource`类之前添加以下行。示例的代码文件包含在`restful_python_2_03_02`文件夹中，在`Flask01/service/views.py`文件中：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `UserResource` class is a subclass of the previously coded `AuthenticationRequiredResource`
    and declares a `get` method that will be called when the HTTP method with the
    same name arrives as a request on the represented resource.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserResource`类是之前编写的`AuthenticationRequiredResource`的子类，并声明了一个`get`方法，当具有相同名称的HTTP方法作为对表示的资源上的请求被调用时，将调用此方法。'
- en: The method receives the id of the user that has to be retrieved in the `id`
    argument. The code calls the `User.query.get_or_404` method to return an HTTP
    `404 Not Found` status if there is no user with the requested id in the underlying
    database. If the user exists, the code calls the `user_schema.dump` method with
    the retrieved user as an argument to use the `UserSchema` instance to serialize
    the `User` instance whose `id` matches the specified `id`. The `dump` method takes
    the `User` instance and applies the field filtering and output formatting specified
    in the `UserSchema` class. The field filtering specifies that we don't want the
    hash for the password to be serialized. The code returns the `data` attribute
    of the result returned by the `dump` method, that is, the serialized message in
    JSON format as the body, with the default HTTP `200 OK` status code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接收 `id` 参数中要检索的用户 id。代码调用 `User.query.get_or_404` 方法，如果没有在底层数据库中找到请求的 id
    对应的用户，则返回 HTTP `404 Not Found` 状态。如果用户存在，代码将调用 `user_schema.dump` 方法，将检索到的用户作为参数，使用
    `UserSchema` 实例来序列化与指定的 `id` 匹配的 `User` 实例。`dump` 方法接收 `User` 实例，并应用在 `UserSchema`
    类中指定的字段过滤和输出格式化。字段过滤指定我们不希望序列化密码的哈希值。代码返回 `dump` 方法返回的结果的 `data` 属性，即作为主体的 JSON
    格式的序列化消息，带有默认的 HTTP `200 OK` 状态码。
- en: 'Now we will create the `UserListResource` class that we will use to represent
    the collection of users. Open the `views.py` file within the `service` folder
    and add the following lines after the code that creates the `UserResource` class.
    The code file for the sample is included in the `restful_python_2_03_02` folder,
    in the `Flask01/service/views.py` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建 `UserListResource` 类，我们将使用它来表示用户集合。打开 `service` 文件夹中的 `views.py` 文件，并在创建
    `UserResource` 类的代码之后添加以下行。示例代码文件包含在 `restful_python_2_03_02` 文件夹中，位于 `Flask01/service/views.py`
    文件：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `UserListResource` class is a subclass of the `flask_restful.Resource`
    superclass because we don''t want all the methods to require authentication. We
    want to be able to create a new user without being authenticated, and therefore,
    we apply the `@auth.login_required` decorator only for the `get` method. The `post`
    method doesn''t require authentication. The class declares the following two methods
    that will be called when the HTTP method with the same name arrives as a request
    on the represented resource:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserListResource` 类是 `flask_restful.Resource` 超类的子类，因为我们不希望所有的方法都需要进行身份验证。我们希望能够在未进行身份验证的情况下创建新用户，因此，我们只为
    `get` 方法应用了 `@auth.login_required` 装饰器。`post` 方法不需要身份验证。该类声明了以下两个方法，当到达表示的资源上的具有相同名称的
    HTTP 方法请求时，将调用这些方法：'
- en: '`get`: This method returns a list with all the `User` instances persisted in
    the database. First, the code calls the `User.query.all` method to retrieve all
    the `User` instances. Then, the code calls the `user_schema.dump` method with
    the retrieved users and the `many` argument set to `True` to serialize the iterable
    collection of objects. The `dump` method will take each `User` instance retrieved
    from the database and apply the field filtering and output formatting specified
    the `UserSchema` class. The code returns the `data` attribute of the result returned
    by the `dump` method, that is, the serialized messages in JSON format as the body,
    with the default HTTP `200 OK` status code.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`：此方法返回一个包含数据库中持久化的所有 `User` 实例的列表。首先，代码调用 `User.query.all` 方法来检索所有 `User`
    实例。然后，代码调用 `user_schema.dump` 方法，将检索到的用户和 `many` 参数设置为 `True` 以序列化对象的可迭代集合。`dump`
    方法将取从数据库检索到的每个 `User` 实例，并应用由 `UserSchema` 类指定的字段过滤和输出格式化。代码返回 `dump` 方法返回的结果的
    `data` 属性，即作为主体的 JSON 格式的序列化消息，带有默认的 HTTP `200 OK` 状态码。'
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `User` instance and persists it in the database. First, the code
    calls the `request.get_json` method to retrieve the key-value pairs received as
    arguments with the request. Then, the code calls the `user_schema.validate` method
    to validate the new user built with the retrieved key-value pairs. In this case,
    the call to this method will just validate the `name` field for the user. If there
    were validation errors, the code returns a tuple composed of the validation errors
    and an HTTP `400 Bad Request` status code. If the validation is successful, the
    code checks whether a user with the same name already exists in the database or
    not to return an appropriate error for the field that must be unique. If the username
    is unique, the code creates a new user with the specified `name` and calls its
    `check_password_strength_and_hash_if_ok` method. If the provided password fulfills
    all the quality requirements, the code persists the user with the hash for its
    password in the database. Finally, the code returns a tuple composed of the serialized
    saved user in JSON format as the body, with the HTTP `201 Created` status code.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`：此方法检索 JSON 主体中接收到的键值对，创建一个新的 `User` 实例并将其持久化到数据库中。首先，代码调用 `request.get_json`
    方法来检索请求中作为参数接收到的键值对。然后，代码调用 `user_schema.validate` 方法来验证使用检索到的键值对构建的新用户。在这种情况下，对这个方法的调用将仅验证用户的
    `name` 字段。如果有验证错误，代码将返回一个由验证错误和 HTTP `400 Bad Request` 状态码组成的元组。如果验证成功，代码将检查数据库中是否已存在具有相同名称的用户，以返回适当的错误信息，该字段必须是唯一的。如果用户名是唯一的，代码将创建一个新的用户，指定其
    `name`，并调用其 `check_password_strength_and_hash_if_ok` 方法。如果提供的密码满足所有质量要求，代码将使用其密码的散列在数据库中持久化用户。最后，代码返回一个由序列化后的
    JSON 格式保存的用户组成的元组，作为正文，并带有 HTTP `201 Created` 状态码。'
- en: 'The following table shows the methods of our previously created classes related
    to users that we want to be executed for each combination of HTTP verb and scope:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了与我们之前创建的、与用户相关的类相关的方法，我们希望为每个 HTTP 方法和范围的组合执行：
- en: '| HTTP verb | Scope | Class and method | Requires authentication |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 方法 | 范围 | 类和方法 | 需要认证 |'
- en: '| `GET` | Collection of users | `UserListResource.get` | Yes |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 用户集合 | `UserListResource.get` | 是 |'
- en: '| `GET` | User | `UserResource.get` | Yes |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 用户 | `UserResource.get` | 是 |'
- en: '| `POST` | Collection of users | `UserListResource.post` | No |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 用户集合 | `UserListResource.post` | 否 |'
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines configure the resource routing for the user-related resources to the `service`
    object. Open the `views.py` file within the `service` folder and add the following
    lines at the end of the code. The code file for the sample is included in the
    `restful_python_2_03_02` folder, in the `Flask01/service/views.py` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过定义 URL 规则来执行必要的资源路由配置，以调用适当的方法并将所有必要的参数传递给它们。以下几行配置了与用户相关的资源到 `service`
    对象的资源路由。打开 `service` 文件夹内的 `views.py` 文件，并在代码末尾添加以下几行。示例代码文件包含在 `restful_python_2_03_02`
    文件夹中，位于 `Flask01/service/views.py` 文件：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each call to the `service.add_resource` method routes a URL to one of the previously
    coded user-related resources. When there is a request to the API, and the URL
    matches one of the URLs specified in the `service.add_resource` method, Flask
    will call the method that matches the HTTP verb in the request for the specified
    class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `service.add_resource` 方法都会将一个 URL 路由到之前编写的与用户相关的资源之一。当有 API 请求时，如果 URL
    与 `service.add_resource` 方法中指定的 URL 之一匹配，Flask 将调用与请求中指定的类的 HTTP 方法匹配的方法。
- en: Running migrations to generate the user table
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行迁移以生成用户表
- en: Now we will run many scripts to run migrations and generate the necessary table
    to persist users in the PostgreSQL 10.5 database. Make sure you run the scripts
    in the Terminal or Command Prompt window in which you have activated the virtual
    environment and that you are located in the `service` folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行多个脚本来运行迁移并生成在 PostgreSQL 10.5 数据库中持久化用户所需的必要表。请确保在激活了虚拟环境并位于 `service`
    文件夹的终端或命令提示符窗口中运行这些脚本。
- en: 'Run the first command that populates the migration script with the detected
    changes in the models. In this case, it is the second time we populate the migration
    script, and therefore, the migration script will generate the new table that will
    persist our new `User` model: `user`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第一个命令，用模型中检测到的更改填充迁移脚本。在这种情况下，这是我们第二次填充迁移脚本，因此，迁移脚本将生成新的表，以持久化我们的新`User`模型：`user`：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following lines show the sample output generated after running the previous
    command. Your output will ...
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上述命令后生成的示例输出。您的输出将...
- en: Composing requests with the necessary authentication
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合带有必要认证的请求
- en: 'Now we will compose and send an HTTP request to retrieve the first page of
    the notifications without authentication credentials. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd317.txt`
    file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个HTTP请求，以获取不带认证凭据的通知的第一页。示例的代码文件包含在`restful_python_2_03_01`文件夹中，在`Flask01/cmd317.txt`文件中：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd318.txt`
    file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例的代码文件包含在`restful_python_2_03_01`文件夹中，在`Flask01/cmd318.txt`文件中：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will receive a `401 Unauthorized` status code in the response header. The
    following lines show a sample response:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在响应头中收到`401 Unauthorized`状态码。以下行显示了示例响应：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we want to retrieve notification, that is, to make a `GET` request to `/service/notifications/`,
    we need to provide authentication credentials by using HTTP authentication. However,
    before we can do this, it is necessary to create a new user. We will use the new
    user to test our new resource classes related to users and our changes in the
    permissions policies. Run the following command to create a new user. The code
    file for the sample is included in the `restful_python_2_03_01` folder, in the
    `Flask01/cmd319.txt` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检索通知，即对`/service/notifications/`进行`GET`请求，我们需要通过使用HTTP认证提供认证凭据。然而，在我们能够这样做之前，有必要创建一个新的用户。我们将使用这个新用户来测试我们与用户相关的新资源类以及我们在权限策略中的更改。运行以下命令以创建新用户。示例的代码文件包含在`restful_python_2_03_01`文件夹中，在`Flask01/cmd319.txt`文件中：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd320.txt`
    file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例的代码文件包含在`restful_python_2_03_01`文件夹中，在`Flask01/cmd320.txt`文件中：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, the creation of a user and the execution of the methods that require
    authentication should only be possible under HTTPS. This way, the username and
    the password would be encrypted. The microservice that encapsulates the API in
    production must work under HTTPS.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，创建用户和执行需要认证的方法只能在HTTPS下进行。这样，用户名和密码将被加密。封装API的生产级微服务必须在HTTPS下运行。
- en: The previous command will compose and send an HTTP `POST` request with the specified
    JSON key-value pairs. The request specifies `/service/users/`, and therefore,
    it will match the `'/users/'` URL route for the `UserList` resource and run the
    `UserList.post` method that doesn't require authentication. The method doesn't
    receive arguments because the URL route doesn't include any parameters. As the
    HTTP verb for the request is `POST`, Flask calls the `post` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送一个带有指定JSON键值对的HTTP `POST`请求。请求指定`/service/users/`，因此，它将匹配`'/users/'`
    URL路由的`UserList`资源，并运行不需要认证的`UserList.post`方法。由于URL路由不包含任何参数，因此该方法不接收任何参数。由于请求的HTTP动词是`POST`，Flask调用`post`方法。
- en: 'The previously specified password only includes lowercase letters, and therefore,
    it doesn''t fulfill all the qualitative requirements we have specified for the
    passwords in the `User.check_password_strength_and_hash_if_ok` method. Thus, we
    will receive a `400 Bad Request` status code in the response header and the error
    message indicating the requirement that the password didn''t fulfill the quality
    requirements in the JSON body. The following lines show a sample response:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之前指定的密码仅包含小写字母，因此，它没有满足我们在`User.check_password_strength_and_hash_if_ok`方法中为密码指定的所有质量要求。因此，我们将在响应头中收到`400
    Bad Request`状态码，并在JSON体中显示错误消息，指出密码没有满足质量要求。以下行显示了示例响应：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following command will create a user with a valid password. The code file
    for the sample is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd321.txt`
    file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将创建一个具有有效密码的用户。示例代码文件包含在`restful_python_2_03_01`文件夹中的`Flask01/cmd321.txt`文件中：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd322.txt`
    file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例代码文件包含在`restful_python_2_03_01`文件夹中的`Flask01/cmd322.txt`文件中：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the new `User` instance is successfully persisted in the database, the call
    will return an HTTP `201 Created` status code and the recently persisted `User`
    serialized to JSON in the response body. The following lines show an example response
    for the HTTP request, with the new `User` object in the JSON responses. Notice
    that the response includes the URL, `url`, for the created user and doesn''t include
    any information related to the password:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的`User`实例成功持久化到数据库中，调用将返回HTTP `201 Created`状态码，并将最近持久化的`User`序列化为JSON格式放在响应体中。以下行显示了HTTP请求的示例响应，其中包含JSON响应中的新`User`对象。注意，响应中包含了创建用户的URL，`url`，但没有包含任何与密码相关的信息：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can run the previously explained command to check the contents of the `user`
    table that the migrations created in the PostgreSQL database. We will notice that
    the `password_hash` field contents are hashed for the new row in the `user` table.
    The following screenshot shows the contents for the new row of the `user` table
    in a PostgreSQL database after running the HTTP request:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行之前解释过的命令来检查PostgreSQL数据库中迁移创建的`user`表的内容。我们会注意到`user`表中新行的`password_hash`字段内容是经过散列的。以下截图显示了在运行HTTP请求后PostgreSQL数据库中`user`表新行的内容：
- en: '![](img/f485275a-696b-4908-b9a6-1bf1317daee4.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f485275a-696b-4908-b9a6-1bf1317daee4.png)'
- en: If we want to retrieve the first page of notifications, that is, to make an
    HTTP `GET` request to `/service/notifications/`, we need to provide authentication
    credentials using HTTP authentication.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检索通知的第一页，即向`/service/notifications/`发送HTTP `GET`请求，我们需要使用HTTP认证提供认证凭据。
- en: 'Now we will compose and send an HTTP request to retrieve the first page of
    messages with authentication credentials, that is, with the username we have recently
    created and his password. The code file for the sample is included in the `restful_python_2_03_01`
    folder, in the `Flask01/cmd323.txt` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个带有认证凭据的HTTP请求来检索消息的第一页，即使用我们最近创建的用户名和他的密码。示例代码文件包含在`restful_python_2_03_01`文件夹中的`Flask01/cmd323.txt`文件中：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd324.txt`
    file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例代码文件包含在`restful_python_2_03_01`文件夹中的`Flask01/cmd324.txt`文件中：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The user will be successfully authenticated and we will be able to process the
    request to retrieve the first page of the notifications persisted in the database.
    With all the changes we have made to our API, unauthenticated requests can only
    create a new user.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将成功认证，我们将能够处理请求以检索数据库中持久化的通知的第一页。随着我们对API所做的所有更改，未经认证的请求只能创建新用户。
- en: Test your knowledge
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'Which HTTP verb is meant to replace an entire resource:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个HTTP动词是用来替换整个资源的：
- en: '`PATCH`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PATCH`'
- en: '`POST`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`PUT`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: 'Which HTTP verb is meant to apply a delta to an existing resource:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个HTTP动词是用来对现有资源应用delta的：
- en: '`PATCH`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PATCH`'
- en: '`POST`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`PUT`'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: 'By default, the `passlib` library will use the SHA-512 scheme for 64-bit platforms
    with the minimum number of rounds set to:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`passlib`库将为64位平台使用SHA-512方案，并将最小轮数设置为：
- en: 135,000
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 135,000
- en: 335,000
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 335,000
- en: 535,000
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 535,000
- en: 'The `flask.g` object is:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flask.g`对象是：'
- en: A proxy that provides access to the current request
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个提供对当前请求访问的代理
- en: An instance of the `flask_httpauth.HTTPBasicAuth` class
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flask_httpauth.HTTPBasicAuth`类的实例'
- en: A proxy that allows us to store on this whatever we want to share for one request
    only
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个代理，允许我们存储在这个代理上我们想要在单个请求中共享的任何内容
- en: 'The `passlib` package provides:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`passlib`包提供：'
- en: A password hashing framework that supports more than 30 schemes
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个支持超过30种方案的密码散列框架
- en: An authentication framework ...
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个认证框架...
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we improved the RESTful API in many ways. We added user-friendly
    error messages for when resources aren't unique. We tested how to update single
    or multiple fields with the `PATCH` method and we created our own generic pagination
    class to enable us to paginate result sets.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从多个方面改进了RESTful API。我们添加了当资源不唯一时的用户友好错误信息。我们测试了如何使用`PATCH`方法更新单个或多个字段，并创建了自己的通用分页类，以便我们可以分页结果集。
- en: Then, we started working with authentication and permissions. We added a user
    model and we updated the underlying PostgreSQL database. We made many changes
    in the different pieces of code to achieve a specific security goal and we took
    advantage of `Flask-HTTPAuth` and `passlib` to use HTTP authentication in our
    API.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始处理认证和权限。我们添加了用户模型，并更新了底层的PostgreSQL数据库。我们在不同的代码片段中进行了许多更改，以实现特定的安全目标，并利用`Flask-HTTPAuth`和`passlib`在我们的API中使用HTTP认证。
- en: Now that we have built an improved a complex API that uses pagination and authentication,
    we will use additional abstractions included in the framework and we will code,
    execute and improve unit tests to get ready to encapsulate our API in a microservice,
    which are the topics of the next chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个改进的复杂API，该API使用了分页和认证功能，我们将使用框架中包含的额外抽象，并编写、执行和改进单元测试，为将我们的API封装成微服务做好准备，这些内容将是下一章的主题。
