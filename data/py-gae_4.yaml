- en: Chapter 4. Improving Application Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：提高应用程序性能
- en: Even if our Notes application lacks many details, at this point, we are using
    a number of key components of the Cloud Platform, and so it can be considered
    a fully fledged web application. This is a good opportunity to stop adding major
    features and trying to delve into some implementation details involving Datastore,
    Memcache, and the Modules service in order to optimize application performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的笔记应用程序缺少许多细节，到目前为止，我们已经在使用云平台的一些关键组件，因此它可以被认为是一个完整的网络应用程序。这是一个很好的机会停止添加主要功能，并尝试深入了解涉及
    Datastore、Memcache 和模块服务的实现细节，以优化应用程序性能。
- en: While going through this chapter, we have to take into consideration how optimizing
    a web application running on a pay-per-use service such as App Engine is crucial
    both to maximize performance and lower costs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章内容时，我们必须考虑到如何优化在按使用付费的服务（如 App Engine）上运行的网络应用程序，这对于最大化性能和降低成本至关重要。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: 'Gain a deeper knowledge of Datastore: properties, queries, caching, indexing
    and administration'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解 Datastore：属性、查询、缓存、索引和管理
- en: How to store transient data into Memcache
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将临时数据存储到 Memcache 中
- en: How to structure our application with the help of the Modules service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在模块服务的帮助下构建我们的应用程序
- en: Advanced use of Datastore
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Datastore 的高级使用
- en: We have already learned a lot about Datastore so far, including how to define
    entity kinds with model classes, the property concept, and how to make simple
    queries.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对 Datastore 学习了很多，包括如何使用模型类定义实体类型、属性概念以及如何进行简单查询。
- en: There is a lot more we can do with the NDB Python API to optimize an application,
    as we will see shortly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 NDB Python API 做很多事情来优化应用程序，正如我们很快就会看到的。
- en: More on properties – arrange composite data with StructuredProperty
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于属性的内容——使用 StructuredProperty 安排复合数据
- en: In our Notes application, we defined the `CheckListItem` model class to represent
    checkable items, and then we added a property to the `Note` model named `checklist_items`
    that references a list of that kind of entities. This is what we usually call
    a one-to-many relationship between notes and checklist items, and it is a common
    way to structure application data. By following this strategy, though, every time
    we add an item to a note, we have to create and store a new entity on Datastore.
    This is not a bad practice at all, but we have to take into consideration that
    we are charged for the use of Datastore depending on the number of operations
    we make; so, if we have a lot of data, keeping a low rate of write operations
    can potentially save a lot of money.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的笔记应用程序中，我们定义了 `CheckListItem` 模型类来表示可勾选项，然后我们在 `Note` 模型中添加了一个名为 `checklist_items`
    的属性，该属性引用了该种实体的列表。这通常被称为笔记和清单项之间的一对多关系，这是构建应用程序数据的一种常见方式。然而，按照这种策略，每次我们向笔记添加一个项目时，我们都必须在
    Datastore 中创建并存储一个新的实体。这根本不是什么坏习惯，但我们必须考虑到我们根据所进行的操作数量来支付 Datastore 的使用费用；因此，如果我们有大量数据，保持低写入操作率可以潜在地节省很多钱。
- en: 'The Python NDB API provides a property type called `StructuredProperty` we
    can use to include one kind of model inside another; instead of referencing the
    `CheckListItem` model from a property of the type `KeyProperty` in the `Note`
    model, we store it in a property of the type `StructuredProperty`. In our `models.py`
    module, we change the Note model as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python NDB API 提供了一种名为 `StructuredProperty` 的属性类型，我们可以使用它将一种模型包含在另一种模型中；而不是在
    `Note` 模型的 `KeyProperty` 类型的属性中引用 `CheckListItem` 模型，我们将其存储在 `StructuredProperty`
    类型的属性中。在我们的 `models.py` 模块中，我们按照以下方式更改 Note 模型：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `main.py` module, we need to adjust the code to store checklist items
    when we create a new note, so we refactor the `create_note` method in this way:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.py` 模块中，当我们创建新笔记时需要调整代码以存储清单项，因此我们这样重构了 `create_note` 方法：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First of all, we move the call to the `note.put()` method right below the note
    creation; we don't need to provide a valid key to the `parent` parameter in the
    `CheckListItem` constructor, so we can persist the `Note` instance later, at the
    end of the method. We then instance a `CheckListItem` object for every item we
    want to add to the note as before, but without actually creating any entity in
    Datastore; these objects will be transparently serialized by the NDB API within
    the `Note` entity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将对 `note.put()` 方法的调用移至笔记创建下方；我们不需要在 `CheckListItem` 构造函数的 `parent` 参数中提供一个有效的键，因此我们可以在方法末尾持久化
    `Note` 实例。然后，我们为每个想要添加到笔记中的项目实例化一个 `CheckListItem` 对象，就像之前一样，但实际上并不在 Datastore
    中创建任何实体；这些对象将由 NDB API 在 `Note` 实体内部透明地序列化。
- en: 'We need to adjust the HTML template as well, as the `checklist_items` property
    in notes entities does not contain a list of keys anymore; it contains a list
    of `CheckListItem` objects instead. In the `main.html` file, we change the code
    accordingly, removing the `get()` method calls:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调整 HTML 模板，因为笔记实体中的 `checklist_items` 属性不再包含键的列表；它包含 `CheckListItem` 对象的列表。在
    `main.html` 文件中，我们相应地更改代码，删除了 `get()` 方法的调用：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To see how it''s easy to work with structured properties, we add a very small
    feature to the app: a link to toggle the checked status for items in checklists.
    To toggle the status of an item, we have to provide the request handler with the
    key of the note containing the item and the index of the item itself inside the
    `checklist_items` list, so we build a URL with the scheme `/toggle/<note_key>/<item_index>`.
    In the `main.html` file, we add this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到与结构化属性一起工作是多么容易，我们在应用程序中添加了一个非常小的功能：一个切换清单中项目选中状态的链接。为了切换项目的状态，我们必须向请求处理程序提供包含项目的笔记的键以及
    `checklist_items` 列表中项目的索引，因此我们构建了一个具有方案 `/toggle/<note_key>/<item_index>` 的 URL。在
    `main.html` 文件中，我们添加了以下内容：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instances of the `Key` class have a `urlsafe()` method that serializes key
    objects into a string that can be safely used as part of URLs. To retrieve the
    current index inside a loop, we use the `loop.index` expression provided by Jinja2\.
    We can also add a simple CSS rule to the `notes.css` file to make the items look
    a little better:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Key` 类的实例有一个 `urlsafe()` 方法，可以将键对象序列化为一个字符串，该字符串可以安全地用作 URL 的一部分。为了在循环中检索当前索引，我们使用
    Jinja2 提供的 `loop.index` 表达式。我们还可以向 `notes.css` 文件中添加一个简单的 CSS 规则，使项目看起来更好一些：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To implement the toggling logic, we add the `ToggleHandler` class in the `main.py`
    module:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现切换逻辑，我们在 `main.py` 模块中添加了 `ToggleHandler` 类：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We normalize the item index so that it is zero-based, and then we load a note
    entity from Datastore using its key. We instantiate a `Key` object passing the
    string generated with the `urlsafe()` method to the constructor with the `urlsafe`
    keyword parameter, then we retrieve the entity with the `get()` method. After
    toggling the state of the item at the requested index, we update the note content
    in Datastore calling the `put()` method. We finally redirect users to the main
    page of the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将项目索引标准化，使其从零开始，然后使用其键从 Datastore 加载一个笔记实体。我们通过将使用 `urlsafe()` 方法生成的字符串传递给构造函数并使用
    `urlsafe` 关键字参数来实例化一个 `Key` 对象，然后使用 `get()` 方法检索实体。在切换请求索引处的项目状态后，我们通过调用 `put()`
    方法更新 Datastore 中的笔记内容。最后，我们将用户重定向到应用程序的主页。
- en: 'Eventually, we add the URL mapping to the application constructor with a regular
    expression matching our URL scheme, `/toggle/<note_key>/<item_index>`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将 URL 映射添加到应用程序构造函数中，使用正则表达式匹配我们的 URL 方案，`/toggle/<note_key>/<item_index>`：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Working with structured properties is straightforward; we simply access properties
    and fields of the objects contained in the `checklist_items` property as they
    were actual entities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与结构化属性一起工作很简单；我们只需像访问实际实体一样访问 `checklist_items` 属性中包含的对象的属性和字段。
- en: The only drawback of this approach is that `CheckListItem` entities are not
    actually stored in Datastore; they don't have a key and we cannot load them independently
    from the `Note` entity they belong to, but this is perfectly fine for our use
    case. Instead of loading the `CheckListItem` entity we want to update, we load
    the `Note` entity and we use the index to access the item. In exchange, during
    notes creation, we save a `put()` method call for the note and a `put()` method
    call for each item in the checklist and when retrieving a note, we save a `get()`
    method call for each item in the checklist. Needless to say, this kind of optimization
    can impact favorably on application costs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的唯一缺点是`CheckListItem`实体实际上并没有存储在Datastore中；它们没有键，我们不能独立于它们所属的`Note`实体来加载它们，但这对我们的用例来说完全没问题。我们不是加载我们想要更新的`CheckListItem`实体，而是加载`Note`实体，并使用索引来访问项目。作为交换，在笔记创建期间，我们为笔记保存一个`put()`方法调用，并为清单中的每个项目保存一个`put()`方法调用；在检索笔记时，我们为清单中的每个项目保存一个`get()`方法调用。不言而喻，这种优化可以有利于应用程序的成本。
- en: More on queries – save space with projections and optimize iterations with mapping
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于查询的内容 - 使用投影来节省空间，并使用映射来优化迭代
- en: Queries are used within an application to search Datastore for entities that
    match a search criteria we can define through filters. We have already used Datastore
    queries to retrieve entities with a filter; for example, every time we perform
    an ancestor query, we are actually filtering out these entities that have a different
    parent from the one we provided to the NDB API `query()` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查询在应用程序中用于搜索Datastore中的实体，这些实体符合我们可以通过过滤器定义的搜索标准。我们已经使用Datastore查询通过过滤器检索实体；例如，每次我们执行祖先查询时，我们实际上是在过滤掉那些具有与提供给NDB
    API `query()`函数不同的父实体的这些实体。
- en: 'There is much more we can do with query filters though, and in this section,
    we will see, in detail, two features provided by the NDB API that can be used
    to optimize application performance: projection queries and mapping.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还可以使用查询过滤器做更多的事情，在本节中，我们将详细探讨NDB API提供的两个可以用来优化应用程序性能的功能：投影查询和映射。
- en: Projection queries
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影查询
- en: When we retrieve an entity with a query, we get all the properties and data
    for that entity as expected; sometimes though, after retrieving an entity, we
    use a small subset of its data. For example, take the `post()` method in our `ShrinkHandler`
    class; we perform an ancestor query to retrieve only the notes belonging to the
    currently logged in user, then we invoke the `_shrink_note()` method on each of
    them. The `_shrink_note()` method only accesses the `files` property from note
    entities, so we are keeping in memory and passing around a rather large object
    even if we only need a very small part of it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用查询检索一个实体时，我们会得到该实体的所有属性和数据，这是预期的；但有时，在检索一个实体之后，我们只使用其数据的一个小子集。例如，看看我们`ShrinkHandler`类中的`post()`方法；我们执行一个祖先查询来检索属于当前登录用户的笔记，然后对每个笔记调用`_shrink_note()`方法。`_shrink_note()`方法只访问笔记实体的`files`属性，所以即使我们只需要它的一小部分，我们仍然在内存中保留并传递一个相当大的对象。
- en: 'With the NDB API, we can pass a projection parameter to the `fetch()` method
    that contains a list of properties we want to be set for the entities retrieved.
    For example, in the `post()` method of the `ShrinkHandler` class, we can modify
    the code in this way:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NDB API，我们可以向`fetch()`方法传递一个投影参数，该参数包含我们想要为检索到的实体设置的属性列表。例如，在`ShrinkHandler`类的`post()`方法中，我们可以这样修改代码：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a so-called projection query and the entities fetched in this way will
    have only the `files` property set. The fetch is much more efficient because it
    retrieves and serializes less data and entities use less space while in memory.
    If we try to access any other property than `files` on such entities, an `UnprojectedPropertyError`
    error will be raised.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种所谓的投影查询，以这种方式检索到的实体将只设置`files`属性。这种检索方式效率更高，因为它检索和序列化的数据更少，实体在内存中占用的空间也更少。如果我们尝试访问这些实体上的任何其他属性而不是`files`，将会抛出`UnprojectedPropertyError`错误。
- en: Projections have some limitations we must be aware of. First of all, as we can
    expect, entities fetched with a projection cannot be saved back on Datastore because
    they are only partially populated. Another limitation is regarding indexes; in
    fact, we can only specify indexed properties in a projection and this makes it
    impossible to project properties with unindexed types such as the `TextProperty`
    type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 投影有一些我们必须注意的限制。首先，正如我们所预期的，使用投影获取的实体不能在 Datastore 上保存，因为它们只是部分填充的。另一个限制是关于索引的；实际上，我们只能在投影中指定索引属性，这使得无法投影具有未索引类型（如
    `TextProperty` 类型）的属性。
- en: Mapping
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: 'Sometimes, we need to call the same function on a set of entities returned
    by a query. For example, in the `post()` method of the `ShrinkHandler` class,
    we need to call the `_shrink_note()` method on all the note entities for the current
    user:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要在查询返回的一组实体上调用相同的函数。例如，在 `ShrinkHandler` 类的 `post()` 方法中，我们需要对当前用户的每个笔记实体调用
    `_shrink_note()` 方法：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We first fetch all the entities matching the query in the notes list, then
    we call the same function for every item in the list. We can rewrite that code
    replacing the `for` iteration with a single call to the `map()` method provided
    by the NDB API:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取与笔记列表中查询匹配的所有实体，然后对列表中的每个项目调用相同的函数。我们可以通过用 NDB API 提供的 `map()` 方法的一个单独调用替换
    `for` 迭代来重写那段代码：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We call the `map()` method passing the callback function we want to be called
    on each result of the query; the callback function receives an entity object of
    kind Note as its only parameter, unless we invoke the `map()` method with the
    `keys_only=True` parameter. In this case, the callback will receive a `Key` instance
    when invoked.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递我们希望在查询的每个结果上调用的回调函数来调用 `map()` 方法；回调函数接收一个类型为 Note 的实体对象作为其唯一参数，除非我们使用
    `keys_only=True` 参数调用 `map()` 方法。在这种情况下，当被调用时，回调将接收一个 `Key` 实例。
- en: 'Since the `map()` method accepts the standard set of query options (that''s
    why we can pass the `keys_only` parameter), we can perform the mapping for a projection
    query too:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `map()` 方法接受标准查询选项集（这就是为什么我们可以传递 `keys_only` 参数），我们也可以对投影查询执行映射：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Besides the projection, this version of the code is slightly more efficient
    because the Datastore can apply some concurrency while loading entities and the
    results are retrieved in batches instead of fetching the entire dataset in memory.
    If we want to get information regarding the current batch inside the callback
    function, we need to pass the `pass_batch_into_callback=True` parameter when calling
    the `map()` method. In this case, the callback will receive three parameters:
    a `Batch` object provided by App Engine that wraps a lot of information about
    the current batch, the index of the current item inside the current batch, and
    the entity object (or the entity key if the `keys_only` parameter was used) fetched
    from Datastore.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了投影之外，这个版本的代码稍微更有效率，因为 Datastore 可以在加载实体时应用一些并发性，并且结果是以批量的形式检索的，而不是在内存中检索整个数据集。如果我们想在回调函数内部获取有关当前批次的详细信息，我们需要在调用
    `map()` 方法时传递 `pass_batch_into_callback=True` 参数。在这种情况下，回调将接收三个参数：一个由 App Engine
    提供的 `Batch` 对象，它封装了大量有关当前批次的详细信息，当前批次中当前项目的索引，以及从 Datastore 获取的实体对象（或如果使用了 `keys_only`
    参数，则为实体键）。
- en: NDB asynchronous operations
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NDB 异步操作
- en: As we can expect, Datastore is a key component when considering application
    performance; adjusting queries and using the right idioms can dramatically improve
    efficiency and lower costs but there's more. Thanks to the NDB API, we can speed
    up our applications by performing Datastore actions in parallel with other jobs,
    or performing a number of Datastore actions concurrently.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，Datastore 是考虑应用程序性能时的一个关键组件；调整查询和使用正确的惯用表达式可以显著提高效率并降低成本，但还有更多。多亏了
    NDB API，我们可以在与其他作业并行执行 Datastore 操作或同时执行多个 Datastore 操作来加速我们的应用程序。
- en: Several functions provided by the NDB API have an `_async` counterpart that
    takes exactly the same arguments, such as the `put` and `put_async` functions.
    Every async function returns a **future**, an object that represents an operation
    that was started but possibly not completed. We get the result of an async operation
    from the future itself calling the `get_result()` method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: NDB API 提供的几个函数都有一个 `_async` 对应版本，它们接受完全相同的参数，例如 `put` 和 `put_async` 函数。每个异步函数都返回一个
    **future**，这是一个表示已启动但可能尚未完成的操作的对象。我们可以通过调用 `get_result()` 方法从 future 本身获取异步操作的结果。
- en: 'In our Notes application, we can use asynchronous operations in the `_render_template()`
    method of the `MainHandler` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的笔记应用程序中，我们可以在`MainHandler`类的`_render_template()`方法中使用异步操作：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Currently, we wait for the notes to be fetched before loading the template
    but we can load the template while Datastore is working:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在加载模板之前等待获取笔记，但我们可以同时在数据存储工作时加载模板：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this way, the application doesn't block on fetching data because the `fetch_async()`
    method returns immediately; we then proceed loading the template while the Datastore
    is working. When it's time to fill the context variable, we call the `get_result()`
    method on the future object. At this point, either the result is available and
    we proceed with rendering operations, or the `get_result()` method blocks, waiting
    for Datastore to be ready. In both cases, we managed to perform two tasks in parallel,
    thereby increasing the performance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，应用程序在获取数据时不会阻塞，因为`fetch_async()`方法会立即返回；我们随后继续加载模板，同时数据存储正在工作。当需要填充上下文变量时，我们在未来对象上调用`get_result()`方法。在这个时候，要么结果可用，我们继续进行渲染操作，要么`get_result()`方法会阻塞，等待数据存储准备好。在这两种情况下，我们都成功地并行执行了两个任务，从而提高了性能。
- en: With the NDB API, we can also implement asynchronous tasks called **tasklets**
    that return a future while performing other work. For example, earlier in this
    chapter, we used the `map()` method in the `ShrinkHandler` class to call the same
    function on a set of entities retrieved from Datastore. We know that code is slightly
    more efficient than the version with the explicit `for` iteration, but it's not
    much faster actually; the callback function blocks on a synchronous `get()` method,
    so every step of the mapping waits for the previous to finish.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NDB API，我们还可以实现称为**任务函数**的异步任务，在执行其他工作的同时返回一个未来。例如，在本章的早期，我们在`ShrinkHandler`类中使用`map()`方法对从数据存储检索的一组实体调用相同的函数。我们知道这段代码比显式`for`循环版本稍微高效一些，但实际上并没有快多少；回调函数在同步的`get()`方法上阻塞，因此映射的每一步都要等待前一步完成。
- en: 'If we turn the callback function into a tasklet, App Engine can run the mapping
    in parallel, dramatically speeding up application performance. Writing tasklets
    is simple, thanks to the NDB API; for example the `_shrink_note()` method of the
    `ShrinkHandler` class can be transformed in a tasklet with just two lines of code,
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将回调函数转换为任务函数，App Engine可以并行运行映射，从而显著提高应用程序性能。由于NDB API，编写任务函数很简单；例如，`ShrinkHandler`类的`_shrink_note()`方法只需两行代码就可以转换为任务函数，如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We first apply the `ndb.tasklet` decorator to the function we want to turn into
    a tasklet; the decorator provides all the logic to support the future mechanism
    with the `get_result()` method. We then use the `yield` statement to tell App
    Engine that we will suspend at that point of the execution, waiting for the result
    of the `get_async()` method. While we suspend, the `map()` method can execute
    another tasklet with a different entity instead of waiting for us to finish.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`ndb.tasklet`装饰器应用于我们想要转换为任务函数的函数；装饰器提供了所有逻辑来支持带有`get_result()`方法的前置机制。然后我们使用`yield`语句告诉App
    Engine，我们将在执行的那个点暂停，等待`get_async()`方法的结果。在我们暂停期间，`map()`方法可以执行另一个具有不同实体的任务函数，而不是等待我们完成。
- en: Caching
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: Caching is a critical component on a system such as App Engine because it impacts
    on application performance and Datastore roundtrips and thus on application costs.
    The NDB API automatically manages the cache for us and provides a set of tools
    to configure the caching system. It's important to understand how NDB cache works
    if we want to take advantage of such features.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是像App Engine这样的系统中的关键组件，因为它影响应用程序性能和数据存储往返，从而影响应用程序成本。NDB API自动为我们管理缓存，并提供了一套配置缓存系统的工具。如果我们想利用这些功能，理解NDB缓存的工作方式非常重要。
- en: 'NDB uses two caching levels: the **in-context** cache that runs in process
    memory and a gateway to the App Engine Memcache service. The in-context cache
    stores data only for the duration of a single HTTP request and is local to the
    code that processes the request, so it is extremely fast. When we use a NDB function
    to write data on the Datastore, it first populates the in-context cache. Symmetrically,
    when we use a NDB function to fetch an entity from Datastore, it first searches
    for it in the in-context cache without even accessing Datastore in the best-case
    scenario.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: NDB 使用两个缓存级别：运行在进程内存中的 **in-context** 缓存和连接到 App Engine Memcache 服务的网关。in-context
    缓存仅在单个 HTTP 请求的持续时间内存储数据，并且仅对处理请求的代码本地，因此它非常快。当我们使用 NDB 函数在 Datastore 上写入数据时，它首先填充
    in-context 缓存。对称地，当我们使用 NDB 函数从 Datastore 获取实体时，它首先在 in-context 缓存中搜索，甚至在最佳情况下都不需要访问
    Datastore。
- en: Memcache is slower than the in-context cache but still way faster than Datastore.
    By default, every Datastore operation performed outside a transaction is cached
    on Memcache and App Engine ensures that data resides on the same server to maximize
    performance. The NDB ignores Memcache when it operates inside a transaction but
    when a transaction is committed, it will attempt to remove all the entities involved
    from Memcache, and we must take into account that some of these deletions can
    fail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Memcache 的速度比 in-context cache 慢，但仍然比 Datastore 快得多。默认情况下，所有在事务外执行的 Datastore
    操作都会在 Memcache 上进行缓存，并且 App Engine 确保数据位于同一服务器上以最大化性能。当 NDB 在事务内操作时忽略 Memcache，但在提交事务时，它会尝试从
    Memcache 中删除所有涉及的实体，我们必须考虑到其中一些删除可能会失败。
- en: Both the caches are managed by a so-called context, represented by an instance
    of the class `Context` provided by App Engine. Each incoming HTTP request and
    each transaction is executed in a new context, and we can access the current context
    using the `get_context()` method provided by the NDB API.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个缓存都由一个所谓的上下文管理，该上下文由 App Engine 提供的 `Context` 类的实例表示。每个传入的 HTTP 请求和每个事务都在一个新的上下文中执行，我们可以使用
    NDB API 提供的 `get_context()` 方法访问当前上下文。
- en: 'In our Notes application, we''ve already experienced one of these rare situations
    where NDB automatic caching is actually an issue; in the `_reload_user()` method
    in `CreateNoteHandler` class, we had to force a reload of the `UserLoader` entity
    from Datastore as a workaround to populate a `User` object. Between the `put()`
    method and the `get()` method of the `UserLoader` entity, we wrote this instruction
    to remove the entity from any location except Datastore:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Notes 应用程序中，我们已经经历过这些罕见的情况之一，即 NDB 自动缓存实际上是一个问题；在 `CreateNoteHandler` 类的
    `_reload_user()` 方法中，我们必须强制从 Datastore 重新加载 `UserLoader` 实体，作为填充 `User` 对象的解决方案。在
    `UserLoader` 实体的 `put()` 方法和 `get()` 方法之间，我们编写了这个指令来从除 Datastore 之外的所有位置删除实体：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Without this instruction, the NDB caching system would not have fetched the
    entity from Datastore from scratch as we needed. Now that we know how NDB caching
    works, we can rewrite that method in an equivalent way, thus being more explicit
    about cache management, using the `Context` instance:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个指令，NDB 缓存系统就不会从头开始从 Datastore 获取实体，正如我们所需要的。现在我们知道了 NDB 缓存的工作方式，我们可以以等效的方式重写那个方法，从而更明确地管理缓存，使用
    `Context` 实例：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `set_cache_policy()` method exposed by the context object accepts a key
    object and returns a Boolean result. When the method returns the `False` parameter,
    the entity identified by that key won't be saved in any cache; in our case, we
    return the `False` parameter only when the entity is of the kind `UserLoader`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由上下文对象公开的 `set_cache_policy()` 方法接受一个键对象并返回一个布尔结果。当该方法返回 `False` 参数时，由该键标识的实体不会被保存到任何缓存中；在我们的情况下，我们仅在实体为
    `UserLoader` 类型时返回 `False` 参数。
- en: Backup and restore functionalities
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份和恢复功能
- en: In order to use the backup and restore functionalities provided by App Engine
    for Datastore, we first need to enable **Datastore Admin**, which is disabled
    by default. Datastore Admin is a web application that provides a set of tools
    very useful for administrative tasks. At the time writing this, the only way to
    enable and access Datastore Admin is via the old Admin Console available at [https://appengine.google.com](https://appengine.google.com).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 App Engine 为 Datastore 提供的备份和恢复功能，我们首先需要启用 **Datastore Admin**，默认情况下它是禁用的。Datastore
    Admin 是一个提供一组非常有助于管理任务的 Web 应用程序。在撰写本文时，启用和访问 Datastore Admin 的唯一方法是使用位于 [https://appengine.google.com](https://appengine.google.com)
    的旧版 Admin Console。
- en: 'We access the console for our project and then we have to perform the following
    steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们访问我们的项目控制台，然后我们必须执行以下步骤：
- en: Click on the **Datastore Admin** menu under the **Data** section on the left
    of the page.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面左侧**数据**部分下的**数据存储管理员**菜单。
- en: Click on the button to enable the admin.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮以启用管理员。
- en: Select one or more entity kinds we want to backup or restore.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个或多个我们想要备份或恢复的实体类型。
- en: 'To perform a complete backup, we first have to put our application in read-only
    mode. From the console, we need to perform the following steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行完整备份，我们首先必须将我们的应用程序置于只读模式。从控制台，我们需要执行以下步骤：
- en: Click on **Application Settings** under the **Administration** menu on the left.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧**管理**菜单下的**应用程序设置**。
- en: At the bottom of the page, click on the **Disable Writes...** button under the
    **Disable Datastore Writes** option.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面底部，点击**禁用写入...**按钮，位于**禁用数据存储写入**选项下。
- en: Return to the **Datastore Admin** section and select all the entity kinds we
    want to backup.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**数据存储管理员**部分，并选择我们想要备份的所有实体类型。
- en: Click on the **Backup Entities** button.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**备份实体**按钮。
- en: Select the destination of the backup and choose between **blobstore** and **Cloud
    Storage**. Specify a name for the backup file.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择备份的目标位置，并在**blobstore**和**云存储**之间进行选择。指定备份文件的名称。
- en: Click on the **Backup Entities** button.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**备份实体**按钮。
- en: The backup runs in the background; once finished, it is listed in **Datastore
    Admin**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 备份在后台运行；一旦完成，它就会在**数据存储管理员**中列出。
- en: Re-enable writings for our application.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启用我们应用程序的写入权限。
- en: From Datastore Admin, we can select a backup and perform a restore. After starting
    a restore operation, Datastore Admin will ask us which entity kinds we want to
    restore, and then it'll proceed in background.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据存储管理员界面，我们可以选择一个备份并执行恢复操作。在开始恢复操作后，数据存储管理员会询问我们想要恢复哪些实体类型，然后它将在后台进行。
- en: Indexing
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引
- en: Indexes are tables that list Datastore entities in a sequence determined by
    certain properties of the index and optionally by entities' ancestors. Every time
    we write on Datastore, indexes are updated to reflect the changes to their respective
    entities; when we read from Datastore, results are fetched accessing indexes.
    This is basically the reason why reading from Datastore is way much faster than
    writing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是按索引的某些属性和可选的实体祖先顺序排列的数据存储实体的表。每次我们对数据存储进行写入时，索引都会更新以反映它们各自实体的变化；当我们从数据存储读取时，结果通过访问索引来获取。这基本上是为什么从数据存储读取比写入快得多的原因。
- en: Our Notes application performs several queries, which means that some index
    must be in place, but we have never directly managed or created indexes. This
    is because of two reasons. The first reason is that when we run the local development
    server, it scans our source code, searching for queries and automatically generates
    the code to create all the indexes needed. The other reason is that Datastore
    automatically generates basic indexes called predefined indexes for each property
    of every kind, functional for simple queries.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Notes应用程序执行多个查询，这意味着必须存在某些索引，但我们从未直接管理或创建索引。这是因为两个原因。第一个原因是当我们运行本地开发服务器时，它会扫描我们的源代码，寻找查询并自动生成创建所有所需索引的代码。另一个原因是数据存储为每个类型的每个属性自动生成基本索引，称为预定义索引，这对于简单的查询是有用的。
- en: 'Indexes are declared in the `index.yaml` file at the application root with
    the following syntax:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 索引在应用程序根目录的`index.yaml`文件中声明，其语法如下：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These are the properties needed to define and create the index that allows us
    to perform queries against Note entities that belong to the currently logged-in
    user and sort them in reverse by date. When we deploy the application, the `index.yaml`
    file is uploaded and App Engine starts to build the indexes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是需要定义和创建索引的属性，以便我们对属于当前登录用户的Note实体进行查询，并按日期逆序排序。当我们部署应用程序时，`index.yaml`文件会被上传，并且App
    Engine开始构建索引。
- en: 'If our application exercises every possible kind of query, including every
    sorting combination, then the entries generated by the development server will
    represent a complete set of indexes. This is why, in the vast majority of the
    cases, we don''t need to declare indexes or customize existing ones unless we
    have a very special case to deal with. Anyway, in order to optimize our application,
    we can disable indexing for properties we know we will never make a query on.
    Predefined indexes are not listed in the `index.yaml` file but we can use the
    properties'' constructors inside the `models.py` module to disable them. For example,
    if we know in advance that we will never search for `NoteFile` entities directly
    with a query, we can disable indexing for all its properties:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序执行了每一种可能的查询，包括每一种排序组合，那么开发服务器生成的条目将代表一个完整的索引集。这就是为什么在绝大多数情况下，我们不需要声明索引或自定义现有的索引，除非我们有一个非常特殊的案例需要处理。无论如何，为了优化我们的应用程序，我们可以禁用那些我们知道永远不会进行查询的属性上的索引。预定义的索引没有列在`index.yaml`文件中，但我们可以使用`models.py`模块中的属性构造函数来禁用它们。例如，如果我们事先知道我们永远不会直接通过查询搜索`NoteFile`实体，我们可以禁用所有其属性的索引：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By passing the `indexed=False` parameter to constructors, we avoid App Engine
    to create indexes for those properties so that every time we store a `NoteFile`
    entity, there will be less indexes to update, speeding up writing operations.
    The `NoteFile` entities can be still retrieved from the `files` property within
    the `Note` entity because App Engine will keep on creating the predefined index
    to retrieve entities by kind and key.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`indexed=False`参数传递给构造函数，我们避免了App Engine为这些属性创建索引，这样每次我们存储一个`NoteFile`实体时，将会有更少的索引需要更新，从而加快写入操作。`NoteFile`实体仍然可以通过`Note`实体中的`files`属性检索，因为App
    Engine会继续创建预定义的索引来按类型和键检索实体。
- en: Using Memcache
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Memcache
- en: We already know that Memcache is the distributed in-memory data cache provided
    by App Engine. A typical use case would be to use it as a cache for rapid data
    retrieval from persistent storage such as Datastore, but we already know that
    the NDB API does this for us, so there's no need to explicitly cache entities.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道Memcache是App Engine提供的分布式内存数据缓存。一个典型的用法是将其用作从持久存储（如Datastore）快速检索数据的缓存，但我们已经知道NDB
    API会为我们做这件事，所以没有必要显式地缓存实体。
- en: Data stored in Memcache can be evicted at any time, so we should cache only
    data that we can safely lose without affecting integrity. For example, in our
    Notes application, we can cache the total number of notes globally stored for
    every user and display this nice kind of metric on the home page. We can perform
    a Datastore query counting `Note` entities every time a user visits the main page
    but this would be cumbersome, possibly nullifying every optimization we made so
    far. A better strategy would be to keep a counter in the Memcache and increment
    that counter every time a note is created within the application; if Memcache
    data expires, we make the counting query again without losing any data and start
    over incrementing the in-memory counter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在Memcache中的数据可以随时被清除，因此我们只应该缓存那些即使丢失也不会影响完整性的数据。例如，在我们的笔记应用中，我们可以缓存每个用户全局存储的笔记总数，并在主页上显示这种类型的指标。每次用户访问主页时，我们都可以执行一个查询来计算`Note`实体，但这会很麻烦，可能会抵消我们迄今为止所做的所有优化。更好的策略是在Memcache中保持一个计数器，并在应用中创建笔记时增加该计数器；如果Memcache数据过期，我们将再次执行计数查询而不会丢失任何数据，并重新开始增加内存中的计数器。
- en: 'We implement two functions to wrap Memcache operations: one to get the value
    of the counter and another to increment it. We first create a new Python module
    in the `utils.py` file that contains the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现两个函数来封装Memcache操作：一个用于获取计数器的值，另一个用于增加它。我们首先在`utils.py`文件中创建一个新的Python模块，该模块包含以下代码：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We first try to access counter value from Memcache calling the `get()` method
    asking for the `note_count` key. If the return value is `None`, we assume the
    key is not in cache and we proceed querying Datastore. We then store the result
    of the query in Memcache and return that value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试从Memcache中调用`get()`方法访问计数器的值，请求`note_count`键。如果返回值是`None`，我们假设键不在缓存中，然后我们继续查询Datastore。然后我们将查询的结果存储在Memcache中，并返回该值。
- en: 'We want to display the counter on the main page, so we add it to the template
    context in the `_render_template()` method of the `MainHandler` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在主页上显示计数器，所以我们在`MainHandler`类的`_render_template()`方法中将它添加到模板上下文中：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before using the function to get the counter, we need to import it from the
    `main` module:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用函数获取计数器之前，我们需要从 `main` 模块中导入它：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have to modify the HTML template as well:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改 HTML 模板：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can then refresh the main page of the Notes application to see the counter
    in action. Now it's time to write the code that increments the counter, but there's
    something we should be aware of before proceeding.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以刷新笔记应用程序的主页，以查看计数器的实际效果。现在，我们需要编写增加计数器的代码，但在继续之前，有一些事情我们应该注意。
- en: Multiple requests can try to increment the value in Memcache concurrently, potentially
    causing race conditions. To avoid this scenario, Memcache provides two functions,
    `incr()` and `decr()`, which atomically increment and decrement a 64-bit integer
    value. These would be perfectly suitable for our counter but we can provide a
    more general solution that works also for cache values that are not integers using
    the **compare** and **set** feature of the App Engine Python API.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 多个请求可能会并发尝试在 Memcache 中增加值，这可能导致竞争条件。为了避免这种情况，Memcache 提供了两个函数，`incr()` 和 `decr()`，它们可以原子性地增加和减少
    64 位整数值。这些将非常适合我们的计数器，但我们可以提供一个更通用的解决方案，该解决方案也适用于非整数的缓存值，使用 App Engine Python
    API 的 **比较** 和 **设置** 功能。
- en: 'In the `utils.py` module, we add the following function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `utils.py` 模块中，我们添加了以下函数：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We use an instance of the `Client` class because the compare and set functionalities
    are not provided as functions in the `memcache` module. After getting a `Client`
    instance, we enter the so-called `retry` loop that we reiterate up to 10 times
    if we detect a rare condition. We then try to get the value for the `note_count`
    key using the `gets` method of the client. This method alters the internal state
    of the client storing a timestamp value provided by the Memcache service. We then
    try to increment the value corresponding to the same key calling the `cas()` method
    on the client object; the method transmits the new value for the key to Memcache,
    plus the previously mentioned timestamp. If the timestamp matches, the value is
    updated and the `cas()` method returns the `True` parameter causing the `retry`
    loop to exit; otherwise, it returns the `False` parameter and we try again.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Client` 类的一个实例，因为 `memcache` 模块中没有提供比较和设置功能作为函数。在获取到 `Client` 实例后，我们进入所谓的
    `retry` 循环，如果检测到罕见条件，我们将重复迭代最多 10 次。然后我们尝试使用客户端的 `gets` 方法获取 `note_count` 键的值。此方法会改变客户端的内部状态，存储由
    Memcache 服务提供的戳记值。然后我们尝试通过在客户端对象上调用 `cas()` 方法来增加与同一键对应的值；该方法将键的新值传输到 Memcache，以及之前提到的戳记。如果戳记匹配，则值被更新，`cas()`
    方法返回 `True` 参数，导致 `retry` 循环退出；否则，它返回 `False` 参数，我们再次尝试。
- en: 'After importing the `inc_note_counter()` function in the main module, we can
    call it to increment the counter wherever we create a new note: within the `_create_note`
    of the `MainHandler` class and within the `_create_note` method in the `CreateNoteHandler`
    class.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 模块中导入 `inc_note_counter()` 函数后，我们可以在创建新笔记的地方调用它来增加计数器：在 `MainHandler`
    类的 `_create_note` 中，以及在 `CreateNoteHandler` 类的 `_create_note` 方法中。
- en: Breaking our application into modules
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的应用程序拆分为模块
- en: At the moment, our Notes application provides some frontend functionalities
    such as serving the main page, together with backend functionalities such as handling
    cron jobs. This is fine for most use cases but if the application architecture
    is complex and we have a lot of traffic, having several backend jobs around that
    steal resources from the frontend cannot be always acceptable. To face this kind
    of problems, App Engine provides an extremely flexible way to lay out a web application
    with the use of **modules**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的笔记应用程序提供了一些前端功能，例如服务主页，以及一些后端功能，例如处理定时任务。这对于大多数用例来说是可以的，但如果应用程序架构复杂且流量很大，那么有多个后端任务占用资源，这并不总是可以接受的。为了应对这类问题，App
    Engine 提供了一种极其灵活的方式来使用 **模块** 来布局 Web 应用程序。
- en: Every App Engine application is made up of at least on module; even if we didn't
    already know it, so far we have worked on the default module of our Notes application.
    A module is identified by a name, consists of source code and configuration files,
    and can reside in the application root or in a subfolder. Every module has a version
    and we can deploy multiple versions of the same module; each version will spawn
    one or more App Engine instances depending on how we configured it for scaling.
    The ability to deploy multiple versions of the same module, in particular, is
    very useful for testing new components or deploying progressive upgrades. Modules
    that are part of the same application share services such as Memcache, Datastore,
    and task queues, and can communicate in a secure fashion using the modules of
    the Python API.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个App Engine应用程序至少由一个模块组成；即使我们之前不知道，到目前为止，我们已经处理了Notes应用程序的默认模块。模块通过名称标识，由源代码和配置文件组成，可以位于应用程序根目录或子目录中。每个模块都有一个版本，我们可以部署同一模块的多个版本；每个版本将根据我们如何配置其扩展性而生成一个或多个App
    Engine实例。能够部署同一模块的多个版本，特别是对于测试新组件或部署渐进式升级非常有用。属于同一应用程序的模块共享服务，如Memcache、Datastore和任务队列，并且可以使用Python
    API模块以安全的方式通信。
- en: 'To delve into some other detail, we can refactor our Notes application by adding
    a new module solely dedicated to handle cron jobs. We don''t need to add any feature;
    we just break up and refactor existing code. As the architecture of our application
    is very simple, we can add the module directly in the application root. First
    of all, we need to configure this new module, we will name `backend` inside a
    new file, `backend.yaml`, which contains the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解一些其他细节，我们可以通过添加一个专门处理cron作业的新模块来重构我们的Notes应用程序。我们不需要添加任何功能；我们只是分解和重构现有代码。由于我们的应用程序架构非常简单，我们可以直接在应用程序根目录中添加该模块。首先，我们需要配置这个新模块，我们将在一个新文件`backend.yaml`中将其命名为`backend`，该文件包含以下内容：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is quite similar to any application configuration file, but the main difference
    is the `module` property that contains the name of the module. When this property
    is not in the configuration file, or it contains the `default` string as value,
    App Engine assumes this is the default module for the application. We then tell
    App Engine we want the `app` application from the `backend_main` file Python module
    handle every request the module will receive. When we do not specify any scaling
    option in the configuration file, **automatic scaling** will be assumed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这与任何应用程序配置文件非常相似，但主要区别是包含模块名称的`module`属性。当此属性不在配置文件中，或其值为`default`字符串时，App Engine假定这是应用程序的默认模块。然后我们告诉App
    Engine，我们希望`backend_main`文件中的Python模块处理该模块将接收到的每个请求。当我们不在配置文件中指定任何扩展选项时，将假定**自动扩展**。
- en: 'We write a brand new Python module with a dedicated WSGI-compliant application
    in the `backend_main.py` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`backend_main.py`文件中编写了一个全新的Python模块，其中包含一个专用的WSGI兼容应用程序：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we see from the mapping, this application will only handle requests for
    the shrink cron job. We take the handler code from the main module, and to avoid
    depending on it, we rewrite the `ShrinkCronJob` class so that it doesn''t need
    to derive from the `ShrinkHandler` class anymore. Again, in the `backend_main.py`
    module, we add the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从映射中看到的那样，此应用程序将仅处理shrink cron作业的请求。我们从主模块中获取处理程序代码，为了避免依赖它，我们重写了`ShrinkCronJob`类，使其不再需要从`ShrinkHandler`类派生。同样，在`backend_main.py`模块中，我们添加以下内容：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For convenience, we can move the `image_formats` dictionary into the `utils.py`
    module so that we can reuse it from here and from the `main.py` module.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们可以将`image_formats`字典移动到`utils.py`模块中，这样我们就可以在这里以及`main.py`模块中重用它。
- en: 'Now that we have two modules, we need to route the requests coming to our application
    to the right module, and we can do this by creating a file called `dispatch.yaml`
    in the application root that contains the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个模块，我们需要将进入我们应用程序的请求路由到正确的模块，我们可以通过在应用程序根目录中创建一个名为`dispatch.yaml`的文件来实现，该文件包含以下内容：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Basically, this is the highest level URL mapping we can have on App Engine.
    We can use wildcards instead of a regular expression to route URLs of incoming
    requests to the right module; in this case, we route requests to the `/shrink_all`
    URL to the backend module, leaving all the rest to the default module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这是我们可以在App Engine上拥有的最高级别的URL映射。我们可以使用通配符而不是正则表达式来将传入请求的URL路由到正确的模块；在这种情况下，我们将请求路由到`/shrink_all`
    URL，将所有其他请求留给默认模块。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ideally, we could have moved to the backend module also the code implementing
    notes creation by e-mail but unfortunately App Engine only allows inbound services
    on default modules.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们可以将实现通过电子邮件创建笔记的代码也移动到后端模块，但不幸的是，App Engine只允许在默认模块上使用入站服务。
- en: Working with modules, both on the local development environment and on production,
    adds some complications because we cannot use the App Engine Launcher graphical
    interface to start and stop the development server or deploy the application;
    we must use the command-line tools instead.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发环境和生产环境中使用模块会增加一些复杂性，因为我们不能使用App Engine Launcher图形界面来启动和停止开发服务器或部署应用程序；我们必须使用命令行工具。
- en: 'For example, we can check out how modules works in the local environment, but
    we have to start the development server passing the `YAML` files for each module
    together with the `dispatch.yaml` file as arguments. In our case, we issue the
    following on the command line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以检查模块在本地环境中的工作方式，但我们必须通过传递每个模块的`YAML`文件以及`dispatch.yaml`文件作为参数来启动开发服务器。在我们的情况下，我们在命令行上执行以下操作：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To deploy the application on App Engine, we use the `appcfg` command-line tool
    passing the `YAML` files of the modules we want to deploy, making sure that the
    configuration file of the default module is the first of the list during the very
    first deploy, for example we can use the `YAML` files as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要在App Engine上部署应用程序，我们使用`appcfg`命令行工具传递我们想要部署的模块的`YAML`文件，确保在第一次部署时，默认模块的配置文件是列表中的第一个，例如，我们可以使用以下`YAML`文件：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the application restarts, we should be able to see an instance running
    for the additional backend module using Development Console or Admin Console.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序重新启动时，我们应该能够在开发控制台或管理控制台中看到为额外的后端模块运行的实例。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since working with modules on a small application such as Notes is less practical
    and provides no benefits for the purpose of the book, we can switch back to the
    layout with only one module.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在像笔记这样的小型应用程序上使用模块不太实用，并且对本书的目的没有提供任何好处，我们可以切换回只有一个模块的布局。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into several details of most of the Cloud Platform
    components we have used so far. As mentioned before, when using a pay-per-use
    service such as the Cloud Platform, mastering the details and the best practices
    provides benefits for performance as well as costs. The majority of this chapter
    was dedicated to Cloud Datastore, confirming that this is a critical component
    for almost any web application; knowing how to lay out data or perform queries
    can determine the success of our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了迄今为止我们使用的云平台组件的许多细节。正如之前提到的，当使用按使用付费的服务，如云平台时，掌握细节和最佳实践对性能和成本都有益。本章的大部分内容都致力于云数据存储，确认这是几乎所有Web应用程序的关键组件；了解如何布局数据或执行查询可以决定我们应用程序的成功。
- en: We also learned how to safely use Memcache from a Python application, avoiding
    race conditions and strange behaviors that are difficult to debug. In the last
    part of the chapter, we covered the modules features of App Engine; even if we
    have to work on a complex application to completely appreciate the benefits of
    a modular architecture, knowing what modules are and what they can do for us is
    an important piece of information if we want to deploy our applications on App
    Engine.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何从Python应用程序安全地使用Memcache，避免竞争条件和难以调试的奇怪行为。在章节的最后部分，我们涵盖了App Engine的模块功能；即使我们必须处理复杂的应用程序以完全欣赏模块化架构的好处，了解模块是什么以及它们能为我们做什么也是重要信息，如果我们想在App
    Engine上部署我们的应用程序。
- en: The next chapter is completely dedicated to the Google Cloud SQL service. We
    will learn how to create and manage database instances and how to make connections
    and perform queries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章完全致力于Google Cloud SQL服务。我们将学习如何创建和管理数据库实例，以及如何建立连接和执行查询。
