- en: The Task of Sending Emails
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送电子邮件的任务
- en: Now that we have our models and views, we will need to make Mail Ape send emails.
    We'll have Mail Ape send two kinds of emails, subscriber confirmation emails and
    mailing list messages. We'll track mailing list message success by creating a
    new model called `SubscriberMessage` to track whether a message was successfully
    sent to an address stored in a `Subscriber` model instance. Since sending emails
    to a lot of `Subscriber` model instances can take a lot of time, we'll use Celery
    to send emails as tasks outside the regular Django request/response cycle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的模型和视图，我们需要让Mail Ape发送电子邮件。我们将让Mail Ape发送两种类型的电子邮件，订阅者确认电子邮件和邮件列表消息。我们将通过创建一个名为`SubscriberMessage`的新模型来跟踪邮件列表消息的成功发送，以跟踪是否成功将消息发送给存储在`Subscriber`模型实例中的地址。由于向许多`Subscriber`模型实例发送电子邮件可能需要很长时间，我们将使用Celery在常规Django请求/响应周期之外作为任务发送电子邮件。
- en: 'In this chapter, we will do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Use Django's template system to generate the HTML body of our emails
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django的模板系统生成我们电子邮件的HTML主体
- en: Send emails that include both HTML and plain text using Django
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django发送包含HTML和纯文本的电子邮件
- en: Use Celery to execute asynchronous tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Celery执行异步任务
- en: Prevent our code from sending actual emails during testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止我们的代码在测试期间发送实际电子邮件
- en: Let's start by creating some common resources that we'll use to send dynamic
    emails.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一些我们将用于发送动态电子邮件的常见资源。
- en: Creating common resources for emails
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建电子邮件的常见资源
- en: In this section, we will create a base HTML email template and a `Context` object
    for rendering email templates. We want to create a base HTML template for our
    emails so that we can avoid repeating boilerplate HTML. We also want to make sure
    that every email we send includes an unsubscribe link to be good email citizens.
    Our `EmailTemplateContext` class will consistently provide the common variables
    that our templates need.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个基本的HTML电子邮件模板和一个用于呈现电子邮件模板的`Context`对象。我们希望为我们的电子邮件创建一个基本的HTML模板，以避免重复使用样板HTML。我们还希望确保我们发送的每封电子邮件都包含一个退订链接，以成为良好的电子邮件用户。我们的`EmailTemplateContext`类将始终提供我们的模板需要的常见变量。
- en: Let's start by creating a base HTML email template.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个基本的HTML电子邮件模板。
- en: Creating the base HTML email template
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的HTML电子邮件模板
- en: 'We''ll create our base email HTML template in `django/mailinglist/templates/mailinglist/email/base.html`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`django/mailinglist/templates/mailinglist/email/base.html`中创建我们的基本电子邮件HTML模板：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding template looks like a much simpler version of `base.html`, except
    it has only one block. Email templates can extend `email/base.html` and override
    the body block to avoid the boilerplate HTML. Despite the filenames being the
    same (`base.html`), Django won't confuse the two. Templates are identified by
    their template paths, not just filenames.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板看起来像是`base.html`的一个更简单的版本，只有一个块。电子邮件模板可以扩展`email/base.html`并覆盖主体块，以避免样板HTML。尽管文件名相同（`base.html`），Django不会混淆两者。模板是通过它们的模板路径标识的，不仅仅是文件名。
- en: Our base template also expects the `unsubscription_link` variable to always
    exist. This will let users unsubscribe if they don't want to continue receiving
    emails.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本模板还期望`unsubscription_link`变量始终存在。这将允许用户取消订阅，如果他们不想继续接收电子邮件。
- en: To make sure that our templates always have the `unsubscription_link` variable,
    we'll create a `Context` that makes sure to always provide it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的模板始终具有`unsubscription_link`变量，我们将创建一个`Context`来确保始终提供它。
- en: Creating EmailTemplateContext
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建EmailTemplateContext
- en: As we've discussed before (refer to [Chapter 1](df6a3177-07c4-4edb-84b8-a01a6fd8ad0e.xhtml),
    *Building MyMDB*), to render a template, we will need to provide Django with a
    `Context` object that has the variables the template references. When writing
    class-based views, we only have to provide a dict in the `get_context_data()` method
    and Django takes care of everything for us. However, when we want to render a
    template ourselves, we'll have to instantiate the `Context` class ourselves. To
    ensure that all our email template-rendering code provides the same minimum information,
    we'll create a custom template `Context`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的（参见[第1章](df6a3177-07c4-4edb-84b8-a01a6fd8ad0e.xhtml)，*构建MyMDB*），要呈现模板，我们需要为Django提供一个`Context`对象，其中包含模板引用的变量。在编写基于类的视图时，我们只需要在`get_context_data()`方法中提供一个字典，Django会为我们处理一切。然而，当我们想要自己呈现模板时，我们将不得不自己实例化`Context`类。为了确保我们所有的电子邮件模板呈现代码提供相同的最小信息，我们将创建一个自定义模板`Context`。
- en: 'Let''s create our `EmailTemplateContext` class in `django/mailinglist/emails.py`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/emails.py`中创建我们的`EmailTemplateContext`类：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our `EmailTemplateContext` is made up of the following three methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`EmailTemplateContext`由以下三种方法组成：
- en: '`make_link()`: This joins a URL''s path with our project''s `MAILING_LIST_LINK_DOMAIN`
    setting. The `make_link` is necessary because Django''s `reverse()` function doesn''t
    include a domain. A Django project can be hosted on multiple different domains.
    We''ll discuss the `MAILING_LIST_LINK_DOMAIN` value more in the *Configuring email
    settings* section.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_link()`: 这将URL的路径与我们项目的`MAILING_LIST_LINK_DOMAIN`设置连接起来。`make_link`是必要的，因为Django的`reverse()`函数不包括域。Django项目可以托管在多个不同的域上。我们将在*配置电子邮件设置*部分更多地讨论`MAILING_LIST_LINK_DOMAIN`的值。'
- en: '`__init__()`: This overrides the `Context.__init__(...)` method to give us
    a chance to add the results of the `common_context()` method to the value of the `dict_` parameter.
    We''re careful to let the data received by the argument overwrite the data we
    generate in `common_context`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`: 这覆盖了`Context.__init__(...)`方法，给了我们一个机会将`common_context()`方法的结果添加到`dict_`参数的值中。我们要小心让参数接收到的数据覆盖我们在`common_context`中生成的数据。'
- en: '`common_context()`: This returns a dictionary that provides the variables we
    want available to all `EmailTemplateContext` objects. We always want to have `subscriber`,
    `mailing_list`, and `unsubscribtion_link` available.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common_context()`: 这返回一个字典，提供我们希望所有`EmailTemplateContext`对象可用的变量。我们始终希望有`subscriber`、`mailing_list`和`unsubscribtion_link`可用。'
- en: We'll use both these resources in our next section, where we'll send confirmation
    emails to new `Subscriber` model instances.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中使用这两个资源，我们将向新的`Subscriber`模型实例发送确认电子邮件。
- en: Sending confirmation emails
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送确认电子邮件
- en: In this section, we'll send emails to new `Subscriber`s to let them confirm
    their subscription to a `MailingList`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向新的`Subscriber`发送电子邮件，让他们确认对`MailingList`的订阅。
- en: 'In this section, we will:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将：
- en: Add Django's email configuration settings to our `settings.py`
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Django的电子邮件配置设置添加到我们的`settings.py`
- en: Write a function to send emails using Django's `send_mail()` function
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来使用Django的`send_mail()`函数发送电子邮件
- en: Create and render HTML and text templates for the body of our emails
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建和渲染电子邮件正文的HTML和文本模板
- en: Update `Subscriber.save()` to send the emails when a new `Subscriber` is created
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Subscriber.save()`以在创建新的`Subscriber`时发送电子邮件
- en: Let's start by updating configuration with our mail server's settings.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新配置开始，使用我们邮件服务器的设置。
- en: Configuring email settings
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置电子邮件设置
- en: In order to be able to send emails, we need to configure Django to talk to a
    **Simple Mail Transfer Protocol** (**SMTP**) server. In development and while
    learning, you can probably use the same SMTP server that your email client uses.
    Using such a server for sending large amounts of production email is likely a
    violation of your email provider's Terms of Service and can lead to account suspension.
    Be careful of which accounts you use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够发送电子邮件，我们需要配置Django与**简单邮件传输协议**（**SMTP**）服务器进行通信。在开发和学习过程中，您可能可以使用与您的电子邮件客户端相同的SMTP服务器。对于发送大量生产电子邮件，使用这样的服务器可能违反您的电子邮件提供商的服务条款，并可能导致帐户被暂停。请注意您使用的帐户。
- en: 'Let''s update our settings in `django/config/settings.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/config/settings.py`中更新我们的设置：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code sample, I''ve used a lot of instances of `example.com`,
    which you should replace with the correct domain for your SMTP host and your domain.
    Let''s take a closer look at the settings:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，我使用了很多`example.com`的实例，您应该将其替换为您的SMTP主机和域的正确域。让我们更仔细地看一下设置：
- en: '`EMAIL_HOST`: This is the address of the SMTP sever we''re using.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST`: 这是我们正在使用的SMTP服务器的地址。'
- en: '`EMAIL_HOST_USER`: The username used to authenticate to the SMTP server.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST_USER`: 用于对SMTP服务器进行身份验证的用户名。'
- en: '`EMAIL_PORT`: The port to connect to the SMTP server.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_PORT`: 连接到SMTP服务器的端口。'
- en: '`EMAIL_USE_TLS`: This is optional and defaults to `False`. Use it if you''re
    connecting over TLS to the SMTP server. If you''re using SSL, then use the `EMAIL_USE_SSL`
    setting. The SSL and TLS settings are mutually exclusive.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_USE_TLS`: 这是可选的，默认为`False`。如果您要通过TLS连接到SMTP服务器，请使用它。如果您使用SSL，则使用`EMAIL_USE_SSL`设置。SSL和TLS设置是互斥的。'
- en: '`EMAIL_HOST_PASSWORD`: The password for the host. In our case, we will expect
    the password in an environment variable.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST_PASSWORD`: 主机的密码。在我们的情况下，我们将期望密码在环境变量中。'
- en: '`MAILING_LIST_FROM_EMAIL`: This is a custom setting we''re using to set who
    set the `FROM` header on the emails we send.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAILING_LIST_FROM_EMAIL`: 这是我们使用的自定义设置，用于设置我们发送的电子邮件的`FROM`标头。'
- en: '`MAILING_LIST_LINK_DOMAIN`: This is the domain to prefix all email template
    links with. We saw this setting used in our `EmailTemplateContext` class.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAILING_LIST_LINK_DOMAIN`: 这是所有电子邮件模板链接的前缀域。我们在`EmailTemplateContext`类中看到了这个设置的使用。'
- en: Next, let's write our create function to send the confirmation emails.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写我们的创建函数来发送确认电子邮件。
- en: Creating the send email confirmation function
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建发送电子邮件确认函数
- en: Now, we will create a function that will actually create and send confirmation
    emails to our `Subscriber`s. The `email` module will contain all our email-related
    code (we've already created the `EmailTemplateContext` class there).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个实际创建并发送确认电子邮件给我们的`Subscriber`的函数。`email`模块将包含所有我们与电子邮件相关的代码（我们已经在那里创建了`EmailTemplateContext`类）。
- en: 'Our `send_confirmation_email()` function will have to do the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`send_confirmation_email()`函数将需要执行以下操作：
- en: Create a `Context` for rendering the email bodies
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为渲染电子邮件正文创建一个`Context`
- en: Create the subject for the email
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为电子邮件创建主题
- en: Render the HTML and text email body
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染HTML和文本电子邮件正文
- en: Send the email using the `send_mail()` function
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`send_mail()`函数发送电子邮件
- en: 'Let''s create that function in `django/mailinglist/emails.py`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/emails.py`中创建该函数：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s take a closer look at our code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下我们的代码：
- en: '`EmailTemplateContext()`: This instantiates the `Context` class we created
    earlier. We provide it with a `Subscriber` instance and a `dict`, which contains
    the confirmation link. The `confirmation_link` variable will be used by our templates,
    which we''ll create in the next two sections.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailTemplateContext()`: 这实例化了我们之前创建的`Context`类。我们为其提供了一个`Subscriber`实例和一个包含确认链接的`dict`。`confirmation_link`变量将被我们的模板使用，我们将在接下来的两个部分中创建。'
- en: '`engines[''django''].engine`: This references the Django Template engine. The
    engine knows how to find `Template`s using the configuration settings in the `TEMPLATES`
    setting of `settings.py`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`engines[''django''].engine`: 这引用了Django模板引擎。引擎知道如何使用`settings.py`中`TEMPLATES`设置中的配置设置来查找`Template`。'
- en: '`dt_engine.get_template()`: This returns a template object. We provide the
    name of the template as an argument to the `get_template()` method.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dt_engine.get_template()`: 这将返回一个模板对象。我们将模板的名称作为参数提供给`get_template()`方法。'
- en: '`text_body_template.render()`: This renders the template (using the context
    we created previously) into a string.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text_body_template.render()`: 这将模板（使用之前创建的上下文）渲染为字符串。'
- en: 'Finally, we send the email using the `send_email()` function. The `send_email()` function takes
    the following arguments:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`send_email()`函数发送电子邮件。`send_email()`函数接受以下参数：
- en: '`subject=subject`: The subject of the email message.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subject=subject`: 电子邮件消息的主题。'
- en: '`message=text_body`: The text version of the email.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message=text_body`: 电子邮件的文本版本。'
- en: '`from_email=settings.MAILING_LIST_FROM_EMAIL`: The sender''s email address.
    If we don''t provide a `from_email` argument, then Django will use the `DEFAULT_FROM_EMAIL`
    setting.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from_email=settings.MAILING_LIST_FROM_EMAIL`：发件人的电子邮件地址。如果我们不提供`from_email`参数，那么Django将使用`DEFAULT_FROM_EMAIL`设置。'
- en: '`recipient_list=(subscriber.email,)`: A list (or tuple) of recipient email
    addresses. This must be a collection, even if you''re only sending to one recipient.
    If you include multiple recipients, they will be able to see each other.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipient_list=(subscriber.email,)`：收件人电子邮件地址的列表（或元组）。这必须是一个集合，即使您只发送给一个收件人。如果包括多个收件人，他们将能够看到彼此。'
- en: '`html_message=html_body`: The HTML version of the email. This argument is optional,
    as we don''t have to provide an HTML body. If we provide an HTML body, then Django
    will send an email that includes both the HTML and text body. Email clients will
    choose to display the HTML or the plain text version of the email.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html_message=html_body`：电子邮件的HTML版本。这个参数是可选的，因为我们不必提供HTML正文。如果我们提供HTML正文，那么Django将发送包含HTML和文本正文的电子邮件。电子邮件客户端将选择显示电子邮件的HTML或纯文本版本。'
- en: Now that we have our code for sending the emails, let's make our email body
    templates.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了发送电子邮件的代码，让我们制作我们的电子邮件正文模板。
- en: Creating the HTML confirmation email template
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTML确认电子邮件模板
- en: 'Let''s make the HTML subscription email confirmation template. We''ll create
    the template in `django/mailinglist/templates/mailinglist/email_templates/confirmation.html`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作HTML订阅电子邮件确认模板。我们将在`django/mailinglist/templates/mailinglist/email_templates/confirmation.html`中创建模板：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our template looks just like an HTML web page template, but it will be used
    in an email. Just like a normal Django template, we're extending a base template
    and filling out a block. In our case, the template we're extending is the `email/base.html`
    template we created at the start of this chapter. Also, note how we're using variables
    that we provided in our `send_confirmation_email()` function (for example, `confirmation_link`)
    and our `EmailTemplateContext` (for example, `mailing_list`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板看起来就像一个HTML网页模板，但它将用于电子邮件。就像一个普通的Django模板一样，我们正在扩展一个基本模板并填写一个块。在我们的情况下，我们正在扩展的模板是我们在本章开始时创建的`email/base.html`模板。另外，请注意我们如何使用我们在`send_confirmation_email()`函数中提供的变量（例如`confirmation_link`）和我们的`EmailTemplateContext`（例如`mailing_list`）。
- en: Emails can include HTML but are not always rendered by web browsers. Notably,
    some versions of Microsoft Outlook use the Microsoft Word HTML renderer to render
    emails. Even Gmail, which runs in a browser, manipulates the HTML it receives
    before rendering it. Be careful to test complicated layouts in real email clients.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件可以包含HTML，但并非总是由Web浏览器呈现。值得注意的是，一些版本的Microsoft Outlook使用Microsoft Word HTML渲染器来渲染电子邮件。即使是在运行在浏览器中的Gmail也会在呈现之前操纵它收到的HTML。请小心在真实的电子邮件客户端中测试复杂的布局。
- en: Next, let's create the plain text version of this template.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建这个模板的纯文本版本。
- en: Creating the text confirmation email template
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文本确认电子邮件模板
- en: 'Now, we will create the plain text version of our confirmation email template;
    let''s create it in `django/mailinglist/templates/mailinglist/email_templates/confirm_subscription.txt`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建确认电子邮件模板的纯文本版本；让我们在`django/mailinglist/templates/mailinglist/email_templates/confirm_subscription.txt`中创建它：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding case, we're not using any HTML nor extending any base template.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，我们既不使用HTML也不扩展任何基本模板。
- en: However, we're still referencing variables that we provided in our `send_confirmation_email()`
    (for example, `confirmation_link`) function and our `EmailTemplateContext` class
    (for example, `mailing_list`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍在引用我们在`send_confirmation_email()`中提供的变量（例如`confirmation_link`）函数和我们的`EmailTemplateContext`类（例如`mailing_list`）。
- en: Now that we have all the code necessary for sending emails, let's send them
    out when we create a new `Subscriber` model instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了发送电子邮件所需的所有代码，让我们在创建新的`Subscriber`模型实例时发送它们。
- en: Sending on new Subscriber creation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在新的Subscriber创建时发送
- en: As the final step, we'll take sending confirmation emails to users; we need
    to call our `send_confirmation_email` function. Based on the philosophy of fat
    models, we will call our `send_confirmation_email` function from our `Subscriber`
    model rather than a view. In our case, we will send the email when a new `Subscriber` model
    instance is saved.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将向用户发送确认电子邮件；我们需要调用我们的`send_confirmation_email`函数。基于fat models的理念，我们将从我们的`Subscriber`模型而不是视图中调用我们的`send_confirmation_email`函数。在我们的情况下，当保存新的`Subscriber`模型实例时，我们将发送电子邮件。
- en: 'Let''s update our `Subscriber` model to send a confirmation email when a new
    `Subscriber` has been saved. To add this new behavior, we will need to edit `django/mailinglist/models.py`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的`Subscriber`模型，在保存新的`Subscriber`时发送确认电子邮件。为了添加这种新行为，我们需要编辑`django/mailinglist/models.py`：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The best way to add a new behavior when a model is created is to override the
    model''s `save()` method. When overriding `save()`, it is vital that we still
    call the super class''s `save()` method to make sure that the model does save.
    Our new save method does three things:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模型时添加新行为的最佳方法是重写模型的`save()`方法。在重写`save()`时，非常重要的是我们仍然调用超类的`save()`方法，以确保模型保存。我们的新保存方法有三个作用：
- en: Checks whether the current model is a new model
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查当前模型是否为新模型
- en: Calls the super class's `save()` method
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用超类的`save()`方法
- en: Sends the confirmation email if the model is new
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模型是新的，则发送确认电子邮件
- en: To check if the current model instance is new, we check the `_state` attribute.
    The `_state` attribute is an instance of the `ModelState` class. Generally, attributes
    that begin with an underscore (`_`) are considered private and may change across
    Django releases. However, the `ModelState` class is described in Django's official
    documentation so we can feel more comfortable using it (though we should keep
    an eye on future release notes for changes). If the `self._state.adding` is `True`,
    then the `save()` method is going to insert this model instance as a new row.
    If `self._state.adding` is `True`, then the `save()` method is going to update
    an existing row.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查当前模型实例是否是新的，我们检查`_state`属性。`_state`属性是`ModelState`类的一个实例。通常，以下划线（`_`）开头的属性被认为是私有的，并且可能会在Django的不同版本中发生变化。但是，`ModelState`类在Django的官方文档中有描述，所以我们可以更放心地使用它（尽管我们应该密切关注未来版本的变化）。如果`self._state.adding`为`True`，那么`save()`方法将会将这个模型实例插入为新行。如果`self._state.adding`为`True`，那么`save()`方法将会更新现有行。
- en: We've also wrapped the call to `emails.send_confirmation_email()` in a `Subscriber`
    method. This will be useful if we ever want to resend a confirmation email. Any
    code that wants to resend a confirmation email will not have to know about the
    `emails` module. The model is the expert on all its operations. This is the heart
    of the fat model philosophy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`emails.send_confirmation_email()`的调用包装在`Subscriber`方法中。如果我们想要重新发送确认电子邮件，这将非常有用。任何想要重新发送确认电子邮件的代码都不需要知道`emails`模块。模型是所有操作的专家。这是fat
    model哲学的核心。
- en: A quick review of the section
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本节的快速回顾
- en: In this section, we've learned more about Django's template system and how to
    send emails. We've learned how to render a template without using one of Django's
    built-in views to render it for us using the Django template engine directly.
    We've used the Django best practice of creating a service module to isolate all
    our email code. Finally, we've also used `send_email()` to send an email with
    a text and HTML body.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了更多关于Django模板系统以及如何发送电子邮件。我们学会了如何渲染模板，而不是使用Django的内置视图来直接使用Django模板引擎为我们渲染它。我们使用了Django的最佳实践，创建了一个服务模块来隔离所有我们的电子邮件代码。最后，我们还使用了`send_email()`来发送一封带有文本和HTML正文的电子邮件。
- en: Next, let's use Celery to send these emails after we return a response to our
    users.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在向用户返回响应后使用Celery发送这些电子邮件。
- en: Using Celery to send emails
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Celery发送电子邮件
- en: As we build increasingly complicated applications, we often want to perform
    operations without forcing the user to wait on us to return them an HTTP response.
    Django works well with Celery, a popular Python distributed task queue, to accomplish
    this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建越来越复杂的应用程序，我们经常希望执行操作，而不强迫用户等待我们返回HTTP响应。Django与Celery很好地配合，Celery是一个流行的Python分布式任务队列，可以实现这一点。
- en: 'Celery is a library to *queue* *tasks* in *brokers* to be processed by Celery
    *workers*. Let''s take a closer look at some of these terms:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Celery是一个在代理中*排队* *任务*以供Celery *工作者*处理的库。让我们更仔细地看看其中一些术语：
- en: A **Celery task** encapsulates a callable we want executed asynchronously.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Celery任务**封装了我们想要异步执行的可调用对象。'
- en: A **Celery** **queue** is a list of tasks in a first in, first out order stored
    in a broker.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Celery队列**是按照先进先出顺序存储在代理中的任务列表。'
- en: A **Celery broker** is a server that provides fast and efficient storage of
    queues. Popular brokers include RabbitMQ, Redis, and AWS SQS. Celery has different
    levels of support for different brokers. We will use Redis as our broker in development.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Celery代理**是提供快速高效的队列存储的服务器。流行的代理包括RabbitMQ、Redis和AWS SQS。Celery对不同代理有不同级别的支持。我们将在开发中使用Redis作为我们的代理。'
- en: '**Celery workers** are separate processes that check queues for tasks to execute
    and execute them.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Celery工作者**是单独的进程，它们检查任务队列以执行任务并执行它们。'
- en: 'In this section, we will be doing the following things:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将做以下事情：
- en: Installing Celery
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Celery
- en: Configuring Celery to work with Django
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Celery以与Django一起工作
- en: Using Celery queue a send confirmation email task
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Celery队列发送确认电子邮件任务
- en: Using a Celery worker to send our emails
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Celery工作者发送我们的电子邮件
- en: Let's start by installing Celery.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先安装Celery。
- en: Installing celery
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装celery
- en: 'To install Celery, we''ll update our `requirements.txt` file with these new
    changes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Celery，我们将使用这些新更改更新我们的`requirements.txt`文件：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will install three new packages and their dependencies:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装三个新包及其依赖项：
- en: '`celery`: Installs the main Celery package'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`celery`：安装主要的Celery包'
- en: '`celery[redis]`: Installs the dependencies we need to use Redis as our broker'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`celery[redis]`：安装我们需要使用Redis作为代理的依赖项'
- en: '`django-celery-results`: Lets us store the results of executed tasks in our
    Django database; this is just one way of storing and logging Celery''s results'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-celery-results`：让我们将执行的任务结果存储在我们的Django数据库中；这只是存储和记录Celery结果的一种方式'
- en: 'Next, let''s install our new packages using `pip`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`pip`安装我们的新包：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have Celery installed, let's configure Mail Ape to use Celery.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Celery，让我们配置Mail Ape来使用Celery。
- en: Configuring Celery settings
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Celery设置
- en: To configure Celery, we will need to make two sets of changes. First, we'll
    update the Django config to use Celery. Second, we'll create a celery configuration
    file that our worker will use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Celery，我们需要进行两组更改。首先，我们将更新Django配置以使用Celery。其次，我们将创建一个Celery配置文件，供我们的工作者使用。
- en: 'Let''s start by updating `django/config/settings.py`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先更新`django/config/settings.py`：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s take a closer look at these new settings:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些新设置：
- en: '`django_celery_results`: This is a Celery extension that we installed as a
    Django app to let us store the results of our Celery tasks in the Django DB.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_celery_results`：这是一个我们安装为Django应用程序的Celery扩展，让我们将Celery任务的结果存储在Django数据库中。'
- en: '`CELERY_BROKER_URL`: This is the URL to our Celery broker. In our case, we
    will use a local Redis server in development.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CELERY_BROKER_URL`：这是我们的Celery代理的URL。在我们的情况下，我们将在开发中使用本地的Redis服务器。'
- en: '`CELERY_RESULT_BACKEND`: This indicates where to store the results. In our
    case, we will use the Django database.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CELERY_RESULT_BACKEND`：这表示存储结果的位置。在我们的情况下，我们将使用Django数据库。'
- en: 'Since the `django_celery_results` app lets us save results in the database,
    it includes new Django models. For those models to exist in the database, we will
    need to migrate our database:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`django_celery_results`应用程序允许我们在数据库中保存结果，因此它包括新的Django模型。为了使这些模型存在于数据库中，我们需要迁移我们的数据库：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, let's create a configuration file for our Celery worker. The worker will
    need an access to Django and our Celery broker.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的Celery工作程序创建一个配置文件。工作程序将需要访问Django和我们的Celery代理。
- en: 'Let''s create the Celery worker configuration in `django/config/celery.py`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/config/celery.py`中创建Celery工作程序配置：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Celery knows how to work with a Django project out of the box. Here, we configure
    an instance of the Celery library based on our Django configuration. Let''s review
    these settings in detail:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Celery知道如何与Django项目直接配合。在这里，我们根据Django配置配置了Celery库的一个实例。让我们详细审查这些设置：
- en: '`setdefault(''DJANGO_SETTINGS_MODULE'', ...)`: This ensures that our Celery
    worker knows which Django settings module to use if the `DJANGO_SETTINGS_MODULE`
    environment variable is not set for it.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setdefault(''DJANGO_SETTINGS_MODULE'', ...)`：这确保我们的Celery工作程序知道如果未为`DJANGO_SETTINGS_MODULE`环境变量设置它，应该使用哪个Django设置模块。'
- en: '`Celery(''mailape'')`: This instantiates the Celery library for Mail Ape. Most
    Django apps use only one Celery instance, so the `mailape` string is not significant.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Celery(''mailape'')`：这实例化了Mail Ape的Celery库。大多数Django应用程序只使用一个Celery实例，因此`mailape`字符串并不重要。'
- en: '`app.config_from_object(''django.conf:settings'', namespace=''CELERY'')`: This
    tells our Celery library to configure itself from the object at `django.conf.settings`.
    The `namespace` argument tells Celery that its settings are prefixed with `CELERY`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.config_from_object(''django.conf:settings'', namespace=''CELERY'')`：这告诉我们的Celery库从`django.conf.settings`对象配置自身。`namespace`参数告诉Celery其设置以`CELERY`为前缀。'
- en: '`app.autodiscover_tasks()`: This lets us avoid registering tasks by hand. When
    Celery is working with Django, it will check each installed app for a `tasks`
    module. Any tasks in that module will be automatically discovered.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.autodiscover_tasks()`：这使我们可以避免手动注册任务。当Celery与Django一起工作时，它将检查每个已安装的应用程序是否有一个`tasks`模块。该模块中的任何任务都将被自动发现。'
- en: Let's learn more about tasks by creating a task to send confirmation emails.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个任务来发送确认电子邮件来了解更多关于任务的信息。
- en: Creating a task to send confirmation emails
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个任务来发送确认电子邮件
- en: Now that Celery is configured, let's create a task to send a confirmation email
    to a subscriber.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Celery已配置好，让我们创建一个任务，向订阅者发送确认电子邮件。
- en: A Celery task is a subclass of `Celery.app.task.Task`. However, most of the
    time when we create Celery tasks, we use Celery's decorators to mark a function
    as a task. In a Django project, it's often simplest to use the `shared_task` decorator.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Celery任务是`Celery.app.task.Task`的子类。但是，当我们创建Celery任务时，大多数情况下，我们使用Celery的装饰器将函数标记为任务。在Django项目中，使用`shared_task`装饰器通常是最简单的。
- en: When creating a task, it's useful to think of it like a view. The Django community's
    best practices recommend *thin views*, which means that views should be simple.
    They should not be responsible for complicated tasks, but should delegate that
    work to the model or a service module (for example, our `mailinglist.emails` module).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任务时，将其视为视图是有用的。Django社区的最佳实践建议*视图应该简单*，这意味着视图应该简单。它们不应该负责复杂的任务，而应该将该工作委托给模型或服务模块（例如我们的`mailinglist.emails`模块）。
- en: Keep task functions simple and put all the logic in models or service modules.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任务函数保持简单，并将所有逻辑放在模型或服务模块中。
- en: 'Let''s create a task to send our confirmation emails in `django/mailinglist/tasks.py`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/tasks.py`中创建一个任务来发送我们的确认电子邮件：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are a few unique things about our `send_confirmation_email_to_subscriber`
    function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的`send_confirmation_email_to_subscriber`函数有一些独特的事情：
- en: '`@shared_task`: This is a Celery decorator that turns a function into a `Task`.
    A `shared_task` is available to all Celery instances (in most Django cases, there''s
    only one anyway).'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@shared_task`：这是一个Celery装饰器，将函数转换为`Task`。`shared_task`对所有Celery实例都可用（在大多数Django情况下，通常只有一个）。'
- en: '`def send_confirmation_email_to_subscriber(subscriber_id):`: This is a regular
    function that takes a subscriber ID as an argument. A Celery task can receive
    any pickle-able object (including a Django model). However, if you''re passing
    around something that may be viewed as confidential (for example, an email address),
    you may wish to limit the number of systems that store the data (for example,
    not store it on the broker). In this case, we''re passing our task function an
    ID of the `Subscriber` instead of the full `Subscriber`. The task function then
    queries the database for the related `Subscriber` instance.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def send_confirmation_email_to_subscriber(subscriber_id):`：这是一个常规函数，它以订阅者ID作为参数。Celery任务可以接收任何可pickle的对象（包括Django模型）。但是，如果您传递的是可能被视为机密的内容（例如电子邮件地址），您可能希望限制存储数据的系统数量（例如，不要在代理商处存储）。在这种情况下，我们将任务函数传递给`Subscriber`的ID，而不是完整的`Subscriber`。然后，任务函数查询相关的`Subscriber`实例的数据库。'
- en: A final item of note in this function is that we import the `Subscriber` model
    inside the function instead of at the top of the file. In our case, we will have
    our `Subscriber` model call this task. If we import the `models` module at the
    top of `tasks.py` and import the `tasks` module at the top of `model.py`, then
    we'll have a cyclic import error. In order to prevent that, we import `Subscriber`
    inside the function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中最后要注意的一点是，我们在函数内部导入了`Subscriber`模型，而不是在文件顶部导入。在我们的情况下，我们的`Subscriber`模型将调用此任务。如果我们在`tasks.py`的顶部导入`models`模块，并在`model.py`的顶部导入`tasks`模块，那么就会出现循环导入错误。为了防止这种情况，我们在函数内部导入`Subscriber`。
- en: Next, let's call our task from `Subscriber.send_confirmation_email()`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从`Subscriber.send_confirmation_email()`中调用我们的任务。
- en: Sending emails to new subscribers
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向新订阅者发送电子邮件
- en: Now that we have our task, let's update our `Subscriber` to send confirmation
    emails using the task instead of using the `emails` module directly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了任务，让我们更新我们的`Subscriber`，使用任务发送确认电子邮件，而不是直接使用`emails`模块。
- en: 'Let''s update `django/mailinglist/models.py`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`django/mailinglist/models.py`：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our updated `send_confirmation_email()` method, we will take a look at how
    to call a task asynchronously.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新的`send_confirmation_email()`方法中，我们将看看如何异步调用任务。
- en: A Celery task can be called either synchronously or asynchronously. Using the
    regular `()` operator, we'll call the task synchronously (for example, `tasks.send_confirmation_email_to_subscriber(self.id)`).
    A task that executes synchronously executes like a regular function call.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Celery任务可以同步或异步调用。使用常规的`()`运算符，我们将同步调用任务（例如，`tasks.send_confirmation_email_to_subscriber(self.id)`）。同步执行的任务就像常规的函数调用一样执行。
- en: A Celery task also has the `delay()` method to execute a task asynchronously.
    When a task is told to execute asynchronously, it will queue a message in Celery's
    message broker. The Celery workers will then (eventually) pull the message from
    the broker's queue and execute the task. The result of the task is stored in the
    storage backend (in our case, the Django database).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Celery任务还有`delay()`方法来异步执行任务。当告诉任务要异步执行时，它将在Celery的消息代理中排队一条消息。然后Celery的worker将（最终）从代理的队列中拉取消息并执行任务。任务的结果存储在存储后端（在我们的情况下是Django数据库）中。
- en: Calling a task asynchronously returns a `result` object that offers a `get()`
    method. Calling `result.get()` blocks the current thread until the task has finished.
    `result.get()` then returns the result of the task. In our case, our tasks will
    not return anything, so we won't use the `result` function..
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 异步调用任务会返回一个`result`对象，它提供了一个`get()`方法。调用`result.get()`会阻塞当前线程，直到任务完成。然后`result.get()`返回任务的结果。在我们的情况下，我们的任务不会返回任何东西，所以我们不会使用`result`函数。
- en: '`task.delay(1, a=''b'')` is actually a shortcut for `task.apply_async((1,),
    kwargs={''a'':''b''})`. Most of the time, the shortcut method is what we want.
    If you need a greater degree of control over your tasks execution, `apply_async()`
    is documented in the Celery documentation ([http://docs.celeryproject.org/en/latest/userguide/calling.html](http://docs.celeryproject.org/en/latest/userguide/calling.html)).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`task.delay(1, a=''b'')`实际上是`task.apply_async((1,), kwargs={''a'':''b''})`的快捷方式。大多数情况下，快捷方法是我们想要的。如果您需要更多对任务执行的控制，`apply_async()`在Celery文档中有记录（[http://docs.celeryproject.org/en/latest/userguide/calling.html](http://docs.celeryproject.org/en/latest/userguide/calling.html)）。'
- en: Now that we can call tasks, let's start a worker to process our queued tasks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用任务了，让我们启动一个worker来处理我们排队的任务。
- en: Starting a Celery worker
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Celery worker
- en: 'Starting a Celery worker does not require us to write any new code. We can
    start one from the command line:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Celery worker不需要我们编写任何新代码。我们可以从命令行启动一个：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s look at all the arguments we gave `celery`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们给`celery`的所有参数：
- en: '`worker`: This indicates that we want to start a new worker.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worker`: 这表示我们想要启动一个新的worker。'
- en: '`-A config.celery`: This is the app, or configuration, we want to use. In our
    case, the app we want is configured in `config.celery`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-A config.celery`: 这是我们想要使用的应用程序或配置。在我们的情况下，我们想要的应用程序在`config.celery`中配置。'
- en: '`-l info`: This is the log level to output. In this case, we''re using `info`.
    By default, the level is `WARNING`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l info`: 这是要输出的日志级别。在这种情况下，我们使用`info`。默认情况下，级别是`WARNING`。'
- en: Our worker is now able to process tasks queued by our code in Django. If we
    find we're queueing a lot of tasks, we can just start more `celery worker` processes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的worker现在能够处理Django中我们的代码排队的任务。如果我们发现我们排队了很多任务，我们可以启动更多的`celery worker`进程。
- en: A quick review of the section
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾一下这一部分
- en: In this section, you learned how to use Celery to process tasks asynchronously.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学会了如何使用Celery来异步处理任务。
- en: We learned how to set the broker and backend using the `CELERY_BROKER_URL` and
    `CELERY_RESULT_BACKEND` settings in our `settings.py`. We also created a `celery.py`
    file for our celery worker. Then, we used the `@shared_task` decorator to make
    a function a Celery task. With the task available, we learned how to call a Celery
    task with the `.delay()` shortcut method. Finally, we started a Celery worker
    to execute queued tasks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何在我们的`settings.py`中使用`CELERY_BROKER_URL`和`CELERY_RESULT_BACKEND`设置来设置代理和后端。我们还为我们的celery
    worker创建了一个`celery.py`文件。然后，我们使用`@shared_task`装饰器将函数变成了Celery任务。有了任务可用，我们学会了如何使用`.delay()`快捷方法调用Celery任务。最后，我们启动了一个Celery
    worker来执行排队的任务。
- en: Now that we know the basics, let's use this approach to send messages to our
    subscribers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了基础知识，让我们使用这种方法向我们的订阅者发送消息。
- en: Sending messages to subscribers
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向订阅者发送消息
- en: In this section, we're going to create the `Message` model instances that represent
    messages that our users want to send to their mailing lists.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建代表用户想要发送到其邮件列表的消息的`Message`模型实例。
- en: 'To send these messages, we will need to do the following things:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送这些消息，我们需要做以下事情：
- en: Create a `SubscriberMessage` model to track which messages got sent and when
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`SubscriberMessage`模型来跟踪哪些消息何时发送
- en: Create a `SubscriberMessage` model instance for each confirmed `Subscriber` model
    instance associated with the new `Message` model instance
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为与新的`Message`模型实例相关联的每个确认的`Subscriber`模型实例创建一个`SubscriberMessage`模型实例
- en: Have `SubscriberMessage` model instances send an email to their associated `Subscriber` model
    instance's email
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让`SubscriberMessage`模型实例向其关联的`Subscriber`模型实例的电子邮件发送邮件。
- en: To make sure that even a `MailingList` model instance with lots of related `Subscriber` model
    instances doesn't slow down our website, we will use Celery to build our list
    of `SubscriberMessage` model instances *and* send the emails.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保即使有很多相关的`Subscriber`模型实例的`MailingList`模型实例也不会拖慢我们的网站，我们将使用Celery来构建我们的`SubscriberMessage`模型实例列表*并*发送电子邮件。
- en: Let's start by creating a `SubscriberManager` to help us get a list of confirmed
    `Subscriber` model instances.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个`SubscriberManager`来帮助我们获取确认的`Subscriber`模型实例的列表。
- en: Getting confirmed subscribers
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取确认的订阅者
- en: Good Django projects use custom model managers to centralize and document `QuerySet` objects
    related to their models. We need a `QuerySet` object to retrieve all the confirmed
    `Subscriber` model instances that belong to a given `MailingList` model instance.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的Django项目使用自定义模型管理器来集中和记录与其模型相关的`QuerySet`对象。我们需要一个`QuerySet`对象来检索属于给定`MailingList`模型实例的所有已确认`Subscriber`模型实例。
- en: 'Let''s update `django/mailinglist/models.py` to add a new `SubscriberManager` class
    that knows how to get confirmed `Subscriber` model instances for a `MailingList` model
    instance:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`django/mailinglist/models.py`，添加一个新的`SubscriberManager`类，它知道如何为`MailingList`模型实例获取已确认的`Subscriber`模型实例：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our new `SubscriberManager` object replaces the default manager in `Subscriber.objects`. The
    `SubscriberManager` class offers the `confirmed_subscribers_for_mailing_list()` method
    as well as all the methods of the default manager.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`SubscriberManager`对象取代了`Subscriber.objects`中的默认管理器。`SubscriberManager`类提供了`confirmed_subscribers_for_mailing_list()`方法以及默认管理器的所有方法。
- en: Next, let's create the `SubscriberMessage` model.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`SubscriberMessage`模型。
- en: Creating the SubscriberMessage model
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SubscriberMessage模型
- en: Now, we will create a `SubscriberMessage` model and manager. The `SubscriberMessage`
    model will let us track whether we successfully sent an email to a `Subscriber` model
    instance. The custom manager will have a method of creating all the `SubscriberMessage` model
    instances that a `Message` model instance needs.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`SubscriberMessage`模型和管理器。`SubscriberMessage`模型将让我们跟踪是否成功向`Subscriber`模型实例发送了电子邮件。自定义管理器将具有一个方法，用于创建`Message`模型实例所需的所有`SubscriberMessage`模型实例。
- en: 'Let''s start by creating our `SubscriberMessage` in `django/mailinglist/models.py`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`django/mailinglist/models.py`中创建我们的`SubscriberMessage`开始：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our `SubscriberMessage` model is pretty heavily customized compared to most
    of our other models:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们其他大部分模型相比，我们的`SubscriberMessage`模型定制程度相当高：
- en: The `SubsriberMessage` fields connect it to a `Message` and a `Subscriber` let
    it track when it was created, last tried to send an email, and succeeded.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubsriberMessage`字段将其连接到`Message`和`Subscriber`，让它跟踪创建时间、最后尝试发送电子邮件以及成功与否。'
- en: '`SubscriberMessage.objects` is a custom manager that we''ll create in the following
    section.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberMessage.objects`是我们将在下一节中创建的自定义管理器。'
- en: '`SubscriberMessage.save()` works similar to `Subscriber.save()`. It checks
    whether the `SubscriberMessage` is new and whether it calls the `send()` method.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberMessage.save()`与`Subscriber.save()`类似。它检查`SubscriberMessage`是否是新的，然后调用`send()`方法。'
- en: '`SubscriberMessage.send()` queues a task to send the message. We''ll create
    that task later in the *Sending emails to Subscribers* section.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberMessage.send()`排队一个任务来发送消息。我们将在*向订阅者发送电子邮件*部分稍后创建该任务。'
- en: 'Now, let''s create a `SubscriberMessageManager` in `django/mailinglist/models.py`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`django/mailinglist/models.py`中创建一个`SubscriberMessageManager`：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our new manager offers a method of creating `SubscriberMessages` from a `Message`.
    The `create_from_message()` method returns a list of `SubscriberMessage`s each
    created using the `Manager.create()` method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新管理器提供了一个从`Message`创建`SubscriberMessages`的方法。`create_from_message()`方法返回使用`Manager.create()`方法创建的`SubscriberMessage`列表。
- en: 'Finally, in order to have a new model available, we will need to create a migration
    and apply it:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使新模型可用，我们需要创建一个迁移并应用它：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have our `SubscriberMessage` model and table, let's update our project
    to automatically create `SubscriberMessage` model instances when a new `Message`
    is created.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`SubscriberMessage`模型和表，让我们更新我们的项目，以便在创建新的`Message`时自动创建`SubscriberMessage`模型实例。
- en: Creating SubscriberMessages when a message is created
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建消息时创建SubscriberMessages
- en: Mail Ape is meant to send a message as soon as it is created. For a `Message` model
    instance to become an email in a subscriber's inbox, we will need to build a set
    of `SubscriberMessage` model instances. The best time to build that set of `SubscriberMessage` model
    instances is just after a new `Message` model instance is created.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Mail Ape旨在在创建后立即发送消息。为了使`Message`模型实例成为订阅者收件箱中的电子邮件，我们需要构建一组`SubscriberMessage`模型实例。构建该组`SubscriberMessage`模型实例的最佳时间是在创建新的`Message`模型实例之后。
- en: 'Let''s override `Message.save()` in `django/mailinglist/models.py`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/models.py`中重写`Message.save()`：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our new `Message.save()` method follows a similar pattern as before. `Message.save()`
    checks whether the current `Message` is new and whether it then queues the `build_subscriber_messages_for_message` task
    for execution.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`Message.save()`方法遵循了与之前类似的模式。`Message.save()`检查当前的`Message`是否是新的，然后是否将`build_subscriber_messages_for_message`任务排队等待执行。
- en: We'll use Celery to build the set of `SubscriberMessage` model instances asynchronously
    because we don't know how many `Subscriber` model instances are related to our `MailingList`
    model instance. If there are very many related `Subscriber` model instances, then
    it might make our web server unresponsive. Using Celery, our web server will return
    a response as soon as the `Message` model instance is saved. The `SubscriberMessage` model
    instances will be created by an entirely separate process.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Celery异步构建一组`SubscriberMessage`模型实例，因为我们不知道有多少`Subscriber`模型实例与我们的`MailingList`模型实例相关联。如果有很多相关的`Subscriber`模型实例，那么可能会使我们的Web服务器无响应。使用Celery，我们的Web服务器将在`Message`模型实例保存后立即返回响应。`SubscriberMessage`模型实例将由一个完全独立的进程创建。
- en: 'Let''s create the `build_subscriber_messages_for_message` task in `django/mailinglist/tasks.py`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/tasks.py`中创建`build_subscriber_messages_for_message`任务：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we discussed previously, our task doesn't contain much logic in itself. `build_subscriber_messages_for_message`
    lets the `SubscriberMessage` manager encapsulate all the logic of creating the
    `SubscriberMessage` model instances.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们的任务本身并不包含太多逻辑。`build_subscriber_messages_for_message`让`SubscriberMessage`管理器封装了创建`SubscriberMessage`模型实例的所有逻辑。
- en: Next, let's write the code for sending emails that contain the `Message` our
    users create.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写发送包含用户创建的`Message`的电子邮件的代码。
- en: Sending emails to subscribers
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向订阅者发送电子邮件
- en: Our final step in this section will be to send an email based on a `SubscriberMessage`.
    Earlier, we had our `SubscriberMessage.save()` method queue a task to send a `Subscriber`
    a `Message`. Now, we'll create that task and update the `emails.py` code to send
    the emails.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最后一步将是根据`SubscriberMessage`发送电子邮件。早些时候，我们的`SubscriberMessage.save()`方法排队了一个任务，向`Subscriber`发送`Message`。现在，我们将创建该任务并更新`emails.py`代码以发送电子邮件。
- en: 'Lets''s start by updating `django/mailinglist/tasks.py` with a new task:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新`django/mailinglist/tasks.py`开始一个新的任务：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This new task follows the same pattern as the previous tasks we''ve created:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新任务遵循了我们之前创建的任务的相同模式：
- en: We use the `shared_task` decorator to turn a regular function into a Celery
    task
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`shared_task`装饰器将常规函数转换为Celery任务
- en: We import our model inside our task function to prevent a cyclical import error
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在任务函数内导入我们的模型，以防止循环导入错误
- en: We let the `emails` module do the actual work of sending the email
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们让`emails`模块来实际发送邮件
- en: 'Next, let''s update the `django/mailinglist/emails.py` file to send emails
    based on a `SubscriberMessage`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新`django/mailinglist/emails.py`文件，根据`SubscriberMessage`发送电子邮件：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our new function takes the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新函数采取以下步骤：
- en: Builds the context for the templates using the `EmailTemplateContext` class
    we created earlier
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前创建的`EmailTemplateContext`类构建模板的上下文
- en: Renders the text and HTML versions of the email using the Django Template engine
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Django模板引擎呈现电子邮件的文本和HTML版本
- en: Records the time of the current sending attempt
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录当前发送尝试的时间
- en: Sends the email using Django's `send_mail()` function
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Django的`send_mail()`函数发送电子邮件
- en: If `send_mail()` returned that it sent an email, it records the time the message
    was sent
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`send_mail()`返回发送了一封电子邮件，它记录了消息发送的时间
- en: Our `send_subscriber_message()` function requires us to create HTML and text
    templates to render.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`send_subscriber_message()`函数要求我们创建HTML和文本模板来渲染。
- en: 'Let''s create our HTML email body template in `django/mailinglist/templates/mailinglist/email_templates/subscriber_message.html`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/templates/mailinglist/email_templates/subscriber_message.html`中创建我们的HTML电子邮件正文模板：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This template renders the markdown body of the `Message` into HTML. We've used
    the `markdownify` tag library to render markdown into HTML before. We don't need
    HTML boilerplate or to include an unsubscribe link footer because the `email_base.html`
    already does that.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板将`Message`的markdown正文呈现为HTML。我们以前使用过`markdownify`标签库来将markdown呈现为HTML。我们不需要HTML样板或包含退订链接页脚，因为`email_base.html`已经包含了。
- en: 'Next, we must create the text version of the message template in `mailinglist/templates/mailinglist/email_templates/subscriber_message.txt`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在`mailinglist/templates/mailinglist/email_templates/subscriber_message.txt`中创建消息模板的文本版本：
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This template looks very similar. In this case, we simply output the body as
    un-rendered markdown. Also, we don't have a base template for our text emails,
    so we have to write out the footer with an unsubscribe link manually.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板看起来非常相似。在这种情况下，我们只是将正文输出为未呈现的markdown。此外，我们没有一个用于文本电子邮件的基本模板，所以我们必须手动编写包含退订链接的页脚。
- en: Congratulations! You've now updated Mail Ape to send emails to mailing list
    subscribers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在已经更新了Mail Ape，可以向邮件列表订阅者发送电子邮件。
- en: Make sure that you restart your `celery worker` process(es) any time you change
    your code. `celery worker` does not include an automatic restart like the Django
    `runserver`. If we don't restart the `worker`, then it won't get any updated code
    changes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在更改代码时重新启动您的`celery worker`进程。`celery worker`不像Django`runserver`那样包含自动重启。如果我们不重新启动`worker`，那么它就不会得到任何更新的代码更改。
- en: Next, let's make sure that we can run our tests without triggering Celery or
    sending an actual email.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确保我们可以在不触发Celery或发送实际电子邮件的情况下运行我们的测试。
- en: Testing code that uses Celery tasks
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试使用Celery任务的代码
- en: At this point, two of our models will automatically queue Celery tasks when
    they are created. This can create a problem for us when testing our code since
    we may not want to have a Celery broker running when we run our tests. Instead,
    we should use Python's `mock` library to prevent the need for an outside system
    to be running when we run our tests.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的两个模型将在创建时自动排队Celery任务。这可能会给我们在测试代码时造成问题，因为我们可能不希望在运行测试时运行Celery代理。相反，我们应该使用Python的`mock`库来防止在运行测试时需要运行外部系统。
- en: One approach we could use is to decorate each test method that uses the `Subscriber`
    or `Message` models with Python's `@patch()` decorator. However, this manual process
    is likely to be error-prone. Let's look at some alternatives instead.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的一种方法是使用Python的`@patch()`装饰器来装饰使用`Subscriber`或`Message`模型的每个测试方法。然而，这个手动过程很可能出错。让我们来看看一些替代方案。
- en: 'In this section, we will take a look at two approaches to make mocking out
    Celery tasks easier:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下使模拟Celery任务更容易的两种方法：
- en: Using a mixin to prevent the `send_confirmation_email_to_subscriber` task from
    being queued in any test
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用mixin来防止`send_confirmation_email_to_subscriber`任务在任何测试中被排队
- en: Using a Factory to prevent the `send_confirmation_email_to_subscriber` task
    from being queued
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂来防止`send_confirmation_email_to_subscriber`任务被排队
- en: By fixing the same problem in two different ways, you'll get insight into which
    solution works better in which situation. You may find that having both options
    available in a project is helpful.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以两种不同的方式解决相同的问题，您将了解到哪种解决方案在哪种情况下更有效。您可能会发现在项目中同时拥有这两个选项是有帮助的。
- en: We can use the exact same approaches for patching references to `send_mail`
    to prevent emails being sent out during testing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用完全相同的方法来修补对`send_mail`的引用，以防止在测试期间发送邮件。
- en: Let's start by using a mixin to apply a patch.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用一个mixin来应用一个补丁。
- en: Using a TestCase mixin to patch tasks
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TestCase mixin来修补任务
- en: In this approach, we will create a mixin that `TestCase` authors can optionally
    use when writing `TestCase`s. We've used mixins in a lot of our Django code to
    override the behavior of class-based views. Now, we'll create a mixin that will
    override the default behavior of `TestCase`s. We will take advantage of each test
    method being preceded by a call to `setUp()` and followed by `tearDown()` to set
    up our patch and mock.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们将创建一个mixin，`TestCase`作者在编写`TestCase`时可以选择使用。我们在我们的Django代码中使用了许多mixin来覆盖基于类的视图的行为。现在，我们将创建一个mixin，它将覆盖`TestCase`的默认行为。我们将利用每个测试方法之前调用`setUp()`和之后调用`tearDown()`的特性来设置我们的修补程序和模拟。
- en: 'Let''s create our mixin `django/mailinglist/tests.py`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/tests.py`中创建我们的mixin：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our mixin''s `setUp()` method does three things:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的mixin的`setUp()`方法做了三件事：
- en: Creates a patch and saves it as an attribute of our object
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个修补程序并将其保存为对象的属性
- en: Starts the patch and saves the resulting mock object as an attribute of our
    object Access to the mock is important so that we can later assert what it was
    called
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动修补程序并将生成的模拟对象保存为对象的属性，访问模拟是重要的，这样我们以后可以断言它被调用了
- en: Calls the parent class's `setUp()` method so that the `TestCase` is properly
    set up
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用父类的`setUp()`方法，以便正确设置`TestCase`
- en: 'Our mixin''s `tearDown` method also does the following three things:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的mixin的`tearDown`方法还做了以下三件事：
- en: Stops the patch
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止修补程序
- en: Removes a reference to the mock
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除对模拟的引用
- en: Calls the parent class's `tearDown` method to complete any other cleanup that
    needs to happen
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用父类的`tearDown`方法来完成任何其他需要发生的清理
- en: Let's create a `TestCase` to test `SubscriberCreation` and take a look at our
    new `MockSendEmailToSubscriberTask` in action. We'll create a test that creates
    a `Subscriber` model instance using its manager's `create()` method. The `create()` call
    will in turn call `save()` on the new `Subscriber` instances. The `Subscriber.save()` method
    should then queue a `send_confirmation_email` task.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`TestCase`来测试`SubscriberCreation`，并看看我们的新`MockSendEmailToSubscriberTask`是如何工作的。我们将创建一个测试，使用其管理器的`create()`方法创建一个`Subscriber`模型实例。`create()`调用将进而调用新的`Subscriber`实例的`save()`。`Subscriber.save()`方法应该排队一个`send_confirmation_email`任务。
- en: 'Let’s add our test to `django/mailinglist/tests.py`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的测试添加到`django/mailinglist/tests.py`中：
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our test asserts that the mock we created in our mixin has been called once.
    This gives us confidence that when we create a new `Subscriber`, we will queue
    the correct task.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试断言我们在mixin中创建的模拟已经被调用了一次。这让我们确信当我们创建一个新的`Subscriber`时，我们将排队正确的任务。
- en: Next, let's look at how we can solve this problem using Factory Boy factories.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用Factory Boy工厂来解决这个问题。
- en: Using patch with factories
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工厂进行修补
- en: We discussed using Factory Boy factories in [Chapter 8](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml),
    *Testing Answerly*. Factories make it easier to create complicated objects. We
    will now take a look at how to use Factories and Python's `patch()` together to
    prevent tasks from being queued.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml)中讨论了使用Factory Boy工厂，*测试Answerly*。工厂使得创建复杂对象变得更容易。现在让我们看看如何同时使用工厂和Python的`patch()`来防止任务被排队。
- en: 'Let''s create a `SubscriberFactory` in `django/mailinglist/factories.py`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/factories.py`中创建一个`SubscriberFactory`：
- en: '[PRE27]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our factory overrides the default `_create()` method to apply the task patch
    before the default `_create()` method is called. When the default `_create()`
    method executes, it will call `Subscriber.save()`, which will try to queue the
    `send_confirmation_email` task. However, the task will be replaced with a mock.
    Once the model is created and the `_create()` method returns, the patch will be
    removed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工厂覆盖了默认的`_create()`方法，以在调用默认的`_create()`方法之前应用任务修补程序。当默认的`_create()`方法执行时，它将调用`Subscriber.save()`，后者将尝试排队`send_confirmation_email`任务。但是，该任务将被替换为模拟。一旦模型被创建并且`_create()`方法返回，修补程序将被移除。
- en: 'We can now use our `SubscriberFactory` in a test. Let''s write a test in `django/mailinglist/tests.py`
    to verify that `SubscriberManager.confirmed_subscribers_for_mailing_list()` works
    correctly:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在测试中使用我们的`SubscriberFactory`。让我们在`django/mailinglist/tests.py`中编写一个测试，以验证`SubscriberManager.confirmed_subscribers_for_mailing_list()`是否正确工作：
- en: '[PRE28]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we've seen both approaches, let's look at some of the trade-offs between
    the two approaches.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了两种方法，让我们来看一下这两种方法之间的一些权衡。
- en: Choosing between patching strategies
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在修补策略之间进行选择
- en: Both Factory Boy factories and `TestCase` mixins help us solve the problem of
    how to test code that queues a Celery task without queuing a Celery task. Let's
    take a closer look at some of the trade-offs.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Factory Boy工厂和`TestCase` mixin都帮助我们解决了如何测试排队Celery任务的代码而不排队Celery任务的问题。让我们更仔细地看一些权衡。
- en: 'Some of the trade-offs when using a mixin are as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mixin时的一些权衡如下：
- en: The patch stays in place during the entire test
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修补程序在整个测试期间保持不变
- en: We have access to the resulting mock
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以访问生成的模拟
- en: The patch will be applied even on tests that don't need it
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修补程序将被应用在不需要它的测试上
- en: The mixins in our `TestCase` are dictated by the models we reference in our
    code, which can be a confusing level of indirection for test authors
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们`TestCase`中的mixin由我们在代码中引用的模型所决定，这对于测试作者来说可能是一种令人困惑的间接层次
- en: 'Some of the trade-offs when using a Factory are as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂时的一些权衡如下：
- en: We can still access the underlying function in a test if we need to.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，我们仍然可以访问测试中的基础函数。
- en: We don't have access to the resulting mock to assert (we often don't need it).
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法访问生成的模拟来断言（我们通常不需要它）。
- en: We don't connect the parent class of `TestCase` to the models we're referring
    to in our test methods. It's simpler for test authors.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不将`TestCase`的`parent class`与我们在测试方法中引用的模型连接起来。对于测试作者来说更简单。
- en: The ultimate decision for which approach to use is dictated by the test we're
    writing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用哪种方法的最终决定取决于我们正在编写的测试。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we gave Mail Ape the ability to send emails to our users' `MailingList`'s
    confirmed `Subscribers`. We also learned how to use Celery to process tasks outside
    of Django's request/response cycle. This lets us process tasks that may take a
    long time or require other resources (for example, SMTP servers and more memory)
    without slowing down our Django web servers.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们赋予了Mail Ape向我们用户的`MailingList`的确认`Subscribers`发送电子邮件的能力。我们还学会了如何使用Celery来处理Django请求/响应周期之外的任务。这使我们能够处理可能需要很长时间或需要其他资源（例如SMTP服务器和更多内存）的任务，而不会减慢我们的Django
    Web服务器。
- en: We covered a variety of email and Celery-related topics in this chapter. We
    saw how to configure Django to use an SMTP server. We used Django's `send_email()` function
    to send emails. We created a Celery task with the `@shared_task` decorator. We
    queued a Celery task using its `delay()` method. Finally, we explored some useful
    approaches for testing code that relies on external resources.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了各种与电子邮件和Celery相关的主题。我们看到了如何配置Django来使用SMTP服务器。我们使用了Django的`send_email()`函数来发送电子邮件。我们使用`@shared_task`装饰器创建了一个Celery任务。我们使用了`delay()`方法将一个Celery任务加入队列。最后，我们探讨了一些有用的方法来测试依赖外部资源的代码。
- en: Next, let's build an API for our Mail Ape so that our users can integrate into
    their own websites and apps.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的Mail Ape构建一个API，这样我们的用户就可以将其集成到他们自己的网站和应用程序中。
