- en: Chapter 1. Profiling 101
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。分析101
- en: Just like any infant needs to learn how to crawl before running 100 mts with
    obstacles in under 12 seconds, programmers need to understand the basics of profiling
    before trying to master that art. So, before we start delving into the mysteries
    of performance optimization and profiling on Python programs, we need to have
    a clear understanding of the basics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何婴儿都需要学会爬行，然后再在12秒内跑100米并克服障碍一样，程序员在尝试掌握这门艺术之前，需要理解分析的基础知识。因此，在我们深入探讨Python程序的性能优化和分析的奥秘之前，我们需要对基础知识有一个清晰的理解。
- en: 'Once you know the basics, you''ll be able to learn about the tools and techniques.
    So, to start us off, this chapter will cover everything you need to know about
    profiling but were too afraid to ask. In this chapter we will do the following
    things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了基础知识，你将能够了解工具和技术。因此，为了开始，本章将涵盖你关于分析所需了解的一切，但你可能因为害怕而未曾提问。在本章中，我们将做以下事情：
- en: We will provide a clear definition of what profiling is and the different profiling
    techniques.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将明确定义什么是分析，以及不同的分析技术。
- en: We will explain the importance of profiling in the development cycle, because
    profiling is not something you do only once and then forget about it. Profiling
    should be an integral part of the development process, just like writing tests
    is.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将解释分析在开发周期中的重要性，因为分析不是你只做一次然后忘记的事情。分析应该是开发过程的一个组成部分，就像编写测试一样。
- en: We will cover things we can profile. We'll go over the different types of resources
    we'll be able to measure and how they'll help us find our problems.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将涵盖我们可以分析的内容。我们将介绍我们将能够衡量的不同类型的资源以及它们如何帮助我们找到问题。
- en: We will discuss the risk of premature optimization, that is, why optimizing
    before profiling is generally a bad idea.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论过早优化的风险，即为什么在分析之前进行优化通常是一个糟糕的想法。
- en: You will learn about running time complexity. Understanding profiling techniques
    is one step into successful optimization, but we also need to understand how to
    measure the complexity of an algorithm in order to understand whether we need
    to improve it or not.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解运行时复杂度。理解分析技术是成功优化的第一步，但我们也需要了解如何衡量算法的复杂度，以便了解我们是否需要改进它。
- en: We will also look at good practices. Finally, we'll go over some good practices
    to keep in mind when starting the profiling process of your project.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将探讨良好的实践。最后，我们将回顾一些在开始项目分析过程时需要记住的良好实践。
- en: What is profiling?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是分析？
- en: A program that hasn't been optimized will normally spend most of its CPU cycles
    in some particular subroutines. Profiling is the analysis of how the code behaves
    in relation to the resources it's using. For instance, profiling will tell you
    how much CPU time an instruction is using or how much memory the full program
    is consuming. It is achieved by modifying either the source code of the program
    or the binary executable form (when possible) to use something called as a profiler.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未经优化的程序通常会在某些特定的子例程中花费大部分的CPU周期。分析是分析代码相对于其使用的资源的行为。例如，分析会告诉你一条指令使用了多少CPU时间，或者整个程序消耗了多少内存。这通过修改程序的源代码或二进制可执行形式（如果可能）来实现，使用的东西被称为分析器。
- en: Normally, developers profile their programs when they need to either optimize
    their performance or when those programs are suffering from some kind of weird
    bug, which can normally be associated with memory leaks. In such cases, profiling
    can help them get an in-depth understanding of how their code is using the computer's
    resources (that is, how many times a certain function is being called).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当开发者需要优化性能或程序出现某种奇怪的错误（这通常与内存泄漏有关）时，他们会分析程序。在这种情况下，分析可以帮助他们深入了解他们的代码是如何使用计算机资源的（即某个特定函数被调用的次数）。
- en: A developer can use this information, along with a working knowledge of the
    source code, to find the program's bottlenecks and memory leaks. The developer
    can then fix whatever is wrong with the code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用这些信息，结合对源代码的熟练掌握，来找出程序的瓶颈和内存泄漏。然后开发者可以修复代码中的任何错误。
- en: 'There are two main methodologies for profiling software: event-based profiling
    and statistical profiling. When using these types of software, you should keep
    in mind that they both have pros and cons.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件分析主要有两种方法：基于事件的性能分析和基于统计的性能分析。当使用这些类型的软件时，你应该记住它们都有优点和缺点。
- en: Event-based profiling
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于事件的性能分析
- en: 'Not every programming language supports this type of profiling. Here are some
    programming languages that support event-based profiling:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每种编程语言都支持这种类型的分析。以下是一些支持基于事件分析的编程语言：
- en: '**Java**: The **JVMTI** (**JVM Tools Interface**) provides hooks for profilers
    to trap events such as calls, thread-related events, class loads and so on'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java**: **JVMTI**（**JVM Tools Interface**）为分析器提供了钩子，用于捕获诸如调用、线程相关事件、类加载等事件'
- en: '**.NET**: Just like with Java, the runtime provides events ([http://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Testing/Profiling#Methods_of_data_gathering](http://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Testing/Profiling#Methods_of_data_gathering))'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET**: 就像Java一样，运行时提供了事件（[http://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Testing/Profiling#Methods_of_data_gathering](http://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Testing/Profiling#Methods_of_data_gathering)）'
- en: '**Python**: Using the `sys.setprofile` function, a developer can trap events
    such as `python_[call|return|exception]` or `c_[call|return|exception]`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**: 使用`sys.setprofile`函数，开发者可以捕获诸如`python_call`、`python_return`或`python_exception`或`c_call`、`c_return`或`c_exception`等事件'
- en: '**Event-based profilers** (also known as **tracing profilers**) work by gathering
    data on specific events during the execution of our program. These profilers generate
    a large amount of data. Basically, the more events they listen to, the more data
    they will gather. This makes them somewhat impractical to use, and they are not
    the first choice when starting to profile a program. However, they are a good
    last resort when other profiling methods aren''t enough or just aren''t specific
    enough. Consider the case where you''d want to profile all the return statements.
    This type of profiler would give you the granularity you''d need for this task,
    while others would simply not allow you to execute this task.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于事件的跟踪分析器**（也称为**跟踪分析器**）通过在程序执行过程中收集特定事件的数据来工作。这些分析器会生成大量数据。基本上，它们监听的事件越多，收集的数据就越多。这使得它们在某种程度上不太实用，并且它们不是开始分析程序时的首选。然而，当其他分析方法不够或不够具体时，它们是一个很好的最后手段。考虑一下你想分析所有返回语句的情况。这种类型的分析器会为你提供完成任务所需的粒度，而其他分析器则根本不允许你执行此任务。'
- en: 'A simple example of an event-based profiler on Python could be the following
    code (we''ll understand this topic better once we reach the upcoming chapters):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python中基于事件的跟踪分析器的一个简单例子可能是以下代码（一旦我们进入即将到来的章节，我们将更好地理解这个主题）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code contributes to the following output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码导致以下输出：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, `PROFILER` is called on every event. We can print/gather the
    information we deem relevant inside the `PROFILER` function. The last line on
    the sample code shows that the simple execution of `fib_seq(2)` generates a lot
    of output data. If we were dealing with a real-world program, this output would
    be several orders of magnitude bigger. This is why event-based profiling is normally
    the last option when it comes to profiling. There are other alternatives out there
    (as we'll see) that generate much less output, but, of course, have a lower accuracy
    rate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`PROFILER`在每次事件上都会被调用。我们可以在`PROFILER`函数内部打印/收集我们认为相关的信息。示例代码的最后一条显示了简单的`fib_seq(2)`执行会产生大量的输出数据。如果我们处理的是一个现实世界的程序，这种输出将会大得多。这就是为什么基于事件的跟踪通常是在分析时最后的选项。还有其他替代方案（我们将在后面看到）会产生更少的输出，但当然，准确性较低。
- en: Statistical profiling
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计分析
- en: Statistical profilers work by sampling the program counter at regular intervals.
    This in turn allows the developer to get an idea of how much time the target program
    is spending on each function. Since it works by sampling the PC, the resulting
    numbers will be a statistical approximation of reality instead of exact numbers.
    Still, it should be enough to get a glimpse of what the profiled program is doing
    and where the bottlenecks are.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 统计分析器通过在固定时间间隔采样程序计数器来工作。这反过来又允许开发者了解目标程序在各个函数上花费的时间。由于它是通过采样PC来工作的，因此得到的数字将是现实情况的统计近似值，而不是精确数字。尽管如此，这应该足以了解被分析程序正在做什么以及瓶颈在哪里。
- en: 'Some advantages of this type of profiling are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型分析的优势如下：
- en: '**Less data to analyze**: Since we''re only sampling the program''s execution
    instead of saving every little piece of data, the amount of information to analyze
    will be significantly smaller.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析数据更少**：由于我们只采样程序的执行而不是保存每一小块数据，因此需要分析的信息量将显著减少。'
- en: '**Smaller profiling footprint**: Due to the way the sampling is made (using
    OS interrupts), the target program suffers a smaller hit on its performance. Although
    the presence of the profiler is not 100 percent unnoticed, statistical profiling
    does less damage than the event-based one.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的剖析影响范围**：由于采样方式（使用操作系统中断），目标程序在性能上受到的影响较小。尽管剖析器的存在并非完全不被察觉，但统计剖析对程序造成的损害比基于事件的剖析要小。'
- en: 'Here is an example of the output of **OProfile** ([http://oprofile.sourceforge.net/news/](http://oprofile.sourceforge.net/news/)),
    a Linux statistical profiler:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是**OProfile**（[http://oprofile.sourceforge.net/news/](http://oprofile.sourceforge.net/news/)）的输出示例，OProfile
    是一个 Linux 统计分析器：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the output of profiling the same Fibonacci code from the preceding
    code using a statistical profiler for Python called statprof:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用名为 statprof 的 Python 统计分析器对前面代码中的相同 Fibonacci 代码进行剖析的输出：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, there is quite a difference between the output of both profilers
    for the same code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于相同的代码，两个剖析器的输出存在相当大的差异。
- en: The importance of profiling
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剖析的重要性
- en: Now that we know what profiling means, it is also important to understand how
    important and relevant it is to actually do it during the development cycle of
    our applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了剖析的含义，了解在应用程序的开发周期中实际进行剖析的重要性和相关性也同样重要。
- en: Profiling is not something everyone is used to do, especially with non-critical
    software (unlike peace maker embedded software or any other type of execution-critical
    example). Profiling takes time and is normally useful only after we've detected
    that something is wrong with our program. However, it could still be performed
    before that even happens to catch possible unseen bugs, which would, in turn,
    help chip away the time spent debugging the application at a later stage.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 剖析并不是每个人都习惯做的事情，尤其是对于非关键软件（与和平制造嵌入式软件或任何其他类型的执行关键示例不同）。剖析需要时间，并且通常只有在我们发现程序有问题时才有用。然而，即使在那之前，它仍然可以执行，以捕捉可能未被发现的问题，这反过来又可以帮助我们在稍后阶段减少调试应用程序所花费的时间。
- en: As hardware keeps advancing, getting faster and cheaper, it is increasingly
    hard to understand why we, as developers, should spend resources (mainly time)
    on profiling our creations. After all, we have practices such as test-driven development,
    code review, pair programming and others that assure us our code is solid and
    that it'll work as we want it. Right?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 随着硬件的不断进步，速度越来越快，价格越来越便宜，我们作为开发者，为何还要花费资源（主要是时间）来分析我们的作品变得越来越难以理解。毕竟，我们有诸如测试驱动开发、代码审查、结对编程等其他实践，这些实践确保我们的代码是可靠的，并且能够按照我们的预期工作。对吧？
- en: However, what we sometimes fail to realize is that the higher level our languages
    become (we've gone from assembler to JavaScript in just a few years), the less
    we think about CPU cycles, memory allocation, CPU registries, and so on. New generations
    of programmers learn their craft using higher level languages because they're
    easier to understand and provide more power out of the box. However, they also
    abstract the hardware and our interaction with it. As this tendency keeps growing,
    the chances that new developers will even consider profiling their software as
    another step on its development grows weaker by the second.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们有时未能意识到的是，随着我们语言级别的提高（我们仅在几年内从汇编语言过渡到 JavaScript），我们对 CPU 循环、内存分配、CPU 寄存器等问题的思考越来越少。新一代程序员使用高级语言学习他们的技艺，因为这些语言更容易理解，并且能够提供开箱即用的更多功能。然而，它们也抽象化了硬件以及我们与它的交互。随着这种趋势的不断增长，新开发者甚至考虑将软件剖析作为其开发过程中的另一个步骤的可能性也在逐秒减弱。
- en: 'Let''s look at the following scenario:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下场景：
- en: As we know, profiling measures the resources our program uses. As I've stated
    earlier, they keep getting cheaper and cheaper. So, the cost of getting our software
    out and the cost of making it available to a higher number of users is also getting
    cheaper.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，剖析测量了我们的程序使用的资源。正如我之前所述，这些资源正变得越来越便宜。因此，将我们的软件推向市场以及使其可供更多用户使用的成本也在降低。
- en: These days, it is increasingly easy to create and publish an application that
    will be reached by thousands of people. If they like it and spread the word through
    social media, that number can blow up exponentially. Once that happens, something
    that is very common is that the software will crash, or it'll become impossibly
    slow and the users will just go away.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，创建和发布一个将被数千人访问的应用程序越来越容易。如果他们喜欢它，并通过社交媒体传播，这个数字可以呈指数级增长。一旦发生这种情况，非常常见的是软件会崩溃，或者它会变得无比缓慢，用户就会离开。
- en: A possible explanation for the preceding scenario is, of course, a badly thought
    and non-scalable architecture. After all, one single server with a limited amount
    of RAM and processing power will get you so far until it becomes your bottleneck.
    However, another possible explanation, one that proves to be true many times,
    is that we failed to stress test our application. We didn't think about resource
    consumption; we just made sure our tests passed, and we were happy with that.
    In other words, we failed to go that extra mile, and as a result, our project
    crashed and burned.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面提到的情况，一个可能的解释当然是一个考虑不周且不可扩展的架构。毕竟，一个单服务器，有限的RAM和计算能力，只能让你走这么远，直到它成为你的瓶颈。然而，另一个可能的解释，一个被证明多次是正确的解释，是我们没有对我们的应用程序进行压力测试。我们没有考虑资源消耗；我们只是确保我们的测试通过，并且我们对这个结果感到满意。换句话说，我们没有走那额外的路，结果我们的项目失败了。
- en: Profiling can help avoid that crash and burn outcome, since it provides a fairly
    accurate view of what our program is doing, no matter the load. So, if we profile
    it with a very light load, and the result is that we're spending 80 percent of
    our time doing some kind of I/O operation, it might raise a flag for us. Even
    if, during our test, the application performed correctly, it might not do so under
    heavy stress. Think of a memory leak-type scenario. In those cases, small tests
    might not generate a big enough problem for us to detect it. However, a production
    deployment under heavy stress will. Profiling can provide enough evidence for
    us to detect this problem before it even turns into one.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 分析可以帮助避免那种崩溃和失败的结果，因为它提供了一个相当准确的观点，无论负载如何。所以，如果我们用很轻的负载来分析它，结果是我们在进行某种I/O操作上花费了80%的时间，这可能会对我们提出警告。即使在我们的测试中，应用程序表现正确，它可能在重压下并不如此。想想内存泄漏类型的场景。在这些情况下，小测试可能不会产生足够大的问题让我们检测到它。然而，在重压下的生产部署会。分析可以提供足够的证据，让我们在问题变成问题之前就检测到它。
- en: What can we profile?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以分析什么？
- en: Going deeper into profiling, it is very important to understand what we can
    actually profile. Measuring is the core of profiling, so let's take a detailed
    look at the things we can measure during a program's execution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 深入分析，了解我们实际上可以分析什么非常重要。测量是分析的核心，所以让我们详细看看在程序执行期间我们可以测量的东西。
- en: Execution time
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行时间
- en: 'The most basic of the numbers we can gather when profiling is the execution
    time. The execution time of the entire process or just of a particular portion
    of the code will shed some light on its own. If you have experience in the area
    your program is running (that is, you''re a web developer and you''re working
    on a web framework), you probably already know what it means for your system to
    take too much time. For instance, a simple web server might take up to 100 milliseconds
    when querying the database, rendering the response, and sending it back to the
    client. However, if the same piece of code starts to slow down and now it takes
    60 seconds to do the same task, then you should start thinking about profiling.
    You also have to consider that numbers here are relative. Let''s assume another
    process: a MapReduce job that is meant to process 2 TB of information stored on
    a set of text files takes 20 minutes. In this case, you might not consider it
    as a slow process, even when it takes considerably more time than the slow web
    server mentioned earlier.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析时我们可以收集的最基本的数据是执行时间。整个过程的执行时间或只是代码特定部分的执行时间会对其本身有所启示。如果你在程序运行的领域有经验（也就是说，你是一个网络开发者，你正在工作在一个网络框架上），你可能已经知道对于你的系统来说，花费太多时间意味着什么。例如，一个简单的网络服务器在查询数据库、渲染响应并发送回客户端时可能需要高达100毫秒。然而，如果相同的代码开始变慢，现在它需要60秒来完成同样的任务，那么你应该开始考虑分析。你还得考虑这里的数字是相对的。让我们假设另一个过程：一个MapReduce作业，旨在处理存储在一系列文本文件上的2TB信息，需要20分钟。在这种情况下，你可能不会认为它是一个慢过程，即使它比前面提到的慢网络服务器花费的时间要多得多。
- en: To get this type of information, you don't really need a lot of profiling experience
    or even complex tools to get the numbers. Just add the required lines into your
    code and run the program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取这类信息，你并不真的需要大量的性能分析经验，甚至不需要复杂的工具来获取数据。只需将所需的行添加到你的代码中并运行程序即可。
- en: 'For instance, the following code will calculate the Fibonnacci sequence for
    the number 30:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将计算数字30的斐波那契数列：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, the code will produce the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码将产生以下输出：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Based on the last three lines, we see the obvious results: the most expensive
    part of the code is the actual calculation of the Fibonacci sequence.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最后三行，我们可以看到明显的结果：代码中最昂贵的部分是斐波那契数列的实际计算。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您购买的所有Packt出版物的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Where are the bottlenecks?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓶颈在哪里？
- en: 'Once you''ve measured how much time your code needs to execute, you can profile
    it by paying special attention to the slow sections. These are the bottlenecks,
    and normally, they are related to one or a combination of the following reasons:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你测量了你的代码需要执行的时间，你可以通过特别关注慢速部分来对其进行分析。这些就是瓶颈，通常它们与以下一个或多个原因相关：
- en: Heavy I/O operations, such as reading and parsing big files, executing long-running
    database queries, calling external services (such as HTTP requests), and so on
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重大的I/O操作，如读取和解析大文件、执行长时间运行的数据库查询、调用外部服务（如HTTP请求）等
- en: Unexpected memory leaks that start building up until there is no memory left
    for the rest of the program to execute properly
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外的内存泄漏开始累积，直到没有内存可供程序正确执行
- en: Unoptimized code that gets executed frequently
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行频率高的未优化代码
- en: Intensive operations that are not cached when they could be
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本可以缓存但未缓存的高强度操作
- en: I/O-bound code (file reads/write, database queries, and so on) is usually harder
    to optimize, because that would imply changing the way the program is dealing
    with that I/O (normally using core functions from the language). Instead, when
    optimizing compute-bound code (like a function that is using a badly implemented
    algorithm), getting a performance improvement is easier (although not necessarily
    easy). This is because it just implies rewriting it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: I/O受限的代码（文件读写、数据库查询等）通常更难优化，因为这会意味着改变程序处理这些I/O的方式（通常使用语言的核心函数）。相反，当优化计算受限的代码（如使用实现不佳的算法的函数）时，获得性能提升更容易（尽管不一定容易）。这是因为它仅仅意味着重写它。
- en: A general indicator that you're near the end of a performance optimization process
    is when most of the bottlenecks left are due to I/O-bound code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普遍的指标表明你接近性能优化过程的尾声，那就是剩下的瓶颈大部分是由于I/O受限的代码造成的。
- en: Memory consumption and memory leaks
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存消耗和内存泄漏
- en: Another very important resource to consider when developing software is memory.
    Regular software developers don't really care much about it, since the era of
    the 640 KB of RAM PC is long dead. However, a memory leak on a long-running program
    can turn any server into a 640 KB computer. Memory consumption is not just about
    having enough memory for your program to run; it's also about having control over
    the memory that your programs use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，另一个需要考虑的重要资源是内存。常规软件开发者并不真正关心它，因为640 KB RAM的PC时代已经一去不复返了。然而，在长时间运行程序中的内存泄漏可以将任何服务器变成一个640
    KB的电脑。内存消耗不仅仅是确保你的程序有足够的内存来运行；它还涉及到控制程序使用的内存。
- en: There are some developments, such as embedded systems, that actually require
    developers to pay extra attention to the amount of memory they use, because it
    is a limited resource in those systems. However, an average developer can expect
    their target system to have the amount of RAM they require.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有些发展，如嵌入式系统，实际上要求开发者特别注意他们使用的内存量，因为在那类系统中，内存是一种有限的资源。然而，一个普通的开发者可以预期他们的目标系统将拥有他们所需的RAM量。
- en: With RAM and higher level languages that come with automatic memory management
    (like garbage collection), the developer is less likely to pay much attention
    to memory utilization, trusting the platform to do it for them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RAM和带有自动内存管理（如垃圾回收）的高级语言，开发者不太可能过多关注内存利用率，相信平台会为他们处理。
- en: 'Keeping track of memory consumption is relatively straightforward. At least
    for a basic approach, just use your OS''s task manager. It''ll display, among
    other things, the amount of memory used or at least the percentage of total memory
    used by your program. The task manager is also a great tool to check your CPU
    time consumption. As you can see in the next screenshot, a simple Python program
    (the preceding one) is taking up almost the entire CPU power (99.8 percent), and
    barely 0.1 percent of the total memory that is available:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪内存消耗相对简单。至少对于基本方法，只需使用你的操作系统任务管理器。它将显示，包括其他事项在内，你的程序使用的内存量或至少是程序使用的总内存百分比。任务管理器也是一个检查你的CPU时间消耗的绝佳工具。正如你在下一张截图中所见，一个简单的Python程序（前面的那个）几乎占用了全部的CPU功率（99.8%），而总共只有0.1%的可用内存：
- en: '![Memory consumption and memory leaks](img/B02088_01_01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![内存消耗和内存泄漏](img/B02088_01_01.jpg)'
- en: With a tool like that (the `top` command line tool from Linux), spotting memory
    leaks can be easy, but that will depend on the type of software you're monitoring.
    If your program is constantly loading data, its memory consumption rate will be
    different from another program that doesn't have to deal much with external resources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的工具（Linux的`top`命令行工具），发现内存泄漏可以很容易，但这将取决于你正在监控的软件类型。如果你的程序不断加载数据，它的内存消耗率将不同于不需要处理太多外部资源的另一个程序。
- en: 'For instance, if we were to chart the memory consumption over time of a program
    dealing with lots of external data, it would look like the following chart:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们绘制一个处理大量外部数据的程序随时间变化的内存消耗图表，它看起来会像以下这样的图表：
- en: '![Memory consumption and memory leaks](img/B02088_01_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![内存消耗和内存泄漏](img/B02088_01_02.jpg)'
- en: There will be peaks, when these resources get fully loaded into memory, but
    there will also be some drops, when those resources are released. Although the
    memory consumption numbers fluctuate quite a bit, it's still possible to estimate
    the average amount of memory that the program will use when no resources are loaded.
    Once you define that area (marked as a green box in the preceding chart), you
    can spot memory leaks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些资源完全加载到内存中时，会出现峰值，但当这些资源被释放时，也会出现一些下降。尽管内存消耗数值波动很大，但仍然可以估计程序在没有加载资源时将使用的平均内存量。一旦你定义了那个区域（前面图表中标记为绿色框的区域），你就可以发现内存泄漏。
- en: 'Let''s look at how the same chart would look with bad resource handling (not
    fully releasing allocated memory):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果资源管理不当（没有完全释放分配的内存），同样的图表会是什么样子：
- en: '![Memory consumption and memory leaks](img/B02088_01_03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![内存消耗和内存泄漏](img/B02088_01_03.jpg)'
- en: In the preceding chart, you can clearly see that not all memory is released
    when a resource is no longer used, which is causing the line to move out of the
    green box. This means the program is consuming more and more memory every second,
    even when the resources loaded are released.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，你可以清楚地看到，当资源不再使用时，并非所有内存都会被释放，这导致线条移出了绿色框。这意味着程序每秒都在消耗越来越多的内存，即使加载的资源已经释放。
- en: The same can be done with programs that aren't resource heavy, for instance,
    scripts that execute a particular processing task for a considerable period of
    time. In those cases, the memory consumption and the leaks should be easier to
    spot.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不是资源密集型的程序，例如执行特定处理任务相当长一段时间的脚本，也可以这样做。在这些情况下，内存消耗和泄漏应该更容易被发现。
- en: 'Let''s take a look at an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '![Memory consumption and memory leaks](img/B02088_01_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![内存消耗和内存泄漏](img/B02088_01_04.jpg)'
- en: When the processing stage starts, the memory consumption should stabilize within
    a clearly defined range. If we spot numbers outside that range, especially if
    it goes out of it and never comes back, we're looking at another example of a
    memory leak.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理阶段开始时，内存消耗应该在明确定义的范围内稳定。如果我们发现超出该范围的数值，尤其是如果它出去后不再回来，我们就在看另一个内存泄漏的例子。
- en: 'Let''s look at an example of such a case:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个这样的例子：
- en: '![Memory consumption and memory leaks](img/B02088_01_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![内存消耗和内存泄漏](img/B02088_01_05.jpg)'
- en: The risk of premature optimization
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提前优化的风险
- en: Optimization is normally considered a good practice. However, this doesn't hold
    true when the act of optimization ends up driving the design decisions of the
    software solution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 优化通常被认为是一种良好的实践。然而，当优化行为最终驱动软件解决方案的设计决策时，这一点并不成立。
- en: A very common pitfall developers face while starting to code a new piece of
    software is premature optimization.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在开始编写新软件时常常会遇到的一个常见陷阱是过早优化。
- en: When this happens, the end result ends up being quite the opposite of the intended
    optimized code. It can contain an incomplete version of the required solution,
    or it can even contain errors derived from the optimization-driven design decisions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，最终结果往往与预期的优化代码相反。它可能包含所需解决方案的不完整版本，或者甚至包含来自优化驱动的设计决策的错误。
- en: As a normal rule of thumb, if you haven't measured (profiled) your code, optimizing
    it might not be the best idea. First, focus on readable code. Then, profile it
    and find out where the real bottlenecks are, and as a final step, perform the
    actual optimization.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条常规规则，如果你还没有测量（分析）你的代码，优化它可能不是最好的主意。首先，关注可读的代码。然后，分析它并找出真正的瓶颈，最后，进行实际的优化。
- en: Running time complexity
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时间复杂度
- en: When profiling and optimizing code, it's really important to understand what
    **Running time complexity** (**RTC**) is and how we can use that knowledge to
    properly optimize our code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析代码和优化时，真正重要的是要理解**运行时间复杂度**（**RTC**）是什么，以及我们如何利用这些知识来正确优化我们的代码。
- en: RTC helps quantify the execution time of a given algorithm. It does so by providing
    a mathematical approximation of the time a piece of code will take to execute
    for any given input. It is an approximation, because that way, we're able to group
    similar algorithms using that value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: RTC 通过提供任何给定输入下代码执行时间的数学近似来量化给定算法的执行时间。这是一个近似值，因为这样我们能够使用该值将类似的算法分组。
- en: RTC is expressed using something called **Big O notation**. In mathematics,
    Big O notation is used to express the limiting behavior of a given function when
    the terms tend to infinity. If I apply that concept in computer science, we can
    use Big O notation to express the limiting behavior of the function describing
    the execution time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: RTC 使用称为 **大O符号** 的东西来表示。在数学中，大O符号用于表示当项趋于无穷大时给定函数的极限行为。如果我在计算机科学中应用这个概念，我们可以使用大O符号来表示描述执行时间的函数的极限行为。
- en: In other words, this notation will give us a broad idea of how long our algorithm
    will take to process an arbitrarily large input. It will not, however, give us
    a precise number for the time of execution, which would require a more in-depth
    analysis of the source code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这种表示法将给我们一个大致的概念，了解我们的算法处理任意大输入将需要多长时间。然而，它不会给我们执行时间的精确数字，这需要更深入地分析源代码。
- en: 'As I''ve said earlier, we can use this tendency to group algorithms. Here are
    some of the most common groups:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说的，我们可以利用这种趋势来分组算法。以下是一些最常见的分组：
- en: Constant time – O(1)
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常数时间 – O(1)
- en: This is the simplest of them all. This notation basically means that the action
    we're measuring will always take a constant amount of time, and this time is not
    dependent on the size of the input.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的一种。这种表示法基本上意味着我们正在测量的动作将始终花费固定的时间，并且这个时间不依赖于输入的大小。
- en: 'Here are some examples of code that have *O(1)* execution time:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些具有 *O(1)* 执行时间的代码示例：
- en: 'Determining whether a number is odd or even:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断一个数字是奇数还是偶数：
- en: '[PRE6]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Printing a message into standard output:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息打印到标准输出：
- en: '[PRE7]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even something more conceptually complex, like finding the value of a key inside
    a dictionary (or hash table), if implemented correctly, can be done in constant
    time. Technically speaking, accessing an element on the hash takes *O(1)* amortized
    time, which roughly means that the average time each operation takes (without
    taking into account edge cases) is a constant *O(1)* time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是更概念上复杂的任务，比如在字典（或哈希表）中查找键的值，如果实现正确，也可以在常数时间内完成。从技术上讲，访问哈希表中的元素需要 *O(1)* 平摊时间，这大致意味着每个操作的平均时间（不考虑边缘情况）是一个常数
    *O(1)* 时间。
- en: Linear time – O(n)
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性时间 – O(n)
- en: Linear time dictates that for a given input of arbitrary length *n*, the amount
    of time required for the execution of the algorithm is linearly proportional to
    *n*, for instance, *3n*, *4n + 5*, and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 线性时间规定，对于任意长度为 *n* 的给定输入，算法执行所需的时间与 *n* 成线性比例，例如，*3n*，*4n + 5*，等等。
- en: '![Linear time – O(n)](img/B02088_01_06.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![线性时间 – O(n)](img/B02088_01_06.jpg)'
- en: The preceding chart clearly shows that both the blue (*3n*) line and the red
    one (*4n + 5*) have the same upper limit as the black line (*n*) when *x* tends
    to infinity. So, to simplify, we can just say that all three functions are *O(n)*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表清楚地显示，当*x*趋向于无穷大时，蓝色(*3n*)线和红色线(*4n + 5*)与黑色线(*n*)具有相同的上限。因此，为了简化，我们可以说这三个函数都是*O(n)*。
- en: 'Examples of algorithms with this execution order are:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这种执行顺序的算法示例：
- en: Finding the smallest value in an unsorted list
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个未排序的列表中寻找最小值
- en: Comparing two strings
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较两个字符串
- en: Deleting the last item inside a linked list
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除链表中的最后一个项目
- en: Logarithmic time – O(log n)
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数时间 – O(log n)
- en: An algorithm with logarithmic execution time is one that will have a very determined
    upper limit time. A logarithmic function grows quickly at first, but it'll slow
    down as the input size gets bigger. It will never stop growing, but the amount
    it grows by will be so small that it will be irrelevant.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 具有对数执行时间的算法将具有一个非常确定的最高限时间。对数函数最初增长得很快，但随着输入规模的增大，它会减慢。它永远不会停止增长，但增长的量将非常小，以至于无关紧要。
- en: '![Logarithmic time – O(log n)](img/B02088_01_07.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![对数时间 – O(log n)](img/B02088_01_07.jpg)'
- en: The preceding chart shows three different logarithmic functions. You can clearly
    see that they all possess a similar shape, including the upper limit *x*, which
    keeps increasing to infinity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了三个不同的对数函数。你可以清楚地看到，它们都具有相似的形状，包括上限*x*，它不断增加到无穷大。
- en: 'Some examples of algorithms that have logarithmic execution time are:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些具有对数执行时间的算法示例：
- en: Binary search
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分搜索
- en: Calculating Fibonacci numbers (using matrix multiplications)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算斐波那契数（使用矩阵乘法）
- en: Linearithmic time – O(nlog n)
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数时间 – O(nlog n)
- en: A particular combination of the previous two orders of execution is the linearithmic
    time. It grows quickly as soon as the value of *x* starts increasing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个执行顺序的特定组合是线性对数时间。当*x*的值开始增加时，它增长得很快。
- en: 'Here are some examples of algorithms that have this order of execution:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些具有这种执行顺序的算法示例：
- en: Merge sort
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序
- en: Heap sort
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆排序
- en: Quick sort (at least its average time complexity)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序（至少是其平均时间复杂度）
- en: 'Let''s see a few examples of plotted linearithmic functions to understand them
    better:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些绘制出的线性对数函数，以更好地理解它们：
- en: '![Linearithmic time – O(nlog n)](img/B02088_01_08.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![线性对数时间 – O(nlog n)](img/B02088_01_08.jpg)'
- en: Factorial time – O(n!)
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阶乘时间 – O(n!)
- en: Factorial time is one of the worst execution times we might get out of an algorithm.
    It grows so quickly that it's hard to plot.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘时间是算法可能得到的最糟糕的执行时间之一。它增长得如此之快，以至于很难绘制。
- en: 'Here is a rough approximation of how the execution time of our algorithm would
    look with factorial time:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是算法执行时间在阶乘时间下的粗略近似：
- en: '![Factorial time – O(n!)](img/B02088_01_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![阶乘时间 – O(n!)](img/B02088_01_09.jpg)'
- en: An example of an algorithm with factorial execution time is the solution for
    the traveling salesman using brute force search (basically checking every single
    possible solution).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有阶乘执行时间的算法示例是使用穷举搜索解决旅行商问题（基本上是检查每一个可能的解决方案）。
- en: Quadratic time – O(n^)
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二次时间 – O(n^)
- en: Quadratic execution time is another example of a fast growing algorithm. The
    bigger the input size, the longer it's going to take (this is true for most complexities,
    but then again, specially true for this one). Quadratic execution time is even
    less efficient that linearithmic time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 二次执行时间是另一个快速增长的算法示例。输入规模越大，所需时间越长（这在大多数复杂度中都是如此，但特别对于这个来说更是如此）。二次执行时间甚至比对数时间效率更低。
- en: 'Some examples of algorithms having this order of execution are:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些具有这种执行顺序的算法示例：
- en: Bubble sort
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Traversing a 2D array
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历一个二维数组
- en: Insertion sort
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: 'Here are some examples of plotted exponential functions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些绘制出的指数函数示例：
- en: '![Quadratic time – O(n^)](img/B02088_01_10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![二次时间 – O(n^)](img/B02088_01_10.jpg)'
- en: 'Finally, let''s look at all examples plotted together to get a clear idea of
    algorithm efficiency:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看所有绘制在一起以获得算法效率的清晰概念：
- en: '![Quadratic time – O(n^)](img/B02088_01_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![二次时间 – O(n^)](img/B02088_01_11.jpg)'
- en: 'Leaving aside constant execution time, which is clearly faster but most of
    the time impossible to achieve in complex algorithms, the order or preference
    should be:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除去恒定执行时间，这显然更快，但在复杂算法中通常难以实现，顺序或偏好应该是：
- en: Logarithmic
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数
- en: Linear
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性
- en: Linearithmic
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性对数
- en: Quadratic
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二次
- en: Factorial
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阶乘
- en: Obviously, there are cases when you'll have no choice but to get a quadratic
    execution time as the best possible result. The idea is to always aim for the
    faster algorithms, but the limitations of your problems and technology will affect
    the actual result.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在某些情况下，你将别无选择，只能得到二次执行时间作为最佳结果。目标是始终追求更快的算法，但你的问题和技术的限制将影响实际结果。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that between quadratic and factorial times, there are several other alternatives
    (cubic, *n ^ 4*, and so on).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在二次和阶乘时间之间，还有其他几种替代方案（立方、*n^4* 等）。
- en: 'Another important consideration is that most algorithms don''t have only a
    single order of execution time. They can have up to three orders of execution
    time: for the best case, normal case, and worst case scenarios. The scenario is
    determined by the properties of the input data. For instance, the insertion sort
    algorithm will run much faster if the input is already sorted (best case), and
    it will be worst (exponential order) for other types of input.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是，大多数算法不仅仅有一个执行时间顺序。它们可以有高达三个执行时间顺序：对于最佳情况、正常情况和最坏情况场景。场景由输入数据的属性决定。例如，如果输入已经排序（最佳情况），插入排序算法将运行得更快，而对于其他类型的输入，它将是最差的（指数级）。
- en: 'Other interesting cases to look at are the data types used. They inherently
    come with execution time that is associated with actions you can perform on them
    (lookup, insert, search, and so on). Let''s look at some of the most common data
    types and their associated actions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 值得关注的其他有趣案例是所使用的数据类型。它们本质上与你可以对其执行的操作（查找、插入、搜索等）相关的执行时间相关联。让我们看看一些最常见的数据类型及其相关操作：
- en: '| Data Structure | Time complexity |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 数据结构 | 时间复杂度 |'
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|   | **Average case** | **Worst case** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|   | **平均情况** | **最坏情况** |'
- en: '|   | **Indexing** | **Search** | **Insertion** | **Deletion** | **Indexing**
    | **Search** | **Insertion** | **Deletion** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|   | **索引** | **搜索** | **插入** | **删除** | **索引** | **搜索** | **插入** | **删除**
    |'
- en: '| **List** | *O(1)* | *O(n)* | *-* | *-* | *O(1)* | *O(n)* | *-* | *-* |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **列表** | *O(1)* | *O(n)* | *-* | *-* | *O(1)* | *O(n)* | *-* | *-* |'
- en: '| **Linked list** | *O(n)* | *O(n)* | *O(1)* | *O(1)* | *O(n)* | *O(n)* | *O(1)*
    | *O(n)* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **链表** | *O(n)* | *O(n)* | *O(1)* | *O(1)* | *O(n)* | *O(n)* | *O(1)* | *O(n)*
    |'
- en: '| **Doubly linked list** | *O(n)* | *O(n)* | *O(1)* | *O(1)* | *O(n)* | *O(n)*
    | *O(1)* | *O(1)* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **双链表** | *O(n)* | *O(n)* | *O(1)* | *O(1)* | *O(n)* | *O(n)* | *O(1)* |
    *O(1)* |'
- en: '| **Dictionary** | *-* | *O(1)* | *O(1)* | *O(1)* | *-* | *O(n)* | *O(n)* |
    *O(n)* |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **字典** | *-* | *O(1)* | *O(1)* | *O(1)* | *-* | *O(n)* | *O(n)* | *O(n)*
    |'
- en: '| **Binary search tree** | *O(log(n))* | *O(log(n))* | *O(log(n))* | *O(log(n))*
    | *O(n)* | *O(n)* | *O(n)* | *O(n)* |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **二叉搜索树** | *O(log(n))* | *O(log(n))* | *O(log(n))* | *O(log(n))* | *O(n)*
    | *O(n)* | *O(n)* | *O(n)* |'
- en: Profiling best practices
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析最佳实践
- en: 'Profiling is a repetitive task. You''ll do it several times inside the same
    project in order to get the best results, and you''ll do it again on the next
    project. Just like with any other repetitive task in software development, there
    is a set of best practices you can follow to ensure that you get the most out
    of the process. Let''s look at some of them:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析是一个重复性的任务。你需要在同一个项目中多次进行性能分析以获得最佳结果，并在下一个项目中再次进行。就像软件开发中的任何其他重复性任务一样，有一套最佳实践可以遵循，以确保你从过程中获得最大收益。让我们看看其中的一些：
- en: Build a regression-test suite
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建回归测试套件
- en: Before starting any kind of optimization process, you need to make sure that
    the changes you make to the code will not affect its functioning in a bad way.
    The best way to do this, especially when it's a big code base, is to create a
    test suite. Make sure that your code coverage is high enough to provide the confidence
    you need to make the changes. A test suite with 60 percent code coverage can lead
    to very bad results.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何类型的优化过程之前，你需要确保你对代码所做的更改不会以不良的方式影响其功能。特别是当代码库很大时，最好的方法就是创建一个测试套件。确保你的代码覆盖率足够高，以便提供你进行更改所需的信心。60%的代码覆盖率可能导致非常糟糕的结果。
- en: A regression-test suite will allow you to make as many optimization tries as
    you need to without fear of breaking the code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个回归测试套件将允许你进行尽可能多的优化尝试，而不用担心破坏代码。
- en: Mind your code
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意你的代码
- en: Functional code tends to be easier to refactor, mainly because the functions
    structured that way tend to avoid side effects. This reduces any risk of affecting
    unwanted parts of your system. If your functions avoid a local mutable state,
    that's another winning point for you. This is because the code should be pretty
    straightforward for you to understand and change. Functions that don't follow
    the previously mentioned guidelines will require more work and care while refactoring.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式代码通常更容易重构，主要是因为以这种方式组织的函数往往避免了副作用。这减少了影响系统不需要的部分的风险。如果你的函数避免了局部可变状态，那对你来说又是一个加分项。这是因为代码应该对你来说非常直观，易于理解和修改。不遵循前面提到的指南的函数在重构时将需要更多的工作和关注。
- en: Be patient
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持耐心
- en: Profiling is not fast, not easy, and not an exact process. What this means is
    that you should not expect to just run the profiler and expect the data from it
    to point directly to your problem. That could happen, yes. However, most of the
    time, the problems you're trying to solve are the ones that simple debugging couldn't
    fix. This means you'll be browsing through data, plotting it to try to make sense
    of it, and narrowing down the source of your problem until you either need to
    start again, or you find it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 分析过程既不快，也不容易，也不是一个精确的过程。这意味着你不应该期望只运行分析器，并期望从它那里直接得到指向问题的数据。是的，这种情况可能发生。然而，大多数情况下，你试图解决的问题正是简单调试无法解决的。这意味着你将浏览数据，绘制图表以试图理解它，并缩小问题的根源，直到你需要重新开始，或者找到它。
- en: Keep in mind that the deeper you get into the profiled data, the deeper into
    the rabbit hole you get. Numbers will stop making sense right away, so make sure
    you know what you're doing and that you have the right tools for the job before
    you start. Otherwise, you'll waste your time and end up with nothing but frustration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你越深入分析所分析的数据，你就越深入到兔子洞中。数字会立即失去意义，所以请确保你在开始之前知道自己在做什么，并且拥有完成这项工作的正确工具。否则，你会浪费时间，最终只会感到沮丧。
- en: Gather as much data as you can
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集尽可能多的数据
- en: Depending on the type and size of software you're dealing with, you might want
    to get as much data as you can before you start analyzing it. Profilers are a
    great source for this. However, there are other sources, such as server logs from
    web applications, custom logs, system resources snapshots (like from the OS task
    manager), and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你处理的软件的类型和大小，你可能在开始分析之前想要尽可能多地收集数据。分析器是这一点的绝佳来源。然而，还有其他来源，例如网络应用程序的服务器日志、自定义日志、系统资源快照（如来自操作系统任务管理器）等。
- en: Preprocess your data
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理你的数据
- en: After you have all the information from your profilers, your logs, and other
    sources, you will probably need to preprocess the data before analyzing it. Don't
    shy away from unstructured data just because a profiler can't understand it. Your
    analysis of the data will benefit from the extra numbers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在你从分析器、日志和其他来源收集到所有信息之后，你可能会在分析之前需要预处理这些数据。不要因为分析器无法理解非结构化数据就回避它。你的数据分析将受益于额外的数字。
- en: For instance, getting the web server logs is a great idea if you're profiling
    a web application, but those files are normally just text files with one line
    per request. By parsing it and getting the data into some kind of database system
    (like MongoDB, MySQL, or the like), you'll be able to give that data meaning (by
    parsing the dates, doing geolocation by source IP address, and so on) and query
    that information afterwards.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在分析一个网络应用程序，获取网络服务器日志是一个很好的主意，但这些文件通常是每条请求一行文本的文件。通过解析它并将数据导入某种数据库系统（如MongoDB、MySQL等），你将能够赋予这些数据意义（通过解析日期，根据源IP地址进行地理位置定位等），并在之后查询这些信息。
- en: The formal name for the stage is ETL, which stands for *extracting the data
    from it's sources, transforming it into something with meaning, and loading it
    into another system that you can later query*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的正式名称是ETL，代表*从其来源提取数据，将其转换成有意义的格式，并将其加载到另一个可以稍后查询的系统*。
- en: Visualize your data
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化你的数据
- en: If you don't know exactly what it is that you're looking for and you're just
    looking for ways to optimize your code before something goes wrong, a great idea
    to get some insight into the data you've already preprocessed is to visualize
    it. Computers are great with numbers, but humans, on the other hand, are great
    with images when we want to find patterns and understand what kind of insight
    we can gather from the information we have.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道你具体在寻找什么，只是想在你遇到问题之前优化你的代码，一个很好的想法是可视化你已经预处理的数据。计算机擅长处理数字，但另一方面，当我们想要寻找模式并理解我们能从我们所拥有的信息中收集到什么样的洞察时，人类更擅长处理图像。
- en: 'For instance, to continue with the web server logs example, a simple plot (such
    as the ones you can do with MS Excel) for the requests by hour can provide some
    insight into the behavior of your users:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，继续以Web服务器日志为例，一个简单的图表（比如你可以用MS Excel做的）展示每小时请求情况，可以为你提供一些关于用户行为的洞察：
- en: '![Visualize your data](img/B02088_01_12.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![可视化你的数据](img/B02088_01_12.jpg)'
- en: The preceding chart clearly shows that the majority of requests are done during
    late afternoon and continue into the night. You can use this insight later on
    for further profiling. For instance, an optional improvement of your setup here
    would be to provide more resources for your infrastructure during that time (something
    that can be done with service providers such as Amazon Web Services).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表清楚地显示，大多数请求都是在下午晚些时候进行的，并持续到夜间。你可以利用这个洞察来进一步进行配置分析。例如，这里的一个可选改进是在那个时间为你基础设施提供更多资源（这可以通过像亚马逊云服务这样的服务提供商来完成）。
- en: 'Another example, using custom profiling data, could be the following chart:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，使用自定义分析数据，可能是以下图表：
- en: '![Visualize your data](img/B02088_01_13.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![可视化你的数据](img/B02088_01_13.jpg)'
- en: It uses data from the first code example of this chapter by counting the number
    of each event that triggers the `profile` function. We can then plot it and get
    an idea of the most common events. In our case, the `call` and `return` events
    are definitely taking up most of our program's time.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用本章第一个代码示例中的数据，通过计算触发`profile`函数的每个事件的次数。然后我们可以绘制它，并了解最常见的活动。在我们的例子中，`call`和`return`事件肯定占用了我们程序的大部分时间。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered the basics of profiling. You understood profiling
    and its importance. You also learned how we can leverage it in order to get the
    most out of our code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了分析的基础知识。你理解了分析及其重要性。你还学习了如何利用它来最大限度地发挥我们代码的潜力。
- en: In the next chapter, we'll start getting our hands dirty by looking at some
    Python profilers and how we can use them on our applications.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过查看一些Python分析器和如何在我们的应用程序中使用它们来开始“动手实践”。
