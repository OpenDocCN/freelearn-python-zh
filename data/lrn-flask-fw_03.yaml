- en: Chapter 3. Templates and Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。模板和视图
- en: 'This chapter could alternatively be titled *The Flask Chapter*, because we
    will cover two of the most recognizable components of the framework: the Jinja2
    template language, and the URL routing framework. Up to this point, we have been
    laying the foundation for the blog app, but we have barely scratched the surface
    of actual Flask development. In this chapter, we will dive into Flask and see
    our app finally start taking shape. We will turn our drab database models into
    dynamically rendered HTML pages, using templates. We will come up with a URL scheme
    that reflects the ways we wish to organize our blog entries. As we progress through
    the chapter, our blog app will start looking like a proper website.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章也可以被称为*Flask章节*，因为我们将涵盖框架中最具代表性的两个组件：Jinja2模板语言和URL路由框架。到目前为止，我们一直在为博客应用奠定基础，但实际上我们几乎没有涉及到Flask的开发。在这一章中，我们将深入了解Flask，并看到我们的应用最终开始成形。我们将把单调的数据库模型转换为动态呈现的HTML页面，使用模板。我们将设计一个URL方案，反映我们希望组织博客条目的方式。随着我们在本章的进展，我们的博客应用将开始看起来像一个真正的网站。
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn how to render HTML templates using Jinja2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Jinja2呈现HTML模板
- en: Learn how to use loops, control structures, and the filters provided by the
    Jinja2 template language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Jinja2模板语言提供的循环、控制结构和过滤器
- en: Use template inheritance to eliminate repetitive coding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板继承来消除重复的编码
- en: Create a clean URL scheme for our blog app and set up the routing from URLs
    to views
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的博客应用创建一个清晰的URL方案，并设置从URL到视图的路由
- en: Render lists of blog entries using Jinja2 templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jinja2模板呈现博客条目列表
- en: Add full-text search to the site
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为网站添加全文搜索
- en: Introducing Jinja2
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Jinja2
- en: Jinja2 is a fast, flexible, and secure templating engine. It allows you to define
    your website in small blocks that are pieced together to form complete pages.
    On our blog, for instance, we will have blocks for the header, the sidebar, the
    footer, as well as templates, for rendering blog posts. This approach is **DRY**
    (**Don't Repeat Yourself**), which means that the markup contained in each block
    should not be copied or pasted elsewhere. Since the HTML for each part of the
    site exists in only one place, making changes and fixing bugs is much easier.
    Jinja2 also allows you to embed display logic in the template. For instance, we
    may wish to display a log out button to users who are logged in, but display a
    log in form to users browsing anonymously. As you will see, it is very easy to
    accomplish these types of things with a bit of template logic.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2是一个快速、灵活和安全的模板引擎。它允许您将网站定义为小块，这些小块被拼凑在一起形成完整的页面。例如，在我们的博客中，我们将为标题、侧边栏、页脚以及用于呈现博客文章的模板创建块。这种方法是DRY（不要重复自己），这意味着每个块中包含的标记不应该被复制或粘贴到其他地方。由于站点的每个部分的HTML只存在于一个地方，因此更改和修复错误变得更容易。Jinja2还允许您在模板中嵌入显示逻辑。例如，我们可能希望向已登录的用户显示注销按钮，但向匿名浏览的用户显示登录表单。正如您将看到的，使用一些模板逻辑来实现这些类型的事情非常容易。
- en: From the beginning, Flask was built with Jinja2 in mind, so working with templates
    in your Flask app is extremely easy. Since Jinja2 is a requirement of the Flask
    framework, it is already installed in our virtualenv, so we're able to get started
    immediately.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Flask就是以Jinja2为核心构建的，因此在Flask应用中使用模板非常容易。由于Jinja2是Flask框架的要求，它已经安装在我们的虚拟环境中，所以我们可以立即开始使用。
- en: 'Create a new folder named `templates` in the blog project''s `app` directory.
    Create a single file inside the template folder named `homepage.html` and add
    the following HTML code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在博客项目的`app`目录中创建一个名为`templates`的新文件夹。在模板文件夹中创建一个名为`homepage.html`的单个文件，并添加以下HTML代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now open `views.py` in the blog project''s `app` directory. We are going to
    modify our `homepage` view to render the new `homepage.html` template. To do this,
    we will use Flask''s `render_template()` function, passing in the name of our
    template as the first argument. Rendering a template is an extremely common action,
    so Flask makes this part as easy as possible:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在博客项目的`app`目录中打开`views.py`。我们将修改我们的`homepage`视图以呈现新的`homepage.html`模板。为此，我们将使用Flask的`render_template()`函数，将我们的模板名称作为第一个参数传递进去。呈现模板是一个非常常见的操作，所以Flask尽可能地简化了这部分内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the `manage.py` helper that we created in the previous chapter, start
    the development server and navigate to `http://127.0.0.1:5000/` to view the rendered
    template, as shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在上一章中创建的`manage.py`助手，启动开发服务器并导航到`http://127.0.0.1:5000/`以查看呈现的模板，如下面的屏幕截图所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Introducing Jinja2](img/1709_03_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![介绍Jinja2](img/1709_03_01.jpg)'
- en: Basic template operations
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的模板操作
- en: 'The previous example may not seem very impressive, since we are doing little
    more than serving a plain HTML document. To make things interesting, we need to
    give our templates **context**. Let''s modify our homepage to display a simple
    greeting to illustrate the point. Open `views.py` and make the following modifications:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可能看起来并不那么令人印象深刻，因为我们所做的不过是提供一个简单的HTML文档。为了使事情变得有趣，我们需要给我们的模板提供上下文。让我们修改我们的主页，显示一个简单的问候语来说明这一点。打开`views.py`并进行以下修改：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the view code, we are passing `name` into the template context. The next
    step is to do something with that `name` inside the actual template. In this example,
    we will simply print the value of `name`. Open `homepage.html` and make the following
    addition:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图代码中，我们将`name`传递到模板上下文中。下一步是在实际模板中对`name`做一些操作。在这个例子中，我们将简单地打印`name`的值。打开`homepage.html`并进行以下添加：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start the development server and navigate to the root URL. You should see something
    like the following image:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 启动开发服务器并导航到根URL。你应该看到类似下面图片的东西：
- en: '![Basic template operations](img/1709_03_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![基本的模板操作](img/1709_03_02.jpg)'
- en: Any keyword arguments passed to the `render_template` function are available
    in the template context. In the template language of Jinja2, double brackets are
    analogous to a `print` statement. We use the `{{ name }}` operation to output
    the value of `name`, which is set to `<unknown>`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`render_template`函数的任何关键字参数都可以在模板上下文中使用。在Jinja2的模板语言中，双大括号类似于`print`语句。我们使用`{{
    name }}`操作来输出`name`的值，该值设置为`<unknown>`。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The security-minded reader may have noticed that, when we viewed our template
    in the browser, the brackets were escaped. Ordinarily, brackets are treated by
    the browser as HTML markup, but, as you can see, Jinja2 has escaped the brackets
    automatically, replacing them with `&lt;` and `&gt;`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注重安全的读者可能已经注意到，当我们在浏览器中查看我们的模板时，括号被转义了。通常，括号被浏览器视为HTML标记，但是如您所见，Jinja2已经自动转义了括号，用`&lt;`和`&gt;`替换了它们。
- en: Try navigating to a URL such as `http://127.0.0.1:5000/?name=Charlie`. Whatever
    value you specify will appear, rendered for us automatically by Jinja2, as seen
    in the following image
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试导航到诸如`http://127.0.0.1:5000/?name=Charlie`之类的URL。无论您指定什么值，Jinja2都会自动为我们呈现，如下图所示
- en: '![Basic template operations](img/1709_03_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: 基本模板操作
- en: Suppose someone malicious visits your site and wants to cause some trouble.
    Noticing that values from the query-string are passed directly into the template,
    this person decides to have some fun by attempting to inject a script tag. Thankfully
    for us, Jinja2 automatically escapes values before inserting them into the rendered
    page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有人恶意访问您的网站并想要制造一些麻烦。注意到查询字符串中的值直接传递到模板中，这个人决定尝试注入一个脚本标记来玩一些恶作剧。幸运的是，Jinja2在将值插入渲染页面之前会自动转义这些值。
- en: '![Basic template operations](img/1709_03_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: 基本模板操作
- en: Loops, control structures, and template programming
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环、控制结构和模板编程
- en: Jinja2 supports a miniature programming language that can be used to perform
    operations on data within the context. If all we could do was print values to
    the context, there honestly wouldn't be too much to be excited about. Things get
    interesting when we combine contextual data with things such as loops and control
    structures.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2支持一种微型编程语言，可用于在上下文中对数据执行操作。如果我们只能将值打印到上下文中，那么实际上就没有太多令人兴奋的事情了。当我们将上下文数据与循环和控制结构等内容结合在一起时，事情就变得有趣起来了。
- en: 'Let''s modify our homepage view once more. This time we will accept a number,
    in addition to a name, from `request.args` and display all the even numbers between
    0 and that number. The neat part is that we will do almost all of this in the
    template. Make the following changes to `views.py`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次修改我们的主页视图。这次我们将从`request.args`中接受一个数字，以及一个名称，并显示0到该数字之间的所有偶数。好处是我们几乎可以在模板中完成所有这些工作。对`views.py`进行以下更改：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now open the `hompage.html` template and add the following code. If it seems
    odd, don't worry. We will go through it line by line.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`hompage.html`模板并添加以下代码。如果看起来奇怪，不用担心。我们将逐行讲解。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Start a runserver and experiment by passing some values in using the query-string.
    Also, take note of what happens when you pass a non-numeric value or a negative
    value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 启动runserver并通过查询字符串传递一些值进行实验。还要注意当传递非数字值或负值时会发生什么。
- en: '![Loops, control structures, and template programming](img/1709_03_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: 循环、控制结构和模板编程
- en: Let's go through our new template code line by line, starting with the `{% if
    number %}` statement. Unlike the print tags that use double curly brackets, logical
    tags use `{%` and `%}`. We are simply checking whether or not a number was passed
    into the context. If the number is `None` or an empty string, this test will fail,
    just as it would in Python.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行讲解我们的新模板代码，从`{% if number %}`语句开始。与使用双大括号的打印标记不同，逻辑标记使用`{%`和`%}`。我们只是检查上下文中是否传递了一个数字。如果数字是`None`或空字符串，则此测试将失败，就像在Python中一样。
- en: The next line prints the integer representation of our number and uses a new
    syntax, `|int`. The pipe symbol (`|`) is used in Jinja2 to indicate a call to
    a filter. A **filter** performs some type of operation on the value to the left
    side of the pipe symbol, and returns a new value. In this case, we are using the
    built-in `int` filter that converts a string to an integer, defaulting to `0`
    when a number cannot be determined. There are many filters built into Jinja2;
    we will discuss them later in the chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行打印了我们数字的整数表示，并使用了一个新的语法`|int`。竖线符号（`|`）在Jinja2中用于表示对过滤器的调用。**过滤器**对位于竖线符号左侧的值执行某种操作，并返回一个新值。在这种情况下，我们使用了内置的`int`过滤器，将字符串转换为整数，在无法确定数字时默认为`0`。Jinja2内置了许多过滤器；我们将在本章后面讨论它们。
- en: The `{% for %}` statement is used to create a *for* loop and looks remarkably
    close to Python. We are using the Jinja2 `range` helper to generate a series of
    numbers with `[0, number)`. Note that we are again piping the `number` context
    value through the `int` filter in the call to `range`. Also note that we are assigning
    a value to a new context variable `i`. Inside the loop body, we can use `i` just
    like any other context variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% for %}`语句用于创建一个*for*循环，看起来非常接近Python。我们使用Jinja2的`range`辅助函数生成一个数字序列`[0，number)`。请注意，我们再次通过`int`过滤器在调用`range`时将`number`上下文值传递给`range`。还要注意，我们将一个值赋给一个新的上下文变量`i`。在循环体内，我们可以像使用任何其他上下文变量一样使用`i`。'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Of course, just like in regular Python, we can also use an `{% else %}` statement
    on a for-loop that can be used to run some code in the eventuality that there
    is nothing for the loop to do.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，就像在普通的Python中一样，我们也可以在for循环上使用`{% else %}`语句，用于在没有要执行的循环时运行一些代码。
- en: 'Now that we are looping through the numbers, we need to check whether `i` is
    even, and if so, print it. Jinja2 provides several ways we could do this, but
    I have chosen to show the use of a Jinja2 feature called **tests**. Like filters
    and control structures, Jinja2 also comes with a number of useful tools for testing
    the attributes of a context value. Tests are used in conjunction with `{% if %}`
    statements and are denoted by the use of the keyword `is`. So we have `{% if i
    is divisibleby 2 %}`, which is very easy to read. If the `if` statement evaluates
    to `True` then we will print the value of `i` using double braces: `{{ i }}`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在循环遍历数字，我们需要检查`i`是否为偶数，如果是，则打印出来。Jinja2提供了几种方法可以做到这一点，但我选择展示了一种名为**tests**的Jinja2特性的使用。与过滤器和控制结构一样，Jinja2还提供了许多有用的工具来测试上下文值的属性。测试与`{%
    if %}`语句一起使用，并通过关键字`is`表示。因此，我们有`{% if i is divisibleby 2 %}`，这非常容易阅读。如果`if`语句评估为`True`，那么我们将使用双大括号打印`i`的值：`{{
    i }}`。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Jinja2 provides a number of useful tests; to learn more check the project documentation
    at [http://jinja.pocoo.org/docs/templates/#tests](http://jinja.pocoo.org/docs/templates/#tests).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2提供了许多有用的测试；要了解更多，请查阅项目文档[http://jinja.pocoo.org/docs/templates/#tests](http://jinja.pocoo.org/docs/templates/#tests)。
- en: Since Jinja2 is not aware of significant whitespace, we need to explicitly close
    all our logical tags. That is why you see an `{% endif %}` tag, signifying the
    closing of the `divisibleby 2` check, and an `{% endfor %},` signifying the closing
    of the `for i in range` loop. After the `for` loop, we are now in the outermost
    `if` statement, which tests whether a number was passed into the context. In the
    event no number is present, we want to print a message to the user so, before
    calling `{% endif %}`, we will use an `{% else %}` tag to display this message.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jinja2不知道重要的空格，我们需要明确关闭所有逻辑标记。这就是为什么您看到了一个`{% endif %}`标记，表示`divisibleby 2`检查的关闭，以及一个`{%
    endfor %}`标记，表示`for i in range`循环的关闭。在`for`循环之后，我们现在处于最外层的`if`语句中，该语句测试是否将数字传递到上下文中。如果没有数字存在，我们希望向用户显示一条消息，因此在调用`{%
    endif %}`之前，我们将使用`{% else %}`标记来显示此消息。
- en: Finally, we have changed the line that prints a greeting to the user to read
    `{{ name|default('<unknown>', True) }}` . In the view code, we removed the logic
    that set it to a default value of `<unknown>`. Instead, we have moved that logic
    into the template. Here we see the `default` filter (denoted by the `|` character)
    but, unlike `int`, we are passing multiple arguments. In Jinja2, a filter can
    take multiple arguments. By convention, the first argument appears to the left
    of the pipe symbol, since filters frequently operate on single values. In the
    event there are multiple arguments, these are specified in parentheses *after*
    the filter name. In the case of the `default` filter, we have specified the value
    to use in the event no name is specified.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已将打印向用户问候语的行更改为`{{ name|default('<unknown>', True) }}`。在视图代码中，我们删除了将其设置为默认值`<unknown>`的逻辑。相反，我们将该逻辑移到了模板中。在这里，我们看到了`default`过滤器（由`|`字符表示），但与`int`不同的是，我们传递了多个参数。在Jinja2中，过滤器可以接受多个参数。按照惯例，第一个参数出现在管道符号的左侧，因为过滤器经常操作单个值。如果有多个参数，则这些参数在过滤器名称之后的括号中指定。在`default`过滤器的情况下，我们已指定在未指定名称时使用的值。
- en: Jinja2 built-in filters
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jinja2内置过滤器
- en: In the previous example, we saw how to use the `int` filter to coerce a context
    value to an integer. Along with `int`, Jinja2 provides a large array of useful
    built-in filters. For reasons of space (the list is very long), I will only include
    the most frequently-used filters from my experience, but the entire list can be
    found online at [http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了如何使用`int`过滤器将上下文值强制转换为整数。除了`int`之外，Jinja2还提供了大量有用的内置过滤器。出于空间原因（列表非常长），我只包含了我经验中最常用的过滤器，但整个列表可以在网上找到[http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters)。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the following examples, the first argument in the argument list would appear
    to the left-hand side of the pipe symbol. So, even though I have written `abs(number)`,
    the filter used would be `number|abs`. When the filter accepts more than one parameter,
    the remaining parameters appear in parentheses after the filter name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，参数列表中的第一个参数将出现在管道符号的左侧。因此，即使我写了`abs(number)`，使用的过滤器将是`number|abs`。当过滤器接受多个参数时，剩余的参数将在过滤器名称后的括号中显示。
- en: '| Filter and parameter(s) | Description and return value |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 过滤器和参数 | 描述和返回值 |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| abs(number) | Returns the absolute value of the number. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| abs(number) | 返回数字的绝对值。|'
- en: '| default(value, default_value='''', boolean=False) | In the event `value`
    is undefined (i.e., the name does not exist in the context) use the provided `default_value`
    instead. In the event you simply want to test whether `value` evaluates to a boolean
    `True` (i.e., not an empty string, the number zero, None, and so on.), then pass
    `True` as the third argument:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| default(value, default_value='''', boolean=False) | 如果`value`未定义（即上下文中不存在该名称），则使用提供的`default_value`。如果您只想测试`value`是否评估为布尔值`True`（即不是空字符串，数字零，None等），则将第三个参数传递为`True`：'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| dictsort(value, case_sensitive=False, by=''key'') | Sorts a dictionary by
    key, yielding `(key, value)` pairs. You can also, however, sort by value.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '| dictsort(value, case_sensitive=False, by=''key'') | 按键对字典进行排序，产生`(key, value)`对。但您也可以按值排序。'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| int(value, default=0) | Converts `value` to an integer. In the event the
    value cannot be converted, use the specified default. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| int(value, default=0) | 将`value`转换为整数。如果无法转换该值，则使用指定的默认值。|'
- en: '| length(object) | Returns the number of items in the collection. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| length(object) | 返回集合中的项目数。|'
- en: '| reverse(sequence) | Reverses the sequence. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| reverse(sequence) | 反转序列。|'
- en: '| safe(value) | Outputs the value unescaped. This filter is useful when you
    have trusted HTML that you wish to print. For instance, if `value = "<b>"`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '| safe(value) | 输出未转义的值。当您有信任的HTML希望打印时，此过滤器非常有用。例如，如果 `value = "<b>"`：'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| sort(value, reverse=False, case_sensitive=False, attribute=None) | Sorts
    an iterable value. If `reverse` is specified, the items will be sorted in reverse
    order. If the `attribute` parameter is used, that attribute will be treated as
    the value to sort by. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| sort(value, reverse=False, case_sensitive=False, attribute=None) | 对可迭代的值进行排序。如果指定了
    `reverse`，则项目将以相反顺序排序。如果使用了 `attribute` 参数，该属性将被视为排序的值。|'
- en: '| striptags(value) | Removes any HTML tags, useful for cleaning up and outputting
    untrusted user input. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| striptags(value) | 删除任何HTML标签，用于清理和输出不受信任的用户输入。|'
- en: '| truncate(value, length=255, killwords=False, end=''...'') | Returns a truncated
    copy of the string. The length parameter specifies how many characters to keep.
    If `killwords` is `False`, then a word may be chopped in half; if `True` then
    Jinja2 will truncate at the previous word boundary. In the event the value exceeds
    the length and needs to be truncated, the value in `end` will be appended automatically.
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| truncate(value, length=255, killwords=False, end=''...'') | 返回字符串的截断副本。长度参数指定要保留多少个字符。如果`killwords`为`False`，则一个单词可能会被切成一半；如果为`True`，则Jinja2将在前一个单词边界截断。如果值超过长度并且需要被截断，将自动附加`end`中的值。|'
- en: '| urlize(value, trim_url_limit=None, nofollow=False, target=None) | Converts
    URLs in plain text into clickable links. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| urlize(value, trim_url_limit=None, nofollow=False, target=None) | 将纯文本中的URL转换为可点击的链接。|'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Filters can be chained together, so `{{ number|int|abs }}` would first convert
    the number variable to an integer, then return its absolute value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器可以链接在一起，所以`{{ number|int|abs }}`首先将数字变量转换为整数，然后返回其绝对值。
- en: Creating a base template for the blog
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为博客创建一个基础模板
- en: Jinja2's inheritance and include features make it is very easy to define a base
    template that serves as the architectural foundation for each page on your site.
    The base template contains basic structural things that should never change, such
    as the `<html>`, `<head>,` and `<body>` tags, as well as the basic structure of
    the body. It can also be used to include style sheets or scripts that will be
    served on every page. Most importantly, the base template is responsible for defining
    overrideable blocks, into which we will place page-specific content such as the
    page title and body content.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2的继承和包含功能使得定义一个基础模板成为站点上每个页面的架构基础非常容易。基础模板包含一些基本结构，如`<html>`、`<head>`和`<body>`标签，以及body的基本结构。它还可以用于包含样式表或脚本，这些样式表或脚本将在每个页面上提供。最重要的是，基础模板负责定义可覆盖的块，我们将在其中放置特定于页面的内容，如页面标题和正文内容。
- en: In order to get up-and-running quickly, we will be using Twitter's Bootstrap
    library (version 3). This will allow us to focus on how templates are structured
    and have a decent-looking site with minimal extra work. You are, of course, welcome
    to use your own CSS if you prefer, but the example code will use bootstrap-specific
    constructs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速启动，我们将使用Twitter的Bootstrap库（版本3）。这将使我们能够专注于模板的结构，并且只需进行最少的额外工作就能拥有一个看起来不错的网站。当然，如果您愿意，也可以使用自己的CSS，但示例代码将使用特定于bootstrap的结构。
- en: 'Create a new file in the `templates` directory named `base.html`, and add the
    following content:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`templates`目录中创建一个名为`base.html`的新文件，并添加以下内容：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Interspersed alongside the markup is a new Jinja2 tag, `block`. The `block`
    tags are used to indicate overrideable areas of the page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记中夹杂着一个新的Jinja2标签`block`。`block`标签用于指示页面的可覆盖区域。
- en: 'You may have noticed that we are serving jQuery and Bootstrap from publicly-available
    URLs. In the next chapter, we will discuss how to serve static files that are
    stored locally on disk. Now we can modify our homepage template and take advantage
    of the new base template. We can do this by extending the base template and overriding
    certain blocks. This works very similar to class inheritance that you find in
    most languages. As long as the sections of the inherited page are split up into
    blocks nicely, we can override only the bits we need to change. Let''s open `homepage.html`
    and replace some of the current contents with the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们正在从公开可用的URL中提供jQuery和Bootstrap。在下一章中，我们将讨论如何提供存储在本地磁盘上的静态文件。现在我们可以修改我们的主页模板，并利用新的基础模板。我们可以通过扩展基础模板并覆盖某些块来实现这一点。这与大多数语言中的类继承非常相似。只要继承页面的部分被很好地分成块，我们就可以只覆盖需要更改的部分。让我们打开`homepage.html`，并用以下内容替换当前内容的一部分：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By extending the original page, we have removed all the HTML boilerplate and
    a lot of complexity, focusing only on what makes this page, our homepage view,
    unique. Start up the server and navigate to `http://127.0.0.1:5000/`, you will
    see that our homepage has been transformed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展原始页面，我们已经删除了所有HTML样板和大量复杂性，只关注于使这个页面，我们的主页视图，独特的部分。启动服务器并导航到`http://127.0.0.1:5000/`，您会看到我们的主页已经改变了。
- en: '![Creating a base template for the blog](img/1709_03_06.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![为博客创建基础模板](img/1709_03_06.jpg)'
- en: Congratulations! You have now learned some of the most commonly-used features
    of Jinja2\. There are many more advanced features that we have not covered in
    the interests of time, and I would recommend reading the project's documentation
    to see the full range of possibilities with Jinja2\. The documentation can be
    found at [http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在已经学会了Jinja2最常用的一些功能。还有许多更高级的功能我们没有在时间允许的情况下涵盖，我建议阅读项目的文档，以了解Jinja2的全部可能性。文档可以在[http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/)找到。
- en: We still need to build templates to display our blog entries. Before continuing
    to build out templates, though, we first must create some view functions that
    will generate the lists of blog entries. We will then pass the entries into the
    context, just as we did with the homepage.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要构建模板来显示我们的博客条目。但在继续构建模板之前，我们首先必须创建一些视图函数，这些函数将生成博客条目的列表。然后我们将条目传递到上下文中，就像我们在主页中所做的那样。
- en: Creating a URL scheme
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建URL方案
- en: URLs are for people, therefore they should be easy to remember. A good URL scheme
    is easy to remember when it accurately reflects the implicit structure of the
    website. Our goal is to create a URL scheme that makes it easy for the visitors
    on our site to find blog entries on topics that interest them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: URL是给人看的，因此它们应该易于记忆。当URL方案准确反映网站的隐含结构时，良好的URL方案易于记忆。我们的目标是创建一个URL方案，使我们网站上的访问者能够轻松找到他们感兴趣的主题的博客条目。
- en: 'Referring back to the spec we created in [Chapter 1](ch01.html "Chapter 1. Creating
    Your First Flask Application"), *Creating Your First Flask Application*, we know
    that we want our blog entries to be organized by tag and by date. Entries organized
    by tag and date will necessarily be a subset of the collection of all entries,
    so that gives us a structure like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们在[第1章](ch01.html "第1章。创建您的第一个Flask应用程序")中创建的规范，*创建您的第一个Flask应用程序*，我们知道我们希望我们的博客条目按标签和日期进行组织。按标签和日期组织的条目必然是所有条目的子集，因此给我们提供了这样的结构：
- en: '| URL | Purpose |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| URL | 目的 |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/entries/` | This displays all of our blog entries, ordered most-recent
    first |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `/entries/` | 这显示了我们所有的博客条目，按最近的顺序排列 |'
- en: '| `/entries/tags/` | This contains all the tags used to organize our blog entries
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `/entries/tags/` | 这包含用于组织我们的博客条目的所有标签 |'
- en: '| `/entries/tags/python/` | This contains all the entries tagged with `python`
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `/entries/tags/python/` | 这包含所有标记为`python`的条目 |'
- en: '| `/entries/learning-the-flask-framework/` | This is a detail page showing
    the body content for a blog entry titled *Learning the Flask Framework* |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `/entries/learning-the-flask-framework/` | 这是显示博客条目标题为*学习Flask框架*的正文内容的详细页面
    |'
- en: 'Since a single blog entry may be associated with multiple tags, how do we decide
    what to use as its canonical URL? If I wrote a blog entry titled *Learning the
    Flask framework*, I could conceivably nest it under `/entries/, /entries/tags/python/`,
    `/entries/tags/flask/`, and so on. That would violate one of the rules about good
    URLs, which is that a unique resource should have one, and only one, URL. For
    that reason, I am going to advocate putting individual blog entries at the top
    of the hierarchy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单个博客条目可能与多个标签相关联，我们如何决定将其用作规范URL？如果我写了一篇名为*学习Flask框架*的博客条目，我可以将其嵌套在`/entries/`，`/entries/tags/python/`，`/entries/tags/flask/`等下。这将违反有关良好URL的规则之一，即唯一资源应该有一个且仅有一个URL。因此，我将主张将单个博客条目放在层次结构的顶部：
- en: '`/entries/learning-the-flask-framework/`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`/entries/learning-the-flask-framework/`'
- en: 'News sites and blogs with a large amount of time-sensitive content will typically
    nest individual pieces of content using the publication date. This prevents collisions
    when two articles might share the same title, but have been written at different
    times. When a lot of content is produced each day, this scheme often makes more
    sense:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，具有大量时间敏感内容的新闻网站和博客将使用发布日期嵌套单个内容片段。这可以防止当两篇文章可能具有相同的标题但是在不同时间编写时发生冲突。当每天产生大量内容时，这种方案通常更有意义：
- en: '`/entries/2014/jan/18/learning-the-flask-framework/`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`/entries/2014/jan/18/learning-the-flask-framework/`'
- en: Although we will not be covering this type of URL scheme in this chapter, the
    code can be found online at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本章中不会涵盖这种类型的URL方案，但代码可以在[http://www.packtpub.com/support](http://www.packtpub.com/support)上找到。
- en: Defining the URL routes
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义URL路由
- en: 'Let''s convert the structure described previously into some URL routes that
    Flask will understand. Create a new directory named `entries` in the blog project''s
    `app` directory. Inside the `entries` directory, create two files, `__init__.py`
    and `blueprint.py as follows`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将之前描述的结构转换为Flask将理解的一些URL路由。在博客项目的`app`目录中创建一个名为`entries`的新目录。在`entries`目录内，创建两个文件，`__init__.py`和`blueprint.py`如下：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Blueprints** provide a nice API for encapsulating a group of related routes
    and templates. In smaller applications, typically everything gets registered on
    the app object (that is, `app.route`). When an application has distinct components,
    as ours does, blueprints can be used to separate the various moving parts. Since
    the `/entries/` URL is going to be devoted entirely to our blog entries, we will
    create a blueprint and then define views to handle the routes that we described
    previously. Open `blueprint.py` and add the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blueprints**提供了一个很好的API，用于封装一组相关的路由和模板。在较小的应用程序中，通常所有内容都会在应用程序对象上注册（即`app.route`）。当应用程序具有不同的组件时，如我们的应用程序，可以使用blueprints来分离各种移动部分。由于`/entries/`
    URL将完全用于我们的博客条目，我们将创建一个blueprint，然后定义视图来处理我们之前描述的路由。打开`blueprint.py`并添加以下代码：'
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These URL routes are placeholders that we will fill in shortly, but I wanted
    to show you how clean and simple it is to translate a set of URL patterns into
    a set of routes and views.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些URL路由是我们将很快填充的占位符，但我想向您展示如何将一组URL模式清晰简单地转换为一组路由和视图。
- en: 'In order to access these new views, we need to register our blueprint with
    our main Flask `app` object. We will also instruct our app that we want our entries''
    URLs to live at the prefix `/entries`. Open `main.py` and make the following additions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问这些新视图，我们需要使用我们的主要Flask `app`对象注册我们的blueprint。我们还将指示我们的应用程序，我们希望我们的条目的URL位于前缀`/entries`。打开`main.py`并进行以下添加：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you want to test it out, start the debug server (`python manage.py runserver`)
    and navigate to `http://127.0.0.1:5000/entries/`. You should see the following
    message:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试一下，请启动调试服务器（`python manage.py runserver`）并导航到`http://127.0.0.1:5000/entries/`。您应该会看到以下消息：
- en: '![Defining the URL routes](img/1709_03_07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![定义URL路由](img/1709_03_07.jpg)'
- en: Building the index view
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建索引视图
- en: 'The `index` view is the top-most URL in our `/entries/` hierarchy, and as such
    will contain all the entries. After a time we might have tens or even hundreds
    of blog entries, so we will want to paginate this list so as not to overwhelm
    our visitors (or our server!). Because we will frequently be displaying lists
    of objects, let''s create a helpers module that will make it easy to display paginated
    lists of objects. In the `app` directory, create a new module named `helpers.py`
    and add the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`index`视图是我们`/entries/`层次结构中最顶层的URL，因此将包含所有的条目。随着时间的推移，我们可能会有数十甚至数百个博客条目，因此我们希望对这个列表进行分页，以免压倒我们的访问者（或我们的服务器！）。因为我们经常需要显示对象列表，让我们创建一个助手模块，以便轻松地显示对象的分页列表。在`app`目录中，创建一个名为`helpers.py`的新模块，并添加以下代码：'
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we will open `entries/blueprint.py` and modify the `index` view to return
    a paginated list of entries:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将打开`entries/blueprint.py`并修改`index`视图以返回分页列表条目：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are importing the `object_list` helper function and passing it the name of
    a template and the query representing the entries we wish to display. As we build
    out the rest of these views, you will see how little helper functions such as
    `object_list` make Flask development quite easy.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入`object_list`辅助函数，并将其传递给模板的名称和表示我们希望显示的条目的查询。随着我们构建这些视图的其余部分，您将看到诸如`object_list`这样的小辅助函数如何使Flask开发变得非常容易。
- en: 'The final piece is the `entries/index.html` template. In the `entries` directory,
    create a directory named `templates`, and a sub-directory named `entries`. Create
    `index.html` such that the full path from the `app` directory is `entries/templates/entries/index.html`
    and add the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是`entries/index.html`模板。在`entries`目录中，创建一个名为`templates`的目录，和一个名为`entries`的子目录。创建`index.html`，使得从`app`目录到`entries/templates/entries/index.html`的完整路径，并添加以下代码：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This template is very minimal, all the work will happen in `includes/list.html`.
    The `{% include %}` tag is new, and is useful for reusable template fragments.
    Create the file `includes/list.html` and add the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板非常简单，所有的工作都将在`includes/list.html`中进行。`{% include %}`标签是新的，对于可重用的模板片段非常有用。创建文件`includes/list.html`并添加以下代码：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `url_for` function is extremely useful. `url_for()` allows us to provide
    the name of a view function or any arguments, and then generates the URL. Since
    the URL we wish to reference is the `detail` view of the entries blueprint, the
    name of the view is `entries.detail`. The detail view accepts a single argument,
    the slug of the entry's title.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`url_for`函数非常有用。`url_for()`允许我们提供视图函数的名称或任何参数，然后生成URL。由于我们希望引用的URL是entries
    blueprint的`detail`视图，视图的名称是`entries.detail`。详细视图接受一个参数，即条目标题的slug。'
- en: 'Before building out the detail view, re-open the base template and add a link
    to the entries in the navigation section:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建详细视图之前，重新打开基本模板，并在导航部分添加一个链接到条目：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following screenshot shows the updated navigation header, along with a
    list of blog entries:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了更新后的导航标题，以及博客条目的列表：
- en: '![Building the index view](img/1709_03_08.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![构建索引视图](img/1709_03_08.jpg)'
- en: Building the detail view
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建详细视图
- en: 'Let''s create a simple view that will render the contents of a single blog
    entry. The slug of the entry will be passed in as a part of the URL. We will attempt
    to match that to an existing `Entry`, returning a 404 response if none matches.
    Update the following code to the `detail` view in the entries blueprint:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的视图，用于呈现单个博客条目的内容。条目的slug将作为URL的一部分传递进来。我们将尝试将其与现有的`Entry`匹配，如果没有匹配项，则返回404响应。更新entries
    blueprint中的`detail`视图的以下代码：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a template in the `entries` template directory named `detail.html` and
    add the following code. We will display the title and body of the entry in the
    main content area, but in the sidebar we will display a list of tags and the date
    the entry was created:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`entries`模板目录中创建一个名为`detail.html`的模板，并添加以下代码。我们将在主内容区域显示条目的标题和正文，但在侧边栏中，我们将显示一个标签列表和条目创建日期：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It should now be possible to view entries on the index page and follow the link
    to the details view. As you probably guessed, the next thing we need to tackle
    is the tag detail page.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该可以在索引页面上查看条目，并转到详细视图的链接。正如你可能猜到的，我们需要解决的下一个问题是标签详细页面。
- en: '![Building the detail view](img/1709_03_09.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![构建详细视图](img/1709_03_09.jpg)'
- en: Listing entries matching a given tag
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出与给定标签匹配的条目
- en: 'Listing the entries that match a given tag will combine the logic from the
    two previous views. First we will need to look up the `Tag` using the `tag` slug
    provided in the URL, and then we will display an `object_list` of `Entry` objects
    that are tagged with the specified tag. In the `tag_detail` view, add the following
    code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列出与给定标签匹配的条目将结合两个先前视图的逻辑。首先，我们需要使用URL中提供的`tag` slug查找`Tag`，然后我们将显示一个`object_list`，其中包含使用指定标签标记的`Entry`对象。在`tag_detail`视图中，添加以下代码：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `entries` query will get all the entries associated with the tag, then
    return them ordered most-recent first. We are also passing the tag into the context
    so we can display it in the template. Create the `tag_detail.html` template and
    add the following code. Since we are going to display a list of entries, we will
    re-use our `list.html` include:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries`查询将获取与标签相关的所有条目，然后按最近的顺序返回它们。我们还将标签传递到上下文中，以便在模板中显示它。创建`tag_detail.html`模板并添加以下代码。由于我们将显示一个条目列表，我们将重用我们的`list.html`包含：'
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following screenshot, I have navigated to `/entries/tags/python/`. This
    page only contains entries that have been tagged with *Python*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我已经导航到`/entries/tags/python/`。这个页面只包含已经被标记为*Python*的条目：
- en: '![Listing entries matching a given tag](img/1709_03_10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![列出与给定标签匹配的条目](img/1709_03_10.jpg)'
- en: Listing all the tags
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出所有标签
- en: 'The final missing piece is the view that will display a list of all the tags.
    This view will be very similar to the `index` entry, except that, instead of `Entry`
    objects, we will be querying the `Tag` model. Update the following code to the
    `tag_index` view:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺失的部分是显示所有标签列表的视图。这个视图将与`index`条目非常相似，只是我们将查询`Tag`模型而不是`Entry`对象。更新以下代码到`tag_index`视图：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the template, we will display each tag as a link to the corresponding tag
    detail page. Create the file `entries/tag_index.html` and add the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们将每个标签显示为指向相应标签详情页面的链接。创建文件`entries/tag_index.html`并添加以下代码：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you like, you can add a link to the tag list in the base template's navigation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以在基础模板的导航中添加一个到标签列表的链接。
- en: Full-text search
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全文搜索
- en: 'In order to allow users to find posts containing certain words or phrases,
    we will add simple full-text search to the pages that contain lists of blog entries.
    To accomplish this, we will do some refactoring. We will be adding a search form
    to the sidebar of all pages containing lists of blog entries. While we could copy
    and paste the same code into both `entries/index.html` and `entries/tag_detail.html`,
    we will, instead, create another base template that contains the search widget.
    Create a new template named `entries/base_entries.html` and add the following
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够找到包含特定单词或短语的帖子，我们将在包含博客条目列表的页面上添加简单的全文搜索。为了实现这一点，我们将进行一些重构。我们将在所有包含博客条目列表的页面的侧边栏中添加一个搜索表单。虽然我们可以将相同的代码复制粘贴到`entries/index.html`和`entries/tag_detail.html`中，但我们将创建另一个包含搜索小部件的基础模板。创建一个名为`entries/base_entries.html`的新模板，并添加以下代码：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even though we will not explicitly pass `request` into the context, Flask will
    make it accessible. You can find the list of standard context variables in the
    Flask documentation at [http://flask.pocoo.org/docs/templating/#standard-context](http://flask.pocoo.org/docs/templating/#standard-context).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会明确地将`request`传递到上下文中，Flask会使其可访问。你可以在Flask文档的[http://flask.pocoo.org/docs/templating/#standard-context](http://flask.pocoo.org/docs/templating/#standard-context)中找到标准上下文变量的列表。
- en: 'Now we will update the `entries/index.html` and `entries/tag_detail.html` to
    utilize this new base template. Since the `content` block contains the list of
    entries, we can remove that from both templates:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新`entries/index.html`和`entries/tag_detail.html`以利用这个新的基础模板。由于`content`块包含条目列表，我们可以从这两个模板中删除它：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is how `entries/index.html` looks after changing the base template and
    removing the context block. Do the same to `entries/tag_detail.html`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在更改基础模板并删除上下文块后的`entries/index.html`的样子。对`entries/tag_detail.html`做同样的操作。
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we need to update our view code to actually perform the search. To do this,
    we will create a new helper function in the blueprint named `entry_list`. This
    helper will be much like the `object_list` helper, but will perform extra logic
    to filter results based on our search inquiry. Add the `entry_list` function to
    the `blueprint.py`. Note how it checks the request query-string for a parameter
    named `q`. If `q` is present, we will return only the entries that contain the
    search phrase in either the title or the body:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更新我们的视图代码来实际执行搜索。为此，我们将在蓝图中创建一个名为`entry_list`的新辅助函数。这个辅助函数将类似于`object_list`辅助函数，但会执行额外的逻辑来根据我们的搜索查询过滤结果。将`entry_list`函数添加到`blueprint.py`中。注意它如何检查请求查询字符串是否包含名为`q`的参数。如果`q`存在，我们将只返回标题或正文中包含搜索短语的条目：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to utilize this functionality, modify the `index` and `tag_detail`
    views to call `entry_list` instead of `object_list`. The updated `index` view
    looks as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这个功能，修改`index`和`tag_detail`视图，调用`entry_list`而不是`object_list`。更新后的`index`视图如下：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Congratulations! You can now navigate to the entries list and perform searches
    using the search form.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你可以导航到条目列表并使用搜索表单进行搜索。
- en: '![Full-text search](img/1709_03_11.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![全文搜索](img/1709_03_11.jpg)'
- en: Adding pagination links
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分页链接
- en: As we discussed earlier, we would like to paginate long lists of entries so
    that users are not overwhelmed with extremely long lists. We have actually done
    all the work in the `object_list` function; the only remaining task is to add
    links allowing users to travel from one page of entries to the next.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们希望对条目的长列表进行分页，以便用户不会被极长的列表所压倒。我们实际上已经在`object_list`函数中完成了所有工作；唯一剩下的任务是添加链接，让用户可以从一个条目页面跳转到下一个页面。
- en: 'Because pagination links are a feature we will use in several places, we will
    create the pagination `include` in our app''s template directory (as opposed to
    the entries template directory). Create a new directory in `app/templates/` named
    `includes` and create a file named `page_links.html`. Since `object_list` returns
    us a `PaginatedQuery` object, we can utilize this object to determine, in the
    template, what page we are on and how many pages there are in total. In order
    to make the pagination links look nice, we will be using CSS classes provided
    by Bootstrap. Add the following content to `page_links.html`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因为分页链接是我们将在多个地方使用的一个功能，我们将在应用程序的模板目录中创建分页`include`（而不是条目模板目录）。在`app/templates/`中创建一个名为`includes`的新目录，并创建一个名为`page_links.html`的文件。由于`object_list`返回一个`PaginatedQuery`对象，我们可以在模板中利用这个对象来确定我们所在的页面以及总共有多少页。为了使分页链接看起来漂亮，我们将使用Bootstrap提供的CSS类。将以下内容添加到`page_links.html`中：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, wherever we are displaying an object list, let''s include the `page_links.html`
    template at the bottom of the page. Currently, the only templates we will need
    to update are `entries/base_entries.html` and `entries/tag_index.html`. The `content`
    block of `base_entries.html` looks as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论我们在哪里显示一个对象列表，让我们在页面底部包含`page_links.html`模板。目前，我们需要更新的模板只有`entries/base_entries.html`和`entries/tag_index.html`。`base_entries.html`的`content`块如下：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Adding pagination links](img/1709_03_12.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![添加分页链接](img/1709_03_12.jpg)'
- en: Enhancing the blog app
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强博客应用
- en: 'Before continuing on to the next chapter, I recommend spending some time experimenting
    with the views and templates we created in this chapter. Here are a few ideas
    you might consider:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一章之前，我建议花一些时间来实验我们在本章中创建的视图和模板。以下是一些您可以考虑的想法：
- en: 'Sort the list of tags on the entry detail view (hint: use the `sort` filter
    on the tag''s `name` attribute).'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在条目详细视图上对标签列表进行排序（提示：使用标签的`name`属性上的`sort`过滤器）。
- en: Remove the example code from the homepage template and add your own content.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主页模板中删除示例代码，并添加您自己的内容。
- en: You may have noticed that we are displaying all entries regardless of their
    status. Modify the `entry_list` function and the entry `detail` view to only display
    `Entry` objects whose status is `STATUS_PUBLIC`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们正在显示所有条目，而不考虑它们的状态。修改`entry_list`函数和条目`detail`视图，只显示状态为`STATUS_PUBLIC`的`Entry`对象。
- en: Experiment with different Bootstrap themes- [http://bootswatch.com](http://bootswatch.com)
    has many available for free.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试不同的Bootstrap主题- [http://bootswatch.com](http://bootswatch.com)有许多免费的主题可供选择。
- en: 'Advanced: allow multiple tags to be specified. For example, `/entries/tags/flask+python/`
    would only display entries that are tagged with both *flask* and *python*.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级：允许指定多个标签。例如，`/entries/tags/flask+python/`只会显示标记有*flask*和*python*的条目。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered a lot of information in this chapter, and by now you should be familiar
    with the process of creating views and templates. We learned how to render Jinja2
    templates and how to pass data from the view into the template context. We also
    learned how to modify context data within the template, using Jinja2 tags and
    filters. In the second half of the chapter, we designed a URL structure for our
    site and translated it into Flask views. We added a simple full-text search feature
    to the site, and wrapped up by adding pagination links to our lists of entries
    and tags.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量信息，到目前为止，您应该熟悉创建视图和模板的过程。我们学会了如何呈现Jinja2模板以及如何将数据从视图传递到模板上下文中。我们还学会了如何在模板中修改上下文数据，使用Jinja2标签和过滤器。在本章的后半部分，我们为网站设计了URL结构，并将其转换为Flask视图。我们为网站添加了一个简单的全文搜索功能，并通过为条目和标签列表添加分页链接来结束。
- en: In the next chapter, we will learn how to create and edit blog entries through
    the website using **Forms**. We will learn how to process and validate user input,
    then save the changes to the database. We will also add a photo-uploading feature
    so we can embed images in our blog entries.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过网站使用**表单**创建和编辑博客条目。我们将学习如何处理和验证用户输入，然后将更改保存到数据库中。我们还将添加一个上传照片的功能，以便在博客条目中嵌入图像。
