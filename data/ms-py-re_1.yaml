- en: Chapter 1. Introducing Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。介绍正则表达式
- en: 'Regular expressions are text patterns that define the form a text string should
    have. Using them, among other usages, it will be possible to do the following
    activities:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是定义文本字符串应具有的形式的文本模式。使用它们，除其他用途外，将能够执行以下活动：
- en: Check if an input honors a given pattern; for example, we can check whether
    a value entered in a HTML formulary is a valid e-mail address
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查输入是否符合给定的模式；例如，我们可以检查HTML表单中输入的值是否是有效的电子邮件地址
- en: Look for a pattern appearance in a piece of text; for example, check if either
    the word "color" or the word "colour" appears in a document with just one scan
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一段文本中查找模式的出现；例如，检查文档中是否只有一个扫描中出现了单词“color”或单词“colour”
- en: Extract specific portions of a text; for example, extract the postal code of
    an address
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取文本的特定部分；例如，提取地址的邮政编码
- en: Replace portions of text; for example, change any appearance of "color" or "colour"
    with "red"
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换文本的部分；例如，将“color”或“colour”的任何出现更改为“red”
- en: Split a larger text into smaller pieces, for example, splitting a text by any
    appearance of the dot, comma, or newline characters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将较大的文本分割成较小的部分，例如，通过任何出现的句点、逗号或换行字符来分割文本
- en: In this chapter, we are going to learn the basics of regular expressions from
    a language-agnostic point of view. At the end of the chapter, we will understand
    how regular expressions work, but we won't yet be able to execute a regular expression
    in Python. This is going to be covered in the next chapter. Because of this reason,
    the examples in this chapter will be approached from a theoretical point of view
    rather than being executed in Python.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从与语言无关的角度学习正则表达式的基础知识。在本章结束时，我们将了解正则表达式的工作原理，但我们还不能在Python中执行正则表达式。这将在下一章中介绍。因此，本章中的示例将从理论角度而不是在Python中执行的角度进行讨论。
- en: History, relevance, and purpose
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史、相关性和目的
- en: Regular expressions are pervasive. They can be found in the newest offimatic
    suite or JavaScript framework to those UNIX tools dating back to the 70s. No modern
    programming language can be called complete until it supports regular expressions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是无处不在的。它们可以在最新的办公套件或JavaScript框架中找到，也可以在追溯到70年代的UNIX工具中找到。没有现代编程语言能够被称为完整，直到它支持正则表达式。
- en: Although they are prevalent in languages and frameworks, regular expressions
    are not yet pervasive in the modern coder's toolkit. One of the reasons often
    used to explain this is the tough learning curve that they have. Regular expressions
    can be difficult to master and very complex to read if they are not written with
    care.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在语言和框架中很普遍，但正则表达式在现代程序员的工具包中还不是无处不在的。经常用来解释这一点的原因之一是它们的学习曲线陡峭。如果不小心编写，正则表达式可能很难掌握，而且阅读起来非常复杂。
- en: 'As a result of this complexity, it is not difficult to find in Internet forums
    the old chestnut:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种复杂性，不难在互联网论坛上找到这个老生常谈的话题：
- en: '|   | *"Some people, when confronted with a problem, think "I know, I''ll use
    regular expressions." Now they have two problems."* |   |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|   | *"有些人面对问题时，想到的是“我知道，我会使用正则表达式。”现在他们有了两个问题。"* |   |'
- en: '|   | --*Jamie Zawinski, 1997* |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|   | --*杰米·扎温斯基，1997* |'
- en: You'll find it at [https://groups.google.com/forum/?hl=en#!msg/alt.religion.emacs/DR057Srw5-c/Co-2L2BKn7UJ](https://groups.google.com/forum/?hl=en#!msg/alt.religion.emacs/DR057Srw5-c/Co-2L2BKn7UJ).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://groups.google.com/forum/?hl=en#!msg/alt.religion.emacs/DR057Srw5-c/Co-2L2BKn7UJ](https://groups.google.com/forum/?hl=en#!msg/alt.religion.emacs/DR057Srw5-c/Co-2L2BKn7UJ)找到它。
- en: Going through this book, we'll learn how to leverage the best practices when
    writing regular expressions to greatly simplify the reading process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本书，我们将学习如何在编写正则表达式时利用最佳实践，从而大大简化阅读过程。
- en: Even though regular expressions can be found in the latest and greatest programming
    languages nowadays and will, probably, for many years on, their history goes back
    to 1943 when the neurophysiologists Warren McCulloch and Walter Pitts published
    *A logical calculus of the ideas immanent in nervous activity*. This paper not
    only represented the beginning of the regular expressions, but also proposed the
    first mathematical model of a neural network.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管正则表达式现在可以在最新和最伟大的编程语言中找到，并且可能会在很多年内都存在，但它们的历史可以追溯到1943年，当时神经生理学家沃伦·麦卡洛克和沃尔特·皮茨发表了《神经活动中所固有的思想的逻辑演算》。这篇论文不仅代表了正则表达式的开始，还提出了神经网络的第一个数学模型。
- en: The next step was taken in 1956, this time by a mathematician. Stephen Kleene
    wrote the paper *Representation of events in nerve nets and finite automata*,
    where he coined the terms **regular sets** and **regular expressions**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在1956年采取的，这次是由一位数学家。斯蒂芬·克利恩写了一篇名为《神经元和有限自动机中事件的表示》的论文，在其中他创造了术语**regular
    sets**和**regular expressions**。
- en: Twelve years later, in 1968, a legendary pioneer of computer science took Kleene's
    work and extended it, publishing his studies in the paper *Regular Expression
    Search Algorithm*. This engineer was Ken Thompson, known for the design and implementation
    of Unix, the B programming language, the UTF-8 encoding, and others.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 十二年后，1968年，计算机科学的传奇先驱接受了克利恩的工作并加以扩展，将他的研究发表在《正则表达式搜索算法》一文中。这位工程师就是肯·汤普森，他以Unix、B编程语言、UTF-8编码等的设计和实现而闻名。
- en: 'Ken Thompson''s work didn''t end in just writing a paper. He included support
    for these regular expressions in his version of QED. To search with a regular
    expression in QED, the following had to be written:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 肯·汤普森的工作不仅仅是写论文。他在他的QED版本中包括了对这些正则表达式的支持。要在QED中使用正则表达式，需要编写以下内容：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding line of code, `g` means global search and `p` means print.
    If, instead of writing `regular expression`, we write the short form `re`, we
    get `g/re/p`, and therefore, the beginnings of the venerable UNIX command-line
    tool `grep`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，`g`表示全局搜索，`p`表示打印。如果我们不写`regular expression`，而是写短形式`re`，我们得到`g/re/p`，因此，这是古老的UNIX命令行工具`grep`的开端。
- en: The next outstanding milestones were the release of the first non-proprietary
    library of **regex** by Henry Spence, and later, the creation of the scripting
    language **Perl** by Larry Wall. Perl pushed the regular expressions to the mainstream.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的重要里程碑是Henry Spence发布了第一个非专有的**regex**库，后来是脚本语言**Perl**的创建。Perl将正则表达式推向了主流。
- en: The implementation in Perl went forward and added many modifications to the
    original regular expression syntax, creating the so-called **Perl flavor**. Many
    of the later implementations in the rest of the languages or tools are based on
    the Perl flavor of regular expressions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Perl中的实现向前迈进，并对原始正则表达式语法进行了许多修改，创建了所谓的**Perl风格**。其他语言或工具中的许多后续实现都基于Perl风格的正则表达式。
- en: The IEEE thought their POSIX standard has tried to standardize and give better
    Unicode support to the regular expression syntax and behaviors. This is called
    the POSIX flavor of the regular expressions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE认为他们的POSIX标准试图标准化并为正则表达式语法和行为提供更好的Unicode支持。这被称为正则表达式的POSIX风格。
- en: Today, the standard Python module for regular expressions—`re`—supports only
    Perl-style regular expressions. There is an effort to write a new regex module
    with better POSIX style support at [https://pypi.python.org/pypi/regex](https://pypi.python.org/pypi/regex).
    This new module is intended to replace Python's `re` module implementation eventually.
    In this book, we will learn how to leverage only the standard `re` module.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，用于正则表达式的标准Python模块`re`仅支持Perl风格的正则表达式。有人正在努力编写一个新的regex模块，以更好地支持POSIX风格，网址为[https://pypi.python.org/pypi/regex](https://pypi.python.org/pypi/regex)。这个新模块打算最终取代Python的`re`模块实现。在本书中，我们将学习如何利用标准的`re`模块。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Regular expressions, regex, regexp, or regexen?**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式，regex，regexp或regexen？**'
- en: Henry Spencer referred indistinctly to his famous library as "regex" or "regexp".
    Wikipedia proposed *regex* or *regexp* to be used as abbreviations. The famous
    Jargon File lists them as *regexp*, regex, and reg-ex.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'Henry Spencer将他著名的库不加区分地称为"regex"或"regexp"。维基百科建议使用*regex*或*regexp*作为缩写。著名的Jargon
    File将它们列为*regexp*、regex和reg-ex。 '
- en: However, even though there does not seem to be a very strict approach to naming
    regular expressions, they are based in the field of mathematics called **formal
    languages**, where being exact is everything. Most modern implementations support
    features that cannot be expressed in formal languages, and therefore, they are
    not real regular expressions. Larry Wall, creator of the Perl language, used the
    term **regexes** or **regexen** for this reason.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管对于命名正则表达式似乎没有非常严格的方法，它们是基于数学领域中称为**形式语言**的领域，其中精确是一切。大多数现代实现支持无法用形式语言表达的特性，因此它们不是真正的正则表达式。Perl语言的创建者Larry
    Wall因此使用了术语**regexes**或**regexen**。
- en: In this book, we will indistinctly use all the aforementioned terms as if they
    were perfect synonyms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将不加区分地使用所有上述术语，就好像它们是完美的同义词一样。
- en: The regular expression syntax
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式语法
- en: Any experienced developer has undoubtedly used some kind of regular expression.
    For instance, in the operating system console, it's not uncommon to find the usage
    of the asterisk (`*`) or the question mark (`?`) to find files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有经验的开发人员无疑都使用过某种形式的正则表达式。例如，在操作系统控制台中，使用星号（`*`）或问号（`?`）来查找文件并不罕见。
- en: The question mark will match a single character with any value on a filename.
    For example, a pattern such as `file?.xml` will match `file1.xml`, `file2.xml`,
    and `file3.xml`, but it won't match `file99.xml` as the pattern expresses that
    anything that starts with `file`, followed by just one character of any value,
    and ends with `.xml`, will be matched.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 问号将匹配文件名中任何值的单个字符。例如，模式`file?.xml`将匹配`file1.xml`、`file2.xml`和`file3.xml`，但不会匹配`file99.xml`，因为该模式表示以`file`开头，接着是任何值的一个字符，最后以`.xml`结尾的任何内容都将匹配。
- en: A similar meaning is defined for asterisk (`*)`. When asterisk is used, any
    number of characters with any value is accepted. In the case of `file*.xml`, anything
    that starts with `file`, followed by any number of characters of any value, and
    finishes with `.xml`, will be matched.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 星号（`*`）也有类似的含义。当使用星号时，任何数量的任何值的字符都被接受。在`file*.xml`的情况下，任何以`file`开头，接着是任何数量的任何值的字符，最后以`.xml`结尾的内容都将匹配。
- en: 'In this expression, we can find two kind of components: **literals** (`file`
    and `.xml`) and **metacharacters** (`?` or `*`). The regular expressions we will
    learn in this book are much more powerful than the simple patterns we can typically
    find on the operating system command line, but both can share one single definition:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式中，我们可以找到两种组件：**文字**（`file`和`.xml`）和**元字符**（`?`或`*`）。我们将在本书中学习的正则表达式比我们通常在操作系统命令行中找到的简单模式更强大，但两者都可以共享一个定义：
- en: A regular expression is a pattern of text that consists of ordinary characters
    (for example, letters *a* through *z* or numbers *0* through *9*) and special
    characters known as metacharacters. This pattern describes the strings that would
    match when applied to a text.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是由普通字符（例如，字母*a*到*z*或数字*0*到*9*）和称为元字符的特殊字符组成的文本模式。这个模式描述了应用于文本时匹配的字符串。
- en: 'Let''s see our very first regular expression that will match any word starting
    with ![The regular expression syntax](graphics/inlinemedia.jpg)`a`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的第一个正则表达式，它将匹配任何以`a`开头的单词![正则表达式语法](graphics/inlinemedia.jpg)：
- en: '![The regular expression syntax](graphics/3156OS_01_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![正则表达式语法](graphics/3156OS_01_01.jpg)'
- en: Regex using literals and metacharacters
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式使用文字和元字符
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Representation of regular expressions in this book**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**本书中正则表达式的表示**'
- en: In the following figures of this book, regular expressions are going to be represented
    bounded by the `/` symbol. This is the QED demarcation that is followed in most
    of the text books. The code examples, however, won't use this notation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续图表中，正则表达式将被`/`符号限定。这是大多数教科书中遵循的QED标记。然而，代码示例不会使用这种表示法。
- en: On the other hand, even with monospaced font faces, the white spaces of a regular
    expression are difficult to count. In order to simplify the reading, every single
    whitespace in the figures will appear as ![The regular expression syntax](graphics/inlinemedia.jpg).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，即使使用等宽字体，正则表达式的空格也很难计算。为了简化阅读，在图表中的每个单个空格都将显示为![正则表达式语法](graphics/inlinemedia.jpg)。
- en: The previous regular expression is again using literals and metacharacters.
    The literals here are ![The regular expression syntax](graphics/inlinemedia.jpg)
    and `a`, and the metacharacters are `\` and `w` that match any alphanumeric character
    including underscore, and `*`, that will allow any number of repetitions of the
    previous character, and therefore, any number of repetitions of any word character,
    including underscore.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的正则表达式再次使用字面量和元字符。这里的字面量是![正则表达式语法](graphics/inlinemedia.jpg)和`a`，元字符是`\`和`w`，它们匹配包括下划线在内的任何字母数字字符，以及`*`，它将允许前一个字符的任意重复，因此，任意数量的任何单词字符的重复，包括下划线。
- en: We will cover the metacharacters later in this chapter, but let's start by understanding
    the literals.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面介绍元字符，但让我们先了解字面量。
- en: Literals
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字面量
- en: Literals are the simplest form of pattern matching in regular expressions. They
    will simply succeed whenever that literal is found.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量是正则表达式中最简单的模式匹配形式。只要找到该字面量，它们就会简单地成功。
- en: 'If we apply the regular expression `/fox/` to search the phrase `The quick
    brown fox jumps over the lazy dog`, we will find one match:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将正则表达式`/fox/`应用于搜索短语`The quick brown fox jumps over the lazy dog`，我们将找到一个匹配：
- en: '![Literals](graphics/3156OS_01_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![文字](graphics/3156OS_01_02.jpg)'
- en: Searching using a regular expression
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式进行搜索
- en: 'However, we can also obtain several results instead of just one, if we apply
    the regular expression `/be/` to the following phrase `To be, or not to be`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将正则表达式`/be/`应用于以下短语`To be, or not to be`，我们也可以获得多个结果而不仅仅是一个：
- en: '![Literals](graphics/3156OS_01_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![文字](graphics/3156OS_01_03.jpg)'
- en: Multiple results searching with regex
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式进行多个结果搜索
- en: We have just learned in the previous section that metacharacters can coexist
    with literals in the same expression. Because of this coexistence, we can find
    that some expressions do not mean what we intended. For example, if we apply the
    expression `/(this is inside)/` to search the text `this is outside (this is inside)`,
    we will find that the parentheses are not included in the result. This happens
    because parentheses are metacharacters and they have a special meaning.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在前一节中学到，元字符可以与字面量共存在同一个表达式中。由于这种共存，我们会发现一些表达式并不是我们想要的。例如，如果我们将表达式`/(this
    is inside)/`应用于搜索文本`this is outside (this is inside)`，我们会发现括号没有包含在结果中。这是因为括号是元字符，它们有特殊的含义。
- en: '![Literals](graphics/3156OS_01_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![文字](graphics/3156OS_01_04.jpg)'
- en: Incorrectly unescaped metacharacters
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 错误未转义的元字符
- en: 'We can use metacharacters as if they were literals. There are three mechanisms
    to do so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将元字符用作字面量。有三种机制可以这样做：
- en: Escape the metacharacters by preceding them with a backslash.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在元字符前加上反斜杠来转义元字符。
- en: In python, use the `re.escape` method to escape non-alphanumeric characters
    that may appear in the expression. We will cover this in [Chapter 2](ch02.html
    "Chapter 2. Regular Expressions with Python"), *Regular Expressions with Python*.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，使用`re.escape`方法转义可能出现在表达式中的非字母数字字符。我们将在[第2章](ch02.html "第2章。使用Python进行正则表达式")中介绍这个内容，*使用Python进行正则表达式*。
- en: '**Quoting with \Q and \E**: There is a third mechanism to quote in regular
    expressions, the quoting with `\Q` and `\E`. In the flavors that support them,
    it''s as simple as enclosing the parts that have to be quoted with \Q (which starts
    a quote) and \E (which ends it).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用\Q和\E进行引用**：在正则表达式中，还有第三种引用机制，即使用`\Q`和`\E`进行引用。在支持它们的语言中，只需用\Q（开始引用）和\E（结束引用）括起需要引用的部分即可。'
- en: However, this is not supported in Python at the moment.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前Python不支持这一点。
- en: 'Using the backslash method, we can convert the previous expression to `/\(this
    is inside\)/` and apply it again to the same text to have the parentheses included
    in the result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反斜杠方法，我们可以将前面的表达式转换为`/\(this is inside\)/`，并再次应用到相同的文本中，以便将括号包含在结果中：
- en: '![Literals](graphics/3156OS_01_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![文字](graphics/3156OS_01_05.jpg)'
- en: Escaped metacharacters in regex
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中转义元字符
- en: 'In regular expressions, there are twelve metacharacters that should be escaped
    if they are to be used with their literal meaning:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，有十二个元字符，如果要以它们的字面意义使用，就应该转义：
- en: Backslash `\`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反斜杠`\`
- en: Caret `^`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入符号`^`
- en: Dollar sign `$`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美元符号`$`
- en: Dot `.`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点`.`
- en: Pipe symbol `|`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道符号`|`
- en: Question mark `?`
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问号`?`
- en: Asterisk `*`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星号`*`
- en: Plus sign `+`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加号`+`
- en: Opening parenthesis `(`
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左括号`(`
- en: Closing parenthesis `)`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右括号`)`
- en: Opening square bracket `[`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左方括号`[`
- en: The opening curly brace `{`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左花括号`{`
- en: In some cases, the regular expression engines will do their best to understand
    if they should have a literal meaning even if they are not escaped; for example,
    the opening curly brace `{` will only be treated as a metacharacter if it's followed
    by a number to indicate a repetition, as we will learn later in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，正则表达式引擎会尽力理解它们是否应该具有字面意义，即使它们没有被转义；例如，左花括号`{`只有在后面跟着一个数字表示重复时才会被视为元字符，我们将在本章后面学习到。
- en: Character classes
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符类
- en: We are going to use a metacharacter for the first time to learn how to leverage
    the character classes. The character classes (also known as character sets) allow
    us to define a character that will match if any of the defined characters on the
    set is present.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首次使用元字符来学习如何利用字符类。字符类（也称为字符集）允许我们定义一个字符，如果集合中定义的任何字符存在，则匹配。
- en: 'To define a character class, we should use the opening square bracket metacharacter
    `[`, then any accepted characters, and finally close with a closing square bracket
    `]`. For instance, let''s define a regular expression that can match the word
    "license" in British and American English written form:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义字符类，我们应该使用开方括号元字符`[`，然后是任何接受的字符，最后用闭方括号`]`关闭。例如，让我们定义一个正则表达式，可以匹配英式和美式英语书写形式中的单词"license"：
- en: '![Character classes](graphics/3156OS_01_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![字符类](graphics/3156OS_01_06.jpg)'
- en: Searching using a character class
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符类进行搜索
- en: It is possible to also use the range of a character. This is done by leveraging
    the hyphen symbol (`-`) between two related characters; for example, to match
    any lowercase letter we can use `[a-z]`. Likewise, to match any single digit we
    can define the character set `[0-9]`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用字符的范围。这是通过在两个相关字符之间使用连字符（`-`）来完成的；例如，要匹配任何小写字母，我们可以使用`[a-z]`。同样，要匹配任何单个数字，我们可以定义字符集`[0-9]`。
- en: 'The character classes'' ranges can be combined to be able to match a character
    against many ranges by just putting one range after the other—no special separation
    is required. For instance, if we want to match any lowercase or uppercase alphanumeric
    character, we can use `[0-9a-zA-Z]` (see next table for a more detailed explanation).
    This can be alternatively written using the union mechanism: `[0-9[a-z[A-Z]]]`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类的范围可以组合在一起，以便通过将一个范围放在另一个范围后面来匹配字符对许多范围进行匹配—不需要特殊的分隔。例如，如果我们想匹配任何小写或大写字母数字字符，我们可以使用`[0-9a-zA-Z]`（有关更详细的解释，请参见下表）。这也可以使用并集机制来替代写成`[0-9[a-z[A-Z]]]`。
- en: '| Element | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **[** | Matches the following set of characters |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **[** | 匹配以下字符集 |'
- en: '| **0-9** | Matches anything between `0` and `9` (`0`, `1`, `2`, `3`, `4`,
    `5`, `6`, `7`, `8`, `9`). |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **0-9** | 匹配`0`到`9`之间的任何内容（`0`，`1`，`2`，`3`，`4`，`5`，`6`，`7`，`8`，`9`）。 |'
- en: '|   | Or |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|   | 或 |'
- en: '| **a-z** | Matches anything between `a` and `z` (`a`, `b`, `c`, `d`, ...,
    `z`) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **a-z** | 匹配`a`到`z`之间的任何内容（`a`，`b`，`c`，`d`，...，`z`） |'
- en: '|   | Or |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|   | 或 |'
- en: '| **A-Z** | Matches anything between `A` and `Z` (`A`, `B`, `C`, `D`, ...,
    `Z`) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **A-Z** | 匹配`A`到`Z`之间的任何内容（`A`，`B`，`C`，`D`，...，`Z`） |'
- en: '| **]** | End of character set |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **]** | 字符集结束 |'
- en: There is another possibility—the negation of ranges. We can invert the meaning
    of a character set by placing a caret (`^`) symbol right after the opening square
    bracket metacharacter (`[`). If we have a character class such as `[0-9]` meaning
    any digit, the negated character class `[^0-9]` will match anything that is not
    a digit. However, it is important to notice that there has to be a character that
    is not a digit; for example, `/hello[^0-9]/` won't match the string `hello` because
    after the ![Character classes](graphics/inlinemedia.jpg) there has to be a non-digit
    character. There is a mechanism to do this—called **negative lookahead**—and it
    will be covered in [Chapter 4](ch04.html "Chapter 4. Look Around"), *Look Around*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种可能性—范围的否定。我们可以通过在开方括号元字符（`[`）后面直接放置一个脱字符（`^`）来颠倒字符集的含义。如果我们有一个字符类，比如`[0-9]`表示任何数字，否定的字符类`[^0-9]`将匹配任何不是数字的内容。但是，重要的是要注意，必须有一个不是数字的字符；例如，`/hello[^0-9]/`不会匹配字符串`hello`，因为在![字符类](graphics/inlinemedia.jpg)之后必须有一个非数字字符。有一种机制可以做到这一点—称为**负向先行断言**—它将在[第4章](ch04.html
    "第4章.环视") *环视*中进行介绍。
- en: Predefined character classes
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义字符类
- en: After using character classes for some time, it becomes clear that some of them
    are very useful and probably worthy of a shortcut.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符类一段时间后，很明显其中一些非常有用，可能值得一个快捷方式。
- en: Luckily enough, there are a number of predefined character classes that can
    be re-used and will be already known by other developers, making the expressions
    using them more readable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有许多预定义的字符类可以被重复使用，并且其他开发人员可能已经知道，使得使用它们的表达式更易读。
- en: These characters are not only useful as well-known shortcuts for typical character
    sets, but also have different meanings in different contexts. The character class
    `\w`, which matches any alphanumeric character, will match a different set of
    characters depending on the configured locale and the support of Unicode.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符不仅作为典型字符集的众所周知的快捷方式非常有用，而且在不同的上下文中具有不同的含义。字符类`\w`，它匹配任何字母数字字符，将根据配置的区域设置和对Unicode的支持匹配不同的字符集。
- en: 'The following table shows the character classes supported at this moment in
    Python:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了Python目前支持的字符类：
- en: '| Element | Description (for regex with default flags) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述（对于默认标志的正则表达式） |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| This element matches any character except newline `\n` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 此元素匹配除换行符`\n`之外的任何字符 |'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| This matches any decimal digit; this is equivalent to the class `[0-9]` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 这匹配任何十进制数字；这相当于类`[0-9]` |'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| This matches any non-digit character; this is equivalent to the class `[^0-9]`
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 这匹配任何非数字字符；这相当于类`[^0-9]` |'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| This matches any whitespace character; this is equivalent to the class `[![Predefined
    character classes](graphics/inlinemedia.jpg)\t\n\r\f\v]` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 这匹配任何空白字符；这相当于类`[![预定义字符类](graphics/inlinemedia.jpg)\t\n\r\f\v]` |'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| This matches any non-whitespace character; this is equivalent to the class
    `[^ \t\n\r\f\v]` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 这匹配任何非空白字符；这相当于类`[^ \t\n\r\f\v]` |'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| This matches any alphanumeric character; this is equivalent to the class
    `[a-zA-Z0-9_]` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 这匹配任何字母数字字符；这相当于类`[a-zA-Z0-9_]` |'
- en: '|'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| This matches any non-alphanumeric character; this is equivalent to the class
    `[^a-zA-Z0-9_]` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 这匹配任何非字母数字字符；这相当于类`[^a-zA-Z0-9_]` |'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**POSIX character classes in Python**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python中的POSIX字符类**'
- en: The POSIX standard provides a number of character classes' denominations, for
    example, `[:alnum:]` for alphanumeric characters, `[:alpha:]` for alphabetic characters,
    or `[:space:]` for all whitespace characters, including line breaks.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX标准提供了许多字符类的名称，例如，`[:alnum:]`表示字母数字字符，`[:alpha:]`表示字母字符，或`[:space:]`表示所有空白字符，包括换行符。
- en: All the POSIX character classes follow the same `[:name:]` notation, rendering
    them easily identifiable. However, they are not supported in Python at the moment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的POSIX字符类都遵循相同的`[:name:]`表示法，使它们易于识别。但是，它们目前在Python中不受支持。
- en: If you come across one of them, you can implement the same functionality by
    leveraging the character classes' functionalities we just studied in this section.
    As an example, for an ASCII equivalent of `[:alnum:]` with an English locale,
    we can write `[a-zA-Z0-9]`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到其中一个，你可以通过利用我们在本节中学到的字符类的功能来实现相同的功能。例如，在英语环境中，ASCII等效的`[:alnum:]`可以写成`[a-zA-Z0-9]`。
- en: The first one from the previous table—the dot—requires special attention. The
    dot is probably one of the oldest and also one of the most used metacharacters.
    The dot can match any character except a newline character.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个表中的第一个元素——点——需要特别注意。点可能是最古老的元字符之一，也是最常用的元字符之一。点可以匹配除换行符之外的任何字符。
- en: The reason to not match the newline is probably UNIX. In UNIX, the command-line
    tools usually worked line by line, and the regular expressions available at the
    moment were applied separately to those lines. Therefore, there were no newline
    characters to match.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不匹配换行符的原因可能是UNIX。在UNIX中，命令行工具通常逐行工作，并且当前可用的正则表达式是分别应用于这些行的。因此，没有换行符可匹配。
- en: 'Let''s put the dot in practice by creating a regular expression that matches
    three characters of any value except newline:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个正则表达式来实践点，该表达式匹配除换行符之外的任何值的三个字符：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Element | Description |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| . | Matches any character |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| . | 匹配任何字符 |'
- en: '| . | Matches any character followed by the previous one |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| . | 匹配前一个字符后面的任何字符 |'
- en: '| . | Matches any character followed by the previous one |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| . | 匹配前一个字符后面的任何字符 |'
- en: The dot is a very powerful metacharacter that can create problems if it is not
    used moderately. In most of the cases where the dot is used, it could be considered
    overkill (or just a symptom of laziness when writing regular expressions).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 点是一个非常强大的元字符，如果不适度使用可能会导致问题。在大多数使用点的情况下，可以考虑使用过度（或者只是在编写正则表达式时的懒惰的表现）。
- en: 'To better define what is expected to be matched and to express more concisely
    to any ulterior reader what a regular expression is intended to do, the usage
    of character classes is much recommended. For instance, when working with Windows
    and UNIX file paths, to match any character except the slash or the backslash,
    you can use a negated character set:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地定义预期匹配的内容，并更简洁地表达正则表达式的意图，强烈推荐使用字符类。例如，在处理Windows和UNIX文件路径时，要匹配除斜杠或反斜杠之外的任何字符，可以使用否定字符集：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| Element | Description |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Matches a set of characters |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 匹配一组字符 |'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| Not matching this symbol''s following characters |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 不匹配此符号后的字符 |'
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '| Matches a `/` character |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 匹配 `/` 字符 |'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| Matches a `\` character |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 匹配 `\` 字符 |'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| End of the set |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 集合的结束 |'
- en: This character set is explicitly telling you that we intend to match anything
    but a Windows or UNIX file path separator.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符集明确告诉你，我们打算匹配除了Windows或UNIX文件路径分隔符之外的任何内容。
- en: Alternation
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交替
- en: 'We have just learned how to match a single character from a set of characters.
    Now, we are going to learn a broader approach: how to match against a set of regular
    expressions. This is accomplished using the pipe symbol `|`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学会了如何匹配一组字符中的单个字符。现在，我们将学习更广泛的方法：如何匹配一组正则表达式。这是使用管道符号`|`来实现的。
- en: 'Let''s start by saying that we want to match either if we find the word "yes"
    or the word "no". Using alternation, it will be as simple as:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从想要匹配的内容开始，如果我们找到单词 "yes" 或单词 "no"。使用交替，就会变得很简单：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| Element | Description |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|   | Matches either of the following character sets |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|   | 匹配以下字符集中的任何一个 |'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| The characters `y`, `e`, and `s`. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 字符 `y`，`e` 和 `s`。 |'
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| Or |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 或 |'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| The characters `n` and `o`. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 字符 `n` 和 `o`。 |'
- en: 'On the other hand, if we want to accept more than two values, we can continue
    adding values to the alternation like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想要接受超过两个值，我们可以继续像这样添加值到交替中：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| Element | Description |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|   | Matches either of the following character sets |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|   | 匹配以下字符集中的任何一个 |'
- en: '|'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| The literal "yes" |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 字面上的 "yes" |'
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| Or |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 或 |'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| The literal "no" |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 字面上的 "no" |'
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| Or |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 或 |'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| The literal "maybe" |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 字面上的 "maybe" |'
- en: 'When using in bigger regular expressions, we will probably need to wrap our
    alternation inside parentheses to express that only that part is alternated and
    not the whole expression. For instance, if we make the mistake of not using the
    parentheses, as in the following expression:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的正则表达式中使用时，我们可能需要将我们的交替放在括号中，以表达只有那部分是交替的，而不是整个表达式。例如，如果我们犯了不使用括号的错误，就像下面的表达式一样：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| Element | Description |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|   | Matches either of the following character sets |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|   | 匹配以下字符集中的任何一个 |'
- en: '|'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| The characters `L`, `i`, `c`, `e`, `n`, `c`, `e`, `:`, ![Alternation](graphics/inlinemedia.jpg),
    `y`, `e`, and `s` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 字符 `L`，`i`，`c`，`e`，`n`，`c`，`e`，`:`，![交替](graphics/inlinemedia.jpg)，`y`，`e`
    和 `s` |'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| Or |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 或 |'
- en: '|'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| The characters `n` and `o`. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 字符 `n` 和 `o`。 |'
- en: 'We may think we are accepting either `Licence: yes` or `Licence: no`, but we
    are actually accepting either `Licence: yes` or `no` as the alternation has been
    applied to the whole regular expression instead of just the `yes|no` part. A correct
    approach for this will be:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可能认为我们接受`Licence: yes`或`Licence: no`，但实际上我们接受的是`Licence: yes`或`no`，因为交替已经应用于整个正则表达式，而不仅仅是`yes|no`部分。正确的方法是：'
- en: '![Alternation](graphics/3156OS_01_07.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![交替](graphics/3156OS_01_07.jpg)'
- en: Regular expression using alternation
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交替的正则表达式
- en: Quantifiers
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量词
- en: So far, we have learned how to define a single character in a variety of fashions.
    At this point, we will leverage the quantifiers—the mechanisms to define how a
    character, metacharacter, or character set can be repeated.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，我们已经学会了以各种方式定义单个字符。在这一点上，我们将利用量词——定义字符、元字符或字符集如何重复的机制。 '
- en: 'For instance, if we define that a `\d` can be repeated many times, we can easily
    create a form validator for the `number of items` field of a shopping cart (remember
    that `\d` matches any decimal digit). But let''s start from the beginning, the
    three basic quantifiers: the question mark `?`, the plus sign `+`, and the asterisk
    `*`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们定义`\d`可以重复多次，我们可以轻松地为购物车的`商品数量`字段创建一个表单验证器（记住`\d`匹配任何十进制数字）。但让我们从头开始，三种基本的量词：问号`?`，加号`+`和星号`*`。
- en: '| Symbol | Name | Quantification of previous character |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 名称 | 前一个字符的量化 |'
- en: '| --- | --- | --- |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| Question mark | Optional (0 or 1 repetitions) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 问号 | 可选的（0次或1次重复） |'
- en: '|'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| Asterisk | Zero or more times |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 星号 | 零次或多次 |'
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| Plus sign | One or more times |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: 加号 | 一次或多次 |
- en: '|'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| Curly braces | Between *n* and *m* times |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 大括号 | 重复*n*到*m*次 |'
- en: 'In the preceding table, we can find the three basic quantifiers, each with
    a specific utility. The question mark can be used to match the word `car` and
    its plural form `cars`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，我们可以找到三种基本的量词，每种都有特定的用途。问号可以用来匹配单词`car`及其复数形式`cars`：
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Element | Description |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| Matches the characters `c`, `a`, `r` and `s` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 匹配字符`c`，`a`，`r`和`s` |'
- en: '|'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| Optionally matches the character `s` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 可选地匹配字符`s` |'
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous example, the question mark is only applied to the character
    `s` and not to the whole word. The quantifiers are always applied only to the
    previous token.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，问号只应用于字符`s`，而不是整个单词。量词总是只应用于前一个标记。
- en: Another interesting example of the usage of the question mark quantifier will
    be to match a telephone number that can be in the format `555-555-555`, `555 555
    555`, or `555555555`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用问号量词的另一个有趣的例子是匹配电话号码，可以是`555-555-555`，`555 555 555`或`555555555`的格式。
- en: 'We now know how to leverage character sets to accept different characters,
    but is it possible to apply a quantifier to a character set? Yes, quantifiers
    can be applied to characters, character sets, and even to groups (a feature we
    will cover in [Chapter 3](ch03.html "Chapter 3. Grouping"), *Grouping*). We can
    construct a regular expression like this to validate the telephone numbers:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何利用字符集来接受不同的字符，但是是否可以将量词应用于字符集？是的，量词可以应用于字符、字符集，甚至是组（我们将在[第3章](ch03.html
    "第3章. 分组")中介绍*分组*）。我们可以构建一个这样的正则表达式来验证电话号码：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the next table, we can find a detailed explanation of the preceding regular
    expression:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，我们可以找到对前面的正则表达式的详细解释：
- en: '| Element | Type | Description |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| Predefined character set | Any decimal character |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 预定义字符集 | 任何十进制字符 |'
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| Quantifier | - that is repeated one or more times |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 量词 | - 重复一次或多次 |'
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| Character set | A hyphen or whitespace character |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 字符集 | 连字符或空格字符 |'
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '| Quantifier | - that may or may not appear |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 量词 | - 可能出现也可能不出现 |'
- en: '|'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '| Predefined character set | Any decimal character |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 预定义字符集 | 任何十进制字符 |'
- en: '|'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| Quantifier | - that is repeated one or more times |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 量词 | - 重复一次或多次 |'
- en: '|'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '| Character set | A hyphen or whitespace character |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 字符集 | 连字符或空格字符 |'
- en: '|'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| Predefined character set | Any decimal character |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 预定义字符集 | 任何十进制字符 |'
- en: '|'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '| Quantifier | - that is repeated one or more times |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 量词 | - 重复一次或多次 |'
- en: At the beginning of this section, one more kind of quantifier using the curly
    braces had been mentioned. Using this syntax, we can define that the previous
    character must appear exactly three times by appending it with `{3}`, that is,
    the expression `\w{8}` specifies exactly eight alphanumeric digits.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头，提到了使用大括号的一种量词。使用这种语法，我们可以通过在其后附加`{3}`来定义前一个字符必须出现三次，也就是说，表达式`\w{8}`指定了确切的八个字母数字。
- en: We can also define a certain range of repetitions by providing a minimum and
    maximum number of repetitions, that is, between three and eight times can be defined
    with the syntax `{4,7}`. Either the minimum or the maximum value can be omitted
    defaulting to `0` and infinite respectively. To designate a repetition of up to
    three times, we can use `{,3}`, we can also establish a repetition at least three
    times with `{3,}`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过提供重复的最小和最大次数来定义一定范围的重复，即，可以使用语法`{4,7}`来定义三到八次之间的重复。最小值或最大值可以省略，默认为`0`和无限。要指定最多重复三次，我们可以使用`{,3}`，我们也可以使用`{3,}`来至少重复三次。
- en: Tip
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Readability Tip**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**可读性提示**'
- en: Instead of using `{,1}`, you can use the question mark. The same applies to
    `{0,}` for the asterisk `*` and `{1,}` for the plus sign `+`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`{,1}`，你可以使用问号。对星号`*`使用`{0,}`，对加号`+`使用`{1,}`也是一样的。
- en: Other developers will expect you to do so. If you don't follow this practice,
    anyone reading your expressions will lose some time trying to figure out what
    kind of fancy stuff you tried to accomplish.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 其他开发人员会期望你这样做。如果你不遵循这个做法，任何阅读你的表达式的人都会花费一些时间来弄清楚你试图完成的是什么样的花哨东西。
- en: 'These four different combinations are shown in the next table:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种不同的组合显示在下表中：
- en: '| Syntax | Description |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 语法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '| The previous character is repeated exactly *n* times. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: 前一个字符恰好重复*n*次。 |
- en: '|'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '| The previous character is repeated at least *n* times. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: 前一个字符至少重复*n*次。 |
- en: '|'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE48]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '| The previous character is repeated at most *n* times. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: 前一个字符最多重复*n*次。 |
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '| The previous character is repeated between *n* and *m* times (both inclusive).
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: 前一个字符重复*n*到*m*次（包括*n*和*m*）。 |
- en: 'Earlier in this chapter, we created a regular expression to validate telephone
    numbers that can be in the format `555-555-555`, `555 555 555`, or `555555555`.
    We defined a regular expression to validate it using the metacharacter plus sign:
    `/\d+[-\s]?\d+[-\s]?\d+/`. It will require the digits (`\d`) to be repeated one
    or more times.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们创建了一个正则表达式来验证电话号码，可以是`555-555-555`，`555 555 555`或`555555555`的格式。我们使用元字符加号来定义验证它的正则表达式：`/\d+[-\s]?\d+[-\s]?\d+/`。它将要求数字（`\d`）重复一次或多次。
- en: 'Let''s fine-tune the regular expression by defining that the leftmost digit
    group can contain up to three characters, while the rest of the digit groups should
    contain exactly three digits:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义左侧数字组最多可以包含三个字符，同时其余的数字组应该包含恰好三个数字，来微调正则表达式：
- en: '![Quantifiers](graphics/3156OS_01_08.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![量词](graphics/3156OS_01_08.jpg)'
- en: Using quantifiers
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用量词
- en: Greedy and reluctant quantifiers
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贪婪和勉强量词
- en: 'We still haven''t defined what would match if we apply a quantifier such as
    this `/".+"/` to a text such as the following: `English "Hello", Spanish "Hola"`.
    We may expect that it matches `"Hello" and "Hola"` but it will actually match
    `"Hello", Spanish "Hola"`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然没有定义如果我们将这样的量词`/" .+"/`应用到以下文本中会匹配什么：`English "Hello", Spanish "Hola"`。我们可能期望它匹配`"Hello"和"Hola"`，但实际上它将匹配`"Hello",
    Spanish "Hola"`。
- en: 'This behavior is called greedy and is one of the two possible behaviors of
    the quantifiers in Python: **greedy** and **non-greedy** (also known as **reluctant**).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为被称为贪婪，是Python中量词的两种可能行为之一：**贪婪**和**非贪婪**（也称为**勉强**）。
- en: The greedy behavior of the quantifiers is applied by default in the quantifiers.
    A greedy quantifier will try to match as much as possible to have the biggest
    match result possible.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量词的贪婪行为是默认应用的。贪婪量词将尝试尽可能多地匹配，以获得最大的匹配结果。
- en: The non-greedy behavior can be requested by adding an extra question mark to
    the quantifier; for example, `??`, `*?` or `+?`. A quantifier marked as reluctant
    will behave like the exact opposite of the greedy ones. They will try to have
    the smallest match possible.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非贪婪行为可以通过在量词后添加一个额外的问号来请求；例如，`??`，`*?`或`+?`。标记为勉强的量词将表现得像贪婪量词的完全相反。它们会尝试获得尽可能小的匹配。
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Possessive quantifiers**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**占有量词**'
- en: There is a third behavior of the quantifiers, the possessive behavior. This
    behavior is only supported by the Java and .NET flavors of the regular expressions
    at the moment.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 量词还有第三种行为，即占有行为。这种行为目前只受Java和.NET正则表达式的支持。
- en: They are represented with an extra plus symbol to the quantifier; for example,
    `?+`, `*+`, or `++`. Possessive quantifiers won't have further coverage in this
    book.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 它们用额外的加号符号表示量词；例如，`?+`，`*+`或`++`。这本书不会进一步涵盖占有量词。
- en: 'We can understand better how this quantifier works by looking at the next figure.
    We will apply almost the same regular expression (with the exception of leaving
    the quantifier as greedy or marking it as reluctant) to the same text, having
    two very different results:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看下图，我们可以更好地理解这个量词是如何工作的。我们将几乎相同的正则表达式（除了将量词保持为贪婪或标记为勉强）应用到相同的文本上，得到两个非常不同的结果：
- en: '![Greedy and reluctant quantifiers](graphics/3156OS_01_09.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![贪婪和勉强量词](graphics/3156OS_01_09.jpg)'
- en: Greedy and reluctant quantifiers
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪和勉强量词
- en: Boundary Matchers
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界匹配器
- en: Until this point, we have just tried to find out regular expressions within
    a text. Sometimes, when it is required to match a whole line, we may also need
    to match at the beginning of a line or even at the end. This can be done thanks
    to the **boundary matchers**.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是试图在文本中找到正则表达式。有时，当需要匹配整行时，我们可能还需要在行的开头或结尾匹配。这可以通过**边界匹配器**来实现。
- en: 'The boundary matchers are a number of identifiers that will correspond to a
    particular position inside of the input. The following table shows the boundary
    matchers available in Python:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 边界匹配器是一些标识符，它们对应于输入中的特定位置。下表显示了Python中可用的边界匹配器：
- en: '| Matcher | Description |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: 匹配器 | 描述 |
- en: '| --- | --- |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE50]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '| Matches at the beginning of a line |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: 匹配行的开头 |
- en: '|'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE51]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '| Matches at the end of a line |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 匹配行的结尾 |'
- en: '|'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE52]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '| Matches a word boundary |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: 匹配单词边界 |
- en: '|'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE53]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '| Matches the opposite of `\b`. Anything that is not a word boundary |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: 匹配`\b`的相反。任何不是单词边界的东西 |
- en: '|'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE54]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '| Matches the beginning of the input |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 匹配输入的开头 |'
- en: '|'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '| Matches the end of the input |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: 匹配输入的结尾 |
- en: These boundary matchers will behave differently in different contexts. For instance,
    the word boundaries (`\b`) will depend directly on the configured locale as different
    languages may have different word boundaries, and the beginning and end of line
    boundaries will behave differently based on certain flags that we will study in
    the next chapter.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边界匹配器在不同的上下文中会有不同的行为。例如，单词边界（`\b`）将直接取决于配置的区域设置，因为不同的语言可能有不同的单词边界，而行的开头和结尾边界将根据我们将在下一章中学习的某些标志而有不同的行为。
- en: 'Let''s start working with boundary matchers by writing a regular expression
    that will match lines that start with "Name:". If you take a look at the previous
    table, you may notice the existence of the metacharacter `^` that expresses the
    beginning of a line. Using it, we can write the following expression:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个正则表达式来开始使用边界匹配器，该正则表达式将匹配以“Name:”开头的行。如果您看一下前面的表格，您可能会注意到存在元字符`^`，表示行的开头。使用它，我们可以编写以下表达式：
- en: '[PRE56]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '| Element | Description |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: 元素 | 描述 |
- en: '| --- | --- |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE57]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '| Matches the beginning of the line |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 匹配行的开头|'
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE58]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '| Matches the followed by character `N` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`N`|'
- en: '|'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE59]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '| Matches the followed by character `a` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`a` |'
- en: '|'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '| Matches the followed by character `m` |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: 匹配后面的字符`m`|
- en: '|'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE61]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '| Matches the followed by character `e` |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`e`|'
- en: '|'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE62]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '| Matches the followed by symbol colon |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: 匹配后面的冒号符号|
- en: If we want to take one step further and continue using the caret and the dollar
    sign in combination to match the end of the line, we should take into consideration
    that from now on we are going to be matching against the whole line, and not just
    trying to find a pattern within a line.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更进一步，继续使用插入符和美元符号的组合来匹配行尾，我们应该考虑从现在开始我们将匹配整行，而不仅仅是在行内寻找模式。
- en: Following the previous example, let's say that we want to make sure that after
    the name, there are only alphabetic characters or spaces until the end of the
    line. We will do this by matching the whole line until the end by setting a character
    set with the accepted characters and allowing their repetition any number of times
    until the end of the line.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，假设我们想要确保在名字后面，直到行尾只有字母字符或空格。我们将通过匹配整行直到末尾来实现这一点，通过设置一个包含接受字符的字符集，并允许它们重复任意次数直到行尾。
- en: '[PRE63]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '| Element | Description |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| --- | --- |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE64]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '| Matches the beginning of the line. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 匹配行的开头。|'
- en: '|'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE65]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '| Matches the followed by character `N`. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`N`。|'
- en: '|'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE66]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '| Matches the followed by character `a`. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`a`。|'
- en: '|'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE67]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '| Matches the followed by character `m`. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`m`。|'
- en: '|'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE68]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '| Matches the followed by character `e`. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`e`。|'
- en: '|'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE69]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '| Matches the followed by colon symbol. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的冒号符号。|'
- en: '|'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE70]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '| Then matches the followed by whitespace, or any alphabetic lowercase or uppercase
    character. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: 然后匹配后面的空格，或任何小写或大写字母字符。|
- en: '|'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE71]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '| The character can be repeated one or more times. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 该字符可以重复一次或多次。|'
- en: '|'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '| Until the end of the line. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: 直到行尾。|
- en: 'Another outstanding boundary matcher is the word boundary `\b`. It will match
    any character that is not a word character (in the configured locale), and therefore,
    any potential word boundary. This is very useful when we want to work with isolated
    words and we don''t want to create character sets with every single character
    that may divide our words (spaces, commas, colons, hyphens, and so on). We can,
    for instance, make sure that the word `hello` appears in a text by using the following
    regular expression:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个出色的边界匹配器是词边界`\b`。它将匹配任何不是单词字符（在配置的语言环境中）的字符，因此，任何潜在的词边界。当我们想要处理孤立的单词，而不想用每个可能分隔我们的单词的字符集（空格、逗号、冒号、连字符等）时，这非常有用。例如，我们可以通过使用以下正则表达式来确保文本中出现单词`hello`：
- en: '[PRE73]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '| Element | Description |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: 元素 | 描述 |
- en: '| --- | --- |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE74]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '| Matches a word boundary. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 匹配一个词边界。|'
- en: '|'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE75]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '| Matches the followed by character `h`. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: 匹配后面的字符`h`。|
- en: '|'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE76]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '| Matches the followed by character `e`. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: 匹配后面的字符`e`。|
- en: '|'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE77]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '| Matches the followed by character `l`. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`l`。|'
- en: '|'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE78]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '| Matches the followed by character `l`. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`l`。|'
- en: '|'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE79]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '| Matches the followed by character `o`. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 匹配后面的字符`o`。|'
- en: '|'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE80]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '| Then matches another followed by word boundary. |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: 然后匹配另一个后面的词边界。|
- en: As an exercise, we could think why the preceding expression is better than `/hello/`.
    The reason is that this expression will match an isolated word instead of a word
    containing "hello", that is, `/hello/` will easily match `hello`, `helloed`, or
    `Othello`; while `/\bhello\b/` will only match `hello`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我们可以思考为什么前面的表达式比`/hello/`更好。原因是这个表达式将匹配一个孤立的单词，而不是包含“hello”的单词，也就是说，`/hello/`很容易匹配`hello`，`helloed`或`Othello`；而`/\bhello\b/`只会匹配`hello`。
- en: Summary
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this first chapter, we have learned the importance of the regular expressions
    and how they became such a relevant tool for the programmers.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这第一章中，我们已经学习了正则表达式的重要性，以及它们如何成为程序员如此重要的工具。
- en: We also studied from a yet non-practical point of view, the basic regular expression
    syntax and some of the key features, such as character classes and quantifiers.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从一个非实际的角度学习了基本的正则表达式语法和一些关键特性，比如字符类和量词。
- en: In the next chapter, we are going to jump over to Python to start practicing
    with the `re` module.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转到Python开始使用`re`模块进行练习。
