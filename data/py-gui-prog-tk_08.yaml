- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Navigating Records with Treeview and Notebook
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Treeview 和 Notebook 导航记录
- en: You've received another request for features in the application. Now that your
    users can open arbitrary files for appending, they'd like to be able to see what's
    in those files and correct old records using the data entry form they've grown
    accustomed to, rather than having to switch over to a spreadsheet. In a nutshell,
    it's finally time to implement read and update capabilities in our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你收到了另一个关于应用程序功能的请求。现在，由于用户可以打开任意文件进行追加，他们希望能够查看这些文件的内容，并使用他们已经习惯的数据输入表单来纠正旧记录，而不是不得不切换到电子表格。简而言之，现在是时候在我们的应用程序中实现读取和更新功能了。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: In *Implementing read and update in the model*, we'll modify our CSV model for
    read and update capabilities.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *在模型中实现读取和更新* 中，我们将修改我们的 CSV 模型以实现读取和更新功能。
- en: In *The Ttk Treeview*, we'll explore the Ttk `Treeview` widget.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *探索 Ttk Treeview* 中，我们将探讨 Ttk 的 `Treeview` 小部件。
- en: In *Implementing a record list with Treeview*, we'll use our knowledge of the
    `Treeview` widget to create an interactive display of records in the CSV file.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *使用 Treeview 实现记录列表* 中，我们将利用我们对 `Treeview` 小部件的了解来创建 CSV 文件中记录的交互式显示。
- en: In *Adding the record list to the application*, we'll incorporate our new record
    list view into our application using the Ttk `Notebook` widget.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *将记录列表添加到应用程序中* 中，我们将使用 Ttk 的 `Notebook` 小部件将我们的新记录列表视图集成到应用程序中。
- en: Implementing read and update in the model
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模型中实现读取和更新
- en: Our entire design up to this point has been centered around a form that only
    appends data to a file; adding read and update capabilities is a fundamental change
    that will touch nearly every portion of the application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止的设计一直围绕着只向文件追加数据的表单；添加读取和更新功能是一个基本的改变，将几乎触及应用程序的每个部分。
- en: It may seem like a daunting task, but by taking it one component at a time,
    we'll see that the changes are not so overwhelming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一项艰巨的任务，但通过一次处理一个组件，我们会发现这些变化并不那么令人难以承受。
- en: 'The first thing we should do is update our documentation. Open the `abq_data_entry_spec.rst`
    file in the `docs` folder, and let''s start with the Requirements section:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该做的是更新我们的文档。在 `docs` 文件夹中打开 `abq_data_entry_spec.rst` 文件，让我们从需求部分开始：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And, of course, we should also update the part that is not required, like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还应该更新那些不需要的部分，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, it's a simple matter of making the code match with the documentation. Let's
    get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让代码与文档匹配只是一个简单的问题。让我们开始吧！
- en: Adding read and update to the CSVModel class
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 CSVModel 类添加读取和更新功能
- en: 'Take a moment to consider what''s missing from the `CSVModel` class that we''ll
    need to add for read and update functionality:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间考虑一下，`CSVModel` 类缺少哪些我们需要添加以实现读取和更新功能的部分：
- en: We'll need a method that can retrieve all records in a file so we can display
    them. We'll call it `get_all_records()`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个可以检索文件中所有记录的方法，这样我们就可以显示它们。我们将称之为 `get_all_records()`。
- en: We'll need a method to fetch individual records from the file by row number.
    We can call this one `get_record()`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个方法来通过行号从文件中获取单个记录。我们可以称这个方法为 `get_record()`。
- en: We'll need to save records in a way that can not only append new records but
    update existing records as well. We can update our `save_record()` method to accommodate
    this.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要以能够追加新记录的同时也能更新现有记录的方式保存记录。我们可以更新我们的 `save_record()` 方法以适应这一需求。
- en: Open up `models.py` in your editor, and let's work through making these changes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开 `models.py` 文件，让我们一步步进行这些修改。
- en: Implementing get_all_records()
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 `get_all_records()`
- en: 'Let''s start a new method in `CSVModel` called `get_all_records()`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `CSVModel` 中开始一个新的方法，称为 `get_all_records()`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing we've done is check if the model's file exists yet (recall that
    `self.file` is a `Path` object, so we can just call `exists()` to see if it exists).
    When our users start the program each morning, the `CSVModel` generates a default
    filename pointing to a file that likely doesn't exist yet, so `get_all_records()`
    will need to handle this situation gracefully. It makes sense to return an empty
    list in this case, since there's no data if the file doesn't exist.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是检查模型文件是否存在（回想一下，`self.file` 是一个 `Path` 对象，因此我们可以直接调用 `exists()` 来查看它是否存在）。当我们的用户每天早上启动程序时，`CSVModel`
    会生成一个指向一个可能还不存在的文件的默认文件名，因此 `get_all_records()` 需要优雅地处理这种情况。在这种情况下返回一个空列表是有意义的，因为没有数据时文件不存在。
- en: 'If the file does exist, we will open it in read-only mode and get all the records.
    We could do that like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件确实存在，我们将以只读模式打开它并获取所有记录。我们可以这样做：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While not terribly efficient, pulling the entire file into memory and converting
    it into a list is acceptable in our case, since we know that our largest files
    should be limited to a mere 241 rows: 20 plots times 3 labs times 4 check sessions,
    plus a header row. That amount of data is easy work for Python, even on an old
    workstation. This method is just a little too trusting, however. We should at
    least do some sanity checks to make sure that the user has actually opened a CSV
    file containing the proper fields and not some other arbitrary file, which would
    likely crash the program.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法效率不高，但将整个文件拉入内存并转换为列表在我们的情况下是可以接受的，因为我们知道我们的最大文件应该限制在仅仅241行：20个图表乘以3个实验室乘以4个检查会话，再加上一个标题行。这么多的数据对于Python来说是小菜一碟，即使是老工作站。然而，这种方法过于信任用户。我们至少应该做一些合理性检查，以确保用户实际上打开了一个包含正确字段的CSV文件，而不是其他任意文件，这可能会使程序崩溃。
- en: 'Let''s revise the method so that it will check the file for the correct field
    structure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改这个方法，使其能够检查文件的正确字段结构：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this version, we first find any missing fields by comparing the `CSVModel.fields`
    dictionary keys to the `fieldnames` list in the CSV file. To find the missing
    fields, we''re using a simple trick involving the Python `set` type: if we convert
    both lists to `set` objects, we can subtract one from the other, leaving us with
    a `set` object containing the fields from the first list (our `fields` keys) that
    were missing from the second list (the CSV field names).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们首先通过比较`CSVModel.fields`字典的键与CSV文件中的`fieldnames`列表来查找任何缺失的字段。为了找到缺失的字段，我们使用了一个涉及Python
    `set`类型的简单技巧：如果我们将两个列表都转换为`set`对象，我们可以从其中一个减去另一个，从而得到一个包含来自第一个列表（我们的`fields`键）而第二个列表（CSV字段名）中缺失的字段的`set`对象。
- en: If `missing_fields` has any items, those are missing fields from the CSV file.
    We'll raise an exception in this case, detailing which fields are absent. Otherwise,
    we convert the CSV data to a list, as we did in our simpler version of the method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`missing_fields`有任何项，那么这些就是CSV文件中缺失的字段。在这种情况下，我们将引发一个异常，详细说明哪些字段缺失。否则，我们将像在方法简单版本中那样将CSV数据转换为列表。
- en: Python `set` objects are very useful for comparing the content of the list,
    tuple, and other sequence objects. They provide an easy way to get information
    such as the difference (items in *x* that are not in *y*) or intersection (items
    in both *x* and *y*) between two sets and allow you to compare sequences without
    respect to order.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python `set`对象在比较列表、元组和其他序列对象的内容时非常有用。它们提供了一个简单的方法来获取两个集合之间的信息，如差集（*x*中不在*y*中的项）或交集（*x*和*y*中都有的项），并允许你比较序列而不考虑顺序。
- en: Before we can return the `records` list from the method, we need to correct
    one issue; all data in a CSV file is stored as text, and read by Python as a string.
    Most of this is not a problem, since Tkinter will take care of converting strings
    to `float` or `int` as necessary. Boolean values, however, are stored in the CSV
    file as the strings `True` and `False`, and coercing these values directly back
    to `bool` doesn't work. The string `False` is a non-empty string, and all non-empty
    strings evaluate to `True` in Python.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够从方法中返回`records`列表之前，我们需要纠正一个问题；CSV文件中的所有数据都存储为文本，并由Python作为字符串读取。大多数情况下这没问题，因为Tkinter会负责将字符串转换为`float`或`int`。然而，布尔值在CSV文件中以字符串`True`和`False`的形式存储，直接将这些值强制转换为`bool`是不行的。字符串`False`是一个非空字符串，在Python中所有非空字符串都会评估为`True`。
- en: 'To fix this, let''s first define a list of strings that should be interpreted
    as `True`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们首先定义一个字符串列表，这些字符串应该被解释为`True`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Any values not in this list will be considered `False`. We'll do a case-insensitive
    comparison, so there are only lowercase values in our list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不在该列表中的值将被视为`False`。我们将进行不区分大小写的比较，因此我们的列表中只有小写值。
- en: 'Next, we create a list of model fields that are Boolean using a list comprehension,
    like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用列表推导创建一个包含布尔型模型字段的列表，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Technically, we know that Equipment Fault is our only Boolean field, so in reality,
    we could just hard-code the method to correct that field. However, it's wiser
    to design the model so that any changes to the schema will be automatically handled
    appropriately by the logic portions. If fields are added or altered, we should
    ideally only need to alter the field specification and the rest of the model code
    should behave correctly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们知道“设备故障”是我们唯一的布尔字段，所以实际上，我们只需将方法硬编码来纠正该字段即可。然而，更明智的做法是设计模型，以便任何对模式的更改都将由逻辑部分自动适当地处理。如果添加或更改了字段，我们理想情况下只需要更改字段规范，其余的模型代码应该能够正确运行。
- en: 'Now, let''s iterate through the records and correct all the Boolean fields
    in each row:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们遍历记录并纠正每行中的所有布尔字段：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For every record, we iterate through our list of the Boolean fields and check
    the field's value against our list of truthy strings, setting the value of the
    item accordingly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条记录，我们遍历布尔字段列表，并将字段的值与我们的真值字符串列表进行比较，相应地设置项的值。
- en: 'With the Boolean values fixed, we can finish our function by returning the
    list of records, like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔值固定后，我们可以通过返回记录列表来完成我们的函数，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the rows returned by this method are dictionaries in the same format
    expected by the `save_record()` method when saving data. It's good practice for
    the model to be consistent about the way it represents data. In a more robust
    model, you might even make a class to represent a row of data, though for simpler
    applications a dictionary usually serves as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法返回的行是以`save_record()`方法保存数据时预期的格式相同的字典。对于模型来说，保持数据表示方式的一致性是一种良好的实践。在一个更健壮的模型中，你甚至可以创建一个类来表示数据行，尽管对于更简单的应用，字典通常也足够好。
- en: Implementing get_record()
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现get_record()
- en: 'The `get_record()` method needs to take a row number and return a single dictionary
    containing the data for that row. Given that we are dealing in very small amounts
    of data, we can simply leverage the `get_all_records()` method we just wrote and
    take care of this in just a few lines, like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_record()`方法需要接受一个行号并返回一个包含该行数据的单个字典。鉴于我们处理的是非常少量的数据，我们可以简单地利用我们刚刚编写的`get_all_records()`方法，并在几行代码中处理这个问题，如下所示：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Keep in mind, however, that it's possible to pass a `rownum` value that doesn't
    exist in our records list; in this case, Python would raise an `IndexError` exception.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，可能传递一个不存在于我们的记录列表中的`rownum`值；在这种情况下，Python会引发`IndexError`异常。
- en: Since there's no meaningful way for us to handle that situation inside the model,
    we'll need to remember to have our controller catch this exception and deal with
    it appropriately when using this method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在模型内部处理这种情况没有有意义的方法，我们需要记住在使用此方法时让我们的控制器捕获这个异常并适当地处理它。
- en: Adding update capability to save_record()
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为save_record()添加更新功能
- en: To convert our `save_record()` method so that we can update records, the first
    thing we'll need to do is provide the ability to pass in a row number to update.
    The default will be `None`, which will indicate that the data is a new row that
    should be appended to the file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`save_record()`方法转换为可以更新记录的方法，我们首先需要提供传递行号以更新的能力。默认值将是`None`，这表示数据是新的行，应该将其附加到文件中。
- en: 'The updated method signature looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的方法签名如下所示：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our existing record-saving logic doesn't need to change, but it should only
    be run if `rownum` is `None`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现有的记录保存逻辑不需要改变，但它应该只在`rownum`为`None`时运行。
- en: 'So, the first thing to do in the method is check `rownum`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在方法中首先要做的是检查`rownum`：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If `rownum` is `None`, we''re just running our existing code: writing a header
    if the file doesn''t exist, and then appending the row to the end of the file.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`rownum`是`None`，我们只是在运行现有的代码：如果文件不存在，则写入标题，然后将行追加到文件末尾。
- en: 'In the case that the `rownum` is *not* `None`, we''ll need to update the given
    row and save the file. There are several approaches to this task, but for relatively
    small files, the simplest way to update a single row is:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`rownum`不是`None`，我们需要更新指定的行并保存文件。完成此任务有几种方法，但对于相对较小的文件，更新单行最简单的方法是：
- en: Load the entire file into a list
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个文件加载到列表中
- en: Change the row in the list
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改列表中的行
- en: Write the entire list back to a clean file
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个列表写回到一个干净的文件中
- en: That may seem inefficient, but again, we're dealing with very small amounts
    of data. A more surgical approach would only be required with much larger sets
    of data (more than should be stored in a CSV file, for sure!).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来效率不高，但再次强调，我们处理的是非常少量的数据。只有在处理大量数据时（肯定不会存储在 CSV 文件中！），才需要更精细的方法。
- en: 'So, let''s add the following code that does this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加以下代码来完成这项工作：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once again, we leverage our `get_all_records()` method to fetch the CSV file's
    content into a list. We then replace the dictionary in the requested row with
    the data dictionary provided. Finally, we open the file in write mode (`w`), which
    will clear its content and replace it with whatever content we write to the file.
    We then write the header and all records back to the empty file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次利用我们的 `get_all_records()` 方法将 CSV 文件的内容提取到列表中。然后，我们将请求行中的字典替换为提供的数据字典。最后，我们以写入模式（`w`）打开文件，这将清除其内容，并用我们写入文件的内容替换它。然后我们将标题和所有记录写回空文件。
- en: Note that the approach we're taking makes it unsafe for two users to work in
    the same CSV file simultaneously. Creating software that allows multiple users
    to edit a single file at the same time is notoriously difficult, and many programs
    simply opt to prevent it in the first place using lock files or other protection
    mechanisms. In *Chapter 12*, *Improving Data Storage with SQL*, we'll update our
    program so that multiple users can use it simultaneously.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们采取的方法使得两个用户同时在一个 CSV 文件中工作变得不安全。创建允许多个用户同时编辑单个文件的软件非常困难，许多程序最初选择通过锁文件或其他保护机制来防止这种情况。在
    *第 12 章*，*使用 SQL 改进数据存储* 中，我们将更新我们的程序，以便多个用户可以同时使用它。
- en: This method is finished, and that's all we need to change in our model to enable
    the updating and viewing of data. Now, it's time to add the necessary features
    to our GUI.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法已完成，我们只需要在我们的模型中进行以下更改，以启用数据的更新和查看。现在，是时候向我们的 GUI 添加必要的功能了。
- en: The Ttk Treeview
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ttk 树视图
- en: For users to be able to view the contents of a CSV file and select records to
    edit, we'll need to implement a new view in the application capable of displaying
    tabular data. This record list view will allow our users to browse the content
    of the file and open records for viewing or editing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够查看 CSV 文件的内容并选择记录进行编辑，我们需要在应用程序中实现一个新的视图，该视图能够显示表格数据。这个记录列表视图将允许我们的用户浏览文件内容，并打开记录进行查看或编辑。
- en: Our users are accustomed to seeing this data in a spreadsheet, laid out in a
    table-like format, so it makes sense to design our view in a similar fashion.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户习惯于以表格形式查看这些数据，类似于表格格式，因此以类似的方式设计我们的视图是有意义的。
- en: For building table-like views with selectable rows, Tkinter gives us the **Ttk
    Treeview** widget. To build our record list view, we'll need to learn about `Treeview`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建具有可选行的表格视图，Tkinter 给我们提供了 **Ttk Treeview** 小部件。为了构建我们的记录列表视图，我们需要了解 `Treeview`。
- en: Anatomy of a Treeview
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树视图的结构
- en: 'To help us explore the treeview, let''s go through a few basic terms and concepts
    related to the widget. A treeview is designed to display **hierarchical data**;
    that is, data that is organized into **nodes**, where each node can have exactly
    one parent node and zero or more child nodes. The following diagram shows an example
    of hierarchical data:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们探索树视图，让我们回顾一些与该小部件相关的基本术语和概念。树视图旨在显示 **层次数据**；也就是说，数据被组织成 **节点**，每个节点可以恰好有一个父节点和零个或多个子节点。以下图表显示了层次数据的示例：
- en: '![](img/B17578_08_01.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_08_01.png)'
- en: 'Figure 8.1: A small hierarchical data structure. Nodes 1, 2, and 3 are children
    of the root, nodes 4 and 5 are children of node 1; "value" is an attribute of
    each node.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：一个小型的层次数据结构。节点 1、2 和 3 是根节点的子节点，节点 4 和 5 是节点 1 的子节点；“值”是每个节点的属性。
- en: The `Treeview` widget displays hierarchical data in a table format; each row
    of the table represents a single node, which it calls an **item**. Each column
    of the table represents some attribute of the node. When a node has child nodes,
    those rows are displayed under their parent and can be hidden or shown by clicking
    the parent row.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview` 小部件以表格格式显示层次数据；表格的每一行代表一个单独的节点，它称之为 **项**。表格的每一列代表节点的某个属性。当一个节点有子节点时，这些行将显示在父节点下方，并且可以通过单击父节点来隐藏或显示。'
- en: 'For example, the hierarchy pictured above in a `Treeview` would look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上面的 `Treeview` 中显示的层次结构将看起来像这样：
- en: '![](img/B17578_08_02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_08_02.png)'
- en: 'Figure 8.2: The berry hierarchy displayed in a Treeview widget'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：在树视图小部件中显示的浆果层次结构
- en: Each item in a treeview is identified by a unique **item identifier** (**IID**),
    and each column by a **column identifier** (**CID**). These values are strings,
    and you can either assign them manually or let the widget choose them automatically.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 树视图中每个项目都有一个唯一的 **项目标识符**（**IID**），每个列都有一个 **列标识符**（**CID**）。这些值是字符串，你可以手动分配它们，或者让小部件自动选择它们。
- en: At the top of the treeview's columns are **header widgets**. These are buttons
    that can display the name of each column, and optionally run a callback when clicked.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在树视图中列的顶部是 **标题小部件**。这些是按钮，可以显示每列的名称，并且可选地当点击时运行回调函数。
- en: The first column of the `Treeview` widget is known as the **icon column** and
    has a CID of `#0`. It cannot be removed, nor can its CID be altered. Typically
    it contains identifying information about the item.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview` 小部件的第一列被称为 **图标列**，其 CID 为 `#0`。它不能被移除，也不能更改其 CID。通常它包含有关项目的标识信息。'
- en: Building a file browser
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建文件浏览器
- en: 'Perhaps the best example of the kind of data we can represent in a treeview
    is a filesystem tree:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在树视图中表示我们能够表示的数据的最好例子可能是一个文件系统树：
- en: Each row can represent a file or directory
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行可以代表一个文件或目录
- en: Each directory can contain additional files or directories
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个目录可以包含额外的文件或目录
- en: Each row can have additional data properties, such as permissions, size, or
    ownership information
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行可以具有额外的数据属性，例如权限、大小或所有权信息
- en: To better understand how a `Treeview` widget works, let's create a simple file
    browser.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 `Treeview` 小部件的工作原理，让我们创建一个简单的文件浏览器。
- en: 'Open a new file called `treeview_demo.py` and start with this template:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个名为 `treeview_demo.py` 的新文件，并从以下模板开始：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll start by getting a list of all the file paths under the current working
    directory. `Path` has a method called `glob()` that will give us such a list.
    Add this line just below the `root = tk.Tk()` line:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取当前工作目录下所有文件路径的列表。`Path` 有一个名为 `glob()` 的方法，将给我们这样一个列表。在 `root = tk.Tk()`
    行下方添加此行：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`glob()` searches a file path for files or directories matching a filesystem-matching
    expression. The expression can contain wildcard characters like `*` (which means
    "zero or more characters") and `?` (which means "a single character"). The name
    "glob" goes back to a very early Unix command, though this same wildcard syntax
    is now used across most modern operating systems'' command-line interfaces.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`glob()` 函数在文件路径中搜索匹配文件系统匹配表达式的文件或目录。该表达式可以包含通配符字符，如 `*`（表示“零个或多个字符”）和 `?`（表示“单个字符”）。虽然“glob”这个名字可以追溯到非常早期的
    Unix 命令，但这个相同的通配符语法现在被用于大多数现代操作系统命令行界面中。'
- en: '`Path(''.'')` creates a path object referencing the current working directory,
    and `**/*` is a special wildcard syntax that recursively grabs all objects under
    the path. Given that wildcard expression, the `glob()` method returns a list of
    the `Path` objects that include every directory and file under our current directory.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path(''.'')` 创建一个引用当前工作目录的路径对象，`**/*` 是一种特殊的通配符语法，它可以递归地获取路径下的所有对象。给定这个通配符表达式，`glob()`
    方法返回一个包含当前目录下每个目录和文件的 `Path` 对象列表。'
- en: Creating and configuring a Treeview
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和配置 Treeview
- en: 'Now that we have some data to display, let''s create a `Treeview` widget to
    display it, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些要显示的数据，让我们创建一个 `Treeview` 小部件来显示它，如下所示：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Like any Tkinter widget, the first argument to `Treeview` is its parent widget.
    Next, we''ve passed in a list of strings to the `column` argument. These are the
    CID values for our columns. Note that these columns are *in addition to* the default
    icon column, so this `Treeview` widget will have 3 total columns: `#0`, `size`,
    and `modified`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何 Tkinter 小部件一样，`Treeview` 的第一个参数是其父小部件。接下来，我们向 `column` 参数传递了一个字符串列表。这些是我们列的
    CID 值。请注意，这些列是 **除了** 默认图标列之外的，所以这个 `Treeview` 小部件将总共有 3 列：`#0`、`size` 和 `modified`。
- en: 'The `selectmode` argument determines how users can select items in the tree.
    The different options for `selectmode` are shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectmode` 参数决定了用户如何在树中选取项目。`selectmode` 的不同选项如下所示：'
- en: '| Value | Behavior |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 行为 |'
- en: '| `"none"` | No selections can be made |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `"none"` | 不能进行选择 |'
- en: '| `"browse"` | User can select one item only |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `"browse"` | 用户只能选择一个项目 |'
- en: '| `"extended"` | User can select multiple items |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `"extended"` | 用户可以选择多个项目 |'
- en: In this case, we're preventing selection, so we set it to `none` (note that
    this is the string `none`, not a `None` object).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在防止选择，因此将其设置为 `none`（注意，这将是字符串 `none`，而不是 `None` 对象）。
- en: 'While Tkinter will add a column for each CID value, it will not automatically
    give those columns a header label. We need to do that ourselves using the `Treeview.heading()`
    method, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Tkinter 会为每个 CID 值添加一个列，但它不会自动给这些列提供标题标签。我们需要自己使用 `Treeview.heading()` 方法来做这件事，如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The treeview's `heading()` method allows us to configure the column heading
    widget; it takes the CID of the column we wish to operate on, followed by any
    number of keyword arguments to configure the header widget.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 树形视图的 `heading()` 方法允许我们配置列标题小部件；它接受我们希望操作的列的 CID，后跟任意数量的关键字参数来配置标题小部件。
- en: 'Those attributes can include:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性可以包括：
- en: '`text`: The text displayed for the heading. By default, it''s blank.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：标题显示的文本。默认情况下，它是空的。'
- en: '`anchor`: The alignment of the text; it can be any of eight cardinal directions
    or `center`, specified as strings or Tkinter constants.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor`：文本的对齐方式；可以是八个基本方向之一或 `center`，指定为字符串或 Tkinter 常量。'
- en: '`command`: A callback to run when the heading is clicked. This might be used
    to order the rows by that column, or select all the values in the column, for
    example.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：当点击标题时运行的回调函数。这可能用于按该列排序行，或选择列中的所有值，例如。'
- en: '`image`: An image to display in the heading.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：要在标题中显示的图像。'
- en: In addition to configuring the headers, we can configure some attributes that
    affect the entire column using the `Treeview.column()` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置标题外，我们还可以使用 `Treeview.column()` 方法配置影响整个列的一些属性。
- en: 'For example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this code, we've set `stretch=True` in the first column, which will cause
    it to expand to fill any available space. Then we've set the `width` value on
    the `size` column to `200` pixels.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们在第一列中设置了 `stretch=True`，这将导致它扩展以填充任何可用空间。然后我们在 `size` 列上设置了 `width`
    值为 `200` 像素。
- en: 'The column parameters that can be set include:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置的列参数包括：
- en: '`stretch`: Whether or not to expand this column to fill the available space.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretch`：是否将此列扩展以填充可用空间。'
- en: '`width`: The width of the column in pixels.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`：列的像素宽度。'
- en: '`minwidth`: The minimum width to which the column can be resized, in pixels.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minwidth`：列可以调整大小的最小宽度，以像素为单位。'
- en: '`anchor`: The alignment of the text in the column. Can be any of eight cardinal
    directions or `center`, specified as strings or Tkinter constants.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor`：列中文本的对齐方式。可以是八个基本方向之一或 `center`，指定为字符串或 Tkinter 常量。'
- en: 'With the treeview configured, let''s add it into the GUI, like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好树形视图后，让我们将其添加到 GUI 中，如下所示：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Populating a Treeview with data
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充 Treeview 的数据
- en: Now that we've finished the GUI portion, our view needs to be filled with data.
    Populating a `Treeview` widget with data is done one row at a time using its `insert()`
    method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 GUI 部分，我们的视图需要填充数据。使用 `Treeview` 小部件的 `insert()` 方法逐行填充数据。
- en: 'A basic call to the `insert()` method looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 方法的基本调用如下：'
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first argument specifies the **parent item** for the inserted row. This
    is *not* the parent widget, but rather the IID of the parent node under which
    the inserted node belongs in the hierarchical structure. For top-level items,
    this value should be an empty string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定了插入行的 **父项**。这 **不是** 父小部件，而是插入节点所属的层次结构中父节点的 IID。对于顶级项，此值应该是一个空字符串。
- en: The next argument specifies where the item should be inserted under its parent
    node with respect to its sibling nodes. It can be either a numerical index or
    the string `end`, which places the item at the end of the list.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数指定了项目相对于其兄弟节点在其父节点下的插入位置。它可以是数值索引或字符串 `end`，它将项目放置在列表的末尾。
- en: 'After those positional arguments, `insert()` takes a number of keyword arguments,
    which can include:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些位置参数之后，`insert()` 接受多个关键字参数，这些参数可以包括：
- en: '`text`: This is the value to be shown in the icon column (CID `#0`).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：这是要在图标列（CID `#0`）中显示的值。'
- en: '`values`: This is a list of values for the remaining columns. Note that we
    need to specify them in order.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`：这是剩余列的值列表。请注意，我们需要按顺序指定它们。'
- en: '`image`: This is an image object to display in the far left of the icon column.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：这是要在图标列的左侧显示的图像对象。'
- en: '`iid`: The row''s IID string. This will be automatically assigned if you don''t
    specify it.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iid`：行的 IID 字符串。如果您不指定它，将自动分配。'
- en: '`open`: For nodes with children, this sets if the row is initially open (displaying
    child items) or not.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`：对于有子节点的节点，这设置行是否最初是打开的（显示子项目）或不是。'
- en: '`tags`: A list of tag strings. We''ll learn more about tags when we discuss
    styling in *Chapter 9*, *Improving the Look with Styles and Themes*.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags`：一个标签字符串列表。当我们讨论第9章中的样式时，我们将了解更多关于标签的信息，*使用样式和主题改进外观*。'
- en: 'To insert our file paths into the treeview, let''s iterate the `paths` list
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的文件路径插入到树视图中，让我们按照以下方式遍历`paths`列表：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Before calling `insert()`, we need to extract and prepare some data from the
    `path` object. The `path.stat()` method will give us an object containing various
    file information, from which we'll extract the size and modified time. `path.parent`
    provides us with the containing path; however, we need to change the name of the
    root path (currently a single dot) to an empty string, which is how `Treeview`
    represents the root node.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`insert()`之前，我们需要从`path`对象中提取和准备一些数据。`path.stat()`方法会给我们一个包含各种文件信息的对象，我们将从中提取大小和修改时间。`path.parent`为我们提供了包含路径；然而，我们需要将根路径（目前是一个点）的名称更改为空字符串，这是`Treeview`表示根节点的方式。
- en: 'Now, still in the `for` loop, we add the `insert()` method call as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在`for`循环中，我们按照以下方式添加`insert()`方法调用：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using the path string as the IID, we can then specify it as a parent for
    its child objects. We use only the path name (that is, the file or directory name
    without the containing path) as our display value, then retrieve `st_size` and
    `st_mtime` from the `stat()` data for populating the size and modification time
    columns.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用路径字符串作为IID，我们可以将其指定为其子对象的父节点。我们只使用路径名称（即，不带包含路径的文件或目录名称）作为我们的显示值，然后从`stat()`数据中检索`st_size`和`st_mtime`以填充大小和修改时间列。
- en: 'Run this script and you should see a simple file tree browser that looks something
    like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本，你应该会看到一个简单的文件树浏览器，看起来像这样：
- en: '![Figure 8.1: Our Treeview filebrowser running on Ubuntu Linux](img/B17578_08_03.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：我们的Treeview文件浏览器在Ubuntu Linux上运行](img/B17578_08_03.png)'
- en: 'Figure 8.3: Our Treeview widget file browser running on Ubuntu Linux'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：我们的Treeview小部件文件浏览器在Ubuntu Linux上运行
- en: Sorting Treeview records
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序Treeview记录
- en: The `Treeview` widget doesn't offer any kind of sorting functionality by default,
    but we can implement sorting by adding a callback function to the column headers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview`小部件默认不提供任何排序功能，但我们可以通过向列标题添加回调函数来实现排序。'
- en: Sorting through hierarchical data of an unknown depth is a bit tricky; to do
    it, we're going to write a **recursive function**. A recursive function is a function
    that calls itself, and they are most commonly employed when dealing with hierarchical
    data of unknown depth.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对未知深度的分层数据进行排序有点棘手；为了做到这一点，我们将编写一个**递归函数**。递归函数是一种调用自身的函数，它们在处理未知深度的分层数据时最常被使用。
- en: 'Let''s start by defining our function signature, like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们的函数签名，如下所示：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This `sort()` function takes a `Treeview` widget, a CID string of the column
    we want to sort on, an optional parent node IID, and a Boolean value indicating
    if the sort should be reversed. The default value for `parent` is an empty string,
    indicating the root of the hierarchy.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`sort()`函数接受一个`Treeview`小部件、我们想要排序的列的CID字符串、一个可选的父节点IID和一个布尔值，表示是否应该反转排序。`parent`的默认值是一个空字符串，表示层次结构的根。
- en: 'The first thing we''re going to do is build a list of tuples, each containing
    the value we want to sort on and the IID of the row containing that value, like
    so:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是构建一个元组列表，每个元组包含我们想要排序的值和包含该值的行的IID，如下所示：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Treeview.get_children()` method retrieves a list of IID strings that are
    immediate children of the given `parent` IID. For example, in our file browser,
    calling `tv.get_children('')` would return a list of all the IID values for the
    files and folders in the current directory (not in any sub-directories).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview.get_children()`方法检索一个IID字符串列表，这些字符串是给定`parent` IID的直接子代。例如，在我们的文件浏览器中，调用`tv.get_children('''')`将返回当前目录（不在任何子目录中）中所有文件和文件夹的IID值列表。'
- en: Once we have this list, we iterate through it and start building a list we can
    sort on. To do this, we need to retrieve the contents of the sort column for each
    IID. Rather confusingly, this is done using the `Treeview.set()` method. `Treeview.set()`
    can be called with either two or three arguments, the first two always being the
    IID and CID of the cell we want to reference. If the third argument is present,
    `set()` will write that value to the cell. If it is omitted, `set()` will return
    the current value of that cell. There is no `Treeview.get()` method, so this is
    how we retrieve the value of a particular cell.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个列表，我们就遍历它，并开始构建一个我们可以对其进行排序的列表。为此，我们需要为每个 IID 获取排序列的内容。这有点令人困惑，这是通过
    `Treeview.set()` 方法完成的。`Treeview.set()` 可以用两个或三个参数调用，前两个始终是我们想要引用的单元格的 IID 和 CID。如果第三个参数存在，`set()`
    将将该值写入单元格。如果省略，`set()` 将返回该单元格的当前值。没有 `Treeview.get()` 方法，所以我们通过这种方式检索特定单元格的值。
- en: However, `set()` cannot be called on CID `#0`, even if we only want to retrieve
    the value. So we have added a check in case the user is sorting on that column,
    and return the IID instead. After obtaining the contents of the table cell, we
    add it with its IID to the `sort_index` list.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使我们只想检索值，也不能在 CID `#0` 上调用 `set()`。因此，我们添加了一个检查，以防用户正在对该列进行排序，并返回 IID。在获取表格单元格的内容后，我们将它及其
    IID 添加到 `sort_index` 列表中。
- en: 'Now, we can sort the index:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对索引进行排序：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because our table cell value is first in each tuple, the tuples will be sorted
    on it by default. Note that we've passed in the `reverse` value, to indicate which
    direction the list will be sorted in.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的表格单元格值在每个元组中都是第一个，所以默认情况下元组将根据它进行排序。请注意，我们已传递了 `reverse` 值，以指示列表的排序方向。
- en: 'Now that we have a sorted list, we''ll need to move each node accordingly.
    Add this code next:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个排序后的列表，我们需要相应地移动每个节点。接下来添加以下代码：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `enumerate()` function returns a tuple containing each item in the list
    with an integer indicating its index in the list. Since each item in our list
    is already a tuple, we''re expanding that as well, giving us three variables:
    `index`, the index number of the list item; `_`, the sort value (which we no longer
    need, so we''re naming it with an underscore); and `iid`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()` 函数返回一个包含列表中每个项目及其在列表中索引的整数的元组。由于我们列表中的每个项目已经是一个元组，所以我们也将它展开，从而得到三个变量：`index`，列表项的索引数字；`_`，排序值（我们不再需要它，所以我们用下划线命名它）；以及
    `iid`。'
- en: 'For each item in the list, we call `Treeview.move()`, which takes three arguments:
    the IID of the row we want to move, the parent node to which we want to move it,
    and the index under that node into which it should be inserted. This will effectively
    sort the rows according to the order of the `sort_index` list.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的每个项目，我们调用 `Treeview.move()`，它接受三个参数：我们想要移动的行的 IID、我们想要移动到的父节点，以及在该节点下应该插入的索引。这将有效地根据
    `sort_index` 列表的顺序对行进行排序。
- en: 'So far, though, this has only sorted the immediate children of our root node.
    Now it is time to employ recursion so that we can sort all the child nodes; this
    takes only one additional line of code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，这仅对根节点的直接子节点进行了排序。现在是我们使用递归以对所有子节点进行排序的时候了；这只需要一行额外的代码：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The last line of the `for` loop calls the `sort()` function again, this time
    passing in the child IID as the parent, and all other arguments the same. `sort()`
    will continue to call itself recursively until it reaches a node that has no children.
    In the case where a node has no children, that call to `sort()` will return without
    doing anything. In this way, all sub-directories containing files will be individually
    sorted by their own call to `sort()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环的最后一行再次调用 `sort()` 函数，这次传入子 IID 作为父节点，并传递所有其他相同的参数。`sort()` 将继续递归调用自身，直到达到没有子节点的节点。在没有子节点的情况下，对
    `sort()` 的调用将返回而不做任何事情。这样，所有包含文件的子目录都将通过它们自己的 `sort()` 调用单独排序。'
- en: 'To use our `sort()` function, we need to bind it to our column headers; we
    can do that once again by calling the `Treeview.heading()` method, like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的 `sort()` 函数，我们需要将其绑定到我们的列标题上；我们可以通过再次调用 `Treeview.heading()` 方法来实现，如下所示：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here we're looping through each of our CID values, calling the `heading()` method
    to add a `command` argument to the heading. We're doing this in the form of a
    `lambda` function with a default argument for the CID.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在遍历每个 CID 值，调用 `heading()` 方法向标题添加一个 `command` 参数。我们以具有默认 CID 的 `lambda`
    函数的形式这样做。
- en: Why use a default argument to pass in the CID? The body of a `lambda` function
    is evaluated using **late binding**, meaning that the value of the variables isn't
    established until the moment the body is run. By that point, `cid` will be the
    last value in the list (`'modified'`) no matter which column is calling the callback.
    The signature of the `lambda` function, however, is evaluated immediately, meaning
    the default value of `col` will be whatever `cid` is when we create the function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用默认参数来传递CID？`lambda`函数的主体使用**延迟绑定**进行评估，这意味着变量的值直到主体运行时才确定。到那时，`cid`将是列表中的最后一个值（`'modified'`），无论哪个列调用回调。然而，`lambda`函数的签名立即评估，这意味着`col`的默认值将是我们创建函数时`cid`的值。
- en: One last fix to make to this function; typically, a sort will reverse with a
    second click of the header. We can implement this with a second set of calls to
    the `heading()` method inside the `sort()` function that will replace the `lambda`
    function with a reversed version.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对此函数的最后一个小修复；通常，点击标题的第二次点击将反转排序。我们可以在`sort()`函数内部通过调用`heading()`方法的第二组调用来实现这一点，这将用反转版本替换`lambda`函数。
- en: 'Inside the `sort()` function, add this code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sort()`函数内部，添加以下代码：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since the function is called recursively, we do not want to call this more than
    once per sorting; so, we'll only run this code for the root node, indicated by
    the `parent` value being a blank string. Inside that block, we reset the `lambda`
    function on the column being sorted, this time setting `reverse` to be the opposite
    of its current value.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该函数是递归调用的，我们不希望在每次排序时调用它超过一次；因此，我们只为根节点运行此代码，由`parent`值是空字符串表示。在该块内部，我们重置正在排序的列上的`lambda`函数，这次将`reverse`设置为当前值的相反。
- en: Now when you run the application, you should be able to sort in both directions
    by clicking the headers of each column.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行应用程序时，你应该能够通过点击每一列的标题以两个方向进行排序。
- en: Note that even though two of the columns contain numbers, they are sorted in
    **lexical order** – that is, as though they were strings, not numerical values.
    This is because the values put into a `Treeview` widget are implicitly converted
    to strings, so the sort value returned by `Treeview.set()` is a string. To sort
    these using a numerical sort, you would need to cast them back to integer or float
    values before sorting.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管两个列包含数字，但它们是按**字典顺序**排序的——也就是说，就像它们是字符串一样，而不是数值。这是因为放入`Treeview`小部件的值隐式转换为字符串，所以`Treeview.set()`返回的排序值是一个字符串。要使用数值排序对这些进行排序，您需要在排序之前将它们转换回整数或浮点值。
- en: Using Treeview virtual events
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Treeview虚拟事件
- en: 'To make it possible to respond to user interaction with the `Treeview` widget''s
    items, the widget includes three virtual events, shown in this table:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够响应用户与`Treeview`小部件项目的交互，该小部件包括三个虚拟事件，如表中所示：
- en: '| Event | Generated |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 生成 |'
- en: '| `<<TreeviewSelect>>` | When the user selects an item |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `<<TreeviewSelect>>` | 当用户选择一个项目时 |'
- en: '| `<<TreeviewOpen>>` | When a parent item is expanded to display child items
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `<<TreeviewOpen>>` | 当一个父项目展开以显示子项目时 |'
- en: '| `<<TreeviewClose>>` | When an open parent item is closed again |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `<<TreeviewClose>>` | 当一个打开的父项目再次关闭时 |'
- en: 'For example, we can use these events to display some directory information
    in a status bar when the user opens a directory. First, let''s add a status bar
    to the application:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用这些事件在用户打开目录时在状态栏中显示一些目录信息。首先，让我们向应用程序添加一个状态栏：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we''ll create a callback for the event that will get some information
    about the opened directory and display it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为获取有关打开目录的信息并显示的事件创建一个回调：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When a user clicks on an item to open it, that item gains focus, so we can use
    the treeview's `focus()` method to get the IID of the item that was clicked on.
    We've converted that to a `Path` and calculated the number of child objects in
    the directory using the `Path` object's `iterdir()` method. Then, we update the
    `status` variable with that information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击一个项目以打开它时，该项目获得焦点，因此我们可以使用treeview的`focus()`方法来获取被点击项目的IID。我们将它转换为`Path`，并使用`Path`对象的`iterdir()`方法计算目录中的子对象数量。然后，我们使用该信息更新`status`变量。
- en: 'Now, we can bind this callback to the appropriate virtual events, like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将此回调绑定到适当的虚拟事件，如下所示：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In addition to binding the open event to our callback, we've bound the close
    event to a `lambda` function that clears the status control variable. Now, run
    the demo script and click on a directory. You should see some information show
    up in the status bar. Click it again and the information goes away.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将打开事件绑定到我们的回调函数外，我们还把关闭事件绑定到一个清除状态控制变量的 `lambda` 函数。现在，运行演示脚本并点击一个目录。你应该会在状态栏中看到一些信息。再次点击它，信息就会消失。
- en: Implementing a record list with Treeview
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Treeview 实现记录列表
- en: 'Now that we understand how to use the `Treeview` widget, it''s time to implement
    a GUI that will allow us to browse the records in the CSV file and open them for
    editing. Let''s take a moment to plan out what it is that we need to create:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用 `Treeview` 小部件，是时候实现一个 GUI，它将允许我们浏览 CSV 文件中的记录并打开它们进行编辑。让我们花点时间来规划我们需要创建的内容：
- en: We want to lay out the CSV data in a table structure, similar to how it would
    look in a spreadsheet. This will be a flat table, not a hierarchy.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望将 CSV 数据以表格结构进行布局，类似于它在电子表格中的样子。这将是一个平面表格，而不是一个层次结构。
- en: Each table row will represent a record in the file. When a user double-clicks
    the row, or highlights it and presses Enter, we want the record form to open with
    the selected record.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表格行将代表文件中的一个记录。当用户双击行或高亮显示并按 Enter 键时，我们希望记录表单以选定的记录打开。
- en: We don't really need to show every field in the table, since its purpose is
    merely to locate records for editing. Instead, we'll show only the rows that uniquely
    identify a record to the user. Namely, those are `Date`, `Time`, `Lab`, and `Plot`.
    We can also show the CSV row number.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实际上不需要在表中显示每个字段，因为它的目的仅仅是定位记录以进行编辑。相反，我们将只显示那些对用户唯一标识记录的行。具体来说，这些是 `Date`（日期）、`Time`（时间）、`Lab`（实验室）和
    `Plot`（绘图）。我们还可以显示 CSV 行号。
- en: There isn't really a need to sort the data, so we won't implement sorting. The
    point is to visualize the CSV file, and its order shouldn't change.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上没有必要对数据进行排序，所以我们不会实现排序。目的是可视化 CSV 文件，其顺序不应该改变。
- en: To make all of this work, we'll first implement a widget, using a treeview,
    to display all the records and allow the selection of a record. Then, we'll go
    through the rest of the application components and integrate the new functionality.
    Let's get started!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有这些工作，我们首先将实现一个使用树视图显示所有记录并允许选择记录的小部件。然后，我们将通过应用程序的其他组件并集成新的功能。让我们开始吧！
- en: Creating the RecordList class
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 RecordList 类
- en: 'We''ll begin building our `RecordList` class by subclassing `tkinter.Frame`,
    just as we did with our record form:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过从 `tkinter.Frame` 继承来开始构建我们的 `RecordList` 类，就像我们处理记录表单时做的那样：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To save ourselves from some repetitious code, we''ll define our treeview''s
    column properties and defaults as class attributes. This will also make it easier
    to tweak them later to suit our evolving needs. Add these properties to the class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复代码，我们将定义树视图的列属性和默认值作为类属性。这也会使我们在以后更容易调整它们以满足不断变化的需求。将这些属性添加到类中：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Recall that we're going to be displaying `Date`, `Time`, `Lab`, and `Plot`.
    For the `#0` column, we'll show the CSV row number. We've also set the `width`
    and `anchor` values for some columns and configured the `Date` field to `stretch`.
    We'll use these values when configuring the `Treeview` widget in the `RecordList`
    class's initializer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们将显示 `Date`（日期）、`Time`（时间）、`Lab`（实验室）和 `Plot`（绘图）。对于 `#0` 列，我们将显示 CSV
    行号。我们还为一些列设置了 `width`（宽度）和 `anchor`（锚点）值，并将 `Date` 字段配置为 `stretch`（拉伸）。在 `RecordList`
    类的初始化器中配置 `Treeview` 小部件时，我们将使用这些值。
- en: 'Moving on to the initializer method, let''s begin it as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是初始化方法，让我们这样开始：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, after running the superclass initializer, we've configured the grid layout
    to expand the first row and first column. This is where our `Treeview` widget
    will be placed, so we want it to take up any available space on the frame.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在运行超类初始化器之后，我们已配置网格布局以扩展第一行和第一列。这就是我们的 `Treeview` 小部件将被放置的地方，因此我们希望它能够占据框架上的任何可用空间。
- en: Configuring a Treeview widget
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Treeview 小部件
- en: 'Now we''re ready to create our `Treeview` widget, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建我们的 `Treeview` 小部件，如下所示：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we've created a `Treeview` widget and added it to the frame's layout.
    We've generated the `columns` list by retrieving the keys from the `column_defs`
    dictionary and excluding the first entry (`#0`). Remember that `#0` is automatically
    created and should not be included in the `columns` list. We're also choosing
    the `browse` selection mode so that users can select only individual rows of the
    CSV file. This will be important in the way we communicate back to the controller.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `Treeview` 小部件并将其添加到框架的布局中。我们通过从 `column_defs` 字典中检索键来生成 `columns`
    列表，并排除了第一个条目（`#0`）。请记住，`#0` 是自动创建的，不应包含在 `columns` 列表中。我们还选择了 `browse` 选择模式，以便用户只能选择
    CSV 文件的单独行。这将在我们与控制器通信的方式中非常重要。
- en: 'Next, we''ll configure the columns and headings of the `Treeview` widget by
    iterating through the `column_defs` dictionary:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过遍历 `column_defs` 字典来配置 `Treeview` 小部件的列和标题：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For each entry in `column_defs`, we're extracting the configuration values specified,
    then passing them to `Treeview.heading()` or `Treeview.column()` as appropriate.
    If the values aren't specified in the dictionary, the class default values will
    be used.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `column_defs` 中的每个条目，我们正在提取指定的配置值，然后根据适当的情况将它们传递给 `Treeview.heading()` 或
    `Treeview.column()`。如果字典中没有指定值，则将使用类的默认值。
- en: 'Finally, we''re going to set up some bindings so that double-clicking or hitting
    Enter on a record will cause a record to be opened, like so:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将设置一些绑定，以便双击或按 Enter 键在记录上会导致打开记录，如下所示：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The event `<Double-1>` refers to double-clicking mouse button 1 (that is, the
    left mouse button), while the `<Return>` event signifies striking the Return or
    Enter key (depending on how it''s labeled on your hardware). These are both bound
    to an instance method called `_on_open_record()`. Let''s go ahead and implement
    that method, like so:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 事件 `<Double-1>` 指的是鼠标按钮 1 的双击（即左键），而 `<Return>` 事件表示按下 Return 或 Enter 键（取决于您的硬件上的标签）。这两个事件都绑定到一个名为
    `_on_open_record()` 的实例方法。让我们继续实现该方法，如下所示：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since opening a record is something that happens outside the `RecordList` class,
    we''re simply going to generate a custom event called `<<OpenRecord>>` that our
    `Application` class can listen for. Of course, `Application` will need to know
    which record to switch to, so we''ll need a way for it to retrieve the currently
    selected row from the table. We''ll do this using a feature of Python classes
    called a **property**. A class property appears to outside code to be a regular
    attribute, but runs a method to determine its value whenever it is evaluated.
    We could use a method here, of course, but using a property simplifies access
    for code outside the class. To create a property, we need to write a method that
    takes only `self` as an argument and returns a value, then use the `@property`
    decorator on it. We''ll call our property `selected_id`; add it to the `RecordList`
    class like so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于打开记录是在 `RecordList` 类外部发生的，我们只是简单地生成一个名为 `<<OpenRecord>>` 的自定义事件，我们的 `Application`
    类可以监听它。当然，`Application` 需要知道要切换到哪个记录，因此我们需要一种方法让它能够从表中检索当前选中的行。我们将使用 Python 类的一个特性，称为**属性**。类属性在外部代码中看起来像是一个常规属性，但在每次评估时都会运行一个方法来确定其值。我们当然可以使用方法，但使用属性简化了类外部的访问。要创建一个属性，我们需要编写一个只接受
    `self` 作为参数的方法并返回一个值，然后使用 `@property` 装饰器。我们将我们的属性命名为 `selected_id`；将其添加到 `RecordList`
    类中，如下所示：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this method, we first retrieve a list of selected items using the `selection()`
    method. This method always returns a list, even when only one item is selected
    (and even when only one item *can* be selected). Since we only want to return
    one IID, we retrieve item 0 from the list if it exists, or `None` if nothing is
    selected. Remember that the IID of each row in our treeview is the CSV row number
    *as a string*. We'll want to convert that to an integer so that the controller
    can easily use it to locate the CSV record from the model.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先使用 `selection()` 方法检索所选项目的列表。此方法始终返回一个列表，即使只选择了一个项目（即使只有一个项目*可以*被选择）。由于我们只想返回一个
    IID，如果列表中存在，则检索项目 0，如果没有任何选择，则返回 `None`。请记住，我们树视图中每一行的 IID 是 CSV 行号*作为字符串*。我们将希望将其转换为整数，以便控制器可以轻松地使用它从模型中定位
    CSV 记录。
- en: Adding a scrollbar for the Treeview
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 Treeview 添加滚动条
- en: Since the CSV files are going to get several hundred records long, the record
    list is bound to overflow the height of the application window, even if the application
    is maximized. If this should happen, it would be helpful for users to have a scroll
    bar to navigate the list vertically.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CSV 文件将包含数百条记录，记录列表很可能会超出应用程序窗口的高度，即使应用程序已最大化。如果发生这种情况，为用户提供一个滚动条来垂直导航列表将很有帮助。
- en: The `Treeview` widget does not have a scrollbar by default; it can be scrolled
    using the keyboard or mouse-wheel controls, but users would reasonably expect
    a scrollbar on a scrollable area like the `Treeview` to help them visualize the
    size of the list and their current position in it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview` 小部件默认没有滚动条；它可以使用键盘或鼠标滚轮控件进行滚动，但用户合理地期望在可滚动的区域（如 `Treeview`）上有一个滚动条，以帮助他们可视化列表的大小和他们在列表中的当前位置。'
- en: 'Fortunately, Ttk provides us with a `Scrollbar` widget that can be connected
    to our `Treeview` widget. Back in the initializer, let''s add one:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Ttk 为我们提供了一个可以连接到我们的 `Treeview` 小部件的 `Scrollbar` 小部件。回到初始化器，让我们添加一个：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Scrollbar` class takes two important keyword arguments:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scrollbar` 类接受两个重要的关键字参数：'
- en: '`orient`: This argument determines whether it is a horizontal or vertical scroll.
    The strings `horizontal` or `vertical` can be used, or the Tkinter constants `tk.HORIZONTAL`
    and `tk.VERTICAL`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orient`：此参数确定是水平还是垂直滚动。可以使用字符串 `horizontal` 或 `vertical`，或者使用 Tkinter 常量 `tk.HORIZONTAL`
    和 `tk.VERTICAL`。'
- en: '`command`: This argument provides a callback for scrollbar move events. The
    callback will be passed arguments describing the scroll movement that happened.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：此参数为滚动条移动事件提供回调。回调将传递描述发生的滚动运动的参数。'
- en: In this case, we set the callback to the treeview's `yview()` method, which
    is used to make the treeview scroll up and down. (The other option would be `xview()`,
    which would be used for horizontal scrolling.) The result is that when the scrollbar
    is moved, the position data is sent to `Treeview.yview()`, causing the treeview
    to scroll up and down.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将回调设置为树视图的 `yview()` 方法，该方法用于使树视图上下滚动。（另一种选择是 `xview()`，它将用于水平滚动。）结果是，当滚动条移动时，位置数据被发送到
    `Treeview.yview()`，导致树视图上下滚动。
- en: 'We also need to connect our `Treeview` back to the scrollbar:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将我们的 `Treeview` 与滚动条连接起来：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This tells the `Treeview` to send its current vertical position to the `Scrollbar`
    widget's `set()` method whenever it is scrolled. If we don't do this, our scrollbar
    won't know how far down the list we've scrolled or how long the list is, and won't
    be able to set the size or location of the bar widget appropriately.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 `Treeview` 在滚动时，将当前垂直位置发送到滚动条小部件的 `set()` 方法。如果我们不这样做，我们的滚动条将不知道我们已经滚动到列表的哪个位置，也不知道列表有多长，因此无法适当地设置条形小部件的大小或位置。
- en: 'With our `Scrollbar` widget configured, we need to place it on the frame. By
    convention, it should be just to the right of the widget being scrolled, like
    so:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了我们的 `Scrollbar` 小部件后，我们需要将其放置在框架上。按照惯例，它应该位于被滚动的小部件的右侧，如下所示：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice we set `sticky` to north, south, and west. North and south make sure
    the scrollbar stretches the entire height of the widget, and west makes sure it's
    snug against the `Treeview` widget to the left of it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们将 `sticky` 设置为北、南和西。北和南确保滚动条拉伸整个小部件的高度，而西确保它紧挨着其左侧的 `Treeview` 小部件。
- en: Populating the Treeview
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充 Treeview
- en: 'Now that we have created and configured our `Treeview` widget, we''ll need
    a way to fill it with data. Let''s create a `populate()` method to do this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建并配置了我们的 `Treeview` 小部件，我们需要一种方法来填充它。让我们创建一个 `populate()` 方法来完成这个任务：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `rows` argument will take a list of dictionaries, such as what is returned
    from the model's `get_all_records()` method. The idea is that the controller will
    fetch a list from the model and then pass it to the `RecordList` via this method.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`rows` 参数将接受一个字典列表，例如模型 `get_all_records()` 方法返回的内容。其思路是控制器将从模型获取一个列表，然后通过此方法将其传递给
    `RecordList`。'
- en: 'Before refilling `Treeview`, we need to empty it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新填充 `Treeview` 之前，我们需要清空它：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To delete records from the treeview, we just need to call its `delete()` method
    with the IID of the row we want to delete. Here, we've retrieved all row IIDs
    using `get_children()`, then passed them one by one to `delete()`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要从树视图中删除记录，我们只需调用其 `delete()` 方法，并传入要删除的行的 IID。在这里，我们已经使用 `get_children()` 获取了所有行的
    IID，然后逐个传递给 `delete()`。
- en: 'Now that the treeview is cleared, we can iterate through the `rows` list and
    populate the table:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在树形视图已被清除，我们可以遍历`rows`列表并填充表格：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first thing we do here is create a list of all the CIDs we actually want
    to fetch from each row by retrieving the treeview's `columns` value.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们首先创建一个列表，列出我们实际上想要从每一行获取的所有CID，通过检索树形视图的`columns`值。
- en: Next, we iterate through the provided data rows using the `enumerate()` function
    to generate a row number. For each row, we'll create a list of values in the proper
    order using a list comprehension, then insert the list at the end of the `Treeview`
    widget with the `insert()` method. Notice that we're just using the row number
    (converted to a string) as both the IID and text for the first column of the row.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`enumerate()`函数遍历提供的数据行以生成行号。对于每一行，我们将使用列表推导式创建一个按正确顺序排列的值列表，然后使用`insert()`方法将列表插入到`Treeview`小部件的末尾。请注意，我们只是使用行号（转换为字符串）作为行的第一列的IID和文本。
- en: The last thing we need to do in this function is a small usability tweak. To
    make our record list keyboard-friendly, we need to initially focus the first item
    so that keyboard users can immediately start to navigate it via the arrow keys.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中最后需要做的事情是一个小的可用性调整。为了使我们的记录列表键盘友好，我们需要最初将焦点放在第一个项目上，这样键盘用户就可以立即通过箭头键开始导航它。
- en: 'Doing this in a `Treeview` widget actually takes three method calls:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Treeview`小部件中执行此操作实际上需要三个方法调用：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, the `focus_set()` method moves focus to the `Treeview` widget. Next,
    `selection_set('0')` selects the first record in the list (note that the string
    `0` is the IID of the first record). Finally, `focus('0')` focuses the row with
    an IID of `0`. And, of course, we only do this if there are any rows at all; if
    we called these methods on an empty `Treeview`, we would cause an exception.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`focus_set()`方法将焦点移动到`Treeview`小部件。接下来，`selection_set('0')`选择列表中的第一个记录（注意字符串`0`是第一个记录的IID）。最后，`focus('0')`将焦点放在IID为`0`的行上。当然，我们只有在有行的情况下才这样做；如果我们对一个空的`Treeview`调用这些方法，我们将引发异常。
- en: The `RecordList` class is now complete. Now it's time to update the rest of
    the application to make use of it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordList`类现在已完成。现在是时候更新应用程序的其余部分以使用它了。'
- en: Adding the record list to the application
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将记录列表添加到应用程序
- en: 'Now that we have a model capable of reading and updating data, and a `RecordList`
    widget capable of displaying the contents of a file, we need to make changes to
    the rest of the application to enable everything to work together. Specifically,
    we''ll have to do the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个能够读取和更新数据的模型，以及一个能够显示文件内容的`RecordList`小部件，我们需要对应用程序的其余部分进行更改以使一切协同工作。具体来说，我们必须做以下事情：
- en: We'll need to update the `DataRecordForm` to be suitable for updating existing
    records as well as adding new ones.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要更新`DataRecordForm`以使其适合更新现有记录以及添加新记录。
- en: We'll need to update the layout of the `Application` window to accommodate the
    new record list.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要更新`Application`窗口的布局以适应新的记录列表。
- en: We'll need to create new `Application` callbacks to handle loading records and
    navigating the application.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建新的`Application`回调来处理记录加载和应用导航。
- en: Finally, we'll need to update the main menu with new options for the added functionality.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要更新主菜单以添加新的功能选项。
- en: Let's get started!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Modifying the record form for read and update
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改记录表单以进行读取和更新
- en: As long as we're still in `views.py`, let's scroll up to look at our `DataRecordForm`
    class and adjust it to make it capable of loading and updating existing records.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们还在`views.py`中，就让我们向上滚动查看我们的`DataRecordForm`类，并调整它使其能够加载和更新现有记录。
- en: 'Take a moment and consider the following changes we''ll need to make:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间考虑以下我们需要做出的更改：
- en: The form will need to keep track of what record it's editing, or if it's a new
    record.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该表单需要跟踪它正在编辑的记录，或者如果是一个新记录。
- en: The user will need some visual indication of what record is being edited.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要一些视觉指示来了解正在编辑的记录。
- en: The form will need some way to load in a record provided by the controller.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单需要一种方式来加载控制器提供的记录。
- en: Let's implement these changes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这些更改。
- en: Adding a current record property
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加当前记录属性
- en: 'To keep track of the current record being edited, we''ll just use an instance
    property. In the `__init__()` method, just above where the first `LabelFrame`
    widget is created, add this code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪正在编辑的当前记录，我们只需使用一个实例属性。在`__init__()`方法中，在第一个`LabelFrame`小部件创建之上，添加以下代码：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `current_record` instance attribute is initially set to `None`, which we'll
    use to indicate that no record is loaded and the form is being used to create
    a new record. When we edit a record, we'll update this value to an integer referencing
    a row in the CSV data. We could use a Tkinter variable here, but there's no real
    advantage in this case, and we wouldn't be able to use `None` as a value.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`current_record`实例属性最初设置为`None`，我们将用它来表示没有加载记录且表单正在用于创建新记录。当我们编辑记录时，我们将此值更新为引用CSV数据中行的整数。我们在这里可以使用Tkinter变量，但在这个情况下没有真正的优势，并且我们无法使用`None`作为值。'
- en: Adding a label to show what is being edited
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个标签来显示正在编辑的内容
- en: 'Since the form might now be editing an existing record or a new one, it would
    be helpful to the user to be able to see what is going on at a glance. To do that,
    let''s add a `Label` to the top of the form to display the current record being
    edited, like so:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表单现在可能正在编辑现有记录或新记录，因此用户能够一眼看出正在发生的事情将很有帮助。为此，让我们在表单顶部添加一个`Label`来显示正在编辑的当前记录，如下所示：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''re placing the new `Label` widget in `row 0`, `column 0`, which is going
    to cause the other widgets to bump down one row. This won''t affect our `Frame`
    widgets generated by `_add_frame()`, since they use implicit row numbers, but
    our Notes input and buttons will need to be moved. Let''s update those widgets
    with a new position:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新的`Label`小部件放置在`row 0`，`column 0`，这将导致其他小部件向下移动一行。这不会影响由`_add_frame()`生成的`Frame`小部件，因为它们使用隐式行号，但我们的笔记输入和按钮需要移动。让我们更新这些小部件到新的位置：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Feel free to adjust the height of the Notes field if this change pushes the
    bottom of the form off-screen on your system!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个更改导致您的系统中的表单底部超出屏幕，请随意调整笔记字段的长度！
- en: Adding a load_record() method
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加`load_record()`方法
- en: 'The last thing to add to the `DataRecordForm` class is a method for loading
    in a new record. This method will need to accept a row number and dictionary of
    data from the controller and use them to update the `current_record`, the data
    in the form, and the label at the top. This will be a public method, since it
    will be called from the controller, and it will begin like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DataRecordForm`类中最后要添加的是一种加载新记录的方法。这个方法需要接受来自控制器的一个行号和数据字典，并使用它们来更新`current_record`（表单中的数据）和顶部的标签。这将是一个公共方法，因为它将由控制器调用，并且它将如下开始：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After updating the `current_record` attribute, we check to see if `rownum` is
    `None`. Recall that this indicates we're requesting a blank form to enter a new
    record. In that case, we'll call the `reset()` method and configure the label
    to show **New Record**.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新`current_record`属性后，我们检查`rownum`是否为`None`。回想一下，这表示我们请求一个空白表单来输入新记录。在这种情况下，我们将调用`reset()`方法并配置标签以显示**新记录**。
- en: Note that our `if` condition here checks specifically whether `rownum` is `None`;
    we can't just check the truth value of `rownum`, since 0 is a valid `rownum` for
    updating!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的`if`条件专门检查`rownum`是否为`None`；我们不能仅仅检查`rownum`的真值，因为0是一个有效的更新`rownum`。
- en: 'If we do have a valid `rownum`, we''ll need it to act differently:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有有效的`rownum`，我们需要它以不同的方式行动：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this block, we first set the label appropriately with the row number we're
    editing. Then, we iterate over the form's `_vars` dictionary, retrieving matching
    values from the `data` dictionary that was passed to the function. Finally, we
    attempt to call the `trigger_focusout_validation()` method on each variable's
    input widget, since it's possible that the CSV file contains invalid data. If
    the input has no such method (that is, if we used a regular Tkinter widget rather
    than one of our validated widgets), we just do nothing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块中，我们首先使用我们正在编辑的行号适当地设置标签。然后，我们遍历表单的`_vars`字典，从传递给函数的`data`字典中检索匹配的值。最后，我们尝试在每个变量的输入小部件上调用`trigger_focusout_validation()`方法，因为CSV文件可能包含无效数据。如果没有这样的方法（也就是说，如果我们使用的是常规Tkinter小部件而不是我们验证过的小部件），我们就什么也不做。
- en: Our form is now ready to load data records!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式现在已准备好加载数据记录！
- en: Updating the application layout
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新应用程序布局
- en: We have the form ready for loading records, and we have the record list ready
    to display them. We now need to incorporate all of this into the main application.
    First, though, we need to consider how we can accommodate both forms into our
    GUI layout.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了用于加载记录的表单，并且我们有了准备显示记录的记录列表。现在，我们需要将这些全部整合到主应用程序中。不过，首先，我们需要考虑如何将这两个表单容纳到我们的GUI布局中。
- en: Back in *Chapter 2*, *Designing GUI Applications*, we listed a few options for
    widgets that can help us group GUI components and cut down on the clutter of the
    GUI. We chose to use framed boxes to organize our data entry form; could we do
    the same again?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二章*，*设计GUI应用程序*中，我们列出了一些可以帮助我们分组GUI组件并减少GUI杂乱的组件选项。我们选择使用框架盒来组织我们的数据输入表单；我们能否再次这样做？
- en: 'A quick mockup of the idea might look something like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法的快速原型可能看起来像这样：
- en: '![Figure 8.2: A layout of our application using side-by-side frames](img/B17578_08_04.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：我们的应用程序布局，使用并排框架](img/B17578_08_04.png)'
- en: 'Figure 8.4: A layout of our application using side-by-side frames'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：使用并排框架的应用程序布局
- en: This could work, but it's a lot of information on the screen at once, and the
    user doesn't really need to see all of this at the same time. The Record List
    is primarily for navigating, and the Data Entry form is for editing or entering
    data. It would probably be better if we showed only one component at a time.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能可行，但屏幕上一次显示的信息太多，用户实际上不需要同时看到所有这些信息。记录列表主要用于导航，数据输入表单用于编辑或输入数据。如果我们一次只显示一个组件可能会更好。
- en: 'Another option for organizing these two large components into the same GUI
    is the **notebook**. This type of widget can switch between multiple pages in
    a GUI by using tabs. Ttk offers us a `Notebook` widget that implements this feature;
    you''ve seen it before, back in *Chapter 1*, *Introduction to Tkinter*, when we
    looked at the IDLE configuration dialog. It can be seen here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个大型组件组织到同一个GUI中的另一种选项是**笔记本**。这种类型的小部件可以通过使用标签在GUI中切换多个页面。Ttk为我们提供了一个实现此功能的`Notebook`小部件；你之前在*第一章*，*Tkinter简介*中已经见过它，当时我们查看IDLE配置对话框。它在这里可以看到：
- en: '![Ttk Notebook tabs in IDLE''s config dialog](img/B17578_08_05.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![IDLE配置对话框中的Ttk笔记本标签](img/B17578_08_05.png)'
- en: 'Figure 8.5: Ttk Notebook tabs in IDLE''s config dialog'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：IDLE配置对话框中的Ttk笔记本标签
- en: Let's take a quick look at the Ttk `Notebook` to see how it can be used in an
    application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下Ttk的`Notebook`，看看它如何在应用程序中使用。
- en: The Ttk Notebook widget
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ttk笔记本小部件
- en: 'The `Notebook` widget is part of the `ttk` module, so we don''t need to add
    any additional imports to use it. Creating one is fairly simple, as shown here:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notebook`小部件是`ttk`模块的一部分，因此我们不需要添加任何额外的导入就可以使用它。创建一个`Notebook`小部件相当简单，如下所示：'
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To add pages to the widgets, we need to create some child widgets. Let''s create
    a couple of `Label` widgets with some informative content:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要向小部件添加页面，我们需要创建一些子小部件。让我们创建几个带有一些信息内容的`Label`小部件：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we've created a couple of labels to be pages in our notebook. Typically
    your notebook page widgets would probably be `Frame` objects or subclasses like
    our `RecordList` or `DataRecordForm` components, but any widget can be used.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一些标签作为笔记本中的页面。通常，你的笔记本页面小部件可能是`Frame`对象或我们的`RecordList`或`DataRecordForm`组件的子类，但任何小部件都可以使用。
- en: 'Rather than use a geometry manager to place these components in the notebook,
    we instead use the widget''s `add()` method, like so:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用几何管理器将这些组件放置在笔记本中，而是使用小部件的`add()`方法，如下所示：
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `add()` method creates a new page containing the given widget at the end
    of the notebook. If we wanted to insert the page somewhere other than the end,
    we could also use the `insert()` method, like so:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`方法创建一个包含给定小部件的新页面，并将其放置在笔记本的末尾。如果我们想将页面插入到其他位置，我们也可以使用`insert()`方法，如下所示：'
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This method is identical, except that it takes an index number as the first
    argument. The page will be inserted at that index.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与之前相同，只是它将索引号作为第一个参数。页面将插入到该索引位置。
- en: 'Both methods take a number of keyword arguments to configure the page and its
    tab, shown here:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都接受多个关键字参数来配置页面及其标签，如下所示：
- en: '| Argument | Values | Description |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `text` | String | The text shown on the label. By default, tabs are blank.
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 字符串 | 标签上显示的文本。默认情况下，标签是空的。 |'
- en: '| `padding` | Integer | Padding in pixels to add around the widget on the page.
    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `padding` | 整数 | 在页面上的小部件周围添加的像素间距。 |'
- en: '| `sticky` | Cardinal values (`N`, `S`, `E`, `W`) | Where to stick the widget
    on the notebook page. `NSEW` by default. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `sticky` | 基数值（`N`，`S`，`E`，`W`） | 在笔记本页面上粘滞小部件的位置。默认为`NSEW`。 |'
- en: '| `underline` | Integer | Index of a letter in the `text` to bind for keyboard
    traversal. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `underline` | 整数 | 在`text`中绑定键盘遍历的字母索引。 |'
- en: '| `image` | Tkinter `Photoimage` | An image to display on the tab. See *Chapter
    9*, *Improving the Look with Styles and Themes*. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `image` | Tkinter `Photoimage` | 在标签上显示的图像。见*第9章*，*使用样式和主题改进外观*。'
- en: '| `compound` | `LEFT`, `RIGHT`, `CENTER`, `TOP`, `BOTTOM` | If both text and
    image are specified, where to display the image in relation to the text. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `compound` | `LEFT`, `RIGHT`, `CENTER`, `TOP`, `BOTTOM` | 如果指定了文本和图像，则显示图像的位置相对于文本。
    |'
- en: The `underline` option is one we've seen before on other widgets (see *Chapter
    3*, *Creating Basic Forms with Tkinter and Ttk Widgets*); however, in the `ttk.Notebook`
    widget, the option actually sets up a keyboard binding when we use it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`underline`选项是我们之前在其他小部件上见过的（见*第3章*，*使用Tkinter和Ttk小部件创建基本表单*）；然而，在`ttk.Notebook`小部件中，当使用该选项时，实际上会设置键盘绑定。'
- en: 'Let''s try that out on our example notebook:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的示例笔记本上尝试一下：
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `tab()` method, similar to a widget's `config()` method, allows us to change
    configuration options on the tab after we've already added it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`tab()`方法类似于小部件的`config()`方法，允许我们在添加标签后更改配置选项。'
- en: In this case, we're specifying `underline=0` for both tabs, meaning the first
    letter of each tab's `text` string will be underlined. In addition, a keybinding
    will be created so that the key combination of Alt plus the underlined letter
    will switch to the matching tab. For example, in our application, we underlined
    letter 0 in the tab labeled **Banana**, so Alt-B will switch to that tab; we also
    underlined letter 0 in the tab labeled **Plantain**, so Alt-P will switch to the
    **Plantain** tab.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们为两个标签都指定了`underline=0`，这意味着每个标签的`text`字符串的第一个字母将被下划线。此外，将创建一个键绑定，以便按下Alt键加上下划线字母的组合可以切换到相应的标签。例如，在我们的应用程序中，我们在标签**Banana**中下划线字母0，所以Alt-B将切换到该标签；我们还在标签**Plantain**中下划线字母0，所以Alt-P将切换到**Plantain**标签。
- en: 'In addition to these bindings, we can enable general keyboard traversal of
    the notebook by calling its `enable_traversal()` method, like so:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些绑定之外，我们还可以通过调用其`enable_traversal()`方法来启用笔记本的通用键盘遍历，如下所示：
- en: '[PRE57]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If this method is called, Control-Tab will cycle through the tabs from left
    to right, and Shift-Control-Tab will cycle through them right to left.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用此方法，Control-Tab将从左到右循环遍历标签页，而Shift-Control-Tab将按从右到左的顺序遍历它们。
- en: 'Our code may sometimes need to select a tab; for this, we can use the `select()`
    method, like so:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码有时可能需要选择一个标签；为此，我们可以使用`select()`方法，如下所示：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this case, we''re passing in the integer `0`, which indicates the first
    tab. We could also pass in the name of the widget contained by the tab, like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们传递整数`0`，表示第一个标签。我们也可以传递包含在标签中的小部件的名称，如下所示：
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This works for the `tab()` method as well, and any method that requires a tab
    ID.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于`tab()`方法以及任何需要标签ID的方法。
- en: The `Notebook` widget has a `<<NotebookTabChanged>>` virtual signal that is
    generated whenever the user changes tabs. You might use this to refresh pages
    or display help messages, for example.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notebook`小部件有一个`<<NotebookTabChanged>>`虚拟信号，每当用户更改标签时都会生成。您可能可以使用此功能刷新页面或显示帮助信息，例如。'
- en: Now that we're familiar with the notebook, let's incorporate one into our application.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了笔记本，让我们将其整合到我们的应用程序中。
- en: Adding a notebook to our application
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将笔记本添加到我们的应用程序中
- en: 'To add a `Notebook` widget to our layout, we''ll need to create one in `Application.__init__()`
    before we create the `DataRecordForm` and `RecordList` widgets. Open the `application.py`
    file and locate the lines that currently create the `DataRecordForm` object, and
    let''s create a notebook just above them, like so:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`Notebook`小部件添加到我们的布局中，我们需要在创建`DataRecordForm`和`RecordList`小部件之前在`Application.__init__()`中创建一个。打开`application.py`文件，找到当前创建`DataRecordForm`对象的行，并在它们上面创建一个笔记本，如下所示：
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note that we''re enabling keyboard traversal for our keyboard-only users, and
    sticking the widget to all sides of the grid. Now, update the lines that create
    the record form as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为仅使用键盘的用户启用了键盘遍历，并将小部件粘附在网格的所有边上。现在，按照以下方式更新创建记录表单的行：
- en: '[PRE61]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we''ve simply removed the call to `self.recordform.grid()` and replaced
    it with `self.notebook.add()`. Next, let''s create an instance of the `RecordList`
    class and add it to the notebook:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是移除了对`self.recordform.grid()`的调用，并用`self.notebook.add()`替换了它。接下来，让我们创建一个`RecordList`类的实例并将其添加到笔记本中：
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Although we're adding the `RecordList` widget second, we'd like it to display
    first; so, we're using `insert()` to add it to the beginning of the tab list.
    That completes adding our pages, but let's start adding the necessary callbacks
    to make them work.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们是在第二个添加 `RecordList` 小部件，但我们希望它首先显示；因此，我们使用 `insert()` 将其添加到标签列表的开头。这样我们就完成了页面的添加，但让我们开始添加必要的回调来使它们工作。
- en: Adding and updating application callbacks
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和更新应用程序回调
- en: 'To bring all of these new widgets together in a functional way, we need to
    create a few callback methods on the `Application` object that will allow the
    application to get the user and the data to appropriate areas of the GUI when
    required. Specifically, we need to create four methods:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以功能方式将这些新小部件组合在一起，我们需要在 `Application` 对象上创建一些回调方法，以便在需要时允许应用程序将用户和数据传递到 GUI
    的适当区域。具体来说，我们需要创建四个方法：
- en: A `_show_recordlist()` method we can use to display the record list when required
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `_show_recordlist()` 方法在需要时显示记录列表
- en: A `_populate_recordlist()` method we can call to repopulate the record list
    from file data
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以用来从文件数据中重新填充记录列表的 `_populate_recordlist()` 方法
- en: A `_new_record()` method that we can use to switch to a new, empty record
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以用来切换到新的、空白的记录的 `_new_record()` 方法
- en: An `_open_record()` method we can call to load a particular record into the
    form from the record list
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以调用的 `_open_record()` 方法来从记录列表中加载特定的记录到表单中
- en: We also need to fix the `Application._on_save()` method to make sure it's passing
    the model all the information necessary for both updating existing records and
    creating new records.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修复 `Application._on_save()` 方法，以确保它传递给模型所有必要的信息，以便更新现有记录和创建新记录。
- en: Let's go through each method, creating or updating the method and binding or
    calling it where appropriate.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每个方法，创建或更新方法，并在适当的地方绑定或调用它。
- en: The _show_recordlist() method
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`_show_recordlist()` 方法'
- en: 'The first method we''ll write is `_show_recordlist()`. This method is fairly
    simple, as you can see:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的第一个方法是 `_show_recordlist()`。正如你所见，这个方法相当简单：
- en: '[PRE63]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It's almost not worth writing such a simple method, but by having this as a
    method we can easily bind it as a callback without resorting to a `lambda` function.
    Note that we could have written this as `self.notebook.select(0)`, but passing
    the widget reference is more explicit about our intentions. Should we decide to
    switch the order of the tabs, this method will continue to work without alteration.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样一个简单的方法几乎不值得，但通过将其作为方法，我们可以轻松地将其绑定为回调，而无需使用 `lambda` 函数。请注意，我们可以将其编写为 `self.notebook.select(0)`，但传递小部件引用更明确地表达了我们的意图。如果我们决定切换标签的顺序，此方法将继续工作而无需更改。
- en: 'One place we''ll want to bind this callback is in our main menu. Back in the
    initializer for `Application`, let''s add this method to our dictionary of callback
    functions, like so:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望将此回调绑定到主菜单上。回到 `Application` 的初始化器中，让我们将此方法添加到我们的回调函数字典中，如下所示：
- en: '[PRE64]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We''ll add the necessary code for the menu itself in the next section. One
    other place we ought to call this method is at the end of `__init__()`, to ensure
    that the record list is displayed when the user opens the program. Add this at
    the end of `Application.__init__()`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中添加菜单本身的必要代码。另一个我们应该调用此方法的地方是在 `__init__()` 的末尾，以确保当用户打开程序时记录列表被显示。在
    `Application.__init__()` 的末尾添加此代码：
- en: '[PRE65]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The _populate_recordlist() method
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`_populate_recordlist()` 方法'
- en: 'The `_populate_recordlist()` method needs to retrieve data from the model and
    hand it to the record list''s `populate()` method. We could write it like so:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`_populate_recordlist()` 方法需要从模型中检索数据并将其传递给记录列表的 `populate()` 方法。我们可以这样编写它：'
- en: '[PRE66]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, remember that `CSVModel.get_all_records()` can potentially raise an
    `Exception` if there are problems with the data in the file. It''s the controller''s
    responsibility to catch that exception and take appropriate action, so we''ll
    write the method like this instead:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，如果文件中的数据有问题，`CSVModel.get_all_records()` 可能会引发一个 `Exception`。捕获这个异常并采取适当的行动是控制器的责任，所以我们将这样编写该方法：
- en: '[PRE67]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this version, if we get an exception from `get_all_records()`, we'll display
    its message in an error dialog. It will then be up to the user to deal with that
    issue.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，如果我们从 `get_all_records()` 获取异常，我们将在错误对话框中显示其消息。然后用户将负责处理这个问题。
- en: 'Now that we have this method, when should it be called? To begin with, it should
    be called whenever we select a new file to work with; so, let''s add a call to
    it at the end of `_on_file_select()`, like so:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个方法，它应该在什么时候被调用？首先，它应该在每次我们选择一个新的文件来工作时被调用；所以，让我们在`_on_file_select()`的末尾添加对它的调用，如下所示：
- en: '[PRE68]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In addition, we need to populate the list whenever we open the program, since
    it will automatically load the default file. Let''s add a call to this method
    in the initializer just after creating the record list widget, as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要在打开程序时填充列表，因为它将自动加载默认文件。让我们在创建记录列表小部件后立即调用此方法，如下所示：
- en: '[PRE69]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, whenever we save a record, this should also update the record list,
    since the new record will have been added to the file. We need to add a call to
    the method in `_on_save()`, like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每次我们保存记录时，这也应该更新记录列表，因为新记录已经被添加到文件中。我们需要在`_on_save()`中添加对方法的调用，如下所示：
- en: '[PRE70]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now our record list should stay in sync with the state of the file we're working
    on.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的记录列表应该与我们在工作的文件状态保持同步。
- en: The _new_record() method
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`_new_record()`方法'
- en: Next, we need a method that can open the data record form for the entry of a
    new record. Remember that our `DataRecordForm.load_record()` method can take `None`
    as arguments for the record number and data, indicating that we want to work on
    a new record, so we just need to write a callback that will do this.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个可以打开数据记录表单以输入新记录的方法。记住，我们的`DataRecordForm.load_record()`方法可以将`None`作为记录号和数据参数，表示我们想要处理一个新记录，所以我们只需要编写一个回调来完成这个操作。
- en: 'Add this method to `Application`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法添加到`Application`：
- en: '[PRE71]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After calling `load_record()` to prepare the form for a new record entry, we
    switch the notebook to the record form using `notebook.select()`. To enable users
    to call this method, we'll create a menu entry, so we'll need to add another entry
    to the `event_callbacks` dictionary.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`load_record()`为新的记录输入准备表单后，我们使用`notebook.select()`将笔记本切换到记录表单。为了使用户能够调用此方法，我们将创建一个菜单项，因此我们需要在`event_callbacks`字典中添加另一个条目。
- en: 'In `Application.__init__()`, update the dictionary as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application.__init__()`中，按如下方式更新字典：
- en: '[PRE72]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We'll add the necessary code to the menu in the next section.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中添加必要的代码到菜单中。
- en: The _open_record() method
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`_open_record()`方法'
- en: 'Next, we need to write a callback method that will open an existing record
    when the user selects one from the record list. Add this method to the `Application`
    class:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个回调方法，当用户从记录列表中选择一个记录时，它会打开一个现有的记录。将此方法添加到`Application`类：
- en: '[PRE73]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Remember that the `RecordList` object updates its `selected_id` property whenever
    a record is double-clicked or activated with the Enter key. We're retrieving this
    ID number and passing it to the model's `get_record()` method. Because `get_record()`
    calls `get_all_records()`, it can also potentially raise an exception if there
    is a problem with the file. Therefore, just as we did in `_populate_recordlist()`,
    we're catching the exception and displaying its message to the user in the case
    of problem.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每当记录被双击或使用Enter键激活时，`RecordList`对象都会更新其`selected_id`属性。我们正在检索这个ID号并将其传递给模型的`get_record()`方法。因为`get_record()`会调用`get_all_records()`，如果文件有问题，它也可能抛出异常。因此，就像我们在`_populate_recordlist()`中所做的那样，我们在有问题的情况下捕获异常并向用户显示其消息。
- en: If there's no problem, we've retrieved the data, and we need only pass the row
    number and dictionary of data to the form's `load_record()` method. Last of all,
    we call `notebook.select()` to switch to the record form view.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有问题，我们已经检索到了数据，我们只需要传递行号和数据字典到表单的`load_record()`方法。最后，我们调用`notebook.select()`来切换到记录表单视图。
- en: This callback needs to be called whenever the user chooses a file from the record
    list. Remember that we have written our `RecordList` objects to generate an `<<OpenRecord>>`
    event whenever this happens. Back in the application's initializer method, we
    need to set up a binding to this event.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调需要在用户从记录列表中选择文件时被调用。记住，我们已经编写了`RecordList`对象来生成一个`<<OpenRecord>>`事件，每当这种情况发生时。回到应用程序的初始化方法中，我们需要设置一个绑定到这个事件。
- en: 'Back in `Application.__init__()`, add this binding just after creating the
    `RecordList` widget, like so:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Application.__init__()`，在创建`RecordList`小部件后添加此绑定，如下所示：
- en: '[PRE74]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now a double-click or Enter keypress will open the selected record in the form.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在双击或按Enter键将打开选定的记录。
- en: The _on_save() method
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`_on_save()`方法'
- en: Finally, now that our model can handle updating existing records, we need to
    alter the call that we make to the model's `save_record()` method to make sure
    we're passing in all the information it needs to either update an existing record
    or insert a new one. Recall that we updated `save_record()` to take a `rownum`
    argument. When this value is `None`, a new record is added; when it is an integer,
    the indicated row number is updated.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们的模型可以处理更新现有记录，我们需要修改调用模型 `save_record()` 方法的代码，以确保我们传递了它需要更新现有记录或插入新记录所需的所有信息。回想一下，我们更新了
    `save_record()` 以接受 `rownum` 参数。当此值为 `None` 时，添加新记录；当它是一个整数时，更新指定的行号。
- en: 'In `Application._on_save()`, update the code as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Application._on_save()` 中，按照以下方式更新代码：
- en: '[PRE75]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Recall that the record form object's `current_record` holds the value of the
    current row being edited, or `None` if it is a new record. We can pass that value
    directly on to the model's `save()` method, ensuring that the data is saved to
    the proper place.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，记录表单对象的 `current_record` 包含正在编辑的当前行的值，如果没有正在编辑的记录，则为 `None`。我们可以直接将此值传递给模型的
    `save()` 方法，确保数据被保存到正确的位置。
- en: Main menu changes
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主菜单更改
- en: The last change we need to make to our application is updating the main menu
    with the new options for navigating the application; specifically, we need to
    add a command for adding a new file, and a command for going back to the record
    list. Remember that the `Application` object has bound callbacks for these operations
    to the `<<ShowRecordlist>>` and `<<NewRecord>>` events, respectively.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们应用程序进行的最后一个更改是更新主菜单，以包含用于导航应用程序的新选项；具体来说，我们需要添加一个添加新文件的命令，以及一个返回记录列表的命令。记住，`Application`
    对象将这些操作的回调绑定到 `<<ShowRecordlist>>` 和 `<<NewRecord>>` 事件上。
- en: 'There isn''t really a standard location for commands that navigate around the
    application, so we''ll create a new sub-menu called Go. Open the `mainmenu.py`
    file, and let''s add a new sub-menu in the initializer method:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在应用程序中导航的命令实际上并没有一个标准的位置，因此我们将创建一个新的子菜单，称为“Go”。打开 `mainmenu.py` 文件，让我们在初始化方法中添加一个新的子菜单：
- en: '[PRE76]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here, we''ve added a new sub-menu widget and added our two navigation commands,
    once again taking advantage of the `_event()` method, which gives us a reference
    to a method that generates the given event. Now add the `Go` menu between the
    File and Options menus, like so:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个新的子菜单小部件，并添加了我们的两个导航命令，再次利用 `_event()` 方法，它为我们提供了一个生成给定事件的方法的引用。现在，在文件和选项菜单之间添加“Go”菜单，如下所示：
- en: '[PRE77]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Testing our program
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的程序
- en: 'At this point, you should be able to run the application and load in a sample
    CSV file as shown in the following screenshot:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够运行应用程序并加载如以下截图所示的示例 CSV 文件。
- en: '![Selecting an existing file for writing with our new menu and record list](img/B17578_08_06.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![使用我们新的菜单和记录列表选择现有文件进行写入](img/B17578_08_06.png)'
- en: 'Figure 8.6: Selecting an existing file for writing with our new menu and record
    list'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：使用我们新的菜单和记录列表选择现有文件进行写入
- en: 'Make sure to try opening a record, editing and saving it, as well as inserting
    new records and opening different files. You should also test the following error
    conditions:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 确保尝试打开记录、编辑并保存它，以及插入新记录和打开不同的文件。你还应该测试以下错误条件：
- en: Try opening a file that isn't a CSV file, or a CSV with incorrect fields. What
    happens?
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试打开一个不是 CSV 文件的文件，或者字段不正确的 CSV 文件。会发生什么？
- en: Open a valid CSV file, select a record for editing, then, before clicking **Save**,
    select a different or empty file. What happens?
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个有效的 CSV 文件，选择一个记录进行编辑，然后，在点击“保存”之前，选择不同的或空文件。会发生什么？
- en: Open two copies of the program and point them to the saved CSV file. Try alternating
    edit or update actions between the programs. Note what happens.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开程序的两个副本，并将它们指向保存的 CSV 文件。尝试在两个程序之间交替执行编辑或更新操作。注意发生了什么。
- en: Consider how you might address some of these issues; in some cases it may not
    be possible, and users will just have to be informed of the limitations. Also,
    if possible, try the last test on different operating systems. Are the results
    different?
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如何解决这些问题；在某些情况下可能无法解决，用户将不得不被告知这些限制。此外，如果可能的话，尝试在不同的操作系统上执行最后一个测试。结果是否不同？
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have changed our program from being an append-only data entry form to an
    application capable of loading, viewing, and updating data from existing files.
    In the process, you learned how to update our model so that it could read and
    update CSV files. You also explored the `Treeview` widget, including its basic
    use, virtual events, and column callbacks. You explored using the `Treeview` widget
    with hierarchical data structures by creating a file-browsing tool. You learned
    how to organize multi-form applications using a `Notebook` widget, and how to
    create scrolling interfaces using the `Scrollbar` widget. Finally, you integrated
    these concepts into the ABQ Data Entry application to address user needs.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将程序从仅能追加数据输入表单转变为能够从现有文件中加载、查看和更新数据的应用程序。在这个过程中，你学习了如何更新我们的模型，使其能够读取和更新CSV文件。你还探索了`Treeview`小部件，包括其基本用法、虚拟事件和列回调。你通过创建文件浏览工具，探索了如何使用`Treeview`小部件与层次化数据结构协同工作。你学习了如何使用`Notebook`小部件组织多表单应用程序，以及如何使用`Scrollbar`小部件创建滚动界面。最后，你将这些概念整合到ABQ数据输入应用程序中，以满足用户需求。
- en: In our next chapter, we'll be learning how to modify the look and feel of our
    application. We'll learn about using widget attributes, styles, and themes, as
    well as working with bitmapped graphics.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的章节中，我们将学习如何修改应用程序的外观和感觉。我们将了解如何使用小部件属性、样式和主题，以及如何处理位图图形。
