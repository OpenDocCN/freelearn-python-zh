- en: Chapter 4. Socializer – the Testable Timeline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。Socializer-可测试的时间线
- en: 'In this chapter we will build our next application with the codename: Socializer.
    This application will provide you with a very typical *timeline* feed, whose variations
    grace many well-known modern web applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用代号“Socializer”构建我们的下一个应用程序。这个应用程序将为您提供一个非常典型的*时间线*信息流，其变体出现在许多知名的现代网络应用程序中。
- en: This application will allow authenticated users to follow others, and be followed
    by other users, and display content posted from the followed users in a time-ordered
    fashion. Along with building the basic features required of a timeline-based application,
    we will implement additional behaviors using the excellent `Blinker` library for
    in-process publish/subscribe signals that will allow us to decouple the application
    into more compassable, reusable parts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序将允许经过身份验证的用户关注其他用户，并被其他用户关注，并以时间顺序显示被关注用户发布的内容。除了构建基于时间线的应用程序所需的基本功能之外，我们还将使用优秀的`Blinker`库来实现其他行为，以进行进程内发布/订阅信号，这将使我们能够将应用程序解耦为更可组合、可重用的部分。
- en: Additionally, Socializer will be built with unit and functional testing in mind,
    allowing us to vigorously test the various models and views to ensure that it
    functions according to our expectations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Socializer将在构建过程中考虑单元测试和功能测试，使我们能够对各种模型和视图进行严格测试，以确保其按照我们的期望进行功能。
- en: Starting off
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'As we did in the previous chapter, let''s create a completely new directory
    for this application, in addition to creating a virtual environment and installing
    a few basic packages that we will be using:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一章中所做的那样，让我们为这个应用程序创建一个全新的目录，另外创建一个虚拟环境，并安装我们将要使用的一些基本包：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our application layout will, for the moment, be very similar to the one that
    we used in the previous chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序布局暂时将与上一章中使用的布局非常相似：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Application factories
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序工厂
- en: One of the major benefits of unit and functional testing is the ability to ensure,
    under a variety of different conditions and configurations, that your application
    behaves in a known and predictable manner. To this end, it will be a great advantage
    to have the ability to construct all the Flask application objects in our test
    suite. We can then easily provide different configurations to each of these objects
    and ensure that they exhibit the behavior that we expect.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和功能测试的一个主要好处是能够在各种不同条件和配置下确保应用程序以已知和可预测的方式运行。为此，在我们的测试套件中构建所有Flask应用程序对象将是一个巨大的优势。然后，我们可以轻松地为这些对象提供不同的配置，并确保它们表现出我们期望的行为。
- en: 'Thankfully, this is entirely achievable using the application factory pattern,
    which is well supported by Flask. Let''s add a `create_app` method to our `application/__init__.py`
    module:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，这完全可以通过应用程序工厂模式来实现，而Flask对此提供了很好的支持。让我们在`application/__init__.py`模块中添加一个`create_app`方法：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What this method does is relatively simple: given an optional `config` argument,
    construct a Flask application object, optionally apply this custom configuration,
    and finally return the newly created Flask application object to the caller.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的作用相对简单：给定一个可选的`config`参数，构建一个Flask应用程序对象，可选地应用这个自定义配置，最后将新创建的Flask应用程序对象返回给调用者。
- en: 'Previously, we would simply instantiate a Flask object in the module itself,
    which meant that on import of this package or module the application object would
    be immediately available. However, this also meant that there was no simple way
    of doing the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们只是在模块本身中实例化一个Flask对象，这意味着在导入此包或模块时，应用程序对象将立即可用。然而，这也意味着没有简单的方法来做以下事情：
- en: Delaying the construction of the application object to some time after the module
    was imported to the local namespace. This may seem frivolous at first but is incredibly
    useful and powerful for large applications that can benefit from this type of
    lazy instantiation. As we mentioned previously, side-effect generating package
    imports should be avoided as much as possible.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序对象的构建延迟到模块导入到本地命名空间之后的某个时间。这一开始可能看起来很琐碎，但对于可以从这种惰性实例化中受益的大型应用程序来说，这是非常有用和强大的。正如我们之前提到的，应尽可能避免产生副作用的包导入。
- en: Substituting different application configuration values, such as those that
    may be needed while running tests. We might like to avoid, for example, sending
    out e-mail notifications to real world users while running our test suite.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换不同的应用程序配置值，例如在运行测试时可能需要的配置值。例如，我们可能希望在运行测试套件时避免向真实用户发送电子邮件通知。
- en: Running multiple Flask applications in the same process. While we do not explicitly
    address the concept in this book, this can be useful in a variety of situations,
    such as having separate application instances that serve different versions of
    a public API or separate application objects that serve different content types
    (JSON, XML, and so on). More information on this topic can be gleaned from the
    *Application dispatching* section in the official Flask online documentation [http://flask.pocoo.org/docs/0.10/patterns/appdispatch/](http://flask.pocoo.org/docs/0.10/patterns/appdispatch/).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一进程中运行多个Flask应用程序。虽然本书中没有明确讨论这个概念，但在各种情况下这可能是有用的，比如拥有为公共API的不同版本提供服务的单独应用程序实例，或者为不同内容类型（JSON、XML等）提供服务的单独应用程序对象。关于这个主题的更多信息可以从官方Flask在线文档的*应用程序调度*部分中获取[http://flask.pocoo.org/docs/0.10/patterns/appdispatch/](http://flask.pocoo.org/docs/0.10/patterns/appdispatch/)。
- en: With the application factory, we now have more flexibility in when and how our
    main application object is constructed. The downside (or upside, if you're intent
    on running several applications in the same process!), of course, is that we no
    longer have access to a quasi-global `app` object that we can import to our modules
    in order to do things such as register route handlers or access the `app` object's
    logger.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有了应用程序工厂，我们现在在何时以及如何构建我们的主应用程序对象方面有了更多的灵活性。当然，缺点（或者优点，如果你打算在同一个进程中运行多个应用程序！）是，我们不再可以访问一个准全局的`app`对象，我们可以导入到我们的模块中，以便注册路由处理程序或访问`app`对象的日志记录器。
- en: The application context
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序上下文
- en: One of the principal design goals of Flask is to ensure that you can run multiple
    applications in the same Python process. How, then, should an application be certain
    that the `app` object being imported to a module is the correct one and not the
    object for one of the other applications running in the same process?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Flask的主要设计目标之一是确保您可以在同一个Python进程中运行多个应用程序。那么，一个应用程序如何确保被导入到模块中的`app`对象是正确的，而不是在同一个进程中运行的其他应用程序的对象？
- en: 'In other frameworks that support the single-process/multi-app paradigm, this
    is sometimes accomplished by enforcing explicit dependency injection: a code that
    requires an `app` object to be present should explicitly require that the app
    object be passed to the function or method that needs it. From an architectural
    design perspective this sounds great, but this can quickly become cumbersome if
    third-party libraries or extensions do not follow the same design principles.
    At best, you will end up needing to write a lot of boilerplate wrapper functions,
    and at worst you will end up resorting to monkey-patching modules and classes
    in a never-ending downward spiral of brittleness and unnecessary complexity that
    will ultimately cause you more trouble than you originally bargained for.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持单进程/多应用程序范式的其他框架中，有时可以通过强制显式依赖注入来实现：需要`app`对象的代码应明确要求将app对象传递给需要它的函数或方法。从架构设计的角度来看，这听起来很棒，但如果第三方库或扩展不遵循相同的设计原则，这很快就会变得繁琐。最好的情况是，您最终将需要编写大量的样板包装函数，最坏的情况是，您最终将不得不诉诸于在模块和类中进行猴子补丁，这将最终导致比您最初预期的麻烦更多的脆弱性和不必要的复杂性。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is, of course, nothing inherently wrong with explicit dependency injection
    boilerplate wrapper functions. Flask has simply chosen a different approach, which
    it has been criticized for in the past, but has shown to be both flexible, testable,
    and resilient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，显式依赖注入样板包装函数本身并没有什么不对。Flask只是选择了一种不同的方法，过去曾因此受到批评，但已经证明是灵活、可测试和有弹性的。
- en: Flask, for better or worse, has been built around an alternative method that
    is based on proxy objects. These proxy objects are, in essence, container objects
    that are shared among all the threads and know how to dispatch to the *real* objects
    that are bound to a particular thread behind the scenes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Flask，不管好坏，都是建立在基于代理对象的替代方法之上的。这些代理对象本质上是容器对象，它们在所有线程之间共享，并且知道如何分派到在幕后绑定到特定线程的*真实*对象。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A common misconception is that in a threaded application, each request will
    be assigned its own new thread under the WSGI specification: this is simply not
    the case. New requests may reuse existing but currently unused threads, and this
    old thread may have locally scoped variables still lurking around that may interfere
    with your new request handling.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是，在多线程应用程序中，根据WSGI规范，每个请求将被分配一个新的线程：这根本不是事实。新请求可能会重用现有但当前未使用的线程，并且这个旧线程可能仍然存在局部作用域的变量，可能会干扰您的新请求处理。
- en: 'One of these proxy objects, `current_app`, is created and bound to the current
    request This means that instead of importing an already-constructed Flask application
    object (or worse, creating additional application objects in the same request),
    we replace it with the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个代理对象`current_app`被创建并绑定到当前请求。这意味着，我们不再导入一个已经构建好的Flask应用程序对象（或者更糟糕的是，在同一个请求中创建额外的应用程序对象），而是用以下内容替换它：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The aliasing of the imported `current_app` object is, of course, completely
    optional. It is sometimes preferable to leave it named `current_app` so as to
    remind yourself that it is not the real application object, but a proxy to it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，导入的`current_app`对象的别名是完全可选的。有时最好将其命名为`current_app`，以提醒自己它不是真正的应用程序对象，而是一个代理对象。
- en: Using this proxy object, we can sidestep the issue of not having an instantiated
    Flask application object available to us at import time when we implement the
    application factory pattern.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个代理对象，我们可以规避在实现应用程序工厂模式时，在导入时没有可用的实例化Flask应用程序对象的问题。
- en: Instantiating an app object
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例化一个应用程序对象
- en: Of course, at some point, we need to actually create an application object so
    that the proxies have something to, well, proxy to. Generally, we want to create
    the object once and then we want to make sure that the `run` method is invoked
    in order to launch the Werkzeug development server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要在某个时候实际创建一个应用程序对象，以便代理有东西可以代理。通常，我们希望创建对象一次，然后确保调用`run`方法以启动Werkzeug开发服务器。
- en: 'To this end, we can modify the `run.py` script that we had in the previous
    chapter to instantiate the app object from our factory and invoke the `run` method
    on the newly created instance, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以修改上一章中的`run.py`脚本，从我们的工厂实例化app对象，并调用新创建的实例的`run`方法，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we should be able to run this extremely barebones application as we have
    previously done:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够像以前一样运行这个极其简陋的应用程序：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'It is also possible to invoke the Python interpreter such that a module, package,
    or script is imported to the environment for you and executed immediately. This
    is accomplished with the `–m` flag and our preceding invocation of `run.py` can
    be modified to the more concise version, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以调用Python解释器，以便为您导入并立即执行模块、包或脚本。这是通过`-m`标志实现的，我们之前对`run.py`的调用可以修改为更简洁的版本，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unit and functional testing
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元和功能测试
- en: One of the primary benefits of implementing an application factory to hand out
    the Flask application instances is that we have the abilities to test the application
    more effectively. We can construct different application instances for different
    test cases and can be sure that they are as isolated from each other as possible
    (or as much as Flask/Werkzeug will allow).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现应用程序工厂以分发Flask应用程序实例的主要好处之一是，我们可以更有效地测试应用程序。我们可以为不同的测试用例构建不同的应用程序实例，并确保它们尽可能地相互隔离（或者尽可能地与Flask/Werkzeug允许的隔离）。
- en: 'The mainstay of the testing libraries in the Python ecosystem is unittest,
    which is included in the standard library and includes much of the functionalities
    that are expected of an xUnit framework. While a complete exposition on unittest
    is largely out of the scope of this book, a typical class-based test case will
    follow this basic skeleton, assuming that we are still using the factory pattern
    to separate our application configuration from instantiation:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python生态系统中测试库的主要组成部分是unittest，它包含在标准库中，并包括了xUnit框架所期望的许多功能。虽然本书不会详细介绍unittest，但一个典型的基于类的测试用例将遵循以下基本结构，假设我们仍然使用工厂模式来将应用程序配置与实例化分离：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following are the advantages of using the unittest test format/style:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用unittest测试格式/样式的优点如下：
- en: It does not require external dependencies; unittest is part of the Python standard
    library.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要外部依赖；unittest是Python标准库的一部分。
- en: Getting started is relatively easy. Most xUnit testing frameworks follow similar
    naming conventions to declare the test classes and test methods, and include several
    helpers for typical assertions such as `assertTrue` or `assertEqual`, among several
    others.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入门相对容易。大多数xUnit测试框架遵循类似的命名约定来声明测试类和测试方法，并包含几个典型断言的辅助函数，如`assertTrue`或`assertEqual`等。
- en: It is, however, not the only player in town; we will be using `pytest` and the
    associated Flask extension that wraps the convenient functionality, `pytest-flask`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它并不是唯一的选择；我们将使用`pytest`和包装方便功能的相关Flask扩展`pytest-flask`。
- en: 'In addition to being a slightly more modern and concise testing framework,
    the other major advantage that `pytest` provides over many other testing tools
    is the ability to define fixtures for the tests, which are described quite succinctly
    from their own documentation, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为一个稍微现代化和简洁的测试框架外，`pytest`相对于许多其他测试工具提供的另一个主要优势是能够为测试定义固定装置，这在它们自己的文档中描述得非常简洁，如下所示：
- en: Fixtures have explicit names and are activated by declaring their use from test
    functions, modules, classes, or whole projects
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定装置具有明确的名称，并通过声明其在测试函数、模块、类或整个项目中的使用来激活它们
- en: Fixtures are implemented in a modular manner as each fixture name triggers a
    fixture function that itself can use other fixtures
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定装置以模块化的方式实现，因为每个固定装置名称都会触发一个固定装置函数，该函数本身可以使用其他固定装置
- en: Fixture management scales from a simple unit to complex functional testing,
    allowing you to parameterize fixtures and tests according to the configuration
    and component options or to reuse fixtures across class, module, or whole test
    session scopes
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定装置管理从简单单元到复杂功能测试的规模，允许您根据配置和组件选项对固定装置和测试进行参数化，或者在类、模块或整个测试会话范围内重用固定装置
- en: In the context of testing a Flask application, this means that we can define
    objects (such as our application object) in a `fixture` and then have this object
    automatically injected into a test function via the use of an argument that has
    the same name as the defined fixture function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试Flask应用程序的情况下，这意味着我们可以在`fixture`中定义对象（例如我们的应用程序对象），然后通过使用与定义的固定装置函数相同名称的参数，将该对象自动注入到测试函数中。
- en: 'If that last paragraph was a bit too much to handle, then a simple example
    should be enough to clear things up. Let''s create the following `conftest.py`
    file, which will contain any test suite-wide fixtures and helpers that our other
    tests might use:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上一段文字有点难以理解，那么一个简单的例子就足以澄清问题。让我们创建以下的`conftest.py`文件，其中将包含任何测试套件范围的固定装置和辅助工具，供其他测试使用：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will create our first test module in `tests/test_application.py`, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`tests/test_application.py`中创建我们的第一个测试模块，如下所示：
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the `tests_*` prefix to the test file names is important—it allows
    `pytest` to automatically discover which files contain test functions and assertions
    that need to be run. If a filename in your tests/folder does not have the aforementioned
    prefix, then the test runner will abstain from loading it and treating it as a
    file that contains functions with test assertions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`tests_*`前缀对于测试文件名是重要的——它允许`pytest`自动发现哪些文件包含需要运行的测试函数和断言。如果您的tests/folder中的文件名没有上述前缀，那么测试运行器将放弃加载它，并将其视为包含具有测试断言的函数的文件。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请注意
- en: Note that the `app` argument in the `test_app` function signature matches the
    name of the `app` fixture function that is defined in `conftest.py`, and the value
    that is passed to `test_app` is the return value of the `app` fixture function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`test_app`函数签名中的`app`参数与`conftest.py`中定义的`app`固定装置函数的名称相匹配，传递给`test_app`的值是`app`固定装置函数的返回值。
- en: 'We will run the test suite using the `py.test` executable that was installed
    to our virtual environment (when we added the `pytest-flask` and `pytest` libraries)
    in the directory that contains `conftest.py` and our tests/folder, and the output
    will indicate that our test module was discovered and run:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用安装到我们的虚拟环境中的`py.test`可执行文件来运行测试套件（当我们添加了`pytest-flask`和`pytest`库时），在包含`conftest.py`和我们的tests/文件夹的目录中运行，输出将指示我们的测试模块已被发现并运行：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And that's it! We've written and run our very first, albeit uninteresting, test
    for our application. Don't fret if you don't quite understand what's going on
    just yet; quite a bit of concrete testing is coming up in this chapter and many
    more examples will follow.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经编写并运行了我们的第一个应用程序测试，尽管不是很有趣。如果你还不太明白发生了什么，不要担心；本章中将进行大量具体的测试，还会有更多的例子。
- en: Social features – friends and followers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交功能-朋友和关注者
- en: Many modern web applications allow users to *friend* or *follow* other users
    and be friended or followed themselves. While this concept may be simple to explain
    in words, there are numerous implementations and variations, all of which are
    optimized for their particular use-cases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代网络应用程序允许用户*添加朋友*或*关注*其他用户，并且自己也可以被添加朋友或关注。虽然这个概念在文字上可能很简单，但有许多实现和变体，所有这些都针对它们特定的用例进行了优化。
- en: 'In this situation, where we want to implement a newsfeed-like service that
    displays information from a selected pool of users in an aggregated timeline that
    is unique for each authenticated user, the following are the three categories
    of approaches that may be used:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要实现一个类似新闻订阅的服务，该服务会显示来自选定用户池的信息，并在每个经过身份验证的用户中显示独特的聚合时间线，以下是可能使用的三种方法类别：
- en: '**Fan-out on Write**: Each newsfeed for a user is stored in a separate logical
    container with the intention of making reads exceedingly simple, fast, and straightforward,
    at the expense of denormalization and lower write throughput. The logical container
    may be a database table for each user (although this is highly inefficient for
    a large amount of users), columns in a column-oriented database such as Cassandra,
    or more specialized storage solutions such as Redis lists that may have elements
    added to them in an atomic fashion.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入时的扇出**：每个用户的新闻订阅都存储在一个单独的逻辑容器中，旨在使读取非常简单、快速和直接，但代价是去规范化和较低的写入吞吐量。逻辑容器可以是每个用户的数据库表（尽管对于大量用户来说效率非常低），也可以是列式数据库（如Cassandra）中的列，或者更专门的存储解决方案，如Redis列表，可以以原子方式向其中添加元素。'
- en: '**Fan-out on Read**: When newsfeeds require additional customization or processing
    to determine things such as visibility or relevance, a fan-out on read approach
    is usually best. This allows more fine-grained control over which items will end
    up in the feed and in which order (assuming that something more elaborate than
    chronological is required) at the cost of increased computational time to load
    the user-specific feed. Such a costly approach may be mitigated by keeping the
    recent items in RAM (which is the basic approach behind the Facebook™ newsfeed
    and the reason why Facebook also has the largest deployment of Memcache in the
    world), but this introduces several layers of complexity and indirection.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取时的扇出**：当新闻订阅需要额外的定制或处理来确定诸如可见性或相关性之类的事情时，通常最好使用读取时的扇出方法。这允许更精细地控制哪些项目将出现在动态信息中，以及以哪种顺序（假设需要比时间顺序更复杂的东西），但这会增加加载用户特定动态信息的计算时间。通过将最近的项目保存在RAM中（这是Facebook™新闻订阅背后的基本方法，也是Facebook在世界上部署最大的Memcache的原因），但这会引入几层复杂性和间接性。'
- en: '**Naïve Normalization**: This is the least scalable of the approaches, but
    the simplest to implement. For many small-scale applications, this is the best
    place to start: a post''s table that contains all the items created by users (with
    a foreign key constraint to the user who created that particular item) and a follower''s
    table that tracks which users are following whom. Various caching solutions may
    be used to speed up parts of the request at the cost of additional complexity
    and may be introduced when they are necessary.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天真的规范化**：这是方法中最不可扩展的，但实现起来最简单。对于许多小规模应用程序来说，这是最好的起点：一个包含所有用户创建的项目的帖子表（带有对创建该特定项目的用户的外键约束）和一个跟踪哪些用户正在关注谁的关注者表。可以使用各种缓存解决方案来加速请求的部分，但这会增加额外的复杂性，并且只有在必要时才能引入。'
- en: For the purposes of our Socializer application, the third approach, the so-called
    naïve normalization, will be the one we implement. The other approaches are valid,
    and you may choose to go down either path depending on your goals, but for the
    sake of simplicity and exposition we shall choose the one that requires the least
    amount of work.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Socializer应用程序，第三种方法，所谓的天真规范化，将是我们实现的方法。其他方法也是有效的，你可以根据自己的目标选择其中任何一条路线，但出于简单和阐述的目的，我们将选择需要最少工作量的方法。
- en: 'With this in mind, let''s begin by implementing the basic SQLAlchemy models
    and relationships that are required. First, let''s use our newly minted application
    factory to initialize and configure the Flask-SQLAlchemy extension along with
    Flask-Bcrypt to hash our user passwords, using the same hybrid property approach
    that we explored in the previous chapter. Our `application/__init__.py` is as
    follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们开始实现所需的基本SQLAlchemy模型和关系。首先，让我们使用我们新创建的应用程序工厂来初始化和配置Flask-SQLAlchemy扩展，以及使用相同的混合属性方法来哈希我们的用户密码，这是我们在上一章中探讨过的方法。我们的`application/__init__.py`如下：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Due to the use of the application factory, we separated the instantiation of
    the extensions (`db` and `flask_bcrypt`) from their configurations. The former
    happens at the time of import and the latter needs to occur when the Flask application
    object is constructed. Luckily, most modern Flask extensions allow this exact
    separation to occur, as we have demonstrated in the preceding snippet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序工厂的使用，我们将扩展（`db`和`flask_bcrypt`）的实例化与它们的配置分开。前者发生在导入时，后者需要在构建Flask应用对象时发生。幸运的是，大多数现代的Flask扩展都允许发生这种确切的分离，正如我们在前面的片段中所演示的那样。
- en: 'Now, we will create our user''s package by creating `application/users/__init__.py`,
    then we will create `application/users/models.py` with our standard bits for the
    Flask-Login extension (which we will use later) as we did in the previous chapter.
    In addition, we will add an explicit SQLAlchemy mapping for our follower''s table
    and the following associated relationship on the User model:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过创建`application/users/__init__.py`来创建我们的用户包，然后我们将创建`application/users/models.py`，其中包含我们用于Flask-Login扩展的标准部分（稍后我们将使用），就像我们在上一章中所做的那样。此外，我们将为我们的关注者表和用户模型上的关联关系添加一个显式的SQLAlchemy映射：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `followed` attribute of the User model is a SQLAlchemy relationship that
    maps the user''s table to itself via the intermediate follower''s table. The intermediate
    table is necessary due to the implicit many-to-many relationship that a social
    connection requires. Take a close look at the `followed` attribute, as shown in
    the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模型的`followed`属性是一个SQLAlchemy关系，它通过中间的关注者表将用户表映射到自身。由于社交连接需要隐式的多对多关系，中间表是必要的。仔细看一下`followed`属性，如下所示的代码：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see that the declaration is somewhat complex in comparison to the regular
    column definitions that we used in this chapter and in previous ones. However,
    each argument to the `relationship` function has a very definite purpose, as shown
    in the following list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，与本章和以前章节中使用的常规列定义相比，声明有些复杂。然而，`relationship`函数的每个参数都有一个非常明确的目的，如下列表所示：
- en: '`User`: This is the string-based name of the target relationship class. This
    can also be the mapped class itself, but then you might end up in a quagmire of
    circular import problems.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`：这是目标关系类的基于字符串的名称。这也可以是映射类本身，但是那样你可能会陷入循环导入问题的泥潭。'
- en: '`primaryjoin`: The value of this argument will be evaluated and then used as
    the `join` condition for the primary table (`user`) to the association table (`follower`).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`primaryjoin`：这个参数的值将被评估，然后用作主表（`user`）到关联表（`follower`）的`join`条件。'
- en: '`secondaryjoin`: The value of this argument, similar to the `primaryjoin`,
    is evaluated and then used in the `join` condition of the association table (`follower`)
    to the child table (`user`). As our primary and child tables are one and the same
    (users follow other users), this condition is almost identical to the one produced
    in the `primaryjoin` argument, differing only in the key that is mapped in the
    association table.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secondaryjoin`：这个参数的值，类似于`primaryjoin`，在关联表（`follower`）到子表（`user`）的`join`条件中被评估并使用。由于我们的主表和子表是一样的（用户关注其他用户），这个条件几乎与`primaryjoin`参数中产生的条件相同，只是在关联表中映射的键方面有所不同。'
- en: '`backref`: This is the name of the property that will be inserted on an instance
    that will handle the reverse direction of the relationship. This means that once
    we have a user instance, we can access `user.followers` to get the list of people
    that are following the given user instance, as opposed to the `user.followed`
    attribute in which we explicitly define the list of users that the current user
    is following.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backref`：这是将插入到实例上的属性的名称，该属性将处理关系的反向方向。这意味着一旦我们有了一个用户实例，我们就可以访问`user.followers`来获取关注给定用户实例的人的列表，而不是`user.followed`属性，其中我们明确定义了当前用户正在关注的用户列表。'
- en: '`lazy`: This is the most often misused attribute for any relationship-based
    property. There are various values available, ranging from `select`, `immediate`,
    `joined`, `subquery`, `noload`, and `dynamic`. These determine how or when the
    related data is loaded. For our application, we''ve chosen to use the value of
    dynamic, which, instead of returning an iterable collection, returns a `Query`
    object that can then be further refined and acted on. For example, we can do something
    such as `user.followed.filter(User.username == ''example'')`. While this is not
    very useful in this particular instance, it provides a huge amount of flexibility,
    sometimes at the cost of generating less efficient SQL queries.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lazy`：这是任何基于关系的属性最常被误用的属性。有各种可用的值，包括`select`、`immediate`、`joined`、`subquery`、`noload`和`dynamic`。这些确定了相关数据的加载方式或时间。对于我们的应用程序，我们选择使用`dynamic`的值，它不返回一个可迭代的集合，而是返回一个可以进一步细化和操作的`Query`对象。例如，我们可以做一些像`user.followed.filter(User.username
    == ''example'')`这样的事情。虽然在这种特定情况下并不是非常有用，但它提供了巨大的灵活性，有时以生成效率较低的SQL查询为代价。'
- en: 'The various attributes that we will set are to ensure that the generated queries
    use the correct columns to create the self-referential many-to-many join and the
    query to obtain the list of followers is only executed when we need it. More information
    about these particular patterns can be found in the official SQLAlchemy documentation:
    [http://docs.sqlalchemy.org/en/latest/](http://docs.sqlalchemy.org/en/latest/).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置各种属性，以确保生成的查询使用正确的列来创建自引用的多对多连接，并且只有在需要时才执行获取关注者列表的查询。关于这些特定模式的更多信息可以在官方的SQLAlchemy文档中找到：[http://docs.sqlalchemy.org/en/latest/](http://docs.sqlalchemy.org/en/latest/)。
- en: 'Now, we will add a few methods to our User model that will facilitate the following/unfollowing
    of other users. Thanks to some under-the-hood cleverness from SQLAlchemy, adding
    and removing followers for a user can be expressed as if you were acting on a
    native Python list, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的用户模型添加一些方法，以便便于关注/取消关注其他用户。由于SQLAlchemy的一些内部技巧，为用户添加和移除关注者可以表达为对本地Python列表的操作，如下所示：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In reality, you are not acting on a native Python list, but rather a data structure
    that SQLAlchemy knows how to track the removals and additions from and then synchronize
    these to the database via the Unit of Work pattern.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您并不是在原生的Python列表上操作，而是在SQLAlchemy知道如何跟踪删除和添加的数据结构上操作，然后通过工作单元模式将这些同步到数据库。
- en: Next, we will create the `Post` model and we'll do so in the blueprint module
    of `application/posts/models.py`. As usual, don't forget to create the `application/posts/__init__.py`
    file in order to declare the folder as a valid Python package, otherwise some
    very confusing import errors will occur when you attempt to run the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`application/posts/models.py`的蓝图模块中创建`Post`模型。像往常一样，不要忘记创建`application/posts/__init__.py`文件，以便将文件夹声明为有效的Python包，否则在尝试运行应用程序时将出现一些非常令人困惑的导入错误。
- en: 'For now, this particular model will be a paragon of simplicity. Here''s the
    current implementation of the User model for this project:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个特定的模型将是一个简单的典范。以下是该项目的用户模型的当前实现：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we have our `Post` model defined, we can now add a method to the User
    model that will allow us to fetch the newsfeed for the user that is linked by
    the current instance. We name that method `newsfeed`, and it''s implementation
    is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了`Post`模型，我们现在可以为用户模型添加一个方法，该方法允许我们获取与当前实例链接的用户的新闻源。我们将该方法命名为`newsfeed`，其实现如下：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we must import the `Post` model to the `application/users/models.py`
    module in order to implement the preceding method as described. While this particular
    scenario will function without issue, one must always be wary of the potential
    circular import problems that may be somewhat difficult to diagnose.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了实现上述方法，我们必须将`Post`模型导入到`application/users/models.py`模块中。虽然这种特定的情况将正常运行，但必须始终注意可能会有一些难以诊断的潜在循环导入问题。
- en: Functional and integration testing
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能和集成测试
- en: In most of the treatments of unit, functional, and integration testing, it is
    often recommended that you write the tests before the corresponding code itself
    is written. While this is generally considered to be a good practice for a variety
    of reasons (primarily allowing you to ensure that the code being written solves
    the problem that has been defined), for the sake of simplicity, we have waited
    until now to touch on this subject.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数单元、功能和集成测试的处理中，通常建议在编写相应的代码之前编写测试。虽然这通常被认为是一个良好的实践，出于各种原因（主要是允许您确保正在编写的代码解决了已定义的问题），但为了简单起见，我们等到现在才涉及这个主题。
- en: 'First, let''s create a new `test_settings.py` file that is sibling to our existing
    `settings.py`. This new file will contain the application configuration constants
    that we want to use while running our test suite. Most importantly, it will contain
    the URI to a database that is not our application database, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的`test_settings.py`文件，它与我们现有的`settings.py`同级。这个新文件将包含我们在运行测试套件时想要使用的应用程序配置常量。最重要的是，它将包含一个指向不是我们应用程序数据库的数据库的URI，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding `SQLALCHEMY_DATABASE_URI` string points to `/tmp/test_app.db`
    as the location for the test database. You may of course choose a different path
    than the system-wide `tmp` directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`SQLALCHEMY_DATABASE_URI`字符串指向`/tmp/test_app.db`作为测试数据库的位置。当然，您可以选择与系统范围的`tmp`目录不同的路径。
- en: 'We will also make a few additions to the `conftest.py` file in order to add
    additional fixtures for initializing a test database and ensuring that we have
    a SQLAlchemy database session object available for any test functions that may
    require it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将对`conftest.py`文件进行一些添加，以添加额外的装置，用于初始化测试数据库，并确保我们有一个SQLAlchemy数据库会话对象可用于可能需要它的任何测试函数：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The session fixture can be augmented with explicit transactions, ensuring that
    a transaction is begun and then committed in the teardown. The (simple) implementation
    of this is left as an exercise to the reader.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 会话装置可以通过显式事务进行增强，确保在拆卸时开始并提交事务。这个（简单）实现留给读者作为一个练习。
- en: 'The `scope` argument indicates the lifetime of the given fixture object once
    it has been created. In the preceding example, we indicated `function` for the
    session fixture, which means that a new fixture object will be created for each
    test function that is invoked as an argument. If we used `module` as our scope
    value, we would have a new fixture created for each `module` that the fixture
    is included in: a single fixture would be used for all the tests in our module.
    This should not be confused with the `session` scope value, which indicates that
    a single fixture object is to be created for the entire duration of our test suite
    run. The session scope can be useful in situations where, for example, creating
    a database connection is an extremely expensive operation. If we only had to create
    the database connection once, the total runtime of our test suite might be significantly
    reduced.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`scope`参数指示了创建的装置对象的生命周期。在前面的例子中，我们为会话装置指定了`function`，这意味着为每个作为参数调用的测试函数创建一个新的装置对象。如果我们使用`module`作为我们的作用域值，我们将为每个包含该装置的`module`创建一个新的装置：一个装置将用于模块中的所有测试。这不应与`session`作用域值混淆，后者表示为整个测试套件运行的整个持续时间创建一个装置对象。会话范围可以在某些情况下非常有用，例如，创建数据库连接是一个非常昂贵的操作。如果我们只需要创建一次数据库连接，那么测试套件的总运行时间可能会大大缩短。'
- en: 'For additional information on the `scope` argument for the `py.test` fixture
    decorator and the use of the built-in `request` object to add the teardown finalizer
    callback functions, the online documentation is a fantastic starting point: [https://pytest.org/latest/contents.html](https://pytest.org/latest/contents.html).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`py.test`装置装饰器的`scope`参数以及使用内置的`request`对象添加拆卸终结器回调函数的更多信息，可以查看在线文档：[https://pytest.org/latest/contents.html](https://pytest.org/latest/contents.html)。
- en: 'We can write a simple test to create a new user from our declarative User model
    in `tests/test_user_model.py`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个简单的测试，从我们的声明性用户模型中创建一个新用户，在`tests/test_user_model.py`中：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After running the test suite with `py.test`, we should see our newly created
    test file appear in the listed output and our tests should run without error.
    We will assert that our newly created user should have an ID (assigned by the
    database) and should not be following any other users. Consequently, the newsfeed
    for the user that we created should also have no elements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`py.test`运行测试套件后，我们应该看到我们新创建的测试文件出现在列出的输出中，并且我们的测试应该无错误地运行。我们将断言我们新创建的用户应该有一个ID（由数据库分配），并且不应该关注任何其他用户。因此，我们创建的用户的新闻源也不应该有任何元素。
- en: 'Let''s add some more tests for the nontrivial parts of our user data model,
    which will ensure that our follow/following relationships work as expected:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为用户数据模型的非平凡部分添加一些更多的测试，这将确保我们的关注/关注关系按预期工作：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Publish/subscribe events with Blinker
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Blinker发布/订阅事件
- en: One of the many difficulties in the lifecycle of any nontrivial application
    is ensuring that the right level of modularity is present in the codebase.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何非平凡应用程序的生命周期中，一个困难是确保代码库中存在正确的模块化水平。
- en: There exist various methodologies to create interfaces, objects, and services
    and implementing design patterns that help us manage the ever-increasing complexity
    that is inevitably created for a real-world application. One methodology that
    is often left unexplored for web applications is the in-process `publish-subscribe`
    design pattern.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 存在各种方法来创建接口、对象和服务，并实现设计模式，帮助我们管理不断增加的复杂性，这是不可避免地为现实世界的应用程序所创建的。一个经常被忽视的方法是Web应用程序中的进程内`发布-订阅`设计模式。
- en: 'Generally, `publish-subscribe`, or more colloquially known as pub/sub, is a
    messaging pattern where two classes of participants exist: **publishers** and
    **subscribers**. Publishers send messages and subscribers subscribe to a subset
    of the messages that are produced via the topic (a named channel) or via the content
    of the message itself.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`发布-订阅`，或者更通俗地称为pub/sub，是一种消息模式，其中存在两类参与者：**发布者**和**订阅者**。发布者发送消息，订阅者订阅通过主题（命名通道）或消息内容本身产生的消息的子集。
- en: In large distributed systems, pub/sub is usually mediated by a message bus or
    broker that communicates with all the various publishers and subscribers and ensures
    that the published messages are routed to the subscribers that are interested
    in them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型分布式系统中，pub/sub通常由一个消息总线或代理来中介，它与所有各种发布者和订阅者通信，并确保发布的消息被路由到感兴趣的订阅者。
- en: 'For our purpose, however, we can use something a little simpler: an in-process
    pub/sub system using the wonderfully simple `Blinker` package, which is supported
    by Flask if it is installed.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了我们的目的，我们可以使用一些更简单的东西：使用非常简单的`Blinker`包支持的进程内发布/订阅系统，如果安装了Flask。
- en: Signals from Flask and extensions
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自Flask和扩展的信号
- en: When the `Blinker` package is present, Flask allows you to subscribe to various
    signals (topics) that are published. In addition, Flask extensions may implement
    their own custom signals. You can subscribe to any number of signals in your application,
    but the order in which the signal subscribers will receive the messages is undefined.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在`Blinker`包时，Flask允许您订阅发布的各种信号（主题）。此外，Flask扩展可以实现自己的自定义信号。您可以订阅应用程序中的任意数量的信号，但是信号订阅者接收消息的顺序是未定义的。
- en: 'A few of the more interesting signals that Flask publishes are described in
    the following list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Flask发布的一些更有趣的信号在以下列表中描述：
- en: '`request_started`: This is sent immediately after the request context was created
    but before any request processing occurs'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request_started`: 这是在请求上下文创建后立即发送的，但在任何请求处理发生之前'
- en: '`request_finished`: This is sent after the response has been constructed but
    immediately before it is sent back to the client'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request_finished`: 这是在响应构造后发送的，但在发送回客户端之前立即发送'
- en: 'The Flask-SQLAlchemy extension publishes the following two signals itself:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy扩展本身发布了以下两个信号：
- en: '`models_committed`: This is sent after any modified model instances are committed
    to the database'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models_committed`: 这是在任何修改的模型实例提交到数据库后发送的'
- en: '`before_models_committed`: This is sent just before the model instances are
    committed to the database'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before_models_committed`: 这是在模型实例提交到数据库之前发送的'
- en: 'Flask-Login publishes half a dozen signals, many of which can be utilized for
    modularizing the authentication concerns. A few useful ones are listed here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-Login发布了半打信号，其中许多可以用于模块化认证问题。以下列出了一些有用的信号：
- en: '`user_logged_in`: This is sent when a user logs in'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_logged_in`: 当用户登录时发送'
- en: '`user_logged_out`: This is sent when a user logs out'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_logged_out`: 当用户注销时发送'
- en: '`user_unauthorized`: This is sent when an unauthenticated user attempts to
    access a resource that requires authentication'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_unauthorized`: 当未经认证的用户尝试访问需要认证的资源时发送'
- en: Creating custom signals
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义信号
- en: In addition to subscribing to the signal topics that are published by Flask
    and various Flask extensions, it's also possible (and sometimes very useful!)
    to create your own custom signals that may then be consumed in your own application.
    While this may seem like a roundabout approach where a simple function or method
    call would suffice, the ability to separate out orthogonal concerns from the various
    parts of your application is an attractive proposal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了订阅由Flask和各种Flask扩展发布的信号主题之外，还可以（有时非常有用！）创建自己的自定义信号，然后在自己的应用程序中使用。虽然这可能看起来像是一个绕圈子的方法，简单的函数或方法调用就足够了，但是将应用程序的各个部分中的正交关注点分离出来的能力是一个吸引人的建议。
- en: For example, say you have a User model that has an `update_password` method,
    which allows the password for the given user instance to be changed to a new given
    value. When the password is changed, we would like to send an e-mail to the user,
    informing them that this action has occurred.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个用户模型，其中有一个`update_password`方法，允许更改给定用户实例的密码为新的值。当密码被更改时，我们希望向用户发送一封邮件，通知他们发生了这个动作。
- en: 'Now, the straightforward implementation of this would be to simply have the
    mail sent in the `update_password` method itself, which is inherently not a bad
    idea. Imagine, however, that we have yet another dozen instances where incurred
    actions require that an e-mail be sent out to the user: when they are followed
    by a new user, when they are unfollowed by a user, when they reach a certain threshold
    of followers, and the list goes on.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个功能的简单实现就是在`update_password`方法中发送邮件，这本身并不是一个坏主意。然而，想象一下，我们还有另外十几个实例需要发送邮件给用户：当他们被新用户关注时，当他们被用户取消关注时，当他们达到一定的关注者数量时，等等。
- en: 'The problem then becomes apparent: we have mixed logic and functionality to
    send an e-mail to a user in various parts of our application, which makes it increasingly
    difficult to reason about, debug, and refactor.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后问题就显而易见了：我们在应用程序的各个部分混合了发送邮件给用户的逻辑和功能，这使得越来越难以理解、调试和重构。
- en: While several methods to manage this complexity exist, the explicit separation
    of concerns that is possible becomes readily apparent when a publish/subscribe
    pattern is implemented. With custom signals in our Flask application, we can create
    a follower-added signal where an event is published after the action takes place
    and any number of subscribers can listen for that particular event. Moreover,
    we can organize our application in such a way that the signal subscribers for
    similar events (for example, sending out an e-mail notification) reside in the
    same location in the codebase.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几种方法可以管理这种复杂性，但当实现发布/订阅模式时，可以明显地看到可能的关注点的明确分离。在我们的Flask应用程序中使用自定义信号，我们可以创建一个添加关注者的信号，在动作发生后发布一个事件，任何数量的订阅者都可以监听该特定事件。此外，我们可以组织我们的应用程序，使得类似事件的信号订阅者（例如，发送电子邮件通知）在代码库中的同一位置。
- en: 'Let''s create a signal that will publish an event whenever a user follows another
    user. First, we will need to create our `Namespace` signal container object so
    that we can then declare our signal topics. Let''s do this in `application/__init__.py`
    module:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个信号，每当一个用户关注另一个用户时就发布一个事件。首先，我们需要创建我们的`Namespace`信号容器对象，以便我们可以声明我们的信号主题。让我们在`application/__init__.py`模块中做这件事：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once this is in place, emitting the `user-followed` event in our `User.follow()`
    method is simple, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个功能就位，我们在`User.follow()`方法中发出`user-followed`事件就很简单了，如下所示：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to add the [PRE23]
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 记得添加[PRE23]
- en: __all__ = ['user_followed_email']
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: __all__ = ['user_followed_email']
- en: import logging
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: import logging
- en: logging.basicConfig(level=logging.DEBUG)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: logging.basicConfig(level=logging.DEBUG)
- en: logger = logging.getLogger(__name__)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: logger = logging.getLogger(__name__)
- en: 'def user_followed_email(user, **kwargs):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'def user_followed_email(user, **kwargs):'
- en: logger.debug(
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: logger.debug(
- en: '"Send an email to {user}".format(user=user.username))'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '"向{user}发送电子邮件".format(user=user.username))'
- en: from application import user_followed
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: from application import user_followed
- en: 'def connect_handlers():'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'def connect_handlers():'
- en: user_followed.connect(user_followed_email)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: user_followed.connect(user_followed_email)
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: from flask import Flask
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: from flask import Flask
- en: from flask.ext.sqlalchemy import SQLAlchemy
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: from flask.ext.sqlalchemy import SQLAlchemy
- en: from flask.ext.bcrypt import Bcrypt
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: from flask.ext.bcrypt import Bcrypt
- en: from blinker import Namespace
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: from blinker import Namespace
- en: Initialize the db extension, but without configuring
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化db扩展，但不配置
- en: it with an application instance.
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它与应用程序实例一起。
- en: db = SQLAlchemy()
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: db = SQLAlchemy()
- en: flask_bcrypt = Bcrypt()
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: flask_bcrypt = Bcrypt()
- en: socializer_signals = Namespace()
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: socializer_signals = Namespace()
- en: user_followed = socializer_signals.signal('user-followed')
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: user_followed = socializer_signals.signal('user-followed')
- en: from signal_handlers import connect_handlers
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: from signal_handlers import connect_handlers
- en: connect_handlers()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: connect_handlers()
- en: …
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: …
- en: …
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: …
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: from flask import Blueprint, render_template, url_for, redirect, flash, g
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: from flask import Blueprint, render_template, url_for, redirect, flash, g
- en: from flask.ext.login import login_user, logout_user
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: from flask.ext.login import login_user, logout_user
- en: from flask.ext.wtf import Form
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: from flask.ext.wtf import Form
- en: from wtforms import StringField, PasswordField
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: from wtforms import StringField, PasswordField
- en: from wtforms.validators import DataRequired, Length
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: from wtforms.validators import DataRequired, Length
- en: from models import User
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: from models import User
- en: from application import db, flask_bcrypt
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: from application import db, flask_bcrypt
- en: users = Blueprint('users', __name__, template_folder='templates')
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: users = Blueprint('users', __name__, template_folder='templates')
- en: "class Login\tForm(Form):"
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: "class Login\tForm(Form):"
- en: '"""'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Represents the basic Login form elements & validators.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 表示基本的登录表单元素和验证器。
- en: '"""'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: username = StringField('username',
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: username = StringField('username',
- en: validators=[DataRequired()])
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: validators=[DataRequired()])
- en: password = PasswordField('password',
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: password = PasswordField('password',
- en: validators=[DataRequired(),Length(min=6)])
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: validators=[DataRequired(),Length(min=6)])
- en: 'class CreateUserForm(Form):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'class CreateUserForm(Form):'
- en: '"""'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Encapsulate the necessary information required for creating a new user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 封装创建新用户所需的必要信息。
- en: '"""'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: username = StringField('username', validators=[DataRequired(), Length(min=3,
    max=40)])
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: username = StringField('username', validators=[DataRequired(), Length(min=3,
    max=40)])
- en: email = StringField('email', validators=[DataRequired(), Length(max=255)])
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: email = StringField('email', validators=[DataRequired(), Length(max=255)])
- en: password = PasswordField('password', validators=[DataRequired(),
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: password = PasswordField('password', validators=[DataRequired(),
- en: Length(min=8)])
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Length(min=8)])
- en: '@users.route(''/signup'', methods=[''GET'', ''POST''])'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '@users.route(''/signup'', methods=[''GET'', ''POST''])'
- en: 'def signup():'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'def signup():'
- en: '"""'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Basic user creation functionality.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用户创建功能。
- en: '"""'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: form = CreateUserForm()
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: form = CreateUserForm()
- en: 'if form.validate_on_submit():'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'if form.validate_on_submit():'
- en: user = User( username=form.username.data,
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: user = User( username=form.username.data,
- en: email=form.email.data,
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: email=form.email.data,
- en: password=form.password.data)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: password=form.password.data)
- en: add the user to the database
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户添加到数据库
- en: db.session.add(user)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: db.session.add(user)
- en: db.session.commit()
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: db.session.commit()
- en: Once we have persisted the user to the database successfully,
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一旦我们成功将用户持久化到数据库中，
- en: authenticate that user for the current session
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证当前会话的用户
- en: login_user(user, remember=True)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: login_user(user，remember=True)
- en: return redirect(url_for('users.index'))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 返回重定向到url_for('users.index')
- en: return render_template('users/signup.html', form=form)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 返回render_template('users/signup.html'，form=form)
- en: '@users.route(''/'', methods=[''GET''])'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '@users.route(''/''，methods=[''GET''])'
- en: 'def index():'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'def index():'
- en: return "User index page!", 200
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 返回"用户索引页！"，200
- en: '@users.route(''/login'', methods=[''GET'', ''POST''])'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '@users.route(''/login''，methods=[''GET''，''POST''])'
- en: 'def login():'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'def login():'
- en: '"""'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Basic user login functionality.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用户登录功能。
- en: '"""'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if hasattr(g, ''user'') and g.user.is_authenticated():'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果g中有'user'属性并且g.user.is_authenticated（）：
- en: return redirect(url_for('users.index'))
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 返回重定向到url_for('users.index')
- en: form = LoginForm()
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: form = LoginForm()
- en: 'if form.validate_on_submit():'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果form.validate_on_submit（）：
- en: We use one() here instead of first()
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在这里使用one（）而不是first（）
- en: user = User.query.filter_by(username=form.username.data).one()
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: user = User.query.filter_by(username=form.username.data).one()
- en: 'if not user or not flask_bcrypt.check_password_hash(user.password, form.password.data):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不存在或者flask_bcrypt.check_password_hash(user.password，form.password.data)：
- en: flash("No such user exists.")
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: flash("不存在这样的用户。")
- en: return render_template('users/login.html', form=form)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 返回render_template('users/login.html'，form=form)
- en: login_user(user, remember=True)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: login_user(user，remember=True)
- en: return redirect(url_for('users.index'))
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 返回重定向到url_for('users.index')
- en: return render_template('users/login.html', form=form)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 返回render_template('users/login.html'，form=form)
- en: '@users.route(''/logout'', methods=[''GET''])'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '@users.route(''/logout''，methods=[''GET''])'
- en: 'def logout():'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'def logout():'
- en: logout_user()
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: logout_user()
- en: return redirect(url_for('users.login'))
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 返回重定向到url_for('users.login')
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '{% extends "layout.html" %}'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '{% extends "layout.html" %}'
- en: '{% block content %}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '{% block content %}'
- en: <form action="{{ url_for('users.signup')}}" method="post">
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <form action="{{ url_for('users.signup')}}" method="post">
- en: '{{ form.hidden_tag() }}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ form.hidden_tag() }}'
- en: '{{ form.id }}'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ form.id }}'
- en: '<div>{{ form.username.label }}: {{ form.username }}</div>'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '<div>{{ form.username.label }}: {{ form.username }}</div>'
- en: '{% if form.username.errors %}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '{% if form.username.errors %}'
- en: <ul class="errors">{% for error in form.username.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <ul class="errors">{% for error in form.username.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
- en: '{% endif %}'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '{% endif %}'
- en: '<div>{{ form.email.label }}: {{ form.email }}</div>'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '<div>{{ form.email.label }}: {{ form.email }}</div>'
- en: '{% if form.email.errors %}'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '{% if form.email.errors %}'
- en: <ul class="errors">{% for error in form.email.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <ul class="errors">{% for error in form.email.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
- en: '{% endif %}'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '{% endif %}'
- en: '<div>{{ form.password.label }}: {{ form.password }}</div>'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '<div>{{ form.password.label }}: {{ form.password }}</div>'
- en: '{% if form.password.errors %}'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '{% if form.password.errors %}'
- en: <ul class="errors">{% for error in form.password.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <ul class="errors">{% for error in form.password.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
- en: '{% endif %}'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '{% endif %}'
- en: <div><input type="submit" value="Sign up!"></div>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <div><input type="submit" value="注册！"></div>
- en: </form>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: </form>
- en: '{% endblock %}'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '{% endblock %}'
- en: '[PRE27]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: from flask import Flask
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 来自flask的导入Flask
- en: from flask.ext.sqlalchemy import SQLAlchemy
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 来自flask.ext.sqlalchemy的导入SQLAlchemy
- en: from flask.ext.bcrypt import Bcrypt
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 来自flask.ext.bcrypt的导入Bcrypt
- en: from blinker import Namespace
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 来自blinker的导入Namespace
- en: from flask.ext.login import LoginManager
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 来自flask.ext.login的导入LoginManager
- en: Initialize the db extension, but without configuring
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化db扩展，但不配置
- en: it with an application instance.
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它与应用程序实例一起。
- en: db = SQLAlchemy()
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: db = SQLAlchemy()
- en: flask_bcrypt = Bcrypt()
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: flask_bcrypt = Bcrypt()
- en: login_manager = LoginManager()
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: login_manager = LoginManager()
- en: socializer_signals = Namespace()
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: socializer_signals = Namespace()
- en: user_followed = socializer_signals.signal('user-followed')
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: user_followed = socializer_signals.signal('user-followed')
- en: from signal_handlers import *
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: from signal_handlers import *
- en: 'def create_app(config=None):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_app(config=None):'
- en: app = Flask(__name__)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: app = Flask(__name__)
- en: 'if config is not None:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果config不为None：
- en: app.config.from_object(config)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: app.config.from_object(config)
- en: Initialize any extensions and bind blueprints to the
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化任何扩展并将蓝图绑定到
- en: application instance here.
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序实例在这里。
- en: db.init_app(app)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: db.init_app(app)
- en: flask_bcrypt.init_app(app)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: flask_bcrypt.init_app(app)
- en: login_manager.init_app(app)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: login_manager.init_app(app)
- en: from application.users.views import users
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 来自应用程序用户视图的导入用户
- en: app.register_blueprint(users, url_prefix='/users')
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: app.register_blueprint(users，url_prefix='/users')
- en: from application.users import models as user_models
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 来自应用程序用户的导入模型作为user_models
- en: '@login_manager.user_loader'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '@login_manager.user_loader'
- en: 'de fload_user(user_id):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'de fload_user(user_id):'
- en: return user_models.User.query.get(int(user_id))
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回user_models.User.query.get(int(user_id))
- en: return app
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 返回app
- en: '[PRE28]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: SQLALCHEMY_DATABASE_URI = 'sqlite:///socializer.db'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: SQLALCHEMY_DATABASE_URI = 'sqlite:///socializer.db'
- en: SECRET_KEY = 'BpRvzXZ800[-t:=z1eZtx9t/,P*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: SECRET_KEY = 'BpRvzXZ800[-t:=z1eZtx9t/，P*'
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: place with other imports…
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放在其他导入的地方…
- en: from sqlalchemy import exc
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从sqlalchemy导入exc
- en: …
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: …
- en: 'try:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: db.session.add(user)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: db.session.add(user)
- en: db.session.commit()
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: db.session.commit()
- en: 'except exc.IntegrityError as e:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 'except exc.IntegrityError as e:'
- en: A unique column constraint was violated
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 唯一列约束被违反
- en: current_app.exception("User unique constraint violated.")
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: current_app.exception("用户唯一约束违反。")
- en: return render_template('users/signup.html', form=form)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 返回render_template('users/signup.html'，form=form)
- en: 'except exc.SQLAlchemyError:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'except exc.SQLAlchemyError:'
- en: current_app.exception("Could not save new user!")
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: current_app.exception("无法保存新用户！")
- en: flash("Something went wrong while creating this user!")
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: flash("创建此用户时出现问题！")
- en: return render_template('users/signup.html', form=form)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 返回render_template('users/signup.html'，form=form)
- en: '[PRE30]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'try:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: We use one() here instead of first()
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在这里使用one（）而不是first（）
- en: user = User.query.filter_by(
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: user = User.query.filter_by(
- en: username=form.username.data).one()s
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: username=form.username.data).one()s
- en: 'except NoResultFound:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'except NoResultFound:'
- en: flash("User {username} does not exist.".format(
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: flash("用户{username}不存在。".format(
- en: username=form.username.data))
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: username=form.username.data））
- en: return render_template('users/login.html', form=form)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 返回render_template('users/login.html'，form=form)
- en: …
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: …
- en: '[PRE31]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'def test_get_user_signup_page(client):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_get_user_signup_page(client):'
- en: '"""Ensure signup page is available."""'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '"""确保注册页面可用。"""'
- en: response = client.get('/users/signup')
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: response = client.get('/users/signup')
- en: assert response.status_code == 200
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: assert response.status_code == 200
- en: assert 'Sign up!' in response.data
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: assert '注册！' in response.data
- en: '[PRE32]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: from flask import session, get_flashed_messages
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 来自flask的导入session，get_flashed_messages
- en: from application.users.models import User
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 来自应用程序用户模型的导入用户
- en: from application import flask_bcrypt
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 来自应用程序的导入flask_bcrypt
- en: 'def test_signup_new_user(client):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: def test_signup_new_user（client）：
- en: '"""Successfully sign up a new user."""'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '"""成功注册新用户。"""'
- en: 'data = {''username'': ''test_username'', ''email'': ''test@example.com'','
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 数据= {'用户名'：'test_username'，'电子邮件'：'test@example.com'，
- en: '''password'': ''my test password''}'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '''password''：''my test password''}'
- en: response = client.post('/users/signup', data=data)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 响应=客户端发布（'/用户/注册'，数据=数据）
- en: On successful creation we redirect.
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功创建后我们重定向。
- en: assert response.status_code == 302
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 断言response.status_code == 302
- en: Assert that a session was created due to successful login
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言由于成功登录而创建了会话
- en: assert '_id' in session
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 断言'_id'在会话中
- en: Ensure that we have no stored flash messages indicating an error
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保我们没有存储的闪存消息指示错误
- en: occurred.
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生。
- en: assert get_flashed_messages() == []
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 断言get_flashed_messages（）== []
- en: user = User.query.filter_by(username=data['username']).one()
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: user = User.query.filter_by（username = data['username']）。one（）
- en: assert user.email == data['email']
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 断言用户电子邮件==数据['电子邮件']
- en: assert user.password
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 断言用户密码
- en: assert flask_bcrypt.check_password_hash(
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 断言flask_bcrypt.check_password_hash（
- en: user.password, data['password'])
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: user.password，data['password']）
- en: '[PRE33]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: import pytest
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 导入pytest
- en: import sqlalchemy
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 导入sqlalchemy
- en: 'def test_signup_invalid_user(client):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: def test_signup_invalid_user（client）：
- en: '"""Try to sign up with invalid data."""'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '"""尝试使用无效数据注册。"""'
- en: 'data = {''username'': ''x'', ''email'': ''short@example.com'','
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 数据= {'用户名'：'x'，'电子邮件'：'short@example.com'，
- en: '''password'': ''a great password''}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '''password''：''a great password''}'
- en: response = client.post('/users/signup', data=data)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 响应=客户端发布（'/用户/注册'，数据=数据）
- en: With a form error, we still return a 200 to the client since
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有了表单错误，我们仍然向客户端返回200
- en: browsers are not always the best at handling proper 4xx response codes.
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器并不总是最擅长处理正确的4xx响应代码。
- en: assert response.status_code == 200
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 断言response.status_code == 200
- en: assert 'must be between 3 and 40 characters long.' in response.data
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 断言'must be between 3 and 40 characters long.'在response.data中
- en: '[PRE34]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'def test_signup_invalid_user_missing_fields(client):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: def test_signup_invalid_user_missing_fields（client）：
- en: '"""Try to sign up with missing email."""'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '"""尝试使用缺少的电子邮件注册。"""'
- en: 'data = {''username'': ''no_email'', ''password'': ''a great password''}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 数据= {'用户名'：'no_email'，'密码'：'a great password'}
- en: response = client.post('/users/signup', data=data)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: response = client.post（'/users/signup'，数据=数据）
- en: assert response.status_code == 200
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 断言response.status_code == 200
- en: assert 'This field is required' in response.data
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 断言'required'在response.data中
- en: 'with pytest.raises(sqlalchemy.orm.exc.NoResultFound):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: with pytest.raises（sqlalchemy.orm.exc.NoResultFound）：
- en: User.query.filter_by(username=data['username']).one()
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.filter_by（username = data['username']）。one（）
- en: 'data = {''username'': ''no_password'', ''email'': ''test@example.com''}'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '数据= {''用户名'': ''无密码''，''电子邮件''：''test@example.com''}'
- en: response = client.post('/users/signup', data=data)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 响应=客户端发布（'/用户/注册'，数据=数据）
- en: assert response.status_code == 200
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 断言response.status_code == 200
- en: assert 'This field is required' in response.data
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 断言'required'在response.data中
- en: 'with pytest.raises(sqlalchemy.orm.exc.NoResultFound):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: with pytest.raises（sqlalchemy.orm.exc.NoResultFound）：
- en: User.query.filter_by(username=data['username']).one()
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.filter_by（username = data['username']）。one（）
- en: '[PRE35]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'class Post(db.Model):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 类帖子（db.Model）：
- en: …
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: …
- en: user = db.relationship('User',
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: user = db.relationship（'User'，
- en: backref=db.backref('posts', lazy='dynamic'))
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: backref = db.backref（'posts'，lazy ='dynamic'）
- en: '[PRE36]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '@users.route(''/feed'', methods=[''GET''])'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '@users.route（''/feed''，methods = [''GET'']）'
- en: '@login_required'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '@login_required'
- en: 'def feed():'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: def feed（）：
- en: '"""'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: List all posts for the authenticated user; most recent first.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 列出经过身份验证的用户的所有帖子；最近的第一个。
- en: '"""'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: posts = current_user.newsfeed()
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子= current_user.newsfeed（）
- en: return render_template('users/feed.html', posts=posts)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 返回render_template（'users/feed.html'，posts=posts）
- en: '[PRE37]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '{% extends "layout.html" %}'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '{% extends "layout.html" %}'
- en: '{% block content %}'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '{% block content %}'
- en: <div class="new-post">
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: <div class="new-post">
- en: <p><a href="{{url_for('posts.add')}}">New Post</a></p>
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: <p><a href="{{url_for('posts.add')}}">New Post</a></p>
- en: </div>
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '{% for post in posts %}'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '{% for post in posts %}'
- en: <div class="post">
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: <div class="post">
- en: <span class="author">{{post.user.username}}</span>, published on <span class="date">{{post.created_on}}</span>
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: <span class="author">{{post.user.username}}</span>，发布于<span class="date">{{post.created_on}}</span>
- en: <pre><code>{{post.content}}</code></pre>
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: <pre><code>{{post.content}}</code></pre>
- en: </div>
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '{% endfor %}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '{% endfor %}'
- en: '{% endblock %}'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '{% endblock %}'
- en: '[PRE38]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: from flask import Blueprint, render_template, url_for, redirect, flash, current_app
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 从flask导入蓝图，render_template，url_for，重定向，闪存，current_app
- en: from flask.ext.login import login_required, current_user
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 从flask.ext.login导入login_required，current_user
- en: from flask.ext.wtf import Form
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 从flask.ext.wtf导入表单
- en: from wtforms import StringField
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 从wtforms导入字符串字段
- en: from wtforms.widgets import TextArea
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 从wtforms.widgets导入TextArea
- en: from wtforms.validators import DataRequired
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 从wtforms.validators导入DataRequired
- en: from sqlalchemy import exc
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 从sqlalchemy导入exc
- en: from models import Post
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 从模型导入帖子
- en: from application import db
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序导入db
- en: posts = Blueprint('posts', __name__, template_folder='templates')
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子= Blueprint（'posts'，__name__，template_folder ='templates'）
- en: 'class CreatePostForm(Form):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 类CreatePostForm（Form）：
- en: '"""Form for creating new posts."""'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '"""用于创建新帖子的表单。"""'
- en: content = StringField('content', widget=TextArea(),
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: content = StringField（'content'，widget = TextArea（），
- en: validators=[DataRequired()])
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: validators=[DataRequired（）]
- en: '@posts.route(''/add'', methods=[''GET'', ''POST''])'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '@posts.route（''/add''，methods = [''GET''，''POST'']）'
- en: '@login_required'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '@login_required'
- en: 'def add():'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: def add（）：
- en: '"""Add a new post."""'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '"""添加新帖子。"""'
- en: form = CreatePostForm()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: form = CreatePostForm（）
- en: 'if form.validate_on_submit():'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果form.validate_on_submit（）：
- en: user_id = current_user.id
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: user_id = current_user.id
- en: post = Post(user_id=user_id, content=form.content.data)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: post = Post（user_id = user_id，content = form.content.data）
- en: db.session.add(post)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: db.session.add（post）
- en: 'try:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: db.session.commit()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: db.session.commit（）
- en: 'except exc.SQLAlchemyError:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 除了exc.SQLAlchemyError：
- en: current_app.exception("Could not save new post!")
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: current_app.exception（“无法保存新帖子！”）
- en: flash("Something went wrong while creating your post!")
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存（“创建您的帖子时出现问题！”）
- en: 'else:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return render_template('posts/add.html', form=form)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 返回render_template（'posts/add.html'，form=form）
- en: return redirect(url_for('users.feed'))
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 返回重定向（url_for（'users.feed'））
- en: '[PRE39]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '{% extends "layout.html" %}'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '{% extends "layout.html" %}'
- en: '{% block content %}'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '{% block content %}'
- en: <form action="{{ url_for('posts.add')}}" method="post">
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: <form action="{{ url_for('posts.add')}}" method="post">
- en: '{{ form.hidden_tag() }}'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ form.hidden_tag（）}}'
- en: '{{ form.id }}'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '{{表单.id}}'
- en: <div class="row">
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: <div class="row">
- en: '<div>{{ form.content.label }}: {{ form.content }}</div>'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: <div>{{ form.content.label }}：{{ form.content }}</div>
- en: '{% if form.content.errors %}'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '{% if form.content.errors %}'
- en: <ul class="errors">{% for error in form.content.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: <ul class="errors">{% for error in form.content.errors %}<li>{{ error }}</li>{%
    endfor %}</ul>
- en: '{% endif %}'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '{% endif %}'
- en: </div>
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div><input type="submit" value="Post"></div>
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: <div><input type="submit" value="Post"></div>
- en: </form>
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: </form>
- en: '{% endblock %}'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '{% endblock %}'
- en: '[PRE40]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'def create_app(config=None):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_app(config=None):'
- en: app = Flask(__name__)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: app = Flask(__name__)
- en: …
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: …
- en: from application.users.views import users
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: from application.users.views import users
- en: app.register_blueprint(users, url_prefix='/users')
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: app.register_blueprint(users, url_prefix='/users')
- en: from application.posts.views import posts
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: from application.posts.views import posts
- en: app.register_blueprint(posts, url_prefix='/posts')
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: app.register_blueprint(posts, url_prefix='/posts')
- en: …
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: …
- en: '```'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Once the preceding code is in place, we can generate a few test users and posts
    for these users by creating user accounts via the web interface at the `/users/signup`
    endpoint and then creating posts for the users at `/posts/add`. Otherwise, we
    could create a small CLI script to do this for us, which we will learn how to
    implement in the next chapter. We could also write a few test cases to ensure
    that the newsfeed works as expected. Actually, we could do all three!
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上述代码就位，我们可以通过在`/users/signup`端点的Web界面上创建用户帐户，然后在`/posts/add`上为用户创建帖子来为这些用户生成一些测试用户和帖子。否则，我们可以创建一个小的CLI脚本来为我们执行此操作，我们将在下一章中学习如何实现。我们还可以编写一些测试用例来确保新闻源按预期工作。实际上，我们可以做这三件事！
- en: Summary
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by first introducing the concept of an application factory
    and described some of the benefits and trade-offs of this approach. Next, we used
    our newly created application factory to set up our first test suite using `py.test`,
    which required some modification as to how our application object was created
    in order to ensure that we obtained a suitable instance that was configured to
    test scenarios.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通过首先介绍应用程序工厂的概念，并描述了这种方法的一些好处和权衡来开始本章。接下来，我们使用我们新创建的应用程序工厂来使用`py.test`设置我们的第一个测试套件，这需要对我们的应用程序对象的创建方式进行一些修改，以确保我们获得一个适合的实例，配置为测试场景。 '
- en: Then, we dove headfirst into implementing the basic data models behind a typical
    web application that contained *social* features with the ability to follow other
    users and be followed ourselves. We briefly touched on several main implementation
    patterns for so-called newsfeed applications and used the simplest version for
    our own data models.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们迅速着手实现了典型Web应用程序背后的基本数据模型，其中包含了*社交*功能，包括关注其他用户以及被其他用户关注的能力。我们简要涉及了所谓新闻源应用程序的几种主要实现模式，并为我们自己的数据模型使用了最简单的版本。
- en: This then led us to discuss and explore the concept of the publish/subscribe
    design pattern, of which an in-process implementation can be found in the `Blinker`
    package that Flask and various Flask extensions integrate. Using this new knowledge,
    we created our own publishers and subscribers, allowing us to address some common
    cross-cutting concerns that exist in many modern web applications.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这随后导致我们讨论和探索了发布/订阅设计模式的概念，Flask和各种Flask扩展集成了`Blinker`包中的一个进程内实现。利用这些新知识，我们创建了自己的发布者和订阅者，使我们能够解决许多现代Web应用程序中存在的一些常见横切关注点。
- en: 'For our next project, we will switch gears from creating the HTML-based forms
    and views that we have used for the past few chapters and focus on another very
    important part of modern web applications: providing a useful JSON API to interact
    with.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个项目，我们将从创建过去几章中使用的基于HTML的表单和视图切换到另一个非常重要的现代Web应用程序部分：提供一个有用的JSON API来进行交互。
