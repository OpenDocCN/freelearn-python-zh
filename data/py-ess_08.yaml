- en: Chapter 8. More Advanced Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。更高级的函数
- en: 'In [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"), *Basic Function
    Definitions*, we looked at the core features of defining a function which returns
    a single result. Even functions with an implicit `return` statement at the end
    of the suite of statements, or a function with a `return` statement that has no
    expression, return a result: the `None` object is the default return value. In
    this chapter, we''ll look at functions which generate multiple results. A generator
    function defines an iterable: it can be used with a `for` statement. This means
    that the generator doesn''t produce a single object with all of the items in the
    result; instead it produces each item of the result separately.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](ch07.html "第 7 章。基本函数定义") 中，我们探讨了定义返回单个结果的函数的核心特性。即使函数在语句序列的末尾有一个隐式的
    `return` 语句，或者一个没有表达式的 `return` 语句，也会返回一个结果：`None` 对象是默认的返回值。在本章中，我们将探讨返回多个结果的函数。生成器函数定义了一个可迭代对象：它可以与
    `for` 语句一起使用。这意味着生成器不会产生一个包含所有结果项的单个对象；相反，它会单独产生每个结果项。
- en: Python offers generator expressions and comprehensions which complement the
    idea of generator functions. We can write simple expressions that represent a
    sequence of values which is generated one item at a time. We can use generator
    expressions to create `list`, `set`, or `dict` objects via a comprehension.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了生成器表达式和推导式，这些与生成器函数的概念相辅相成。我们可以编写简单的表达式，表示一个一次生成一个值的值序列。我们可以使用生成器表达式通过推导式创建
    `list`、`set` 或 `dict` 对象。
- en: We'll review the `for` statement and its relationship with iterable data. This
    will help us understand how generator functions work. We'll also look at some
    functions which work as well with collection objects as with generator functions.
    This includes built-in reduction functions such as `max()`, `min()`, and `sum()`.
    It also includes higher-order functions such as `map()`, `filter()`, `functools.reduce()`,
    and the functions of the `itertools` module.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾 `for` 语句及其与可迭代数据的关系。这将帮助我们理解生成器函数是如何工作的。我们还将查看一些既适用于集合对象也适用于生成器函数的函数。这包括内置的归约函数，如
    `max()`、`min()` 和 `sum()`，以及高阶函数，如 `map()`、`filter()`、`functools.reduce()` 和 `itertools`
    模块中的函数。
- en: This chapter will skim over some concepts of functional programming. An entire
    book could be written about functional programming in Python. See [https://www.packtpub.com/application-development/functional-python-programming](https://www.packtpub.com/application-development/functional-python-programming)
    for more information. We'll focus on the essentials.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍一些函数式编程的概念。关于 Python 中的函数式编程，可以写一本书。有关更多信息，请参阅[https://www.packtpub.com/application-development/functional-python-programming](https://www.packtpub.com/application-development/functional-python-programming)。我们将关注核心内容。
- en: Using the for statement with iterable collections
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `for` 语句与可迭代集合
- en: Python allows us to use the `for` statement with any kind of collection. We
    can write a statement like `for x in coll` to process `list`, `set`, or the keys
    of a `dict`. This works because all of the Python collections have common abstract
    base classes, defined in the `collections.abc` module.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许我们使用 `for` 语句与任何类型的集合一起使用。我们可以编写类似 `for x in coll` 的语句来处理 `list`、`set`
    或 `dict` 的键。这是因为所有 Python 集合都有在 `collections.abc` 模块中定义的共同抽象基类。
- en: This works via a common feature of the base classes, `Sequence`, `Set`, and
    `Mapping`. The `Iterable` mix in the class is part of each class definition. The
    implementation of this abstraction is our guarantee that all of the built-in collections
    will cooperate with the `for` statement.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过基类 `Sequence`、`Set` 和 `Mapping` 的一个共同特性实现的。类中的 `Iterable` 混合是每个类定义的一部分。这个抽象实现的保证是所有内置的集合都将与
    `for` 语句协同工作。
- en: 'Let''s open up the internals to see how it works. We''ll use this compound
    `for` statement as a concrete example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开内部结构，看看它是如何工作的。我们将使用这个复合 `for` 语句作为一个具体的例子：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Conceptually, this compound statement starts with something very much like
    this assignment: `coll_i=iter(coll)`. This will get an iterator object for the
    `coll` collection. This `iter()` function will leverage the special method `__iter__()`
    to produce the iterator object. We can summarize how this works with a simple
    rule: if the variable `coll` doesn''t reference a proper collection, a `TypeError`
    exception will be raised.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这个复合语句开始于一个非常类似于这个赋值的东西：`coll_i=iter(coll)`。这将获取 `coll` 集合的迭代器对象。这个 `iter()`
    函数将利用特殊方法 `__iter__()` 来产生迭代器对象。我们可以用一条简单的规则来总结这个工作原理：如果变量 `coll` 不引用一个合适的集合，将引发
    `TypeError` 异常。
- en: Given the resulting iterator object, `coll_i`, the `for` statement can then
    evaluate `x=next(coll_i)` to get each item from the iterator. This will leverage
    the special method `coll_i.__next__()` to produce an item from the original collection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 给定结果迭代器对象 `coll_i`，`for` 语句可以评估 `x=next(coll_i)` 来从迭代器中获取每个项目。这将利用特殊方法 `coll_i.__next__()`
    从原始集合中产生一个项目。
- en: If the evaluation of `next(coll_i)` returns an item, this is assigned to `x`
    and the suite of statements is executed with this value bound to the `x` variable.
    We'll see the value of `x` printed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `next(coll_i)` 的评估返回一个项目，这个项目将被分配给 `x`，并且语句序列将使用这个值绑定到 `x` 变量来执行。我们将看到 `x`
    的值被打印出来。
- en: If `next(coll_i)` raises a `StopIteration` exception, the underlying collection
    is out of items, and the loop will finish normally. In the case of any another
    exception being raised, this simply propagates according to the standard exception
    rules. (We'll look at exceptions in [Chapter 9](ch09.html "Chapter 9. Exceptions"),
    *Exceptions*.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `next(coll_i)` 引发 `StopIteration` 异常，则底层集合已无项目，循环将正常结束。在引发任何其他异常的情况下，这简单地根据标准异常规则传播。（我们将在第
    9 章[异常](ch09.html "第 9 章。异常")中查看异常。）
- en: Iterators and iterable collections
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器和可迭代集合
- en: A collection is iterable when it implements the `__iter__()` special method.
    Almost universally, this means that it will be a subclass of the `Iterable` class
    defined in the `collections.abc` module. The presence of this special method means
    that evaluating `iter()` on a collection object will return an iterator object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合实现了 `__iter__()` 特殊方法时，它是可迭代的。几乎在所有情况下，这意味着它将是 `collections.abc` 模块中定义的 `Iterable`
    类的子类。这个特殊方法的存在意味着在集合对象上评估 `iter()` 将返回一个迭代器对象。
- en: The iterator for a collection must implement the `__next__()` and `__iter__()`
    special methods. Generally, an iterator object implements the `__iter__()` method
    by returning itself as the result. Having this tautological redundancy available
    means that we can not only create an explicit iterator but also provide the iterator
    to a `for` statement without causing an exception; the `for` statement's processing
    can evaluate `iter(object)` without the overheads of checking to see if the object
    is already an iterator.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的迭代器必须实现 `__next__()` 和 `__iter__()` 特殊方法。通常，一个迭代器对象通过返回自身作为结果来实现 `__iter__()`
    方法。这种自洽的冗余意味着我们不仅可以创建一个显式的迭代器，还可以将其提供给 `for` 语句而不引发异常；`for` 语句的处理可以评估 `iter(object)`
    而无需检查该对象是否已经是迭代器。
- en: What if we have a sequence of items which has a header that we'd like to ignore?
    This often happens when a source data file includes a heading line that must be
    processed separately. We can leverage an explicit iterator object to discard items
    from a sequential collection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一系列项目，其中包含我们想要忽略的标题，这种情况通常发生在源数据文件包含必须单独处理的标题行时。我们可以利用显式的迭代器对象来丢弃顺序集合中的项目。
- en: 'We might write something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会写一些像这样的事情：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we've created an iterator, `source_iter`, based on a source
    collection or generator, unimaginatively named `source`. When we evaluated `next(source_iter)`,
    we consumed the first item from the collection, which we then assigned to the
    `heading` variable. We can then use the iterator object in the `for` statement
    to consume the rest of the items in that iterator.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个基于源集合或生成器的迭代器，命名为 `source_iter`，这个名字缺乏想象力，叫作 `source`。当我们评估 `next(source_iter)`
    时，我们从集合中消耗了第一个项目，然后将其分配给 `heading` 变量。然后我们可以使用迭代器对象在 `for` 语句中消耗该迭代器中的其余项目。
- en: 'In effect, the preceding example is nearly identical to this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，前面的例子几乎与这个相同：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This second example actually makes a shallow copy of the source collection and
    assigns this copy to the `rest` variable. We've nearly doubled the amount of memory
    used. For a small list, this doesn't matter. For a larger collection, this can
    become a problem.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例实际上是对源集合进行了浅拷贝，并将这个拷贝赋值给 `rest` 变量。我们几乎加倍了使用的内存量。对于小列表来说，这无关紧要。对于更大的集合来说，这可能会成为一个问题。
- en: If the source is an open file or a generator based on an open file, materializing
    the data in the `rest` collection could be impossible. Files too big to fit into
    memory are part of their own unique problem, sometimes called "big data". Using
    the `iter()` function explicitly allows us to avoid the risky attempt to create
    a large collection that may not fit in memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源是一个打开的文件或基于打开文件的生成器，将 `rest` 集合中的数据实体化可能是不可行的。文件太大，无法放入内存，是它们自己独特问题的一部分，有时被称为“大数据”。显式使用
    `iter()` 函数允许我们避免创建可能不适合内存的大型集合的风险尝试。
- en: Consequences and next steps
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后果和下一步
- en: 'There are three important consequences to the way a `for` statement uses `coll_i=
    iter(x)` and `x=next(coll_i)`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个重要的后果是 `for` 语句使用 `coll_i= iter(x)` 和 `x=next(coll_i)` 的方式：
- en: We can write generator expressions which implicitly have the required interface
    to work as an `Iterable` class
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写隐式具有所需接口的生成器表达式，以便作为 `Iterable` 类工作
- en: Python gives us a way to write generator functions which will work as an `Iterable`
    class
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 给我们提供了编写作为 `Iterable` 类工作的生成器函数的方法
- en: We can create our own classes which implement the special method names required
    to implement the `Iterable` abstract base class
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建自己的类，这些类实现了实现 `Iterable` 抽象基类所需的特殊方法名称
- en: We'll start by writing generator expressions. We can use these to create `list`,
    `set`, and mapping "comprehensions." A **comprehension** is an expression that
    defines the contents of a collection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始编写生成器表达式。我们可以使用这些表达式来创建 `list`、`set` 和映射“推导式”。**推导式**是一个定义集合内容的表达式。
- en: We'll look at writing generator functions. The `yield` statement changes the
    semantics of a function from being "simple" (or "ordinary") to being a generator.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨编写生成器函数。`yield` 语句改变了函数的语义，从“简单”的（或“普通”）变为生成器。
- en: While class definitions are the subject of [Chapter 11](ch11.html "Chapter 11. Class
    Definitions"), *Class Definitions*, we won't dig deeply into how we can create
    our own unique collections. Python already offers so many collections that defining
    our own is not really necessary.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [第 11 章](ch11.html "第 11 章。类定义")，*类定义* 是关于类定义的主题，但我们不会深入探讨如何创建我们自己的独特集合。Python
    已经提供了如此多的集合，定义自己的并不是真的必要。
- en: Using generator expressions and comprehensions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器表达式和推导式
- en: 'We can think of simple generator expressions as an operator with three operands.
    The syntax for these three operands parallels the `for` statement:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将简单的生成器表达式视为一个有三个操作数的运算符。这三个操作数的语法与 `for` 语句平行：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We specify an *expression* which is evaluated for each value assigned to a *target*
    variable from a *source*. There are more complex generators, which we'll look
    at later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定一个 *表达式*，该表达式为从 *源* 分配给 *目标* 变量的每个值进行评估。还有更复杂的生成器，我们将在后面探讨。
- en: Generator expressions can be used freely in Python. They can be used anywhere
    in a sequence or a collection that is meaningful.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式在 Python 中可以自由使用。它们可以在任何有意义的序列或集合中使用。
- en: 'It''s important to note that a generator expression is lazy, or "non-strict."
    It doesn''t actually calculate anything until some consuming operation demands
    values from it. To see this, we can try to evaluate a generator expression at
    the REPL:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，生成器表达式是惰性的，或者说“非严格的”。它实际上不会计算任何东西，直到某个消耗操作要求它提供值。为了看到这一点，我们可以在 REPL
    中尝试评估一个生成器表达式：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Python tells us only that we've created a generator object. Since we didn't
    write an expression to consume the values, all we saw was the object, passively
    waiting to be evaluated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python 只告诉我们我们创建了一个生成器对象。由于我们没有编写一个表达式来消耗这些值，我们看到的就是这个对象，被动地等待被评估。
- en: 'The best way to explore a generator expression is to apply a function, such
    as `list()` or `tuple()`, that will consume the generator''s values and build
    a collection object from them. Here''s an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 探索生成器表达式的最佳方式是应用一个函数，例如 `list()` 或 `tuple()`，它将消耗生成器的值并从它们中构建一个集合对象。以下是一个示例：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the `tuple()` function consumed values from the generator object
    and created a `tuple` object from those values. Rather than display the generator
    object, the REPL shows us the `tuple` which was created from the generated values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`tuple()` 函数从生成器对象中消耗值，并从这些值创建了一个 `tuple` 对象。而不是显示生成器对象，REPL 显示了我们从生成值创建的
    `tuple`。
- en: We can use generator expressions for a wide variety of processing. There are
    several patterns in the `itertools` module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用生成器表达式进行各种处理。`itertools` 模块中有几种模式。
- en: Limitations of generator expressions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器表达式的局限性
- en: Generator expressions have a few limitations. The most obvious limitation is
    that some language features are only available as Python statements. If we need
    to perform exception handling, context management, or exiting a loop early via
    a `break` statement, we can't write a generator expression. We have to resort
    to writing a complete generator function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式有一些局限性。最明显的局限性是，某些语言特性仅作为 Python 语句可用。如果我们需要执行异常处理、上下文管理或通过 `break` 语句提前退出循环，我们无法编写生成器表达式。我们必须求助于编写完整的生成器函数。
- en: 'A less obvious limitation is that a generator expression behaves very much
    like a sequence. But it can only do that trick once. After the generator terminates
    the first time, it behaves like an empty sequence every time it''s referenced
    after that. Here''s a concrete example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不那么明显的局限性是，生成器表达式表现得非常像序列。但它只能这样做一次。在生成器第一次终止后，每次引用它时都表现得像空序列。这里有一个具体的例子：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, we assigned a generator expression to a variable, `x`. When
    we compute `sum(x)`, the `sum()` function consumes all of the values produced
    by the generator expression: the sum is 400 in this example. Once we''ve used
    the generator, it is still valid, but it no longer generates values. All subsequent
    evaluations of `sum(x)` will produce 0.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将生成器表达式赋值给变量 `x`。当我们计算 `sum(x)` 时，`sum()` 函数消耗了生成器表达式产生的所有值：在这个例子中总和是
    400。一旦我们使用了生成器，它仍然有效，但它不再生成值。所有后续的 `sum(x)` 评估都将产生 0。
- en: There's no special exception to warn us that we're reusing an iterator that
    has already been exhausted. In some cases, a program may appear broken because
    we're using a generator expression instead of a `list` or `tuple` sequence. The
    fix is almost always to convert the generator into a `tuple` object so that it
    can be used twice. We can change to `x= tuple(2*x+1 for x in range(20))` to see
    the difference.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特殊的异常来警告我们正在重用已经耗尽的迭代器。在某些情况下，程序可能看起来是损坏的，因为我们使用了生成器表达式而不是 `list` 或 `tuple`
    序列。修复方法几乎总是将生成器转换为 `tuple` 对象，以便它可以被两次使用。我们可以将 `x= tuple(2*x+1 for x in range(20))`
    改变以查看差异。
- en: When working with a generator function or expression, `iter(some_function)`
    will return the generator object because it is an iterator. In the case of a collection
    object, `iter(some_collection)` will create an iterator object that has a reference
    to the collection. The result will be a distinct object. A function can use `iter(param)
    is iter(param)` to detect the difference between a generator function and a concrete
    collection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当与生成器函数或表达式一起工作时，`iter(some_function)` 将返回生成器对象，因为它是一个迭代器。在集合对象的情况下，`iter(some_collection)`
    将创建一个具有集合引用的迭代器对象。结果将是一个不同的对象。一个函数可以使用 `iter(param) is iter(param)` 来检测生成器函数和具体集合之间的差异。
- en: In some cases, we might include the statement `assert iter(param) is not iter(param),
    "Collection object required"` to raise an exception if a generator function is
    provided as an argument to a function which traverses a collection more than once.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能会包含语句 `assert iter(param) is not iter(param), "Collection object
    required"` 以在将生成器函数作为参数传递给遍历集合超过一次的函数时引发异常。
- en: Using multiple loops and conditions
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个循环和条件
- en: 'The body of a generator can include multiple `for` clauses. This allows us
    to iterate over multiple dimensions. We can write expressions like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的主体可以包含多个 `for` 子句。这允许我们遍历多个维度。我们可以编写这样的表达式：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The generator expression has two `for` clauses: `for s in ''♣♦♥♠''` and `for
    r in range(1,14)`. It''s clear from the results that the `for` clause on the right
    executes most frequently. This follows the nesting rules we''d see if we rewrote
    this as nested `for` statements. The `for` clause on the right is like an innermost
    `for` statement.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式有两个`for`子句：`for s in '♣♦♥♠'`和`for r in range(1,14)`。从结果中可以看出，右侧的`for`子句执行得最频繁。这遵循了如果我们将其重写为嵌套`for`语句时我们会看到的嵌套规则。右侧的`for`子句就像一个最内层的`for`语句。
- en: 'Additionally, the body of a generator can include `if` clauses. These can be
    used to filter values created by the `for` clauses. Here''s an example of conditional
    processing in a generator expression:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，生成器的主体可以包含`if`子句。这些可以用来过滤由`for`子句创建的值。以下是一个生成器表达式中条件处理的例子：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the expression is just the target variable, `x`. The source
    is `range(36)`, numbers that include zero and 35\. We've included an `if` clause
    that will pass only those values which are multiples of five or seven. All other
    values will be rejected. In order to see a result, we collected the values from
    the generator into a `list` object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，表达式仅仅是目标变量`x`。来源是`range(36)`，包括零和35的数字。我们包含了一个`if`子句，它只会传递那些是五或七的倍数的值。所有其他值将被拒绝。为了看到结果，我们将生成器的值收集到一个`list`对象中。
- en: Writing comprehensions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写推导式
- en: We can leverage a variation of the generator expression to create `list`, `set`,
    or `dict` objects. These are called comprehensions, and represent tangible objects,
    built from lazy generators.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用生成器表达式的变体来创建`list`、`set`或`dict`对象。这些被称为推导式，它们代表从惰性生成器构建的实体对象。
- en: 'Here are some simple examples:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些简单的例子：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first example uses the `[]` to create a `list` comprehension. This will
    create a list of odd values from one to nine. The second example uses `{}` to
    create a `set` comprehension. This will be a set based on multiples of five or
    seven.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子使用`[]`创建一个`list`推导式。这将创建一个从一到九的奇数值列表。第二个例子使用`{}`创建一个`set`推导式。这将基于五或七的倍数创建一个集合。
- en: The third example creates a `dict` comprehension. The `{}` are used to bracket
    the expression. The use of the `:` character to separate key and value distinguishes
    a `dict` comprehension from a `set` comprehension. This dictionary provides a
    mapping from values of *n*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子创建一个`dict`推导式。`{}`用于括号表达式。使用`:`字符来分隔键和值，将`dict`推导式与`set`推导式区分开来。这个字典提供了从*n*的映射。
- en: This last example could be used as an optimization for a deeply-nested expression.
    Looking up a value in a mapping is faster than repeatedly recalculating. Using
    the `@lru_cache` decorator gives similar performance benefits.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的例子可以用作对深度嵌套表达式的优化。在映射中查找值比反复重新计算要快。使用`@lru_cache`装饰器可以提供类似性能的好处。
- en: Defining generator functions with the yield statement
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`yield`语句定义生成器函数
- en: A generator function has properties similar to a generator expression. Rather
    than a single expression, a generator function is a full Python function. It has
    all of the features of the functions described in [Chapter 7](ch07.html "Chapter 7. Basic
    Function Definitions"), *Basic Function Definitions*. It has the additional characteristic
    of being an iterator, capable of generating a sequence of items.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数具有与生成器表达式相似的属性。生成器函数不是一个单独的表达式，而是一个完整的Python函数。它具有[第7章](ch07.html "第7章。基本函数定义")中描述的函数的所有特性，*基本函数定义*。它还有一个额外的特性，即它是一个迭代器，能够生成一系列项目。
- en: When we use a `yield` statement, the semantics of the function are changed.
    Without a `yield`, a function will return a single value. With a `yield` statement,
    a function will behave like an iterator, providing multiple values to a consumer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`yield`语句时，函数的语义会发生变化。没有`yield`，函数将返回单个值。有`yield`语句时，函数将表现得像迭代器，向消费者提供多个值。
- en: 'Here''s an example of a generator function that applies a range of values to
    a model to compute a domain of results. We''ll apply the model to a sequence of
    input values to compute the results for each input:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个生成器函数的例子，它将一系列值应用于模型以计算结果域。我们将对一系列输入值应用模型以计算每个输入的结果：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `model_iter()` function accepts a single argument, `until`, which is the
    number of values generated by this function. The body of the function includes
    a `for` statement which will set the `n` variable to values defined by the `range()`
    object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `model_iter()` 函数接受一个参数，`until`，它表示该函数生成的值的数量。函数体包含一个 `for` 语句，该语句将 `n` 变量设置为
    `range()` 对象定义的值。
- en: The essential feature of this function is the `yield` statement. Each value
    created by the `yield` statement will be part of the sequence of items emitted
    by this statement.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的基本特性是 `yield` 语句。由 `yield` 语句创建的每个值都将成为此语句产生的项目序列的一部分。
- en: 'Here''s one way to use this function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用此函数的一种方法：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we've collected the results into a single `list` object. Creating
    a `list` object is just one of the many things we can do. We could just as easily
    sum the results of the model to compute the mean value for the given range.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将结果收集到一个单独的 `list` 对象中。创建一个 `list` 对象只是我们可以做的许多事情之一。我们同样可以计算给定范围的平均值，将模型的结果相加。
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we provided the results of the `model_iter()` generator to
    the `sum()` function. This avoids building a large collection of results. The
    `sum()` function will consume all of the values yielded by the generator function.
    We can process thousands or millions of values with this kind of construct because
    a large `list` or `set` is not materialized in memory. Only the individual items
    are processed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `model_iter()` 生成器的结果传递给 `sum()` 函数。这样可以避免构建大量结果集合。`sum()` 函数将消费生成器函数产生的所有值。我们可以使用这种结构处理成千上百万的值，因为不会在内存中生成一个大的
    `list` 或 `set`。只有单个项目被处理。
- en: Using the higher-order functions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高阶函数
- en: A function which accepts a function as an argument, or returns a function as
    a result, is called a **higher-order function**. Python has a number of higher-order
    functions. The most commonly-used of these functions are `map()`, `filter()`,
    and `sorted()`. The `itertools` module contains numerous additional higher-order
    functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接受函数作为参数或返回函数作为结果的函数被称为**高阶函数**。Python 有许多高阶函数。这些函数中最常用的是 `map()`、`filter()`
    和 `sorted()`。`itertools` 模块包含许多其他高阶函数。
- en: The `map()` and `filter()` functions are generators; their results must be consumed.
    Both of them apply a function to a collection of values. In the case of `map()`,
    the results of the function are yielded. In the case of `filter()`, if the result
    of the function is true, the original value is yielded.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 和 `filter()` 函数是生成器；它们的输出必须被消费。它们都将一个函数应用到值集合上。在 `map()` 的情况下，函数的结果被产生。在
    `filter()` 的情况下，如果函数的结果为真，原始值被产生。'
- en: 'Here''s how we can apply a very simple function—so simple we coded it as a
    lambda—to a sequence of values:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何将一个非常简单的函数——简单到我们将其编码为 lambda——应用到一系列值：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function is just an expression, `2*x**2-2`. We've applied this function
    to values given by the `range()` object. The result is a generator, and we need
    to consume the values. We've used `list()` to create a collection that we can
    print. The values are the result of applying the given function to each value
    in the source collection.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数只是一个表达式，`2*x**2-2`。我们已经将此函数应用于 `range()` 对象提供的值。结果是生成器，我们需要消费这些值。我们使用了 `list()`
    来创建一个可以打印的集合。这些值是应用给定函数到源集合中每个值的计算结果。
- en: 'Here''s how we can apply a simple logical test to a sequence of values using
    `filter()`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用 `filter()` 对值序列应用简单逻辑测试：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We've defined a simple function as a lambda; the function, `n%5==0 or n%7==0`,
    is true for multiples of five or seven. We've applied that filter to values produced
    by a `range()` object. The result includes only the values for which the given
    function is `True`. All other values are rejected.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个简单的函数作为 lambda；函数 `n%5==0 or n%7==0` 对于五的倍数或七的倍数是真实的。我们将这个过滤器应用于 `range()`
    对象生成的值。结果只包括给定函数为 `True` 的值。所有其他值都被拒绝。
- en: We used a `list` comprehension to gather the values into a `list` object. This
    `list` comprehension did no calculation and no filtering, so it's equivalent to
    `list(fb)`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表推导式将值收集到一个 `list` 对象中。这个列表推导式没有进行计算和过滤，因此它与 `list(fb)` 等效。
- en: 'We can implement the simple versions of `map()` and `filter()` using generator
    expressions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用生成器表达式实现 `map()` 和 `filter()` 的简单版本：
- en: '`map(function, iterable)` is the same as `(function(x) for x in iterable)`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map(function, iterable)` 与 `(function(x) for x in iterable)` 相同'
- en: '`filter(function, iterable)` is the same as `(x for x in iterable if function(x))`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter(function, iterable)` 与 `(x for x in iterable if function(x))` 相同'
- en: The `map()` function can handle additional iterables, providing more sophistication
    than the generator expression.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数可以处理额外的可迭代对象，比生成器表达式提供更多的复杂性。'
- en: The `sorted()` function is similar to `map()` and `filter()`. The `sorted()`
    function follows a different design pattern for its parameters. The `map()` and
    `filter()` functions accept a function first, followed by an item to process.
    The `sorted()` function accepts an item to sort first, and an optional function
    which defines the keys on which to sort, as well as an optional reverse Boolean
    value used to reverse the sense of the key comparisons. We'll look at sorted in
    detail in the *Three ways to sort a sequence* section later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()` 函数类似于 `map()` 和 `filter()`。`sorted()` 函数对其参数遵循不同的设计模式。`map()` 和
    `filter()` 函数首先接受一个函数，然后是一个要处理的项。`sorted()` 函数首先接受一个要排序的项，以及一个可选的函数，该函数定义了排序的键，以及一个可选的布尔值，用于反转键比较的意义。我们将在后面的
    *三种排序序列的方法* 部分详细探讨排序。'
- en: The `itertools` module contains a large number of generator functions that can
    be combined to create sophisticated processing. For more information on how this
    module works, the book, *Functional Python Programming*, *Steven Lott*, *Packt
    Publishing*, devotes two chapters to the subject ([https://www.packtpub.com/application-development/functional-python-programming](https://www.packtpub.com/application-development/functional-python-programming)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 模块包含大量可以组合以创建复杂处理的生成器函数。有关此模块如何工作的更多信息，书籍 *Functional Python Programming*，作者
    *Steven Lott*，由 *Packt Publishing* 出版，为此主题奉献了两章（[https://www.packtpub.com/application-development/functional-python-programming](https://www.packtpub.com/application-development/functional-python-programming)）。'
- en: Writing our own higher-order functions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们自己的高级函数
- en: Perhaps the simplest kind of higher-order function is based on a generator expression.
    Since a generator expression is lazy, its behavior is more like a function than
    an object which contains relevant data. A function which returns a generator relies
    on some other piece of programming to actually consume the data which is yielded
    by the generator.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最简单的高级函数类型是基于生成器表达式。由于生成器表达式是惰性的，其行为更像是一个函数而不是包含相关数据的对象。返回生成器的函数依赖于其他编程片段来实际消费生成器产生的数据。
- en: A common file input requirement is to strip trailing punctuation and ignore
    blank lines. We'll assume a language which follows the Python rule for comments.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的文件输入需求是去除尾随标点符号并忽略空白行。我们将假设遵循 Python 注释规则的编程语言。
- en: 'Here''s an example of a function that returns a generator:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个返回生成器的函数的例子：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've broken down the processing into four separate generator functions. The
    result of the function is the fourth of these generators, but this depends on
    the others to yield its results. Since generators are lazy, no processing happens
    until a function or statement consumes the data yielded by the generator. We must
    use the result of this function with a `for` statement or a `list()` or `tuple()`
    function to consume the data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理分解为四个独立的生成器函数。函数的结果是这四个生成器中的第四个，但这取决于其他生成器来产生结果。由于生成器是惰性的，直到函数或语句消费生成器产生的数据之前，不会发生任何处理。我们必须使用
    `for` 语句或 `list()` 或 `tuple()` 函数的结果来消费数据。
- en: When a consuming process iterates over the result of this function, it will
    receive individual lines of text from the `non_empty` generator expression. The
    `non_empty` generator filters the lines created by the `decommented` generator
    expression. The `decommented` generator in turn relies on the `partitioned` and
    `stripped` generator expressions to remove comments and whitespace.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费过程迭代此函数的结果时，它将接收到来自 `non_empty` 生成器表达式的单个文本行。`non_empty` 生成器过滤由 `decommented`
    生成器表达式创建的行。`decommented` 生成器反过来依赖于 `partitioned` 和 `stripped` 生成器表达式来移除注释和空白。
- en: What's important here is that the pipeline of processing is the return value
    from the `text_cleaner()` function. This function does not process any data. This
    function returns a generator expression that will process some data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，处理流程的管道是 `text_cleaner()` 函数的返回值。这个函数不处理任何数据。这个函数返回一个生成器表达式，它将处理一些数据。
- en: Each of these generators can be also rewritten to use `map()` or `filter()`.
    We'll leave that as an exercise for the reader.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成器也可以重写为使用 `map()` 或 `filter()`。我们将把这个作为读者的练习。
- en: 'We can use the `text_cleaner()` function like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用 `text_cleaner()` 函数：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've created some text with comments and data. The format of the data appears
    to be `name=value` settings. The `text_cleaner()` function isn't sensitive to
    the format of the data, only to the presence of comments and whitespace. We applied
    the `splitlines()` function to make the block of text behave like a file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一些带有注释和数据的文本。数据的格式看起来是 `name=value` 设置。`text_cleaner()` 函数对数据的格式不敏感，只对注释和空白敏感。我们应用了
    `splitlines()` 函数，使文本块表现得像文件。
- en: The result of `text_cleaner()` is a function which strips away comments, leading
    and trailing spaces, and leaves us with just the meaningful content of the file.
    In this example, we used a `for` statement to consume the data yielded by the
    generator function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`text_cleaner()` 函数的结果是一个函数，它移除了注释、前导和尾随空格，只留下了文件的有意义内容。在这个例子中，我们使用了一个 `for`
    语句来消费生成器函数产生的数据。'
- en: This can be part of a more complex process that uses these `name=value` lines
    as configuration parameters.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是更复杂过程的一部分，该过程使用这些 `name=value` 行作为配置参数。
- en: What's important about generator functions is that they are completely lazy.
    They don't create giant data structures in memory. They process the minimum amount
    of data to satisfy the consumer's requests. This reduces overheads. Additionally,
    each generator can be kept relatively simple, allowing an expressive composition
    to be built from simple pieces.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数的重要之处在于它们是完全懒加载的。它们不会在内存中创建巨大的数据结构。它们只处理满足消费者请求的最小数据量。这减少了开销。此外，每个生成器可以相对简单，从而可以从简单的部分构建出表达性的组合。
- en: Using the built-in reductions – max, min, and reduce
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置归约函数 – max、min 和 reduce
- en: 'We have two other built-in higher-order functions that can accept functions
    as arguments. These can be characterized as reductions: they reduce a collection
    of values to a single value. There''s a third built-in reduction, sum, but it''s
    not a proper higher-order function: we can''t tailor its operation by plugging
    in a function.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个内置的高阶函数可以接受函数作为参数。这些可以描述为归约：它们将一组值归约为一个值。还有一个内置的归约函数 `sum`，但它不是一个正确的高阶函数：我们无法通过插入函数来定制其操作。
- en: 'The `max()` and `min()` reductions follow the design pattern for the `sorted()`
    function: they accept an iterable object first, and they can be customized with
    an optional key function. We''ll show the default behavior first, then we''ll
    show how to customize this with the key function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()` 和 `min()` 归约遵循 `sorted()` 函数的设计模式：它们首先接受一个可迭代对象，并且可以通过可选的键函数进行自定义。我们将首先展示默认行为，然后展示如何使用键函数进行自定义：'
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the first example, the string objects were compared using string comparison.
    This leads to the anomaly of seeing `"21"` appear to be less than `"3"`. In fact,
    a string beginning with `"2"` is sorted before a string beginning with `"3"`,
    but this may not be what the program needs to show as output.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，字符串对象是通过字符串比较来比较的。这导致了一个异常，即看到 `"21"` 看起来小于 `"3"`。实际上，以 `"2"` 开头的字符串会排在以
    `"3"` 开头的字符串之前，但这可能不是程序需要显示的输出。
- en: In the second example, we provided the `int()` function for min to use when
    comparing items. This means that the strings are compared as integers, not as
    strings. This selects `"3"` as the string with the minimal integer value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们为 `min` 函数提供了 `int()` 函数，用于比较项。这意味着字符串被作为整数比较，而不是作为字符串。这选择了具有最小整数值的字符串
    `"3"`。
- en: Note that we did not write `min(data, key=int())`. We're not evaluating the
    `int` function. We're providing the `int` function as an object which the `min()`
    function will use.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有写 `min(data, key=int())`。我们不是评估 `int` 函数。我们提供 `int` 函数作为对象，`min()` 函数将使用它。
- en: Additionally, there's a generic `functools.reduce()` function which can be used
    to build new kinds of reductions. This function accepts a two-valued function,
    an iterable and an initial value. It can compute a wide variety of reductions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个通用的 `functools.reduce()` 函数，可以用来构建新的归约类型。这个函数接受一个二元函数、一个可迭代对象和一个初始值。它可以计算各种归约。
- en: Three ways to sort a sequence
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序序列的三种方法
- en: Python offers us three common approaches to the general problem of sorting a
    `list` of complex items.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 为我们提供了三种处理复杂项 `list` 排序的通用方法。
- en: We can sort with the `sorted()` generator function. This will duplicate an object
    as part of sorting.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `sorted()` 生成器函数进行排序。这会将对象作为排序的一部分进行复制。
- en: We can sort a list with its `sort()` method and a key function. This will mutate
    the `list` into the requested order.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用列表的`sort()`方法和键函数对列表进行排序。这将使列表按请求的顺序进行修改。
- en: We can create an intermediate sequence of objects which can be sorted easily.
    This is sometimes called the **wrap-sort-unwrap** design pattern.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个中间序列的对象，这些对象可以很容易地进行排序。这有时被称为**包装-排序-解包**设计模式。
- en: In order to look at each of these in some detail, we need a collection of complex
    objects which we can sort. We'll use a simple dataset based on a case study in
    the *NIST Engineering Statistics Handbook*, section 7.1.6\. See [http://www.itl.nist.gov/div898/handbook](http://www.itl.nist.gov/div898/handbook)
    for more information.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细查看这些，我们需要一个可以排序的复杂对象集合。我们将使用基于*NIST 工程统计手册*案例研究的简单数据集，第7.1.6节。更多信息请见[http://www.itl.nist.gov/div898/handbook](http://www.itl.nist.gov/div898/handbook)。
- en: 'We''ve got metrics data that—after a little re-organization and cleanup—looks
    like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经整理和清理了一些度量数据，看起来是这样的：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have a list-of-list structure with 90 pairs. Since the date strings are formatted
    nicely as `yyyy-mm-dd`, we can easily sort this into date order using the `sorted(data)`
    function, or the `data.sort()` method. Note that `sorted(data)` will create a
    duplicate of the `data` object. The `data.sort()` method will mutate the `data`
    object in place.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含90对的对列表结构。由于日期字符串格式良好，为`yyyy-mm-dd`，我们可以很容易地使用`sorted(data)`函数或`data.sort()`方法将其按日期顺序排序。请注意，`sorted(data)`将创建`data`对象的副本。`data.sort()`方法将就地修改`data`对象。
- en: How can we put the data into order by count? We can apply a key function to
    the `sorted()` function or `sort()` method. We'll look at these first. As an alternative,
    we can use the wrap-sort-unwrap design pattern.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何按计数对数据进行排序呢？我们可以将键函数应用于`sorted()`函数或`sort()`方法。我们首先看看这些。作为替代，我们可以使用包装-排序-解包设计模式。
- en: Sorting via a key function
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过键函数进行排序
- en: Putting the metrics data into order by count requires us to use a function which
    will change the way items are compared. In this case, we need a more complex key
    function that does two things. It must select the second item of each two item
    data points, and it must convert the second item to a proper integer value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按计数对度量数据进行排序需要我们使用一个函数来改变项目比较的方式。在这种情况下，我们需要一个更复杂的键函数来完成两件事。它必须选择每个两个数据点的第二个项目，并且必须将第二个项目转换为适当的整数值。
- en: 'We can sort by count using either of these examples:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这两个示例中的任何一个按计数进行排序：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both examples use a lambda that performs the integer conversion of the second
    item in each two-item list. The first example updates the data object. The second
    example creates a new object which is a clone of the data object, put into order.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 两个示例都使用了一个lambda表达式，该表达式对每个两元素列表中的第二个项目执行整数转换。第一个示例更新了数据对象。第二个示例创建了一个新的对象，它是数据对象的克隆，并已排序。
- en: Sorting via wrapping and unwrapping
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过包装和解包进行排序
- en: The wrap-sort-unwrap design pattern can be done with a pair of generator expressions.
    The first will create two-tuples from each original piece of data. The first item
    in each new two-tuple is the proper sort key. The second generator will select
    the second item from each of those two-tuples to recover the original object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一对生成器表达式可以实现包装-排序-解包设计模式。第一个将创建从每个原始数据块中生成的两元组。每个新两元组中的第一个项目是适当的排序键。第二个生成器将选择这些两元组中的第二个项目以恢复原始对象。
- en: 'The whole sequence looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 整个序列看起来是这样的：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the first step, we turned each piece of original data into a two-tuple of
    `(sort key, original item)`. We've used a `list` comprehension to create a new
    object that we can sort, leaving the original object undisturbed. Once we've done
    this, the default sort operation works correctly. Once the data is sorted, we
    can recover the original items easily. In this case, we created yet another list
    object using a `list` comprehension.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们将每条原始数据转换成了一个`(sort key, original item)`的两元组。我们使用列表推导式创建了一个新的对象，我们可以对其进行排序，而原始对象保持不变。一旦我们这样做，默认的排序操作就可以正确工作。一旦数据排序完成，我们就可以轻松地恢复原始项目。在这种情况下，我们使用列表推导式创建了另一个列表对象。
- en: 'In both cases, we can tweak this slightly to the `map()` function instead of
    with generator expressions. For example, we can wrap items using `map(lambda item:
    (int(item[1]), item), data)`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '在这两种情况下，我们可以稍微调整一下，使用`map()`函数而不是生成器表达式。例如，我们可以使用`map(lambda item: (int(item[1]),
    item), data)`来包装项目。'
- en: 'Note that the `map()` function is a generator: it''s lazy. A `list` comprehension
    consumes data and creates a tangible object. We can''t easily switch from `list`
    to generator with a simple copy-and-paste. We''ll need to either create a `list`
    object from the map generator, or use `sorted()`, which creates a `list` from
    a generator.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`map()`函数是一个生成器：它是惰性的。列表理解消耗数据并创建一个有形的对象。我们无法通过简单的复制粘贴从列表切换到生成器。我们需要从map生成器创建一个列表对象，或者使用`sorted()`，它从一个生成器创建列表。
- en: The wrap-sort-unwrap is often used when the wrap function is quite complex.
    We might have a generator which performs database lookups, file merges, or extremely
    complex calculations as part of the ordering. In these cases, a simple lambda
    might be difficult to write.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当包装函数相当复杂时，通常会使用包装-排序-解包的方法。我们可能有一个执行数据库查询、文件合并或作为排序一部分的极其复杂的计算的生成器。在这些情况下，编写一个简单的lambda函数可能很困难。
- en: Functional programming design patterns
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程设计模式
- en: The presence of higher-order functions in Python allows us to leverage a great
    many functional programming design patterns. To learn more about these design
    patterns, a good place to start is the `itertools` module. The functions in this
    module provide many examples of how we can write simple functions that do sophisticated
    processing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Python中高阶函数的存在使我们能够利用许多函数式编程设计模式。要了解更多关于这些设计模式的信息，一个好的起点是`itertools`模块。该模块中的函数提供了许多示例，说明了我们如何编写简单的函数来进行复杂的处理。
- en: 'Additionally, we can use some of the features in the `functools` module. This
    contains the general-purpose `reduce()` function. It also contains some functions
    that can help us write decorators. A decorator, as we''ll see in [Chapter 13](ch13.html
    "Chapter 13. Metaprogramming and Decorators"), *Metaprogramming and Decorators*,
    is another kind of higher-order function: it''s a function that modifies the definition
    of an original function. This is another aspect of functional programming.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用`functools`模块的一些功能。它包含通用的`reduce()`函数。它还包含一些可以帮助我们编写装饰器的函数。正如我们在第13章[Metaprogramming
    and Decorators](ch13.html "Chapter 13. Metaprogramming and Decorators")中将要看到的，装饰器是一种高级函数：它修改原始函数的定义。这是函数式编程的另一个方面。
- en: 'Most importantly, we have two ways to approach algorithms:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们有两种方法来处理算法：
- en: We can process items in large collections of data, creating additional collections
    that are copies, subsets, or transformations.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在大量数据集合中处理项目，创建副本、子集或转换的额外集合。
- en: We can process items by iterating through a large collection of data as if we're
    creating additional collections. Instead of actually creating copies, subsets,
    or transformations, we can use iterators, filter functions, and mapping functions.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过迭代大量数据集合，就像我们正在创建额外的集合一样来处理项目。实际上，我们不需要创建副本、子集或转换，我们可以使用迭代器、过滤函数和映射函数。
- en: When we have alternatives, we can choose a variation that is succinct and expressive.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有替代方案时，我们可以选择简洁且表达力强的变体。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've seen a number of the advanced features of functions.
    We've looked at the essential generator expression and how this is used as part
    of a comprehension. A `list` comprehension assembles a `list` from the generated
    values. Similarly, a `set` comprehension creates a `set`. A dictionary comprehension
    creates a `dict` structure from the keys and values in a generator expression.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了函数的许多高级特性。我们研究了基本的生成器表达式以及它是如何作为理解的一部分使用的。列表理解从生成的值中组装列表。同样，集合理解创建集合。字典理解从生成器表达式中的键和值创建字典结构。
- en: We've looked at using the `yield` statement to create a generator function.
    This allows us to use all of the various Python statement features when creating
    a generator. Since a generator is iterable, it works with a `for` loop so that
    we can write a simple loop to process multiple values created by an iterator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了使用`yield`语句创建生成器函数。这允许我们在创建生成器时使用所有各种Python语句功能。由于生成器是可迭代的，它可以与`for`循环一起使用，这样我们就可以编写一个简单的循环来处理由迭代器创建的多个值。
- en: We've also looked at higher-order functions. These are functions which take
    functions as arguments or produce functions as a result. With higher-order functions,
    we can refactor our algorithms into functions that can be combined to create the
    desired behavior.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了高阶函数。这些函数接受函数作为参数或产生函数作为结果。使用高阶函数，我们可以将我们的算法重构为可以组合以创建所需行为的函数。
- en: In [Chapter 9](ch09.html "Chapter 9. Exceptions"), *Exceptions*, we'll look
    at how Python raises exceptions, how we can capture those exceptions, and what
    kind of exceptional processing we need to write.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.html "第9章。异常")，*异常*中，我们将探讨Python如何引发异常，我们如何捕获这些异常，以及我们需要编写什么样的异常处理。
