- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Exploring Object Transformations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索对象变换
- en: The ability to change an object’s location, rotation, and dimension in a space
    is a tenet of any animation software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在空间中改变对象的位置、旋转和尺寸是任何动画软件的基本原则。
- en: Artists are used to changing the values of transform channels to carry out these
    operations. More technical users are aware of the geometric implications of such
    actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家用于更改变换通道的值以执行这些操作。更技术性的用户了解此类动作的几何含义。
- en: In this chapter, we will learn how Object Transformations work and how to implement
    them in our script. We will also learn how to add object constraints programmatically
    and how Blender can carry out the more difficult operations for us.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习对象变换的工作原理以及如何在我们的脚本中实现它们。我们还将学习如何以编程方式添加对象约束，以及Blender如何为我们执行更复杂的操作。
- en: Finally, we will implement a new command that affects the transformation of
    more objects at once and accepts user input.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现一个新的命令，该命令可以一次影响更多对象的变换，并接受用户输入。
- en: 'This chapter will cover the following key topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Transforming objects, using coordinate notations, and avoiding pitfalls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用坐标表示变换对象，并避免陷阱
- en: Applying object constraints and hierarchies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用对象约束和层次结构
- en: Using matrix representation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用矩阵表示
- en: Adding interactive operators to our add-ons
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的插件添加交互式操作员
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will use Blender and **Visual Studio Code** (**VS Code**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Blender和**Visual Studio Code**（**VS Code**）。
- en: 'The examples created in this chapter can be found at the following URL: [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章创建的示例可以在以下网址找到：[https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4).
- en: Moving objects in space
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在空间中移动对象
- en: Three-dimensional objects can be moved, rotated, and scaled. Since they do not
    change the geometry of an object, location and rotation are considered **rigid
    transformations**. Technically, changing the size of an object using its scale
    value applies a non-rigid transformation, but since the vertex geometry doesn’t
    change, scale is considered an object-level transformation and is displayed alongside
    location and rotation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 三维对象可以移动、旋转和缩放。由于它们不改变对象的几何形状，位置和旋转被认为是**刚性变换**。技术上，使用缩放值改变对象的大小应用非刚性变换，但由于顶点几何形状没有改变，缩放被认为是对象级别的变换，并显示在位置和旋转旁边。
- en: In this section, we will use Python to transform objects in Blender.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Python在Blender中变换对象。
- en: Transforming objects
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变换对象
- en: An object is transformed by changing the values of its Location, Rotation, and
    Scale channels. Location and scale coordinates are immediately associated with
    the X, Y, and Z of the Cartesian space; rotations have more options as they come
    with some implications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对象通过改变其位置、旋转和缩放通道的值进行变换。位置和缩放坐标立即与笛卡尔空间的X、Y和Z相关联；旋转有更多选项，因为它们带来一些含义。
- en: Affecting an object’s location
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影响对象的定位
- en: 'We have already met the `location` attribute in [*Chapter 1*](B18375_01.xhtml#_idTextAnchor014)
    and [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033). If we have an active object,
    such as the cube from Blender’s default scene, the following lines will move it
    to the location with *x*, *y*, *z* coordinates `1.0`, `2.0`, and `3.0`. These
    lines use **tuple assignment** to set all three coordinates at once:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第1章*](B18375_01.xhtml#_idTextAnchor014)和[*第2章*](B18375_02.xhtml#_idTextAnchor033)中遇到了`location`属性。如果我们有一个活动对象，例如Blender默认场景中的立方体，以下行将把它移动到具有*x*、*y*、*z*坐标`1.0`、`2.0`和`3.0`的位置。这些行使用**元组赋值**一次设置所有三个坐标：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since Blender coordinates can also be assigned through letters, that expression
    is equivalent to the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Blender坐标也可以通过字母赋值，该表达式等同于以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Coordinates are stored inside **Vectors**. Vector components can be accessed
    separately:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标存储在**向量**中。向量分量可以单独访问：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, they can be accessed as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们可以通过以下方式访问：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Location and Scale are both stored as Vectors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 位置和缩放都存储为向量。
- en: Affecting object scale
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影响对象缩放
- en: 'Like with location, the three dimensions of scale are accessed through the
    `Vector` coordinates:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与位置一样，缩放的三维维度通过`Vector`坐标访问：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can assign a non-uniform scale to an object, such as a different value for
    each axis:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为对象分配非均匀缩放，例如每个轴有不同的值：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The scale of an object is more often uniform, meaning it is the same on each
    axis. Blender Vectors provide a convenient way for assigning uniform values:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 物体的缩放通常是均匀的，这意味着它在每个轴上都是相同的。Blender矢量提供了一个方便的方式来分配均匀值：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Like with `location`, `scale` coordinates can be set individually or together.
    The rest values are different, by the way: the scale at rest is `[1.0, 1.0, 1.0]`
    rather than `[0.0, 0.0, 0.0]`. That reflects how scaling is a multiplicative operation
    while location is additive.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与`位置`一样，`缩放`坐标可以单独设置或一起设置。顺便说一下，静止时的缩放值是`[1.0, 1.0, 1.0]`而不是`[0.0, 0.0, 0.0]`。这反映了缩放是一种乘法操作，而位置是加法操作。
- en: Rotations are less immediate to combine. We will see that there are different
    ways to represent rotations in the first place.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转的组合不如立即。我们将看到有不同方式来表示旋转。
- en: Affecting object rotations
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影响物体旋转
- en: Using rotations, we can orient an object around the *x*, *y*, and *z* axes.
    Doing that will give objects an orientation of their own, with their own *x*,
    *y*, and *z* local axes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用旋转，我们可以围绕*x*、*y*和*z*轴对物体进行定位。这样做会给物体赋予自己的方向，并拥有自己的*x*、*y*和*z*局部轴。
- en: 'We refer to these new axes, aligned with the object, as **Local Orientation**.
    Blender lets the user choose between different axes for transforming objects.
    The axes aligned with the viewport grid are the **Global Orientation** or **World
    Axes**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些与物体对齐的新轴称为**局部方向**。Blender允许用户在变换物体时选择不同的轴。与视口网格对齐的轴是**全局方向**或**世界轴**：
- en: '![Figure 4.1: Rotation rings and axes of an object at rest and after a rotation](img/Figure_4.01_B18375.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：静止和旋转后的物体旋转环和轴](img/Figure_4.01_B18375.jpg)'
- en: 'Figure 4.1: Rotation rings and axes of an object at rest and after a rotation'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：静止和旋转后的物体旋转环和轴
- en: 'Even if an object was rotated, we can still change **Rotation Mode** in the
    viewport top bar and use *Global Orientation*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使物体已经旋转，我们仍然可以在视口顶栏中更改**旋转模式**并使用*全局方向*：
- en: '![Figure 4.2: A rotated airplane still using Global Orientation](img/Figure_4.02_B18375.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：仍然使用全局方向的旋转飞机](img/Figure_4.02_B18375.jpg)'
- en: 'Figure 4.2: A rotated airplane still using Global Orientation'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：仍然使用全局方向的旋转飞机
- en: 'Rotations are more complex than translation and scale: by definition, a rotation
    involves a pivot and a constant distance. For that reason, rotations are affected
    by some minor issues that require extra consideration.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转比平移和缩放更复杂：根据定义，旋转涉及一个支点和恒定的距离。因此，旋转会受到一些需要额外考虑的次要问题的影响。
- en: Issues related to rotations
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与旋转相关的问题
- en: Because of their composite nature, rotations around one axis can change the
    rotation value on another. To sum that up, rotation is described as a three-dimensional
    property with only two **degrees of freedom**, as no more than two channels have
    the chance to change freely.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的复合性质，围绕一个轴的旋转可能会改变另一个轴的旋转值。总结一下，旋转被描述为只有两个**自由度**的三维属性，因为不超过两个通道有机会自由改变。
- en: Also, the order in which rotations are stacked together changes the result.
    To visualize a rotated object correctly, we need to know which axes were rotated
    first, that is, the **rotation order**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，旋转叠加的顺序会改变结果。为了正确可视化旋转后的物体，我们需要知道哪个轴首先被旋转，即**旋转顺序**。
- en: 'We could just stick with one rotation order, say *x*, then *y*, and then *z*,
    but that would limit our options against another potential shortcoming: three-dimensional
    rotations that overlap one axis with another end up making one coordinate useless,
    a well-known problem known as **gimbal lock**.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以坚持使用一种旋转顺序，比如*x*，然后*y*，然后*z*，但这将限制我们对抗另一个潜在缺陷的选择：重叠一个轴的另一个轴的三维旋转最终会使一个坐标变得无用，这是一个众所周知的问题，称为**万向节锁**。
- en: Since different rotation orders lock at different angles, changing the order
    helps cope with the issue.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同的旋转顺序会在不同的角度上锁定，改变顺序有助于应对这个问题。
- en: These problems aren't specific to Blender or any other animation software; they
    are inherent properties of three-dimensional spaces, up to and including the one
    that we inhabit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题并不仅限于Blender或其他动画软件；它们是三维空间固有的属性，包括我们所在的空间。
- en: To work around them, rotations provide a wider range of options. In addition
    to different orders for combining the three angles, there are also abstract representations
    such as quaternions. This terminology might sound scary at first, but it will
    become more familiar as we proceed with the chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，旋转提供了更广泛的选择。除了三个角度的不同组合顺序外，还有如四元数这样的抽象表示。这种术语一开始可能听起来很吓人，但随着我们继续本章的学习，它将变得更加熟悉。
- en: Changing rotation mode
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改旋转模式
- en: 'The **Rotation Mode** box in **Transform Properties** displays the available
    options for rotating objects:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换属性**中的**旋转模式**框显示了可用于旋转对象的可用选项：'
- en: '![Figure 4.3: Rotation modes](img/Figure_4.03_B18375.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：旋转模式](img/Figure_4.03_B18375.jpg)'
- en: 'Figure 4.3: Rotation modes'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：旋转模式
- en: 'We do not need to cover this topic in full here, but essentially the following
    provides a brief introduction:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不需要全面覆盖这个主题，但基本上以下提供了一个简要的介绍：
- en: '**Quaternions**: These are mathematic notations that use four coefficients:
    in Blender, **W**, **X**, **Y**, and **Z**. Quaternions do not suffer from gimbal
    lock.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四元数**：这些是使用四个系数的数学符号：在 Blender 中，**W**、**X**、**Y** 和 **Z**。四元数不受万向节锁的影响。'
- en: '**Euler angles**: These list the angles on three rotation axes. It’s the common
    acceptance of rotation and comes with two caveats: the result depends on the axis
    order, and one axis might end up overlapping another. To mitigate the perils of
    losing a channel to gimbal lock, more combinations of **X**, **Y**, and **Z**
    are allowed.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**欧拉角**：这些列出三个旋转轴上的角度。这是旋转的普遍接受方式，但有两个注意事项：结果取决于轴的顺序，一个轴可能最终与另一个轴重叠。为了减轻丢失通道到万向节锁的危险，允许更多的
    **X**、**Y** 和 **Z** 组合。'
- en: '**Axis Angle**: This uses **X**, **Y,** and **Z** to define a point as the
    rotation axis. The **W** attribute is the twisting angle in said direction.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴角**：这使用 **X**、**Y**、**Z** 来定义一个点作为旋转轴。**W** 属性是该方向上的扭转角。'
- en: '![Figure 4.4: Rotation attributes for the Quaternion, Euler, and Axis Angle
    modes](img/Figure_4.04_B18375.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4：四元数、欧拉和轴角模式的旋转属性](img/Figure_4.04_B18375.jpg)'
- en: 'Figure 4.4: Rotation attributes for the Quaternion, Euler, and Axis Angle modes'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：四元数、欧拉和轴角模式的旋转属性
- en: Changing this property in the interface changes the displayed channels. In Python,
    we need to use different attributes depending on the current mode.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在界面中更改此属性会更改显示的通道。在 Python 中，我们需要根据当前模式使用不同的属性。
- en: Accessing rotations in Python
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Python 中访问旋转
- en: 'The `rotation_mode` attribute specifies which system is being used to rotate
    an object. It is an `TypeError`. The error message prints out the allowed keywords:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotation_mode` 属性指定正在使用哪个系统来旋转对象。它是一个 `TypeError`。错误信息打印出允许的关键词：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each mode provides its attributes for setting rotations:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每种模式都提供其设置旋转的属性：
- en: '`QUATERNION`: To affect the quaternion coefficients *W*, *X*, *Y*, and *Z,*
    we use the following, respectively:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUATERNION`：要影响四元数的系数 *W*、*X*、*Y* 和 *Z*，我们分别使用以下内容：'
- en: '`rotation_quaternion.w` or `rotation_quaternion[0]`'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_quaternion.w` 或 `rotation_quaternion[0]`'
- en: '`rotation_quaternion.x` or `rotation_quaternion[1]`'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_quaternion.x` 或 `rotation_quaternion[1]`'
- en: '`rotation_quaternion.y` or `rotation_quaternion[2]`'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_quaternion.y` 或 `rotation_quaternion[2]`'
- en: '`rotation_quaternion.z` or `rotation_quaternion[3]`'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_quaternion.z` 或 `rotation_quaternion[3]`'
- en: '`XYZ`, `XZY`, `YXZ`, `YZX`, `ZXY`, and `ZYX` are Euler angles evaluated in
    different orders. No matter which one we choose, the Euler attributes for these
    are the following:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XYZ`、`XZY`、`YXZ`、`YZX`、`ZXY` 和 `ZYX` 是按不同顺序评估的欧拉角。无论我们选择哪一个，这些欧拉属性如下：'
- en: '`rotation_euler.x` or `rotation_euler[0]`'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_euler.x` 或 `rotation_euler[0]`'
- en: '`rotation_euler.y` or `rotation_euler[1]`'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_euler.y` 或 `rotation_euler[1]`'
- en: '`rotation_euler.z` or `rotation_euler[2]`'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_euler.z` 或 `rotation_euler[2]`'
- en: We should set these values in radians.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将这些值设置为弧度。
- en: '`AXIS_ANGLE`: *Axis Angle – Axis Angle (W+XYZ)*, defines a rotation around
    some axis defined by 3D-Vector. We can set the torsion angle in radians via the
    following:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AXIS_ANGLE`：*轴角 – 轴角 (W+XYZ)*，定义围绕由 3D-向量定义的某个轴的旋转。我们可以通过以下方式设置扭转角（以弧度为单位）：'
- en: '`rotation_axis_angle[0]`'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_axis_angle[0]`'
- en: 'We can set the axis vector x, y, z coordinates using the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式设置轴向量的 x、y、z 坐标：
- en: '`rotation_axis_angle[1]`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_axis_angle[1]`'
- en: '`rotation_axis_angle[2]`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_axis_angle[2]`'
- en: '`rotation_axis_angle[3]`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_axis_angle[3]`'
- en: The `math` module provides some help in using radians as angular units.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 模块在以弧度作为角度单位的使用上提供了一些帮助。'
- en: Using radians and degrees
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用弧度和度
- en: Blender’s API describes angles of rotation using radians rather than degrees.
    Degrees express an angle using values between 0 and 360, while radians range between
    0 and 2π. The Greek letter π (pi) refers to the ratio between a circle and its
    diameter. 2π (approximately 6.28) measures the arc of a full circle of radius
    1.0.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Blender的API使用弧度而不是度来描述旋转角度。度数使用介于0到360之间的值来表示一个角度，而弧度介于0到2π之间。希腊字母π（pi）指的是圆与其直径的比例。2π（约等于6.28）测量半径为1.0的完整圆的弧长。
- en: In Python, we can use the `math` module’s functions to convert between the two
    systems, `radians()` and `degrees()`, and the `pi` variable for quick access to
    the value of π.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用`math`模块的函数在两个系统之间进行转换，即`radians()`和`degrees()`，以及`pi`变量以快速访问π的值。
- en: 'Take the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With that in mind, when we set rotations, we can convert angular units on the
    fly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，当我们设置旋转时，我们可以即时转换角度单位。
- en: Setting rotation attributes
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置旋转属性
- en: 'Before we set a rotation in a script, we must ensure that we use the right
    rotation system. In the following snippet, we set the rotation mode beforehand:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中设置旋转之前，我们必须确保我们使用正确的旋转系统。在以下片段中，我们事先设置了旋转模式：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we change `rotation_mode`, Blender converts the current state to the selected
    system. That prevents an object from suddenly changing its orientation in space
    and works for most cases, but there are a few exceptions. For instance, animations
    have values set for each keyframe, so switching the rotation type of animated
    controls ends up changing the visual rotation during playback. In that case, we
    can use conversion methods in our scripts, as we will see in the next Python snippet.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改`rotation_mode`时，Blender会将当前状态转换为所选系统。这防止了对象突然在空间中改变其方向，并且适用于大多数情况，但也有一些例外。例如，动画为每个关键帧设置了值，因此切换动画控制的旋转类型会导致在播放时改变视觉旋转。在这种情况下，我们可以在脚本中使用转换方法，就像我们将在下一个Python片段中看到的那样。
- en: Converting between rotation systems
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在旋转系统之间转换
- en: 'In the following snippet, we start with a `Euler` rotation and use conversion
    methods to change the rotation mode:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下片段中，我们从一个`Euler`旋转开始，并使用转换方法来更改旋转模式：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At the time of writing, the Euler representation doesn’t have a `to_axis_angle()`
    method, so we convert to quaternion first. Using quaternions as a crossroad is
    common, as they are the most generic system for expressing rotations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，欧拉表示法还没有`to_axis_angle()`方法，因此我们首先将其转换为四元数。使用四元数作为交叉点是常见的，因为它们是表达旋转的最通用系统。
- en: Rotations can also be written down as a **matrix**. The matrix form is how all
    the transforms are stored internally. We will get to that after we have learned
    more about indirect transforms, that is, moving an object without changing its
    channels.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转也可以写成**矩阵**的形式。矩阵形式是所有变换在内部存储的方式。在我们学习了更多关于间接变换（即在不改变其通道的情况下移动对象）之后，我们将了解这一点。
- en: Transforming objects indirectly
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接变换对象
- en: We have seen how to transform an object by altering its channels directly. There
    are two other ways to influence an object’s position, rotation, and scale. **Object
    Constraints** are special utilities that affect the transformation either by limiting
    certain values or by copying them from another object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过直接改变通道来变换对象。还有两种其他方式可以影响对象的位置、旋转和缩放。**对象约束**是特殊的工具，通过限制某些值或从另一个对象复制它们来影响变换。
- en: Then there is the possibility to arrange more objects in a hierarchy via **Parenting**,
    that is, by making one object belong to another.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有通过**父子关系**安排更多对象层次结构的可能性，即通过使一个对象属于另一个对象。
- en: We will see how these operations are reflected in Python.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到这些操作如何在Python中体现。
- en: Using Object Constraints
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象约束
- en: Constraints can move, rotate, or scale an object without changing its transform
    properties. Some of them, such as **Copy Transforms**, override the object transform
    completely; others, such as **Limit Distance**, operate on top of them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 约束可以移动、旋转或缩放一个对象，而不会改变其变换属性。其中一些，例如**复制变换**，完全覆盖了对象的变换；而另一些，例如**限制距离**，则在其之上操作。
- en: '![Figure 4.5: Blender constraints menu](img/Figure_4.05_B18375.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：Blender约束菜单](img/Figure_4.05_B18375.jpg)'
- en: 'Figure 4.5: Blender constraints menu'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：Blender约束菜单
- en: Most constraints bind the transforms of more objects together, such as **Copy
    Location**, while others, such as **Limit Location**, have their own transform
    attributes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数约束将更多对象的变换绑定在一起，例如**复制位置**，而另一些，例如**限制位置**，有自己的变换属性。
- en: An object can have an unspecified number of constraints. The steps to add them
    in Python are very similar to how they work in the graphic interface.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以有未指定的约束数量。在Python中添加它们的步骤与在图形界面中的工作方式非常相似。
- en: Adding constraints in Python
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中添加约束
- en: Constraints are exposed as a collection property of an object. They can be added
    by providing a constraint type to the `new(type)` method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 约束作为对象的一个集合属性公开。可以通过向`new(type)`方法提供约束类型来添加它们。
- en: 'Much like with rotation mode, providing a wrong keyword will prompt an error
    and list the available options:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与旋转模式类似，提供错误的关键字将提示错误并列出可用选项：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `new` method returns the created constraint, so we can easily access its
    properties.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`方法返回创建的约束，因此我们可以轻松访问其属性。'
- en: Setting constraint attributes
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置约束属性
- en: 'Different types of constraints have different attributes, but some common patterns
    exist. Most constraints will contain these properties:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的约束类型有不同的属性，但存在一些共同的模式。大多数约束将包含以下属性：
- en: '**Boolean** switches:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔**开关：'
- en: '`.enabled`: This enables/disables a constraint'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.enabled`: 这启用/禁用约束'
- en: '`.use_x`, `.use_y`, `.use_z`: Use when available to enable/disable only one
    axis'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.use_x`, `.use_y`, `.use_z`: 当可用时，仅启用/禁用一个轴'
- en: '`.use_offset`: Use when available to sum the constraint effect to the transform
    channels'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.use_offset`: 当可用时，将约束效果累加到变换通道'
- en: 'Object: Use `.target`, if available, to set the bind target of the constraint'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象：如果可用，使用`.target`来设置约束的绑定目标
- en: 'String: Use `.subtarget`, if available, to use only part of the target (e.g.,
    a vertex group) for the actual computation'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：如果可用，使用`.subtarget`来仅使用目标的一部分（例如，顶点组）进行实际计算
- en: 'Enum switches:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**枚举**开关：'
- en: '`.target_space`: This makes the constraint act at the `.owner_space`: This
    changes the constraint source data to the **Local**, **World,** or **Custom**
    **Object** level'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.target_space`: 这使约束在`.owner_space`上起作用：这更改约束源数据为**本地**、**世界**或**自定义****对象**级别'
- en: 'Float number: Use `.influence` to convey only a fraction of the effect'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数：使用`.influence`来传达只有部分效果
- en: Some properties are specific to each type, such as the `distance` attribute
    of the **Distance Constraint**. In that case, their path can be traced by hovering
    over or right-clicking in the graphic interface (see the *Copying the data path
    section in* [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033)) or from the API documentation
    (see the *Accessing Blender data* section in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '一些属性是特定于每种类型的，例如**距离约束**的`distance`属性。在这种情况下，它们的路径可以通过在图形界面中悬停或右键单击来追踪（见[*第2章*](B18375_02.xhtml#_idTextAnchor033)中的*复制数据路径部分*)或从API文档中（见[*第2章*](B18375_02.xhtml#_idTextAnchor033)中的*访问Blender数据部分*)。 '
- en: Limiting an object scale
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制对象缩放
- en: 'The following snippet adds a **Limit Scale** constraint that limits the maximum
    height of the active object:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段添加了一个**限制缩放**约束，该约束限制了活动对象的最高高度：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If applied to the default cube, it will halve its height as if a scale of `[1.0,
    1.0, 0.5]` had been applied, despite its scale values still being `[1.0,` `1.0,
    1.0]`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用于默认立方体，它将将其高度减半，就像应用了 `[1.0, 1.0, 0.5]` 的缩放一样，尽管其缩放值仍然是 `[1.0,` `1.0, 1.0]`。
- en: Objects can be part of a hierarchy. In that case, they follow the objects that
    are higher in their hierarchical tree. We will explore this concept next.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以是层次结构的一部分。在这种情况下，它们遵循其层次树中级别更高的对象。我们将在下一节中探讨这个概念。
- en: Using object hierarchies
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象层次结构
- en: Objects in the viewport can be arranged as **children** of other objects. In
    that case, they will be affected by the translation, rotation, and scale of their
    **parent**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 视口中的对象可以作为其他对象的**子对象**进行排列。在这种情况下，它们将受到其**父对象**的平移、旋转和缩放的影响。
- en: We can access hierarchical relationships in Python via the `parent`, `children`,
    and `children_recursive` attributes. Only the parent attribute is writable; the
    other two are only for listing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过Python中的`parent`、`children`和`children_recursive`属性来访问层次关系。只有`parent`属性是可写的；其他两个仅用于列出。
- en: The difference between `children` and `children_recursive` is that the latter
    lists every affected object down the hierarchy, including children of children
    and all the *descendants*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`children`和`children_recursive`之间的区别在于后者列出了层次结构中受影响的每个对象，包括子对象的子对象以及所有**后代**。'
- en: 'This snippet parents all the existing objects one under the other, then it
    prints a report:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将所有现有对象依次作为父对象，然后打印一份报告：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running that code in the default scene brings the following result:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认场景中运行该代码将产生以下结果：
- en: '![Figure 4.6: Default objects reparented in one hierarchy](img/Figure_4.06_B18375.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：在一个层次结构中默认重置的父级对象](img/Figure_4.06_B18375.jpg)'
- en: 'Figure 4.6: Default objects reparented in one hierarchy'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：在一个层次结构中默认重置的父级对象
- en: 'This is reflected in the printout: the first object lists all the others as
    *grandchildren*, while `children_recursive` and `children` contain the same results
    for the last two, which have no other descendants:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这在打印输出中得到了反映：第一个对象列出了所有其他对象作为*孙辈*，而`children_recursive`和`children`对于最后两个没有其他后代的对象，包含相同的结果：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we look at the viewport, we can see that the object positions have changed:
    parenting an object in Python applies a new reference system instantly. To replicate
    that behavior, we need to understand the transformation matrix.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看视口，我们可以看到对象位置已经改变：在Python中设置对象的父级会立即应用一个新的参考系。为了复制这种行为，我们需要理解变换矩阵。
- en: Understanding the transform matrix
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变换矩阵
- en: Three-dimensional transforms of Location, Rotation, and Scale are stored together
    inside a **matrix**. Matrices are, at large, tables of numbers arranged in rows
    and columns. Transformation matrices are combined using **linear algebra**. We
    will not go into the details here; we will just have a quick look at what a matrix
    means and how we can use it in our scripts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 位置、旋转和缩放的三维变换存储在一个**矩阵**中。矩阵在广义上是由行和列排列的数字表。变换矩阵通过**线性代数**组合。我们不会深入细节；我们只是快速看一下矩阵的含义以及我们如何在脚本中使用它。
- en: 'Like with other representations, Blender provides a `Matrix` class in the `mathutils`
    module:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他表示一样，Blender在`mathutils`模块中提供了一个`Matrix`类：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A matrix containing these default values, `1.0` in its *diagonal* entries and
    `0.0` everywhere else, represents the *rest* state. In other words, an object
    associated with this matrix was not moved, rotated, or scaled. It is known as
    an **identity matrix**, as it leaves an object in its *identical* state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 包含这些默认值，其对角线条目为`1.0`，其他地方为`0.0`的矩阵代表了*静止*状态。换句话说，与这个矩阵关联的对象没有被移动、旋转或缩放。它被称为**单位矩阵**，因为它使对象保持*相同*的状态。
- en: Whenever an object is moved, rotated, or scaled, the entries of its matrix change
    to different values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每当对象移动、旋转或缩放时，其矩阵的条目都会改变为不同的值。
- en: Accessing matrices
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问矩阵
- en: 'Objects contain more than one matrix. Trying to reach an object matrix via
    autocompletion shows four different attributes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对象包含多个矩阵。尝试通过自动完成来访问对象矩阵会显示四个不同的属性：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Each of them covers a specific aspect:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条目都涵盖了一个特定的方面：
- en: '`matrix_basis`: This contains the local location, rotation, and scale of an
    object before it is transformed by object constraints. This matrix reflects the
    channels displayed in the object properties.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix_basis`：这个矩阵包含了对象在由对象约束变换之前的本地位置、旋转和缩放。这个矩阵反映了在对象属性中显示的通道。'
- en: '`matrix_local`: This contains the local location, rotation, and scale of an
    object, omitting the transformation inherited by the parent object but not the
    one resulting from constraints.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix_local`：这个矩阵包含了一个对象的位置、旋转和缩放，省略了从父级对象继承的变换，但不包括由约束产生的变换。'
- en: '`matrix_parent_inverse`: Whenever we don’t want an object at rest to match
    its parent exactly, we add an offset inside this matrix.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix_parent_inverse`：每当我们不希望一个静止的对象与其父级完全匹配时，我们会在该矩阵内添加一个偏移量。'
- en: '`matrix_world`: This contains the final location, rotation, and scale in world
    coordinates, reflecting all the transformations to which an object is subject.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix_world`：这个矩阵包含了在全局坐标系中的最终位置、旋转和缩放，反映了对象所受的所有变换。'
- en: With that in mind, we can improve the *parent snippet* from the previous section
    and keep the object positions intact.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以改进上一节中的*父级片段*，并保持对象位置不变。
- en: Storing object matrices
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储对象矩阵
- en: Assigning a parent relationship via Python previously has snapped every object
    to its parent positions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Python设置父级关系之前，曾经使每个对象都瞬间移动到其父级位置。
- en: We want them to maintain their visual transformation after the change in hierarchy.
    In matrix terms, we are saying that we want to keep their world matrix unchanged.
    To do that, we will learn how to store a matrix properly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望它们在层次结构改变后保持其视觉变换。用矩阵术语来说，我们想要保持它们的世界矩阵不变。为了做到这一点，我们将学习如何正确地存储矩阵。
- en: Copying matrices
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制矩阵
- en: Python variables containing single values store their own data. Variables with
    aggregate values such as lists, dictionaries, and Blender `mathutils` types point
    to shared references of their values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 包含单个值的 Python 变量存储它们自己的数据。具有聚合值（如列表、字典和 Blender `mathutils` 类型）的变量指向它们值的共享引用。
- en: 'Let’s look at the following example. The `b` variable has the same value as
    `a`. After `a` is changed to `5`, `b` is still `4`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。`b` 变量的值与 `a` 相同。在将 `a` 更改为 `5` 之后，`b` 仍然是 `4`：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The same doesn’t apply to lists, even if they consist of one single element:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样不适用于列表，即使它们只包含一个元素：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Despite being a different variable, the `b` list points to the same data as
    the `a` list. To free it from getting updates from the original, we must state
    explicitly that it is a copy.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管是不同的变量，`b` 列表指向与 `a` 列表相同的数据。为了使其不更新原始数据，我们必须明确声明它是一个副本。
- en: Expert Python users know very well how to avert that using Python’s `copy` module.
    Blender aggregate types provide a `.copy()` method for convenience.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 熟练的 Python 用户非常清楚如何使用 Python 的 `copy` 模块来避免这种情况。Blender 聚合类型提供了一个 `.copy()`
    方法以方便使用。
- en: 'In the following snippet, changes to `matrix_a` will also change `matrix_b`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，对 `matrix_a` 的更改也会影响 `matrix_b`：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following creates a `matrix_a`, that is, all its values are copied:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码创建了一个 `matrix_a`，即它的所有值都是复制的：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can now keep the object’s world transformations and restore them after the
    hierarchy has changed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以保持对象的世界变换，并在层次结构改变后恢复它们。
- en: Restoring transformations using the world matrix
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用世界矩阵恢复变换
- en: Since `matrix_world` is writeable, it can be stored and reapplied after setting
    the parent.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `matrix_world` 是可写的，它可以在设置父级后存储并重新应用。
- en: 'To restore the matrix *as it was*, we need to store a copy of its value, like
    in the following snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复矩阵到其原始状态，我们需要存储其值的副本，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see that the objects maintain their position. If we look at the transform
    channels, we will find that they have changed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到对象保持其位置。如果我们查看变换通道，我们会发现它们已经改变。
- en: Setting the world matrix affects the location/rotation/scale values. In their
    rest position, the objects still go back to their parent center.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设置世界矩阵会影响位置/旋转/缩放值。在它们的原始位置，对象仍然回到其父级中心。
- en: If that is not what we want to achieve, we can use the `matrix_parent_inverse`
    attribute to offset the rest position.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不是我们想要实现的目标，我们可以使用 `matrix_parent_inverse` 属性来偏移原始位置。
- en: Creating rest offsets with the parent inverse matrix
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用父级逆矩阵创建原始偏移
- en: The `parent_matrix_inverse` attribute contains a transform that is hidden from
    the interface. It is used for setting a rest position away from the parent’s origin.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent_matrix_inverse` 属性包含一个从界面中隐藏的变换。它用于设置远离父级原点的原始位置。'
- en: The idea is to counter the inherited transform, adding its inverse to the transform.
    For instance, the inverse of moving an object to the `[5.0, 5.0, 5.0]` coordinates
    is moving it to `[-5.0, -``5.0, -5.0]`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是抵消继承的变换，将它的逆变换添加到变换中。例如，将对象移动到 `[5.0, 5.0, 5.0]` 坐标的逆变换是将它移动到 `[-5.0, -5.0,
    -5.0]`。
- en: Inverting a rotation is a little bit more complicated, but in Blender, we can
    find the inverse of any transform using the `.inverted()` method of its matrix.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 逆转旋转稍微复杂一些，但在 Blender 中，我们可以使用其矩阵的 `.inverted()` 方法找到任何变换的逆变换。
- en: 'This is how the following snippet parents the objects in `bpy.data`, while
    keeping their transform and visual coordinates:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是以下代码片段如何将 `bpy.data` 中的对象设置为父级，同时保持它们的变换和视觉坐标：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The matrix system can be scary, as many people don’t usually think of transformations
    in this form. But even this basic understanding of it provides a very powerful
    tool in our scripting bench.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵系统可能令人畏惧，因为许多人通常不会以这种形式考虑变换。但即使是对它的基本理解也为我们提供了脚本工具箱中的非常强大的工具。
- en: In the next section, we put the skills learned throughout the chapter to use
    in a single add-on. This add-on changes the positions of many objects as one and
    can optionally work through constraints.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将本章学到的技能应用于单个插件。此插件可以一次性更改许多对象的位置，并且可以选择通过约束进行工作。
- en: Writing the Elevator add-on
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Elevator 插件
- en: Now that we know how to transform objects in Python, we can write a new add-on
    that contains a transformation operator.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在 Python 中变换对象，我们可以编写一个新的插件，其中包含变换操作符。
- en: This add-on allows us to move all selected objects above a certain height. It
    can be useful whenever we want to set a minimum height, that is, a *floor*, for
    our scene. As we did in [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), we start
    with a basic implementation, and we will then proceed to refine it. As usual,
    we start our work by setting a folder for the code of the chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件允许我们将所有选定的对象移动到一定的高度以上。当我们想要为场景设置最小高度，即*地板*时，这可能很有用。正如我们在[*第三章*](B18375_03.xhtml#_idTextAnchor049)中所做的那样，我们从一个基本的实现开始，然后我们将继续对其进行完善。像往常一样，我们首先为章节的代码设置一个文件夹。
- en: Setting the environment
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'As we did at the beginning of [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049),
    we create a folder for [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075) in our
    `ch4` folder as the **Scripts** folder:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第三章*](B18375_03.xhtml#_idTextAnchor049)开头所做的那样，我们在`ch4`文件夹中为[*第四章*](B18375_04.xhtml#_idTextAnchor075)创建一个文件夹作为**脚本**文件夹：
- en: '![Figure 4.7: System folder for Chapter 4](img/Figure_4.07_B18375.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7：第四章的系统文件夹](img/Figure_4.07_B18375.jpg)'
- en: 'Figure 4.7: System folder for [Chapter 4](B18375_04.xhtml#_idTextAnchor075)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：第四章的系统文件夹
- en: 'Now it’s time to add a new file to our project:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向我们的项目中添加一个新文件了：
- en: Select `PythonScriptingBlender/ch4/addons` in VS Code.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中选择 `PythonScriptingBlender/ch4/addons`。
- en: Create a new file by clicking the **New** **File** icon.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建** **文件**图标创建一个新文件。
- en: Name the new file `object_elevator.py`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`object_elevator.py`。
- en: Open the file by double-clicking it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件打开它。
- en: We can now start writing our add-on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写我们的插件了。
- en: Writing the first draft
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写第一个草稿
- en: 'As we have seen in the *Add-on requirements* section in [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049),
    our add-on needs the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第三章*](B18375_03.xhtml#_idTextAnchor049)的[*插件要求*](B18375_03.xhtml#_idTextAnchor049)部分所看到的，我们的插件需要以下内容：
- en: The add-on *information* `bl_info` dictionary
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件*信息* `bl_info` 字典
- en: An *operator* that performs the desired action
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行所需操作的*操作员*
- en: The `register`/`unregister` function for `enable`/`disable` operations
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register`/`unregister`函数用于`enable`/`disable`操作'
- en: 'Let’s begin writing the first draft by filling in the requirements; we can
    refine the add-on in the second step:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写第一个草稿，通过填写要求；我们可以在第二步中完善插件：
- en: 'We write down the add-on information in the `bl_info` header. That also helps
    clarify the purpose and functionality of the tool:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`bl_info`头部写下附加信息。这也有助于阐明工具的目的和功能：
- en: object_elevator.py
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: object_elevator.py
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let’s nail down the main functionality: the add-on contains an operator
    that moves all the objects up to a given height. We store this height in the static
    variable floor, which, for now, is hardcoded and set to `5.0`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们确定主要功能：插件包含一个操作员，可以将所有对象移动到给定的高度。我们将这个高度存储在静态变量`floor`中，目前它是硬编码的，设置为`5.0`：
- en: '[PRE24]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since it affects the selected objects, the condition to check in the `poll()`
    method is that the selection is not empty:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它会影响选定的对象，`poll()`方法中要检查的条件是选择不为空：
- en: '[PRE29]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here’s the bulk of the code: the `execute` function checks for each object
    that its `Z` location is not less than `self.floor` (at the moment, `self.floor`
    equals `5.0`). When all the objects have been processed, it returns a `''``FINISHED''`
    status:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是代码的主体部分：`execute`函数检查每个对象的`Z`位置是否不小于`self.floor`（目前，`self.floor`等于`5.0`）。当所有对象都处理完毕后，它返回一个`'FINISHED'`状态：
- en: '[PRE32]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we can add our operator to the object right-click menu; to do that, we
    need a `drawmenu` function:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的操作员添加到对象的右键菜单中；为此，我们需要一个`drawmenu`函数：
- en: '[PRE38]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'All the elements of our add-on are ready; all that is left is to add them to
    the registration functions. This is how we do it:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们插件的全部元素都已准备就绪；剩下的只是将它们添加到注册函数中。这就是我们这样做的方式：
- en: '[PRE42]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Our add-on is ready for its test drive. We can find it in the **Add-ons** preferences:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插件已经准备好进行测试。我们可以在**插件**首选项中找到它：
- en: '![Figure 4.8: Object: Elevator enabled in the Add-ons preferences](img/Figure_4.08_B18375.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8：在插件首选项中启用的对象：电梯](img/Figure_4.08_B18375.jpg)'
- en: 'Figure 4.8: Object: Elevator enabled in the Add-ons preferences'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：在插件首选项中启用的对象：电梯
- en: 'When the add-on is enabled, a new entry is added to the object’s *right-click*
    menu:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件启用时，对象右键菜单中会添加一个新条目：
- en: '![Figure 4.9: Right-clicking in the viewport shows our new menu entry](img/Figure_4.09_B18375.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9：在视图中右键单击显示我们的新菜单项](img/Figure_4.09_B18375.jpg)'
- en: 'Figure 4.9: Right-clicking in the viewport shows our new menu entry'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：在视图中右键单击显示我们的新菜单项
- en: If we select some objects and open the context menu via right-clicking them,
    we will find `location.z` to `5.0` unless it already has a higher value.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择一些对象并通过右键单击它们打开上下文菜单，我们将找到 `location.z` 到 `5.0`，除非它已经有一个更高的值。
- en: Setting a minimum height for a scene can be useful when it contains a ground
    level, and we want to ensure that no object ends up below it. The static value
    of `OBJECT_OT_elevator.floor` doesn’t help here, though, as it only applies to
    the case when the ground level equals `5.0`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为场景设置最小高度在它包含地面层并且我们想要确保没有对象最终低于它时很有用。然而，`OBJECT_OT_elevator.floor` 的静态值在这里没有帮助，因为它只适用于地面层等于
    `5.0` 的情况。
- en: 'Luckily that was only for testing: the final version of the script makes use
    of an input parameter instead.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这只是为了测试：脚本的最终版本使用了一个输入参数。
- en: Using input properties
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输入属性
- en: Replacing the static `floor` member in our operator with an editable value requires
    Blender to channel the user input to our Python script.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们操作符中的静态 `floor` 成员替换为可编辑值需要 Blender 将用户输入通道到我们的 Python 脚本中。
- en: For that purpose, Blender’s API provides special properties that show up as
    graphic elements in the interface and can be used as variables in Python scripts.
    These properties are part of the `bpy.props` module.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，Blender 的 API 提供了特殊的属性，它们在界面中作为图形元素出现，并可以在 Python 脚本中用作变量。这些属性是 `bpy.props`
    模块的一部分。
- en: 'To make `floor` an editable property of our operator:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `floor` 成为我们的操作符的可编辑属性：
- en: 'As `OBJECT_OT_elevator.floor` is a float number, so we need to use `FloatProperty`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `OBJECT_OT_elevator.floor` 是一个浮点数，所以我们需要使用 `FloatProperty`：
- en: '[PRE52]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Since we are forcing a specific type, we will use a Python `floor = 5.0` to
    `floor:FloatProperty(name="Floor", default=0)`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在强制指定一个特定类型，我们将使用 Python 的 `floor = 5.0` 到 `floor:FloatProperty(name="Floor",
    default=0)`。
- en: Take note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Using an annotation in lieu of variables of a determined type is a best practice
    in Python, but it is required in Blender: the input property will not appear otherwise.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替代确定类型的变量注释是 Python 中的最佳实践，但在 Blender 中是必需的：否则输入属性将不会出现。
- en: Then we must keep in mind that, because of how Blender works, operators that
    accept input values must be aware of the undo system. So, we add the `bl_options
    = {'REGISTER', '``UNDO'}` property.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须记住，由于 Blender 的工作方式，接受输入值的操作符必须了解撤销系统。因此，我们添加了 `bl_options = {'REGISTER',
    'UNDO'}` 属性。
- en: 'Here’s how the header of our operator looks now:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们操作符的标题看起来是这样的：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Refreshing the operators by pressing *F3* + **Reload Scripts** and executing
    **Elevate Objects** again displays the input properties inside an expansion popup
    at the bottom left of the screen:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 *F3* + **重新加载脚本** 并再次执行 **提升对象** 来刷新操作符，将在屏幕左下角显示一个展开的弹出窗口中的输入属性：
- en: '![Figure 4.10: Our editable Floor property](img/Figure_4.10_B18375.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：我们的可编辑地板属性](img/Figure_4.10_B18375.jpg)'
- en: 'Figure 4.10: Our editable Floor property'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：我们的可编辑地板属性
- en: Changing this property affects the minimum height of all selected objects.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 更改此属性会影响所有选中对象的最小高度。
- en: So far, we have operated on the `location.z` attribute. This might not work
    if our object has a parent with a different orientation or scale. We can overcome
    that using the object world matrix instead.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在操作 `location.z` 属性。如果我们的对象有一个具有不同方向或缩放的父对象，这可能不起作用。我们可以通过使用对象世界矩阵来克服这个问题。
- en: Setting the height in the world matrix
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在世界矩阵中设置高度
- en: 'Blender stores the object translation in the matrix’s last column, as seen
    in *Figure 4**.11*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 将对象平移存储在矩阵的最后一列中，如 *图 4**.11* 所示：
- en: '![Figure 4.11: The entries of a transform matrix](img/Figure_4.11_B18375.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11：变换矩阵的项](img/Figure_4.11_B18375.jpg)'
- en: 'Figure 4.11: The entries of a transform matrix'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：变换矩阵的项
- en: The indices of `Matrix` point to its rows; so, to access location z, we need
    to get the third row and look for its fourth element. Since the enumeration starts
    with `0`, the indices we are looking for are, respectively, `[2]` and `[3]`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matrix` 的索引指向其行；因此，要访问位置 z，我们需要获取第三行并查找其第四个元素。由于枚举从 `0` 开始，我们正在寻找的索引分别是 `[2]`
    和 `[3]`。'
- en: 'Our `execute` function now uses `matrix_world[2][3]` instead of `location.z`.
    Since matrix values are not automatically updated during script execution, we’ll
    need to invoke `context.view_layer.update()` after the value is set:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `execute` 函数现在使用 `matrix_world[2][3]` 而不是 `location.z`。由于矩阵值在脚本执行期间不会自动更新，我们将在值设置后调用
    `context.view_layer.update()`：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This version of the script can handle the objects that inherit a parent transform,
    but what if the parent is also selected?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的脚本可以处理继承父变换的对象，但如果父对象也被选中怎么办？
- en: Moving a parent after a child has already been handled will change the positions
    of both, thus bringing the child to a wrong height.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完子对象之后移动父对象将改变两者的位置，从而将子对象带到错误的高度。
- en: We need to make sure that parent objects are always moved first.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保父对象总是首先移动。
- en: Avoiding duplicate transformations
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免重复变换
- en: We need to reorder our list of objects, but with `context.selected_objects`
    being read-only, we cannot reorder it directly; we need to copy its content to
    a list.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新排序我们的对象列表，但由于`context.selected_objects`是只读的，我们无法直接对其进行排序；我们需要将其内容复制到一个列表中。
- en: Copying selected_objects to an editable list
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将选定的对象复制到可编辑列表中
- en: 'We can use the `copy` module to create a **shallow copy** of that list. It
    will reference the same data but allow us to sort them at will:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`copy`模块创建该列表的**浅拷贝**。它将引用相同的数据，但允许我们随意对其进行排序：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, in the `execute` method, locate the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`execute`方法中，定位以下代码：
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Replace it with this code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它：
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now we can order this list in a way that won’t cause the same object to be moved
    twice.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以以这种方式对列表进行排序，这样就不会导致同一对象被移动两次。
- en: Ordering by hierarchy
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按层次排序
- en: To sort a list, we need a function that returns each element’s position in a
    new order.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要对一个列表进行排序，我们需要一个函数，该函数返回每个元素在新顺序中的位置。
- en: We want to handle child objects only after their parents are already processed.
    Reordering the list so that objects with more ancestors are processed later will
    meet this condition.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在处理完父对象之后才处理子对象。通过重新排序列表，使具有更多祖先的对象稍后处理，以满足这个条件。
- en: 'We need a function that returns the number of ancestors: starting with an object,
    it checks whether it has a parent, and then whether that parent has a parent,
    until none is found. The `ancestors_count` function achieves that using a `while`
    loop:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个函数来返回祖先的数量：从一个对象开始，检查它是否有父对象，然后检查那个父对象是否有父对象，直到没有找到为止。`ancestors_count`函数使用`while`循环实现这一点：
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We add this function to our script and use it as the `key` argument of the
    `sort` method:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个函数添加到我们的脚本中，并将其用作`sort`方法的`key`参数：
- en: '[PRE60]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Our add-on is now able to raise all the selected objects to a minimum height
    and avoids summing the transforms in hierarchies.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将所有选定的对象提升到最小高度，并避免在层次结构中累加变换。
- en: We could consider it finished, but since we know how to add constraints, we
    can use them for the same purpose.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以认为它已经完成，但既然我们知道如何添加约束，我们可以将其用于相同的目的。
- en: Adding the constraints switch
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加约束开关
- en: 'We can allow the user to use constraints and leave the transform channels unaffected.
    This is how we can do it:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以允许用户使用约束，同时不影响变换通道。我们可以这样做到：
- en: 'Since we want to display a checkbox for using constraints, we need to add a
    Boolean property to our operator. We need to import `BoolProperty` as we did with
    `FloatProperty` earlier:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想要显示一个用于使用约束的复选框，我们需要在我们的操作符中添加一个布尔属性。我们需要像之前导入`FloatProperty`一样导入`BoolProperty`：
- en: '[PRE61]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then we add a `BoolProperty` annotation to our operator:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在我们的操作符中添加一个`BoolProperty`注解：
- en: '[PRE62]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We will use constraints when the `constr` property is set to `True`. We set
    it to `False` by default so that a new option doesn’t change the add-on’s behavior.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`constr`属性设置为`True`时，我们将使用约束。默认情况下，我们将其设置为`False`，这样新的选项就不会改变附加组件的行为。
- en: 'Using constraints makes our job easier; we don’t need to sort the objects and
    set their matrices. Our `execute` function now starts like this:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用约束使我们的工作变得更简单；我们不需要对对象进行排序并设置它们的矩阵。我们的`execute`函数现在开始如下：
- en: '[PRE69]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If we use constraints, we can just exit the function, returning a `{'FINISHED'}`
    set as soon as we are done setting them. If we don’t, the `execute` function keeps
    going with the previous code.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用约束，我们只需退出函数，在设置完约束后立即返回一个`{'FINISHED'}`集合。如果不这样做，`execute`函数将继续执行之前的代码。
- en: 'The visual result is equivalent, but turning **Constraints** on doesn’t affect
    the transform channels. There is one last caveat: if the operator is run multiple
    times on the same objects, a new constraint is added.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉结果等效，但开启**约束**不会影响变换通道。有一个最后的注意事项：如果操作符在相同的对象上多次运行，将添加一个新的约束。
- en: We will make **Elevate Objects** reuse an existing constraint when it is found.
    That avoids creating too many constraints for the same purpose. It also prevents
    the effects of previous constraints from interfering. When an object has more
    than one limit to its location, only the more restrictive one is effective.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到现有约束时，我们将使**提升对象**重用该约束。这避免了为相同目的创建过多的约束。它还防止了先前约束的效果相互干扰。当一个对象有多个位置限制时，只有最严格的那个是有效的。
- en: Avoiding duplicate constraints
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免重复约束
- en: 'If **Limit Location** is found on an object, our operator uses it. We make
    this behavior optional in case the user wants to create new constraints anyway:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象上存在**限制位置**，我们的操作符会使用它。我们将其行为设置为可选，以防用户无论如何都想创建新的约束：
- en: 'To do that, we add another Boolean property to our operator first:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先为我们的操作符添加另一个布尔属性：
- en: '[PRE79]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Then, inside our loop, we check for an existing constraint that we can use.
    If it is not found, our script creates it.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的循环内部，我们检查是否存在我们可以使用的现有约束。如果没有找到，我们的脚本将创建它。
- en: 'This behavior can be implemented in a function:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可以通过一个函数实现：
- en: '[PRE80]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'That has made our `execute` method much cleaner:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使得我们的`execute`方法变得更加简洁：
- en: '[PRE81]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If we reload the scripts and run the operator, we will see all its properties
    in the execution panel:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新加载脚本并运行操作符，我们将在执行面板中看到所有其属性：
- en: '![Figure 4.12: All the Elevate Objects options](img/Figure_4.12_B18375.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12：所有提升对象选项](img/Figure_4.12_B18375.jpg)'
- en: 'Figure 4.12: All the Elevate Objects options'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：所有提升对象选项
- en: Ideally, the **Reuse** property should be displayed only when **Constraints**
    is enabled, as it has no effect otherwise.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，**重用**属性应该仅在**约束**启用时显示，因为否则它没有效果。
- en: This is possible if we take care of drawing the user interface of our tools,
    which will be introduced in the next chapter.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们注意绘制我们工具的用户界面，这是在下一章中将要介绍的，这是可能的。
- en: For now, we have added a good deal of flexibility to a script that started as
    a very simple tool. This brings us to the end of the chapter, as we have covered
    most of the topics about writing custom tools.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们为从非常简单的工具开始的脚本添加了大量灵活性。这使我们到达了本章的结尾，因为我们已经涵盖了关于编写自定义工具的大部分主题。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use `Vector`, `Quaternion`, and `Matrix`
    entities to our advantage, not to mention the different *rotation modes*. That
    gives us the elements for understanding and mastering the transformations in space
    and moving the objects in the scene.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用`Vector`、`Quaternion`和`Matrix`实体，以及不同的*旋转模式*来为我们自身谋利。这为我们理解并掌握空间中的变换以及移动场景中的对象提供了元素。
- en: We also learned how to create constraints in Python, which is very important
    in all set-up scripts.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何在Python中创建约束，这在所有设置脚本中都非常重要。
- en: Lastly, we learned how our operators can get user input and display their parameters
    inside the Blender user interface during their execution.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了我们的操作符如何在执行期间从用户那里获取输入并在Blender用户界面中显示它们的参数。
- en: In [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), we will learn how to code
    our own panels for the graphic interface and make its options aware of the context.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18375_05.xhtml#_idTextAnchor100)中，我们将学习如何为我们自己的图形界面编写面板代码，并使其选项能够感知上下文。
- en: Questions
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a rigid transformation?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是刚体变换？
- en: Can we convert coordinates between different rotation systems?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在不同旋转系统之间转换坐标？
- en: Can we convert coordinates between different rotation orders?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在不同旋转顺序之间转换坐标？
- en: Why are quaternions useful for conversion?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么四元数在转换中很有用？
- en: In which form are transformations stored internally?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变换是以何种形式存储在内部？
- en: Are objects associated with only one transformation matrix?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象是否只与一个变换矩阵相关联？
