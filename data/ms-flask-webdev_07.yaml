- en: Using NoSQL with Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flask中使用NoSQL
- en: A **NoSQL** (short for **Not Only SQL**) database is any non-relational data
    store. It usually focuses on speed and scalability. NoSQL has been taking the
    web development world by storm for the past seven years. Huge companies, such
    as Netflix and Google, have announced that they are moving many of their services
    to NoSQL databases, and many smaller companies have followed their example.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**NoSQL**（代表**Not Only SQL**）数据库是指任何非关系型数据存储。它通常侧重于速度和可扩展性。过去七年中，NoSQL一直在Web开发世界中掀起风暴。像Netflix和Google这样的大公司已经宣布，他们正在将许多服务迁移到NoSQL数据库，许多较小的公司也效仿了它们的做法。'
- en: This chapter will deviate from the rest of the book in that it will not mostly
    focus on Flask. The focus on the database design might seem odd in a book about
    Flask, but choosing the correct database for your application is arguably the
    most important decision that you can make while designing your technology stack.
    In the vast majority of web applications, the database is the bottleneck, so the
    database you pick will determine the overall speed of your app. A study conducted
    by Amazon showed that even a 100 ms delay caused a one percent reduction in sales,
    so speed should always be one of the main concerns of a web developer. There is
    also an abundance of horror stories in the programmer community of web developers
    involving developers choosing a popular NoSQL database and then not really understanding
    what the database requires in terms of administration. This leads to large amounts
    of data loss and crashes, which in turn means the loss of customers. All in all,
    it's no exaggeration to say that your choice of database for your application
    can be the difference between your app succeeding and failing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将与本书的其他部分有所不同，因为它不会主要关注Flask。在关于Flask的书中关注数据库设计可能看起来有些奇怪，但选择适合您应用程序的正确数据库可能是您在设计技术堆栈时可以做出的最重要的决定。在绝大多数Web应用程序中，数据库是瓶颈，因此您选择的数据库将决定您应用程序的整体速度。亚马逊进行的一项研究表明，即使100毫秒的延迟也会导致销售额下降1%，因此速度始终应该是Web开发者关注的重点之一。在程序员社区中，关于Web开发者选择流行的NoSQL数据库但并未真正理解数据库在管理方面的要求的恐怖故事也很多。这导致大量数据丢失和崩溃，进而意味着客户流失。总的来说，可以说您为应用程序选择的数据库可能是您的应用程序成功与失败之间的区别。
- en: In this chapter, we will illustrate the strengths and weaknesses of NoSQL databases
    by examining each type of NoSQL database and the differences between NoSQL and
    traditional databases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过检查每种类型的NoSQL数据库以及NoSQL与传统数据库之间的差异，来说明NoSQL数据库的优点和缺点。
- en: Types of NoSQL database
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL数据库类型
- en: NoSQL is a blanket term used to describe nontraditional methods of storing data
    in a database. The vast majority of NoSQL databases are not relational—unlike
    RDBMS—which means that they normally cannot perform operations such as `JOIN`.
    There are a number of other features that distinguish an SQL database from a NoSQL
    database. With a NoSQL database, we have the ability to not impose a fixed schema—for
    example, a collection on MongoDB can hold different fields, and so they can accept
    any kind of document. With NoSQL you can (and should) take advantage of denormalization,
    making a tradeoff between storage and speed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL是一个总称，用于描述在数据库中存储数据的非传统方法。绝大多数NoSQL数据库都不是关系型数据库——与RDBMS不同——这意味着它们通常无法执行诸如`JOIN`之类的操作。还有许多其他特性将SQL数据库与NoSQL数据库区分开来。使用NoSQL数据库，我们有能力不强制实施固定模式——例如，MongoDB上的集合可以包含不同的字段，因此它们可以接受任何类型的文档。使用NoSQL，您可以（并且应该）利用反规范化，在存储和速度之间做出权衡。
- en: Modern NoSQL databases include key-value stores, document stores, column family
    stores, and graph databases.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现代NoSQL数据库包括键值存储、文档存储、列族存储和图数据库。
- en: Key-value stores
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键值存储
- en: 'A **key-value** NoSQL database acts much like a dictionary in Python. A single
    value is associated with one key and is accessed via that key. Also, like a Python
    dictionary, most key-value databases have the same read speed regardless of how
    many entries there are. Advanced programmers would know this as **O(1) reads**.
    In some key-value stores, only one key can be retrieved at a time, rather than
    multiple rows in traditional SQL databases. In most key-value stores, the content
    of the value is not queryable, but the keys are. Values are just binary blobs:
    they can be literally anything, from a string to a movie file. However, some key-value
    stores give default types, such as strings, lists, sets, and dictionaries, while
    still giving the option of adding binary data.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**键值**型NoSQL数据库在功能上与Python中的字典非常相似。单个值与一个键相关联，并通过该键访问。同样，像Python字典一样，大多数键值数据库的读取速度不受条目数量的影响。高级程序员可能会将这称为**O(1)读取**。在一些键值存储中，一次只能检索一个键，而不是传统SQL数据库中的多行。在大多数键值存储中，值的内文是不可查询的，但键是可查询的。值只是二进制块：它们可以是任何东西，从字符串到电影文件。然而，一些键值存储提供默认类型，如字符串、列表、集合和字典，同时仍然提供添加二进制数据的选择。'
- en: Because of their simplicity, key-value stores are typically very fast. However,
    their simplicity makes them unsuitable as the main database for most applications.
    As such, most key-value store use cases involve storing simple objects that need
    to expire after a certain amount of time. Two common examples of this pattern
    are storing users' session data and shopping cart data. Also, key-value stores
    are commonly used as caches for the application or for other databases. For example,
    results from a commonly run, or CPU-intensive, query or function are stored with
    the query or function name as a key. The application will check the cache in the
    key-value store before running the query on the database, thereby decreasing page
    load times and stress on the database. An example of this functionality will be
    shown in [Chapter 10](657deeac-378d-4d68-8f93-bb2512fe7ad8.xhtml), *Useful Flask
    Extensions*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的简单性，键值存储通常非常快。然而，它们的简单性使它们不适合作为大多数应用程序的主要数据库。因此，大多数键值存储用例涉及存储需要在一定时间后过期的简单对象。这种模式的两个常见例子是存储用户的会话数据和购物车数据。此外，键值存储通常用作应用程序或其他数据库的缓存。例如，将常用或CPU密集型查询或函数的结果存储为键，以查询或函数名称作为键。应用程序将在数据库上运行查询之前检查键值存储中的缓存，从而减少页面加载时间和数据库的压力。这种功能的示例将在[第10章](657deeac-378d-4d68-8f93-bb2512fe7ad8.xhtml)，*有用的Flask扩展*中展示。
- en: The most popular key–value stores are **Redis**, **Riak**, and **Amazon DynamoDB**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的键值存储包括**Redis**、**Riak**和**Amazon DynamoDB**。
- en: Document stores
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档存储
- en: '**Document store** is one of the most popular NoSQL database types, and is
    typically used to replace RDBMSes. Databases store data in collections of key-value
    pairs called documents. These documents are schemaless, meaning that no document
    follows the structure of any other document. Also, extra keys may be appended
    to each document after its creation. Document stores can store data in **JSON**,
    BSON, and XML. For example, the following are two different post objects stored
    in JSON:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档存储**是NoSQL数据库中最受欢迎的类型之一，通常用于替代RDBMS。数据库将数据存储在称为文档的键值对集合中。这些文档是无模式的，这意味着没有文档遵循任何其他文档的结构。此外，在文档创建后，可以附加额外的键。文档存储可以存储**JSON**、BSON和XML格式的数据。例如，以下是在JSON中存储的两个不同的帖子对象：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the first document has no comments array. As stated before, documents
    are schemaless, so this format is perfectly valid. The lack of a schema also means
    that there are no type checks at the database level. There is nothing in the database
    to stop an integer from being entered into the title field of a post. Schemaless
    data is the most powerful feature of document stores and attracts many developers
    to adopt it for their apps. However, it can also be considered very dangerous,
    as there is one less check to stop faulty or malformed data from getting into
    your database.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个文档没有评论数组。如前所述，文档是无模式的，因此这种格式是完全有效的。无模式也意味着在数据库级别没有类型检查。数据库中没有阻止整数被输入到帖子标题字段中的内容。无模式数据是文档存储最强大的功能之一，吸引了众多开发者将其用于他们的应用程序。然而，它也可以被认为是非常危险的，因为这意味着有更少的检查来阻止错误或不规范的数据进入您的数据库。
- en: Some document stores collect similar objects into collections of documents to
    make querying objects easier. However, in some document stores, all objects are
    queried at once. Document stores store the metadata of each object, which allows
    all of the values in each document to be queried and return matching documents.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文档存储将类似的对象收集到文档集合中，以简化对象的查询。然而，在某些文档存储中，所有对象都会一次性查询。文档存储存储每个对象的元数据，这使得可以查询每个文档中的所有值并返回匹配的文档。
- en: The most popular document stores are **MongoDB**, **CouchDB**, and **Couchbase**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的文档存储包括 **MongoDB**、**CouchDB** 和 **Couchbase**。
- en: Column family stores
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列族存储
- en: '**Column family stores**, also known as **wide column stores**, have many things
    in common with both key-value stores and document stores. Column family stores
    are the fastest type of NoSQL database because they are designed for large applications.
    Their main advantage is their ability to handle terabytes of data and still have
    very fast read and write speeds by distributing the data across several servers
    in an intelligent way.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**列族存储**，也称为 **宽列存储**，与键值存储和文档存储有许多共同之处。列族存储是NoSQL数据库中最快的一种类型，因为它们是为大型应用程序设计的。它们的主要优势是能够通过智能地跨多个服务器分配数据来处理数以TB计的数据，同时仍然保持非常快的读写速度。'
- en: Column family stores are also the hardest to understand, due in part to the
    vernacular of column family stores, as they use many of the same terms as RDBMSes,
    but with wildly different meanings. In order to clearly understand what a column
    family store is, let's jump straight into an example. Let's create a simple *user-to-posts*
    association in a typical column family store.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列族存储也最难理解，部分原因是由于列族存储的术语，因为它们使用了与RDBMSes相同的许多术语，但含义却截然不同。为了清楚地理解什么是列族存储，让我们直接进入一个例子。让我们在一个典型的列族存储中创建一个简单的
    *用户到帖子* 关联。
- en: 'First, we need a user table. In column family stores, data is stored and accessed
    via a unique key, such as a key-value store, but the content consists of unstructured
    columns, such as a document store. Consider the following user table:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个用户表。在列族存储中，数据通过唯一键存储和访问，就像键值存储一样，但内容由非结构化列组成，就像文档存储一样。考虑以下用户表：
- en: '| **Key** | `Jack` |  |  | `John` |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **键** | `Jack` |  |  | `John` |  |'
- en: '| **Column** | `Full Name` | `Bio` | `Location` | `Full Name` | `Bio` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **列** | `全名` | `简介` | `位置` | `全名` | `简介` |'
- en: '| **Value** | `Jack Stouffer` | `This is my about me` | `Michigan, USA` | `John
    Doe` | `This is my about me` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **值** | `Jack Stouffer` | `这是我关于我的介绍` | `美国，密歇根州` | `John Doe` | `这是我关于我的介绍`
    |'
- en: 'Note that each key holds columns, which are key-value pairs as well. Also,
    it is not necessary for each key to have the same number or type of columns. Each
    key can store hundreds of unique columns, or they can all have the same number
    of columns to make application development easier. This is in contrast to key-value
    stores, which can hold any type of data with each key. This is also slightly different
    than document stores, which can store types, such as arrays and dictionaries,
    in each document. Now let''s create our posts table:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个键都包含列，这些列也是键值对。此外，每个键不需要具有相同数量或类型的列。每个键可以存储数百个独特的列，或者它们可以具有相同数量的列，以简化应用程序开发。这与键值存储不同，每个键可以存储任何类型的数据。这与文档存储也略有不同，文档存储可以在每个文档中存储类型，如数组和字典。现在让我们创建我们的帖子表：
- en: '| **Key** | `Post/1` |  |  | `Post/2` |  |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **键** | `Post/1` |  |  | `Post/2` |  |  |'
- en: '| **Column** | `Title` | `Date` | `Text` | `Title` | `Date` | `Text` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **列** | `标题` | `日期` | `文本` | `标题` | `日期` | `文本` |'
- en: '| **Value** | `Hello World` | `2015-01-01` | `Post text...` | `Still Here`
    | `2015-02-01` | `Post text...` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **值** | `Hello World` | `2015-01-01` | `帖子文本...` | `仍在这里` | `2015-02-01`
    | `帖子文本...` |'
- en: There are several things to understand about column family stores before we
    continue. Firstly, in column family stores, data can only be selected via a single
    key or key range; there is no way to query the contents of the columns. To get
    around this, many programmers use an external search tool with their database—such
    as **Elasticsearch**—that stores the contents of columns in a searchable format
    (Lucene's inverted indexes) and returns matching keys to be queried on the database.
    This limitation is why proper *schema* design is so crucial in column family stores,
    and must be carefully thought through before storing any data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有几件事情需要了解关于列族存储。首先，在列族存储中，数据只能通过单个键或键范围进行选择；无法查询列的内容。为了解决这个问题，许多程序员使用外部搜索工具与他们的数据库一起使用——例如**Elasticsearch**——该工具以可搜索的格式（Lucene的倒排索引）存储列的内容，并返回匹配的键以在数据库上进行查询。这种限制使得在列族存储中进行适当的**模式**设计变得至关重要，必须在存储任何数据之前仔细考虑。
- en: Secondly, data cannot be ordered by the content of the columns. Data can only
    be ordered by key, which is why the keys to the posts are integers. This allows
    the posts to be returned in the order in which they were entered. This is not
    a requirement for the user table because there is no need to sequentially order
    users.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，数据不能按列的内容排序。数据只能按键排序，这就是为什么帖子键是整数的原因。这允许帖子以它们被输入的顺序返回。这不是用户表的要求，因为不需要按顺序排列用户。
- en: 'Thirdly, there are no `JOIN` operators, and we cannot query for a column that
    would hold a user key. With our current schema, there is no way to associate a
    post with a user. To create this functionality, we need a third table that holds
    the user to post associations, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，没有`JOIN`运算符，我们无法查询包含用户键的列。根据我们当前的架构，无法将帖子与用户关联起来。为了创建这个功能，我们需要一个包含用户到帖子关联的第三个表，如下所示：
- en: '| **Key** | `Jack` |  |  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **键** | `Jack` |  |  |'
- en: '| **Column** | `Posts` | `Posts/1` | `Post/1` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **列** | `Posts` | `Posts/1` | `Post/1` |'
- en: '| **Value** |  | `Posts/2` | `Post/2` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **值** |  | `Posts/2` | `Post/2` |'
- en: This is slightly different from the other tables we have seen so far. The `Posts`
    column is named a **super column**, which is a column that holds other columns.
    In this table, a super column is associated with our user key, which is holding
    an association of the position of a post to one post. Clever readers might ask
    why we wouldn't just store this association in our `user` table, much like how
    the problem would be solved in document stores. This is because regular columns
    and super columns cannot be held in the same table. You must choose one at the
    creation of each table.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他我们迄今为止看到的表格略有不同。`Posts`列被命名为**超级列**，这是一个包含其他列的列。在这个表中，超级列与我们的用户键相关联，它保存了一个帖子位置与一个帖子的关联。聪明的读者可能会问，为什么我们不在我们的`user`表中存储这个关联，就像在文档存储中解决问题一样。这是因为常规列和超级列不能在同一个表中保存。你必须在每个表创建时选择一个。
- en: To get a list of all the posts by a user, we would first have to query the post
    association table with our user key, use the returned list of associations to
    get all of the keys in the posts' table, and query the post table with the keys.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个用户的全部帖子列表，我们首先必须使用我们的用户键查询帖子关联表，使用返回的关联列表获取帖子表中的所有键，然后使用这些键查询帖子表。
- en: If that query seems like a roundabout process to you, that's because it is,
    and it is made that way by design. The limiting nature of a column family store
    is what allows it to be so fast and handle so much data. Removing features such
    as searching by value and column name gives column family stores the ability to
    handle hundreds of terabytes of data. It's not an exaggeration to say that SQLite
    is a more complex database for the programmer than a typical column family store.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个查询过程看起来很绕，那是因为它确实如此，而且这是设计使然。列族存储的限制性质使其能够如此快速地处理大量数据。通过移除如按值和列名搜索等特性，列族存储能够处理数百TB的数据。说SQLite对于程序员来说比典型的列族存储更复杂，并不夸张。
- en: For this reason, most Flask developers should steer clear of column family stores
    as they add complexity to applications that isn't necessary. Unless your application
    is going to handle millions of reads and writes a second, using a column family
    store is like pounding in a nail with an atomic bomb.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数Flask开发者应该避免使用列族存储，因为它们为应用程序增加了不必要的复杂性。除非你的应用程序将要处理每秒数百万次的读写操作，否则使用列族存储就像用原子弹钉钉子一样。
- en: The most popular column family stores are **BigTable**, **Cassandra**, and **HBase**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的列族存储是 **BigTable**、**Cassandra** 和 **HBase**。
- en: Graph databases
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图数据库
- en: Designed to describe and then query relationships, **graph databases** are like
    document stores, but have mechanisms to create and describe links between two
    nodes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 设计用于描述和查询关系，**图数据库**类似于文档存储，但具有创建和描述两个节点之间链接的机制。
- en: 'A **node** is like an instance of an object, usually a collection of key-value
    pairs or a JSON document. Nodes can be given labels to mark them as part of a
    category—for example, a user or a group. After your nodes have been defined, an
    arbitrary number of one-way relationships between the nodes, named **links**,
    can be created with their own attributes. For example, if our data had two user
    nodes and each of the two users knew each other, we would define two `knows` links
    between them to describe that relationship, as shown in the following diagram.
    This would allow you to query all the people that know one user or all the people
    that a user knows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**节点**类似于对象的实例，通常是一组键值对或JSON文档的集合。节点可以通过标签来标记它们属于某个类别——例如，用户或组。在定义了节点之后，可以在节点之间创建任意数量的单向关系，称为**链接**，并具有它们自己的属性。例如，如果我们的数据有两个用户节点，并且两个用户彼此认识，我们会在它们之间定义两个`知道`链接来描述这种关系，如下面的图所示。这将允许你查询知道一个用户的所有人或者一个用户知道的所有人：'
- en: '![](img/511f648d-f81b-41e3-8666-0229727d66e1.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/511f648d-f81b-41e3-8666-0229727d66e1.png)'
- en: Graph stores also allow you to query by the link's attributes. This allows you
    to easily create otherwise complex queries, such as a search for all of the users
    that one user marked as known in October 2001\. Graph stores can follow links
    from node to node to create even more complex queries. If this example dataset
    had more groups, we can query for groups that people we know have joined but that
    we haven't joined. Otherwise, we can query for people who are in the same groups
    as a user, but who the user doesn't know. Queries in a graph store can also follow
    a large number of links to answer complex questions, such as "which restaurants in
    New York that serve burgers and have a three-star rating or higher have my friends
    liked?"
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库还允许你通过链接的属性进行查询。这使你能够轻松创建其他情况下复杂的查询，例如搜索2001年10月被一个用户标记为已知的所有用户。图数据库可以跟随节点到节点的链接来创建更复杂的查询。如果这个示例数据集有更多组，我们可以查询我们认识的人加入但尚未加入的组。否则，我们可以查询与用户在同一组但用户不认识的人。图数据库中的查询还可以跟随大量链接来回答复杂问题，例如“纽约哪些提供汉堡并拥有三星或更高评价的餐厅，我的朋友喜欢过？”
- en: The most common use case for a graph database is to build a recommendation engine.
    For example, say that we had a graph store that is filled with our friend data
    from a social networking site. Using this data, we could build a mutual friend
    finder by querying for users that have been marked as friends by more than two
    of our friends.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库最常见的使用案例是构建推荐引擎。例如，假设我们有一个图数据库，里面存储了来自社交网络网站的朋友数据。使用这些数据，我们可以通过查询被我们超过两个朋友标记为朋友的用户来构建一个共同朋友查找器。
- en: It is very rare for a graph database to be used as the primary data store of
    an application. Most uses of graph stores have each node acting as a representation
    of a piece of data in their main database by storing its unique identifier and
    a small amount of other identifying information.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库作为应用程序的主要数据存储使用的情况非常罕见。大多数图存储的使用中，每个节点都充当它们主数据库中数据的一部分的表示，通过存储其唯一标识符和一些其他识别信息来实现。
- en: The most popular graph stores are **Neo4j** and **InfoGrid**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的图数据库是 **Neo4j** 和 **InfoGrid**。
- en: RDBMS versus NoSQL
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RDBMS 与 NoSQL 的比较
- en: NoSQL is a tool, and like any tool there are specific use cases where it excels
    and there are use cases where some other tool would be a better fit. No one would
    use a screwdriver to pound in a nail; it's possible, but using a hammer would
    make the job easier. One large problem with NoSQL databases is that people adopt
    them when an RDBMS would solve the problem just as well, or better.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 是一个工具，就像任何工具一样，有一些特定的用例它做得很好，而有些用例其他工具可能更适合。没有人会用螺丝刀敲钉子；这是可能的，但用锤子会让工作更容易。NoSQL
    数据库的一个大问题是，当 RDBMS 也能很好地解决问题，甚至更好时，人们仍然采用它们。
- en: To understand which tool should be used when, we must understand the strengths
    and weaknesses of both systems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解何时使用哪种工具，我们必须理解这两种系统的优势和劣势。
- en: The strengths of RDBMS databases
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RDBMS 数据库的优势
- en: One of the biggest strengths of RDBMSes is their maturity. The technology behind
    RDBMSes has existed for over 40 years and is based on the solid theory of relational
    algebra and relational calculus. Because of their maturity, they have a long,
    proven track record across many different industries of handling data in a safe
    and secure way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS（关系型数据库管理系统）最大的优势之一是其成熟度。RDBMS背后的技术已经存在了40多年，基于关系代数和关系演算的坚实基础理论。正因为其成熟度，它们在许多不同行业中处理数据的安全和可靠方面有着长期的、经过验证的记录。
- en: Data integrity
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据完整性
- en: Integrity is also one of the biggest selling points of RDBMSes. RDBMSes have
    several methods in place to ensure that the data entered into a database will
    not only be correct, but that data loss will be practically nonexistent. These
    methods combine to form what is known as **ACID** (short for **atomicity**, **consistency**,
    **isolation**, and **durability**). ACID is a set of rules for transactions that
    guarantee that the transaction is handled safely.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性也是RDBMS最大的卖点之一。RDBMS有几种方法来确保输入数据库的数据不仅正确，而且数据丢失实际上是不存在的。这些方法结合起来形成了所谓的**ACID**（代表**原子性**、**一致性**、**隔离性**和**持久性**）。ACID是一组规则，用于保证事务的安全处理。
- en: 'The principle of atomicity requires that each transaction is all or nothing.
    If one part of the transaction fails, the entire transaction fails. This is much
    like the following quote from *The Zen of Python*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性原则要求每个事务要么全部完成，要么全部不完成。如果事务的一部分失败，整个事务就会失败。这就像以下来自*Python之禅*的引言：
- en: '"Errors should never pass silently. Unless explicitly silenced."'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “错误绝不应该默默无闻。除非明确地被压制。”
- en: If there is a problem with the data that has been changed or entered, the transaction
    should not keep operating because the proceeding operations most likely require
    that the previous operations were successful.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改或输入的数据存在问题，事务不应该继续运行，因为后续的操作很可能需要前面的操作成功。
- en: The principle of consistency requires that any data that the transaction modifies
    or adds follows the rules of each table. Such rules include type checks, user-defined
    constraints—such as *foreign keys—*cascade rules, and triggers. If any of the
    rules are broken, then according to the atomicity rule, the transaction will be
    thrown out.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性原则要求事务修改或添加的任何数据都必须遵循每个表的规则。这些规则包括类型检查、用户定义的约束（如*外键*）、级联规则和触发器。如果任何规则被违反，根据原子性规则，事务将被取消。
- en: The principle of isolation requires that if the database runs transactions concurrently
    to speed up writes, then the outcome of the transactions would be the same as
    if they were run serially. This is mostly a rule for database programmers, and
    is not something that web developers need to worry about.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离性原则要求，如果数据库为了加速写入而并发运行事务，那么事务的结果应该与它们串行运行时相同。这主要是一条针对数据库程序员的规则，并不是网络开发者需要担心的事情。
- en: Finally, the principle of durability requires that once a transaction is accepted,
    the data must never be lost, barring a hard drive failure after the transaction
    is accepted. If the database crashes or loses power, then the durability principle
    requires that any data written before the problem occurred should still be present
    when the server is backed up. This essentially means that all transactions must
    be written to the disk once they are accepted.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，持久性原则要求一旦事务被接受，数据就绝不能丢失，除非是在事务被接受后硬盘故障。如果数据库崩溃或断电，持久性原则要求在服务器备份时，任何在问题发生之前写入的数据仍然应该存在。这实际上意味着一旦事务被接受，所有事务都必须写入磁盘。
- en: Speed and scale
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度和规模
- en: A common misconception is that the ACID principle makes RDBMSes slow and unable
    to scale. This is only half true—it is completely possible for an RDBMS to scale.
    For example, an Oracle database configured by a professional database administrator
    can handle tens of thousands of complex queries a second. Huge companies, such
    as Facebook, Twitter, Tumblr, and Yahoo!, are using MySQL to great effect, and
    PostgreSQL is emerging as a favorite of many programmers because of its speed
    advantage over MySQL.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是ACID原则使得RDBMS变得**慢**和**无法扩展**。这只有一半是真的——RDBMS完全可以扩展。例如，由专业数据库管理员配置的Oracle数据库可以每秒处理数万个复杂查询。像Facebook、Twitter、Tumblr和Yahoo！这样的大公司正在有效地使用MySQL，而PostgreSQL由于其比MySQL更快的速度优势，正在成为许多程序员的喜爱。
- en: Tools
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: When evaluating a programming language, the strongest points for or against
    adopting it are the size and activity of its community. A larger and more active
    community means more help if you get stuck and more open source tools available
    for you to use in your projects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估一种编程语言时，支持或反对采用它的最强论点是其社区的大小和活跃度。一个更大、更活跃的社区意味着如果你遇到困难时会有更多帮助，以及更多开源工具可供你在项目中使用。
- en: It's no different with databases. RDBMSes, such as MySQL and PostgreSQL, have
    official libraries for almost every language that is used in commercial environments
    and unofficial libraries for everything else. Tools, such as Excel, can easily
    download the latest data from one of these databases and allow the user to treat
    it like it was any other dataset. Several free desktop GUIs exist for each database,
    and some are officially supported by the databases' corporate sponsor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库也是如此。例如MySQL和PostgreSQL这样的RDBMSes，为商业环境中使用的几乎每种语言都提供了官方库，为其他所有内容提供了非官方库。例如Excel这样的工具可以轻松地从这些数据库中下载最新数据，并允许用户将其视为任何其他数据集。每个数据库都有几个免费的桌面GUI，其中一些由数据库的赞助公司官方支持。
- en: The strengths of NoSQL databases
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诺斯克数据库的优势
- en: The main reason that many people use NoSQL databases is its speed advantage over
    traditional databases. Out of the box, many NoSQL databases can outperform RDBMSes.
    However, a well-tuned and properly scaled SQL database with read slaves can outperform
    NoSQL databases. Many NoSQL databases, especially document stores, sacrifice consistency
    for availability. This means that they can handle many concurrent reads and writes,
    but those writes may be in conflict with one another. Yet, this is not straightforward,
    as you will soon see when we look at the CAP theorem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人使用诺斯克数据库的主要原因是其速度优势，这种优势超过了传统数据库。开箱即用的许多诺斯克数据库可以超越RDBMSes。然而，经过良好调整和适当扩展的带有读从机的SQL数据库可以超越诺斯克数据库。许多诺斯克数据库，尤其是文档存储，为了可用性牺牲了一致性。这意味着它们可以处理许多并发读取和写入，但这些写入可能相互冲突。然而，这并不简单，正如我们将在CAP定理中看到的那样。
- en: The second feature that pulls people to NoSQL is its ability to handle unformatted
    data. Storing data in XML or JSON allows an arbitrary structure to each document.
    Applications that store user-designed data have benefited greatly from the adoption
    of NoSQL. For example, a video game that allows players to submit their custom
    levels to some central repository can now store the data in a queryable format
    rather than in a binary blob.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 诺斯克数据库吸引人们的第二个特点是它处理未格式化数据的能力。将数据存储在XML或JSON中允许每个文档具有任意结构。存储用户设计数据的应用程序从采用诺斯克数据库中受益匪浅。例如，一款允许玩家将自定义关卡提交到某个中央存储库的视频游戏现在可以将数据存储在可查询的格式中，而不是二进制blob中。
- en: The third feature that draws people to NoSQL is the ease of creating a cluster
    of databases working in tandem. Not having `JOIN` operators or only accessing
    values via keys makes splitting the data across servers a rather trivial task
    when compared with RDBMSes. This is due to the fact that `JOIN` operators require
    a scan of the entire table, even if it is split across many different servers.
    The `JOIN` operators become even slower when documents or keys can be assigned
    to a server by an algorithm as simple as the starting character of its unique
    identifier—for example, everything that starts with the letters A–H is sent to
    server 1, I–P to server 2, and Q–Z to server 3\. This makes looking up the location
    of data for a connected client very fast.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 诺斯克数据库吸引人们的第三个特点是创建一个协同工作的数据库集群非常容易。没有`JOIN`操作符或仅通过键访问值，与关系型数据库管理系统（RDBMSes）相比，将数据分散到服务器上变得相当简单。这是因为`JOIN`操作符需要扫描整个表，即使它分布在许多不同的服务器上。当文档或键可以通过像其唯一标识符的起始字符这样简单的算法分配给服务器时，`JOIN`操作符会变得更慢——例如，以字母A–H开头的所有内容都发送到服务器1，I–P发送到服务器2，Q–Z发送到服务器3。这使得查找连接客户端的数据位置非常快。
- en: Next, we will briefly explain the CAP theorem, to give you some background on
    the underlying problems behind database-distributed systems.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要解释CAP定理，以便您了解数据库分布式系统背后的基本问题。
- en: CAP theorem
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAP定理
- en: The **CAP** theorem stands for **consistency**, **availability**, and **partition**
    tolerance, and states that it's not possible for a distributed system to guarantee
    all three, so a trade-off must be made.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAP**定理代表**一致性**、**可用性**和**分区容错性**，并指出分布式系统无法保证所有三者，因此必须做出权衡。'
- en: 'The following list shows exactly what each of these guarantees means on a distributed
    system:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了在分布式系统中这些保证的确切含义：
- en: '**Consistency:** Guarantees that each node on a cluster returns the most recent
    write and preserves linear consistency'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：保证集群中的每个节点返回最新的写入并保持线性一致性'
- en: '**Availability:** Every non failing node is able to respond to a request with
    a non error response'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：每个非故障节点都能以非错误响应响应请求'
- en: '**Partition tolerance**: The system continues to operate despite network outages/delays'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容错性**：系统在网络中断/延迟的情况下仍能继续运行'
- en: The theorem states that in case of a network partition, a distributed system
    has to choose between consistency or availability, so in the case of a network
    partition, systems must fall into two main categories, CP and AP.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该定理表明，在出现网络分区的情况下，分布式系统必须在一致性和可用性之间做出选择，因此，在网络分区的情况下，系统必须分为两大类，CP和AP。
- en: 'A simple visualization of such a distributed system would be two instances
    serving many clients concurrently on distinct data centers. One client sends:
    write the key-value **a:0** to **server1**. Then **server1** sends **a:0** to
    **server2**, **server2** sends an acknowledgement back to **server1** which then
    sends an acknowledgement back to the client. This is shown in the following diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对这样一个分布式系统的简单可视化将是两个实例在各自的数据中心并发地为许多客户端提供服务。一个客户端发送：将键值**a:0**写入**server1**。然后**server1**将**a:0**发送给**server2**，**server2**将确认信息发送回**server1**，**server1**再将确认信息发送回客户端。这在上面的图中展示：
- en: '![](img/82a9d1a9-ded1-4560-890f-1b6db2ad194e.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82a9d1a9-ded1-4560-890f-1b6db2ad194e.png)'
- en: 'Imagine that a network partition occurs and this prevents **server1** from
    communicating with **server2**. Meanwhile, **client1** requests that **server1**
    changes **a:0** to **a:1**. If the system aims for consistency, then it would
    reject the transaction since it can''t send the write to **server2** and **server2**
    would deny any transactions since it could serve dirty reads, and we are aiming
    for consistency. This relationship is shown in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设发生网络分区，这阻止了**server1**与**server2**通信。同时，**client1**请求**server1**将**a:0**改为**a:1**。如果系统追求一致性，那么它将拒绝这个事务，因为它不能将写入发送到**server2**，而**server2**将拒绝任何事务，因为它可以提供脏读，而我们追求的是一致性。这种关系在上面的图中展示：
- en: '![](img/73ec2395-8639-44f5-a5ad-12a4174c9508.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73ec2395-8639-44f5-a5ad-12a4174c9508.png)'
- en: If we want to aim for availability, we must relax consistency. In today's database
    RDBMS or NoSQL, systems are not 100% CP or AP, but they can be configured to be
    more or less relaxed as to their consistency and availability to a certain degree.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要追求可用性，我们必须放宽一致性。在今天的数据库RDBMS或NoSQL中，系统不是100%的CP或AP，但它们可以被配置为在一定程度上更加或更少地放宽其一致性和可用性。
- en: 'Although not 100% correct, MongoDB aims for consistency and partition tolerance.
    MongoDB in a cluster architecture uses a single-master setup, which means that
    a single node can accept writes. It avoids a **single point of failure** (**SPOF**)
    by having the ability to switch if the majority of the other nodes lose contact
    with their current master. This increases availability by lowering consistency
    for the following reasons:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是100%正确，但MongoDB旨在实现一致性和分区容错性。在集群架构中，MongoDB使用单主设置，这意味着单个节点可以接受写入。通过在大多数其他节点与当前主节点失去联系时具有切换能力，它避免了**单点故障**（**SPOF**）。这通过以下原因降低了一致性来提高可用性：
- en: If you use a single node, then reads and writes to the same system on MongoDB
    will make it a very consistent system, but if you use multiple instances for reads
    with asynchronous replication, then the entire system will eventually become consistent
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用单个节点，那么在MongoDB中对同一系统的读写将使其成为一个非常一致的系统，但如果你使用异步复制的多个实例进行读取，那么整个系统最终将变得一致
- en: When the old master node recovers, it will rejoin the cluster as a slave node,
    and all the dirty writes it might have will be rolled back
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当旧的主节点恢复后，它将以从节点的身份重新加入集群，并且它可能有的所有脏写操作都将被回滚
- en: What database to use and when
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用哪种数据库
- en: So, each database has different uses. It was stated at the beginning of the
    section that the main problem when programmers choose a NoSQL database for their
    technology stack is that they choose it when an RDBMS would work just as well.
    This is born out of some common misconceptions. Firstly, people try to use a relational
    mindset and data model and think that they will work just as well in a NoSQL database.
    People usually come to this misunderstanding because the marketing on the various
    websites of NoSQL databases is misleading, and encourages users to drop their
    current database without considering whether a non-relational model will work
    for their project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个数据库都有不同的用途。本节开头提到，当程序员在选择 NoSQL 数据库作为其技术栈时遇到的主要问题是，他们在 RDBMS 也能正常工作的情况下选择了它。这源于一些常见的误解。首先，人们试图使用关系型思维和数据模型，并认为它们在
    NoSQL 数据库中也能同样工作。人们通常产生这种误解是因为 NoSQL 数据库在各种网站上的营销误导，并鼓励用户在没有考虑非关系型模型是否适用于他们的项目的情况下放弃当前的数据库。
- en: Secondly, people believe that you must use only one data store for your application.
    Many applications can benefit from using more than one data store. Take a Facebook
    clone as an example. It could use MySQL for holding user data, Redis to store
    session data, a document store to hold the data for the quizzes and surveys that
    people share with each other, and a graph database to implement a feature for
    finding friends.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，人们认为你必须为你的应用程序只使用一个数据存储。许多应用程序可以从使用多个数据存储中受益。以 Facebook 复制品为例。它可以使用 MySQL
    来存储用户数据，Redis 来存储会话数据，文档存储来存储人们相互分享的测验和调查数据，以及图数据库来实现查找朋友的功能。
- en: If an application feature needs very fast writes, and write safety is not a
    primary concern, then you should use a document store database. If you need to
    store and query schemaless data, then you should use a document store database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序功能需要非常快的写入，并且写入安全性不是首要关注的问题，那么你应该使用文档存储数据库。如果你需要存储和查询无模式数据，那么你应该使用文档存储数据库。
- en: If an application feature needs to store something that deletes itself after
    a specified time, or if the data does not need to be searched, then you should
    use a key-value store.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序功能需要存储在指定时间后自动删除的数据，或者如果数据不需要被搜索，那么你应该使用键值存储。
- en: If an application feature involves finding or describing complex relationships
    between two or more sets of data, then you should use a graph store.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序功能涉及在两个或多个数据集之间找到或描述复杂的关系，那么你应该使用图存储。
- en: If an application feature needs guaranteed write safety, or if it needs each
    entry to fit into a specified schema, different sets of data in the database to
    be compared using `JOIN` operators, or constraints on the entered data, then you
    should use an RDBMS.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序功能需要保证写入安全性，或者如果每个条目都需要符合指定的模式，或者需要在数据库中使用 `JOIN` 操作符比较不同的数据集，或者对输入的数据有约束，那么你应该使用
    RDBMS。
- en: MongoDB in Flask
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB 在 Flask 中
- en: MongoDB is far and away the most popular NoSQL database. MongoDB is also the
    best-supported NoSQL database for Flask and Python in general. Therefore, our
    examples will focus on MongoDB.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是最受欢迎的 NoSQL 数据库。MongoDB 也是 Flask 和 Python 的一般情况下支持最好的 NoSQL 数据库。因此，我们的示例将专注于
    MongoDB。
- en: MongoDB is a document storage NoSQL database. Documents are stored in collections,
    which allow the grouping of similar documents, but no similarities between documents
    are necessary to store a document in a collection. Documents are defined in a
    JSON superset named **BSON** (short for **Binary JSON**). BSON allows JSON to
    be stored in binary format rather than in string format, saving a lot of space.
    BSON also distinguishes between several different ways of storing numbers, such
    as 32-bit integers and doubles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一种文档存储的 NoSQL 数据库。文档存储在集合中，允许将相似的文档分组，但存储在集合中的文档之间没有必要有相似性。文档由一个名为
    **BSON**（即 **Binary JSON**）的 JSON 扩展定义。BSON 允许将 JSON 以二进制格式而不是字符串格式存储，从而节省大量空间。BSON
    还区分了几种不同的存储数字的方式，例如 32 位整数和双精度浮点数。
- en: To understand the basics of MongoDB, we will use **Flask-MongoEngine** to cover
    the same functionality of Flask-SQLAlchemy in the previous chapters. Remember
    that these are just examples. There is no benefit of refactoring our current code
    to use MongoDB because MongoDB cannot offer any new functionality for our use
    case. New functionality with MongoDB will be shown in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解MongoDB的基本知识，我们将使用**Flask-MongoEngine**来覆盖前几章中Flask-SQLAlchemy的功能。请记住，这些只是示例。将我们当前的代码重构为使用MongoDB没有任何好处，因为MongoDB无法为我们提供任何新的功能。MongoDB的新功能将在下一节中展示。
- en: Installing MongoDB
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装MongoDB
- en: To install MongoDB, go to [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)
    and select your OS from the tabs under the heading Download MongoDB. Every OS
    that has a supported version has installation instructions listed next to the
    download button of the installer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装MongoDB，请访问[https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)，然后在“下载MongoDB”标题下的选项卡中选择您的操作系统。每个有支持版本的操作系统旁边都有安装说明，列在安装程序的下载按钮旁边。
- en: 'To run MongoDB, go to Bash and run the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行MongoDB，请进入Bash并运行以下命令：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will run a server for as long as the window is open.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使服务器在窗口打开期间一直运行。
- en: Using Docker, you can easily launch a MongoDB server without needing to install
    anything else on your computer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，您可以轻松启动MongoDB服务器，而无需在您的计算机上安装任何其他东西。
- en: 'To start a MongoDB server on Docker, enter the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Docker上启动MongoDB服务器，请输入以下命令：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setting up MongoEngine
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置MongoEngine
- en: 'If you''re following the example code provided with this book (which you can
    find at [https://github.com/PacktPublishing/Hands-On-Web-Development-with-Flask](https://github.com/PacktPublishing/Hands-On-Web-Development-with-Flask)),
    then all you need to do is create a new Python virtual environment and install
    all the necessary dependencies. You will notice the provided `init.sh` and `requirements.txt`.
    Inside the `init.sh`, we have all the necessary commands to get us set up, as
    shown in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在遵循本书提供的示例代码（您可以在[https://github.com/PacktPublishing/Hands-On-Web-Development-with-Flask](https://github.com/PacktPublishing/Hands-On-Web-Development-with-Flask)找到），那么您需要做的就是创建一个新的Python虚拟环境并安装所有必要的依赖项。您会注意到提供的`init.sh`和`requirements.txt`。在`init.sh`中，我们包含了所有必要的命令来帮助我们设置，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, of course, our **`requirements.txt` **contains the following necessary
    packages:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的**`requirements.txt`**文件包含了以下必要的包：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `__init__.py` file, a `mongo` object will be created that represents
    our database, as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__.py`文件中，将创建一个`mongo`对象，它代表我们的数据库，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before our app will run, our `DevConfig` object in `config.py` needs to set
    up the parameters of the `mongo` connection:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序运行之前，`config.py`中的`DevConfig`对象需要设置`mongo`连接的参数：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These are the defaults for a brand new MongoDB installation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是全新MongoDB安装的默认设置。
- en: Defining documents
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义文档
- en: MongoEngine is an ORM that is based around Python's object system, and is specifically
    designed for MongoDB. Unfortunately, there is no SQLAlchemy-style wrapper that
    supports all NoSQL drivers. In RDBMSes, the implementations of SQL are so similar
    that creating a universal interface is possible. However, the underlying implementations
    of each document store are different enough that the task of creating a similar
    interface would be more trouble than it is worth.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: MongoEngine是一个基于Python对象系统的ORM，专门为MongoDB设计。不幸的是，没有支持所有NoSQL驱动器的SQLAlchemy风格的包装器。在RDBMS中，SQL的实现非常相似，因此创建一个通用接口是可能的。然而，每个文档存储的底层实现差异足够大，以至于创建类似接口的任务可能比它值得的麻烦更多。
- en: 'Each collection in your Mongo database is represented by a class that inherits
    from `mongo.Document`, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您Mongo数据库中的每个集合都由一个继承自`mongo.Document`的类表示，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each class variable is a representation of a key belonging to a document, which
    is represented in this example of a `Post` class. The class variable name is used
    as the key in the document.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类变量都是文档中属于键的表示，在这个`Post`类的示例中。类变量名称用作文档中的键。
- en: 'Unlike SQLAlchemy, there is no need to define a primary key. A unique ID will
    be generated for you under the `id` attribute. The preceding code would generate
    a BSON document that would resemble the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与SQLAlchemy不同，不需要定义主键。在`id`属性下会为您自动生成一个唯一的ID。前面的代码将生成一个类似于以下内容的BSON文档：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Field types
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段类型
- en: 'There are a large number of fields, and each represents a distinct category
    of data in Mongo. Unlike the underlying database, each field provides a type check
    before the document is allowed to be saved or altered. The most-used fields are
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 存在大量字段，每个字段在Mongo中表示一种独特的数据类别。与底层数据库不同，每个字段在允许文档保存或修改之前都会进行类型检查。最常用的字段如下：
- en: '`BooleanField`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BooleanField`'
- en: '`DateTimeField`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTimeField`'
- en: '`DictField`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DictField`'
- en: '`DynamicField`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DynamicField`'
- en: '`EmbeddedDocumentField`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmbeddedDocumentField`'
- en: '`FloatField`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FloatField`'
- en: '`IntField`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntField`'
- en: '`ListField`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListField`'
- en: '`ObjectIdField`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectIdField`'
- en: '`ReferenceField`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReferenceField`'
- en: '`StringField`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringField`'
- en: For a full list of fields and detailed documentation, go to the MongoEngine
    website at [http://docs.mongoengine.org](http://docs.mongoengine.org).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取字段和详细文档的完整列表，请访问MongoEngine网站[http://docs.mongoengine.org](http://docs.mongoengine.org)。
- en: 'The majority of these are named after the Python type they accept and work
    in the same way as the SQLAlchemy types. However, there are some new types that
    have no counterpart in SQLAlchemy. Let''s take a look at them in detail:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些字段都是以它们接受的Python类型命名的，并且与SQLAlchemy类型的工作方式相同。然而，也有一些新的类型在SQLAlchemy中没有对应项。让我们详细看看它们：
- en: '`DynamicField` is a field that can hold any type of value and performs no type
    checks on values.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DynamicField` 是一个可以存储任何类型值且不对值进行类型检查的字段。'
- en: '`DictField` can store any Python dictionary that can be serialized by `json.dumps()`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DictField` 可以存储任何可以通过`json.dumps()`序列化的Python字典。'
- en: '`ReferenceField` simply stores the unique ID of a document, and when queried,
    MongoEngine will return the referenced document.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReferenceField` 仅存储文档的唯一ID，当查询时，MongoEngine将返回引用的文档。'
- en: '`EmbeddedDocumentField` stores the passed document in the parent document,
    so there is no need for a second query.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmbeddedDocumentField` 将传递的文档存储在父文档中，因此无需进行第二次查询。'
- en: '`ListField` represents a list of fields of a specific type. This is typically
    used to store a list of references to other documents or a list of embedded documents
    to create a one-to-many relationship. If a list of unknown types is needed, then `DynamicField`
    can be used.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListField` 表示特定类型的字段列表。这通常用于存储对其他文档的引用列表或嵌入文档列表以创建一对一关系。如果需要未知类型的列表，则可以使用`DynamicField`。'
- en: 'Each field type takes some common arguments, as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段类型都接受一些常见的参数，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `primary_key` argument specifies that you do not want MongoEngine to autogenerate
    a unique key, but the value of the field should be used as the ID. The value of
    this field will now be accessible from both the `id` attribute and the name of
    the field.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`primary_key` 参数指定您不希望MongoEngine自动生成唯一键，但应使用字段的值作为ID。现在，该字段的值将从`id`属性和字段名称中访问。'
- en: '`db_field` defines what the key will be named in each document. If it is not
    set, it will default to the name of the class variable.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db_field` 定义了每个文档中键的名称。如果未设置，则默认为类变量的名称。'
- en: If `required` is defined as `True`, then that key must be present in the document.
    Otherwise, the key does not have to exist for documents of that type. When a class
    is defined, the nonexistent key is queried, and it will return `None`.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`required`定义为`True`，则该键必须存在于文档中。否则，该类型的文档不需要存在该键。当定义一个类时，查询不存在的键将返回`None`。
- en: '`default` specifies the value that this field will be given if no value is
    defined.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default` 指定如果没有定义值，该字段将赋予的值。'
- en: 'If `unique` is set to `True`, then MongoEngine checks to make sure that no
    other documents in the collection will have the same value for this field:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`unique`设置为`True`，则MongoEngine将检查确保集合中不会有其他文档具有该字段的相同值：
- en: When passed a list of field names, `unique_with` will make sure that—when taken
    in combination—the values of all the fields will be unique for each document.
    This is much like multicolumn `UNIQUE` indexes in RDBMSes.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递字段名称列表时，`unique_with`将确保在组合中，所有字段的值对于每个文档都是唯一的。这类似于RDBMS中的多列`UNIQUE`索引。
- en: Finally, when given a list, the `choices` option limits the allowable values
    for that field to the elements in the list.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当给定一个列表时，`choices`选项将限制该字段的允许值为列表中的元素。
- en: Types of documents
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档类型
- en: 'MongoEngine''s method to define documents allows either flexibility or rigidity
    on a collection-by-collection basis. Inheriting from `mongo.Document` means that
    only the keys defined in the class can be saved to the database. Those keys defined
    in the class can be empty, but everything else will be ignored. On the other hand,
    if your class inherits `mongo.DynamicDocument`, then any extra fields that are
    set will be treated as `DynamicField` and will be saved with the document, as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: MongoEngine定义文档的方法允许在集合级别上实现灵活性或刚性。从`mongo.Document`继承意味着只有类中定义的键可以保存到数据库中。类中定义的键可以是空的，但其他所有内容都将被忽略。另一方面，如果你的类继承自`mongo.DynamicDocument`，那么设置的任何额外字段都将被视为`DynamicField`并与文档一起保存，如下所示：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To show the  extreme case (which is not recommended), the following class is
    perfectly valid; it has no required fields and allows any fields to be set:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示极端情况（不推荐这样做），以下类是完全有效的；它没有必需的字段，允许设置任何字段：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last type of document is `EmbeddedDocument`. A `EmbeddedDocument` is simply
    a document that is passed to `EmbeddedDocumentField` and is stored as is in the
    document, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种文档类型是`EmbeddedDocument`。一个`EmbeddedDocument`简单地说是一个传递给`EmbeddedDocumentField`并按原样存储在文档中的文档，如下所示：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Why use `EmbeddedDocumentField` over `DictField` when they seem to perform
    the same function? The end result of using each is the same. However, an embedded
    document defines a structure for the data, while `DictField` can be anything.
    To understand this better, think of it this way: `Document` is to `DynamicDocument` what `EmbeddedDocument`
    is to `DictField`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在它们似乎执行相同功能的情况下使用`EmbeddedDocumentField`而不是`DictField`？使用每个的最终结果都是相同的。然而，一个嵌入文档定义了数据结构，而`DictField`可以是任何东西。为了更好地理解这一点，可以这样想：`Document`相对于`DynamicDocument`，就像`EmbeddedDocument`相对于`DictField`。
- en: The meta attribute
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`meta`属性'
- en: 'Using the `meta` class variable, many attributes of a document can be manually
    set. If you are working with an existing set of data and want to connect your
    classes to the collections, then set the collection key of the `meta` dictionary,
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`meta`类变量，可以手动设置文档的许多属性。如果你正在处理一组现有数据，并且想要将你的类连接到集合中，那么请设置`meta`字典的集合键，如下所示：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also manually set the maximum number of documents in the collection
    and the maximum size of each document. In the following example, there can be
    only 10,000 documents, and each document can''t be larger than 2 MB:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以手动设置集合中文档的最大数量和每个文档的最大大小。在以下示例中，只能有10,000个文档，并且每个文档的大小不能超过2 MB：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Indexes can also be set through MongoEngine. Indexes can be made single field
    by using a string or multifield by using a tuple, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 索引也可以通过MongoEngine设置。索引可以通过使用字符串创建单字段索引，或者使用元组创建多字段索引，如下所示：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The default ordering of a collection can be set through the `meta` variable
    using the **ordering key**, as shown in the following code. When `-` is prepended,
    it tells MongoEngine to order results in descending order of that field. If `+`
    is prepended, it tells MongoEngine to order results in ascending order of that
    field. This default behavior is overridden if the `order_by` function is specified
    in a query, which will be shown in the *CRUD* section:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`meta`变量使用**排序键**来设置集合的默认排序，如下面的代码所示。当以`-`开头时，它告诉MongoEngine按该字段的降序排序结果。如果以`+`开头，它告诉MongoEngine按该字段的升序排序结果。如果查询中指定了`order_by`函数，则将覆盖此默认行为，这将在*CRUD*部分中展示：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `meta` variable can also enable inheritance from user-defined documents,
    which is disabled by default. The subclass of the original document will be treated
    as a member of the parent class and will be stored in the same collection, as
    follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta`变量还可以启用从用户定义的文档继承，默认情况下是禁用的。原始文档的子类将被视为父类的一个成员，并将存储在同一个集合中，如下所示：'
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: CRUD
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD
- en: As stated in [Chapter 2](42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml), *Creating
    Models with SQLAlchemy*, there are four main forms of data manipulation that any
    data store must implement. They are the creation of new data, the reading of existing
    data, the updating of existing data, and the deletion of data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml)所述，*使用SQLAlchemy创建模型*，任何数据存储都必须实现四种主要的数据操作形式。它们是创建新数据、读取现有数据、更新现有数据以及删除数据。
- en: Create
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建
- en: 'To create a new document, just create a new instance of the class and call
    the `save` method, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的文档，只需创建该类的新实例并调用`save`方法，如下所示：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Otherwise, the values can be passed as keywords in the object creation, as
    follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，可以在对象创建时作为关键字参数传递值，如下所示：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Unlike SQLAlchemy, MongoEngine does not automatically save related objects
    that are stored in `ReferenceFields`. To save any changes to referenced documents
    along with the changes to the current document, pass `cascade` as `True`, as shown
    in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQLAlchemy 不同，MongoEngine 不会自动保存存储在 `ReferenceFields` 中的相关对象。要保存对引用文档的任何更改以及当前文档的更改，请将
    `cascade` 设置为 `True`，如下所示：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you wish to insert a document and skip its checks against the defined parameters
    in the class definition, then pass `validate` as `False`, as shown in the following
    code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望插入一个文档并跳过其与类定义中定义的参数的检查，那么请将 `validate` 设置为 `False`，如下所示：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember that these checks exist for a reason. Turn them off only for a very
    good reason.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些检查存在是有原因的。只有在非常合理的情况下才关闭它们。
- en: Write safety
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入安全性
- en: 'By default, MongoDB does not wait for the data to be written to disk before
    acknowledging that the write occurred. This means that it is possible for writes
    that were acknowledged to have failed, either by hardware failure or some error
    when the write occurred. To ensure that the data is written to disk before Mongo
    confirms the write, use the `write_concern` keyword. The `write_concern` parameter
    tells Mongo when it should return with an acknowledgement of the write, as shown
    in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MongoDB 在确认写入之前不会等待数据写入磁盘。这意味着已确认的写入可能会失败，无论是由于硬件故障还是写入时发生的某些错误。为了确保在
    Mongo 确认写入之前数据已写入磁盘，请使用 `write_concern` 关键字。`write_concern` 参数告诉 Mongo 应在何时返回写入确认，如下所示：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As stated in the *RDBMS versus NoSQL* section, it's very important that you
    understand how the NoSQL database that you are using treats writes. To learn more
    about MongoDB's write concern, go to [http://docs.mongodb.org/manual/reference/write-concern/](http://docs.mongodb.org/manual/reference/write-concern/).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 *RDBMS 与 NoSQL* 部分所述，了解你使用的 NoSQL 数据库如何处理写入非常重要。要了解更多关于 MongoDB 写入关注的内容，请访问
    [http://docs.mongodb.org/manual/reference/write-concern/](http://docs.mongodb.org/manual/reference/write-concern/)。
- en: Read
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读
- en: 'The `objects` attribute is used to access the documents from the database.
    To read all of the documents in a collection, use the `all` method, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`objects` 属性用于访问数据库中的文档。要读取集合中的所有文档，请使用 `all` 方法，如下所示：'
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To limit the number of items returned, use the `limit` method as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要限制返回的项目数量，请使用 `limit` 方法，如下所示：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This `limit` command is slightly different than the SQL version. In SQL, the
    `limit` command can also be used to skip the first results. To replicate this
    functionality, use the `skip` method as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `limit` 命令与 SQL 版本略有不同。在 SQL 中，`limit` 命令也可以用来跳过第一个结果。为了复制此功能，请使用 `skip`
    方法，如下所示：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'By default, MongoDB returns the results in the order of the time of their creation.
    To control this, there is the `order_by` function, which is used as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MongoDB 按创建时间顺序返回结果。为了控制这一点，有 `order_by` 函数，其用法如下：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you want only the first result from a query, use the `first` method. If
    your query returns nothing, and you expected it to, then use `first_or_404` to
    automatically abort with a `404` error. This acts in exactly the same way as its
    Flask-SQLAlchemy counterpart, and is provided by Flask-MongoEngine, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想从查询中获取第一个结果，请使用 `first` 方法。如果你的查询没有返回任何内容，而你预期它会返回，那么请使用 `first_or_404`
    以自动终止并返回 `404` 错误。这与其 Flask-SQLAlchemy 对应方法的行为完全相同，由 Flask-MongoEngine 提供，如下所示：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The same behavior is available for the `get` method, which expects that the
    query will only return one result and will raise an exception otherwise, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的行为也适用于 `get` 方法，它期望查询只返回一个结果，否则将引发异常，如下所示：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `paginate` method is also present and has the exact same API as its Flask-SQLAlchemy
    counterpart, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`paginate` 方法也存在，并且与 Flask-SQLAlchemy 的对应方法具有完全相同的 API，如下所示：'
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Also, if your document has a `ListField` method, then the `paginate_field` method
    on the document object can be used to paginate through the items of the list.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你的文档有一个 `ListField` 方法，那么文档对象的 `paginate_field` 方法可以用来分页遍历列表中的项。
- en: Filtering
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: 'If you know the exact value of the field you wish to filter by, then you can
    pass its value as a keyword to the `objects` method, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道要过滤的字段的精确值，则可以将该值作为关键字传递给 `objects` 方法，如下所示：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Unlike SQLAlchemy, we cannot pass truth tests to filter our results. Instead,
    special keyword arguments are used to test values. For example, to find all posts
    published after January 1 2015, enter the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQLAlchemy 不同，我们无法传递真值测试来过滤我们的结果。相反，使用特殊的关键字参数来测试值。例如，要查找所有在 2015 年 1 月 1
    日之后发布的帖子，请输入以下内容：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `__gt` appended to the end of the keyword is called an operator. MongoEngine
    supports the following operators:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到关键字末尾的`__gt`称为运算符。MongoEngine 支持以下运算符：
- en: '`ne`: Not equal to'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ne`: 不等于'
- en: '`lt`: Less than'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lt`: 小于'
- en: '`lte`: Less than or equal to'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lte`: 小于或等于'
- en: '`gt`: Greater than'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gt`: 大于'
- en: '`gte`: Greater than or equal to'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gte`: 大于或等于'
- en: '`not`: Negate an operator—for example, `publish_date__not__gt`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`: 取消运算符——例如，`publish_date__not__gt`'
- en: '`in`: Value is in the list'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`: 值在列表中'
- en: '`nin`: Value is not in the list'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nin`: 值不在列表中'
- en: '`mod`: Value % a == b—a and b are passed as (a, b)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod`: 值 % a == b——a 和 b 作为（a, b）传递'
- en: '`all`: Every item in the provided list of values is in the field'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`: 提供的值列表中的每个项目都在字段中'
- en: '`size`: The size of the list'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`: 列表的大小'
- en: '`exists`: Value for the field exists'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists`: 字段存在值'
- en: 'MongoEngine also provides the following operators to test string values:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: MongoEngine 还提供了以下运算符来测试字符串值：
- en: '`exact`: String equals the value'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exact`: 字符串等于值'
- en: '`iexact`: String equals the value (case-insensitive)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iexact`: 字符串等于值（不区分大小写）'
- en: '`contains`: String contains the value'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains`: 字符串包含值'
- en: '`icontains`: String contains the value (case-insensitive)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icontains`: 字符串包含值（不区分大小写）'
- en: '`startswith`: String starts with the value'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startswith`: 字符串以值开头'
- en: '`istartswith`: String starts with the value (case-insensitive)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istartswith`: 字符串以值开头（不区分大小写）'
- en: '`endswith`: String ends with the value'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endswith`: 字符串以值结尾'
- en: '`iendswith`: String ends with the value (case insensitive) `Update`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iendswith`: 字符串以值结尾（不区分大小写）`Update`'
- en: 'These operators can be combined to create the same powerful queries that were
    created in the previous sections. For example, to find all of the posts that were
    created after January 1 2015 don''t use the word `post` in the title. Instead,
    the body text should start with the word `Lorem` and should be ordered by the
    publish date, starting with the latest one. You can do this using the following
    code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符可以组合起来创建与前面章节中创建的相同强大的查询。例如，要查找所有在 2015 年 1 月 1 日之后创建的帖子，标题中不使用单词 `post`。相反，正文文本应以单词
    `Lorem` 开头，并按发布日期排序，从最新开始。你可以使用以下代码来完成此操作：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, if there is a complex query that cannot be represented by these tools,
    then a raw Mongo query can be passed as well, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果有一个复杂的查询无法用这些工具表示，则可以传递一个原始的 Mongo 查询，如下所示：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Update
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Update
- en: 'To update objects, the `update` method is called on the results of a query,
    as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新对象，请在查询结果上调用`update`方法，如下所示：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If your query should only return one value, then use `update_one` to only modify
    the first result, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的查询只应返回一个值，那么使用`update_one`只修改第一个结果，如下所示：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Unlike traditional SQL, there are many different ways to change a value in
    MongoDB. Operators are used to change the values of a field in the following different
    ways:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的 SQL 不同，在 MongoDB 中有许多不同的方式来更改一个值。运算符用于以下不同的方式来更改字段的值：
- en: '`set`: Sets a value (same as given earlier)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`: 设置一个值（与之前给出的相同）'
- en: '`unset`: Deletes a value and removes the key'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unset`: 删除一个值并移除键'
- en: '`inc`: Increments a value'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inc`: 增加一个值'
- en: '`dec`: Decrements a value'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dec`: 减少一个值'
- en: '`push`: Appends a value to a list'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`: 将一个值追加到列表中'
- en: '`push_all`: Appends several values to a list'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push_all`: 将多个值追加到列表中'
- en: '`pop`: Removes the first or last element of a list'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop`: 移除列表的第一个或最后一个元素'
- en: '`pull`: Removes a value from a list'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull`: 从列表中移除一个值'
- en: '`pull_all`: Removes several values from a list'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull_all`: 从列表中移除多个值'
- en: '`add_to_set`: Adds a value to a list only if it''s not in the list already'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_to_set`: 如果值不在列表中，则将其添加到列表中'
- en: 'For example, if a `Python` value needs to be added to a `ListField` named tags
    for all `Post` documents that have the `MongoEngine` tag, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果需要将一个 `Python` 值添加到名为 `tags` 的 `ListField` 中，对于所有带有 `MongoEngine` 标签的 `Post`
    文档，如下所示：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The same write concern parameters to save exist for updates, as shown in the
    following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与更新一样，相同的写入关注参数也存在，如下所示：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Delete
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Delete
- en: 'To delete a document instance, call its `delete` method as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个文档实例，调用其`delete`方法，如下所示：
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Relationships in NoSQL
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL 中的关系
- en: Just as we created relationships in SQLAlchemy, we can create relationships
    between objects in MongoEngine. Only with MongoEngine, we will be doing so without
    `JOIN` operators.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在SQLAlchemy中创建关系一样，我们可以在MongoEngine中创建对象之间的关系。只是在MongoEngine中，我们将不使用`JOIN`运算符。
- en: One-to-many relationships
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一对多关系
- en: 'There are two ways to create a one-to-many relationship in MongoEngine. The
    first method is to create a relationship between two documents by using `ReferenceField`
    to point to the ID of another object, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoEngine中创建一对一关系有两种方式。第一种方法是通过使用`ReferenceField`指向另一个对象的ID来在两个文档之间创建关系，如下所示：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Accessing the property of `ReferenceField` gives us direct access to the referenced
    object, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`ReferenceField`的属性为我们提供了直接访问引用对象的权限，如下所示：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Unlike SQLAlchemy, MongoEngine has no way to access objects that have relationships
    to other objects. With SQLAlchemy, a `db.relationship` variable could be declared,
    which allowed a user object to access all of the posts with a matching `user_id`
    column. No such variable exists in MongoEngine.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与SQLAlchemy不同，MongoEngine没有访问与其他对象有关联的对象的方法。在SQLAlchemy中，可以声明一个`db.relationship`变量，允许用户对象访问所有具有匹配`user_id`列的帖子。MongoEngine中没有这样的变量。
- en: 'A solution is to get the user ID for the posts you wish to search for and filter
    with the `user` field. This is the same thing that SQLAlchemy did behind the scenes,
    but we are doing it manually, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是获取您要搜索的帖子的用户ID，并使用`user`字段进行过滤。这与SQLAlchemy在幕后所做的是同一件事，但我们正在手动执行，如下所示：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The second way to create a one-to-many relationship is to use `EmbeddedDocumentField`
    with `EmbeddedDocument`, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一对一关系的第二种方式是使用`EmbeddedDocumentField`与`EmbeddedDocument`，如下所示：
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Accessing the `comments` property gives a list of all the embedded documents.
    To add a new comment to the post, treat it like a list and append `comment` documents
    to it, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`comments`属性会得到所有嵌入文档的列表。要向帖子添加新的评论，将其视为列表，并将`comment`文档追加到其中，如下所示：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that there was no call to a `save` method on the `comment` variable. This
    is because the comment document is not a real document; it is only an abstraction
    of `DictField`. Also, keep in mind that documents can only be up to 16 MB in size,
    so be careful how many `EmbeddedDocumentFields` are on each document and how many
    `EmbeddedDocuments` each one is holding.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有在`comment`变量上调用`save`方法。这是因为评论文档不是一个真正的文档；它只是`DictField`的一个抽象。此外，请注意，文档的大小只能达到16
    MB，因此请小心每个文档上的`EmbeddedDocumentFields`数量以及每个文档所包含的`EmbeddedDocuments`数量。
- en: Many-to-many relationships
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多对多关系
- en: 'The concept of a many-to-many relationship does not exist in document store
    databases. This is because with `ListFields`, they become completely irrelevant.
    To idiomatically create the tag feature for the `Post` object, add a list of strings
    as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系在文档存储数据库中不存在。这是因为使用`ListFields`后，它们变得完全无关。为了为`Post`对象创建标签功能，添加以下字符串列表：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, when we wish to query for all of the `Post` objects that have a specific
    tag or many tags, all we need is a simple query, as shown in the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们希望查询具有特定标签或多个标签的所有`Post`对象时，我们只需要一个简单的查询，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the list of roles on each user object, we use a list of references using
    the `ListField` of `ReferenceField(Role)`, as shown in the highlighted text in
    the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个用户对象的角色列表，我们使用`ReferenceField(Role)`的`ListField`来引用，如下面代码中高亮显示的文本所示：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Leveraging the power of NoSQL
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用NoSQL的力量
- en: 'To show the unique power of NoSQL, let''s add a feature that would be possible
    with SQLAlchemy, but which would be much more difficult: different post types,
    each with their own custom bodies. This will be much like the functionality of
    the popular blog platform Tumblr.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示NoSQL的独特优势，让我们添加一个在SQLAlchemy中可能实现但会困难得多的功能：不同的帖子类型，每个类型都有自己的自定义正文。这将会非常类似于流行的博客平台Tumblr的功能。
- en: 'To begin, allow your post type to act as a parent class and remove the text
    field from the `Post` class, as not all posts will have text on them. This is
    shown in the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，允许你的帖子类型充当父类，并从`Post`类中移除文本字段，因为并非所有帖子都有文本。这如下面的代码所示：
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Each post type will inherit from the `Post` class. Doing so will allow the
    code to treat any `Post` subclass as if it were a post. Our blogging app will
    have four types of post: a normal blog post, an image post, a video post, and
    a quote post. These are shown in the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每个帖子类型都将继承自`Post`类。这样做将允许代码将任何`Post`子类视为帖子。我们的博客应用将有四种帖子类型：一篇普通博客帖子、一篇图片帖子、一篇视频帖子和一篇引用帖子。这些在以下代码中展示：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Our post-creation page needs to be able to create each of these post types.
    The `PostForm` object in `forms.py`, which handles post creation, will need to
    be modified to handle the new fields first. We will add a selection field that
    determines the type of post, an `author` field for the quote type, an `image`
    field to hold a URL, and a `video` field that will hold the embedded HTML iframe.
    The `quote` and `blog` post content will both share the `text` field, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建帖子页面需要能够创建这些帖子类型中的每一个。处理帖子创建的`forms.py`中的`PostForm`对象需要修改以首先处理新字段。我们将添加一个选择字段以确定帖子类型，一个用于引用类型的`author`字段，一个用于存储URL的`image`字段，以及一个用于存储嵌入HTML
    iframe的`video`字段。`quote`和`blog`帖子内容都将共享`text`字段，如下所示：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `new_post` view function in the `blog/controllers.py` controller will also
    need to be updated to handle the new post types, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog/controllers.py`控制器中的`new_post`视图函数也需要更新以处理新的帖子类型，如下所示：'
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `new.html` file that renders our `form` object will need to display the
    new fields that are added to the form, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染我们的`form`对象的`new.html`文件需要显示添加到表单中的新字段，如下所示：
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that we have our new inputs, we can add some JavaScript to show and hide
    the fields based on the type of post, as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新的输入，我们可以添加一些JavaScript来根据帖子的类型显示和隐藏字段，如下所示：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, the `post.html` file needs to be able to display our post types correctly.
    We have the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`post.html`文件需要能够正确显示我们的帖子类型。我们有以下代码：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'All that is needed is to replace this with the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的只是将此替换为以下内容：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, the fundamental differences between NoSQL and traditional SQL
    systems were laid out. We explored the main types of NoSQL systems and why an
    application might need, or not need, to be designed with a NoSQL database. We
    addressed the CAP theorem and its implications regarding modern database systems.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了NoSQL和传统SQL系统之间的基本区别。我们探讨了NoSQL系统的主要类型以及为什么一个应用程序可能需要或不需要设计为使用NoSQL数据库。我们讨论了CAP定理及其对现代数据库系统的影响。
- en: Using our app's models as a base, the power of MongoDB and MongoEngine was shown
    by demonstrating how simple it was to set up complex relationships and inheritance.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的应用程序模型为基础，通过展示如何简单设置复杂的关系和继承，展示了MongoDB和MongoEngine的强大功能。
- en: In the next chapter, our blogging application will be extended with a feature
    designed for other programmers who wish to use our site to build their own service—that
    is, RESTful endpoints.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们的博客应用将通过一个为其他希望使用我们的网站构建自己服务的程序员设计的功能进行扩展——即RESTful端点。
