- en: Testing, Debugging, and Scheduling Concurrent Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试、调试和并发应用程序的调度
- en: In this chapter, we will discuss the process of using concurrent Python programs
    on a higher level. First, you will learn about scheduling Python programs to be
    run concurrently at a later time—either once, or periodically. We will analyze APScheduler,
    a Python library that allows us to do this on a cross-platform basis. Furthermore,
    we will go over testing and debugging, which are essential yet are often overlooked
    components of programming. Given the complexities of concurrent programming, testing
    and debugging are even more difficult than in traditional applications. This chapter
    will cover a number of strategies for the effective testing and debugging of concurrent
    programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在更高层次上使用并发Python程序的过程。首先，您将学习如何安排Python程序在以后同时运行，无论是一次还是定期。我们将分析APScheduler，这是一个允许我们在跨平台基础上做到这一点的Python库。此外，我们将讨论测试和调试，这是编程中必不可少但经常被忽视的组成部分。鉴于并发编程的复杂性，测试和调试甚至比传统应用程序更加困难。本章将涵盖一些有效测试和调试并发程序的策略。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The APScheduler library and its usage in concurrently scheduling Python applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APScheduler库及其在并发调度Python应用程序中的使用
- en: Different testing techniques for Python programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python程序的不同测试技术
- en: Debugging practices in Python programming, as well as concurrency-specific debugging
    techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python编程中的调试实践，以及并发特定的调试技术
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的先决条件如下：
- en: Ensure that you have Python 3 installed on your computer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的计算机上安装了Python 3
- en: Ensure that you have the `apscheduler` and `concurrencytest` libraries installed
    with your Python distribution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的Python发行版中安装了`apscheduler`和`concurrencytest`库
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)下载GitHub存储库
- en: During this chapter, we will be working with the subfolder named `Chapter19`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用名为`Chapter19`的子文件夹进行工作
- en: Check out the following video to see the Code in Action: [http://bit.ly/2OZdOZc](http://bit.ly/2OZdOZc)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2OZdOZc](http://bit.ly/2OZdOZc)
- en: Scheduling with APScheduler
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用APScheduler进行调度
- en: '**APScheduler** (short for **Advanced Python Scheduler**) is an external Python
    library that supports the scheduling of Python code to be executed later, either
    once or periodically. This library gives us high-level options to dynamically
    add/remove jobs to/from the job list so they can be scheduled and executed, as
    well as to decide how to distribute those jobs to different threads and processes.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**APScheduler**（**Advanced Python Scheduler**的缩写）是一个外部Python库，支持安排Python代码以便稍后执行，无论是一次还是定期。该库为我们提供了高级选项，以动态地向作业列表中添加/删除作业，以便安排和执行，以及决定如何将这些作业分配给不同的线程和进程。'
- en: 'Some might think of Celery ([http://www.celeryproject.org/](http://www.celeryproject.org/))
    as the go-to scheduling tool for Python. However, while Celery is a distributed
    task queue with basic scheduling capabilities, APScheduler is quite the opposite:
    a scheduler with basic task queuing options and advanced scheduling functionalities.
    Additionally, users of both tools have reported that APScheduler is easier to
    set up and implement.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会认为Celery（[http://www.celeryproject.org/](http://www.celeryproject.org/)）是Python的首选调度工具。然而，虽然Celery是一个具有基本调度功能的分布式任务队列，但APScheduler恰恰相反：它是一个具有基本任务排队选项和高级调度功能的调度程序。此外，两种工具的用户都报告说APScheduler更容易设置和实现。
- en: Installing APScheduler
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装APScheduler
- en: 'As with most common Python external libraries, APScheduler can be installed
    via the package manager, `pip`, by running the following command in your Terminal:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数常见的Python外部库一样，可以通过包管理器`pip`来安装APScheduler，只需在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another way to install this library, if the `pip` command does not work, is
    to manually download the source code from PyPI, which can be found at [pypi.org/project/APScheduler/](https://pypi.org/project/APScheduler/).
    The downloaded file can then be extracted and installed by running the following
    command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pip`命令不起作用，另一种安装此库的方法是从PyPI手动下载源代码，网址为[pypi.org/project/APScheduler/](https://pypi.org/project/APScheduler/)。然后可以通过运行以下命令来提取和安装下载的文件：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As always, to test whether your APScheduler distribution has been correctly
    installed, open a Python interpreter and try to import the library, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，要测试您的APScheduler发行版是否已正确安装，请打开Python解释器并尝试导入库，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If no errors are returned, it means that the library has been completely installed
    and is ready to be used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有返回错误，这意味着库已经完全安装并准备好使用。
- en: Not a scheduling service
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不是调度服务
- en: As the term scheduler can be quite misleading to specific groups of developers,
    let's clarify the functionalities that APScheduler provides, as well as what it
    does not provide. First and foremost, the library can be used as a cross-platform
    scheduler that is also application-specific, as opposed to more common schedulers
    that are platform-specific, such as the cron daemon (for Linux systems) or the
    Windows task scheduler.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于术语“调度程序”可能会对特定开发人员群体产生误导，让我们澄清APScheduler提供的功能，以及它不提供的功能。首先，该库可以用作跨平台调度程序，也可以是特定于应用程序的，而不是更常见的特定于平台的调度程序，比如cron守护程序（用于Linux系统）或Windows任务调度程序。
- en: It is important to note that APScheduler is not, in itself, a scheduling service
    that has a prebuilt GUI or command-line interface. It is still a Python library
    that has to be imported and utilized inside existing applications (that is why
    it is application-specific). However, as you will learn later on, APScheduler
    comes with numerous functionalities that can be leveraged to build an actual scheduling
    service.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，APScheduler本身并不是一个具有预构建GUI或命令行界面的调度服务。它仍然是一个必须在现有应用程序中导入和利用的Python库（这就是为什么它是特定于应用程序的）。然而，正如您将在后面了解到的，APScheduler具有许多功能，可以利用来构建实际的调度服务。
- en: For example, the ability to schedule jobs (specifically, background ones) is
    essential for web applications nowadays, as they can include different but important
    functionalities, such as sending emails or backing up and synchronizing data.
    In that context, APScheduler is arguably the most common tool to schedule tasks
    for cloud applications that involve Python instructions, such as Heroku and PythonAnywhere.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在对于Web应用程序来说，调度作业（特别是后台作业）的能力是至关重要的，因为它们可以包括不同但重要的功能，如发送电子邮件或备份和同步数据。在这种情况下，APScheduler可以说是调度云应用程序任务的最常见工具，这些任务涉及Python指令，如Heroku和PythonAnywhere。
- en: APScheduler functionalities
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: APScheduler功能
- en: 'Let''s explore some of the most common functionalities provided by the APScheduler
    library. Execution-wise, it offers three different scheduling mechanisms, so that
    one can choose the mechanism that is most suitable for one''s applications (these
    mechanisms are also sometimes called event triggers):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索APScheduler库提供的一些最常见功能。在执行方面，它提供了三种不同的调度机制，这样我们就可以选择最适合自己应用程序的机制（有时也称为事件触发器）：
- en: '**Cron-style scheduling**: This mechanism allows jobs to have prespecified
    start and end times'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cron风格调度**：此机制允许作业具有预定的开始和结束时间'
- en: '**Interval-based execution**: This mechanism runs jobs at even intervals (for
    example, every two minutes, every day), with optional start and end times'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于间隔的执行**：此机制以均匀的间隔运行作业（例如，每两分钟、每天），并可选择开始和结束时间'
- en: '**Delayed execution**: This mechanism allows the application to wait for a
    specific period of time before executing items in the job list'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟执行**：此机制允许应用程序在执行作业列表中的项目之前等待特定的时间段'
- en: Furthermore, APScheduler allows us to store jobs to be executed in various backend
    systems, such as regular memory, MongoDB, Redis, RethinkDB, SPLAlchemy, or ZooKeeper.
    Whether it is a desktop program, a web application, or simply a Python script,
    APScheduler is most likely to be able to work with how scheduled jobs are stored.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，APScheduler允许我们将要在各种后端系统中执行的作业存储在常规内存、MongoDB、Redis、RethinkDB、SPLAlchemy或ZooKeeper等系统中。无论是桌面程序、Web应用程序还是简单的Python脚本，APScheduler都很可能能够处理定时作业的存储方式。
- en: In addition to that, the library can also work seamlessly with common Python
    concurrency frameworks, such as AsyncIO, Gevent, Tornado, and Twisted. This means
    that the low-level code included in the APScheduler library contains instructions
    that can cohesively schedule and execute functions and programs implemented in
    these frameworks, making the library even more dynamic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，该库还可以与常见的Python并发框架（如AsyncIO、Gevent、Tornado和Twisted）无缝配合工作。这意味着APScheduler库中包含的低级代码包含了可以协调安排和执行这些框架中实现的函数和程序的指令，使得该库更加动态。
- en: Finally, APScheduler provides different options to actually execute the scheduled
    code, by specifying the appropriate executor(s). Specifically, one can simply
    execute jobs normally, in a blocking way or in the background. We also have the
    option to use a pool of threads or processes to distribute the work in a concurrent
    way. Later on, we will look at an example where we utilize a process pool to execute
    scheduled jobs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，APScheduler提供了不同的选项来实际执行计划代码，通过指定适当的执行器。具体来说，可以简单地以阻塞方式或后台方式执行作业。我们还可以选择使用线程或进程池以并发方式分发工作。稍后，我们将看一个示例，其中我们利用进程池来执行定时作业。
- en: 'The following diagram maps out all of the major classes and functionalities
    included in APScheduler:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了APScheduler中包含的所有主要类和功能：
- en: '![](assets/d409ecad-f11f-446f-831b-fbcbcc1cc188.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d409ecad-f11f-446f-831b-fbcbcc1cc188.png)'
- en: APScheduler—main classes and functionalities
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: APScheduler-主要类和功能
- en: APScheduler API
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: APScheduler API
- en: In this section, we will look at how to actually integrate APScheduler into
    existing Python programs, by analyzing the different classes and methods provided
    by the library. We will also look at how jobs are distributed across different
    threads and processes, when we utilize a concurrent executor to run our scheduled
    jobs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何将APScheduler实际集成到现有的Python程序中，分析库提供的不同类和方法。当我们利用并发执行器运行我们的定时作业时，我们还将看看作业如何分布在不同的线程和进程中。
- en: Scheduler classes
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器类
- en: 'First, let''s look at the options available for our main scheduler, which is
    the most important component in the process of scheduling tasks to be executed
    at a later time:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的主调度器可用的选项，这是安排任务在以后执行过程中最重要的组件：
- en: '`BlockingScheduler`: This class should be used when the scheduler is intended
    to be the only task running in the process. As the name suggests, an instance
    of this class will block any other instructions in the same process.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockingScheduler`：当调度程序打算是进程中唯一运行的任务时，应使用此类。顾名思义，此类的实例将阻止同一进程中的任何其他指令。'
- en: '`BackgroundScheduler`: As opposed to `BlockingScheduler`, this class allows
    scheduled jobs to be executed in the background, inside an existing application.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackgroundScheduler`：与`BlockingScheduler`相反，此类允许在现有应用程序内后台执行定时作业。'
- en: 'In addition, there are also scheduler classes to be used if your application
    utilizes specific concurrency frameworks: `AsyncIOScheduler` for the `asyncio`
    module; `GeventScheduler` for Gevent; `TornadoScheduler` for Tornado applications;
    `TwistedScheduler` for Twisted applications; and so on.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您的应用程序使用特定的并发框架，则还有调度器类可供使用：`AsyncIOScheduler`用于`asyncio`模块；`GeventScheduler`用于Gevent；`TornadoScheduler`用于Tornado应用程序；`TwistedScheduler`用于Twisted应用程序；等等。
- en: Executor classes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行器类
- en: 'Another important choice to be made during the process of scheduling jobs to
    be executed at a later time is: Which executor(s) should run the jobs? Generally,
    the default executor, `ThreadPoolExecutor`, which distributes the work across
    different threads in the same process, is recommended. However, as you have learned,
    if the scheduled jobs contain instructions that utilize CPU-intensive operations,
    then the workload should be distributed across multiple CPU cores, and `ProcessPoolExecutor`
    should be utilized.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在安排将来执行的作业的过程中，另一个重要的选择是：哪个执行器应该运行这些作业？通常建议使用默认执行器`ThreadPoolExecutor`，它在同一进程中的不同线程之间分配工作。然而，正如您所了解的，如果预定的作业包含利用CPU密集型操作的指令，则工作负载应该分布在多个CPU核心上，并且应该使用`ProcessPoolExecutor`。
- en: It is important to note that these two executor classes interact with the `concurrent.futures`
    module that we discussed in earlier chapters, in order to facilitate concurrent
    execution. The default number of maximum workers for both executor classes is
    `10`, and can be changed upon initialization.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这两个执行器类与我们在早期章节中讨论的`concurrent.futures`模块进行交互，以便实现并发执行。这两个执行器类的默认最大工作线程数为`10`，可以在初始化时进行更改。
- en: Trigger keywords
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发关键字
- en: 'The last decision in the process of building a scheduler is how scheduled jobs
    should be executed in the future; this is the event-trigger option we mentioned
    earlier. APScheduler provides three different triggering mechanisms; the following
    keywords should be passed as an argument to the scheduler initializer, in order
    to specify the event trigger type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建调度器的过程中的最后一个决定是如何在将来执行预定的作业；这是我们之前提到的事件触发选项。APScheduler提供了三种不同的触发机制；以下关键字应作为参数传递给调度器初始化程序，以指定事件触发类型：
- en: '`''date''`: This keyword is used when the job is to be run once, at a specific
    point in the future.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''日期''`: 当工作需要在将来的特定时间点运行一次时使用此关键字。'
- en: '`''interval''`: This is keyword is used when the job is to be run at fixed
    intervals of time. We will be using this keyword in our examples later on.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''间隔''`: 当工作需要定期以固定时间间隔运行时使用此关键字。我们稍后在示例中将使用此关键字。'
- en: '`''cron''`: This keyword is used when the job is to be periodically run at
    a certain time of day.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''cron''`: 当作业需要在一天的特定时间定期运行时使用此关键字。'
- en: Additionally, it is possible to mix and match multiple types of trigger. We
    also have the option to have scheduled jobs executed either when all registered
    triggers so specify, or when at least one of them does.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以混合和匹配多种类型的触发器。我们还可以选择在所有注册的触发器都指定时执行预定的作业，或者在至少一个触发器指定时执行。
- en: Common scheduler methods
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的调度器方法
- en: 'Finally, let''s consider the methods that are commonly used when declaring
    a scheduler, in addition to the preceding classes and keywords. Specifically,
    the following methods are called by `scheduler` objects:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑在声明调度器时常用的方法，以及前面提到的类和关键字。具体来说，以下方法由`scheduler`对象调用：
- en: '`add_executor()`: This method is called to register an executor to run jobs
    in the future. Specifically, we typically pass the string `''processpool''` to
    this method to have the jobs be distributed across multiple processes. Otherwise,
    as mentioned, as thread pool will be used a the default executor. This method
    also returns an executor object that can be manipulated further.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_executor()`: 调用此方法来注册一个执行器以在将来运行作业。通常，我们将字符串`''processpool''`传递给此方法，以便将作业分布在多个进程中。否则，如前所述，默认执行器将使用线程池。此方法还返回一个可以进一步操作的执行器对象。'
- en: '`remove_executor()`: This method is used on an executor object, to remove it
    from a scheduler.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_executor()`: 此方法用于在执行器对象上移除它。'
- en: '`add_job()`: This method can be used to add an additional job to the job list,
    to be executed later. The method first takes in a callable that is the new job
    in the job list, and various other arguments that are used to specify how the
    job should be scheduled and executed. Similar to `add_executor()`, this method
    can return a `job` object that can be manipulated outside the method.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_job()`: 此方法可用于将额外的作业添加到作业列表中，以便稍后执行。该方法首先接受一个可调用对象，该对象是作业列表中的新作业，以及用于指定作业应如何预定和执行的各种其他参数。与`add_executor()`类似，此方法可以返回一个可以在方法外部操作的`job`对象。'
- en: '`remove_job()`: Similarly, this method can be used on a `job` object, to remove
    it from a scheduler.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_job()`: 类似地，此方法可以用于`job`对象，以将其从调度器中移除。'
- en: '`start()`: This method starts scheduled jobs along with implemented executors,
    and begins to process the job list.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`: 此方法启动预定的作业以及已实现的执行器，并开始处理作业列表。'
- en: '`shutdown()`: This method stops the calling scheduler object, along with its
    job list and implemented executors. If it is called when there are current jobs
    running, those jobs will not be interrupted.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown()`: 此方法停止调用调度器对象，以及其作业列表和已实现的执行器。如果在当前有作业运行时调用它，这些作业将不会被中断。'
- en: Examples in Python
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python示例
- en: In this subsection, we will look at how some of the APIs that we discussed are
    used in sample Python programs. Download the code for this book from the GitHub
    page, then go ahead and navigate to the `Chapter19` folder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将看看我们讨论的一些API在示例Python程序中的使用方式。从GitHub页面下载本书的代码，然后转到`Chapter19`文件夹。
- en: Blocking scheduler
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞调度器
- en: 'First, let''s take a look at an example of a blocking scheduler in the `Chapter19/example1.py`
    file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个阻塞调度器的示例，在`Chapter19/example1.py`文件中：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we are implementing a scheduler for the `tick()` function specified
    in the preceding code, which simply prints out the current time at which it is
    executed. In our main function, we are using an instance from the `BlockingScheduler`
    class, imported from APScheduler, as our scheduler for this program. In addition
    to this, the aforementioned `add_job()` method is used to register `tick()` as
    a job to be executed later. Specifically, it should be executed periodically,
    at even intervals (specified by the `'interval'` string passed in)—particularly,
    every three seconds (specified by the argument `seconds=3`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在为前面代码中指定的`tick()`函数实现一个调度程序，该函数简单地打印出执行时的当前时间。在我们的主函数中，我们使用了从APScheduler导入的`BlockingScheduler`类的实例作为本程序的调度程序。除此之外，上述的`add_job()`方法被用来注册`tick()`作为稍后要执行的作业。具体来说，它应该定期执行，以均匀的间隔（由传入的`'interval'`字符串指定）——特别是每三秒钟（由参数`seconds=3`指定）。
- en: 'Recall that a blocking scheduler will block all other instructions in the same
    process that it runs in. To test this, we are also inserting a `print` statement,
    right after starting the scheduler, to see whether it will be executed. After
    running the script, your output should look similar to the following (except for
    the specific times that are being printed out):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，阻塞调度程序将阻止在其运行的同一进程中的所有其他指令。为了测试这一点，我们还在启动调度程序后插入了一个`print`语句，以查看它是否会被执行。运行脚本后，您的输出应该类似于以下内容（除了正在打印的具体时间）：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that this scheduler will run forever, unless it is stopped by a `KeyboardInterrupt`
    event or other potential exceptions, and the printing statement that we placed
    near the end of the main program will never be executed. For this reason, the
    `BlockingScheduler` class should only be used when it is intended to be the only
    task running in its process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该调度程序将永远运行，除非它被`KeyboardInterrupt`事件或其他潜在异常停止，并且我们放在主程序末尾附近的打印语句将永远不会被执行。因此，只有在打算在其进程中运行的唯一任务时，才应该使用`BlockingScheduler`类。
- en: Background scheduler
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后台调度程序
- en: 'In this example, we will look at whether the use of the `BackgroundScheduler`
    class would help if we wanted to execute our scheduler in the background, concurrent
    with other tasks. The code for this example is included in the `Chapter19/example2.py`
    file, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看看是否使用`BackgroundScheduler`类会有所帮助，如果我们想要在后台并发地执行我们的调度程序。此示例的代码包含在`Chapter19/example2.py`文件中，如下所示：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code in this example is almost identical to what we had previously. However,
    here, we are using the class for background schedulers, as well as printing out
    messages from the main program every two seconds, in an infinite `while` loop.
    Theoretically, if the `scheduler` object can indeed run the scheduled job in the
    background, our output will consist of a combination of print statements, in both
    the main program and the `tick()` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的代码几乎与我们之前的代码相同。然而，在这里，我们使用了后台调度程序的类，并且每两秒钟在一个无限的`while`循环中从主程序中打印出消息。理论上，如果`scheduler`对象确实可以在后台运行计划的作业，我们的输出将由主程序和`tick()`函数中的打印语句的组合组成。
- en: 'The following is my output, after executing the script:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本后，以下是我的输出：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Again, the scheduler will continue on forever, until an interruption from the
    keyboard is evoked. Here, we can see what we expected to see: print statements
    from the main program and the scheduled job are produced concurrently, indicating
    that the scheduler was indeed running in the background.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，调度程序将一直继续下去，直到从键盘中产生中断。在这里，我们可以看到我们期望看到的东西：主程序和计划的作业的打印语句同时产生，表明调度程序确实在后台运行。
- en: Executor pool
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行器池
- en: 'One additional functionality offered by APScheduler is the ability to distribute
    scheduled jobs to be executed across multiple CPU cores (or processes). In this
    example, you will learn how to do that with a background scheduler. Navigate to
    the `Chapter19/example3.py` file and inspect the included code, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: APScheduler提供的另一个功能是能够将计划的作业分发到多个CPU核心（或进程）上执行。在这个例子中，您将学习如何使用后台调度程序来实现这一点。转到`Chapter19/example3.py`文件并检查包含的代码，如下所示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this program, the job that we would like to schedule (the `task()` function)
    prints out the identifier of the process that is running it at each call (using
    the `os.getpid()` method) and is designed to last for around four seconds. In
    the main program, we are using the same background scheduler we used in the last
    example, but we are specifying that scheduled jobs should be executed in a pool
    of processes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们想要调度的作业（`task()`函数）在每次调用时打印出运行它的进程的标识符（使用`os.getpid()`方法），并且设计为持续约四秒钟。在主程序中，我们使用了上一个示例中使用的相同后台调度程序，但我们指定了计划的作业应该在一个进程池中执行：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Remember that the default value of the number of processes in this pool is
    10, and can be changed to a different value. Next, as we add the job to the scheduler,
    we also have to specify that this job can be executed in more than one process
    instance (in this case, three instances); this allows our process pool executor
    to be utilized fully and efficiently:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此进程池中进程数量的默认值为10，可以更改为不同的值。接下来，当我们将作业添加到调度程序时，我们还必须指定此作业可以在多个进程实例中执行（在本例中为三个实例）；这允许我们的进程池执行程序得到充分和高效地利用：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first few lines of my output, after running the program, are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，我的输出的前几行如下：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see from the printed process identifiers, the scheduled job was being
    executed in different processes. You will also notice that the ID of the first
    process was `1213`, and, as soon as our scheduler started to use the process with
    the ID of `1222`, it then switched back to the `1213` process (notice the last
    few lines of the preceding output). This is because our process pool contains
    10 workers, and the `1222` process was the last element of the pool.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从打印的进程标识中可以看出，计划任务是在不同的进程中执行的。您还会注意到第一个进程的ID是`1213`，而当我们的调度器开始使用ID为`1222`的进程时，它又切换回`1213`进程（请注意前面输出的最后几行）。这是因为我们的进程池包含10个工作进程，而`1222`进程是池的最后一个元素。
- en: Running on the cloud
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云上运行
- en: 'Earlier, we mentioned that cloud services that host Python code, such as Heroku
    and PythonAnywhere, are some of the most common places to apply APScheduler''s
    functionalities. In this subsection, we will look at one example from the user
    guide on the Heroku website, which can be found in the `Chapter19/example4.py`
    file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们提到了托管Python代码的云服务，如Heroku和PythonAnywhere，是应用APScheduler功能的最常见的地方之一。在本小节中，我们将看一下Heroku网站用户指南中的一个示例，该示例可以在`Chapter19/example4.py`文件中找到：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see that this program uses decorators to register scheduled jobs for
    the scheduler. Specifically, when the `scheduled_job()` method is called by a
    `scheduler` object, that whole instruction can be used as a decorator for a function,
    to convert it to a scheduler job for that scheduler. You can also see an example
    of a `cron` scheduled job in the preceding code, which can be executed at specific
    times of day (in this case, it is every weekday at 5:00 p.m.).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，该程序使用装饰器为调度器注册了计划任务。具体来说，当`scheduled_job()`方法由`scheduler`对象调用时，整个指令可以作为函数的装饰器，将其转换为该调度器的调度任务。您还可以在前面的代码中看到一个`cron`计划的作业的示例，它可以在一天中的特定时间执行（在这种情况下，是每个工作日下午5:00）。
- en: As a final note on APScheduler, we have seen that instructions utilizing the
    library API are also Python code, and not a separate service in itself. However,
    considering how flexible the library is in providing different scheduling options
    and how pluggable its programs are in terms of working with external services
    (such as cloud-based ones), APScheduler is a valuable tool for scheduling Python
    applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于APScheduler的一点说明，我们已经看到利用库API的指令也是Python代码，而不是一个独立的服务。然而，考虑到该库在提供不同的调度选项方面有多么灵活，以及在与外部服务（如基于云的服务）合作方面有多么可插拔，APScheduler是调度Python应用程序的有价值的工具。
- en: Testing and concurrency in Python
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的测试和并发
- en: As mentioned previously, testing is an essential (yet often overlooked) component
    of software development specifically, and programming in general. The goal of
    testing is to evoke errors that would indicate the existence of bugs in our programs.
    This is to be contrasted with the process of debugging, which is used to identify
    the bugs themselves; we will discuss the topic of debugging in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，测试是软件开发特别是编程中一个重要的（但经常被忽视的）组成部分。测试的目标是引发错误，这些错误会表明我们程序中存在bug。这与调试的过程相对，调试用于识别bug本身；我们将在下一节讨论调试的主题。
- en: In the most general sense, testing is about determining whether specific functions
    and methods can perform and produce results that we intend them to; this is typically
    done by comparing the results that are produced. In other words, testing is collecting
    evidence as to the correctness of our programs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在最一般的意义上，测试是关于确定特定的功能和方法是否能够执行并产生我们期望的结果；通常是通过比较产生的结果来完成的。换句话说，测试是收集关于程序正确性的证据。
- en: However, testing cannot ensure that all potential defects and bugs in the program
    under consideration will be identified. Additionally, the test results are only
    as good as the tests themselves, and if the tests do not cover some specific potential
    bugs, then those bugs will most likely not be detected during the testing process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试不能确保在考虑中的程序中所有潜在的缺陷和bug都会被识别出来。此外，测试结果只有测试本身那么好，如果测试没有涵盖一些特定的潜在bug，那么这些bug在测试过程中很可能不会被检测到。
- en: Testing concurrent programs
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试并发程序
- en: 'In this chapter, we will consider two distinct topics of testing, with regard
    to concurrency: **testing concurrent programs** and **testing programs concurrently**.
    When it comes to testing concurrent programs, the general consensus is that it
    is extremely demanding and difficult to get right. As you saw in previous chapters,
    bugs such as deadlocks or race conditions can be quite subtle in a concurrent
    program, and can manifest themselves in many ways.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑与并发相关的测试的两个不同主题：**测试并发程序**和**同时测试程序**。当涉及测试并发程序时，一般的共识是这是极其严格和难以正确完成的。正如您在前几章中看到的，诸如死锁或竞争条件之类的bug在并发程序中可能相当微妙，并且可能以多种方式表现出来。
- en: Furthermore, one distinct feature of concurrency is nondeterminism, which means
    that it is possible for a concurrency bug to be detected in one run of the test
    and become invisible in another. This is because a major component of concurrent
    programming is the scheduling of tasks, and, like the order in which different
    tasks are executed in a concurrent program, concurrency bugs can show and hide
    themselves in an unpredictable way. We call these tests non-reproducible, to indicate
    that we cannot reliably pass or fail a program with these tests in a consistent
    way.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，并发的一个显著特点是非确定性，这意味着并发bug可能在一个测试运行中被检测到，而在另一个测试运行中变得不可见。这是因为并发编程的一个重要组成部分是任务的调度，就像并发程序中执行不同任务的顺序一样，并发bug可能以不可预测的方式显示和隐藏自己。我们称这些测试为不可重现的，表示我们无法以一致的方式可靠地通过或失败这些测试来测试程序。
- en: With that said, there are some general strategies that can help us to navigate
    through the process of testing concurrent programs. In the following section,
    we will explore the various tools that can assist us with specific strategies
    for testing concurrent programs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些通用策略可以帮助我们在测试并发程序的过程中进行导航。在接下来的部分中，我们将探讨各种工具，这些工具可以帮助我们针对测试并发程序的特定策略进行辅助。
- en: Unit testing
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: The first strategy that we will consider is unit testing. The term indicates
    a method that tests for individual units of the program under consideration, where
    a unit is the smallest testable part of the program. For this reason, unit testing
    is not meant for testing a complete concurrent system. Specifically, it is recommended
    that you do not test a concurrent program as a whole, but that you break the program
    down into smaller components and test them separately.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的第一种策略是单元测试。该术语表示一种测试程序考虑的各个单元的方法，其中单元是程序的最小可测试部分。因此，单元测试不适用于测试完整的并发系统。具体来说，建议您不要将并发程序作为一个整体进行测试，而是将程序分解为较小的组件并分别测试它们。
- en: 'As usual, Python provides libraries that offer intuitive APIs to solve most
    common problems in programming; in this case, it is the `unittest` module. The
    module was originally inspired by the unit testing framework for the Java programming
    language JUnit; it also provides common unit testing functionalities in other
    languages. Let''s consider a quick example of how we can use `unittest` to test
    a Python function in the `Chapter19/example5.py` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Python提供了提供直观API来解决编程中最常见问题的库；在这种情况下，它是`unittest`模块。该模块最初受到了Java编程语言JUnit的单元测试框架的启发；它还提供了其他语言中常见的单元测试功能。让我们考虑一个快速示例，演示如何使用`unittest`来测试`Chapter19/example5.py`文件中的Python函数：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we would like to test the `fib()` function that generates specific
    elements in the Fibonacci sequence (where an element is the sum of its two previous
    elements), whose starting values are `0` and `1`, respectively.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想要测试`fib()`函数，该函数生成斐波那契数列中的特定元素（其中一个元素是其前两个元素的和），其起始值分别为`0`和`1`。
- en: Now, let's focus our attention on the `FibTest` class, which extends the `TestCase`
    class from the `unittest` module. This class contains different methods that test
    for specific cases of the results returned by the `fib()` function. Specifically,
    we have a method that looks at edge cases for this function, which are the first
    two elements of the sequence, and another method that tests for an arbitrary value
    in the sequence.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把注意力集中在`FibTest`类上，该类扩展了`unittest`模块中的`TestCase`类。这个类包含了测试`fib()`函数返回的特定结果的不同方法。具体来说，我们有一个方法来查看这个函数的边界情况，即序列的前两个元素，还有一个方法来测试序列中的任意值。
- en: 'After running the preceding script, your output should be similar to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述脚本之后，您的输出应该类似于以下内容：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output indicates that our tests passed without any errors. Additionally,
    as suggested by the class name, this class is an individual test case, which is
    a unit of testing. You can expand different test cases into a **test suite**,
    which is defined as a collection of test cases, test suites, or both. Test suites
    are generally used to combine tests that you would like to run together.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明我们的测试通过了，没有任何错误。另外，正如类名所示，这个类是一个单独的测试用例，是测试的一个单元。您可以将不同的测试用例扩展为**测试套件**，它被定义为测试用例、测试套件或两者的集合。测试套件通常用于组合您想要一起运行的测试。
- en: Static code analysis
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Another viable method to identify potential errors and bugs in your concurrent
    programs is to perform static code analysis. This method looks for patterns in
    the code itself, as opposed to executing some (or all) parts of the code. In other
    words, static code analysis inspects a program by visually looking at its structure,
    the use of variables and instructions, and how different parts of the program
    interact with each other.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 识别并发程序中潜在错误和漏洞的另一种可行方法是进行静态代码分析。这种方法寻找代码本身的模式，而不是执行代码的一部分（或全部）。换句话说，静态代码分析通过视觉检查程序的结构、变量和指令的使用以及程序的不同部分如何相互交互来检查程序。
- en: The main advantage of using static code analysis is that we are not relying
    on just the execution of our programs and the results produced during that process
    (in other words, dynamic testing) to determine whether the programs are correctly
    designed. This method can detect errors and bugs that do not manifest themselves
    (easily, or at all) in implemented tests. For this reason, static code analysis
    should be combined with other testing methods, such as unit testing, to create
    a comprehensive testing process.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态代码分析的主要优势在于，我们不仅依赖于程序的执行和在该过程中产生的结果（换句话说，动态测试）来确定程序是否设计正确。这种方法可以检测在实施测试中不会表现出来的错误和漏洞。因此，静态代码分析应该与其他测试方法结合使用，例如单元测试，以创建一个全面的测试过程。
- en: Static code analysis is often used to identify subtle errors or bugs, such as
    unused variables, empty catch blocks, or even unnecessary object creation. In
    terms of concurrent programming, the method can be used to analyze synchronization
    techniques used in a program. Specifically, static code analysis can look for
    the atomicity of shared resources in a program, then reveal any uncoordinated
    usage of non-atomic resources that could produce detrimental race conditions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析通常用于识别微妙的错误或漏洞，例如未使用的变量、空的catch块，甚至不必要的对象创建。在并发编程方面，该方法可用于分析程序中使用的同步技术。具体来说，静态代码分析可以查找程序中共享资源的原子性，然后揭示任何不协调使用非原子资源的情况，这可能会产生有害的竞争条件。
- en: Various tools are available to facilitate static code analysis for Python programs,
    with one of the more common ones being PMD ([https://github.com/pmd/pmd](https://github.com/pmd/pmd)).
    With that said, the specific use of these tools is beyond the scope of this book,
    and we will not go into them further.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序的静态代码分析有各种工具可用，其中一个比较常见的是PMD（[https://github.com/pmd/pmd](https://github.com/pmd/pmd)）。话虽如此，这些工具的具体使用超出了本书的范围，我们不会进一步讨论它们。
- en: Testing programs concurrently
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发测试程序。
- en: Another aspect of combining testing and concurrent programming is performing
    tests in a concurrent way. This aspect of testing is more straightforward and
    intuitive than testing concurrent programs themselves. In this subsection, we
    will explore a library that can help us facilitate this process, `concurrencytest`,
    which can work seamlessly with test cases implemented with the preceding `unittest`
    module.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结合测试和并发编程的另一个方面是以并发方式执行测试。这方面的测试比测试并发程序本身更直接和直观。在本小节中，我们将探索一个可以帮助我们简化这个过程的库`concurrencytest`，它可以与前面的`unittest`模块实现的测试用例无缝配合。
- en: '`concurrencytest` is designed as a `testtools` extension that implements concurrency
    in running test suites. It can be installed from PyPI, using `pip`, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrencytest`被设计为`testtools`的扩展，用于在运行测试套件时实现并发。可以通过PyPI使用`pip`安装它，如下所示：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Additionally, `concurrencytest` is dependent on the `testtools` ([pypi.org/project/testtools/](https://pypi.org/project/testtools/))
    and `python-subunit` ([pypi.org/project/python-subunit/](https://pypi.org/project/python-subunit/))
    libraries, which are a test extension framework and a streamlining protocol for
    test results, respectively. These libraries can also be installed via `pip`, as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`concurrencytest`依赖于`testtools`（[pypi.org/project/testtools/](https://pypi.org/project/testtools/)）和`python-subunit`（[pypi.org/project/python-subunit/](https://pypi.org/project/python-subunit/)）库，它们分别是测试扩展框架和测试结果的流程协议。这些库也可以通过`pip`安装，如下所示：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As always, to verify your installation, try to import the library in a Python
    interpreter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，要验证你的安装，尝试在Python解释器中导入库：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Receiving no printed errors means that the library and its dependencies were
    installed successfully. Now, let''s look at how this library can help us to achieve
    better speed for our tests. Navigate to the `Chapter19/example6.py` file and consider
    the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 没有打印错误意味着库及其依赖项已成功安装。现在，让我们看看这个库如何帮助我们提高测试速度。转到`Chapter19/example6.py`文件并考虑以下代码：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The main goal of the examples in this section is testing the function that produces
    numbers in the Fibonacci sequence, specifically numbers with large indices. The
    `fib()` function that we have is similar to that of the previous example, although
    this one performs the calculation iteratively, without using recursion.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例的主要目标是测试生成斐波那契数列中具有大索引的数字的函数。我们拥有的`fib()`函数与之前的示例类似，尽管这个函数是迭代执行计算的，而不是使用递归。
- en: In our test case, aside from the two starting values, we are now testing numbers
    at indices 499,990, 499,995, and 500,000\. Since the resulting numbers are significantly
    large, we are only testing the last ten digits for each number (this is done via
    the `mod` attribute of the test class, specified in the initialization method).
    This testing process will be executed in one process, in a sequential way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试用例中，除了两个起始值外，我们现在还在测试索引为499,990、499,995和500,000的数字。由于结果数字非常大，我们只测试每个数字的最后十位数（这是通过测试类的初始化方法中指定的`mod`属性完成的）。这个测试过程将在一个进程中以顺序方式执行。
- en: 'Run the program, and your output should be similar to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，你的输出应该类似于以下内容：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, the time specified in the output can vary from system to system. With
    that said, remember the amount of time that the program took, so that you can
    compare it with the speed of other programs that we will consider later on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，输出中指定的时间可能因系统而异。话虽如此，记住程序所花费的时间，以便与我们稍后考虑的其他程序的速度进行比较。
- en: 'Now, let''s look at how we can distribute the testing workload across multiple
    processes, with `concurrencytest`. Consider the `Chapter19/example7.py` file,
    as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`concurrencytest`在多个进程中分发测试工作负载。考虑以下`Chapter19/example7.py`文件：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This version of the program is examining the same `fib()` function, using the
    same test case. However, in the main program, we are initializing an instance
    of the `ConcurrentTestSuite` class, from the `concurrencytest` library. This instance
    takes in a test suite, which was created using the `TestLoader()` API from the
    `unittest` module, and the `fork_for_tests()` function, with the parameter `4`,
    to specify that we want to utilize four separate processes to distribute the testing
    procedure.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序版本正在检查相同的`fib()`函数，使用相同的测试用例。然而，在主程序中，我们正在初始化`concurrencytest`库的`ConcurrentTestSuite`类的一个实例。这个实例接受一个测试套件，该测试套件是使用`unittest`模块的`TestLoader()`API创建的，并使用`fork_for_tests()`函数，参数为`4`，以指定我们要利用四个独立进程来分发测试过程。
- en: 'Now, let''s run this program and compare its speed with that of our previous
    tests:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个程序，并将其速度与之前的测试进行比较：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see that a significant improvement in speed was achieved by this method
    of multiprocessing. However, this improvement does not fall around perfect scalability
    (discussed in [Chapter 16](132200fe-4caa-4848-9533-ce8c839af9af.xhtml), *Designing
    Lock-Based and Mutex-Free Concurrent Data Structures*); that is because there
    is significant overhead in creating concurrent test suites that can be executed
    across multiple processes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，通过这种多进程方法，速度有了显著的提高。然而，这种改进并不完全达到了完美的可扩展性（在[第16章](132200fe-4caa-4848-9533-ce8c839af9af.xhtml)中讨论过，*设计基于锁和无互斥的并发数据结构*）；这是因为创建可以在多个进程中执行的并发测试套件会产生相当大的开销。
- en: One more thing that we should mention is that it is quite possible to achieve
    the same multiprocessing setup that we implemented here by using the traditional
    concurrent programming tools that we discussed in previous chapters, such as `concurrent.futures`
    or `multiprocessing`. With that said, the `concurrencytest` library, as we have
    seen, is able to eliminate significant boilerplate code, and thus provides an
    easy and fast API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该提到的一点是，通过使用我们在前几章讨论过的传统并发编程工具，如`concurrent.futures`或`multiprocessing`，完全可以实现与我们在这里实现的相同的多进程设置。尽管如此，正如我们所看到的，`concurrencytest`库能够消除大量样板代码，因此提供了一个简单快速的API。
- en: Debugging concurrent programs
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试并发程序
- en: In this last section, we will discuss the various advanced debugging strategies
    that can be used individually, or in combination with each other, to detect and
    pinpoint bugs in our programs. In general, the term **debugging** is used to denote
    the process in which programmers attempt to identify and resolve problems or defects
    that would otherwise cause the computer applications they reside in to produce
    incorrect results, or even stop functioning.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将讨论各种高级调试策略，这些策略可以单独使用，也可以结合使用，以便检测和定位程序中的错误。
- en: The strategies that we will discuss include general debugging strategies, as
    well as particular techniques used in debugging concurrent applications. A systematic
    application of these strategies would improve your debugging process, in terms
    of both effectiveness and speed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的策略包括一般的调试策略，以及调试并发应用程序中使用的特定技术。系统地应用这些策略将提高调试过程的效率和速度。
- en: Debugging tools and techniques
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试工具和技术
- en: 'First, let''s briefly look at some of the most common techniques and tools
    that can facilitate the debugging process in Python:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们简要地看一下一些可以在Python中促进调试过程的常见技术和工具：
- en: '**Print debugging**: This is perhaps the most elementary and intuitive method
    of debugging. This method involves inserting print statements for the values of
    variables, or the states of functions, at various points in the execution of the
    considered program. Doing this allows us to keep track of how these values and
    states interact and change throughout the program, giving us insight into how
    particular errors or exceptions are raised.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印调试**：这可能是最基本和直观的调试方法。这种方法涉及在考虑的程序执行过程中的各个点插入打印语句，以输出变量的值或函数的状态。这样做可以让我们跟踪这些值和状态在程序中如何相互作用和改变，从而让我们了解特定错误或异常是如何引发的。'
- en: '**Logging**: In the field of computer science, logging is the process of recording
    various events that take place during the execution of a particular program. In
    essence, logging can be quite similar to print debugging; however, the former
    typically writes to a log file that can be viewed later on. Python offers excellent
    logging functionalities, included in the built-in `logging` module. Users can
    specify the level of importance for the logging process; for example, normally,
    one can log only important events and operations, but during debugging everything
    will be logged.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**：在计算机科学领域，日志记录是记录特定程序执行过程中发生的各种事件的过程。实质上，日志记录可能与打印调试非常相似；然而，前者通常会写入一个可以稍后查看的日志文件。Python提供了出色的日志记录功能，包含在内置的`logging`模块中。用户可以指定日志记录过程的重要性级别；例如，通常情况下，可以仅记录重要事件和操作，但在调试期间将记录所有内容。'
- en: '**Tracing**: This is another form of keeping track of program execution. Tracing
    follows the actual low-level details of the program execution, as opposed to only
    changes in variables and functions. Tracing functionalities can be implemented
    via the `sys.settrace()` method in Python.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：这是另一种跟踪程序执行的形式。跟踪遵循程序执行的实际低级细节，而不仅仅是变量和函数的变化。跟踪功能可以通过Python中的`sys.settrace()`方法实现。'
- en: '**Using a debugger**:Sometimes, the most powerful debugging options can be
    achieved via an automated debugger. The most popular debugger in the Python language
    is the Python debugger: `pdb`. This module provides an interactive debugging environment
    that implements useful functionalities, such as breakpoints, stepping through
    the source code, or inspecting the stack.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用调试器**：有时，最强大的调试选项可以通过自动调试器实现。Python语言中最流行的调试器是Python调试器：`pdb`。该模块提供了一个交互式调试环境，实现了诸如断点、逐步执行源代码或检查堆栈等有用功能。'
- en: Again, the preceding strategies are applicable to both traditional and concurrent
    programs, and a combination of more than one of them can help programmers to obtain
    valuable information during the debugging process.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，上述策略适用于传统程序和并发程序，结合其中的一个或多个策略可以帮助程序员在调试过程中获得有价值的信息。
- en: Debugging and concurrency
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和并发
- en: 'Similar to the problem of testing concurrent programs, debugging, when applied
    to concurrency, can become increasingly complex and difficult. Again, this is
    due to the fact that shared resources can interact with (and be altered by) multiple
    agents, simultaneously. With that said, there are still strategies that can make
    the process of debugging concurrent programs more straightforward. These include
    the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试并发程序的问题类似，调试并发时可能变得越来越复杂和困难。这是因为共享资源可以与（并且可以被）多个代理同时交互和改变。尽管如此，仍然有一些策略可以使调试并发程序的过程更加简单。这些策略包括以下内容：
- en: '**Minimization**:Concurrent applications are typically implemented in complex
    and interconnected systems. Debugging a whole system when an error occurs can
    be quite intimidating, and is not very feasible. The strategy is to isolate different
    parts of the system into individual, smaller programs, and identify the one that
    fails in the same way as for large systems. Here, we want to divide a large program
    into smaller and smaller parts, until they cannot be broken apart anymore. The
    original error can then be easily identified and efficiently fixed.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化**：并发应用通常在复杂和相互连接的系统中实现。当发生错误时，调试整个系统可能会令人望而生畏，并且并不可行。策略是将系统的不同部分隔离成单独的、较小的程序，并识别与大型系统相同方式失败的部分。在这里，我们希望将一个大型程序分割成越来越小的部分，直到它们无法再分割。然后可以轻松地识别原始错误并有效地修复。'
- en: '**Single-threading and processing**:This method is similar to minimization,
    but focuses on only one aspect of concurrent programming: the interaction between
    different threads/processes. By eliminating the biggest aspect of concurrency
    in your concurrent programming, you can isolate errors to either the program logic
    itself (which can cause errors, even when running sequentially) or the interaction
    between threads/processes (which can result from the common concurrency bugs that
    we discussed in previous chapters).'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单线程和处理**：这种方法类似于最小化，但专注于并发编程的一个方面：不同线程/进程之间的交互。通过消除并发编程中最大的方面，可以将错误隔离到程序逻辑本身（即使按顺序运行时也可能导致错误）或线程/进程之间的交互（这可能是由我们在前几章中讨论的常见并发错误导致的）。'
- en: '**Manipulating scheduling to amplify potential bugs**: We have actually seen
    the application of this method in previous chapters. Some concurrency bugs do
    not manifest themselves often, if the threads/processes implemented in our program
    are not scheduled to execute in a specific way. For example, an existing race
    condition may not affect a shared resource if the interactions between it and
    other agents happen so fast that they do not overlap each other often. This leads
    to the fact that testing might not reveal a race condition, even though it actually
    exists in the program.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操纵调度以放大潜在错误**：我们实际上在前几章中看到了这种方法的应用。如果我们程序中实现的线程/进程没有按特定方式调度执行，一些并发错误可能不经常显现。例如，如果共享资源与其他代理之间的交互发生得如此之快，以至于它们不经常重叠，那么现有的竞争条件可能不会影响共享资源。这导致测试可能不会揭示竞争条件，即使它实际上存在于程序中。'
- en: Various methods can be implemented in Python so that incorrect values and operations
    resulting from concurrency bugs can be amplified. Two of the most common are fuzzing,
    achieved by inserting sleep functions between commands in thread/process instructions,
    and minimizing the system thread switching interval, achieved by using the `sys.setcheckinterval()`
    method (discussed in [Chapter 17](0c8ecb2f-a8ac-4196-9d1e-8b729ef5b67c.xhtml),
    *Memory Models and Operations on Atomic Types*). These methods disrupt the regular
    scheduling protocols of thread and process execution in Python in different ways,
    and can effectively reveal hidden concurrency bugs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在Python中实现各种方法，以放大并发错误导致的不正确值和操作。其中最常见的两种是模糊化，通过在线程/进程指令中的命令之间插入休眠函数来实现，以及最小化系统线程切换间隔，通过使用`sys.setcheckinterval()`方法（在[第17章](0c8ecb2f-a8ac-4196-9d1e-8b729ef5b67c.xhtml)中讨论，*内存模型和原子类型上的操作*）。这些方法以不同的方式干扰Python中线程和进程执行的常规调度协议，并可以有效地揭示隐藏的并发错误。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we provided a high-level analysis of concurrent programs in
    Python, via scheduling, testing, and debugging. Scheduling can be done in Python
    via the APScheduler module, which provides powerful and flexible functionalities
    to specify how scheduled jobs should be executed later on in the future. Furthermore,
    the module allows scheduled jobs to be distributed and executed across different
    threads and processes, offering a concurrency improvement in testing speed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过调度、测试和调试对Python中的并发程序进行了高层次的分析。可以通过APScheduler模块在Python中进行调度，该模块提供了强大而灵活的功能，以指定将来如何执行预定作业。此外，该模块允许预定的作业在不同的线程和进程中分布和执行，提供了测试速度的并发改进。
- en: Concurrency also introduces complex problems in terms of testing and debugging,
    resulting from simultaneous and parallel interactions between the agents in a
    program. However, these problems can be approached effectively, with methodical
    solutions and the appropriate tools.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 并发还在测试和调试方面引入了复杂的问题，这是由程序中代理之间的同时和并行交互导致的。然而，这些问题可以通过有条理的解决方案和适当的工具有效地解决。
- en: This topic marks the end of our journey through *Mastering Concurrency in Python*.
    Throughout this book, we have considered and analyzed various elements of concurrent
    programming with the Python language in depth, such as threading, multiprocessing,
    and asynchronous programming. Powerful applications involving concurrency, such
    as context management, reduction operations, image processing, and network programming,
    were also discussed, in addition to the common problems faced by programmers working
    with concurrency in Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题标志着我们通过《Python并发编程大师》的旅程结束。在整本书中，我们深入考虑和分析了使用Python语言进行并发编程的各种元素，如线程、多进程和异步编程。此外，还讨论了涉及并发性的强大应用，如上下文管理、减少操作、图像处理和网络编程，以及在Python中处理并发性的程序员面临的常见问题。
- en: In the most general sense, this book serves as a guide to some of the more advanced
    concepts of concurrency; it is my hope that, through reading this book, you have
    had the chance to become well versed in the topic of concurrent programming.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从最一般的意义上讲，这本书是对并发的一些更高级概念的指南；我希望通过阅读这本书，你有机会对并发编程的主题有所了解。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is APScheduler? Why isn't it a scheduling service?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APScheduler是什么？为什么它不是一个调度服务？
- en: What are the main scheduling functionalities of APScheduler?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APScheduler的主要调度功能是什么？
- en: What are the differences between APScheduler and another scheduling tool in
    Python, Celery?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APScheduler与Python中另一个调度工具Celery之间有什么区别？
- en: What is the purpose of testing in programming? How is it different in concurrent
    programming?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程中测试的目的是什么？在并发编程中有何不同？
- en: What methods of testing were discussed in this chapter?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了哪些测试方法？
- en: What is the purpose of debugging in programming? How is it different in concurrent
    programming?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试在编程中的目的是什么？在并发编程中有何不同？
- en: What methods of debugging were discussed in this chapter?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了哪些调试方法？
- en: Further reading
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下链接：
- en: '*Advanced Python Scheduler* ([apscheduler.readthedocs.io/en/latest/index](https://apscheduler.readthedocs.io/en/latest/index.html))'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高级Python调度器* ([apscheduler.readthedocs.io/en/latest/index](https://apscheduler.readthedocs.io/en/latest/index.html))'
- en: '*Scheduled Jobs with Custom Clock Processes in Python with APScheduler* ([devcenter.heroku.com/articles/clock-processes-python](https://devcenter.heroku.com/articles/clock-processes-python))'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用APScheduler在Python中进行定时作业* ([devcenter.heroku.com/articles/clock-processes-python](https://devcenter.heroku.com/articles/clock-processes-python))'
- en: '*The Architecture of APScheduler*, Ju Lin ([enqueuezero.com/apscheduler](https://enqueuezero.com/apscheduler.html))'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*APScheduler的架构*，Ju Lin ([enqueuezero.com/apscheduler](https://enqueuezero.com/apscheduler.html))'
- en: ', Alex. *APScheduler 3.0 released*, Alex Grönholm ([alextechrants.blogspot.com/2014/08/apscheduler-30-released](http://alextechrants.blogspot.com/2014/08/apscheduler-30-released.html))'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ', Alex. *APScheduler 3.0发布*，Alex Grönholm ([alextechrants.blogspot.com/2014/08/apscheduler-30-released](http://alextechrants.blogspot.com/2014/08/apscheduler-30-released.html))'
- en: '*Testing Your Code* (*The Hitchhiker''s Guide to Python*), Kenneth Reitz'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试您的代码* (*Python之旅者指南*), Kenneth Reitz'
- en: '*Python – concurrencytest: Running Concurrent Tests*, Corey Goldberg ([coreygoldberg.blogspot.com/2013/06/python-concurrencytest-running](http://coreygoldberg.blogspot.com/2013/06/python-concurrencytest-running.html))'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python – concurrencytest: 运行并发测试*，Corey Goldberg ([coreygoldberg.blogspot.com/2013/06/python-concurrencytest-running](http://coreygoldberg.blogspot.com/2013/06/python-concurrencytest-running.html))'
- en: '*Getting Started With Testing in Python*, Anthony Shaw ([realpython.com/python-testing/](https://realpython.com/python-testing/))'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python测试入门*，Anthony Shaw ([realpython.com/python-testing/](https://realpython.com/python-testing/))'
- en: '*Tracing python code*, Andrew Dalke ([dalkescientific.com/writings/diary/archive/2005/04/20/tracing_python_code](http://www.dalkescientific.com/writings/diary/archive/2005/04/20/tracing_python_code.html))'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跟踪Python代码*，Andrew Dalke ([dalkescientific.com/writings/diary/archive/2005/04/20/tracing_python_code](http://www.dalkescientific.com/writings/diary/archive/2005/04/20/tracing_python_code.html))'
