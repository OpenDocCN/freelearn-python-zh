- en: Chapter 7. Form Mason – a Monkey of your own
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。表单梅森-你自己的猴子
- en: In our journey to learn Django, we have traveled far. We started from baby steps,
    learning to set up databases, basic views, and templates. We then moved on to
    more difficult stuff such as management commands and the Django shell. This is
    the last chapter in that journey, where we use all the knowledge that we have
    gained, and use it to create one of the most complicated applications yet. It's
    always fun to end things with a bang, and that's what we'll do here!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习Django的旅程中，我们走了很远的路。我们从小步开始，学习设置数据库、基本视图和模板。然后我们转向更困难的东西，比如管理命令和Django
    shell。这是我们旅程的最后一章，在这里我们将使用我们所学到的所有知识，并用它来创建迄今为止最复杂的应用程序之一。以一个轰轰烈烈的方式结束事情总是很有趣，这就是我们将在这里做的事情！
- en: You might have heard of SurveyMonkey ([www.surveymonkey.com](http://www.surveymonkey.com))
    or Wufoo ([www.wufoo.com](http://www.wufoo.com)). If not, these are web applications
    that allow you to create custom forms to gather data from audiences. You use the
    control panel available on these sites to set up a form, defining all the fields
    and how they should be validated, and configuring some basic stuff such as what
    the form should look like, what theme it should use, and so on. After configuring
    the form, you get a link to a web page that displays that form.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能听说过SurveyMonkey（[www.surveymonkey.com](http://www.surveymonkey.com)）或Wufoo（[www.wufoo.com](http://www.wufoo.com)）。如果没有，这些都是允许您创建自定义表单以从受众那里收集数据的网络应用程序。您可以使用这些网站上提供的控制面板设置表单，定义所有字段以及它们应该如何验证，并配置一些基本的东西，比如表单应该看起来像什么，应该使用什么主题等等。配置表单后，您将获得一个显示该表单的网页链接。
- en: You then send this link out to the intended audience and they fill it in, with
    their responses being saved. As part of your control panel, you also get a web
    page where you can view and filter these responses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将此链接发送给预期的受众，他们填写表格，他们的回答将被保存。作为您的控制面板的一部分，您还可以获得一个网页，您可以在其中查看和过滤这些回答。
- en: Services like these make it dead simple for even the least computer-savvy people
    to create online surveys and gather data for any purpose from a wide audience.
    This seems like a cool service that we will replicate in this chapter. It will
    also be the most complex application that we will have created, as it requires
    us to dive deep into Django and understand how Django forms work behind the scenes.
    In a sense, you will learn about the magic that makes Django tick. Exciting, isn't
    it!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务使得即使是最不懂计算机的人也能轻松创建在线调查，并从广泛的受众那里收集任何目的的数据。这似乎是一个很酷的服务，我们将在本章中复制它。这也将是我们创建的最复杂的应用程序，因为它要求我们深入了解Django，并了解Django表单在幕后是如何工作的。在某种意义上，您将了解使Django运行的魔法。令人兴奋，不是吗！
- en: Code pack
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码包
- en: This chapter does not have a code pack because almost all of the stuff that
    we are about to do here is new. Plus, we will do a lot of exploring in this chapter
    as well. This is both fun and shows you one of the many ways of approaching a
    tough project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有代码包，因为我们即将要做的几乎所有东西都是新的。此外，在本章中我们也将进行大量的探索。这既有趣，又向您展示了解决一个艰巨项目的许多方法之一。
- en: 'As there is no code pack to work from, you''ll need to start the project by
    yourself. First, as always, create a new virtual environment for the new project.
    Next, with the environment activated, install Django and run the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有代码包可供使用，您需要自己启动项目。首先，像往常一样，为新项目创建一个新的虚拟环境。接下来，在激活环境的情况下，安装Django并运行以下命令：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should create a `formmason` folder with our new Django project, ready
    for us to start working on. Use the `cd` command to get into this folder and create
    a new application that we''ll be using to hold our views, models, and so on:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有我们的新Django项目的`formmason`文件夹，准备让我们开始工作。使用`cd`命令进入此文件夹，并创建一个新的应用程序，我们将使用它来保存我们的视图、模型等等：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, add the `main` application to our list of `INSTALLED_APPS` in `formmason/settings.py`.
    Once that's done, we're ready to start!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`formmason/settings.py`中将`main`应用程序添加到我们的`INSTALLED_APPS`列表中。完成后，我们准备开始了！
- en: Looking at a Django form
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看Django表单
- en: 'As our aim is to allow users to create dynamic forms based on parameters stored
    in a database, a good place to start is to look at how a Django form works under
    the hood and what options we have to customize it. First, let''s create a basic
    form. Create a new `main/forms.py` file and add the following code to it:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是允许用户根据数据库中存储的参数创建动态表单，因此一个很好的起点是看看Django表单在幕后是如何工作的，以及我们有哪些选项可以自定义它。首先，让我们创建一个基本表单。创建一个新的`main/forms.py`文件，并将以下代码添加到其中：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a pretty basic form. However, it has a variety of form fields that
    we can look at. Let''s play around a bit in the shell, which you can start as
    follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的表单。但是，它有各种我们可以查看的表单字段。让我们在shell中玩一下，您可以按照以下方式启动：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I usually like to install another package called ipython. When you start the
    Django shell with ipython installed, you get an enhanced version of the basic
    shell with a lot of cool features such as autocomplete and a much better looking
    interface. I always install it in any Django project because I almost always use
    the shell at the start of the project to play around. I highly advise you to install
    it as well when you start a new Django project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常喜欢安装另一个叫做ipython的包。当您安装了ipython并启动Django shell时，您将获得增强版的基本shell，具有许多很酷的功能，如自动完成和更好看的界面。我总是在任何Django项目中安装它，因为我几乎总是在项目开始时使用shell来玩耍。我强烈建议您在开始新的Django项目时也安装它。
- en: 'Import our form in the shell as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中导入我们的表单，如下所示：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the same shell, type the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个shell中，输入以下内容：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first line of code simply created an instance of our form class. It's the
    second line where the fun begins. However, I'll first explain the `OrderedDict`
    data structure a bit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码只是创建了我们表单类的一个实例。第二行才是开始有趣的地方。不过，我先解释一下`OrderedDict`数据结构。
- en: As the name suggests, `OrderedDict` is a dictionary that maintains the order
    in which its elements were inserted. A normal dictionary in Python has no fixed
    order. If you insert three elements into a dictionary with keys `A`, `B`, and
    `C`, and then you ask for the keys back using the `keys()` method on the dictionary
    instance, the order in which you will get them back is not guaranteed, which is
    why normal built-in dictionaries are said to be unordered.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，`OrderedDict`是一个保持其元素插入顺序的字典。Python中的普通字典没有固定的顺序。如果你向一个字典插入三个元素，键为`A`，`B`和`C`，然后你使用字典实例的`keys()`方法要求返回键，你得到它们的顺序是不确定的，这就是为什么普通内置字典被称为无序的。
- en: In contrast, the keys in `OrderedDict`, which is from the `collections` library
    (part of the Python standard library), are guaranteed to be in the same order
    that you inserted them in. So if you were to iterate over the keys using either
    the `keys()` or `items()` method, you would always get them back in the same order
    that you inserted them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`OrderedDict`中的键是有序的，它来自`collections`库（Python标准库的一部分）。因此，如果你使用`keys()`或`items()`方法迭代键，你总是会按照插入的顺序得到它们。
- en: Getting back to the output, you will see that the dictionary printed has the
    same keys as the names of the fields that we used when we created our `SampleForm`
    class. The values of these keys are the `Field` subclasses (`CharField`, `IntegerField`,
    and so on) that we used in our form.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回到输出，你会发现打印的字典具有与我们创建`SampleForm`类时使用的字段名称相同的键。这些键的值是我们在表单中使用的`Field`子类（`CharField`，`IntegerField`等）。
- en: 'Let''s try something. In the shell, type the following and look at the output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下。在shell中，输入以下内容并查看输出：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It seems that the `name` attribute that we defined on our `SampleForm` class
    is no longer there. Weird, huh?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们在`SampleForm`类上定义的`name`属性不再存在了。奇怪，对吧？
- en: So far you have learned two facts about a Django form. The first, that the `fields`
    attribute on a form instance contains a mapping of field names to the `Field`
    classes. Second, that the field attributes we defined when creating our `SampleForm`
    class are not accessible on the instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了关于Django表单的两个事实。首先，表单实例的`fields`属性包含字段名称到`Field`类的映射。其次，在创建`SampleForm`类时定义的字段属性在实例上是不可访问的。
- en: Putting these two facts together gives us some indication of what Django does
    with the `SampleForm` class when creating an instance of it. It removes the field
    attributes and adds them to the `fields` dictionary. After a form instance is
    created, the only way to find out the fields that are defined on it is the `fields`
    dictionary attribute.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个事实结合起来，我们可以得出一些关于Django在创建`SampleForm`类的实例时的做法。它会删除字段属性并将它们添加到`fields`字典中。创建表单实例后，查找定义在其上的字段的唯一方法是使用`fields`字典属性。
- en: So, if we wanted to add another field to a form after the class has been defined
    and we could not change the code of the class itself, we could add an instance
    of a `Field` subclass to the `fields` attribute on the form instance. Let's try
    it out and see if this works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想在类定义后向表单添加另一个字段，而且无法更改类本身的代码，我们可以将`Field`子类的实例添加到表单实例的`fields`属性中。让我们试一试，看看这是否有效。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I lied a little when I said that Django removes the field attributes from a
    `SampleForm` class when creating an instance of it. In reality, the `SampleForm`
    class also has its field attributes removed. If you typed `SampleForm.name` in
    the shell, you would get a similar `AttributeError`. However, this information
    is not relevant to our current task, and the reason why this happens is complicated
    so I won't go into it in this book. If you want all the details, check out the
    source for the `django.forms.Form` class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说Django在创建`SampleForm`类的实例时会删除字段属性时，我有点撒谎。实际上，`SampleForm`类也删除了它的字段属性。如果你在shell中输入`SampleForm.name`，你会得到类似的`AttributeError`。然而，这些信息与我们当前的任务无关，而且发生这种情况的原因很复杂，所以我不会在本书中详细介绍。如果你想了解所有细节，请查看`django.forms.Form`类的源代码。
- en: Adding an extra field to a SampleForm instance
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向SampleForm实例添加额外字段
- en: 'We will now try an experiment. We will create an instance of our `SampleForm`
    with some valid test data, and then we will add another field to the `fields`
    attribute on our instance. We will then call the `is_valid()` method to see if
    our form instance considers the dynamically added field when validating the data
    provided earlier. Let''s see what happens. In the Django shell, enter the following
    commands:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将进行一个实验。我们将使用一些有效的测试数据创建`SampleForm`的实例，然后我们将在实例的`fields`属性上添加另一个字段。然后我们将调用`is_valid()`方法，看看我们的表单实例在验证先前提供的数据时是否考虑了动态添加的字段。让我们看看会发生什么。在Django
    shell中，输入以下命令：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Nice! It seems like our idea worked. Even though we added the `country` field
    after our `SampleForm` had been instantiated and provided the data, the form validation
    did consider our new field. As the `country` field was not part of the `test_data`
    dictionary and the field is required, the form validation failed and the `errors`
    list included the appropriate error.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！看起来我们的想法奏效了。尽管我们在`SampleForm`实例化并提供数据后添加了`country`字段，但表单验证确实考虑了我们的新字段。由于`country`字段不是`test_data`字典的一部分，并且该字段是必需的，表单验证失败，并且`errors`列表包含了适当的错误。
- en: Now that we have a technique to achieve our objective, let's create some views
    and templates to render a dynamic form.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种实现目标的技术，让我们创建一些视图和模板来呈现动态表单。
- en: Generating dynamic forms
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成动态表单
- en: Before we get to the code, we have to decide on a data format to specify the
    structure of our dynamic forms. **JSON** is one of the most popular, if not the
    most popular, data storage and exchange formats on the web right now. You will
    probably be aware of what JSON, is and how it works and what it looks like. However,
    if you're not, here's a quick introduction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们必须决定一个数据格式来指定我们动态表单的结构。**JSON**是当前网络上最受欢迎的，如果不是最受欢迎的数据存储和交换格式之一。你可能已经知道JSON是什么，它是如何工作的，以及它是什么样子。不过，如果你不知道，这里有一个快速介绍。
- en: 'JSON stands for JavaScript Object Notation. It uses the same format that JavaScript
    uses to declare objects. The biggest benefit for us Python guys is that it is
    almost exactly the same as the dictionary declaration syntax in Python. Let''s
    say that we want to store some details about a user. In JSON, here is what that
    information would look like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JSON代表JavaScript对象表示法。它使用与JavaScript用于声明对象相同的格式。对于我们Python程序员来说，最大的好处是它几乎与Python中的字典声明语法完全相同。假设我们想要存储有关用户的一些详细信息。在JSON中，这些信息看起来是这样的：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we can even copy and paste this into our Python code and it
    would be a valid dictionary definition, which makes it very easy for us to work
    with.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们甚至可以将其复制粘贴到我们的Python代码中，它将是一个有效的字典定义，这使得我们很容易使用。
- en: 'JSON has a number of benefits over other data storage/exchange formats:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JSON相对于其他数据存储/交换格式有许多优点：
- en: It's text only, so no need to have special tools built around it for the viewing
    and parsing.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只是文本，所以不需要专门的工具来查看和解析它。
- en: Parsing JSON is very easy, and most languages have a library for this. Python
    comes with a standard library to parse JSON.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析JSON非常容易，大多数语言都有用于此的库。Python自带了一个标准库来解析JSON。
- en: It's simple to write by hand.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个格式很容易手写。
- en: It can be stored in a number of ways without needing to do anything special.
    We will use this fact later on to store JSON in our database as a simple text
    field.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以以多种方式存储，而无需进行任何特殊处理。我们稍后将利用这一事实将JSON存储在我们的数据库中作为一个简单的文本字段。
- en: Now that you know a bit about JSON, let's see how to use it. We will store information
    about how to construct a dynamic form in JSON. We will then use the Python standard
    library `json` to convert the JSON string to a Python dictionary, which we will
    then iterate over and create our form.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些关于JSON的知识，让我们看看如何使用它。我们将存储有关如何构建动态表单的信息。然后我们将使用Python标准库`json`将JSON字符串转换为Python字典，然后我们将迭代并创建我们的表单。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this section, we will hardcode the JSON that we use in order to generate
    the form. Later on, we will allow our users to create and store the JSON themselves
    in a database from a control panel that we will make for them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将硬编码我们用来生成表单的JSON。稍后，我们将允许用户从我们为他们制作的控制面板中创建和存储JSON到数据库中。
- en: We will look at how to define the form fields in JSON and generate a dynamic
    form from this schema. We will also create an HTML form to render our form so
    we can test that everything works as expected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看如何在JSON中定义表单字段，并从此模式生成动态表单。我们还将创建一个HTML表单来渲染我们的表单，以便我们可以测试一切是否符合预期。
- en: 'Let''s look at the format for a simple form that can be used to collect basic
    demographic information about people:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个用于收集有关人们基本人口统计信息的简单表单的格式：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the sample JSON that we will use in this section to generate and display
    our dynamic form. This structure is a simple dictionary with strings for the values.
    We have to write code to parse this dictionary and create a Django form out of
    this information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本节中将使用的示例JSON，用于生成和显示我们的动态表单。这个结构是一个简单的带有字符串值的字典。我们必须编写代码来解析这个字典，并根据这些信息创建一个Django表单。
- en: Generating a form out of JSON
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从JSON生成表单
- en: The first thing that we will need to do is convert the JSON data that our view
    will get to a Python dictionary so that we can iterate over it. Python comes with
    the `json` module as part of the standard library that will handle the parsing
    for us. You can read the documentation for it at [https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html).
    It is dead simple to use, however, so let's just dive in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将我们的视图获取的JSON数据转换为Python字典，以便我们可以对其进行迭代。Python自带了`json`模块作为标准库的一部分，它将为我们处理解析。你可以在[https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html)阅读它的文档。不过，它非常简单易用，所以让我们直接开始吧。
- en: 'Open up `main/views.py` and add this code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`main/views.py`并添加以下代码：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are a couple of things to explain here. However, let''s first get the
    view working and see if it does what we want. Then I''ll explain what this code
    does. Next, let''s create the `main/templates/custom_form.html` template. You
    will need to create the `templates` folder under the `main/` folder first. Put
    this code in there:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情需要解释。不过，让我们先让视图工作起来，看看它是否符合我们的要求。然后我会解释这段代码的作用。接下来，让我们创建`main/templates/custom_form.html`模板。你需要先在`main/`文件夹下创建`templates`文件夹。将这段代码放在那里：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, put the following code in `formmason/urls.py` to include our new view:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`formmason/urls.py`中放入以下代码以包含我们的新视图：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That''s it for now. To test it out, run the development server using the `runserver`
    command and then open up `http://127.0.0.1:8000` in any browser. You should see
    a screen similar to this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。要测试它，使用`runserver`命令运行开发服务器，然后在任何浏览器中打开`http://127.0.0.1:8000`。你应该会看到一个类似这样的屏幕：
- en: '![Generating a form out of JSON](img/00698_07_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![从JSON生成表单](img/00698_07_01.jpg)'
- en: 'Try submitting an incomplete form and the page should be rendered with the
    correct error messages. Try to complete the form and submit it. Now you should
    see an error page, with the `ImproperlyConfigured: No URL to redirect to. Provide
    a success_url` error. This error comes from our use of the `FormView` generic
    view. When the form is valid, it expects `success_url` to be defined so that the
    user can be redirected to it. We don''t have anywhere to redirect the user to,
    so we will ignore this for now. Let''s take a look at the code and see what we
    have done here.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试提交一个不完整的表单，页面应该呈现出正确的错误消息。尝试完成表单并提交。现在你应该看到一个错误页面，显示`ImproperlyConfigured:
    No URL to redirect to. Provide a success_url`错误。这个错误来自我们使用的`FormView`通用视图。当表单有效时，它期望`success_url`被定义，以便用户可以被重定向到它。我们没有任何地方可以重定向用户，所以我们现在会忽略这个。让我们看看代码，看看我们在这里做了什么。'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This example also highlighted the power of generic views. By just redefining
    one function, `get_form`, we were able to use all the features of `FormView` with
    a form that is generated dynamically. As the Django generic views are made with
    modularity in mind, the rest of the view does not care how the form is created,
    just that the `get_form` method returns a valid form.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也突出了通用视图的强大之处。通过重新定义一个函数`get_form`，我们能够使用`FormView`的所有功能，而这个表单是动态生成的。由于Django通用视图是以模块化为目的设计的，视图的其余部分并不关心表单是如何创建的，只要`get_form`方法返回一个有效的表单。
- en: Most of the action happens in the `get_form` method of our `CustomFormView`,
    so let's start there. The first line of code defines the JSON data structure that
    we will use to generate our form. As I've mentioned before, this data will eventually
    be coming from a database backend; however, for testing purposes, we are hardcoding
    it for now. Next, we use the `json.loads` method to convert the JSON string to
    a Python object. This conversion process is pretty intuitive. The JSON string
    that we have is a dictionary with keys for `name`, `age`, `city`, `country`, and
    `time_lived_in_current_city`. The Python object that we get from `json.loads`
    is a dictionary as well, with the same key/value pairs. You can also have arrays
    in your JSON string and loading it would give you a Python list. JSON has support
    for nested objects, so you could have an array of dictionaries or a dictionary
    with an array for a value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CustomFormView`的`get_form`方法中发生了大部分操作，所以让我们从那里开始。代码的第一行定义了我们将用来生成表单的JSON数据结构。正如我之前提到的，这些数据最终将来自数据库后端；然而，出于测试目的，我们现在将其硬编码。接下来，我们使用`json.loads`方法将JSON字符串转换为Python对象。这个转换过程非常直观。我们拥有的JSON字符串是一个带有`name`、`age`、`city`、`country`和`time_lived_in_current_city`键的字典。我们从`json.loads`得到的Python对象也是一个带有相同键/值对的字典。你也可以在你的JSON字符串中有数组，并且加载它会给你一个Python列表。JSON支持嵌套对象，所以你可以有一个字典数组或一个值为数组的字典。
- en: Next, we create an instance of the base `django.forms.Form` class. As we saw
    in our experimentation before, we can take an instance of a Django form and add
    fields to it. Instead of creating an empty form class and using that, we just
    use the base `Form` class from Django directly. To the constructor of the form
    class, we pass whatever we receive from `self.get_form_kwargs()`. This method
    is part of the Django `FormView` class and depending on the request type creates
    the correct keyword arguments to be passed to a `Form` class. For instance, if
    the request was a POST/PUT request, `get_form_kwargs()` would return a dictionary
    that contains the `data` keyword argument so that we can use the form to validate
    and take further action on the data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了基础`django.forms.Form`类的一个实例。正如我们之前的实验中看到的，我们可以取一个Django表单的实例并向其添加字段。我们不是创建一个空的表单类并使用它，而是直接使用Django的基础`Form`类。对于表单类的构造函数，我们传递了`self.get_form_kwargs()`接收到的任何内容。这个方法是Django
    `FormView`类的一部分，根据请求类型创建正确的关键字参数传递给`Form`类。例如，如果请求是POST/PUT请求，`get_form_kwargs()`将返回一个包含`data`关键字参数的字典，以便我们可以使用表单来验证并对数据采取进一步的操作。
- en: 'The interesting bit happens next, when we loop over the items list of our custom
    fields data. The `items()` method on the data that we loaded from JSON returns
    a list as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来发生有趣的事情，当我们循环遍历我们自定义字段数据的项目列表时。我们从JSON加载的数据上使用`items()`方法返回一个列表，如下所示：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We loop over this list, assigning each of these item pairs to variables `key`
    and `value` in the `for` loop. We then pass the values to the `get_field_class_from_type`
    method, which decides which of the available form field classes to use for the
    type of data passed. The method's code is a simple `if/else`, which returns a
    field class or `None` if it was passed an invalid type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环遍历这个列表，将这些项目对分配给`for`循环中的变量`key`和`value`。然后我们将这些值传递给`get_field_class_from_type`方法，该方法决定使用哪个可用的表单字段类来处理传递的数据类型。该方法的代码是一个简单的`if/else`，如果传递了无效的类型，则返回一个字段类或`None`。
- en: We use the return value of this method, which is a class, and assign an instance
    of it to the form's `fields` attribute dictionary. *Note that we assign an instance
    of the field class and not the class itself*. The name of the field is the key
    from our JSON dictionary. We also do some basic error handling, raising `TypeError`
    if we cannot find a matching field class for the type we got in our JSON data
    dictionary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个方法的返回值，这是一个类，并将其实例分配给表单的`fields`属性字典。*请注意，我们分配的是字段类的实例，而不是类本身*。字段的名称是我们的JSON字典中的键。我们还进行了一些基本的错误处理，如果我们在JSON数据字典中找不到匹配的字段类，则引发`TypeError`。
- en: Finally, we return our customized form class. From there on, the Django `FormView`
    takes over and either renders the form, with errors if necessary, or redirects
    the user to the success URL if the form data submitted by the user was valid.
    As we didn't define any success URL, we get an error when we submit a valid form.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回我们定制的表单类。从那里开始，Django `FormView`接管并且要么呈现表单，如果需要的话带有错误，要么如果用户提交的表单数据有效，就重定向用户到成功的URL。因为我们没有定义任何成功的URL，所以当我们提交一个有效的表单时会出现错误。
- en: That's it. That is all the code that we need to create a dynamically generated
    form. We can add a couple of more features such as custom validation or advanced
    features such as supporting choice fields with a limited set of choices, but I'll
    leave that as an interesting project for you to try on your own.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这就是我们需要创建动态生成表单的所有代码。我们可以添加一些其他功能，比如自定义验证或支持具有有限选择集的选择字段的高级功能，但我会把这些作为一个有趣的项目留给你自己去尝试。
- en: Next, let's take a look at how we can store the JSON data that defines our custom
    form in a database. We'll create a model for it and allow the user to create multiple
    forms with different fields from an admin panel.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在数据库中存储定义我们自定义表单的JSON数据。我们将为其创建一个模型，并允许用户从管理面板创建具有不同字段的多个表单。
- en: A model for our JSON
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的JSON模型
- en: As I have mentioned earlier, one of the biggest benefits of using JSON as the
    definition format for our forms is that it uses just simple text data to encode
    the definition of complex objects. While some databases such as PostgreSQL have
    a column type for JSON, others do not. However, because we are dealing with simple
    text data, we don't need one! We can store our JSON data in a simple `TextField`
    and then encode and decode the data to and from a Python dictionary whenever required.
    In fact, there are many people in the Django community who have already dealt
    with this problem and open sourced their solutions for us to use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，使用JSON作为表单定义格式的最大好处之一是它只使用简单的文本数据来编码复杂对象的定义。虽然一些数据库，如PostgreSQL，有一个用于JSON的列类型，但其他数据库没有。然而，因为我们处理的是简单的文本数据，我们不需要一个！我们可以将我们的JSON数据存储在一个简单的`TextField`中，然后在需要时对数据进行编码和解码为Python字典。事实上，Django社区中有许多人已经处理过这个问题，并为我们开源了他们的解决方案供我们使用。
- en: One such package that I have used in the past is `django-jsonfield`. You can
    find it at [https://github.com/bradjasper/django-jsonfield](https://github.com/bradjasper/django-jsonfield),
    and we will be using it in our project. First, install the required package by
    typing the following command in your command line. Make sure to have the virtual
    environment activated first so that it is installed in the correct location.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我过去使用过的一个这样的包是`django-jsonfield`。你可以在[https://github.com/bradjasper/django-jsonfield](https://github.com/bradjasper/django-jsonfield)找到它，我们将在我们的项目中使用它。首先，在命令行中输入以下命令来安装所需的包。确保首先激活虚拟环境，以便它安装在正确的位置。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the package installed, we can create a model for our form. Open up `main/models.py`
    and change it to have the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这个包后，我们可以为我们的表单创建一个模型。打开`main/models.py`并将其更改为以下代码：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save the file and then create and run migrations so that Django creates the
    tables for our new model. In the command line, run the following commands:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后创建和运行迁移，以便Django为我们的新模型创建表。在命令行中运行以下命令：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the migrations done, let''s see how we can use this model. Instead of
    writing the code for the view, I like to start by doing a bit of experimentation
    in the Django shell. Open it up by typing as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移完成后，让我们看看如何使用这个模型。我喜欢从在Django shell中进行一些实验开始，而不是直接编写视图的代码。输入以下内容打开它：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then type in the following to test out our new model:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后输入以下内容来测试我们的新模型：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What we have done here should be pretty simple for you to understand by now.
    The important thing to note here is the value that we assigned to the `schema`
    field. Instead of using a string representation of the JSON data, we simply assigned
    a Python dictionary to it. The `JSONField` class we used as the field class in
    our model does the heavy lifting of converting from a Python dictionary to a JSON
    string when saving to the database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所做的对你来说应该很简单理解。这里要注意的重要事情是我们分配给`schema`字段的值。我们没有使用JSON数据的字符串表示，而是简单地分配了一个Python字典。我们在模型中使用的`JSONField`类在保存到数据库时会把Python字典转换为JSON字符串。
- en: The reverse is also the same. Notice how, in the last line of our shell session,
    we simply accessed the schema field directly and got a Python dictionary back
    instead of the string JSON data that is actually saved in the database. This makes
    working with JSON transparent to us.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 反之亦然。注意，在我们的shell会话的最后一行中，我们直接访问了模式字段，并得到了一个Python字典，而不是实际保存在数据库中的字符串JSON数据。这使得我们对JSON的处理对我们来说是透明的。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might be wondering why I am asking you to experiment in this chapter and
    play around in the shell, whereas in the previous chapters, I just showed you
    the relevant view/model/template code directly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我要求你在本章中进行实验并在shell中玩耍，而在之前的章节中，我直接向你展示了相关的视图/模型/模板代码。
- en: Like I mentioned at the start of this chapter, this chapter is about showing
    you how to arrive at a solution by yourself instead of me holding your hand and
    showing you the end result immediately.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在本章开头提到的，本章是关于向你展示如何自己找到解决方案，而不是我牵着你的手直接向你展示最终结果。
- en: All good Django developers that I know have a similar method of developing solutions
    for the projects that they work on. They experiment a bit, and in doing so figure
    out a solution to the problem they are working on. Everyone has a different way
    of experimenting though. Some people, like me, use the Django shell a lot. Others
    write test code in views and models. Others might create simple Django management
    commands to do the same. However, everyone goes through the same process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我认识的所有优秀的Django开发者都有一种类似的方法来为他们所工作的项目开发解决方案。他们会进行一些实验，并通过这样做找到解决问题的方法。不过，每个人的实验方式都不同。有些人，比如我，经常使用Django
    shell。其他人在视图和模型中编写测试代码。其他人可能创建简单的Django管理命令来做同样的事情。然而，每个人都经历了同样的过程。
- en: We find a problem that needs to be solved, we research it a bit, and then experiment
    with the various methods of solving it, finally choosing one which we like the
    best. You will eventually develop a method that you are comfortable with. In the
    meanwhile, I'll be walking you through my method and you can use this if you like.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现一个需要解决的问题，我们稍微研究一下，然后尝试各种解决方法，最后选择我们最喜欢的方法。您最终会开发出一种您感到舒适的方法。与此同时，我将带您了解我的方法，如果您喜欢，可以使用这个方法。
- en: 'We now have a `FormSchema` object in our database, so let''s create a view
    that can use this object to generate a form. In `main/views.py`, first import
    our new model near the top:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据库中有一个`FormSchema`对象，让我们创建一个视图，可以使用这个对象来生成一个表单。在`main/views.py`中，首先在顶部导入我们的新模型：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then change the `get_form` method in our `CustomFormView` to match this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将我们的`CustomFormView`中的`get_form`方法更改为匹配这个：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I have highlighted the new line. We have removed the hardcoded JSON string that
    we used and instead assigned the `schema` field's value from our database object
    to the `form_structure` variable. The rest of the code stays the same. Try opening
    the home page for the application again. You'll find that the frontend has stayed
    the same. The interactions will be the same as well. You can try to submit invalid
    or incomplete data and it will show you the errors as before. Trying to submit
    a valid form will still result in the error about success URL not being defined.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了新行。我们已经删除了我们使用的硬编码JSON字符串，并将数据库对象的`schema`字段的值分配给了`form_structure`变量。其余代码保持不变。尝试再次打开应用程序的主页。您会发现前端保持不变。交互也将保持不变。您可以尝试提交无效或不完整的数据，它将像以前一样显示错误。尝试提交有效的表单仍将导致有关未定义成功URL的错误。
- en: Next, let's create a better frontend for our users. We'll create a list view
    where the user can see a list of all forms available on the site and a form view
    that displays the actual form and handles the interactions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的用户创建一个更好的前端。我们将创建一个列表视图，用户可以在该视图中看到站点上所有可用表单的列表，以及一个表单视图，显示实际的表单并处理交互。
- en: Creating a better user interface
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更好的用户界面
- en: There isn't anything complicated about what we'll do here. It should be very
    easy for you to follow along, so I'll just give you the code to write and leave
    the explanation, as we have done all of this many times before in the previous
    chapters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里做的事情并不复杂。您应该很容易跟上，所以我将给您写代码并留下解释，因为我们在之前的章节中已经做过这些很多次了。
- en: 'Start by creating a `templates` directory in the project root. Next, add it
    to the list of `DIRS` in the `TEMPLATES` configuration variable in our `formmason/settings.py`
    file. The `settings.py` file already has a `TEMPLATES` variable configured, so
    go ahead and replace the `DIRS` list in this dictionary with the value that you
    see here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在项目根目录中创建一个`templates`目录。接下来，在我们的`formmason/settings.py`文件中的`TEMPLATES`配置变量的`DIRS`列表中添加它。`settings.py`文件已经配置了一个`TEMPLATES`变量，所以请继续用这里看到的值替换这个字典中的`DIRS`列表：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, create a `base.html` template in the new `templates` directory that you
    just created and put this code in there:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您刚刚创建的新的`templates`目录中创建一个`base.html`模板，并将以下代码放入其中：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify `main/templates/custom_form.html` to match this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`main/templates/custom_form.html`以匹配这个：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Change `main/views.py` to this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将`main/views.py`更改为以下内容：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a new home template at `main/templates/home.html` and give it the following
    code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main/templates/home.html`中创建一个新的主页模板，并给出以下代码：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, change `formmason/urls.py` to match this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`formmason/urls.py`更改为匹配这个：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once you have done all this, open up the home page for the application again
    at `http://127.0.0.1:8000`, and you should see a page similar to this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，再次打开应用程序的主页`http://127.0.0.1:8000`，您应该会看到一个类似于这样的页面：
- en: '![Creating a better user interface](img/00698_07_02.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![创建更好的用户界面](img/00698_07_02.jpg)'
- en: Clicking on the link for the form should take you to the same form page that
    we had before; the only difference is that now it is served at the URL, `http://127.0.0.1:8000/form/1/`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单击表单链接应该将您带到之前的相同表单页面；唯一的区别是现在它是在URL `http://127.0.0.1:8000/form/1/` 上提供的。
- en: 'Like I said, all this is pretty basic stuff that we have done repeatedly in
    the past few chapters. One thing that might be new is our use of `self.kwargs[''form_pk'']`
    in the `CustomFormView.get_form` method. Here''s the relevant line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我说的，所有这些都是我们在过去几章中反复做过的基本事情。可能新的一件事是我们在`CustomFormView.get_form`方法中使用了`self.kwargs['form_pk']`。以下是相关行：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For any generic view that Django provides (except for the base `View` class),
    `self.kwargs` is a dictionary of all named parameters that matched the URL pattern.
    If you look at our `formmason/urls.py` file, we defined the URL for our custom
    form page like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Django提供的任何通用视图（除了基本的`View`类），`self.kwargs`是与URL模式匹配的所有命名参数的字典。如果您查看我们的`formmason/urls.py`文件，我们定义了自定义表单页面的URL如下：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In our view, the `form_pk` parameter defined in the regex pattern for the URL
    is available in `self.kwargs`. Likewise, any non-keyword parameters in the URL
    pattern are available for use in `self.args`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的视图中，URL的正则表达式模式中定义的`form_pk`参数在`self.kwargs`中可用。同样，URL模式中的任何非关键字参数都可以在`self.args`中使用。
- en: Now that we have a useable user interface, we will move on to storing the form
    responses in our database and giving our customers a page to view these responses.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可用的用户界面，我们将继续将表单响应存储在我们的数据库中，并为我们的客户提供一个页面来查看这些响应。
- en: Saving the responses
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存响应
- en: 'We want to save the response of the user filling in one of our dynamic forms.
    As the data from a dynamic form will also be dynamic, we need to store an unknown
    number of fields and their values in our database. As we have already seen, JSON
    is a reasonable way to store such data. Let''s create a new model in `main/models.py`
    to store the responses:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保存用户填写我们动态表单之一的响应。由于动态表单的数据也是动态的，我们需要在数据库中存储未知数量的字段及其值。正如我们已经看到的，JSON是存储这种数据的合理方式。让我们在`main/models.py`中创建一个新模型来存储响应：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, create and run the migrations to add this new model to our database:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建并运行迁移以将这个新模型添加到我们的数据库中：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have our model, we need to save valid responses for our forms in
    this model. The `form_valid` method of `CustomFormView` is the correct place to
    add this logic. First, we need to import a few things from Django and our new
    model at the top of our `main/views.py` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的模型，我们需要将我们表单的有效响应保存到这个模型中。`CustomFormView`的`form_valid`方法是添加此逻辑的正确位置。首先，我们需要在`main/views.py`文件的顶部从Django和我们的新模型中导入一些东西：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, add a `form_valid` method with this code to the `CustomFormView` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`CustomFormView`类中添加一个`form_valid`方法，其中包含以下代码：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That''s it. Now try submitting the custom form that we created earlier and
    if the data was valid, you should be redirected to the home page after your response
    was saved. Right now, we have no way to see these responses in the frontend; however,
    we can use the Django shell to make sure that our data has been saved. Start the
    shell with the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在尝试提交我们之前创建的自定义表单，如果数据有效，您应该在响应保存后被重定向到主页。目前，我们无法在前端看到这些响应；但是，我们可以使用Django
    shell来确保我们的数据已经保存。使用以下命令启动shell：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then use the following lines of code to see the response that was saved:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下代码行来查看保存的响应：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You should see the data that you entered when saving the form. Now let's create
    a screen where our customers can see the responses for their custom forms.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当保存表单时，您应该看到输入的数据。现在让我们创建一个屏幕，让我们的客户可以看到他们定制表单的响应。
- en: Showing the responses
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示响应
- en: 'The code in this section is pretty simple and should not have any surprises
    for you. First, let''s create the view in `main/views.py`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码非常简单，对您来说应该没有任何意外。首先，在`main/views.py`中创建视图：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, create the `main/templates/form_responses.html` template:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`main/templates/form_responses.html`模板：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In `formmason/urls.py`, import our new view:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`formmason/urls.py`中，导入我们的新视图：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add this URL pattern to the `urlpatterns` list:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将此URL模式添加到`urlpatterns`列表中：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, edit `main/templates/home.html` to add a link to this new view:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编辑`main/templates/home.html`以添加到这个新视图的链接：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The new line of code is highlighted. After making all these changes, open the
    home page and you should see the **See Responses** links for the new view next
    to each of the existing form links:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码行已经突出显示。在进行所有这些更改后，打开主页，您应该看到现有表单链接旁边的**查看响应**链接，用于新视图：
- en: '![Showing the responses](img/00698_07_03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![显示响应](img/00698_07_03.jpg)'
- en: 'Clicking on the link should take you to a page as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 单击链接应该会带您到以下页面：
- en: '![Showing the responses](img/00698_07_04.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![显示响应](img/00698_07_04.jpg)'
- en: While it does get the job done, it is very crude. We can do better. Let's improve
    this.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可以完成工作，但它非常粗糙。我们可以做得更好。让我们改进一下。
- en: An improved responses list
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进的响应列表
- en: 'What we''d like is to show the responses in a tabular fashion with the field
    names as the header and response values for these fields underneath them. Let''s
    start out by modifying our view code. In `main/views.py`, first import `TemplateView`
    as we will no longer be using `ListView` as the base class for our `FormResponsesListView`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望以表格的形式显示响应，字段名称作为标题，字段的响应值显示在它们的下方。让我们首先修改我们的视图代码。在`main/views.py`中，首先导入`TemplateView`，因为我们将不再使用`ListView`作为`FormResponsesListView`的基类：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, modify `FormResponsesListView` to match the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`FormResponsesListView`以匹配以下代码：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The major changes here are in the `get_context_data` method. We also changed
    the base class to `TemplateView` from `ListView`. Let's look at what we are doing
    in the `get_context_data` method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要更改在`get_context_data`方法中。我们还将基类从`ListView`更改为`TemplateView`。让我们看看我们在`get_context_data`方法中做了什么。
- en: First, we use the `keys` method on the JSON form schema, which is saved in the
    `FormSchema` model, to create a list of field headers. We pass this to the template
    in the `headers` context variable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用JSON表单模式中的`keys`方法来创建字段标题的列表，该模式保存在`FormSchema`模型中。我们将这个列表传递给模板中的`headers`上下文变量。
- en: The slightly complicated part comes next. We loop over each of the `FormResponse`
    objects in our database. For each response object, we then loop over the form
    field names and get that attribute from the response data. We do this because,
    in the Django template, there is no way to get a value from a dictionary with
    a variable key name. We could create a custom template tag; however, that would
    add unnecessary complexity. Instead, we do the same thing in our view, where it
    is easier. For each response object, we create a list of values that is in the
    same order as the field headers. We then add this list of field values to our
    list of responses. The reason that our data is structured in this way becomes
    clear when we look at our template.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微复杂的部分接下来。我们循环遍历数据库中的每个`FormResponse`对象。对于每个响应对象，我们然后循环遍历表单字段名称，并从响应数据中获取该属性。我们这样做是因为在Django模板中，没有办法使用变量键名从字典中获取值。我们可以创建一个自定义模板标签；但是，那会增加不必要的复杂性。相反，我们在视图中做同样的事情，这样更容易。对于每个响应对象，我们创建一个与字段标题顺序相同的值列表。然后，我们将这个字段值列表添加到我们的响应列表中。当我们查看我们的模板时，我们的数据结构方式变得清晰。
- en: 'Finally, we assign the list of responses to the `object_list` template context
    variable and return the context. Next, let''s change the `main/templates/form_responses.html`
    template to match the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将响应列表分配给`object_list`模板上下文变量并返回上下文。接下来，让我们修改`main/templates/form_responses.html`模板以匹配以下内容：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you understood how our data was structured in the view, the template should
    be simple enough to follow. These are all the changes that we need to make for
    now.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您理解了我们在视图中的数据结构方式，那么模板应该很容易理解。这是我们现在需要做的所有更改。
- en: 'If you open the responses page again, you should now see a neatly aligned table,
    as shown in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次打开响应页面，您现在应该看到一个整齐排列的表格，如下截图所示：
- en: '![An improved responses list](img/00698_07_05.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![改进的响应列表](img/00698_07_05.jpg)'
- en: We have so far created a page to list the available forms, a page to submit
    data with a dynamic form, and a page to show those responses. Our application
    is nearly done. However, we are still missing a page that allows customers to
    create a custom form. Let's tackle this next.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个页面来列出可用的表单，一个页面来提交动态表单的数据，以及一个页面来显示这些响应。我们的应用程序几乎完成了。然而，我们仍然缺少一个页面，允许客户创建自定义表单。让我们接下来解决这个问题。
- en: Designing a form creation interface
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计表单创建界面
- en: We want to provide our users with a friendly interface to edit the structure
    of their dynamic forms. The ideal interface would be something that allows users
    to drag and drop their fields and set the properties for these fields using simple
    click and type operations on a web page. However, creating an interface like this
    is a major undertaking and a project on its own. It requires a team of frontend
    developers and designers to create something that user friendly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为用户提供一个友好的界面，以编辑他们动态表单的结构。理想的界面应该是允许用户在网页上进行拖放操作，并使用简单的点击和输入操作设置这些字段的属性。然而，创建这样的界面是一个重大的工作，需要一个前端开发人员和设计师团队来创建用户友好的界面。
- en: Unfortunately, we can't create something like that as an interface like that
    is more of a frontend project than something related to Django. However, if you
    want, it is a good exercise if you are looking to improve your frontend skills.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法创建这样的界面，因为这样的界面更多的是一个前端项目，而不是与Django相关的项目。然而，如果你愿意，这是一个很好的练习，如果你想提高你的前端技能。
- en: 'For this project, we will create a simple Django form where the user can manually
    enter the JSON to define the structure of their forms. We will provide basic validation
    and editing capabilities. So let''s start by creating our form. Change the `main/forms.py`
    file to match the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将创建一个简单的Django表单，用户可以手动输入JSON来定义他们的表单结构。我们将提供基本的验证和编辑功能。所以让我们从创建我们的表单开始。更改`main/forms.py`文件以匹配以下代码：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The form itself is pretty simple. However, we need to take a closer look at
    the `clean_schema` method. When the `is_valid()` method is called on a Django
    form, it goes through a couple of steps. The exact details can be found in the
    documentation at [https://docs.djangoproject.com/en/stable/ref/forms/validation/](https://docs.djangoproject.com/en/stable/ref/forms/validation/).
    However, a good approximation is that Django calls two different types of clean
    methods on the form class. First, it looks for methods named `clean_<fieldname>`
    for *each* field defined on the form. This method should return the cleaned value
    of the field that will then be stored in the `cleaned_data` dictionary of the
    form. Next, Django calls the `clean` method on the form class. This method is
    meant to clean data for fields that depend on each other as dependent cleaning
    should not be done in individual `clean_<fieldname>` methods. The `clean` method
    should return a dictionary that will replace the form's `cleaned_data` dictionary
    completely.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 表单本身非常简单。然而，我们需要仔细研究`clean_schema`方法。当在Django表单上调用`is_valid()`方法时，它经过了几个步骤。确切的细节可以在文档中找到[https://docs.djangoproject.com/en/stable/ref/forms/validation/]。然而，一个很好的近似值是Django在表单类上调用两种不同类型的清理方法。首先，它查找每个字段定义在表单上的`clean_<fieldname>`方法。这个方法应该返回字段的清理值，然后存储在表单的`cleaned_data`字典中。接下来，Django在表单类上调用`clean`方法。这个方法用于清理相互依赖的字段的数据，因为依赖的清理不应该在单独的`clean_<fieldname>`方法中完成。`clean`方法应该返回一个字典，它将完全替换表单的`cleaned_data`字典。
- en: Either type of clean methods can raise a `forms.ValidationError` exception if
    the data is not in the expected format. If `ValidationError` is raised in a `clean_<fieldname>`
    method, the error is tied to that field and displayed next to it when the form
    is rendered. If the error is raised in the general `clean` method, the error is
    displayed in the form error list that is displayed right before the form fields
    start in the HTML of the form.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一种清理方法都可以引发`forms.ValidationError`异常，如果数据不符合预期的格式。如果在`clean_<fieldname>`方法中引发`ValidationError`，则错误与该字段绑定，并在表单呈现时显示在其旁边。如果错误是在一般的`clean`方法中引发的，错误将显示在表单错误列表中，在表单字段在HTML中开始之前显示。
- en: As we wish to make sure that the data entered by the user in the schema field
    is valid JSON, we use `json.loads` on the user-entered data and raise an exception
    if the call fails. One important thing to note is that we return a modified version
    of the schema if our `clean_schema` call succeeds. This is because, in our model,
    we need to save a Python dictionary instead of a JSON string. Our `JSONField`
    model field handles the necessary conversion from a Python object to a JSON string
    when saving to the database.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望确保用户在模式字段中输入的数据是有效的JSON，我们在用户输入的数据上使用`json.loads`，如果调用失败则引发异常。一个重要的事情要注意的是，如果我们的`clean_schema`调用成功，我们将返回模式的修改版本。这是因为在我们的模型中，我们需要保存一个Python字典而不是一个JSON字符串。当保存到数据库时，我们的`JSONField`模型字段处理了从Python对象到JSON字符串的必要转换。
- en: 'Another side note is that the `clean_schema` method is not given any arguments.
    It must get the value for the schema field from the form''s `cleaned_data` dictionary.
    With our form created, let''s add a view to `main/views.py` to display this form.
    First, import our new form and the `json` library at the top:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的是`clean_schema`方法没有给出任何参数。它必须从表单的`cleaned_data`字典中获取模式字段的值。有了我们创建的表单，让我们在`main/views.py`中添加一个视图来显示这个表单。首先，在顶部导入我们的新表单和`json`库：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then add the following code to the view:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在视图中添加以下代码：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, create the `main/templates/create_edit_form.html` file and put this code
    in there:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`main/templates/create_edit_form.html`文件，并将以下代码放入其中：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, import this new view in our `formmason/urls.py` and add two patterns
    for it to the `urlpatterns` file. Here is the final `formmason/urls.py` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的`formmason/urls.py`中导入这个新视图，并为它添加两个模式到`urlpatterns`文件。这是最终的`formmason/urls.py`文件：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We are using the same view twice—once as a create view and once as an edit view.
    If you look at the code for the view, we provide the form with initial data from
    a `FormSchema` object if the `form_pk` keyword argument was matched from the URL.
    If it wasn't, we know that we are creating a new form and our initial data dictionary
    is empty. One thing to note is that in the initial data, we use `json.dumps(form.schema)`
    to provide the initial value for the schema field. This is the reverse of what
    we do in the `clean_schema` method of our form. That's because `form.schema` is
    a Python object; however, our frontend needs to show the JSON for the structure.
    So we convert from a Python object to a JSON string using the `json.dumps` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们两次使用相同的视图——一次作为创建视图，一次作为编辑视图。如果你看一下视图的代码，我们会根据URL中的`form_pk`关键字参数是否匹配来为表单提供来自`FormSchema`对象的初始数据。如果没有匹配，我们知道我们正在创建一个新表单，我们的初始数据字典是空的。需要注意的一点是，在初始数据中，我们使用`json.dumps(form.schema)`来为模式字段提供初始值。这与我们在表单的`clean_schema`方法中所做的相反。这是因为`form.schema`是一个Python对象；然而，我们的前端需要显示结构的JSON。因此，我们使用`json.dumps`方法将Python对象转换为JSON字符串。
- en: We handle both the cases—new form creation and form editing—in the `form_valid`
    method of our view. On successfully saving or creating our form, we redirect the
    user to the home page again.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在视图的`form_valid`方法中处理两种情况——新表单创建和表单编辑。成功保存或创建我们的表单后，我们将用户重定向到主页。
- en: 'The last thing we need to do is add links to our base template and home page
    to create and edit forms. First, add this link right after the link for **Home**
    in `templates/base.html`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是在我们的基本模板和主页上添加链接来创建和编辑表单。首先，在`templates/base.html`中的**Home**链接后添加此链接：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In `main/templates/home.html`, add this after the link for **See Respo** **nses**:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main/templates/home.html`中，在**查看响应**链接后添加这个：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'That''s it. Let''s test it out. Open the home page at `http://127.0.0.1:8000/`
    first and you should see something similar to the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。让我们来测试一下。首先打开主页`http://127.0.0.1:8000/`，你应该看到类似下面截图的内容：
- en: '![Designing a form creation interface](img/00698_07_06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![设计表单创建界面](img/00698_07_06.jpg)'
- en: 'Click on the **Edit Form** button and you should see the following page:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**编辑表单**按钮，你应该看到下面的页面：
- en: '![Designing a form creation interface](img/00698_07_07.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![设计表单创建界面](img/00698_07_07.jpg)'
- en: 'Let''s change the title to something new and then type this in the **Schema**
    field:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将标题更改为新的内容，然后在**模式**字段中输入这个：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Click on the **Create New Form** link. This should save the form and take you
    back to the home page. The title of your form on the home page should be changed
    to whatever you edited it to. Click on the link to see the form, and you should
    see a screen similar to this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**创建新表单**链接。这应该保存表单并将您带回主页。主页上的表单标题应该更改为您编辑的内容。点击链接查看表单，你应该看到类似这样的屏幕：
- en: '![Designing a form creation interface](img/00698_07_08.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![设计表单创建界面](img/00698_07_08.jpg)'
- en: 'Nice! Our form has changed to match the schema that we entered while editing
    the form. Let''s take a look at what our responses page looks like. Submit some
    test data with the new form schema and open up the responses page. You should
    see something like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的表单已经更改以匹配我们在编辑表单时输入的模式。让我们看看我们的响应页面是什么样子的。使用新的表单模式提交一些测试数据，然后打开响应页面。你应该看到类似这样的内容：
- en: '![Designing a form creation interface](img/00698_07_09.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![设计表单创建界面](img/00698_07_09.jpg)'
- en: This page works as expected, without having to change any of the code. You'll
    see that the previous responses are no longer visible; however, there seems to
    be some empty cells above the latest response. We'll look into fixing this and
    other small issues next. However, our application is complete except for a few
    small fixes that we need to do.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面按预期工作，无需更改任何代码。你会发现以前的响应不再可见；然而，在最新的响应上方似乎有一些空单元格。我们将在接下来解决这个问题和其他一些小问题。然而，我们的应用程序除了需要做一些小修复外已经完成了。
- en: You should use the **Create New Form** link at the top of the pages as well
    to create a new form and test it out. It should work as expected.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该在页面顶部使用**创建新表单**链接来创建一个新表单并进行测试。它应该按预期工作。
- en: Small fixes
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小修复
- en: 'I noticed three small errors while working on this last section that I''d like
    to fix. First of all, if you take a closer look at the form submission page (where
    the user can enter data in a custom form), you''ll notice that the heading on
    the top says **Custom Form**. This is from our first test, when our form schema
    was defined in a hardcoded JSON string and didn''t have a title. As our form model
    now has a title field, edit `main/templates/custom_form.html` and change the `h1`
    tag to match the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我在最后一节工作时注意到了三个小错误，我想要修复。首先，如果你仔细看表单提交页面（用户可以在自定义表单中输入数据的页面），你会注意到顶部的标题是**自定义表单**。这是我们的第一个测试，当我们的表单模式是在硬编码的JSON字符串中定义的，并且没有标题。由于我们的表单模型现在有一个标题字段，编辑`main/templates/custom_form.html`并更改`h1`标签以匹配以下内容：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, edit `CustomFormView` in `main/views.py` and add the `this get_context_data`
    method to the class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`main/views.py`中编辑`CustomFormView`并将`this get_context_data`方法添加到类中：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Look at the form detail page again. This time, the heading should reflect the
    form title, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看表单详细页面。这次，标题应该反映表单标题，如下面的截图所示：
- en: '![Small fixes](img/00698_07_10.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![小修复](img/00698_07_10.jpg)'
- en: 'The next error that I noticed was on the form editing page. Right now, whether
    you are creating a new form or editing an existing one, the heading always says
    `Create/Edit Form` and the **Submit** button always says **Create New Form**.
    Let''s modify our `main/templates/create_edit_form.html` template to tell the
    user explicitly what action they are taking. Here is the final code for the template:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我注意到的下一个错误是在表单编辑页面上。现在，无论你是创建新表单还是编辑现有表单，标题总是说`创建/编辑表单`，**提交**按钮总是说**创建新表单**。让我们修改我们的`main/templates/create_edit_form.html`模板，明确告诉用户他们正在执行什么操作。以下是模板的最终代码：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now if you edit an existing form or create a new one, the heading and button
    should match that action:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你编辑一个现有表单或创建一个新表单，标题和按钮应该与该操作匹配：
- en: '![Small fixes](img/00698_07_11.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![小修复](img/00698_07_11.jpg)'
- en: 'The last issue I saw was on the responses page. If you edit a form that already
    has responses and the new form has none of the fields that the old form had, you
    will see some empty table rows at the start. That''s because even though our view
    code doesn''t include any data for those rows, it still includes an empty row.
    Let''s fix this by modifying the `get_context_data` method of `FormResponsesListView`
    in `main/views.py`. Look for this piece of code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到的最后一个问题是在响应页面上。如果你编辑一个已经有响应的表单，并且新表单没有旧表单的任何字段，你会看到一些空的表格行。这是因为即使我们的视图代码不包括这些行的任何数据，它仍然包括一个空行。让我们通过修改`main/views.py`中`FormResponsesListView`的`get_context_data`方法来解决这个问题。找到这段代码：
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Change it to the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The last two lines, the highlighted ones, are the changes. The `any` function
    is a built-in Python method that returns `True` if any of the values in the given
    list evaluates to `True`. If our `responses_list` contains all empty strings,
    which is the case if our new form structure has no fields that overlap with the
    old form structure, the `if` condition will fail and we will not include a completely
    empty row in our responses list. Try looking at the responses list page again
    and you should see that the empty rows have now disappeared:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行，被标记的那些，是更改。`any`函数是一个内置的Python方法，如果给定列表中的任何值求值为`True`，则返回`True`。如果我们的`responses_list`包含所有空字符串，也就是说，如果我们的新表单结构没有与旧表单结构重叠的字段，`if`条件将失败，我们将不会在我们的响应列表中包含一个完全空的行。再次查看响应列表页面，你会发现空行现在已经消失了：
- en: '![Small fixes](img/00698_07_12.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![小修复](img/00698_07_12.jpg)'
- en: That's it. Our last, and most ambitious, application is complete. Congratulations!
    You have come a long way from the simple blog that we created at the start of
    this book. You should now be ready to tackle any web application project that
    comes your way.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们最后一个，也是最雄心勃勃的应用程序已经完成。恭喜！你已经从我们在本书开头创建的简单博客中走了很长的路。现在你应该准备好应对任何网页应用项目了。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was more about exploration than new concepts. The only major new
    concept that you learned was about the inner workings of Django forms, and this
    section took up fewer than five pages. The rest of the chapter was about finding
    solutions to problems that we encountered along the way.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更多的是关于探索而不是新概念。你学到的唯一重要的新概念是关于Django表单的内部工作原理，而这一部分不到五页。本章的其余部分是关于找到我们在路上遇到的问题的解决方案。
- en: As I said at the start of this chapter, this was the most complicated application
    that we have created in the book. It is also likely to be one of the more complicated
    applications you will create at the start of your career. It is by no means a
    polished product; that's more because we didn't do any frontend work, rather than
    some lack of features in the Django backend.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头所说的，这是我们在书中创建的最复杂的应用程序。这也很可能是你在职业生涯初期创建的更复杂的应用程序之一。这并不是一个完美的产品；这更多是因为我们没有做任何前端工作，而不是Django后端功能的缺失。
- en: While the knowledge we gained about Django forms in this chapter will prove
    invaluable to you, I would like the main takeaway from it to be the approach to
    solving problems. We found a problem we needed to solve, we experimented in the
    Django shell, and we found a solution. Sometimes it's a bit more complicated than
    that. You probably need to search the Internet for existing solutions or ask your
    colleagues. However, after finding answers that seem to be relevant to your problem,
    you will always have to go back to the experimentation and make sure that the
    solution really does solve your problem.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本章对Django表单的了解将对你非常有价值，但我希望你从中主要学到的是解决问题的方法。我们发现了一个需要解决的问题，我们在Django shell中进行了实验，然后找到了解决方案。有时候情况会比这更复杂。你可能需要搜索互联网上的现有解决方案或向同事求助。然而，在找到似乎与你的问题相关的答案之后，你总是需要回到实验中，确保解决方案确实解决了你的问题。
- en: The way I showed you how to play around in the Django shell is just one of the
    many ways that you can choose to experiment with different solutions. As I've
    mentioned before, everyone has their own technique. Some use management commands,
    some use simple Python scripts, and some write test code in the views. In the
    end, you will come up with a way that you like the best.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我向你展示的在Django shell中玩耍的方式只是你可以选择尝试不同解决方案的众多方式之一。正如我之前提到的，每个人都有自己的技巧。有些人使用管理命令，有些人使用简单的Python脚本，有些人在视图中编写测试代码。最终，你会找到自己最喜欢的方式。
- en: Another thing that I hope you take away from this chapter is the use of external
    libraries to help solve our problems. When we needed a way to store JSON in our
    database, we used the `jsonfield` library that was available as open source instead
    of rolling our own custom solution. This has benefits and drawbacks. The benefits
    are that if you find a package, such as `jsonfield` that is widely used, you will
    get a solution that has been tested by many before you. Due to that testing, the
    library will be much more stable than what you, or any person, can come up with
    on your own. The drawback of using something external is that you have no control
    over the direction the project takes and in some projects, you'll have to painstakingly
    go over the code for the external library to make sure that it meets any regulations
    your project might have about external code usage.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你从本章中带走的另一件事是使用外部库来帮助解决我们的问题。当我们需要一种方法来在数据库中存储JSON时，我们使用了`jsonfield`库，这是作为开源软件可用的，而不是自己定制的解决方案。这有利有弊。好处是，如果你找到一个广泛使用的包，比如`jsonfield`，你将得到一个经过许多人测试的解决方案。由于经过测试，该库将比你或任何人自己想出的东西稳定得多。使用外部内容的缺点是你无法控制项目的发展方向，在某些项目中，你将不得不仔细检查外部库的代码，以确保它符合项目可能对外部代码使用的任何规定。
- en: However, personally, I prefer to use a tried and tested third-party library
    every time over creating something by myself. For me, the pros usually outweigh
    the cons.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就我个人而言，我更喜欢每次都使用经过验证的第三方库，而不是自己创建东西。对我来说，优点通常大于缺点。
- en: That's it! This was the final chapter in this epic journey that we started with
    a simple blog! We have come a long way from where we started; however, I'm sure
    that your journey as a Django web developer is just starting. You have many more
    exciting things to look forward to, and I wish you the best of luck in this journey.
    I hope you enjoyed reading this book as much as I enjoyed writing it. Bon voyage!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！这是我们从一个简单的博客开始的史诗般旅程的最后一章！我们已经走了很长的路；然而，我相信你作为一名Django网络开发者的旅程才刚刚开始。你还有许多令人期待的事情，我祝你在这个旅程中一切顺利。希望你和我写作时一样享受阅读这本书。一路顺风！
