- en: Chapter 3 – Modularity
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三章 - 模块化
- en: Modularity is an important property for anything but trivial software systems
    as it gives us the power to make self-contained, reusable pieces which can be
    combined in new ways to solve different problems. In Python, as with most programming
    languages, the most fine-grained modularization facility is the definition of
    reusable functions. But Python also gives us several other powerful modularization
    mechanisms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化对于除了微不足道的软件系统以外的任何东西都是一个重要的属性，因为它赋予我们能力去创建自包含、可重复使用的部分，这些部分可以以新的方式组合来解决不同的问题。在Python中，与大多数编程语言一样，最细粒度的模块化设施是可重复使用函数的定义。但是Python还给了我们几种其他强大的模块化机制。
- en: Collections of related functions are themselves grouped together a form modularity
    called *modules*. Modules are source code files ^([3](chap21.xhtml#fn-modules-as-files))
    that can be referenced by other modules, allowing the functions defined in one
    module to be re-used in another. So long as you take care to avoid any circular
    dependencies, modules are a simple and flexible way to organize programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 相关函数的集合本身被组合在一起形成了一种称为*模块*的模块化形式。模块是可以被其他模块引用的源代码文件，允许在一个模块中定义的函数在另一个模块中被重用。只要你小心避免任何循环依赖，模块是组织程序的一种简单灵活的方式。
- en: In previous chapters we’ve seen that we can import modules into the REPL. We’ll
    also show you how modules can be executed directly as programs or scripts. As
    part of this we’ll investigate the Python execution model, to ensure that you
    have a good understanding of exactly *when* code is evaluated and executed. We’ll
    round off this chapter by showing you how to use command-line arguments to get
    basic configuration data into your program and make your program executable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经看到我们可以将模块导入REPL。我们还将向您展示模块如何直接作为程序或脚本执行。作为这一部分的一部分，我们将调查Python执行模型，以确保您对代码何时被评估和执行有一个很好的理解。我们将通过向您展示如何使用命令行参数将基本配置数据传递到您的程序中并使您的程序可执行来结束本章。
- en: To illustrate this chapter, we’ll start with the code snippet for retrieving
    words from a web-hosted text document that we developed at the end of the previous
    chapter. We’ll elaborate on that code by organizing it into a fully-fledged Python
    module.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明本章，我们将从上一章末尾开发的从网络托管的文本文档中检索单词的代码片段开始。我们将通过将代码组织成一个完整的Python模块来详细说明该代码。
- en: Organizing code in a .py file
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在一个.py文件中组织代码
- en: Let’s start with the snippet we worked with in Chapter 2\. Open a text editor
    – preferably one with syntax highlighting support for Python – and configure it
    to insert four spaces per indent level when you press the tab key. You should
    also check that your editor saves the file using the UTF 8 encoding as that’s
    what the Python 3 runtime expects by default.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第二章中我们使用的代码片段开始。打开一个文本编辑器 - 最好是一个支持Python语法高亮的编辑器 - 并配置它在按下tab键时插入四个空格的缩进级别。你还应该检查你的编辑器是否使用UTF
    8编码保存文件，因为这是Python 3运行时的默认设置。
- en: Create a directory called `pyfund` in your home directory. This is where we’ll
    put the code for the chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的主目录下创建一个名为`pyfund`的目录。这是我们将放置本章代码的地方。
- en: 'All Python source files use the `.py` extension, so let’s get the snippet we
    wrote at the REPL at end of the previous module into a text file called `pyfund/words.py`.
    The file’s contents should looks like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Python源文件都使用`.py`扩展名，所以让我们把我们在REPL中写的片段放到一个名为`pyfund/words.py`的文本文件中。文件的内容应该是这样的：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’ll notice some minor differences between the code above and what we wrote
    previously at the REPL. Now that we’re using a text file for our code we can pay
    a little more attention to readability, so, for example, we’ve put a blank line
    after the `import` statement.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到上面的代码和我们之前在REPL中写的代码之间有一些细微的差异。现在我们正在使用一个文本文件来编写我们的代码，所以我们可以更加注意可读性，例如，在`import`语句后我们加了一个空行。
- en: Save this file before moving on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前保存这个文件。
- en: Running Python programs from the operating system shell
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从操作系统shell运行Python程序
- en: 'Switch to a console with your operating system’s shell prompt and change to
    the new `pyfund` directory:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到带有操作系统shell提示符的控制台，并切换到新的`pyfund`目录：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can execute our module by calling Python and passing the module’s filename:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用Python并传递模块的文件名来执行我们的模块：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'on Mac or Linux, or:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac或Linux上，或者：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: on Windows.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上。
- en: When you press return, after a short delay you’ll be returned to the system
    prompt. Not very impressive, but if you got no response then the program is running
    as expected. If, on the other hand, you saw some error out, then something it
    wrong. An `HTTPError`, for example, indicates there’s a network problem, whilst
    other types of errors probably mean you have mistyped the code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下回车键后，经过短暂的延迟，你将返回到系统提示符。并不是很令人印象深刻，但如果你没有得到任何响应，那么程序正在按预期运行。另一方面，如果你看到一些错误，那么就有问题了。例如，`HTTPError`表示有网络问题，而其他类型的错误可能意味着你输入了错误的代码。
- en: 'Let’s add another for-loop to the end of the program to print out one word
    per line. Add this code to the end of your Python file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在程序的末尾再添加一个for循环，每行打印一个单词。将这段代码添加到你的Python文件的末尾：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you go to your command prompt and execute the code again, you should see
    some output. Now we have the beginnings of a useful program!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去命令提示符并再次执行代码，你应该会看到一些输出。现在我们有了一个有用程序的开端！
- en: Importing modules into the REPL
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将模块导入到REPL中
- en: 'Our module can also be imported into the REPL. Let’s try that and see what
    happens. Start the REPL and import your module. When importing a module, you use
    `import <module-name>`, omitting the `.py` extension from the module name. In
    our case, it looks something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模块也可以导入到REPL中。让我们试试看会发生什么。启动REPL并导入你的模块。当导入一个模块时，你使用`import <module-name>`，省略模块名称的`.py`扩展名。在我们的情况下，看起来是这样的：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code in your module is executed immediately when imported! That’s maybe
    not what you expected, and it’s certainly not very useful. To give us more control
    over when our code is executed, and to allow it to be reused, we’ll need to put
    our code in a function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入模块时，模块中的代码会立即执行！这也许不是你期望的，而且肯定不是很有用。为了更好地控制代码的执行时间，并允许其被重用，我们需要将代码放入一个函数中。
- en: Defining functions
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'Functions are defined using the `def` keyword followed by the function name,
    an argument list in parentheses, and a colon to start a new block. Let’s quickly
    define a few functions at the REPL to get the idea:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`def`关键字定义函数，后面跟着函数名、括号中的参数列表和一个冒号来开始一个新的块。让我们在REPL中快速定义一些函数来了解一下：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the `return` keyword to return a value from the function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`return`关键字从函数中返回一个值。
- en: 'As we’ve seen previously, we call functions by providing the actual arguments
    in parentheses after the function name:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，我们通过在函数名后的括号中提供实际参数来调用函数：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Functions aren’t required to explicitly return a value though — perhaps they
    produce side effects:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 函数并不需要显式返回一个值 - 也许它们会产生副作用：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can return early from a function by using the `return` keyword with no
    parameter:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`return`关键字而不带参数来提前从函数中返回：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you don’t have an explicit `return` in your function, Python will implicitly
    add one at the end if your function. This implicit return, or a `return` without
    a parameter, actually causes the function to return `None`. Remember, though,
    that the REPL doesn’t display `None` results, so we don’t see them. By capturing
    the returned object into a named variable we can test for `None`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数中没有显式的`return`，Python会在函数末尾隐式添加一个`return`。这个隐式的返回，或者没有参数的`return`，实际上会导致函数返回`None`。不过要记住，REPL不会显示`None`结果，所以我们看不到它们。通过将返回的对象捕获到一个命名变量中，我们可以测试是否为`None`：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Organizing our module into functions
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将我们的模块组织成函数
- en: Let’s organize our words module using functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用函数来组织我们的words模块。
- en: 'First we’ll move all the code except the import statement into a function called
    `fetch_words()`. You do that by adding the `def` statement and indenting the code
    below it by one extra level:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将除了导入语句之外的所有代码移动到一个名为`fetch_words()`的函数中。您可以通过添加`def`语句并将其下面的代码缩进一级来实现这一点：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Save the module, and reload the module using a fresh Python REPL:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 保存模块，并使用新的Python REPL重新加载模块：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The module imports, but the words are not fetched until we call the `fetch_words()`
    function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 模块已导入，但直到我们调用`fetch_words()`函数时，单词才会被获取：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively we can import our specific function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以导入我们的特定函数：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So far so good, but what happens when we try to run our module directly from
    the operating system shell?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切都很好，但当我们尝试直接从操作系统shell运行我们的模块时会发生什么？
- en: 'Exit from the REPL with `Ctrl-D` from Mac or Linux or `Ctrl-Z` for Windows,
    and run Python 3 passing the module filename:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从Mac或Linux使用`Ctrl-D`退出REPL，或者从Windows使用`Ctrl-Z`，然后运行Python 3并传递模块文件名：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: No words are printed. This is because all the module does now is to define a
    function and then immediately exit. To make a module from which we can usefully
    import functions into the REPL *and* which can be run as a script, we need to
    learn a new Python idiom.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单词被打印。这是因为现在模块所做的只是定义一个函数，然后立即退出。为了创建一个我们可以有用地从中导入函数到REPL *并且*可以作为脚本运行的模块，我们需要学习一个新的Python习惯用法。
- en: '`__name__` and executing modules from the command line'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`__name__`和从命令行执行模块'
- en: 'The Python runtime system defines some special variables and attributes, the
    names of which are delimited by double underscores. One such special variable
    is called `__name__`, and it gives us the means for our module to determine whether
    it has been run as a script or, instead, imported into another module or the REPL.
    To see how, add:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python运行时系统定义了一些特殊变量和属性，它们的名称由双下划线分隔。其中一个特殊变量叫做`__name__`，它为我们的模块提供了一种方式来确定它是作为脚本运行还是被导入到另一个模块或REPL中。要查看如何操作，请添加：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: add the end of your module, outside of the `fetch_words()` function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fetch_words()`函数之外的模块末尾添加。
- en: 'First of all, let’s import the modified words module back into the REPL:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将修改后的words模块重新导入到REPL中：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that when imported `__name__` does indeed evaluate to the module’s
    name.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当导入`__name__`时，它确实会评估为模块的名称。
- en: 'As a brief aside, if you import the module again, the print statement will
    *not* be executed; module code is only executed once, on first import:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果再次导入模块，print语句将*不会*被执行；模块代码只在第一次导入时执行一次：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let’s try running the module as a script:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试将模块作为脚本运行：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case the special `__name__` variable is equal to the string “**main**”
    which is also delimited by double underscores. Our module can use this behavior
    to detect how it is being used. We replace the print statement with an if-statement
    which tests the value of `__name__`. If the value is equal to “**main**” then
    our function is executed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，特殊的`__name__`变量等于字符串“**main**”，也由双下划线分隔。我们的模块可以利用这种行为来检测它的使用方式。我们用一个if语句替换print语句，该语句测试`__name__`的值。如果值等于“**main**”，那么我们的函数就会被执行：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can safely import our module without unduly executing our function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以安全地导入我们的模块，而不会过度执行我们的函数：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'and we can usefully run our function as a script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有用地将我们的函数作为脚本运行：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The Python execution model
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python执行模型
- en: In order to have a really solid foundation in Python, it’s important to understand
    the Python *execution model*. By this, we mean the rules defining precisely when
    function definitions and other important events occur during module import and
    execution. To help you develop this understanding, we’ll focus on the `def` keyword
    since you’re already familiar with it. Once you have an understanding of how `def`
    is processed by Python, you’ll know most of what you need to know about Python’s
    execution model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中有一个真正坚实的基础，了解Python的*执行模型*是很重要的。我们指的是定义模块导入和执行期间发生的函数定义和其他重要事件的规则。为了帮助你发展这种理解，我们将专注于`def`关键字，因为你已经熟悉它。一旦你了解了Python如何处理`def`，你就会知道大部分关于Python执行模型的知识。
- en: 'What’s important to understand is this: **`def` isn’t merely a declaration,
    it’s a *statement***. What this means is that `def` is actually executed at runtime
    along with the rest of the top-level module-scope code. What `def` does is to
    bind the code in the function’s body to the name following `def`. When modules
    are imported or run, all of the top-level statements are run, and this is the
    means by which the functions within the module namespace are defined.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解这一点：**`def`不仅仅是一个声明，它是一个*语句***。这意味着`def`实际上是在运行时执行的，与其他顶层模块范围代码一起。`def`的作用是将函数体中的代码绑定到`def`后面的名称。当模块被导入或运行时，所有顶层语句都会运行，这是模块命名空间中的函数定义的方式。
- en: To reiterate, `def` is executed at runtime. This is very different from how
    function definitions are handled in many other languages, especially compiled
    languages like C++, Java, and C#. In those languages, function definitions are
    processed by the compiler at *compile time*, not at runtime.^([4](chap21.xhtml#fn-dynamic-functions))
    By the time the program is actually executing, those function definitions are
    fixed. In Python there is no compiler ^([5](chap21.xhtml#fn-no-compiler)), and
    functions don’t exist in any form — except that of source code — until execution.
    In fact, since a function is only defined when its `def` is processed on import,
    a function in a module which is never imported will never be defined.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，`def`是在运行时执行的。这与许多其他语言中处理函数定义的方式非常不同，特别是在编译语言如C++、Java和C#中。在这些语言中，函数定义是由编译器在*编译时*处理的，而不是在运行时。^([4](chap21.xhtml#fn-dynamic-functions))实际执行程序时，这些函数定义已经固定。在Python中没有编译器^([5](chap21.xhtml#fn-no-compiler))，函数在执行之前并不存在任何形式，除了源代码。事实上，由于函数只有在导入时处理其`def`时才被定义，因此在从未导入的模块中的函数将永远不会被定义。
- en: Understanding this dynamic nature of Python function definitions is critical
    to understanding important concepts later in this book, so make sure you’re comfortable
    with it. If you’ve access to a Python debugger, e.g. in an IDE, you might spend
    some time stepping through your `words.py` module as it’s imported.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Python函数定义的这种动态特性对于后面本书中的重要概念至关重要，所以确保你对此感到舒适。如果你有Python调试器，比如在IDE中，你可以花一些时间逐步执行你的`words.py`模块。
- en: The difference between modules, scripts, and programs
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块、脚本和程序之间的区别
- en: We’re sometimes asked about the differences between Python modules, Python scripts,
    and Python programs. Any `.py` file constitutes a Python module, but as we have
    seen modules can be written for convenient import, convenient execution, or, using
    the `if __name__ == "__main__"` idiom, both.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们会被问及Python模块、Python脚本和Python程序之间的区别。任何`.py`文件都构成一个Python模块，但正如我们所见，模块可以被编写为方便导入、方便执行，或者使用`if
    __name__ == "__main__"`的习惯用法，两者兼而有之。
- en: We strongly recommend making even simple scripts importable since it eases development
    and testing so much if you can access your code from the Python REPL. Likewise,
    even modules which are only ever meant to be imported in production settings benefit
    from having executable test code. For this reason nearly all modules we create
    have this form of defining one or more importable functions with a postscript
    to facilitate execution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议即使是简单的脚本也要可导入，因为如果可以从Python REPL访问代码，这样可以极大地简化开发和测试。同样，即使是只在生产环境中导入的模块也会受益于具有可执行的测试代码。因此，我们创建的几乎所有模块都采用了定义一个或多个可导入函数的形式，并附有后缀以便执行。
- en: Whether you consider a module to be a Python script or Python program is a matter
    of context and usage. It’s certainly wrong to consider Python to be merely a scripting
    tool — in the vein of Windows batch files or Unix shell scripts — as many large
    and complex applications have been built exclusively with Python.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块视为Python脚本或Python程序取决于上下文和用法。将Python仅视为脚本工具是错误的，因为许多大型复杂的应用程序都是专门使用Python构建的，而不是像Windows批处理文件或Unix
    shell脚本那样。
- en: Setting up a main function with command line argument
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置带有命令行参数的主函数
- en: 'Let’s refine our word fetching module a little further. First, we’ll perform
    a small refactoring and separate the word retrieval and collection on the one
    hand from the word printing on the other:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步完善我们的单词获取模块。首先，我们将进行一些小的重构，将单词检索和收集与单词打印分开：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We do this because it separates two important concerns: when importing we’d
    rather get the words as a list, but when running directly, we’d prefer the words
    to be printed.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为它分离了两个重要的关注点：在导入时，我们宁愿得到单词列表，但在直接运行时，我们更希望单词被打印出来。
- en: 'Next, we’ll extract the code from our `if __name__ == ''__main__''` block into
    a function called `main()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从`if __name__ == '__main__'`块中提取代码到一个名为`main()`的函数中：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By moving this code into a function we can test it from the REPL, something
    which isn’t possible while it’s in the module scope if-block.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这段代码移到一个函数中，我们可以在REPL中测试它，而在模块范围的if块中是不可能的。
- en: 'We can now try these functions from the REPL:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在REPL中尝试这些函数：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We’ve used this opportunity to introduce a couple of new forms of the `import`
    statement. The first new form imports multiple objects from a module using a comma
    separated list. The parentheses are optional, but they do allow you to break this
    list over multiple lines if it gets long. This form is perhaps the most widely
    used form of the import statement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用这个机会介绍了`import`语句的一些新形式。第一种新形式使用逗号分隔的列表从模块中导入多个对象。括号是可选的，但如果列表很长，它们可以允许您将此列表分成多行。这种形式可能是最广泛使用的`import`语句的形式之一。
- en: 'A second new form imports everything from a module using an asterisk wildcard:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种新形式使用星号通配符从模块中导入所有内容：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This latter form is recommended only for casual use at the REPL. It can wreak
    havoc in programs since what is imported is now potentially beyond your control,
    opening yourself up to potential namespace clashes at some future time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种形式仅建议在REPL上进行临时使用。它可能会在程序中造成严重破坏，因为导入的内容现在可能超出您的控制范围，从而在将来可能导致潜在的命名空间冲突。
- en: 'Having done this, we can fetch words from the URL:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以从URL获取单词：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since we’ve separated the fetching code from the printing code, we can also
    print *any* list of words:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已将获取代码与打印代码分开，因此我们还可以打印*任何*单词列表：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Indeed, we can even run the main program:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们甚至可以运行主程序：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice that the `print_words()` function isn’t fussy about the type items in
    the list. It’s perfectly happy to print a list of numbers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`print_words()`函数对列表中的项目类型并不挑剔。它可以很好地打印数字列表：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So perhaps `print_words()` isn’t the best name. In fact, the function doesn’t
    mention lists either - it will happily print any collection that the for-loop
    is capable of iterating over, such as a string:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，也许`print_words()`不是最好的名称。实际上，该函数也没有提到列表-它可以很高兴地打印任何for循环能够迭代的集合，例如字符串：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So let’s perform a minor refactoring and rename this function to `print_items()`,
    changing the variable names within the function to suit:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们进行一些小的重构，并将此函数重命名为`print_items()`，并相应地更改函数内的变量名：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, one obvious improvement to our module would be to replace the hard-coded
    URL with a value we can pass in. Let’s extract that value into an argument of
    the `fetch_words()` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对我们的模块的一个明显改进是用一个可以传递的值替换硬编码的URL。让我们将该值提取到`fetch_words()`函数的参数中：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Accepting command line arguments
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接受命令行参数
- en: 'That last change actually breaks our `main()` since it’s not passing the new
    `url` argument. When running our module as a standalone program, we’ll need to
    accept the URL as a command line argument. Access to command line arguments in
    Python is through an attribute of the `sys` module called `argv` which is a list
    of strings. To use it we must first import the `sys` module at the top of our
    program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次更改实际上破坏了我们的`main()`，因为它没有传递新的`url`参数。当我们将模块作为独立程序运行时，我们需要接受URL作为命令行参数。在Python中访问命令行参数是通过`sys`模块的一个属性`argv`，它是一个字符串列表。要使用它，我们必须首先在程序顶部导入`sys`模块：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then get the second argument (with an index of one) from the list:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从列表中获取第二个参数（索引为1）：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And of course this works as expected:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这按预期工作：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This looks fine until we realize that we can’t usefully test `main()` any longer
    from the REPL because it refers to `sys.argv[1]` which is unlikely to have a useful
    value in that environment:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很好，直到我们意识到我们无法从REPL有用地测试`main()`，因为它引用`sys.argv[1]`，在该环境中这个值不太可能有用：
- en: '[PRE37]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The solution is to allow the argument list to be passed as a formal argument
    to the `main()` function, using `sys.argv` as the actual parameter in the `if
    __name__ == ''__main__''` block:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是允许将参数列表作为`main()`函数的形式参数传递，使用`sys.argv`作为`if __name__ == '__main__'`块中的实际参数：
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Testing from the REPL again, we can see that everything works as expected:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从REPL进行测试，我们可以看到一切都按预期工作：
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Python is a great tool for developing command line tools, and you’ll likely
    find that you need to handle command line arguments for many situations. For more
    sophisticated command line processing we recommend you look at the [Python Standard
    Library `argparse`](https://docs.python.org/3/library/argparse.html) module or
    [the inspired third-party `docopt` module](http://docopt.org/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python是开发命令行工具的好工具，您可能会发现您需要处理许多情况的命令行参数。对于更复杂的命令行处理，我们建议您查看[Python标准库`argparse`](https://docs.python.org/3/library/argparse.html)模块或[受启发的第三方`docopt`模块](http://docopt.org/)。
- en: '* * *'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Moment of zen
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禅意时刻
- en: '![](images/m03----zen-sparse-is-better-than-dense.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m03----zen-sparse-is-better-than-dense.png)'
- en: You’ll notice that our top level functions have two blank lines between them.
    This is conventional for modern Python code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们的顶级函数之间有两个空行。这是现代Python代码的传统。
- en: According to [the PEP 8 style-guide](https://www.python.org/dev/peps/pep-0008/)
    it’s customary to use two blank lines between module-level functions. We find
    this convention has served us well, making code easier to navigate. Similarly,
    we use single blank lines for logical breaks within functions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[PEP 8风格指南](https://www.python.org/dev/peps/pep-0008/)，在模块级函数之间使用两个空行是习惯的。我们发现这种约定对我们有所帮助，使代码更容易导航。同样，我们在函数内使用单个空行进行逻辑分隔。
- en: '* * *'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Docstrings
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档字符串
- en: We saw previously how it was possible to ask at the REPL for help on Python
    functions. Let’s look at how to add this self-documenting capability to our own
    module.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了如何在REPL上询问Python函数的帮助。让我们看看如何将这种自我记录的能力添加到我们自己的模块中。
- en: 'API documentation in Python uses a facility called *docstrings*. Docstrings
    are literal strings which occur as the first statement within a named block, such
    as a function or module. Let’s document the `fetch_words()` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的API文档使用一种称为*docstrings*的设施。 Docstrings是出现在命名块（例如函数或模块）的第一条语句中的文字字符串。让我们记录`fetch_words()`函数：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We use triple-quoted strings even for single-line docstrings because they can
    be easily expanded to add more detail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至使用三引号字符串来编写单行文档字符串，因为它们可以很容易地扩展以添加更多细节。
- en: 'One Python convention for docstrings is documented in [PEP 257](https://www.python.org/dev/peps/pep-0257/),
    although it is not widely adopted. Various tools, such as [Sphinx](http://www.sphinx-doc.org/),
    are available to build HTML documentation from Python docstrings, and each tool
    mandates its preferred docstring format. Our preference is to use the form presented
    in [Google’s Python style-guide](https://google.github.io/styleguide/pyguide.html),
    since it is amenable to being machine parsed whilst still remaining readable at
    the console:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python文档字符串的一个约定在[PEP 257](https://www.python.org/dev/peps/pep-0257/)中有记录，尽管它并没有被广泛采用。各种工具，如[Sphinx](http://www.sphinx-doc.org/)，可用于从Python文档字符串构建HTML文档，每个工具都规定了其首选的文档字符串格式。我们的首选是使用[Google的Python风格指南](https://google.github.io/styleguide/pyguide.html)中提出的形式，因为它适合被机器解析，同时在控制台上仍然可读：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we’ll access this `help()` from the REPL:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从REPL中访问这个`help()`：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We’ll add similar docstrings for our other functions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为其他函数添加类似的文档字符串：
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'and one for the module itself. Module docstrings should be placed at the beginning
    of the module, before any statements:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以及模块本身的文档字符串。模块文档字符串应放在模块的开头，任何语句之前：
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now when we request `help()` on the module as a whole, we get quite a lot of
    useful information:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们在整个模块上请求`help()`时，我们会得到相当多有用的信息：
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Comments
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: We believe docstrings are the right place for most documentation in Python code.
    They explain how to consume the facilities your module provides rather than how
    it works. Ideally your code should be clean enough that ancillary explanation
    is not required. Nevertheless, it’s sometimes necessary to explain *why* a particular
    approach has be chosen or a particular technique used, and we can do that using
    Python comments. Comments in Python begin with `#` and continue to the end of
    the line.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为文档字符串是Python代码中大多数文档的正确位置。它们解释了如何使用模块提供的功能，而不是它的工作原理。理想情况下，您的代码应该足够清晰，不需要辅助解释。尽管如此，有时需要解释为什么选择了特定的方法或使用了特定的技术，我们可以使用Python注释来做到这一点。Python中的注释以`#`开头，直到行尾。
- en: 'As a demonstration, let’s document the fact that it might not be immediately
    obvious why we’re using `sys.argv[1]` rather than `sys.argv[0]` in our call to
    `main()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，让我们记录这样一个事实，即为什么我们在调用`main()`时使用`sys.argv[1]`而不是`sys.argv[0]`可能不是立即明显的：
- en: '[PRE46]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Shebang
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shebang
- en: It’s common on Unix-like systems to have the first line of a script include
    a special comment, `#!`, called a *shebang*. This allows the program loader to
    identify which interpreter should be used to run the program. Shebangs have an
    additional purpose of conveniently documenting at the top of a file whether the
    Python code therein is Python 2 or Python 3.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix系统上，脚本的第一行通常包括一个特殊的注释`#!`，称为*shebang*。这允许程序加载器识别应该使用哪个解释器来运行程序。Shebang还有一个额外的目的，方便地在文件顶部记录Python代码是Python
    2还是Python 3。
- en: 'The exact details of your shebang command depend on the location of Python
    on your system. Typical Python 3 shebangs use the Unix `env` program to locate
    Python 3 on your `PATH` environment variable, which importantly is compatible
    with Python virtual environments:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您的shebang命令的确切细节取决于系统上Python的位置。典型的Python 3 shebang使用Unix的`env`程序来定位您的`PATH`环境变量上的Python
    3，这一点非常重要，它与Python虚拟环境兼容：
- en: '[PRE47]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Executable Python programs on Linux and Mac
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux和Mac上可执行的Python程序
- en: 'On Mac or Linux, we must mark our script as executable using the `chmod` command
    before the shebang will have any effect:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac或Linux上，我们必须在shebang生效之前使用`chmod`命令将脚本标记为可执行：
- en: '[PRE48]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Having done that, we can now run our script directly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些之后，我们现在可以直接运行我们的脚本：
- en: '[PRE49]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Executable Python programs on Windows
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows上可执行的Python程序
- en: Starting with Python 3.3, Python on Windows also supports the use of the shebang
    to make Python scripts directly executable with the correct version of the Python
    interpreter, even to the extent that shebangs that look like they should only
    work on Unix-like systems will work as expected on Windows. This works because
    Windows Python distributions now use a program called *PyLauncher*. PyLauncher,
    the executable for which is called `py.exe`, will parse the shebang and locate
    the appropriate version of Python.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.3开始，Windows上的Python也支持使用shebang来使Python脚本直接可执行，即使看起来只能在类Unix系统上正常工作的shebang也会在Windows上按预期工作。这是因为Windows
    Python发行版现在使用一个名为*PyLauncher*的程序。 PyLauncher的可执行文件名为`py.exe`，它将解析shebang并找到适当版本的Python。
- en: 'For example, on Windows at the `cmd` prompt, this command will be sufficient
    to run your script with Python 3 (even if you also have Python 2 installed):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Windows的`cmd`提示符下，这个命令就足以用Python 3运行你的脚本（即使你也安装了Python 2）：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In Powershell the equivalent is:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Powershell中，等效的是：
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can read more about PyLauncher in [PEP 397](https://www.python.org/dev/peps/pep-0397/).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[PEP 397](https://www.python.org/dev/peps/pep-0397/)中了解更多关于PyLauncher的信息。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'Python modules:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python模块：
- en: Python code is placed in `*.py` files called modules.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python代码放在名为模块的`*.py`文件中。
- en: Modules can be executed directly by passing them as the first argument to the
    Python interpreter.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块可以通过将它们作为Python解释器的第一个参数直接执行。
- en: Modules can also be imported into the REPL, at which point all top-level statements
    in the module are executed in order.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块也可以被导入到REPL中，此时模块中的所有顶级语句将按顺序执行。
- en: 'Python functions:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python函数：
- en: Named functions are defined using the `def` keyword followed by the function
    name and the argument list in parentheses.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`def`关键字定义命名函数，后面跟着函数名和括号中的参数列表。
- en: We can return objects from functions using the `return` statement.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`return`语句从函数中返回对象。
- en: Return statements without a parameter return `None`, as does the implicit `return`
    at the end of every function body.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有参数的返回语句返回`None`，在每个函数体的末尾也是如此。
- en: 'Module execution:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块执行：
- en: We can detect whether a module has been imported or executed by examining the
    value of the special `__name__` variable. If it is equal to the string `"__main__"`
    our module has been executed directly as a program. By executing a function if
    this condition is met using the top-level `if __name__ == '__main__'` idiom at
    the end of our module, we can make our module both usefully importable and executable,
    an important testing technique even for short scripts.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过检查特殊的`__name__`变量的值来检测模块是否已导入或执行。如果它等于字符串`"__main__"`，我们的模块已直接作为程序执行。通过在模块末尾使用顶层`if
    __name__ == '__main__'`习语来执行函数，如果满足这个条件，我们的模块既可以被有用地导入，又可以被执行，这是一个重要的测试技术，即使对于短脚本也是如此。
- en: Module code is only executed once, on first import.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块代码只在第一次导入时执行一次。
- en: The `def` keyword is a statement which binds executable code to a function name.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def`关键字是一个语句，将可执行代码绑定到函数名。'
- en: Command line arguments can be accessed as a list of strings accessible through
    the `argv` attribute of the `sys` module. The zero-th command line argument is
    the script filename, so the item at index one is the first true argument.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数可以作为字符串列表访问，通过`sys`模块的`argv`属性。零号命令行参数是脚本文件名，因此索引为1的项是第一个真正的参数。
- en: Python’s dynamic typing means our functions can be very generic with respect
    to the type of their arguments.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的动态类型意味着我们的函数可以非常通用，关于它们参数的类型。
- en: 'Docstrings:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档字符串：
- en: A literal string as the first line of a function’s definition forms the function’s
    docstring. They are typically triple-quoted multiline strings containing usage
    information.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数定义的第一行的文字字符串形成函数的文档字符串。它们通常是包含使用信息的三引号多行字符串。
- en: Function documentation provided in docstrings can be retrieved using `help()`
    in the REPL.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在REPL中，可以使用`help()`检索文档字符串中提供的函数文档。
- en: Module docstrings should be placed near the beginning of the module prior to
    any Python statements such as import statements.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块文档字符串应放置在模块的开头，先于任何Python语句，如导入语句。
- en: 'Comments:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释：
- en: Comments in Python commence with a hash character and continue to the end of
    the line.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的注释以井号字符开头，并延续到行尾。
- en: The first line of the module can contain a special comment called a shebang,
    allowing the program loader to launch the correct Python interpreter on all major
    platforms.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的第一行可以包含一个特殊的注释，称为shebang，允许程序加载器在所有主要平台上启动正确的Python解释器。
