- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Creating Basic Forms with Tkinter and Ttk Widgets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tkinter 和 Ttk 小部件创建基本表单
- en: 'Good news! Your design has been reviewed and approved by the director. Now
    it''s time to start implementing it! In this chapter, we''ll be creating a very
    simple application that delivers the core functionality of the specification and
    little else. This is known as a **minimum viable product** or **MVP**. The MVP
    will not be production-ready, but it will give us something to show our users
    and help us better understand the problem and the technologies we''re working
    with. We''ll cover this in the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！您的设计方案已经经过审查并获得总监批准。现在是时候开始实施了！在本章中，我们将创建一个非常简单的应用程序，它提供了规范的核心功能，而其他功能则很少。这被称为
    **最小可行产品** 或 **MVP**。MVP 不会是生产就绪的，但它将给我们一些东西向用户展示，并帮助我们更好地理解问题和我们所工作的技术。以下是我们将要讨论的主题：
- en: In *The Ttk widget set*, we'll learn about a better widget set for Tkinter,
    Ttk.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Ttk 小部件集* 中，我们将了解一个更好的 Tkinter 小部件集，即 Ttk。
- en: In *Implementing the application*, we'll build our form design using Python,
    Tkinter, and Ttk.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *实现应用程序* 中，我们将使用 Python、Tkinter 和 Ttk 来构建我们的表单设计。
- en: Let's get coding!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编码！
- en: The Ttk widget set
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ttk小部件集
- en: In *Chapter 1*, *Introduction to Tkinter*, we created a survey application using
    the default Tkinter widgets. These widgets are perfectly functional and still
    used in many Tkinter applications, but modern Tkinter applications tend to prefer
    an improved set of widgets called **Ttk**. Ttk is a sub-module of Tkinter that
    provides themed versions of many (but not all) Tkinter widgets. These widgets
    are mostly identical to the traditional widgets but provide advanced styling options
    in an aim to look more modern and natural on Windows, macOS, and Linux.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 1 章*，*Tkinter 简介* 中，我们使用默认的 Tkinter 小部件创建了一个调查应用程序。这些小部件功能齐全，并且仍然被许多 Tkinter
    应用程序使用，但现代 Tkinter 应用程序往往更喜欢一个改进的小部件集，称为 **Ttk**。Ttk 是 Tkinter 的一个子模块，它提供了许多（但不是所有）Tkinter
    小部件的主题版本。这些小部件与传统的类似，但提供了旨在使它们在 Windows、macOS 和 Linux 上看起来更现代和自然的先进样式选项。
- en: On each platform, Ttk includes platform-specific themes that mimic the platform's
    native widgets. In addition, Ttk adds a few extra widgets that offer functionality
    not found in the default library.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个平台上，Ttk 包含模仿平台原生小部件的平台特定主题。此外，Ttk 还添加了一些额外的提供默认库中找不到的功能的小部件。
- en: Although this chapter will cover the basic usage of Ttk widgets, full coverage
    of the fonts, colors, and other style customization for Ttk widgets can be found
    in *Chapter 9*, *Improving the Look with Styles and Themes*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章将涵盖 Ttk 小部件的基本用法，但关于 Ttk 小部件的字体、颜色和其他样式定制的完整覆盖可以在 *第 9 章*，*通过样式和主题改进外观*
    中找到。
- en: 'Ttk is already included as part of Tkinter, so we do not need to install anything
    extra. To use Ttk widgets in our Tkinter applications, we will need to import
    `ttk` like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk 已经作为 Tkinter 的一部分包含在内，因此我们不需要安装任何额外的东西。要在我们的 Tkinter 应用程序中使用 Ttk 小部件，我们需要像这样导入
    `ttk`：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this section, we''ll take a deeper look at the Ttk widgets that will be
    useful in our application. Remember from our design that we need the following
    types of widgets for our application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地了解将在我们的应用程序中非常有用的小部件。记住，从我们的设计中我们知道我们需要以下类型的小部件：
- en: Labels
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Date entry
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期输入
- en: Text entry
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本输入
- en: Number entry
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字输入
- en: Check boxes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框
- en: Radio buttons
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选按钮
- en: Select list
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择列表
- en: Long text entry
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长文本输入
- en: Buttons
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: Boxed frames with headers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带标题的框式框架
- en: Let's look at the Ttk widgets that we can use to meet these needs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用来满足这些需求的小部件。
- en: The Label widget
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签小部件
- en: 'We made good use of the Tkinter `Label` widget in *Chapter 1*, *Introduction
    to Tkinter*, and the Ttk version is essentially the same. We can create one like
    so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 1 章*，*Tkinter 简介* 中，我们很好地使用了 Tkinter `Label` 小部件，Ttk 版本本质上相同。我们可以这样创建一个：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This results in a label that looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个看起来像这样的标签：
- en: '![](img/B17578_03_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_03_01.png)'
- en: 'Figure 3.1: A Ttk Label widget'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：一个 Ttk 标签小部件
- en: 'The Ttk `Label` widget shares most of the same options as the Tk version, the
    most common of which are listed here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk `Label` 小部件与 Tk 版本具有大多数相同的选项，其中最常见的是以下列出的：
- en: '| Argument | Values | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `text` | String | The text content of the label |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 字符串 | 标签的文本内容 |'
- en: '| `textvariable` | `StringVar` | The variable to bind to the contents of the
    label |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `textvariable` | `StringVar` | 绑定到标签内容的变量 |'
- en: '| `anchor` | Cardinal direction | The position of the text relative to the
    inner margins |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `anchor` | 方向 | 文本相对于内边距的位置 |'
- en: '| `justify` | `left`, `right`, or `center` | The alignment of the lines of
    text relative to one another |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `justify` | `left`, `right`, 或 `center` | 文本行相对于彼此的对齐方式 |'
- en: '| `foreground` | Color string | The color of the text |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `foreground` | 颜色字符串 | 文本的颜色 |'
- en: '| `wraplength` | Integer | Number of pixels before the text is wrapped to the
    next line |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `wraplength` | 整数 | 文本换行前的像素数 |'
- en: '| `underline` | Integer | The index of a character in `text` to underline |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `underline` | 整数 | `text` 中字符的下划线索引 |'
- en: '| `font` | Font string or tuple | The font to be used |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `font` | 字体字符串或元组 | 要使用的字体 |'
- en: Note that a label's text can either be specified directly using `text`, or bound
    to a `StringVar`, allowing for dynamic label text. The `underline` argument allows
    for underlining a single character in the label text; this is useful for indicating
    a keybinding for the user, for example, to activate a control widget labeled by
    the label. No keybinding is actually created by this argument; it's merely cosmetic.
    We'll learn to create keybindings in *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标签的文本可以通过 `text` 直接指定，或者绑定到 `StringVar`，允许动态标签文本。`underline` 参数允许在标签文本中下划线一个字符；这有助于指示用户的快捷键，例如，激活由标签命名的控制小部件。此参数实际上不会创建快捷键；它仅具有装饰性。我们将在
    *第 10 章*，*维护跨平台兼容性* 中学习如何创建快捷键。
- en: The Entry widget
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Entry 小部件
- en: 'The `ttk.Entry` widget is a simple one-line text entry, just like the Tkinter
    version. It looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk.Entry` 小部件是一个简单的单行文本输入，就像 Tkinter 版本一样。它看起来是这样的：'
- en: '![](img/B17578_03_02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_03_02.png)'
- en: 'Figure 3.2: A Ttk Entry widget'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：Ttk Entry 小部件
- en: 'We can create an `Entry` widget using this code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码创建一个 `Entry` 小部件：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Ttk `Entry` is very similar to the Tkinter `Entry` widget we''ve already
    seen, and supports many of the same arguments. Here is a selection of the more
    common `Entry` options:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk 的 `Entry` 小部件与我们之前看到的 Tkinter `Entry` 小部件非常相似，并支持许多相同的参数。以下是更常见的 `Entry`
    选项的选取：
- en: '| Argument | Values | Description |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `textvariable` | `StringVar` | Tkinter control variable to bind. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `textvariable` | `StringVar` | Tkinter 控制变量绑定。|'
- en: '| `show` | String | Character or string to show when the user types. Useful
    for password fields, for example. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `show` | 字符串 | 用户输入时显示的字符或字符串。例如，对于密码字段很有用。|'
- en: '| `justify` | `left`, `right`, or `center` | Alignment of the text in the entry.
    `left` is default. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `justify` | `left`, `right`, 或 `center` | 输入框中文字的对齐方式。`left` 为默认值。|'
- en: '| `foreground` | Color string | Color of text. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `foreground` | 颜色字符串 | 文本的颜色。|'
- en: We'll learn some more options for the `Entry` as we dig deeper into the capabilities
    of Ttk widgets in future chapters. The `Entry` will be used for all of our text
    entry fields, as well as our `Date` field. Ttk does not have a dedicated `date`
    widget, but we'll learn in *Chapter 5*, *Reducing User Error with Validation and
    Automation*, how to turn our `Entry` into a `date` field.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来章节中深入探讨 Ttk 小部件的功能时，我们将学习更多关于 `Entry` 的选项。`Entry` 将用于我们所有的文本输入字段，以及我们的 `Date`
    字段。Ttk 没有专门的 `date` 小部件，但在 *第 5 章*，*通过验证和自动化减少用户错误* 中，我们将学习如何将我们的 `Entry` 转换为
    `date` 字段。
- en: The Spinbox widget
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spinbox 小部件
- en: Like the Tkinter version, the Ttk `Spinbox` adds increment and decrement buttons
    to the standard `Entry` widget, making it suitable for numerical data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Tkinter 版本一样，Ttk 的 `Spinbox` 在标准的 `Entry` 小部件中添加了增加和减少按钮，使其适合数值数据。
- en: 'The Ttk `Spinbox` is shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了 Ttk 的 `Spinbox`：
- en: '![](img/B17578_03_03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_03_03.png)'
- en: 'Figure 3.3: A Ttk Spinbox widget'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：Ttk Spinbox 小部件
- en: 'We can create one like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个如下所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As this code shows, the Ttk `Spinbox` takes a number of arguments that control
    the behavior of its arrow buttons, listed in this table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，Ttk 的 `Spinbox` 接受多个参数来控制其箭头按钮的行为，列于下表：
- en: '| Argument | Values | Description |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `from_` | Float or Int | Minimum value the arrows will decrement to. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `from_` | 浮点数或整数 | 箭头减少到的最小值。|'
- en: '| `to` | Float or Int | Maximum value the arrows will increment to. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `to` | 浮点数或整数 | 箭头增加到的最大值。|'
- en: '| `increment` | Float or Int | Value that will be added or subtracted by the
    arrows. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `increment` | 浮点数或整数 | 由箭头添加或减去的值。|'
- en: '| `command` | Python function | Callback to be executed when either button
    is pushed. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `command` | Python 函数 | 当任意按钮被按下时执行的回调函数。|'
- en: '| `textvariable` | Control variable (any type) | Variable bound to the field
    value. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `textvariable` | 控制变量（任何类型） | 绑定到字段值的变量。|'
- en: '| `values` | List of strings or numbers | Set of choices the buttons will scroll
    through. Overrides the `from_` and `to` values. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `values` | 字符串或数字列表 | 按钮将滚动浏览的选项集。覆盖`from_`和`to`值。 |'
- en: Note that these arguments do *not* restrict what is entered into the `Spinbox`;
    they only impact the behavior of the arrows. Also, be aware that if you specify
    only one of `from_` or `to`, the other defaults to `0` automatically. This can
    lead to unexpected behavior; for example, if you set `from_=1` without specifying
    `to`, then `to` will default to `0` and your arrows will only toggle between `1`
    and `0`. To explicitly set no limit, you can use `from_='-infinity'` and `to='infinity'`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些参数并不限制输入到`Spinbox`中的内容；它们仅影响箭头的行为。此外，请注意，如果你只指定了`from_`或`to`中的一个，另一个将自动默认为`0`。这可能会导致意外的行为；例如，如果你设置了`from_=1`但没有指定`to`，那么`to`将默认为`0`，你的箭头将只在`1`和`0`之间切换。要显式设置无限制，可以使用`from_='-infinity'`和`to='infinity'`。
- en: The `Spinbox` widget is not merely for numbers, even though that's primarily
    how we'll be using it. As you can see, it can also take a `values` argument, which
    is a list of strings or numbers that can be scrolled through using the arrow buttons.
    Because of this, the `Spinbox` can be bound to any kind of control variable, not
    just `IntVar` or `DoubleVar` variables.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spinbox`小部件不仅用于数字，尽管我们主要会这样使用它。正如你所见，它还可以接受`values`参数，这是一个字符串或数字列表，可以通过箭头按钮滚动浏览。因此，`Spinbox`可以绑定到任何类型的控制变量，而不仅仅是`IntVar`或`DoubleVar`变量。'
- en: Remember, none of these parameters actually limit what can be typed into a `Spinbox`
    widget. It's really nothing more than an `Entry` widget with buttons tacked on,
    and you can type not only numeric values outside the valid range but letters and
    symbols as well. Doing so can cause an exception if you've bound the widget to
    a non-string variable. In *Chapter 5*, *Reducing User Error with Validation and
    Automation*, we'll learn how to make the `Spinbox` widget limit entry to valid
    numeric characters only.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些参数实际上并没有限制可以输入到`Spinbox`小部件中的内容。它实际上只是一个带有按钮的`Entry`小部件，你可以输入不仅限于有效范围内的数值，还可以输入字母和符号。这样做可能会导致异常，如果你将小部件绑定到非字符串变量。在*第5章*，*通过验证和自动化减少用户错误*中，我们将学习如何使`Spinbox`小部件仅允许输入有效的数字字符。
- en: The Checkbutton widget
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复选框小部件
- en: 'The Ttk `Checkbutton` widget is a labeled checkbox ideal for entering Boolean
    data. It can be created like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk `Checkbutton`小部件是一个带标签的复选框，非常适合输入布尔数据。它可以创建如下：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Checkbutton` widgets can take a number of arguments in addition to those listed
    above, as shown in this table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上面列出的参数外，`Checkbutton`小部件还可以接受其他参数，如下表所示：
- en: '| Argument | Values | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `variable` | Control variable | The variable to which the checked/unchecked
    state of the box is bound |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `variable` | 控制变量 | 复选框选中/未选中状态所绑定的变量 |'
- en: '| `text` | String | The label text |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `text` | String | 标签文本 |'
- en: '| `textvariable` | `StringVar` | The variable to which the label text is bound
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `textvariable` | `StringVar` | 标签文本所绑定的变量 |'
- en: '| `command` | Python function | A callback to execute whenever the box is checked
    or unchecked |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `command` | Python函数 | 当复选框选中或未选中时执行的回调函数 |'
- en: '| `onvalue` | Any | Value to set `variable` when the box is checked |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `onvalue` | Any | 当复选框选中时设置`variable`的值 |'
- en: '| `offvalue` | Any | Value to set `variable` when the box is unchecked |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `offvalue` | Any | 当复选框未选中时设置`variable`的值 |'
- en: '| `underline` | Integer | Index of a character in `text` to underline |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `underline` | Integer | `text`中字符的下划线索引 |'
- en: The label included in the `Checkbutton` can be set directly using the `text`
    argument, or it can be bound to a control variable using `textvariable`. This
    allows for dynamic labeling of the widget, which can be useful in many situations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Checkbutton`中的标签可以直接使用`text`参数设置，或者可以使用`textvariable`将其绑定到控制变量。这允许对小部件进行动态标签化，这在许多情况下都很有用。'
- en: Although the `Checkbutton` is ideal for Boolean data and defaults to setting
    its bound variable to `True` or `False`, we can override this behavior with the
    `onvalue` and `offvalue` arguments, allowing it to be usable with any type of
    control variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然复选框非常适合布尔数据，并且默认将其绑定的变量设置为`True`或`False`，但我们可以使用`onvalue`和`offvalue`参数来覆盖此行为，使其可以与任何类型的控制变量一起使用。
- en: 'For example, we can use it with a `DoubleVar` like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以用它与`DoubleVar`一起使用，如下所示：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Ttk `Checkbutton` places the label to the right of the box, as shown in
    this screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk `Checkbutton`将标签放置在框的右侧，如以下截图所示：
- en: '![](img/B17578_03_04.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_03_04.png)'
- en: 'Figure 3.4: A Ttk Checkbutton widget with its built-in label'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：带有内置标签的Ttk Checkbutton小部件
- en: The Radiobutton widget
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Radiobutton小部件
- en: 'Like its Tkinter counterpart, the Ttk `Radiobutton` widget is used for selection
    among a set of mutually exclusive options. A single `Radiobutton` by itself is
    not a terribly useful widget; instead, they are usually created as a group, as
    shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与其Tkinter对应物一样，Ttk `Radiobutton`小部件用于在一组相互排斥的选项中进行选择。单个`Radiobutton`本身不是一个非常有用的小部件；相反，它们通常作为一个组创建，如下所示：
- en: '![](img/B17578_03_05.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_03_05.png)'
- en: 'Figure 3.5: A pair of Ttk Radiobutton widgets'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：一对Ttk Radiobutton小部件
- en: 'The following code shows how to create these buttons:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何创建这些按钮：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To group `Radiobutton` widgets, you simply need to assign them all the same
    control variable, then add a distinct `value` to each button. In our example,
    we've also grouped them on the same parent widget, but this is merely for visual
    reasons and not strictly necessary.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要分组`Radiobutton`小部件，您只需将它们都分配给相同的控制变量，然后为每个按钮添加一个不同的`value`。在我们的例子中，我们还将它们分组在同一个父小部件上，但这只是为了视觉原因，并不是严格必要的。
- en: 'This table shows some of the various arguments you can use with a `Radiobutton`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此表显示了您可以与`Radiobutton`一起使用的各种参数：
- en: '| Argument | Values | Description |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `variable` | Control variable | A variable to be bound to the button''s selected
    state |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `variable` | 控制变量 | 绑定到按钮选中状态的变量 |'
- en: '| `value` | Any | A value to set the variable to when the button is selected
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `value` | 任何 | 当按钮被选中时设置变量的值 |'
- en: '| `command` | Python function | A callback to execute when the button is clicked
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `command` | Python函数 | 当按钮被点击时执行的回调函数 |'
- en: '| `text` | String | The label connected to the radio button |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 字符串 | 连接到单选按钮的标签 |'
- en: '| `textvariable` | `StringVar` | A variable bound to the button''s label text
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `textvariable` | `StringVar` | 绑定到按钮标签文本的变量 |'
- en: '| `underline` | Integer | Index of a character in `text` to underline |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `underline` | 整数 | `text`中要下划线的字符索引 |'
- en: The Combobox widget
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Combobox小部件
- en: 'In *Chapter 1*, *Introduction to Tkinter*, we learned about a couple of options
    for providing a selection between distinct options: the `Listbox` and `OptionMenu`
    widgets. Ttk offers a new widget for this purpose, `Combobox`. The `Combobox`
    widget is an `Entry` widget that has a drop-down listbox added. It not only allows
    for mouse selection, but also keyboard entry. Although it may seem like `OptionMenu`
    is a better fit for our application in some ways, we''re going to exploit the
    `Combobox` widget''s keyboard functionality to build a superior drop-down widget.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*Tkinter简介*中，我们学习了提供不同选项之间选择的一两种方法：`Listbox`和`OptionMenu`小部件。Ttk为此目的提供了一个新小部件，`Combobox`。`Combobox`小部件是一个带有下拉列表框的`Entry`小部件。它不仅允许鼠标选择，还允许键盘输入。尽管在某些方面`OptionMenu`可能更适合我们的应用程序，但我们将利用`Combobox`小部件的键盘功能来构建一个更高级的下拉小部件。
- en: 'We can create a `Combobox` widget like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样创建一个`Combobox`小部件：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running that code will give us a combo box that looks something like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将给我们一个看起来像这样的组合框：
- en: '![](img/B17578_03_06.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_03_06.png)'
- en: 'Figure 3.6: A Ttk Combobox widget'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：一个Ttk Combobox小部件
- en: Note that while we can specify a list of possible values to populate the drop-down
    listbox, the `Combobox` widget is not limited to those values. Users can type
    any text they wish into the box and the bound variable will be updated accordingly.
    By default, the `Combobox` is not suited to a list of values that must remain
    constrained to a set list; however, in *Chapter 5*, *Reducing User Error with
    Validation and Automation*, we'll learn how to address this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们可以指定一个可能的值列表来填充下拉列表框，但`Combobox`小部件并不限于这些值。用户可以在框中输入任何他们想要的文本，并且绑定的变量将相应地更新。默认情况下，`Combobox`不适合必须保持约束在固定列表中的值列表；然而，在*第5章*，*通过验证和自动化减少用户错误*中，我们将学习如何解决这个问题。
- en: 'This table shows some of the common arguments used with a `Combobox`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此表显示了与`Combobox`一起使用的常见参数：
- en: '| Argument | Values | Description |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `textvariable` | `StringVar` | Variable bound to the contents of the `Combobox`
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `textvariable` | `StringVar` | 绑定到`Combobox`内容的变量 |'
- en: '| `values` | List of strings | Values to populate the drop-down `listbox` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `values` | 字符串列表 | 填充下拉`listbox`的值 |'
- en: '| `postcommand` | Python function | Callback to run just before the `listbox`
    is displayed |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `postcommand` | Python函数 | 在`listbox`显示之前运行的回调函数 |'
- en: '| `justify` | `left`, `right`, or `center` | Alignment of text in the box |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `justify` | `left`、`right`或`center` | 框中文本的对齐方式 |'
- en: The Text widget
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Text小部件
- en: The `Text` widget, which we have already met in *Chapter 1*, *Introduction to
    Tkinter*, is the only widget we'll use that *does not* have a Ttk version. While
    this widget is most often used for multi-line text entry, it actually offers much
    more than that. The `Text` widget can be used to display or edit text that contains
    images, multicolored text, hyperlink-style clickable text, and much more.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*第1章*，*Tkinter简介*中遇到过的`Text`小部件是我们将使用的唯一没有Ttk版本的小部件。虽然这个小部件最常用于多行文本输入，但它实际上提供了更多功能。`Text`小部件可以用来显示或编辑包含图像、多色文本、超链接样式可点击文本等的文本。
- en: 'We can add one to an application as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样向一个应用程序添加一个：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The above code will produce something that looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成类似以下的内容：
- en: '![](img/B17578_03_07.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_03_07.png)'
- en: 'Figure 3.7: A Tk Text widget'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：Tk Text小部件
- en: 'The `Text` widget has a large number of arguments we can specify to control
    its appearance and behavior. Some of the more useful ones are listed in this table:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text`小部件有大量我们可以指定的参数来控制其外观和行为。其中一些更有用的参数列在这个表中：'
- en: '| Argument | Values | Description |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `height` | Integer | Height of the widget in lines of text. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `height` | 整数 | 小部件的高度，以文本行数表示。 |'
- en: '| `width` | Integer | Width of the widget in number of characters. For variable-width
    fonts, the width of a "0" character is used to calculate the width. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `width` | 整数 | 小部件的宽度，以字符数表示。对于可变宽度字体，使用“0”字符的宽度来计算宽度。 |'
- en: '| `undo` | Boolean | Activates or deactivates the undo functionality. Undo
    and redo actions are activated using the platform''s default shortcuts. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `undo` | 布尔值 | 激活或停用撤销功能。撤销和重做操作使用平台默认快捷键激活。 |'
- en: '| `maxundo` | Integer | Maximum number of edits that will be stored for undo.
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `maxundo` | 整数 | 将存储的撤销操作的最大数量。 |'
- en: '| `wrap` | `none`, `char`, or `word` | Specifies how a line of text will be
    broken and wrapped when it exceeds the width of the widget. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `wrap` | `none`、`char`或`word` | 指定当文本行超出小部件宽度时，文本行将如何断开和换行。 |'
- en: '| `spacing1` | Integer | The number of pixels to pad above each complete line
    of text. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `spacing1` | 整数 | 在每行文本上方填充的像素数。 |'
- en: '| `spacing2` | Integer | The number of pixels to pad between displayed lines
    of wrapped text. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `spacing2` | 整数 | 在显示的换行文本行之间填充的像素数。 |'
- en: '| `spacing3` | Integer | The number of pixels to pad below each complete line
    of text. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `spacing3` | 整数 | 在每行文本下方填充的像素数。 |'
- en: More advanced visual configuration of the `Text` widget is implemented using
    **tags**. We'll discuss tags in *Chapter 9*, *Improving the Look with Styles and
    Themes*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**标签**实现`Text`小部件的更高级视觉配置。我们将在*第9章*，*使用样式和主题改进外观*中讨论标签。
- en: Text widget indices
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Text小部件索引
- en: Remember that a `Text` widget cannot be bound to a control variable; to access,
    set, or clear its contents, we need to use its `get()`, `insert()`, and `delete()`
    methods, respectively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`Text`小部件不能绑定到控制变量；要访问、设置或清除其内容，我们需要分别使用其`get()`、`insert()`和`delete()`方法。
- en: 'When reading or modifying with these methods, you are required to pass in one
    or two **index values** to select the character or range of characters that you''re
    operating on. These index values are strings that can take any of the following
    formats:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这些方法读取或修改时，您需要传递一个或两个**索引值**来选择您正在操作的字符或字符范围。这些索引值是字符串，可以采用以下任何一种格式：
- en: The line number and character number separated by a dot. Lines are numbered
    from 1 and characters from 0, so the first character on the first line is `1.0`,
    while the twelfth character on the fourth line would be `4.11`. Note that a *line*
    is determined by the presence of a newline character; a wrapped line of text is
    still only considered one line for index purposes.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行号和字符号由点分隔。行从1开始编号，字符从0开始，因此第一行的第一个字符是`1.0`，而第四行的第十二个字符是`4.11`。请注意，*行*由换行符的存在确定；换行文本行在索引目的上仍然只被认为是一行。
- en: The string literal `end`, or the Tkinter constant `END`, indicating the end
    of the text.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串字面量`end`，或Tkinter常量`END`，表示文本的末尾。
- en: 'A numerical index plus one of the words `linestart`, `lineend`, `wordstart`,
    or `wordend`, indicating the start or end of the line or word relative to the
    numerical index. For example:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数值索引加上单词`linestart`、`lineend`、`wordstart`或`wordend`之一，表示相对于数值索引的行或单词的开始或结束。例如：
- en: '`6.2 wordstart` would be the start of the word containing the third character
    on line 6'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.2 wordstart`将是包含第6行第三个字符的单词的开始'
- en: '`2.0 lineend` would be the end of line 2'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.0 lineend`将是第2行的末尾'
- en: 'Any of the preceding, a plus or minus operator, and a number of characters
    or lines. For example:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何前面的内容，一个加号或减号运算符，以及一定数量的字符或行。例如：
- en: '`2.5 wordend - 1 chars` would be the character before the end of the word containing
    the sixth character on line 2'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.5 wordend - 1 chars`将是包含第2行第6个字符的单词结束前的字符'
- en: 'The following example shows these indices in action:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这些索引的实际应用：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note in the last example that we deleted two characters in order to delete the
    last character. The `Text` widget automatically appends a newline to the end of
    its text content, so we always need to remember to account for that extra character
    when dealing with indices or the extracted text.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在最后一个例子中，我们删除了两个字符以删除最后一个字符。`Text`小部件会自动在其文本内容末尾添加一个换行符，因此我们始终需要记住在处理索引或提取的文本时考虑到这个额外的字符。
- en: Remember, these indices should be *strings*, not float values! Float values
    will sometimes work due to implicit type casting, but don't rely on that behavior.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些索引应该是**字符串**，而不是浮点值！由于隐式类型转换，浮点值有时可能工作，但不要依赖这种行为。
- en: The Button widget
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮小部件
- en: 'The Ttk `Button` is a simple clickable pushbutton that can activate a callback
    function. It appears something like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk的`Button`是一个简单的可点击的按钮，可以激活回调函数。它看起来像这样：
- en: '![](img/B17578_03_08.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_03_08.png)'
- en: 'Figure 3.8: A Ttk Button widget'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：一个Ttk按钮小部件
- en: 'We can create one like so:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个如下所示：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The button is a pretty straightforward widget, but it has a few options that
    can be used to configure it. These are shown in the table below:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是一个相当直观的小部件，但它有一些可以用来配置它的选项。这些选项在下表中展示：
- en: '| Arguments | Values | Description |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `text` | String | Label text on the button. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 字符串 | 按钮上的标签文本。 |'
- en: '| `textvariable` | `StringVar` | Variable bound to the label text of the button.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `textvariable` | `StringVar` | 绑定到按钮标签文本的变量。 |'
- en: '| `command` | Python function | Callback to be executed when the button is
    clicked. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `command` | Python函数 | 当按钮被点击时执行的回调。 |'
- en: '| `default` | `normal`, `active`, `disabled` | If the button executes when
    `Enter` is pushed. `active` means it will execute in response to `Enter`, `normal`
    means it will only if selected first, and `disabled` means it will not respond
    to `Enter`. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `default` | `normal`，`active`，`disabled` | 如果按钮在按下`Enter`键时执行。`active`表示它将在响应`Enter`时执行，`normal`表示只有在首先选中时才会执行，`disabled`表示它不会响应`Enter`。
    |'
- en: '| `underline` | Integer | Index of a character in `text` to underline. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `underline` | 整数 | `text`中要下划线的字符索引。 |'
- en: Buttons can also be configured to display images rather than text. We'll learn
    more about that in *Chapter 9*, *Improving the Look with Styles and Themes*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮也可以配置为显示图像而不是文本。我们将在**第9章**，**使用样式和主题改进外观**中了解更多。
- en: The LabelFrame widget
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LabelFrame小部件
- en: In *Chapter 1*, *Introduction to Tkinter*, we used the `Frame` widget to group
    together our widgets. Ttk offers us a more powerful option in the `LabelFrame`,
    which provides a frame with a border and a label. This is a very useful widget
    to provide visual grouping for widgets in our GUI.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第1章**，**Tkinter简介**中，我们使用了`Frame`小部件来组合我们的小部件。Ttk为我们提供了一个更强大的选项`LabelFrame`，它提供了一个带有边框和标签的框架。这是一个非常实用的工具，可以为我们GUI中的小部件提供视觉分组。
- en: 'This code shows an example of a `LabelFrame`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了`LabelFrame`的一个示例：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The resulting GUI would look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的GUI将看起来像这样：
- en: '![](img/B17578_03_09.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_03_09.png)'
- en: 'Figure 3.9: A Ttk LabelFrame widget'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：一个Ttk LabelFrame小部件
- en: 'The `LabelFrame` widget offers us a few arguments for configuration, shown
    here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`LabelFrame`小部件为我们提供了一些配置参数，如下所示：'
- en: '| Argument | Values | Description |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `text` | String | The text of the label to display. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 字符串 | 要显示的标签文本。 |'
- en: '| `labelanchor` | Cardinal direction | Where to anchor the text label. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `labelanchor` | 基本方向 | 文本标签的锚点位置。 |'
- en: '| `labelwidget` | `ttk.Label` object | A label widget to use for the label.
    Overrides `text`. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `labelwidget` | `ttk.Label`对象 | 用于标签的标签小部件。覆盖`text`。 |'
- en: '| `underline` | Integer | The index of a character in `text` to underline.
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `underline` | 整数 | `text`中要下划线的字符索引。 |'
- en: As you can see, we can configure the label of the `LabelFrame` either by specifying
    the `text` argument, or by creating a `Label` widget and assigning it using the
    `labelwidget` argument. The latter case may be preferable if we want to take advantage
    of some of the `Label` widget's advanced features, such as binding a `textvariable`
    to it. If we use it, it will override the `text` argument.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以通过指定`text`参数或创建一个`Label`小部件并使用`labelwidget`参数来配置`LabelFrame`的标签。如果我们想利用`Label`小部件的一些高级功能，例如将其`textvariable`绑定，后者可能更可取。如果我们使用它，它将覆盖`text`参数。
- en: Tkinter and Ttk contain many more widgets, some of which we'll encounter later
    in this book. Python also ships with a widget library called `tix`, which contains
    several dozen widgets. However, `tix` is very outdated, and we won't be covering
    it in this book. You should know that it exists, though.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter和Ttk包含许多更多的小部件，其中一些我们将在本书的后面遇到。Python还附带了一个名为`tix`的小部件库，其中包含几十个小部件。然而，`tix`非常过时，我们不会在本书中介绍它。尽管如此，你应该知道它的存在。
- en: Implementing the application
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用实现
- en: 'So far, we''ve learned some Tkinter basics, researched the user''s needs, designed
    our application, and determined which Ttk widgets will be useful in our application.
    Now it''s time to put all of this together and actually code the first version
    of the ABQ Data Entry application. Recall our design from *Chapter 2*, *Designing
    GUI Applications*, shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了Tkinter的基本知识，研究了用户的需求，设计了我们的应用，并确定了哪些Ttk小部件将在我们的应用中有用。现在是时候将这些整合起来，并实际编写ABQ数据输入应用的第一版。回想一下我们的设计，来自*第2章*，*设计GUI应用*，如下所示：
- en: '![](img/B17578_03_10.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_03_10.png)'
- en: 'Figure 3.10: The ABQ Data Entry application layout'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：ABQ数据输入应用布局
- en: Take a moment to review the widgets we need to create, and we'll begin coding.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间回顾我们需要创建的小部件，然后我们将开始编码。
- en: First steps
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步
- en: 'Open a new file in your editor called `data_entry_app.py`, and let''s begin
    like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开一个名为`data_entry_app.py`的新文件，让我们从这里开始：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our script starts with a **docstring**, as all Python scripts should. This string
    at a minimum should give the name of the application to which the file belongs,
    and may also include notes about usage, authorship, or other items a future maintainer
    would need to know.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本以一个**文档字符串**开始，就像所有Python脚本应该做的那样。这个字符串至少应该给出文件所属的应用程序的名称，也可以包括有关使用、作者或其他未来维护者需要了解的项目。
- en: 'Next, we''re importing the Python modules that we''ll need for this application;
    these are:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将导入我们将在本应用中需要的Python模块；这些是：
- en: '`tkinter` and `ttk`, of course, for our GUI items'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，`tkinter`和`ttk`用于我们的GUI元素
- en: The `datetime` class, from the `datetime` module, which we'll use to generate
    a datestring for the filename
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`datetime`模块的`datetime`类，我们将用它来生成文件名的日期字符串
- en: The `Path` class, from the `pathlib` module, which is used for some file operations
    in our save routine
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`pathlib`模块的`Path`类，用于我们在保存例程中的某些文件操作
- en: The `csv` module, which we'll use to interact with the CSV file
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用的`csv`模块，用于与CSV文件交互
- en: 'Next, let''s create some global variables that the app will use to keep track
    of information:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些全局变量，应用将使用这些变量来跟踪信息：
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `variables` dictionary will hold all of the form's control variables. Keeping
    them in a dictionary will make it a little easier to manage them and will keep
    our global namespace lean and clean. The `records_saved` variable will store how
    many records the user has saved since opening the app.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables`字典将保存所有表单的控制变量。将它们保存在字典中将使管理它们变得更容易，并将我们的全局命名空间保持精简和整洁。`records_saved`变量将存储用户自打开应用以来保存的记录数。'
- en: 'Now it''s time to create and configure the root window:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建和配置根窗口了：
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We've set the window title for the application and also configured its layout
    grid so that the first column is allowed to expand. The root window will only
    have one column, but by setting this it will allow the form to remain centered
    on the application if the window is expanded. Without it, the form would be stuck
    to the left side of the window when the window is expanded.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已设置应用程序的窗口标题并配置了其布局网格，以便允许第一列扩展。根窗口将只有一个列，但通过设置这一点，它将允许表单在窗口扩展时保持居中。如果没有它，当窗口扩展时，表单将固定在窗口的左侧。
- en: 'Now we''ll add a heading for the application:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为应用添加一个标题：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because we won't need to refer to this widget again, we won't bother assigning
    it to a variable. This also allows us to call `grid()` on the `Label` on the same
    line, keeping our code more concise and the namespace less cluttered. We'll do
    this for most of the widgets in the application, unless there is some reason we
    may need to interact with the widget elsewhere in the code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要再次引用这个小部件，我们不会费心将其分配给变量。这也允许我们在同一行上调用`Label`上的`grid()`，使我们的代码更加简洁，命名空间更加清晰。我们将为应用程序中的大多数小部件这样做，除非我们有理由可能在代码的其他地方与之交互。
- en: Note that we used `TkDefaultFont` as the font family value for this label widget.
    This is an alias defined in Tkinter that points to the default window font on
    your platform. We'll learn more about fonts in *Chapter 9*, *Improving the Look
    with Styles and Themes*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`TkDefaultFont`作为这个标签小部件的字体家族值。这是Tkinter中定义的一个别名，指向平台上的默认窗口字体。我们将在*第9章*，*通过样式和主题改进外观*中了解更多关于字体信息。
- en: Building the data record form
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建数据记录表
- en: 'With the initial application window set up, let''s start building the actual
    data entry form. We''ll create a frame to contain the entire data record form,
    called `drf`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好初始应用程序窗口后，让我们开始构建实际的数据输入表单。我们将创建一个框架来包含整个数据记录表，称为`drf`：
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `drf` frame is added to the main window with a bit of horizontal padding,
    and the `sticky` argument ensures that it will stretch when the containing column
    is stretched. We're also going to configure its grid to expand the first column.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`drf`框架以一点水平填充添加到主窗口中，`sticky`参数确保它在包含列拉伸时也会拉伸。我们还将配置其网格以扩展第一列。'
- en: For windows or frames using a grid layout, if you want to make the child widgets
    stretch when the parent is stretched, you need to make sure both the container
    will expand (using `columnconfigure` and `rowconfigure` on the parent) *and* the
    child widget will expand with the container (using `sticky` when you call `grid()`
    on the child widget).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用网格布局的窗口或框架，如果你想在父级拉伸时使子小部件拉伸，你需要确保容器将扩展（在父级上使用`columnconfigure`和`rowconfigure`），*并且*子小部件将与容器一起扩展（在调用子小部件上的`grid()`时使用`sticky`）。
- en: The Record Information section
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录信息部分
- en: 'The first section of our form is the `Record Information` section. Let''s create
    and configure a `LabelFrame` to store that:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们表单的第一部分是`记录信息`部分。让我们创建并配置一个`LabelFrame`来存储它：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We start by creating a Ttk `LabelFrame` widget with the data record form as
    its parent. We add it to the parent's grid, setting the `sticky` argument so that
    it will expand when the window is resized. Each frame of this form is going to
    have three columns of input widgets, and we want each column to expand evenly
    to fill the width of the frame. So, we have used a `for` loop to set the `weight`
    attribute of each column to `1`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个Ttk `LabelFrame`小部件，将其数据记录表作为其父级。我们将其添加到父级的网格中，设置`sticky`参数，以便在窗口大小调整时它将扩展。这个表单的每一部分都将有三列输入小部件，我们希望每一列均匀扩展以填充框架的宽度。因此，我们使用了一个`for`循环来设置每一列的`weight`属性为`1`。
- en: 'Now we can begin creating the contents of the frame, starting with the first
    input widget, the `Date` field:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建框架的内容，从第一个输入小部件，即`日期`字段开始：
- en: '[PRE18]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we created a control variable and put it in the `variables` dictionary.
    Then we created our `Label` widget for the `Date` field and added it to the `LabelFrame`
    widget's grid. We're going to use explicit `row` and `column` values here, even
    when it's not strictly necessary, because we're going to be placing objects a
    little out of order. Without explicit coordinates, things could get confusing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个控制变量并将其放入`variables`字典中。然后我们为`日期`字段创建了我们的`Label`小部件，并将其添加到`LabelFrame`小部件的网格中。即使不是严格必要的，我们也将使用显式的`row`和`column`值，因为我们将要放置一些稍微偏离顺序的对象。没有显式坐标，事情可能会变得混乱。
- en: Finally, we create the `Entry` widget, passing in the control variable. Note
    that we aren't going to save any references to our widgets if we can use a variable
    to store the value. This will keep the code more concise. We've added our widget
    to the grid, placing it *below* its label by specifying the first column of the
    next row. For both the `Entry` and the `Label`, we've used the `sticky` argument
    to make sure the widget stretches when the GUI is expanded.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个`Entry`小部件，传递了控制变量。请注意，如果我们可以使用变量来存储值，我们不会保存我们小部件的任何引用。这将使代码更加简洁。我们已经将我们的小部件添加到网格中，通过指定下一行的第一列将其放置在其标签的下方。对于`Entry`和`Label`，我们使用了`sticky`参数来确保小部件在GUI扩展时拉伸。
- en: 'Now let''s add the rest of the first line, the `Time` and `Technician` fields:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加第一行的其余部分，`Time`和`Technician`字段：
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once again, we create a variable, `Label`, and input widget for each item. Recall
    that the `Combobox` widget takes a list of strings for its `values` argument,
    which will populate the drop-down part of the widget. That takes care of the first
    row.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们为每个项目创建一个变量和输入小部件。回想一下，`Combobox`小部件使用字符串列表作为其`values`参数，这将填充小部件的下拉部分。这样就处理了第一行。
- en: 'On the second row, we''ll start with the `Lab` inputs:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们将从`Lab`输入开始：
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Like before, we've created the control variable and `Label`, but for the input
    widget we've created a `Frame` to hold the three `Radiobutton` widgets. We're
    also creating our `Radiobutton` widgets using a `for` loop to keep the code more
    concise and consistent.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们创建了控制变量和`Label`，但对于输入小部件，我们创建了一个`Frame`来容纳三个`Radiobutton`小部件。我们还在使用`for`循环创建`Radiobutton`小部件，以使代码更简洁和一致。
- en: The `pack()` geometry manager comes in handy here because we can populate from
    left to right without having to explicitly manage column numbers. The `expand`
    argument causes the widget to use extra space when the window is resized; this
    will help our buttons to utilize available space and not be scrunched into the
    left side of the window.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack()`几何管理器在这里很有用，因为我们可以从左到右填充，而无需显式管理列号。`expand`参数使得小部件在窗口大小调整时使用额外空间；这将帮助我们的按钮利用可用空间，而不会挤到窗口的左侧。'
- en: 'Now let''s do the remaining portion of line two, the `Plot` and `Seed Sample`
    fields:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们完成第二行的剩余部分，`Plot`和`Seed Sample`字段：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have the same thing going on here: create a variable, create a `Label`,
    create the input widget. Note that for the `Plot` values we''re generating a list
    using `range()` to keep our code concise.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情与之前相同：创建一个变量，创建一个`Label`，创建输入小部件。注意，对于`Plot`值，我们使用`range()`生成一个列表，以使代码更简洁。
- en: The Environment Data section
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这是环境数据部分
- en: 'The next part of the form is the `Environment Data` frame. Let''s begin that
    section as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的下一部分是`Environment Data`框架。让我们开始这个部分如下：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is exactly what we did for the last `LabelFrame`, with only the names
    updated. Let''s start populating it with the `Humidity`, `Light`, and `Temperature`
    widgets:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们为最后一个`LabelFrame`所做的事情，只是名称有所更新。让我们开始用`Humidity`、`Light`和`Temperature`小部件填充它：
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Good! Now, for the second row of this section, we only need to add in the `Equipment
    Fault` check button:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在，对于本节第二行，我们只需要添加`Equipment Fault`复选框：
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first three values are all floating-point numbers, so we''re using `DoubleVar`
    control variables and `Spinbox` widgets for entry. Don''t forget to populate the
    `from_`, `to`, and `increment` values for the `Spinbox` widgets, so that the arrows
    behave properly. Our `Checkbutton` takes a `BooleanVar` control variable and doesn''t
    need a `Label` widget due to its built-in label. Also, note that because we''ve
    started a new frame, our rows and columns for the grid start over. This is a benefit
    of breaking up the form into smaller frames: we don''t have to keep track of ever-increasing
    row or column numbers.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个值都是浮点数，所以我们使用`DoubleVar`控制变量和`Spinbox`小部件进行输入。别忘了为`Spinbox`小部件填充`from_`、`to`和`increment`值，以便箭头能够正确地工作。我们的`Checkbutton`使用`BooleanVar`控制变量，由于它内置了标签，所以不需要`Label`小部件。注意，因为我们开始了一个新的框架，我们的网格行和列从零开始。这是将表单拆分成更小框架的好处：我们不必跟踪不断增长的行或列号。
- en: The Plant Data section
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这是植物数据部分
- en: 'We''ll create the next frame, `Plant Data`, just like the other two:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建下一个框架，`Plant Data`，就像其他两个一样：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, having created and configured the frame, let''s add in the first row of
    inputs, `Plants`, `Blossoms`, and `Fruit`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建并配置了框架后，让我们添加第一行的输入项，`Plants`、`Blossoms`和`Fruit`：
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is nothing really new here, except that, since we're using `IntVar` control
    variables, we've set the `Spinbox` increment to `1`. That won't really stop anyone
    from entering a decimal (or any arbitrary string for that matter), but at least
    the buttons won't steer the user wrong. In *Chapter 5*, *Reducing User Error with
    Validation and Automation*, we'll see how to enforce `increment` more thoroughly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么真正新的东西，只是因为我们使用`IntVar`控制变量，我们将`Spinbox`的增量设置为`1`。这并不能真正阻止任何人输入小数（或任何任意的字符串），但至少按钮不会误导用户。在*第5章*，*通过验证和自动化减少用户错误*中，我们将看到如何更彻底地执行`increment`。
- en: 'And now finally our last row of inputs, `Min Height`, `Max Height`, and `Med
    Height`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后的一行输入项，`Min Height`、`Max Height`和`Med Height`：
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've made three more `DoubleVar` objects, three more labels, and three more
    `Spinbox` widgets. If this feels a little repetitive, don't be surprised; GUI
    code can tend to be quite repetitive. In *Chapter 4*, *Organizing Our Code with
    Classes*, we'll find ways to reduce this repetitiveness.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个更多的`DoubleVar`对象，三个更多的标签和三个更多的`Spinbox`小部件。如果这感觉有点重复，不要感到惊讶；GUI代码往往会有点重复。在*第四章*，*使用类组织我们的代码*中，我们将找到减少这种重复性的方法。
- en: Finishing the GUI
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成GUI
- en: 'That finishes our three info sections; now we need to add the `Notes` input.
    We''ll add it directly to the `drf` frame with a label, like so:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的三个信息部分；现在我们需要添加“笔记”输入。我们将它直接添加到`drf`框架中，并添加一个标签，如下所示：
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since we cannot associate a control variable with the `Text` widget, we'll need
    to keep a regular variable reference to it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法将控制变量与`Text`小部件关联，我们需要保留一个常规变量引用。
- en: When you do need to save a reference to a widget, don't forget to call `grid()`
    in a separate statement! Since `grid()` (and other geometry manager methods) returns
    `None`, if you create and position the widget in one statement your saved widget
    reference will just be `None`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要保存小部件的引用时，不要忘记在单独的语句中调用`grid()`！由于`grid()`（和其他几何管理方法）返回`None`，如果你在一个语句中创建并定位小部件，你保存的小部件引用将只是`None`。
- en: 'We''re almost finished with the form! We just need to add some buttons:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了表单！我们只需要添加一些按钮：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To keep the form's grid layout simpler, we've packed the two buttons into a
    sub-frame, using `pack()` with the `side` argument to keep them over on the right.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使表单的网格布局更简单，我们将两个按钮打包到一个子框架中，使用`pack()`函数的`side`参数将它们保持在右侧。
- en: 'That finishes the data record form; to finish out the application GUI, we only
    need to add in a status bar with an associated variable, like so:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了数据记录表单；为了完成应用程序的GUI，我们只需要添加一个带有相关变量的状态栏，如下所示：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The status bar is simply a `Label` widget, which we've placed on the `root`
    window's grid at row `99` to ensure that it stays at the bottom in case of any
    future additions to the application. Note that we have not added the status variable
    to the `variables` dictionary; that dictionary is reserved for variables that
    will hold user input. This variable is just going to be used to display messages
    to the user.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 状态栏只是一个`Label`小部件，我们将其放置在`root`窗口的网格的第`99`行，以确保在应用程序未来添加任何内容时它保持在底部。请注意，我们没有将状态变量添加到`variables`字典中；该字典保留用于存储用户输入的变量。这个变量只是用来向用户显示消息。
- en: Writing the callback functions
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写回调函数
- en: 'Now that our layout is done, let''s work on creating the functionality of our
    application. Our form has two buttons that need callback functions: `Reset` and
    `Save`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了布局，让我们着手创建应用程序的功能。我们的表单有两个需要回调函数的按钮：“重置”和“保存”。
- en: The Reset function
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置函数
- en: The job of our reset function is to return the entire form to a blank state
    so the user can enter in more data. We'll need this function not only as a callback
    to the `Reset` button, but also to prepare the form for the next record after
    the user saves a record. Otherwise, the user would have to manually delete and
    overwrite the data in each field for every new record.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 重置函数的职责是将整个表单恢复到空白状态，以便用户可以输入更多数据。我们不仅需要这个函数作为“重置”按钮的回调，还需要在用户保存记录后为下一个记录准备表单。否则，用户将不得不手动删除并覆盖每个字段的每个新记录中的数据。
- en: 'Since we''ll need to call the reset callback from the save callback, we need
    to write the reset function first. At the end of `data_entry_app.py`, start a
    new function like so:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要从保存回调中调用重置回调，我们需要先编写重置函数。在`data_entry_app.py`的末尾，开始一个新的函数，如下所示：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The function is called `on_reset()`. Recall from *Chapter 1*, *Introduction
    to Tkinter*, that, by convention, callback functions are typically named `on_<eventname>`,
    where `eventname` refers to the event that triggers it. Since this will be triggered
    by clicking the `Reset` button, we'll call it `on_reset()`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被命名为`on_reset()`。回想一下*第一章*，*Tkinter入门*，按照惯例，回调函数通常命名为`on_<事件名>`，其中`事件名`指的是触发该事件的事件。由于这将由点击“重置”按钮触发，我们将它命名为`on_reset()`。
- en: Inside the function, we need to reset all the widgets to an empty value. But
    wait! We didn't save references to any of the widgets, apart from the `Notes`
    input. What do we need to do?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们需要将所有小部件重置为空值。但是等等！我们没有保存任何小部件的引用，除了“笔记”输入。我们需要做什么？
- en: 'Simple: we reset all the *variables* to a blank string, like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们将所有**变量**重置为空字符串，如下所示：
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`StringVar`, `DoubleVar`, and `IntVar` objects can be set to a blank string,
    which will cause any widgets bound to them to be blank. `BooleanVar` variables
    will raise an exception if we try to do that, so instead we''ll check if our variable
    is a `BooleanVar` using Python''s built-in `isinstance()` function. If it is,
    we simply set it to `False`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringVar`、`DoubleVar` 和 `IntVar` 对象可以设置为空字符串，这将导致任何绑定到它们的部件变为空白。如果尝试这样做，`BooleanVar`
    变量将引发异常，因此我们将使用 Python 的内置 `isinstance()` 函数检查我们的变量是否是 `BooleanVar`。如果是，我们只需将其设置为
    `False`。'
- en: For the `Notes` input, we can use the `Text` widget's `delete()` method to clear
    its contents. This method takes a start and end location, just like the `get()`
    method does. The values `1.0` and `tk.END` indicate the entire contents of the
    widget. Recall from our earlier discussion of the `Text` widget that this index
    is the *string* `1.0`, *not* a float value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Notes` 输入，我们可以使用 `Text` 小部件的 `delete()` 方法来清除其内容。此方法接受一个起始位置和结束位置，就像 `get()`
    方法一样。值 `1.0` 和 `tk.END` 表示小部件的全部内容。回顾我们之前对 `Text` 小部件的讨论，此索引是 *字符串* `1.0`，*不是*
    浮点值。
- en: 'That''s all we need in our reset callback. To bind it to the button, use the
    button''s `configure()` method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在重置回调函数中需要做的所有事情。要将它绑定到按钮，请使用按钮的 `configure()` 方法：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `configure()` method can be called on any Tkinter widget to change its properties.
    It accepts the same keyword arguments as the widget's constructor.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure()` 方法可以在任何 Tkinter 小部件上调用以更改其属性。它接受与部件构造函数相同的关键字参数。'
- en: The Save callback
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存回调
- en: 'Our last bit of functionality, and the most important, is the `Save` callback.
    Recall from our program specification that our application needs to append the
    entered data to a **CSV** (**comma-separated values**) file with the filename
    `abq_data_record_CURRENTDATE.csv`, where `CURRENTDATE` is the date in ISO format
    (year-month-day). The CSV should be created if it doesn''t exist, and have the
    column headers written to the first row. Therefore, this function needs to do
    the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一点功能，也是最重要的，是 `Save` 回调。回顾我们的程序规范，我们的应用程序需要将输入的数据追加到名为 `abq_data_record_CURRENTDATE.csv`
    的 **CSV** （**逗号分隔值**） 文件中，其中 `CURRENTDATE` 是 ISO 格式的日期（年-月-日）。如果文件不存在，则应创建该文件并将列标题写入第一行。因此，此函数需要执行以下操作：
- en: Determine the current date and generate the filename
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定当前日期并生成文件名
- en: Determine if the file exists, and if not create it and write a header row
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定文件是否存在，如果不存在，则创建它并写入标题行
- en: Extract the data from the form and do any clean-up necessary
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从表单中提取数据并执行任何必要的清理
- en: Append the row of data to the file
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据行追加到文件中
- en: Increment `records_saved` and alert the user that the record was saved
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加记录已保存的数量，并通知用户记录已保存
- en: Reset the form for the next record
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为下一条记录重置表单
- en: 'Let''s start the function out this way:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下方式开始这个函数：
- en: '[PRE34]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once again, we're using the `on_<eventname>` naming convention. The first thing
    we've done is declared `records_saved` as a global variable. If we don't do this,
    Python will interpret the name `records_saved` as a local variable and we won't
    be able to update it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用了 `on_<eventname>` 命名约定。我们首先声明 `records_saved` 为一个全局变量。如果我们不这样做，Python
    将将名称 `records_saved` 解释为局部变量，我们将无法更新它。
- en: 'Modifying global variables is generally bad form, but Tkinter doesn''t really
    give us many options here: we can''t use a return value to update the variable,
    because this is a callback function that is called in response to an event, not
    at any place in our code where we have direct access to `records_saved`. In *Chapter
    4*, *Organizing Our Code with Classes*, we''ll learn a better way to implement
    this functionality without global variables; for now, though, we''re stuck with
    it.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 修改全局变量通常是不好的做法，但 Tkinter 在这里实际上并没有给我们太多选择：我们无法使用返回值来更新变量，因为这是一个在响应事件时调用的回调函数，而不是我们代码中的任何地方，我们都有直接访问
    `records_saved` 的权限。在 *第 4 章*，*使用类组织我们的代码* 中，我们将学习一种更好的方法来实现此功能而不使用全局变量；然而，现在我们仍然被困在这里。
- en: 'Next, let''s figure out the details of the filename and whether it exists or
    not:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确定文件名的细节以及它是否存在：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `datetime.today()` function returns a `Date` object for the current day,
    and its `strftime()` method allows us to format that date into a string in any
    way we specify. The syntax for `strftime()` has its roots in C programming, so
    it's rather cryptic in some cases; but hopefully it is clear that `%Y` means year,
    `%m` means month, and `%d` means day. This will return the date in ISO format;
    for example, 2021-10-31 for October 31, 2021.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime.today()`函数返回一个表示当前日期的`Date`对象，其`strftime()`方法允许我们将日期格式化为任何我们指定的字符串。`strftime()`的语法起源于C编程，所以在某些情况下可能相当晦涩；但希望它足够清晰，`%Y`表示年份，`%m`表示月份，`%d`表示日期。这将返回ISO格式的日期；例如，2021-10-31代表2021年10月31日。'
- en: With the `datestring` in hand, we can use it to build the filename for the day's
    CSV file. In the next line, `Path(filename).exists()` tells us whether the file
    exists in the current working directory. It does this by constructing a `Path`
    object using the filename, then calling its `exists()` method to see if the file
    is already on the filesystem. We'll save this information to a variable called
    `newfile`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有`datestring`后，我们可以用它来构建当天CSV文件的文件名。在下一行中，`Path(filename).exists()`告诉我们文件是否在当前工作目录中存在。它是通过使用文件名构造一个`Path`对象，然后调用其`exists()`方法来检查文件是否已经在文件系统中。我们将这个信息保存到一个名为`newfile`的变量中。
- en: 'Now it''s time to get the data from the form:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候从表单中获取数据了：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We're going to store the data in a new dictionary object called `data`. To do
    this, we'll iterate through our `variables` dictionary, calling `get()` on each
    variable. Of course, if there is an equipment fault, we want to skip the values
    for `Light`, `Humidity`, and `Temperature`, so we're first getting the value of
    `Equipment Fault` and checking it before those field values are being retrieved.
    If we do need to retrieve a value from the variable, we'll do this in a `try`
    block. Remember that variables will raise a `TclError` if the `get()` method is
    called when there is an invalid value in them, so we need to handle that exception.
    In this case, we'll let the user know that there was a problem with that particular
    field and exit the function immediately.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据存储在一个名为`data`的新字典对象中。为此，我们将遍历我们的`variables`字典，对每个变量调用`get()`。当然，如果有设备故障，我们想要跳过`Light`、`Humidity`和`Temperature`字段的值，所以我们首先获取`Equipment
    Fault`的值并检查它，然后再检索这些字段值。如果我们确实需要从变量中检索值，我们将在`try`块中这样做。记住，如果变量中有无效值时调用`get()`方法，变量将引发`TclError`，因此我们需要处理这个异常。在这种情况下，我们将通知用户该特定字段存在问题并立即退出函数。
- en: Finally, we need to get the data from the `Notes` field using `get()`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使用`get()`方法从`Notes`字段获取数据。
- en: 'Now that we have the data, we need to write it to a CSV. Add the following
    code next:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，我们需要将其写入CSV文件。接下来添加以下代码：
- en: '[PRE37]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, we're opening the file using a context manager (the `with` keyword).
    Doing it this way ensures that the file will be closed when we exit the indented
    block. We're opening in *append* mode (indicated by the `a` argument to `open`),
    which means any data we write will simply be added to the end of whatever is already
    there. Note the `newline` argument, which we've set to an empty string. This is
    to work around a bug in the CSV module on Windows that causes an extra empty line
    to appear between each record. It does no harm on other platforms.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用上下文管理器（`with`关键字）打开文件。这样做可以确保当我们退出缩进的块时文件将被关闭。我们以*追加*模式打开（由`open`函数的`a`参数指示），这意味着我们写入的任何数据都将简单地添加到现有内容的末尾。注意`newline`参数，我们将其设置为空字符串。这是为了解决CSV模块在Windows上的一个bug，该bug会在每条记录之间出现额外的空行。在其他平台上这不会造成任何伤害。
- en: Inside the block, we need to create something called a **CSV Writer object**.
    The standard library `csv` module contains a few different types of objects that
    can write data into a CSV file. The `DictWriter` class is handy in that it can
    take a dictionary of values in any order and write them to the proper fields of
    the CSV, provided the first row contains the names of the columns. We can tell
    the `DictWriter` what those header values should be by passing it `data.keys()`,
    which is all the names of our data values.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块内部，我们需要创建一个名为**CSV Writer对象**的东西。标准库`csv`模块包含几种不同类型的对象，可以将数据写入CSV文件。`DictWriter`类很方便，因为它可以接受任何顺序的值字典，并将它们写入CSV的正确字段，前提是第一行包含列名。我们可以通过传递`data.keys()`来告诉`DictWriter`那些标题值应该是什么，这包含了我们数据值的所有名称。
- en: Append mode will create the file if it does not exist, but it won't write the
    header row automatically. Therefore, we need to check if the file is a new file
    (using the `newfile` value we found earlier), and if it is, we'll write the header
    row. The `DictWriter` object has a method for this, which causes it to just write
    a single row containing all the field names.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 追加模式将在文件不存在时创建文件，但不会自动写入标题行。因此，我们需要检查文件是否是新的文件（使用我们之前找到的`newfile`值），如果是，我们将写入标题行。`DictWriter`对象有一个用于此目的的方法，它将导致它只写入包含所有字段名称的单行。
- en: Finally, we can use the `DictWriter` object's `writerow()` method to pass in
    our dictionary of data to be written to the file. As we exit the indented block,
    Python closes the file and saves it to disk.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`DictWriter`对象的`writerow()`方法将我们的数据字典传递给要写入的文件。当我们退出缩进块时，Python会关闭文件并将其保存到磁盘。
- en: 'That leaves us with just a few final lines in the `on_save()` function:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了`on_save()`函数中的最后几行：
- en: '[PRE38]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, we'll increment the `records_saved` variable, then alert the user in
    the status bar how many records have been saved so far. This is good feedback
    that helps the user know their actions were successful. Finally, we call `on_reset()`
    to prepare the form for the next record to be entered.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将增加`records_saved`变量，然后在状态栏中通知用户到目前为止已保存了多少条记录。这是良好的反馈，有助于用户知道他们的操作是成功的。最后，我们调用`on_reset()`来为输入下一条记录准备表单。
- en: 'With the save method implemented, let''s go ahead and bind it to our button:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 保存方法实现后，让我们将其绑定到我们的按钮上：
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Last of all, let''s reset the form and launch the main event loop:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们重置表单并启动主事件循环：
- en: '[PRE40]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it, your first application for ABQ is finished and ready to go!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，您的第一个ABQ应用程序已经完成并准备好发布了！
- en: Finishing up and testing
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成并测试
- en: 'Before we send our application out into the world, let''s fire it up and give
    it a test:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将应用程序发送到世界之前，让我们先启动它并进行测试：
- en: '![](img/B17578_03_11.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_03_11.png)'
- en: 'Figure 3.11: Our first ABQ Data Entry application'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：我们的第一个ABQ数据录入应用程序
- en: Looking good! And it works, too. Go ahead and enter some test data and save
    it. Of course, this isn't the end – we haven't quite addressed everything on the
    program specification, and once users get their hands on the application, the
    feature requests will undoubtedly begin. But for now, we can celebrate the victory
    of a working MVP.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！而且它也真的能工作。请继续输入一些测试数据并保存它。当然，这并不是终点——我们还没有完全解决程序规格说明中的所有问题，一旦用户接触到应用程序，无疑会开始提出功能请求。但就目前而言，我们可以庆祝一个工作MVP的胜利。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Well, we've come a long way in this chapter! You took your design from a specification
    and some drawings to a running MVP of the application that already covers the
    basic functionality you need. You learned about basic Ttk widgets, such as `Entry`,
    `Spinbox`, `Combobox`, `Radiobutton`, and `Checkbutton`, as well as the Tkinter
    `Text` widget. You learned how to assemble these widgets into a complex but organized
    GUI using nested `LabelFrame` widgets, and how to save a file using a callback
    method.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在这一章中，我们已经走了很长的路！您将设计从规格说明和一些图纸变成了一个运行中的最小可行产品（MVP），该产品已经涵盖了您所需的基本功能。您学习了关于基本Ttk小部件，如`Entry`、`Spinbox`、`Combobox`、`Radiobutton`和`Checkbutton`，以及Tkinter的`Text`小部件。您学习了如何使用嵌套的`LabelFrame`小部件将这些小部件组装成一个复杂但有序的GUI，以及如何使用回调方法保存文件。
- en: In the next chapter, we're going to utilize classes and object-oriented programming
    techniques to clean up our code and expand the capabilities of our widgets.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用类和面向对象编程技术来清理我们的代码并扩展小部件的功能。
