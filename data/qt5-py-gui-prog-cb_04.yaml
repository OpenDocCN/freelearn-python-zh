- en: Chapter 4. Data and Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 数据和类
- en: 'In this chapter, we will use data and OOP classes using Python 3:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python 3中的数据和面向对象类：
- en: How to use StringVar()
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 StringVar()
- en: How to get data from a widget
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从小部件获取数据
- en: Using module-level global variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块级全局变量
- en: How coding in classes can improve the GUI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在课堂上编码来提升图形用户界面（GUI）
- en: Writing callback functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写回调函数
- en: Creating reusable GUI components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用GUI组件
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will save our GUI data into tkinter variables.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把我们的GUI数据保存到tkinter变量中。
- en: We will also start using **object-oriented programming** (**OOP**) to extend
    the existing tkinter classes in order to extend tkinter's built-in functionality.
    This will lead us into creating reusable OOP components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将开始使用**面向对象编程**（**OOP**）来扩展现有的tkinter类，以便扩展tkinter的内置功能。这将引导我们创建可重用的OOP组件。
- en: How to use StringVar()
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用 StringVar()
- en: There are built-in programming types in tkinter that differ slightly from the
    Python types we are used to programming with. StringVar() is one of those tkinter
    types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: tkinter 中内置了一些编程类型，这些类型与我们习惯的 Python 类型略有不同。StringVar() 就是这些 tkinter 类型之一。
- en: This recipe will show you how to use the StringVar() type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您展示如何使用 StringVar() 类型。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We are learning how to save data from the tkinter GUI into variables so we can
    use that data. We can set and get their values, very similar to the Java getter/setter
    methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在学习如何将 tkinter GUI 中的数据保存到变量中，以便我们可以使用这些数据。我们可以设置和获取它们的值，这与 Java 的 getter/setter
    方法非常相似。
- en: 'Here are some of the available types of coding in tkinter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是tkinter中可用的一些编码类型：
- en: '| `strVar = StringVar()` | # Holds a string; the default value is an empty
    string "" |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `strVar = StringVar()` | # 存储一个字符串；默认值是一个空字符串 "" |'
- en: '| `intVar = IntVar()` | # Holds an integer; the default value is 0 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `intVar = IntVar()` | # 存储一个整数；默认值是 0 |'
- en: '| `dbVar = DoubleVar()` | # Holds a float; the default value is 0.0 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `dbVar = DoubleVar()` | # 存储一个浮点数；默认值是 0.0 |'
- en: '| `blVar = BooleanVar()` | # Holds a Boolean, it returns 0 for false and 1
    for true |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `blVar = BooleanVar()` | # 存储布尔值，它返回0表示假，1表示真 |'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Different languages call numbers with decimal points, floats, or doubles. Tkinter
    calls a DoubleVar for what in Python is called a float datatype. Depending on
    the level of precision, floats and double data can be different. Here, we are
    translating the tkinter DoubleVar into what Python turns into a Python float type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言用小数点、浮点数或双精度数来表示数字。Tkinter 将 Python 中的浮点数据类型称为 DoubleVar。根据精度的不同，浮点数和双精度数可能会有所不同。在这里，我们将
    tkinter 的 DoubleVar 转换为 Python 转换为 Python 浮点类型的结果。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We are creating a new Python module and the following screenshot shows both
    the code and the resulting output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个新的Python模块，以下截图展示了代码和生成的输出：
- en: '![How to do it...](img/B04829_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_01.jpg)'
- en: First, we import the tkinter module and alias it to the name `tk`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入tkinter模块并将其别名设置为`tk`。
- en: Next, we use this alias to create an instance of the `Tk` class by appending
    parentheses to `Tk`, which calls the constructor of the class. This is the same
    mechanism as calling a function, only here we are creating an instance of a class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过在`Tk`后添加括号来使用这个别名创建`Tk`类的一个实例，这会调用类的构造函数。这与调用函数的机制相同，只是在这里我们是在创建一个类的实例。
- en: Usually we use this instance assigned to the variable `win` to start the main
    event loop later in the code. But here, we are not displaying a GUI but demonstrating
    how to use the tkinter StringVar type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们使用这个分配给变量`win`的实例来在代码的后面启动主事件循环。但在这里，我们不是显示一个GUI，而是在演示如何使用tkinter的StringVar类型。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: We still have to create an instance of `Tk()`. If we comment out this line,
    we will get an error from tkinter, so this call is necessary.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要创建一个`Tk()`实例。如果我们取消注释这一行，我们将从tkinter获得错误，因此这个调用是必要的。
- en: Then we create an instance of the tkinter StringVar type and assign it to our
    Python `strData` variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个 `tkinter StringVar` 类型的实例，并将其分配给我们的 Python `strData` 变量。
- en: After that, we use our variable to call the `set()` method on StringVar and,
    after having it set to a value, we then get the value and save it in a new variable
    named `varData` and then print out its value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用我们的变量来调用StringVar的`set()`方法，在将其设置为某个值之后，我们获取这个值并将其保存在一个名为`varData`的新变量中，然后打印出它的值。
- en: In the Eclipse PyDev console, towards the bottom of the screenshot, we can see
    the output printed to the console, which is **Hello StringVar**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse PyDev 控制台中，截图的底部我们可以看到打印到控制台的信息，即 **Hello StringVar**。
- en: Next, we will print the default values of tkinter's IntVar, DoubleVar, and BooleanVar
    types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将打印 tkinter 的 IntVar、DoubleVar 和 BooleanVar 类型的默认值。
- en: '![How to do it...](img/B04829_04_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_02.jpg)'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As can be seen in the preceding screenshot, the default values do not get printed
    as we would have expected.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，默认值并没有像我们预期的那样被打印出来。
- en: The online literature mentions default values, but we won't see those values
    until we call the `get` method on them. Otherwise, we just get a variable name
    that automatically increments (for example PY_VAR3, as can be seen in the preceding
    screenshot).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线文献中提到了默认值，但我们在调用它们的`get`方法之前不会看到这些值。否则，我们只会得到一个自动递增的变量名（例如PY_VAR3，如前一张截图所示）。
- en: Assigning the tkinter type to a Python variable does not change the outcome.
    We still do not get the default value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将 tkinter 类型分配给 Python 变量并不会改变结果。我们仍然没有得到默认值。
- en: 'Here, we are focusing on the simplest code (which creates PY_VAR0):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们专注于最简单的代码（它创建PY_VAR0）：
- en: '![How it works...](img/B04829_04_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_04_03.jpg)'
- en: The value is PY_VAR0, not the expected 0, until we call the `get` method. Now
    we can see the default value. We did not call `set`, so we see the default value
    automatically assigned to each tkinter type once we call the `get` method on each
    type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 值为 PY_VAR0，而不是预期的 0，直到我们调用 `get` 方法。现在我们可以看到默认值。我们没有调用 `set`，因此当我们对每个类型调用 `get`
    方法时，我们看到默认值被自动分配给每个 tkinter 类型。
- en: '![How it works...](img/B04829_04_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_04_04.jpg)'
- en: Notice how the default value of 0 gets printed to the console for the `IntVar`
    instance we saved in the `intData` variable. We can also see the values in the
    Eclipse PyDev debugger window at the top of the screenshot.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意默认值0是如何打印到控制台上的，这是我们保存在`intData`变量中的`IntVar`实例。我们还可以在截图顶部的Eclipse PyDev调试器窗口中看到这些值。
- en: How to get data from a widget
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何从小部件获取数据
- en: When the user enters data, we want to do something with it in our code. This
    recipe shows how to capture data in a variable. In the previous recipe, we created
    several tkinter class variables. They were standalone. Now we are connecting them
    to our GUI, using the data we get from the GUI and storing it in Python variables.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入数据时，我们希望在代码中对它进行处理。本菜谱展示了如何将数据捕获到变量中。在前一个菜谱中，我们创建了几个tkinter类变量。它们是独立的。现在，我们正在将它们连接到我们的GUI，使用从GUI获取的数据并将其存储在Python变量中。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We are continuing to use the Python GUI we were building in the previous chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在继续使用我们在上一章中构建的 Python 图形用户界面。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We are assigning a value from our GUI to a Python variable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将GUI中的值赋给一个Python变量。
- en: 'Add the following code towards the bottom of our module, just above the main
    event loop:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们模块的底部添加以下代码，位于主事件循环之上：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the code gives us the following result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码得到以下结果：
- en: '![How to do it...](img/B04829_04_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_05.jpg)'
- en: We are retrieving the current value of the `Spinbox` control.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在检索`Spinbox`控件当前值。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: We placed our code above the GUI main event loop and so the printing happens
    before the GUI becomes visible. We would have to place the code in a callback
    function if we wanted to print out the current value after displaying the GUI
    and changing the value of the `Spinbox` control.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码放置在GUI主事件循环之上，因此打印操作发生在GUI可见之前。如果我们想在显示GUI并更改`Spinbox`控件值之后打印当前值，我们就必须将代码放在回调函数中。
- en: 'We created our Spinbox widget using the following code, hard-coding the available
    values into it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码创建了我们的 Spinbox 小部件，并将可用的值硬编码到其中：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can also move the hard-coding of the data out of the creation of the `Spinbox`
    class instance and set it later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将数据的硬编码从`Spinbox`类实例的创建中移除，并在之后设置它。
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It does not matter how we create our widget and insert data into it because
    we can access this data by using the `get()` method on the instance of the widget.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建小部件并插入数据的方式并不重要，因为我们可以通过在部件实例上使用`get()`方法来访问这些数据。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to get values out of our GUI written using tkinter, we use the tkinter
    `get()` method on an instance of the widget we wish to get the value from.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从使用 tkinter 编写的 GUI 中获取值，我们使用 tkinter 的 `get()` 方法在我们要获取值的控件实例上。
- en: In the above example we used the Spinbox control, but the principle is the same
    for all widgets that have a `get()` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中我们使用了 Spinbox 控件，但对于所有具有 `get()` 方法的控件，其原理都是相同的。
- en: Once we have gotten the data, we are in a pure Python world and tkinter did
    serve us to build our GUI. Now that we know how to get the data out of our GUI,
    we can use this data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了数据，我们就进入了纯Python的世界，tkinter确实为我们构建GUI提供了帮助。现在我们知道了如何从GUI中获取数据，我们可以使用这些数据。
- en: Using module-level global variables
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块级全局变量
- en: Encapsulation is a major strength in any programming language that enables us
    to program using OOP. Python is both OOP and procedural. We can create global
    variables that are localized to the module they reside in. They are global only
    to this module, which is one form of encapsulation. Why do we want this? Because,
    as we add more and more functionality to our GUI, we want to avoid naming conflicts,
    which could result in bugs in our code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是任何编程语言的主要优势之一，它使我们能够使用面向对象编程（OOP）进行编程。Python 既是面向对象又是过程式的。我们可以创建全局变量，这些变量仅限于它们所在的模块。它们仅对这个模块是全局的，这是封装的一种形式。我们为什么想要这样做呢？因为，随着我们向我们的图形用户界面（GUI）添加越来越多的功能，我们希望避免命名冲突，这可能导致代码中的错误。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: We do not want naming clashes creating bugs in our code! Namespaces are one
    way to avoid these bugs, and in Python, we can do this by using Python modules
    (which are unofficial namespaces).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望命名冲突在我们的代码中产生错误！命名空间是避免这些错误的一种方法，在Python中，我们可以通过使用Python模块（这些是非官方的命名空间）来实现这一点。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We can declare module-level globals in any module just above and outside of
    functions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何模块中声明模块级别的全局变量，只需在函数之上和之外即可。
- en: We then have to use the `global` Python keyword to refer to them. If we forget
    to use `global` in functions, we will accidentally create new local variables.
    This would be a bug and something we really do not want to do.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后必须使用 Python 的 `global` 关键字来引用它们。如果我们忘记在函数中使用 `global`，我们将会意外地创建新的局部变量。这将是一个错误，是我们真的不希望做的事情。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Python is a dynamic, strongly typed language. We will only notice bugs like
    this (forgetting to scope variables with the global keyword) at runtime.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种动态、强类型语言。我们只有在运行时才会注意到这类错误（忘记使用全局关键字来作用域变量）。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Add the code shown on line 15 to the GUI we used in the previous recipe and
    the last chapter, which creates a module-level global variable. We use the C-style
    all uppercase convention, which is not truly "Pythonic" but I think this does
    emphasize the principle we are addressing in this recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将第15行显示的代码添加到我们在上一道菜谱和上一章中使用的GUI中，这将创建一个模块级别的全局变量。我们使用C风格的全部大写约定，这并不真正是“Pythonic”，但我认为这确实强调了我们在本菜谱中要处理的原则。
- en: '![How to do it...](img/B04829_04_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_06.jpg)'
- en: Running the code results in a printout of the global. Notice **42** being printed
    to the Eclipse console.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会在全局变量上打印输出。注意**42**被打印到了Eclipse控制台。
- en: '![How to do it...](img/B04829_04_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_07.jpg)'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define a global variable at the top of our module and, later, towards the
    bottom of our module, we print out its value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模块顶部定义一个全局变量，随后在模块底部，我们打印出它的值。
- en: That works.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那是有效的。
- en: 'Add this function towards the bottom of our module:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数添加到我们模块的底部：
- en: '![How it works...](img/B04829_04_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_04_08.jpg)'
- en: 'Above, we are using the module-level global. It is easy to make a mistake by
    shadowing the `global`, as demonstrated in the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，我们正在使用模块级别的全局变量。由于在下面的截图中所展示的，通过覆盖`global`变量很容易犯错：
- en: '![How it works...](img/B04829_04_09.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_04_09.jpg)'
- en: Note how `42` became `777`, even though we are using the same variable name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何`42`变成了`777`，尽管我们使用了相同的变量名。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: There is no compiler in Python that warns us if we overwrite global variables
    in a local function. This can lead to difficulties in debugging at runtime.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中没有编译器会警告我们在局部函数中覆盖全局变量。这可能导致在运行时调试出现困难。
- en: 'Using the global qualifier (line 234) prints out the value we originally assigned
    it (42) towards the top of our module, as can be seen in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局限定符（第234行）将打印出我们最初分配给它的值（42），如下面的截图所示：
- en: '![How it works...](img/B04829_04_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_04_10.jpg)'
- en: 'But, be careful. When we uncomment the local global, we print out the value
    of the local, not the global:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意。当我们取消对局部全局变量的注释时，我们打印出的是局部变量的值，而不是全局变量的值：
- en: '![How it works...](img/B04829_04_11.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_04_11.jpg)'
- en: Even though we are using the `global` qualifier, the local variable seems to
    override it. We are getting a warning from the Eclipse PyDev plug-in that our
    `GLOBAL_CONST = 777` is not being used, yet running the code still prints 777
    instead of the expected 42.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用了`global`限定符，但局部变量似乎覆盖了它。我们从 Eclipse PyDev 插件那里收到了警告，指出我们的`GLOBAL_CONST
    = 777`没有被使用，然而运行代码仍然打印出 777 而不是预期的 42。
- en: This might not be the behavior we expect. Using the `global` qualifier we might
    expect that we are pointing to the global variable created earlier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是我们预期的行为。使用`global`限定符，我们可能期望我们正在指向之前创建的全局变量。
- en: Instead, it seems that Python creates a new global variable in a local function
    and overwrites the one we created earlier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，似乎Python在局部函数中创建了一个新的全局变量，并覆盖了我们之前创建的那个。
- en: Global variables can be very useful when programming small applications. They
    can help to make data available across methods and functions within the same Python
    module and sometimes the overhead of OOP is not justified.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量在编写小型应用程序时非常有用。它们可以帮助在同一个Python模块内的方法和函数之间共享数据，有时面向对象的额外开销也是不必要的。
- en: As our programs grow in complexity, the benefit we gained from using globals
    can quickly diminish.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的程序复杂性增加，从使用全局变量中获得的益处可能会迅速减少。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: It is best to avoid globals and accidentally shadowing variables by using the
    same name in different scopes. We can use OOP instead of using globals.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免使用全局变量，并通过在不同作用域中使用相同的名称意外地覆盖变量。我们可以使用面向对象编程（OOP）来代替使用全局变量。
- en: We played around with global variables within procedural code and learned how
    that can lead to hard-to-debug bugs. In the next chapter, we will move on to OOP,
    which can eliminate these kinds of bugs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在过程式代码中玩弄全局变量，并了解到这可能导致难以调试的错误。在下一章中，我们将转向面向对象编程（OOP），这可以消除这类错误。
- en: How coding in classes can improve the GUI
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在课堂上编码来提升图形用户界面（GUI）
- en: So far, we have been coding in a procedural style. This is a quick scripting
    method from Python. Once our code gets larger and larger, we need to advance to
    coding in OOP.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用过程式编程风格。这是一种快速的Python脚本方法。一旦我们的代码变得越来越大，我们就需要进阶到面向对象编程（OOP）的编程方式。
- en: Why?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？
- en: Because, among many other benefits, OOP allows us to move code around by using
    methods. Once we use classes, we no longer have to physically place code above
    the code that calls it. This gives us great flexibility in organizing our code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，在众多其他好处中，面向对象编程（OOP）允许我们通过使用方法来移动代码。一旦我们使用了类，就不再需要物理地将代码放置在调用它的代码之上。这使我们能够极大地提高代码组织的灵活性。
- en: We can write related code next to other code and no longer have to worry that
    the code will not run because the code does not sit above the code that calls
    it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相关代码写在其他代码旁边，再也不必担心代码无法运行，因为代码不再位于调用它的代码之上。
- en: We can take that to some rather fancy extremes by coding up modules that refer
    to methods that are not being created within that module. They rely on the runtime
    state having created those methods during the time the code runs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写模块来达到一些相当复杂的极端情况，这些模块引用的方法不是在该模块内创建的。它们依赖于在代码运行期间，运行时状态已经创建了这些方法。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: If the methods we call have not been created by that time, we get a runtime
    error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们称之为的方法在那个时间点尚未被创建，我们将得到一个运行时错误。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will turn our entire procedural code into OOP very simply. We just turn it
    into a class, indent all the existing code, and prepend `self` to all variables.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将非常简单地把我们所有的过程性代码转换为面向对象编程（OOP）。我们只需将其转换为一个类，缩进所有现有代码，并将`self`前缀添加到所有变量之前。
- en: It is very easy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。
- en: While at first it might feel a little bit annoying having to prepend everything
    with the `self` keyword, making our code more verbose (hey, we are wasting so
    much paper…); in the end, it will be worth it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能觉得在每样东西前都加上`self`关键字有点烦人，使得我们的代码更加冗长（嘿，我们浪费了这么多纸张……）；但最终，这将是值得的。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the beginning, all hell breaks loose, but we will very soon fix this apparent
    mess.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，一切似乎都陷入了混乱，但我们很快就会解决这个问题表面的混乱。
- en: Note that, in Eclipse, the PyDev editor hints at coding problems by highlighting
    them in red on the right-side portion of the code editor.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Eclipse中，PyDev编辑器通过在代码编辑器的右侧部分用红色突出显示来提示编码问题。
- en: Maybe we should not code in OOP after all, but this is what we do, and for very
    good reasons.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们最终不应该使用面向对象编程（OOP）来编码，但这是我们正在做的事情，而且有非常好的理由。
- en: '![How to do it...](img/B04829_04_12.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_12.jpg)'
- en: We just have to prepend all variables with the `self` keyword and also bind
    the functions to the class by using `self`, which officially and technically turns
    the functions into methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在所有变量前加上`self`关键字，并且通过使用`self`将函数绑定到类上，这样在官方和技术上正式地将函数转换为方法。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a difference between functions and methods. Python makes this very
    clear. Methods are bound to a class while functions are not. We can even mix the
    two within the same Python module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法之间有区别。Python 将这一点阐述得非常清晰。方法绑定到类上，而函数则不是。我们甚至可以在同一个 Python 模块中混合使用这两种。
- en: Let's prefix everything with `self` to get rid of the red, so we can run our
    code again.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给所有内容都加上`self`前缀，以消除红色提示，这样我们就可以再次运行我们的代码了。
- en: '![How to do it...](img/B04829_04_13.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_13.jpg)'
- en: Once we do this for all of the errors highlighted in red, we can run our Python
    code again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理完所有用红色突出显示的错误，我们就可以再次运行我们的Python代码。
- en: The `clickMe` function is now bound to the class and has officially become a
    method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`clickMe` 函数现在已绑定到类中，并正式成为了一个方法。'
- en: Unfortunately, starting in a procedural way and then translating it into OOP
    is not as simple as I stated above. The code became a huge mess. This is a very
    good reason to start programming in Python using the OOP paradigm.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，从过程式编程开始然后转换为面向对象编程并不像我上面所说的那么简单。代码变得一团糟。这正是开始用Python使用面向对象范式编程的一个很好的理由。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Python is good at doing things the easy way. The easy code often becomes more
    complex (because it was easy to begin with). Once we get too complex, refactoring
    our procedural code into what truly could be OOP code becomes harder with every
    single line of code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python擅长以简单的方式完成任务。简单的代码往往变得更为复杂（因为一开始它就是简单的）。一旦我们变得过于复杂，将我们的过程性代码重构为真正意义上的面向对象代码就会随着每一行代码的增加而变得更加困难。
- en: We are translating our procedural code into object-oriented code. Looking at
    all the troubles we got ourselves into, translating only 200+ lines of Python
    code into OOP could suggest that we might as well start coding in OOP from the
    beginning.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将我们的过程式代码转换为面向对象的代码。看看我们给自己带来的所有麻烦，仅仅将200多行Python代码转换为面向对象（OOP）可能意味着我们最好从一开始就使用面向对象编程。
- en: We actually did break some of our previously working functionality. Using Tab
    2 and clicking the radio buttons no longer works. We have to refactor more.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上破坏了一些之前正常工作的功能。使用Tab 2并点击单选按钮不再起作用。我们不得不进行更多的重构。
- en: The procedural code was easy in the sense that it was simply top to bottom coding.
    Now that we have placed our code into a class, we have to move all callback functions
    into methods. This works, but does take some work to translate our original code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 程序代码在某种程度上是简单的，因为它只是从上到下的编码。现在我们将代码放入了一个类中，我们必须将所有回调函数移动到方法中。这可行，但确实需要一些工作来转换我们的原始代码。
- en: 'Our procedural code looked like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序代码看起来是这样的：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We moved the callback methods to the top of the module, inside the new OOP class.
    We moved all the widget creation code into one rather long method, which we call
    in the initializer of the class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回调方法移动到了模块的顶部，在新的面向对象类内部。我们将所有的小部件创建代码合并到一个相对较长的函数中，我们称这个函数为类的初始化器中调用的函数。
- en: Technically, deep underneath the hood of low-level code, Python does have a
    constructor, yet Python frees us from any worries about this. It is taken care
    of for us.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，在底层代码的深处，Python 确实有一个构造函数，然而 Python 让我们免于对此有任何担忧。它已经由系统为我们处理好了。
- en: Instead, in addition to a "real" constructor, Python provides us with an initializer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，除了一个“真实”的构造函数外，Python还为我们提供了一个初始化器。
- en: We are strongly encouraged to use this initializer. We can use it to pass in
    parameters to our class, initializing variables we wish to use inside of our class
    instance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议使用这个初始化器。我们可以用它向我们的类传递参数，初始化我们希望在类实例内部使用的变量。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In Python, several classes can exist within the same Python module.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，同一个Python模块中可以存在多个类。
- en: Unlike Java, which has a very rigid naming convention (without which it does
    not work), Python is much more flexible.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java不同，Java有一个非常严格的命名规范（没有这个规范就无法工作），而Python则要灵活得多。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: We can create multiple classes within the same Python module. Unlike Java, we
    do not depend on a file name that has to match each class name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一个Python模块中创建多个类。与Java不同，我们不需要依赖一个必须与每个类名匹配的文件名。
- en: Python truly rocks!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python 真的太棒了！
- en: Once our Python GUI gets large, we will break some classes out into their own
    modules but, unlike Java, we do not have to. In this book and project, we will
    keep some classes in the same module, while at the same time, we will break out
    some other classes into their own modules, importing them into what can be considered
    as a main() function (this is not C, but we can think C-like because Python is
    very flexible).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 Python 图形用户界面变得庞大时，我们将把一些类拆分到它们自己的模块中，但与 Java 不同，我们不必这样做。在这本书和项目中，我们将保持一些类在同一个模块中，同时，我们还将把一些其他类拆分到它们自己的模块中，并将它们导入可以被认为是
    main() 函数的部分（这虽然不是 C 语言，但我们可以以 C 语言的方式去思考，因为 Python 非常灵活）。
- en: What we have achieved so far is to add the `ToolTip` class to our Python module
    and refactor our procedural Python code into OOP Python code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前所取得的成就是将`ToolTip`类添加到我们的Python模块中，并将我们的过程式Python代码重构为面向对象（OOP）的Python代码。
- en: Here, in this recipe, we can see that more than one class can live in the same
    Python module.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们可以看到多个类可以存在于同一个Python模块中。
- en: Cool stuff, indeed!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 确实很酷！
- en: '![How to do it...](img/B04829_04_14.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_14.jpg)'
- en: Both the `ToolTip` class and the `OOP` class reside within the same Python module.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolTip` 类和 `OOP` 类都位于同一个 Python 模块中。'
- en: '![How to do it...](img/B04829_04_15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_15.jpg)'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we advanced our procedural code into object-oriented-programming
    (OOP) code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将我们的过程式代码提升到了面向对象编程（OOP）代码。
- en: Python enables us to write code in both a practical, procedural style like the
    C-programming language.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python使我们能够以类似于C编程语言的实际、过程式风格编写代码。
- en: At the same time, we have the option to code in an OOP style, like Java, C#,
    and C++.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们也有选择以面向对象（OOP）风格进行编码的选项，例如 Java、C# 和 C++。
- en: Writing callback functions
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写回调函数
- en: At first, callback functions can seem to be a little bit intimidating. You call
    the function, passing it some arguments, and now the function tells you that it
    is really very busy and it will call you back!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，回调函数可能会显得有些令人畏惧。你调用函数，传递给它一些参数，然后这个函数告诉你它真的很忙，它将会回过头来调用你！
- en: 'You wonder: "Will this function *ever* call me back?" "And how long do I have
    to *wait*?"'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你会想：“这个功能**会**再联系我吗？”“我需要**等**多久？”
- en: In Python, even callback functions are easy and, yes, they usually do call you
    back.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，即使是回调函数也容易使用，是的，它们通常确实会回调你。
- en: They just have to complete their assigned task first (hey, it was you who coded
    them in the first place…).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 他们只需首先完成分配给他们的任务（嘿，毕竟是你最初为他们编写代码的……）。
- en: Let us understand a little bit more about what happens when we code callbacks
    into our GUI.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解一下，当我们把回调函数编码到我们的图形用户界面(GUI)中时会发生什么。
- en: Our GUI is event-driven. After it has been created and displayed onscreen, it
    typically sits there waiting for an event to happen. It is basically waiting for
    an event to be sent to it. We can send an event to our GUI by clicking one of
    its action buttons.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图形用户界面是事件驱动的。创建并显示在屏幕上后，它通常就坐在那里等待事件发生。它基本上是在等待事件被发送给它。我们可以通过点击其操作按钮之一来向我们的GUI发送事件。
- en: This creates an event and, in a sense, we "called" our GUI by sending it a message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个事件，从某种意义上说，我们通过发送消息“调用”了我们的GUI。
- en: Now, what is supposed to happen after we send a message to our GUI?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们向GUI发送消息后，应该发生什么情况？
- en: What happens after clicking the button depends on whether we created an event
    handler and associated it with this button. If we did not create an event handler,
    clicking the button will have no effect.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后会发生什么取决于我们是否创建了一个事件处理器并将其与该按钮关联。如果我们没有创建事件处理器，点击按钮将没有任何效果。
- en: The event handler is a callback function (or method, if we use classes).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器是一个回调函数（或者，如果我们使用类，是方法）。
- en: The callback method is also sitting there passively, like our GUI, waiting to
    be invoked.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回调方法也像我们的GUI一样，在那里被动地等待被调用。
- en: Once our GUI gets its button clicked, it will invoke the callback.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的GUI按钮被点击，它将调用回调函数。
- en: The callback often does some processing and, when done, it returns the result
    to our GUI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数通常会进行一些处理，完成后将结果返回到我们的图形用户界面(GUI)。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In a sense, we can see that our callback function is calling back to our GUI.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我们可以看到我们的回调函数正在回调到我们的GUI。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The Python interpreter runs through all the code in a project once, finding
    any syntax errors and pointing them out. You cannot run your Python code if you
    do not have the syntax right. This includes indentation (if not resulting in a
    syntax error, wrong indentation usually results in a bug).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器会遍历项目中的所有代码一次，查找任何语法错误并指出它们。如果你没有正确使用语法，就无法运行你的Python代码。这包括缩进（即使不会导致语法错误，错误的缩进通常也会导致错误）。
- en: On the next parsing round, the interpreter interprets our code and runs it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一轮解析中，解释器将解析我们的代码并运行它。
- en: At runtime, many GUI events can be generated and it is usually callback functions
    that add functionality to GUI widgets.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，可以生成许多GUI事件，通常是通过回调函数来为GUI小部件添加功能。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here is the callback for the Spinbox widget:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Spinbox 小部件的回调函数：
- en: '![How to do it...](img/B04829_04_16.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_16.jpg)'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a callback method in the `OOP` class, which gets called when we select
    a value from the Spinbox widget because we bound the method to the widget via
    the `command` argument (`command=self._spin`). We use a leading underscore to
    hint at the fact that this method should be respected like a private Java method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`OOP`类中创建了一个回调方法，当我们在Spinbox小部件中选择一个值时会被调用，因为我们通过`command`参数（`command=self._spin`）将方法绑定到小部件。我们使用前导下划线来暗示这个方法应该像私有Java方法一样受到尊重。
- en: Python intentionally avoids language restrictions such as private, public, friend,
    and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Python故意避免了诸如私有、公有、友元等语言限制。
- en: In Python, we use naming conventions instead. Leading and trailing double underscores
    surrounding a keyword are expected to be restricted to the Python language, and
    we should not use them in our own Python code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们使用命名约定。期望关键字周围的前导和尾随双下划线仅限于Python语言，我们不应在我们的Python代码中使用它们。
- en: However, we can use a leading underscore prefix to a variable name or function
    to provide a hint that this name should be respected as a private helper.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用一个前置下划线前缀来命名变量或函数，以提供提示，表明这个名称应该被视为一个私有辅助者。
- en: 'At the same time, we can postfix a single underscore if we wish to use what
    otherwise would be Python built-in names. For example, if we wished to abbreviate
    the length of a list, we could do the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果我们希望使用否则会是 Python 内置名称的变量，我们可以给其后缀一个单下划线。例如，如果我们想缩写列表的长度，我们可以这样做：
- en: '[PRE4]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Often, the underscore is hard to read and easy to oversee, so this might not
    be the best idea in practice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，下划线难以阅读且容易忽略，因此在实践中这可能不是最好的主意。
- en: Creating reusable GUI components
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的GUI组件
- en: We are creating reusable GUI components using Python.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 Python 创建可重用的 GUI 组件。
- en: In this recipe, we will keep it simple by moving our `ToolTip` class into its
    own module. Next, we will import and use it for displaying tooltips over several
    widgets of our GUI.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过将我们的 `ToolTip` 类移动到它自己的模块中来保持简单。接下来，我们将导入并使用它来在我们的 GUI 的几个小部件上显示工具提示。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are building on our previous code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在基于之前的代码进行构建。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will start by breaking out our `ToolTip` class into a separate Python module.
    We will slightly enhance it to pass in the control widget and the tooltip text
    we wish to display when we hover the mouse over the control.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将我们的`ToolTip`类拆分到一个独立的Python模块中。我们将对其进行轻微增强，以便在鼠标悬停在控件上时，能够传入我们希望显示的控件小部件和提示文本。
- en: We create a new Python module and place the `ToolTip` class code into it and
    then import this module into our primary module.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的Python模块，并将`ToolTip`类的代码放入其中，然后将其导入到我们的主模块中。
- en: We then reuse the imported `ToolTip` class by creating several tooltips, which
    can be seen when hovering the mouse over several of our GUI widgets.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后通过创建多个工具提示来重用导入的`ToolTip`类，这些工具提示会在鼠标悬停在我们的GUI小部件上时显示。
- en: Refactoring our common `ToolTip` class code out into its own module helps us
    to reuse this code from other modules. Instead of copy/paste/modify we use the
    DRY principle and our common code is located in only one place, so when we modify
    the code, all modules that import it will automatically get the latest version
    of our module.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们常用的 `ToolTip` 类代码重构到一个独立的模块中，有助于我们从其他模块中复用这段代码。我们不再使用复制/粘贴/修改的方式，而是遵循DRY原则，将公共代码放置在唯一的位置，因此当我们修改代码时，所有导入它的模块将自动获取模块的最新版本。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: DRY stands for Don't Repeat Yourself and we will look at it again in a later
    chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: DRY代表“不要重复自己”，我们将在后面的章节中再次探讨它。
- en: We can do similar things by turning our Tab3 image into a reusable component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 Tab3 图像转换成一个可重复使用的组件来做类似的事情。
- en: To keep this recipe's code simple, we removed Tab 3, but you can experiment
    with the code from the previous chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个菜谱的代码简单，我们移除了Tab 3，但你可以在前一章的代码上进行实验。
- en: '![How to do it...](img/B04829_04_17.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_17.jpg)'
- en: '[PRE5]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This also works on the second tab.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于第二个标签页。
- en: '![How to do it...](img/B04829_04_18.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_18.jpg)'
- en: 'The new code structure looks like this now:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码结构现在看起来是这样的：
- en: '![How to do it...](img/B04829_04_19.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_19.jpg)'
- en: 'The import statement looks like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 导入语句看起来是这样的：
- en: '![How to do it...](img/B04829_04_20.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_20.jpg)'
- en: 'And the broken out (aka refactored) code in a separate module looks like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 并且拆分出来（即重构）的代码在单独的模块中看起来是这样的：
- en: '![How to do it...](img/B04829_04_21.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_04_21.jpg)'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the preceding screenshots, we can see several tooltip messages being displayed.
    The one for the main window might appear a little bit annoying, so it is better
    not to display a tooltip for the main window because we really wish to highlight
    the functionality of the individual widgets. The main window form has a title
    that explains its purpose; no need for a tooltip.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图里，我们可以看到几个提示信息正在显示。对于主窗口的提示信息可能显得有些烦人，因此最好不为主窗口显示提示信息，因为我们真的希望突出各个小部件的功能。主窗口的表单有一个标题来解释其用途；无需提示信息。
