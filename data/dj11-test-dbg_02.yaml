- en: Chapter 2. Does This Code Work? Doctests in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。这段代码有效吗？深入了解文档测试
- en: 'In the first chapter, we learned how to run the sample tests created by `manage.py
    startapp`. Although we used a Django utility to run the tests, there was nothing
    specific to Django about the sample tests themselves. In this chapter, we will
    start getting into details of how to write tests for a Django application. We
    will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们学习了如何运行`manage.py startapp`创建的示例测试。虽然我们使用了Django实用程序来运行测试，但是示例测试本身与Django无关。在本章中，我们将开始详细介绍如何为Django应用程序编写测试。我们将：
- en: Begin writing the market research project created in the first chapter by developing
    some basic models that will be used by the project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过开发一些基本模型来开始编写第一章创建的市场调研项目
- en: Experiment with adding doctests to one of the models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试向其中一个模型添加文档测试
- en: Begin to learn the kinds of tests that are useful, and the kinds that just add
    clutter to the code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始学习哪些测试是有用的，哪些只会给代码增加混乱
- en: Discover some of the advantages and disadvantages of doctests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现文档测试的一些优缺点
- en: 'While the previous chapter mentioned both doctests and unit tests, the focus
    for this chapter will be on doctests exclusively. Developing unit tests for Django
    applications will be the focus of [Chapter 3](ch03.html "Chapter 3. Testing 1,
    2, 3: Basic Unit Testing"), *Testing 1, 2, 3: Basic Unit Testing* and [Chapter
    4](ch04.html "Chapter 4. Getting Fancier: Django Unit Test Extensions"), *Getting
    Fancier: Django Unit Test Extensions*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章提到了文档测试和单元测试，而本章的重点将专门放在文档测试上。开发Django应用程序的单元测试将是[第3章](ch03.html "第3章。测试1,
    2, 3：基本单元测试")和[第4章](ch04.html "第4章。变得更花哨：Django单元测试扩展")的重点。
- en: The Survey application models
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查应用程序模型
- en: 'A common place to start development of a new Django application is with the
    models: the basic building blocks of data that are going to be manipulated and
    stored by the application. A cornerstone model for our example market research
    `survey` application will be the `Survey` model.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 开始开发新的Django应用程序的常见地方是从模型开始：这些数据的基本构建块将由应用程序进行操作和存储。我们示例市场调研`survey`应用程序的基石模型将是`Survey`模型。
- en: 'A `Survey` is going to be similar to the Django tutorial `Poll` model, except
    that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Survey`将类似于Django教程`Poll`模型，只是：'
- en: Where the tutorial `Poll` only contains one question, a `Survey` will have multiple
    questions.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程`Poll`只包含一个问题，而`Survey`将有多个问题。
- en: A `Survey` will have a title for reference purposes. For the tutorial `Poll`,
    a single question could be used for this.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Survey`将有一个标题用于参考目的。对于教程`Poll`，可以使用一个单一的问题。'
- en: A `Survey` will only be open for responses for a limited (and variable, depending
    on the `Survey` instance) time. While the `Poll` model has a `pub_date` field,
    it is not used for anything other than ordering `Polls` on the index page. Thus,
    `Survey` will need two date fields where `Poll` has only one, and the `Survey`
    date fields will be used more than the `Poll pub_date` field is used.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Survey`只会在有限的时间内（取决于`Survey`实例）开放回应。虽然`Poll`模型有一个`pub_date`字段，但它除了在索引页面上对`Polls`进行排序之外没有用。因此，`Survey`将需要两个日期字段，而`Poll`只有一个，`Survey`的日期字段将比`Poll
    pub_date`字段更常用。'
- en: 'Given just these few simple requirements for `Survey`, we can start developing
    a Django model for it. Specifically, we can capture those requirements in code
    by adding the following to the auto-generated `models.py` file for our `survey`
    application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 只需这些简单的要求，我们就可以开始为`Survey`开发Django模型。具体来说，我们可以通过将以下内容添加到我们`survey`应用程序的自动生成的`models.py`文件中的代码来捕捉这些要求：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that since a `Survey` may have several questions, it does not have a question
    field. Instead there is a separate model, `Question`, to hold questions along
    with the Survey instance they are related to:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`Survey`可能有多个问题，它没有一个问题字段。相反，有一个单独的模型`Question`，用于保存与其相关的调查实例的问题：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The final model we need (at least to start with) is one to hold the possible
    answers to each question, and to track how many times each answer is chosen by
    a survey respondent. This model, `Answer`, is much like the tutorial `Choice`
    model, except it is related to a `Question`, not a `Poll`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最终模型（至少是开始时）是一个用于保存每个问题的可能答案，并跟踪调查受访者选择每个答案的次数。这个模型`Answer`与教程`Choice`模型非常相似，只是它与`Question`相关联，而不是与`Poll`相关联：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Testing the Survey model
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试调查模型
- en: If you are at all like me, at this point you might want to start verifying that
    what you've got so far is correct. True, there is not much code yet, but particularly
    when just starting out on a project I like to make sure, early and often, that
    what I've got so far is valid. So, how do we start testing at this point? First,
    we can verify that we've got no syntax errors by running `manage.py syncdb`, which
    will also let us start experimenting with these models in a Python shell. Let's
    do that. Since this is the first time we've run `syncdb` for this project, we'll
    get messages about creating tables for the other applications listed in `INSTALLED_APPS`,
    and we'll be asked if we want to create a superuser, which we may as well go ahead
    and do also.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样，在这一点上你可能想要开始验证到目前为止是否正确。的确，现在还没有太多的代码，但特别是在项目刚开始的时候，我喜欢确保我到目前为止的东西是有效的。那么，我们如何开始测试？首先，我们可以通过运行`manage.py
    syncdb`来验证我们没有语法错误，这也会让我们在Python shell中开始尝试这些模型。让我们来做吧。由于这是我们为这个项目第一次运行`syncdb`，我们将收到关于为`INSTALLED_APPS`中列出的其他应用程序创建表的消息，并且我们将被问及是否要创建超级用户，我们也可以继续做。
- en: Testing Survey model creation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试调查模型创建
- en: 'Now, what might we do with these models to test them in a Python shell? Really,
    not much beyond creating each, perhaps verifying that if we don''t specify one
    of the fields we get an error, or the correct default value is assigned, and verifying
    whether we can traverse the relationships between the models. If we focus first
    on the `Survey` model and what we might do in order to test the creation of it,
    a Python shell session for that might look something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用这些模型做些什么来在Python shell中测试它们？实际上，除了创建每个模型之外，我们并没有太多可做的事情，也许可以验证一下，如果我们没有指定其中一个字段，我们会得到一个错误，或者正确的默认值被分配，并验证我们是否可以遍历模型之间的关系。如果我们首先关注`Survey`模型以及为了测试其创建而可能做的事情，那么Python
    shell会话可能看起来像这样：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we started by importing our `Survey` model and the Python `datetime` module,
    then created a variable `t` to hold a title string and a variable `d` to hold
    a date value, and used those values to create a `Survey` instance. No error was
    reported, so that looks good.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先导入了我们的`Survey`模型和Python的`datetime`模块，然后创建了一个变量`t`来保存一个标题字符串和一个变量`d`来保存一个日期值，并使用这些值创建了一个`Survey`实例。没有报告错误，所以看起来很好。
- en: 'If we then wanted to verify whether we''d get an error if we tried to create
    a `Survey` with no close date, we would proceed with:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想验证一下，如果我们尝试创建一个没有关闭日期的`Survey`，我们会得到一个错误吗，我们将继续进行：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here all we did differently with the `Survey` instance creation attempt was
    specify `None` for the `closes` value instead of passing in our date variable
    `d`. The result was an error ending in a message reporting an `IntegrityError`,
    since the closes column of the survey table cannot be null. This confirms our
    expectation of what should happen, so all is good so far. We could then perform
    similar tests for the other fields, and see identical tracebacks reporting an
    `IntegrityError` for the other columns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试创建`Survey`实例的唯一不同之处是为`closes`值指定了`None`，而不是传入我们的日期变量`d`。结果是一个以`IntegrityError`结尾的错误消息，因为调查表的关闭列不能为null。这证实了我们对应该发生的预期，所以到目前为止一切都很好。然后我们可以对其他字段执行类似的测试，并看到相同的回溯报告了其他列的`IntegrityError`。
- en: 'If we wanted to, we could then make these tests a permanent part of our model
    definition by cutting-and-pasting them from our shell session directly in our
    `survey/models.py` file, like so:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想的话，我们可以通过直接从shell会话中剪切和粘贴它们到我们的`survey/models.py`文件中，将这些测试变成我们模型定义的永久部分，就像这样：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You probably noticed that the results shown are not a direct cut-and-paste
    from the shell session. Differences include:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，所显示的结果并不是直接从shell会话中剪切和粘贴的。差异包括：
- en: The `import datetime` was moved out of the doctest and made part of the code
    in the `models.py` file. This wasn't strictly necessary—it would have worked fine
    as part of the doctest, but it is not necessary in the doctest if the import is
    in the main code. As the code in `models.py` will likely need to use `datetime`
    functions later on, putting the import in the main code now reduces duplication
    and clutter later, when the main code needs the import.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import datetime`被移出了doctest，并成为`models.py`文件中的代码的一部分。这并不是严格必要的——如果作为doctest的一部分，它也可以正常工作，但是如果导入在主代码中，那么在doctest中就不是必要的。由于`models.py`中的代码可能需要稍后使用`datetime`函数，因此现在将导入放在主代码中可以减少稍后的重复和混乱，当主代码需要导入时。'
- en: The call stack portion of the tracebacks, that is everything except the first
    and last lines, were removed and replaced with lines containing three dots. This
    too was not strictly necessary and was done simply to remove clutter and highlight
    the important bits of the result. The doctest runner ignores the contents of the
    call stack (if present in the expected output) when deciding on test success or
    failure. So you can leave a call stack in the test if it has some explanatory
    value. However, for the most part, it is best to remove call stacks since they
    produce a lot of clutter without providing much in the way of useful information.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回溯的调用堆栈部分，也就是除了第一行和最后一行之外的所有内容，都被删除并替换为包含三个点的行。这也并不是严格必要的，只是为了去除杂乱，并突出结果的重要部分。doctest运行器在决定测试成功或失败时会忽略调用堆栈的内容（如果预期输出中存在）。因此，如果调用堆栈具有一些解释价值，可以将其保留在测试中。然而，大部分情况下，最好删除调用堆栈，因为它们会产生大量杂乱，而提供的有用信息并不多。
- en: 'If we now run `manage.py test survey -v2`, the tail end of the output will
    be:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行`manage.py test survey -v2`，输出的最后部分将是：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've still got our sample tests in `tests.py` running, and now we can also
    see our `survey.models.Survey` doctest listed as being run, and passing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在`tests.py`中运行我们的样本测试，现在我们还可以看到我们的`survey.models.Survey` doctest被列为正在运行并通过。
- en: Is that test useful?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那个测试有用吗？
- en: 'But wait; is that test we just added useful? What is it actually testing? Nothing
    really, beyond verifying that basic Django functions work as advertised. It tests
    whether we can create an instance of a model we''ve defined, and that the fields
    we specified as required in the model definition are in fact required in the associated
    database table. It seems that this test is testing the underlying Django code
    more than our application. Testing Django itself is not necessary in our application:
    Django has its own test suite we can run if we want to test it (though it is pretty
    safe to assume basic functions work correctly in any released version of Django).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等；我们刚刚添加的测试有用吗？它实际上在测试什么？实际上并没有什么，除了验证基本的Django函数是否按照广告那样工作。它测试我们是否可以创建我们定义的模型的实例，并且我们在模型定义中指定为必需的字段实际上在关联的数据库表中是必需的。看起来这个测试更像是在测试Django的底层代码，而不是我们的应用程序。在我们的应用程序中测试Django本身并不是必要的：Django有自己的测试套件，我们可以运行它进行测试（尽管可以相当安全地假设基本功能在任何发布版本的Django中都能正确工作）。
- en: It could be argued that this test validates that the correct and intended options
    have been specified for each field in the model, and so it is a test of the application
    and not just the underlying Django functions. However, testing things that are
    obvious by inspection (to anyone with a basic knowledge of Django) strikes me
    as going a bit overboard. This is not a test I would generally include in a project
    I was writing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，这个测试验证了模型中每个字段是否已经指定了正确和预期的选项，因此这是对应用程序而不仅仅是底层Django函数的测试。然而，测试那些通过检查就很明显的事情（对于任何具有基本Django知识的人来说）让我觉得有点过分。这不是我通常会在自己写的项目中包含的测试。
- en: 'That is not to say I would not try out things like this in a Python shell during
    development: I would, and I do. But not everything experimented with in the shell
    during development needs to become a permanent test in the application. The kinds
    of tests you want to include in the application are those that exercise behavior
    that is unique to the application. So let''s start developing some survey application
    code and experiment with testing it in the Python shell. When we have the code
    working, we can assess what tests from the shell session are useful to keep.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说我在开发过程中不会在Python shell中尝试类似的事情：我会的，而且我也会。但是在开发过程中在shell中尝试的并不是所有东西都需要成为应用程序中的永久测试。您想要包含在应用程序中的测试类型是那些对应用程序独特行为进行测试的测试。因此，让我们开始开发一些调查应用程序代码，并在Python
    shell中进行测试。当我们的代码工作正常时，我们可以评估哪些来自shell会话的测试是有用的。
- en: Developing a custom Survey save method
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发自定义调查保存方法
- en: 'To begin writing some application-specific code, consider that for the Survey
    model we may want to allow for the `closes` field to assume a default value of
    a week after `opens`, if `closes` is not specified when the model instance is
    created. We cannot use the Django model field default option for this, as the
    value we want to assign is dependent on another field in the model. Therefore,
    we would typically do this by overriding the model''s save method. A first attempt
    at implementing this might be:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写一些特定于应用程序的代码，请考虑对于调查模型，如果在创建模型实例时没有指定`closes`，我们可能希望允许`closes`字段假定默认值为`opens`后的一周。我们不能使用Django模型字段默认选项，因为我们想要分配的值取决于模型中的另一个字段。因此，我们通常会通过覆盖模型的保存方法来实现这一点。首次尝试实现这一点可能是：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That is, in the case where `save` is called and the model instance does not
    have a primary key assigned yet (and so this is the first save to the database),
    and `closes` has not been specified, we assign `closes` a value that is a week
    later than `opens` before calling the superclass `save` method. We could then
    test if this works properly by experimenting in a Python shell:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在调用`save`并且模型实例尚未分配主键（因此这是对数据库的第一次保存），并且没有指定`closes`的情况下，我们在调用超类`save`方法之前将`closes`赋予一个比`opens`晚一周的值。然后我们可以通过在Python
    shell中进行实验来测试这是否正常工作：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is very similar to our earlier tests except we chose a specific date to
    assign to `opens` rather than using today's date, and after creating the `Survey`
    instance without specifying a value for `closes`, we checked the value that was
    assigned to it. The value displayed is a week later than `opens`, so that looks
    good.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前的测试非常相似，只是我们选择了一个特定的日期来分配给`opens`，而不是使用今天的日期，并且在创建`Survey`实例时没有指定`closes`的值，我们检查了分配给它的值。显示的值比`opens`晚一周，所以看起来很好。
- en: Note the choice of an `opens` date where the week-later value would be in the
    next month and year was deliberate. Testing boundary values is always a good idea
    and a good habit to get into, even when (as here) there is nothing in the code
    we are writing that is responsible for getting the answer right for the boundary
    case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，故意选择`opens`日期，其中一周后的值将在下个月和年份是一个明智的选择。测试边界值总是一个好主意，也是一个好习惯，即使（就像这里一样）我们正在编写的代码中没有任何东西负责为边界情况得到正确的答案。
- en: 'Next we might want to make sure that if we do specify a value for `closes`,
    it is honored and not overridden by a week-later default date:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可能希望确保如果我们指定了`closes`的值，它会被尊重，而不会被默认的一周后的日期覆盖：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All looks good there, `opens` and `closes` are displayed as having the same
    value, as we specified on the `create` call. We can also verify that if we reset
    `closes` to `None` after the model has already been saved, and try to save again,
    we''ll get an error. Resetting `closes` to `None` on an existing model instance
    would be an error in the code that does that. So what we are testing here is that
    our `save` method override does not hide that error by quietly re-assigning a
    value to `closes`. In our shell session, we proceed like so and see:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有看起来都很好，`opens`和`closes`显示为具有相同的值，就像我们在`create`调用中指定的那样。我们还可以验证，如果我们在模型已经保存后将`closes`重置为`None`，然后尝试再次保存，我们会得到一个错误。在现有模型实例上将`closes`重置为`None`将是代码中的错误。因此，我们在这里测试的是我们的`save`方法重写不会通过悄悄地重新分配一个值给`closes`来隐藏该错误。在我们的shell会话中，我们可以这样继续并查看：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, that looks good since it is the result we expect. Finally, since we
    have inserted some of our own code into the basic model save processing, we should
    verify that we have not broken anything for the other expected failure cases where
    no `title` or no `opens` field is specified on `create`. If we do that, we will
    see that the case of no `title` specified works correctly (we get the expected
    `IntegrityError` on the database title column), but if neither `opens` nor `closes`
    is specified we get an unexpected error:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这看起来很好，因为这是我们期望的结果。最后，由于我们已经将一些自己的代码插入到基本模型保存处理中，我们应该验证我们没有在`create`上没有指定`title`或`opens`字段的其他预期失败情况中出现问题。如果我们这样做，我们会发现没有指定`title`的情况下工作正常（我们在数据库标题列上得到了预期的`IntegrityError`），但如果`opens`和`closes`都没有指定，我们会得到一个意外的错误：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here we have traded a reasonably clear error message reporting that we have
    left a required value unspecified for a rather more obscure message complaining
    about unsupported operand types—that''s not good. The problem is we did not check
    if `opens` had a value before attempting to use it in our `save` method override.
    In order to get the correct (clearer) error for this case, our `save` method should
    be modified to look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用一个相当晦涩的消息来报告我们留下了一个必需的值未指定的错误，而不是一个相当清晰的错误消息。问题是我们在尝试在`save`方法重写中使用`opens`之前没有检查它是否有值。为了获得这种情况下的正确（更清晰）错误，我们的`save`方法应该修改为如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That is, we should not attempt to set `closes` if `opens` has not been specified.
    Rather, in this case we forward the `save` call directly to the superclass and
    let the normal error path report the problem. Then, when we try to create a `Survey`
    without specifying an `opens` or `closes` value, we will see:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果`opens`没有被指定，我们不应该尝试设置`closes`。在这种情况下，我们直接将`save`调用转发到超类，并让正常的错误路径报告问题。然后，当我们尝试创建一个没有指定`opens`或`closes`值的`Survey`时，我们会看到：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is much better, since the reported error directly indicates what the problem
    is.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会好得多，因为报告的错误直接指出了问题所在。
- en: Deciding what to test
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定测试什么
- en: 'At this point we are reasonably certain our `save` override is working the
    way we intended. Of all the tests we ran in the Python shell for verification
    purposes, which ones make sense to include in the code permanently? The answer
    to that question involves a judgment call, and reasonable people may have different
    answers. Personally, I would tend to include:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们相当确定我们的`save`重写正在按我们的意图工作。在我们为验证目的在Python shell中运行的所有测试中，哪些测试有意义地包含在代码中？这个问题的答案涉及判断，并且不同的人可能会有不同的答案。就我个人而言，我倾向于包括：
- en: All tests involving the parameter(s) directly affected by the code
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受代码直接影响的参数的所有测试
- en: Any tests that I ran across while doing initial testing of the code that did
    not work in the original version of the code I had written
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对代码进行初始测试时遇到的任何测试，这些测试在我编写的原始代码版本中没有起作用
- en: 'So, my `save` override function, including doctests with comments to explain
    them, might look something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我的`save`重写函数，包括带有注释的doctests，可能看起来像这样：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Some pros and cons of doctests so far
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止，doctests的一些优缺点
- en: Even with the experience of just this one example method we have studied, we
    can begin to see some of the pros and cons of doctests. Clearly, it is easy to
    re-use work done in Python shell sessions (work that is likely already being done
    as part of coding) for permanent test purposes. This makes it both more likely
    that tests will be written for the code, and that the tests themselves will not
    need to be debugged. Those are two nice advantages of doctests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只是通过研究这一个例子方法的经验，我们也可以开始看到doctests的一些优缺点。显然，可以很容易地重用在Python shell会话中完成的工作（这些工作很可能已经作为编码的一部分而被完成）用于永久测试目的。这使得更有可能为代码编写测试，并且测试本身不需要被调试。这是doctests的两个很好的优点。
- en: A third is that doctests provide unambiguous documentation of how the code is
    expected to behave. Prose descriptions can be fuzzy while code examples in the
    form of tests are impossible to misinterpret. Furthermore, the fact that the tests
    are part of the docstrings makes them accessible to all Python tools that use
    docstrings to auto-generate help and documentation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个是doctests提供了代码预期行为的明确文档。散文描述可能模糊不清，而以测试形式的代码示例是不可能被误解的。此外，测试作为文档字符串的一部分，使它们可以被所有使用文档字符串自动生成帮助和文档的Python工具访问。
- en: Including tests here helps to make this documentation complete. For example,
    the behavior after resetting `closes` to `None` is one where the intended behavior
    might not be obvious—an equally valid design would have been to say that in this
    case `closes` would be reset to a week-later date during `save`. This sort of
    detail can easily be forgotten when writing documentation. Thus having the intended
    behavior spelled out in a doctest is helpful, as it is then automatically documented.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里包括测试有助于使文档完整。例如，将`closes`重置为`None`后的行为可能不明显，一个同样有效的设计是在`save`期间将`closes`重置为一周后的日期。在编写文档时很容易忽略这种细节。因此，在doctest中详细说明预期的行为是有帮助的，因为它会自动记录下来。
- en: 'However, this tests-doubling-as-documentation feature also has a down side:
    some of the testing you may want to include may not really be appropriate as documentation,
    and you may wind up with an overwhelming amount of documentation for rather simple
    code. Consider the `save` override case we developed. It has four lines of code
    and a more than 30 line docstring. That ratio may be appropriate for some complicated
    functions with many parameters, or parameters that interact in non-obvious ways,
    but nearly ten times as much documentation as code seems excessive for this straightforward
    method.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种测试兼作文档的特性也有一个缺点：您可能希望包括的一些测试实际上可能并不适合作为文档，并且您可能会得到一个对相当简单的代码而言文档过多的情况。考虑我们开发的`save`重写案例。它有四行代码和超过30行的文档字符串。这种比例对于一些具有许多参数或参数以非明显方式相互作用的复杂函数可能是合适的，但是对于这种简单的方法来说，文档比代码多近十倍似乎过多了。
- en: 'Let''s consider the individual tests in `save`, focusing on their usefulness
    as documentation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`save`中的各个测试，重点是它们作为文档的有用性：
- en: The first test, which shows creating a `Survey` with `title` and `opens` but
    no `closes`, and verifies that the correct value is assigned to `closes` after
    creation, is an example of what the `save` override allows a caller to do. This
    is the specific call pattern enabled by the added code, and is therefore useful
    as documentation, even though it largely duplicates the prose description.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试显示了使用`title`和`opens`创建`Survey`，但没有`closes`，并验证了在创建后将正确值分配给`closes`，这是`save`重写允许调用者执行的示例。这是通过添加的代码启用的特定调用模式，并且因此作为文档是有用的，即使它在很大程度上重复了散文描述。
- en: The second test, which shows that `closes` is honored if specified, is not particularly
    useful as documentation. Any programmer would expect that if `closes` is specified,
    it should be honored. This behavior may be good to test, but is not necessary
    to document.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试显示了如果指定了`closes`，它将被遵守，这并不特别适合作为文档。任何程序员都会期望，如果指定了`closes`，它应该被遵守。这种行为可能适合测试，但不需要记录。
- en: The third test, which illustrates the expected behavior of `save` after resetting
    `closes` to `None` on an existing `Survey` instance, is useful as documentation,
    for the previously-mentioned reasons.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个测试展示了在现有的`Survey`实例上将`closes`重置为`None`后`save`的预期行为，出于前面提到的原因，这对于文档来说是有用的。
- en: The fourth and final test illustrates that the added code will not cause an
    unexpected exception to be generated in the error case where neither `opens` nor
    `closes` is specified. This is another example of something that is good to test,
    but not necessary to document, as the right behavior is obvious.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个和最后一个测试说明了添加的代码不会在未指定`opens`或`closes`的错误情况下引发意外异常。这是另一个需要测试但不需要记录的例子，因为正确的行为是显而易见的。
- en: 'Having half of our docstring classified as not useful for documentation purposes
    is not good. People tend to stop reading when they encounter obvious, redundant,
    or unhelpful information. We can address this problem without giving up some of
    the advantages of doctests by moving such tests from the docstring method into
    our `tests.py` file. If we take this approach, we might change the `__test__`
    dictionary in `tests.py` to look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的文档字符串的一半分类为不适合文档目的是不好的。当人们遇到明显的、冗余的或无用的信息时，他们往往会停止阅读。我们可以通过将这些测试从文档字符串方法移到我们的`tests.py`文件中来解决这个问题，而不放弃doctests的一些优势。如果我们采取这种方法，我们可能会改变`tests.py`中的`__test__`字典，使其看起来像这样：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we changed the key for the test from the generic `doctest` to `survey_save`,
    so that the reported test name in any test output will give a hint as to what
    is being tested. Then we just moved the "non-documentation" tests (along with
    some of the variable setup code that now needs to be in both places) from our
    `save` override docstring into the key value here, adding a general comment at
    the top noting what the tests are for.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将测试的关键字从通用的`doctest`改为`survey_save`，这样任何测试输出中报告的测试名称都会给出被测试的提示。然后我们将“非文档”测试（以及现在需要在两个地方都设置的一些变量设置代码）从我们的`save`覆盖文档字符串中移到这里的键值中，并在顶部添加一般注释，说明测试的目的。
- en: 'What remains in the docstring for the `save` method itself are the tests that
    do have some value as documentation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`方法本身的文档字符串中剩下的测试确实具有一定的文档价值：'
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That is certainly a much more manageable docstring for the function, and is
    no longer likely to overwhelm someone typing `help(Survey.save)` in a Python shell.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于函数的文档字符串来说肯定更容易管理，不太可能会让在Python shell中键入`help(Survey.save)`的人感到不知所措。
- en: This approach, though, does also have its down side. The tests for the code
    are no longer all in one place, making it hard to know or easily determine how
    completely the code is tested. Anyone who ran across the test in `tests.py`, without
    knowing there were additional tests in the method's docstring, might well wonder
    why only these two edge cases were tested and why a straightforward test of the
    basic function added was omitted.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也有其不利之处。代码的测试不再集中在一个地方，很难知道或轻松确定代码被完全测试了多少。如果有人在`tests.py`中遇到测试，却不知道方法的文档字符串中还有额外的测试，很可能会想知道为什么只测试了这两个边缘情况，为什么忽略了基本功能的直接测试。
- en: Also, when adding tests, it may not be clear (especially to programmers new
    to the project) where exactly the new tests should go. So even if a project starts
    out with a nice clean split of "tests that make for good documentation" in the
    docstring tests and "tests that are necessary but not good documentation" in the
    `tests.py` file, this distinction may easily become blurred over time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当添加测试时，可能不清楚（特别是对于新加入项目的程序员）新测试应该放在哪里。因此，即使项目一开始在文档字符串测试中有一个很好的清晰分割，“适合文档的测试”和“必要但不适合文档的测试”在`tests.py`文件中，随着时间的推移，这种区别可能很容易变得模糊。
- en: 'Test choice and placement thus involves a tradeoff. There is not necessarily
    a "right" answer for every project. Adopting a consistent approach, though, is
    best. When choosing that approach, each project team should take into account
    the answers to questions such as:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试选择和放置涉及权衡。并不是每个项目都有“正确”的答案。然而，采用一致的方法是最好的。在选择这种方法时，每个项目团队都应该考虑诸如以下问题的答案：
- en: '**What is the expected audience for auto-generated docstring-based documentation?**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动生成的基于文档字符串的文档的预期受众是谁？**'
- en: If other documentation exists (or is being written) that is expected to be the
    main source for "consumers" of the code, then it may not be a problem to have
    doctests that do not serve the documentation function very well.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在其他文档（或正在编写），预期它们将成为代码“使用者”的主要来源，那么具有不太好的文档功能的doctests可能并不是问题。
- en: '**How many people will likely be working on the code?**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可能会有多少人在代码上工作？**'
- en: If it is a relatively small and constant number, it may not be much of an issue
    to get everyone to remember about tests split between two places. For a larger
    project or if there is high developer turnover, educating developers about this
    sort of split may become more of an issue and it may be harder to maintain consistent
    code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人数相对较少且稳定，让每个人记住测试分散在两个地方可能不是什么大问题。对于一个较大的项目或者如果开发人员流动性较高，教育开发人员关于这种分割可能会成为更大的问题，而且可能更难维护一致的代码。
- en: Additional doctest caveats
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加的doctest注意事项
- en: Doctests have some additional disadvantages that we haven't necessarily run
    into or noticed yet. Some of these are just things we need to watch out for if
    we want to make sure our doctests will work properly in a wide variety of environments
    and as code surrounding our code changes. Others are more serious issues that
    are most easily solved by switching to unit tests instead of doctests for at least
    the affected tests. In this section, we will list many of the additional doctest
    issues to watch out for, and give guidance on what to do to avoid or overcome
    them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Doctests还有一些我们可能还没有遇到或注意到的额外缺点。其中一些只是我们需要注意的事项，如果我们想确保我们的doctests在各种环境中能正常工作，并且在我们的代码周围的代码发生变化时。其他更严重的问题最容易通过切换到单元测试而不是doctests来解决，至少对受影响的测试来说是这样。在本节中，我们将列出许多需要注意的额外doctest问题，并提供关于如何避免或克服这些问题的指导。
- en: Beware of environmental dependence
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意环境依赖
- en: It is very easy for doctests to be unintentionally dependent on implementation
    details of code other than the code that is actually being tested. We have some
    of this already in the `save` override tests, though we have not tripped over
    it yet. The dependence we have is actually a very specific form of environmental
    dependence—database dependence. As database dependence is a fairly big issue on
    its own, it will be discussed in detail in the next section. However, we'll first
    cover some other minor environmental dependencies we might easily run into and
    see how to avoid including them in our tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: doctests很容易无意中依赖于实际被测试的代码以外的代码的实现细节。我们在`save`覆盖测试中已经有了一些这样的情况，尽管我们还没有被这个问题绊倒。我们现在所面临的依赖实际上是一种非常特定的环境依赖——数据库依赖。由于数据库依赖本身就是一个相当大的问题，它将在下一节中详细讨论。然而，我们首先将介绍一些其他可能会遇到的次要环境依赖，并看看如何避免将它们包含在我们的测试中。
- en: 'An extremely common form of environmental dependence that creeps into doctests
    is relying on the printed representation of objects. For example, a `__unicode__`
    method is a common method to be implemented in a model class first. It was omitted
    from the earlier `Survey` model discussion since it wasn''t necessary at that
    time, but in reality we probably would have implemented `__unicode__` before the
    `save` override. A first pass at a `__unicode__` method for `Survey` may have
    looked something like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一种极其常见的环境依赖形式是依赖于对象的打印表示。例如，`__unicode__`方法是首先在模型类中实现的常见方法。它在之前的`Survey`模型讨论中被省略，因为那时并不需要，但实际上我们可能会在`save`覆盖之前实现`__unicode__`。对于`Survey`的第一次尝试`__unicode__`方法可能看起来像这样：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here we have decided that the printed representation of a `Survey` instance
    will consist of the title value followed by a parenthesized note about when this
    survey opens and closes. Given that method definition, our shell session for testing
    the proper setting of `closes` when it is not specified during creation may have
    looked something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们决定`Survey`实例的打印表示将由标题值后跟括号中的有关此调查何时开放和关闭的注释组成。鉴于该方法的定义，我们在测试创建实例时正确设置`closes`时的shell会话可能看起来像这样：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That is, instead of specifically checking the value assigned to `closes`, we
    may have just displayed the printed representation of the created instance, since
    it includes the `closes` value. When experimenting in a shell session, it's natural
    to perform checking this way rather than interrogating the attribute in question
    directly. For one thing, it's shorter (`s` is a good bit easier to type than `s.closes`).
    In addition, it often displays more information than the specific piece we may
    be testing, which is helpful when we are experimenting.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们可能不是专门检查`closes`分配的值，而是显示已创建实例的打印表示，因为它包括`closes`的值。在shell会话中进行实验时，自然而然地会以这种方式进行检查，而不是直接询问相关属性。首先，这样做更短（`s`比`s.closes`更容易输入）。此外，它通常显示的信息比我们可能正在测试的特定部分更多，这在我们进行实验时是有帮助的。
- en: 'However, if we had cut and pasted directly from that shell session into our
    `save` override doctest, we would have made that doctest dependent on the implementation
    details of `__unicode__`. We might subsequently decide we didn''t want to include
    all of that information in the printable representation of a `Survey`, or even
    just that it would look better if the "o" in "Opens" was not capitalized. So we
    make a minor change to the `__unicode__` method implementation and suddenly a
    doctest for an unrelated method begins to fail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们直接从shell会话中复制并粘贴到我们的`save`覆盖doctest中，我们就会使该doctest依赖于`__unicode__`的实现细节。随后，我们可能会决定不想在`Survey`的可打印表示中包含所有这些信息，甚至只是认为如果“Opens”中的“o”不大写会看起来更好。因此，我们对`__unicode__`方法的实现进行了微小的更改，突然间一个与其他方法无关的doctest开始失败了。
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Thus when creating doctests from shell sessions, it's good to carefully consider
    whether the session relied on implementation details of any code other than that
    specifically being tested, and if so make adjustments to remove the dependence.
    In this case, using `s.closes` to test what value has been assigned to `closes`
    removes the dependence on how the `Survey` model `__unicode__` method happens
    to be implemented.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在从shell会话创建doctests时，需要仔细考虑会话是否依赖于被测试的代码以外的任何代码的实现细节，并相应地进行调整以消除这种依赖。在这种情况下，使用`s.closes`来测试`closes`被赋予了什么值，消除了对`Survey`模型`__unicode__`方法实现方式的依赖。
- en: 'There are many other cases of environmental dependence that may arise in doctests,
    including:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在doctests中可能会出现许多其他环境依赖的情况，包括：
- en: Any test that relies on the printed representation of a file path can run afoul
    of the fact that on Unix-based operating systems path components are separated
    by a forward slash where Windows uses a backslash. If you need to include doctests
    that rely on file path values, it may be necessary to use a utility function to
    normalize file path representations across different operating systems.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何依赖于文件路径打印表示的测试都可能会遇到问题，因为在基于Unix的操作系统上，路径组件由正斜杠分隔，而Windows使用反斜杠。如果需要包含依赖于文件路径值的doctests，可能需要使用实用函数来规范不同操作系统上的文件路径表示。
- en: Any test that relies on dictionary keys being printed in a specific order can
    run afoul of the fact that this order may be different for different operating
    systems or Python implementations. Thus to make such tests robust across different
    platforms, it may be necessary to specifically interrogate dictionary key values
    instead of simply printing the entire dictionary contents, or use a utility function
    that applies a consistent order to the keys for the printed representation.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何依赖于字典键以特定顺序打印的测试都可能会遇到一个问题，即这个顺序在不同操作系统或Python实现中可能是不同的。因此，为了使这些测试在不同平台上更加健壮，可能需要专门查询字典键值，而不仅仅是打印整个字典内容，或者使用一个实用函数，为打印表示应用一致的顺序到键上。
- en: 'There is nothing particularly specific to Django about these kinds of environmental
    dependence issues that often arise in doctests. There is, however, one type of
    environmental dependence that is particularly likely to arise in a Django application:
    database dependence. This issue is discussed next.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些在doctests中经常出现的环境依赖问题，没有什么特别与Django相关的内容。然而，在Django应用程序中特别容易出现一种环境依赖：数据库依赖。接下来将讨论这个问题。
- en: Beware of database dependence
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警惕数据库依赖
- en: The Django **object-relational manager** (**ORM**) goes through considerable
    trouble to shield application code from differences in the underlying databases.
    However, it is not feasible for Django to make all of the different supported
    databases look exactly the same under all circumstances. Thus it is possible to
    observe database-specific differences at the application level. These differences
    may then easily find their way into doctests, making the tests dependent on a
    specific database backend in order to pass.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Django的**对象关系管理器**（**ORM**）非常费力地屏蔽应用程序代码与底层数据库的差异。但是，让所有不同的支持的数据库在所有情况下看起来完全相同对Django来说是不可行的。因此，在应用程序级别可能观察到特定于数据库的差异。这些差异可能很容易进入doctests，使得测试依赖于特定的数据库后端才能通过。
- en: 'This sort of dependence is already present in the `save` override tests developed
    earlier in this chapter. Because SQLite is the easiest database to use (since
    it requires no installation or configuration), so far the example code and tests
    have been developed using a setting of `DATABASE_ENGINE = ''sqlite3''` in `settings.py`.
    If we switch to using MySQL (`DATABASE_ENGINE = ''mysql''`) for the database instead,
    and attempt to run our `survey` application tests, we will see failures. There
    are two failures, but we will first focus only on the last one in the test output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种依赖已经存在于本章早期开发的`save`覆盖测试中。因为SQLite是最容易使用的数据库（因为它不需要安装或配置），所以到目前为止，示例代码和测试都是使用`settings.py`中的`DATABASE_ENGINE
    = 'sqlite3'`设置开发的。如果我们切换到使用MySQL（`DATABASE_ENGINE = 'mysql'`）作为数据库，并尝试运行我们的`survey`应用程序测试，我们将看到失败。有两个失败，但我们首先只关注测试输出中的最后一个：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What''s the problem here? For the `save` call in the doctest in `tests.py`
    where no value for `opens` was specified, an `IntegrityError` was expected, and
    an `IntegrityError` was produced, but the details of the `IntegrityError` message
    are different. The SQLite database returns:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是什么？在`tests.py`中的doctest中的`save`调用中没有为`opens`指定值，预期会出现`IntegrityError`，而确实出现了`IntegrityError`，但`IntegrityError`消息的细节是不同的。SQLite数据库返回：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'MySQL says the same thing somewhat differently:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL以稍微不同的方式表达了同样的观点：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are two simple ways to fix this. One is to use the doctest directive `IGNORE_EXCEPTION_DETAIL`
    on the failing test. With this option, the doctest runner will only consider the
    type of exception (in this case, `IntegrityError`) when determining whether the
    expected result matches the actual result. So differences in the exact exception
    messages produced by the different databases will not cause the test to fail.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种简单的方法可以解决这个问题。一种是在失败的测试上使用doctest指令`IGNORE_EXCEPTION_DETAIL`。使用此选项，doctest运行程序在确定预期结果是否与实际结果匹配时，只会考虑异常的类型（在本例中为`IntegrityError`）。因此，不同数据库产生的确切异常消息的差异不会导致测试失败。
- en: 'Doctest directives are specified for individual tests by placing them as comments
    on the line containing the test. The comment starts with `doctest:` and is followed
    by one or more directive names preceded either by `+` to turn the option on or
    `–` to turn the option off. So in this case, we would change the failing test
    line in `tests.py` to be (note that though this line wraps to a second line on
    this page, it needs to be kept on a single line in the test):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在包含测试的行上将doctest指令指定为单个测试来指定。注释以`doctest：`开头，后面跟着一个或多个指令名称，前面是`+`表示打开选项，`-`表示关闭选项。因此，在这种情况下，我们将更改`tests.py`中失败的测试行为（请注意，尽管此行在此页面上换行到第二行，但在测试中需要保持在一行上）：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The other way to fix this is to replace the detailed message portion of the
    expected output in the test with three dots, which is an ellipsis marker. That
    is, change the test to be:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种修复方法是用省略号替换测试中预期输出的详细消息部分，省略号是一个省略标记。也就是说，将测试更改为：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is an alternate way to tell the doctest runner to ignore the specifics
    of the exception message. It relies on the doctest option `ELLIPSIS` being enabled
    for the doctest run. While this option is not enabled by default by Python, it
    is enabled by the doctest runner that Django uses, so you do not need to do anything
    in your test code to enable use of ellipsis markers in expected output. Also note
    that `ELLIPSIS` is not specific to exception message details; it's a more general
    method that lets you indicate portions of doctest output that may differ from
    run to run without resulting in test failure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是告诉doctest运行器忽略异常消息的具体方法。它依赖于doctest选项`ELLIPSIS`在doctest运行时被启用。虽然这个选项在Python中默认情况下是不启用的，但是Django使用的doctest运行器启用了它，所以你不需要在你的测试代码中做任何事情来启用期望输出中的省略号标记。还要注意，`ELLIPSIS`不仅仅适用于异常消息的细节；它是一种更一般的方法，让你指示doctest输出的部分可能因运行而异，而不会导致测试失败。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you read the Python documentation for `ELLIPSIS`, you may notice that it
    was introduced in Python 2.4\. You may expect, then, if you are running Python
    2.3 (which is still supported by Django 1.1), that you would not be able to use
    the ellipsis marker technique in your Django application's doctests. However,
    Django 1.0 and 1.1 ship with a customized doctest runner that is used when you
    run your application's doctests. This customized runner is based on the doctest
    module that is shipped with Python 2.4\. Thus you can use doctest options, such
    as `ELLIPSIS`, from Python 2.4 even if you are running an earlier Python version.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了`ELLIPSIS`的Python文档，你可能会注意到它是在Python 2.4中引入的。因此，如果你正在运行Python 2.3（这仍然是Django
    1.1支持的），你可能会期望在你的Django应用程序的doctests中无法使用省略号标记技术。然而，Django 1.0和1.1附带了一个定制的doctest运行器，当你运行你的应用程序的doctests时会使用它。这个定制的运行器是基于Python
    2.4附带的doctest模块的。因此，即使你运行的是早期的Python版本，你也可以使用Python 2.4中的doctest选项，比如`ELLIPSIS`。
- en: 'Note, though, the flip side of Django using its own customized doctest runner:
    if you are running a more recent Python version than 2.4, you cannot use doctest
    options added later than 2.4 in your application''s doctests. For example, Python
    added the `SKIP` option in Python 2.5\. Until Django updates the version of its
    customized doctest module, you will not be able to use this new option in your
    Django application doctests.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管Django使用自己定制的doctest运行器的另一面是：如果你运行的Python版本比2.4更新，你不能在应用程序的doctests中使用比2.4更晚添加的doctest选项。例如，Python在Python
    2.5中添加了`SKIP`选项。在Django更新其定制的doctest模块的版本之前，你将无法在Django应用程序的doctests中使用这个新选项。
- en: 'Recall that there were two test failures and we only looked at the output from
    one (the other most likely scrolled off the screen too quickly to read). Given
    what the one failure we examined was, though, we might expect the other one would
    be the same, since we have a very similar test for an `IntegrityError` in the
    doctest in `models.py`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，有两次测试失败，我们只看了其中一个的输出（另一个很可能滚动得太快，无法阅读）。然而，考虑到我们检查过的一个失败，我们可能期望另一个也是一样的，因为在`models.py`的doctest中，我们对`IntegrityError`有一个非常相似的测试：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will certainly also need to be fixed to ignore the exception detail, so
    we may as well do both at the same time and perhaps correct both test failures.
    And in fact, when we run the tests again after changing both expected `IntegrityErrors`
    to include an ellipsis marker instead of a specific error message, the tests all
    pass.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定也需要被修复以忽略异常细节，所以我们可能会同时做这两件事，并且可能会纠正两个测试失败。事实上，当我们在将两个预期的`IntegrityErrors`都更改为包含省略号标记而不是具体错误消息后再次运行测试时，所有的测试都通过了。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that for some configurations of MySQL, this second test failure will not
    be corrected by ignoring the exception details. Specifically, if the MySQL server
    is configured to run in "non-strict" mode, attempting to update a row to contain
    a `NULL` value in a column declared as `NOT NULL` does not raise an error. Rather,
    the value is set to the implicit default value for the column's type and a warning
    is issued.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于某些MySQL的配置，忽略异常细节将无法纠正第二个测试失败。具体来说，如果MySQL服务器配置为以“非严格”模式运行，尝试将行更新为包含`NULL`值的列声明为`NOT
    NULL`不会引发错误。相反，该值将设置为列类型的隐式默认值，并发出警告。
- en: Most likely if you are using MySQL, you will want to configure it to run in
    "strict mode". However, if for some reason you cannot, and you need to have a
    test like this in your application, and you need the test to pass on multiple
    databases, you would have to account for that difference in database behavior
    in your test. It can be done, but it is much more easily done in a unit test than
    a doctest, so we will not cover how to fix the doctest for this case.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，如果你正在使用MySQL，你会想要配置它以在“严格模式”下运行。然而，如果由于某种原因你不能这样做，并且你需要在你的应用程序中有这样一个测试，并且你需要测试在多个数据库上通过，你将不得不考虑在你的测试中考虑数据库行为的差异。这是可以做到的，但在单元测试中更容易完成，而不是在doctest中，所以我们不会讨论如何修复这种情况的doctest。
- en: Now that we have gotten our tests to pass on two different database backends,
    we may think we are set and would likely get a clean test run on all databases
    that Django supports. We'd be wrong, as we will discover when we attempt to run
    these same tests using PostgreSQL as the database. The database difference we
    encounter with PostgreSQL highlights the next item to beware of when writing doctests,
    and is covered in the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让我们的测试在两个不同的数据库后端上通过了，我们可能会认为我们已经准备好了，并且可能会在Django支持的所有数据库上获得一个干净的测试运行。我们错了，当我们尝试使用PostgreSQL作为数据库运行相同的测试时，我们会发现数据库的差异，这突出了在编写doctests时需要注意的下一项内容，并在下一节中进行了介绍。
- en: Beware of test interdependence
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意测试之间的相互依赖
- en: 'We get a very curious result if we now try running our tests using PostgreSQL
    as the database (specify `DATABASE_ENGINE = ''postgresql_psycopg2''` in `settings.py`).
    From the tail end of the output of `manage.py test survey -v2`, we see:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试使用PostgreSQL作为数据库运行我们的测试（在`settings.py`中指定`DATABASE_ENGINE = 'postgresql_psycopg2'`），我们会得到一个非常奇怪的结果。从`manage.py
    test survey -v2`的输出的末尾，我们看到：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The sample unit test we still have in `tests.py` runs and passes, then the
    doctest from `models.py` also passes, but the doctest we added to `tests.py` fails.
    The failure details are:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在`tests.py`中有一个样本单元测试运行并通过，然后`models.py`中的doctest也通过了，但我们添加到`tests.py`中的doctest失败了。失败的细节是：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '****This time we need to examine the reported errors in order as the second
    error is resulting from the first. Such chaining of errors is common, so it is
    good to keep in mind that while it may be tempting to start by looking at the
    last failure, since it is the easiest one to see at the end of the test run, that
    may not be the most productive route. If it isn''t immediately obvious what is
    causing the last failure, it''s usually best to start at the beginning and figure
    out what is causing the first failure. The reason for subsequent failures may
    then become obvious. For reference, the beginning of the test that is failing
    is:****'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们需要按顺序检查报告的错误，因为第二个错误是由第一个错误导致的。这种错误的链接是常见的，因此要记住，虽然从测试运行结束时最容易看到的最后一个失败开始可能很诱人，但这可能不是最有效的方法。如果不立即明显导致最后一个失败的原因，通常最好从头开始，找出导致第一个失败的原因。随后的失败原因可能会变得明显。供参考，正在失败的测试的开头是：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '****Thus, based on the test output, the very first attempt to access the database—that
    is the attempt to create a `Survey` instance—in this test results in an error:****'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据测试输出，这个测试中对数据库的第一次访问——也就是尝试创建`Survey`实例——导致了错误。
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '****Then the next line of the test also results in an error as it uses the
    variable `s` that was supposed to be assigned in the previous line. However, that
    line did not complete execution, so the variable `s` is not defined when the test
    attempts to use it. So the second error makes sense given the first, but why did
    the first database access in this test result in an error?****'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试的下一行也会导致错误，因为它使用了应该在上一行中分配的变量`s`。然而，那一行没有完成执行，所以当测试尝试使用它时，变量`s`没有被定义。因此，第二个错误是有道理的，考虑到第一个错误，但为什么这个测试中的第一个数据库访问会导致错误呢？
- en: '****In order to understand the explanation for that, we have to look back at
    the test that ran immediately preceding this one. We can see from the test output
    that the test immediately preceding this one was the doctest in `models.py`. The
    end of that test is:****'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点的解释，我们必须回顾一下紧接在这个测试之前运行的测试。从测试输出中我们可以看到，紧接在这个测试之前的测试是`models.py`中的doctest。该测试的结尾是：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '****The last thing that test did was something that was expected to raise a
    database error. A side-effect of this, on PostgreSQL, is that the database connection
    enters a state where the only commands it will allow are ones that end the transaction
    block. So this test ended leaving the database connection in a broken state, and
    it was still broken when the next doctest began running, causing the next doctest
    to fail as soon as it attempted any database access.****'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的最后一件事是预期引发数据库错误的事情。在PostgreSQL上的一个副作用是，数据库连接进入了一个状态，只允许结束事务块的命令。因此，这个测试结束时，数据库连接处于一个破碎的状态，当下一个doctest开始运行时，它仍然处于破碎状态，导致下一个doctest在尝试任何数据库访问时立即失败。
- en: '****This problem illustrates that there is no database isolation between doctests.
    What one doctest does to the database can be observed by subsequent ones that
    run. This includes problems such as the one seen here, in addition to creation,
    updates, or deletion of rows in the database tables. This particular problem can
    be solved by adding a call to rollback the current transaction following the code
    that deliberately caused a database error:****'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题说明了doctests之间没有数据库隔离。一个doctest对数据库的操作可以被后续运行的doctest观察到。这包括在数据库表中创建、更新或删除行的问题，以及在这里看到的问题。这个特定的问题可以通过在故意引起数据库错误的代码后添加一个回滚当前事务的调用来解决。
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '****This will allow the tests to pass on PostgreSQL and will be harmless on
    the other database backends. Thus one way to deal with no database isolation in
    doctests is to code them so that they clean up after themselves. That may be an
    acceptable approach for problems such as this one, but if a test has added, modified,
    or deleted objects in the database, it may be difficult to put everything back
    the way it was originally at the end.****'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许测试在PostgreSQL上通过，并且在其他数据库后端上是无害的。因此，处理doctests中没有数据库隔离的一种方法是编写代码，使它们在自己之后进行清理。这可能是一个可以接受的方法，但如果测试已经在数据库中添加、修改或删除了对象，可能很难将一切恢复到最初的状态。
- en: '****A second approach is to reset the database to a known state on entry to
    every doctest. Django does not do this for you, but you can do it manually by
    calling the management command to synchronize the database. I would not recommend
    this approach in general because it becomes extremely time-consuming as your application
    grows.****'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是在每个doctest进入时将数据库重置为已知状态。Django不会为您执行此操作，但您可以通过调用管理命令来手动执行。我通常不建议这种方法，因为随着应用程序的增长，它变得非常耗时。
- en: '****A third approach is to make doctests reasonably tolerant of database state,
    so that they will be likely to run properly regardless of whether other tests
    may or may not have run before them. Techniques to use here include:****'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是使doctests在数据库状态上相对宽容，这样它们可能会在其他测试是否运行过的情况下正常运行。在这里使用的技术包括：
- en: '****Create all objects needed by the test in the test itself. That is, do not
    rely on the existence of objects created by any previously-run tests since that
    test may change, or be removed, or the order in which tests run may change at
    some time.****'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试本身创建测试所需的所有对象。也就是说，不要依赖于任何先前运行的测试创建的对象的存在，因为该测试可能会更改，或被删除，或测试运行的顺序可能会在某个时候更改。
- en: '****When creating objects, guard against collisions with similar objects that
    may be created by other tests. For example, if a test needs to create a `User`
    instance with the `is_superuser` field set to `True` in order to test certain
    behavior for users that have that attribute, it might seem natural to give the
    `User` instance a `username` of "superuser". However, if two doctests did that,
    then whichever one was unlucky enough to run second would encounter an error because
    the `username` field of the `User` model is declared to be unique, so the second
    attempt to create a `User` with this `username` would fail. Thus it is best to
    use values for unique fields in shared models that are unlikely to have been used
    by other tests.****'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建对象时，要防止与其他测试可能创建的相似对象发生冲突。例如，如果一个测试需要创建一个`is_superuser`字段设置为`True`的`User`实例，以便测试具有该属性的用户的某些行为，那么给`User`实例一个`username`为"superuser"可能是很自然的。然而，如果两个doctest都这样做了，那么不幸的是第二个运行的测试会遇到错误，因为`User`模型的`username`字段被声明为唯一，所以第二次尝试使用这个`username`创建`User`会失败。因此，最好使用在共享模型中不太可能被其他测试使用的唯一字段的值。
- en: '****All of these approaches and techniques have their disadvantages. For this
    particular issue, unit tests are a much better solution, as they automatically
    provide database isolation without incurring a performance cost to reset the database
    (so long as you run them on a database that supports transactions). Thus if you
    start encountering a lot of test interdependence issues with doctests, I''d strongly
    suggest considering unit tests as a solution instead of relying on any of the
    approaches listed here.****'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法和技术都有其缺点。对于这个特定问题，单元测试是一个更好的解决方案，因为它们可以自动提供数据库隔离，而不会产生重置数据库的性能成本（只要在支持事务的数据库上运行）。因此，如果你开始遇到很多doctest的测试相互依赖的问题，我强烈建议考虑单元测试作为解决方案，而不是依赖于这里列出的任何方法。
- en: '****Beware of Unicode****'
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谨防Unicode
- en: '****The final issue we will cover in doctest caveats is Unicode. If you have
    done much work with Django (or even just Python) using data from languages with
    character sets broader than English, you''ve likely run into `UnicodeDecodeError`
    or `UnicodeEncodeError` once or twice. As a result, you may have gotten into the
    habit of routinely including some non-ASCII characters in your tests to ensure
    that everything is going to work properly for all languages, not just English.
    That''s a good habit, but unfortunately testing with Unicode values in doctests
    has some unexpected glitches that need to be overcome.****'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在doctest注意事项中涵盖的最后一个问题是Unicode。如果你在Django（甚至只是Python）中使用了比英语更广泛的字符集的数据，你可能已经遇到过`UnicodeDecodeError`或`UnicodeEncodeError`一两次。因此，你可能已经养成了在测试中包含一些非ASCII字符的习惯，以确保一切都能正常工作，不仅仅是英语。这是一个好习惯，但不幸的是，在doctest中使用Unicode值进行测试会出现一些意想不到的故障，需要克服。
- en: '****The previously mentioned `__unicode__` method of `Survey` would be a likely
    place we would want to test for proper behavior in the face of non-ASCII characters.
    A first pass at a test for this might be:****'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 先前提到的`Survey`的`__unicode__`方法可能是我们希望在面对非ASCII字符时测试其行为是否正确的一个地方。对此进行测试的第一步可能是：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '****This test is similar to many of the save override tests in that it first
    creates a `Survey` instance. The significant parameter in this case is the title,
    which is specified as a Unicode literal string and contains non-ASCII characters.
    After the `Survey` instance is created, a call is made to print it in order to
    verify that the non-ASCII characters are displayed correctly in the printed representation
    of the instance, and that no Unicode exceptions are raised.****'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与许多保存覆盖测试类似，因为它首先创建了一个`Survey`实例。在这种情况下，重要的参数是标题，它被指定为Unicode文字字符串，并包含非ASCII字符。创建了`Survey`实例后，调用打印它以验证非ASCII字符在实例的打印表示中是否正确显示，并且没有引发Unicode异常。
- en: '****How well does this test work? Not so well. Attempting to run the survey
    tests after adding that code will result in an error:****'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试效果如何？不太好。在添加了那段代码后，尝试运行调查测试会导致错误：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '****This one is easy to fix; we simply forgot to declare the encoding for our
    Python source file. To do that, we need to add a comment line to the top of the
    file specifying the encoding used by the file. Let''s assume we are using UTF-8
    encoding, so we should add the following as the first line of our `models.py`
    file:****'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很容易解决；我们只是忘记了声明Python源文件的编码。为了做到这一点，我们需要在文件顶部添加一个注释行，指定文件使用的编码。假设我们使用UTF-8编码，所以我们应该将以下内容添加为我们的`models.py`文件的第一行：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '****Now will the new test work? Not yet, we still get a failure:****'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在新的测试会起作用吗？还没有，我们仍然失败了：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '****This one is a bit puzzling. Though we specified the title as a Unicode
    literal string `u''¿Como está usted?''` in our test, it is apparently coming back
    as **Â¿Como estÃ¡ usted?** when printed. Data corruption like this is a telltale
    sign that the wrong encoding has been used at some point to transform a bytestring
    into a Unicode string. In fact the specific nature of the corruption here, where
    each non-ASCII character in the original string has been replaced by two (or more)
    characters in the corrupted version, is the characteristic of a string which is
    actually encoded in UTF-8 being interpreted as if it were encoded in ISO-8859-1
    (also called Latin-1). But how could that happen here, as we specified UTF-8 as
    our Python file encoding declaration? Why would this string be interpreted using
    any other encoding?****'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点令人费解。虽然我们在测试中将标题指定为Unicode文字字符串`u'¿Como está usted?'`，但打印出来时显然是**Â¿Como
    estÃ¡ usted?**。这种数据损坏是错误地使用了错误的编码将字节字符串转换为Unicode字符串的明显迹象。事实上，这里的损坏特性，即原始字符串中的每个非ASCII字符在损坏版本中被两个（或更多）字符替换，是实际上以UTF-8编码的字符串被解释为如果它是以ISO-8859-1（也称为Latin-1）编码的特征。但是这里怎么会发生这种情况，因为我们指定了UTF-8作为我们的Python文件编码声明？为什么这个字符串会使用其他编码来解释？
- en: '****At this point, we might go and carefully read the web page referenced in
    the first error message we got, and learn that the encoding declaration we have
    added only has an effect on how Unicode literal strings are constructed by the
    Python interpreter from the source file. We may then notice that though our title
    is a Unicode literal string, the doctest it is contained in is not. So perhaps
    this odd result is because we neglected to make the docstring containing the doctest
    a Unicode literal. Our next version of the test, then, might be to specify the
    whole docstring as a Unicode literal.****'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可能会去仔细阅读我们收到的第一个错误消息中引用的网页，并了解到我们添加的编码声明只影响Python解释器从源文件构造Unicode文字字符串的方式。然后我们可能会注意到，尽管我们的标题是一个Unicode文字字符串，但包含doctest的文档字符串却不是。因此，也许这个奇怪的结果是因为我们忽略了将包含doctest的文档字符串作为Unicode文字字符串。因此，我们下一个版本的测试可能是将整个文档字符串指定为Unicode文字字符串。
- en: '****Unfortunately this too would be unsuccessful, due to problems with Unicode
    literal docstrings. First the doctest runner cannot correctly compare expected
    output (now Unicode, since the docstring itself is a Unicode literal) with actual
    output that is a bytestring containing non-ASCII characters. Such a bytestring
    must be converted to Unicode in order to perform the comparison. Python will automatically
    perform this conversion when necessary, but the problem is that it does not know
    the actual encoding of the bytestring it is converting. Thus it assumes ASCII,
    and fails to perform the conversion if the bytestring contains any non-ASCII characters.****'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这也将是不成功的，因为存在Unicode文字文档字符串的问题。首先，doctest运行器无法正确比较预期输出（现在是Unicode，因为文档字符串本身是Unicode文字）和包含非ASCII字符的字节串的实际输出。这样的字节串必须转换为Unicode以进行比较。当必要时，Python将自动执行此转换，但问题在于它不知道正在转换的字节串的实际编码。因此，它假定为ASCII，并且如果字节串包含任何非ASCII字符，则无法执行转换。
- en: '****This failure in conversion will lead to an assumed failure of the comparison
    involving the bytestring, which in turn will lead to the test being reported as
    failing. Even if the expected and received outputs were identical, if only the
    right encoding were assumed for the bytestring, there is no way to get the proper
    encoding to be used, so the test will fail. For the `Survey` model `__unicode__`
    doctest, this problem will cause the test to fail when attempting to compare the
    actual output of `print s` (which will be a UTF-8 encoded bytestring) to the expected
    output.****'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换失败将导致涉及字节串的比较被假定为失败，进而导致测试被报告为失败。即使预期和接收到的输出是相同的，如果只假定了字节串的正确编码，也没有办法使正确的编码被使用，因此测试将失败。对于`Survey`模型`__unicode__`
    doctest，这个问题将导致在尝试比较`print s`的实际输出（这将是一个UTF-8编码的字节串）和预期输出时测试失败。
- en: '****A second problem with Unicode literal docstrings involves reporting of
    output that contains non-ASCII characters, such as this failure that will occur
    with the `Survey` model `__unicode__` doctest. The doctest runner will attempt
    to display a message showing the expected and received outputs. However, it will
    run into the same problem as encountered during the comparison when it attempts
    to combine the expected and received outputs into a single message for display.
    Thus instead of generating a message that would at least reveal where the test
    is running into trouble, the doctest runner itself generates a `UnicodeDecodeError`.****'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode文字文档字符串的第二个问题涉及包含非ASCII字符的输出的报告，例如在`Survey`模型`__unicode__` doctest中将发生的失败。doctest运行器将尝试显示一个消息，显示预期和接收到的输出。然而，当它尝试将预期和接收到的输出合并成一个用于显示的单个消息时，它将遇到与比较期间遇到的相同问题。因此，与其生成一个至少能够显示测试遇到问题的消息，doctest运行器本身会生成`UnicodeDecodeError`。
- en: '****There is an open Python issue in Python''s bug tracker that reports these
    problems: [http://bugs.python.org/issue1293741](http://bugs.python.org/issue1293741).
    Until it is fixed, it is probably best to avoid using Unicode literal docstrings
    for doctests.****'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Python的bug跟踪器中有一个未解决的Python问题报告了这些问题：[http://bugs.python.org/issue1293741](http://bugs.python.org/issue1293741)。在它被修复之前，最好避免在doctests中使用Unicode文字文档字符串。
- en: '****Is there any way, then, to include some testing of non-ASCII data in doctests?
    Yes, it is possible. The key to making such tests work is to avoid using Unicode
    literals within the docstring. Instead, explicitly decode strings to Unicode objects.
    For example:****'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有没有办法在doctests中包含一些非ASCII数据的测试？是的，这是可能的。使这样的测试起作用的关键是避免在文档字符串中使用Unicode文字。而是显式将字符串解码为Unicode对象。例如：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '****That is, replace the Unicode literal title string with a bytestring that
    is explicitly decoded using UTF-8 to create a Unicode string.****'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，用一个明确使用UTF-8解码的字节串替换Unicode文字标题字符串，以创建一个Unicode字符串。
- en: '****Does that work? Running `manage.py test survey -v2` now, we see the following
    at the tail end of the output:****'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做有用吗？现在运行`manage.py test survey -v2`，我们在输出的最后看到以下内容：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '****Success! It is possible, then, to correctly test with non-ASCII data in
    doctests. Some care must simply be taken to avoid running into existing problems
    related to using Unicode literal docstrings or embedding Unicode literal strings
    within a doctest.****'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！因此，在doctests中正确测试非ASCII数据是可能的。只需注意避免遇到使用Unicode文字文档字符串或在doctest中嵌入Unicode文字字符串相关的现有问题。
- en: '****# Summary'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '# 总结'
- en: 'Our exploration of doctests for Django applications is now complete. In this
    chapter, we:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Django应用程序的doctests的探索现在已经完成。在本章中，我们：
- en: Began to develop some models for our Django `survey` application
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始为我们的Django`survey`应用程序开发一些模型
- en: Experimented with adding doctests to one of these models—the `Survey` model
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试向其中一个模型添加doctests——`Survey`模型
- en: Learned what sorts of doctests are useful and which simply add clutter to the
    code
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解了哪些类型的doctests是有用的，哪些只是为代码添加了混乱
- en: Experienced some of the advantages of doctests, namely the easy re-use of Python
    shell session work and convenient use of doctests as documentation
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体验了doctests的一些优势，即轻松重用Python shell会话工作和方便地将doctests用作文档
- en: Ran afoul of many of the disadvantages of doctests, and learned how to avoid
    or overcome them
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到了许多doctests的缺点，并学会了如何避免或克服它们
- en: 'In the next chapter, we will begin to explore unit tests. While unit tests
    may not offer some of the easy re-use features of doctests, they also do not suffer
    from many of the disadvantages of doctests. Furthermore, the overall unit test
    framework allows Django to provide convenient support specifically useful for
    web applications, which will be covered in detail in [Chapter 4](ch04.html "Chapter 4. Getting
    Fancier: Django Unit Test Extensions").****'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探索单元测试。虽然单元测试可能不提供一些doctests的轻松重用功能，但它们也不会受到许多doctests的缺点的影响。此外，整体的单元测试框架允许Django提供特别适用于Web应用程序的便利支持，这将在[第4章](ch04.html
    "第4章。变得更高级：Django单元测试扩展")中详细介绍。
