- en: Chapter 3. When Objects Are Alike
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。当对象相似时
- en: In the programming world, duplicate code is considered evil. We should not have
    multiple copies of the same, or similar, code in different places.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，重复的代码被认为是邪恶的。我们不应该在不同的地方有相同或相似的代码的多个副本。
- en: 'There are many ways to merge pieces of code or objects that have a similar
    functionality. In this chapter, we''ll be covering the most famous object-oriented
    principle: inheritance. As discussed in [Chapter 1](ch01.html "Chapter 1. Object-oriented
    Design"), *Object-oriented Design*, inheritance allows us to create *is a* relationships
    between two or more classes, abstracting common logic into superclasses and managing
    specific details in the subclass. In particular, we''ll be covering the Python
    syntax and principles for:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以合并具有类似功能的代码或对象。在本章中，我们将介绍最著名的面向对象原则：继承。如[第1章](ch01.html "第1章。面向对象设计")中所讨论的，继承允许我们在两个或多个类之间创建*是*关系，将通用逻辑抽象为超类，并在子类中管理特定细节。特别是，我们将介绍Python的语法和原则：
- en: Basic inheritance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本继承
- en: Inheriting from built-ins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内置继承
- en: Multiple inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重继承
- en: Polymorphism and duck typing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态和鸭子类型
- en: Basic inheritance
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本继承
- en: Technically, every class we create uses inheritance. All Python classes are
    subclasses of the special class named `object`. This class provides very little
    in terms of data and behaviors (the behaviors it does provide are all double-underscore
    methods intended for internal use only), but it does allow Python to treat all
    objects in the same way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们创建的每个类都使用继承。所有Python类都是名为`object`的特殊类的子类。这个类在数据和行为方面提供的很少（它提供的行为都是双下划线方法，仅供内部使用），但它确实允许Python以相同的方式处理所有对象。
- en: 'If we don''t explicitly inherit from a different class, our classes will automatically
    inherit from `object`. However, we can openly state that our class derives from
    `object` using the following syntax:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有明确从不同的类继承，我们的类将自动从`object`继承。但是，我们可以明确声明我们的类派生自`object`，使用以下语法：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is inheritance! This example is, technically, no different from our very
    first example in [Chapter 2](ch02.html "Chapter 2. Objects in Python"), *Objects
    in Python*, since Python 3 automatically inherits from `object` if we don't explicitly
    provide a different superclass. A superclass, or parent class, is a class that
    is being inherited from. A subclass is a class that is inheriting from a superclass.
    In this case, the superclass is `object`, and `MySubClass` is the subclass. A
    subclass is also said to be derived from its parent class or that the subclass
    extends the parent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是继承！从技术上讲，这个例子与我们在[第2章](ch02.html "第2章。Python中的对象")中的第一个例子没有什么不同，因为如果我们没有明确提供不同的超类，Python
    3会自动从`object`继承。超类或父类是被继承的类。子类是继承自超类的类。在这种情况下，超类是`object`，而`MySubClass`是子类。子类也被称为从其父类派生，或者说子类扩展了父类。
- en: As you've probably figured out from the example, inheritance requires a minimal
    amount of extra syntax over a basic class definition. Simply include the name
    of the parent class inside parentheses after the class name but before the colon
    terminating the class definition. This is all we have to do to tell Python that
    the new class should be derived from the given superclass.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经从示例中了解到的那样，继承需要比基本类定义多一点额外的语法。只需在类名后面的冒号之前的括号内包含父类的名称，但在类定义结束之前。这就是我们要告诉Python的所有内容，新类应该从给定的超类派生。
- en: 'How do we apply inheritance in practice? The simplest and most obvious use
    of inheritance is to add functionality to an existing class. Let''s start with
    a simple contact manager that tracks the name and e-mail address of several people.
    The contact class is responsible for maintaining a list of all contacts in a class
    variable, and for initializing the name and address for an individual contact:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在实践中应用继承？继承的最简单和最明显的用法是向现有类添加功能。让我们从一个简单的联系人管理器开始，跟踪几个人的姓名和电子邮件地址。联系人类负责在一个类变量中维护所有联系人的列表，并为单个联系人初始化名称和地址：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example introduces us to class variables. The `all_contacts` list, because
    it is part of the class definition, is shared by all instances of this class.
    This means that there is only one `Contact.all_contacts` list, which we can access
    as `Contact.all_contacts`. Less obviously, we can also access it as `self.all_contacts`
    on any object instantiated from `Contact`. If the field can't be found on the
    object, then it will be found on the class and thus refer to the same single list.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们介绍了类变量。`all_contacts`列表，因为它是类定义的一部分，被所有这个类的实例共享。这意味着只有一个`Contact.all_contacts`列表，我们可以访问为`Contact.all_contacts`。更不明显的是，我们也可以在从`Contact`实例化的任何对象上作为`self.all_contacts`访问它。如果在对象上找不到该字段，那么它将在类上找到，从而引用相同的单个列表。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be careful with this syntax, for if you ever *set* the variable using `self.all_contacts`,
    you will actually be creating a **new** instance variable associated only with
    that object. The class variable will still be unchanged and accessible as `Contact.all_contacts`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这种语法，因为如果您使用`self.all_contacts`*设置*变量，您实际上将创建一个**新的**与该对象关联的实例变量。类变量仍然不变，并且可以作为`Contact.all_contacts`访问。
- en: 'This is a simple class that allows us to track a couple pieces of data about
    each contact. But what if some of our contacts are also suppliers that we need
    to order supplies from? We could add an `order` method to the `Contact` class,
    but that would allow people to accidentally order things from contacts who are
    customers or family friends. Instead, let''s create a new `Supplier` class that
    acts like our `Contact` class, but has an additional `order` method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，允许我们跟踪每个联系人的一些数据。但是，如果我们的一些联系人也是我们需要从中订购物品的供应商呢？我们可以在`Contact`类中添加一个`order`方法，但这将允许人们意外地从客户或家庭朋友的联系人那里订购东西。相反，让我们创建一个新的`Supplier`类，它的行为类似于我们的`Contact`类，但有一个额外的`order`方法：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, if we test this class in our trusty interpreter, we see that all contacts,
    including suppliers, accept a name and e-mail address in their `__init__`, but
    only suppliers have a functional order method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在我们信任的解释器中测试这个类，我们会发现所有的联系人，包括供应商，在他们的`__init__`中都接受了名字和电子邮件地址，但只有供应商有一个功能性的订单方法：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, now our `Supplier` class can do everything a contact can do (including adding
    itself to the list of `all_contacts`) and all the special things it needs to handle
    as a supplier. This is the beauty of inheritance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的`Supplier`类可以做任何联系人可以做的事情（包括将自己添加到`all_contacts`列表中），以及作为供应商需要处理的所有特殊事情。这就是继承的美妙之处。
- en: Extending built-ins
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展内置类型
- en: 'One interesting use of this kind of inheritance is adding functionality to
    built-in classes. In the `Contact` class seen earlier, we are adding contacts
    to a list of all contacts. What if we also wanted to search that list by name?
    Well, we could add a method on the `Contact` class to search it, but it feels
    like this method actually belongs to the list itself. We can do this using inheritance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种继承的一个有趣的用法是向内置类添加功能。在前面看到的`Contact`类中，我们正在将联系人添加到所有联系人的列表中。如果我们还想按名称搜索该列表怎么办？嗯，我们可以在`Contact`类上添加一个搜索方法，但感觉这个方法实际上属于列表本身。我们可以使用继承来做到这一点：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of instantiating a normal list as our class variable, we create a new
    `ContactList` class that extends the built-in `list`. Then, we instantiate this
    subclass as our `all_contacts` list. We can test the new search functionality
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将普通列表实例化为我们的类变量，我们创建一个新的`ContactList`类，它扩展了内置的`list`。然后，我们将这个子类实例化为我们的`all_contacts`列表。我们可以测试新的搜索功能如下：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Are you wondering how we changed the built-in syntax `[]` into something we
    can inherit from? Creating an empty list with `[]` is actually a shorthand for
    creating an empty list using `list()`; the two syntaxes behave identically:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道我们是如何将内置语法`[]`改变成我们可以继承的东西的？使用`[]`创建一个空列表实际上是使用`list()`创建一个空列表的简写；这两种语法的行为是相同的：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In reality, the `[]` syntax is actually so-called **syntax sugar** that calls
    the `list()` constructor under the hood. The `list` data type is a class that
    we can extend. In fact, the list itself extends the `object` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`[]`语法实际上是所谓的**语法糖**，在底层调用`list()`构造函数。`list`数据类型是一个我们可以扩展的类。事实上，列表本身扩展了`object`类：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As a second example, we can extend the `dict` class, which is, similar to the
    list, the class that is constructed when using the `{}` syntax shorthand:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个例子，我们可以扩展`dict`类，它与列表类似，是在使用`{}`语法简写时构造的类：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is easy to test in the interactive interpreter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这在交互式解释器中很容易测试：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most built-in types can be similarly extended. Commonly extended built-ins are
    `object`, `list`, `set`, `dict`, `file`, and `str`. Numerical types such as `int`
    and `float` are also occasionally inherited from.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内置类型都可以类似地扩展。常见的扩展内置类型包括`object`、`list`、`set`、`dict`、`file`和`str`。数值类型如`int`和`float`有时也会被继承。
- en: Overriding and super
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖和super
- en: So, inheritance is great for *adding* new behavior to existing classes, but
    what about *changing* behavior? Our `contact` class allows only a name and an
    e-mail address. This may be sufficient for most contacts, but what if we want
    to add a phone number for our close friends?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继承对于向现有类*添加*新行为非常有用，但是*改变*行为呢？我们的`contact`类只允许一个名字和一个电子邮件地址。对于大多数联系人来说，这可能已经足够了，但是如果我们想为我们的亲密朋友添加一个电话号码呢？
- en: 'As we saw in [Chapter 2](ch02.html "Chapter 2. Objects in Python"), *Objects
    in Python*, we can do this easily by just setting a `phone` attribute on the contact
    after it is constructed. But if we want to make this third variable available
    on initialization, we have to override `__init__`. Overriding means altering or
    replacing a method of the superclass with a new method (with the same name) in
    the subclass. No special syntax is needed to do this; the subclass''s newly created
    method is automatically called instead of the superclass''s method. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.html "第2章。Python中的对象")中看到的，*Python中的对象*，我们可以很容易地通过在构造后在联系人上设置`phone`属性来做到这一点。但是，如果我们想在初始化时使这个第三个变量可用，我们必须覆盖`__init__`。覆盖意味着用子类中的新方法（具有相同名称）改变或替换超类的方法。不需要特殊的语法来做到这一点；子类新创建的方法会自动被调用，而不是超类的方法。例如：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any method can be overridden, not just `__init__`. Before we go on, however,
    we need to address some problems in this example. Our `Contact` and `Friend` classes
    have duplicate code to set up the `name` and `email` properties; this can make
    code maintenance complicated as we have to update the code in two or more places.
    More alarmingly, our `Friend` class is neglecting to add itself to the `all_contacts`
    list we have created on the `Contact` class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法都可以被覆盖，不仅仅是`__init__`。然而，在继续之前，我们需要解决这个例子中的一些问题。我们的`Contact`和`Friend`类有重复的代码来设置`name`和`email`属性；这可能会使代码维护复杂化，因为我们必须在两个或更多的地方更新代码。更令人担忧的是，我们的`Friend`类忽略了将自己添加到我们在`Contact`类上创建的`all_contacts`列表中。
- en: 'What we really need is a way to execute the original `__init__` method on the
    `Contact` class. This is what the `super` function does; it returns the object
    as an instance of the parent class, allowing us to call the parent method directly:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是一种执行`Contact`类上的原始`__init__`方法的方法。这就是`super`函数所做的；它将对象作为父类的实例返回，允许我们直接调用父方法：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example first gets the instance of the parent object using `super`, and
    calls `__init__` on that object, passing in the expected arguments. It then does
    its own initialization, namely, setting the `phone` attribute.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先使用`super`获取父对象的实例，并在该对象上调用`__init__`，传入预期的参数。然后它进行自己的初始化，即设置`phone`属性。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `super()` syntax does not work in older versions of Python. Like
    the [] and {} syntaxes for lists and dictionaries, it is a shorthand for a more
    complicated construct. We'll learn more about this shortly when we discuss multiple
    inheritance, but know for now that in Python 2, you would have to call `super(EmailContact,
    self).__init__()`. Specifically notice that the first argument is the name of
    the child class, not the name as the parent class you want to call, as some might
    expect. Also, remember the class comes before the object. I always forget the
    order, so the new syntax in Python 3 has saved me hours of having to look it up.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`super()`语法在较旧版本的Python中不起作用。就像列表和字典的[]和{}语法一样，它是更复杂结构的简写。当我们讨论多重继承时，我们很快会了解更多，但现在要知道，在Python
    2中，您必须调用`super(EmailContact, self).__init__()`。特别注意第一个参数是子类的名称，而不是您想要调用的父类的名称，这可能有些人会期望。还要记住类在对象之前。我总是忘记顺序，所以Python
    3中的新语法为我节省了很多时间。
- en: A `super()` call can be made inside any method, not just `__init__`. This means
    all methods can be modified via overriding and calls to `super`. The call to `super`
    can also be made at any point in the method; we don't have to make the call as
    the first line in the method. For example, we may need to manipulate or validate
    incoming parameters before forwarding them to the superclass.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()`调用可以在任何方法中进行，不仅仅是`__init__`。这意味着所有方法都可以通过覆盖和调用`super`进行修改。`super`的调用也可以在方法中的任何位置进行；我们不必在方法中的第一行进行调用。例如，我们可能需要在将参数转发给超类之前操纵或验证传入参数。'
- en: Multiple inheritance
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'Multiple inheritance is a touchy subject. In principle, it''s very simple:
    a subclass that inherits from more than one parent class is able to access functionality
    from both of them. In practice, this is less useful than it sounds and many expert
    programmers recommend against using it.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承是一个敏感的话题。原则上，它非常简单：从多个父类继承的子类能够访问它们两者的功能。实际上，这并不像听起来那么有用，许多专家程序员建议不要使用它。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As a rule of thumb, if you think you need multiple inheritance, you're probably
    wrong, but if you know you need it, you're probably right.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果您认为需要多重继承，您可能是错误的，但如果您知道需要它，您可能是正确的。
- en: 'The simplest and most useful form of multiple inheritance is called a **mixin**.
    A mixin is generally a superclass that is not meant to exist on its own, but is
    meant to be inherited by some other class to provide extra functionality. For
    example, let''s say we wanted to add functionality to our `Contact` class that
    allows sending an e-mail to `self.email`. Sending e-mail is a common task that
    we might want to use on many other classes. So, we can write a simple mixin class
    to do the e-mailing for us:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单和最有用的多重继承形式称为**mixin**。mixin通常是一个不打算独立存在的超类，而是打算被其他一些类继承以提供额外功能。例如，假设我们想要为我们的`Contact`类添加一个功能，允许向`self.email`发送电子邮件。发送电子邮件是一个常见的任务，我们可能希望在许多其他类上使用它。因此，我们可以编写一个简单的mixin类来为我们发送电子邮件：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For brevity, we won't include the actual e-mail logic here; if you're interested
    in studying how it's done, see the `smtplib` module in the Python standard library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们不会在这里包含实际的电子邮件逻辑；如果您有兴趣学习如何完成，可以查看Python标准库中的`smtplib`模块。
- en: 'This class doesn''t do anything special (in fact, it can barely function as
    a standalone class), but it does allow us to define a new class that describes
    both a `Contact` and a `MailSender`, using multiple inheritance:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类并没有做任何特殊的事情（实际上，它几乎不能作为一个独立的类运行），但它确实允许我们定义一个新的类，描述了`Contact`和`MailSender`，使用多重继承：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The syntax for multiple inheritance looks like a parameter list in the class
    definition. Instead of including one base class inside the parentheses, we include
    two (or more), separated by a comma. We can test this new hybrid to see the mixin
    at work:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承的语法看起来像类定义中的参数列表。在括号内不是包含一个基类，而是包含两个（或更多），用逗号分隔。我们可以测试这个新的混合体，看看mixin的工作情况：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Contact` initializer is still adding the new contact to the `all_contacts`
    list, and the mixin is able to send mail to `self.email` so we know everything
    is working.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact`初始化器仍然将新联系人添加到`all_contacts`列表中，而mixin能够向`self.email`发送邮件，所以我们知道一切都在运作。'
- en: 'This wasn''t so hard, and you''re probably wondering what the dire warnings
    about multiple inheritance are. We''ll get into the complexities in a minute,
    but let''s consider some other options we had, rather than using a mixin here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不难，你可能想知道关于多重继承的严重警告是什么。我们将在一分钟内深入讨论复杂性，但让我们考虑一些其他选项，而不是在这里使用mixin：
- en: We could have used single inheritance and added the `send_mail` function to
    the subclass. The disadvantage here is that the e-mail functionality then has
    to be duplicated for any other classes that need e-mail.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以使用单一继承，并将`send_mail`函数添加到子类中。这样做的缺点是，电子邮件功能必须为任何需要电子邮件的其他类复制。
- en: We can create a standalone Python function for sending an e-mail, and just call
    that function with the correct e-mail address supplied as a parameter when the
    e-mail needs to be sent.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个独立的Python函数来发送电子邮件，并在需要发送电子邮件时使用正确的电子邮件地址作为参数调用该函数。
- en: We could have explored a few ways of using composition instead of inheritance.
    For example, `EmailableContact` could have a `MailSender` object instead of inheriting
    from it.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以探索一些使用组合而不是继承的方法。例如，`EmailableContact`可以有一个`MailSender`对象，而不是继承它。
- en: We could monkey-patch (we'll briefly cover monkey-patching in [Chapter 7](ch07.html
    "Chapter 7. Python Object-oriented Shortcuts"), *Python Object-oriented Shortcuts*)
    the `Contact` class to have a `send_mail` method after the class has been created.
    This is done by defining a function that accepts the `self` argument, and setting
    it as an attribute on an existing class.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以对`Contact`类进行猴子补丁（我们将在[第7章](ch07.html "第7章。Python面向对象快捷方式")中简要介绍猴子补丁，*Python面向对象快捷方式*），在类创建后添加一个`send_mail`方法。这是通过定义一个接受`self`参数的函数，并将其设置为现有类的属性来完成的。
- en: Multiple inheritance works all right when mixing methods from different classes,
    but it gets very messy when we have to call methods on the superclass. There are
    multiple superclasses. How do we know which one to call? How do we know what order
    to call them in?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承在混合来自不同类的方法时运行良好，但当我们必须调用超类的方法时，它变得非常混乱。有多个超类。我们怎么知道该调用哪一个？我们怎么知道以什么顺序调用它们？
- en: Let's explore these questions by adding a home address to our `Friend` class.
    There are a few approaches we might take. An address is a collection of strings
    representing the street, city, country, and other related details of the contact.
    We could pass each of these strings as a parameter into the `Friend` class's `__init__`
    method. We could also store these strings in a tuple or dictionary and pass them
    into `__init__` as a single argument. This is probably the best course of action
    if there are no methods that need to be added to the address.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向我们的`Friend`类添加家庭地址来探讨这些问题。我们可能会采取一些方法。地址是表示联系人的街道、城市、国家和其他相关细节的字符串集合。我们可以将这些字符串中的每一个作为参数传递到`Friend`类的`__init__`方法中。我们也可以将这些字符串存储在元组或字典中，并将它们作为单个参数传递到`__init__`中。如果没有需要添加到地址的方法，这可能是最好的方法。
- en: Another option would be to create a new `Address` class to hold those strings
    together, and then pass an instance of this class into the `__init__` method of
    our `Friend` class. The advantage of this solution is that we can add behavior
    (say, a method to give directions or to print a map) to the data instead of just
    storing it statically. This is an example of composition, as we discussed in [Chapter
    1](ch01.html "Chapter 1. Object-oriented Design"), *Object-oriented Design*. The
    "has a" relationship of composition is a perfectly viable solution to this problem
    and allows us to reuse `Address` classes in other entities such as buildings,
    businesses, or organizations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是创建一个新的`Address`类来将这些字符串放在一起，然后将这个类的实例传递到我们的`Friend`类的`__init__`方法中。这种解决方案的优势在于，我们可以为数据添加行为（比如，一个给出方向或打印地图的方法），而不仅仅是静态存储它。这是组合的一个例子，正如我们在[第1章](ch01.html
    "第1章。面向对象设计")中讨论的那样，*面向对象设计*。组合的“有一个”关系是这个问题的一个完全可行的解决方案，并且允许我们在其他实体中重用`Address`类，比如建筑物、企业或组织。
- en: 'However, inheritance is also a viable solution, and that''s what we want to
    explore. Let''s add a new class that holds an address. We''ll call this new class
    "AddressHolder" instead of "Address" because inheritance defines an *is a* relationship.
    It is not correct to say a "Friend" is an "Address" , but since a friend can have
    an "Address" , we can argue that a "Friend" is an "AddressHolder". Later, we could
    create other entities (companies, buildings) that also hold addresses. Here''s
    our `AddressHolder` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，继承也是一个可行的解决方案，这就是我们想要探讨的。让我们添加一个新的类来保存一个地址。我们将这个新类称为“AddressHolder”，而不是“Address”，因为继承定义了一个*是一个*的关系。说“Friend”是“Address”是不正确的，但由于朋友可以有一个“Address”，我们可以说“Friend”是“AddressHolder”。以后，我们可以创建其他实体（公司、建筑物）也持有地址。这是我们的`AddressHolder`类：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Very simple; we just take all the data and toss it into instance variables upon
    initialization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单；我们只需在初始化时将所有数据放入实例变量中。
- en: The diamond problem
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 菱形问题
- en: 'We can use multiple inheritance to add this new class as a parent of our existing
    `Friend` class. The tricky part is that we now have two parent `__init__` methods
    both of which need to be initialized. And they need to be initialized with different
    arguments. How do we do this? Well, we could start with a naive approach:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多重继承将这个新类作为现有`Friend`类的父类。棘手的部分是，我们现在有两个父`__init__`方法，它们都需要被初始化。而且它们需要用不同的参数进行初始化。我们该怎么做呢？嗯，我们可以从一个天真的方法开始：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we directly call the `__init__` function on each of the superclasses
    and explicitly pass the `self` argument. This example technically works; we can
    access the different variables directly on the class. But there are a few problems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们直接调用每个超类的`__init__`函数，并显式地传递`self`参数。这个例子在技术上是有效的；我们可以直接在类上访问不同的变量。但是有一些问题。
- en: First, it is possible for a superclass to go uninitialized if we neglect to
    explicitly call the initializer. That wouldn't break this example, but it could
    cause hard-to-debug program crashes in common scenarios. Imagine trying to insert
    data into a database that has not been connected to, for example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们忽略显式调用初始化程序，可能会导致超类未初始化。这不会破坏这个例子，但在常见情况下可能导致难以调试的程序崩溃。例如，想象一下尝试向未连接的数据库插入数据。
- en: 'Second, and more sinister, is the possibility of a superclass being called
    multiple times because of the organization of the class hierarchy. Look at this
    inheritance diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，更加阴险的是，由于类层次结构的组织，可能会多次调用超类。看看这个继承图：
- en: '![The diamond problem](images/8781OS_3_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![菱形问题](images/8781OS_3_01.jpg)'
- en: The `__init__` method from the `Friend` class first calls `__init__` on `Contact`,
    which implicitly initializes the `object` superclass (remember, all classes derive
    from `object`). `Friend` then calls `__init__` on `AddressHolder`, which implicitly
    initializes the `object` superclass *again*. This means the parent class has been
    set up twice. With the `object` class, that's relatively harmless, but in some
    situations, it could spell disaster. Imagine trying to connect to a database twice
    for every request!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Friend`类的`__init__`方法首先调用`Contact`的`__init__`，这隐式地初始化了`object`超类（记住，所有类都派生自`object`）。然后`Friend`调用`AddressHolder`的`__init__`，这又一次隐式初始化了`object`超类。这意味着父类已经被设置了两次。对于`object`类来说，这相对无害，但在某些情况下，可能会带来灾难。想象一下，每次请求都要连接两次数据库！'
- en: The base class should only be called once. Once, yes, but when? Do we call `Friend`,
    then `Contact`, then `Object`, then `AddressHolder`? Or `Friend`, then `Contact`,
    then `AddressHolder`, then `Object`?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 基类应该只被调用一次。一次，是的，但是什么时候？我们先调用`Friend`，然后是`Contact`，然后是`Object`，然后是`AddressHolder`？还是`Friend`，然后是`Contact`，然后是`AddressHolder`，然后是`Object`？
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The order in which methods can be called can be adapted on the fly by modifying
    the `__mro__` (**Method Resolution Order**) attribute on the class. This is beyond
    the scope of this book. If you think you need to understand it, I recommend *Expert
    Python Programming*, *Tarek Ziadé*, *Packt Publishing*, or read the original documentation
    on the topic at [http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的调用顺序可以通过修改类的`__mro__`（**方法解析顺序**）属性来动态调整。这超出了本书的范围。如果您认为您需要了解它，我建议阅读*Tarek
    Ziadé*的*Expert Python Programming*，*Packt Publishing*，或者阅读有关该主题的原始文档[http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/)。
- en: 'Let''s look at a second contrived example that illustrates this problem more
    clearly. Here we have a base class that has a method named `call_me`. Two subclasses
    override that method, and then another subclass extends both of these using multiple
    inheritance. This is called diamond inheritance because of the diamond shape of
    the class diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更清楚地说明这个问题的第二个刻意的例子。这里有一个基类，其中有一个名为`call_me`的方法。两个子类覆盖了该方法，然后另一个子类使用多重继承扩展了这两个子类。这被称为菱形继承，因为类图的形状是菱形：
- en: '![The diamond problem](images/8781OS_3_02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![菱形问题](images/8781OS_3_02.jpg)'
- en: 'Let''s convert this diagram to code; this example shows when the methods are
    called:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个图表转换为代码；这个例子展示了方法何时被调用：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This example simply ensures that each overridden `call_me` method directly
    calls the parent method with the same name. It lets us know each time a method
    is called by printing the information to the screen. It also updates a static
    variable on the class to show how many times it has been called. If we instantiate
    one `Subclass` object and call the method on it once, we get this output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子简单地确保每个重写的`call_me`方法直接调用具有相同名称的父方法。它通过将信息打印到屏幕上来告诉我们每次方法被调用的次数。它还更新了类的静态变量，以显示它被调用的次数。如果我们实例化一个`Subclass`对象并调用它的方法一次，我们会得到这个输出：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Thus we can clearly see the base class's `call_me` method being called twice.
    This could lead to some insidious bugs if that method is doing actual work—like
    depositing into a bank account—twice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以清楚地看到基类的`call_me`方法被调用了两次。如果该方法正在执行实际工作，比如存款到银行账户，这可能会导致一些隐匿的错误。
- en: 'The thing to keep in mind with multiple inheritance is that we only want to
    call the "next" method in the class hierarchy, not the "parent" method. In fact,
    that next method may not be on a parent or ancestor of the current class. The
    `super` keyword comes to our rescue once again. Indeed, `super` was originally
    developed to make complicated forms of multiple inheritance possible. Here is
    the same code written using `super`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承需要记住的一点是，我们只想调用类层次结构中的“下一个”方法，而不是“父”方法。实际上，下一个方法可能不在当前类的父类或祖先上。`super`关键字再次来到我们的救援。事实上，`super`最初是为了使复杂形式的多重继承成为可能而开发的。这里是使用`super`编写的相同代码：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The change is pretty minor; we simply replaced the naive direct calls with
    calls to `super()`, although the bottom subclass only calls `super` once rather
    than having to make the calls for both the left and right. The change is simple
    enough, but look at the difference when we execute it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 变化非常小；我们只是用`super()`调用替换了天真的直接调用，尽管底部的子类只调用了一次`super`，而不是必须为左侧和右侧都进行调用。这个变化很简单，但当我们执行它时看看它的不同之处：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Looks good, our base method is only being called once. But what is `super()`
    actually doing here? Since the `print` statements are executed after the `super`
    calls, the printed output is in the order each method is actually executed. Let's
    look at the output from back to front to see who is calling what.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，我们的基本方法只被调用了一次。但`super()`在这里实际上是在做什么呢？由于`print`语句是在`super`调用之后执行的，所以打印输出是每个方法实际执行的顺序。让我们从后往前看输出，看看是谁在调用什么。
- en: First, `call_me` of `Subclass` calls `super().call_me()`, which happens to refer
    to `LeftSubclass.call_me()`. The `LeftSubclass.call_me()` method then calls `super().call_me()`,
    but in this case, `super()` is referring to `RightSubclass.call_me()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Subclass`的`call_me`调用`super().call_me()`，这恰好是指`LeftSubclass.call_me()`。然后`LeftSubclass.call_me()`方法调用`super().call_me()`，但在这种情况下，`super()`指的是`RightSubclass.call_me()`。
- en: 'Pay particular attention to this: the `super` call is *not* calling the method
    on the superclass of `LeftSubclass` (which is `BaseClass`). Rather, it is calling
    `RightSubclass`, even though it is not a direct parent of `LeftSubclass`! This
    is the *next* method, not the parent method. `RightSubclass` then calls `BaseClass`
    and the `super` calls have ensured each method in the class hierarchy is executed
    once.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意：`super`调用*不*是在`LeftSubclass`的超类（即`BaseClass`）上调用方法。相反，它调用`RightSubclass`，即使它不是`LeftSubclass`的直接父类！这是*下一个*方法，而不是父方法。然后`RightSubclass`调用`BaseClass`，并且`super`调用确保了类层次结构中的每个方法都被执行一次。
- en: Different sets of arguments
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的参数集。
- en: 'This is going to make things complicated as we return to our `Friend` multiple
    inheritance example. In the `__init__` method for `Friend`, we were originally
    calling `__init__` for both parent classes, *with different sets of arguments*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回到我们的`Friend`多重继承示例时，情况会变得复杂。在`Friend`的`__init__`方法中，我们最初调用了两个父类的`__init__`，*使用不同的参数*：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How can we manage different sets of arguments when using `super`? We don't necessarily
    know which class `super` is going to try to initialize first. Even if we did,
    we need a way to pass the "extra" arguments so that subsequent calls to `super`,
    on other subclasses, receive the right arguments.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`super`时，我们如何管理不同的参数集？我们不一定知道`super`将首先尝试初始化哪个类。即使我们知道，我们也需要一种方法来传递“额外”的参数，以便后续对其他子类的`super`调用接收正确的参数。
- en: Specifically, if the first call to `super` passes the `name` and `email` arguments
    to `Contact.__init__`, and `Contact.__init__` then calls `super`, it needs to
    be able to pass the address-related arguments to the "next" method, which is `AddressHolder.__init__`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，如果第一次调用`super`将`name`和`email`参数传递给`Contact.__init__`，然后`Contact.__init__`再调用`super`，它需要能够将与地址相关的参数传递给“下一个”方法，即`AddressHolder.__init__`。
- en: This is a problem whenever we want to call superclass methods with the same
    name, but with different sets of arguments. Most often, the only time you would
    want to call a superclass with a completely different set of arguments is in `__init__`,
    as we're doing here. Even with regular methods, though, we may want to add optional
    parameters that only make sense to one subclass or set of subclasses.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要使用相同名称但具有不同参数集的超类方法时，这就是一个问题。最常见的情况是，您只想在`__init__`中使用完全不同的参数集调用超类，就像我们在这里所做的那样。即使对于常规方法，我们可能也希望添加仅对一个子类或一组子类有意义的可选参数。
- en: Sadly, the only way to solve this problem is to plan for it from the beginning.
    We have to design our base class parameter lists to accept keyword arguments for
    any parameters that are not required by every subclass implementation. Finally,
    we must ensure the method freely accepts unexpected arguments and passes them
    on to its `super` call, in case they are necessary to later methods in the inheritance
    order.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，解决这个问题的唯一方法是从一开始就为其进行规划。我们必须设计基类参数列表，以接受不是每个子类实现都需要的关键字参数。最后，我们必须确保该方法自由接受意外参数并将它们传递给其`super`调用，以防它们对继承顺序中的后续方法是必要的。
- en: 'Python''s function parameter syntax provides all the tools we need to do this,
    but it makes the overall code look cumbersome. Have a look at the proper version
    of the `Friend` multiple inheritance code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python的函数参数语法提供了我们需要的所有工具，但它使整体代码看起来很笨重。看看`Friend`多重继承代码的正确版本：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've changed all arguments to keyword arguments by giving them an empty string
    as a default value. We've also ensured that a `**kwargs` parameter is included
    to capture any additional parameters that our particular method doesn't know what
    to do with. It passes these parameters up to the next class with the `super` call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过给所有参数赋予空字符串作为默认值，将所有参数更改为关键字参数。我们还确保包含了一个`**kwargs`参数来捕获我们特定方法不知道如何处理的任何额外参数。它通过`super`调用将这些参数传递给下一个类。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you aren't familiar with the `**kwargs` syntax, it basically collects any
    keyword arguments passed into the method that were not explicitly listed in the
    parameter list. These arguments are stored in a dictionary named `kwargs` (we
    can call the variable whatever we like, but convention suggests `kw`, or `kwargs`).
    When we call a different method (for example, `super().__init__`) with a `**kwargs`
    syntax, it unpacks the dictionary and passes the results to the method as normal
    keyword arguments. We'll cover this in detail in [Chapter 7](ch07.html "Chapter 7. Python
    Object-oriented Shortcuts"), *Python Object-oriented Shortcuts*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉`**kwargs`语法，它基本上会收集传递给方法的任何未在参数列表中明确列出的关键字参数。这些参数存储在一个名为`kwargs`的字典中（我们可以随意命名变量，但约定建议使用`kw`或`kwargs`）。当我们使用`**kwargs`语法调用不同的方法（例如`super().__init__`）时，它会解包字典并将结果作为普通关键字参数传递给方法。我们将在[第7章](ch07.html
    "第7章。Python面向对象的快捷方式")中详细介绍这一点，*Python面向对象的快捷方式*。
- en: The previous example does what it is supposed to do. But it's starting to look
    messy, and it has become difficult to answer the question, *What arguments do
    we need to pass into* `Friend.__init__`? This is the foremost question for anyone
    planning to use the class, so a docstring should be added to the method to explain
    what is happening.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子做到了它应该做的事情。但它开始看起来凌乱，而且很难回答这个问题，*我们需要传递什么参数到* `Friend.__init__`？这是任何计划使用该类的人最关心的问题，因此应该在方法中添加一个文档字符串来解释正在发生的事情。
- en: Further, even this implementation is insufficient if we want to *reuse* variables
    in parent classes. When we pass the `**kwargs` variable to `super`, the dictionary
    does not include any of the variables that were included as explicit keyword arguments.
    For example, in `Friend.__init__`, the call to `super` does not have `phone` in
    the `kwargs` dictionary. If any of the other classes need the `phone` parameter,
    we need to ensure it is in the dictionary that is passed. Worse, if we forget
    to do this, it will be tough to debug because the superclass will not complain,
    but will simply assign the default value (in this case, an empty string) to the
    variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使这种实现方式也不足以实现在父类中*重用*变量。当我们将`**kwargs`变量传递给`super`时，字典不包括任何作为显式关键字参数包含的变量。例如，在`Friend.__init__`中，对`super`的调用在`kwargs`字典中没有`phone`。如果其他类中需要`phone`参数，我们需要确保它包含在传递的字典中。更糟糕的是，如果我们忘记这样做，调试将会很困难，因为超类不会抱怨，而只会将默认值（在这种情况下为空字符串）分配给变量。
- en: 'There are a few ways to ensure that the variable is passed upwards. Assume
    the `Contact` class does, for some reason, need to be initialized with a `phone`
    parameter, and the `Friend` class will also need access to it. We can do any of
    the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以确保变量向上传递。假设`Contact`类因某种原因需要用`phone`参数初始化，并且`Friend`类也需要访问它。我们可以执行以下任一操作：
- en: Don't include `phone` as an explicit keyword argument. Instead, leave it in
    the `kwargs` dictionary. `Friend` can look it up using the syntax `kwargs['phone']`.
    When it passes `**kwargs` to the `super` call, `phone` will still be in the dictionary.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将`phone`作为显式关键字参数包含在内。相反，将其留在`kwargs`字典中。`Friend`可以使用语法`kwargs['phone']`查找它。当它将`**kwargs`传递给`super`调用时，`phone`仍然会在字典中。
- en: Make `phone` an explicit keyword argument but update the `kwargs` dictionary
    before passing it to `super`, using the standard dictionary syntax `kwargs['phone']
    = phone`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`phone`作为显式关键字参数，但在传递给`super`之前更新`kwargs`字典，使用标准字典语法`kwargs['phone'] = phone`。
- en: 'Make `phone` an explicit keyword argument, but update the `kwargs` dictionary
    using the `kwargs.update` method. This is useful if you have several arguments
    to update. You can create the dictionary passed into `update` using either the
    `dict(phone=phone)` constructor, or the dictionary syntax `{''phone'': phone}`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`phone`作为显式关键字参数，但使用`kwargs.update`方法更新`kwargs`字典。如果有多个参数需要更新，这是很有用的。您可以使用`dict(phone=phone)`构造函数或字典语法`{''phone'':
    phone}`创建传递给`update`的字典。'
- en: Make `phone` an explicit keyword argument, but pass it to the super call explicitly
    with the syntax `super().__init__(phone=phone, **kwargs)`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`phone`作为显式关键字参数，但使用语法`super().__init__(phone=phone, **kwargs)`将其明确传递给super调用。
- en: We have covered many of the caveats involved with multiple inheritance in Python.
    When we need to account for all the possible situations, we have to plan for them
    and our code will get messy. Basic multiple inheritance can be handy but, in many
    cases, we may want to choose a more transparent way of combining two disparate
    classes, usually using composition or one of the design patterns we'll be covering
    in [Chapter 10](ch10.html "Chapter 10. Python Design Patterns I"), *Python Design
    Patterns I* and [Chapter 11](ch11.html "Chapter 11. Python Design Patterns II"),
    *Python Design Patterns II*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Python中多重继承涉及的许多注意事项。当我们需要考虑所有可能的情况时，我们必须为它们做好规划，我们的代码会变得混乱。基本的多重继承可能很方便，但在许多情况下，我们可能希望选择更透明的方式来组合两个不同的类，通常使用组合或我们将在[第10章](ch10.html
    "第10章。Python设计模式I")中介绍的设计模式之一，*Python设计模式I*和[第11章](ch11.html "第11章。Python设计模式II")中介绍的设计模式之一，*Python设计模式II*。
- en: Polymorphism
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: 'We were introduced to polymorphism in [Chapter 1](ch01.html "Chapter 1. Object-oriented
    Design"), *Object-oriented Design*. It is a fancy name describing a simple concept:
    different behaviors happen depending on which subclass is being used, without
    having to explicitly know what the subclass actually is. As an example, imagine
    a program that plays audio files. A media player might need to load an `AudioFile`
    object and then `play` it. We''d put a `play()` method on the object, which is
    responsible for decompressing or extracting the audio and routing it to the sound
    card and speakers. The act of playing an `AudioFile` could feasibly be as simple
    as:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。面向对象设计")中介绍了多态。这是一个描述简单概念的花哨名字：根据使用的子类不同，会发生不同的行为，而不必明确知道子类实际上是什么。举个例子，想象一个播放音频文件的程序。媒体播放器可能需要加载一个`AudioFile`对象，然后`play`它。我们会在对象上放一个`play()`方法，负责解压或提取音频并将其路由到声卡和扬声器。播放`AudioFile`的行为可能是非常简单的：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, the process of decompressing and extracting an audio file is very different
    for different types of files. The `.wav` files are stored uncompressed, while
    `.mp3`, `.wma`, and `.ogg` files all have totally different compression algorithms.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，解压和提取音频文件的过程对于不同类型的文件是非常不同的。`.wav`文件是未压缩的，而`.mp3`、`.wma`和`.ogg`文件都有完全不同的压缩算法。
- en: 'We can use inheritance with polymorphism to simplify the design. Each type
    of file can be represented by a different subclass of `AudioFile`, for example,
    `WavFile`, `MP3File`. Each of these would have a `play()` method, but that method
    would be implemented differently for each file to ensure the correct extraction
    procedure is followed. The media player object would never need to know which
    subclass of `AudioFile` it is referring to; it just calls `play()` and polymorphically
    lets the object take care of the actual details of playing. Let''s look at a quick
    skeleton showing how this might look:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用继承和多态来简化设计。每种类型的文件都可以由`AudioFile`的不同子类来表示，例如`WavFile`、`MP3File`。每个子类都会有一个`play()`方法，但是为了确保正确的提取过程，每个文件的这个方法都会有不同的实现。媒体播放器对象永远不需要知道它正在引用`AudioFile`的哪个子类；它只是调用`play()`，并且通过多态让对象来处理实际的播放细节。让我们看一个快速的骨架，展示这个可能是什么样子：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All audio files check to ensure that a valid extension was given upon initialization.
    But did you notice how the `__init__` method in the parent class is able to access
    the `ext` class variable from different subclasses? That's polymorphism at work.
    If the filename doesn't end with the correct name, it raises an exception (exceptions
    will be covered in detail in the next chapter). The fact that `AudioFile` doesn't
    actually store a reference to the `ext` variable doesn't stop it from being able
    to access it on the subclass.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有音频文件都会检查初始化时是否给出了有效的扩展名。但是你有没有注意到父类中的`__init__`方法如何能够从不同的子类中访问`ext`类变量？这就是多态的作用。如果文件名不以正确的名称结尾，它会引发一个异常（异常将在下一章详细介绍）。`AudioFile`实际上并没有存储对`ext`变量的引用，但这并不妨碍它能够在子类上访问它。
- en: 'In addition, each subclass of `AudioFile` implements `play()` in a different
    way (this example doesn''t actually play the music; audio compression algorithms
    really deserve a separate book!). This is also polymorphism in action. The media
    player can use the exact same code to play a file, no matter what type it is;
    it doesn''t care what subclass of `AudioFile` it is looking at. The details of
    decompressing the audio file are *encapsulated*. If we test this example, it works
    as we would hope:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AudioFile`的每个子类都以不同的方式实现了`play()`（这个例子实际上并不播放音乐；音频压缩算法确实值得一本单独的书！）。这也是多态的实际应用。媒体播放器可以使用完全相同的代码来播放文件，无论它是什么类型的；它不在乎它正在查看`AudioFile`的哪个子类。解压音频文件的细节被*封装*起来。如果我们测试这个例子，它会按照我们的期望工作：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See how `AudioFile.__init__` is able to check the file type without actually
    knowing what subclass it is referring to?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`AudioFile.__init__`如何能够检查文件类型，而实际上并不知道它正在引用哪个子类？
- en: 'Polymorphism is actually one of the coolest things about object-oriented programming,
    and it makes some programming designs obvious that weren''t possible in earlier
    paradigms. However, Python makes polymorphism less cool because of duck typing.
    Duck typing in Python allows us to use *any* object that provides the required
    behavior without forcing it to be a subclass. The dynamic nature of Python makes
    this trivial. The following example does not extend `AudioFile`, but it can be
    interacted with in Python using the exact same interface:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 多态实际上是面向对象编程中最酷的东西之一，它使一些在早期范式中不可能的编程设计变得显而易见。然而，由于鸭子类型，Python使多态变得不那么酷。Python中的鸭子类型允许我们使用*任何*提供所需行为的对象，而无需强制它成为子类。Python的动态性使这变得微不足道。下面的示例并不扩展`AudioFile`，但它可以使用完全相同的接口在Python中进行交互：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our media player can play this object just as easily as one that extends `AudioFile`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的媒体播放器可以像扩展`AudioFile`一样轻松地播放这个对象。
- en: Polymorphism is one of the most important reasons to use inheritance in many
    object-oriented contexts. Because any objects that supply the correct interface
    can be used interchangeably in Python, it reduces the need for polymorphic common
    superclasses. Inheritance can still be useful for sharing code but, if all that
    is being shared is the public interface, duck typing is all that is required.
    This reduced need for inheritance also reduces the need for multiple inheritance;
    often, when multiple inheritance appears to be a valid solution, we can just use
    duck typing to mimic one of the multiple superclasses.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是在许多面向对象的上下文中使用继承的最重要原因之一。因为在Python中，任何提供正确接口的对象都可以互换使用，这减少了对多态公共超类的需求。继承仍然可以用于共享代码，但如果所有被共享的只是公共接口，那么只需要鸭子类型。这种对继承的需求减少也减少了对多重继承的需求；通常，当多重继承似乎是一个有效的解决方案时，我们可以使用鸭子类型来模仿多个超类中的一个。
- en: Of course, just because an object satisfies a particular interface (by providing
    required methods or attributes) does not mean it will simply work in all situations.
    It has to fulfill that interface in a way that makes sense in the overall system.
    Just because an object provides a `play()` method does not mean it will automatically
    work with a media player. For example, our chess AI object from [Chapter 1](ch01.html
    "Chapter 1. Object-oriented Design"), *Object-oriented Design*, may have a `play()`
    method that moves a chess piece. Even though it satisfies the interface, this
    class would likely break in spectacular ways if we tried to plug it into a media
    player!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅因为一个对象满足特定的接口（通过提供所需的方法或属性）并不意味着它会在所有情况下都能正常工作。它必须以一种在整个系统中有意义的方式来满足该接口。仅仅因为一个对象提供了`play()`方法并不意味着它会自动与媒体播放器配合工作。例如，我们在[第1章](ch01.html
    "第1章。面向对象设计")中的象棋AI对象，*面向对象设计*，可能有一个`play()`方法来移动棋子。即使它满足了接口，如果我们尝试将它插入到媒体播放器中，这个类很可能会以惊人的方式崩溃！
- en: Another useful feature of duck typing is that the duck-typed object only needs
    to provide those methods and attributes that are actually being accessed. For
    example, if we needed to create a fake file object to read data from, we can create
    a new object that has a `read()` method; we don't have to override the `write`
    method if the code that is going to interact with the object will only be reading
    from the file. More succinctly, duck typing doesn't need to provide the entire
    interface of an object that is available, it only needs to fulfill the interface
    that is actually accessed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型的另一个有用特性是，鸭子类型的对象只需要提供那些实际被访问的方法和属性。例如，如果我们需要创建一个虚假的文件对象来读取数据，我们可以创建一个具有`read()`方法的新对象；如果与对象交互的代码只会从文件中读取，我们就不必覆盖`write`方法。简而言之，鸭子类型不需要提供对象的整个接口，它只需要满足实际被访问的接口。
- en: Abstract base classes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象基类
- en: While duck typing is useful, it is not always easy to tell in advance if a class
    is going to fulfill the protocol you require. Therefore, Python introduced the
    idea of abstract base classes. **Abstract base classes**, or **ABCs**, define
    a set of methods and properties that a class must implement in order to be considered
    a duck-type instance of that class. The class can extend the abstract base class
    itself in order to be used as an instance of that class, but it must supply all
    the appropriate methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然鸭子类型很有用，但事先很难判断一个类是否会满足您需要的协议。因此，Python引入了抽象基类的概念。**抽象基类**，或**ABCs**，定义了一个类必须实现的一组方法和属性，以便被视为该类的鸭子类型实例。该类可以扩展抽象基类本身，以便用作该类的实例，但它必须提供所有适当的方法。
- en: In practice, it's rarely necessary to create new abstract base classes, but
    we may find occasions to implement instances of existing ABCs. We'll cover implementing
    ABCs first, and then briefly see how to create your own if you should ever need
    to.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，很少需要创建新的抽象基类，但我们可能会发现需要实现现有ABC的实例的情况。我们将首先介绍实现ABC，然后简要看看如何创建自己的ABC（如果您确实需要的话）。
- en: Using an abstract base class
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用抽象基类
- en: 'Most of the abstract base classes that exist in the Python Standard Library
    live in the `collections` module. One of the simplest ones is the `Container`
    class. Let''s inspect it in the Python interpreter to see what methods this class
    requires:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中存在的大多数抽象基类都位于`collections`模块中。其中最简单的之一是`Container`类。让我们在Python解释器中检查一下这个类需要哪些方法：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, the `Container` class has exactly one abstract method that needs to be
    implemented, `__contains__`. You can issue `help(Container.__contains__)` to see
    what the function signature should look like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Container`类恰好有一个需要实现的抽象方法，`__contains__`。您可以发出`help(Container.__contains__)`来查看函数签名应该是什么样子的：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, we see that `__contains__` needs to take a single argument. Unfortunately,
    the help file doesn't tell us much about what that argument should be, but it's
    pretty obvious from the name of the ABC and the single method it implements that
    this argument is the value the user is checking to see if the container holds.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到`__contains__`需要接受一个参数。不幸的是，帮助文件并没有告诉我们太多关于该参数应该是什么，但从ABC的名称和它实现的单个方法来看，很明显这个参数是用户要检查的容器是否包含的值。
- en: 'This method is implemented by `list`, `str`, and `dict` to indicate whether
    or not a given value is in that data structure. However, we can also define a
    silly container that tells us whether a given value is in the set of odd integers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法由`list`、`str`和`dict`实现，用于指示给定值是否在该数据结构中。然而，我们也可以定义一个愚蠢的容器，告诉我们给定的值是否在奇数集合中：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can instantiate an `OddContainer` object and determine that, even though
    we did not extend `Container`, the class *is a* `Container` object:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实例化一个`OddContainer`对象，并确定，即使我们没有扩展`Container`，该类*是一个*`Container`对象：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And that is why duck typing is way more awesome than classical polymorphism.
    We can create *is a* relationships without the overhead of using inheritance (or
    worse, multiple inheritance).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么鸭子类型比经典多态更棒。我们可以创建*是一个*关系，而无需使用继承（或更糟糕的是，多重继承）的开销。
- en: 'The interesting thing about the `Container` ABC is that any class that implements
    it gets to use the `in` keyword for free. In fact, `in` is just syntax sugar that
    delegates to the `__contains__` method. Any class that has a `__contains__` method
    is a `Container` and can therefore be queried by the `in` keyword, for example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Container` ABC的有趣之处在于，任何实现它的类都可以免费使用`in`关键字。实际上，`in`只是语法糖，委托给`__contains__`方法。任何具有`__contains__`方法的类都是`Container`，因此可以通过`in`关键字进行查询，例如：'
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating an abstract base class
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建抽象基类
- en: 'As we saw earlier, it''s not necessary to have an abstract base class to enable
    duck typing. However, imagine we were creating a media player with third-party
    plugins. It is advisable to create an abstract base class in this case to document
    what API the third-party plugins should provide. The `abc` module provides the
    tools you need to do this, but I''ll warn you in advance, this requires some of
    Python''s most arcane concepts:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，不需要有一个抽象基类来实现鸭子类型。然而，想象一下，如果我们正在创建一个带有第三方插件的媒体播放器。在这种情况下，最好创建一个抽象基类来记录第三方插件应该提供的API。`abc`模块提供了您需要的工具，但我提前警告您，这需要一些Python中最深奥的概念：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a complicated example that includes several Python features that won't
    be explained until later in this book. It is included here for completeness, but
    you don't need to understand all of it to get the gist of how to create your own
    ABC.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的示例，其中包含了本书后面才会解释的几个Python特性。它在这里包含是为了完整性，但您不需要理解所有内容就能理解如何创建自己的ABC。
- en: The first weird thing is the `metaclass` keyword argument that is passed into
    the class where you would normally see the list of parent classes. This is a rarely
    used construct from the mystic art of metaclass programming. We won't be covering
    metaclasses in this book, so all you need to know is that by assigning the `ABCMeta`
    metaclass, you are giving your class superpower (or at least superclass) abilities.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个奇怪的地方是`metaclass`关键字参数，它被传递到类中，而在通常情况下，您会看到父类列表。这是来自元类编程的神秘艺术中很少使用的构造。我们不会在本书中涵盖元类，所以您需要知道的是，通过分配`ABCMeta`元类，您正在赋予您的类超能力（或至少是超类）能力。
- en: Next, we see the `@abc.abstractmethod` and `@abc.abstractproperty` constructs.
    These are Python decorators. We'll discuss those in [Chapter 5](ch05.html "Chapter 5. When
    to Use Object-oriented Programming"), *When to Use Object-oriented Programming*.
    For now, just know that by marking a method or property as being abstract, you
    are stating that any subclass of this class must implement that method or supply
    that property in order to be considered a proper member of the class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了`@abc.abstractmethod`和`@abc.abstractproperty`构造。这些是Python装饰器。我们将在[第5章](ch05.html
    "第5章。何时使用面向对象编程")中讨论这些内容，*何时使用面向对象编程*。现在，只需知道通过将方法或属性标记为抽象，您声明该类的任何子类必须实现该方法或提供该属性，以便被视为该类的合格成员。
- en: 'See what happens if you implement subclasses that do or don''t supply those
    properties:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如果实现了或没有提供这些属性的子类会发生什么：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since the `Wav` class fails to implement the abstract attributes, it is not
    possible to instantiate that class. The class is still a legal abstract class,
    but you'd have to subclass it to actually do anything. The `Ogg` class supplies
    both attributes, so it instantiates cleanly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Wav`类未能实现抽象属性，因此无法实例化该类。该类仍然是一个合法的抽象类，但您必须对其进行子类化才能实际执行任何操作。`Ogg`类提供了这两个属性，因此可以实例化。
- en: Going back to the `MediaLoader` ABC, let's dissect that `__subclasshook__` method.
    It is basically saying that any class that supplies concrete implementations of
    all the abstract attributes of this ABC should be considered a subclass of `MediaLoader`,
    even if it doesn't actually inherit from the `MediaLoader` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MediaLoader` ABC，让我们解析一下`__subclasshook__`方法。基本上，它是在说，任何提供了该ABC的所有抽象属性的具体实现的类都应该被视为`MediaLoader`的子类，即使它实际上并没有继承自`MediaLoader`类。
- en: More common object-oriented languages have a clear separation between the interface
    and the implementation of a class. For example, some languages provide an explicit
    `interface` keyword that allows us to define the methods that a class must have
    without any implementation. In such an environment, an abstract class is one that
    provides both an interface and a concrete implementation of some but not all methods.
    Any class can explicitly state that it implements a given interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的面向对象语言在类的接口和实现之间有明确的分离。例如，一些语言提供了一个明确的`interface`关键字，允许我们定义一个类必须具有的方法，而不需要任何实现。在这样的环境中，抽象类是提供了接口和一些但不是所有方法的具体实现的类。任何类都可以明确声明它实现了给定的接口。
- en: Python's ABCs help to supply the functionality of interfaces without compromising
    on the benefits of duck typing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python的ABCs有助于提供接口的功能，而不会影响鸭子类型的好处。
- en: Demystifying the magic
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解密魔术
- en: You can copy and paste the subclass code without understanding it if you want
    to make abstract classes that fulfill this particular contract. We'll cover most
    of the unusual syntaxes throughout the book, but let's go over it line by line
    to get an overview.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要创建满足这个特定契约的抽象类，可以复制并粘贴子类代码而不必理解它。我们将在整本书中涵盖大部分不寻常的语法，但让我们逐行地概述一下。
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This decorator marks the method as a class method. It essentially says that
    the method can be called on a class instead of an instantiated object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器标记方法为类方法。它基本上表示该方法可以在类上调用，而不是在实例化对象上调用：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This defines the `__subclasshook__` class method. This special method is called
    by the Python interpreter to answer the question, *Is the class* `C` *a subclass
    of this class?*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了`__subclasshook__`类方法。 Python解释器调用这个特殊方法来回答问题，“*类*`C`*是这个类的子类吗？*”
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We check to see if the method was called specifically on this class, rather
    than, say a subclass of this class. This prevents, for example, the `Wav` class
    from being thought of as a parent class of the `Ogg` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查方法是否特别在这个类上调用，而不是在这个类的子类上调用。例如，这可以防止`Wav`类被认为是`Ogg`类的父类：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'All this line does is get the set of methods and properties that the class
    has, including any parent classes in its class hierarchy:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行的作用只是获取类的方法和属性集，包括其类层次结构中的任何父类：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This line uses set notation to see whether the set of abstract methods in this
    class have been supplied in the candidate class. Note that it doesn't check to
    see whether the methods have been implemented, just if they are there. Thus, it's
    possible for a class to be a subclass and yet still be an abstract class itself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行使用集合表示法来查看这个类中的抽象方法集是否在候选类中提供。请注意，它不检查方法是否已经被实现，只是检查它们是否存在。因此，一个类可以是一个子类，但仍然是一个抽象类本身。
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If all the abstract methods have been supplied, then the candidate class is
    a subclass of this class and we return `True`. The method can legally return one
    of the three values: `True`, `False`, or `NotImplemented`. `True` and `False`
    indicate that the class is or is not definitively a subclass of this class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的抽象方法都已经被提供，那么候选类是这个类的子类，我们返回`True`。该方法可以合法地返回三个值中的一个：`True`，`False`或`NotImplemented`。`True`和`False`表示该类明确地是或不是这个类的子类：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If any of the conditionals have not been met (that is, the class is not `MediaLoader`
    or not all abstract methods have been supplied), then return `NotImplemented`.
    This tells the Python machinery to use the default mechanism (does the candidate
    class explicitly extend this class?) for subclass detection.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何条件都没有被满足（也就是说，这个类不是`MediaLoader`，或者并非所有抽象方法都已经被提供），那么返回`NotImplemented`。这告诉Python机制使用默认机制（候选类是否显式扩展了这个类？）进行子类检测。
- en: 'In short, we can now define the `Ogg` class as a subclass of the `MediaLoader`
    class without actually extending the `MediaLoader` class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们现在可以将`Ogg`类定义为`MediaLoader`类的子类，而不实际扩展`MediaLoader`类：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Case study
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'Let''s try to tie everything we''ve learned together with a larger example.
    We''ll be designing a simple real estate application that allows an agent to manage
    properties available for purchase or rent. There will be two types of properties:
    apartments and houses. The agent needs to be able to enter a few relevant details
    about new properties, list all currently available properties, and mark a property
    as sold or rented. For brevity, we won''t worry about editing property details
    or reactivating a property after it is sold.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用一个更大的例子把我们学到的一切联系在一起。我们将设计一个简单的房地产应用程序，允许代理人管理可供购买或租赁的房产。将有两种类型的属性：公寓和房屋。代理人需要能够输入有关新属性的一些相关细节，列出所有当前可用的属性，并标记属性为已售出或已出租。为简洁起见，我们不会担心编辑属性细节或在出售后重新激活属性。
- en: The project will allow the agent to interact with the objects using the Python
    interpreter prompt. In this world of graphical user interfaces and web applications,
    you might be wondering why we're creating such old-fashioned looking programs.
    Simply put, both windowed programs and web applications require a lot of overhead
    knowledge and boilerplate code to make them do what is required. If we were developing
    software using either of these paradigms, we'd get so lost in GUI programming
    or web programming that we'd lose sight of the object-oriented principles we're
    trying to master.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将允许代理人使用Python解释器提示与对象进行交互。在这个图形用户界面和Web应用程序的世界中，您可能会想知道为什么我们要创建这样看起来如此老式的程序。简而言之，窗口程序和Web应用程序都需要大量的知识和样板代码来使它们做所需的事情。如果我们使用这两种范式开发软件，我们将在GUI编程或Web编程中迷失，而失去我们试图掌握的面向对象的原则。
- en: Luckily, most GUI and web frameworks utilize an object-oriented approach, and
    the principles we're studying now will help in understanding those systems in
    the future. We'll discuss them both briefly in [Chapter 13](ch13.html "Chapter 13. Concurrency"),
    *Concurrency*, but complete details are far beyond the scope of a single book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数GUI和Web框架都采用面向对象的方法，我们现在学习的原则将有助于理解未来的这些系统。我们将在[第13章](ch13.html "第13章。并发")*并发*中简要讨论它们，但完整的细节远远超出了一本书的范围。
- en: Looking at our requirements, it seems like there are quite a few nouns that
    might represent classes of objects in our system. Clearly, we'll need to represent
    a property. Houses and apartments may need separate classes. Rentals and purchases
    also seem to require separate representation. Since we're focusing on inheritance
    right now, we'll be looking at ways to share behavior using inheritance or multiple
    inheritance.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的要求来看，似乎有很多名词可以代表我们系统中的对象类。显然，我们需要代表一个属性。房屋和公寓可能需要单独的类。租赁和购买似乎也需要单独的表示。由于我们现在专注于继承，我们将探讨使用继承或多重继承来共享行为的方法。
- en: '`House` and `Apartment` are both types of properties, so `Property` can be
    a superclass of those two classes. `Rental` and `Purchase` will need some extra
    thought; if we use inheritance, we''ll need to have separate classes, for example,
    for `HouseRental` and `HousePurchase`, and use multiple inheritance to combine
    them. This feels a little clunky compared to a composition or association-based
    design, but let''s run with it and see what we come up with.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`House`和`Apartment`都是物业的类型，所以`Property`可以是这两个类的超类。`Rental`和`Purchase`需要一些额外的考虑；如果我们使用继承，我们将需要有单独的类，例如`HouseRental`和`HousePurchase`，并使用多重继承来组合它们。与基于组合或关联的设计相比，这种感觉有点笨拙，但让我们试试看会得到什么。'
- en: Now then, what attributes might be associated with a `Property` class? Regardless
    of whether it is an apartment or a house, most people will want to know the square
    footage, number of bedrooms, and number of bathrooms. (There are numerous other
    attributes that might be modeled, but we'll keep it simple for our prototype.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`Property`类可能与哪些属性相关联？无论是公寓还是房子，大多数人都想知道面积、卧室数量和浴室数量。（可能有许多其他属性可以建模，但是对于我们的原型，我们将保持简单。）
- en: If the property is a house, it will want to advertise the number of stories,
    whether it has a garage (attached, detached, or none), and whether the yard is
    fenced. An apartment will want to indicate if it has a balcony, and if the laundry
    is ensuite, coin, or off-site.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物业是一座房子，它将希望宣传楼层数，车库类型（连接的、独立的或没有），以及院子是否有围栏。公寓将希望指示是否有阳台，以及洗衣房是套房式的、投币式的，还是在外面。
- en: Both property types will require a method to display the characteristics of
    that property. At the moment, no other behaviors are apparent.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 两种属性类型都需要一个方法来显示该属性的特征。目前，没有其他行为是明显的。
- en: Rental properties will need to store the rent per month, whether the property
    is furnished, and whether utilities are included, and if not, what they are estimated
    to be. Properties for purchase will need to store the purchase price and estimated
    annual property taxes. For our application, we'll only need to display this data,
    so we can get away with just adding a `display()` method similar to that used
    in the other classes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 租赁物业需要存储每月的租金，物业是否配备家具，以及是否包括公用事业，如果不包括，估计需要多少费用。购买物业需要存储购买价格和估计的年度物业税。对于我们的应用程序，我们只需要显示这些数据，所以我们可以简单地添加一个类似于其他类中使用的`display()`方法。
- en: Finally, we'll need an `Agent` object that holds a list of all properties, displays
    those properties, and allows us to create new ones. Creating properties will entail
    prompting the user for the relevant details for each property type. This could
    be done in the `Agent` object, but then `Agent` would need to know a lot of information
    about the types of properties. This is not taking advantage of polymorphism. Another
    alternative would be to put the prompts in the initializer or even a constructor
    for each class, but this would not allow the classes to be applied in a GUI or
    web application in the future. A better idea is to create a static method that
    does the prompting and returns a dictionary of the prompted parameters. Then,
    all the `Agent` has to do is prompt the user for the type of property and payment
    method, and ask the correct class to instantiate itself.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将需要一个`Agent`对象，它保存所有属性的列表，显示这些属性，并允许我们创建新的属性。创建属性将涉及提示用户输入每种属性类型的相关细节。这可以在`Agent`对象中完成，但是`Agent`将需要了解很多关于属性类型的信息。这并没有充分利用多态性。另一种选择是将提示放在初始化器或每个类的构造函数中，但这将不允许将来在GUI或Web应用程序中应用这些类。更好的想法是创建一个静态方法来提示并返回提示的参数的字典。然后，`Agent`所需做的就是提示用户输入属性类型和付款方式，并要求正确的类实例化自己。
- en: 'That''s a lot of designing! The following class diagram may communicate our
    design decisions a little more clearly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多的设计！以下的类图可能会更清晰地传达我们的设计决策：
- en: '![Case study](images/8781OS_3_03.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![案例研究](images/8781OS_3_03.jpg)'
- en: Wow, that's a lot of inheritance arrows! I don't think it would be possible
    to add another level of inheritance without crossing arrows. Multiple inheritance
    is a messy business, even at the design stage.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这是很多的继承箭头！我认为不可能再添加另一个继承级别而不交叉箭头。多重继承是一件混乱的事情，即使在设计阶段也是如此。
- en: 'The trickiest aspects of these classes is going to be ensuring superclass methods
    get called in the inheritance hierarchy. Let''s start with the `Property` implementation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类最棘手的方面将是确保在继承层次结构中调用超类方法。让我们从`Property`的实现开始：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This class is pretty straightforward. We've already added the extra `**kwargs`
    parameter to `__init__` because we know it's going to be used in a multiple inheritance
    situation. We've also included a call to `super().__init__` in case we are not
    the last call in the multiple inheritance chain. In this case, we're *consuming*
    the keyword arguments because we know they won't be needed at other levels of
    the inheritance hierarchy.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常直接了当。我们已经在`__init__`中添加了额外的`**kwargs`参数，因为我们知道它将在多重继承的情况下使用。我们还包括了对`super().__init__`的调用，以防我们不是多重继承链中的最后一个调用。在这种情况下，我们*消耗*了关键字参数，因为我们知道它们在继承层次结构的其他级别不会被需要。
- en: We see something new in the `prompt_init` method. This method is made into a
    static method immediately after it is initially created. Static methods are associated
    only with a class (something like class variables), rather than a specific object
    instance. Hence, they have no `self` argument. Because of this, the `super` keyword
    won't work (there is no parent object, only a parent class), so we simply call
    the static method on the parent class directly. This method uses the Python `dict`
    constructor to create a dictionary of values that can be passed into `__init__`.
    The value for each key is prompted with a call to `input`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`prompt_init`方法中我们看到了一些新的东西。这个方法在初始创建后立即变成了一个静态方法。静态方法只与类相关联（类似于类变量），而不是特定的对象实例。因此，它们没有`self`参数。因为这个原因，`super`关键字不起作用（没有父对象，只有一个父类），所以我们直接在父类上调用静态方法。这个方法使用Python的`dict`构造函数来创建一个可以传递给`__init__`的值的字典。每个键的值都是通过调用`input`来提示的。
- en: 'The `Apartment` class extends `Property`, and is similar in structure:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apartment`类扩展了`Property`，并且在结构上类似：'
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `display()` and `__init__()` methods call their respective parent class
    methods using `super()` to ensure the `Property` class is properly initialized.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`display()`和`__init__()`方法使用`super()`调用它们各自的父类方法，以确保`Property`类被正确初始化。'
- en: The `prompt_init` static method is now getting dictionary values from the parent
    class, and then adding some additional values of its own. It calls the `dict.update`
    method to merge the new dictionary values into the first one. However, that `prompt_init`
    method is looking pretty ugly; it loops twice until the user enters a valid input
    using structurally similar code but different variables. It would be nice to extract
    this validation logic so we can maintain it in only one location; it will likely
    also be useful to later classes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`prompt_init`静态方法现在从父类获取字典值，然后添加一些自己的额外值。它调用`dict.update`方法将新的字典值合并到第一个字典中。然而，`prompt_init`方法看起来相当丑陋；它循环两次，直到用户使用结构相似但不同的变量输入有效输入。我们最好提取这个验证逻辑，这样我们就可以在一个位置维护它；这对以后的类也可能有用。'
- en: With all the talk on inheritance, we might think this is a good place to use
    a mixin. Instead, we have a chance to study a situation where inheritance is not
    the best solution. The method we want to create will be used in a static method.
    If we were to inherit from a class that provided validation functionality, the
    functionality would also have to be provided as a static method that did not access
    any instance variables on the class. If it doesn't access any instance variables,
    what's the point of making it a class at all? Why don't we just make this validation
    functionality a module-level function that accepts an input string and a list
    of valid answers, and leave it at that?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有关于继承的讨论中，我们可能会认为这是使用mixin的好地方。相反，我们有机会研究继承不是最佳解决方案的情况。我们要创建的方法将用于一个静态方法。如果我们从提供验证功能的类继承，那么这个功能也必须作为一个静态方法提供，不得访问类上的任何实例变量。如果它不访问任何实例变量，那么把它作为一个类有什么意义呢？为什么我们不把这个验证功能作为一个模块级函数，接受一个输入字符串和一个有效答案列表，然后就此打住呢？
- en: 'Let''s explore what this validation function would look like:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个验证函数会是什么样子：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can test this function in the interpreter, independent of all the other classes
    we've been working on. This is a good sign, it means different pieces of our design
    are not tightly coupled to each other and can later be improved independently,
    without affecting other pieces of code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在解释器中测试这个函数，而不受我们一直在工作的所有其他类的影响。这是一个好迹象，这意味着我们设计的不同部分不会紧密耦合在一起，可以在不影响其他代码的情况下独立进行改进。
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s quickly update our `Apartment.prompt_init` method to use this new
    function for validation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速更新我们的`Apartment.prompt_init`方法，以使用这个新的验证函数：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That''s much easier to read (and maintain!) than our original version. Now
    we''re ready to build the `House` class. This class has a parallel structure to
    `Apartment`, but refers to different prompts and variables:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们原来的版本容易阅读（和维护！）。现在我们准备构建`House`类。这个类与`Apartment`有相似的结构，但是引用了不同的提示和变量：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There''s nothing new to explore here, so let''s move on to the `Purchase` and
    `Rental` classes. In spite of having apparently different purposes, they are also
    similar in design to the ones we just discussed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的东西可以探索，所以让我们继续讨论`Purchase`和`Rental`类。尽管它们似乎有不同的目的，但它们的设计也与我们刚刚讨论的类似：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'These two classes don''t have a superclass (other than `object`), but we still
    call `super().__init__` because they are going to be combined with the other classes,
    and we don''t know what order the `super` calls will be made in. The interface
    is similar to that used for `House` and `Apartment`, which is very useful when
    we combine the functionality of these four classes in separate subclasses. For
    example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类没有超类（除了`object`），但我们仍然调用`super().__init__`，因为它们将与其他类组合在一起，我们不知道`super`调用的顺序。接口与用于`House`和`Apartment`的接口类似，当我们将这四个类的功能组合在单独的子类中时，这是非常有用的。例如：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is slightly surprising, as the class on its own has neither an `__init__`
    nor `display` method! Because both parent classes appropriately call `super` in
    these methods, we only have to extend those classes and the classes will behave
    in the correct order. This is not the case with `prompt_init`, of course, since
    it is a static method that does not call `super`, so we implement this one explicitly.
    We should test this class to make sure it is behaving properly before we write
    the other three combinations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点令人惊讶，因为这个类本身既没有`__init__`方法也没有`display`方法！因为两个父类在这些方法中适当地调用了`super`，所以我们只需要扩展这些类，这些类就会按正确的顺序行为。当然，这在`prompt_init`中并不适用，因为它是一个不调用`super`的静态方法，所以我们要显式地实现这个方法。在我们写其他三种组合之前，我们应该测试这个类以确保它的行为正常：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It looks like it is working fine. The `prompt_init` method is prompting for
    initializers to all the super classes, and `display()` is also cooperatively calling
    all three superclasses.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它工作得很好。`prompt_init`方法正在提示所有超类的初始化器，并且`display()`也在合作地调用所有三个超类。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order of the inherited classes in the preceding example is important. If
    we had written `class HouseRental(House, Rental)` instead of `class HouseRental(Rental,
    House)`, `display()` would not have called `Rental.display()`! When `display`
    is called on our version of `HouseRental`, it refers to the `Rental` version of
    the method, which calls `super.display()` to get the `House` version, which again
    calls `super.display()` to get the property version. If we reversed it, `display`
    would refer to the `House` class's `display()`. When super is called, it calls
    the method on the `Property` parent class. But `Property` does not have a call
    to `super` in its `display` method. This means `Rental` class's `display` method
    would not be called! By placing the inheritance list in the order we did, we ensure
    that `Rental` calls `super`, which then takes care of the `House` side of the
    hierarchy. You might think we could have added a `super` call to `Property.display()`,
    but that will fail because the next superclass of `Property` is `object`, and
    `object` does not have a `display` method. Another way to fix this is to allow
    `Rental` and `Purchase` to extend the `Property` class instead of deriving directly
    from `object`. (Or we could modify the method resolution order dynamically, but
    that is beyond the scope of this book.)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中继承类的顺序很重要。如果我们写的是`class HouseRental(House, Rental)`而不是`class HouseRental(Rental,
    House)`，`display()`就不会调用`Rental.display()`！当在我们的`HouseRental`版本上调用`display`时，它指的是`Rental`方法的版本，它调用`super.display()`来获取`House`版本，再次调用`super.display()`来获取属性版本。如果我们颠倒了顺序，`display`就会指向`House`类的`display()`。当调用super时，它会在`Property`父类上调用方法。但是`Property`的`display`方法中没有调用`super`。这意味着`Rental`类的`display`方法不会被调用！通过按照我们的继承列表的顺序，我们确保`Rental`调用`super`，然后处理`House`层次结构的一面。你可能会认为我们可以在`Property.display()`中添加一个`super`调用，但这将失败，因为`Property`的下一个超类是`object`，而`object`没有`display`方法。修复这个问题的另一种方法是允许`Rental`和`Purchase`扩展`Property`类，而不是直接从`object`派生。（或者我们可以动态修改方法解析顺序，但这超出了本书的范围。）
- en: 'Now that we have tested it, we are prepared to create the rest of our combined
    subclasses:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试过了，我们准备创建我们的其他组合子类：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That should be the most intense designing out of our way! Now all we have to
    do is create the `Agent` class, which is responsible for creating new listings
    and displaying existing ones. Let''s start with the simpler storing and listing
    of properties:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是我们最紧张的设计了！现在我们所要做的就是创建`Agent`类，负责创建新的列表并显示现有的列表。让我们从更简单的存储和列出属性开始：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Adding a property will require first querying the type of property and whether
    property is for purchase or rental. We can do this by displaying a simple menu.
    Once this has been determined, we can extract the correct subclass and prompt
    for all the details using the `prompt_init` hierarchy we''ve already developed.
    Sounds simple? It is. Let''s start by adding a dictionary class variable to the
    `Agent` class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 添加属性将首先需要查询属性类型以及属性是出售还是出租。我们可以通过显示一个简单的菜单来做到这一点。确定了这一点后，我们可以提取正确的子类，并使用我们已经开发的`prompt_init`层次结构提示所有细节。听起来简单吗？是的。让我们首先向`Agent`类添加一个字典类变量：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That''s some pretty funny looking code. This is a dictionary, where the keys
    are tuples of two distinct strings, and the values are class objects. Class objects?
    Yes, classes can be passed around, renamed, and stored in containers just like
    *normal* objects or primitive data types. With this simple dictionary, we can
    simply hijack our earlier `get_valid_input` method to ensure we get the correct
    dictionary keys and look up the appropriate class, like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点滑稽！这是一个字典，其中键是两个不同字符串的元组，值是类对象。类对象？是的，类可以像*普通*对象或原始数据类型一样传递、重命名和存储在容器中。通过这个简单的字典，我们可以简单地劫持我们之前的`get_valid_input`方法，以确保我们获得正确的字典键并查找适当的类，就像这样：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This may look a bit funny too! We look up the class in the dictionary and store
    it in a variable named `PropertyClass`. We don't know exactly which class is available,
    but the class knows itself, so we can polymorphically call `prompt_init` to get
    a dictionary of values appropriate to pass into the constructor. Then we use the
    keyword argument syntax to convert the dictionary into arguments and construct
    the new object to load the correct data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这也许看起来有点滑稽！我们在字典中查找类并将其存储在名为`PropertyClass`的变量中。我们不知道确切可用的类是哪个，但类知道自己，所以我们可以多态地调用`prompt_init`来获取适合传递到构造函数的值的字典。然后我们使用关键字参数语法将字典转换为参数，并构造新对象来加载正确的数据。
- en: 'Now our user can use this `Agent` class to add and view lists of properties.
    It wouldn''t take much work to add features to mark a property as available or
    unavailable or to edit and remove properties. Our prototype is now in a good enough
    state to take to a real estate `agent` and demonstrate its functionality. Here''s
    how a demo session might work:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的用户可以使用这个`Agent`类来添加和查看属性列表。添加功能来标记属性为可用或不可用，或编辑和删除属性也不需要太多工作。我们的原型现在已经足够好，可以带给房地产经纪人并展示其功能。以下是演示会话可能的工作方式：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Exercises
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Look around you at some of the physical objects in your workspace and see if
    you can describe them in an inheritance hierarchy. Humans have been dividing the
    world into taxonomies like this for centuries, so it shouldn't be difficult. Are
    there any non-obvious inheritance relationships between classes of objects? If
    you were to model these objects in a computer application, what properties and
    methods would they share? Which ones would have to be polymorphically overridden?
    What properties would be completely different between them?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你的工作空间中的一些物理物体，看看你是否能用继承层次结构描述它们。人类几个世纪以来一直在将世界划分成这样的分类，所以这不应该难。在对象类之间是否存在一些非明显的继承关系？如果你要在计算机应用程序中对这些对象建模，它们会共享哪些属性和方法？哪些属性需要多态地重写？它们之间会有完全不同的属性吗？
- en: Now, write some code. No, not for the physical hierarchy; that's boring. Physical
    items have more properties than methods. Just think about a pet programming project
    you've wanted to tackle in the past year, but never got around to. For whatever
    problem you want to solve, try to think of some basic inheritance relationships.
    Then implement them. Make sure that you also pay attention to the sorts of relationships
    that you actually don't need to use inheritance for. Are there any places where
    you might want to use multiple inheritance? Are you sure? Can you see any place
    you would want to use a mixin? Try to knock together a quick prototype. It doesn't
    have to be useful or even partially working. You've seen how you can test code
    using `python -i` already; just write some code and test it in the interactive
    interpreter. If it works, write some more. If it doesn't, fix it!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，写一些代码。不是为了物理层次结构；那太无聊了。物理物品比方法有更多的属性。只是想想你过去一年想要解决的宠物编程项目，但从未着手解决过。无论你想解决什么问题，都试着想一些基本的继承关系。然后实施它们。确保你也注意到你实际上不需要使用继承的关系。有没有地方你可能想要使用多重继承？你确定吗？你能看到任何你想要使用mixin的地方吗？试着拼凑一个快速的原型。它不必有用，甚至部分工作。你已经看到如何使用`python
    -i`测试代码了；只需写一些代码并在交互式解释器中测试它。如果它有效，就写更多。如果不行，就修复它！
- en: Now, take a look at the real estate example. This turned out to be quite an
    effective use of multiple inheritance. I have to admit though, I had my doubts
    when I started the design. Have a look at the original problem and see if you
    can come up with another design to solve it that uses only single inheritance.
    How would you do it with abstract base classes? What about a design that doesn't
    use inheritance at all? Which do you think is the most elegant solution? Elegance
    is a primary goal in Python development, but each programmer has a different opinion
    as to what is the most elegant solution. Some people tend to think and understand
    problems most clearly using composition, while others find multiple inheritance
    to be the most useful model.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看房地产的例子。这实际上是多重继承的一种非常有效的应用。不过，我必须承认，当我开始设计时，我有些怀疑。看看原始问题，看看你是否能想出另一种只使用单一继承来解决它的设计。你会如何使用抽象基类来做到这一点？还有一种不使用继承的设计吗？你认为哪种是最优雅的解决方案？优雅是Python开发的主要目标，但每个程序员对什么是最优雅的解决方案有不同的看法。有些人倾向于使用组合来更清晰地思考和理解问题，而其他人则认为多重继承是最有用的模型。
- en: Finally, try adding some new features to the three designs. Whatever features
    strike your fancy are fine. I'd like to see a way to differentiate between available
    and unavailable properties, for starters. It's not of much use to me if it's already
    rented!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试向这三种设计添加一些新功能。任何你喜欢的功能都可以。我想看到一种区分可用和不可用属性的方法，首先。如果已经被租出去，对我来说没什么用！
- en: Which design is easiest to extend? Which is hardest? If somebody asked you why
    you thought this, would you be able to explain yourself?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种设计最容易扩展？哪种最难？如果有人问你为什么这样认为，你能解释吗？
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've gone from simple inheritance, one of the most useful tools in the object-oriented
    programmer's toolbox, all the way through to multiple inheritance, one of the
    most complicated. Inheritance can be used to add functionality to existing classes
    and built-ins using inheritance. Abstracting similar code into a parent class
    can help increase maintainability. Methods on parent classes can be called using
    `super` and argument lists must be formatted safely for these calls to work when
    using multiple inheritance.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从简单的继承，这是面向对象程序员工具箱中最有用的工具之一，一直到多重继承，这是最复杂的工具之一。继承可以用来向现有类和内置类添加功能。将相似的代码抽象成父类可以帮助增加可维护性。可以使用`super`调用父类上的方法，并且在使用多重继承时，必须安全地格式化参数列表，以使这些调用正常工作。
- en: In the next chapter, we'll cover the subtle art of handling exceptional circumstances.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论处理特殊情况的微妙艺术。
