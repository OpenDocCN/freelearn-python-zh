- en: Data Persistence and BaseDataObject
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据持久性和BaseDataObject
- en: This chapter will focus exclusively on the development and testing of the `BaseDataObject`
    ABC (Abstract Base Class), which we'll need in both the `hms_artisan` (**Artisan
    Application**) and `hms_gateway` (**Artisan Gateway** service) component projects.
    It is possible that the `hms_co` (**Central Office Application**) code base will
    also need to utilize the same functionality. We'll look at that in some depth
    later, while working through the `hms_co` code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于`BaseDataObject` ABC（抽象基类）的开发和测试，我们将在`hms_artisan`（**Artisan Application**）和`hms_gateway`（**Artisan
    Gateway**服务）组件项目中都需要它。`hms_co`（**Central Office Application**）代码库可能也需要利用相同的功能。在后面深入研究`hms_co`代码时，我们将更深入地了解这一点。
- en: 'At present, we''re expecting `BaseDataObject` to look something like this:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们期望`BaseDataObject`看起来像这样：
- en: '![](assets/5ea73312-a111-454d-8888-4ee6220ffe0a.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5ea73312-a111-454d-8888-4ee6220ffe0a.png)'
- en: 'The story that drives the design and implementation of the `BaseDataObject` that
    was described earlier is as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的驱动`BaseDataObject`设计和实现的故事如下：
- en: As a developer, I need a common structure for providing persistence of state
    data for business objects that are available across the entire system so that
    I can build the relevant final classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要一个通用的结构来提供整个系统可用的业务对象的状态数据的持久性，以便我可以构建相关的最终类
- en: '`BaseDataObject` is not functionally related to the business object definitions
    in `hms_core`, but the functionality it provides still needs to be available to
    all of the real code bases – the ones for the applications and the **Artisan Gateway**
    service – it makes sense that it should live in the `hms_core` package, but perhaps
    not with the business object definitions from the previous iteration. In the long
    run, it will be easier to understand and maintain the `hms_core` package if its
    various members are organized into modules that group elements into common purposes
    or themes. Before the end of this iteration, the current `hms_core.__init__.py` module
    will be renamed to something more indicative of the purposes it serves, and it
    will live next to a new module that will contain all of the data objects'' classes
    and functionality: `data_object.py`.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDataObject`与`hms_core`中的业务对象定义没有功能上的关联，但它提供的功能仍然需要对所有真实的代码库（应用程序和**Artisan
    Gateway**服务）可用，因此它应该存在于`hms_core`包中，但可能不应该与上一次迭代的业务对象定义一起。从长远来看，如果`hms_core`的各个成员被组织成将元素分组到共同目的或主题的模块，那么理解和维护`hms_core`包将更容易。在本次迭代结束之前，当前的`hms_core.__init__.py`模块将被重命名为更具指示性的名称，并且它将与一个新模块一起存在，该模块将包含所有数据对象的类和功能：`data_object.py`。'
- en: 'There are two additional stories that relate to the structure of `BaseDataObject` and
    capabilities, whose needs will be noted as they are met during the development
    of the class:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个与`BaseDataObject`结构和功能相关的故事，它们的需求将在开发类的过程中得到满足：
- en: As any data consumer, I need to be able to create, read, update and delete individual
    data objects, so that I can perform basic data management tasks against those
    objects.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为任何数据使用者，我需要能够创建、读取、更新和删除单个数据对象，以便对这些对象执行基本的数据管理任务。
- en: As any data consumer, I need to be able to search for specific data objects
    so that I can then work with the resulting items found.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为任何数据使用者，我需要能够搜索特定的数据对象，以便我可以使用找到的结果项。
- en: The BaseDataObject ABC
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BaseDataObject ABC
- en: 'The bulk of the properties of `BaseDataObject` are Boolean values, flags that
    indicate whether an instance of the class is in a specific state. The implementations
    of those properties all follow a simple pattern that''s already been shown in
    the definition of the  `available` property of `BaseProduct` in the previous iteration.
    That structure looks like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDataObject`的大部分属性都是布尔值，表示类的实例是否处于特定状态的标志。这些属性的实现都遵循一个简单的模式，这个模式已经在上一次迭代中的`BaseProduct`的`available`属性的定义中展示过。这个结构看起来像这样：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The deleter methods behind those properties, since they are also used to set
    the default values for an instance during initialization, should yield specific
    values when the properties are deleted (calling those methods):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性背后的删除方法，因为它们也用于在初始化期间设置实例的默认值，当删除属性时应该产生特定的值（调用这些方法）：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Unless overridden by a derived class, or by a specific object creation process,
    any instance derived from `BaseDataObject` will start with these:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除非被派生类或特定对象创建过程覆盖，从`BaseDataObject`派生的任何实例都将以这些值开始：
- en: '`is_active == True`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_active == True`'
- en: '`is_deleted == False`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_deleted == False`'
- en: '`is_dirty == False`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_dirty == False`'
- en: '`is_new == True`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_new == True`'
- en: So a newly created instance will be active, not deleted, not dirty, and new
    , the assumption being that the process of creating a new object will usually
    be with the intention of saving a new, active object. If any state changes are
    made between the creation of the instance, those may set the `is_dirty` flag to `True` in
    the process, but the fact that `is_new` is `True` means that the object's record
    needs to be created rather than updated in the backend datastore.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，新创建的实例将是活动的，未删除的，未修改的，新的，假设是创建新对象的过程通常是为了保存一个新的、活动的对象。如果在实例创建之间进行了任何状态更改，这些更改可能会在过程中将`is_dirty`标志设置为`True`，但`is_new`为`True`的事实意味着对象的记录需要在后端数据存储中被创建而不是更新。
- en: 'The only significant deviation from that standard Boolean property structure
    is in the documentation of the properties themselves during their definition:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准布尔属性结构的唯一重大偏差在于它们的定义过程中属性本身的文档：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Two of the properties of `BaseDataObject`, `created` and `modified`, are shown
    in the class diagram as `datetime` values – objects that represent a specific
    time of day on a specific date. A `datetime` object stores the year, month, day,
    hour, minute, second, and microsecond of a date/time, and provides several conveniences
    over, say, working with an equivalent value that is managed strictly as a timestamp
    number value, or a string representation of a date/time. One of those conveniences
    is the ability to parse a value from a string, allowing the `_set_created` and `_set_modified` setter methods
    behind the property to accept a string value instead of requiring an actual `datetime`.
    Similarly, `datetime` provides the ability to create a `datetime` instance from
    a timestamp – the number of seconds elapsed from a common starting date/time. In
    order to fully support all those argument types, it''s necessary to define a common
    format string that will be used to parse the `datetime` values from strings and to
    format them into strings. That value, at least for now, feels like it''s probably
    best stored as a class attribute on `BaseDataObject` itself. That way, all classes
    that derive from it will have the same value available by default:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDataObject`的两个属性`created`和`modified`在类图中显示为`datetime`值-表示特定日期的特定时间的对象。`datetime`对象存储日期/时间的年、月、日、小时、分钟、秒和微秒，并提供了一些方便之处，例如，与严格作为时间戳数字值管理的等效值或日期/时间的字符串表示相比。其中一个方便之处是能够从字符串中解析值，允许属性背后的`_set_created`和`_set_modified`setter方法接受字符串值而不是要求实际的`datetime`。同样，`datetime`提供了从时间戳创建`datetime`实例的能力-从公共起始日期/时间开始经过的秒数。为了完全支持所有这些参数类型，有必要定义一个通用的格式字符串，用于从字符串中解析`datetime`值并将其格式化为字符串。至少目前来看，最好将该值存储为`BaseDataObject`本身的类属性。这样，所有从中派生的类都将默认可用相同的值：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The setter methods are somewhat longer than most, since they are dealing with
    four different viable value types, though there are only two subprocesses required
    to cover all of those variations. The setter process starts by type checking the
    supplied value and confirming that it''s one of the accepted types first:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: setter方法比大多数方法要长一些，因为它们处理四种不同的可行值类型，尽管只需要两个子进程来覆盖所有这些变化。setter过程首先通过类型检查提供的值并确认它是接受的类型之一：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Handling either of the numeric types that are legitimate is fairly straightforward.
    If an error is detected, we should provide more specific messaging around the
    nature of the encountered problem:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 处理合法的两种数字类型都相当简单。如果检测到错误，我们应该提供更具体的消息，说明遇到的问题的性质：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The subprocess for handling string values is similar, apart from its call to `datetime.strptime` instead
    of `datetime.fromtimestamp`, and its use of the `_data_time_string` class attribute
    to define what a valid date/time string looks like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 处理字符串值的子进程类似，除了调用`datetime.strptime`而不是`datetime.fromtimestamp，并使用`_data_time_string`类属性来定义有效的日期/时间字符串外：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the original value was an instance of `datetime`, then neither of the previous
    subprocesses would have executed. If either of them executed, then the original
    value argument will have been replaced with a `datetime` instance. In either case,
    that value can be stored in the underlying property attribute:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始值是`datetime`的实例，那么之前的任何一个子进程都不会被执行。如果它们中的任何一个被执行，那么原始值参数将被替换为`datetime`实例。无论哪种情况，该值都可以存储在底层属性中：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the purposes of `BaseDataObject`, both `created` and `modified` should always have
    a value, and if one isn''t available when it''s needed – generally only when a
    data object''s state data record is being saved – one should be created then and
    there for the current value, which can be accomplished in the getter method with `datetime.now()`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`BaseDataObject`，`created`和`modified`应该始终有一个值，如果在需要时没有可用值（通常只有在保存数据对象的状态数据记录时才需要），则应该为当前值创建一个值，可以在getter方法中使用`datetime.now()`来实现：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That, in turn, implies that the deleter method should set the property storage
    attribute''s value to `None`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来意味着删除方法应该将属性存储属性的值设置为`None`：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The corresponding property definitions are standard, except that the `created` property
    doesn''t allow deletion directly;  it makes no sense to allow an object to delete
    its own created date/time:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的属性定义是标准的，只是`created`属性不允许直接删除；允许对象删除自己的创建日期/时间是没有意义的：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last property of `BaseDataObject` is, perhaps, the most critical  `oid`,
    which is intended to uniquely identify the state data record for a given data
    object. That property is defined as a **Universally Unique Identifier** (**UUID**)
    value, which Python provides in its `uuid` library. There are at least two advantages
    to using a UUID as a unique identifier instead of some of the more traditional
    approaches, such as a serial record number:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDataObject`的最后一个属性可能是最关键的`oid`，它旨在唯一标识给定数据对象的状态数据记录。该属性被定义为**通用唯一标识符**（**UUID**）值，Python在其`uuid`库中提供。使用UUID作为唯一标识符而不是一些更传统的方法，例如序列记录号，至少有两个优点：'
- en: '**UUIDs are not dependent on a database operation''s success to be available:**
    They can be generated in code, without having to worry about waiting for a SQL
    INSERT to complete, for example, or whatever corresponding mechanism might be
    available in a NoSQL data store. That means fewer database operations, and probably
    simpler ones as well, which makes things easier.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UUID不依赖于数据库操作的成功才可用：**它们可以在代码中生成，而无需担心等待SQL INSERT完成，例如，或者在NoSQL数据存储中可能可用的任何相应机制。这意味着更少的数据库操作，可能也更简单，这样事情就更容易了。'
- en: '**UUIDs are not easily predictable:** A UUID is a series of 32 hexadecimal
    digits (with some dashes separating them into sections that are not relevant for
    this discussion), such as `ad6e3d5c-46cb-4547-9971-5627e6b3039a`. If they are
    generated with any of several standard functions provided by the `uuid` library,
    their sequence, if not truly random, is at least random enough to make finding
    a given value very difficult for a malicious user, with 3.4 × 10^(34) possible
    values to look for (16 values per hex digit, 31 digits because one is reserved).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UUID不容易预测：** UUID是一系列由32个十六进制数字组成的字符串（其中有一些破折号将它们分成了本讨论不相关的部分），例如`ad6e3d5c-46cb-4547-9971-5627e6b3039a`。如果它们是由`uuid`库提供的几个标准函数之一生成的，它们的序列，即使不是真正随机的，也至少足够随机，使得对于恶意用户来说，找到给定值非常困难，有3.4×10^(34)个可能的值要查找（每个十六进制数字有16个值，31个数字因为其中一个被保留）。'
- en: The unpredictability of UUIDs is especially useful in applications that have
    data accessible over the internet. Identification of records by sequential numbering
    makes it *much* easier for malicious processes to hit an API of some sort and
    just retrieve each record in sequence, all else being equal.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: UUID的不可预测性在具有通过互联网访问的数据的应用程序中尤其有用。通过顺序编号识别记录，使恶意进程更容易命中某种API并按顺序检索每个记录，其他条件相同。
- en: 'There are some caveats, though:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些注意事项：
- en: Not all database engines will recognize UUID objects as viable field types.
    That can be managed by storing actual UUID values in the data objects, but writing
    and reading string representations of those values to and from the database.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有的数据库引擎都会将UUID对象识别为可行的字段类型。这可以通过将实际的UUID值存储在数据对象中来管理，但是将这些值的字符串表示写入和从数据库中读取。
- en: There may be very slight performance impacts on database operations that use
    UUIDs as unique identifiers as well, especially if a string representation is
    used instead of the actual value.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UUID作为唯一标识符的数据库操作可能会产生非常轻微的性能影响，特别是如果使用字符串表示而不是实际值。
- en: Their inherent unpredictability can make legitimate examination of data difficult
    if there aren't other identifying criteria that can be used – human-meaningful
    data values that can be queried against (against other identifying criteria).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们固有的不可预测性可以使对数据的合法检查变得困难，如果没有其他可以用来查询的标识标准（针对其他标识标准）。
- en: 'Even setting the advantages aside, `BaseDataObject` will use UUIDs for object
    identity (the `oid` property) because of a combination of requirements and expected
    implementations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使将优势放在一边，`BaseDataObject`将使用UUID作为对象标识（`oid`属性）的原因是一系列要求和预期的实现的结合：
- en: The **Artisan Application** won't have a real database behind it. It'll probably
    end up being a simple, local document store so the generation of a unique identifier
    for any given data object must be something that's self-contained and not reliant
    on anything other than the application's code base.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Artisan Application**将不会有一个真正的数据库支持它。它最终可能会成为一个简单的本地文档存储，因此为任何给定的数据对象生成唯一标识符必须是自包含的，不依赖于应用程序代码库之外的任何东西。'
- en: The same `oid` values need to propagate to and from the **Artisan Application**
    and the **Artisan Gateway** service. Trying to coordinate identities across any
    number of artisans could lead, very quickly, to identity collisions, and mitigating
    that would probably require more work (maybe a lot more) without making significant
    changes to the requirements of the system, or at least how the various installables
    in the system interact. The likelihood of collisions between any two randomly-generated
    UUIDs is extremely low (if not impossible for all practical purposes), simply
    because of the number of possible values involved.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相同的oid值需要在**Artisan Application**和**Artisan Gateway**服务之间传播。尝试在任意数量的工匠之间协调身份可能会很快导致身份冲突，而要减轻这种情况可能需要更多的工作（也许是更多），而不会对系统的要求或系统中的各种可安装组件的交互方式进行重大改变。两个随机生成的UUID之间发生碰撞的可能性非常低（对于所有实际目的来说几乎不可能），仅仅是因为涉及的可能值的数量。'
- en: 'Implementation of the `oid` property will follow a pattern similar to the one
    established for the ones based on `datetime`. The getter method will create one
    on demand, the setter method will accept `UUID` objects or string representations
    of it and create actual `UUID` objects internally, and the deleter method will
    set the current storage value to `None`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`oid`属性的实现将遵循与基于`datetime`的属性类似的模式。获取方法将根据需要创建一个，设置方法将接受`UUID`对象或其字符串表示，并在内部创建实际的`UUID`对象，删除方法将将当前存储值设置为`None`：'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Most of the methods of `BaseDataObject` are abstract, including all of the
    class methods. None of them has any concrete implementations that might be reused
    in derived classes, so they are all very basic definitions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDataObject`的大多数方法都是抽象的，包括所有的类方法。它们都没有任何可能在派生类中重用的具体实现，因此它们都是非常基本的定义。'
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `to_data_dict` instance method and the `from_data_dict` class method are
    intended to provide mechanisms to represent an instance's complete state data
    as a `dict`, and create an instance from such a `dict` representation, respectively.
    The `from_data_dict` method should facilitate record retrieval and conversion
    into actual programmatic objects across most standard RDBMS-connection libraries
    in Python, especially if the field names in the database are identical to the
    property names of the class. Similar usage should be viable in NoSQL data stores
    as well. Though the `to_data_dict` method may or may not be as useful in writing
    records to a data store, it will be needed to match objects based on criteria
    (the matches method, which we'll get to shortly).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_data_dict`实例方法和`from_data_dict`类方法旨在提供机制，将实例的完整状态数据表示为`dict`，并从这样的`dict`表示中创建一个实例。`from_data_dict`方法应该促进记录检索和转换为实际的程序对象，尤其是在Python中的标准RDBMS连接库中，如果数据库中的字段名与类的属性名相同。在NoSQL数据存储中也应该有类似的用法。尽管`to_data_dict`方法在写入数据存储时可能有用，但它将需要根据标准匹配对象（我们马上会讨论的`matches`方法）。'
- en: PEP-249, the current **Python Database API Specification**, defines an expectation
    that database queries in libraries that conform to the standards of the PEP will,
    at a minimum, return lists of tuples as result sets. Most mature database connector
    libraries also provide a convenience mechanism to return a list of `dict` record
    values, where each dict maps field names as keys to the values of the source records.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-249，当前的**Python数据库API规范**，定义了符合PEP标准的库中的数据库查询的预期，至少会返回元组列表作为结果集。大多数成熟的数据库连接器库还提供了一种方便的机制，以返回一个`dict`记录值列表，其中每个`dict`将字段名映射为源记录的值。
- en: The `_create` and `_update` methods are simply requirements for the record creation
    and record update processes, and will eventually be called by the `save` method.
    The need for separate record creation and record update processes may not be applicable
    to all data store engines, though; some, especially in the NoSQL realm, already
    provide a single mechanism for writing a record, and simply don't care whether
    it already exists. Others may provide some sort of mechanism that will allow an
    attempt to create a new record to be made first, and if that fails (because a
    duplicate key is found, indicating that the record already exists), then update
    the existing record instead. This option is available in `MySQL` and `MariaDB`
    databases, but may exist elsewhere. In any of those cases, overriding the save
    method to use those single-point-of-contact processes may be a better option.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`_create`和`_update`方法只是记录创建和记录更新过程的要求，并最终将被`save`方法调用。然而，单独的记录创建和记录更新过程的需求可能并不适用于所有数据存储引擎；一些，特别是在NoSQL领域，已经提供了写入记录的单一机制，并且根本不关心它是否已经存在。其他一些可能提供某种机制，允许首先尝试创建一个新记录，如果失败（因为找到了重复的键，表明记录已经存在），则更新现有记录。这个选项在`MySQL`和`MariaDB`数据库中可用，但可能也存在于其他地方。在任何这些情况下，覆盖保存方法以使用这些单一接触点的过程可能是一个更好的选择。'
- en: The `delete` class method is  self-explanatory, and `sort` probably is as well.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`类方法是不言自明的，`sort`可能也是如此。'
- en: 'The `get` method requires some examination, even without any concrete implementation.
    As noted earlier, it is intended to be the primary mechanism for returning objects
    with state data retrieved from the database, and to accept both zero-to-many object
    IDs (the `*oids` argument list) and filtering criteria (in the `**criteria` keyword
    arguments). The expectation for how the whole `get` process will actually work is
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法需要一些检查，即使没有任何具体的实现。正如前面所述，它旨在成为从数据库检索状态数据并接受零到多个对象ID（`*oids`参数列表）和过滤标准（在`**criteria`关键字参数中）的主要机制。整个`get`过程实际上的预期工作如下：'
- en: 'If `oids` is not empty:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`oids`不为空：
- en: Perform whatever low-level query or lookup is needed to find objects that match
    one of the provided `oids`, processing each record with `from_data_dict` and yielding
    a list of objects
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所需的任何低级查询或查找以找到与提供的`oids`之一匹配的对象，使用`from_data_dict`处理每个记录并生成对象列表
- en: If `criteria` is not empty, filter the current list down to those objects whose `matches` results
    against the criteria are `True`
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`criteria`不为空，则将当前列表过滤为那些与标准的`matches`结果为`True`的对象
- en: Return the resulting list
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回结果列表
- en: 'Otherwise, if `criteria` is not empty:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果`criteria`不为空：
- en: Perform whatever low-level query or lookup is needed to find objects that match one of
    the provided criteria values, processing each record with `from_data_dict` and
    yielding a list of objects
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行所需的任何低级查询或查找以找到与提供的标准值之一匹配的对象，使用`from_data_dict`处理每个记录并生成对象列表
- en: Filter the current list down to those objects whose `matches` results against
    the criteria are `True`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前列表过滤为那些与标准的`matches`结果为`True`的对象
- en: Return the resulting list
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回结果列表
- en: Otherwise, perform whatever low-level query or lookup is needed to retrieve all available
    objects, again processing each record with `from_data_dict`, yielding a list of
    objects and simply returning them all
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，执行所需的任何低级查询或查找以检索所有可用对象，再次使用`from_data_dict`处理每个记录，生成对象列表并简单地返回它们所有
- en: 'Taken together, the combination of the `oids` and `criteria` values will allow
    the `get` class method to find and return objects that do the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 综合考虑，`oids`和`criteria`值的组合将允许`get`类方法找到并返回执行以下操作的对象：
- en: Match one or more `oids`: `get(oid[, oid, …, oid])`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配一个或多个`oids`：`get(oid[, oid, …, oid])`
- en: Match one or more `oids` and some set of `criteria`: `get(oid[, oid, …, oid],
    key=value[, key=value, …, key=value])`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配一个或多个`oids`和一些`criteria`的集合：`get(oid[, oid, …, oid], key=value[, key=value,
    …, key=value])`
- en: Match one or more `criteria` key/value pairs, regardless of the `oids` of the
    found items: `get(key=value[, key=value, …, key=value])`
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配一个或多个`criteria`键/值对，无论找到的项目的`oids`如何：`get(key=value[, key=value, …, key=value])`
- en: 'That simply exist in the backend data store: `get()`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这只是存在于后端数据存储中的：`get()`
- en: 'That leaves the `matches` and `save` methods, the only two concrete implementations
    in the class. The goal behind `matches` is to provide an instance-level mechanism
    for comparing the instance with criteria names/values, which is the process that
    the `criteria` in the `get` method uses and relies upon to actually find matching
    items. Its implementation is simpler than it might appear at first, but relies
    on operations against `set` objects, and on a Python built-in function that is
    often overlooked (`all`), so the process itself is heavily commented in the code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了`matches`和`save`方法，这两个方法是类中唯一的两个具体实现。`matches`的目标是提供一个实例级机制，用于比较实例与标准名称/值，这是`get`方法中使用和依赖的过程，以实际找到匹配项。它的实现比起一开始可能看起来要简单，但依赖于对`set`对象的操作，并且依赖于一个经常被忽视的Python内置函数（`all`），因此代码中的过程本身有很多注释：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `all` function is a nice convenience it returns `True` if all of the items
    in the iterable it''s passed evaluate to `True` (or at least true-ish, so non-empty
    strings, lists, tuples, and dictionaries, and non-zero numbers, would all be considered `True`).
    It returns `False` if any members of the iterable aren''t `True`, and returns `True` if
    the iterable is empty. The results of `matches` will be `False` if these conditions
    occur:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`函数是一个很好的便利，如果它被传递的可迭代对象中的所有项都评估为`True`（或至少是真的，因此非空字符串、列表、元组和字典以及非零数字都被认为是`True`），它将返回`True`。如果可迭代对象中的任何成员不是`True`，则返回`False`，如果可迭代对象为空，则返回`True`。如果出现这些条件，`matches`的结果将是`False`：'
- en: Any key in the `criteria` doesn't exist in the instance's `data_dict` – a criteria
    key that cannot be matched, essentially
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`criteria`中的任何键都不存在于实例的`data_dict`中- 一个无法匹配的标准键，本质上'
- en: Any value specified in `criteria` doesn't exactly match its corresponding value
    in the instance's `data_dict`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`criteria`中指定的任何值都不完全匹配实例的`data_dict`中的相应值'
- en: 'The `save` method is very simple. It just calls the instance''s `_create` or `_update` methods
    based on the current state of the instance''s `is_new` or `is_dirty` flag properties,
    respectively, and resets those flags after either executes, leaving the object
    clean and ready for whatever might come next:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`方法非常简单。它只是根据实例的`is_new`或`is_dirty`标志属性的当前状态调用实例的`_create`或`_update`方法，然后在执行后重置这些标志，使对象变得干净并准备好接下来可能发生的任何事情：'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The initialization of a `BaseDataObject` should allow values for all of its
    properties, but not require any of those values:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDataObject`的初始化应该允许为其所有属性指定值，但不需要这些值：'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The actual initialization process follows the previously established pattern
    for optional arguments for all arguments in that case: calling the corresponding `_del_` method
    for each, then calling the corresponding `_set_` method for each if the argument
    isn''t `None`. Let''s use the `oid` argument as an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的初始化过程遵循了先前为所有参数建立的可选参数模式：对于每个参数，如果参数不是`None`，则调用相应的`_del_`方法，然后调用相应的`_set_`方法。让我们以`oid`参数为例：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This initializer method''s signature is getting pretty long, with seven arguments
    (ignoring `self`, since that will always be present, and will always be the first
    argument). Knowing that we''ll eventually define concrete classes as combinations
    of `BaseDataObject` and one of the business object classes defined, the signature
    for `__init__` on those concrete classes could get much longer, too. That, though,
    is part of the reason why the initialization signature of `BaseDataObject` makes
    all of the arguments optional. Taken in combination with one of those business
    object classes, `BaseArtisan`, for example, with an `__init__` signature of:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始化方法的签名变得非常长，有七个参数（忽略`self`，因为它总是存在的，并且总是第一个参数）。知道我们最终将定义具体类作为`BaseDataObject`和已定义的业务对象类的组合，这些具体类的`__init__`签名也可能会变得更长。然而，这正是`BaseDataObject`的初始化签名使所有参数都是可选的原因之一。与其中一个业务对象类结合使用时，例如`BaseArtisan`，其`__init__`签名如下：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The combined `__init__` signature for an `Artisan` that's derived from both,
    while long...
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两者派生的`Artisan`的`__init__`签名，虽然很长...
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '... only requires the `contact_name`, `contact_email`, and `address` arguments
    that `BaseArtisan` requires, and allows all of the arguments to be passed as if
    they were keyword arguments, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '...只需要`BaseArtisan`需要的`contact_name`、`contact_email`和`address`参数，并允许所有参数都被传递，就像它们是关键字参数一样，像这样：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Allows the entire parameter set to be defined as a single dictionary and passed
    whole-cloth to the initializer using the same syntax that passing a keyword argument
    set would use:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 允许将整个参数集定义为单个字典，并使用传递关键字参数集的相同语法将其整体传递给初始化程序：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That syntax for passing arguments in a dictionary using `**dictionary_name` is
    a common form of argument parameterization in Python, especially in functions
    and methods where the full collection of arguments is unreasonably long. It requires
    some thought and discipline on the design side of the development process, and
    an eye toward being very restrictive with respect to required arguments, but in
    the long run, it's more helpful and easier to use than might appear at first glance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，使用`**dictionary_name`将参数传递给字典的语法是一种常见的参数参数化形式，特别是在参数集合非常长的函数和方法中。这需要在开发过程的设计方面进行一些思考和纪律，并且需要对必需参数非常严格，但从长远来看，它比一开始看起来的更有帮助和更容易使用。
- en: 'This last structure will be critical in the implementation of the `from_data_dict` methods
    of the various classes derived from `BaseDataObject` – in most cases, it should allow
    the implementation of those methods to be little more than this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的结构将对从`BaseDataObject`派生的各种类的`from_data_dict`方法的实现至关重要- 在大多数情况下，它应该允许这些方法的实现不仅仅是这样：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Unit testing BaseDataObject
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试`BaseDataObject`
- en: 'Unit testing of `BaseDataObject` is going to be… interesting, as it stands
    right now. Testing the `matches` method, a concrete method that depends on an
    abstract method (`to_data_dict`), which, in turn depends on the actual data structure
    (`properties`) of a derived class, is either not possible or meaningless in the
    context of the test case class for `BaseDataObject` itself:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，对`BaseDataObject`进行单元测试将会是有趣的。测试`matches`方法，这是一个依赖于抽象方法(`to_data_dict`)的具体方法，而抽象方法又依赖于派生类的实际数据结构(`properties`)，在`BaseDataObject`的测试用例类的上下文中，要么是不可能的，要么是没有意义的：
- en: In order to test `matches`, we have to define a non-abstract class with a concrete
    implementation of `to_data_dict`, and some actual properties to generate that resulting `dict` from/with
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了测试`matches`，我们必须定义一个非抽象类，其中包含`to_data_dict`的具体实现，以及一些实际属性来生成该`dict`。
- en: That derived class, unless it also happens to be an actual class needed in the
    system, has no relevance in the final system's code, so tests there do not assure
    us that other derived classes won't have issues in `matches`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非该派生类也恰好是系统中需要的实际类，否则它在最终系统代码中没有相关性，因此在那里的测试不能保证其他派生类在`matches`中不会出现问题
- en: Even setting the testing of the `matches` method completely aside, testing `save` is
    similarly pointless, for much the same reason  it's a concrete method that depends
    on methods that are, at the `BaseDataObject` level, abstract and undefined
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使完全放置`matches`方法的测试，测试`save`也同样毫无意义，原因是它是一个依赖于在`BaseDataObject`级别上是抽象和未定义的方法的具体方法
- en: 'Back when `BaseArtisan` was being implemented, we defined its `add_product` and `remove_product` methods
    as abstract, but still wrote usable concrete implementation code in both, in order
    to allow derived classes to simply call the parent''s implementation. In effect,
    we required an implementation of both in all derived classes, but provided an
    implementation that could be called from within the derived class methods. The
    same sort of approach, applied to the  `matches` and `save` methods in `BaseDataObject`,
    would essentially enforce testing requirements on each derived concrete class,
    while still permitting the use of a single implementation until or unless a need
    arose to override that implementation. It might feel a bit hacky, but there don''t
    appear to be any downsides to that approach:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现`BaseArtisan`时，我们定义了它的`add_product`和`remove_product`方法为抽象，但仍然在两者中编写了可用的具体实现代码，以便允许派生类简单地调用父类的实现。实际上，我们要求所有派生类都实现这两个方法，但提供了一个可以从派生类方法内部调用的实现。同样的方法应用到`BaseDataObject`中的`matches`和`save`方法，基本上会强制每个派生具体类的测试要求，同时允许在需要覆盖该实现之前或除非需要覆盖该实现之前使用单一实现。这可能感觉有点狡猾，但这种方法似乎没有任何不利之处：
- en: The methods processed in this fashion still have to be implemented in the derived
    classes.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以这种方式处理的方法仍然必须在派生类中实现。
- en: If they need to be overridden for whatever reason, testing policies will still
    require them to be tested.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由于某种原因需要覆盖它们，测试策略仍将要求对它们进行测试。
- en: If they are implemented as nothing more than a call to the parent class method,
    they will function and testing policy code will still recognize them as local
    to the derived class. Our testing policy says those are in need of a test method, and
    that allows test methods to execute against the specific needs and functionality
    of the derived class.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们只是作为对父类方法的调用实现，它们将起作用，并且测试策略代码仍将识别它们为派生类的本地方法。我们的测试策略表示这些方法需要一个测试方法，这允许测试方法针对派生类的特定需求和功能执行。
- en: Testing `save` doesn't have to take that approach, however. Ultimately, all
    we're really concerned with as far as that method is concerned is that we can
    prove that it calls the `_create` and `_update` abstract methods and resets the
    flags. If that proof can be tested and established in the process of testing `BaseDataObject`,
    we won't have to test it elsewhere unless the test policy code detects an override
    of the method. That would, in turn, allow us to avoid having the same test code
    scattered across all the test cases for all of the final, concrete classes later
    on, which is a good thing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试`save`不必采用这种方法。最终，就该方法而言，我们真正关心的是能够证明它调用了`_create`和`_update`抽象方法并重置了标志。如果可以在测试`BaseDataObject`的过程中测试和建立这个证明，我们就不必在其他地方进行测试，除非测试策略代码检测到该方法的覆盖。这将使我们能够避免在以后的所有最终具体类的所有测试用例中散布相同的测试代码，这是一件好事。
- en: 'Starting the unit tests for the `data_objects` module is simple enough:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开始`data_objects`模块的单元测试非常简单：
- en: Create a `test_data_object.py` file in the project's `test_hms_core` directory
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`test_hms_core`目录中创建一个`test_data_object.py`文件
- en: Perform the two name replacements noted in the header comments
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行头部注释中指出的两个名称替换
- en: Add a reference to it in `__init__.py` in that same directory
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一目录的`__init__.py`中添加对它的引用
- en: Run the test code and go through the normal iterative test writing process
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试代码并进行正常的迭代测试编写过程
- en: 'The reference to the new test module in `__init__.py` follows the structure
    that already exists in our unit test module template making a copy of the two
    lines starting with `# import child_module` in the existing code, then uncommenting
    them and changing `child_module` to the new test module:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__.py`中对新测试模块的引用遵循我们的单元测试模块模板中已经存在的结构，复制现有代码中以`# import child_module`开头的两行，然后取消注释并将`child_module`更改为新的测试模块：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That addition adds all of the tests in the new `test_data_objects` module to
    the tests already present in the top-level `__init__.py` test module, allowing
    that top-level test suite to execute the child module tests:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个添加将新的`test_data_objects`模块中的所有测试添加到顶层`__init__.py`测试模块中已经存在的测试中，从而使顶层测试套件能够执行子模块的测试：
- en: '![](assets/f9359000-284f-4821-a55a-54158255a251.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f9359000-284f-4821-a55a-54158255a251.png)'
- en: 'The tests in `test_data_objects.py` can also be executed independently, yielding
    the same failure, but without executing all of the other existing tests:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_data_objects.py`中的测试也可以独立执行，产生相同的失败，但不执行所有其他现有的测试：'
- en: '![](assets/51ea1863-b0cd-436c-8809-be5d1e9e7e1e.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51ea1863-b0cd-436c-8809-be5d1e9e7e1e.png)'
- en: 'The iterative process for writing unit tests for `data_objects.py` is no different
    than the process that was used for writing tests for the base business objects
    in the previous iteration: run the test module, find a test that''s failing, write
    or modify that test, and re-run until all tests pass. Since `BaseDataObject` is
    an abstract class, a throwaway, derived concrete class will be needed to perform
    some tests against it. With the exception of the value-oriented testing of the `oid`, `created`, and `modified` properties
    of `BaseDataObject`, we have established patterns that cover everything else:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为`data_objects.py`编写单元测试的迭代过程与在上一次迭代中为基本业务对象编写测试的过程没有区别：运行测试模块，找到失败的测试，编写或修改该测试，并重复运行直到所有测试通过。由于`BaseDataObject`是一个抽象类，需要一个一次性的派生具体类来执行一些测试。除了针对`BaseDataObject`的`oid`，`created`和`modified`属性的面向值的测试之外，我们已经建立了覆盖其他所有内容的模式：
- en: 'Iteration over good and bad value lists that are meaningful as values for the
    member being tested:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代好和坏值列表，这些值对于正在测试的成员是有意义的：
- en: (Not applicable yet) standard optional text-line values
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （尚不适用）标准可选文本行值
- en: (Not applicable yet) standard required text-line values
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （尚不适用）标准必需文本行值
- en: Boolean (and numeric-equivalent) values
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔（和数值等效）值
- en: (Not applicable yet) non-negative numeric values
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （尚不适用）非负数值
- en: Verifying property method associations – getter methods in every case so far,
    and setter and deleter methods where they are expected
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证属性方法的关联——到目前为止在每种情况下都是获取方法，以及预期的设置方法和删除方法
- en: Verifying getter methods retrieve their underlying storage attribute values
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证获取方法检索其底层存储属性值
- en: Verifying deleter methods reset their underlying storage attribute values as
    expected
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证删除方法按预期重置其底层存储属性值
- en: Verifying that setter methods enforce type checks and value checks as expected
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证设置方法是否按预期执行类型检查和值检查
- en: Verifying that initialization methods (`__init__`) call all of the deleter and
    setter methods as expected
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证初始化方法（`__init__`）按预期调用所有删除和设置方法
- en: 'Those same three properties (`oid`, `created`, and `modified`), apart from
    not having an established test pattern already defined, share another common characteristic:
    all three of them will create a value if the property is requested and doesn''t
    already have one (that is, the underlying storage attribute''s value is `None`).
    That behavior requires some additional testing beyond the normal confirmation
    that the getter reads the storage attribute that the test methods start with (using `test_get_created` to
    illustrate):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个属性（`oid`，`created`和`modified`）除了没有已定义的测试模式之外，还共享另一个共同特征：如果请求属性并且属性尚未存在值（即，底层存储属性的值为`None`），则这三个属性都将创建一个值。这种行为需要一些额外的测试，超出了测试方法开始时确认获取方法读取存储属性的正常确认（使用`test_get_created`来说明）：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Up to this point, the test method is pretty typical of a getter method test
    it sets an arbitrary value (because what''s being tested is whether the getter
    retrieves the value, nothing more), and verifies that the result is what was set.
    Next, though, we force the storage attribute''s value to None, and verify that
    the result of the getter method is an object of the appropriate type a `datetime` in
    this case:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，测试方法与获取方法的测试非常典型，它设置一个任意值（因为正在测试的是获取方法是否检索到值，而不仅仅是这个），并验证结果是否与设置的值相同。然后，我们将存储属性的值强制设置为None，并验证获取方法的结果是否是适当类型的对象——在这种情况下是`datetime`：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The test method for the property setter method (`_set_created` in this case)
    has to account for all of the different type variations that are legitimate for
    the property – `datetime`, `int`, `float`, and `str` values alike for `_set_created` –
    and set the expected value accordingly based on the input type before calling
    the method being tested and checking the results:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 属性设置方法（在这种情况下为`_set_created`）的测试方法必须考虑属性的所有不同类型变化，这些类型对于`_set_created`来说都是合法的——`datetime`，`int`，`float`和`str`值，然后根据输入类型设置预期值，然后调用被测试的方法并检查结果：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The deleter method test is structurally the same test process that we''ve implemented
    before, though:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 删除方法的测试结构上与之前实施的测试过程相同，尽管：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The exact same structure, with `created` changed to `modified`, tests the underlying
    methods of the `modified` property. A very similar structure, changing names (`created` to
    `oid`) and expected types (`datetime` to `UUID`), serves as a starting point for
    the tests of the property methods for the `oid` property.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同结构的`created`更改为`modified`，测试`modified`属性的基础方法。具有非常相似结构的`created`更改为`oid`和预期类型更改为`UUID`，作为`oid`属性的属性方法测试的起点。
- en: 'Testing `_get_oid`, then looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试`_get_oid`看起来像这样：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And testing `_set_oid` looks like this (note that the type change also has
    to account for a different expected type and value):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`_set_oid`看起来像这样（请注意，类型更改还必须考虑不同的预期类型和值）：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With all of the data object tests complete (for now), it''s a good time to
    move the class definitions that were living in the package header file (`hms_core/__init__.py`)
    into a module file just for them: `business_objects.py`. While it''s purely a
    namespace organizational concern (since none of the classes themselves are being
    changed, just where they live in the package), it''s one that makes a lot of sense,
    in the long run. With the move completed, there is a logical grouping to the classes
    that reside in the package:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 随着所有数据对象测试的完成（目前为止），现在是时候将生活在包头文件（`hms_core/__init__.py`）中的类定义移动到一个专门为它们的模块文件中：`business_objects.py`。虽然这纯粹是一个命名空间组织上的问题（因为类本身都没有被改变，只是它们在包中的位置发生了变化），但从长远来看，这是非常有意义的。移动完成后，包中的类有了逻辑分组：
- en: '![](assets/bfca67f7-3fc4-4445-be41-603b18e47305.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bfca67f7-3fc4-4445-be41-603b18e47305.png)'
- en: 'Business object definitions, and items that tie directly to those types, will
    all live in the `hms_core.business_objects` namespace, and can be imported from
    there, for example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 业务对象定义以及直接与这些类型相关的项目都将存在于`hms_core.business_objects`命名空间中，并且可以从那里导入，例如：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All members of `hms_core.business_objects` could be imported, if needed, with:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，`hms_core.business_objects`的所有成员都可以被导入：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similarly, functionality that relates to the data object structure that''s
    still in development will all live in the `hms_core.data_objects` namespace:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与仍在开发中的数据对象结构相关的功能都将存在于`hms_core.data_objects`命名空间中：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or, again, all members of the module could be imported with:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，模块的所有成员都可以通过以下方式导入：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With the basic data object structure ready and tested, it's time to start implementing
    some concrete, data persisting business objects, starting with the ones living
    in the Artisan Application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数据对象结构准备就绪并经过测试，现在是时候开始实现一些具体的、数据持久化的业务对象，首先是Artisan应用程序中的业务对象。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The implementation of `BaseDataObject` provides mechanisms for all of the common
    data access needs we identified earlier (all the CRUD operations):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDataObject`的实现提供了我们之前确定的所有常见数据访问需求的机制（所有CRUD操作）：'
- en: It allows derived data objects, once they've been instantiated, to create and
    update their state data
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许派生数据对象一旦被实例化，就可以创建和更新它们的状态数据。
- en: It provides a single mechanism that allows one or more data objects to be read
    from the data store, and as a bonus allows for some degree of object retrieval
    based on criteria other than just the `oid` of the data objects in question
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个单一的机制，允许从数据存储中读取一个或多个数据对象，并且作为一个额外的奖励，还允许根据除了数据对象的`oid`之外的标准来检索对象。
- en: It provides a single mechanism for the deletion of object data
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个用于删除对象数据的单一机制。
- en: The actual implementation of those methods is the responsibility of the data
    objects themselves, which will relate directly to the storage mechanism that each
    object type uses.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的实际实现是数据对象本身的责任，它们将直接与每种对象类型使用的存储机制相关联。
- en: The data storage for the Artisan Application, reading and writing data to local
    files on the user's machine, is, in many respects, the simpler of the two data
    storage options to implement, so we'll start with that.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Artisan应用程序的数据存储，读取和写入用户机器上的本地文件，在许多方面来说，是两种数据存储选项中较为简单的，因此我们将从这里开始。
