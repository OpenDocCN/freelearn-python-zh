- en: Managing Workflows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理工作流程
- en: In this chapter, we will bring the different processes we described in the previous
    chapters together into a general workflow so that we can make changes to a single
    microservice. We will move on from the process of getting a new feature request
    to developing it locally, reviewing it, testing it in a demo environment, and
    approving the changes and releasing them to the live cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把前几章描述的不同流程汇总到一般工作流程中，以便对单个微服务进行更改。我们将从获取新功能请求的过程转移到本地开发、审查、在演示环境中测试，并批准更改并将其发布到实时集群。
- en: This is related to the pipeline concept we introduced in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml),
    *Creating a Pipeline and Workflow*. In this chapter, however, we will talk about
    the processes of the task. The pipeline and build structures are there to ensure
    that any proposed change follows quality standards. In this chapter, we will focus
    on the teamwork aspects of the technology and how to allow smooth interaction
    while keeping track of the different changes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)中介绍的流水线概念有关，*创建流水线和工作流*。然而，在本章中，我们将讨论任务的过程。流水线和构建结构旨在确保任何提议的更改都符合质量标准。在本章中，我们将重点关注技术的团队合作方面，以及如何在跟踪不同更改的同时实现顺畅的互动。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the life cycle of a feature
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解功能的生命周期
- en: Reviewing and approving a new feature
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查和批准新功能
- en: Setting up multiple environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置多个环境
- en: Scaling the workflow and making it work
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展工作流程并使其正常运行
- en: By the end of this chapter, we will have a clear view of the different steps
    that are involved in setting up a new feature for one of our microservices, and
    how can we use multiple environments to test and ensure that the release is successful.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，我们将清楚地了解设置新功能所涉及的不同步骤，以及如何使用多个环境来测试和确保发布成功。
- en: Understanding the life cycle of a feature
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解功能的生命周期
- en: Following on from agile principles, the main objective of any team is to be
    able to implement new features quickly, without compromising the quality or stability
    of the system. The first element of change comes in the shape of a** feature request**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循敏捷原则，任何团队的主要目标是能够快速实现新功能，而不会影响系统的质量或稳定性。变化的第一个元素是**功能请求**。
- en: A feature request is a description of a change in the system in non-technical
    terms. Feature requests are normally generated by non-engineers (product owners,
    managers, and CEOs) who are looking to improve the system for business-related
    reasons, such as making a better product or increasing revenue.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 功能请求是以非技术术语描述系统变更的请求。功能请求通常由非工程师（产品所有者、经理和CEO）生成，他们希望出于业务原因改进系统，比如打造更好的产品或增加收入。
- en: Feature requests can be simple, such as *updating the logo of the company in
    the main page*, or big and complicated, such as *adding support to the new 5G
    network*. Feature requests may include bug reports. While they don't usually,
    they will for the purpose of this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 功能请求可能很简单，比如*更新公司主页的标志*，也可能很大且复杂，比如*添加对新的5G网络的支持*。功能请求可能包括错误报告。虽然通常不会，但在本章中会有。
- en: Complicated feature requests may need to be subdivided into smaller self-contained
    feature requests so that we can iterate in small increments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的功能请求可能需要分解为更小的独立功能请求，以便我们可以逐步迭代。
- en: Our focus is on the elements that need to be taken into account due to the microservices
    approaches and practices more than agile practices. Such practices deal with how
    to structure feature requests into tasks and estimations, but they are not specific
    to the underlying technologies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重点是微服务方法和实践，而不是敏捷实践。这些实践涉及如何将功能请求结构化为任务和估算，但并不特定于基础技术。
- en: Take a look at the *Further reading* section at the end of this chapter to find
    out more about agile practices and methodologies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看本章末尾的*进一步阅读*部分，以了解更多关于敏捷实践和方法论的信息。
- en: In a monolith, we have all the elements under the same code base. So, no matter
    how complicated a particular feature request is, only one system will be affected.
    There is only a single system in a monolith. However, this isn't the case once
    we migrate to microservices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，所有元素都在同一个代码库下。因此，无论特定功能请求有多复杂，只会影响一个系统。在单体架构中只有一个系统。然而，一旦我们迁移到微服务，情况就不同了。
- en: In a microservice architecture, we need to analyze any incoming feature request
    in terms of what microservice or microservices it affects. If we design our microservices properly,
    most of the requests will only affect a single microservice. However, eventually,
    some of the feature requests will be too big to fit neatly into a single microservice
    and will need to be divided into two or more steps, each changing a different
    microservice.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，我们需要分析任何新功能请求涉及的微服务。如果我们正确设计了微服务，大多数请求只会影响单个微服务。然而，最终，一些功能请求将太大，无法完全适应单个微服务，需要分成两个或更多步骤，每个步骤都改变不同的微服务。
- en: For example, if we have a new feature request that allows us to mention a user in the
    text of a thought (similar to how a mention works on Twitter), then this mention will
    have to be stored in the Thoughts Backend and be displayed in the Frontend. This
    feature affects two microservices: the Frontend and the Thoughts Backend.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个新的功能请求，允许我们在一条*想法*的文本中提及用户（类似于Twitter上的提及方式），那么这个提及将需要存储在Thoughts后端，并在前端显示。这个功能影响了两个微服务：前端和Thoughts后端。
- en: In this section, we are referring to concepts that we introduced in the previous
    chapters and are joining them together from a global point of view.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们引用了前几章介绍的概念，并从全局角度将它们结合起来。
- en: In the next subsection, we will look at the features that affect multiple microservices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将看看影响多个微服务的特性。
- en: Features that affect multiple microservices
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影响多个微服务的特性
- en: For a multiple microservice feature request, you need to divide the feature
    into several technical features, with each one affecting a single microservice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个微服务的特性请求，您需要将特性分成几个技术特性，每个特性影响一个单独的微服务。
- en: Each technical feature should cover an aspect that's relevant to the microservice
    it affects. If each microservice has a clear purpose and objective, the feature
    will be completed and generalized so that it can be used for later requests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个技术特性应涵盖与其影响的微服务相关的方面。如果每个微服务都有明确的目的和目标，那么特性将被完成和概括，以便以后的请求可以使用。
- en: The basis for a successful microservice architecture is to have loosely coupled
    services. Ensuring that the API of each microservice makes sense on its own is
    important if we wish to avoid blurring the lines between services. Not doing so
    may mean that independent work and deployments aren't allowed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的微服务架构的基础是有松散耦合的服务。确保每个微服务的API本身是有意义的，这一点很重要，如果我们希望避免模糊服务之间的界限。不这样做可能意味着独立的工作和部署是不被允许的。
- en: The dependencies between the requests and microservices should also be considered
    so that the work can be arranged back to front. This means preparing the new feature
    that will add extra data or capabilities but keeping the old behavior by default.
    After doing this, a new feature that uses this extra data can be deployed. This
    way of working ensures backward compatibility at any given time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还应考虑请求和微服务之间的依赖关系，以便工作可以从后往前安排。这意味着准备添加额外数据或功能的新特性，但默认情况下保留旧行为。在这样做之后，可以部署使用这些额外数据的新特性。这种工作方式确保了任何给定时间的向后兼容性。
- en: We will look at the features that affect multiple microservices in more detail
    in [Chapter 11](06d0c451-77f1-4e4a-8d38-3abf112f79fa.xhtml), *Handling Change,
    Dependencies, and Secrets in the System*. We'll also learn how to coordinate work
    and dependencies in more detail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](06d0c451-77f1-4e4a-8d38-3abf112f79fa.xhtml)中更详细地查看影响多个微服务的特性，*处理系统中的变更、依赖和秘密*。我们还将学习如何更详细地协调工作和依赖关系。
- en: Going back to our previous example, to add a user's mention to their thoughts,
    we need to make the Thoughts Backend capable of dealing with optional references
    to users. This is a self-contained task that won't affect the existing functionality.
    It can be deployed and tested.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的例子，要将用户的提及添加到他们的想法中，我们需要使Thoughts Backend能够处理对用户的可选引用。这是一个独立的任务，不会影响现有的功能。它可以被部署和测试。
- en: Then, we can make the corresponding changes in the Frontend to allow external
    users to interact with it through an HTML interface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在前端进行相应的更改，以允许外部用户通过HTML界面与其进行交互。
- en: As we discussed in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml),
    *Making the Move – Design, Plan, and Execute*, it is crucial for any microservice
    architecture that we can deploy services independently. This allows us to test
    services independently and avoid any overhead that requires complicated deployments
    that make it difficult for us to debug and roll back if errors occur.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中讨论的，*迁移-设计、计划和执行*，对于任何微服务架构来说，独立部署服务是至关重要的。这使我们能够独立测试服务，并避免任何需要复杂部署的开销，这使得我们难以调试和回滚错误。
- en: If different teams work independently on different microservices, then they
    will also require coordination.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不同的团队独立地在不同的微服务上工作，那么它们也将需要协调。
- en: In the next section, we will learn how to implement a feature in a single microservice.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在单个微服务中实施特性。
- en: Implementing a feature
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施特性
- en: Once we have the definition of an independent technical feature, it can be implemented.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了独立技术特性的定义，就可以实施它。
- en: Defining a technical feature in a clear manner can be challenging. Remember
    that a single feature may need to be further subdivided into smaller tasks. However,
    as we mentioned previously, the objective here is not to structure our tasks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰地定义技术特性可能是具有挑战性的。请记住，一个特性可能需要进一步细分为更小的任务。然而，正如我们之前提到的，这里的目标不是构建我们的任务结构。
- en: Start your task by creating a new Git branch. The code can be changed to reflect
    the new feature in this branch. As we saw in [Chapter 2](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml), *Creating
    a REST Service with Python*, and [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml),
    *Build, Run, and Test Your Service Using Docker*, unit tests can be run to ensure
    that this work isn't breaking the build.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个新的Git分支来开始您的任务。代码可以被更改以反映这个分支中的新特性。正如我们在[第2章](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml)和[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)中所看到的，*使用Python创建REST服务*和*使用Docker构建、运行和测试您的服务*，可以运行单元测试来确保这项工作不会破坏构建。
- en: As we described in [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml), *Build,
    Run, and Test Your Service Using Docker*, in the *Operating with an immutable
    container* section, we can use `pytest` arguments to run subsets of tests to speed
    up development, thereby enabling quick feedback when running tests. Make sure
    you use it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)中所描述的，*使用Docker构建、运行和测试您的服务*，在*使用不可变容器进行操作*部分，我们可以使用`pytest`参数来运行测试的子集，以加快开发速度，从而在运行测试时获得快速反馈。确保您使用它。
- en: How this functionality works in relation to the whole system can be checked
    through the deployment of the local cluster. This starts other microservices that
    may be affected by the work in this branch, but it helps ensure that the current
    work is not breaking any existing calls that affect other microservices.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在整个系统中的工作方式可以通过部署本地集群来检查。这会启动其他可能受到这个分支工作影响的微服务，但它有助于确保当前的工作不会破坏影响其他微服务的现有调用。
- en: Based on the pipeline, any commit that's pushed to Git will run all its tests.
    This will detect problems early and ensure that the build is correct before it's
    merged with the main branch.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据流水线，推送到Git的任何提交都将运行所有测试。 这将及早发现问题，并确保在与主分支合并之前构建正确。
- en: While this is in progress, we can use a pull request to review the changes between
    the main branch and the new features. We can check our GitHub configuration to
    ensure that the code is in good shape before we merge it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们可以使用拉取请求来审查主分支和新功能之间的更改。 我们可以检查我们的GitHub配置，以确保代码在合并之前处于良好状态。
- en: Once the feature is ready and has been merged with the main branch, a new tag
    should be created to allow for its deployment. As part of the configured pipeline,
    this tag will trigger a build that produces an image in the registry and label
    the image with the same tag. The tag and image are immutable, so we can be sure
    that the code won't change between the different environments. You can roll forward
    and back with confidence that the code will be the exact same code that was defined
    in the tag.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦功能准备就绪并已与主分支合并，应创建一个新标签以允许其部署。 作为配置的一部分，此标签将触发生成注册表中的图像的构建，并使用相同的标签标记图像。 标签和图像是不可变的，因此我们可以确保代码在不同环境之间不会更改。
    您可以放心地前进和后退，确保代码与标签中定义的完全相同的代码。
- en: As we saw in [Chapter 8](9a5c53a2-9131-4233-9e4f-992af51d8321.xhtml), *Using
    GitOps Principles*, the tag can be deployed by following GitOps principles. The
    deployment is described in Kubernetes configuration files, under Git control,
    and is reviewed in a pull request that needs to be approved. Once the pull request
    has been merged with the main branch, it will be deployed by Flux automatically,
    as we described in [Chapter 8](9a5c53a2-9131-4233-9e4f-992af51d8321.xhtml), *Using
    GitOps Principles*, in the *Setting up Flux to control the Kubernetes cluster*
    section. At that time, the feature is available in the cluster.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第8章](9a5c53a2-9131-4233-9e4f-992af51d8321.xhtml)中看到的，*使用GitOps原则*，可以通过遵循GitOps原则部署标签。
    部署在Kubernetes配置文件中，受Git控制，并在需要获得批准的拉取请求中进行审查。 一旦拉取请求已与主分支合并，Flux将自动部署，正如我们在[第8章](9a5c53a2-9131-4233-9e4f-992af51d8321.xhtml)中描述的那样，在*设置Flux控制Kubernetes集群*部分。
    此时，功能在集群中可用。
- en: 'Let''s recap on this life cycle, from the description of the technical request
    to when it''s deployed into a cluster:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个生命周期，从技术请求的描述到部署到集群为止：
- en: This is a more complete version of the Flow that we introduced in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating
    a Pipeline and Workflow*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)中介绍的流程的更完整版本。
- en: The technical request is ready to be implemented into a single microservice.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 技术请求已准备好实施到单个微服务中。
- en: A new feature branch is created.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的功能分支。
- en: The microservice's code is changed in this branch until the feature is ready.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此分支中更改微服务的代码，直到功能准备就绪。
- en: A pull request, which is used to merge the feature branch into the main branch,
    is created. This, as described in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating
    a Pipeline and Workflow*, in the *Understanding the continuous integration practices*
    section, runs the CI process to ensure that it is of a high quality.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个拉取请求，用于将功能分支合并到主分支中。 正如我们在[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)中描述的那样，在*理解持续集成实践*部分，运行CI流程以确保其质量。
- en: The pull request is reviewed, approved, and merged into the main branch.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取请求已经审查，批准并合并到主分支。
- en: A new tag is created.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个新标签。
- en: A deployment branch is created in the GitOps repository that changes the version
    of the microservice to the new tag.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitOps存储库中创建一个部署分支，将微服务的版本更改为新标签。
- en: A pull request, which is used to merge this deployment branch, is created. Then,
    it's reviewed and merged.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于合并此部署分支的拉取请求。 然后进行审查和合并。
- en: Once the code has been merged, the cluster automatically releases the new version
    of the microservice.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦代码已合并，集群将自动发布微服务的新版本。
- en: Finally, the new feature is available in the cluster!
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，新功能在集群中可用！
- en: This is a simplified version of the life cycle; in reality, it may be more complicated.
    Later in this chapter, we will look at a situation where the life cycle needs
    to be deployed to more than one cluster.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生命周期的简化版本； 实际上，可能更复杂。 在本章后面，我们将看到需要将生命周期部署到多个集群的情况。
- en: In the next section, we will look at some recommendations when it comes to reviewing
    and approving pull requests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看一些关于审查和批准拉取请求的建议。
- en: Reviewing and approving a new feature
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查和批准新功能
- en: As specified by the pipeline model we described in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating
    a Pipeline and Workflow*, the candidate code moves through a series of stages,
    stopping if there's a problem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)中描述的流水线模型，候选代码通过一系列阶段，如果出现问题就停止。
- en: As we mentioned previously, reviewing using GitHub pull requests works if we
    wish to introduce new features to the code of our microservices, as well as if
    we wish to deploy those changes into clusters through GitOps practices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用GitHub拉取请求进行审查适用于我们希望向微服务代码引入新功能，以及希望通过GitOps实践将这些更改部署到集群中。
- en: 'In both cases, we can check this automatically through automated tests and
    processes. However, there''s a final step that requires manual intervention: knowledge
    transfer and an extra pair of eyes. Once the reviewer thinks the new feature is
    ready, they can approve it.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们可以通过自动化测试和流程自动检查。 但是，还有最后一步需要手动干预：知识转移和额外的眼睛。 一旦审阅者认为新功能已准备就绪，他们可以批准它。
- en: The tools are the same, although the reviewing process works a little differently.
    This is because the objectives aren't the same. For feature code, the review is
    more open to discussion until it's approved and merged into the main branch. On
    the other hand, reviewing and approving a release is typically more straightforward
    and faster.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 工具是一样的，尽管审查过程有些不同。这是因为目标不同。对于功能代码，审查更加开放，直到获得批准并合并到主分支。另一方面，审查和批准发布通常更加直接和快速。
- en: Let's start by learning how to review feature code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习如何审查功能代码开始。
- en: Reviewing feature code
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查功能代码
- en: Code reviews can be initiated while the feature is being developed and a request
    has been opened to merge it. As we've already seen, in GitHub, code can be reviewed
    while it's in the **pull request** stage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查可以在开发功能并打开合并请求时启动。正如我们已经看到的，在GitHub中，代码可以在**拉取请求**阶段进行审查。
- en: A code review is basically a shaped discussion about the code and the new feature;
    that is, we're checking the code before it is introduced to the main branch. This
    presents us with the opportunity to improve the feature while it is in development,
    and before it becomes a component of the system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查基本上是关于代码和新功能的讨论；也就是说，在将代码引入主分支之前，我们会对代码进行检查。这为我们提供了在开发过程中改进功能的机会，以及在其成为系统组件之前进行改进。
- en: Here, a member of the team may read the code that hasn't been merged and give
    the author some feedback. This can go back and forth until the reviewer thinks
    that the code is ready to be merged and approves it. In essence, someone else,
    other than the author of the feature, needs to agree that the new code meets the
    required standards.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，团队的成员可以阅读尚未合并的代码，并给作者一些反馈。这可能来回进行，直到审阅者认为代码已经准备好合并并批准它。实质上，除了功能的作者之外，其他人需要同意新代码符合所需的标准。
- en: Code bases grow over time and their components can help each other out. Merging
    code into the main branch states that you fully accept that the new code will
    be maintained by the team as part of the code base.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库随着时间的推移而增长，它们的组件可以相互帮助。将代码合并到主分支表示您完全接受新代码将作为代码库的一部分由团队维护。
- en: The code may need to be approved by one or more people, or by specific people.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能需要得到一个或多个人的批准，或者特定人员的批准。
- en: In GitHub, you can enable code owners. These are engineers who are responsible
    for approving repositories, or parts of repositories. Check out the GitHub documentation
    for more information: [https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub中，你可以启用代码所有者。这些是负责批准存储库或存储库部分的工程师。查看GitHub文档以获取更多信息：[https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners)。
- en: Code reviewing is a quite common process these days, and the popularity and
    ease of using pull requests in GitHub has spread. Most developers are familiar
    with this process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查是一个非常常见的过程，而在GitHub中使用拉取请求的流行度和便利性已经传播开来。大多数开发人员都熟悉这个过程。
- en: Implementing a good feedback culture is more difficult than it looks, though.
    Writing code is a deeply personal experience; no two people will write the same
    code. For developers, having your code criticized by others can be a difficult
    experience unless there are clear rules.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实施良好的反馈文化比看起来更加困难。编写代码是一种深层次的个人体验；没有两个人会写出相同的代码。对开发人员来说，让他人批评自己的代码可能是一种困难的经历，除非有明确的规则。
- en: 'Here are some suggestions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些建议：
- en: 'Tell your reviewers what they should look for. Make a point of following a
    checklist. This helps develop a culture within the team so that they care about
    shared core values. This also helps junior developers know what to look for. This
    may change from team to team, but here are some examples:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉你的审阅者他们应该寻找什么。坚持使用检查表。这有助于在团队内部培养关心共享核心价值观的文化。这也有助于初级开发人员知道要寻找什么。这可能会因团队而异，但以下是一些示例：
- en: There are new tests.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有新的测试。
- en: Error conditions are tested.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误条件要经过测试。
- en: The documentation is properly updated.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档要得到适当的更新。
- en: Any new endpoints comply with standards.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何新的端点都要符合标准。
- en: Architectural diagrams are updated.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构图已更新。
- en: Reviewing code is not the same thing as writing the code. There will always
    be discrepancies (for example, this variable name could be changed), but what
    needs to be reviewed is whether such changes need to be implemented. Nitpicking
    will erode the trust between team members.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查代码并不等同于编写代码。总会有差异（例如，这个变量名可以更改），但需要审查的是是否需要实施这样的更改。挑剔将会侵蚀团队成员之间的信任。
- en: The bigger the code to review, the more difficult it is to do. It's better to
    work in small increments, which works well with the principles of continuous integration.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要审查的代码越大，就越难以完成。最好是以小的增量工作，这与持续集成的原则相符。
- en: All of the code should be reviewed on equal grounds. This includes the code
    of senior developers, and junior developers should be encouraged to leave honest
    feedback. This helps ownership of the code and its fairness to grow.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的代码都应该在同等的基础上进行审查。这包括高级开发人员的代码，应鼓励初级开发人员留下诚实的反馈。这有助于代码的所有权和公平性增长。
- en: A code review is a conversation. A comment doesn't necessarily mean that the
    reviewer's feedback has to be implemented without you questioning it first. It
    opens a conversation about improving the code, and making clarifications and pushing
    back is totally fine. Sometimes, the proper way of handling a request, that is,
    to change a part of the code, is to leave a comment explaining why this was done
    in a particular way.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查是一种对话。评论并不一定意味着审阅者的反馈必须在你质疑之前立即实施。它开启了关于改进代码的对话，进行澄清和反驳是完全可以的。有时，处理请求的正确方式，也就是更改代码的一部分，是留下一条评论解释为什么以这种方式进行。
- en: 'Reviews help spread knowledge about the code base. This isn''t a silver bullet,
    though. Code reviews tend to fall into tunnel vision, where only small issues
    such as typos, and local snippets of code, are looked at, and not the bigger elements.
    This is why it''s important to implement features in small increments: to help
    those around you digest change.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查有助于传播关于代码库的知识。然而，这并不是万能的。代码审查往往会陷入隧道视野，只关注诸如拼写错误和局部代码片段等小问题，而不关注更大的元素。这就是为什么以小的增量实现功能很重要的原因：以帮助周围的人消化变化。
- en: It's important to leave appreciative comments. Create a culture that appreciates
    well-written code. Only highlighting what's bad makes the review process miserable
    for the author.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 留下赞赏的评论很重要。营造一个欣赏写得好的代码的文化。只强调问题会让作者对审查过程感到痛苦。
- en: Criticism should be addressed to the code, not to the coder. Ensure that your
    review is civil. In this step, we want to ensure that the code is of a high quality;
    you don't want to make yourself, as the reviewer, look superior.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批评应该针对代码，而不是针对编码人员。确保您的审查是文明的。在这一步中，我们要确保代码质量高；作为审查人，您不希望让自己显得更优越。
- en: Code reviews can be stressful for those who aren't used to them. Some companies
    are creating principles and ideas to make this process less painful. A good example
    can be found at [https://www.recurse.com/social-rules](https://www.recurse.com/social-rules).
    Don't be afraid to define and share your own principles.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不习惯代码审查的人来说，代码审查可能会带来压力。一些公司正在制定原则和想法，以减轻这一过程的痛苦。一个很好的例子可以在[https://www.recurse.com/social-rules](https://www.recurse.com/social-rules)找到。不要害怕制定并分享您自己的原则。
- en: It's important that code can be approved at all times, even when someone in
    the team is on holiday or sick. Ensure that you grant approval to multiple members
    of the team so that the approval process itself isn't a bottleneck.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是，代码可以随时获得批准，即使团队中的某人正在度假或生病。确保您授予团队多名成员批准，以便批准过程本身不成为瓶颈。
- en: When you start producing code reviews, ensure that the team leaders keep these
    considerations in mind and emphasize why all the code is reviewed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始进行代码审查时，请确保团队领导牢记这些考虑，并强调为什么所有代码都要经过审查。
- en: It is worth emphasizing how code reviews are not a technological solution, but
    a people-related one. As such, they can suffer from people-related problems such
    as big egos, adversarial discussions, or non-productive debates.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 强调代码审查并不是技术解决方案，而是与人相关的解决方案。因此，它们可能会受到与人相关的问题的影响，比如自负、对立的讨论或无效的辩论。
- en: The microservice architecture is fit for big systems that have multiple people
    working on them. Teamwork is crucial. Part of that is ensuring that the code doesn't
    belong to a single person, but to a whole team. Code reviews are a great tool
    to that end, but be sure to actively look for healthy ones.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构适用于有多人共同开发的大型系统。团队合作至关重要。其中一部分是确保代码不属于单个人，而是整个团队的。代码审查是实现这一目标的好工具，但一定要积极寻找健康的审查。
- en: Over time, a consensus will develop and a lot of code will be developed consistently.
    In a healthy team, the amount of time that's spent on reviews should reduce.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，将形成共识，并且会一致地开发大量代码。在一个健康的团队中，花在审查上的时间应该减少。
- en: Over time, the team will perform code reviews routinely, but setting these foundations
    may be complicated in the beginning. Ensure that you allow time to introduce them.
    As we mentioned previously, once the feature is ready, we need to go ahead and
    approve it. Approving code for a new feature and merging it into the main branch
    is the final stage of the feature review, but it still needs to be released. Releases
    are under code control, and they need to be reviewed as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，团队将定期进行代码审查，但在开始阶段建立这些基础可能会很复杂。确保您留出时间来介绍它们。正如我们之前提到的，一旦功能准备就绪，我们需要继续批准它。批准新功能的代码并将其合并到主分支是功能审查的最后阶段，但仍然需要发布。发布受代码控制，也需要进行审查。
- en: Approving releases
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批准发布
- en: Using GitOps principles allows us to enable the same review and approval methods
    so that we can make changes in the Kubernetes infrastructure. As we mentioned
    previously, the fact that the infrastructure is defined by YAML files in Kubernetes
    allows us to control these changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitOps原则使我们能够启用相同的审查和批准方法，以便我们可以对Kubernetes基础架构进行更改。正如我们之前提到的，基础架构是由Kubernetes中的YAML文件定义的，这使我们能够控制这些更改。
- en: Any change that's made over a Kubernetes cluster can be subjected to a pull
    request and review method. This makes approving a release to a cluster an easy
    process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对Kubernetes集群进行的任何更改都可以经过拉取请求和审查方法。这使得批准将发布到集群变得简单。
- en: This helps in minimizing problems, since more members of the team are involved
    in the changes and the knowledge that they have of the infrastructure is better.
    This works well with the DevOps principles of allowing teams to take control over
    their own deployment and infrastructure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于最小化问题，因为团队的成员参与了更改，并且他们对基础架构的了解更加深入。这与DevOps原则很好地契合，允许团队掌控自己的部署和基础架构。
- en: However, infrastructure changes in GitOps tend to be easier to review than regular
    code reviews. In general terms, they are done in very small increments, and most
    changes will be so straightforward that the probability of generating debate is
    minimal.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，GitOps中的基础架构更改往往比常规代码审查更容易审查。一般来说，它们是以非常小的增量进行的，大多数更改都是如此直截了当，几乎不会引发辩论的可能性很小。
- en: As a general rule, try to make any infrastructure change as small as possible.
    Infrastructure changes are riskier as errors may bring down important parts of
    it. The smaller the change, the smaller the risk and the easier it is to diagnose
    any issues.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一般原则是，尽量使基础架构更改尽可能小。基础架构更改存在风险，因为错误可能导致其中的重要部分崩溃。更改越小，风险越小，诊断任何问题也就越容易。
- en: All the suggestions we made about code reviews have a role to play, too. The
    most important one is to include some guidelines that reference critical parts
    of the infrastructure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的关于代码审查的所有建议也都有一定作用。其中最重要的一个是包括一些参考基础设施关键部分的指南。
- en: Some sections of the infrastructure may be under the GitHub code owner's protection.
    This makes it mandatory for certain engineers to approve changes to critical parts
    of the infrastructure. Take a look at the documentation for more information: [https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施的某些部分可能受到GitHub代码所有者的保护。这使得某些工程师必须批准对基础设施关键部分的更改。查看更多信息，请参阅文档：[https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners)。
- en: Since the infrastructure is defined as code stored in GitHub, this also makes
    it easy to copy the infrastructure, thereby greatly simplifying the generation
    of multiple environments.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基础设施被定义为存储在GitHub中的代码，这也使得复制基础设施变得容易，从而极大地简化了生成多个环境的过程。
- en: Setting up multiple environments
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置多个环境
- en: The ease of creating, copying, and removing namespaces under Kubernetes greatly
    reduces the previous burden of keeping multiple copies of environments to replicate
    the underlying infrastructure. You can use this to your advantage.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes下创建、复制和删除命名空间的便利大大减轻了以前保持多个环境副本以复制基础设施的负担。您可以利用这一点。
- en: Based on the GitOps principles we mentioned earlier, we can define new namespaces
    to generate a new cluster. We can either use another branch (for example, use
    the `master` branch for the production cluster and `demo` for the demo cluster)
    or copy the files containing the cluster definition and change the namespaces.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前提到的GitOps原则，我们可以定义新的命名空间来生成新的集群。我们可以使用另一个分支（例如，使用`master`分支用于生产集群，`demo`用于演示集群），或者复制包含集群定义的文件并更改命名空间。
- en: You can use different physical Kubernetes clusters for different purposes. It's
    better to leave the production cluster as not being shared with any other environment
    to reduce risks. However, every other environment could live in the same cluster,
    which won't affect external customers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为不同的目的使用不同的物理Kubernetes集群。最好将生产集群保持独立，不与任何其他环境共享，以减少风险。然而，其他每个环境可以存在于同一个集群中，这不会影响外部客户。
- en: 'Some feature requests are evidence enough that the development team will know
    exactly what to do, such as with bug reports. However, others may require a bit
    more of testing and communication while they''re in development to ensure that
    they fulfill a requirement. This may be the case when we''re checking that a new
    feature is actually useful to the intended external user, or could be a more explorative
    feature. In this case, we need to call an external party, that is, the ultimate
    approver of the feature: the *stakeholder*.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一些功能请求足以证明开发团队将确切知道该做什么，比如在处理错误报告时。然而，其他可能需要更多的测试和沟通，以确保它们在开发过程中满足要求。当我们检查新功能是否确实对预期的外部用户有用时，或者可能是更具探索性的功能时，就可能出现这种情况。在这种情况下，我们需要联系外部方，也就是功能的最终批准者：*利益相关者*。
- en: A stakeholder is a term from project management that specifies a third party,
    that is, the final user of a product or a user who's impacted by it. Here, we
    use the term to specify someone who's interested in a feature but external to
    the team, so they can't define the feature requirements from within. A stakeholder
    can be, for example, a manager, a customer, the CEO of the company, or a user
    of an internal tool.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 利益相关者是项目管理中的一个术语，指定了第三方，也就是产品的最终用户或受其影响的用户。在这里，我们使用这个术语来指定对功能感兴趣但不属于团队外部的人，因此他们无法从内部定义功能要求。利益相关者可以是例如经理、客户、公司的CEO或内部工具的用户。
- en: Any developer who has had to deal with a fuzzily defined request from a stakeholder,
    such as *allow search by name*, has had to tweak it: *no, not by the first name,
    by surname*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾经不得不处理模糊定义的利益相关者请求的开发人员，比如*允许按名称搜索*，都不得不对其进行微调：*不是按名字，而是按姓氏*。
- en: Ensure that you define a proper end to these kinds of tasks. Stakeholder feedback
    can be endless if it's allowed to run without limits. Define what is and is not
    included in it, as well as any deadlines, beforehand.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您为这类任务定义适当的结束。如果允许其无限制地运行，利益相关者的反馈可能是无穷无尽的。事先定义其中包含和不包含的内容，以及任何截止日期。
- en: To run tests and to ensure that the feature that's under development is going
    in the right direction, you can create one or more demo environments where you
    will deploy work in progress before it is merged into the main branch. This will
    help us share this work with stakeholders so that they can give us feedback before
    the feature is completed, without us having to release it in a production environment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行测试并确保正在开发的功能朝着正确的方向发展，您可以创建一个或多个演示环境，在这些环境中，您将部署尚未合并到主分支中的工作。这将帮助我们与利益相关者分享这项工作，以便他们在功能完成之前向我们提供反馈，而无需我们在生产环境中发布它。
- en: As we saw in the previous chapters, generating a new environment in Kubernetes
    is easy. We need to create a new namespace and then replicate the production definition
    of the cluster, thereby changing the namespace. This will create a copy of the
    environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中看到的，在Kubernetes中生成新环境很容易。我们需要创建一个新的命名空间，然后复制集群的生产定义，同时更改命名空间。这将创建一个环境的副本。
- en: Changing the specific version of the microservice under development will allow
    us to create a working version of it. Newer versions can be deployed as usual
    in this demo environment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更改正在开发的微服务的特定版本将允许我们创建其工作版本。新版本可以像往常一样部署在这个演示环境中。
- en: This is a simplified version. You may need to make changes between the production
    environment and demo environments, such as the number of replicas, and database
    setup. In such cases, a *template environment* could be used as a reference so
    that it's ready to be copied.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化版本。您可能需要在生产环境和演示环境之间进行更改，例如副本数量和数据库设置。在这种情况下，可以使用*模板环境*作为参考，以便随时可以复制。
- en: Other environments, such as staging, can be created in a similar fashion, with
    the aim of creating tests that ensure that the code that's been deployed into
    production will work as expected. These tests can be automatic, but they can also
    be manual if we want to check that the user experience is adequate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其他环境，如暂存，可以以类似的方式创建，旨在创建确保已部署到生产环境的代码将按预期工作的测试。这些测试可以是自动的，但如果我们想要检查用户体验是否合适，也可以是手动的。
- en: A staging environment is a setup that works as a replica that's as faithful
    as possible to the production environment, which means we can run tests to provide
    assurance that the deployment in production will work. Staging normally helps
    us verify that the deployment process will be correct, as well as any final tests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 暂存环境是一个尽可能忠实于生产环境的副本设置，这意味着我们可以运行测试，以确保在生产环境中部署将正常工作。暂存通常帮助我们验证部署过程是否正确，以及任何最终测试。
- en: Staging environments are typically very expensive to run. After all, they are
    a copy of a production environment. With Kubernetes, you can replicate the production
    environment easily and reduce the required physical infrastructure. You can even
    start and stop it when it is not in use to reduce costs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 暂存环境通常非常昂贵。毕竟，它们是生产环境的副本。使用Kubernetes，您可以轻松复制生产环境并减少所需的物理基础设施。甚至可以在不使用时启动和停止它以减少成本。
- en: You can use multiple environments to create a cascading structure of deployment
    in a similar fashion. This means that a tag needs to be deployed into the staging
    environment and be approved before it goes into the production environment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用多个环境以类似的方式创建部署的级联结构。这意味着需要将标签部署到暂存环境并获得批准，然后才能部署到生产环境。
- en: Let's now look at how we can deal with this structure from the point of view
    of the developers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从开发人员的角度来看如何处理这个结构。
- en: Scaling the workflow and making it work
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展工作流并使其正常工作
- en: Some of the challenges of implementing this way of working include creating
    a culture that provides an adequate feedback loop and checking new code carefully
    while reviewing it quickly. Waiting for a review is a blocked state that stops
    the developer from implementing the feature that's being reviewed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这种工作方式的一些挑战包括创建提供充分反馈循环的文化，并在快速审查新代码时仔细检查它。等待审查是一种阻塞状态，会阻止开发人员实施正在审查的功能。
- en: While this waiting time can be used for other purposes, not being able to progress
    will quickly lower productivity. Either the developer will keep a few features
    in parallel, which is highly problematic from the context switch perspective,
    or they need to wait and roll their thumbs until the review is completed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段等待时间可以用于其他目的，但无法取得进展会迅速降低生产率。开发人员要么会同时保留几个功能，这在上下文切换的角度来看是非常有问题的，要么他们需要等待并无所事事，直到审查完成。
- en: The context switch is probably the most serious killer of productivity. One
    of the keys to keeping your team's productivity high is being able to start and
    finish a task. If the task is small enough, it will be finished quickly, so swapping
    between projects is easier. However, working on two or more tasks at the same
    time is a very bad practice.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换可能是生产力的最严重杀手。保持团队的生产力高的关键之一是能够开始并完成任务。如果任务足够小，它将很快完成，因此在项目之间切换更容易。然而，同时处理两个或更多任务是非常不好的做法。
- en: If this happens often, try to divide your tasks into smaller chunks.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这经常发生，请尝试将任务分解为较小的块。
- en: To be able to balance thoroughly reviewing the code and reducing the blocking
    time, there are some elements to keep in mind.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够彻底审查代码并减少阻塞时间，有一些要点需要牢记。
- en: Reviewing and approving is done by the whole team
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查和批准由整个团队完成
- en: There need to be sufficient reviewers available at all times. If just the developers
    are experienced, reviews may end up only being done by the single most senior
    person on the team, for example, the team lead. Though this person may be the
    better reviewer in principle, in the long run, this structure will compromise
    the team as the reviewer won't be able to do anything else. Making progress in
    the development and release stages will also be blocked if the reviewer is unavailable
    for any reason, such as due to illness or if they're on holiday.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 必须随时有足够的审阅者可用。如果只有开发人员有经验，审查可能最终只由团队中最资深的人员完成，例如团队负责人。尽管这个人原则上可能是更好的审阅者，但从长远来看，这种结构将损害团队，因为审阅者将无法做其他事情。如果审阅者因病或度假等原因不可用，开发和发布阶段的进展也将受阻。
- en: Instead, make the whole team capable of reviewing their peer's code. Even though
    a senior contributor takes a more proactive role in teaching the rest of the team
    on how to review, after a while, most reviews shouldn't require their assistance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使整个团队都能够审查其同行的代码。即使资深贡献者在教导团队其他成员如何审查方面扮演更积极的角色，但一段时间后，大多数审查不应需要他们的帮助。
- en: Initially, though implementing this process requires active mentoring, this
    will typically be lead by the senior members of the team. Reviewing code is a
    trainable ability with the objective that, after a period of time, everyone is
    capable of running a review and allowed to approve pull requests.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最初实施这个流程需要积极的指导，但这通常由团队的资深成员来领导。审查代码是一种可培训的能力，其目标是在一段时间后，每个人都能够进行审查并获准批准拉取请求。
- en: The same process is followed for deployment pull requests. Eventually, everyone
    in the team, or at least a significant number of members, should be able to deploy
    a release. The initial main reviewer could be someone different, though.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 部署拉取请求也遵循相同的流程。最终，团队中的每个人，或者至少是相当数量的成员，都应该能够部署一个发布。不过，最初的主要审阅者可能会是不同的人。
- en: It is likely that the best candidate to review a release is an expert on how
    the Kubernetes infrastructure is configured, but not an expert on microservice
    code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最适合审查发布的候选人可能是对Kubernetes基础设施配置非常了解，但对微服务代码不是专家。
- en: Understanding that not every approval is the same
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并不是每个批准都是一样的
- en: Remember that the different stages of a feature are not equally critical. The
    code review's early process is about ensuring that the code is readable and that
    it keeps the quality standards. In the early stages, the code will have a relatively
    high number of comments and there will be more to discuss since more elements will
    need to be tweaked.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个功能的不同阶段并不同样关键。代码审查的早期过程是为了确保代码可读，并且保持质量标准。在早期阶段，代码将有相对较多的注释，并且会有更多需要讨论的地方，因为需要调整的元素更多。
- en: A big part of reviews is creating code that is *understandable enough* that
    other members of the team understand it. Although some people claim that code
    reviews make everyone aware of the changes that other members of the team are
    implementing, in my experience, reviewers are not that aware of specific features.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 审查的一个重要部分是创建*足够易懂*的代码，以便团队的其他成员能够理解。尽管有些人声称代码审查可以让每个人都意识到团队其他成员正在实施的更改，但根据我的经验，审阅者并不那么了解特定功能。
- en: A good review, however, will ensure that nothing cryptic is being introduced
    into the code base and that the core elements are respected (elements such as
    introducing tests, keeping documentation up to date, and keeping code readable).
    As we suggested previously in this chapter, try to create an explicit list of
    things to check. It will help you make the reviews and code more consistent.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个良好的审查将确保没有令人费解的东西被引入到代码库中，并且核心元素得到尊重（例如引入测试，保持文档更新，保持代码可读）。正如我们在本章前面建议的那样，尝试创建一个明确的检查事项列表。这将有助于使审查和代码更加一致。
- en: The deployment stages of a new feature only require that we check that the version
    of the microservice changes and that the remainder of the infrastructure is intact.
    These will typically be very small; most of them double-check that there are no
    typos and that the microservice to be changed is the correct one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能的部署阶段只需要检查微服务版本的更改以及基础设施的其余部分是否完好。这些通常会非常小；大多数情况下会再次检查是否有拼写错误，以及要更改的微服务是否正确。
- en: Defining a clear path for releases
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义发布的明确路径
- en: 'Having a simple and clear process helps everyone involved have a clear understanding
    of how a feature moves from being developed to being released into the production
    environment. For example, based on the ideas we''ve discussed, we could end up
    with a deployment path that''s similar to the one shown in the following diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个简单明了的流程可以帮助所有参与者清楚地了解一个功能是如何从开发到发布到生产环境的。例如，基于我们讨论过的想法，我们可能会得到一个类似于以下图表所示的部署路径：
- en: '![](img/22480f67-8ebb-41fe-8395-f832aa7b5909.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22480f67-8ebb-41fe-8395-f832aa7b5909.png)'
- en: For each of these steps, we need to validate that the step is correct. As we
    saw in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating a Pipeline
    and Workflow*, automatic tests ensure that anything that's merged into the main
    branch doesn't break the existing builds. This covers the preceding diagram up
    to the **Create tag** step.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些步骤中的每一步，我们需要验证该步骤是否正确。正如我们在[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)中所看到的，*创建流水线和工作流*，自动化测试确保合并到主分支的任何内容都不会破坏现有的构建。这涵盖了前面的图表直到**创建标签**步骤。
- en: 'Equally, there could be a way of validating that a deployment has been successful
    after it''s been applied. The following are a few ideas regarding this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可能有一种方法可以在部署后验证部署是否成功。以下是关于此的一些想法：
- en: Manual tests, to check that the deployed microservice works as expected
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试，以检查部署的微服务是否按预期工作
- en: Automated tests, such as the ones described in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating
    a Pipeline and Workflow*
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试，比如[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)中描述的那些，*创建流水线和工作流*
- en: Check that the image to be deployed has been correctly deployed using Kubernetes
    tools or a version API
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查要部署的图像是否已经使用Kubernetes工具或版本API正确部署
- en: Once one deployment stage has been successfully completed, the next can be started.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个部署阶段成功完成，就可以开始下一个阶段。
- en: Performing a deployment in non-production environments minimizes the risk of
    breaking a production as it will ensure that the deployment process is correct. The
    process needs to be fast enough to allow quick deployments, thus making them as
    small as possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在非生产环境中进行部署可以最大程度地减少破坏生产环境的风险，因为这将确保部署过程是正确的。流程需要足够快，以便允许快速部署，从而使它们尽可能小。
- en: The full process from merging into the main branch until the new version is
    released into the production environment should take less than a few hours, but
    ideally less than that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从合并到主分支到新版本发布到生产环境，整个过程应该不超过几个小时，但最好是更短。
- en: If more time is required, the process is probably too heavy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更多时间，那么这个流程可能太繁重了。
- en: Small, frequent deployments will minimize the risk of breaking the production
    environment. In some exceptional cases, the regular process may be slow, and an
    emergency procedure should be used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 小而频繁的部署将最大程度地减少破坏生产环境的风险。在一些特殊情况下，常规流程可能会很慢，需要使用紧急程序。
- en: Emergency releases
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧急发布
- en: Let's imagine that there's a critical bug in production and that it needs to
    be addressed as fast as possible. For these exceptional cases, it is fine to define
    an emergency process beforehand.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设在生产中有一个关键错误，需要尽快解决。对于这些特殊情况，事先定义一个紧急流程是可以的。
- en: This emergency process may involve speeding up reviews or even skipping them
    completely. This may include skipping intermediate releases (such as not deploying
    to a demo environment before hand). Ensure that you explicitly define when this
    process is required and ensure it's used in emergency situations only.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种紧急流程可能涉及加快审查甚至完全跳过审查。这可能包括跳过中间发布（例如在事先不部署到演示环境）。确保明确定义何时需要使用此流程，并确保仅在紧急情况下使用。
- en: If your regular deployment process is fast enough, then there's no need for
    an emergency process. This is an excellent reason to try to increase deployment
    times.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的常规部署流程足够快，那么就不需要紧急流程。这是尝试提高部署时间的一个很好的理由。
- en: A rollback is a good example of such a situation. To revert the deployment of
    a microservice that had a critical bug introduced to it in the last version, rolling
    back and returning to the previous version only in production, without affecting
    anything else, is a reasonable process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚是一个很好的例子。要撤销微服务的部署，因为上一个版本引入了关键错误，只需在生产环境中回滚并返回到上一个版本，而不影响其他任何东西，这是一个合理的流程。
- en: Note how, here, we're reducing the risk of making a quick change with the assurance
    that the version that's been rolled back has already been deployed before. This
    is an excellent example of how an emergency procedure may work and reduce risks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们减少了进行快速更改的风险，并确保已经回滚的版本已经在之前部署过。这是紧急程序可能起作用并减少风险的一个很好的例子。
- en: Use your common sense when it comes to detecting exceptional situations and
    discuss how to deal with them with your team beforehand. We will talk about retrospectives
    in [Chapter 12](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml), *Collaborating and
    Communicating across Teams.*
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现特殊情况时要运用常识，并与团队事先讨论如何处理。我们将在[第12章](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml)
    *跨团队协作和沟通* 中讨论回顾。
- en: Releasing frequently and adding feature flags
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频繁发布和添加功能标志
- en: While rollbacks are possible, as we've just seen, the general consensus should
    be that each new deployment moves forward. The code for a new release contains
    the code from the previous release, plus some small changes. Following the Git
    way of operating, we work on a single branch (the main branch) that gets pushed
    forward.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然回滚是可能的，正如我们刚才看到的，但一般共识应该是每次新部署都是向前推进的。新版本的代码包含了上一个版本的代码，再加上一些小的更改。按照Git的操作方式，我们在一个分支上工作（主分支），并将其推进。
- en: This means having to avoid several active long-lived branches. This model is
    called *trunk-based development* and it's the recommended way of working to aim
    for continuous integration. In a trunk-based development, feature branches are
    short-lived and are always merged with the main branch (or trunk), which is normally
    called the `master` in Git.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着要避免几个长期存在的活跃分支。这种模式被称为*基于主干的开发*，是持续集成的推荐工作方式。在基于主干的开发中，功能分支是短暂存在的，并且始终与主分支（或主干）合并，通常在Git中称为`master`。
- en: Trunk-based development avoids issues when we have long-lived branches that
    diverge from the main one, thus making the integration of several components complicated.
    The basis for continuous integration is to be able to always have code that can
    be released in small increments. This model takes "trunk" as the reference for
    the releases.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发避免了当我们有长期存在且与主分支分歧的分支时出现的问题，从而使多个组件的集成变得复杂。持续集成的基础是始终具有可以以小的增量发布的代码。这种模式以“主干”作为发布的参考。
- en: 'In the following diagram, we can see how **feature A** was merged to the **master** branch
    and how **feature B** is still in progress. Any releases will come from the **master** branch:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到**功能A**是如何合并到**主分支**中的，以及**功能B**仍在进行中。任何发布都将来自**主分支**：
- en: '![](img/2dab7dbb-586a-4dea-a959-14ba5beea981.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dab7dbb-586a-4dea-a959-14ba5beea981.png)'
- en: If **feature A** were to introduce a bug, a new bugfix branch will branch off
    from **master** and will be merged back. Note how the structure is to keep going
    forward.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**功能A**引入了一个错误，一个新的bug修复分支将从**主分支**分支出来，并将被合并回去。请注意结构是继续向前推进的。
- en: For this system to work, feature branches need to be short-lived – typically
    for only a few days. This makes merges easy and allows for small incremental changes,
    which are the key to continuous integration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个系统工作，功能分支需要短暂存在 - 通常只有几天。这样做可以使合并变得容易，并允许进行小的增量更改，这是持续集成的关键。
- en: Using feature flags
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用功能标志
- en: Sometimes, there are some features that, by design, require big/drastic changes
    to be made in one go, such as a new UI interface. The kind of short, quick iteration
    cycle of slowly adding small features that continuous integration advocates doesn't
    work in these frequent release situations. The new interface needs to include
    all the elements in one go, or it will look weird.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有一些功能，由设计需要一次性进行大规模/重大更改，比如新的UI界面。持续集成倡导者提倡的短小迭代周期，逐渐添加小功能的方式在这些频繁发布的情况下行不通。新界面需要一次性包含所有元素，否则会显得奇怪。
- en: You can use feature flags when you want to keep working in a small incremental
    way and, at the same time, delay the activation of a feature until it's ready.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望以小的增量方式继续工作，并同时延迟功能的激活时，可以使用功能标志。
- en: Feature flags are configuration elements that enable or disable a particular
    feature. This allows you to change the behavior of the microservice with a configuration
    change, which acts as a switch.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志是启用或禁用特定功能的配置元素。这使您可以通过配置更改改变微服务的行为，起到开关的作用。
- en: In Kubernetes, we use the `deployment.yaml` file to describe the environment
    variables, as well as ConfigMaps. We will discuss ConfigMaps in [Chapter 11](06d0c451-77f1-4e4a-8d38-3abf112f79fa.xhtml),
    *Handling Change, Dependencies, and Secrets in the System*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，我们使用`deployment.yaml`文件来描述环境变量，以及ConfigMaps。我们将在第11章《处理系统中的变更、依赖关系和机密信息》中讨论ConfigMaps。
- en: The configuration is tied to each individual environment. This makes it possible
    for us to present a feature in a particular environment and not in another, while
    the code base remains the same.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 配置与每个单独的环境相关联。这使我们能够在特定环境中展示一个功能，而在另一个环境中不展示，同时代码库保持不变。
- en: For example, a new interface can be slowly developed and protected under a feature
    flag. Some environments, such as demo environments, can still be active so that
    internal feedback can be gathered, but this won't be displayed in the production
    environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以慢慢开发并在功能标志下保护一个新接口。一些环境，比如演示环境，仍然可以处于活动状态，以便收集内部反馈，但这不会显示在生产环境中。
- en: Once the new interface is ready, small changes can be made; for example, we
    can change the configuration parameter to enable it. This may look like a big
    change externally, but it can easily be reverted if we swap back to the parameter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新接口准备就绪，就可以进行小的更改；例如，我们可以更改配置参数以启用它。这在外部看起来可能是一个很大的变化，但如果我们切换回参数，它可以很容易地恢复。
- en: Feature flags are useful when we're dealing with externally accessible services.
    Internal services can add more features without any issue since they'll only be
    called by other microservices in the system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志在处理外部可访问服务时非常有用。内部服务可以添加更多功能而不会出现任何问题，因为它们只会被系统中的其他微服务调用。
- en: Internal microservices are normally okay with adding new features. Here, backward
    compatibility is respected. Externally accessible features sometimes require us
    to replace a feature with another for reasons including interface changes or the
    deprecation of products.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 内部微服务通常可以添加新功能。在这里，会尊重向后兼容性。外部可访问的功能有时需要我们出于各种原因（包括接口更改或产品弃用）用另一个功能替换一个功能。
- en: A related approach is to roll a feature to a subset of users. This can be a
    predefined set of users, such as users who have enrolled in a beta program to
    receive early access to features or a random sample so that they can detect problems
    early, ahead of a global release.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的方法是将功能推送给一部分用户。这可以是预定义的用户集，例如已经加入测试计划以获得早期功能访问权限的用户，或者是一个随机样本，以便他们可以在全球发布之前及早发现问题。
- en: Some big companies use regional access as well, where some features are enabled
    in certain countries first.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一些大公司也使用区域访问，其中一些功能首先在特定国家/地区启用。
- en: Once the feature flag has been activated, any deprecated features can be removed
    and cleaned up, so there's no old code that's not going to be used.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦功能标志被激活，任何已弃用的功能都可以被移除和清理，这样就不会有不会被使用的旧代码了。
- en: Dealing with database migrations
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据库迁移
- en: Database migrations are changes that are made to the persistent data that's
    stored in a particular environment (normally, in one or more databases). Most
    of the time, this means changing the database schema, but there are others.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移是对存储在特定环境中的持久数据进行的更改（通常是在一个或多个数据库中）。大多数情况下，这意味着改变数据库模式，但也有其他情况。
- en: The data in a production environment is the most important asset in a running
    system. Extra care is advised for database migrations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境中的数据是运行系统中最重要的资产。对数据库迁移需要特别小心。
- en: In certain cases, a migration may lock a table for a certain period of time,
    thereby rendering the system unusable. Ensure that you test your migrations properly
    in order to avoid or at least prepare for these cases.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，迁移可能会锁定表一段时间，从而使系统无法使用。确保您适当地测试您的迁移，以避免或至少为这些情况做好准备。
- en: Though database migrations may technically be reversible, doing so is very expensive
    in terms of development time. For example, adding and removing a column could
    be simple, but once the column is in operation, the column will contain data that
    shouldn't be removed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据库迁移在技术上可能是可逆的，但从开发时间的角度来看，这样做是非常昂贵的。例如，添加和删除列可能很简单，但一旦列投入使用，它将包含不应删除的数据。
- en: 'To be able to work seamlessly in the event of data migration, you need to detach
    it from the code that is going to call it and follow these steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在数据迁移事件中无缝工作，您需要将其与将调用它的代码分离，并按照以下步骤进行操作：
- en: Design a database migration in a way that doesn't interfere with the current
    code. For example, adding a table or column to the database is safe since the
    old code will ignore it.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计数据库迁移时，要以不干扰当前代码为目标。例如，向数据库添加表或列是安全的，因为旧代码会忽略它。
- en: Perform database migration. This makes the required changes while the existing
    code keeps operating without interruption.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行数据库迁移。这样就可以在现有代码继续运行而不中断的情况下进行所需的更改。
- en: Now, the code can be deployed. Once it has been deployed, it will start using
    the advantages of the new database definition. If there's a problem, the code
    can be rolled back to a previous version.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，代码可以部署。一旦部署完成，它将开始使用新数据库定义的优势。如果出现问题，代码可以回滚到先前的版本。
- en: 'This implies that we need to create two deployments:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要创建两个部署：
- en: One for the migration
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于迁移
- en: Another for the code that uses this migration
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个用于使用此迁移的代码
- en: Migration deployment may be similar to code deployment. Maybe there's a microservice
    running the migrations, or maybe it's a script doing all the work. Most frameworks
    will have a way of making migrations to ensure that a migration isn't applied
    twice.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移部署可能类似于代码部署。也许有一个运行迁移的微服务，或者可能是一个执行所有工作的脚本。大多数框架都会有一种迁移的方法，以确保迁移不会被应用两次。
- en: For example, for SQLAlchemy, there's a tool called Alembic ([https://alembic.sqlalchemy.org/en/latest/](https://alembic.sqlalchemy.org/en/latest/))
    that we can use to generate and run migrations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于SQLAlchemy，有一个名为Alembic的工具（[https://alembic.sqlalchemy.org/en/latest/](https://alembic.sqlalchemy.org/en/latest/)），我们可以使用它来生成和运行迁移。
- en: 'However, there is an alternative operation: try to apply the migrations to
    the microservice that will make use of them. When dealing with a production environment,
    this is a bad idea as this will slow start up times in all situations, regardless
    of whether a migration is occurring. Also, it won''t check that the code can be
    safely rolled back and works with the previous version of the database.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种替代操作：尝试将迁移应用于将使用它们的微服务。在处理生产环境时，这是一个坏主意，因为这将在所有情况下减慢启动时间，而不管是否正在进行迁移。此外，它不会检查代码是否可以安全回滚，并且是否与数据库的先前版本兼容。
- en: 'Working with two independent deployments is obviously a bit more restrictive
    than changing the database freely, but it ensures that each step forward is solid
    and that the service is uninterrupted. It''s more deliberate. For example, to
    rename a column, we would follow these steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与两个独立的部署一起工作显然比自由更改数据库更加受限，但它确保每一步都是稳固的，服务不会中断。这更加故意。例如，要重命名列，我们将按照以下步骤进行：
- en: First, we would deploy a migration that creates a new column with the new column
    name, thereby copying the data from the old column. The code reads and writes
    from the old column.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将部署一个创建具有新列名称的新列的迁移，从而复制旧列中的数据。代码从旧列读取和写入。
- en: Then, we would deploy the new code that reads from the old column and writes
    to both. During the release process, any writes from the old code to the old column
    will be read correctly.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将部署从旧列读取并向两者写入的新代码。在发布过程中，从旧代码到旧列的任何写入都将被正确读取。
- en: After, we would create another migration that copies the data from the old one
    to the new one. This ensures that any transient copy is correctly applied. At
    this point, any new data still goes to both columns.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将创建另一个迁移，将数据从旧迁移复制到新迁移。这样可以确保任何瞬态复制都被正确应用。此时，任何新数据仍然会同时写入两列。
- en: Then, we would deploy code that reads and writes to the new column, ignoring
    the old one.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将部署代码，从新列读取和写入，忽略旧列。
- en: Finally, we would implement a migration to drop the old column. At this point,
    the old column doesn't contain relevant data and can be safely deleted. It won't
    affect the code.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实施一个迁移来删除旧列。此时，旧列不包含相关数据，可以安全地删除。这不会影响代码。
- en: This is a deliberate example of a long process, but in most cases, such a long
    process won't be required. However, at no point in any of these steps is there
    any inconsistency. If there's a problem in one of the stages, we can revert to
    the previous stage – it will still work until a fix is put in place.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个故意的长流程示例，但在大多数情况下，不需要这样的长流程。然而，在这些步骤中的任何时候都没有任何不一致。如果某个阶段出现问题，我们可以回滚到上一个阶段
    - 直到修复为止，它仍然可以工作。
- en: The main objective is to avoid having transient states where the database won't
    work with the currently deployed code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标是避免数据库与当前部署的代码不兼容的瞬态状态。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about the flow of a team, from starting a new feature
    to deploying it into a production environment.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了团队的流程，从开始一个新功能到将其部署到生产环境中。
- en: We started by talking about the key points of feature requests when we're working
    in a microservices architecture. We introduced requests that affect multiple microservices
    and learned how to structure the work so that the service isn't interrupted.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了在微服务架构中工作时功能请求的关键点。我们介绍了影响多个微服务的请求，并学习了如何构建工作，以便服务不会中断。
- en: We talked about the elements that make a good review and approval process, as
    well as how GitHub pull requests help us do this. Using GitOps practices to control
    the infrastructure makes deployments to be reviewed straightforward.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了构成良好审查和批准流程的要素，以及GitHub拉取请求如何帮助我们做到这一点。使用GitOps实践来控制基础设施使得部署可以轻松地进行审查。
- en: Then, we discussed how working with Kubernetes and GitOps helps us create multiple
    environments and how we can use them to our advantage when dealing with demo and
    staging environments to test deployments and to present features in a controlled
    environment before they go to production.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了如何使用Kubernetes和GitOps帮助我们创建多个环境，以及在处理演示和分段环境时如何利用它们的优势，以测试部署并在进入生产之前在受控环境中展示功能。
- en: After this, we talked about how we can make a team have a global view of the
    entire life cycle, from feature request to deployment and being able to follow
    the full path quickly. We learned how to clarify these steps and how to make the
    team responsible for reviewing and approving its own code, which allows developers
    to take full ownership of the development cycle.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们讨论了如何使团队能够全面了解整个生命周期，从功能请求到部署，并能够快速跟踪整个路径。我们学会了如何澄清这些步骤，以及如何使团队负责审查和批准自己的代码，这使开发人员可以完全拥有开发周期。
- en: We also talked about the issues that may occur when we're dealing with database
    migrations and explained how to proceed with this special kind of deployment,
    which isn't easy to roll back.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了在处理数据库迁移时可能出现的问题，并解释了如何进行这种特殊类型的部署，这不容易回滚。
- en: In the next chapter, we will talk about live systems and how to enable elements
    such as metrics and logs so that we can detect problems and bugs that occur in
    a production environment and have enough information to remediate them as quickly
    and proactively as possible.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论实时系统以及如何启用诸如指标和日志之类的元素，以便我们可以检测在生产环境中发生的问题和错误，并获得足够的信息尽快主动地进行修复。
- en: Questions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: As a new business feature is received, what analysis do we need to perform in
    a system working under a microservice architecture?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到一个新的业务功能时，在微服务架构下，我们需要进行怎样的分析？
- en: If a feature requires two or more microservices to be changed, how do we decide
    which one should be changed first?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个功能需要修改两个或更多微服务，我们如何决定首先修改哪一个？
- en: How does Kubernetes help us set up multiple environments?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes如何帮助我们建立多个环境？
- en: How does a code review work?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码审查是如何工作的？
- en: What is the main bottleneck for code reviews?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码审查的主要瓶颈是什么？
- en: Under GitOps principles, are the reviews for deployment different from code
    reviews?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据GitOps原则，部署审查与代码审查有何不同？
- en: Why is it important to have a clear path to deployment once a feature is ready
    to be merged into the main branch?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么一旦一个功能准备合并到主分支时，有一个清晰的部署路径是很重要的？
- en: Why are database migrations different from regular code deployments?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么数据库迁移与常规代码部署不同？
- en: Further reading
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about agile practices and introducing them to a team, take a
    look at the following books:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于敏捷实践并将其引入团队的信息，请查阅以下书籍：
- en: '*The Agile Developer''s Handbook* ([https://www.packtpub.com/eu/web-development/agile-developers-handbook](https://www.packtpub.com/eu/web-development/agile-developers-handbook))'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《The Agile Developer's Handbook》
- en: '*Agile Technical Practices Distilled* ([https://www.packtpub.com/eu/business-other/agile-technical-practices-distilled](https://www.packtpub.com/eu/business-other/agile-technical-practices-distilled))'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Agile Technical Practices Distilled》
- en: If you're using JIRA in your organization, reading *Hands-On Agile Software
    Development with JIRA* ([https://www.packtpub.com/eu/application-development/hands-agile-software-development-jira](https://www.packtpub.com/eu/application-development/hands-agile-software-development-jira)) can
    help you get better use out of the tool when you're working with agile practices.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组织在使用JIRA，阅读《Hands-On Agile Software Development with JIRA》可以帮助你更好地利用这个工具来进行敏捷实践。
