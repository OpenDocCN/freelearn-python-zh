- en: Chapter 8. Python – Architectural Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。Python - 架构模式
- en: Architectural patterns are the highest level of patterns in the pantheon of
    patterns in software. Architectural patterns allow the architects to specify the
    fundamental structure of an application. The architectural pattern chosen for
    a given software problem governs the rest of its activities, such as the design
    of systems involved, communication between different parts of the system, and
    so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式是软件模式体系中最高级别的模式。架构模式允许架构师指定应用程序的基本结构。为给定的软件问题选择的架构模式控制着其余的活动，例如所涉及系统的设计，系统不同部分之间的通信等等。
- en: There are a number of architectural patterns to choose from depending upon the
    problem at hand. Different patterns solve different classes or families of problems,
    creating their own style or class of architecture. For example, a certain class
    of patterns solves the architecture of client/server systems, certain others help
    to build distributed systems, and a third helps to design highly decoupled peer-to-peer
    systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根据手头的问题，可以选择多种架构模式。不同的模式解决不同类或系列的问题，创造出自己的风格或架构类别。例如，某一类模式解决了客户端/服务器系统的架构，另一类模式帮助构建分布式系统，第三类模式帮助设计高度解耦的对等系统。
- en: In this chapter, we will discuss and focus on a few architectural patterns that
    are encountered often in the Python world. Our pattern of discussion in the chapter
    will be to take a well-known architectural pattern, and explore one or two popular
    software applications or frameworks that implement it, or a variation of it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论并专注于Python世界中经常遇到的一些架构模式。我们在本章中的讨论模式将是采用一个众所周知的架构模式，并探索一个或两个实现它的流行软件应用程序或框架，或者它的变体。
- en: We will not discuss a lot of code in this chapter—the usage of code will be
    limited to those patterns where an illustration using a program is absolutely
    essential. On the other hand, most of the discussion will be on the architectural
    details, participating subsystems, variations in the architecture implemented
    by the chosen application/framework, and the like.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会讨论大量的代码 - 代码的使用将仅限于那些绝对必要使用程序进行说明的模式。另一方面，大部分讨论将集中在架构细节，参与子系统，所选应用程序/框架实现的架构变化等方面。
- en: There are any number of architecture patterns that we can look at. In this chapter,
    we will focus on MVC and its related patterns, Event-driven programming architectures,
    Microservices architectures, and Pipes and Filters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以研究任意数量的架构模式。在本章中，我们将重点关注MVC及其相关模式，事件驱动编程架构，微服务架构以及管道和过滤器。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: 'Introducing MVC:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍MVC：
- en: Model View Template – Django
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型视图模板 - Django
- en: Flask Microframework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask微框架
- en: 'Event driven Programming:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动编程：
- en: Chat server and client using select
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用select的聊天服务器和客户端
- en: Event-driven versus Concurrent programming
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动与并发编程
- en: Twisted
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扭曲
- en: Twisted Chat Server and Client
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 扭曲聊天服务器和客户端
- en: Eventlet
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eventlet
- en: Eventlet Chat Server
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Eventlet聊天服务器
- en: Greenlets and gevent
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Greenlets和gevent
- en: Gevent Chat Server
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Gevent聊天服务器
- en: 'Microservices Architecture:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构：
- en: Microservice frameworks in Python
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的微服务框架
- en: Microservice example
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务示例
- en: Microservice advantages
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务优势
- en: 'Pipe and Filter Architecture:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道和过滤器架构：
- en: Pipe and Filter in Python – examples
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的管道和过滤器 - 示例
- en: Introducing MVC
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MVC
- en: 'Model View Controller or MVC is a well known and popular architectural pattern
    for building interactive applications. MVC splits the application into three components:
    the Model, the View, and the Controller.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模型视图控制器或MVC是用于构建交互式应用程序的众所周知和流行的架构模式。MVC将应用程序分为三个组件：模型，视图和控制器。
- en: '![Introducing MVC](../Images/image00489.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![介绍MVC](../Images/image00489.jpeg)'
- en: Model-View-Controller (MVC) Architecture
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）架构
- en: 'The three components perform the following responsibilities:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个组件执行以下职责：
- en: '**Model**: The model contains the core data and logic of the application.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型包含应用程序的核心数据和逻辑。'
- en: '**View**: The view(s) form the output of the application to the user. They
    display information to the user. Multiple views of the same data are possible.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图形成应用程序向用户的输出。它们向用户显示信息。可以有同一数据的多个视图。'
- en: '**Controller**: The controller receives and processes user input such as keyboard
    clicks or mouse clicks/movements, and converts them into change requests for the
    model or the view.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器接收和处理用户输入，如键盘点击或鼠标点击/移动，并将它们转换为对模型或视图的更改请求。'
- en: Separation of concerns using these three components avoids tight coupling between
    the data of the application and its representation. It allows for multiple representations
    (views) of the same data (model), which can be computed and presented according
    to user input received via the controller.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个组件分离关注避免了应用程序的数据和其表示之间的紧密耦合。它允许同一数据（模型）的多个表示（视图），可以根据通过控制器接收的用户输入进行计算和呈现。
- en: 'The MVC pattern allows the following interactions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式允许以下交互：
- en: A model can change its data depending upon inputs received from the controller.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型可以根据从控制器接收的输入更改其数据。
- en: The changed data is reflected on the views, which are subscribed to changes
    in the model.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改的数据反映在视图上，这些视图订阅了模型的更改。
- en: Controllers can send commands to update the model's state, such as when making
    changes to a document. Controllers can also send commands to modify the presentation
    of a view without any change to the model, such as zooming in on a graph or chart.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器可以发送命令来更新模型的状态，例如在对文档进行更改时。控制器还可以发送命令来修改视图的呈现，而不对模型进行任何更改，例如放大图表或图表。
- en: The MVC pattern implicitly includes a change propagation mechanism to notify
    each component of changes on the other dependent components.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC模式隐含地包括一个变更传播机制，以通知其他依赖组件的变更。
- en: A number of web applications in the Python world implement MVC or a variation
    of it. We will look at a couple of them, namely Django and Flask, in the coming
    sections.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python世界中的许多Web应用程序实现了MVC或其变体。我们将在接下来的部分中看一些，即Django和Flask。
- en: Model Template View (MTV) – Django
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板视图（MTV） - Django
- en: The Django project is one of the most popular web application frameworks in
    the Python world. Django implements something like an MVC pattern, but with some
    subtle differences.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目是Python世界中最受欢迎的Web应用程序框架之一。Django实现了类似MVC模式的东西，但有一些细微的差异。
- en: 'The Django (core) component architecture is illustrated in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Django（核心）组件架构如下图所示：
- en: '![Model Template View (MTV) – Django](../Images/image00490.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Model Template View (MTV) – Django](../Images/image00490.jpeg)'
- en: Django Core Component Architecture
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Django核心组件架构
- en: 'The core components of the Django framework are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Django框架的核心组件如下：
- en: An **Object Relational Mapper** (**ORM**), which acts as a mediator between
    data models (Python) and the database (RDBMS)—this can be thought of as the **Modle**
    layer.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象关系映射器（ORM），充当数据模型（Python）和数据库（关系数据库管理系统）之间的中介 - 这可以被认为是模型层。
- en: A set of callback functions in Python, which renders the data to the user interface
    for a specific URL—this can be thought of as the **VIEW** layer. The view focuses
    on building and transforming the content rather than on its actual presentation.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的一组回调函数，将数据呈现给特定URL的用户界面 - 这可以被认为是VIEW层。视图侧重于构建和转换内容，而不是实际呈现。
- en: A set of HTML templates to render content in different presentations. The view
    delegates to a specific template, which is responsible for how the data is presented.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组HTML模板，用于以不同的方式呈现内容。视图委托给特定模板，该模板负责数据的呈现方式。
- en: A regular expression-based **URL DISPATCHER**, which connects relative paths
    on the server to specific views and their variable arguments. This can be thought
    of as a rudimentary **Controller**.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于正则表达式的URL DISPATCHER，将服务器上的相对路径连接到特定视图及其变量参数。这可以被认为是一个基本的控制器。
- en: In Django, since the presentation is performed by the **TEMPLATE** layer and
    only the content mapping done by the **VIEW** layer, Django is often described
    as implementing the **Model Template View** (**MTV**) framework.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Django中，由于呈现是由TEMPLATE层执行的，而只有VIEW层执行内容映射，因此Django经常被描述为实现Model Template View（MTV）框架。
- en: The Controller in Django is not very well defined – it can be thought of as
    the entire framework itself – or limited to the **URL DISPATCHER** layer.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django中的控制器并没有很好地定义 - 它可以被认为是整个框架本身 - 或者限于URL DISPATCHER层。
- en: Django admin – automated model-centric views
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django admin - 自动化的模型中心视图
- en: One of the most powerful components of the Django framework is its automatic
    admin system, which reads metadata from the Django models, and generates quick,
    model-centric admin views, where administrators of the system can view and edit
    data models via simple HTML forms.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Django框架最强大的组件之一是其自动管理员系统，它从Django模型中读取元数据，并生成快速的、以模型为中心的管理员视图，系统管理员可以通过简单的HTML表单查看和编辑数据模型。
- en: 'For illustration, the following is an example of a Django model that describes
    a term that is added to a website as a `glossary` term (A glossary is a list or
    index of words that describes the meaning of words related to a specific subject,
    text, or dialect):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，以下是一个描述将术语添加到网站作为“词汇”术语的Django模型的示例（词汇是描述与特定主题、文本或方言相关的词汇含义的列表或索引）：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is combined with an admin system that registers a model for an automated
    admin view:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这与一个注册模型以获得自动化管理员视图的管理员系统相结合：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is an image of the automated admin view (HTML form) for adding
    a glossary term via the Django admin interface:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过Django admin界面添加术语词汇的自动化管理员视图（HTML表单）的图像：
- en: '![Django admin – automated model-centric views](../Images/image00491.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Django admin – automated model-centric views](../Images/image00491.jpeg)'
- en: Django Automated Admin View (HTML form) for adding a glossary term
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Django自动管理员视图（HTML表单）用于添加词汇术语
- en: A quick observation tells you how the Django admin is able to generate the correct
    field type for the different data fields in the model, and generate a form for
    adding the data. This is a powerful pattern that is present in Django, which allows
    one to generate automated admin views for adding/editing models with almost zero
    coding effort.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 快速观察告诉您Django管理员如何为模型中的不同数据字段生成正确的字段类型，并生成添加数据的表单。这是Django中的一个强大模式，允许您以几乎零编码工作量生成自动化的管理员视图以添加/编辑模型。
- en: Let us now look at another popular Python web application framework, namely,
    Flask.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看另一个流行的Python Web应用程序框架，即Flask。
- en: Flexible Microframework – Flask
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活的微框架 - Flask
- en: 'Flask is a micro web framework, which uses a minimalistic philosophy for building
    web applications. Flask relies on just two libraries: the Werkzeug ([http://werkzeug.pocoo.org/](http://werkzeug.pocoo.org/))
    WSGI tool kit and the Jinja2 templating framework.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是一个微型Web框架，它使用了一种最小主义的哲学来构建Web应用程序。Flask仅依赖于两个库：Werkzeug（[http://werkzeug.pocoo.org/](http://werkzeug.pocoo.org/)）WSGI工具包和Jinja2模板框架。
- en: Flask comes with simple URL routing via decorators. The *micro* word in Flask
    indicates that the core of the framework is small. Support for databases, forms,
    and others is provided by multiple extensions that the Python community has built
    around Flask.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Flask通过装饰器提供了简单的URL路由。Flask中的“微”一词表明框架的核心很小。对数据库、表单和其他功能的支持是由Python社区围绕Flask构建的多个扩展提供的。
- en: The core Flask can thus be thought of as an MTV framework minus the M (View
    Template), since the core does not implement support for models.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Flask的核心可以被认为是一个MTV框架减去M（视图模板），因为核心不实现对模型的支持。
- en: 'Here is an approximate schematic diagram of the Flask component architecture:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Flask组件架构的近似示意图：
- en: '![Flexible Microframework – Flask](../Images/image00492.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Flexible Microframework – Flask](../Images/image00492.jpeg)'
- en: Schematic diagram of Flask components
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Flask组件的示意图
- en: 'A simple Flask application using templates looks something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板的简单Flask应用程序看起来是这样的：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can find a few components of the MVC pattern right here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里找到MVC模式的一些组件：
- en: The `@app.route` decorator routes requests from the browser to the `index` function.
    The application router can be thought of as the controller.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@app.route`装饰器将浏览器的请求路由到`index`函数。应用程序路由器可以被视为控制器。'
- en: The `index` function returns the data, and renders it using a template. The
    `index` function can be thought of as generating the view or the view component.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`函数返回数据，并使用模板进行渲染。`index`函数可以被视为生成视图或视图组件。'
- en: Flask uses templates like Django to keep the content separate from the presentation.
    This can be thought of as the template component.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask使用类似Django的模板来将内容与呈现分开。这可以被视为模板组件。
- en: There is no specific model component in Flask core. However, this can be added
    on with the help of additional plugins.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Flask核心中没有特定的模型组件。但是，可以借助附加插件来添加模型组件。
- en: Flask uses a plugin architecture to support additional features. For example,
    models can be added on by using Flask-SQLAlchemy, RESTful API support using Flask-RESTful,
    serialization using Flask-marshmallow, and others.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask使用插件架构来支持附加功能。例如，可以使用Flask-SQLAlchemy添加模型，使用Flask-RESTful支持RESTful API，使用Flask-marshmallow进行序列化等。
- en: Event-driven programming
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动编程
- en: Event-driven programming is a paradigm of system architecture where the logic
    flow within the program is driven by events such as user actions, messages from
    other programs, or hardware (sensor) inputs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程是一种系统架构范式，其中程序内部的逻辑流由事件驱动，例如用户操作、来自其他程序的消息或硬件（传感器）输入。
- en: In Event-driven architectures, there is usually a main event loop, which listens
    for events, and then triggers callback functions with specific arguments when
    an event is detected.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动架构中，通常有一个主事件循环，它监听事件，然后在检测到事件时触发具有特定参数的回调函数。
- en: In modern operating systems like Linux, support for events on input file descriptors
    such as sockets or opened files are implemented by system calls such as `select`,
    `poll`, and `epoll`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Linux这样的现代操作系统中，对输入文件描述符（如套接字或已打开的文件）的事件的支持是通过系统调用（如`select`、`poll`和`epoll`）来实现的。
- en: Python provides wrappers to these system calls via its `select` module. It is
    not very difficult to write a simple Event-driven program using the `select` module
    in Python.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过其`select`模块提供了对这些系统调用的包装。使用`select`模块在Python中编写简单的事件驱动程序并不是很困难。
- en: The following set of programs together implement a basic chat server and client
    in Python using the power of the select module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一组程序一起使用Python实现了基本的聊天服务器和客户端，利用了select模块的强大功能。
- en: Chat server and client using I/O multiplexing with the select module
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用select模块进行I/O多路复用的聊天服务器和客户端
- en: Our chat server uses the `select` system call via the `select` module to create
    channels where clients can connect to and talk with each other. It handles the
    events (sockets) that are input ready–if the event is a client connecting to the
    server, it connects and performs a handshake; if the event is data to be read
    from standard input, the server reads the data, or else it passes the data received
    from one client to the others.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天服务器使用`select`模块通过`select`系统调用来创建频道，客户端可以连接到这些频道并相互交谈。它处理输入准备好的事件（套接字）-如果事件是客户端连接到服务器，则连接并进行握手；如果事件是要从标准输入读取数据，则服务器读取数据，否则将从一个客户端接收到的数据传递给其他客户端。
- en: 'Here is our chat server:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的聊天服务器：
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the code of the chat server is big, we are only including the main function,
    namely the serve one here showing how the server uses select-based I/O multiplexing.
    A lot of code in the `serve` function has also been trimmed to keep the printed
    code small.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于聊天服务器的代码很大，我们只包含了主函数，即`serve`函数，显示服务器如何使用基于select的I/O多路复用。`serve`函数中的大量代码也已经被修剪，以保持打印的代码较小。
- en: The complete source code can be downloaded from the code archive of this book
    from the book's website.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以从本书的代码存档中下载，也可以从本书的网站上下载。
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The chat server can be stopped by sending a single line of empty input.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发送一行空输入可以停止聊天服务器。
- en: 'The chat client also uses the `select` system call. It uses a socket to connect
    to the server, and then waits for events on the socket plus the standard input.
    If the event is from the standard input, it reads the data. Otherwise, it sends
    the data to the server via the socket:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天客户端也使用`select`系统调用。它使用套接字连接到服务器，然后在套接字和标准输入上等待事件。如果事件来自标准输入，则读取数据。否则，它通过套接字将数据发送到服务器：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The chat client can be stopped by pressing *Ctrl* + *C* on the terminal.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天客户端可以通过在终端上按下*Ctrl* + *C*来停止。
- en: 'In order to send data to and fro via sockets, both these scripts use a third
    module named `communication`, which has a `send` and a `receive` function. This
    module uses pickle to serialize and deserialize data in the `send` and `receive`
    functions, respectively:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过套接字发送和接收数据，这两个脚本都使用了一个名为`communication`的第三方模块，该模块具有`send`和`receive`函数。该模块分别在`send`和`receive`函数中使用pickle对数据进行序列化和反序列化：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following are some images of the server running and two clients that are
    connected to each other via the chat server:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务器运行的一些图像，以及通过聊天服务器相互连接的两个客户端：
- en: 'Here is the image of client #1 named `andy` connected to the chat server:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是连接到聊天服务器的名为`andy`的客户端#1的图像：
- en: '![Chat server and client using I/O multiplexing with the select module](../Images/image00493.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用select模块进行I/O多路复用的聊天服务器和客户端](../Images/image00493.jpeg)'
- en: 'Chat session of chat client #1 (client name: andy)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天客户端#1的聊天会话（客户端名称：andy）
- en: 'Similarly, here is a client named `betty` who is connected to the chat server
    and is talking to `andy`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是一个名为`betty`的客户端，它连接到聊天服务器并与`andy`进行交谈：
- en: '![Chat server and client using I/O multiplexing with the select module](../Images/image00494.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![使用select模块进行I/O多路复用的聊天服务器和客户端](../Images/image00494.jpeg)'
- en: 'Chat session of chat client #2 (client name: betty)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天客户端#2的聊天会话（客户端名称：betty）
- en: 'Some interesting points of program are listed as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的一些有趣点列举如下：
- en: See how the clients are able to see each other's messages. This happens because
    the server sends the data sent by one client to all the other connected clients.
    Our chat server prefixes the messages with a hash `#` to indicate that this message
    is from another client.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看客户端是如何看到彼此的消息的。这是因为服务器将一个客户端发送的数据发送给所有其他连接的客户端。我们的聊天服务器使用井号`#`作为前缀来指示这条消息来自另一个客户端。
- en: See how the server sends connection and disconnection information of a client
    to all other clients. This informs the clients when another client is connected
    to or disconnected from the session.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看服务器是如何将客户端的连接和断开信息发送给所有其他客户端的。这通知了客户端另一个客户端何时连接到或从会话中断开。
- en: 'The server echoes messages when a client disconnects saying that the client
    *hung up*:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器在客户端断开连接时会回显消息，表示客户端已经“挂断”：
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding chat server and client example is a minor variation of the author's
    own Python recipe in the ASPN Cookbook at [https://code.activestate.com/recipes/531824](https://code.activestate.com/recipes/531824).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的聊天服务器和客户端示例是作者在ASPN Cookbook中的Python配方的一个小变化，网址为[https://code.activestate.com/recipes/531824](https://code.activestate.com/recipes/531824)。
- en: The simple select-based multiplexing is taken to the next level by libraries
    such as Twisted, Eventlet, and Gevent in order to build systems that provide high
    level event-based programming routines to the programmer, typically based on a
    core event loop very similar to the loop of our chat server example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 像Twisted、Eventlet和Gevent这样的库将简单的基于select的多路复用提升到了下一个级别，以构建提供高级基于事件的编程例程的系统，通常基于类似于我们聊天服务器示例的核心事件循环的核心事件循环。
- en: We will discuss the architecture of these frameworks in the following sections.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论这些框架的架构。
- en: Event-driven programming versus Concurrent programming
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动编程与并发编程
- en: The example we saw in the previous section uses the technique of asynchronous
    events as we saw in the chapter on concurrency. This is different from true concurrent
    or parallel programming.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中我们看到的例子使用了异步事件的技术，正如我们在并发章节中看到的那样。这与真正的并发或并行编程是不同的。
- en: Event programming libraries also work on the technique of asynchronous events.
    There is only a single thread of execution in which tasks are interleaved one
    after another based on the events received.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 事件编程库也使用了异步事件的技术。在其中只有一个执行线程，任务根据接收到的事件依次交错执行。
- en: 'In the following example, consider a truly parallel execution of three tasks
    by three threads or processes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，考虑通过三个线程或进程并行执行三个任务：
- en: '![Event-driven programming versus Concurrent programming](../Images/image00495.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![事件驱动编程与并发编程](../Images/image00495.jpeg)'
- en: Parallel execution of three tasks using three threads
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个线程并行执行三个任务
- en: 'Contrast this with what happens when the tasks are executed via Event-driven
    programming as depicted in the following diagram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过事件驱动编程执行任务时发生的情况形成对比，如下图所示：
- en: '![Event-driven programming versus Concurrent programming](../Images/image00496.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![事件驱动编程与并发编程](../Images/image00496.jpeg)'
- en: Asynchronous execution of three tasks in a single thread
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个线程中异步执行三个任务
- en: In the asynchronous model, there is only one single thread of execution with
    tasks executing in an interleaved fashion. Each task gets its own slot of processing
    time in the event loop of the asynchronous processing server, but only one task
    executes at a given time. Tasks yield control back to the loop so that it can
    schedule a different task in the next time slice from the task that is being executed
    currently. As we have seen in [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Writing
    Applications That Scale"), *Writing Applications that Scale*, this is a kind of
    cooperative multitasking.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步模型中，只有一个单一的执行线程，任务以交错的方式执行。每个任务在异步处理服务器的事件循环中有自己的处理时间段，但在任何给定时间只有一个任务在执行。任务将控制权交还给循环，以便它可以在下一个时间片中安排一个不同的任务来执行当前正在执行的任务。正如我们在[第5章](part0040.xhtml#aid-164MG1
    "第5章。编写可扩展的应用程序")中所看到的，“编写可扩展的应用程序”，这是一种协作式多任务处理。
- en: Twisted
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twisted
- en: Twisted is an Event-driven networking engine with support for multiple protocols,
    such as DNS, SMTP, POP3, IMAP, and so on. It also comes with support for writing
    SSH clients and servers, and to build messaging and IRC clients and servers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Twisted是一个事件驱动的网络引擎，支持多种协议，如DNS、SMTP、POP3、IMAP等。它还支持编写SSH客户端和服务器，并构建消息和IRC客户端和服务器。
- en: Twisted also provides a set of patterns (styles) to write common servers and
    clients, such as Web Server/Client (HTTP), Publish/Subscribe patterns, Messaging
    Clients and Servers (SOAP/XML-RPC), and others.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Twisted还提供了一组模式（风格）来编写常见的服务器和客户端，例如Web服务器/客户端（HTTP）、发布/订阅模式、消息客户端和服务器（SOAP/XML-RPC）等。
- en: It uses the Reactor design pattern, which multiplexes and dispatches events
    from multiple sources to their event handlers in a single thread.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了反应器设计模式，将来自多个来源的事件多路复用并分派给它们的事件处理程序在一个单线程中。
- en: It receives messages, requests, and connections coming from multiple concurrent
    clients, and processes these posts sequentially using event handlers without requiring
    concurrent threads or processes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收来自多个并发客户端的消息、请求和连接，并使用事件处理程序顺序处理这些帖子，而无需并发线程或进程。
- en: 'The reactor pseudo-code looks, approximately, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 反应器伪代码大致如下：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Twisted uses callbacks to call event handlers as and when an event happens.
    To handle a specific event, a callback is registered for that event. Callbacks
    can be used for regular processing, and also for managing exceptions (errbacks).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Twisted使用回调来在事件发生时调用事件处理程序。为了处理特定事件，为该事件注册一个回调。回调可以用于常规处理，也可以用于管理异常（错误回调）。
- en: Like the `asyncio` module, Twisted uses an object such as futures in order to
    wrap the results of a task execution, whose actual results are still not available.
    In Twisted, these objects are called **Deferreds**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与`asyncio`模块一样，Twisted使用类似于futures的对象来包装任务执行的结果，其实际结果仍然不可用。在Twisted中，这些对象称为**Deferreds**。
- en: 'Deferred objects have a pair of callback chains: one for processing results
    (callbacks) and one for managing errors (errbacks). When the result of an execution
    is obtained, a Deferred object is created, and its callbacks and/or errbacks are
    called in the order in which they were added.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟对象有一对回调链：一个用于处理结果（回调），另一个用于管理错误（errbacks）。当获得执行结果时，将创建一个延迟对象，并按照添加的顺序调用其回调和/或errbacks。
- en: 'Here is an architecture diagram of Twisted, showing the high-level components:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Twisted的架构图，显示了高级组件：
- en: '![Twisted](../Images/image00497.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Twisted](../Images/image00497.jpeg)'
- en: Twisted – Core Components
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 扭曲 - 核心组件
- en: Twisted – a simple web client
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Twisted - 一个简单的Web客户端
- en: 'The following is a simple example of a web HTTP client using Twisted, fetching
    a given URL and saving its contents to a specific filename:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Twisted的简单Web HTTP客户端的示例，获取给定URL并将其内容保存到特定文件名：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see in the preceding code, the `getPage` method returns a deferred,
    and not the data of the URL. To the deferred, we add two callbacks: one for processing
    the data (the `save_page` function) and another for handling errors (the `handle_error`
    function). The `addBoth` method of the deferred adds a single function as both
    callback and errback.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，`getPage`方法返回一个延迟对象，而不是URL的数据。对于延迟对象，我们添加了两个回调：一个用于处理数据（`save_page`函数），另一个用于处理错误（`handle_error`函数）。延迟的`addBoth`方法将一个函数添加为回调和errback。
- en: The event processing is started by running the reactor. In the `finish_processing`
    callback, which is called at the end, the reactor is stopped. Since event handlers
    are called in the order that they are added, this function will be called only
    at the very end.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理是通过运行反应器来启动的。在结束时调用`finish_processing`回调，停止反应器。由于事件处理程序是按添加顺序调用的，因此此函数只会在最后调用。
- en: 'When the reactor is run the following events happen:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当反应器运行时，会发生以下事件：
- en: The page is fetched and the deferred is created.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面被获取并创建了延迟。
- en: The callbacks are called in order on the deferred. First the `save_page` function
    is called, which saves contents of the page to the `content.html` file. Then a
    `handle_error` event handler is called, which prints any error string.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调按顺序在延迟上调用。首先调用`save_page`函数，将页面内容保存到`content.html`文件中。然后调用`handle_error`事件处理程序，打印任何错误字符串。
- en: Finally, `finish_processing` is called, which stops the reactor and the event
    processing ends, exiting the program.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，调用`finish_processing`，停止反应器，事件处理结束，退出程序。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, Twisted is not yet available for Python3, so the preceding
    code is written for Python2.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Twisted尚未适用于Python3，因此前面的代码是针对Python2编写的。
- en: 'When you run the code, you will see that the following output is produced:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您运行代码时，您会看到产生以下输出：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Chat Server using Twisted
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Twisted的聊天服务器
- en: Let's now see how we can write a simple chat server in Twisted on lines similar
    to our chat server using the `select` module.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在Twisted上编写一个简单的聊天服务器，类似于我们使用`select`模块的聊天服务器。
- en: In Twisted, servers are built by implementing protocols and protocol factories.
    A protocol class typically inherits from the Twisted `Protocol` class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twisted中，服务器是通过实现协议和协议工厂来构建的。协议类通常继承自Twisted的`Protocol`类。
- en: A factory is nothing but a class that serves as a factory pattern for protocol
    objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂只是作为协议对象的工厂模式的类。
- en: 'Using this, here is our chat server using Twisted:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，这是我们使用Twisted的聊天服务器：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our chat server is a bit more sophisticated than the one before as it performs
    the following additional steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天服务器比以前的更复杂，因为它执行以下附加步骤：
- en: It has a separate handshake protocol using the special `<handshake>` message.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它有一个单独的握手协议，使用特殊的`<handshake>`消息。
- en: When a client connects, it is broadcast to other clients informing them of the
    client's name and connection details.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端连接时，会向其他客户端广播通知他们客户端的名称和连接详细信息。
- en: When a client disconnects, other clients are informed about this.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端断开连接时，其他客户端会收到通知。
- en: The chat client also uses Twisted and uses two protocols – namely a `ChatClientProtocol`
    for communication with the server and a `StdioClientProtocol` for reading data
    from standard input and echoing data received from the server to the standard
    output.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天客户端还使用Twisted，并使用两个协议 - 分别是用于与服务器通信的`ChatClientProtocol`和用于从标准输入读取数据并将从服务器接收的数据回显到标准输出的`StdioClientProtocol`。
- en: The latter protocol also connects the former one to its input, so that any data
    that is received on the standard input is sent to the server as a chat message.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 后一个协议还将前一个协议连接到其输入，以便将接收到的任何数据发送到服务器作为聊天消息。
- en: 'Take a look at the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are some screenshots of the two clients `andy` and `betty` communicating
    using this chat server and client:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个客户端`andy`和`betty`使用这个聊天服务器和客户端进行通信的一些屏幕截图：
- en: '![Chat Server using Twisted](../Images/image00498.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![使用Twisted的聊天服务器](../Images/image00498.jpeg)'
- en: 'Chat client using Twisted chat server – session for client #1 (andy)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Twisted的聊天客户端 - 客户端＃1（andy）的会话
- en: 'Here is the second session, for the client betty:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个会话，针对客户端betty：
- en: '![Chat Server using Twisted](../Images/image00499.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用Twisted的聊天服务器](../Images/image00499.jpeg)'
- en: 'Chat client using Twisted chat server – session for client #2 (betty)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Twisted的聊天客户端 - 客户端＃2（betty）的会话
- en: You can follow the flow of the conversation by alternately looking at the screenshots.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过交替查看屏幕截图来跟踪对话的流程。
- en: Note the connection and disconnection messages sent by the server when user
    betty connects and user andy disconnects respectively.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，服务器在用户betty连接和用户andy断开连接时发送的连接和断开连接消息。
- en: Eventlet
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eventlet
- en: Eventlet is another well known networking library in the Python world that allows
    one to write Event-driven programs using the same concept of asynchronous execution.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Eventlet是Python世界中另一个知名的网络库，允许使用异步执行的概念编写事件驱动程序。
- en: Eventlet uses co-routines for this purpose with the help of a set of so-called
    *green threads*, which are light-weight user-space threads that perform cooperative
    multitasking.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Eventlet使用协程来执行这些任务，借助一组所谓的*绿色线程*，这些线程是轻量级的用户空间线程，执行协作式多任务。
- en: Eventlet uses an abstraction over a set of green threads, the `Greenpool` class,
    in order to perform its tasks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Eventlet使用一组绿色线程的抽象，`Greenpool`类，以执行其任务。
- en: The `Greenpool` class runs a predefined set of `Greenpool` threads (default
    is `1000`), and provides ways to map functions and callables to the threads in
    different ways.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greenpool`类运行预定义的一组`Greenpool`线程（默认为`1000`），并提供不同方式将函数和可调用对象映射到线程的方法。'
- en: 'Here is the multiuser chat server rewritten using Eventlet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Eventlet重写的多用户聊天服务器：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This server can be used with the Twisted chat client that we've seen in the
    previous example, and behaves in exactly the same way. Hence, we will not show
    running examples of this server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器可以与我们在之前示例中看到的Twisted聊天客户端一起使用，并且行为完全相同。因此，我们不会展示此服务器的运行示例。
- en: The Eventlet library internally uses `greenlets`, a package that provides green
    threads on Python runtime. We will see greenlet and a related library, Gevent,
    in the following section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Eventlet库在内部使用`greenlets`，这是一个在Python运行时上提供绿色线程的包。我们将在下一节中看到greenlet和一个相关库Gevent。
- en: Greenlets and Gevent
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Greenlets和Gevent
- en: Greenlet is a package that provides a version of green or microthreads on top
    of the Python interpreter. It is inspired by Stackless, a version of CPython that
    supports microthreads called stacklets. However, greenlets are able to run on
    the standard CPython runtime.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Greenlet是一个在Python解释器之上提供绿色或微线程版本的包。它受Stackless的启发，Stackless是支持称为stacklets的微线程的CPython的一个版本。然而，greenlets能够在标准CPython运行时上运行。
- en: Gevent is a Python networking library providing high-level synchronous API on
    top of `libev`, the event library written in C.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Gevent是一个Python网络库，提供在C语言编写的`libev`之上的高级同步API。
- en: Gevent is inspired by gevent, but it features a more consistent API and better
    performance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Gevent受到gevent的启发，但它具有更一致的API和更好的性能。
- en: Like Eventlet, gevent does a lot of monkey patching on system libraries to provide
    support for cooperative multitasking. For example, gevent comes with its own sockets,
    just like Eventlet does.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与Eventlet一样，gevent对系统库进行了大量的猴子补丁，以提供协作式多任务支持。例如，gevent自带自己的套接字，就像Eventlet一样。
- en: Unlike Eventlet, gevent also requires explicit monkey patching to be done by
    the programmer. It provides a method to do this on the module itself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与Eventlet不同，gevent还需要程序员显式进行猴子补丁。它提供了在模块本身上执行此操作的方法。
- en: 'Without further ado, let us look at how the multiuser chat server using gevent
    looks like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们看看使用gevent的多用户聊天服务器是什么样子的：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code for the gevent-based chat server is almost the same as the one using
    Eventlet. The reason for this is that both work in very similar ways by handling
    control to a callback function when a new connection is made. In both cases the
    callback function is named `new_chat_channel`, which has the same functionality
    and hence very similar code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 基于gevent的聊天服务器的代码几乎与使用Eventlet的代码相同。原因是它们都通过在建立新连接时将控制权交给回调函数的方式以非常相似的方式工作。在这两种情况下，回调函数的名称都是`new_chat_channel`，具有相同的功能，因此代码非常相似。
- en: 'The differences between the two are as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的区别如下：
- en: gevent provides its own TCP server class—`StreamingServer`–so we use that instead
    of listening on the module directly
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gevent提供了自己的TCP服务器类——`StreamingServer`，因此我们使用它来代替直接监听模块
- en: In the gevent server, for every connection the `new_chat_channel` handler is
    invoked, hence the participant set is managed there
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在gevent服务器中，对于每个连接，都会调用`new_chat_channel`处理程序，因此参与者集合在那里进行管理
- en: Since the gevent server has its own event loop, there is no need to create a
    while loop for listening for incoming connections as we had to do with Eventlet
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于gevent服务器有自己的事件循环，因此无需创建用于监听传入连接的while循环，就像我们在Eventlet中所做的那样
- en: This example works exactly the same as the previous ones and works with the
    Twisted chat client.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与之前的示例完全相同，并且与Twisted聊天客户端一起使用。
- en: Microservice architecture
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Microservice architecture is an architectural style of developing a single application
    as a suite of small independent services, each running in its own process and
    communicating via light-weight mechanisms—typically, using HTTP protocol.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是开发单个应用程序的一种架构风格，将其作为一套小型独立服务运行，每个服务在自己的进程中运行，并通过轻量级机制进行通信，通常使用HTTP协议。
- en: Microservices are independently deployable components, and usually, have zero
    or minimalistic central management or configuration.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是独立部署的组件，通常没有或者只有极少的中央管理或配置。
- en: Microservices can be thought of as a specific implementation style for **Service
    Oriented Architectures** (**SOA**), where, instead of building a monolith application
    top-down, the application is built as a dynamic group of mutually interacting,
    independent services.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以被视为**面向服务的架构**（**SOA**）的特定实现风格，其中应用程序不是自上而下构建为单体应用程序，而是构建为相互交互的独立服务的动态组。
- en: 'Traditionally, enterprise applications were built in a monolithic pattern,
    typically consisting of these three layers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，企业应用程序是以单块模式构建的，通常由这三个层组成：
- en: A client-side User Interface (UI) layer consisting of HTML and JavaScript.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由HTML和JavaScript组成的客户端用户界面（UI）层。
- en: A server-side application consisting of the business logic.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由业务逻辑组成的服务器端应用程序。
- en: A database and data access layer, which holds the business data.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库和数据访问层，保存业务数据。
- en: On the other hand, a microservices architecture will split this layer into multiple
    services. For example, the business logic, instead of being in a single application,
    will be split into multiple component services, whose interactions define the
    logic flow inside the application. The services might query a single database
    or independent local databases with the latter configuration being more common.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，微服务架构将这一层拆分为多个服务。例如，业务逻辑不再在单个应用程序中，而是拆分为多个组件服务，它们的交互定义了应用程序内部的逻辑流程。这些服务可能查询单个数据库或独立的本地数据库，后者的配置更常见。
- en: Data in microservices architectures are usually processed and returned in the
    form of document objects – typically encoded in JSON.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构中的数据通常以文档对象的形式进行处理和返回 - 通常以JSON编码。
- en: 'The following schematic diagram illustrates the difference of a monolithic
    architecture from a microservices one:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示意图说明了单体架构与微服务架构的区别：
- en: '![Microservice architecture](../Images/image00500.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![微服务架构](../Images/image00500.jpeg)'
- en: Monolithic (left) vs Microservices (right) Architecture
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构（左）与微服务架构（右）
- en: Microservice frameworks in Python
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的微服务框架
- en: 'With microservices being more of a philosophy or style of architecture, there
    are no distinct classes of software frameworks that one can say is the right fit
    for them. However, one can still make a few educated projections for the properties
    that a framework should have for it being a good choice for building a microservices
    architecture for your web application in Python. These properties include the
    following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务更多地是一种哲学或架构风格，没有明确的软件框架类别可以说是它们的最佳选择。然而，人们仍然可以对框架应该具有的属性做出一些合理的预测，以便为在Python中构建Web应用程序的微服务架构选择一个好的框架。这些属性包括以下内容：
- en: The component architecture should be flexible. The framework should not be rigid
    in the component choices that it stipulates to make the different parts of the
    system work.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件架构应该是灵活的。框架不应该在规定使系统的不同部分工作的组件选择方面变得死板。
- en: The core of the framework should be lightweight. This makes sense, since if
    we start off with, say, a lot of dependencies for the microservices framework
    itself, the software starts feeling heavy right in the beginning. This may cause
    issues in deployment, testing, and so on.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的核心应该是轻量级的。这是有道理的，因为如果我们从头开始，比如说，微服务框架本身有很多依赖，软件在一开始就会感觉很沉重。这可能会导致部署、测试等方面出现问题。
- en: The framework should support zero or minimalistic configuration. Microservices
    architectures are usually configured automatically (zero configuration) or with
    a minimal set of configuration inputs that are available at one place. Usually
    the configuration is itself available as a microservice for other services to
    query and make the sharing of configuration easy, consistent, and scalable.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架应该支持零或最小化配置。微服务架构通常是自动配置的（零配置）或具有一组最小配置输入，这些输入在一个地方可用。通常，配置本身作为微服务可供其他服务查询，并使配置共享变得简单、一致和可扩展。
- en: It should make it very easy to take an existing piece of business logic, say
    coded as a class or a function, and turn it into an HTTP or RCP service. This
    allows reuse and smart refactoring of code.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该非常容易将现有的业务逻辑，比如编码为类或函数的业务逻辑，转换为HTTP或RCP服务。这允许代码的重用和智能重构。
- en: If you use these principles and look around in the Python software ecosystem,
    you will figure out that a few web application frameworks fit the bill, whereas
    a few don't.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循这些原则并在Python软件生态系统中寻找，您会发现一些Web应用程序框架符合要求，而另一些则不符合。
- en: For example, Flask and its single-file counterpart Bottle are good candidates
    for a microservices framework due to their minimal footprint, small core, and
    simple configuration.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Flask及其单文件对应物Bottle由于其最小的占用空间、小的核心和简单的配置，是微服务框架的良好选择。
- en: A framework such as Pyramid can also be used for a microservices architecture
    since it promotes flexibility of choice of components and eschews tight integration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Pyramid等框架也可以用于微服务架构，因为它促进了组件选择的灵活性，并避免了紧密集成。
- en: A more sophisticated web framework such as Django makes a poor choice for a
    microservices framework due to exactly the opposite reasons–tight vertical integration
    of components, lack of flexibility in choosing components, complex configuration,
    and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 像Django这样更复杂的Web框架由于正好相反的原因 - 组件的紧密垂直集成、在选择组件方面缺乏灵活性、复杂的配置等等，因此不适合作为微服务框架的选择。
- en: Another framework that is written specifically for implementing microservices
    in Python is Nameko. Nameko is geared towards testability of the application,
    and it provides support for different protocols for communication such as HTTP,
    RPC (over AMQP)—a Pub-Sub system, and a Timer service.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个专门用于在Python中实现微服务的框架是Nameko。Nameko旨在测试应用程序，并提供对不同通信协议的支持，如HTTP、RPC（通过AMQP）-
    发布-订阅系统和定时器服务。
- en: We will not be going into details of these frameworks. On the other hand, we
    will take a look at architecting and designing a real-life example of a web application
    using microservices.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍这些框架。另一方面，我们将看一下如何使用微服务来设计和构建一个真实的Web应用程序示例。
- en: Microservices example – restaurant reservation
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务示例 - 餐厅预订
- en: Let us take a real-life example for a Python web application, and try and design
    it as a set of microservices.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个Python Web应用程序的真实例子为例，尝试将其设计为一组微服务。
- en: Our application is a restaurant reservation app that helps users make a reservation
    for a certain number of people at a specific time in a restaurant close to their
    current location. Assume that reservations are only done for the same day.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用是一个餐厅预订应用程序，帮助用户在靠近他们当前位置的餐厅预订特定时间的一定人数。假设预订只能在同一天进行。
- en: 'The application needs to do the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要执行以下操作：
- en: Return a list of restaurants open for business at the time for which the user
    wants to make the reservation.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回在用户想要进行预订的时间营业的餐厅列表。
- en: For a given restaurant, return enough meta information, such as cuisine choices,
    rating, pricing, and so on, and allow the user to filter the hotels based on their
    criteria.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于给定的餐厅，返回足够的元信息，如菜肴选择、评分、定价等，并允许用户根据其标准筛选酒店。
- en: Once the user has made a choice, allow them to make a reservation on the selected
    restaurant for a certain number of people for a given time.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户做出选择，允许他们为选定的餐厅预订一定数量的座位，预订时间。
- en: Each of these requirements is granular enough to have their own microservice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求中的每一个都足够细粒度，可以拥有自己的微服务。
- en: 'Hence, our application will be designed with the following set of microservices:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的应用程序将设计为以下一组微服务：
- en: A service that uses the user's location, and returns a list of restaurants open
    for business, and which support the online reservation API.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户的位置，并返回一份营业中的餐厅列表，并支持在线预订API的服务。
- en: A second service that retrieves metadata for a given hotel, given the restaurant
    ID. The application can use this metadata to compare against the user's criteria
    to see if it's a match.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个服务根据餐厅ID检索给定酒店的元数据。应用程序可以使用此元数据与用户的标准进行比较，以查看是否匹配。
- en: A third service, which, given a restaurant ID, the user's information, the number
    of seats required, and the time of reservation, uses the reservation API to make
    a reservation for seats, and returns the status.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个服务，根据餐厅ID、用户信息、所需座位数和预订时间，使用预订API进行座位预订，并返回状态。
- en: The core parts of the application logic now fit these three microservices. Once
    they are implemented, the plumbing—in terms of calling these services and performing
    a reservation—will happen in the application logic directly.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序逻辑的核心部分现在适合这三个微服务。一旦它们被实现，调用这些服务并执行预订的管道将直接发生在应用程序逻辑中。
- en: We will not be showing any code for this application as that is a project in
    its own, but we will show the reader how the microservices look like in terms
    of their APIs and return data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会展示此应用程序的任何代码，因为那是一个独立的项目，但我们将向读者展示微服务的API和返回数据是什么样子的。
- en: '![Microservices example – restaurant reservation](../Images/image00501.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![微服务示例-餐厅预订](../Images/image00501.jpeg)'
- en: Architecture of restaurant reservation application using microservices
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务的餐厅预订应用程序架构
- en: 'A microservice usually returns data in the form of JSON. For example, our first
    service that returns a list of restaurants would return a JSON similar to the
    one that follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常以JSON形式返回数据。例如，我们的第一个返回餐厅列表的服务将返回类似于以下内容的JSON：
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second service, which returns restaurant metadata, would mostly return
    a JSON like this one:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 返回餐厅元数据的第二个服务，大多会返回类似于以下内容的JSON：
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the interaction for the third one, which does a booking given the restaurant
    ID:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第三个互动，根据餐厅ID进行预订：
- en: Since this service needs the user to provide information for the reservation,
    it needs a JSON payload with the details of booking. Hence, this is best done
    as an HTTP POST call.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此服务需要用户提供预订信息，因此需要一个包含预订详细信息的JSON有效负载。因此，最好以HTTP POST调用进行。
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The service in this case will use the following given payload as the POST data:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，该服务将使用以下给定的有效负载作为POST数据：
- en: '[PRE16]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It will return a JSON like the following as a response:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回类似于以下内容的JSON作为响应：
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this design in place, it is not very difficult to implement the application
    in a framework of your choice, whether it be Flask, Bottle, Nameko, or anything
    else.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的设计，很容易在您选择的框架中实现应用程序，无论是Flask、Bottle、Nameko还是其他任何东西。
- en: Microservices – advantages
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务-优势
- en: 'So what are the advantages of using microservices over a monolithic application?
    Let us take a look at some of the important ones:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 那么使用微服务而不是单体应用程序有哪些优势呢？让我们看看其中一些重要的优势：
- en: Microservices enhance separation of concern by splitting the application logic
    into multiple services. This improves cohesion, and decreases coupling. There
    is no need for a top-down, upfront design of the system, since the business logic
    is not in a single place. Instead, the architect can focus on the interplay and
    communication between the microservices and the application, and let the design
    and architecture of the microservices itself emerge iteratively through refactoring.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务通过将应用程序逻辑拆分为多个服务来增强关注点分离。这提高了内聚性，减少了耦合。由于业务逻辑不在一个地方，因此无需对系统进行自上而下的预先设计。相反，架构师可以专注于微服务和应用程序之间的相互作用和通信，让微服务的设计和架构通过重构逐步出现。
- en: Microservices improve testability, since now each part of the logic is independently
    testable as a separate service, and hence, is easy to isolate from other parts,
    and test.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务改善了可测试性，因为现在逻辑的每个部分都可以作为独立的服务进行独立测试，因此很容易与其他部分隔离并进行测试。
- en: Teams can be organized around the business capabilities rather than around tiers
    of the application or technology layers. Since each microservice includes logic,
    data, and deployment, companies using microservices encourage cross-functional
    roles. This helps to build a more agile organization.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队可以围绕业务能力而不是应用程序或技术层的层次进行组织。由于每个微服务都包括逻辑、数据和部署，使用微服务的公司鼓励跨功能角色。这有助于构建更具敏捷性的组织。
- en: Microservices encourage decentralized data. Usually, each service will have
    its own local database or data store instead of the central database that is preferred
    by monolithic applications.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务鼓励去中心化数据。通常，每个服务都将拥有自己的本地数据库或数据存储，而不是单体应用程序所偏爱的中央数据库。
- en: Microservices facilitate continuous delivery and integration, and fast deployments.
    Since a change to business logic might often need only a small change in one or
    a few services, testing and redeployment can be often done in tight cycles, and
    in most cases, can be fully automated.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务促进了持续交付和集成，以及快速部署。由于对业务逻辑的更改通常只需要对一个或几个服务进行小的更改，因此测试和重新部署通常可以在紧密的周期内完成，并且在大多数情况下可以完全自动化。
- en: Pipe and Filter architectures
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道和过滤器架构
- en: Pipe and Filter is a simple architectural style, which connects a number of
    components that process a stream of data, each connected to the next component
    in the processing pipeline via a **Pipe**.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和过滤器是一种简单的架构风格，它连接了一些处理数据流的组件，每个组件通过**管道**连接到处理管道中的下一个组件。
- en: The Pipe and Filter architecture is inspired by the Unix technique of connecting
    the output of an application to the input of another via pipes on the shell.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和过滤器架构受到了Unix技术的启发，该技术通过shell上的管道将一个应用程序的输出连接到另一个应用程序的输入。
- en: 'The Pipe and Filter architecture consists of one or more data sources. The
    data source is connected to data filters via pipes. Filters process the data they
    receive, passing them to other filters in the pipeline. The final data is received
    at a **Data Sink**:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和过滤器架构由一个或多个数据源组成。数据源通过管道连接到数据过滤器。过滤器处理它们接收到的数据，并将它们传递给管道中的其他过滤器。最终的数据接收到一个**数据接收器**：
- en: '![Pipe and Filter architectures](../Images/image00502.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![管道和过滤器架构](../Images/image00502.jpeg)'
- en: Pipe and Filter Architecture
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和过滤器架构
- en: Pipe and filter are used commonly for applications that perform a lot of data
    processing such as data analytics, data transformation, metadata extraction, and
    so on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和过滤器通常用于执行大量数据处理的应用程序，如数据分析、数据转换、元数据提取等。
- en: The filters can be running on the same machine, and they use actual Unix pipes
    or shared memory for communication. However, in large systems, these usually run
    on separate machines, and the pipes need not be actual pipes, but any kind of
    data channel such as sockets, shared memory, queues, and the like.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器可以在同一台机器上运行，并且它们使用实际的Unix管道或共享内存进行通信。然而，在大型系统中，这些通常在单独的机器上运行，管道不需要是实际的管道，而可以是任何类型的数据通道，如套接字、共享内存、队列等。
- en: Multiple filter pipelines can be connected together to perform complex data
    processing and data staging.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 可以连接多个过滤器管道以执行复杂的数据处理和数据分段。
- en: A very good example of a Linux application that works using this architecture
    is `gstreamer`—the multimedia processing library that can perform a number of
    tasks on multimedia video and audio including play, record, edit, and stream.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的使用这种架构的Linux应用程序的例子是`gstreamer`——这是一个多媒体处理库，可以对多媒体视频和音频执行多项任务，包括播放、录制、编辑和流式传输。
- en: Pipe and Filter in Python
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的管道和过滤器
- en: In Python, we encounter pipes in their most pure form in the multiprocessing
    module. The multiprocessing module provides Pipes as a way to communicate from
    one process to another.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们在多进程模块中以最纯粹的形式遇到管道。多进程模块提供了管道作为一种从一个进程到另一个进程进行通信的方式。
- en: A pipe is created as a pair of parent and child connections. What is written
    on one side of the connection can be read on the other side and vice versa.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个父子连接对的管道。在连接的一侧写入的内容可以在另一侧读取，反之亦然。
- en: This allows us to build very simple pipelines of data processing.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够构建非常简单的数据处理管道。
- en: 'For example, on Linux, the number of words in a file can be computed by this
    series of commands:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Linux上，可以通过以下一系列命令计算文件中的单词数：
- en: '[PRE18]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will write a simple program that mimics this pipeline using the multiprocessing
    module:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用多进程模块编写一个简单的程序，模拟这个管道：
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is an analysis of the workflow:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是工作流程的分析：
- en: A pipe is created, and two connections are obtained.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个管道，并获得了两个连接。
- en: The `read` function is executed as a process, passing one end of the pipe (child)
    and the filename to be read.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`read`函数作为一个进程执行，传递管道的一端（子进程）和要读取的文件名。'
- en: This process reads the file, writing the data to the connection.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该进程读取文件，将数据写入连接。
- en: The `words` function is executed as a second process, passing the other end
    of the pipe to it.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`words`函数作为第二个进程执行，将管道的另一端传递给它。'
- en: When this function executes as a process, it reads the data from the connection,
    and prints the number of words.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当此函数作为一个进程执行时，它从连接中读取数据，并打印单词的数量。
- en: 'The following screenshot shows the output of both the shell command and the
    preceding program on the same file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了相同文件上的shell命令和前面程序的输出：
- en: '![Pipe and Filter in Python](../Images/image00503.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![Python中的管道和过滤器](../Images/image00503.jpeg)'
- en: Output of a shell command using pipes and its equivalent Python program
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道和其等效的Python程序的shell命令的输出
- en: You do not need to use an object that looks like an actual pipe in order to
    create pipelines. On the other hand, generators in Python provide an excellent
    way to create a set of callables, which call each other, and consume and process
    each other's data, producing a pipeline of data processing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要使用看起来像实际管道的对象来创建管道。另一方面，Python中的生成器提供了一个很好的方式来创建一组可调用对象，它们相互调用，消耗和处理彼此的数据，产生数据处理的管道。
- en: 'Here is the same example as the previous one, rewritten to use generators,
    and this time, to process all the files in the folder matching a particular pattern:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与前一个示例相同的示例，重写为使用生成器，并且这次是处理文件夹中匹配特定模式的所有文件：
- en: '[PRE20]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is a screenshot of the output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出的屏幕截图：
- en: '![Pipe and Filter in Python](../Images/image00504.jpeg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![Python中的管道和过滤器](../Images/image00504.jpeg)'
- en: Output of a pipeline using generators that print the word count of Python programs
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器输出管道的输出，打印Python程序的单词计数
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'One can verify the output of a program such as the preceding one using this
    command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令验证类似于前面程序的输出：
- en: '[PRE21]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is another program that uses another couple of data filtering generators
    to build a program, which watches files matching a specific pattern and prints
    information about the most recent file—something similar to what is done by the
    watch program on Linux:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个程序，它使用另外两个数据过滤生成器来构建一个程序，该程序监视与特定模式匹配的文件并打印有关最近文件的信息，类似于Linux上的watch程序所做的事情：
- en: '[PRE22]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The details of this last program should be self-explanatory to the reader.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后一个程序的细节应该对读者是不言自明的。
- en: 'Here is the output of our program on the console, watching over Python source
    files:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在控制台上程序的输出，监视Python源文件：
- en: '![Pipe and Filter in Python](../Images/image00505.jpeg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![Python中的管道和过滤器](../Images/image00505.jpeg)'
- en: Output of the program that watches over recently modified Python source files
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 监视最近修改的Python源文件的程序输出
- en: 'If we create an empty Python source file, say `example.py`, the output changes
    in two seconds:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个空的Python源文件，比如`example.py`，两秒后输出会发生变化：
- en: '![Pipe and Filter in Python](../Images/image00506.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![Python中的管道和过滤器](../Images/image00506.jpeg)'
- en: Output of the watch program changes, always showing the most recently modified
    file
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 监视程序更改的输出，始终显示最近修改的文件
- en: The underlying technique of using generators (co-routines) to build such pipelines
    is to connect the output of one generator to the input of the next. By connecting
    many such generators in a series, one can build data processing pipelines that
    vary in complexity from simple to complex.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器（协程）构建这样的管道的基本技术是将一个生成器的输出连接到下一个生成器的输入。通过在系列中连接许多这样的生成器，可以构建从简单到复杂的数据处理管道。
- en: Of course, one can use a number of techniques for building pipelines apart from
    this. Some common choices are producer-consumer tasks connected using queues,
    which can use threads or processes. We have seen examples of this in the chapter
    on scalability.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了这些之外，我们还可以使用许多技术来构建管道。一些常见的选择是使用队列连接的生产者-消费者任务，可以使用线程或进程。我们在可扩展性章节中看到了这方面的例子。
- en: Microservices can also build simple processing pipelines by connecting the input
    of one microservice to the output of another.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务还可以通过将一个微服务的输入连接到另一个微服务的输出来构建简单的处理管道。
- en: In the Python third-party software ecosystem, there are a number of modules
    and frameworks that allow you to build complex data pipelines. Celery, though
    a task queue, can be used to build simple batch processing workflows with limited
    pipeline support. Pipelining is not the strong feature of celery, but it has limited
    support for chaining tasks that can be used for this purpose.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python第三方软件生态系统中，有许多模块和框架可以让您构建复杂的数据管道。Celery虽然是一个任务队列，但可以用于构建具有有限管道支持的简单批处理工作流。管道不是Celery的强项，但它对于链接任务具有有限的支持，可以用于此目的。
- en: Luigi is another robust framework that is written for complex, long-running
    batch processing jobs that require a pipe and filter architecture. Luigi comes
    with built-in support for Hadoop jobs, so it makes it a good choice for building
    data analytics pipelines.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Luigi是另一个强大的框架，专为需要管道和过滤器架构的复杂、长时间运行的批处理作业而编写。Luigi具有内置的支持Hadoop作业的功能，因此它是构建数据分析管道的良好选择。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at some common architectural patterns of building
    software. We started with the Model View Controller architecture, and looked at
    examples in Django and Flask. You learned about the components of an MVC architecture,
    and learned that Django implements a variant of MVC using templates.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些构建软件的常见架构模式。我们从模型视图控制器架构开始，并在Django和Flask中看了一些例子。您了解了MVC架构的组件，并了解到Django使用模板实现了MVC的变体。
- en: We looked at Flask as an example of a micro framework that implements the minimal
    footprint of a web application by using a plugin architecture with additional
    services that can be added on.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以Flask作为一个微框架的例子，它通过使用插件架构实现了Web应用程序的最小占地面积，并可以添加额外的服务。
- en: We went on to discuss the Event-driven programming architecture, which is a
    kind of asynchronous programming using co-routines and events. We started with
    a multiuser chat example using the `select` module in Python. From there, we went
    on to discuss larger frameworks and libraries.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续讨论事件驱动的编程架构，这是一种使用协程和事件的异步编程。我们从一个在Python中使用`select`模块的多用户聊天示例开始。然后，我们继续讨论更大的框架和库。
- en: We discussed the architecture of Twisted and its components. We also discussed
    Eventlet and its close cousin gevent. For each of these frameworks, we saw an
    implementation of the multiuser chat server.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了Twisted的架构和其组件。我们还讨论了Eventlet及其近亲gevent。对于这些框架，我们看到了多用户聊天服务器的实现。
- en: Next, we took up microservices as an architecture, which builds scalable services
    and deployments by splitting the core business logic across multiple services.
    We designed an example of a restaurant reservation application using microservices,
    and briefly looked at the landscape of Python web frameworks, which can be used
    to build microservices.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以微服务作为架构，通过将核心业务逻辑分割到多个服务中来构建可扩展的服务和部署。我们设计了一个使用微服务的餐厅预订应用程序的示例，并简要介绍了可以用于构建微服务的Python
    Web框架的情况。
- en: Towards the end of the chapter, we saw the architecture of using Pipes and Filters
    for serial and scalable data processing. We built a simple example of actual pipes
    using the multiprocessing module in Python, which mimicked a Unix pipe command.
    We then looked at the technique of building pipelines using generators, and saw
    couple of examples. We summarized techniques for building pipelines and frameworks
    available in the Python third-party software ecosystem.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们看到了使用管道和过滤器进行串行和可扩展数据处理的架构。我们使用Python中的多进程模块构建了一个实际管道的简单示例，模仿了Unix的管道命令。然后，我们看了使用生成器构建管道的技术，并看了一些例子。我们总结了构建管道和Python第三方软件生态系统中可用框架的技术。
- en: This brings us to the end of the chapter on application architectures. In the
    next chapter, we will look at deployability - namely the aspect of deploying software
    to environments such as production systems.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是应用架构章节的结束。在下一章中，我们将讨论可部署性-即将软件部署到生产系统等环境的方面。
