- en: Implementing Asynchronous Programming in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中实现异步编程
- en: This chapter will introduce you to the `asyncio` module in Python. It will cover
    the idea behind this new concurrency module, which utilizes event loops and coroutines
    and provides an API that is as readable as synchronous code. In this chapter,
    we will also discuss the implementation of asynchronous programming, in addition
    to threading and multiprocessing through the `concurrent.futures` module. During
    this process, we will cover the application of asynchronous programming via the
    most common uses of `asyncio`, including asynchronous input/output and avoiding
    blocking tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍Python中的`asyncio`模块。它将涵盖这个新并发模块背后的理念，该模块利用事件循环和协程，并提供了一个与同步代码一样可读的API。在本章中，我们还将讨论异步编程的实现，以及通过`concurrent.futures`模块进行线程和多进程处理。在此过程中，我们将涵盖通过`asyncio`的最常见用法来应用异步编程，包括异步输入/输出和避免阻塞任务。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The fundamental elements of implementing asynchronous programming using `asyncio`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`实现异步编程的基本要素
- en: The framework for asynchronous programming provided by `asyncio`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`提供的异步编程框架'
- en: The `concurrent.futures` module and its usage, in respect to `asyncio`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures`模块及其在`asyncio`中的使用'
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is the list a prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的先决条件列表：
- en: Ensure that you have Python 3 installed on your computer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的计算机上安装了Python 3
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)下载GitHub存储库
- en: During this chapter, we will be working with the subfolder titled `Chapter10`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用名为`Chapter10`的子文件夹进行工作
- en: Check out the following video to see the Code in Action: [http://bit.ly/2TAtTrA](http://bit.ly/2TAtTrA)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际运行情况：[http://bit.ly/2TAtTrA](http://bit.ly/2TAtTrA)
- en: The asyncio module
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`asyncio`模块'
- en: As you saw in the previous chapter, the `asyncio` module provides an easy way
    to convert a sequential program to an asynchronous one. In this section, we will
    be discussing the general structure of an asynchronous program, and subsequently,
    how to implement the conversion from a sequential to an asynchronous program in
    Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一章中看到的，`asyncio`模块提供了一种将顺序程序转换为异步程序的简单方法。在本节中，我们将讨论异步程序的一般结构，以及如何在Python中实现从顺序到异步程序的转换。
- en: Coroutines, event loops, and futures
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程、事件循环和futures
- en: 'There are a few common elements that most asynchronous programs have, and coroutines,
    event loops, and futures are three of those elements. They are defined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数异步程序都具有一些常见的元素，协程、事件循环和futures就是其中的三个元素。它们的定义如下：
- en: '**Event loops** are the main coordinators of tasks in an asynchronous program.
    An event loop keeps track of all of the tasks that are to be run asynchronously,
    and decides which of those tasks should be executed at a given moment. In other
    words, event loops handle the task switching aspect (or the execution flow) of
    asynchronous programming.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件循环**是异步程序中任务的主要协调者。事件循环跟踪所有要异步运行的任务，并决定在特定时刻执行哪些任务。换句话说，事件循环处理异步编程的任务切换方面（或执行流程）。'
- en: '**Coroutines** are a special type of function that wrap around specific tasks,
    so that they can be executed asynchronously. A coroutine is required in order
    to specify where in the function the task switching should take place; in other
    words, they specify when the function should give back the flow of execution to
    the event loop. The tasks for coroutines are typically either stored in a task
    queue or created inside the event loop.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程**是一种特殊类型的函数，它包装特定任务，以便可以异步执行。为了指定函数中应该发生任务切换的位置，需要协程；换句话说，它们指定函数应该何时将执行流程交还给事件循环。协程的任务通常存储在任务队列中或在事件循环中创建。'
- en: '**Futures** are placeholders for the results returned from coroutines. These
    future objects are created as soon as coroutines are initiated in the event loop,
    so futures can represent actual results, pending results (if the coroutines have
    not finished executing), or even an exception (if that is what the coroutine will
    return).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Futures**是从协程返回的结果的占位符。这些future对象在协程在事件循环中启动时创建，因此futures可以表示实际结果、待定结果（如果协程尚未执行完毕）或异常（如果协程将返回异常）。'
- en: An event loop, coroutines, and their corresponding futures, are the core elements
    of an asynchronous programming process. First, the event loop is started and interacts
    with its task queue, in order to obtain the first task. The coroutine for this
    task and its corresponding future are then created. When a task switching has
    to take place inside of that coroutine, the coroutine suspends, and the next coroutine
    is called; all data and the context from the first coroutine are also saved.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环、协程及其对应的futures是异步编程过程的核心元素。首先启动事件循环并与其任务队列交互，以获取第一个任务。然后创建该任务的协程及其对应的future。当需要在该协程内进行任务切换时，协程将暂停，并调用下一个协程；同时也保存了第一个协程的所有数据和上下文。
- en: Now, if that coroutine is blocking (for example, input/output processing or
    sleeping), the flow of execution is released back to the event loop, which will
    move on to the next item in the task queue. The event loop will initiate the last
    item in the task queue before it switches back to the first coroutine, and will
    proceed the execution from where it was last suspended.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果该协程是阻塞的（例如，输入/输出处理或休眠），执行流程将被释放回事件循环，事件循环将继续执行任务队列中的下一个项目。事件循环将在切换回第一个协程之前启动任务队列中的最后一个项目，并将从上次暂停的地方继续执行。
- en: 'As each task finishes executing, it will be dequeued from the task queue, its
    coroutine will be terminated, and the corresponding future will register the returned
    result from the coroutine. This process will go on until all tasks in the task
    queue are completely executed. The following diagram further illustrates the general
    structure of the asynchronous process described earlier:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个任务执行完成时，它将从任务队列中出列，其协程将被终止，并且相应的future将注册来自协程的返回结果。这个过程将一直持续，直到任务队列中的所有任务都被完全执行。下面的图表进一步说明了前面描述的异步过程的一般结构：
- en: '![](assets/8e37c350-e34c-4f29-9459-8084491a0a3e.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8e37c350-e34c-4f29-9459-8084491a0a3e.png)'
- en: Asynchronous programming process
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程过程
- en: Asyncio API
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步IO API
- en: With the general structure of an asynchronous program in mind, let's consider
    the specific APIs that the `asyncio` module and Python provide for the implementation
    of asynchronous programs. The first foundation for this API is the `async` and
    `await` keywords that were added to Python 3.5\. These keywords are used to specify
    the main elements of an asynchronous program to Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑异步程序的一般结构时，让我们考虑一下`asyncio`模块和Python为实现异步程序提供的特定API。这个API的第一个基础是添加到Python
    3.5中的`async`和`await`关键字。这些关键字用于向Python指定异步程序的主要元素。
- en: Specifically, `async` is typically put in front of the `def` keyword when a
    function is declared. A function with the `async` keyword in front of it will
    be interpreted by Python as a coroutine. As we discussed, inside of each coroutine,
    there has to be a specification regarding when the task switching events will
    take place. The `await` keyword is then used to specify where and when, exactly,
    to give back the flow of execution to the event loop; this is typically done through
    waiting for another coroutine to produce a result (`await coroutine`) or through
    helper functions from the `asyncio` module, such as the `asyncio.sleep()` and
    `asyncio.wait()` functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，当声明一个函数时，`async`通常放在`def`关键字的前面。在带有`async`关键字的函数前面声明的函数将被Python解释为协程。正如我们讨论过的，每个协程内部都必须有关于何时进行任务切换事件的规定。然后，`await`关键字用于指定何时何地将执行流返回给事件循环；这通常是通过等待另一个协程产生结果（`await
    coroutine`）或通过`asyncio`模块的辅助函数，如`asyncio.sleep()`和`asyncio.wait()`函数来实现的。
- en: It is important to note that the `async` and `await` keywords are actually provided
    by Python and are not managed by the `asyncio` module. This means that asynchronous
    programming can actually be implemented without `asyncio`, but, as you will see,
    `asyncio` provides a framework and infrastructure to streamline this process,
    and is therefore the primary tool in Python for the implementation of asynchronous
    programming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`async`和`await`关键字实际上是由Python提供的，而不是由`asyncio`模块管理的。这意味着异步编程实际上可以在没有`asyncio`的情况下实现，但是，正如你将看到的，`asyncio`提供了一个框架和基础设施来简化这个过程，因此是Python中实现异步编程的主要工具。
- en: 'Specifically, the most commonly used API from the `asyncio` module is event-loop-managing
    functionalities. With `asyncio`, you can start to manipulate your tasks and event
    loop with intuitive and easy function calls, without extensive boilerplate code.
    These include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，`asyncio`模块中最常用的API是事件循环管理功能。使用`asyncio`，你可以通过直观和简单的函数调用开始操纵你的任务和事件循环，而不需要大量的样板代码。其中包括以下内容：
- en: '`asyncio.get_event_loop()`: This method returns the event loop for the current
    context, which is an `AbstractEventLoop` object. Most of the time, we do not need
    to worry about this class, as the `asyncio` module already provides a high-level
    API to manage our event loops.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.get_event_loop()`: 这个方法返回当前上下文的事件循环，它是一个`AbstractEventLoop`对象。大多数情况下，我们不需要担心这个类，因为`asyncio`模块已经提供了一个高级API来管理我们的事件循环。'
- en: '`AbstractEventLoop.create_task()`: This method is to be called by an event
    loop. It adds its input to the current task queue of the calling event loop; the
    input is typically a coroutine (that is, a function with the `async` keyword).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractEventLoop.create_task()`: 这个方法由事件循环调用。它将其输入添加到调用事件循环的当前任务队列中；输入通常是一个协程（即带有`async`关键字的函数）。'
- en: '`AbstractEventLoop.run_until_complete()`: This method is also to be called
    by an event loop. It takes in the main coroutine of an asynchronous program and
    executes it until the corresponding future of the coroutine is returned. While
    the method initiates the event loop execution, it also blocks all subsequent code
    following it, until all futures are complete.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractEventLoop.run_until_complete()`: 这个方法也是由事件循环调用的。它接受异步程序的主协程，并执行它，直到协程的相应future被返回。虽然这个方法启动了事件循环的执行，但它也会阻塞其后的所有代码，直到所有的future都完成。'
- en: '`AbstractEventLoop.run_forever()`: This method is somewhat similar to `AbstractEventLoop.run_until_complete()`,
    except for the fact that, as suggested by the method name, the calling event loop
    will run forever, unless the `AbstractEventLoop.stop()` method is called. So,
    instead of exiting, the loop will continue to run, even upon obtaining the returned
    futures.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractEventLoop.run_forever()`: 这个方法与`AbstractEventLoop.run_until_complete()`有些相似，不同之处在于，正如方法名所示，调用事件循环将永远运行，除非调用`AbstractEventLoop.stop()`方法。因此，循环不会退出，即使获得了返回的future。'
- en: '`AbstractEventLoop.stop()`: This method causes the calling event loop to stop
    executing and exit at the nearest appropriate opportunity, without causing the
    whole program to crash.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractEventLoop.stop()`: 这个方法会导致调用事件循环停止执行，并在最近的适当机会退出，而不会导致整个程序崩溃。'
- en: 'Aside from these methods, we use a number of non-blocking functions to facilitate
    the task switching event. These include the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方法之外，我们使用了许多非阻塞函数来促进任务切换事件。其中包括以下内容：
- en: '`asyncio.sleep()`: While in itself a coroutine, this function creates an additional
    coroutine that completes after a given time (specified by the input, in seconds).
    It is typically used as `asyncio.sleep(0)`, to cause an immediate task switching
    event.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.sleep()`: 虽然本身是一个协程，但这个函数创建一个在给定时间后（由输入的秒数指定）完成的额外协程。通常用作`asyncio.sleep(0)`，以引起立即的任务切换事件。'
- en: '`asyncio.wait()`: This function is also a coroutine, and hence, it can be used
    to switch tasks. It takes in a sequence (usually a list) of futures and waits
    for them to complete their execution.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.wait()`: 这个函数也是一个协程，因此可以用来切换任务。它接受一个序列（通常是一个列表）的futures，并等待它们完成执行。'
- en: The asyncio framework in action
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步框架的实际应用
- en: As you have seen, `asyncio` provides a simple and intuitive way to implement
    the framework of an asynchronous program with Python's asynchronous programming
    keywords. With that, let's consider the process of applying the framework provided
    to a synchronous application in Python, and convert it to an asynchronous one.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`asyncio`提供了一种简单直观的方法来使用Python的异步编程关键字实现异步程序的框架。有了这个，让我们考虑将提供的框架应用于Python中的同步应用程序，并将其转换为异步应用程序。
- en: Asynchronously counting down
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步倒计时
- en: 'Let''s take a look at the `Chapter10/example1.py` file, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`Chapter10/example1.py`文件，如下所示：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The goal of this example is to illustrate the asynchronous nature of overlapping
    the processing and waiting time of independent tasks. To do this, we will be analyzing
    a countdown function (`count_down()`) that takes in a string and a delay time.
    It will then count down from three to one, in seconds, while printing out the
    time elapsed from the beginning of the function's execution and the input string
    (with the current countdown number).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的目标是说明重叠处理和独立任务等待时间的异步特性。为了做到这一点，我们将分析一个倒计时函数（`count_down()`），它接受一个字符串和一个延迟时间。然后它将从三倒数到一，以秒为单位，同时打印出从函数执行开始到输入字符串（带有当前倒计时数字）的经过的时间。
- en: 'In our main program, we will call the `count_down()` function on the letters
    `A`, `B`, and `C`, with different delay times. After running the script, your
    output should be similar to the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主程序中，我们将在字母`A`、`B`和`C`上调用`count_down()`函数，延迟时间不同。运行脚本后，您的输出应该类似于以下内容：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The numbers at the beginning of the lines indicate the total numbers of seconds
    elapsed from the beginning of the program. You can see that the program counted
    down for letter `A` first, with one-second intervals, and it moved on to letter
    `B`, with 0.8-second intervals, and finally, to letter `C`, with 0.5-second intervals.
    This is a purely sequential, synchronous program, since there is no overlapping
    between processing and waiting time. Additionally, it took approximately 6.9 seconds
    to run the program, which is the sum of the counting down time of all three letters:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 行首的数字表示从程序开始经过的总秒数。您可以看到程序首先为字母`A`倒数，间隔一秒，然后转移到字母`B`，间隔0.8秒，最后转移到字母`C`，间隔0.5秒。这是一个纯粹的顺序同步程序，因为处理和等待时间之间没有重叠。此外，运行程序大约需要6.9秒，这是所有三个字母倒计时时间的总和：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keeping the idea behind asynchronous programming in mind, we can see that it
    is actually possible for us to convert this program to an asynchronous one. Specifically,
    let's suppose that during the first second of the program, while we are waiting
    to count down the letter `A`, we can switch tasks to move to other letters. In
    fact, we will implement this setup for all of the letters inside the `count_down()`
    function (in other words, we will turn `count_down()` into a coroutine).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记异步编程背后的思想，我们可以看到实际上我们可以将这个程序转换为异步程序。具体来说，假设在程序的第一秒钟，当我们等待倒数字母`A`时，我们可以切换任务以移动到其他字母。事实上，我们将为`count_down()`函数中的所有字母实现这个设置（换句话说，我们将`count_down()`变成一个协程）。
- en: Theoretically, now that all counting down tasks are coroutines in an asynchronous
    program, we should achieve better execution time and responsiveness for our program.
    Since all three tasks are processed independently, the countdown messages should
    be printed out of order (jumping between different letters), and the asynchronous
    program should only take about the same time as the largest task takes (that is,
    three seconds for letter `A`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，现在所有倒计时任务都是异步程序中的协程，我们应该能够获得更好的执行时间和响应性。由于所有三个任务都是独立处理的，倒计时消息应该是无序打印出来的（在不同的字母之间跳跃），而异步程序应该只需要与最大任务所需的时间大致相同（即字母`A`需要三秒）。
- en: 'But first, let''s make our program asynchronous. To do this, we first need
    to make `count_down()` into a coroutine and specify a point inside the function
    to be a task switching event. In other words, we will add the keyword `async`
    in front of the function, and, instead of the `time.sleep()` function, we will
    be using the `asyncio.sleep()` function along with the `await` keyword; the rest
    of the function should remain the same. Our `count_down()` coroutine should now
    be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们将程序变成异步的。为了做到这一点，我们首先需要将`count_down()`变成一个协程，并指定函数内的某一点为任务切换事件。换句话说，我们将在函数前面添加关键字`async`，而不是使用`time.sleep()`函数，我们将使用`asyncio.sleep()`函数以及`await`关键字；函数的其余部分应保持不变。我们的`count_down()`协程现在应该如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As for our main program, we will need to initialize and manage an event loop.
    Specifically, we will create an empty event loop with the `asyncio.get_event_loop()`
    method, add all of the three counting down tasks into the task queue with `AbstractEventLoop.create_task()`,
    and, finally, start running the event loop with `AbstractEventLoop.run_until_complete()`.
    Our main program should look like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们的主程序，我们需要初始化和管理一个事件循环。具体来说，我们将使用`asyncio.get_event_loop()`方法创建一个空的事件循环，使用`AbstractEventLoop.create_task()`将所有三个倒计时任务添加到任务队列中，并最后使用`AbstractEventLoop.run_until_complete()`开始运行事件循环。我们的主程序应该如下所示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The complete script can also be found in the code repository of the book, inside
    the `Chapter10` subfolder, named `example2.py`. After running the script, your
    output should look similar to the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本也可以在书的代码存储库中找到，在`Chapter10`子文件夹中，名为`example2.py`。运行脚本后，您的输出应该类似于以下内容：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you can see how having an asynchronous program can improve the execution
    time and responsiveness of our programs. Instead of executing individual tasks
    sequentially, our program now switches between different countdowns and overlaps
    their processing/waiting times. This, as we discussed, results in different letters
    being printed out in between each other, or simultaneously.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到异步程序如何可以提高程序的执行时间和响应性。我们的程序不再按顺序执行单个任务，而是在不同的倒计时之间切换，并重叠它们的处理/等待时间。正如我们讨论过的，这导致不同的字母在彼此之间或同时被打印出来。
- en: At the beginning of the program, instead of waiting for the whole first second
    to print out the first message `A = 3`, the program switches to the next task
    in the task queue (in this case, it is waiting for 0.8 seconds for the letter
    `B`). This process continues until 0.5 seconds have passed and `C = 3` is printed
    out, and 0.3 seconds later (at the time 0.8 seconds), `B = 3` is printed out.
    This all happens before `A = 3` is printed out.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序开始时，程序不再等待整整一秒才打印出第一条消息`A = 3`，而是切换到任务队列中的下一个任务（在这种情况下，它等待0.8秒来打印字母`B`）。这个过程一直持续，直到过去了0.5秒，打印出`C
    = 3`，再过0.3秒（在0.8秒时），打印出`B = 3`。这都发生在打印出`A = 3`之前。
- en: 'This task-switching property of our asynchronous program makes it significantly
    more responsive. Instead of hanging for one second before the first message is
    printed, the program now only takes 0.5 seconds (the shortest waiting period)
    to print out its first message. As for the execution time, you can see that this
    time, it only takes three seconds, in total, to execute the whole program (instead
    of 6.9 seconds). This corresponds to what we speculated: that the execution time
    would be right around the time it takes to execute the largest task.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的异步程序的这种任务切换属性使其更具响应性。在打印第一条消息之前不再等待一秒，程序现在只需要0.5秒（最短的等待时间）就可以打印出第一条消息。至于执行时间，您可以看到这一次，整个程序只需要三秒的时间来执行（而不是6.9秒）。这符合我们的推测：执行时间将会接近执行最大任务所需的时间。
- en: A note about blocking functions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于阻塞函数的说明
- en: 'As you have seen, we have to replace our original `time.sleep()` function with
    its equivalent from the `asyncio` module. This is because `time.sleep()` is, by
    nature, a blocking function, which means that it cannot be used to implement a
    task switching event. To test this, in our `Chapter10/example2.py` file (our asynchronous
    program), we will replace the following line of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们必须用`asyncio`模块中的等效函数替换我们原始的`time.sleep()`函数。这是因为`time.sleep()`本质上是一个阻塞函数，这意味着它不能用于实现任务切换事件。为了测试这一点，在我们的`Chapter10/example2.py`文件（我们的异步程序）中，我们将替换以下代码行：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code will be replaced with the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码将被替换为以下代码：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After running this new script, your output will simply be the same as that of
    our original sequential, synchronous program. So, replacing `await asyncio.sleep()`
    with `time.sleep()` actually converts our program back to synchronous, ignoring
    the event loop that we implemented. What happened was, when our program proceeded
    to that line inside of the `count_down()` function, `time.sleep()` actually blocked
    and prevented the release of the execution flow, essentially rendering the whole
    program synchronous once again. Revert `time.sleep()` back to `await asyncio.sleep()`
    to fix this problem.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个新脚本后，您的输出将与我们原始的顺序同步程序的输出相同。因此，用`time.sleep()`替换`await asyncio.sleep()`实际上将我们的程序重新转换为同步，忽略了我们实现的事件循环。发生的情况是，当我们的程序继续执行`count_down()`函数中的那行时，`time.sleep()`实际上阻塞并阻止了执行流的释放，从根本上使整个程序再次变成同步。将`time.sleep()`恢复为`await
    asyncio.sleep()`以解决这个问题。
- en: 'The following diagram illustrates an example of the difference in execution
    time between blocking and non-blocking file handling:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了阻塞和非阻塞文件处理之间执行时间差异的示例：
- en: '![](assets/14eb98aa-5364-4486-8fba-75e4434c5293.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14eb98aa-5364-4486-8fba-75e4434c5293.png)'
- en: Blocking versus non-blocking
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞与非阻塞
- en: 'This phenomenon raises an interesting issue: if a heavy, long-running task
    is blocking, then it is literally impossible to implement asynchronous programming
    with that task as a coroutine. So, if we really wanted to achieve what a blocking
    function returns in an asynchronous application, we would need to implement another
    version of that blocking function, which could be made into a coroutine and allow
    for task switching events to take place at at least one point inside the function.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种现象引发了一个有趣的问题：如果一个耗时长的任务是阻塞的，那么使用该任务作为协程实现异步编程就是不可能的。因此，如果我们真的想要在异步应用程序中实现阻塞函数返回的内容，我们需要实现该阻塞函数的另一个版本，该版本可以成为协程，并允许在函数内至少有一个点进行任务切换。
- en: Luckily, after implementing `asyncio` as one of the official features of Python,
    Python core developers have been on working to produce the coroutine version of
    the most commonly used Python blocking functions. This means that if you ever
    find blocking functions that prevent your program from being truly asynchronous,
    you will most likely be able to find the coroutine versions of those functions
    to implement in your program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在将`asyncio`作为Python的官方功能之一后，Python核心开发人员一直在努力制作最常用的Python阻塞函数的协程版本。这意味着，如果您发现阻塞函数阻止您的程序真正实现异步，您很可能能够找到这些函数的协程版本来在您的程序中实现。
- en: However, the fact that there are asynchronous versions of traditionally blocking
    functions in Python with potentially different APIs means that you will need to
    familiarize yourself with those APIs from separate functions. Another way to handle
    blocking functions without having to implement their coroutine versions is to
    use an executor to run the functions in separate threads or separate processes,
    to avoid blocking the thread of the main event loop.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python中传统阻塞函数的异步版本具有潜在不同的API，这意味着您需要熟悉来自单独函数的这些API。处理阻塞函数的另一种方法，而无需实现它们的协程版本，是使用执行器在单独的线程或单独的进程中运行函数，以避免阻塞主事件循环的线程。
- en: Asynchronous prime-checking
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步素数检查
- en: 'Moving on from our starting counting-down example, let''s reconsider the example
    from the previous chapter. As a refresher, the following is the code for the synchronous
    version of the program:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们开始的倒计时例子中继续，让我们重新考虑上一章的例子。作为一个复习，以下是程序同步版本的代码：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we discussed in the last chapter, here, we have a simple prime-checking function, `is_prime(x)`,
    that prints out messages indicating whether the input integer that it takes in, `x`,
    is a prime number. In our main program, we call `is_prime()` on three prime numbers,
    in an order of decreasing magnitude sequentially. This setup again creates a significant
    period of time during which the program appears to be hanging while processing
    the large input, resulting in a low responsiveness for the program.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章讨论的那样，这里我们有一个简单的素数检查函数`is_prime(x)`，它打印出消息，指示它接收的输入整数`x`是否是素数。在我们的主程序中，我们按照递减的顺序依次对三个素数调用`is_prime()`。这种设置再次在处理大输入时创建了一个显著的时间段，导致程序在处理大输入时出现停顿，从而降低了程序的响应性。
- en: 'The output produced by the program will look similar to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 程序产生的输出将类似于以下内容：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To implement asynchronous programming for this script, first, we will have
    to create our first main component: the event loop. To do this, instead of using
    the `''__main__''` scope, we will convert it to a separate function. This function
    and our `is_prime()` prime-checking function will be the coroutines in our final
    asynchronous program.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要为此脚本实现异步编程，首先，我们将不得不创建我们的第一个主要组件：事件循环。为此，我们将其转换为一个单独的函数，而不是使用`'__main__'`范围。这个函数和我们的`is_prime()`素数检查函数将成为我们最终异步程序中的协程。
- en: 'Now, we need to convert both the `is_prime()` and `main()` functions into coroutines;
    again, this means putting the `async` keyword in front of the `def` keyword, and
    the `await` keyword inside each function, to specify the task-switching event.
    For `main()`, we simply implement that event while waiting for the task queue
    by using `aysncio.wait()`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`is_prime()`和`main()`函数都转换为协程；同样，这意味着在`def`关键字前面加上`async`关键字，并在每个函数内部使用`await`关键字来指定任务切换事件。对于`main()`，我们只需在等待任务队列时实现该事件，使用`aysncio.wait()`，如下所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Things are more complicated in the `is_prime()` function, as there is no clear
    point during which the execution flow should be released back to the event loop,
    like in our previous counting-down example. Recall that the goal of asynchronous
    programming is to achieve a better execution time and responsiveness, and to implement
    this, the task-switching event should take place during a heavy, long-running
    task. This requirement, however, is dependent on the specifics of your program—particularly,
    the coroutine, the task queue of the program, and the individual tasks in the
    queue.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_prime()`函数中的情况更加复杂，因为在执行流程应该释放回事件循环的时间点不明确，就像我们之前倒计时的例子一样。回想一下，异步编程的目标是实现更好的执行时间和响应性，为了实现这一点，任务切换事件应该发生在一个繁重且长时间运行的任务中。然而，这一要求取决于您的程序的具体情况，特别是协程、程序的任务队列和队列中的各个任务。'
- en: 'For example, the task queue of our program consists of three numbers: `9637529763296797`,
    `427920331`, and `157`; in order, we can consider them as a large task, a medium
    task, and a small task. To improve responsiveness, we would like to switch tasks
    during the large task, and not during the small task. This setup will allow the
    medium and small tasks to be started, processed, and maybe finished during the
    execution of the large task, even if the large task is in front in the task queue
    of the program.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们程序的任务队列包括三个数字：`9637529763296797`、`427920331`和`157`；按顺序，我们可以将它们视为一个大任务、一个中等任务和一个小任务。为了提高响应性，我们希望在大任务期间切换任务，而不是在小任务期间。这种设置将允许在执行大任务时启动、处理和可能完成中等和小任务，即使大任务在程序的任务队列中处于前列。
- en: Then, we will consider our `is_prime()` coroutine. After checking for some specific
    edge cases, it iterates in a `for` loop through every odd number under the square
    root of the input integer and tests for the divisibility of the input with regards
    to the current odd number in question. Inside this long-running `for` loop, then,
    is the perfect place to switch tasks—that is, to release the execution flow back
    to the event loop.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将考虑我们的`is_prime()`协程。在检查一些特定边界情况后，它通过`for`循环遍历输入整数平方根下的每个奇数，并测试输入与当前奇数的可除性。在这个长时间运行的`for`循环中，是切换任务的完美位置——即释放执行流程回事件循环。
- en: 'However, we still need to decide at which specific points in the `for` loop
    to implement the task-switching event. Again, taking into account the individual
    tasks in the task queue, we are looking for a point that is fairly common in the
    large task, not so common in the medium task, and non-existent in the small task.
    I have decided that this point is every 1,00,000-number period, which does satisfy
    our requirements, and I have used the `await asyncio.sleep(0)` command to facilitate
    the task-switching event, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要决定在`for`循环中的哪些具体点实现任务切换事件。再次考虑任务队列中的各个任务，我们正在寻找一个在大任务中相当常见，在中等任务中不太常见，并且在小任务中不存在的点。我决定这一点是每1,00,000个数字周期，这满足我们的要求，我使用了`await
    asyncio.sleep(0)`命令来促进任务切换事件，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, in our main program (not to be confused with the `main()` coroutine),
    we create our event loop and use it to run our `main()` coroutine, until it completes
    its execution:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的主程序（不要与`main()`协程混淆），我们创建事件循环并使用它来运行我们的`main()`协程，直到它完成执行：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you saw in the previous chapter, better responsiveness was achieved through
    this asynchronous version of the script. Specifically, instead of appearing like
    it is hanging while processing the first large task, our program now prints out
    output messages for the other, smaller tasks, before it finishes executing the
    large task. Our end result will look similar to the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一章中看到的，通过脚本的这种异步版本实现了更好的响应性。具体来说，我们的程序现在在处理第一个大任务时不会像挂起一样，而是在完成执行大任务之前，会打印出其他较小任务的输出消息。我们的最终结果将类似于以下内容：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Improvements from Python 3.7
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 3.7的改进
- en: As of 2018, Python 3.7 has just come out, with several major new features, such
    as data classes, guaranteed ordered dictionaries, better timing precision, and
    so on. Asynchronous programming and the `asyncio` module received a number of
    important improvements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2018年，Python 3.7刚刚发布，带来了几个重大的新功能，例如数据类、有序字典、更好的时间精度等。异步编程和`asyncio`模块也得到了一些重要的改进。
- en: 'First of all, `async` and `await` are now officially reserved keywords in Python.
    While we have been calling them keywords, Python did not, in fact, treat these
    words as reserved keywords, up until now. This means that neither `async` nor
    `await` can be used to name variables or functions in a Python program. If you
    are using Python 3.7, fire up a Python interpreter and try to use these keywords
    for variable or function names, and you should receive the following error message:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`async`和`await`现在在Python中是正式保留的关键字。虽然我们一直称它们为关键字，但事实上，Python直到现在都没有将这些词视为保留关键字。这意味着在Python程序中既不能使用`async`也不能使用`await`来命名变量或函数。如果您正在使用Python
    3.7，请启动Python解释器并尝试使用这些关键字作为变量或函数名称，您应该会收到以下错误消息：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A major improvement in Python 3.7 comes with the `asyncio` module. Specifically,
    you might have noticed from our previous examples that the main program typically
    contains a fair amount of boilerplate code to initiate and run the event loop,
    which most likely remains the same in all asynchronous programs:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.7的一个重大改进是`asyncio`模块。具体来说，您可能已经注意到从我们之前的例子中，主程序通常包含大量样板代码来初始化和运行事件循环，这在所有异步程序中可能都是相同的：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With `main()` being a coroutine in our program, `asyncio` allows us to simply
    run it in an event loop by using the `asyncio.run()` method. This eliminates significant
    boilerplate code in Python asynchronous programming.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，`main()`是一个协程，`asyncio`允许我们使用`asyncio.run()`方法在事件循环中简单地运行它。这消除了Python异步编程中的重要样板代码。
- en: 'So, we can convert the preceding code to a more simplified version in Python
    3.7, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将前面的代码转换为Python 3.7中更简化的版本，如下所示：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are other improvements regarding asynchronous programming, in both performance
    and ease in usage, that were implemented in Python 3.7; however, we will not be
    discussing them in this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异步编程，Python 3.7还实现了性能和使用便利方面的其他改进；但是，在本书中我们将不会讨论它们。
- en: Inherently blocking tasks
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固有阻塞任务
- en: In the first example in this chapter, you saw that asynchronous programming
    can provide our Python programs with better execution time, but that is not always
    the case. Asynchronous programming alone can only provide improvements in speed
    if all processing tasks are non-blocking. However, similar to the comparison between
    concurrency and inherent sequentiality in programming tasks, some computing tasks
    in Python are inherently blocking, and therefore, they cannot be taken advantage
    of by asynchronous programming.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个例子中，您看到异步编程可以为我们的Python程序提供更好的执行时间，但并非总是如此。仅有异步编程本身只能在所有处理任务都是非阻塞的情况下提供速度上的改进。然而，类似于并发和编程任务中固有的顺序性之间的比较，Python中的一些计算任务是固有阻塞的，因此无法利用异步编程。
- en: This means that if your asynchronous programming has inherently blocking tasks
    in some coroutines, the program will not gain any additional improvement in speed
    from the asynchronous architecture. While task-switching events still take place
    in those programs, which will improve the responsiveness of the programs, no instructions
    will be overlapping each other, and no additional speed will thus be gained. In
    fact, since there is considerable overhead regarding the implementation of asynchronous
    programming in Python, our programs might even take longer to finish their execution
    than the original, synchronous programs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果您的异步编程在某些协程中具有固有的阻塞任务，程序将无法从异步架构中获得额外的速度改进。虽然这些程序仍然会发生任务切换事件，从而提高程序的响应性，但指令不会重叠，因此也不会获得额外的速度。事实上，由于Python中异步编程的实现存在相当大的开销，我们的程序甚至可能需要更长的时间来完成执行，而不是原始的同步程序。
- en: For example, let's look at a comparison in speed between the two versions of
    our prime-checking program. Since the primary processing portion of the program
    is the `is_prime()` coroutine, which solely consists of number crunching, we know
    that this coroutine contains blocking tasks. So, the asynchronous version is,
    in fact, expected to run more slowly than the synchronous version.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们来比较一下我们的素数检查程序的两个版本在速度上的差异。由于程序的主要处理部分是`is_prime()`协程，它完全由数字计算组成，我们知道这个协程包含阻塞任务。因此，预期异步版本的运行速度会比同步版本慢。
- en: 'Navigate to the `Chapter10` subfolder of the code repository and take a look
    at the files `example3.py` and `example4.py`. These files contain the same code
    for the synchronous and asynchronous prime-checking programs that we have been
    seeing, but with the addition that we are also tracking how much time it takes
    to run the respective programs. The following is my output after running `example3.py`,
    the synchronous version of the program:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 转到代码存储库的`Chapter10`子文件夹，查看`example3.py`和`example4.py`文件。这些文件包含我们一直在看的同步和异步素数检查程序的相同代码，但额外添加了跟踪运行各自程序所需时间的功能。以下是我运行`synchronous`程序`example3.py`后的输出：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code shows my output when running `example4.py`, the asynchronous
    program:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我运行`asynchronous`程序`example4.py`后的输出：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While the output that you receive might be different in the specific times it
    took to run either program, it should be the case that, as we discussed, the asynchronous
    program actually took longer to run than the synchronous (sequential) one. Again,
    this is because the number crunching tasks inside our `is_prime()` coroutine are
    blocking, and, instead of overlapping these tasks in order to gain additional
    speed, our asynchronous program simply switched between these tasks in its execution.
    In this case, only responsiveness is achieved through asynchronous programming.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您收到的输出在运行每个程序所需的具体时间上可能有所不同，但应该是异步程序实际上比同步（顺序）程序运行时间更长。再次强调，这是因为我们的`is_prime()`协程中的数字计算任务是阻塞的，而我们的异步程序在执行时只是在这些任务之间切换，而不是重叠这些任务以获得额外的速度。在这种情况下，异步编程只能实现响应性。
- en: However, this does not mean that if your program contains blocking functions,
    asynchronous programming is out of the question. As mentioned previously, all
    execution in an asynchronous program, if not specified otherwise, occurs entirely
    in the same thread and process, and blocking CPU-bound tasks can thus prevent
    program instructions from overlapping each other. However, this is not the case
    if the tasks are distributed to separate threads/processes. In other words, threading
    and multiprocessing can help asynchronous programs with blocking instructions
    to achieve better execution time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着如果您的程序包含阻塞函数，异步编程就不可能。如前所述，如果未另行指定，异步程序中的所有执行都完全在同一线程和进程中进行，阻塞的CPU绑定任务可以阻止程序指令重叠。但是，如果任务分布到单独的线程/进程中，情况就不同了。换句话说，线程和多进程可以帮助具有阻塞指令的异步程序实现更好的执行时间。
- en: concurrent.futures as a solution for blocking tasks
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`concurrent.futures`作为解决阻塞任务的解决方案。'
- en: 'In this section, we will be considering another way to implement threading/multiprocessing:
    the `concurrent.futures` module, which is designed to be a high-level interface
    for implementing asynchronous tasks. Specifically, the `concurrent.futures` module
    works seamlessly with the `asyncio` module, and, in addition, it provides an abstract
    class called `Executor`, which contains the skeleton of the two main classes that
    implement asynchronous threading and multiprocessing, respectively (as suggested
    by their names): `ThreadPoolExecutor` and `ProcessPoolExecutor`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑另一种实现线程/多进程的方法：`concurrent.futures`模块，它被设计为实现异步任务的高级接口。具体来说，`concurrent.futures`模块与`asyncio`模块无缝配合，此外，它还提供了一个名为`Executor`的抽象类，其中包含实现异步线程和多进程的两个主要类的骨架（根据它们的名称建议）：`ThreadPoolExecutor`和`ProcessPoolExecutor`。
- en: Changes in the framework
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架的变化
- en: Before we jump into the API from `concurrent.futures`, let's discuss the theoretical
    basics of asynchronous threading/multiprocessing, and how it plays into the framework
    of the asynchronous programming that `asyncio` provides.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论`concurrent.futures`的API之前，让我们先讨论一下异步线程/多进程的理论基础，以及它如何融入`asyncio`提供的异步编程框架。
- en: 'As a reminder, we have three major elements in our ecosystem of asynchronous
    programming: the event loop, the coroutines, and their corresponding futures.
    We still need the event loop while utilizing threading/multiprocessing, to coordinate
    the tasks and handle their returned results (futures), so these elements typically
    remain consistent with single-threaded asynchronous programming.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，我们的异步编程生态系统中有三个主要元素：事件循环、协程和它们对应的future。在利用线程/多进程时，我们仍然需要事件循环来协调任务并处理它们返回的结果（future），因此这些元素通常与单线程异步编程保持一致。
- en: As for the coroutines, since the idea of combining asynchronous programming
    with threading and multiprocessing involves avoiding blocking tasks in the coroutines
    by executing them in separate threads and processes, the coroutines do not necessarily
    have to be interpreted as actual coroutines by Python anymore. Instead, they can
    simply be traditional Python functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 至于协程，由于将异步编程与线程和多进程相结合的想法涉及通过在单独的线程和进程中执行它们来避免协程中的阻塞任务，因此协程不再必须被Python解释为实际的协程。相反，它们可以简单地成为传统的Python函数。
- en: One new element that we will need to implement is the executor that facilitates
    threading or multiprocessing; this can be an instance of the `ThreadPoolExecutor`
    class or the `ProcessPoolExecutor` class. Now, every time we add a task to our
    task queue in the event loop, we will also need to reference this executor, so
    that separate tasks will be executed in separated threads/processes. This is done
    through the `AbstractEventLoop.run_in_executor()` method, which takes in an executor,
    a coroutine (though, again, it does not have to be an actual coroutine), and arguments
    for the coroutines to be executed in separate threads/processes. We will see an
    example of this API in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要实现的一个新元素是执行器，它可以促进线程或多进程；这可以是`ThreadPoolExecutor`类或`ProcessPoolExecutor`类的实例。现在，每当我们在事件循环中向任务队列添加任务时，我们还需要引用这个执行器，这样分离的任务将在不同的线程/进程中执行。这是通过`AbstractEventLoop.run_in_executor()`方法完成的，该方法接受一个执行器、一个协程（尽管它不必是一个真正的协程），以及要在单独的线程/进程中执行的协程的参数。我们将在下一节中看到这个API的示例。
- en: Examples in Python
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python示例
- en: Let's look at a specific implementation of the `concurrent.futures` module.
    Recall that in this chapter's first example (the counting down example), the blocking
    `time.sleep()` function prevented our asynchronous program from becoming truly
    asynchronous, and had to be replaced with its non-blocking version, `asyncio.sleep()`.
    Now, we are executing the individual countdowns in separate threads or processes,
    which means that the blocking `time.sleep()` function will not pose any problems
    in terms of executing our program asynchronously.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`concurrent.futures`模块的具体实现。回想一下，在本章的第一个示例（倒计时示例）中，阻塞的`time.sleep()`函数阻止了我们的异步程序真正成为异步，必须用其非阻塞版本`asyncio.sleep()`替换。现在，我们在单独的线程或进程中执行各自的倒计时，这意味着阻塞的`time.sleep()`函数不会在执行我们的程序异步方面造成任何问题。
- en: 'Navigate to the `Chapter10/example5.py` file, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`Chapter10/example5.py`文件，如下所示：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that `count_down()` is declared as a typical, non-coroutine Python function.
    In `main()`, which remains a coroutine, we declare our task queue for the event
    loop. Again, we are using the `run_in_executor()` method during this process,
    instead of the `create_task()` method that is used in single-threaded asynchronous
    programming. In our main program, we also need to initiate an executor, which,
    in this case, is an instance of the `ThreadPoolExecutor` class from the `concurrent.futures`
    module.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`count_down()`被声明为一个典型的非协程Python函数。在`main()`中，仍然是一个协程，我们为事件循环声明了我们的任务队列。同样，在这个过程中，我们使用`run_in_executor()`方法，而不是在单线程异步编程中使用的`create_task()`方法。在我们的主程序中，我们还需要初始化一个执行器，这种情况下，它是来自`concurrent.futures`模块的`ThreadPoolExecutor`类的实例。
- en: The decision between using threading and multiprocessing is, as we discussed
    in previous chapters, dependent on the nature of the program. Here, we need to
    share the `start` variable (holding the time at which the program starts to execute)
    among separate coroutines, so that they can perform the act of counting down;
    so, threading is chosen over multiprocessing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程和多进程的决定，正如我们在之前的章节中讨论的那样，取决于程序的性质。在这里，我们需要在单独的协程之间共享`start`变量（保存程序开始执行的时间），以便它们可以执行倒计时的动作；因此，选择了多线程而不是多进程。
- en: 'After running the script, your output should be similar to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，您的输出应该类似于以下内容：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This output is identical to the one that we obtained from the asynchronous program
    with pure `asyncio` support. So, even with a blocking processing function, we
    were able to make the execution of our program asynchronous, with threading implemented
    by the `concurrent.futures` module.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出与我们从纯`asyncio`支持的异步程序中获得的输出是相同的。因此，即使有一个阻塞处理函数，我们也能够使我们的程序的执行异步化，通过`concurrent.futures`模块实现了线程。
- en: 'Let''s now apply the same concept to our prime-checking problem. We are first
    converting our `is_prime()` coroutine to its original, non-coroutine form, and
    executing it in separate processes again (which are more desirable than threads,
    as the `is_prime()` function is an intensive number-crunching task). An additional
    benefit of using the original version of `is_prime()` is that we will not have
    to perform a check of the task-switching condition that we have in our single-threaded
    asynchronous program:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将相同的概念应用到我们的素数检查问题上。我们首先将我们的`is_prime()`协程转换为其原始的非协程形式，并再次在单独的进程中执行它（这比线程更可取，因为`is_prime()`函数是一个密集的数值计算任务）。使用原始版本的`is_prime()`的另一个好处是，我们不必执行我们在单线程异步程序中的任务切换条件的检查。
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will provide us with a significant speedup, as well. Let''s take a look
    at the `Chapter10/example6.py` file, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将为我们提供显著的加速。让我们看一下`Chapter10/example6.py`文件，如下所示：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After running the script, I obtained the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，我得到了以下输出：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Again, your execution time will most likely be different from mine, although
    the comparison between this and the other two versions of our prime-checking program
    should always be consistent: the original, synchronous version takes less time
    than the single-threaded asynchronous version, but more than the multiprocessing
    asynchronous version. In other words, by combining multiprocessing with asynchronous
    programming, we get the best of both worlds: the consistent responsiveness from
    asynchronous programming, and the improvement in speed from multiprocessing.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，您的执行时间很可能与我的不同，尽管我们的原始、同步版本所花费的时间应该始终与单线程异步版本和多进程异步版本的比较一致：原始的同步版本所花费的时间少于单线程异步版本，但多于多进程异步版本。换句话说，通过将多进程与异步编程结合起来，我们既得到了异步编程的一致响应性，又得到了多进程的速度提升。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned about asynchronous programming, which is a model
    of programming that takes advantage of coordinating computing tasks to overlap
    the waiting and processing times. There are three main components to an asynchronous
    program: the event loop, the coroutines, and the futures. The event loop is in
    charge of scheduling and managing coroutines using its task queue. Coroutines
    are computing tasks that are to be executed asynchronously; each coroutine has
    to specify inside of its function exactly where it will give the execution flow
    back to the event loop (that is, the task-switching event). Futures are placeholder
    objects that contain the results obtained from the coroutines.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了异步编程，这是一种利用协调计算任务以重叠等待和处理时间的编程模型。异步程序有三个主要组件：事件循环、协程和期货。事件循环负责使用其任务队列调度和管理协程。协程是要异步执行的计算任务；每个协程都必须在其函数内部指定它将在何处将执行流返回给事件循环（即任务切换事件）。期货是包含从协程获得的结果的占位符对象。
- en: The `asyncio` module, together with the Python keywords `async` and `await`,
    provides an easy-to-use API and an intuitive framework to implement asynchronous
    programs; additionally, this framework makes the asynchronous code just as readable
    as synchronous code, which is generally quite rare in asynchronous programming.
    However, we cannot apply single-threaded asynchronous programming on blocking
    computing tasks with the `asyncio` module alone. The solution to this is the `concurrent.futures`
    module, which provides a high-level API to implement asynchronous threading and
    multiprocessing, and can be used in addition to the `asyncio` module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块与Python关键字`async`和`await`一起，提供了易于使用的API和直观的框架来实现异步程序；此外，该框架使异步代码与同步代码一样易读，这在异步编程中通常是相当罕见的。然而，我们不能仅使用`asyncio`模块在阻塞计算任务上应用单线程异步编程。解决此问题的方法是`concurrent.futures`模块，它提供了一个高级API来实现异步线程和多进程，并且可以与`asyncio`模块一起使用。'
- en: In the next chapter, we will be discussing one of the most common applications
    of asynchronous programming, **Transmission Control Protocol** (**TCP**), as a
    means of server-client communication. You will learn about the basics of the concept,
    how it takes advantage of asynchronous programming, and how to implement it in
    Python.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论异步编程的最常见应用之一，即**传输控制协议**（**TCP**），作为服务器-客户端通信的手段。您将了解概念的基础，它如何利用异步编程，并如何在Python中实现它。
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is asynchronous programming? What advantages does it provide?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是异步编程？它提供了哪些优势？
- en: What are the main elements in an asynchronous program? How do they interact
    with each other?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步程序中的主要元素是什么？它们如何相互交互？
- en: What are the `async` and `await` keywords? What purposes do they serve?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`和`await`关键字是什么？它们有什么作用？'
- en: What options does the `asyncio` module provide, in terms of the implementation
    of asynchronous programming?
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`模块在实现异步编程方面提供了哪些选项？'
- en: What are the improvements in regards to asynchronous programming provided in
    Python 3.7?
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.7中关于异步编程的改进是什么？
- en: What are blocking functions? Why do they pose a problem for traditional asynchronous
    programming?
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是阻塞函数？它们为传统的异步编程带来了什么问题？
- en: How does `concurrent.futures` provide a solution to blocking functions for asynchronous
    programming? What options does it provide?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures`如何为异步编程中的阻塞函数提供解决方案？它提供了哪些选项？'
- en: Further reading
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下链接：
- en: Zaccone, Giancarlo. *Python Parallel Programming Cookbook*. Packt Publishing
    Ltd, 2015
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zaccone, Giancarlo. *Python Parallel Programming Cookbook*. Packt Publishing
    Ltd, 2015
- en: '*A guide to asynchronous programming in Python with asyncio* ([medium.freecodecamp.org/a-guide-to-asynchronous-programming-in-python-with-asyncio](https://medium.freecodecamp.org/a-guide-to-asynchronous-programming-in-python-with-asyncio-232e2afa44f6)), Mariia Yakimova'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用asyncio在Python中进行异步编程的指南* ([medium.freecodecamp.org/a-guide-to-asynchronous-programming-in-python-with-asyncio](https://medium.freecodecamp.org/a-guide-to-asynchronous-programming-in-python-with-asyncio-232e2afa44f6)),
    Mariia Yakimova'
- en: '*AsyncIO for the Working Python Developer* ([hackernoon.com/asyncio-for-the-working-python-developer](https://hackernoon.com/asyncio-for-the-working-python-developer-5c468e6e2e8e)), Yeray Diaz'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AsyncIO for the Working Python Developer* ([hackernoon.com/asyncio-for-the-working-python-developer](https://hackernoon.com/asyncio-for-the-working-python-developer-5c468e6e2e8e)),
    Yeray Diaz'
- en: Python Documentation. Tasks and coroutines. [docs.python.org/3/library/asyncio](https://docs.python.org/3/library/asyncio.html)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python文档。任务和协程。[docs.python.org/3/library/asyncio](https://docs.python.org/3/library/asyncio.html)
- en: '*Modern Concurrency*, ([speakerdeck.com/pybay/2017-luciano-ramalho-modern-concurrency](https://speakerdeck.com/pybay/2017-luciano-ramalho-modern-concurrency)),
    PyBay 2017'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Modern Concurrency*, ([speakerdeck.com/pybay/2017-luciano-ramalho-modern-concurrency](https://speakerdeck.com/pybay/2017-luciano-ramalho-modern-concurrency)),
    PyBay 2017'
