- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Automating Deployment on AWS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化 AWS 部署
- en: In the previous chapter, we successfully deployed the Django application on
    an EC2 instance. However, most of the deployment is done manually, and we don’t
    check for regression when pushing a new version of the application. Interestingly,
    all the deploying can be automated using GitHub Actions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们成功地将 Django 应用部署到了一个 EC2 实例上。然而，大多数部署都是手动完成的，我们在推送应用的新版本时并没有检查回归。有趣的是，所有部署都可以使用
    GitHub Actions 自动化。
- en: 'In this chapter, we will use GitHub Actions to automatically deploy on an AWS
    EC2 instance so that you don’t have to do it manually. We will explore how to
    write a configuration file that will run tests on the code to avoid regressions,
    and finally connect via **Secure Socket Shell** (**SSH**) to a server and execute
    the script to pull and build the recent version of the code and up the container.
    To recapitulate, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 GitHub Actions 自动部署到 AWS EC2 实例上，这样你就不必手动操作了。我们将探讨如何编写一个配置文件，该文件将在代码上运行测试以避免回归，并最终通过
    **安全套接字外壳** (**SSH**) 连接到服务器并执行脚本以拉取和构建代码的最新版本以及更新容器。为了回顾，我们将涵盖以下主题：
- en: Explaining **continuous integration and continuous** **deployment** (**CI/CD**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释 **持续集成和持续** **部署** (**CI/CD**)
- en: Defining the CI/CD workflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 CI/CD 工作流程
- en: What is GitHub Actions?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 GitHub Actions？
- en: Configuring the backend for automated deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置后端以实现自动化部署
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap14](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap14).
    If you are using a Windows machine, ensure that you have the OpenSSH client installed
    on your machine as we will generate SSH key pairs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap14](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap14)
    找到。如果你使用的是 Windows 机器，请确保你的机器上安装了 OpenSSH 客户端，因为我们将生成 SSH 密钥对。
- en: Explaining CI/CD
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 CI/CD
- en: Before going deeper into GitHub Actions, we must understand the terms *CI* and
    *CD*. In this section, we will understand each term and explain the differences.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究 GitHub Actions 之前，我们必须了解 *CI* 和 *CD* 这两个术语。在本节中，我们将了解每个术语并解释它们之间的区别。
- en: CI
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI
- en: '**CI** is a practice of automating the integration of code changes from multiple
    collaborators into a single project. It also concerns the ability to reliably
    release changes made to an application at any time. Without CI, we should have
    to manually coordinate the deployment, the integration of changes into an application,
    and security and regression checks.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**CI** 是一种自动化将多个协作者的代码更改集成到单个项目中的实践。它还涉及到在任何时候可靠地发布对应用程序所做的更改的能力。没有 CI，我们就需要手动协调部署、将更改集成到应用程序中以及进行安全和回归检查。'
- en: 'Here’s a typical CI workflow:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的 CI 工作流程：
- en: A developer creates a new branch from the main branch, makes changes, commits,
    and then pushes it to the branch.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者从主分支创建一个新的分支，进行更改，提交，然后将它推送到分支。
- en: When the push is done, the code is built, and then automated tests are run.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送完成后，代码会被构建，然后运行自动化测试。
- en: If the automated tests fail, the developer team is notified, and the next steps
    (usually deployment) are canceled. If the tests succeed, then the code is ready
    to be deployed in a staging or production environment.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果自动化测试失败，开发团队会收到通知，并且下一步（通常是部署）会被取消。如果测试成功，那么代码就准备好在预发布或生产环境中部署了。
- en: You can find many tools for CI pipeline configurations. You have tools such
    as GitHub Actions, Semaphore, Travis CI, and a lot more. In this book, we will
    use GitHub Actions to build the CI pipeline, and if the CI pipeline passes, we
    can deploy it on AWS. Let’s now learn more about CD.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到许多用于 CI 管道配置的工具。你拥有 GitHub Actions、Semaphore、Travis CI 等工具。在这本书中，我们将使用
    GitHub Actions 来构建 CI 管道，如果 CI 管道通过，我们就可以在 AWS 上部署它。现在让我们更深入地了解 CD。
- en: CD
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CD
- en: '**CD** is related to CI but most of the time represents the next step after
    a successful CI pipeline passes. The quality of the CI pipeline (builds and tests)
    will determine the quality of the releases made. With CD, the software is automatically
    deployed to a staging or production environment once it passes the CI step.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**CD** 与 CI 相关，但大多数时候代表 CI 管道成功通过后的下一步。CI 管道的质量（构建和测试）将决定发布的质量。有了 CD，一旦通过了
    CI 步骤，软件就会自动部署到预发布或生产环境。'
- en: 'An example of a CD pipeline could look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CD 管道的一个例子可能看起来像这样：
- en: A developer writes a branch, makes changes and pushes the changes, and then
    creates a merge request.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者创建一个分支，进行修改并推送更改，然后创建一个合并请求。
- en: Tests and builds are done to make sure there is no regression.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行测试和构建以确保没有回归。
- en: The code is reviewed by another developer, and if the review is done, the merge
    request is validated and then another suite of tests and builds are done.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码由另一位开发者进行审查，如果审查完成，则合并请求得到验证，然后进行另一套测试和构建。
- en: After that, the changes are deployed to a staging or production environment.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，更改被部署到预发布或生产环境。
- en: GitHub Actions and the other tools mentioned for CI also support CD. With a
    better understanding of CI and CD, let’s define the workflow that we will configure
    for the backend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 以及提到的其他 CI 工具也支持 CD。在更好地理解 CI 和 CD 之后，让我们定义我们将要配置的后端工作流程。
- en: Important note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You will also hear about *continuous delivery* if you are diving deeper into
    CI/CD; it is a further extension of *continuous deployment*. Continuous deployment
    focuses on the deployment of the servers while continuous delivery focuses on
    the release and release strategy.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更深入地了解 CI/CD，您还会听到 *持续交付* 的概念；它是 *持续部署* 的进一步扩展。持续部署侧重于服务器的部署，而持续交付侧重于发布和发布策略。
- en: Defining the CI/CD workflow
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 CI/CD 工作流程
- en: Before deploying an application as we did in the previous chapter, we need to
    write off the steps we will follow, along with the tools needed for the deployment.
    In this chapter, we will automate the deployment of the backend on AWS. Basically,
    each time we have a push made on the main branch of the repository, the code should
    be updated on the server and the containers should be updated and restarted.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们像上一章那样部署应用程序之前，我们需要写下我们将遵循的步骤，以及部署所需的工具。在本章中，我们将自动化 AWS 上的后端部署。基本上，每次我们在存储库的主分支上进行推送时，代码都应该在服务器上更新，并且容器应该更新并重新启动。
- en: 'Again, let’s define the flow, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们定义以下流程：
- en: A push is made on the principal branch of the server.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器的主分支上进行了推送。
- en: Docker containers are built and started to run tests. If the tests fail, the
    following steps are ignored.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并启动 Docker 容器以运行测试。如果测试失败，则忽略以下步骤。
- en: We connect via SSH to the server and run a script to pull the new changes from
    the remote repository, build the containers, and restart the services using `docker-compose`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过 SSH 连接到服务器，并运行一个脚本来从远程仓库拉取新的更改，构建容器，并使用 `docker-compose` 重新启动服务。
- en: 'The following diagram illustrates a typical CI/CD workflow:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了典型的 CI/CD 工作流程：
- en: '![Figure 14.1 – CI/CD workflow](img/Figure_14.01_B18221.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – CI/CD 工作流程](img/Figure_14.01_B18221.jpg)'
- en: Figure 14.1 – CI/CD workflow
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – CI/CD 工作流程
- en: That is a lot of things to do manually, and thankfully, GitHub provides an interesting
    feature called GitHub Actions. Now that we have a better idea about the deployment
    strategy, let’s explore this feature more.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要手动完成很多事情，幸运的是，GitHub 提供了一个有趣的功能，称为 GitHub Actions。现在我们已经对部署策略有了更好的了解，让我们更深入地探索这个功能。
- en: What is GitHub Actions?
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 GitHub Actions？
- en: GitHub Actions is a service built and developed by GitHub for automating builds,
    testing, and deployment pipelines. Using GitHub Actions, we can easily implement
    the CI/CD workflow shown in *Figure 14**.1*. Before continuing, make sure that
    your project is hosted on GitHub.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是由 GitHub 构建和开发的服务，用于自动化构建、测试和部署管道。使用 GitHub Actions，我们可以轻松实现如图
    14.1 所示的 CI/CD 工作流程。在继续之前，请确保您的项目托管在 GitHub 上。
- en: GitHub Actions configurations are made in a file that must be stored in a dedicated
    directory in the repository called `.github/workflows`. For a better workflow,
    we will also use GitHub secrets to store deployment information such as the IP
    address of the server, the SSH passphrase, and the server username. Let’s start
    by understanding how to write a GitHub Actions workflow file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 配置在一个文件中，必须存储在存储库中名为 `.github/workflows` 的专用目录中。为了更好的工作流程，我们还将使用
    GitHub secrets 来存储部署信息，例如服务器的 IP 地址、SSH 密码短语和服务器用户名。让我们首先了解如何编写 GitHub Actions
    工作流程文件。
- en: How to write a GitHub Actions workflow file
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何编写 GitHub Actions 工作流程文件
- en: Workflow files are stored in a dedicated directory called `.github/workflows`.
    The syntax used for these files is YAML syntax, hence workflow files have the
    `.``yml` extension.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程文件存储在名为 `.github/workflows` 的专用目录中。这些文件使用的语法是 YAML 语法，因此工作流程文件具有 `.yml`
    扩展名。
- en: 'Let’s dive deeper into the syntax of a workflow file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解工作流程文件的语法：
- en: '`name`: This represents the name of the workflow. This name is set by placing
    the following line at the beginning of the file:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这代表工作流程的名称。此名称通过在文件开头放置以下行来设置：'
- en: '[PRE0]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`on`: This specifies the events that will trigger the workflow automatically.
    An example of an event is a push, a pull request, or a fork:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on`: 这指定了将自动触发工作流程的事件。一个事件示例是推送、拉取请求或分支：'
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`jobs`: This specifies the actions that the workflow will perform. You can
    have multiple jobs and even have some jobs depending on each other:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs`: 这指定了工作流程将执行的操作。您可以有多个任务，甚至可以有一些任务相互依赖：'
- en: '[PRE2]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In our GitHub Actions workflow, we will have two jobs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GitHub Actions工作流程中，我们将有两个任务：
- en: A job named `build-test` to build the Docker containers and run the tests inside
    those containers
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`build-test`的任务，用于构建Docker容器并在其中运行测试
- en: A job named `deploy` to deploy the application to the AWS server
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`deploy`的任务，用于将应用程序部署到AWS服务器
- en: The deployment of the application will depend on the failure or success of the
    `build-test` job. It’s a good way to prevent code from failing and crashing in
    the production environment. Now that we understand the GitHub Actions workflow,
    YAML syntax, and the jobs we want to write for our workflow, let’s write the GitHub
    Actions file and configure the server for automatic deployment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的部署将取决于`build-test`任务的失败或成功。这是一种防止代码在生产环境中失败和崩溃的好方法。既然我们已经了解了GitHub Actions工作流程、YAML语法以及我们想要为工作流程编写的任务，那么让我们编写GitHub
    Actions文件并配置服务器以实现自动部署。
- en: Configuring the backend for automated deployment
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置后端以实现自动化部署
- en: In the previous sections, we discussed more about the syntax of a GitHub Actions
    file and the jobs we must write to add CI and CD to the Django application. Let’s
    write the GitHub Action file and configure the backend for automatic deployment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了更多关于GitHub Actions文件语法以及我们必须编写的任务，以便为Django应用程序添加CI和CD。让我们编写GitHub
    Action文件并配置后端以实现自动部署。
- en: Adding the GitHub Actions file
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加GitHub Actions文件
- en: 'At the root of the project, create a directory called `.github`, and inside
    this directory create another directory called `workflows`. Inside the `workflows`
    directory, create a file called `ci-cd.yml`. This file will contain the YAML configuration
    for the GitHub action. Let’s start by defining the name and the events that will
    trigger the running of the workflow:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下，创建一个名为`.github`的目录，并在该目录内创建另一个名为`workflows`的目录。在`workflows`目录内，创建一个名为`ci-cd.yml`的文件。此文件将包含GitHub动作的YAML配置。让我们首先定义工作流程的名称和将触发工作流程运行的事件：
- en: .github/workflows/ci-cd.yml
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: .github/workflows/ci-cd.yml
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The workflow will run every time there is a push on the main branch. Let’s
    go on to write a `build-test` job. For this job, we will follow three steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每当主分支上有推送时，工作流程都会运行。让我们继续编写`build-test`任务。对于这个任务，我们将遵循三个步骤：
- en: Injecting environment variables into a file. Docker will need a `.env` file
    to build the images and start the containers. We’ll inject dummy environment variables
    into the Ubuntu environment.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将环境变量注入到文件中。Docker需要`.env`文件来构建镜像并启动容器。我们将向Ubuntu环境注入虚拟环境变量。
- en: After that, we will build the containers.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将构建容器。
- en: And finally, we run the tests on the `api` container.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`api`容器上运行测试。
- en: 'Let’s get started with the steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从步骤开始：
- en: 'Let’s start by writing the job and injecting the environment variables:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从编写任务和注入环境变量开始：
- en: .github/workflows/ci-cd.yml
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: .github/workflows/ci-cd.yml
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The tests will probably fail because we haven’t defined the Github Secret called
    `TEST_SECRETS`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可能会失败，因为我们还没有定义名为`TEST_SECRETS`的GitHub密钥。
- en: '![Figure 14.2 – Testing Github secrets](img/Figure_14.02_B18221.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 测试Github密钥](img/Figure_14.02_B18221.jpg)'
- en: Figure 14.2 – Testing Github secrets
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 测试Github密钥
- en: 'Next, let’s add the command to build the containers:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加构建容器的命令：
- en: .github/workflows/ci-cd.yml
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: .github/workflows/ci-cd.yml
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And finally, let’s run the `pytest` command in the `api` container:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在`api`容器中运行`pytest`命令：
- en: .github/workflows/ci-cd.yml
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: .github/workflows/ci-cd.yml
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Great! We have the first job of the workflow fully written.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经完全编写了工作流程的第一个任务。
- en: 'Let’s push the code by running the following command and see how it runs on
    the GitHub side:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来推送代码，并查看它在GitHub上的运行情况：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Go to GitHub to check your repository. You will see an orange badge on the
    details of the repository, meaning that the workflow is running:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往GitHub检查您的仓库。您将在仓库详情中看到一个橙色徽章，表示工作流程正在运行：
- en: '![Figure 14.3 – Running GitHub Actions](img/Figure_14.03_B18221.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 运行 GitHub Actions](img/Figure_14.03_B18221.jpg)'
- en: Figure 14.3 – Running GitHub Actions
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 运行 GitHub Actions
- en: 'Click on the orange badge to have more details about the running workflows.
    The workflow should pass, and you will have a green status:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击橙色徽章以获取有关正在运行的流程的更多详细信息。流程应该通过，你将看到一个绿色的状态：
- en: '![Figure 14.4 – Successful GitHub Action job](img/Figure_14.04_B18221.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 成功的 GitHub Action 任务](img/Figure_14.04_B18221.jpg)'
- en: Figure 14.4 – Successful GitHub Action job
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 成功的 GitHub Action 任务
- en: Great! We have the `build-test` job running successfully, which means that our
    code can be deployed in a production environment. Before writing the `deploy`
    job, let’s configure the server first for automatic deployment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的 `build-test` 任务已成功运行，这意味着我们的代码可以在生产环境中部署。在编写 `deploy` 任务之前，让我们先为自动部署配置服务器。
- en: Configuring the EC2 instance
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 EC2 实例
- en: 'It’s time to go back to the EC2 instance and make some configurations to ease
    the automatic deployment. Here’s the list of tasks to do so that GitHub Actions
    can automatically handle the deployment for us:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候回到 EC2 实例并做一些配置，以便简化自动部署。以下是需要完成的任务列表，以便 GitHub Actions 可以自动为我们处理部署：
- en: Generate a pair of SSH keys (private and public keys) with a passphrase.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密码短语生成一对 SSH 密钥（私钥和公钥）。
- en: Add the public key to `authorized_keys` on the server.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将公钥添加到服务器的 `authorized_keys`。
- en: Add the private key to GitHub Secrets to reuse it for the SSH connection.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将私钥添加到 GitHub Secrets 以供 SSH 连接重用。
- en: Register the username used on the OS of the EC2 instance, the IP address, and
    the SSH passphrase to GitHub Secrets.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 EC2 机器操作系统的用户名、IP 地址和 SSH 密码短语注册到 GitHub Secrets。
- en: Add a deploying script on the server. Basically, the script will pull code from
    GitHub, check for changes, and eventually build and rerun the containers.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上添加部署脚本。基本上，该脚本将从 GitHub 拉取代码，检查更改，并最终构建和重新运行容器。
- en: Wrap everything and add the `deploy` job.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容封装起来并添加 `deploy` 任务。
- en: 'This looks like a lot of steps, but here’s the good thing: you just need to
    do that once. Let’s start by generating SSH credentials.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有很多步骤，但这里有个好消息：你只需要做一次。让我们先从生成 SSH 凭据开始。
- en: Generating SSH credentials
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成 SSH 凭据
- en: 'The best practice for generating SSH keys is to generate the keys on the local
    machine and not the remote machine. In the next lines, we will use terminal commands.
    If you are working on a Windows machine, make sure you have the OpenSSH client
    installed. The following commands are executed on a Linux machine. Let’s get started
    with the steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 SSH 密钥的最佳实践是在本地机器上生成，而不是在远程机器上。在接下来的几行中，我们将使用终端命令。如果你在 Windows 机器上工作，请确保已经安装了
    OpenSSH 客户端。以下命令是在 Linux 机器上执行的。让我们开始以下步骤：
- en: 'Open the terminal and enter the following command to generate an RSA key pair:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并输入以下命令以生成 RSA 密钥对：
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Figure 14.5 – Generating SSH keys](img/Figure_14.05_B18221.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 生成 SSH 密钥](img/Figure_14.05_B18221.jpg)'
- en: Figure 14.5 – Generating SSH keys
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 生成 SSH 密钥
- en: 'Next, copy the content of the public key and add it to the `.ssh/authorized_keys`
    file of the remote EC2 instance. You can just do a copy and paste using the mouse,
    or you can type the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，复制公钥的内容并将其添加到远程 EC2 实例的 `.ssh/authorized_keys` 文件中。你可以使用鼠标进行复制粘贴，或者你可以输入以下命令：
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, copy the content of the private key and add it to GitHub Secrets:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，复制私钥的内容并将其添加到 GitHub Secrets：
- en: "![Figure 14.6 – Registering \uFEFFthe private key into GitHub \uFEFFSecrets](img/Figure_14.06_B18221.jpg)"
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6 – 将私钥注册到 GitHub Secrets](img/Figure_14.06_B18221.jpg)'
- en: Figure 14.6 – Registering the private key into GitHub Secrets
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – 将私钥注册到 GitHub Secrets
- en: 'You also need to do the same for the passphrase, EC2 server IP address, and
    username for the OS of the EC2 machine:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要为密码短语、EC2 服务器 IP 地址和 EC2 机器的操作系统用户名执行相同的操作：
- en: '![Figure 14.7 – Repository secrets](img/Figure_14.07_B18221.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 存储库密钥](img/Figure_14.07_B18221.jpg)'
- en: Figure 14.7 – Repository secrets
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 存储库密钥
- en: Great! We have the secrets configured on the repository; we can now write the
    `deploy` job on the GitHub action.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经配置了存储库中的密钥；现在我们可以在 GitHub Action 上编写 `deploy` 任务了。
- en: Adding a deploying script
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加部署脚本
- en: The benefit of using GitHub Actions is that you can already find preconfigured
    GitHub Actions on GitHub Marketplace and just use them instead of reinventing
    the wheel. For the deployment, we will use the `ssh-action` GitHub action, which
    is developed to allow developers to execute remote commands via SSH. This perfectly
    fits our needs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitHub Actions的好处是您可以在GitHub Marketplace上找到预配置的GitHub Actions，并直接使用它们，而不是重新发明轮子。对于部署，我们将使用`ssh-action`
    GitHub动作，该动作是为了允许开发者通过SSH执行远程命令而开发的。这完美符合我们的需求。
- en: 'Let’s write the `deploy` job inside our GitHub action workflow and write a
    deployment script on the EC2 instance:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在GitHub动作工作流程中编写`deploy`作业，并在EC2实例上编写部署脚本：
- en: 'Inside the `.github/workflows/ci-cd.yml` file, add the following code at the
    end of the file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.github/workflows/ci-cd.yml`文件中，在文件末尾添加以下代码：
- en: .github/workflows/ci-cd.yml
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`.github/workflows/ci-cd.yml`'
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The script run on the EC2 instance is the execution of a file called `docker-ec2-deploy.sh`.
    This file will contain Bash code for pulling code from the GitHub repository and
    building the containers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在EC2实例上运行的脚本是对一个名为`docker-ec2-deploy.sh`的文件的执行。该文件将包含从GitHub仓库拉取代码并构建容器的Bash代码。
- en: Let’s connect to the EC2 instance and add the `docker-ec2-deploy.sh` code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接到EC2实例并添加`docker-ec2-deploy.sh`代码。
- en: 'In the home directory, create a file called `docker-ec2-deploy.sh`. The process
    for deployment using Git and Docker will follow these steps:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主目录下，创建一个名为`docker-ec2-deploy.sh`的文件。使用Git和Docker进行部署的过程将遵循以下步骤：
- en: 'We must ensure that there are effective changes in the GitHub repository to
    continue with building and running the containers. It will be a waste of resources
    and memory to rebuild the containers if the Git pull hasn’t brought new changes.
    Here’s how we can check this:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保GitHub仓库中有有效的更改，以便继续构建和运行容器。如果Git拉取没有带来新更改，重新构建容器将是资源内存的浪费。以下是我们可以如何检查这一点的方法：
- en: '[PRE17]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next step, we will do a `git fetch` command to download content from the GitHub
    repository:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步，我们将执行`git fetch`命令以从GitHub仓库下载内容：
- en: '[PRE28]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once this is done, we will then check the repository is up to date by comparing
    the `HEAD` hash and the `UPSTREAM` hash. If they are the same, then the repository
    is up to date.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们将通过比较`HEAD`哈希值和`UPSTREAM`哈希值来检查仓库是否是最新的。如果它们相同，则仓库是最新的。
- en: 'If the `HEAD` and the `UPSTREAM` hashes are not the same, we pull the latest
    changes, build the containers, and run the containers:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`HEAD`和`UPSTREAM`哈希值不相同，我们将拉取最新更改，构建容器，并运行容器：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Great! We can now give execution permission to the script:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在可以给脚本执行权限：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And we are done. You can push the changes made on the GitHub workflow and the
    automatic deployment job will start.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了。您可以将GitHub工作流程中做出的更改推送到GitHub，自动部署作业将开始。
- en: Important note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Depending on the type of repository (private or public), you might need to enter
    your GitHub credentials on every remote git command executed such as `git push`
    or `git pull` for example. Ensure you have your credentials configured using SSH
    or HTTPS. You can check how to do it [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据仓库的类型（私有或公共），您可能需要在执行每个远程git命令时输入您的GitHub凭据，例如`git push`或`git pull`等。确保您已使用SSH或HTTPS配置了凭据。您可以检查如何操作[https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)
- en: 'Ensure to have a `.env` file at the root of the project in the AWS server.
    Here is an example of a `.env` file you can use for deployment. Don’t forget to
    change the values of database credentials or secret keys:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在AWS服务器项目的根目录下有一个`.env`文件。以下是一个您可以使用进行部署的`.env`文件示例。别忘了更改数据库凭据或密钥的值：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Ensure to replace the `EC2_IP_ADDRESS` and the `EC2_INSTANCE_URL` with the values
    of your EC2 instance. You will also need to allow TCP connections on port **80**
    to allow HTTP requests on the EC2 instances for the whole configuration to work.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`EC2_IP_ADDRESS`和`EC2_INSTANCE_URL`替换为您的EC2实例的值。您还需要在端口**80**上允许TCP连接，以便在整个配置中允许EC2实例上的HTTP请求。
- en: '![Figure 14.8 – Allowing HTTP requests](img/Figure_14.08_B18221.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – 允许HTTP请求](img/Figure_14.08_B18221.jpg)'
- en: Figure 14.8 – Allowing HTTP requests
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 允许HTTP请求
- en: You can also remove the **8000** configurations as NGINX handles the redirection
    of HTTP requests to **0.0.0.0:8000** automatically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以移除**8000**个配置，因为NGINX会自动处理将HTTP请求重定向到**0.0.0.0:8000**。
- en: With the concept of CI/CD understood and GitHub Actions explained and written,
    you have all the tools you need now to automate deployment on EC2 instances and
    any server. Now that the backend is deployed, we can move on to deploying the
    React frontend, not on an EC2 instance but on AWS **Simple Storage** **Service**
    (**S3**).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了CI/CD的概念，并解释和编写了GitHub Actions之后，你现在拥有了所有需要的工具，可以自动化在EC2实例和任何服务器上的部署。现在后端已经部署完成，我们可以继续部署React前端，不是在EC2实例上，而是在AWS的**简单存储服务**（**S3**）上。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have finally automated the deployment of the Django application
    on AWS using GitHub Actions. We have explored the concepts of CI and CD and how
    GitHub Actions allow the configuration of such concepts.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们最终使用GitHub Actions自动化了Django应用程序在AWS上的部署。我们探讨了CI和CD的概念，以及GitHub Actions如何允许配置这些概念。
- en: We have written a GitHub action file with jobs to build and run the test suites,
    and if these steps are successful, we run the `deploy` job, which is just connecting
    to the EC2 instance, and run a script to pull changes, build new images, and run
    the containers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个GitHub动作文件，其中包含构建和运行测试套件的作业，如果这些步骤成功，我们运行`deploy`作业，这仅仅是连接到EC2实例，并运行一个脚本来拉取更改，构建新镜像，并运行容器。
- en: In the next chapter, we will learn how to deploy the React application using
    a service such as AWS S3.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用像AWS S3这样的服务来部署React应用程序。
- en: Questions
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between CI and CD?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI和CD之间的区别是什么？
- en: What are GitHub Actions?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是GitHub Actions？
- en: What is continuous delivery?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是持续交付？
