- en: Chapter 7. Python Object-oriented Shortcuts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。Python面向对象的快捷方式
- en: 'There are many aspects of Python that appear more reminiscent of structural
    or functional programming than object-oriented programming. Although object-oriented
    programming has been the most visible paradigm of the past two decades, the old
    models have seen a recent resurgence. As with Python''s data structures, most
    of these tools are syntactic sugar over an underlying object-oriented implementation;
    we can think of them as a further abstraction layer built on top of the (already
    abstracted) object-oriented paradigm. In this chapter, we''ll be covering a grab
    bag of Python features that are not strictly object-oriented:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python的许多方面看起来更像是结构化或函数式编程，而不是面向对象编程。尽管面向对象编程在过去的二十年中是最可见的范例，但旧模型最近又出现了。与Python的数据结构一样，这些工具大多是在基础面向对象实现之上的语法糖；我们可以将它们看作是在（已经抽象化的）面向对象范例之上构建的进一步抽象层。在本章中，我们将涵盖一些不严格面向对象的Python特性。
- en: Built-in functions that take care of common tasks in one call
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理常见任务的内置函数
- en: File I/O and context managers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件I/O和上下文管理器
- en: An alternative to method overloading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重载的替代方法
- en: Functions as objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为对象
- en: Python built-in functions
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python内置函数
- en: There are numerous functions in Python that perform a task or calculate a result
    on certain types of objects without being methods on the underlying class. They
    usually abstract common calculations that apply to multiple types of classes.
    This is duck typing at its best; these functions accept objects that have certain
    attributes or methods, and are able to perform generic operations using those
    methods. Many, but not all, of these are special double underscore methods. We've
    used many of the built-in functions already, but let's quickly go through the
    important ones and pick up a few neat tricks along the way.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有许多函数，可以在某些类型的对象上执行任务或计算结果，而不是作为基础类的方法。它们通常抽象出适用于多种类型的类的常见计算。这是鸭子类型的最佳体现；这些函数接受具有某些属性或方法的对象，并能够使用这些方法执行通用操作。其中许多，但并非全部，都是特殊的双下划线方法。我们已经使用了许多内置函数，但让我们快速浏览一下重要的函数，并学习一些巧妙的技巧。
- en: The len() function
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: len()函数
- en: 'The simplest example is the `len()` function, which counts the number of items
    in some kind of container object, such as a dictionary or list. You''ve seen it
    before:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的例子是`len()`函数，它计算某种容器对象中的项目数量，例如字典或列表。你以前见过它：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Why don't these objects have a length property instead of having to call a function
    on them? Technically, they do. Most objects that `len()` will apply to have a
    method called `__len__()` that returns the same value. So `len(myobj)` seems to
    call `myobj.__len__()`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这些对象没有长度属性，而是必须对它们调用一个函数？从技术上讲，它们有。大多数`len()`将适用于的对象都有一个名为`__len__()`的方法，返回相同的值。因此，`len(myobj)`似乎调用了`myobj.__len__()`。
- en: Why should we use the `len()` function instead of the `__len__` method? Obviously
    `__len__` is a special double-underscore method, suggesting that we shouldn't
    call it directly. There must be an explanation for this. The Python developers
    don't make such design decisions lightly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该使用`len()`函数而不是`__len__`方法？显然，`__len__`是一个特殊的双下划线方法，这表明我们不应该直接调用它。这一定有一个解释。Python开发人员不会轻易做出这样的设计决定。
- en: The main reason is efficiency. When we call `__len__` on an object, the object
    has to look the method up in its namespace, and, if the special `__getattribute__`
    method (which is called every time an attribute or method on an object is accessed)
    is defined on that object, it has to be called as well. Further, `__getattribute__`
    for that particular method may have been written to do something nasty, like refusing
    to give us access to special methods such as `__len__`! The `len()` function doesn't
    encounter any of this. It actually calls the `__len__` function on the underlying
    class, so `len(myobj)` maps to `MyObj.__len__(myobj)`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是效率。当我们在对象上调用`__len__`时，对象必须在其命名空间中查找该方法，并且如果该对象上定义了特殊的`__getattribute__`方法（每次访问对象的属性或方法时都会调用），还必须调用该方法。此外，该特定方法的`__getattribute__`可能已经被编写为执行一些不好的操作，比如拒绝让我们访问`__len__`之类的特殊方法！`len()`函数不会遇到任何这些问题。它实际上调用了基础类上的`__len__`函数，因此`len(myobj)`映射到`MyObj.__len__(myobj)`。
- en: Another reason is maintainability. In the future, the Python developers may
    want to change `len()` so that it can calculate the length of objects that don't
    have `__len__`, for example, by counting the number of items returned in an iterator.
    They'll only have to change one function instead of countless `__len__` methods
    across the board.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是可维护性。将来，Python开发人员可能希望更改`len()`，以便它可以计算没有`__len__`的对象的长度，例如，通过计算迭代器返回的项目数量。他们只需要更改一个函数，而不是在整个系统中无数次更改`__len__`方法。
- en: 'There is one other extremely important and often overlooked reason for `len()`
    being an external function: backwards compatibility. This is often cited in articles
    as "for historical reasons", which is a mildly dismissive phrase that an author
    will use to say something is the way it is because a mistake was made long ago
    and we''re stuck with it. Strictly speaking, `len()` isn''t a mistake, it''s a
    design decision, but that decision was made in a less object-oriented time. It
    has stood the test of time and has some benefits, so do get used to it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()`作为外部函数的另一个极其重要且经常被忽视的原因是向后兼容性。这在文章中经常被引用为“出于历史原因”，这是作者用来表示某事之所以是某种方式的一个轻蔑的短语，因为很久以前犯了一个错误，我们现在被困在这种情况下。严格来说，`len()`并不是一个错误，而是一个设计决策，但这个决策是在一个不那么面向对象的时代做出的。它经受住了时间的考验，并且有一些好处，所以要习惯它。'
- en: Reversed
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转
- en: The `reversed()` function takes any sequence as input, and returns a copy of
    that sequence in reverse order. It is normally used in `for` loops when we want
    to loop over items from back to front.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()`函数接受任何序列作为输入，并返回该序列的一个副本，顺序相反。通常在`for`循环中使用，当我们想要从后到前循环遍历项目时。'
- en: 'Similar to `len`, `reversed` calls the `__reversed__()` function on the class
    for the parameter. If that method does not exist, `reversed` builds the reversed
    sequence itself using calls to `__len__` and `__getitem__`, which are used to
    define a sequence. We only need to override `__reversed__` if we want to somehow
    customize or optimize the process:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `len` 类似，`reversed` 调用参数类的 `__reversed__()` 函数。如果该方法不存在，`reversed` 将使用对 `__len__`
    和 `__getitem__` 的调用构建反转序列，这些方法用于定义序列。如果我们想要自定义或优化过程，只需要重写 `__reversed__`：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `for` loops at the end print the reversed versions of a normal list, and
    instances of the two custom sequences. The output shows that `reversed` works
    on all three of them, but has very different results when we define `__reversed__`
    ourselves:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `for` 循环打印了正常列表的反转版本，以及两个自定义序列的实例。输出显示 `reversed` 在所有三个上都起作用，但当我们自己定义 `__reversed__`
    时结果大不相同：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we reverse `CustomSequence`, the `__getitem__` method is called for each
    item, which just inserts an `x` before the index. For `FunkyBackwards`, the `__reversed__`
    method returns a string, each character of which is output individually in the
    `for` loop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们反转 `CustomSequence` 时，`__getitem__` 方法将为每个项目调用，它只是在索引之前插入一个 `x`。对于 `FunkyBackwards`，`__reversed__`
    方法返回一个字符串，其中的每个字符在 `for` 循环中单独输出。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding two classes aren't very good sequences as they don't define a
    proper version of `__iter__`, so a forward `for` loop over them will never end.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面两个类不是很好的序列，因为它们没有定义 `__iter__` 的正确版本，所以对它们进行正向 `for` 循环将永远不会结束。
- en: Enumerate
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Sometimes, when we''re looping over a container in a `for` loop, we want access
    to the index (the current position in the list) of the current item being processed.
    The `for` loop doesn''t provide us with indexes, but the `enumerate` function
    gives us something better: it creates a sequence of tuples, where the first object
    in each tuple is the index and the second is the original item.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们在 `for` 循环中循环容器时，我们希望访问索引（列表中的当前位置）的当前项目。`for` 循环不提供索引，但 `enumerate` 函数给了我们更好的东西：它创建了一个元组序列，其中每个元组中的第一个对象是索引，第二个是原始项目。
- en: 'This is useful if we need to use index numbers directly. Consider some simple
    code that outputs each of the lines in a file with line numbers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要直接使用索引号，这很有用。考虑一些简单的代码，输出文件中的每一行及其行号：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running this code using it''s own filename as the input file shows how it works:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自己的文件名作为输入文件运行此代码可以显示它的工作原理：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `enumerate` function returns a sequence of tuples, our `for` loop splits
    each tuple into two values, and the `print` statement formats them together. It
    adds one to the index for each line number, since `enumerate`, like all sequences,
    is zero-based.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate` 函数返回一个元组序列，我们的 `for` 循环将每个元组拆分为两个值，`print` 语句将它们格式化在一起。它为每行号添加一个索引，因为
    `enumerate`，像所有序列一样，是从零开始的。'
- en: 'We''ve only touched on a few of the more important Python built-in functions.
    As you can see, many of them call into object-oriented concepts, while others
    subscribe to purely functional or procedural paradigms. There are numerous others
    in the standard library; some of the more interesting ones include:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只触及了一些更重要的 Python 内置函数。正如你所看到的，其中许多函数调用了面向对象的概念，而其他一些则遵循纯粹的函数式或过程式范式。标准库中还有许多其他函数；其中一些更有趣的包括：
- en: '`all` and `any`, which accept an iterable object and return `True` if all,
    or any, of the items evaluate to true (such as a nonempty string or list, a nonzero
    number, an object that is not `None`, or the literal `True`).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all` 和 `any`，它们接受一个可迭代对象，并在所有或任何项目评估为真时返回 `True`（例如非空字符串或列表，非零数，不是 `None`
    的对象，或字面值 `True`）。'
- en: '`eval`, `exec`, and `compile`, which execute string as code inside the interpreter.
    Be careful with these ones; they are not safe, so don''t execute code an unknown
    user has supplied to you (in general, assume all unknown users are malicious,
    foolish, or both).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval`，`exec` 和 `compile`，它们将字符串作为代码在解释器中执行。对于这些要小心；它们不安全，所以不要执行未知用户提供给你的代码（一般来说，假设所有未知用户都是恶意的、愚蠢的或两者兼有）。'
- en: '`hasattr`, `getattr`, `setattr`, and `delattr`, which allow attributes on an
    object to be manipulated by their string names.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasattr`，`getattr`，`setattr` 和 `delattr`，它们允许通过它们的字符串名称操作对象的属性。'
- en: '`zip`, which takes two or more sequences and returns a new sequence of tuples,
    where each tuple contains a single value from each sequence.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`，它接受两个或更多序列，并返回一个新的元组序列，其中每个元组包含来自每个序列的单个值。'
- en: And many more! See the interpreter help documentation for each of the functions
    listed in `dir(__builtins__)`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多！请参阅解释器帮助文档，了解 `dir(__builtins__)` 中列出的每个函数。
- en: File I/O
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件 I/O
- en: Our examples so far that touch the filesystem have operated entirely on text
    files without much thought to what is going on under the hood. Operating systems,
    however, actually represent files as a sequence of bytes, not text. We'll do a
    deep dive into the relationship between bytes and text in [Chapter 8](ch08.html
    "Chapter 8. Strings and Serialization"), *Strings and Serialization*. For now,
    be aware that reading textual data from a file is a fairly involved process. Python,
    especially Python 3, takes care of most of this work for us behind the scenes.
    Aren't we lucky?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所涉及的与文件系统有关的示例完全是在文本文件上进行的，没有太多考虑到底层发生了什么。然而，操作系统实际上将文件表示为字节序列，而不是文本。我们将深入探讨字节和文本之间的关系，[第
    8 章](ch08.html "第 8 章. 字符串和序列化") *字符串和序列化*。现在，请注意，从文件中读取文本数据是一个相当复杂的过程。Python，特别是
    Python 3，在幕后为我们处理了大部分工作。我们是不是很幸运？
- en: The concept of files has been around since long before anyone coined the term
    object-oriented programming. However, Python has wrapped the interface that operating
    systems provide in a sweet abstraction that allows us to work with file (or file-like,
    vis-á-vis duck typing) objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的概念早在有人创造面向对象编程这个术语之前就已经存在。然而，Python 封装了操作系统提供的接口，提供了一个良好的抽象，使我们能够使用文件（或类似文件，即鸭子类型）对象。
- en: The `open()` built-in function is used to open a file and return a file object.
    For reading text from a file, we only need to pass the name of the file into the
    function. The file will be opened for reading, and the bytes will be converted
    to text using the platform default encoding.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()`内置函数用于打开文件并返回文件对象。要从文件中读取文本，我们只需要将文件名传递给函数。文件将被打开以进行读取，并且字节将使用平台默认编码转换为文本。'
- en: 'Of course, we don''t always want to read files; often we want to write data
    to them! To open a file for writing, we need to pass a `mode` argument as the
    second positional argument, with a value of `"w"`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们并不总是想要读取文件；通常我们想要向其中写入数据！要打开一个文件进行写入，我们需要将`mode`参数作为第二个位置参数传递，值为`"w"`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We could also supply the value `"a"` as a mode argument, to append to the end
    of the file, rather than completely overwriting existing file contents.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将值`"a"`作为模式参数传递，以追加到文件末尾，而不是完全覆盖现有文件内容。
- en: These files with built-in wrappers for converting bytes to text are great, but
    it'd be awfully inconvenient if the file we wanted to open was an image, executable,
    or other binary file, wouldn't it?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些具有内置包装器的文件，用于将字节转换为文本，非常好，但如果我们想要打开的文件是图像、可执行文件或其他二进制文件，那将非常不方便，不是吗？
- en: To open a binary file, we modify the mode string to append `'b'`. So, `'wb'`
    would open a file for writing bytes, while `'rb'` allows us to read them. They
    will behave like text files, but without the automatic encoding of text to bytes.
    When we read such a file, it will return `bytes` objects instead of `str`, and
    when we write to it, it will fail if we try to pass a text object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开二进制文件，我们修改模式字符串以附加`'b'`。因此，`'wb'`将打开一个用于写入字节的文件，而`'rb'`允许我们读取它们。它们的行为类似于文本文件，但没有将文本自动编码为字节。当我们读取这样的文件时，它将返回`bytes`对象而不是`str`，当我们向其写入时，如果尝试传递文本对象，它将失败。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These mode strings for controlling how files are opened are rather cryptic and
    are neither pythonic nor object-oriented. However, they are consistent with virtually
    every other programming language out there. File I/O is one of the fundamental
    jobs an operating system has to handle, and all programming languages have to
    talk to the OS using the same system calls. Just be glad that Python returns a
    file object with useful methods instead of the integer that most major operating
    systems use to identify a file handle!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式字符串用于控制文件的打开方式，相当晦涩，既不符合Python的风格，也不是面向对象的。然而，它们与几乎所有其他编程语言保持一致。文件I/O是操作系统必须处理的基本工作之一，所有编程语言都必须使用相同的系统调用与操作系统进行通信。幸运的是，Python返回一个带有有用方法的文件对象，而不是大多数主要操作系统用于标识文件句柄的整数！
- en: Once a file is opened for reading, we can call the `read`, `readline`, or `readlines`
    methods to get the contents of the file. The `read` method returns the entire
    contents of the file as a `str` or `bytes` object, depending on whether there
    is `'b'` in the mode. Be careful not to use this method without arguments on huge
    files. You don't want to find out what happens if you try to load that much data
    into memory!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被打开以进行读取，我们可以调用`read`、`readline`或`readlines`方法来获取文件的内容。`read`方法将整个文件的内容作为`str`或`bytes`对象返回，具体取决于模式中是否有`'b'`。在大文件上不要在没有参数的情况下使用此方法。您不希望尝试将如此多的数据加载到内存中！
- en: It is also possible to read a fixed number of bytes from a file; we pass an
    integer argument to the `read` method describing how many bytes we want to read.
    The next call to `read` will load the next sequence of bytes, and so on. We can
    do this inside a `while` loop to read the entire file in manageable chunks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从文件中读取固定数量的字节；我们将整数参数传递给`read`方法，描述我们想要读取多少字节。对`read`的下一次调用将加载下一个字节序列，依此类推。我们可以在`while`循环中执行此操作，以管理的方式读取整个文件。
- en: The `readline` method returns a single line from the file (where each line ends
    in a newline, a carriage return, or both, depending on the operating system on
    which the file was created). We can call it repeatedly to get additional lines.
    The plural `readlines` method returns a list of all the lines in the file. Like
    the `read` method, it's not safe to use on very large files. These two methods
    even work when the file is open in `bytes` mode, but it only makes sense if we
    are parsing text-like data that has newlines at reasonable positions. An image
    or audio file, for example, will not have newline characters in it (unless the
    newline byte happened to represent a certain pixel or sound), so applying `readline`
    wouldn't make sense.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`readline`方法从文件中返回一行（每行以换行符、回车符或两者结尾，具体取决于创建文件的操作系统）。我们可以重复调用它以获取其他行。复数`readlines`方法返回文件中所有行的列表。与`read`方法一样，它不适用于非常大的文件。这两种方法甚至在文件以`bytes`模式打开时也适用，但只有在解析具有合理位置换行符的类文本数据时才有意义。例如，图像或音频文件中不会有换行符（除非换行符字节恰好表示某个像素或声音），因此应用`readline`是没有意义的。'
- en: For readability, and to avoid reading a large file into memory at once, it is
    often better to use a `for` loop directly on a file object. For text files, it
    will read each line, one at a time, and we can process it inside the loop body.
    For binary files, it's better to read fixed-sized chunks of data using the `read()`
    method, passing a parameter for the maximum number of bytes to read.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，并且避免一次性将大文件读入内存，通常最好直接在文件对象上使用`for`循环。对于文本文件，它将一次读取一行，我们可以在循环体内对其进行处理。对于二进制文件，最好使用`read()`方法读取固定大小的数据块，传递一个参数来指定要读取的最大字节数。
- en: Writing to a file is just as easy; the `write` method on file objects writes
    a string (or bytes, for binary data) object to the file. It can be called repeatedly
    to write multiple strings, one after the other. The `writelines` method accepts
    a sequence of strings and writes each of the iterated values to the file. The
    `writelines` method does *not* append a new line after each item in the sequence.
    It is basically a poorly named convenience function to write the contents of a
    sequence of strings without having to explicitly iterate over it using a `for`
    loop.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件就像写入文件一样简单；文件对象上的`write`方法将一个字符串（或字节，用于二进制数据）对象写入文件。可以重复调用它来写入多个字符串，一个接一个。`writelines`方法接受一个字符串序列，并将迭代的每个值写入文件。`writelines`方法*不*在序列中的每个项目后附加新行。它基本上是一个命名不当的便利函数，用于写入字符串序列的内容，而无需使用`for`循环显式迭代。
- en: Lastly, and I do mean lastly, we come to the `close` method. This method should
    be called when we are finished reading or writing the file, to ensure any buffered
    writes are written to the disk, that the file has been properly cleaned up, and
    that all resources associated with the file are released back to the operating
    system. Technically, this will happen automatically when the script exits, but
    it's better to be explicit and clean up after ourselves, especially in long-running
    processes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我是指最后，我们来到`close`方法。当我们完成读取或写入文件时，应调用此方法，以确保任何缓冲写入都写入磁盘，文件已经得到适当清理，并且与文件关联的所有资源都释放回操作系统。从技术上讲，当脚本退出时，这将自动发生，但最好是明确地清理自己的东西，特别是在长时间运行的进程中。
- en: Placing it in context
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将其放入上下文中
- en: The need to close files when we are finished with them can make our code quite
    ugly. Because an exception may occur at any time during file I/O, we ought to
    wrap all calls to a file in a `try`...`finally` clause. The file should be closed
    in the `finally` clause, regardless of whether I/O was successful. This isn't
    very Pythonic. Of course, there is a more elegant way to do it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成文件时需要关闭文件，这可能会使我们的代码变得相当丑陋。因为在文件I/O期间可能随时发生异常，我们应该将对文件的所有调用包装在`try`...`finally`子句中。无论I/O是否成功，文件都应在`finally`子句中关闭。这不是很Pythonic。当然，有一种更优雅的方法来做到这一点。
- en: 'If we run `dir` on a file-like object, we see that it has two special methods
    named `__enter__` and `__exit__`. These methods turn the file object into what
    is known as a **context manager**. Basically, if we use a special syntax called
    the `with` statement, these methods will be called before and after nested code
    is executed. On file objects, the `__exit__` method ensures the file is closed,
    even if an exception is raised. We no longer have to explicitly manage the closing
    of the file. Here is what the `with` statement looks like in practice:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类似文件的对象上运行`dir`，我们会看到它有两个名为`__enter__`和`__exit__`的特殊方法。这些方法将文件对象转换为所谓的**上下文管理器**。基本上，如果我们使用一种称为`with`语句的特殊语法，这些方法将在嵌套代码执行之前和之后被调用。对于文件对象，`__exit__`方法确保文件被关闭，即使引发异常。我们不再需要显式管理文件的关闭。这是`with`语句在实践中的样子：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `open` call returns a file object, which has `__enter__` and `__exit__`
    methods. The returned object is assigned to the variable named `file` by the `as`
    clause. We know the file will be closed when the code returns to the outer indentation
    level, and that this will happen even if an exception is raised.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`调用返回一个文件对象，该对象具有`__enter__`和`__exit__`方法。返回的对象由`as`子句分配给名为`file`的变量。我们知道当代码返回到外部缩进级别时，文件将被关闭，并且即使引发异常，也会发生这种情况。'
- en: The `with` statement is used in several places in the standard library where
    startup or cleanup code needs to be executed. For example, the `urlopen` call
    returns an object that can be used in a `with` statement to clean up the socket
    when we're done. Locks in the threading module can automatically release the lock
    when the statement has been executed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句在标准库中的几个地方使用，需要执行启动或清理代码。例如，`urlopen`调用返回一个对象，可以在`with`语句中使用以在完成时清理套接字。线程模块中的锁可以在语句执行后自动释放锁。'
- en: 'Most interestingly, because the `with` statement can apply to any object that
    has the appropriate special methods, we can use it in our own frameworks. For
    example, remember that strings are immutable, but sometimes you need to build
    a string from multiple parts. For efficiency, this is usually done by storing
    the component strings in a list and joining them at the end. Let''s create a simple
    context manager that allows us to construct a sequence of characters and automatically
    convert it to a string upon exit:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的是，因为`with`语句可以应用于具有适当特殊方法的任何对象，我们可以在自己的框架中使用它。例如，记住字符串是不可变的，但有时您需要从多个部分构建一个字符串。出于效率考虑，通常通过将组件字符串存储在列表中并在最后将它们连接来完成。让我们创建一个简单的上下文管理器，允许我们构建一个字符序列，并在退出时自动将其转换为字符串：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code adds the two special methods required of a context manager to the
    `list` class it inherits from. The `__enter__` method performs any required setup
    code (in this case, there isn't any) and then returns the object that will be
    assigned to the variable after `as` in the `with` statement. Often, as we've done
    here, this is just the context manager object itself. The `__exit__` method accepts
    three arguments. In a normal situation, these are all given a value of `None`.
    However, if an exception occurs inside the `with` block, they will be set to values
    related to the type, value, and traceback for the exception. This allows the `__exit__`
    method to do any cleanup code that may be required, even if an exception occurred.
    In our example, we take the irresponsible path and create a result string by joining
    the characters in the string, regardless of whether an exception was thrown.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将两个特殊方法添加到`list`类中，这两个方法是上下文管理器所需的。`__enter__`方法执行任何必需的设置代码（在本例中没有），然后返回将分配给`with`语句中`as`后面的变量的对象。通常情况下，就像我们在这里做的一样，这只是上下文管理器对象本身。`__exit__`方法接受三个参数。在正常情况下，这些参数都被赋予`None`的值。然而，如果在`with`块内发生异常，它们将被设置为与异常类型、值和回溯相关的值。这允许`__exit__`方法执行任何可能需要的清理代码，即使发生异常。在我们的例子中，我们采取了不负责任的路径，并通过连接字符串中的字符来创建一个结果字符串，而不管是否抛出异常。
- en: 'While this is one of the simplest context managers we could write, and its
    usefulness is dubious, it does work with a `with` statement. Have a look at it
    in action:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是我们可以编写的最简单的上下文管理器之一，而且它的实用性是可疑的，但它确实可以与`with`语句一起使用。看看它的运行情况：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code constructs a string of 15 random characters. It appends these to a
    `StringJoiner` using the `append` method it inherited from `list`. When the `with`
    statement goes out of scope (back to the outer indentation level), the `__exit__`
    method is called, and the `result` attribute becomes available on the joiner object.
    We print this value to see a random string.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码构造了一个包含15个随机字符的字符串。它使用从`list`继承的`append`方法将这些字符附加到`StringJoiner`上。当`with`语句超出范围（回到外部缩进级别）时，将调用`__exit__`方法，并且连接器对象上的`result`属性变得可用。我们打印这个值来看一个随机字符串。
- en: An alternative to method overloading
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重载的替代方法
- en: One prominent feature of many object-oriented programming languages is a tool
    called **method overloading**. Method overloading simply refers to having multiple
    methods with the same name that accept different sets of arguments. In statically
    typed languages, this is useful if we want to have a method that accepts either
    an integer or a string, for example. In non-object-oriented languages, we might
    need two functions, called `add_s` and `add_i`, to accommodate such situations.
    In statically typed object-oriented languages, we'd need two methods, both called
    `add`, one that accepts strings, and one that accepts integers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多面向对象的编程语言的一个显著特点是一种称为**方法重载**的工具。方法重载简单地指的是具有相同名称但接受不同参数集的多个方法。在静态类型的语言中，如果我们想要一个方法既接受整数又接受字符串，这是很有用的。在非面向对象的语言中，我们可能需要两个函数，称为`add_s`和`add_i`，来适应这种情况。在静态类型的面向对象语言中，我们需要两个方法，都称为`add`，一个接受字符串，一个接受整数。
- en: In Python, we only need one method, which accepts any type of object. It may
    have to do some testing on the object type (for example, if it is a string, convert
    it to an integer), but only one method is required.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们只需要一个方法，它接受任何类型的对象。它可能需要对对象类型进行一些测试（例如，如果它是一个字符串，将其转换为整数），但只需要一个方法。
- en: However, method overloading is also useful when we want a method with the same
    name to accept different numbers or sets of arguments. For example, an e-mail
    message method might come in two versions, one of which accepts an argument for
    the "from" e-mail address. The other method might look up a default "from" e-mail
    address instead. Python doesn't permit multiple methods with the same name, but
    it does provide a different, equally flexible, interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，方法重载在我们希望一个方法具有相同名称但接受不同数量或一组不同参数时也很有用。例如，电子邮件消息方法可能有两个版本，其中一个接受“from”电子邮件地址的参数。另一个方法可能会查找默认的“from”电子邮件地址。Python不允许具有相同名称的多个方法，但它提供了一个不同但同样灵活的接口。
- en: 'We''ve seen some of the possible ways to send arguments to methods and functions
    in previous examples, but now we''ll cover all the details. The simplest function
    accepts no arguments. We probably don''t need an example, but here''s one for
    completeness:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在之前的例子中发送参数给方法和函数的一些可能方式，但现在我们将涵盖所有细节。最简单的函数不接受任何参数。我们可能不需要一个例子，但为了完整起见，这里有一个：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s how it''s called:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方式如下：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A function that does accept arguments will provide the names of those arguments
    in a comma-separated list. Only the name of each argument needs to be supplied.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接受参数的函数将在逗号分隔的列表中提供这些参数的名称。只需要提供每个参数的名称。
- en: 'When calling the function, these positional arguments must be specified in
    order, and none can be missed or skipped. This is the most common way we''ve specified
    arguments in our previous examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，这些位置参数必须按顺序指定，不能遗漏或跳过任何一个。这是我们在之前的例子中指定参数的最常见方式：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To call it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 调用它：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Any type of object can be passed as an argument: an object, a container, a
    primitive, even functions and classes. The preceding call shows a hardcoded string,
    an unknown variable, and an integer passed into the function.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的对象都可以作为参数传递：对象、容器、原始类型，甚至函数和类。前面的调用显示了一个硬编码的字符串、一个未知的变量和一个整数传递给函数。
- en: Default arguments
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: If we want to make an argument optional, rather than creating a second method
    with a different set of arguments, we can specify a default value in a single
    method, using an equals sign. If the calling code does not supply this argument,
    it will be assigned a default value. However, the calling code can still choose
    to override the default by passing in a different value. Often, a default value
    of `None`, or an empty string or list is suitable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使参数可选，而不是创建具有不同参数集的第二个方法，我们可以在单个方法中指定默认值，使用等号。如果调用代码没有提供此参数，它将被分配一个默认值。但是，调用代码仍然可以选择通过传入不同的值来覆盖默认值。通常，`None`、空字符串或空列表是合适的默认值。
- en: 'Here''s a function definition with default arguments:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有默认参数的函数定义：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first three arguments are still mandatory and must be passed by the calling
    code. The last two parameters have default arguments supplied.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个参数仍然是必需的，并且必须由调用代码传递。最后两个参数有默认参数。
- en: 'There are several ways we can call this function. We can supply all arguments
    in order as though all the arguments were positional arguments:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以调用这个函数。我们可以按顺序提供所有参数，就好像所有参数都是位置参数一样：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, we can supply just the mandatory arguments in order, leaving
    the keyword arguments to be assigned their default values:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以按顺序提供必需的参数，将关键字参数分配它们的默认值：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also use the equals sign syntax when calling a function to provide values
    in a different order, or to skip default values that we aren''t interested in.
    For example, we can skip the first keyword arguments and supply the second one:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在调用函数时使用等号语法提供不同顺序的值，或者跳过我们不感兴趣的默认值。例如，我们可以跳过第一个关键字参数并提供第二个参数：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Surprisingly, we can even use the equals sign syntax to mix up the order of
    positional arguments, so long as all of them are supplied:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们甚至可以使用等号语法来改变位置参数的顺序，只要所有参数都被提供：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With so many options, it may seem hard to pick one, but if you think of the
    positional arguments as an ordered list, and keyword arguments as sort of like
    a dictionary, you'll find that the correct layout tends to fall into place. If
    you need to require the caller to specify an argument, make it mandatory; if you
    have a sensible default, then make it a keyword argument. Choosing how to call
    the method normally takes care of itself, depending on which values need to be
    supplied, and which can be left at their defaults.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多选项，可能很难选择一个，但是如果你把位置参数看作一个有序列表，把关键字参数看作一种字典，你会发现正确的布局往往会自然而然地出现。如果需要要求调用者指定参数，就把它设为必需的；如果有一个合理的默认值，那就把它设为关键字参数。选择如何调用方法通常会自行解决，取决于需要提供哪些值，哪些可以保持默认值。
- en: 'One thing to take note of with keyword arguments is that anything we provide
    as a default argument is evaluated when the function is first interpreted, not
    when it is called. This means we can''t have dynamically generated default values.
    For example, the following code won''t behave quite as expected:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数需要注意的一点是，我们提供的默认参数在函数首次解释时进行评估，而不是在调用时。这意味着我们不能有动态生成的默认值。例如，以下代码的行为不会完全符合预期：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we run this code, it outputs the number 8 first, but then it outputs the
    number 5 for the call with no arguments. We had set the variable to the number
    6, as evidenced by the last line of output, but when the function is called, the
    number 5 is printed; the default value was calculated when the function was defined,
    not when it was called.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，首先输出数字8，但接着对于没有参数的调用输出数字5。我们已经将变量设置为数字6，正如输出的最后一行所证明的那样，但当函数被调用时，打印出数字5；默认值是在函数定义时计算的，而不是在调用时计算的。
- en: 'This is tricky with empty containers such as lists, sets, and dictionaries.
    For example, it is common to ask calling code to supply a list that our function
    is going to manipulate, but the list is optional. We''d like to make an empty
    list as a default argument. We can''t do this; it will create only one list, when
    the code is first constructed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这在空容器（如列表、集合和字典）中有些棘手。例如，通常要求调用代码提供一个我们的函数将要操作的列表，但列表是可选的。我们希望将一个空列表作为默认参数。我们不能这样做；它将在代码首次构造时创建一个列表：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Whoops, that's not quite what we expected! The usual way to get around this
    is to make the default value `None`, and then use the idiom `iargument = argument
    if argument else []` inside the method. Pay close attention!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这不是我们预期的结果！通常的解决方法是将默认值设为`None`，然后在方法内部使用习惯用法`iargument = argument if argument
    else []`。请注意！
- en: Variable argument lists
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数列表
- en: Default values alone do not allow us all the flexible benefits of method overloading.
    The thing that makes Python really slick is the ability to write methods that
    accept an arbitrary number of positional or keyword arguments without explicitly
    naming them. We can also pass arbitrary lists and dictionaries into such functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅使用默认值并不能让我们获得方法重载的所有灵活优势。使Python真正灵活的是能够编写接受任意数量的位置或关键字参数的方法，而不需要显式命名它们。我们还可以将任意列表和字典传递给这样的函数。
- en: 'For example, a function to accept a link or list of links and download the
    web pages could use such variadic arguments, or **varargs**. Instead of accepting
    a single value that is expected to be a list of links, we can accept an arbitrary
    number of arguments, where each argument is a different link. We do this by specifying
    the `*` operator in the function definition:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个接受链接或链接列表并下载网页的函数可以使用这样的可变参数，或者**varargs**。我们可以接受任意数量的参数，其中每个参数都是不同的链接。我们通过在函数定义中指定`*`运算符来实现这一点：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `*links` parameter says "I''ll accept any number of arguments and put them
    all in a list named `links`". If we supply only one argument, it''ll be a list
    with one element; if we supply no arguments, it''ll be an empty list. Thus, all
    these function calls are valid:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`*links`参数表示“我将接受任意数量的参数，并将它们全部放入名为`links`的列表中”。如果我们只提供一个参数，它将是一个具有一个元素的列表；如果我们不提供参数，它将是一个空列表。因此，所有这些函数调用都是有效的：'
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also accept arbitrary keyword arguments. These arrive into the function
    as a dictionary. They are specified with two asterisks (as in `**kwargs`) in the
    function declaration. This tool is commonly used in configuration setups. The
    following class allows us to specify a set of options with default values:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以接受任意关键字参数。这些参数以字典的形式传入函数。它们在函数声明中用两个星号（如`**kwargs`）指定。这个工具通常用于配置设置。以下类允许我们指定一组具有默认值的选项：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All the interesting stuff in this class happens in the `__init__` method. We
    have a dictionary of default options and values at the class level. The first
    thing the `__init__` method does is make a copy of this dictionary. We do that
    instead of modifying the dictionary directly in case we instantiate two separate
    sets of options. (Remember, class-level variables are shared between instances
    of the class.) Then, `__init__` uses the `update` method on the new dictionary
    to change any non-default values to those supplied as keyword arguments. The `__getitem__`
    method simply allows us to use the new class using indexing syntax. Here''s a
    session demonstrating the class in action:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中所有有趣的东西都发生在`__init__`方法中。我们在类级别有一个默认选项和值的字典。`__init__`方法的第一件事是复制这个字典。我们这样做是为了避免直接修改字典，以防我们实例化两组不同的选项。（请记住，类级别的变量在类的实例之间是共享的。）然后，`__init__`使用新字典上的`update`方法将任何非默认值更改为提供的关键字参数。`__getitem__`方法简单地允许我们使用新类使用索引语法。以下是演示该类工作的会话：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're able to access our options instance using dictionary indexing syntax,
    and the dictionary includes both default values and the ones we set using keyword
    arguments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字典索引语法访问我们的选项实例，字典包括默认值和我们使用关键字参数设置的值。
- en: The keyword argument syntax can be dangerous, as it may break the "explicit
    is better than implicit" rule. In the preceding example, it's possible to pass
    arbitrary keyword arguments to the `Options` initializer to represent options
    that don't exist in the default dictionary. This may not be a bad thing, depending
    on the purpose of the class, but it makes it hard for someone using the class
    to discover what valid options are available. It also makes it easy to enter a
    confusing typo ("Debug" instead of "debug", for example) that adds two options
    where only one should have existed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数语法可能是危险的，因为它可能违反“明确胜于隐式”的规则。在前面的示例中，可能会将任意关键字参数传递给`Options`初始化程序，以表示默认字典中不存在的选项。这可能不是一件坏事，这取决于类的目的，但它使得使用该类的人很难发现哪些有效选项是可用的。它还使得很容易输入令人困惑的拼写错误（例如，“Debug”而不是“debug”），从而添加两个选项，而实际上只应该存在一个选项。
- en: 'Keyword arguments are also very useful when we need to accept arbitrary arguments
    to pass to a second function, but we don''t know what those arguments will be.
    We saw this in action in [Chapter 3](ch03.html "Chapter 3. When Objects Are Alike"),
    *When Objects Are Alike*, when we were building support for multiple inheritance.
    We can, of course, combine the variable argument and variable keyword argument
    syntax in one function call, and we can use normal positional and default arguments
    as well. The following example is somewhat contrived, but demonstrates the four
    types in action:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要接受要传递给第二个函数的任意参数时，关键字参数也非常有用，但我们不知道这些参数是什么。我们在[第3章](ch03.html "第3章。当对象相似时")中看到了这一点，当我们构建多重继承的支持时。当然，我们可以在一个函数调用中结合可变参数和可变关键字参数语法，并且我们也可以使用正常的位置参数和默认参数。以下示例有些牵强，但演示了这四种类型的作用：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example will process an arbitrary list of files. The first argument is
    a target folder, and the default behavior is to move all remaining non-keyword
    argument files into that folder. Then there is a keyword-only argument, `verbose`,
    which tells us whether to print information on each file processed. Finally, we
    can supply a dictionary containing actions to perform on specific filenames; the
    default behavior is to move the file, but if a valid string action has been specified
    in the keyword arguments, it can be ignored or copied instead. Notice the ordering
    of the parameters in the function; first the positional argument is specified,
    then the `*filenames` list, then any specific keyword-only arguments, and finally,
    a `**specific` dictionary to hold remaining keyword arguments.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将处理任意文件列表。第一个参数是目标文件夹，默认行为是将所有剩余的非关键字参数文件移动到该文件夹中。然后是一个仅限关键字参数，`verbose`，它告诉我们是否要打印有关每个处理的文件的信息。最后，我们可以提供一个包含要对特定文件名执行的操作的字典；默认行为是移动文件，但如果在关键字参数中指定了有效的字符串操作，它可以被忽略或复制。请注意函数参数的顺序；首先指定位置参数，然后是`*filenames`列表，然后是任何特定的仅限关键字参数，最后是一个`**specific`字典，用于保存剩余的关键字参数。
- en: We create an inner helper function, `print_verbose`, which will print messages
    only if the `verbose` key has been set. This function keeps code readable by encapsulating
    this functionality into a single location.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个内部辅助函数`print_verbose`，只有在设置了`verbose`键时才会打印消息。这个函数通过将这个功能封装到一个单一位置来保持代码的可读性。
- en: 'In common cases, assuming the files in question exist, this function could
    be called as:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见情况下，假设所讨论的文件存在，可以调用此函数：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command would move the files `one` and `two` into the `move_here` directory,
    assuming they exist (there's no error checking or exception handling in the function,
    so it would fail spectacularly if the files or target directory didn't exist).
    The move would occur without any output, since `verbose` is `False` by default.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将文件`one`和`two`移动到`move_here`目录中，假设它们存在（函数中没有错误检查或异常处理，因此如果文件或目标目录不存在，它将失败）。由于`verbose`默认为`False`，移动将在没有任何输出的情况下发生。
- en: 'If we want to see the output, we can call it with:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要看到输出，我们可以这样调用它：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This moves one file named `three`, and tells us what it's doing. Notice that
    it is impossible to specify `verbose` as a positional argument in this example;
    we must pass a keyword argument. Otherwise, Python would think it was another
    filename in the `*filenames` list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移动名为`three`的一个文件，并告诉我们它在做什么。请注意，在这个例子中不可能将`verbose`指定为位置参数；我们必须传递关键字参数。否则，Python会认为它是`*filenames`列表中的另一个文件名。
- en: 'If we want to copy or ignore some of the files in the list, instead of moving
    them, we can pass additional keyword arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要复制或忽略列表中的一些文件，而不是移动它们，我们可以传递额外的关键字参数：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will move the sixth file and copy the fourth, but won''t display any output,
    since we didn''t specify `verbose`. Of course, we can do that too, and keyword
    arguments can be supplied in any order:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移动第六个文件并复制第四个文件，但不会显示任何输出，因为我们没有指定`verbose`。当然，我们也可以这样做，关键字参数可以以任何顺序提供：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Unpacking arguments
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包参数
- en: 'There''s one more nifty trick involving variable arguments and keyword arguments.
    We''ve used it in some of our previous examples, but it''s never too late for
    an explanation. Given a list or dictionary of values, we can pass those values
    into a function as if they were normal positional or keyword arguments. Have a
    look at this code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个关于可变参数和关键字参数的巧妙技巧。我们在之前的一些示例中使用过它，但现在解释也不算晚。给定一个值的列表或字典，我们可以将这些值传递到函数中，就好像它们是普通的位置参数或关键字参数。看看这段代码：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s what it looks like when we run it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，它看起来是这样的：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The function accepts three arguments, one of which has a default value. But
    when we have a list of three arguments, we can use the `*` operator inside a function
    call to unpack it into the three arguments. If we have a dictionary of arguments,
    we can use the `**` syntax to unpack it as a collection of keyword arguments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受三个参数，其中一个具有默认值。但是当我们有一个包含三个参数的列表时，我们可以在函数调用中使用`*`运算符将其解包为三个参数。如果我们有一个参数字典，我们可以使用`**`语法将其解包为一组关键字参数。
- en: This is most often useful when mapping information that has been collected from
    user input or from an outside source (for example, an Internet page or a text
    file) to a function or method call.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射从用户输入或外部来源（例如互联网页面或文本文件）收集的信息到函数或方法调用时，这通常是最有用的。
- en: Remember our earlier example that used headers and lines in a text file to create
    a list of dictionaries with contact information? Instead of just adding the dictionaries
    to a list, we could use keyword unpacking to pass the arguments to the `__init__`
    method on a specially built `Contact` object that accepts the same set of arguments.
    See if you can adapt the example to make this work.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们之前的例子吗？它使用文本文件中的标题和行来创建包含联系信息的字典列表？我们可以使用关键字解包将这些参数传递给专门构建的`Contact`对象上的`__init__`方法，该对象接受相同的参数集。看看你是否可以调整示例使其工作。
- en: Functions are objects too
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数也是对象
- en: Programming languages that overemphasize object-oriented principles tend to
    frown on functions that are not methods. In such languages, you're expected to
    create an object to sort of wrap the single method involved. There are numerous
    situations where we'd like to pass around a small object that is simply called
    to perform an action. This is most frequently done in event-driven programming,
    such as graphical toolkits or asynchronous servers; we'll see some design patterns
    that use it in [Chapter 10](ch10.html "Chapter 10. Python Design Patterns I"),
    *Python Design Patterns I* and [Chapter 11](ch11.html "Chapter 11. Python Design
    Patterns II"), *Python Design Patterns II*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 过分强调面向对象原则的编程语言往往不赞成不是方法的函数。在这种语言中，你应该创建一个对象来包装所涉及的单个方法。有许多情况下，我们希望传递一个简单调用以执行操作的小对象。这在事件驱动编程中最常见，例如图形工具包或异步服务器；我们将在[第10章](ch10.html
    "第10章。Python设计模式I")和[第11章](ch11.html "第11章。Python设计模式II")中看到一些使用它的设计模式，*Python设计模式I*和*Python设计模式II*。
- en: 'In Python, we don''t need to wrap such methods in an object, because functions
    already are objects! We can set attributes on functions (though this isn''t a
    common activity), and we can pass them around to be called at a later date. They
    even have a few special properties that can be accessed directly. Here''s yet
    another contrived example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们不需要将这些方法包装在对象中，因为函数本身就是对象！我们可以在函数上设置属性（尽管这不是常见的活动），并且我们可以传递它们以便在以后调用。它们甚至有一些可以直接访问的特殊属性。这里是另一个刻意的例子：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we run this code, we can see that we were able to pass two different functions
    into our third function, and get different output for each one:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们可以看到我们能够将两个不同的函数传递到我们的第三个函数中，并获得不同的输出：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We set an attribute on the function, named `description` (not very good descriptions,
    admittedly). We were also able to see the function's `__name__` attribute, and
    to access its class, demonstrating that the function really is an object with
    attributes. Then we called the function by using the callable syntax (the parentheses).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数上设置了一个名为`description`的属性（诚然，这些描述并不是很好）。我们还能够看到函数的`__name__`属性，并访问它的类，证明了函数确实是一个具有属性的对象。然后我们使用可调用语法（括号）调用了该函数。
- en: 'The fact that functions are top-level objects is most often used to pass them
    around to be executed at a later date, for example, when a certain condition has
    been satisfied. Let''s build an event-driven timer that does just this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为顶级对象的一个最常见的用途是将它们传递以便在以后的某个日期执行，例如当满足某个条件时。让我们构建一个事件驱动的定时器，它正是这样做的：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In production, this code should definitely have extra documentation using docstrings!
    The `call_after` method should at least mention that the `delay` parameter is
    in seconds, and that the `callback` function should accept one argument: the timer
    doing the calling.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，这段代码应该有额外的文档，使用文档字符串！`call_after`方法至少应该提到`delay`参数是以秒为单位的，并且`callback`函数应该接受一个参数：调用的定时器。
- en: We have two classes here. The `TimedEvent` class is not really meant to be accessed
    by other classes; all it does is store `endtime` and `callback`. We could even
    use a `tuple` or `namedtuple` here, but as it is convenient to give the object
    a behavior that tells us whether or not the event is ready to run, we use a class
    instead.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个类。`TimedEvent`类实际上并不是其他类可以访问的；它只是存储`endtime`和`callback`。我们甚至可以在这里使用`tuple`或`namedtuple`，但是为了方便起见，给对象赋予一个告诉我们事件是否准备运行的行为，我们使用了一个类。
- en: 'The `Timer` class simply stores a list of upcoming events. It has a `call_after`
    method to add a new event. This method accepts a `delay` parameter representing
    the number of seconds to wait before executing the callback, and the `callback`
    function itself: a function to be executed at the correct time. This `callback`
    function should accept one argument.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer`类只是存储了一个即将到来的事件列表。它有一个`call_after`方法来添加一个新的事件。这个方法接受一个`delay`参数，表示在执行回调之前等待的秒数，以及`callback`函数本身：在正确的时间执行的函数。这个`callback`函数应该接受一个参数。'
- en: The `run` method is very simple; it uses a generator expression to filter out
    any events whose time has come, and executes them in order. The timer loop then
    continues indefinitely, so it has to be interrupted with a keyboard interrupt
    (*Ctrl* + *C* or *Ctrl* + *Break*). We sleep for half a second after each iteration
    so as to not grind the system to a halt.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`方法非常简单；它使用生成器表达式来过滤出任何时间到来的事件，并按顺序执行它们。然后定时器循环无限继续，因此必须使用键盘中断（*Ctrl* +
    *C*或*Ctrl* + *Break*）来中断它。在每次迭代后，我们休眠半秒，以免使系统陷入停顿。'
- en: The important things to note here are the lines that touch callback functions.
    The function is passed around like any other object and the timer never knows
    or cares what the original name of the function is or where it was defined. When
    it's time to call the function, the timer simply applies the parenthesis syntax
    to the stored variable.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事情是涉及回调函数的那些行。函数像任何其他对象一样被传递，定时器从不知道或关心函数的原始名称是什么，或者它是在哪里定义的。当该函数被调用时，定时器只是将圆括号语法应用于存储的变量。
- en: 'Here''s a set of callbacks that test the timer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一组测试定时器的回调函数：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This example allows us to see how multiple callbacks interact with the timer.
    The first function is the `format_time` function. It uses the string `format`
    method to add the current time to the message, and illustrates variable arguments
    in action. The `format_time` method will accept any number of positional arguments,
    using variable argument syntax, which are then forwarded as positional arguments
    to the string's `format` method. After this, we create three simple callback methods
    that simply output the current time and a short message telling us which callback
    has been fired.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子让我们看到多个回调函数如何与定时器交互。第一个函数是`format_time`函数。它使用字符串的`format`方法将当前时间添加到消息中，并演示了可变参数的作用。`format_time`方法将接受任意数量的位置参数，使用可变参数语法，然后将它们作为位置参数转发给字符串的`format`方法。之后，我们创建了三个简单的回调方法，它们只是输出当前时间和一个简短的消息，告诉我们哪个回调已经被触发。
- en: 'The `Repeater` class demonstrates that methods can be used as callbacks too,
    since they are really just functions. It also shows why the `timer` argument to
    the callback functions is useful: we can add a new timed event to the timer from
    inside a presently running callback. We then create a timer and add several events
    to it that are called after different amounts of time. Finally, we start the timer
    running; the output shows that events are run in the expected order:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repeater`类演示了方法也可以用作回调，因为它们实际上只是函数。它还展示了回调函数中的`timer`参数的用处：我们可以在当前正在运行的回调中向定时器添加一个新的定时事件。然后，我们创建了一个定时器，并向其中添加了几个在不同时间后调用的事件。最后，我们启动了定时器；输出显示事件按预期顺序运行：'
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Python 3.4 introduces a generic event-loop architecture similar to this. We'll
    be discussing it later in [Chapter 13](ch13.html "Chapter 13. Concurrency"), *Concurrency*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.4引入了类似于这样的通用事件循环架构。我们将在[第13章](ch13.html "第13章.并发") *并发*中讨论它。
- en: Using functions as attributes
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数作为属性
- en: 'One of the interesting effects of functions being objects is that they can
    be set as callable attributes on other objects. It is possible to add or change
    a function to an instantiated object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为对象的一个有趣的效果是，它们可以被设置为其他对象的可调用属性。可以向已实例化的对象添加或更改函数：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code creates a very simple class with a `print` method that doesn't tell
    us anything we didn't know. Then we create a new function that tells us something
    we don't believe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个非常简单的类，其中包含一个不告诉我们任何新信息的`print`方法。然后我们创建了一个新的函数，告诉了我们一些我们不相信的东西。
- en: 'When we call `print` on an instance of the `A` class, it behaves as expected.
    If we then set the `print` method to point at a new function, it tells us something
    different:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`A`类的实例上调用`print`时，它的行为与预期一样。如果我们将`print`方法设置为指向一个新函数，它会告诉我们一些不同的东西：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is also possible to replace methods on classes instead of objects, although
    in that case we have to add the `self` argument to the parameter list. This will
    change the method for all instances of that object, even ones that have already
    been instantiated. Obviously, replacing methods like this can be both dangerous
    and confusing to maintain. Somebody reading the code will see that a method has
    been called and look up that method on the original class. But the method on the
    original class is not the one that was called. Figuring out what really happened
    can become a tricky, frustrating debugging session.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以替换类的方法而不是对象的方法，尽管在这种情况下，我们必须将`self`参数添加到参数列表中。这将更改该对象的所有实例的方法，即使已经实例化了这些实例。显然，这样替换方法既危险又令人困惑。阅读代码的人会看到已调用一个方法，并在原始类上查找该方法。但是在原始类上的方法并不是被调用的方法。弄清楚到底发生了什么可能会变成一个棘手的，令人沮丧的调试过程。
- en: It does have its uses though. Often, replacing or adding methods at run time
    (called **monkey-patching**) is used in automated testing. If testing a client-server
    application, we may not want to actually connect to the server while testing the
    client; this may result in accidental transfers of funds or embarrassing test
    e-mails being sent to real people. Instead, we can set up our test code to replace
    some of the key methods on the object that sends requests to the server, so it
    only records that the methods have been called.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实有其用途。通常，在运行时替换或添加方法（称为**monkey-patching**）在自动化测试中使用。如果测试客户端-服务器应用程序，我们可能不希望在测试客户端时实际连接到服务器；这可能导致资金的意外转移或向真实人员发送尴尬的测试电子邮件。相反，我们可以设置我们的测试代码来替换发送请求到服务器的对象的一些关键方法，这样它只记录这些方法已被调用。
- en: Monkey-patching can also be used to fix bugs or add features in third-party
    code that we are interacting with, and does not behave quite the way we need it
    to. It should, however, be applied sparingly; it's almost always a "messy hack".
    Sometimes, though, it is the only way to adapt an existing library to suit our
    needs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey-patching也可以用于修复第三方代码中的错误或添加我们正在交互的功能，并且不会以我们需要的方式行为。但是，它应该谨慎应用；它几乎总是一个“混乱的黑客”。不过，有时它是适应现有库以满足我们需求的唯一方法。
- en: Callable objects
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可调用对象
- en: Just as functions are objects that can have attributes set on them, it is possible
    to create an object that can be called as though it were a function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数是可以在其上设置属性的对象一样，也可以创建一个可以像函数一样被调用的对象。
- en: 'Any object can be made callable by simply giving it a `__call__` method that
    accepts the required arguments. Let''s make our `Repeater` class, from the timer
    example, a little easier to use by making it a callable:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对象都可以通过简单地给它一个接受所需参数的`__call__`方法来使其可调用。让我们通过使其可调用来使我们的`Repeater`类，从计时器示例中，更容易使用：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This example isn''t much different from the earlier class; all we did was change
    the name of the `repeater` function to `__call__` and pass the object itself as
    a callable. Note that when we make the `call_after` call, we pass the argument
    `Repeater()`. Those two parentheses are creating a new instance of the class;
    they are not explicitly calling the class. This happens later, inside the timer.
    If we want to execute the `__call__` method on a newly instantiated object, we''d
    use a rather odd syntax: `Repeater()()`. The first set of parentheses constructs
    the object; the second set executes the `__call__` method. If we find ourselves
    doing this, we may not be using the correct abstraction. Only implement the `__call__`
    function on an object if the object is meant to be treated like a function.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与之前的类没有太大的不同；我们所做的只是将`repeater`函数的名称更改为`__call__`并将对象本身作为可调用传递。请注意，当我们进行`call_after`调用时，我们传递参数`Repeater()`。这两个括号创建了一个类的新实例；它们并没有显式调用类。这发生在稍后，在计时器内部。如果我们想要在新实例化的对象上执行`__call__`方法，我们将使用相当奇怪的语法：`Repeater()()`。第一组括号构造了对象；第二组执行了`__call__`方法。如果我们发现自己这样做，我们可能没有使用正确的抽象。只有在对象被视为函数时才实现`__call__`函数。
- en: Case study
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: To tie together some of the principles presented in this chapter, let's build
    a mailing list manager. The manager will keep track of e-mail addresses categorized
    into named groups. When it's time to send a message, we can pick a group and send
    the message to all e-mail addresses assigned to that group.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将本章介绍的一些原则联系起来，让我们构建一个邮件列表管理器。该管理器将跟踪分类为命名组的电子邮件地址。当发送消息时，我们可以选择一个组，并将消息发送到分配给该组的所有电子邮件地址。
- en: 'Now, before we start working on this project, we ought to have a safe way to
    test it, without sending e-mails to a bunch of real people. Luckily, Python has
    our back here; like the test HTTP server, it has a built-in **Simple Mail Transfer
    Protocol** (**SMTP**) server that we can instruct to capture any messages we send
    without actually sending them. We can run the server with the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们开始处理这个项目之前，我们应该有一种安全的方法来测试它，而不会向一群真实的人发送电子邮件。幸运的是，Python在这方面有所帮助；就像测试HTTP服务器一样，它有一个内置的**简单邮件传输协议**（**SMTP**）服务器，我们可以指示它捕获我们发送的任何消息，而不实际发送它们。我们可以使用以下命令运行服务器：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Running this command at a command prompt will start an SMTP server running on
    port 1025 on the local machine. But we've instructed it to use the `DebuggingServer`
    class (it comes with the built-in SMTP module), which, instead of sending mails
    to the intended recipients, simply prints them on the terminal screen as it receives
    them. Neat, eh?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符下运行此命令将在本地机器上的端口1025上启动运行SMTP服务器。但是，我们已经指示它使用`DebuggingServer`类（它与内置的SMTP模块一起提供），它不会将邮件发送给预期的收件人，而是在接收到邮件时将其简单地打印在终端屏幕上。好吧，是不是很整洁？
- en: 'Now, before writing our mailing list, let''s write some code that actually
    sends mail. Of course, Python supports this in the standard library, too, but
    it''s a bit of an odd interface, so we''ll write a new function to wrap it all
    cleanly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在编写邮件列表之前，让我们编写一些实际发送邮件的代码。当然，Python也支持标准库中的邮件发送，但它的接口有点奇怪，所以我们将编写一个新的函数来清晰地包装它：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We won't cover the code inside this method too thoroughly; the documentation
    in the standard library can give you all the information you need to use the `smtplib`
    and `email` modules effectively.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过分深入地讨论此方法中的代码；标准库中的文档可以为您提供使用`smtplib`和`email`模块的所有信息。
- en: We've used both variable argument and keyword argument syntax in the function
    call. The variable argument list allows us to supply a single string in the default
    case of having a single `to` address, as well as permitting multiple addresses
    to be supplied if required. Any extra keyword arguments are mapped to e-mail headers.
    This is an exciting use of variable arguments and keyword arguments, but it's
    not really a great interface for the person calling the function. In fact, it
    makes many things the programmer will want to do impossible.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数调用中使用了变量参数和关键字参数语法。变量参数列表允许我们在默认情况下提供单个`to`地址的字符串，并允许在需要时提供多个地址。任何额外的关键字参数都将映射到电子邮件标头。这是变量参数和关键字参数的一个令人兴奋的用法，但它实际上并不是对调用函数的人来说一个很好的接口。实际上，它使得程序员想要做的许多事情都变得不可能。
- en: The headers passed into the function represent auxiliary headers that can be
    attached to a method. Such headers might include `Reply-To`, `Return-Path`, or
    *X-pretty-much-anything*. But in order to be a valid identifier in Python, a name
    cannot include the `-` character. In general, that character represents subtraction.
    So, it's not possible to call a function with `Reply-To = my@email.com`. It appears
    we were too eager to use keyword arguments because they are a new tool we just
    learned about in this chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给函数的标头表示可以附加到方法的辅助标头。这些标头可能包括`Reply-To`、`Return-Path`或*X-pretty-much-anything*。但是为了成为Python中的有效标识符，名称不能包括`-`字符。一般来说，该字符表示减法。因此，不可能使用`Reply-To
    = my@email.com`来调用函数。看来我们太急于使用关键字参数，因为这是我们在本章中刚学到的新工具。
- en: 'We''ll have to change the argument to a normal dictionary; this will work because
    any string can be used as a key in a dictionary. By default, we''d want this dictionary
    to be empty, but we can''t make the default parameter an empty dictionary. So,
    we''ll have to make the default argument `None`, and then set up the dictionary
    at the beginning of the method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要将参数更改为普通字典；这将起作用，因为任何字符串都可以用作字典中的键。默认情况下，我们希望这个字典是空的，但我们不能将默认参数设置为空字典。因此，我们将默认参数设置为`None`，然后在方法的开头设置字典：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we have our debugging SMTP server running in one terminal, we can test this
    code in a Python interpreter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个终端中运行我们的调试SMTP服务器，我们可以在Python解释器中测试这段代码：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, if we check the output from the debugging SMTP server, we get the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们检查调试SMTP服务器的输出，我们会得到以下内容：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Excellent, it has "sent" our e-mail to the two expected addresses with subject
    and message contents included. Now that we can send messages, let's work on the
    e-mail group management system. We'll need an object that somehow matches e-mail
    addresses with the groups they are in. Since this is a many-to-many relationship
    (any one e-mail address can be in multiple groups; any one group can be associated
    with multiple e-mail addresses), none of the data structures we've studied seems
    quite ideal. We could try a dictionary of group-names matched to a list of associated
    e-mail addresses, but that would duplicate e-mail addresses. We could also try
    a dictionary of e-mail addresses matched to groups, resulting in a duplication
    of groups. Neither seems optimal. Let's try this latter version, even though intuition
    tells me the groups to e-mail address solution would be more straightforward.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，它已经将我们的电子邮件发送到了两个预期的地址，并包括主题和消息内容。现在我们可以发送消息了，让我们来处理电子邮件组管理系统。我们需要一个对象，以某种方式将电子邮件地址与它们所在的组匹配起来。由于这是一对多的关系（任何一个电子邮件地址可以在多个组中；任何一个组可以与多个电子邮件地址相关联），我们学习过的数据结构似乎都不太理想。我们可以尝试一个将组名与相关电子邮件地址列表匹配的字典，但这样会重复电子邮件地址。我们也可以尝试一个将电子邮件地址与组匹配的字典，这样会导致组的重复。两者都不太理想。让我们尝试后一种版本，尽管直觉告诉我，组到电子邮件地址的解决方案可能更直接。
- en: 'Since the values in our dictionary will always be collections of unique e-mail
    addresses, we should probably store them in a `set` container. We can use `defaultdict`
    to ensure that there is always a `set` container available for each key:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们字典中的值始终是唯一电子邮件地址的集合，我们可能应该将它们存储在`set`容器中。我们可以使用`defaultdict`来确保每个键始终有一个`set`容器可用：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s add a method that allows us to collect all the e-mail addresses
    in one or more groups. This can be done by converting the list of groups to a
    set:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个方法，允许我们收集一个或多个组中的所有电子邮件地址。这可以通过将组列表转换为一个集合来完成：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, look at what we''re iterating over: `self.email_map.items()`. This method,
    of course, returns a tuple of key-value pairs for each item in the dictionary.
    The values are sets of strings representing the groups. We split these into two
    variables named `e` and `g`, short for e-mail and groups. We add the e-mail address
    to the set of return values only if the passed in groups intersect with the e-mail
    address groups. The `g & groups` syntax is a shortcut for `g.intersection(groups)`;
    the `set` class does this by implementing the special `__and__` method to call
    `intersection`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看我们正在迭代的内容：`self.email_map.items()`。这个方法当然会返回字典中每个项目的键-值对元组。值是表示组的字符串集合。我们将这些拆分成两个变量，命名为`e`和`g`，分别代表电子邮件和组。只有当传入的组与电子邮件地址组相交时，我们才将电子邮件地址添加到返回值集合中。`g
    & groups`语法是`g.intersection(groups)`的快捷方式；`set`类通过实现特殊的`__and__`方法来调用`intersection`。
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This code could be made a wee bit more concise using a set comprehension, which
    we'll discuss in [Chapter 9](ch09.html "Chapter 9. The Iterator Pattern"), *The
    Iterator Pattern*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以通过使用集合推导式变得更加简洁，我们将在[第9章](ch09.html "第9章. 迭代器模式")*迭代器模式*中讨论。
- en: 'Now, with these building blocks, we can trivially add a method to our `MailingList`
    class that sends messages to specific groups:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这些基本组件，我们可以轻松地向我们的`MailingList`类添加一个发送消息到特定组的方法：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function relies on variable argument lists. As input, it takes a list of
    groups as variable arguments. It gets the list of e-mails for the specified groups
    and passes those as variable arguments into `send_email`, along with other arguments
    that were passed into this method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数依赖于可变参数列表。作为输入，它接受一个组列表作为可变参数。它获取指定组的电子邮件列表，并将它们作为可变参数传递到`send_email`中，以及传递给这个方法的其他参数。
- en: 'The program can be tested by ensuring the SMTP debugging server is running
    in one command prompt, and, in a second prompt, loading the code using:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过确保SMTP调试服务器在一个命令提示符中运行，并在第二个提示符中使用以下代码来加载代码来测试程序：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a `MailingList` object with:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个`MailingList`对象：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then create a few fake e-mail addresses and groups, along the lines of:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一些虚假的电子邮件地址和组，类似于：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, use a command like this to send e-mails to specific groups:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下命令发送电子邮件到特定组：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: E-mails to each of the addresses in the specified groups should show up in the
    console on the SMTP server.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 指定组中每个地址的电子邮件应该显示在SMTP服务器的控制台上。
- en: The mailing list works fine as it is, but it's kind of useless; as soon as we
    exit the program, our database of information is lost. Let's modify it to add
    a couple of methods to load and save the list of e-mail groups from and to a file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件列表的工作正常，但它有点无用；一旦我们退出程序，我们的信息数据库就丢失了。让我们修改它，添加一些方法来从文件中加载和保存电子邮件组列表。
- en: In general, when storing structured data on disk, it is a good idea to put a
    lot of thought into how it is stored. One of the reasons myriad database systems
    exist is that if someone else has put this thought into how data is stored, you
    don't have to. We'll be looking at some data serialization mechanisms in the next
    chapter, but for this example, let's keep it simple and go with the first solution
    that could possibly work.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，当在磁盘上存储结构化数据时，很有必要认真考虑它的存储方式。存在众多数据库系统的原因之一是，如果其他人已经考虑过数据的存储方式，你就不必再考虑了。我们将在下一章中看一些数据序列化机制，但对于这个例子，让我们保持简单，选择可能有效的第一个解决方案。
- en: The data format I have in mind is to store each e-mail address followed by a
    space, followed by a comma-separated list of groups. This format seems reasonable,
    and we're going to go with it because data formatting isn't the topic of this
    chapter. However, to illustrate just why you need to think hard about how you
    format data on disk, let's highlight a few problems with the format.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我心目中的数据格式是存储每个电子邮件地址，后跟一个空格，再跟一个逗号分隔的组列表。这种格式似乎是合理的，我们将采用它，因为数据格式化不是本章的主题。然而，为了说明为什么你需要认真考虑如何在磁盘上格式化数据，让我们来强调一下这种格式的一些问题。
- en: 'First, the space character is technically legal in e-mail addresses. Most e-mail
    providers prohibit it (with good reason), but the specification defining e-mail
    addresses says an e-mail can contain a space if it is in quotation marks. If we
    are to use a space as a sentinel in our data format, we should technically be
    able to differentiate between that space and a space that is part of an e-mail.
    We''re going to pretend this isn''t true, for simplicity''s sake, but real-life
    data encoding is full of stupid issues like this. Second, consider the comma-separated
    list of groups. What happens if someone decides to put a comma in a group name?
    If we decide to make commas illegal in group names, we should add validation to
    ensure this to our `add_to_group` method. For pedagogical clarity, we''ll ignore
    this problem too. Finally, there are many security implications we need to consider:
    can someone get themselves into the wrong group by putting a fake comma in their
    e-mail address? What does the parser do if it encounters an invalid file?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，空格字符在技术上是合法的电子邮件地址。大多数电子邮件提供商禁止它（有充分的理由），但定义电子邮件地址的规范说，如果电子邮件地址在引号中，它可以包含空格。如果我们要在我们的数据格式中使用空格作为标记，我们应该在这个空格和电子邮件中的空格之间进行区分。出于简单起见，我们将假装这不是真的，但现实生活中的数据编码充满了这样愚蠢的问题。其次，考虑逗号分隔的组列表。如果有人决定在组名中放一个逗号会发生什么？如果我们决定在组名中禁止逗号，我们应该添加验证以确保这一点到我们的`add_to_group`方法。为了教学上的清晰，我们也将忽略这个问题。最后，有许多安全问题需要考虑：有人是否可以通过在他们的电子邮件地址中放一个虚假的逗号来把自己放入错误的组？如果解析器遇到无效文件会怎么做？
- en: The takeaway from this discussion is to try to use a data-storage method that
    has been field tested, rather than designing your own data serialization protocol.
    There are a ton of bizarre edge cases you might overlook, and it's better to use
    code that has already encountered and fixed those edge cases.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次讨论中得出的要点是，尽量使用经过现场测试的数据存储方法，而不是设计自己的数据序列化协议。你可能会忽略很多奇怪的边缘情况，最好使用已经遇到并解决了这些边缘情况的代码。
- en: 'But forget that, let''s just write some basic code that uses an unhealthy dose
    of wishful thinking to pretend this simple data format is safe:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但是忘了那个，让我们只是写一些基本的代码，使用大量的一厢情愿来假装这种简单的数据格式是安全的：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The code to do this is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的代码如下：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the `save` method, we open the file in a context manager and write the file
    as a formatted string. Remember the newline character; Python doesn't add that
    for us. The `load` method first resets the dictionary (in case it contains data
    from a previous call to `load`) uses the `for`...`in` syntax, which loops over
    each line in the file. Again, the newline character is included in the line variable,
    so we have to call `.strip()` to take it off. We'll learn more about such string
    manipulation in the next chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`save`方法中，我们使用上下文管理器打开文件并将文件写入格式化字符串。记住换行符；Python不会为我们添加它。`load`方法首先重置字典（以防它包含来自对`load`的先前调用的数据），使用`for`...`in`语法，循环遍历文件中的每一行。同样，换行符包含在行变量中，所以我们必须调用`.strip()`来去掉它。我们将在下一章中学习更多关于这种字符串操作的知识。
- en: 'Before using these methods, we need to make sure the object has a `self.data_file`
    attribute, which can be done by modifying `__init__`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些方法之前，我们需要确保对象具有`self.data_file`属性，可以通过修改`__init__`来实现：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can test these two methods in the interpreter as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在解释器中测试这两种方法，如下所示：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The resulting `addresses.db` file contains the following lines, as expected:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的“addresses.db”文件包含以下行，如预期的那样：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can also load this data back into a `MailingList` object successfully:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以成功地将这些数据加载回“MailingList”对象中：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As you can see, I forgot to do the `load` command, and it might be easy to
    forget the `save` command as well. To make this a little easier for anyone who
    wants to use our `MailingList` API in their own code, let''s provide the methods
    to support a context manager:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我忘记了“load”命令，也可能很容易忘记“save”命令。为了使任何想要在自己的代码中使用我们的“MailingList”API的人更容易一些，让我们提供支持上下文管理器的方法：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'These simple methods just delegate their work to load and save, but we can
    now write code like this in the interactive interpreter and know that all the
    previously stored addresses were loaded on our behalf, and that the whole list
    will be saved to the file when we are done:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的方法只是将它们的工作委托给load和save，但现在我们可以在交互式解释器中编写这样的代码，并知道以前存储的所有地址都已经被加载，并且在我们完成时整个列表将保存到文件中：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Exercises
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you haven't encountered the `with` statements and context managers before,
    I encourage you, as usual, to go through your old code and find all the places
    you were opening files, and make sure they are safely closed using the `with`
    statement. Look for places that you could write your own context managers as well.
    Ugly or repetitive `try`...`finally` clauses are a good place to start, but you
    may find them useful any time you need to do before and/or after tasks in context.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有遇到“with”语句和上下文管理器，我鼓励您像往常一样，浏览您的旧代码，并确保所有打开文件的地方都使用“with”语句安全关闭。还要寻找可以编写自己的上下文管理器的地方。丑陋或重复的“try”...“finally”子句是一个很好的起点，但您可能会发现它们在任何需要在上下文中执行之前和/或之后的任务时都很有用。
- en: You've probably used many of the basic built-in functions before now. We covered
    several of them, but didn't go into a great deal of detail. Play with `enumerate`,
    `zip`, `reversed`, `any` and `all`, until you know you'll remember to use them
    when they are the right tool for the job. The `enumerate` function is especially
    important; because not using it results in some pretty ugly code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在现在之前使用了许多基本的内置函数。我们涵盖了其中的一些，但没有详细讨论。尝试使用“enumerate”、“zip”、“reversed”、“any”和“all”，直到您知道在合适的情况下会记得使用它们。特别重要的是“enumerate”函数；因为不使用它会导致一些非常丑陋的代码。
- en: Also explore some applications that pass functions around as callable objects,
    as well as using the `__call__` method to make your own objects callable. You
    can get the same effect by attaching attributes to functions or by creating a
    `__call__` method on an object. In which case would you use one syntax, and when
    would it be more suitable to use the other?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 还要探索一些将函数作为可调用对象传递的应用程序，以及使用“__call__”方法使您自己的对象可调用。您可以通过将属性附加到函数或在对象上创建“__call__”方法来获得相同的效果。在哪种情况下您会使用一种语法，何时更适合使用另一种语法？
- en: Our mailing list object could overwhelm an e-mail server if there is a massive
    number of e-mails to be sent out. Try refactoring it so that you can use different
    `send_email` functions for different purposes. One such function could be the
    version we used here. A different version might put the e-mails in a queue to
    be sent by a server in a different thread or process. A third version could just
    output the data to the terminal, obviating the need for a dummy SMTP server. Can
    you construct the mailing list with a callback such that the `send_mailing` function
    uses whatever is passed in? It would default to the current version if no callback
    is supplied.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有大量的电子邮件需要发送，我们的邮件列表对象可能会使电子邮件服务器不堪重负。尝试重构它，以便您可以为不同的目的使用不同的“send_email”函数。其中一个函数可以是我们在这里使用的版本。另一个版本可能会将电子邮件放入队列，由不同的线程或进程中的服务器发送。第三个版本可能只是将数据输出到终端，从而避免了需要虚拟的SMTP服务器。您能否构建带有回调的邮件列表，以便“send_mailing”函数使用传入的任何内容？如果没有提供回调，则默认使用当前版本。
- en: The relationship between arguments, keyword arguments, variable arguments, and
    variable keyword arguments can be a bit confusing. We saw how painfully they can
    interact when we covered multiple inheritance. Devise some other examples to see
    how they can work well together, as well as to understand when they don't.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 参数、关键字参数、可变参数和可变关键字参数之间的关系可能有点令人困惑。我们看到它们在多重继承时是如何痛苦地相互作用的。设计一些其他示例，看看它们如何能够很好地协同工作，以及了解它们何时不适用。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered a grab bag of topics in this chapter. Each represented an important
    non-object-oriented feature that is popular in Python. Just because we can use
    object-oriented principles does not always mean we should!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一系列杂项主题。每个主题都代表了Python中流行的重要非面向对象的特性。仅仅因为我们可以使用面向对象的原则，并不意味着我们总是应该这样做！
- en: However, we also saw that Python typically implements such features by providing
    a syntax shortcut to traditional object-oriented syntax. Knowing the object-oriented
    principles underlying these tools allows us to use them more effectively in our
    own classes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们也看到Python通常通过为传统面向对象的语法提供语法快捷方式来实现这些功能。了解这些工具背后的面向对象原则使我们能够更有效地在自己的类中使用它们。
- en: We discussed a series of built-in functions and file I/O operations. There are
    a whole bunch of different syntaxes available to us when calling functions with
    arguments, keyword arguments, and variable argument lists. Context managers are
    useful for the common pattern of sandwiching a piece of code between two method
    calls. Even functions are objects, and, conversely, any normal object can be made
    callable.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一系列内置函数和文件I/O操作。在调用带有参数、关键字参数和可变参数列表时，我们有许多不同的语法可供选择。上下文管理器对于将一段代码夹在两个方法调用之间的常见模式非常有用。甚至函数也是对象，反之亦然，任何普通对象都可以被调用。
- en: 'In the next chapter, we''ll learn more about string and file manipulation,
    and even spend some time with one of the least object-oriented topics in the standard
    library: regular expressions.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于字符串和文件操作的知识，甚至会花一些时间来学习标准库中最不面向对象的主题之一：正则表达式。
