- en: Local Development with Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行本地开发
- en: In this chapter, you'll learn how to define a cluster, deploying all the interacting
    microservices, and how to work locally for development purposes. We will build
    on the concepts introduced in the previous chapter and we will describe how to
    configure the whole system in Kubernetes in practical terms, deploying multiple
    microservices, and how to make it work as a whole on your own local computer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何定义一个集群，部署所有交互式微服务，以及如何在本地进行开发。我们将在前一章介绍的概念基础上进行构建，并描述如何在Kubernetes中以实际方式配置整个系统，部署多个微服务，并使其在您自己的本地计算机上作为一个整体运行。
- en: 'Here, we will introduce the other two microservices: the Frontend and the Users
    Backend. They were discussed in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml), *Making
    the Move – Design, Plan, and Execute*, in the *Strategic planning to break the
    monolith* section. We will see in this chapter how they need to be configured
    to work in Kubernetes. This is in addition to the Thoughts Backend introduced
    in [Chapter 2](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml), *Creating a REST Service
    with Python;* [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml), *Build,
    Run, and Test Your Service Using Docker*, and [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml),
    *Creating a Pipeline and Workflow*. We will discuss how to configure the three
    of them properly and add some other options to ensure their smooth operation once
    they''re deployed in a production environment.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍另外两个微服务：前端和用户后端。它们在[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中讨论过，在*战略规划以打破单体*部分。我们将在本章中看到它们需要如何配置才能在Kubernetes中工作。这是除了[第2章](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml)中介绍的Thoughts后端，*使用Python创建REST服务*，[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)，*使用Docker构建、运行和测试您的服务*，和[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)，*创建管道和工作流*。我们将讨论如何正确配置它们三个，并添加一些其他选项，以确保它们在部署到生产环境后能够顺利运行。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Implementing multiple services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施多个服务
- en: Configuring the services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务
- en: Deploying the full system locally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地部署完整系统
- en: By the end of the chapter, you will have a working local Kubernetes system with
    the three microservices deployed and working as a whole. You will understand how
    the different elements work and how to configure and tweak them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有一个在本地工作的Kubernetes系统，其中三个微服务已部署并作为一个整体运行。您将了解不同元素的工作原理以及如何配置和调整它们。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need to have a local Kubernetes instance running as described
    in the previous chapter. Remember to have the Ingress controller installed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要像前一章中描述的那样运行本地Kubernetes实例。记得安装Ingress控制器。
- en: You can check the full code that we are going to use in the GitHub repository
    ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库中检查我们将在其中使用的完整代码（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06)）。
- en: Implementing multiple services
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施多个服务
- en: 'In the GitHub repo, you can find the three microservices that we will be using
    in this chapter. They are based on the monolith introduced in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml),
    *Making the Move – Design, Plan, and Execute*, and are split into three elements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub存储库中，您可以找到本章中将使用的三个微服务。它们基于[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中介绍的单体，并分为三个元素：
- en: '**Thoughts Backend**: As described in the previous chapter, this handles the
    storage of thoughts and the search for them.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thoughts后端：如前一章所述，它处理了Thoughts的存储和搜索。
- en: '**Users Backend**: This stores the users and allows them to log in. Based on
    the description of the authentication method, this creates a token that can be
    used to authenticate against other systems.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户后端：存储用户并允许他们登录。根据身份验证方法的描述，它创建一个可用于对其他系统进行身份验证的令牌。
- en: '**Frontend**: This comes from the monolith, but instead of accessing a database directly,
    it makes requests to the User and Thoughts Backends to replicate the functionality.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端：这来自单体应用，但是不直接访问数据库，而是向用户和Thoughts后端发出请求以复制功能。
- en: Note that the static files are still being served by the Frontend, even though
    we described the final stage of the cluster serving them independently. This is
    done for simplicity and to avoid having an extra service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们描述了集群独立提供静态文件的最终阶段，但静态文件仍由前端提供。这是为了简单起见，以避免多余的服务。
- en: The aforementioned services are Dockerized in similar ways to how the Thoughts
    Backend was in [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml), *Build,
    Run, and Test Your Service Using Docker*. Let's look at some of the details for
    the other microservices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述服务与Thoughts后端在[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)中的方式类似进行了Docker化，*使用Docker构建、运行和测试您的服务*。让我们看看其他微服务的一些细节。
- en: Describing the Users Backend microservice
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述用户后端微服务
- en: The code for the Users Backend can be found at [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend).
    The structure is very similar to the Thoughts Backend, a Flask-RESTPlus application
    that communicates to a PostgreSQL database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 用户后端的代码可以在[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend)找到。其结构与Thoughts后端非常相似，是一个与PostgreSQL数据库通信的Flask-RESTPlus应用程序。
- en: 'It has two endpoints, as seen in its Swagger interface:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个端点，如其Swagger接口中所示：
- en: '![](img/b3fae995-d64e-42dd-90ab-e11643f75592.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3fae995-d64e-42dd-90ab-e11643f75592.png)'
- en: 'The endpoints are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 端点如下：
- en: '|  | **Endpoint** | **Input** | **Returns** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  | **端点** | **输入** | **返回** |'
- en: '| `POST` | `/api/login` | `{username: <username>, password: <password>}` |
    `{Authorized: <token header>}` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/api/login` | `{username: <username>, password: <password>}` |
    `{Authorized: <token header>}` |'
- en: '| `POST` | `/admin/users` | `{username: <username>, password: <password>}`
    | `<new_user>` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/admin/users` | `{username: <username>, password: <password>}`
    | `<new_user>` |'
- en: The `admin` endpoint allows you to create new users, and the login API returns
    a valid header that can be used for the Thoughts Backend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`admin`端点允许您创建新用户，登录API返回一个有效的标头，可用于Thoughts Backend。'
- en: 'The users are stored in the database with the following schema:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用户存储在数据库中，具有以下架构：
- en: '| **Field** | **Format** | **Comments** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **格式** | **注释** |'
- en: '| `id` | `Integer` | Primary key |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `Integer` | 主键 |'
- en: '| `username` | `String (50)` | Username |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `username` | `String (50)` | 用户名 |'
- en: '| `password` | `String(50)` | Password stored in plain text, which is a bad
    idea, but simplifies the example |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `password` | `String(50)` | 密码以明文存储，这是一个坏主意，但简化了示例 |'
- en: '| `creation` | `Datetime` | The time of the creation of the user |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `creation` | `Datetime` | 用户创建时间 |'
- en: 'This schema, in SQLAlchemy model definition, is described using the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码描述了SQLAlchemy模型定义中的此模式：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the creation date gets stored automatically. Also, note that we store
    the password in plain text. This is a *terrible, terrible idea in a production
    service*. You can check out an article called *How to store a password in the
    database?* ([https://www.geeksforgeeks.org/store-password-database/](https://www.geeksforgeeks.org/store-password-database/))
    to get general ideas for encrypting passwords with a salt seed. You can use a
    package such as `pyscrypt` ([https://github.com/ricmoo/pyscrypt](https://github.com/ricmoo/pyscrypt))
    to implement this kind of structure in Python.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，创建日期会自动存储。还要注意，我们以明文形式存储密码。这是*在生产服务中一个可怕的主意*。您可以查看一篇名为*如何在数据库中存储密码？*的文章（[https://www.geeksforgeeks.org/store-password-database/](https://www.geeksforgeeks.org/store-password-database/)）以获取有关使用盐种加密密码的一般想法。您可以使用`pyscrypt`（[https://github.com/ricmoo/pyscrypt](https://github.com/ricmoo/pyscrypt)）等软件包在Python中实现此类结构。
- en: The users *bruce* and *stephen *are added to the `db` example as a way of having
    example data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用户*bruce*和*stephen*被添加到`db`示例中，作为示例数据。
- en: Describing the Frontend microservice
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述前端微服务
- en: The Frontend code is available in the GitHub repo. It is based on the Django
    monolith ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith))
    introduced in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml), *Making
    the Move – Design, Plan, and Execute*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前端代码可以在GitHub存储库中找到。它基于Django单体应用程序（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith)）介绍于[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)，*进行移动-设计，计划和执行*。
- en: The main difference from the monolith is that the database is not accessed.
    Therefore, there are no uses for the Django ORM. They are replaced with HTTP requests
    to the other backends. To make the requests, we use the fantastic `requests` library.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与单体应用程序的主要区别在于不访问数据库。因此，Django ORM没有用处。它们被替换为对其他后端的HTTP请求。为了发出请求，我们使用了fantastic
    `requests`库。
- en: 'For example, the `search.py` file gets converted into the following code, which
    delegates the search toward the Thoughts Backend microservice. Note how the request
    by the customer gets transformed into an internal API call to the `GET /api/thoughts`
    endpoint. The result is decoded in JSON and rendered in the template:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`search.py`文件被转换为以下代码，该代码将搜索委托给Thoughts Backend微服务。请注意，客户的请求被转换为对`GET /api/thoughts`端点的内部API调用。结果以JSON格式解码并呈现在模板中：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The monolith equivalent code can be compared in the `Chapter01` subdirectory
    of the repo ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter01/Monolith/mythoughts/thoughts/search.py](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter01/Monolith/mythoughts/thoughts/search.py)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 单体等效代码可以在存储库的`Chapter01`子目录中进行比较（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter01/Monolith/mythoughts/thoughts/search.py](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter01/Monolith/mythoughts/thoughts/search.py)）。
- en: Note how we make a `get` request through the `requests` library to the defined
    search endpoint, which results in the `json` format being returned and rendered.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过`requests`库向定义的搜索端点发出`get`请求，结果以`json`格式返回并呈现。
- en: The `THOUGTHS_BACKEND` root URL comes from the settings, in usual Django fashion.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`THOUGTHS_BACKEND`根URL来自设置，通常是Django的风格。'
- en: This example is a simple one because there's no authentication involved. The
    parameters are captured from the user interface, then routed toward the backend.
    The request gets properly formatted both toward the backend and once the result
    is obtained, and then rendered. This is the core of two microservices working
    together.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，因为没有涉及身份验证。参数从用户界面捕获，然后路由到后端。请求在发送到后端和获取结果后都得到了正确格式化，然后呈现。这是两个微服务共同工作的核心。
- en: 'A more interesting case is the `list_thought` ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/thoughts/thoughts.py#L18](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/thoughts/thoughts.py#L18))
    view. The following code lists the thoughts for the logged in user:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣的案例是`list_thought`（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/thoughts/thoughts.py#L18](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/thoughts/thoughts.py#L18)）视图。以下代码列出了已登录用户的想法：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, before doing anything, we need to check whether a user is logged in. This
    is done in the `get_username_from_session` call, which returns the `username`
    or `None`, if they're not logged in. If they're not logged in, the return gets
    redirected to the login screen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在做任何事情之前，我们需要检查用户是否已登录。这是在 `get_username_from_session` 调用中完成的，它返回 `username`
    或 `None`（如果他们未登录）。如果他们未登录，则返回将被重定向到登录屏幕。
- en: As this endpoint requires authentication, we need to add the session from the
    user in an `Authorization` header to our request. The session of the user can
    be obtained from the `request.COOKIES` dictionary.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此端点需要身份验证，因此我们需要将用户的会话添加到请求的 `Authorization` 标头中。用户的会话可以从 `request.COOKIES`
    字典中获取。
- en: As a safeguard, we need to check whether the returning status code from the
    backend is correct. For this call, any resulting status code that's not a 200
    (HTTP call correct) will produce a redirection to the login page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为保障，我们需要检查后端返回的状态代码是否正确。对于此调用，任何不是200（HTTP调用正确）的结果状态代码都将导致重定向到登录页面。
- en: For simplicity and clarity, our example services are not handling different
    error cases. In a production system, there should be a differentiation between
    errors where the issue is that either the user is not logged in or there's another
    kind of user error (a 400 error), or the backend service is not available (a 500
    status code).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单和清晰起见，我们的示例服务不处理不同的错误情况。在生产系统中，应该区分错误，其中问题是用户未登录或存在其他类型的用户错误（400错误），或者后端服务不可用（500状态码）。
- en: Error handling, when done properly, is difficult, but worth doing well, especially
    if the error helps users to understand what happened.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理，如果做得当，是困难的，但值得做好，特别是如果错误帮助用户理解发生了什么。
- en: 'The `get_username_from_session` function encapsulates a call to `validate_token_header`,
    the same one as introduced in the previous chapter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_username_from_session` 函数封装了对 `validate_token_header` 的调用，与上一章介绍的相同：'
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `settings` file contains the public key required to decode the token.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings` 文件包含解码令牌所需的公钥。'
- en: In this chapter, for simplicity, we copied the key directly into the `settings`
    file. This is not the way to go for a production environment. Any secret should
    be obtained through the Kubernetes environment configuration. We will see how
    to do this in the following chapters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，为简单起见，我们直接将密钥复制到 `settings` 文件中。这不适用于生产环境。任何秘密都应通过Kubernetes环境配置获取。我们将在接下来的章节中看到如何做到这一点。
- en: The environment file needs to specify where both the base URLs for the Users
    Backend and the Thoughts Backend are, to be able to connect to them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 环境文件需要指定用户后端和Thoughts后端的基本URL，以便能够连接到它们。
- en: Connecting the services
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接服务
- en: It's possible to test the services working in unison only with `docker-compose`.
    Check that the `docker-compose.yaml` files in both the Users Backend and the Thoughts
    Backend expose different ports externally.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 只有使用 `docker-compose` 才能测试服务是否协同工作。检查Users后端和Thoughts后端的 `docker-compose.yaml`
    文件是否在外部公开了不同的端口。
- en: 'The Thoughts Backend exposes port `8000` and the Users Backend exposes port
    `8001`. This allows the Frontend to connect to them (and expose port `8002`).
    This diagram shows how this system works:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Thoughts后端公开端口`8000`，用户后端公开端口`8001`。这允许前端连接到它们（并公开端口`8002`）。此图显示了此系统的工作原理：
- en: '![](img/1a463150-339d-4bf2-8a94-374bb6a34ec3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a463150-339d-4bf2-8a94-374bb6a34ec3.png)'
- en: You can see how the three services are isolated, as `docker-compose` will create
    its own network for them to connect. Both backends have their own container, which
    acts as the database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到三个服务是如何隔离的，因为 `docker-compose` 将为它们创建自己的网络以进行连接。两个后端都有自己的容器，充当数据库。
- en: The Frontend service needs to connect to the others. The URL of the services
    should be added to the `environment.env` file and should indicate the service
    with the IP of the computer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前端服务需要连接到其他服务。服务的URL应该添加到 `environment.env` 文件中，并且应该指示具有计算机IP的服务。
- en: An internal IP such as localhost or `127.0.0.1` does not work, as it gets interpreted
    **inside the container. **You can obtain the local IP by running `ifconfig`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 内部IP，如localhost或`127.0.0.1`，不起作用，因为它在容器内部被解释。您可以通过运行 `ifconfig` 来获取本地IP。
- en: 'For example, if your local IP is `10.0.10.3`, the `environment.env` file should
    contain the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的本地IP是 `10.0.10.3`，则 `environment.env` 文件应包含以下内容：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you access the Frontend service in your browser, it should connect to the
    other services.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中访问前端服务，它应该连接到其他服务。
- en: A possibility could be to generate a bigger `docker-compose` file that includes
    everything. This could make sense if all the microservices are in the same Git
    repo, a technique known as **monorepo** ([https://gomonorepo.org/](https://gomonorepo.org/)).
    Possible problems include keeping both the internal `docker-compose` to work with
    a single system and the general one in sync so that the automated tests should
    detect any problems.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能性是生成一个更大的 `docker-compose` 文件，其中包括所有内容。如果所有微服务都在同一个Git存储库中，这可能是有意义的，这种技术被称为**monorepo**
    ([https://gomonorepo.org/](https://gomonorepo.org/))。可能的问题包括保持内部的 `docker-compose`
    与单个系统一起工作，并使通用的 `docker-compose` 保持同步，以便自动化测试应该检测到任何问题。
- en: This structure is a bit cumbersome, so we can transform it into a proper Kubernetes
    cluster, aiming at local development.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构有点累赘，因此我们可以将其转换为一个适当的Kubernetes集群，以便进行本地开发。
- en: Configuring the services
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务
- en: 'To configure the apps in Kubernetes, we need to define the following Kubernetes
    objects per app:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Kubernetes中配置应用程序，我们需要为每个应用程序定义以下Kubernetes对象：
- en: '**Deployment**: The deployment will control the creation of pods, so they will
    always be available. It will also create them based on the image and will add
    configuration, where needed. The pod runs the app.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：部署将控制pod的创建，因此它们将始终可用。它还将根据镜像创建它们，并在需要时添加配置。Pod运行应用程序。'
- en: '**Service**: The service will make the RESTful requests available inside the
    cluster, with a short name. This routes the requests to any available pod.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Service**：该服务将使 RESTful 请求在集群内部可用，具有简短的名称。这将路由请求到任何可用的 pod。'
- en: '**Ingress**: This makes the service available outside of the cluster, so we
    can access the app from outside the cluster.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ingress**：这使得服务在集群外部可用，因此我们可以从集群外部访问该应用。'
- en: In this section, we will look at the Thoughts Backend configuration in detail
    as an example. Later, we will see how the different parts connect. We created
    a Kubernetes sub-directory ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/thoughts_backend/kubernetes](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/thoughts_backend/kubernetes))
    to store the `.yaml` files with each of the definitions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细查看 Thoughts Backend 配置作为示例。稍后，我们将看到不同部分是如何连接的。我们创建了一个 Kubernetes 子目录
    ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/thoughts_backend/kubernetes](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/thoughts_backend/kubernetes))
    来存储每个定义的 `.yaml` 文件。
- en: 'We will use the `example` namespace, so be sure that it''s created:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `example` 命名空间，因此请确保它已创建：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's start with the first Kubernetes object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个 Kubernetes 对象开始。
- en: Configuring the deployment
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置部署
- en: For the Thoughts Backend deployment, we will deploy a pod with two containers,
    one with the database, and another with the application. This configuration makes
    it easy to work locally but keep in mind that recreating the pod will restart
    both containers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Thoughts Backend 部署，我们将部署一个具有两个容器的 pod，一个带有数据库，另一个带有应用程序。这种配置使得在本地工作变得容易，但请记住，重新创建
    pod 将重新启动两个容器。
- en: 'The file for configuration is fully available here ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/deployment.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/deployment.yaml)),
    so let''s take a look at its different parts. The first element describes what
    it is and its name, as well as the namespace it lives at:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件完全在这里可用 ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/deployment.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/deployment.yaml))，让我们来看看它的不同部分。第一个元素描述了它是什么以及它的名称，以及它所在的命名空间：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we generate `spec`. It contains how many pods we should keep and the
    template for each pod. `selector` defines what labels are monitored, and it should
    match the `labels` in the template:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们生成 `spec`。它包含我们应该保留多少个 pod 以及每个 pod 的模板。`selector` 定义了要监视的标签，它应该与模板中的 `labels`
    匹配：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `template` section defines the containers in its own `spec` section:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 部分在其自己的 `spec` 部分中定义了容器：'
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`thoughts-backend-db` is simpler. The only required element is to define the
    name of the container and the image. We need to define the pulling policy as `Never`
    to indicate that the image is available in the local Docker repo, and that it''s
    not necessary to pull it from a remote registry:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`thoughts-backend-db` 更简单。唯一需要的元素是定义容器的名称和镜像。我们需要将拉取策略定义为 `Never`，以指示镜像在本地
    Docker 仓库中可用，并且不需要从远程注册表中拉取它：'
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`thoughts-backend-service` needs to define the exposed port for the service
    as well as the environment variables. The variable values are the ones that we
    used previously when creating the database, except for `POSTGRES_HOST`, where
    we have the advantage that all containers in the same pod share the same IP:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`thoughts-backend-service` 需要定义服务的暴露端口以及环境变量。变量的值是我们在创建数据库时使用的值，除了 `POSTGRES_HOST`，在这里我们有一个优势，即同一
    pod 中的所有容器共享相同的 IP：'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get the deployment in Kubernetes, you need to apply the file, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kubernetes 中获取部署，需要应用该文件，如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The deployment is now created in the cluster:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 部署现在已在集群中创建：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This creates pods automatically. If the pod is deleted or crashes, the deployment
    will restart it with a different name:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动创建 pods。如果 pod 被删除或崩溃，部署将使用不同的名称重新启动它：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The deployment is tracking the latest image, but it won''t create a new pod
    unless it''s deleted. To make changes, be sure to delete the pod manually, after
    which it will be recreated:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 部署正在跟踪最新的镜像，但除非删除，否则不会创建新的 pod。要进行更改，请确保手动删除 pod，之后它将被重新创建：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The application is still not discoverable inside the cluster, other than referring
    to it by its specific pod name, which can change, so we need to create a service
    for that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序在集群内部仍然无法被发现，除非通过其特定的 pod 名称引用它，而这个名称可能会改变，因此我们需要为此创建一个服务。
- en: Configuring the service
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务
- en: 'We create a Kubernetes service to create a name for the application exposed
    by the created deployment. The service can be checked in the `service.yaml` file.
    Let''s take a look:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 Kubernetes 服务来为创建的部署公开的应用程序创建一个名称。服务可以在 `service.yaml` 文件中进行检查。让我们来看一下：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The initial data is similar to the deployment. The `spec` section defines the
    open ports, routing access to the service on port `80` to port `8000` in containers
    in `thoughts-backend`, the name of the deployment. The `selector` part routes
    all the requests to any pod that matches.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 初始数据类似于部署。`spec` 部分定义了开放端口，将对 `thoughts-backend` 中的容器中的服务的端口 `80` 的访问路由到端口 `8000`，部署的名称。`selector`
    部分将所有请求路由到与之匹配的任何 pod。
- en: 'The type is `NodePort` to allow access from outside the cluster. This allows
    us to check that it is working correctly, once we find the externally exposed
    IP:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `NodePort`，以允许从集群外部访问。这使我们能够检查它是否正常工作，一旦找到外部暴露的 IP：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can access the Thoughts Backend by accessing localhost with the described
    pod. In this case, `http://127.0.0.1:31600`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问所描述的 pod 的本地主机来访问 Thoughts Backend。在这种情况下，`http://127.0.0.1:31600`：
- en: '![](img/4281d880-2b90-4375-b757-16fca37b7c00.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4281d880-2b90-4375-b757-16fca37b7c00.png)'
- en: The service gives us an internal name, but if we want to have control over how
    it is exposed externally, we need to configure an Ingress.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 服务为我们提供了内部名称，但是如果我们想要控制它如何在外部暴露，我们需要配置Ingress。
- en: Configuring the Ingress
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Ingress
- en: 'Finally, we describe the Ingress in `ingress.yaml` ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/ingress.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/ingress.yaml)).
    The file is copied here. Note how we set up the metadata to live in the proper
    namespace:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`ingress.yaml`中描述Ingress（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/ingress.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/ingress.yaml)）。文件在此处复制。注意我们如何设置元数据以存储在正确的命名空间中：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This Ingress will make the service be exposed to the nodes on port `80`. As
    multiple services can be exposed on the same nodes, they get distinguished by
    their hostname, in this case, `thoughts.example.local`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此Ingress将使服务在端口`80`上暴露给节点。由于多个服务可以在同一节点上暴露，它们通过主机名进行区分，在本例中为`thoughts.example.local`。
- en: The Ingress controller we are using only allows exposing ports `80` (HTTP) and
    `443` (HTTPS) in `servicePort`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的Ingress控制器只允许在`servicePort`中暴露端口`80`（HTTP）和`443`（HTTPS）。
- en: 'After applying the service, we can try to access the page, but, unless we address
    the calls toward the proper host, we will get a 404 error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务后，我们可以尝试访问页面，但是，除非我们将调用指向正确的主机，否则我们将收到404错误：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to be able to point any request to `thoughts.example.local` to our
    localhost. In Linux and macOS, the easiest way is to change your `/etc/hosts`
    file to include the following line:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够将任何请求指向`thoughts.example.local`到我们的本地主机。在Linux和macOS中，最简单的方法是更改您的`/etc/hosts`文件，包括以下行：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we can use a browser to check our application, this time in `http://thoughts.example.local`
    (and port `80`):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用浏览器检查我们的应用程序，这次是在`http://thoughts.example.local`（端口`80`）：
- en: '![](img/ce2705b4-0075-4086-9b08-df80806271e5.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce2705b4-0075-4086-9b08-df80806271e5.png)'
- en: Defining different host entries allows us to access all the services externally,
    to be able to tweak them and debug problems. We will define the rest of the Ingresses
    in the same way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义不同的主机条目允许我们外部访问所有服务，以便能够调整它们并调试问题。我们将以相同的方式定义其余的Ingresses。
- en: If you get a `Connection refused` error and the word `localhost` does not appear
    when running `kubectl get ingress -n example`, your Kubernetes installation does
    not have the Ingress controller installed. Double-check the installation documentation
    at [https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md.](https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行`kubectl get ingress -n example`时出现`Connection refused`错误，并且单词`localhost`没有出现，那么您的Kubernetes安装没有安装Ingress控制器。请仔细检查安装文档[https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md.](https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md)
- en: So now we have a working application deployed in Kubernetes locally!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们在Kubernetes中本地部署了一个可工作的应用程序！
- en: Deploying the full system locally
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地部署完整系统
- en: Each of our microservices works on its own, but to have the whole system working,
    we need to deploy the three of them (Thoughts Backend, Users Backend, and Frontend)
    and connect them to each other. The Frontend, in particular, requires the other
    two microservices to be up and running. With Kubernetes, we can deploy it locally.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个微服务都可以独立运行，但是要使整个系统工作，我们需要部署这三个（Thoughts后端、用户后端和前端）并将它们连接在一起。特别是前端需要其他两个微服务正在运行。使用Kubernetes，我们可以在本地部署它。
- en: To deploy the full system, we need to deploy the Users Backend first, and then
    the Frontend. We will describe each of these systems, relating them to the already
    deployed Thoughts Backend, which we saw how to deploy before.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署完整系统，我们需要先部署用户后端，然后是前端。我们将描述这些系统的每一个，将它们与已部署的Thoughts后端相关联，我们之前看到如何部署它。
- en: Deploying the Users Backend
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署用户后端
- en: 'The Users Backend files are very similar to the Thoughts Backend. You can check
    them in the GitHub repo ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend/kubernetes](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend/kubernetes)).
    Be sure that the environment settings in the `deployment.yaml` values are correct:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用户后端文件与Thoughts后端非常相似。您可以在GitHub存储库中检查它们（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend/kubernetes](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend/kubernetes)）。确保`deployment.yaml`中的环境设置值是正确的：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remember to be sure to include the new hostname in `/etc/hosts`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记得确保在`/etc/hosts`中包含新的主机名：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can access the Users Backend in `http://users.example.local`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`http://users.example.local`访问用户后端。
- en: Adding the Frontend
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加前端
- en: 'The Frontend service and Ingress are very similar to the previous ones. The
    deployment is slightly different. Let''s take a look at the configuration, in
    three groups:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前端服务和Ingress与先前的非常相似。部署略有不同。让我们分三组查看配置：
- en: 'First, we add the metadata about the `namespace`, `name`, and the `kind` (deployment)
    as shown in the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加关于`namespace`、`name`和`kind`（deployment）的元数据，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we define the `spec` with the template and the number of `replicas`.
    Only one replica is fine for a local system:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用模板和`replicas`的数量定义`spec`。对于本地系统来说，一个副本就可以了：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we `spec` out the template with the container definition:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用容器定义`spec`模板：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The main difference from the previously defined Thoughts Backend deployment
    is that there's a single container and that the environment on it is simpler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前定义的Thoughts后端部署的主要区别在于只有一个容器，而且它上面的环境更简单。
- en: We define the backend URLs environments as the service endpoints. These endpoints
    are available inside the cluster, so they'll be directed to the proper containers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将后端URL环境定义为服务端点。这些端点在集群内可用，因此它们将被定向到适当的容器。
- en: Remember that the `*.example.local` addresses are only available in your computer,
    as they only live in `/etc/hosts`. Inside the container, they won't be available.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`*.example.local`地址仅在您的计算机上可用，因为它们只存在于`/etc/hosts`中。在容器内，它们将不可用。
- en: This is suitable for local development, but an alternative is to have a DNS
    domain that can be redirected to `127.0.0.1` or similar.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于本地开发，但另一种选择是拥有一个可以重定向到`127.0.0.1`或类似地址的DNS域。
- en: 'We should add a new domain name in the `/etc/hosts` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在`/etc/hosts`文件中添加一个新的域名：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Django requires you to set up the `ALLOWED_HOSTS` setting's value, to allow
    it to accept the hostname, as, by default, it only allows connections from localhost.
    See the Django documentation ([https://docs.djangoproject.com/en/2.2/ref/settings/#allowed-hosts](https://docs.djangoproject.com/en/2.2/ref/settings/#allowed-hosts))
    for more information. To simplify things, we can allow any host using `'*'`. Check
    out the code on GitHub ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/mythoughts/settings.py#L28](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/mythoughts/settings.py#L28)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Django要求您设置`ALLOWED_HOSTS`设置的值，以允许它接受主机名，因为默认情况下它只允许从localhost进行连接。有关更多信息，请参阅Django文档([https://docs.djangoproject.com/en/2.2/ref/settings/#allowed-hosts](https://docs.djangoproject.com/en/2.2/ref/settings/#allowed-hosts))。为了简化事情，我们可以使用`'*'`来允许任何主机。在GitHub上查看代码([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/mythoughts/settings.py#L28](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/mythoughts/settings.py#L28))。
- en: In production, it's good practice to limit the hosts to the **Fully Qualified
    Domain Name** (**FQDN**), the full DNS name of a host, but the Kubernetes Ingress
    will check the host header and reject it if it's not correct.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，将主机限制为**完全限定域名**（**FQDN**），主机的完整DNS名称是一个良好的做法，但Kubernetes Ingress将检查主机头并在不正确时拒绝它。
- en: 'The Frontend application gets deployed as we''ve done before:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用程序将像以前一样部署：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then we can access the full system, login, search, and so on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以访问整个系统，登录，搜索等。
- en: Remember that there are two users, `bruce` and `stephen`. Their passwords are
    the same as their usernames. You don't need to be logged in to search.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 记住有两个用户，`bruce`和`stephen`。他们的密码与他们的用户名相同。您无需登录即可搜索。
- en: 'In your browser, go to `http://frontend.example.local/`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，转到`http://frontend.example.local/`：
- en: '![](img/b45ab968-9029-4a8b-9c2a-7571d2057c07.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b45ab968-9029-4a8b-9c2a-7571d2057c07.png)'
- en: Congratulations! You have a working Kubernetes system, including different deployed
    microservices. You can access each of the microservices independently to debug
    it or to carry out actions such as creating a new user, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您拥有一个工作的Kubernetes系统，包括不同的部署的微服务。您可以独立访问每个微服务以进行调试或执行操作，例如创建新用户等。
- en: If you need to deploy a new version, build the proper containers using the `docker-compose`
    build and delete the pod to force the recreation of it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要部署新版本，请使用`docker-compose`构建适当的容器并删除pod以强制重新创建它。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to deploy our microservices in a Kubernetes local
    cluster to allow local development and testing. Having the whole system deployed
    on your local computer greatly simplifies developing new features or debugging
    the behavior of the system. The production environment will be very similar, so
    this also lays the foundation for it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在Kubernetes本地集群中部署我们的微服务，以允许本地开发和测试。在本地计算机上部署整个系统大大简化了开发新功能或调试系统行为的过程。生产环境将非常相似，因此这也为其奠定了基础。
- en: We first described the two microservices that were missing. The Users Backend
    handles the authentication for users and Frontend is a modified version of the
    monolith presented in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml),
    *Making the Move – Design, Plan, and Execute*, which connects to the two backends.
    We showed how to build and run them in a `docker-compose` way.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先描述了两个缺失的微服务。用户后端处理用户的身份验证，前端是[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中介绍的单体的修改版本，*进行移动-设计，计划和执行*，它连接到两个后端。我们展示了如何以`docker-compose`的方式构建和运行它们。
- en: After that, we described how to set up a combination of `.yaml` files to configure
    applications properly in Kubernetes. Each microservice has its own deployment
    to define the available pods, a service to define a stable access point, and an
    Ingress to allow external access. We described them in detail, and then applied
    them to all of the microservices.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们描述了如何设置一组`.yaml`文件来在Kubernetes中正确配置应用程序。每个微服务都有自己的部署来定义可用的pod，一个服务来定义一个稳定的访问点，以及一个Ingress来允许外部访问。我们对它们进行了详细描述，然后将它们应用到所有的微服务上。
- en: In the next chapter, we will see how to move from local deployment and deploy
    a Kubernetes cluster ready for production.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何从本地部署转移到部署准备好生产的Kubernetes集群。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the three microservices that we are deploying?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在部署的三个微服务是什么？
- en: Which microservice requires the other two to be available?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个微服务需要其他两个可用？
- en: Why do we need to use external IPs to connect the microservices while running
    in `docker-compose`?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要在运行`docker-compose`时使用外部IP来连接微服务？
- en: What are the main Kubernetes objects required for each application?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个应用程序所需的主要Kubernetes对象是什么？
- en: Are any of the objects not required?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些对象是不必要的？
- en: Can you see any issues if we scale any of the microservices to more than one
    pod?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将任何微服务扩展到多个pod，您能看到任何问题吗？
- en: Why are we using the `/etc/hosts` file?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要使用`/etc/hosts`文件？
- en: Further reading
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can learn more about Kubernetes in the books *Kubernetes for Developers*
    ([https://www.packtpub.com/eu/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/eu/virtualization-and-cloud/kubernetes-developers))
    and *Kubernetes Cookbook - Second Edition* ([https://www.packtpub.com/in/virtualization-and-cloud/kubernetes-cookbook-second-edition](https://www.packtpub.com/in/virtualization-and-cloud/kubernetes-cookbook-second-edition)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书籍《Kubernetes for Developers》（[https://www.packtpub.com/eu/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/eu/virtualization-and-cloud/kubernetes-developers)）和《Kubernetes
    Cookbook - Second Edition》（[https://www.packtpub.com/in/virtualization-and-cloud/kubernetes-cookbook-second-edition](https://www.packtpub.com/in/virtualization-and-cloud/kubernetes-cookbook-second-edition)）中了解更多关于Kubernetes的信息。
