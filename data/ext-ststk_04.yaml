- en: Chapter 4. Wrapping States Around Execution Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：将状态包裹在执行模块周围
- en: 'Now that we''ve covered execution modules and configuration modules, it''s
    time to talk about configuration management. The idea behind a state module is
    to use execution modules as a mechanism for bringing a resource to a certain state:
    a package is in an installed state, a service is in a running state, a file''s
    contents match the state defined on the Master. In this chapter, we''ll discuss:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了执行模块和配置模块，是时候讨论配置管理了。状态模块背后的想法是使用执行模块作为一个机制，将资源带到某种状态：一个软件包处于安装状态，一个服务处于运行状态，一个文件的内容与Master上定义的状态相匹配。在本章中，我们将讨论：
- en: The concepts behind a basic state module layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本状态模块布局背后的概念
- en: Deciding how far to take each state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定每个状态要推进多远
- en: Troubleshooting state modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除状态模块
- en: Forming a state module
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建状态模块
- en: State modules are more structured than most other kinds of modules, but as you'll
    soon see, that actually makes them easier to write.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模块比大多数其他类型的模块更有结构，但正如你很快就会看到的，这实际上使它们更容易编写。
- en: Determining state
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定状态
- en: 'There is a set of operations that a state module must take in order to perform
    its job, and as those operations are done, there is certain data that is stored.
    Let''s start off with a pseudo piece of code, and explain each component in turn:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模块必须执行一系列操作以完成其工作，并且在这些操作执行过程中，会存储某些数据。让我们从一个伪代码片段开始，并依次解释每个组件：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The __virtual__() function
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`__virtual__()` 函数'
- en: By now, you're already familiar with this function, but I want to mention it
    here again. Because execution modules are meant to perform the heavy lifting,
    it is crucial to make sure that they are available before trying to make use of
    them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经熟悉这个函数了，但我想在这里再次提到它。因为执行模块旨在执行繁重的工作，所以在尝试使用它们之前确保它们可用是至关重要的。
- en: There's a good chance you'll need to cross-call multiple functions inside your
    state module. Usually, you'll call at least one function to check for the status
    of the item in question, and at least one more to bring the item into the desired
    configuration. But if they're all in the same execution module, you really only
    need to check for the presence of one of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 很有可能你需要在你的状态模块内部跨调用多个函数。通常，你会调用至少一个函数来检查相关项的状态，至少再调用一个来将项带入所需的配置。但如果它们都在同一个执行模块中，你实际上只需要检查其中一个的存在。
- en: 'Say you were going to write a state that used the `http.query` execution module
    to perform lookups and make changes to a web resource. That function should always
    be available, but for the sake of demonstration, we''ll assume that we need to
    check for it. One way to write the function would be:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将要编写一个使用 `http.query` 执行模块进行查找和更改Web资源的状态的函数。这个函数应该始终可用，但为了演示的目的，我们将假设我们需要检查它。编写这个函数的一种方法可以是：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There is also a shorter way to do this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一种更简短的方式来做到这一点：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setting up defaults
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置默认值
- en: 'With the `__virtual__()` function out of the way, we can move on to the stateful
    function itself. First we set up some default variables in a dictionary. In our
    example, and in most state modules, the dictionary is called `ret`. This is by
    convention only, and is not an actual requirement. However, the keys and their
    data types inside the dictionary are a hard requirement. These keys are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完 `__virtual__()` 函数之后，我们可以继续讨论状态函数本身。首先，我们在字典中设置一些默认变量。在我们的示例中，以及在大多数状态模块中，这个字典被称为
    `ret`。这仅是一种惯例，并不是实际的要求。然而，字典内部的键及其数据类型是硬性要求。这些键包括：
- en: '`name` (string) – This is the name of the resource that is passed into the
    state. This is also known as the ID from the state. For instance, in the following
    state:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`（字符串）- 这是传递到状态中的资源的名称。这也被称为状态中的ID。例如，在以下状态中：'
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The name passed in would be `nginx`.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传入的名称将是 `nginx`。
- en: '`changes` (dictionary) – If the state applies any changes to the Minion, this
    dictionary will contain an entry for each of the changes that was applied. For
    instance, if `pkg.installed` was used to install `nginx`, the `changes` dictionary
    would look like:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changes`（字典）- 如果状态对Minion应用了任何更改，这个字典将包含对已应用的每个更改的条目。例如，如果使用了 `pkg.installed`
    来安装 `nginx`，则 `changes` 字典将如下所示：'
- en: '[PRE4]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is no restriction imposed on the type of data stored in `changes`, so
    long as `changes` itself is a dictionary. If changes are made, then this dictionary
    *must* have something in it.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对存储在`changes`中的数据类型没有限制，只要`changes`本身是一个字典。如果进行了更改，则此字典*必须*包含一些内容。
- en: '`result` (boolean) – This field is one of three values: `True`, `False`, or
    `None`. If the specified resource is already in the state that it was meant to
    be in, or it was successfully made to be in that state, this field will be `True`.
    If the resource was not in the correct state, but `salt` was run with `test=True`,
    then this field is set to `None`. If the resource was not in the correct state,
    and Salt was unable to put it into the correct state, then this field will be
    set to `False`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result`（布尔值）- 此字段是三个值之一：`True`、`False`或`None`。如果指定的资源已经处于它应该处于的状态，或者它已经被成功配置到该状态，则此字段将为`True`。如果资源不在正确的状态，但`salt`以`test=True`运行，则此字段设置为`None`。如果资源不在正确的状态，并且Salt无法将其置于正确的状态，则此字段设置为`False`。'
- en: When performing a state run, such as `state.highstate`, the value of the result
    will affect the color of the output. States that are `True`, but have no `changes`,
    will be green. States that are `True` and have `changes` will be blue. States
    that are `None` will be yellow. States that are `False` will be red.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行状态运行，如`state.highstate`时，结果值将影响输出的颜色。状态为`True`但没有`changes`的状态将是绿色。状态为`True`且有`changes`的状态将是蓝色。状态为`None`的状态将是黄色。状态为`False`的状态将是红色。
- en: '`comment` (string) – This field is entirely freeform: it may contain any comments
    you want, or no comments. However, it is better to have some comment, even as
    short as `The requested resource is already in the desired state`. If the result
    is `None` or `False`, then the `comment` should contain a message that is as helpful
    as possible concerning why the resource is not configured properly, and how that
    may be corrected.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comment`（字符串）- 此字段完全自由格式：它可以包含任何你想要的注释，或者没有注释。然而，最好有一些注释，即使像“请求的资源已经处于期望状态”这样简短也行。如果结果是`None`或`False`，则`comment`应包含尽可能有帮助的消息，说明为什么资源没有正确配置，以及如何纠正。'
- en: 'The defaults that we use in our example will be good for almost any state:'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在示例中使用的默认值几乎适用于任何状态：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Checking for truth
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查真实性
- en: 'After the defaults have been set, the next task is to check the resource and
    see whether or not it is in the desired state:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置默认值之后，接下来的任务是检查资源，看看它是否处于期望的状态：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This may be a quick check using a single function in an execution module, or
    it may consist of much more logic requiring several functions to be cross-called.
    Don't add any more code here than is necessary to check the state of the resource;
    remember that all heavy lifting should be performed in the execution module.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个使用执行模块中的单个函数进行的快速检查，或者可能包含需要跨调用几个函数的更多逻辑。不要在这里添加任何不必要的代码来检查资源的状态；记住，所有重负载都应该在执行模块中完成。
- en: If the resource is found to be properly configured, then the `result` is set
    to `True`, a helpful `comment` is added, and the function `return`s. If the resource
    is not properly configured, then we move on to the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现资源配置得当，则将`result`设置为`True`，添加一个有用的`comment`，然后函数`return`s。如果资源没有正确配置，则继续下一部分。
- en: Checking for test mode
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查测试模式
- en: If the code makes it past the check for truth, then we can assume that something
    is wrong. But before we make any changes to the system, we need to see whether
    or not `salt` was called with `test=True`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码通过了真实性检查，那么我们可以假设有问题。但在对系统进行任何更改之前，我们需要查看`salt`是否以`test=True`被调用。
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If so, we set a helpful `comment` for the user, and then `return` the `ret`
    dictionary. If there is any more logic that happens once it has been determined
    that `salt` is running in `test` mode, then it should only be to give the user
    more helpful information in the comment. No changes should ever be made in `test`
    mode!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们为用户设置一个有用的`comment`，然后`return``ret`字典。如果一旦确定`salt`正在`test`模式下运行，还有更多的逻辑发生，那么它应该只用于在注释中为用户提供更多信息。在`test`模式下永远不应该进行任何更改！
- en: Attempting to configure the resource
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试配置资源
- en: 'If we get past the check for `test` mode, then we know that we can try to make
    changes to correctly configure the resource:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过了`test`模式的检查，那么我们知道我们可以尝试更改以正确配置资源：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, this section of the code should only contain enough logic to correctly
    configure the resource in question, and then notify the user if it was successful.
    If the change was successful, then we update the `changes` dictionary, add a `comment`
    that describes how those `changes` were achieved, set the `result` to `True`,
    and then `return`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这段代码应该只包含足够的逻辑来正确配置相关资源，并在成功时通知用户。如果更改成功，那么我们更新`changes`字典，添加一个描述如何实现这些`changes`的`comment`，将`result`设置为`True`，然后`return`。
- en: Notifying about False
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通知关于错误
- en: 'If we get past that piece of code, we are now assured that something has gone
    wrong, and that we are unable to fix it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过了那段代码，我们现在可以确信出了问题，我们无法修复它：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the most important section of code to be helpful to the user, because
    user interaction will likely be required to fix whatever the problem is.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码中最重要的部分，因为用户交互很可能会被用来修复问题。
- en: It could be that the SLS file was just poorly written, and that the next state
    run will fix it. It could also be that the state module has a bug that needs to
    be fixed. Or there could be some other situation that is beyond Salt's ability
    to control, such as a web service that is temporarily unavailable. The comment
    should contain as much information as is helpful to track down and fix the problem,
    and no more. This is also the time to set the result to `False` before `return`ing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是SLS文件只是写得不好，下一次状态运行会修复它。也可能是状态模块存在需要修复的bug。或者可能存在一些Salt无法控制的其他情况，例如一个暂时不可用的网络服务。注释应该包含尽可能多的信息，以便追踪和修复问题，而不要过多。这也是在`return`之前将结果设置为`False`的时候。
- en: 'Example: checking an HTTP service'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：检查HTTP服务
- en: 'There is already a state for contacting web services: the `http.query` state.
    However, it is very general-purpose, and using it directly has limited use. In
    fact, it doesn''t really have the logic to do much more than check whether a URL
    responds as expected. In order to make it more intelligent, we need to add some
    logic on our own.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有一个用于联系网络服务的状态：`http.query`状态。然而，它非常通用，直接使用它的用途有限。实际上，它并没有执行更多逻辑的真正逻辑，而只是检查URL是否按预期响应。为了使其更智能，我们需要添加一些自己的逻辑。
- en: Checking credentials
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查凭证
- en: 'Let''s start by setting up our `docstring`, a library import, and a `__virtual__()`
    function with some credentials for a theoretical web service:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置我们的`docstring`、库导入以及一个带有理论网络服务凭证的`__virtual__()`函数开始：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, we aren't checking for the existence of the `http.query` function;
    as we said before, it's already there. But this module won't function without
    being able to connect to the web service, so we do a quick check to make sure
    the credentials are in place.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们不是检查`http.query`函数的存在；正如我们之前所说的，它已经存在了。但是，如果没有能够连接到网络服务，这个模块将无法工作，所以我们快速检查以确保凭证已经就位。
- en: We aren't checking to see if the service itself responds, or if the credentials
    are correct. The `__virtual__()` function is checked when the Minion starts, and
    doing all that checking then is unnecessary and, in the event of downtime, possibly
    inaccurate. It will also slow the Minion from loading. It is better to do that
    checking later, when we actually make the call to the service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有检查服务本身是否响应，或者凭证是否正确。`__virtual__()`函数在Minion启动时进行检查，那时进行所有这些检查是不必要的，而且在停机事件中可能是不准确的。更好的做法是在我们实际调用服务时再进行检查。
- en: The first stateful function
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一个状态函数
- en: 'Next, we need to set up a state function. For our example, we''re going to
    allow users to make sure that a specific user''s account on that web service is
    locked out. First, we set up our defaults, and then check to see if that user''s
    account has been locked out yet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置一个状态函数。在我们的例子中，我们将允许用户确保该网络服务上的特定用户账户已被锁定。首先，我们设置默认值，然后检查该用户的账户是否已被锁定：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You may see a problem right away. Making an authenticated web call is a little
    heavy, especially when you have to decode the return data, no matter how you do
    it. We''re going to make another web call in this function, and then more in other
    functions. Let''s break out what we can into another function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能立刻就会发现问题。进行认证的网络调用有点重，尤其是当你必须解码返回数据时，无论你如何做。我们将在这个函数中再次进行网络调用，在其他函数中还会进行更多调用。让我们将我们可以的部分拆分到另一个函数中：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The new `_query()` function expects at least one argument: the type of query
    (`action`) that is going to be performed against the API. It''s very common for
    this kind of API to be expected to list all items for that query if a specific
    resource isn''t specified, so we''ve allowed the resource to be blank. We''ve
    also set up another optional parameter called data, which we''ll make use of in
    a moment.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`_query()`函数至少需要一个参数：将要执行的操作（`action`）的类型。这种类型的API通常期望在未指定特定资源的情况下列出该查询的所有项目，所以我们允许资源为空。我们还设置了一个名为`data`的可选参数，我们将在稍后使用它。
- en: 'Now we have a check for whether the account is locked, and are able to `return
    True` if it is. If we get past that point, we know the account isn''t locked,
    so let''s do our check for `test` mode:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个检查账户是否被锁定，并且如果它是的话，我们可以返回`True`。如果我们通过了这一点，我们知道账户没有被锁定，所以让我们进行对`test`模式的检查：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This part is easy enough; we have all of the information that is needed for
    `test` mode, and we don't need to do anything else besides `return` it. Let's
    go ahead and try to apply the correct setting to the account.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分很容易；我们已经有了一切需要的`test`模式信息，我们不需要做任何事情，除了返回它。让我们尝试将正确的设置应用到账户上。
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remember that `data` option? We used it to pass in a dictionary that sets the
    access value for that user to `locked`. This is also a very common way to modify
    data with a web API.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记住那个`data`选项吗？我们用它传递一个字典，将用户的访问值设置为`locked`。这也是使用Web API修改数据的一种非常常见的方式。
- en: 'Of course, we don''t necessarily know that the setting was applied correctly,
    so let''s do one more check, just to make sure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不一定知道设置是否被正确应用，所以让我们再进行一次检查，以确保：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the account is now locked, then we can return that we were successful. If
    the account is still not locked, then we can return a failure message.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果账户现在被锁定，那么我们可以返回我们已成功。如果账户仍然没有被锁定，那么我们可以返回一个失败信息。
- en: Another stateful function
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一个状态函数
- en: 'Let''s go ahead and add another function, to allow a user account to be unlocked.
    We''ll also take this opportunity to show you the entire module, with all of the
    public and private functions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加另一个函数，以便解锁用户账户。我们也将借此机会向您展示整个模块，包括所有公共和私有函数：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see that there''s not much difference between these two functions.
    In fact, really, they do exactly the same thing, but with opposing logic: one
    locks an account and one unlocks an account.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这两个函数之间没有太大的区别。实际上，它们确实做了完全相同的事情，但逻辑相反：一个锁定账户，另一个解锁账户。
- en: It is very common for a state module to contain two opposites for the same configuration.
    You will frequently see function names like `installed` and `removed`, `present`
    and `absent`, and `running` and `dead`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模块通常包含同一配置的两个相反值。你经常会看到像`installed`和`removed`、`present`和`absent`、`running`和`dead`这样的函数名。
- en: Troubleshooting state modules
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试状态模块
- en: 'Even though the code is more structured, it can be a little tricky to troubleshoot
    state modules. This is because you need to test all four types of return results:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码结构更清晰，但调试状态模块可能有点棘手。这是因为你需要测试所有四种类型的返回结果：
- en: True – The resource is already correctly configured
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确 – 资源已正确配置
- en: None – The resource is not correctly configured, and `test` mode is True
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无 – 资源配置不正确，且`test`模式为真
- en: True with changes – The resource was not correctly configured, but now it is
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确并更改 – 资源之前配置不正确，但现在已正确
- en: False – The resource could not be correctly configured
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误 – 资源配置不正确
- en: What makes this even trickier is that in the course of troubleshooting, you
    are likely to change configuration to be correct, and then incorrect, and then
    back again several times before the code is right. I suggest breaking it up.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使这更加棘手的是，在调试过程中，你可能会多次更改配置，从正确到错误，然后再回到正确，直到代码正确为止。我建议将其拆分。
- en: 'Step 1: test for truth'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步：测试真值
- en: 'Your first step, after setting up your defaults, is to check whether the resource
    is correctly configured. This is likely to require you to manually toggle settings
    to make sure it is properly checking both desired and undesired configuration.
    Add two returns: one for `True` and one for `False`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置默认值之后，你的第一步是检查资源是否正确配置。这可能需要你手动切换设置以确保它正确地检查了所需和不需要的配置。添加两个返回值：一个用于`True`，一个用于`False`：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can remove those last two lines later, once you know the code is correct.
    You don''t need to set up an entire SLS file to test your state; you can use `state.single`
    to perform a one-off state command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道代码是正确的，你可以稍后删除最后两行。你不需要设置整个SLS文件来测试你的状态；你可以使用`state.single`来执行一次性的状态命令：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Step 2: test mode'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步：测试模式
- en: 'Once you''re sure it''s correctly detecting the current configuration, manually
    set the configuration to an undesired value, and make sure `test` mode is working
    properly:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确信它能够正确地检测当前配置，手动将配置设置为不期望的值，并确保`test`模式工作正常：
- en: 'Step 3: applying changes'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步：应用更改
- en: When you are sure that your code will not try to apply changes without first
    checking for test mode, you can move on to applying changes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确信你的代码在尝试应用更改之前不会尝试检查测试模式，你可以继续应用更改。
- en: 'This is the trickiest part, for two reasons. First, you''ll end up setting
    and resetting your configuration a lot. This can be tedious at best, but there''s
    no avoiding it. Second, you''ll be both setting the correct configuration, and
    then testing to see if it was set, at the same time:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最难的部分，有两个原因。首先，你将不得不频繁地设置和重置你的配置。这最多可能有些繁琐，但这是不可避免的。其次，你将同时设置正确的配置，然后测试以查看它是否被设置：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You may think that you can split this part up, but before long you're likely
    to realize that in order to make sure the configuration was applied properly,
    you still need to perform the same check as you would normally be performing in
    your own tests, so you might as well get it out of the way now.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为你可以将这部分拆分，但很快你可能会意识到，为了确保配置被正确应用，你仍然需要执行与你在自己的测试中通常执行相同的检查，所以你不妨现在就把它解决掉。
- en: Testing opposites
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试相反的操作
- en: Thankfully, if you're writing functions that perform opposite functions, the
    second one tends to go much faster. That's because once you have the first one
    out of the way, you can keep running it to reset the configuration back to the
    undesired value for the second one. In the case of our example, once you are able
    to lock an account, you can easily lock it while testing the unlock functionality.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果你正在编写执行相反功能的函数，第二个通常要快得多。这是因为一旦你完成了第一个，你可以继续运行它来将配置重置为第二个不期望的值。在我们的例子中，一旦你能够锁定一个账户，你就可以在测试解锁功能时轻松地锁定它。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: State modules are more structured than execution modules, but that often makes
    them easier to write. A state's return result can be True (green), None (yellow),
    True with changes (blue), or False (red). State modules frequently contain pairs
    of functions that perform opposing functionality.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模块比执行模块更有结构，但这通常使它们更容易编写。状态返回的结果可以是True（绿色），None（黄色），True with changes（蓝色），或False（红色）。状态模块通常包含执行相反功能的函数对。
- en: 'Now that you know how to write state modules, it''s time to take a look at
    the data that we pass to them. Next up: renderers!'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何编写状态模块了，是时候看看我们传递给它们的那些数据了。接下来是：渲染器！
