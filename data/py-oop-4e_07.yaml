- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Python Data Structures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 数据结构
- en: 'In our examples so far, we''ve already seen many of the built-in Python data
    structures in action. You''ve probably also covered many of them in introductory
    books or tutorials. In this chapter, we''ll discuss the object-oriented features
    of these data structures, when they should be used instead of a regular class,
    and when they should not be used. In particular, we''ll be covering the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们已经看到了许多内置的Python数据结构在实际中的应用。你可能也在入门书籍或教程中接触过它们中的许多。在本章中，我们将讨论这些数据结构的面向对象特性，以及它们应该在什么情况下替代常规类使用，以及在什么情况下不应该使用。特别是，我们将涵盖以下主题：
- en: Tuples and named tuples
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组与命名元组
- en: Dataclasses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类
- en: Dictionaries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Lists and sets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和集合
- en: Three types of queues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种类型的队列
- en: This chapter's case study will revisit the data model for the *k*-nearest neighbors
    classifier. After looking at Python's sophisticated built-in data structure and
    class definitions, we can simplify some of the application class definitions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究将重新审视*k*最近邻分类器的数据模型。在查看Python的复杂内置数据结构和类定义之后，我们可以简化一些应用程序类定义。
- en: We'll start by looking at some of the foundational constructs. The `object`
    class, specifically.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨一些基础构造，特别是`object`类。
- en: Empty objects
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空对象
- en: 'Let''s start with the most basic Python built-in, one that we''ve used implicitly
    many times already, the one (it turns out) we''ve extended in every class we have
    created: the `object`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的Python内置函数开始，这是我们已经在很多次使用中隐含地使用过的，也是（结果证明）我们在创建的每一个类中都进行了扩展的：`object`。
- en: 'Technically, we can instantiate an `object` without writing a subclass, as
    follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们可以不编写子类就实例化一个`对象`，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unfortunately, as you can see, it's not possible to set any attributes on an `object` that
    was instantiated directly. This isn't because the Python developers wanted to
    force us to write our own classes, or anything so sinister. They did this to save
    memory – a lot of memory. When Python allows an object to have arbitrary attributes,
    it takes a certain amount of system memory to keep track of what attributes each
    object has, for storing both the attribute name and its value. Even if no attributes
    are stored, memory is allocated to make it possible to add attributes. Given the
    dozens, hundreds, or thousands of objects (*every* class extends the `object`
    class) in a typical Python program, this small amount of memory would quickly
    become a large amount of memory. So, Python disables arbitrary properties on `object`,
    and several other built-ins, by default.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，正如您所看到的，无法在直接实例化的`对象`上设置任何属性。这并不是因为Python开发者想要强迫我们编写自己的类，或者任何如此邪恶的事情。他们这样做是为了节省内存——大量的内存。当Python允许一个对象具有任意属性时，它需要一定量的系统内存来跟踪每个对象具有哪些属性，用于存储属性名称及其值。即使没有存储任何属性，也会分配内存以使其能够添加属性。考虑到典型的Python程序中有数十、数百或数千个对象（*每个*类都扩展了`object`类），这样一小块内存很快就会变成大量内存。因此，Python默认禁用了`object`以及几个其他内置对象的任意属性。
- en: It is possible to restrict arbitrary properties on our own classes using `__slots__`.
    Slots are part of *Chapter 12*, *Advanced Design Patterns*. We'll look at them
    as a way to save memory for objects that occur many, many times.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `__slots__` 可以在自定义类上限制任意属性。槽位是 *第12章*，*高级设计模式* 的一部分。我们将通过它们作为一种为频繁出现的对象节省内存的方法来探讨。
- en: 'It is, however, trivial to create an empty object class of our own; we saw
    it in our earliest example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建我们自己的空对象类是非常简单的；我们在最早的例子中看到了这一点：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In effect, `class MyObject` is equivalent to `class MyObject(object)`. As we''ve
    already seen, it''s possible to set attributes on such classes as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`class MyObject` 等同于 `class MyObject(object)`。正如我们之前所看到的，我们可以在这样的类上设置属性，如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we wanted to group an unknown number of attribute values together, we could
    store them in an empty object like this. The problem with this approach is the
    lack of an obvious schema that we can use to understand what attributes should
    be present and what types of values they'll have.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将未知数量的属性值分组，我们可以将它们存储在一个空对象中，如下所示。这种方法的缺点是缺乏一个明显的模式，我们可以用它来理解应该有哪些属性以及它们将具有哪些类型的值。
- en: A focus of this book is the way classes and objects should only be used when
    you want to specify *both* data and behaviors. Therefore, it is important to decide
    from the outset whether the data is purely data, or whether it is an object in
    disguise. Once that design decision is made, the rest of the design can grow from
    the seed concept.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个重点是，只有在你想要指定*数据*和*行为*时，才应该使用类和对象。因此，从一开始就决定数据是否仅仅是数据，或者它是否是伪装成对象的实体，这一点非常重要。一旦做出这个设计决策，其余的设计就可以从种子概念中发展出来。
- en: Tuples and named tuples
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组与命名元组
- en: Tuples are objects that can store a specific number of other objects in sequence.
    They are *immutable*, meaning we can't add, remove, or replace objects on the
    fly. This may seem like a massive restriction, but the truth is, if you need to
    modify a tuple, you're using the wrong data type (usually, a `list` would be more
    suitable). The primary benefit of tuples' immutability is a tuple of immutable
    objects (like strings and numbers and other tuples) has a hash value, allowing
    us to use them as keys in dictionaries, and members of a set. (A tuple that contains
    a mutable structure, like a list, set, or dict, isn't composed of immutable items,
    and doesn't have a hash value. We'll look closely at this distinction in the next
    section.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是能够按顺序存储特定数量其他对象的实体。它们是**不可变**的，这意味着我们无法在运行时添加、删除或替换对象。这看起来可能是一个巨大的限制，但事实是，如果你需要修改一个元组，你使用的数据类型可能不正确（通常，使用列表会更合适）。元组不可变性的主要好处是，不可变对象的元组（如字符串、数字和其他元组）有一个哈希值，允许我们将其用作字典的键和集合的成员。（包含可变结构（如列表、集合或字典）的元组不是由不可变项组成的，并且没有哈希值。我们将在下一节中仔细研究这个区别。）
- en: Instances of Python's built-in generic `tuple` class are used to store data;
    behavior cannot be associated with a built-in tuple. If we require behavior to
    manipulate a tuple, we have to pass the tuple into a function (or method on another
    object) that performs the action. This is the subject of *Chapter 8*, *The Intersection
    of Object-Oriented and Functional Programming*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内置的泛型 `tuple` 类的实例用于存储数据；无法将行为关联到内置的元组。如果我们需要行为来操作元组，我们必须将元组传递给一个执行该操作的函数（或另一个对象上的方法）。这是
    *第8章*，*面向对象与函数式编程的交汇点* 的主题。
- en: 'Tuples overlap with the idea of coordinates or dimensions. A mathematical (x,
    y) pair or (r, g, b) color are examples of tuples; the order matters, a lot: the
    color (255, 0, 0) looks nothing like (0, 255, 0). The primary purpose of a tuple
    is to aggregate different pieces of data together into one container.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与坐标或维度的概念重叠。数学上的(x, y)对或(r, g, b)颜色都是元组的例子；顺序很重要：颜色(255, 0, 0)看起来与(0, 255,
    0)完全不同。元组的主要目的是将不同的数据片段聚集到一个容器中。
- en: 'We create a tuple by separating values with a comma. Usually, tuples are wrapped
    in parentheses to make them easy to read and to separate them from other parts
    of an expression, but this is not always mandatory. The following two assignments
    are identical (they record a stock, the current price, the 52-week high, and the
    52-week low, for a rather profitable company):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过逗号分隔值来创建一个元组。通常，元组会被括号包围以使其易于阅读，并与其他表达式的部分区分开来，但这并非总是必须的。以下两个赋值是相同的（它们记录了一家相当盈利公司的股票、当前价格、52周最高价和52周最低价）：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (When the first edition of this book was printed, this stock was trading around
    US$ 8 per share; the stock value has almost doubled with each edition of this
    book!)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: (当这本书的第一版印刷时，该股票的交易价格约为每股8美元；随着这本书每一版的出版，股票价值几乎翻倍！）
- en: 'If we''re grouping a tuple inside of some other object, such as a function
    call, list comprehension, or generator, the parentheses are required. Otherwise,
    it would be impossible for the interpreter to know whether it is a tuple or the
    next function parameter. For example, the following function accepts a tuple and
    a date, and returns a tuple of the date and the middle value between the stock''s
    high and low value:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在某个其他对象内部对元组进行分组，例如函数调用、列表推导或生成器，则需要使用括号。否则，解释器将无法知道它是一个元组还是下一个函数参数。例如，以下函数接受一个元组和日期，并返回一个包含日期和股票最高价与最低价之间中间值的元组：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, a new four-tuple is created directly inside the function call.
    The items are separated by commas and the entire tuple is cuddled up inside parentheses.
    This tuple is then followed by a comma to separate it from the second argument,
    a `datetime.date` object. When Python displays a tuple, it uses what's called
    the **canonical** representation; this will always include `()`'s, making the
    `()`'s a common practice even when they're not – strictly – required. The `return`
    statement, specifically, has redundant `()`'s around the tuple it creates.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个新的四元组直接在函数调用内部创建。这些项由逗号分隔，整个元组被括号包围。然后，通过逗号将其与第二个参数，一个`datetime.date`对象分开。当Python显示一个元组时，它使用所谓的**规范**表示法；这总是会包括括号`()`，即使在严格意义上不是必需的，括号的使用也已成为一种常见做法。特别是`return`语句，它在其创建的元组周围有冗余的括号。
- en: The degenerate cases include a tuple with only one item, written like this `(2.718,)`.
    The extra comma is required here. An empty tuple is `()`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 退化情况包括只有一个元素的元组，写作这样 `(2.718,)`。这里需要额外的逗号。空元组是 `()`。
- en: 'We can sometimes wind up with a statement like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时可能会得出这样的陈述：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s sometimes surprising that the variable `a` will be a one-tuple. The trailing
    comma is what creates an expression list with a single item; this is the value
    of the tuple. The `()`''s are required for two things: (1) to create an empty
    tuple or (2) to separate a tuple from other expressions. For example, the following
    creates nested tuples:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候会让人惊讶，变量 `a` 会被赋值为一个单元素元组。尾随的逗号是用来创建一个包含单个元素的列表表达式；这就是元组的值。括号 `()` 有两个用途：(1)
    创建一个空元组，或者(2) 将元组与其他表达式区分开来。例如，以下代码创建了嵌套元组：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The trailing commas in Python are politely ignored.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python中尾随的逗号被礼貌地忽略。
- en: The `middle()` function also illustrates **tuple unpacking**. The first line
    inside the function unpacks the `stock` parameter into four different variables.
    The tuple has to be exactly the same length as the number of variables, or it
    will raise an exception.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`middle()` 函数也展示了**元组解包**。函数内部的第 一行将`stock`参数解包成四个不同的变量。元组的长度必须与变量的数量完全相同，否则会引发异常。'
- en: 'Unpacking is a very useful feature in Python. A tuple groups related values
    together to make storing and passing them around simpler; the moment we need to
    access the pieces, we can unpack them into separate variables. Of course, sometimes
    we only need access to one of the variables in the tuple. We can use the same
    syntax that we use for other sequence types (lists and strings, for example) to
    access an individual value:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 解包是Python中一个非常实用的功能。元组将相关值组合在一起，使得存储和传递它们变得更加简单；当我们需要访问这些片段时，我们可以将它们解包到单独的变量中。当然，有时我们只需要访问元组中的一个变量。我们可以使用与其他序列类型（例如列表和字符串）相同的语法来访问单个值：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can even use slice notation to extract larger pieces of tuples, as demonstrated
    in the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用切片符号来提取更大的元组片段，如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These examples, while illustrating how flexible tuples can be, also demonstrate
    one of their major disadvantages: readability. How does someone reading this code
    know what is in position 2 of a specific tuple? They can guess, using the name
    of the variable we assigned it to, that it is `high` of some sort, but if we had
    just accessed the tuple value in a calculation without assigning it, there would
    be no such indication. They would have to paw through the code to find where the
    tuple was packed or unpacked before they could discover what it does.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子虽然说明了元组可以有多大的灵活性，但也展示了它们的一个主要缺点：可读性。阅读这段代码的人如何知道特定元组的第2个位置是什么内容呢？他们可以猜测，通过我们分配给它的变量名称，它可能是某种“高”值，但如果我们只是在不分配的情况下访问元组值进行计算，就没有这样的提示。他们必须翻阅代码，找到元组被打包或解包的位置，才能发现它所做的工作。
- en: 'Accessing tuple members directly is fine in some circumstances, but don''t
    make a habit of it. The index values become what we might call *magic numbers*:
    numbers that seem to come out of thin air with no apparent meaning within the
    code. This opacity is the source of many coding errors and leads to hours of frustrated
    debugging. Try to use tuples only when you know that all the values are going
    to be useful at once and it''s normally going to be unpacked when it is accessed.
    Think of (x, y) coordinate pairs and (r, g, b) colors, where the number of items
    is fixed, the order matters, and the meaning is clear.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，直接访问元组成员是可以的，但不要养成这种习惯。索引值变成了我们可能称之为*魔法数字*的东西：看起来像是凭空出现，在代码中没有明显的意义。这种不透明性是许多编码错误的源头，导致长时间的挫败感调试。尽量只在你知道所有值都将同时有用，并且通常在访问时会被解包的情况下使用元组。想想(x,
    y)坐标对和(r, g, b)颜色，其中项目数量固定，顺序很重要，意义也很明确。
- en: One way to provide some useful documentation is to define numerous little helper
    functions. This can help to clarify the way a tuple is used. Here's an example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一些有用文档的一种方法就是定义许多小辅助函数。这有助于阐明元组的使用方式。以下是一个示例。
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need to keep these helper functions collected together into a single namespace.
    Doing this causes us to suspect that a class is better than a tuple with a lot
    of helper functions. There are other alternatives to clarifying the contents of
    tuples, the most important of which is the `typing.NamedTuple` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这些辅助函数收集到一个单独的命名空间中。这样做让我们怀疑，一个类比带有许多辅助函数的元组更好。还有其他方法可以澄清元组的内容，其中最重要的是`typing.NamedTuple`类。
- en: Named tuples via typing.NamedTuple
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 `typing.NamedTuple` 命名的元组
- en: 'So, what do we do when we want to group values together but know we''re frequently
    going to need to access them individually? There are actually several options,
    including these:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们想要将值分组在一起，但又知道我们经常会需要单独访问它们时，我们该怎么办呢？实际上有几种选择，包括以下这些：
- en: We could use an empty `object` instance, as discussed previously. We can assign
    arbitrary attributes to this object. But without a good definition of what's allowed
    and what types are expected, we'll have trouble understanding this. And we'll
    get a lot of **mypy** errors.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用一个空的`对象`实例，正如之前所讨论的。我们可以给这个对象分配任意的属性。但是如果没有一个良好的定义来规定允许什么以及期望什么类型，我们将难以理解这一点。而且我们会遇到很多**mypy**错误。
- en: We could use a dictionary. This can work out nicely, and we can formalize the
    acceptable list of keys for the dictionary with the `typing.TypedDict` hint. We'll
    touch on these in the case study for *Chapter 9*, *Strings, Serialization, and
    File Paths*.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用字典。这样可能会很好用，并且我们可以使用`typing.TypedDict`提示来正式化字典可接受的键列表。我们将在第9章的案例研究中涉及到这些内容，即*字符串、序列化和文件路径*。
- en: We can use a `@dataclass`, the subject of the next section in this chapter.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用一个`@dataclass`，这是本章下一节的主题。
- en: We can also provide names to the positions of a tuple. While we're at it, we
    can also define methods for these named tuples, making them super helpful.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以为元组的各个位置提供名称。在此过程中，我们还可以为这些命名元组定义方法，使它们变得非常有帮助。
- en: Named tuples are tuples with attitude. They are a great way to create an immutable
    grouping of data values. When we define a **named tuple** we're creating a subclass
    of `typing.NamedTuple`, based on a list of names and data types. We don't need
    to write an `__init__()` method; it's created for us.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This new class will have a number of methods, including `__init__()`, `__repr__()`,
    `__hash__()`, and `__eq__()`. These will be based on the generic `tuple` processing
    with the added benefit of names for the various items. There are more methods,
    including comparison operations. Here''s how we can create a tuple of this class.
    It looks almost like creating a generic tuple:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类将包含多个方法，包括 `__init__()`、`__repr__()`、`__hash__()` 和 `__eq__()`。这些方法将基于通用的
    `tuple` 处理，并增加了为各种项目命名的好处。还有更多方法，包括比较操作。以下是创建此类元组的示例。它看起来几乎就像创建一个通用元组：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can use keyword parameters to make things more clear:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用关键字参数来使事情更加清晰：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The constructor must have exactly the correct number of arguments to create
    the tuple. Values can be passed in as positional or keyword arguments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数必须恰好有正确数量的参数来创建元组。值可以作为位置参数或关键字参数传递。
- en: It's important to recognize that the names are provided at the class level,
    but we are **not** actually creating class-level attributes. The class-level names
    are used to build the `__init__()` method; each instance will have the expected
    names for the positions within the tuple. There's a clever metaclass-level transformation
    from what we wrote into the somewhat more complex definition of the resulting
    class with named, positional items. For more information on metaclasses, refer
    back to *Chapter 6*, *Abstract Base Classes and Operator Overloading*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，名称是在类级别提供的，但我们实际上**并没有**创建类级别的属性。类级别的名称用于构建`__init__()`方法；每个实例都将拥有在元组内部位置的预期名称。从我们编写的内容到结果类的更复杂定义（具有命名和位置项）之间存在一种巧妙的元类级别转换。有关元类的更多信息，请参阅*第6章*，*抽象基类和运算符重载*。
- en: 'The resulting instance of our `NamedTuple` subclass, `Stock`, can then be packed,
    unpacked, indexed, sliced, and otherwise treated like a normal tuple, but we can
    also access individual attributes by name as if it were an object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`NamedTuple`子类的实例，即`Stock`，可以被打包、解包、索引、切片，以及其他像普通元组一样的处理方式，但我们也可以通过名称访问单个属性，就像它是一个对象一样：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Named tuples are perfect for many use cases. Like strings, tuples and named
    tuples are immutable, so we cannot modify an attribute once it has been set. For
    example, the current value of this company''s stock has gone down since we started
    this discussion, but we can''t set the new value, as can be seen in the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组非常适合许多用例。与字符串一样，元组和命名元组都是不可变的，因此一旦设置了属性，我们就不能修改它。例如，自从我们开始这次讨论以来，这家公司的股票当前价值已经下降，但我们不能设置新的值，如下所示：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The immutability refers only to the attributes of the tuple itself. This can
    seem odd, but it's a consequence of the definitions of an immutable tuple. The
    tuple can contain mutable elements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性仅指元组本身的属性。这可能会显得有些奇怪，但这是由不可变元组的定义所导致的后果。元组可以包含可变元素。
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The object, `t`, is a tuple, which means it's immutable. The tuple object contains
    two items. The value of `t[0]` is a string, which is also immutable. The value
    of `t[1]`, however, is a mutable list. The mutability of the list is not altered
    by the immutability of the object, `t`, with which it's associated. A list is
    mutable, irrespective of context. The tuple, `t`, is immutable, even if items
    within it are mutable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对象 `t` 是一个元组，这意味着它是不可变的。元组对象包含两个元素。`t[0]` 的值是一个字符串，它也是不可变的。然而，`t[1]` 的值是一个可变列表。与它关联的对象
    `t` 的不可变性并不会改变列表的可变性。列表是可变的，无论其上下文如何。即使元组 `t` 内部的元素是可变的，`t` 本身也是不可变的。
- en: Because the example tuple, `t`, contains a mutable list, it doesn't have a hash
    value. This shouldn't be surprising, either. The `hash()` computation requires
    the hash from each item within the collection. Since the list value of `t[1]`
    can't produce a hash, the tuple `t` – as a whole – can't produce a hash, either.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为示例元组`t`包含一个可变列表，所以它没有哈希值。这也不应该令人惊讶。`hash()`计算需要集合中每个项目的哈希值。由于`t[1]`的列表值无法生成哈希，因此整个元组`t`也无法生成哈希。
- en: 'Here''s what happens when we try:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们尝试时会发生的情况：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The presence of the unhashable list object means the tuple – as a whole – is
    also unhashable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 存在不可哈希的列表对象意味着整个元组也是不可哈希的。
- en: 'We can create methods to compute derived values of the attributes of a named
    tuple. We can, for example, redefine our `Stock` tuple to include the middle computation
    as a method (or a `@property`):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建方法来计算命名元组的属性派生值。例如，我们可以重新定义我们的`Stock`元组，将其中间计算作为一个方法（或一个`@property`）包含进去：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can''t change the state, but we can compute values derived from the current
    state. This lets us couple computations directly to the tuple holding the source
    data. Here''s an object created with this definition of the `Stock` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法改变状态，但我们可以计算从当前状态派生出的值。这使得我们可以直接将计算与持有源数据的元组耦合。以下是一个使用这种`Stock`类定义创建的对象：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `middle()` method is now part of the class definition. The best part? The
    **mypy** tool can look over our shoulder to be sure the type hints all match up
    properly throughout our application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`middle()` 方法现在已成为类定义的一部分。最好的部分？**mypy** 工具可以站在我们身后，确保我们的应用程序中所有的类型提示都正确匹配。'
- en: The state of a named tuple is fixed when the tuple is created. If we need to
    be able to change stored data, a `dataclass` may be what we need instead. We'll
    look at those next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建元组时，命名元组的状态是固定的。如果我们需要能够更改存储的数据，那么可能需要一个`dataclass`，我们将在下一节中探讨这些内容。
- en: Dataclasses
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: Since Python 3.7, dataclasses let us define ordinary objects with a clean syntax
    for specifying attributes. They look – superficially – very similar to named tuples.
    This is a pleasant approach that makes it easy to understand how they work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Python 3.7 版本开始，dataclasses 允许我们使用简洁的语法来定义具有属性的标准对象。它们——表面上——看起来非常类似于命名元组。这是一种令人愉悦的方法，使得理解它们的工作原理变得容易。
- en: 'Here''s a `dataclass` version of our `Stock` example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`Stock`示例的`dataclass`版本：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For this case, the definition is nearly identical to the `NamedTuple` definition.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例，定义几乎与`NamedTuple`定义相同。
- en: The `dataclass` function is applied as a class decorator, using the `@` operator.
    We encountered decorators in *Chapter 6*, *Abstract Base Classes and Operator
    Overloading*. We'll dig into them deeply in *Chapter 11*, *Common Design Patterns*.
    This class definition syntax isn't much less verbose than an ordinary class with `__init__()`,
    but it gives us access to several additional `dataclass` features.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataclass` 函数作为类装饰器使用，通过 `@` 操作符应用。我们在 *第6章*，*抽象基类和运算符重载* 中遇到了装饰器。我们将在 *第11章*，*常见设计模式*
    中深入探讨它们。这种类定义语法与带有 `__init__()` 的普通类相比，并没有少多少冗余，但它为我们提供了访问几个额外的 `dataclass` 功能。'
- en: It's important to recognize that the names are provided at the class level,
    but are **not** actually creating class-level attributes. The class level names
    are used to build several methods, including the `__init__()` method; each instance
    will have the expected attributes. The decorator transforms what we wrote into
    the more complex definition of a class with the expected attributes and parameters
    to `__init__()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，这些名称是在类级别提供的，但实际上**并没有**创建类级别的属性。类级别的名称用于构建多个方法，包括`__init__()`方法；每个实例都将具有预期的属性。装饰器将我们编写的内容转换成具有预期属性和`__init__()`参数的更复杂的类定义。
- en: Because dataclass objects can be stateful, mutable objects, there are a number
    of extra features available. We'll start with some basics. Here's an example of
    creating an instance of the `Stock` dataclass.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据类对象可以是具有状态的、可变的对象，所以有众多额外功能可供使用。我们将从一些基础知识开始。以下是一个创建`Stock`数据类实例的示例。
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once instantiated, the `Stock` object can be used like any ordinary class.
    You can access and update attributes as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化，`Stock` 对象就可以像任何普通类一样使用。你可以按照以下方式访问和更新属性：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As with other objects, we can add attributes beyond those formally declared
    as part of the dataclass. This isn''t always the best idea, but it''s supported
    because this is an ordinary mutable object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他对象一样，我们可以在正式声明为数据类一部分的属性之外添加属性。这并不总是最好的主意，但这是被支持的，因为这是一个普通的可变对象：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Adding attributes isn''t available for frozen dataclasses, which we''ll talk
    about later in this section. At first glance, it seems like dataclasses don''t
    give many benefits over an ordinary class definition with an appropriate constructor.
    Here''s an ordinary class that''s similar to the dataclass:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为冻结的数据类添加属性是不可用的，我们将在本节稍后讨论这一点。乍一看，似乎数据类与具有适当构造函数的普通类定义相比并没有带来很多好处。这里有一个与数据类相似的普通类：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'One obvious benefit to a dataclass is we only need to state the attribute names
    once, saving the repetition in the `__init__()` parameters and body. But wait,
    that''s not all! The dataclass also provides a much more useful string representation
    than we get from the implicit superclass, `object`. By default, dataclasses include
    an equality comparison, also. This can be turned off in the cases where it doesn''t
    make sense. The following example compares the manually built class to these dataclass
    features:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类的一个明显好处是我们只需要声明一次属性名称，这样就节省了在`__init__()`参数和主体中的重复。但是等等，这还不是全部！数据类还提供了一个比从隐式超类`object`获得的字符串表示更实用的功能。默认情况下，数据类还包括一个等价比较。在不适用的情况下，可以将其关闭。以下示例比较了手动构建的类与这些数据类功能：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The class built manually has an awful default representation, and the lack of
    an equality test can make life difficult. We'd prefer the behavior of the `Stock`
    class defined as a dataclass.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 手动构建的类有一个糟糕的默认表示，而且缺少等式测试可能会让生活变得困难。我们更倾向于将`Stock`类的行为定义为数据类。
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Class definitions decorated with `@dataclass` also have many other useful features.
    For example, you can specify a default value for the attributes of a dataclass.
    Perhaps the market is currently closed and you don''t know what the values for
    the day are:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@dataclass` 装饰的类定义也具有许多其他有用的功能。例如，您可以指定数据类的属性默认值。也许市场目前是关闭的，您不知道当天的值是什么：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can construct this class with just the stock name; the rest of the values
    will take on the defaults. But you can still specify values if you prefer, as
    follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用股票名称来构建这个类；其余的值将采用默认值。但您仍然可以指定值，如下所示：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We saw earlier that dataclasses support equality comparison by default. If
    all the attributes compare as equal, then the dataclass objects as a whole also
    compare as equal. By default, dataclasses do not support other comparisons, such
    as less than or greater than, and they can''t be sorted. However, you can easily
    add comparisons if you wish, demonstrated as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，数据类默认支持相等比较。如果所有属性都相等，那么整个数据类对象也会被视为相等。默认情况下，数据类不支持其他比较，如小于或大于，并且不能进行排序。然而，如果您愿意，可以轻松地添加比较，如下所示：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It''s okay to ask "Is that all that''s needed?" The answer is yes. The `order=True`
    parameter to the decorator leads to the creation of all of the comparison special
    methods. This change gives us the opportunity to sort and compare the instances
    of this class. It works like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 提问“这需要的就是这些吗？”是可以的。答案是肯定的。装饰器中的`order=True`参数会导致所有比较特殊方法的创建。这种变化为我们提供了对这类实例进行排序和比较的机会。它的工作原理是这样的：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the dataclass decorator receives the `order=True` argument, it will, by
    default, compare the values based on each of the attributes in the order they
    were defined. So, in this case, it first compares the `name` attribute values
    of the two objects. If those are the same, it compares the `current` attribute
    values. If those are also the same, it will move on to `high` and will even include
    `low` if all the other attributes are equal. The rules follow the definition of
    a tuple: the order of definition is the order of comparison.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据类装饰器接收到`order=True`参数时，它将默认根据每个属性定义的顺序来比较它们的值。因此，在这种情况下，它首先比较两个对象的`name`属性值。如果这些值相同，它将比较`current`属性值。如果这些值也相同，它将继续比较`high`属性，如果所有其他属性都相等，甚至包括`low`。这些规则遵循元组的定义：定义的顺序是比较的顺序。
- en: Another interesting feature of dataclasses is `frozen=True`. This creates a
    class that's similar to a `typing.NamedTuple`. There are some differences in what
    we get as features. We'd need to use `@dataclass(frozen=True, ordered=True)` to
    create structures. This leads to a question of "Which is better?", which – of
    course – depends on the details of a given use case. We haven't explored all of
    the optional features of dataclasses, like initialization-only fields and the
    `__post_init__()` method. Some applications don't need all of these features,
    and a simple `NamedTuple` may be adequate.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类的一个有趣特性是 `frozen=True`。这会创建一个类似于 `typing.NamedTuple` 的类。我们在获得的功能上存在一些差异。我们需要使用
    `@dataclass(frozen=True, ordered=True)` 来创建结构。这引发了一个问题：“哪个更好？”，当然，这取决于特定用例的细节。我们还没有探索数据类的所有可选功能，比如仅初始化的字段和
    `__post_init__()` 方法。某些应用可能不需要所有这些功能，一个简单的 `NamedTuple` 可能就足够了。
- en: There are a few other approaches. Outside the standard library, packages like
    `attrs`, `pydantic`, and `marshmallow` provide attribute definition capabilities
    that are – in some ways – similar to dataclasses. Other packages outside the standard
    library offer additional features. See [https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html](https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html)
    for a comparison.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种其他的方法。在标准库之外，像 `attrs`、`pydantic` 和 `marshmallow` 这样的包提供了类似于数据类的属性定义功能。标准库之外的其他包还提供了额外的功能。有关比较，请参阅
    [https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html](https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html)。
- en: We've looked at two ways to create unique classes with specific attribute values,
    named tuples and dataclasses. It's often easier to start with dataclasses and
    add specialized methods. This can save us a bit of programming because some of
    the basics, like initialization, comparison, and string representations, are handled
    elegantly for us.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了两种创建具有特定属性值的独特类的方法，即命名元组和数据类。通常，从数据类开始并添加专用方法会更简单。这可以节省我们一些编程工作，因为一些基本操作，如初始化、比较和字符串表示，都为我们优雅地处理了。
- en: It's time to look at Python's built-in generic collections, `dict`, `list`,
    and `set`. We'll start by exploring dictionaries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看 Python 的内置泛型集合了，`dict`、`list` 和 `set`。我们将从探索字典开始。
- en: Dictionaries
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词典
- en: Dictionaries are incredibly useful containers that allow us to map objects directly
    to other objects. Dictionaries are extremely efficient at looking up a **value**,
    given a specific **key** object that maps to that value. The secret of the speed
    is using a **hash** of the key to locate the value. Every immutable Python object
    has a numeric hash code; a relatively simple table is used to map the numeric
    hashes directly to values. This trick means a dictionary never searches the entire
    collection for a key; the key is transformed to a hash, which locates the associated
    value (almost) immediately.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 词典是极其有用的容器，它允许我们将对象直接映射到其他对象。在给定一个特定的**键**对象，该对象映射到该值的情况下，词典在查找**值**方面非常高效。速度的秘密在于使用键的**哈希**来定位值。每个不可变的Python对象都有一个数值哈希码；使用一个相对简单的表将数值哈希直接映射到值。这个技巧意味着字典永远不会在整个集合中搜索键；键被转换成哈希，这可以立即定位相关的值（几乎）。
- en: Dictionaries can be created either using the `dict()` constructor or the `{}` syntax
    shortcut. In practice, the latter format is almost always used. We can prepopulate
    a dictionary by separating the keys from the values using a colon and separating
    the key-value pairs using a comma.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 字典可以通过使用`dict()`构造函数或`{}`语法快捷方式来创建。在实践中，后者格式几乎总是被使用。我们可以通过使用冒号分隔键和值，以及使用逗号分隔键值对来预先填充一个字典。
- en: 'We can also create dictionaries using keyword parameters. We can use `dict(current=1235.20,
    high=1242.54, low=1231.06)` to create the value `{''current'': 1235.2, ''high'':
    1242.54, ''low'': 1231.06}`. This `dict()` syntax overlaps with other constructors
    like dataclasses and named tuples.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以使用关键字参数来创建字典。我们可以使用 `dict(current=1235.20, high=1242.54, low=1231.06)`
    来创建值 `{''current'': 1235.2, ''high'': 1242.54, ''low'': 1231.06}`。这种 `dict()`
    语法与其他构造函数（如 dataclasses 和命名元组）重叠。'
- en: 'For example, in our stock application, we would most often want to look up
    prices by the stock symbol. We can create a dictionary that uses stock symbols
    as keys, and tuples (you could also use named tuples or dataclasses as values,
    of course) of current, high, and low as values, like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的股票应用中，我们通常会想要通过股票符号来查找价格。我们可以创建一个字典，使用股票符号作为键，而将当前价、最高价和最低价作为值的元组（当然，你也可以使用命名元组或数据类作为值），如下所示：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As we''ve seen in previous examples, we can then look up values in the dictionary
    by requesting a key inside square brackets. If the key is not in the dictionary,
    it will raise a `KeyError` exception, demonstrated as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们可以通过在方括号内请求字典中的键来查找值。如果键不在字典中，它将引发一个`KeyError`异常，如下所示：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can, of course, catch the `KeyError` and handle it. But we have other options.
    Remember, dictionaries are objects, even if their primary purpose is to hold other
    objects. As such, they have several behaviors associated with them. One of the
    most useful of these methods is the `get` method; it accepts a key as the first
    parameter and an optional default value if the key doesn''t exist:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以捕获`KeyError`并处理它。但还有其他选择。记住，字典是对象，即使它们的主要目的是持有其他对象。因此，它们具有与它们相关的几种行为。其中最有用的方法之一是`get`方法；它接受一个键作为第一个参数，如果键不存在，则可以接受一个可选的默认值：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For even more control, we can use the `setdefault()` method. If the key is
    in the dictionary, this method behaves just like the `get()` method; it returns
    the value for that key. Otherwise, if the key is not in the dictionary, it will
    not only return the default value we supply in the method call (just like the
    `get()` method does); it will also set the key to that same value. Another way
    to think of it is that `setdefault()` sets a value in the dictionary only if that
    value has not previously been set. Then, it returns the value in the dictionary;
    either the one that was already there or the newly provided default value, as
    can be seen in the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更多的控制，我们可以使用`setdefault()`方法。如果键存在于字典中，这个方法的行为就像`get()`方法一样；它返回该键的值。否则，如果键不在字典中，它不仅会返回我们在方法调用中提供的默认值（就像`get()`方法所做的那样）；它还会将该键设置为那个相同的值。另一种思考方式是，`setdefault()`方法仅在之前没有设置该值的情况下，才在字典中设置一个值。然后，它返回字典中的值；要么是已经存在的那个值，要么是新提供的默认值，如下所示：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `"GOOG"` stock was already in the dictionary, so when we tried to use `setdefault()`
    to change it to an invalid value, it just returned the value already in the dictionary.
    The key `"BB"` was not in the dictionary, so the `setdefault()` method returned
    the default value and set the new value in the dictionary for us. We then check
    that the new stock is, indeed, in the dictionary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`"GOOG"` 股票已经在字典中，所以当我们尝试使用 `setdefault()` 函数将其更改为无效值时，它只是返回了字典中已有的值。键 `"BB"`
    不在字典中，因此 `setdefault()` 方法返回了默认值，并为我们设置了字典中的新值。然后我们检查新的股票确实在字典中。'
- en: The type hints for dictionaries must include the type for the keys and the type
    for the values. Starting with Python 3.9, and **mypy** release 0.812, we describe
    this structure with a type hint of `dict[str, tuple[float, float, float]]`; we
    can avoid importing the `typing` module. Depending on your version of Python,
    you'll often need to use `from __future__ import annotations` as the first line
    of code in your module; this includes the necessary language support to treat
    built-in classes as properly generic type annotations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的类型提示必须包括键的类型和值的类型。从 Python 3.9 版本开始，以及 **mypy** 版本 0.812，我们使用类型提示 `dict[str,
    tuple[float, float, float]]` 来描述这种结构；这样可以避免导入 `typing` 模块。根据您的 Python 版本，您通常需要在模块的第一行代码中使用
    `from __future__ import annotations`；这包括将内置类作为适当泛型类型提示所需的语言支持。
- en: 'Three other useful dictionary methods are `keys()`, `values()`, and `items()`.
    The first two return iterators over all the keys and all the values in the dictionary.
    We can use these in `for` loops if we want to process all the keys or values.
    We''ll return to the universality of iterators in *Chapter 10*, *The Iterator
    Pattern*. The `items()` method is probably the most useful; it returns an iterator
    over tuples of `(key, value)` pairs for every item in the dictionary. This works
    great with tuple unpacking in a `for` loop to loop over associated keys and values.
    The following example does just that to print each stock in the dictionary with
    its current value:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 三种其他有用的字典方法是 `keys()`、`values()` 和 `items()`。前两种方法返回字典中所有键和所有值的迭代器。如果我们想处理所有的键或值，我们可以使用这些方法在
    `for` 循环中。我们将在第 10 章，即《迭代器模式》中回到迭代器的通用性。`items()` 方法可能是最有用的；它返回一个迭代器，遍历字典中每个项目的
    `(key, value)` 对。这非常适合在 `for` 循环中使用元组解包来遍历关联的键和值。以下示例正是这样做的，用于打印字典中每个股票及其当前值：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Each key/value tuple is unpacked into two variables named `stock` and `values` (we
    could use any variable names we wanted, but these both seem appropriate) and then
    printed in a formatted string.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键/值元组被解包成两个名为 `stock` 和 `values` 的变量（我们可以使用任何我们想要的变量名，但这两个似乎都很合适），然后以格式化的字符串形式打印出来。
- en: Notice that the stocks show up in the same order in which they were inserted.
    This was not true until Python 3.6, and was not a formal part of the language
    definition until Python 3.7\. Before that, the `dict` implementation used a different
    underlying data structure with a difficult-to-predict ordering. According to PEP
    478, Python 3.5's final release was in September 2020, making this older, difficult-to-predict
    ordering fully obsolete. To preserve the ordering of keys, we used to be forced
    to use the `OrderedDict` class in the `collections` module, but that's no longer
    needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，股票的显示顺序与它们被插入的顺序相同。这种情况在 Python 3.6 之前并不成立，直到 Python 3.7 才成为语言定义的正式部分。在此之前，`dict`
    实现使用了一个不同的底层数据结构，其顺序难以预测。根据 PEP 478，Python 3.5 的最终发布是在 2020 年 9 月，这使得这种较老且难以预测的顺序完全过时。为了保留键的顺序，我们曾经被迫在
    `collections` 模块中使用 `OrderedDict` 类，但现在不再需要这样做了。
- en: 'There are numerous ways to retrieve data from a dictionary once it has been
    instantiated: we can use square brackets as index syntax, the `get()` method,
    the `setdefault()` method, or iterate over the `items()` method, among others.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化字典，就有许多种方法可以检索数据：我们可以使用方括号作为索引语法，`get()`方法，`setdefault()`方法，或者遍历`items()`方法，等等。
- en: 'Finally, as you likely already know, we can set a value in a dictionary using
    the same indexing syntax we use to retrieve a value:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如你可能已经知道的，我们可以使用与检索值相同的索引语法在字典中设置一个值：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To reflect a change in the GOOG stock, we can update the tuple value in the
    dictionary. We can use this index syntax to set a value for any key, regardless
    of whether the key is in the dictionary. If it is in the dictionary, the old value
    will be replaced with the new one; otherwise, a new key-value pair will be created.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要反映GOOG股票的变化，我们可以在字典中更新元组值。我们可以使用这种索引语法为任何键设置值，无论该键是否在字典中。如果它在字典中，旧值将被新值替换；否则，将创建一个新的键值对。
- en: We've been using strings as dictionary keys, so far, but we aren't limited to
    string keys. It is common to use strings as keys, especially when we're storing
    data in a dictionary to gather it together (instead of using an object or dataclass
    with named properties). But we can also use tuples, numbers, or even objects we've
    defined ourselves as dictionary keys. The essential ingredient is a `__hash__()`
    method, which immutable types offer. While we can even use different types of
    objects as keys in a single dictionary, this is difficult to describe to **mypy**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止一直使用字符串作为字典键，但我们并不局限于字符串键。通常情况下，使用字符串作为键是很常见的，尤其是当我们需要在字典中存储数据以将其聚集在一起时（而不是使用具有命名属性的类或数据类）。但我们也可以使用元组、数字，甚至是我们自己定义的对象作为字典键。关键因素是一个`__hash__()`方法，这是不可变类型提供的。虽然我们甚至可以在单个字典中使用不同类型的对象作为键，但这很难向**mypy**描述。
- en: 'Here''s an example of a dictionary with a variety of keys and values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个包含多种键和值的字典示例：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code shows several different types of keys we can supply to a dictionary.
    The data structure has a type hint of `dict[Union[str, int, float, Tuple[str,
    int], AnObject], str]`. This is clearly terribly complex. Writing type hints for
    this can be bewildering, suggesting it's not the best approach.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了我们可以提供给字典的几种不同类型的键。该数据结构具有类型提示`dict[Union[str, int, float, Tuple[str,
    int], AnObject], str]`。这显然非常复杂。为这种类型编写类型提示可能会让人感到困惑，暗示这不是最佳方法。
- en: This example also shows one type of object that cannot be used as a key. We've
    already used lists extensively, and we'll be seeing many more details of them
    in the next section. Because lists are mutable – they can change at any time (by
    adding or removing items, for example) – they cannot hash to a single value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也展示了一种不能用作键的对象类型。我们已经广泛使用了列表，在下一节中我们将看到更多关于它们的细节。因为列表是可变的——它们可以在任何时间改变（例如通过添加或删除项目）——所以它们不能哈希到一个单一值。
- en: We can use code like the following to examine values in the dictionary. This
    works because the default behavior of a mapping is to iterate over the keys.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来检查字典中的值。这是因为映射的默认行为是遍历键。
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To be usable as a dictionary key, an object must be **hashable**, that is, have
    a `__hash__()` method to convert the object''s state into a unique integer value
    for rapid lookup in a dictionary or set. The built-in `hash()` function uses the
    `__hash__()` method of the object''s class. This hash is used to find values in
    a dictionary. For example, strings map to integers based on numeric codes for
    the characters in the string, while tuples combine hashes of the items inside
    the tuple. Any two objects that are considered equal (such as strings with the
    same characters or tuples with the same values) **must** also have the same hash
    value. Note that there is an asymmetry between equality and matching hash values.
    If two strings have the same hash value, they could still be unequal. Think of
    hash equality as an approximation for an equality test: if the hashes aren''t
    equal, don''t bother looking at the details. If the hashes are equal, invest the
    time in checking each attribute value or each item of the tuple, or each individual
    character of the string.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要用作字典键，一个对象必须是**可哈希的**，也就是说，必须有一个`__hash__()`方法来将对象的状态转换为唯一整数值，以便在字典或集中快速查找。内置的`hash()`函数使用对象的类的`__hash__()`方法。这个哈希值用于在字典中查找值。例如，字符串根据字符串中字符的数值代码映射到整数，而元组则结合元组内项的哈希值。任何被认为相等的两个对象（例如具有相同字符的字符串或具有相同值的元组）**必须**也有相同的哈希值。请注意，相等性和匹配的哈希值之间存在不对称性。如果两个字符串具有相同的哈希值，它们仍然可能不相等。将哈希相等性视为相等性测试的近似：如果哈希值不相等，就无需查看细节。如果哈希值相等，则投入时间检查每个属性值或元组的每个项，或字符串的每个单独字符。
- en: 'Here''s an example of two integers with the same hash value that are not actually
    equal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，展示了两个具有相同哈希值但实际并不相等的整数：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When we use these values as keys in a dictionary, a hash collision algorithm
    will keep them separated. The situation leads to a microscopic slowdown in these
    rare cases of hash collisions. This is why dictionary lookup isn''t **always**
    immediate: a hash collision might slow down access.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这些值用作字典中的键时，哈希冲突算法将保持它们的分离。这种情况会导致在哈希冲突的罕见情况下出现微小的速度减慢。这就是为什么字典查找并不**总是**立即发生：哈希冲突可能会减慢访问速度。
- en: The built-in mutable objects – including lists, dictionaries, and sets – cannot
    be used as dictionary keys. These mutable collections don't provide hash values.
    We can, however, create our own class of objects that are both mutable and provide
    a hash value; this is unsafe because a change to the object's state can make it
    difficult to find the key in the dictionary.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的可变对象——包括列表、字典和集合——不能用作字典键。这些可变集合不提供哈希值。然而，我们可以创建自己的对象类，这些对象既是可变的又提供哈希值；这不太安全，因为对象状态的变化可能会使得在字典中查找键变得困难。
- en: We can go too far, of course. It is certainly possible to create a class with
    a mixture of mutable and immutable attributes and confine a customized hash computation
    to the mutable attributes. Because of the differences in behavior between the
    mutable and immutable features, this seems like it's really two objects that collaborate,
    not a single object with mutable and immutable features. We can use the immutable
    part for dictionary keys and keep the mutable part in the dictionary value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可能会走得太远。确实有可能创建一个具有可变和不可变属性的类，并将定制的哈希计算仅限于可变属性。由于可变和不可变特性之间的行为差异，这看起来像是两个协作的对象，而不是具有可变和不可变特性的单个对象。我们可以使用不可变部分作为字典键，并将可变部分保留在字典值中。
- en: In contrast, there are no limits on the types of objects that can be used as
    dictionary values. We can use a string key that maps to a list value, for example,
    or we can have a nested dictionary as a value in another dictionary.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，没有限制可以使用哪些类型的对象作为字典值。例如，我们可以使用字符串键映射到列表值，或者我们可以在另一个字典中有一个嵌套字典作为值。
- en: Dictionary use cases
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典使用案例
- en: 'Dictionaries are extremely versatile and have numerous uses. Here are two major
    examples:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 词典极其多功能，用途广泛。以下是两个主要例子：
- en: We can have dictionaries where all the values are different instances of objects
    with the same type. For example, our stock dictionary would have a type hint of
    `dict[str, tuple[float, float, float]]`. The string key maps to a three-tuple
    of values. We use the stock symbol as an index to price details. If we had a more
    complex `Stock` class, we might have a dictionary with `dict[str, Stock]` as the
    type hint for an index into these objects.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以拥有所有值都是相同类型对象不同实例的字典。例如，我们的股票字典会有一个类型提示为 `dict[str, tuple[float, float,
    float]]`。字符串键映射到一个包含三个值的元组。我们使用股票符号作为价格详情的索引。如果我们有一个更复杂的 `Stock` 类，我们可能有一个类型提示为
    `dict[str, Stock]` 的字典，作为这些对象的索引。
- en: 'The second design is to have each key represent some aspect or attribute of
    a single object; the values often have distinct types. We may, for example, represent
    a stock with `{''name'': ''GOOG'', ''current'': 1245.21, ''range'': (1252.64,
    1245.18)}`. This case clearly overlaps with named tuples, dataclasses, and objects
    in general. Indeed, there''s a special type hint for this kind of dictionary,
    called a `TypedDict`, that looks like a `NamedTuple` type hint.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第二种设计是让每个键代表单个对象的一些方面或属性；值通常具有不同的类型。例如，我们可以用`{''name'': ''GOOG'', ''current'':
    1245.21, ''range'': (1252.64, 1245.18)}`来表示一支股票。这种情况下，它与命名元组、数据类以及一般对象明显重叠。实际上，对于这种类型的字典，有一个特殊的类型提示，称为`TypedDict`，其外观类似于`NamedTuple`类型提示。'
- en: This second example can be confusing; how do we decide how to represent attribute
    values of an object? We can rank the techniques like this.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个例子可能会让人困惑；我们如何决定如何表示一个对象的属性值呢？我们可以这样对技术进行排序。
- en: For a lot of cases, dataclasses offer a number of helpful features with less
    code writing. They can be immutable, or mutable, giving us a wide range of options.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于许多情况，数据类提供了一系列有助于减少代码编写的功能。它们可以是不可变的，也可以是可变的，为我们提供了广泛的选择。
- en: For cases where the data is immutable, a `NamedTuple` can be slightly more efficient
    than a frozen dataclass by about 5% – not much. What tips the balance here is
    an expensive attribute computation. While a `NamedTuple` can have properties,
    if the computation is very costly and the results are used frequently, it can
    help to compute it in advance, something a `NamedTuple` isn't good at. Check out
    the documentation for dataclasses and their `__post_init__()` method as a better
    choice in the rare case where it's helpful to compute an attribute value in advance.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于数据不可变的情况，`NamedTuple` 比冻结的数据类大约高效 5% —— 并不是很多。这里的平衡点在于昂贵的属性计算。虽然 `NamedTuple`
    可以有属性，但如果计算非常昂贵且结果被频繁使用，提前计算它可能会有所帮助，这是 `NamedTuple` 不擅长的。在极少数需要提前计算属性值的情况下，请查看数据类的文档及其
    `__post_init__()` 方法，作为更好的选择。
- en: Dictionaries are ideal when the complete set of keys isn't known in advance.
    When we're starting a design, we may have throwaway prototypes or proofs of concept
    using dictionaries. When we try to write unit tests and type hints, we may need
    to ramp up the formality. In some cases, the domain of possible keys is known,
    and a `TypedDict` type hint makes sense as a way to characterize the valid keys
    and value types.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字典在事先不知道完整键集时非常理想。当我们开始设计时，可能会使用字典来制作可丢弃的原型或概念验证。当我们尝试编写单元测试和类型提示时，可能需要提高正式性。在某些情况下，可能的键域是已知的，使用`TypedDict`类型提示作为描述有效键和值类型的手段是有意义的。
- en: Because of the similar syntax, it's relatively easy to try different designs
    to see which works better for the problem, which is faster, which is easier to
    test, and which uses less memory. Sometimes, all three converge and there's one
    best choice. More often, it's a trade-off.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语法相似，尝试不同的设计以查看哪种更适合问题、哪种更快、哪种更容易测试以及哪种使用的内存更少相对容易。有时，这三个方面都会趋于一致，从而有一个最佳选择。更常见的情况是，这是一个权衡的过程。
- en: Technically, most classes are implemented using dictionaries under the hood.
    You can see this by loading an object into the interactive interpreter and looking
    at the `__dict__` special attribute, if it's present. When you access an attribute
    on an object using syntax like `obj.attr_name`, this is effectively `obj.__dict__['attr_name']`
    under the hood. It's actually a bit more complicated, involving `__getattr__()`
    and `__getattribute__()`, but you get the gist. Even dataclasses have a `__dict__`
    attribute, which just goes to show how widely used dictionaries really are. They
    aren't universal, but they are common.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，大多数类都是在底层使用字典实现的。你可以通过将一个对象加载到交互式解释器中并查看是否存在特殊属性`__dict__`来看到这一点。当你使用类似`obj.attr_name`的语法在对象上访问属性时，这实际上在底层是`obj.__dict__['attr_name']`。实际上要复杂一些，涉及到`__getattr__()`和`__getattribute__()`，但你能理解其精髓。即使是数据类也有`__dict__`属性，这仅仅表明字典的实际应用范围有多么广泛。它们不是万能的，但它们很常见。
- en: Using defaultdict
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 defaultdict
- en: 'We''ve seen how to use the `setdefault` method to set a default value if a
    key doesn''t exist, but this can get a bit monotonous if we need to set a default
    value every time we look up a value. For example, if we''re writing code that
    counts the number of times a letter occurs in a given sentence, we could do the
    following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`setdefault`方法在键不存在时设置默认值，但如果每次查找值时都需要设置默认值，这可能会变得有点单调乏味。例如，如果我们正在编写代码来计算一个句子中某个字母出现的次数，我们可以这样做：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Every time we access the dictionary, we need to check that it has a value already,
    and if not, set it to zero. When something like this needs to be done every time
    an empty key is requested, we can create a different version of a dictionary.
    The `defaultdict`, defined in the `collections` module, handles missing keys elegantly:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们访问字典时，都需要检查它是否已经有值，如果没有，则将其设置为零。当每次请求空键时都需要执行此类操作时，我们可以创建字典的不同版本。在`collections`模块中定义的`defaultdict`优雅地处理了缺失键的情况：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code looks odd: the `defaultdict()` evaluation accepts a function, `int`,
    in its constructor. We''re not evaluating the `int()` function; we''re providing
    a reference to this function to `defaultdict()`. Whenever a key is accessed that
    is not already in the dictionary, it calls that function, with no parameters,
    to create a default value.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来很奇怪：`defaultdict()` 函数的构造函数接受一个函数，`int`，作为参数。我们并不是在评估 `int()` 函数；我们是在向
    `defaultdict()` 提供对这个函数的引用。每当访问一个不在字典中的键时，它会调用这个函数（无参数），以创建一个默认值。
- en: Note that the `defaultdict[str, int]` type hint is slightly wordier than the
    `defaultdict()` evaluation itself. The `defaultdict()` class only needs a function
    that will create default values. The type of the keys doesn't actually matter
    at runtime; any object with a `__hash__()` method will work. When using `defaultdict`
    as a type hint, though, it needs some additional details before we can be **sure**
    this will work. We need to provide both the type of the key – `str`, in this example
    – and the type of object that will be associated with the key – `int`, in this
    example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`defaultdict[str, int]` 类型提示比 `defaultdict()` 评估本身要冗长一些。`defaultdict()` 类只需要一个函数来创建默认值。键的类型在运行时实际上并不重要；任何具有
    `__hash__()` 方法的对象都可以工作。然而，当将 `defaultdict` 用作类型提示时，我们需要一些额外的细节才能确保这会工作。我们需要提供键的类型——在这个例子中是
    `str` ——以及将与键关联的对象的类型——在这个例子中是 `int`。
- en: In this example, the `frequencies` object uses the function `int()` to create
    default values. This is the constructor for an integer object. Normally, integers
    are created as a literal, by typing an integer number into our code. If we do
    create an integer using the `int()` constructor, it's often part of a conversion;
    for example, to convert a string of digits into an integer, like `int("42")`.
    But if we call `int()` without any arguments, it returns, conveniently, the number
    zero. In this code, if a letter doesn't exist in the `defaultdict`, the number
    zero is created by the factory function and returned when we access it. Then,
    we add one to this number to indicate that we've found an instance of that letter
    and save the updated value back into the dictionary. The next time we find the
    same character, the new number will be returned and we can increment the value
    and save it back into the dictionary.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`frequencies` 对象使用 `int()` 函数来创建默认值。这是整数对象的构造函数。通常，整数是通过将整数数字输入到我们的代码中作为字面量来创建的。如果我们使用
    `int()` 构造函数创建整数，它通常是一个转换的一部分；例如，将数字字符串转换为整数，如 `int("42")`。但是，如果我们不带任何参数调用 `int()`，它方便地返回数字零。在这段代码中，如果
    `defaultdict` 中不存在字母，则通过工厂函数创建数字零，并在我们访问它时返回。然后，我们将这个数字加一，以表示我们找到了该字母的一个实例，并将更新后的值保存回字典。下次我们找到相同的字符时，将返回新的数字，我们可以增加这个值并将其保存回字典。
- en: 'The `defaultdict()` is useful for creating dictionaries of containers. If we
    want to create a dictionary of closing stock prices for the past 30 days, we could
    use a stock symbol as the key and store the prices in a `list`; the first time
    we access the stock price, we would want to create an empty list. Simply pass
    the `list` function into the `defaultdict`, like this: `defaultdict(list)`. The
    `list()` function will be called every time a previously unknown key is accessed.
    We can do similar things with sets or even empty dictionaries if we want to use
    a subsidiary dictionary as the value for a key.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict()` 函数在创建容器字典时非常有用。如果我们想创建一个包含过去30天收盘价的字典，我们可以使用股票代码作为键，并将价格存储在一个`list`中；当我们第一次访问股票价格时，我们希望创建一个空列表。只需将`list`函数传递给`defaultdict`，如下所示：`defaultdict(list)`。每次访问一个之前未知的键时，都会调用`list()`函数。如果我们想使用子字典作为键的值，我们可以用集合或空字典来做类似的事情。'
- en: Of course, we can also write our own functions and pass them into the `defaultdict`.
    Suppose we want to create a `defaultdict` where each key maps to a dataclass with
    information about that key. If we define our dataclass with default values, then
    our class name will work as a function without arguments.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以编写自己的函数并将它们传递给`defaultdict`。假设我们想要创建一个`defaultdict`，其中每个键映射到一个包含该键信息的数据类。如果我们使用默认值定义我们的数据类，那么我们的类名将作为一个不带参数的函数使用。
- en: 'Consider this dataclass, `Prices`, with all default values:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个数据类，`Prices`，其中包含所有默认值：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since the class has default values for all attributes, we can use the class
    name without argument values and get a useful object. This means our class name
    will work as the argument to the `defaultdict()` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该类为所有属性提供了默认值，我们可以不提供参数值直接使用类名，从而获得一个有用的对象。这意味着我们的类名将作为`defaultdict()`函数的参数：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When we print `portfolio`, we see how the default objects were saved in the
    dictionary:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印`portfolio`时，我们看到默认对象是如何在字典中保存的：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This `portfolio` dictionary creates a default `Prices` object for unknown keys.
    This works because the `Prices` class had default values for all of the attributes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`portfolio`字典为未知键创建了一个默认的`Prices`对象。这是因为`Prices`类为所有属性都设置了默认值。
- en: 'We can extend this even further. What if we want prices for stocks grouped
    by month? We want a dictionary with a key of the stock name. Within that we want
    dictionaries keyed by month. And within that inner dictionary, we want prices.
    This can be tricky because we want a default function that takes zero arguments
    and creates a `defaultdict(Prices)` for us. We can define a one-line function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更进一步扩展。如果我们想要按月分组的价格呢？我们想要一个以股票名称为键的字典。在这个字典中，我们想要以月份为键的子字典。而在那个内部字典中，我们想要价格。这可能会有些棘手，因为我们想要一个接受零个参数并为我们创建`defaultdict(Prices)`的默认函数。我们可以定义一个单行函数：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can also use a Python lambda form – a no-name, one expression function for
    this. A lambda can have parameters, but we don't need any. The single expression
    is the object we'd like created as a default.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 Python 的 lambda 表达式——一个无名称的、单表达式函数来做到这一点。lambda 可以有参数，但我们不需要任何参数。这个单表达式就是我们要创建的对象，作为默认值。
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now we can have nested `defaultdict` dictionaries. When a key is missing, a
    proper default is built.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以拥有嵌套的 `defaultdict` 字典。当缺失键时，会构建一个合适的默认值。
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `by_month` collection's top-level key points to an internal dictionary.
    The internal dictionary has prices for each month.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`by_month` 集合的最高级键指向一个内部字典。该内部字典包含每个月的价格。'
- en: Counter
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数器
- en: 'You''d think that algorithms could not get much simpler than using `defaultdict(int)`.
    The *I want to count specific instances in an iterable* use case is common enough
    that the Python developers created a specific class for this exact purpose, simplifying
    things even further. The previous code that counts characters in a string can
    easily be calculated in a single line:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，算法的简化程度不可能超过使用 `defaultdict(int)`。*我想在可迭代对象中计数特定实例* 的用例足够常见，以至于 Python
    开发者为这个特定目的创建了一个特定的类，进一步简化了事情。之前用于计算字符串中字符数量的代码可以轻松地用一行计算出来：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Counter` object behaves like a beefed-up dictionary where the keys are
    the items being counted and the values are the quantities of such items. One of
    the most useful functions is the `most_common()` method. It returns a list of
    `(key,count)` tuples in descending order by the count. You can optionally pass
    an integer argument into `most_common()` to request a list of only the most common
    elements. For example, you could write a simple polling application as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 对象的行为类似于增强版的字典，其中键是正在计数的项，值是此类项的数量。其中最有用的函数之一是 `most_common()` 方法。它按计数降序返回
    `(key,count)` 元组的列表。你可以选择性地向 `most_common()` 方法传递一个整数参数，以请求仅包含最常见元素的列表。例如，你可以编写一个简单的投票应用程序如下：'
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Presumably, you'd get the responses from a database or by using a computer vision
    algorithm to count the kids who raised their hands. Here, we hardcoded the `responses`
    object with literal values so that we can test the `most_common()` method. This
    method always returns a list, even when we only asked for one element. The hint
    is effectively `list[tuple[T, int]]` where `T` is the type we're counting. In
    our example, where we're counting strings, the hint for the `most_common()` method
    is `list[tuple[str, int]]`. We only want the first item from a one-item list,
    so `[0]` is required. We can then decompose the two-tuple into the value that
    was counted and the integer count.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 据推测，您可能通过数据库或使用计算机视觉算法来统计举手的孩子。在这里，我们硬编码了`responses`对象，并使用字面值，以便测试`most_common()`方法。此方法始终返回一个列表，即使我们只请求一个元素。提示实际上是`list[tuple[T,
    int]]`，其中`T`是我们正在计数的类型。在我们的例子中，我们正在计数字符串，因此`most_common()`方法的提示是`list[tuple[str,
    int]]`。我们只想从一个只有一个元素的列表中获取第一个项目，所以需要`[0]`。然后我们可以将这个二元组分解为被计数的值和整数计数。
- en: Speaking of lists, it's time to dig a little more deeply into Python's list
    collection.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到列表，是时候更深入地了解一下 Python 的列表集合了。
- en: Lists
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Python's generic list structure is integrated into a number of language features.
    We don't need to import them and rarely need to use method syntax to access their
    features. We can visit all the items in a list without explicitly requesting an
    iterator object, and we can construct a list (as with a dictionary) with very
    simple-looking syntax. Further, list comprehensions and generator expressions
    turn them into a veritable Swiss Army knife of computing functionality.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Python的通用列表结构集成到许多语言特性中。我们不需要导入它们，也很少需要使用方法语法来访问它们的功能。我们可以访问列表中的所有项目，而无需显式请求迭代器对象，并且我们可以用非常简单的语法构造一个列表（就像字典一样）。此外，列表推导式和生成器表达式使它们成为计算功能的瑞士军刀。
- en: If you don't know how to create or append to a list, how to retrieve items from
    a list, or what *slice notation* is, we direct you to the official Python tutorial,
    posthaste. It can be found online at [http://docs.python.org/3/tutorial/](http://docs.python.org/3/tutorial/).
    In this section, we'll move beyond the basics to cover when lists should be used,
    and their nature as objects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道如何创建或向列表中添加内容，如何从列表中检索项目，或者什么是*切片表示法*，我们立即将你指引到官方的Python教程。它可以在网上找到，地址是[http://docs.python.org/3/tutorial/](http://docs.python.org/3/tutorial/)。在本节中，我们将超越基础知识，讨论何时应该使用列表，以及它们作为对象的本性。
- en: In Python, lists should normally be used when we want to store several instances
    of the *same* type of object; lists of strings or lists of numbers. We'll often
    use a type hint `list[T]` to specify the type, `T`, of object kept in the list,
    for example, `list[int]` or `list[str]`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当我们想要存储同一类型对象的多个实例时，通常应该使用列表；例如字符串列表或数字列表。我们通常会使用类型提示`list[T]`来指定列表中保存的对象类型`T`，例如`list[int]`或`list[str]`。
- en: (Remember that `from __future__ import annotations` is required for this to
    work.) Lists must be used when we want to store items in some kind of order. Often,
    this is the order in which they were inserted, but they can also be sorted by
    other criteria.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: （请记住，要使此功能正常工作，需要使用`from __future__ import annotations`。）当我们想要以某种顺序存储项目时，必须使用列表。通常，这是它们被插入的顺序，但也可以根据其他标准进行排序。
- en: Lists are mutable, so items can be added, replaced, and removed from the list.
    This can be handy for reflecting the state of some more complex objects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是可变的，因此可以从列表中添加、替换和删除项目。这有助于反映某些更复杂对象的状态。
- en: Like dictionaries, Python lists use an extremely efficient and well-tuned internal
    data structure so we can worry about what we're storing, rather than how we're
    storing it. Python expands on lists to provide some specialized data structures
    for queues and stacks. Python doesn't make a distinction between lists based on
    arrays or lists that use links. Generally, the built-in list data structure can
    serve a wide variety of purposes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字典一样，Python 列表使用了一种极其高效和调优良好的内部数据结构，因此我们可以关注我们存储的内容，而不是存储的方式。Python 在列表的基础上扩展了一些专门的数据结构，用于队列和栈。Python
    并不区分基于数组或使用链接的列表。通常，内置的列表数据结构可以满足多种用途。
- en: Don't use lists for collecting different attributes of individual items. Tuples,
    named tuples, dictionaries, and objects would all be more suitable for collecting
    different kinds of attribute values. Our first `Stock` data examples at the beginning
    of the chapter stored current price, minimum price, and maximum price, each a
    different attribute with a distinct meaning in a single sequence. This isn't really
    ideal, and named tuples or dataclasses were clearly superior.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用列表来收集单个项目的不同属性。元组、命名元组、字典和对象都更适合收集不同种类的属性值。本章开头我们存储的“Stock”数据示例中存储了当前价格、最低价格和最高价格，每个都是单序列中具有不同含义的不同属性。这并不是真正理想的，命名元组或数据类显然更优越。
- en: 'Here''s a rather convoluted counterexample that demonstrates how we could perform
    the frequency example using a list. It is much more complicated than the dictionary
    examples and illustrates the effect that choosing the right (or wrong) data structure
    can have on the readability (and performance) of our code. This is demonstrated
    as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个相当复杂的反例，展示了我们如何使用列表来执行频率示例。它比字典示例复杂得多，并说明了选择正确（或错误）的数据结构对我们代码的可读性（以及性能）可能产生的影响。这如下所示：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This code starts with a list of possible characters. The `string.ascii_letters` attribute
    provides a string of all the letters, lowercase and uppercase, in order. We convert
    this to a list and then use list concatenation (the `+` operator causes two lists
    to be concatenated into one) to add one more character, a space. These are the
    available characters in our frequency list (the code would break if we tried to
    add a letter that wasn't in the list).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从一个可能的字符列表开始。`string.ascii_letters` 属性提供了一个包含所有字母（大小写）的字符串，并按顺序排列。我们将这个字符串转换为列表，然后使用列表连接（`+`
    运算符将两个列表连接成一个）添加一个额外的字符，即一个空格。这些就是我们在频率列表中可用的字符（如果我们尝试添加不在列表中的字母，代码将会出错）。
- en: The first line inside the function uses a list comprehension to turn the `CHARACTERS` list
    into a list of tuples. Then, we loop over each of the characters in the sentence.
    We first look up the index of the character in the `CHARACTERS` list, which we
    know has the same index in our frequencies list, since we created the second list
    from the first. We then update that index in the frequencies list by creating
    a new tuple, discarding the original one. Aside from garbage collection and memory
    waste concerns, this is rather difficult to read!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内的第一行使用列表推导将`CHARACTERS`列表转换为一个元组列表。然后，我们遍历句子中的每个字符。我们首先在`CHARACTERS`列表中查找字符的索引，由于我们知道这个索引与我们的频率列表中的索引相同，因为我们是从第一个列表创建第二个列表的。然后，我们通过创建一个新的元组来更新频率列表中的该索引，丢弃原始的元组。除了垃圾回收和内存浪费的担忧之外，这相当难以阅读！
- en: Finally, we filter the list by examining each tuple and keeping only pairs where
    the count is greater than zero. This removes the letters we allocated space for
    but never saw.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过检查每个元组来过滤列表，只保留计数大于零的成对元素。这样就去掉了我们分配了空间但从未见过的字母。
- en: Besides being longer, the `CHARACTERS.index(letter)` operation can be very slow.
    The worst case is to examine each of the characters in the list for a match. On
    average, it will search half the list. Compare this with a dictionary that does
    a hash computation and examines one item for a match. (Except in the case of a
    hash collision where there's a tiny probability of examining more than one and
    it has to handle hash collision with a second lookup.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更长之外，`CHARACTERS.index(letter)` 操作可能非常慢。最坏的情况是检查列表中的每个字符以找到匹配项。平均来说，它会搜索列表的一半。与进行哈希计算并检查一个项以找到匹配项的字典相比。（除非发生哈希冲突，在这种情况下，检查多个项的概率极小，并且它必须通过第二次查找来处理哈希冲突。）
- en: The type hint describes the type of the objects in the list. We summarized it
    as `list[tuple[str, int]]`. Each of the items in the resulting list will be a
    two-tuple. This lets **mypy** confirm that the operations respect the structure
    of the list overall and each tuple within the list.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示描述了列表中对象的数据类型。我们将其总结为`list[tuple[str, int]]`。结果列表中的每个项目都将是一个包含两个元素的元组。这使得**mypy**可以确认操作尊重列表的整体结构和列表中每个元组的结构。
- en: 'Like dictionaries, lists are objects, too. They have several methods that can
    be invoked upon them. Here are some common ones:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字典一样，列表也是对象。它们有几个可以在其上调用的方法。以下是一些常见的：
- en: The `append(element)` method adds an element to the end of the list
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append(element)`方法将元素添加到列表的末尾'
- en: The `insert(index, element)` method inserts an item at a specific position
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `count(element)` method tells us how many times an element appears in the
    list
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count(element)`方法告诉我们一个元素在列表中出现的次数'
- en: The `index()` method tells us the index of an item in the list, raising an exception
    if it can't find it
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index()` 方法告诉我们列表中一个项目的索引，如果找不到它将抛出一个异常'
- en: The `find()` method does the same thing but returns `-1` instead of raising
    an exception for missing items
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find()` 方法执行相同的操作，但针对缺失的项目返回 `-1` 而不是抛出异常'
- en: The `reverse()` method does exactly what it says – turns the list around
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse()` 方法确实如其名所示——将列表反转'
- en: The `sort()` method has some rather intricate object-oriented behaviors, which
    we'll cover now
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()` 方法有一些相当复杂的面向对象行为，我们现在就来探讨一下'
- en: 'There are a few more that are less commonly used. The complete list of methods
    is in the *Sequence Types* section of the Python Standard Library documentation:
    [https://docs.python.org/3.9/library/stdtypes.html#sequence-types-list-tuple-range](https://docs.python.org/3.9/library/stdtypes.html#sequence-types-list-tuple-range).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些不太常用的。完整的方法列表可以在Python标准库文档的*序列类型*部分找到：[https://docs.python.org/3.9/library/stdtypes.html#sequence-types-list-tuple-range](https://docs.python.org/3.9/library/stdtypes.html#sequence-types-list-tuple-range).
- en: Sorting lists
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序列表
- en: Without any parameters, the `sort()` method of a `list` object will generally
    do as expected. If we have a `list[str]` object, the `sort()` method will place
    the items in alphabetical order. This operation is case sensitive, so all capital
    letters will be sorted before lowercase letters; that is, `Z` comes before `a`.
    If it's a list of numbers, they will be sorted in numerical order. If a list of
    tuples is provided, the list is sorted by considering the elements in the tuple
    in order. If a mixture containing unsortable items is supplied, the sort will
    raise a `TypeError` exception.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何参数的情况下，`list` 对象的 `sort()` 方法通常会按预期工作。如果我们有一个 `list[str]` 对象，`sort()` 方法将按字母顺序排列项目。这个操作是区分大小写的，所以所有大写字母都将排在小写字母之前；也就是说，`Z`
    在 `a` 之前。如果是一个数字列表，它们将按数值顺序排序。如果提供了一个包含不可排序项的混合列表，排序将引发一个 `TypeError` 异常。
- en: If we want to place objects of classes we've defined ourselves into a list and
    make those objects sortable, we have to do a bit more work. The special `__lt__()`
    method, which stands for *less than*, must be defined on the class to make instances
    of that class comparable. The `sort` method on the list will access this method
    on each object to determine where it goes in the list. This method should return
    `True` if our class is somehow less than the passed parameter, and `False` otherwise.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将我们自己定义的类的对象放入列表中，并使这些对象可排序，我们就需要做更多的工作。必须定义一个特殊的`__lt__()`方法，它代表“小于”，以便使该类的实例可比较。列表上的`sort`方法将访问每个对象的此方法，以确定它在列表中的位置。如果我们的类在某种程度上小于传递的参数，则此方法应返回`True`，否则返回`False`。
- en: Often, when we need comparisons like this, we'll use a dataclass. As discussed
    in the *Dataclasses* section, the `@dataclass(order=True)` decorator will assure
    that all of the comparison methods are built for us. A named tuple also has the
    ordering operations defined by default.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们需要这样的比较时，我们会使用数据类。正如在*数据类*部分所讨论的，`@dataclass(order=True)`装饰器将确保所有比较方法都为我们构建。命名元组也默认定义了排序操作。
- en: One tricky situation that arises with sorting is handling a data structure sometimes
    called a **tagged union**. A union is a description of an object where attributes
    are not **always** relevant. If an attribute's relevance depends on another attribute's
    value, this can be seen as a union of distinct subtypes with a tag to distinguish
    between the two types.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序过程中可能会遇到的一个棘手情况是处理一种有时被称为**标记联合**的数据结构。联合是对一个对象的描述，其中属性并非**总是**相关。如果一个属性的相关性取决于另一个属性值，这可以看作是具有标记以区分两种类型的不同子类型的联合。
- en: Here's some example data, where a tag value, the **Data Source** column, is
    required to decide how best to deal with the remaining columns. Some values of
    **Data Source** tell us to use the timestamp, where as other values tell us to
    use the creation date.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例数据，其中标签值、**数据源**列是必须的，以便决定如何最好地处理剩余的列。**数据源**的一些值告诉我们使用时间戳，而其他值则告诉我们使用创建日期。
- en: '| Data Source | Timestamp | Creation Date | Name, Owner, etc. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 数据来源 | 时间戳 | 创建日期 | 名称、所有者等 |'
- en: '| Local | 1607280522.68012 |  | "Some File", etc. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 本地 | 1607280522.68012 |  | "某些文件"，等等 |'
- en: '| Remote |  | "2020-12-06T13:47:52.849153" | "Another File", etc. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 远程 |  | "2020-12-06T13:47:52.849153" | "另一个文件"，等等 |'
- en: '| Local | 1579373292.452993 |  | "This File", etc. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 本地 | 1579373292.452993 |  | "此文件"，等等 |'
- en: '| Remote |  | "2020-01-18T13:48:12.452993" | "That File", etc. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 远程 |  | "2020-01-18T13:48:12.452993" | "那个文件"，等等 |'
- en: How can we sort these into a single, coherent order? We'd like to have a single,
    consistent data type in our list, but the source data has two subtypes with a
    tag.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这些内容排序成一个单一、连贯的顺序呢？我们希望在列表中有一个单一、一致的数据类型，但源数据有两个子类型并带有标签。
- en: A simple-seeming `if row.data_source == "Local":` can work to distinguish values,
    but it can be confusing logic for **mypy** to work with. One or two *ad hoc* `if`
    statements aren't too bad, but the design principle of throwing `if` statements
    at the problem isn't very scalable.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来简单的 `if row.data_source == "Local":` 可以用来区分值，但对于 **mypy** 来说，这可能是一种令人困惑的逻辑。一两个
    *ad hoc* 的 `if` 语句问题不大，但将 `if` 语句抛向问题的设计原则并不十分可扩展。
- en: In this example, we can consider **Timestamp** as the preferred representation.
    This means we only need to compute timestamps from the creation date string for
    the items where the data source is "Remote." In this example, either the float
    value or the string would sort into order properly. This happens to work out well
    because the string is in the carefully designed ISO format. If it was in American
    month-day-year format, it would require conversion to a timestamp to be useful.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以将**时间戳**视为首选的表示方式。这意味着我们只需要从创建日期字符串中计算数据源为"远程"的项目的时间戳。在这个例子中，无论是浮点值还是字符串都能正确排序。这恰好工作得很好，因为字符串是精心设计的ISO格式。如果它采用美国月份-日期-年份格式，就需要转换成时间戳才能使用。
- en: Converting all of the various input formats to Python's native `datetime.datetime`
    objects is another choice. This has the advantage of being distinct from any of
    the input formats. While this is a little more work, it gives us more flexibility
    because we're not tied to a source data format that may change in the future.
    The concept is to make every variant input format convert to a single, common
    `datetime.datetime` instance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有各种输入格式转换为 Python 的原生 `datetime.datetime` 对象是另一种选择。这具有与任何输入格式都不同的优势。虽然这需要做更多的工作，但它给了我们更多的灵活性，因为我们不会绑定到可能在未来发生变化的源数据格式。其概念是将每个变体输入格式转换为单个、通用的
    `datetime.datetime` 实例。
- en: What's central is treating the two subtypes as if they're a single class of
    objects. This doesn't always work out well. Often this is a design constraint
    that sneaks up on us when we have additional customers or additional sources of
    data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 核心在于将两种亚型视为一个单一的对象类别。这并不总是能取得良好的效果。通常，当我们有更多的客户或额外的数据来源时，这会变成一种设计约束，悄悄地出现在我们面前。
- en: 'We''ll start an implementation with a single type that supports both subtypes
    of data. This is not ideal, but it matches the source data and is often how we
    start tackling this kind of data. Here''s the essential class definition:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个支持数据子类型的数据类型开始实施。这并不是理想的做法，但它与源数据相匹配，并且通常是我们开始处理这类数据的方式。下面是基本的类定义：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `__lt__()` method compares an object of the `MultiItem` class to another
    instance of the same class. Because there are two implicit subclasses, we have
    to check the tag attributes, `self.data_source` and `other.data_source`, to see
    which of the various combinations of fields we're dealing with. We'll do a conversion
    from a timestamp or a string into a common representation. Then we can compare
    the two common representations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`__lt__()` 方法比较 `MultiItem` 类的对象与同一类的另一个实例。由于存在两个隐式子类，我们必须检查标签属性，`self.data_source`
    和 `other.data_source`，以确定我们正在处理各种字段组合中的哪一个。然后我们将时间戳或字符串转换为通用表示。之后，我们可以比较这两个通用表示。'
- en: The conversion processing is nearly duplicate code. Later in this section, we
    will look at refactoring this to remove the redundancy. The `cast()` operations
    are required to make it clear to **mypy** that the item will not be `None`. While
    we know the rules that match the tag (the **Data Source** column) and the two
    kinds of values, those rules need to be stated in a way **mypy** can exploit them.
    The `cast()` is how we tell **mypy** what the data will be at runtime; there's
    no processing that actually happens.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 转换处理几乎是重复的代码。在本节稍后，我们将探讨如何重构以消除冗余。`cast()`操作是必需的，以便向**mypy**明确指出该项不会是`None`。虽然我们知道匹配标签（**数据源**列）和两种值的规则，但这些规则需要以一种**mypy**可以利用的方式表述。`cast()`是我们告诉**mypy**运行时数据将是什么的方式；实际上并没有发生任何处理。
- en: Note that our application could have incomplete type hints and we could run
    with a bug and an object that's not an instance of `MultiItem` could be compared
    with an instance of `MultiItem`. This will likely result in a runtime error. The
    `cast()` is a claim about the intent and the design, with no runtime impact. Because
    of Python's duck typing, some unexpected type that has the right attributes can
    be used and will work. Unit testing is essential even with careful type hints.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的应用程序可能存在不完整的类型提示，并且我们可能会在存在错误的情况下运行，此时一个不是`MultiItem`实例的对象可能会与一个`MultiItem`实例进行比较。这很可能会导致运行时错误。`cast()`是对意图和设计的声明，没有运行时影响。由于Python的鸭子类型，一些具有正确属性的意外类型也可以使用并且会正常工作。即使有仔细的类型提示，单元测试也是必不可少的。
- en: 'The following output illustrates this class in action when it comes to sorting:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出展示了该类在排序方面的实际应用：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The comparison rules were applied among the various subtypes that were conflated
    into a single class definition. If the rules are more complex, however, this can
    become unwieldy.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 比较规则被应用于合并成一个单一类定义的各种子类型之间。然而，如果规则更加复杂，这可能会变得难以操控。
- en: 'Only the `__lt__()` method is required to implement to enable sorting. To be
    complete, the class may also implement the similar `__gt__()`, `__eq__()`, `__ne__()`,
    `__ge__()`, and `__le__()` methods. This ensures all of the `<`, `>`, `==`, `!=`,
    `>=`, and `<=` operators also work properly. You can get this for free by implementing
    `__lt__()` and `__eq__()`, and then applying the `@total_ordering` class decorator
    to supply the rest:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 仅需要实现`__lt__()`方法即可启用排序功能。为了完整，该类还可以实现类似的`__gt__()`、`__eq__()`、`__ne__()`、`__ge__()`和`__le__()`方法。这确保了所有`<`、`>`、`==`、`!=`、`>=`和`<=`运算符也能正常工作。通过实现`__lt__()`和`__eq__()`，然后应用`@total_ordering`类装饰器来提供其余部分，你可以免费获得这些功能：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We didn't repeat the `__lt__()` method body; we encourage the reader to rewrite
    it to look more like the `__eq__()` method. When we provide some combination of
    `<` (or `>`) and `=`, the `@total_order` decorator can deduce the remaining logic
    operator implementations. For example, ![](img/B17070_07_001.png). The implementation
    of `__ge__(self, other)` is `not self < other`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有重复`__lt__()`方法的主体；我们鼓励读者将其重写，使其更像`__eq__()`方法。当我们提供一些组合的`<`（或`>`）和`=`时，`@total_order`装饰器可以推断出剩余的逻辑运算符实现。例如，![图片](img/B17070_07_001.png)。`__ge__(self,
    other)`的实现是`not self < other`。
- en: 'Note that our class method definitions are (very) narrowly focused on comparing
    `timestamp` and `creation_date` attributes among these objects. The definitions
    of these methods are – perhaps – less than ideal because they reflect exactly
    one use case of comparison. We often have two possible designs:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的类方法定义（非常）专注于比较这些对象之间的 `timestamp` 和 `creation_date` 属性。这些方法的定义——或许——并不理想，因为它们正好反映了比较的一个用例。我们通常有两种可能的设计：
- en: Define the comparison operations narrowly, focused on a specific use case. In
    this example, we compare only the timestamps and ignore all other attributes.
    This is inflexible but can be made very efficient.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 狭义地定义比较操作，专注于特定的用例。在这个例子中，我们只比较时间戳，忽略所有其他属性。这种方法不够灵活，但可以非常高效。
- en: Define the comparison operations broadly, often only supporting `__eq__()` and
    `__ne__()` because there are too many alternative ordering comparisons that could
    be used. We extract individual attribute comparison rules outside the class and
    make them part of the sorting operation.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛定义比较操作，通常只支持`__eq__()`和`__ne__()`，因为可能存在太多可用的替代排序比较。我们将单个属性比较规则提取到类外，并使其成为排序操作的一部分。
- en: 'The second design strategy requires us to localize the comparison as part of
    evaluating the `sort()` method, instead of making the comparison a general part
    of the class. The `sort()` method can take an optional `key` argument. We use
    this to provide a "key extraction" function to the `sort()` method. This argument
    to `sort()` is a function that translates each object in a list into an object
    that can somehow be compared. In our case, we''d like a function to extract either
    the `timestamp` or the `creation_date` for comparison. It looks like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种设计策略要求我们将比较操作作为评估`sort()`方法的一部分进行本地化，而不是将比较作为类的一般部分。`sort()`方法可以接受一个可选的`key`参数。我们利用这个参数向`sort()`方法提供一个“键提取”函数。这个参数传递给`sort()`的是一个函数，它可以将列表中的每个对象转换成可以进行比较的对象。在我们的例子中，我们希望有一个函数能够提取用于比较的`timestamp`或`creation_date`。它看起来是这样的：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here''s how we use this `by_timestamp()` function to compare objects using
    `datetime` objects from each `SimpleMultiItem` object:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用这个`by_timestamp()`函数，通过每个`SimpleMultiItem`对象中的`datetime`对象来比较对象：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ve divorced the sorting rules from the class, leading to a pleasant simplification.
    We can leverage this kind of design to provide other kinds of sorts. We might,
    for example, sort by name only. This is slightly simpler because no conversion
    is required:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将排序规则从类中分离出来，这导致了一种令人愉悦的简化。我们可以利用这种设计来提供其他类型的排序。例如，我们可能只按名称排序。这稍微简单一些，因为不需要转换：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We've created a lambda object, a tiny no-name function that takes an item as
    an argument and returns the value of `item.name`. A lambda is a function, but
    it doesn't have a name, and it can't have any statements. It only has a single
    expression. If you need statements (for example a try/except clause) you need
    a conventional function definition outside the `sort()` method arguments.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个lambda对象，这是一个微不足道的无名函数，它接受一个项目作为参数并返回`item.name`的值。Lambda是一个函数，但它没有名字，并且不能有任何语句。它只有一个表达式。如果你需要语句（例如try/except子句），你需要在`sort()`方法参数外部使用传统的函数定义。
- en: 'There are a few sort key operations that are so common that the Python team
    has supplied them so you don''t have to write them yourself. For example, it is
    common to sort a list of tuples by something other than the first item in the
    list. The `operator.attrgetter` method can be used as a key to do this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些排序键操作非常常见，Python 团队已经提供了它们，这样你就不必自己编写它们。例如，通常情况下，我们会根据列表中的除第一个元素之外的其他元素来对元组列表进行排序。可以使用
    `operator.attrgetter` 方法作为键来完成这个操作：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `attrgetter()` function fetches a specific attribute from an object. When
    working with tuples or dictionaries, `itemgetter()` can be used to extract a specific
    item by name or position. There's even a `methodcaller()`, which returns the result
    of a method call on the object being sorted. Refer to the `operator` module documentation
    for more information.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrgetter()` 函数用于从对象中获取特定属性。当处理元组或字典时，可以使用 `itemgetter()` 通过名称或位置提取特定项。甚至还有一个
    `methodcaller()`，它返回对排序对象进行方法调用的结果。有关更多信息，请参阅 `operator` 模块文档。'
- en: There's rarely one single sort order for data objects. Providing the key function
    as part of the `sort()` method lets us define a wide variety of sorting rules
    without creating complex class definitions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对象很少只有一个排序方式。将键函数作为`sort()`方法的一部分，让我们能够定义多种多样的排序规则，而无需创建复杂的类定义。
- en: After looking at dictionaries and now lists, we can turn our attention to sets.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在查阅了词典和列表之后，我们可以将注意力转向集合。
- en: Sets
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Lists are extremely versatile tools that suit many container object applications.
    But they are not useful when we want to ensure that objects in a list are unique.
    For example, a song library may contain many songs by the same artist. If we want
    to sort through the library and create a list of all the artists, we would have
    to check the list to see whether we've added the artist already, before we add
    them again.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是极其多功能的工具，适用于许多容器对象应用。但是，当我们想要确保列表中的对象唯一时，它们就不再有用。例如，一个音乐库可能包含同一艺术家的许多歌曲。如果我们想要在库中筛选并创建所有艺术家的列表，我们必须在再次添加之前检查列表，看看我们是否已经添加了该艺术家。
- en: This is where sets come in. Sets come from mathematics, where they represent
    an unordered group of unique items. We can try to add an item to a set five times,
    but the "is a member of a set" doesn't change after the first time we add it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是集合发挥作用的地方。集合来源于数学，它们代表了一组无序且唯一的物品。我们可以尝试将一个物品添加到集合中五次，但“是集合的成员”这一属性在我们第一次添加后并不会改变。
- en: 'In Python, sets can hold any hashable object, not just strings or numbers.
    Hashable objects implement the `__hash__()` method; these are the same objects
    that can be used as keys in dictionaries; so again, mutable lists, sets, and dictionaries
    are out. Like mathematical sets, they can store only one copy of each object.
    If we''re trying to create a list of song artists, we can create a set of string
    names and simply add them to the set. This example starts with a list of `(song,
    artist)` tuples and creates a set of the artists:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，集合可以包含任何可哈希的对象，而不仅仅是字符串或数字。可哈希的对象实现了`__hash__()`方法；这些对象与可以作为字典键使用的对象相同；因此，可变列表、集合和字典都不适用。像数学集合一样，它们只能存储每个对象的单个副本。如果我们试图创建一个歌曲艺术家的列表，我们可以创建一个字符串名称的集合，并将它们简单地添加到集合中。这个例子从一个`(song,
    artist)`元组的列表开始，并创建一个艺术家集合：
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'There is no built-in syntax for an empty set as there is for lists and dictionaries;
    we create a set using the `set()` constructor. However, we can use the curly braces
    (borrowed from dictionary syntax) to create a set, so long as the set contains
    values. If we use colons to separate pairs of values, it''s a dictionary, as in
    `{''key'': ''value'', ''key2'': ''value2''}`. If we just separate values with
    commas, it''s a set, as in `{''value'', ''value2''}`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '对于空集合，没有内置的语法与列表和字典相同；我们使用`set()`构造函数来创建一个集合。然而，只要集合包含值，我们就可以使用花括号（从字典语法中借用）来创建一个集合。如果我们使用冒号来分隔值对，它就是一个字典，例如`{''key'':
    ''value'', ''key2'': ''value2''}`。如果我们只是用逗号分隔值，它就是一个集合，例如`{''value'', ''value2''}`。'
- en: 'Items can be added individually to the set using the `add()` method, and updated
    in bulk using the `update()` method. If we run the script shown above, we see
    that the set works as advertised:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`add()`方法逐个将项目添加到集合中，并使用`update()`方法批量更新。如果我们运行上面显示的脚本，我们会看到集合按预期工作：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you're paying attention to the output, you'll notice that the items are not
    printed in the order they were added to the sets. Indeed each time you run this,
    you may see the items in a different order.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关注输出结果，你会注意到项目不是按照它们被添加到集合中的顺序打印的。实际上，每次运行这个程序，你可能会看到不同的顺序。
- en: 'Sets are inherently unordered due to a hash-based data structure used for efficient
    access to the members. Because of this lack of ordering, sets cannot have items
    looked up by index. The primary purpose of a set is to divide the world into two
    groups: *things that are in the set*, and *things that are not in the set*. It
    is easy to check whether an item is in a set or to loop over the items in a set,
    but if we want to sort or order them, we have to convert the set to a list. This
    output shows all three of these activities:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 集合由于使用了基于哈希的数据结构以实现成员的高效访问，因此本质上是无序的。正因为这种缺乏顺序性，集合不能通过索引来查找项目。集合的主要目的是将世界划分为两组：*集合中的事物*和*不在集合中的事物*。检查一个项目是否在集合中或者遍历集合中的项目都很简单，但如果我们要对它们进行排序或排序，我们必须将集合转换为列表。此输出显示了所有这三个活动：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This output is highly variable; any one of the possible orderings could be used,
    depending on the hash randomization in use.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出非常多变；根据所使用的哈希随机化，任何可能的排序都可以使用。
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The primary *feature* of a set is uniqueness. Sets are often used to deduplicate
    data. Sets are also used to create combinations, including unions and differences
    between collections. Most of the methods on the set type operate on other sets,
    allowing us to efficiently combine or compare the items in two or more sets.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的主要**特征**是唯一性。集合通常用于去重数据。集合还用于创建组合，包括集合之间的并集和差集。大多数集合类型上的方法都作用于其他集合，使我们能够高效地组合或比较两个或更多集合中的项目。
- en: The `union` method is the most common and easiest to understand. It takes a
    second set as a parameter and returns a new set that contains all elements that
    are in *either* of the two sets; if an element is in both original sets, it will
    only show up once in the new set. Union is like a logical `or` operation. Indeed,
    the `|` operator can be used on two sets to perform the union operation, if you
    don't like calling methods.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`方法是最常见且最容易理解的。它接受一个作为参数的第二个集合，并返回一个包含两个集合中所有元素的新的集合；如果一个元素在原始的两个集合中，它只会在新的集合中显示一次。并集操作就像逻辑`or`操作。实际上，如果你不喜欢调用方法，可以使用`|`运算符对两个集合执行并集操作。'
- en: Conversely, the `intersection` method accepts a second set and returns a new
    set that contains only those elements that are in *both* sets. It is like a logical `and` operation,
    and can also be referenced using the `&` operator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`交集`方法接受第二个集合，并返回一个新集合，该集合仅包含在**两个**集合中都存在的元素。这就像一个逻辑`与`操作，也可以使用`&`运算符来引用。
- en: 'Finally, the `symmetric_difference` method tells us what''s left; it is the
    set of objects that are in one set or the other, but not in both. It uses the
    `^` operator. The following example illustrates these methods by comparing some
    artists preferred by two different people:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`symmetric_difference` 方法告诉我们剩下的是什么；它是那些只在一个集合或另一个集合中，但不在两个集合中的对象的集合。它使用
    `^` 操作符。以下示例通过比较两位不同的人喜欢的艺术家来说明这些方法：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here are three examples of union, intersection, and symmetric difference:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是并集、交集和对称差集的三个示例：
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The union, intersection, and symmetric difference methods are commutative. We
    can say `dusty_artists.union(steve_artists)` or `steve_artists.union(dusty_artists)`
    and get the same general result. The order of values will vary because of hash
    randomization, but the same items will be present in both sets.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 联集、交集和对称差集方法都是交换律的。我们可以说 `dusty_artists.union(steve_artists)` 或者 `steve_artists.union(dusty_artists)`
    并得到相同的一般结果。由于哈希随机化，值的顺序可能会有所不同，但相同的项将存在于两个集合中。
- en: There are also methods that return different results depending on who is the
    caller and who is the argument. These methods include `issubset` and `issuperset`,
    which are the inverse of each other. Both return a `bool`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些方法根据调用者和参数的不同返回不同的结果。这些方法包括`issubset`和`issuperset`，它们是彼此的逆操作。两者都返回一个`bool`。
- en: The `issubset` method returns `True` if all of the items in the calling set
    are also in the set passed as an argument. We can use the `<=` operator for this,
    also.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`issubset` 方法返回 `True` 如果调用集合中的所有项目也都在作为参数传递的集合中。我们也可以使用 `<=` 操作符来做到这一点。'
- en: The `issuperset` method returns `True` if all of the items in the argument are
    also in the calling set. Thus, `s.issubset(t)`, `s <= t`, `t.issuperset(s)`, and
    `t >= s` are all identical.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`issuperset` 方法返回 `True` 如果调用集中所有项目也在参数中。因此，`s.issubset(t)`、`s <= t`、`t.issuperset(s)`
    和 `t >= s` 都是相同的。'
- en: They will both return `True` if `t` contains all the elements in `s`. (The `<`
    and `>` operators are for proper subsets and proper supersets; there are no named
    methods for these operations.)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`t`包含`s`中的所有元素，它们都将返回`True`。（`<`和`>`运算符用于真子集和真超集；这些操作没有命名的方法。）
- en: 'Finally, the `difference` method returns all the elements that are in the calling
    set, but not in the set passed as an argument. The `difference` method can also
    be represented by the `-` operator. The following code illustrates these methods
    in action:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`difference` 方法返回调用集中存在的所有元素，但不包括作为参数传递的集合中的元素。`difference` 方法也可以用 `-` 运算符表示。以下代码展示了这些方法在实际中的应用：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `difference` method, in the final expression, returns an empty set, since
    there are no items in `bands` that are not in `artists`. Looked at another way,
    we start with the value in `bands` and then remove all the items from `artists`.
    It may be helpful to think of as the expression `bands - artists`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 差分法在最终表达式中返回一个空集，因为`bands`中没有不在`artists`中的项目。从另一个角度来看，我们以`bands`中的值为起点，然后移除`artists`中的所有项目。可以将其视为表达式`bands
    - artists`。
- en: The `union`, `intersection`, and `difference` methods can all take multiple
    sets as arguments; they will return, as we might expect, the set that is created
    when the operation is called on all the parameters.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`并集`、`交集`和`差集`方法都可以接受多个集合作为参数；正如我们可能预期的，它们将返回在所有参数上调用操作时创建的集合。'
- en: So, the methods on sets clearly suggest that sets are meant to operate on other
    sets, and that they are not just containers. If we have data coming in from two
    different sources and need to quickly combine them in some way, so as to determine
    where the data overlaps or is different, we can use set operations to efficiently
    compare them. Or, if we have data incoming that may contain duplicates of data
    that has already been processed, we can use sets to compare the two and process
    only the new data.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，集合上的方法明显表明集合是用来在其他集合上操作的，并且它们不仅仅是容器。如果我们从两个不同的来源接收数据，并且需要以某种方式快速地将它们组合起来，以便确定数据重叠或不同之处，我们可以使用集合操作来高效地比较它们。或者，如果我们接收到的数据可能包含已经处理过的数据的重复项，我们可以使用集合来比较这两个数据集，并且只处理新数据。
- en: Finally, it is valuable to know that sets are much more efficient than lists
    when checking for membership using the `in` keyword. If you use the `value in
    container` syntax on a set or a list, it will return `True` if one of the elements
    in `container` is equal to `value`, and `False` otherwise. However, in a list,
    it will look at every object in the container until it finds the value, whereas
    in a set, it simply hashes the value and checks for membership. This means that
    a set will find the value in the same amount of time no matter how big the container
    is, but a list will take longer and longer to search for a value as the list contains
    more and more values.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，了解集合在用 `in` 关键字检查成员资格时比列表更高效是有价值的。如果你在集合或列表上使用 `value in container` 语法，如果
    `container` 中的任何一个元素等于 `value`，它将返回 `True`，否则返回 `False`。然而，在列表中，它会检查容器中的每一个对象，直到找到该值，而在集合中，它只是对值进行哈希并检查成员资格。这意味着无论容器有多大，集合都会在相同的时间内找到该值，但列表随着包含的值的增加，搜索值所需的时间会越来越长。
- en: Three types of queues
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三种类型的队列
- en: We'll look at an application of the list structure to create a queue. A queue
    is a special kind of buffer, summarized as **First In First Out** (**FIFO**).
    The idea is to act as a temporary stash so one part of an application can write
    to the queue while another part consumes items from the queue.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用列表结构来创建一个队列。队列是一种特殊的缓冲区，简称为**先进先出**（**FIFO**）。其理念是作为一个临时的存储空间，以便应用程序的一部分可以向队列写入数据，而另一部分则从队列中消费项目。
- en: A database might have a queue of data to be written to disk. When our application
    performs an update, the local cache version of the data is updated so all other
    applications can see the change. The write to the disk, however, may be placed
    in a queue for a writer to deal with a few milliseconds later.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库可能有一个数据队列等待写入磁盘。当我们的应用程序执行更新时，数据的本地缓存版本会被更新，这样所有其他应用程序都能看到这个变化。然而，写入磁盘的操作可能会被放入队列中，由写入器在几毫秒后处理。
- en: 'When we''re looking at files and directories, a queue can be a handy place
    to stash details of the directories so they can be processed later. We''ll often
    represent a directory as the path from the root of the filesystem to the file
    of interest. We''ll look at `Path` objects in detail in *Chapter 9*, *Strings,
    Serialization, and File Paths*. The algorithm works like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看文件和目录时，队列可以是一个方便的地方来存放目录的详细信息，以便稍后处理。我们通常将目录表示为从文件系统根目录到感兴趣文件的路径。我们将在*第9章*，*字符串、序列化和文件路径*中详细探讨`Path`对象。算法的工作原理如下：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can visualize this list-like structure as growing via an `append()` and
    shrinking via `pop(0)`. It would look like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个类似列表的结构想象为通过`append()`方法增长，通过`pop(0)`方法缩小。它看起来会是这样：
- en: '![Diagram  Description automatically generated](img/B17070_07_01.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_07_01.png)'
- en: 'Figure 7.1: Queue concept'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：队列概念
- en: 'The idea is for the queue to grow and shrink: each directory grows the queue
    and each file shrinks the queue. Eventually, all the files and directories have
    been processed and the queue is empty. The original order is preserved by the
    FIFO rule.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是让队列增长和缩小：每个目录增长队列，每个文件缩小队列。最终，所有文件和目录都已被处理，队列变为空。原始顺序通过先进先出（FIFO）规则得到保留。
- en: 'We have several ways to implement a queue in Python:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法在Python中实现队列：
- en: List using the `pop()` and `append()` methods of a list.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用列表的 `pop()` 和 `append()` 方法创建列表。
- en: The `collections.deque` structure, which supports `popleft()` and `append()`
    methods. A "deque" is a Double-Ended Queue. This is an elegant queue implementation
    that's faster than a simple list for the specific operations of appending and
    popping.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`collections.deque` 结构，支持 `popleft()` 和 `append()` 方法。一个 "deque" 是一个双端队列。这是一个比简单列表在追加和弹出特定操作上更快的优雅队列实现。'
- en: The `queue` module provides a queue often used for multithreading, but it can
    also be used for our single thread to examine a directory tree. This uses `get()`
    and `put()` methods. Since this structure is designed for concurrency, it locks
    the data structure to assure that each change is atomic and can't be interrupted
    by other threads. For a non-concurrent application, the locking overhead is a
    performance penalty we can avoid. This is the subject of *Chapter 14*, *Concurrency*.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`queue`模块提供了一个常用于多线程的队列，但它也可以用于我们的单线程来检查目录树。这使用了`get()`和`put()`方法。由于这个结构是为并发设计的，它会锁定数据结构以确保每个更改都是原子的，并且不会被其他线程中断。对于非并发应用程序，锁定开销是一个我们可以避免的性能惩罚。这是*第14章*，*并发*的主题。'
- en: The `heapq` module also provides a queue, but it does some extra processing
    that's irrelevant to this specific example. It keeps items in priority order,
    not the order they were put into the queue, breaking the FIFO expectation. We'll
    use this in *Chapter 8*, in the *Functions are objects, too* section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`heapq`模块也提供了一个队列，但它进行了一些与这个特定示例无关的额外处理。它按照优先级顺序保存项目，而不是它们被放入队列的顺序，打破了先进先出（FIFO）的预期。我们将在*第8章*的*函数也是对象*部分使用这个功能。'
- en: 'Each of these implementations is slightly different. This suggests we want
    to create handy wrapper classes around them to provide a uniform interface. We
    can create class definitions like the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 每种实现都有细微的差别。这表明我们希望围绕它们创建便捷的包装类，以提供统一的接口。我们可以创建如下所示的类定义：
- en: '[PRE65]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This shows the three essential operations for a queue. We can put something
    into the queue, appending it to the end. We can get something from the queue,
    removing the item at the head of the queue. Finally, we can ask if the queue is
    empty. We''ve layered this on a list class by extending it to add three new methods:
    `put()`, `get()`, and `empty()`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了队列的三个基本操作。我们可以将某物放入队列，将其附加到末尾。我们也可以从队列中取出某物，移除队列头部的项目。最后，我们可以询问队列是否为空。我们通过扩展列表类并添加三个新方法：`put()`、`get()`和`empty()`来实现这一功能。
- en: Next is a slightly different implementation. The `typing.Deque` type hint is
    the wrapper around the `collections.deque` class. A recent change to Python changed
    the underlying `collections.deque` class, removing the need for a special hint.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是稍微不同的实现方式。`typing.Deque` 类型提示是 `collections.deque` 类的包装器。Python 的一次最近更改改变了底层的
    `collections.deque` 类，从而消除了对特殊提示的需求。
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It's hard to see the distinction between this implementation and the generic
    list implementation. It turns out the `popleft()` method is a higher-speed version
    of `pop(0)` in a conventional list. Otherwise, this looks very similar to the
    list-based implementation.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 很难看出这种实现和通用列表实现之间的区别。结果是`popleft()`方法是一种比传统列表中的`pop(0)`更高的速度版本。否则，这看起来与基于列表的实现非常相似。
- en: Here's a final version that uses the `queue` module. This `queue` module's implementation
    uses locks to prevent the data structure from being damaged by concurrent access
    across multiple threads. It's generally opaque to us, except as a tiny performance
    cost.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`queue`模块的最终版本。这个`queue`模块的实现使用锁来防止多个线程并发访问时损坏数据结构。对于我们来说，它通常是透明的，除了带来微小的性能成本。
- en: '[PRE67]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This implementation works because we decided to use the `Queue` class interface
    as the template for the other two classes. This meant we didn't have to do any
    real work to implement this class; this design was the overall target for the
    other class designs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方式之所以有效，是因为我们决定将`Queue`类接口作为其他两个类的模板。这意味着我们实际上不需要做任何真正的开发工作来实现这个类；这种设计是其他类设计的目标。
- en: The type hints, however, are rather complex-looking. The `queue.Queue` class
    definition is also a generic type hint. When the code is being examined by **mypy**,
    the `TYPE_CHECKING` variable is `True`, and we need to provide a parameter to
    the generic type. When the `TYPE_CHECKING` variable is `False`, we're not using
    **mypy**, and the class name (without any additional parameters) is all that's
    needed to define a queue at runtime.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型提示看起来相当复杂。`queue.Queue` 类的定义也是一个泛型类型提示。当代码正在被 **mypy** 检查时，`TYPE_CHECKING`
    变量是 `True`，我们需要为泛型类型提供一个参数。当 `TYPE_CHECKING` 变量是 `False` 时，我们未使用 **mypy**，此时只需要类名（不带任何额外参数）就可以在运行时定义一个队列。
- en: 'These three classes are similar with respect to the three defined methods.
    We could define an abstract base class for them. Or we could provide the following
    type hint:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类在三个定义的方法方面是相似的。我们可以为它们定义一个抽象基类。或者，我们可以提供以下类型提示：
- en: '[PRE68]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This `PathQueue` type hint summarizes all three types, allowing us to define
    an object of any of these three classes to use for the final implementation choice.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `PathQueue` 类型提示总结了所有三种类型，使我们能够定义一个对象，用于最终实现选择，可以是这三个类中的任何一个。
- en: The question of "which is better" is answered by the standard response of "it
    depends on what you need to do."
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: “哪个更好”的问题，标准回答是“这取决于你需要做什么。”
- en: For single-threaded applications, the `collections.deque` is ideal; it's designed
    for this purpose.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于单线程应用程序，`collections.deque` 是理想的；它为此目的而设计。
- en: For multi-threaded applications, the `queue.Queue` is required to provide a
    data structure that can be read and written by multiple concurrent threads. We'll
    return to this in *Chapter 14*, *Concurrency*.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于多线程应用程序，需要使用`queue.Queue`来提供一个可以被多个并发线程读写的数据结构。我们将在*第14章，并发*中回到这个话题。
- en: While we can often leverage a built-in structure, like the generic `list` class,
    for a wide variety of purposes, it may not be ideal. The other two implementations
    offer advantages over the built-in list. Python's standard library, and the broader
    ecosystem of external packages available through the Python Package Index (PYPI),
    can provide improvements over generic structures. What's important is having a
    specific improvement before searching high and low for a "perfect" package. In
    our example, the performance difference between the `deque` and the `list` is
    small. The time is dominated by the OS work required to gather the raw data. For
    a large file system, perhaps spanning multiple hosts, the difference will add
    up.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常可以利用内置结构，如通用的 `list` 类，来满足各种用途，但这可能并不理想。其他两种实现方式在内置列表之上提供了优势。Python 的标准库以及通过
    Python 包索引（PYPI）提供的更广泛的外部包生态系统，可以在通用结构之上提供改进。重要的是在四处寻找“完美”的包之前，先有一个具体的改进方案。在我们的例子中，`deque`
    和 `list` 之间的性能差异很小。时间主要被用于收集原始数据的操作系统工作所占据。对于大型文件系统，可能跨越多个主机，这种差异将会累积。
- en: Python's object-orientation gives us the latitude to explore design alternatives.
    We should feel free to try more than one solution to a problem as a way to better
    understand the problem, and arrive at an acceptable solution.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的面向对象特性为我们提供了探索设计替代方案的自由度。我们应该感到自由地尝试多种解决方案来更好地理解问题，并找到可接受的解决方案。
- en: Case study
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: In this chapter's case study, we'll revisit our design, leveraging Python's
    `@dataclass` definitions. This holds some potential for streamlining our design.
    We'll be looking at some choices and limitations; this will lead us to explore
    some difficult engineering trade-offs, where there isn't one obvious best approach.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的案例研究中，我们将回顾我们的设计，利用 Python 的 `@dataclass` 定义。这为简化我们的设计提供了一些潜力。我们将探讨一些选择和限制；这将引导我们探索一些困难的工程权衡，在这些权衡中，没有一种明显最佳的方法。
- en: We'll also look at immutable `NamedTuple` class definitions. These objects have
    no internal state changes, leading to the possibility of some design simplifications.
    This will also change our design to make less use of inheritance and more use
    of composition.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨不可变的`NamedTuple`类定义。这些对象没有内部状态变化，这可能导致某些设计简化。这也会改变我们的设计，使其减少对继承的使用，更多地使用组合。
- en: Logical model
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑模型
- en: 'Let''s review the design we have so far for our `model.py` module. This shows
    the hierarchy of `Sample` class definitions, used to reflect the various ways
    samples are used:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止我们为`model.py`模块所做的设计。这显示了`Sample`类定义的层次结构，用于反映样本被使用的各种方式：
- en: '![Diagram  Description automatically generated](img/B17070_07_02.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_07_02.png)'
- en: 'Figure 7.2: Class diagram so far'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：到目前为止的类图
- en: 'The various `Sample` classes are a very good fit with the dataclass definition.
    These objects have a number of attributes, and the methods built automatically
    seem to fit the behaviors we want. Here''s the revised `Sample` class, implemented
    as a `@dataclass` instead of being built entirely by hand:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 各种`Sample`类与数据类定义非常契合。这些对象具有许多属性，自动构建的方法似乎符合我们想要的行为。以下是经过修订的`Sample`类，它被实现为`@dataclass`而不是完全手动构建：
- en: '[PRE69]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We''ve used the `@dataclass` decorator to create a class from the supplied
    attribute type hints. We can use the resulting `Sample` class like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`@dataclass`装饰器从提供的属性类型提示中创建一个类。我们可以像这样使用生成的`Sample`类：
- en: '[PRE70]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This example shows how we create instances of a class defined with the `@dataclass`
    decorator. Note that a representation function, `__repr__()`, was automatically
    created for us; it displays a useful level of detail, as shown in the example
    above. This is very pleasant. It almost feels like cheating!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了我们如何使用`@dataclass`装饰器定义类的实例。注意，一个表示函数`__repr__()`已经自动为我们创建；它显示了有用的详细程度，如上例所示。这非常令人愉快。几乎感觉像是在作弊！
- en: Here are the definitions for some more of the `Sample` class hierarchy.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Sample`类层次结构中一些更多定义的说明。
- en: '[PRE71]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This seems to cover the user stories described in *Chapter 1*, *Object-Oriented
    Design*, and expanded in *Chapter 4*, *Expecting the Unexpected*. We can provide
    training data, test the classifier, and handle the classification of unknown samples.
    We didn't have to write very much code and we get a lot of useful features.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎涵盖了第1章中描述的用户故事，即*面向对象设计*，并在第4章*预料之外*中进行了扩展。我们可以提供训练数据，测试分类器，并处理未知样本的分类。我们不需要编写很多代码，就能获得许多有用的特征。
- en: We do have a potential problem, however. While we are permitted to set a classification
    attribute on a `TrainingKnownSample` instance, this doesn't seem to be a great
    idea. Here's an example, where we create a sample to be used for training, and
    then also set a classification attribute.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实存在一个潜在问题。虽然我们被允许在`TrainingKnownSample`实例上设置一个分类属性，但这似乎不是一个好主意。以下是一个例子，我们创建一个用于训练的样本，然后也设置了分类属性。
- en: '[PRE72]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Generally, Python doesn't stop us from creating a new attribute, like `classification`,
    in an object. This behavior could be the source of hidden bugs. (A good unit test
    will often expose these bugs.) Note the additional attribute is not reflected
    in the `__repr__()` method processing or `__eq__()` method comparisons for this
    class. It's not a serious problem. In later sections, we'll address it using frozen
    dataclasses as well as the `typing.NamedTuple` class.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Python 并不会阻止我们在对象中创建新的属性，例如 `classification`。这种行为可能是隐藏性错误的来源。（一个好的单元测试通常会暴露这些错误。）请注意，这个类中新增的属性不会反映在
    `__repr__()` 方法处理或 `__eq__()` 方法比较中。这不是一个严重的问题。在后面的章节中，我们将使用冻结的数据类以及 `typing.NamedTuple`
    类来解决这个问题。
- en: The remaining classes in our model don't enjoy the same huge benefit from being
    implemented as dataclasses as the `Sample` classes did. When a class has a lot
    of attributes, and few methods, then the `@dataclass` definition is a big help.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型中剩余的类不像`Sample`类那样，从实现为数据类（dataclasses）中获得巨大的好处。当一个类有很多属性而方法很少时，使用`@dataclass`定义就是一个很大的帮助。
- en: 'Another class to benefit the most from the `@dataclass` treatment is the `Hyperparameter` class.
    Here''s the first part of the definition, with the method body omitted:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 从`@dataclass`处理中受益最多的另一个类是`Hyperparameter`类。以下是定义的第一部分，省略了方法体：
- en: '[PRE73]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This reveals an interesting feature that is made available when we use `from
    __future__ import annotations`. Specifically, the value of `weakref.ReferenceType["TrainingData"]`has
    two distinct goals:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了当我们使用 `from __future__ import annotations` 时出现的一个有趣特性。具体来说，`weakref.ReferenceType["TrainingData"]`
    的值有两个不同的目标：
- en: The **mypy** tool uses this to check type references. We must provide a qualifier, `weakref.ReferenceType["TrainingData"]`.
    This uses a string as a forward reference to the yet-undefined `TrainingData` class.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mypy** 工具使用此方法来检查类型引用。我们必须提供一个限定符，`weakref.ReferenceType["TrainingData"]`。这使用一个字符串作为对尚未定义的
    `TrainingData` 类的前向引用。'
- en: When evaluated at runtime by the `@dataclass` decorator to build a class definition,
    the additional type qualifier isn't used.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过`@dataclass`装饰器在运行时构建类定义时，不会使用额外的类型限定符。
- en: We've omitted the details of the `classify()` method. We'll examine some alternative
    implementations in *Chapter 10*, *The Iterator Pattern*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了`classify()`方法的细节。我们将在第10章，*迭代器模式*中考察一些替代实现。
- en: We haven't seen all the features of dataclasses. In the next section, we'll
    freeze them to help spot the kind of bug where a piece of training data is used
    for testing purposes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到数据类的所有功能。在下一节中，我们将冻结它们以帮助发现那种使用训练数据用于测试目的的bug类型。
- en: Frozen dataclasses
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冻结的数据类
- en: The general case for dataclasses is to create mutable objects. The state of
    an object can be changed by assigning new values to the attributes. This isn't
    always a desirable feature, and we can make a dataclass immutable.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类的通用情况是创建可变对象。可以通过为新属性赋值来改变对象的状态。这并不总是我们希望拥有的特性，我们可以使数据类不可变。
- en: 'We can describe the UML diagram of the design by adding a stereotype of `«Frozen»`.
    This notation can help to remind us of the implementation choice of making the
    object immutable. We must also respect an important rule of frozen dataclasses:
    an extension via inheritance must also be frozen.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`«Frozen»`的类符来描述设计的 UML 图。这种表示法可以帮助我们记住将对象设置为不可变性的实现选择。我们还得遵守冻结数据类的一个重要规则：通过继承的扩展也必须被冻结。
- en: 'The definition of the frozen `Sample` objects must be kept separate from the
    mutable objects that are part of processing an unknown or testing sample. This
    splits our design into two families of classes:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结的`Sample`对象的定义必须与处理未知样本或测试样本的不可变对象分开。这把我们的设计分为两个类家族：
- en: A small hierarchy of immutable classes, specifically `Sample` and `KnownSample`
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不可变类的小层次，具体为`Sample`和`KnownSample`
- en: Some associated classes that leverage these frozen classes
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些利用这些冻结类别的相关类别
- en: 'The related classes for testing samples, training samples, and unknown samples
    form a loose collection of classes with nearly identical methods and attributes.
    We can call this a "paddling" of related classes. This comes from the duck typing
    rule: "When I see a bird that walks like a duck and quacks like a duck, I call
    that bird a duck." Objects created from classes with the same attributes and methods
    are interchangeable, even though they lack a common abstract superclass.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 测试样本、训练样本和未知样本的相关类形成了一个具有几乎相同方法和属性的松散类集合。我们可以称这为“相关类的泛化”。这源于鸭子类型规则：“当我看到一只既像鸭子走路又像鸭子嘎嘎叫的鸟时，我就称那只鸟为鸭子。”从具有相同属性和方法的类中创建的对象可以互换，即使它们缺少一个共同的抽象超类。
- en: 'We can describe this revised design with a diagram like this:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这样的图表来描述这个修改后的设计：
- en: '![Diagram  Description automatically generated](img/B17070_07_03.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_07_03.png)'
- en: 'Figure 7.3: Revised class diagram with frozen classes'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：带有冻结类的修订版类图
- en: 'Here''s the change to the `Sample` class hierarchy. It''s relatively minor
    and easy to overlook the `frozen=True` in a few places:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Sample`类层次结构的变更。这个变更相对较小，很容易在几个地方忽略`frozen=True`：
- en: '[PRE74]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'When we create an instance of a `TrainingKnownSample` or `TestingKnownSample`,
    we have to respect the composition of these objects: there''s a frozen `KnownSample` object
    inside each of these classes. The following example shows one way to create a
    composite object.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个`TrainingKnownSample`或`TestingKnownSample`的实例时，我们必须尊重这些对象的组成：每个类中都有一个冻结的`KnownSample`对象。以下示例展示了创建复合对象的一种方法。
- en: '[PRE75]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This nested construction of a `TrainingKnownSample` instance containing a `KnownSample` object
    is explicit. It exposes the immutable `KnownSample` object.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套构造一个包含`KnownSample`对象的`TrainingKnownSample`实例是明确的。它暴露了不可变的`KnownSample`对象。
- en: 'The frozen design has a very pleasant consequence for detecting subtle bugs.
    The following example shows the exception raised by improper use of a `TrainingKnownSample`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结设计在检测细微错误方面有一个非常令人愉悦的结果。以下示例展示了由于不当使用`TrainingKnownSample`而引发的异常：
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We can't accidentally introduce a bug that changes a training instance.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能意外地引入一个会改变训练实例的bug。
- en: We get one more bonus feature that makes it easier to spot duplicates when allocating
    instances to the training set. The frozen versions of the `Sample` (and `KnownSample`)
    classes produce a consistent `hash()` value. This makes it easier to locate duplicate
    values by examining the subset of items with a common hash value.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得了一个额外的功能，这使得在分配实例到训练集时更容易发现重复项。`Sample`（以及`KnownSample`）类的冻结版本产生一致的`hash()`值。这使得通过检查具有共同哈希值的物品子集来定位重复值变得更加容易。
- en: Appropriate use of `@dataclass` and `@dataclass(frozen=True)` can be a big help
    in implementing object-oriented Python. These definitions provide a rich set of
    features with minimal code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 适当使用 `@dataclass` 和 `@dataclass(frozen=True)` 可以在实现面向对象的 Python 中提供很大帮助。这些定义提供了丰富的功能，同时代码量最小化。
- en: One other technique available to us is similar to the frozen dataclass, the
    `typing.NamedTuple`. We'll look at this next.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一种可用的技术，类似于冻结的数据类，即`typing.NamedTuple`。我们将在下一节中探讨这个话题。
- en: NamedTuple classes
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名元组类
- en: Using `typing.NamedTuple` is somewhat similar to using `@dataclass(frozen=True)`.
    There are some significant differences in the implementation details, however.
    In particular, the `typing.NamedTuple` class does not support inheritance in the
    most obvious way. This leads us to a design based around composition of objects
    in the `Sample` class hierarchy. With inheritance, we're often extending a base
    class to add features. With composition, we're often building multi-part objects
    of several different classes.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `typing.NamedTuple` 与使用 `@dataclass(frozen=True)` 有一定的相似性。然而，在实现细节上存在一些显著差异。特别是，`typing.NamedTuple`
    类不支持最直观的继承方式。这导致我们在 `Sample` 类层次结构中采用基于对象组合的设计。使用继承时，我们通常扩展基类以添加功能。而使用组合时，我们通常构建由几个不同类组成的多个部分的对象。
- en: 'Here''s the definition of `Sample` as `NamedTuple`. It looks similar to the
    `@dataclass` definition. The definition of `KnownSample`, however, must change
    dramatically:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Sample`作为`NamedTuple`的定义。它看起来与`@dataclass`的定义相似。然而，`KnownSample`的定义必须发生显著变化：
- en: '[PRE77]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `KnownSample` class is a composite, built from a `Sample` instance, plus
    the species assigned when the data was loaded initially. Since these are both
    subclasses of `typing.NamedTuple`, the values are immutable.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`KnownSample` 类是一个复合类，由一个 `Sample` 实例以及数据最初加载时分配的物种组成。由于这两个都是 `typing.NamedTuple`
    的子类，因此其值是不可变的。'
- en: 'We''ve shifted from inheritance to composition in our design. Here are the
    two concepts, side by side:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设计上已经从继承转向了组合。以下是这两个概念，并列展示：
- en: '![Diagram  Description automatically generated](img/B17070_07_04.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_07_04.png)'
- en: 'Figure 7.4: Inheritance-based versus composition-based class designs'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：基于继承与基于组合的类设计
- en: 'The differences can be easy to overlook in the diagram:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，这些差异可能容易被忽视：
- en: 'Using an **inheritance-focused** design, a `KnownSample` instance is a `Sample`
    instance. It has five attributes: all four attributes inherited from the `Sample`
    class plus one attribute unique to the `KnownSample` subclass.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用以**继承**为中心的设计，`KnownSample`实例是一个`Sample`实例。它具有五个属性：从`Sample`类继承的所有四个属性，加上一个仅属于`KnownSample`子类的独特属性。
- en: Using a **composition-focused** design, a `KnownSample_C` instance is composed
    of a `Sample` instance and a species classification. It has two attributes.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以**组合**为重点的设计，一个`KnownSample_C`实例由一个`Sample`实例和物种分类组成。它有两个属性。
- en: As we've seen, both designs will work. The choice is difficult and often revolves
    around the number and the complexity of the methods that are inherited from the
    superclass. In this example, there are no methods of importance to the application
    defined in the `Sample` class.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这两种设计都能工作。选择是困难的，通常围绕着从超类继承的方法的数量和复杂性来决定。在这个例子中，`Sample`类中没有定义对应用程序重要的方法。
- en: The inheritance versus composition design decision represents a difficult choice
    with no single, right answer. The decision is often helped by a nuanced understanding
    of whether a subclass truly is a member of the superclass or not. Metaphorically,
    we often ask if an Apple is a Fruit to help understand narrower subclasses and
    generic superclasses. The problem we have is that an Apple can also be a Dessert,
    confounding what seemed to be a simple decision with additional details.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 继承与组合的设计决策代表了一个没有单一、正确答案的艰难选择。这个决策通常需要通过细微地理解一个子类是否真正是超类的一个成员来帮助。比喻地说，我们经常问一个苹果是否是水果来帮助理解更窄的子类和通用的超类。我们面临的问题是，苹果也可以是甜点，这使原本看似简单的决策因为额外的细节而变得复杂。
- en: Don't forget, an Apple (as applesauce) may be part of the Main Course, also.
    This kind of complication can make an "is-a" question harder to answer. In our
    case, the "is-a" relationship between samples, known samples, unknown samples,
    testing, and training samples may not be the best path forward. We seem to have
    multiple roles (i.e., testing, training, to-be-classified) that are associated
    with each sample, and there may only be two subclasses of `Sample`, known and
    unknown.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，苹果（作为苹果酱）也可能是主菜的一部分。这种复杂性可能会使得“是”的问题更难回答。在我们的情况下，样本、已知样本、未知样本、测试样本和训练样本之间的“是”的关系可能不是最佳的前进路径。我们似乎有多个角色（即，测试、训练、待分类）与每个样本相关联，并且可能只有两个`Sample`的子类，即已知和未知。
- en: The `TestingKnownSample` and `TrainingKnownSample` class definitions follow
    the duck typing rule. They have similar attributes and can be used interchangeably
    in many cases.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestingKnownSample` 和 `TrainingKnownSample` 类定义遵循鸭子类型规则。它们具有相似的属性，在许多情况下可以互换使用。'
- en: '[PRE78]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In this case, both `TestingKnownSample` and `TrainingKnownSample` are composite
    objects that contain a `KnownSample` object. The primary difference is the presence
    (or absence) of an additional attribute, the `classification` value.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`TestingKnownSample` 和 `TrainingKnownSample` 都是包含一个 `KnownSample` 对象的复合对象。主要区别在于是否存在（或不存在）一个额外的属性，即
    `classification` 值。
- en: 'Here''s an example of creating a `TrainingKnownSample` and trying (erroneously)
    to set the classification:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个创建`TrainingKnownSample`并尝试（错误地）设置分类的示例：
- en: '[PRE79]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The code reflects the composite-of-composite design. A `TrainingKnownSample`
    instance contains a `KnownSample` object, which contains a `Sample` object. The
    example shows that we cannot add a new attribute to a `TrainingKnownSample` instance.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 代码反映了复合的复合设计。一个`TrainingKnownSample`实例包含一个`KnownSample`对象，该对象又包含一个`Sample`对象。示例显示我们无法向`TrainingKnownSample`实例添加新的属性。
- en: Conclusion
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Up to now, we've seen a total of four ways to address object-oriented design
    and implementation.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了总共四种处理面向对象设计和实现的方法。
- en: In previous chapters, we've looked at creating objects "from scratch," writing
    all the method definitions ourselves. We've emphasized inheritance among the classes
    in the `Sample` class hierarchy.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了从头开始创建对象，自己编写所有方法定义。我们强调了`Sample`类层次结构中类的继承。
- en: In this chapter, we've seen a stateful class definition using `@dataclass`.
    This supports inheritance among the classes in the `Sample` class hierarchy.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了使用`@dataclass`定义的状态类。这支持`Sample`类层次结构中类之间的继承。
- en: We've also seen a stateless (or immutable) definition using `@dataclass(frozen=True)`.
    This tends to discourage some aspects of inheritance and favor composition.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还看到了使用 `@dataclass(frozen=True)` 的无状态（或不可变）定义。这往往抑制了一些继承方面的特性，并倾向于支持组合。
- en: Finally, we've looked at stateless (or immutable) definitions using `NamedTuple`.
    This must be designed using composition. This preliminary overview of these classes
    makes the design seem quite simple. We'll return to this in *Chapter 8*, *The
    Intersection of Object-Oriented and Functional Programming*.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们探讨了使用`NamedTuple`进行无状态（或不可变）定义。这必须通过组合设计。对这些类的前期概述使得设计看起来相当简单。我们将在*第8章*，*面向对象与函数式编程的交汇处*中回到这一点。
- en: We have a lot of flexibility in Python. It's important to look at the choices
    from the viewpoint of our future self trying to add or alter features. It helps
    to follow the SOLID design principles and focus on Single Responsibility and Interface
    Segregation to isolate and encapsulate our class definitions.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们拥有很大的灵活性。从我们未来想要添加或修改特性的自我视角来看，考虑选择是很重要的。遵循SOLID设计原则并专注于单一职责和接口分离，有助于隔离和封装我们的类定义。
- en: Recall
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆
- en: We've explored a variety of built-in Python data structures in this chapter.
    Python lets us do a great deal of object-oriented programming without the overheads
    of numerous, potentially confusing, class definitions. We can rely on a number
    of built-in classes where they fit our problem.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中探讨了多种内置的 Python 数据结构。Python 允许我们在不承受大量可能令人困惑的类定义开销的情况下进行大量的面向对象编程。当它们适合我们的问题时，我们可以依赖许多内置的类。
- en: 'In this chapter, we looked at the following:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了以下内容：
- en: Tuples and named tuples let us leverage a simple collection of attributes. We
    can extend the `NamedTuple` definition to add methods when those are necessary.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组和命名元组允许我们利用一组简单的属性。当需要时，我们可以扩展`NamedTuple`的定义来添加方法。
- en: Dataclasses provide sophisticated collections of attributes. A variety of methods
    can be provided for us, simplifying the code we need to write.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dataclasses 提供了复杂的属性集合。可以为我们提供各种方法，简化我们需要编写的代码。
- en: Dictionaries are an essential feature, used widely in Python. There are many
    places where keys are associated with values. The syntax for using the built-in
    dictionary class makes it easy to use.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典是一个基本特性，在Python中被广泛使用。有许多地方键与值相关联。使用内置字典类的语法使其易于使用。
- en: Lists and sets are also first-class parts of Python; our applications can make
    use of these.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和集合也是 Python 的一等组成部分；我们的应用程序可以利用这些功能。
- en: We also looked at three types of queues. These are more specialized structures
    with more focused patterns of access than a generic list object. The idea of specialization
    and narrowing the domain of features can lead to performance improvements, also,
    making the concept widely applicable.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还研究了三种类型的队列。这些结构比通用列表对象具有更专业化的结构和更集中的访问模式。专业化和缩小特征域的概念可以导致性能提升，同时，也使得这一概念具有更广泛的应用性。
- en: Additionally, in the case study, we looked at ways to use these built-in classes
    to define our data samples used for testing and training.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在案例研究中，我们探讨了如何使用这些内置类来定义用于测试和训练的数据样本。
- en: Exercises
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The best way to learn how to choose the correct data structure is to do it wrong
    a few times (intentionally or accidentally!). Take some code you've recently written,
    or write some new code that uses a list. Try rewriting it using some different
    data structures. Which ones make more sense? Which ones don't? Which have the
    most elegant code?
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何选择正确的数据结构最好的方法是通过几次做错（有意或无意地！）来实践。拿一些你最近写的代码，或者编写一些使用列表的新代码。尝试用一些不同的数据结构重写它。哪些更合理？哪些不合理？哪些拥有最优雅的代码？
- en: Try this with a few different pairs of data structures. You can look at examples
    you've done for previous chapter exercises. Are there objects with methods where
    you could have used dataclasses, `namedtuple`, or `dict` instead? Attempt both
    and see. Are there dictionaries that could have been sets because you don't really
    access the values? Do you have lists that check for duplicates? Would a set suffice?
    Or maybe several sets? Would one of the queue implementations be more efficient?
    Is it useful to restrict the API to the top of a stack rather than allowing random
    access to the list?
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用几对不同类型的数据结构进行这个练习。你可以查看之前章节练习中做过的例子。有没有对象使用了方法，而你本可以使用数据类（dataclasses）、`namedtuple`
    或 `dict` 的？尝试两种方法并看看结果。有没有字典本可以成为集合，因为你实际上并没有访问其值？你有没有检查重复项的列表？一个集合是否足够？或者可能需要几个集合？队列实现中哪一个可能更高效？限制API只允许对栈顶的访问而不是允许对列表的随机访问是否有用？
- en: Have you written any container objects recently that you could improve by inheriting
    a built-in and overriding some of the *special* double-underscore methods? You
    may have to do some research (using `dir` and `help`, or the Python library reference)
    to find out which methods need overriding.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你最近有没有编写过任何可以通过继承内置类并重写一些特殊的双下划线方法来改进的容器对象？你可能需要进行一些研究（使用`dir`和`help`，或者查阅Python库参考）来找出哪些方法需要重写。
- en: Are you sure inheritance is the correct tool to apply; could a composition-based
    solution be more effective? Try both (if it's possible) before you decide. Try
    to find different situations where each method is better than the other.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你确定继承是正确的工具吗；基于组合的解决方案可能更有效吗？在做出决定之前，尝试两种方法（如果可能的话）。尝试找到不同的情况下，每种方法都比另一种方法更好的情况。
- en: If you were familiar with the various Python data structures and their uses
    before you started this chapter, you may have been bored. But if that is the case,
    there's a good chance you use data structures too much! Look at some of your old
    code and rewrite it to use more self-made classes. Carefully consider the alternatives
    and try them all out; which one makes for the most readable and maintainable system?
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这章开始之前就已经熟悉了各种Python数据结构和它们的用途，你可能感到无聊。但如果是这种情况，你很可能过度使用了数据结构！看看你的一些旧代码，并重写它们以使用更多自定义类。仔细考虑替代方案，并尝试所有这些方案；哪一个能让你构建出最易于阅读和维护的系统？
- en: The `MultiItem` example in this section started with a clunky-looking `__lt__()`
    method. The second version had a slightly nicer `__eq__()` method. Rewrite `__lt__()`
    to follow the design pattern of `__eq__()`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的`MultiItem`示例最初使用了一个看起来笨拙的`__lt__()`方法。第二个版本有一个稍微更好的`__eq__()`方法。将`__lt__()`重写为遵循`__eq__()`的设计模式。
- en: 'The bigger problem with the original class design was trying to handle the
    variety of subtypes and their optional fields. The presence of an optional attribute
    is a suggestion that – perhaps – there are distinct classes struggling to separate
    from each other. What happens if we distinguish between two closely related but
    distinct classes: `LocalItem` (which uses `timestamp`) and `RemoteItem` (which
    uses `created_date`). We can define a common type hint as a `Union[LocalItem,
    RemoteItem]`. If each class has a property like `creation_datetime` that computes
    a `datetime.datetime` object, would processing be simpler? Build the two classes;
    create some test data. How does it look to separate the two subtypes?'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类设计的更大问题是试图处理各种子类型及其可选字段。存在一个可选属性是一种暗示——也许——有不同类正在努力相互区分。如果我们区分两个密切相关但不同的类：`LocalItem`（使用`timestamp`）和`RemoteItem`（使用`created_date`），会发生什么？我们可以定义一个公共类型提示为`Union[LocalItem,
    RemoteItem]`。如果每个类都有一个像`creation_datetime`这样的属性，它会计算一个`datetime.datetime`对象，处理会变得更简单吗？构建这两个类；创建一些测试数据。如何分离这两个子类型看起来会是什么样子？
- en: Always critically evaluate your code and design decisions. Make a habit of reviewing
    old code and take note of whether your understanding of *good design* has changed
    since you wrote it. Software design has a large aesthetic component, and like
    artists with oil on canvas, we all have to find the style that suits us best.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 总是批判性地评估你的代码和设计决策。养成回顾旧代码的习惯，并注意自你编写以来你对*良好设计*的理解是否有所改变。软件设计具有很大的美学成分，就像在画布上用油画的艺术家一样，我们都需要找到最适合自己的风格。
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered several built-in data structures and attempted to understand how
    to choose one for specific applications. Sometimes, the best thing we can do is
    create a new class of objects, but often, one of the built-ins provides exactly
    what we need. When it doesn't, we can always use inheritance or composition to
    adapt them to our use cases. We can even override special methods to completely
    change the behavior of built-in syntaxes.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了几个内置的数据结构，并尝试理解如何为特定的应用选择一个。有时，我们能做的最好的事情就是创建一个新的对象类，但通常，内置的其中一个就能提供我们所需的一切。当它不能满足需求时，我们总是可以使用继承或组合来适应我们的使用场景。我们甚至可以覆盖特殊方法来完全改变内置语法的行为。
- en: In the next chapter, we'll discuss how to integrate the object-oriented and
    not-so-object-oriented aspects of Python. Along the way, we'll discover that it's
    more object-oriented than it looks at first sight!
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何整合Python中面向对象和非面向对象方面的内容。在这个过程中，我们会发现它比第一眼看上去更加面向对象！
