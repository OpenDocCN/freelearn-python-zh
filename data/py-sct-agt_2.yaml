- en: Chapter 2. Acquiring Intelligence Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：获取情报数据
- en: We're going to acquire intelligence data from a variety of sources. We might
    interview people. We might steal files from a secret underground base. We might
    search the **World Wide Web** (**WWW**), and this is what we'll focus on in this
    chapter. Using our own cameras or recording devices is the subject of the next
    chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从各种来源获取情报数据。我们可能会采访人们。我们可能会从秘密地下基地窃取文件。我们可能会搜索**万维网**（**WWW**），这是我们本章将关注的重点。使用我们自己的相机或录音设备是下一章的主题。
- en: Important espionage targets include natural resources, popular opinion, and
    strategic economic strengths. This kind of background information is useful in
    a number of ways. A great deal of the world's data is already on the Web, and
    the rest will get there eventually. Any modern search for intelligence starts
    with the Web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 重要间谍目标包括自然资源、公众舆论和战略经济优势。这类背景信息在许多方面都很有用。世界上大量的数据已经存在于互联网上，其余的最终也会到达那里。任何现代的情报搜索都始于互联网。
- en: We can use Python libraries such as `http.client` and `urllib` to get data from
    remote servers and transfer files to other servers. Once we've found remote files
    of interest, we're going to need a number of Python libraries to parse and extract
    data from these libraries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python库，如`http.client`和`urllib`，从远程服务器获取数据并将文件传输到其他服务器。一旦我们找到了感兴趣的远程文件，我们将需要多个Python库来解析和提取这些库中的数据。
- en: In [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our Espionage
    Toolkit*, we looked at how we can peek inside a ZIP archive. We'll look inside
    other kinds of files in this chapter. We'll focus on JSON files, because they're
    widely used for web services APIs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html "第一章：我们的间谍工具包")《我们的间谍工具包》中，我们探讨了如何查看ZIP存档的内容。在本章中，我们将查看其他类型的文件。我们将重点关注JSON文件，因为它们在Web服务API中得到广泛应用。
- en: 'Along the way, we''ll cover a number of topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在旅途中，我们将涵盖多个主题：
- en: How to access online data from Python.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从Python访问在线数据。
- en: The HTTP protocol and how to access websites from our applications.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP协议以及如何从我们的应用程序访问网站。
- en: The FTP protocol and how to upload and download large volumes of bulk data.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP协议以及如何上传和下载大量批量数据。
- en: Many of the core Python data structures will include lists, tuples, dictionaries,
    and sets, and how we use these structures to organize and manage information.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多核心Python数据结构将包括列表、元组、字典和集合，以及我们如何使用这些结构来组织和管理工作信息。
- en: At the end of this chapter, we'll be able to build applications that access
    live, current, up-to-the-minute data from the Web. Once we've got the data, we
    can filter and analyze it to create useful intelligence assets.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将能够构建应用程序，从网络获取实时、最新、分秒必争的数据。一旦我们获取了数据，我们可以过滤和分析它，以创建有用的情报资产。
- en: Accessing data from the Internet
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从互联网获取数据
- en: The WWW and Internet are based on a series of agreements called **Request for
    Comments** (**RFC**). The RFCs define the standards and protocols to interconnect
    different networks, that is, the rules for internetworking. The WWW is defined
    by a subset of these RFCs that specifies the protocols, behaviors of hosts and
    agents (servers and clients), and file formats, among other details.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网和互联网基于一系列称为**请求评论**（**RFC**）的协议。RFCs定义了连接不同网络的标准和协议，即互联网互连的规则。万维网由这些RFC的一个子集定义，该子集指定了协议、主机和代理（服务器和客户端）的行为以及文件格式等细节。
- en: In a way, the Internet is a controlled chaos. Most software developers agree
    to follow the RFCs. Some don't. If their idea is really good, it can catch on,
    even though it doesn't precisely follow the standards. We often see this in the
    way some browsers don't work with some websites. This can cause confusion and
    questions. We'll often have to perform both espionage and plain old debugging
    to figure out what's available on a given website.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，互联网是一种受控的混乱。大多数软件开发者都同意遵循RFCs。有些人则不然。如果他们的想法真的很好，它可能会流行起来，即使它并不完全遵循标准。我们经常在看到一些浏览器与某些网站不兼容时看到这种情况。这可能会引起困惑和疑问。我们经常不得不进行间谍活动和普通的调试，以确定给定网站上的可用信息。
- en: Python provides a variety of modules that implement the software defined in
    the Internet RFCs. We'll look at some of the common protocols to gather data through
    the Internet and the Python library modules that implement these protocols.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一系列模块，实现了互联网RFCs中定义的软件。我们将探讨一些常见的协议，通过互联网收集数据以及实现这些协议的Python库模块。
- en: Background briefing – the TCP/IP protocols
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景简报——TCP/IP协议
- en: The essential idea behind the WWW is the Internet. The essential idea behind
    the Internet is the TCP/IP protocol stack. The IP part of this is the internetworking
    protocol. This defines how messages can be routed between networks. Layered on
    top of IP is the TCP protocol to connect two applications to each other. TCP connections
    are often made via a software abstraction called a **socket**. In addition to
    TCP, there's also UDP; it's not used as much for the kind of WWW data we're interested
    in.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网背后的基本思想是互联网。互联网背后的基本思想是 TCP/IP 协议栈。这个协议栈中的 IP 部分是互联网互连协议。它定义了消息如何在网络之间路由。在
    IP 之上是 TCP 协议，用于连接两个应用程序。TCP 连接通常通过一个称为 **套接字** 的软件抽象来实现。除了 TCP 之外，还有 UDP；它在我们感兴趣的万维网数据中并不常用。
- en: In Python, we can use the low-level `socket` library to work with the TCP protocol,
    but we won't. A socket is a file-like object that supports open, close, input,
    and output operations. Our software will be much simpler if we work at a higher
    level of abstraction. The Python libraries that we'll use will leverage the socket
    concept under the hood.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以使用低级的 `socket` 库来处理 TCP 协议，但我们不会这样做。套接字是一个支持打开、关闭、输入和输出操作的文件类似对象。如果我们在一个更高的抽象级别上工作，我们的软件将会更简单。我们将使用的
    Python 库将在幕后利用套接字概念。
- en: 'The Internet RFCs defines a number of protocols that build on TCP/IP sockets.
    These are more useful definitions of interactions between host computers (servers)
    and user agents (clients). We''ll look at two of these: **Hypertext Transfer Protocol**
    (**HTTP**) and **File Transfer Protocol** (**FTP**).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网 RFC 定义了在 TCP/IP 套接字上构建的多个协议。这些是主机计算机（服务器）和用户代理（客户端）之间交互的有用定义。我们将查看其中的两个：**超文本传输协议**（**HTTP**）和**文件传输协议**（**FTP**）。
- en: Using http.client for HTTP GET
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 http.client 进行 HTTP GET
- en: 'The essence of web traffic is HTTP. This is built on TCP/IP. HTTP defines two
    roles: host and user agent, also called server and client, respectively. We''ll
    stick to server and client. HTTP defines a number of kinds of request types, including
    `GET` and `POST`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网络流量的本质是 HTTP。这是建立在 TCP/IP 之上的。HTTP 定义了两个角色：主机和用户代理，也分别称为服务器和客户端。我们将坚持使用服务器和客户端。HTTP
    定义了多种请求类型，包括 `GET` 和 `POST`。
- en: A web browser is one kind of client software we can use. This software makes
    `GET` and `POST` requests, and displays the results from the web server. We can
    do this kind of client-side processing in Python using two library modules.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器是我们可以使用的一种客户端软件。该软件会发出 `GET` 和 `POST` 请求，并显示来自网络服务器的结果。我们可以使用两个库模块在 Python
    中进行这种客户端处理。
- en: The `http.client` module allows us to make `GET` and `POST` requests as well
    as `PUT` and `DELETE`. We can read the response object. Sometimes, the response
    is an HTML page. Sometimes, it's a graphic image. There are other things too,
    but we're mostly interested in text and graphics.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.client` 模块允许我们进行 `GET` 和 `POST` 请求，以及 `PUT` 和 `DELETE` 请求。我们可以读取响应对象。有时，响应是一个
    HTML 页面。有时，它是一个图形图像。还有其他一些东西，但我们主要对文本和图形感兴趣。'
- en: Here's a picture of a mysterious device we've been trying to find. We need to
    download this image to our computer so that we can see it and send it to our informant
    from [http://upload.wikimedia.org/wikipedia/commons/7/72/IPhone_Internals.jpg](http://upload.wikimedia.org/wikipedia/commons/7/72/IPhone_Internals.jpg).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们一直在试图找到的神秘设备的图片。我们需要将此图像下载到我们的计算机上，以便我们可以查看并发送给我们的线人。[http://upload.wikimedia.org/wikipedia/commons/7/72/IPhone_Internals.jpg](http://upload.wikimedia.org/wikipedia/commons/7/72/IPhone_Internals.jpg)
- en: '![Using http.client for HTTP GET](img/Image_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![使用 http.client 进行 HTTP GET](img/Image_1.jpg)'
- en: 'Here''s a picture of the currency we''re supposed to track down and pay with:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要追踪并支付的货币的图片：
- en: '![Using http.client for HTTP GET](img/0420OS_02_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用 http.client 进行 HTTP GET](img/0420OS_02_02.jpg)'
- en: 'We need to download this image. Here is the link:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要下载这张图片。以下是链接：
- en: '[http://upload.wikimedia.org/wikipedia/en/c/c1/1drachmi_1973.jpg](http://upload.wikimedia.org/wikipedia/en/c/c1/1drachmi_1973.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://upload.wikimedia.org/wikipedia/en/c/c1/1drachmi_1973.jpg](http://upload.wikimedia.org/wikipedia/en/c/c1/1drachmi_1973.jpg)'
- en: 'Here''s how we can use `http.client` to get these two image files:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何使用 `http.client` 来获取这两个图像文件的方法：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We're using `http.client` to handle the client side of the HTTP protocol. We're
    also using the `contextlib` module to politely disentangle our application from
    network resources when we're done using them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `http.client` 来处理 HTTP 协议的客户端部分。我们还在使用 `contextlib` 模块，在完成使用网络资源后，礼貌地将我们的应用程序与网络资源分离。
- en: We've assigned a list of paths to the `path_list` variable. This example introduces
    list objects without providing any background. We'll return to lists in the *Organizing
    collections of data* section later in the chapter. It's important that lists are
    surrounded by `[]` and the items are separated by `,`. Yes, there's an extra `,`
    at the end. This is legal in Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将路径列表赋值给 `path_list` 变量。这个例子介绍了列表对象，但没有提供任何背景信息。我们将在本章后面的 *组织数据集合* 部分回到列表。重要的是列表必须用
    `[]` 括起来，并且项目之间用 `,` 分隔。是的，在末尾有一个额外的 `,`。这在 Python 中是合法的。
- en: We created an `http.client.HTTPConnection` object using the host computer name.
    This connection object is a little like a file; it entangles Python with operating
    system resources on our local computer plus a remote server. Unlike a file, an
    `HTTPConnection` object isn't a proper context manager. As we really like context
    managers to release our resources, we made use of the `contextlib.closing()` function
    to handle the context management details. The connection needs to be closed; the
    `closing()` function assures that this will happen by calling the connection's
    `close()` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用主机计算机名创建了一个 `http.client.HTTPConnection` 对象。这个连接对象有点像文件；它将 Python 与我们本地计算机上的操作系统资源以及远程服务器连接起来。与文件不同，`HTTPConnection`
    对象不是一个合适的上下文管理器。因为我们非常喜欢使用上下文管理器来释放资源，所以我们使用了 `contextlib.closing()` 函数来处理上下文管理细节。连接需要被关闭；`closing()`
    函数通过调用连接的 `close()` 方法确保这一点会发生。
- en: For all of the paths in our `path_list`, we make an HTTP `GET` request. This
    is what browsers do to get the image files mentioned in an HTML page. We print
    a few things from each response. The status, if everything worked, will be 200\.
    If the status is not 200, then something went wrong and we'll need to read up
    on the HTTP status code to see what happened.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们 `path_list` 中的所有路径，我们发送一个 HTTP `GET` 请求。这就是浏览器获取 HTML 页面中提到的图像文件的方式。我们从每个响应中打印了一些信息。如果一切正常，状态将是
    200。如果状态不是 200，那么就出了问题，我们需要查阅 HTTP 状态码来了解发生了什么。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you use a coffee shop Wi-Fi connection, perhaps you're not logged in. You
    might need to open a browser to set up a connection.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用咖啡馆的 Wi-Fi 连接，可能你没有登录。你可能需要打开浏览器来设置连接。
- en: An HTTP response includes headers that provide some additional details about
    the request and response. We've printed the headers because they can be helpful
    in debugging any problems we might have. One of the most useful headers is `('Content-Type',
    'image/jpeg')`. This confirms that we really did get an image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应包括一些提供请求和响应额外细节的头部信息。我们打印了头部信息，因为它们在调试我们可能遇到的问题时可能很有帮助。最有用的头部信息之一是 `('Content-Type',
    'image/jpeg')`。这确认了我们确实得到了一个图像。
- en: We used `_, _, filename = path.rpartition("/")` to locate the right-most `/`
    character in the path. Recall that the `partition()` method locates the left-most
    instance. We're using the right-most one here. We assigned the directory information
    and separator to the variable `_`. Yes, `_` is a legal variable name. It's easy
    to ignore, which makes it a handy shorthand for *we don't care*. We kept the filename
    in the `filename` variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `_, _, filename = path.rpartition("/")` 来定位路径中的最右侧 `/` 字符。回想一下，`partition()`
    方法用于定位最左侧的实例。在这里我们使用最右侧的。我们将目录信息和分隔符赋值给变量 `_`。是的，`_` 是一个合法的变量名。它很容易被忽略，这使得它成为表示“我们不关心”的便捷缩写。我们将文件名保存在
    `filename` 变量中。
- en: We create a nested context for the resulting image file. We can then read the
    body of the response—a collection of bytes—and write these bytes to the image
    file. In one quick motion, the file is ours.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为生成的图像文件创建了一个嵌套的上下文。然后我们可以读取响应的主体——一组字节，并将这些字节写入图像文件。一气呵成，文件就归我们所有了。
- en: The HTTP `GET` request is what underlies much of the WWW. Programs such as `curl`
    and `wget` are expansions of this example. They execute batches of `GET` requests
    to locate one or more pages of content. They can do quite a bit more, but this
    is the essence of extracting data from the WWW.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `GET` 请求是 WWW 的基础。例如 `curl` 和 `wget` 这样的程序是这个例子的扩展。它们执行一系列 `GET` 请求来定位一个或多个页面内容。它们可以做很多事情，但这只是从
    WWW 中提取数据的本质。
- en: Changing our client information
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改客户端信息
- en: An HTTP `GET` request includes several headers in addition to the URL. In the
    previous example, we simply relied on the Python `http.client` library to supply
    a suitable set of default headers. There are several reasons why we might want
    to supply different or additional headers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 HTTP `GET` 请求除了 URL 之外还包含几个头部信息。在之前的例子中，我们只是简单地依赖 Python `http.client` 库来提供一组合适的默认头部信息。我们可能有几个原因想要提供不同的或额外的头部信息。
- en: First, we might want to tweak the `User-Agent` header to change the kind of
    browser that we're claiming to be. We might also need to provide cookies for some
    kinds of interactions. For information on the user agent string, see [http://en.wikipedia.org/wiki/User_agent_string#User_agent_identification](http://en.wikipedia.org/wiki/User_agent_string#User_agent_identification).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可能想要调整 `User-Agent` 头部来改变我们声称的浏览器类型。我们也可能需要为某些类型的交互提供 cookies。关于用户代理字符串的信息，请参阅
    [http://en.wikipedia.org/wiki/User_agent_string#User_agent_identification](http://en.wikipedia.org/wiki/User_agent_string#User_agent_identification)。
- en: 'This information may be used by the web server to determine if a mobile device
    or desktop device is being used. We can use something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信息可能被网络服务器用来确定是否正在使用移动设备或桌面设备。我们可以使用类似的方法：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This makes our Python request appear to come from the Safari browser instead
    of a Python application. We can use something like this to appear to be a different
    browser on a desktop computer:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的 Python 请求看起来像是来自 Safari 浏览器而不是一个 Python 应用程序。我们可以在桌面计算机上使用类似的方法来模拟不同的浏览器：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use something like this to appear to be an iPhone instead of a Python
    application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的方法来模拟 iPhone 而不是 Python 应用程序：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We make this change by adding headers to the request we''re making. The change
    looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向请求中添加头部信息来做出这种改变。改变看起来是这样的：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will make the web server treat our Python application like it's on an iPhone.
    This might lead to a more compact page of data than might be provided to a full
    desktop computer that makes the same request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使网络服务器将我们的 Python 应用程序视为在 iPhone 上运行。这可能会导致比提供给完全桌面计算机的数据页面更紧凑。
- en: 'The header information is a structure with the `{ key: value, }` syntax. This
    is a dictionary. We''ll return to dictionaries in the following *Organizing collections
    of data* section. It''s important that dictionaries are surrounded by `{}`, the
    keys and values are separated by `:`, and each key-value pair is separated by
    `,`. Yes, there''s an extra `,` at the end. This is legal in Python.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '头部信息是一个具有 `{ key: value, }` 语法的结构。这是一个字典。我们将在接下来的 *组织数据集合* 部分回到字典。重要的是字典被 `{}`
    包围，键和值由 `:` 分隔，每个键值对由 `,` 分隔。是的，结尾有一个额外的 `,`。这在 Python 中是合法的。'
- en: There are many more HTTP headers we can provide. The `User-Agent` header is
    perhaps most important to gather different kinds of intelligence data from web
    servers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供许多其他的 HTTP 头部信息。`User-Agent` 头部可能是从网络服务器收集不同类型智能数据最重要的。
- en: Using FTP in Python
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中使用 FTP
- en: 'FTP specifies ways to transfer files between computers. There are two principle
    variants: the original FTP and the more secure version, FTPS. This more secure
    version uses SSL to assure that the lower-level sockets are fully encrypted. It''s
    sometimes called `FTP_TLS`, FTP with transport layer security.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 指定了在计算机之间传输文件的方法。有两种主要变体：原始 FTP 和更安全的版本 FTPS。这个更安全的版本使用 SSL 来确保低级套接字完全加密。有时被称为
    `FTP_TLS`，即带有传输层安全的 FTP。
- en: The SSH standard includes a file-transfer protocol, SFTP. This is a part of
    SSH and is separate from other FTP variants. This is supported by the `ftplib`
    module, even though it's really a different protocol.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 标准包括一个文件传输协议，SFTP。这是 SSH 的一部分，与其他 FTP 变体分开。这由 `ftplib` 模块支持，尽管它实际上是一个不同的协议。
- en: In some cases, FTP access is anonymous. No security credentials (such as usernames
    or passwords) are used. This is usually reserved for download-only content. Sometimes,
    anonymous access expects a placeholder username and password—the username should
    be *anonymous*, and typically, your e-mail address is used as a password. In other
    cases, we need to have proper credentials. We'll focus on publicly accessible
    FTP servers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，FTP 访问是匿名的。不使用任何安全凭证（如用户名或密码）。这通常保留用于仅下载的内容。有时，匿名访问期望一个占位符用户名和密码——用户名应该是
    *anonymous*，通常，你的电子邮件地址被用作密码。在其他情况下，我们需要有适当的凭证。我们将关注公开可访问的 FTP 服务器。
- en: We're going to look for the CIA World Factbooks. We know that there are copies
    in Project Gutenberg. This leads us to use the [ftp.ibiblio.org](http://ftp.ibiblio.org)
    server as the target of our investigation. The base URL is [ftp://ftp.ibiblio.org/pub/docs/books/gutenberg/](ftp://ftp.ibiblio.org/pub/docs/books/gutenberg/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要寻找《CIA世界事实全书》。我们知道在 Project Gutenberg 中有副本。这使我们决定使用 [ftp.ibiblio.org](http://ftp.ibiblio.org)
    服务器作为我们调查的目标。基本 URL 是 [ftp://ftp.ibiblio.org/pub/docs/books/gutenberg/](ftp://ftp.ibiblio.org/pub/docs/books/gutenberg/)。
- en: FTP has its own language of commands used to examine remote (and local) filesystems,
    create and remove directories, as well as get and put files. Some of this language
    is exposed through the Python FTP module. Some of it is kept hidden under the
    hood.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 有自己的命令语言，用于检查远程（和本地）文件系统、创建和删除目录，以及获取和放置文件。其中一些语言通过 Python FTP 模块公开。其中一些则隐藏在幕后。
- en: 'We can see some top-level documents available on the Project Gutenberg server
    with a script like the following. Here''s our initial step in discovering the
    data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用如下脚本查看 Project Gutenberg 服务器上可用的顶层文档。这是我们发现数据的初始步骤：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We imported the FTP library. We'll need this to do anything using the FTP protocol.
    We assigned the host, `host`, and root path, `root`, as strings. We'll use this
    in several functions that we need to define.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了 FTP 库。我们需要使用 FTP 协议做任何事情。我们将主机 `host` 和根路径 `root` 作为字符串分配。我们将在需要定义的几个函数中使用它。
- en: We defined a `directory_list()` function that will display names, types, and
    sizes from a directory. This lets us explore the files in our local directories.
    We'll use this function with different parameters after we've tracked down the
    directory with our candidate files.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `directory_list()` 函数，该函数将显示目录中的名称、类型和大小。这使我们能够探索本地目录中的文件。在找到候选文件所在的目录后，我们将使用不同的参数调用此函数。
- en: The `directory_list()` function opens a context using a `ftplib.FTP` object.
    We don't need to use the `contextlib.closing()` function, because this context
    is well behaved. This object will manage the various sockets used to exchange
    data with the FTP server. One of the methods, `getwelcome()`, retrieves any welcome
    message. We'll see that this is pretty short. Sometimes, they're more elaborate.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`directory_list()` 函数使用 `ftplib.FTP` 对象打开一个上下文。我们不需要使用 `contextlib.closing()`
    函数，因为这个上下文表现良好。此对象将管理用于与 FTP 服务器交换数据的各种套接字。其中一个方法，`getwelcome()`，检索任何欢迎消息。我们会看到这相当简短。有时，它们会更详细。'
- en: We'll dump the top-level directory information that shows the various files,
    directories, and their sizes. The `details['type']` syntax is how we pick a particular
    name out of the name-value pairs in a dictionary. The `details.get('size')` syntax
    does a similar thing. Getting an item with `[]` will raise an exception if the
    name is not found. Getting an item with the `get()` method supplies a default
    value instead of an exception. Unless specified otherwise, the default value is
    `None`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输出顶层目录信息，显示各种文件、目录及其大小。`details['type']` 语法是我们从字典中的键值对中选择特定名称的方式。`details.get('size')`
    语法做类似的事情。使用 `[]` 获取项如果找不到名称将引发异常。使用 `get()` 方法获取项而不是异常提供默认值。除非指定其他值，否则默认值是 `None`。
- en: We're making the claim that the `details` dictionary must have a `type` item.
    If it doesn't, the program will crash, because something's very wrong. We're also
    making the claim that the `details` dictionary might or might not have the `size`
    item. If the size isn't present, the `None` value will do instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声称 `details` 字典必须有一个 `type` 项。如果没有，程序将会崩溃，因为某些东西非常不对劲。我们还声称 `details` 字典可能或可能没有
    `size` 项。如果大小不存在，则 `None` 值将代替。
- en: There are a number of files here. The `README` and `GUTINDEX.ALL` files look
    promising; let's examine them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多文件。《README》和 `GUTINDEX.ALL` 文件看起来很有希望；让我们检查一下。
- en: Downloading a file via FTP
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 FTP 下载文件
- en: The FTP library relies on a technique called a **callback function** to support
    incremental processing. Downloading a 13 MB file takes some time. Having our computer
    just doze off while downloading is impolite. It's good to provide some ongoing
    status with respect to progress (or lack of it thereof).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 库依赖于一种称为 **回调函数** 的技术来支持增量处理。下载一个 13 MB 的文件需要一些时间。让我们的电脑在下载时只是打盹是不礼貌的。提供一些关于进度（或缺乏进度）的持续状态是很好的。
- en: 'We can define callback functions in a number of ways. If we''re going to use
    class definitions, the callback function will simply be another method of the
    class. Class definitions get a bit beyond the scope of our book. They''re quite
    simple, but we have to focus on espionage, not software design. Here''s a general-purpose
    `get()` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式定义回调函数。如果我们打算使用类定义，回调函数将是类的另一个方法。类定义超出了我们书籍的范围。它们相当简单，但我们必须专注于间谍活动，而不是软件设计。这里有一个通用目的的
    `get()` 函数：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `get()` function contains a function definition buried inside it. The `line_save()`
    function is the callback function that's used by the `retrlines()` function of
    an FTP connection. Each line of data from the server will be passed to the `line_save()`
    function to process it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()` 函数包含一个嵌套在其内的函数定义。`line_save()` 函数是 `retrlines()` 函数使用的回调函数，用于 FTP 连接。来自服务器的每一行数据都将传递给
    `line_save()` 函数进行处理。'
- en: 'Our `line_save()` function uses three `nonlocal` variables: `download`, `expected`,
    and `dots`. These variables are neither global nor are they local to the `line_save()`
    function. They''re initialized before any lines are downloaded, and they are updated
    within the `line_save()` function on a line-by-line basis. As they are a saved
    state for the `line_save()` function, we need to notify Python not to create local
    variables when these are used in an assignment statement.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `line_save()` 函数使用三个 `nonlocal` 变量：`download`、`expected` 和 `dots`。这些变量既不是全局的，也不是
    `line_save()` 函数的局部变量。它们在下载任何行之前被初始化，并在 `line_save()` 函数中逐行更新。由于它们是 `line_save()`
    函数的保存状态，我们需要通知 Python 在这些变量在赋值语句中使用时不要创建局部变量。
- en: The function's primary job is to print the line to the file named in the `output`
    variable. Interestingly, the `output` variable is also nonlocal. As we never try
    to assign a new value to this variable, we don't need to notify Python about its
    use in an assignment statement. A function has read access to nonlocal variables;
    write access requires special arrangements via the `global` or `nonlocal` statements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的主要任务是打印 `output` 变量中命名的行到文件。有趣的是，`output` 变量也是 `nonlocal` 的。由于我们从未尝试为这个变量分配新值，所以我们不需要通知
    Python 在赋值语句中使用它。一个函数可以读取非局部变量；写入访问需要通过 `global` 或 `nonlocal` 语句的特殊安排。
- en: If the output file is `sys.stdout`, we're displaying the file on the console.
    Writing status information is just confusing. If the output file is not `sys.stdout`,
    we're saving the file. Showing some status is helpful.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出文件是 `sys.stdout`，我们在控制台上显示文件。写入状态信息只会让人困惑。如果输出文件不是 `sys.stdout`，我们将保存文件。显示一些状态信息是有帮助的。
- en: We compute how many dots (from 0 to 19) to show. If the number of dots has increased,
    we'll print another dash. Yes, we called the variable `dots` but decided to print
    dashes. Obscurity is never a good thing. You might want to take an independent
    mission and write your own version, which is clearer than this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算需要显示多少个点（从 0 到 19）。如果点的数量增加了，我们会打印另一个破折号。是的，我们调用了变量 `dots` 但决定打印破折号。神秘性从来都不是一件好事。你可能想独立执行任务并编写自己的版本，这个版本比这个更清晰。
- en: The `get()` function creates a context using an `ftplib.FTP` object. This object
    will manage the various sockets used to exchange data with the FTP server. We
    use the `getwelcome()` method to get the welcome message. We use the `size()`
    method to get the size of the file we're about to request. By setting the `expected`
    variable, we can assure that up to 20 dashes are displayed to show the state of
    the download.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()` 函数使用 `ftplib.FTP` 对象创建一个上下文。该对象将管理用于与 FTP 服务器交换数据的各种套接字。我们使用 `getwelcome()`
    方法获取欢迎信息。我们使用 `size()` 方法获取我们即将请求的文件的大小。通过设置 `expected` 变量，我们可以确保显示最多 20 个破折号以显示下载的状态。'
- en: The `retrlines()` method of the connection requires an FTP command and a callback
    function. It sends the command; each line of the response is sent to the callback
    function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的 `retrlines()` 方法需要一个 FTP 命令和一个回调函数。它发送命令；响应的每一行都会发送到回调函数。
- en: Using our FTP get() function
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用我们的 FTP get() 函数
- en: 'We can use this `get()` function to download files from the server. We''ll
    start with two examples of extracting files from an FTP server:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个 `get()` 函数从服务器下载文件。我们将从两个从 FTP 服务器提取文件的示例开始：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first example is a small file. We'll display the `README` file, which might
    have useful information. It's usually small, and we can write it to `stdout` immediately.
    The second example will open a file processing context to save the large `GUTINDEX.ALL`
    file locally for further analysis. It's quite large, and we certainly don't want
    to display it immediately. We can search this index file for CIA World Factbooks.
    There are several Factbooks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子是一个小文件。我们将显示 `README` 文件，它可能包含有用的信息。它通常很小，我们可以立即将其写入 `stdout`。第二个例子将打开一个文件处理上下文，将大的
    `GUTINDEX.ALL` 文件本地保存以供进一步分析。它相当大，我们当然不想立即显示它。我们可以在索引文件中搜索中央情报局世界事实书。有几个事实书。
- en: The introduction to the `GUTINDEX.ALL` file describes how document numbers turn
    into directory paths. One of the CIA World Factbooks, for example, is document
    number 35830\. This becomes the directory path `3/5/3/35380/`. The document will
    be in this directory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`GUTINDEX.ALL` 文件的介绍描述了文档编号如何转换为目录路径。例如，中央情报局世界事实书中之一是文档编号 35830。这变成了目录路径 `3/5/3/35380/`。文档将在这个目录中。'
- en: 'We can use our `directory_list()` function to see what else is there:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的 `directory_list()` 函数来查看还有其他什么内容：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will show us that there are several subdirectories and a ZIP file that
    appears to have images. We''ll start with the text document. We can use our `get()`
    function to download the CIA Factbook in a script like the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示有几个子目录和一个看起来包含图像的 ZIP 文件。我们将从文本文件开始。我们可以使用我们的 `get()` 函数在以下脚本中下载中央情报局事实书：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This gets us one of the CIA World Factbooks. We can easily track down the others.
    We can then analyze information from these downloaded documents.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个中央情报局世界事实书。我们可以轻松追踪其他事实书。然后我们可以分析这些下载文档中的信息。
- en: Using urllib for HTTP, FTP, or file access
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 urllib 进行 HTTP、FTP 或文件访问
- en: The `urllib` package wraps HTTP, FTP, and local file access in a single, tidy
    package. In the most common situations, this package allows us to elide some of
    the processing details we saw in the previous examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib` 包将 HTTP、FTP 和本地文件访问封装在一个单一、整洁的包中。在大多数常见情况下，这个包允许我们省略一些我们在前一个例子中看到的处理细节。'
- en: 'The advantage of the general approach in `urllib` is that we can write smallish
    programs that can work with data from a wide variety of locations. We can rely
    on `urllib` to work with HTTP, FTP, or local files seamlessly. The disadvantage
    is that we can''t do some more complex HTTP or FTP interactions. Here''s an example
    of downloading two images with the `urllib` version of the HTTP `get` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib` 中通用方法的优点是我们可以编写小型程序，这些程序可以与来自各种位置的数据一起工作。我们可以依赖 `urllib` 无缝地处理 HTTP、FTP
    或本地文件。缺点是我们不能进行一些更复杂的 HTTP 或 FTP 交互。以下是一个使用 `urllib` 版本的 HTTP `get` 函数下载两个图像的例子：'
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've defined two URLs. When using `urllib`, we can provide full URLs without
    having to distinguish between the host and the path we're tying to access.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已定义了两个 URL。当使用 `urllib` 时，我们可以提供完整的 URL，而无需区分我们试图访问的主机和路径。
- en: 'We create a context using `urllib.request.urlopen()`. This context will contain
    all of the resources used for getting the file from the World Wide Web. The `response`
    object is called a **file-like object** in Python parlance. We can use it the
    way we''d use a file: it supports `read()` and `readline()` methods. It can be
    used in a `for` statement to iterate over lines of a text file.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `urllib.request.urlopen()` 创建一个上下文。这个上下文将包含从万维网获取文件所使用的所有资源。在 Python 术语中，`response`
    对象被称为 **文件类似对象**。我们可以像使用文件一样使用它：它支持 `read()` 和 `readline()` 方法。它可以用在 `for` 语句中，以迭代文本文件的行。
- en: Using urllib for FTP access
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 urllib 进行 FTP 访问
- en: 'We can use a simple `urllib.request` to get a file via FTP. We can simply change
    the URL to reflect the protocol we''re using. Something like this works well:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的 `urllib.request` 通过 FTP 获取文件。我们只需更改 URL 以反映我们使用的协议。以下类似的内容可以很好地工作：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will open the source file and print it on `sys.stdout`. Note that we had
    to decode the bytes from ASCII to create proper Unicode characters for use by
    Python. We can print the other status and header information if we find it necessary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开源文件并在 `sys.stdout` 上打印它。请注意，我们必须将字节从 ASCII 解码为以创建适当的 Unicode 字符，以便 Python
    使用。如果我们发现有必要，我们可以打印其他状态和标题信息。
- en: 'We can also use a local file URL. The schema is `file:` instead of `http:`
    or `ftp:`. Generally, the hostname is omitted, thus leading to file URLs like
    this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用本地文件 URL。其模式是 `file:` 而不是 `http:` 或 `ftp:`。通常省略主机名，因此导致类似这样的文件 URL：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using `urllib` leads to a few pleasant simplifications. We can treat resources
    located across the WWW with code that's similar to handling a local file. Remote
    resources are often slower than local files; we might want to give up waiting
    after a period of time. Also, there's the possibility of network disconnections.
    Our error handling needs to be more robust when working with remote data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`urllib`带来了一些方便的简化。我们可以用处理本地文件类似的代码来处理位于整个互联网上的资源。远程资源通常比本地文件慢；我们可能在一段时间后放弃等待。此外，还有网络断开连接的可能性。在处理远程数据时，我们的错误处理需要更加健壮。
- en: Using a REST API in Python
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python中的REST API
- en: A great deal of intelligence data is available through REST APIs. Much of the
    data is available in simple JSON, CSV, or XML documents. In order to make sense
    of this data, we need to be able to parse these various kinds of serialization
    formats. We'll focus on JSON because it's widely used. Sadly, it's not universal.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过REST API可以获取大量的智能数据。大部分数据以简单的JSON、CSV或XML文档的形式提供。为了理解这些数据，我们需要能够解析这些各种类型的序列化格式。我们将重点关注JSON，因为它被广泛使用。遗憾的是，它并不是通用的。
- en: 'A REST protocol is essentially HTTP. It will leverage `POST`, `GET`, `PUT`,
    and `DELETE` requests to implement the essential four stages in the life of persistent
    data: **Create, Retrieve, Update, and Delete** (**CRUD**) rules.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: REST协议本质上就是HTTP。它将利用`POST`、`GET`、`PUT`和`DELETE`请求来实现持久数据生命周期的四个基本阶段：**创建、检索、更新和删除**（**CRUD**）规则。
- en: We'll look at currency conversion as a simple web API. This can both help us
    bribe our information sources as well as provide important information on the
    overall state of a nation's economy. We can measure national economies against
    each other as well as measure them against non-national crypto currencies such
    as bitcoins.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究货币转换作为一个简单的Web API。这不仅可以帮助我们贿赂我们的信息来源，还可以提供关于一个国家经济整体状况的重要信息。我们可以将国家经济相互比较，也可以将它们与非国家加密货币，如比特币进行比较。
- en: We'll get exchange and currency information from [http://www.coinbase.com](http://www.coinbase.com).
    There are a lot of similar services; this one seems reasonably complete. They
    seem to have up-to-date currency information that we can report to HQ as part
    of an overall intelligence assessment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从[http://www.coinbase.com](http://www.coinbase.com)获取汇率和货币信息。有许多类似的服务；这个看起来相当完整。他们似乎有最新的货币信息，我们可以将其作为整体情报评估的一部分报告给总部。
- en: Their API documentation is available at [https://coinbase.com/api/doc](https://coinbase.com/api/doc).
    This tells us what URLs to use, what data to provide with the URL, and what kind
    of response to expect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的API文档可在[https://coinbase.com/api/doc](https://coinbase.com/api/doc)找到。这告诉我们应该使用哪些URL，应该与URL一起提供哪些数据，以及可以期待什么样的响应。
- en: Getting simple REST data
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取简单的REST数据
- en: We can get the currency exchange data either with the `http.client` or `urllib.request`
    module. This won't be new to us; we already grabbed data using both libraries.
    The responses from this website will be in the JSON notation. For more information,
    see [http://www.json.org/](http://www.json.org/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`http.client`或`urllib.request`模块来获取货币交换数据。这对我们来说并不陌生；我们已经在使用这两个库获取数据。这个网站的响应将是JSON格式。更多信息，请参阅[http://www.json.org/](http://www.json.org/)。
- en: 'To parse a JSON document, we''ll need to import the `json` module from the
    standard library. The response that we get from `urllib` is a sequence of bytes.
    We''ll need to decode these bytes to get a string. We can then use the `json.loads()`
    function to build Python objects from that string. Here''s how it looks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析一个JSON文档，我们需要从标准库中导入`json`模块。我们从`urllib`获取的响应是一系列字节。我们需要解码这些字节以获取字符串。然后我们可以使用`json.loads()`函数从该字符串构建Python对象。看起来是这样的：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We imported the two libraries that we need: `urllib.request` to get the data
    and `json` to parse the response.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了所需的两个库：`urllib.request`用于获取数据，`json`用于解析响应。
- en: The currency query (`/api/v1/currencies/`) is described in the API documentation
    on the Coinbase website. When we make this request, the resulting document will
    have all of the currencies they know about.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 货币查询（`/api/v1/currencies/`）在Coinbase网站的API文档中有描述。当我们发起这个请求时，返回的文档将包含他们所知道的全部货币。
- en: We printed `document.info().items()`; this is the collection of headers that
    came back with the response. Sometimes, these are interesting. In this case, they
    don't tell us too much that we don't already know. What's important is that the
    `Content-Type` header has a `application/json; charset=utf-8` value . This tells
    us how to decode the bytes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印了`document.info().items()`；这是随响应返回的头信息集合。有时，这些信息很有趣。在这种情况下，它们并没有告诉我们太多我们不知道的事情。重要的是`Content-Type`头信息具有`application/json;
    charset=utf-8`的值。这告诉我们如何解码字节。
- en: We read the resulting document (`document.read()`) and then converted the bytes
    to characters. The `Content-Type` header says that the characters were encoded
    using `utf-8`, so we'll use `utf-8` to decode the bytes and recover the original
    sequence of characters. Once we have the characters, we can use `json.loads()`
    to create a Python object from the characters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取了生成的文档(`document.read()`)，然后将字节转换为字符。`Content-Type`头信息表明字符使用`utf-8`进行编码，因此我们将使用`utf-8`来解码字节并恢复原始字符序列。一旦我们有了字符，我们可以使用`json.loads()`从字符创建Python对象。
- en: 'This will get us a list of currencies we can work with. The response object
    looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一个我们可以工作的货币列表。响应对象看起来像这样：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is a list of lists that provides the names of 161 currencies.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个列表列表，提供了161种货币的名称。
- en: In the next section, we'll look at ways to work with a list-of-tuple structure.
    Working with a list of list is going to be very similar to working with a list
    of tuple.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何处理列表-元组结构。处理列表列表与处理列表元组非常相似。
- en: To make this more flexible, we need to turn the header `items()` list into a
    dictionary. From this, we can get the `Content-Type` value string from the dictionary.
    This string can be partitioned on `;` to locate the `charset=utf-8` substring.
    This string can subsequently be partitioned on the `=` character to locate the
    `utf-8` encoding information. This would be slightly better than assuming a `utf-8`
    encoding. The first step, creating a dictionary from the headers, has to wait
    until the *Organizing collections of data* section. First, we'll look at getting
    other information using the REST protocol.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加灵活，我们需要将`items()`头信息列表转换为字典。从字典中，我们可以获取`Content-Type`值字符串。这个字符串可以被分割在`;`上以定位`charset=utf-8`子串。这个字符串随后可以被分割在`=`字符上以定位`utf-8`编码信息。这会比假设`utf-8`编码稍微好一些。第一步，从头信息创建字典，必须等到*组织数据集合*部分。首先，我们将查看如何使用REST协议获取其他信息。
- en: Using more complex RESTful queries
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用更复杂的RESTful查询
- en: Once we have a list of currencies, we can request spot conversion rates. This
    involves a somewhat more complex URL. We need to provide a currency code to get
    the current bitcoin exchange rate for that specific currency.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了货币列表，我们就可以请求即期汇率。这涉及到一个稍微复杂一些的URL。我们需要提供一个货币代码来获取该特定货币的当前比特币汇率。
- en: While it's not perfectly clear from the API documentation, the RFCs for the
    web state that we should encode the query string as part of our processing. In
    this specific situation, it doesn't seem possible for the query string to contain
    any characters that *require* encoding.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从API文档中并不完全清楚，但Web状态RFC指出我们应该将查询字符串作为我们处理的一部分进行编码。在这种情况下，查询字符串似乎不可能包含任何需要编码的字符。
- en: We're going to be fussy though and encode the query string properly using the
    `urllib` module. Encoding will be essential for a number of examples in [Chapter
    4](ch04.html "Chapter 4. Drops, Hideouts, Meetups, and Lairs"), *Drops, Hideouts,
    Meetups, and Lairs*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将非常挑剔，并使用`urllib`模块正确地编码查询字符串。编码对于[第4章](ch04.html "第4章。Drop、藏身之处、聚会和巢穴")中的许多示例至关重要，*Drop、藏身之处、聚会和巢穴*。
- en: 'Query string encoding is done using the `urllib.parse` module. It looks like
    this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串编码使用`urllib.parse`模块完成。它看起来像这样：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `scheme_netloc_path` variable has a portion of the URL. It has the scheme
    (`http`), network location (`coinbase.com`), and path (`api/v1/prices/spot_rate`).
    This fragment of the URL doesn't have the query string; we'll encode this separately
    because it had dynamic information that changes from request to request.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`scheme_netloc_path`变量包含URL的一部分。它有方案(`http`)、网络位置(`coinbase.com`)和路径(`api/v1/prices/spot_rate`)。这个URL片段没有查询字符串；我们将单独对其进行编码，因为它包含动态信息，这些信息会随着请求而变化。'
- en: Technically, a query string is a bunch of parameters that have been encoded
    so that certain reserved characters such as `?` and `#` don't cause any confusion
    to the web server. Pragmatically, the query string used here is very simple with
    only a single parameter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，查询字符串是一系列经过编码的参数，这样一些保留字符，如 `?` 和 `#`，就不会对Web服务器造成任何混淆。实际上，这里使用的查询字符串非常简单，只有一个参数。
- en: To handle query strings in a general-purpose way, we defined an HTML form using
    a dictionary and assigned it to the `form` variable. This dictionary is a model
    of a form on an HTML web page with a single input field. We modeled an input field
    with a name, `currency`, that has an `EUR` value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以通用方式处理查询字符串，我们使用字典定义了一个HTML表单，并将其分配给 `form` 变量。这个字典是HTML网页上表单的一个模型，包含一个输入字段。我们模拟了一个名为
    `currency` 的输入字段，其值为 `EUR`。
- en: The `urllib.parse.urlencode()` function encodes all the fields of the form into
    a tidy representation with any reserved characters handled properly. In this case,
    there's only one field, and no reserved characters are used by the field name
    or the field value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib.parse.urlencode()` 函数将表单的所有字段编码成一个整洁的表示形式，任何保留字符都得到适当的处理。在这种情况下，只有一个字段，并且字段名或字段值没有使用保留字符。'
- en: 'We can play with this in interactive Python:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在交互式Python中玩弄这个：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code shows how we built a form object as a dictionary and then
    encoded it to create a valid URL-encoded query string. As the data was so simple,
    the encoding is quite simple.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码显示了如何将表单对象作为字典构建，然后编码以创建有效的URL编码查询字符串。由于数据非常简单，编码也很简单。
- en: 'Here''s an example with a more complex piece of data in the form:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含更复杂数据片段的示例：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, we updated the form with different input; we changed the currency value
    to `Something with # or ?`. We''ll look at dictionary updates in the next section.
    The updated value has reserved characters in it. When we encoded this form, the
    result shows how reserved characters are handled by URL encoding.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们更新了表单，使用了不同的输入；我们将货币值更改为 `Something with # or ?`。我们将在下一节中查看字典更新。更新后的值中包含保留字符。当我们对表单进行编码时，结果显示了保留字符是如何通过URL编码处理的。'
- en: 'As we start working with more complex structures, we''ll find that the built-in
    `print()` function isn''t going to do everything we need. In the `pprint` module,
    the `pprint()` function does a much nicer job working with complex data. We can
    use this to get the pretty-print function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理更复杂的结构时，我们会发现内置的 `print()` 函数并不能完成我们需要的所有事情。在 `pprint` 模块中，`pprint()`
    函数在处理复杂数据方面做得更好。我们可以使用这个来获取美观打印函数：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use our query template and the encoded data like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的查询模板和编码后的数据如下：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The expression, `scheme_netloc_path+"?"+query`, assembled the complete URL from,
    the relatively static portions, and the dynamic query string. We've used a `with`
    statement to be sure that all of the network resources are properly released when
    we're done. We used the `pprint()` function to show the headers, which tell us
    the content type. The headers also include three cookies, which we're studiously
    ignoring for these examples.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `scheme_netloc_path+"?"+query` 从相对静态部分和动态查询字符串组装了完整的URL。我们使用 `with` 语句确保在完成后所有网络资源都得到适当释放。我们使用
    `pprint()` 函数显示头部信息，这些信息告诉我们内容类型。头部还包括三个cookie，在这些示例中我们仔细地忽略了它们。
- en: 'When we print the `spot_rate` value, we see that the Python object looks like
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印 `spot_rate` 值时，我们看到Python对象看起来是这样的：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These are Python dictionary objects. We'll need to learn more about dictionaries
    to be able to work with these responses. Stay tuned for the *Using a Python dictionary
    mapping* section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Python字典对象。我们需要了解更多关于字典的知识，以便能够处理这些响应。请关注 *使用Python字典映射* 部分。
- en: Saving our data via JSON
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过JSON保存我们的数据
- en: What if we want to save the data we downloaded? This is something in which JSON
    excels. We can use the JSON module to serialize objects into a string and write
    this string to a file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想保存下载的数据呢？这是JSON擅长的事情。我们可以使用JSON模块将对象序列化为字符串并将此字符串写入文件。
- en: 'Here''s how we can save our two-spot currency rate pieces of data into a JSON
    document. First, we need to turn our `spot_rate` example from the *Getting more
    RESTful data* section into a function. Here''s how it might look:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何将我们的两价货币汇率数据保存到JSON文档中的示例。首先，我们需要将 *获取更多RESTful数据* 部分的 `spot_rate` 示例转换为函数。它可能看起来是这样的：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function requires the currency code as an argument. Given the currency
    code, it creates a tiny input form and encodes this to create the query string.
    In this case, we saved that string in the `query` variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要一个货币代码作为参数。给定货币代码，它创建了一个小型的输入表单并将这个表单编码以创建查询字符串。在这种情况下，我们将这个字符串保存在`query`变量中。
- en: 'We created the URL from a template and the data. This URL was used as a request
    to get a currency spot rate. We read the entire response and decoded the string
    from bytes. Once we had the string, we loaded a Python dictionary object using
    this string. We returned this dictionary using the `get_spot_rate()` function.
    We can now use this function to get some spot-rate dictionary objects:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个模板和数据中创建了 URL，这个 URL 被用作获取货币点价的请求。我们读取了整个响应并将字节字符串解码。一旦我们有了字符串，我们就使用这个字符串加载了一个
    Python 字典对象。我们使用`get_spot_rate()`函数返回了这个字典。现在我们可以使用这个函数来获取一些点价字典对象：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This statement built a list-of-dictionary structure from our three spot-rate
    dictionaries. It assigned the collection to the `rates` variable. Once we have
    this, we can serialize it and create a file that has some useful exchange-rate
    information.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句从我们的三个点值字典中构建了一个列表-字典结构。它将这个集合分配给`rates`变量。一旦我们有了这个，我们就可以序列化它并创建一个包含一些有用汇率信息的文件。
- en: 'Here''s how we use JSON to save a Python object to a file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用 JSON 将 Python 对象保存到文件中的示例：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We opened a file to write something and used this as a processing context to
    be assured that the file will be properly closed when we're done. We then used
    the `json.dump()` function to dump our `rates` object to this file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了一个文件来写入一些内容，并使用这个作为处理上下文以确保我们在完成后文件会被正确关闭。然后我们使用`json.dump()`函数将我们的`rates`对象转储到这个文件中。
- en: What's important about this is that JSON works most simply when we encode one
    object to a file. In this case, we built a list of individual objects and encoded
    that list into the file. As we can't easily perform any sort of partial or incremental
    encoding of objects into a JSON file, we built a list with everything in it. Except
    in cases of huge mountains of data, this technique of building and dumping a list
    works very nicely.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，JSON 在我们将一个对象编码到文件时工作得最简单。在这种情况下，我们构建了一个包含单个对象的列表并将其编码到文件中。由于我们无法轻松地对对象进行任何类型的部分或增量编码到
    JSON 文件中，所以我们构建了一个包含所有内容的列表。除非在数据量巨大的情况下，这种构建和转储列表的技术工作得非常好。
- en: Organizing collections of data
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织数据集合
- en: We introduced some data collections earlier in the chapter. It's time to come
    clean on what these collections are and how we can use them effectively. As we
    observed in [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our Espionage
    Toolkit*, Python offers a tower of different types of numbers. The commonly used
    numbers are built in; the more specialized numbers are imported from the standard
    library.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节的早期介绍了一些数据集合。现在是时候坦白这些集合是什么以及我们如何有效地使用它们了。正如我们在[第1章](ch01.html "第1章. 我们的间谍工具包")中观察到的，*我们的间谍工具包*，Python
    提供了一座不同类型的数字宝塔。常用的数字是内置的；更专业的数字是从标准库中导入的。
- en: In a similar way, Python has a number of built-in collections. There is also
    a very large number of additional collection types available in the standard library.
    We'll look at the built-in lists, tuples, dictionaries, and sets. These cover
    the essential bases to work with groups of data items.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，Python 有许多内置的集合。在标准库中还有大量额外的集合类型可用。我们将查看内置的列表、元组、字典和集合。这些涵盖了处理数据项组的基本基础。
- en: Using a Python list
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 列表
- en: The Python list class can be summarized as a mutable sequence. **Mutability**
    means that we can add, change, and remove items (the list can be changed). Sequence
    means that the items are accessed based on their positions within the list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Python 列表类可以概括为一种可变序列。**可变性**意味着我们可以添加、更改和删除项目（列表可以更改）。序列意味着项目是通过它们在列表中的位置来访问的。
- en: The syntax is pleasantly simple; we put the data items in `[]` and separate
    the items with `,`. We can use any Python object in the sequence.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 语法非常简单；我们将数据项放在`[]`中，并用`,`分隔项。我们可以在序列中使用任何 Python 对象。
- en: HQ wants information on per capita consumption of selected cheese varieties.
    While HQ doesn't reveal much to field agents, we know that they often want to
    know about natural resources and strategic economic strengths.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 总部希望了解选定奶酪品种的人均消费情况。虽然总部没有向现场特工透露太多信息，但我们知道他们经常想知道关于自然资源和战略经济优势的信息。
- en: We can find cheese consumption data at [http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls](http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls](http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls)找到奶酪消费数据。
- en: Sadly, the data is in a proprietary spreadsheet format and rather difficult
    to work with. To automate the data gathering, we would need something like Project
    Stingray to extract the data from this document. For manual data gathering, we
    can copy and paste the data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，数据是专有电子表格格式，并且相当难以处理。为了自动化数据收集，我们需要类似Project Stingray这样的工具来从该文档中提取数据。对于手动数据收集，我们可以复制并粘贴数据。
- en: 'Here''s the data starting in 2000 and extending through 2010; we''ll use it
    to show some simple list processing:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从2000年开始到2010年结束的数据；我们将用它来展示一些简单的列表处理：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We created a list object and assigned it to the `cheese` variable. We used the
    `min()` function, which reveals the least value in the `29.87` sequence.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个列表对象，并将其分配给`cheese`变量。我们使用了`min()`函数，它揭示了`29.87`序列中的最小值。
- en: The `index()` method searches through the sequence for the matching value. We
    see that the maximum consumption found with the `max()` function has an index
    of `7` corresponding to 2007\. After that, cheese consumption fell slightly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()`方法在序列中搜索匹配的值。我们看到使用`max()`函数找到的最大消费量对应的索引是`7`，即2007年。之后，奶酪消费量略有下降。'
- en: Note that we have prefix function notations (`min()`, `max()`, `len()`, and
    several others). We also have method function notation, `cheese.index()`, and
    many others. Python offers a rich variety of notations. There's no fussy adherence
    to using only method functions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有一些前缀函数表示法（`min()`、`max()`、`len()`等），我们还有方法函数表示法，如`cheese.index()`，以及其他许多。Python提供了丰富的表示法。没有严格遵循只使用方法函数的规则。
- en: 'As a list is mutable, we can append additional values to the list. We can use
    an `cheese.extend()` function to extend a given list with an additional list of
    values:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表是可变的，我们可以向列表中添加额外的值。我们可以使用`cheese.extend()`函数将额外的值列表扩展到给定的列表中：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can also use the `+` operator to combine two lists.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`+`运算符来合并两个列表。
- en: 'We can reorder the data so that it''s strictly ascending using the following
    code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码重新排序数据，使其严格递增：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the `sort()` method doesn't return a value. It mutates the list object
    itself; it doesn't return a new list. If we try something like `sorted_cheese=
    cheese.sort()`, we see that `sorted_cheese` has a `None` value. This is a consequence
    of `sort()` not returning a value; it mutates the list.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sort()`方法不返回值。它修改了列表对象本身；它不返回一个新列表。如果我们尝试`sorted_cheese= cheese.sort()`，我们会看到`sorted_cheese`有一个`None`值。这是由于`sort()`不返回值的结果；它修改了列表。
- en: When working with time-series data, this kind of transformation will be confusing
    because the relationship between year and cheese consumption is lost when we sort
    the list.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理时间序列数据时，这种转换会让人困惑，因为当我们对列表进行排序时，年份和奶酪消费量之间的关系就丢失了。
- en: Using list index operations
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表索引操作
- en: 'We can access individual items using the `cheese[index]` notation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cheese[index]`表示法来访问单个项目：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This allows us to pick specific items from a list. As the list was sorted,
    the item `0` is the least, and the item `1` is the next larger value. We can index
    *backwards* from the end of the list, as shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们从列表中挑选特定的项目。由于列表已排序，项目`0`是最小的，项目`1`是下一个较大的值。我们可以从列表的末尾*反向*索引，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the sorted data, the `-2` item is next to the largest one; the `-1` item
    is the last one, which is the largest value seen. In the original, unsorted `cheese[-2]`
    data would have been the 2009 data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序后的数据中，`-2`项是下一个最大的值；`-1`项是最后一个，即最大的值。在原始未排序的`cheese[-2]`数据将是2009年的数据。
- en: 'We can take a *slice* from a list too. Some common slice manipulations look
    like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从列表中取一个*切片*。一些常见的切片操作如下所示：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first slice picks the first five values—the values of least cheese consumption.
    As we sorted the time-series data, we don't readily know which years' these were.
    We might need a more sophisticated data collection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一片选取了前五个值——奶酪消费量最少的值。由于我们已对时间序列数据进行排序，我们并不容易知道这些值是哪一年的。我们可能需要更复杂的数据收集。
- en: 'When working with collections, we find that we have a new comparison operator,
    `in`. We can use a simple `in` test to see if a value occurs anywhere in the collection:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理集合时，我们发现我们有一个新的比较运算符`in`。我们可以使用简单的`in`测试来查看值是否在任何集合中发生：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `in` operator works for tuples, dictionary keys, and sets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符适用于元组、字典键和集合。'
- en: 'The comparison operators compare the elements in order, looking for the first
    nonequal element between two sequences. Consider the following example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符按顺序比较两个序列中的元素，寻找两个序列之间第一个不等的元素。考虑以下示例：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As the first two elements were equal, it was the third element that determined
    the relationship between the two lists. This rule also works for tuples.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前两个元素相等，所以是第三个元素决定了两个列表之间的关系。这个规则也适用于元组。
- en: Using a Python tuple
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python元组
- en: 'The Python tuple class can be summarized as an immutable sequence. Immutability
    means that once created, the tuple cannot be changed. The value of the number
    3 is immutable, also: it''s always 3\. Sequence means that the items are accessed
    based on their positions within the tuple.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Python的元组类可以概括为一个不可变序列。不可变性意味着一旦创建，元组就不能被更改。数字3的值是不可变的，也是：它始终是3。序列意味着可以通过元组中元素的顺序来访问这些元素。
- en: 'The syntax is pleasantly simple; we might need to put the data items in `()`
    and must separate the items with `,`. We can use any Python objects in the sequence.
    The idea is to create an object that looks like a mathematical coordinate: `(3,
    4)`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 语法简单愉快；我们可能需要将数据项放在`()`中，并用`,`分隔项。我们可以使用任何Python对象作为序列。想法是创建一个看起来像数学坐标的对象：`(3,
    4)`。
- en: 'Tuples are used under the hood at many places within Python. When we use multiple
    assignments, for example, the right-hand side of the following code creates a
    tuple and the left-hand side decomposes it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在Python的许多地方被底层使用。当我们使用多重赋值时，例如，以下代码的右侧创建了一个元组，而左侧将其分解：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The right-hand side created a two-tuple `(0, 1)`. The syntax doesn't require
    `()` around the tuple. The left-hand side broke down a two-tuple, assigning the
    values to two distinct variables.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧创建了一个二元组`(0, 1)`。语法不需要在元组周围使用`()`。左侧将二元组分解，将值分配给两个不同的变量。
- en: 'We generally use tuples for data objects where the number of elements is fixed
    by the problem domain. We often use tuples for coordinate pairs such as latitude
    and longitude. We don''t need the flexible length that a list offers because the
    size of a tuple cannot change. What would a three-tuple mean when it''s supposed
    to have just two values, latitude and longitude? A different kind of problem might
    involve longitude, latitude, and altitude; in this case, we''re working with three-tuples.
    Using two-tuples or three-tuples in these examples is an essential feature of
    the problem: we won''t be mutating objects to add or remove values.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在问题域中元素数量固定的情况下使用元组。我们经常使用元组来表示坐标对，如纬度和经度。我们不需要列表提供的灵活长度，因为元组的大小不能改变。当它应该只有两个值，纬度和经度时，三元组意味着什么？在涉及经度、纬度和海拔的情况下，我们可能面临不同类型的问题；在这种情况下，我们正在处理三元组。在这些例子中使用二元组或三元组是问题的一个基本特征：我们不会通过添加或删除值来修改对象。
- en: When we looked at HTTP headers in requests and responses, we saw that these
    are represented as a list of two-tuples, such as `('Content-Type', 'text/html;
    charset=utf-8')`. Each tuple has a header name (`'Content-Type'`) and header value
    (`'text/html; charset=utf-8'`).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看请求和响应中的HTTP头时，我们看到这些被表示为二元组的列表，例如`('Content-Type', 'text/html; charset=utf-8')`。每个二元组都有一个头名称（`'Content-Type'`）和一个头值（`'text/html;
    charset=utf-8'`）。
- en: 'Here''s an example of using a two-tuple to include year and cheese consumption:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用二元组包含年份和奶酪消费量的例子：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This list-of-tuple structure allows us to perform a slightly simpler analysis
    of the data. Here are two examples:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种二元组列表结构允许我们执行稍微简单一点的数据分析。这里有两个例子：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We applied the `max()` function to our list of tuples. The second argument to
    the `max()` function is another function—in this case, an anonymous `lambda` object—that
    evaluates just the second value in each tuple.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`max()`函数应用于我们的元组列表。`max()`函数的第二个参数是另一个函数——在这种情况下，是一个匿名`lambda`对象——它仅评估每个二元组的第二个值。
- en: 'Here are two more examples that show what''s happening with the `lambda` object:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个更多示例，展示了`lambda`对象正在发生的事情：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `(2007, 33.5)` two-tuple has the `[1]` get item operation applied; this
    will pick the item at position `1`, that is, the `33.5` value. The item at position
    zero is the year 2007.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`(2007, 33.5)`二元组应用了`[1]`获取项操作；这将选择位置`1`的项，即`33.5`值。位置零是年份2007。'
- en: The `(lambda x:x[1])` expression creates an anonymous `lambda` function. We
    can then apply this function to the `(2007, 33.5)` two-tuple. As the `x[1]` expression
    picks the item at index position `1`, we get the `33.5` value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda x:x[1])`表达式创建了一个匿名`lambda`函数。然后我们可以将这个函数应用于`(2007, 33.5)`双元组。由于`x[1]`表达式选择了索引位置`1`的项，我们得到了`33.5`值。'
- en: We can, if we want, create a fully defined, named function instead of using
    `lambda`, as shown in the following code
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，可以创建一个完全定义的、命名的函数而不是使用`lambda`，如下面的代码所示
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A named function has two advantages: it has a name, and it can have multiple
    lines of code. A `lambda` function has the advantage of being tiny when the entire
    function can be reduced to a single expression.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数有两个优点：它有一个名称，并且可以有多个代码行。`lambda`函数的优点是当整个函数可以简化为一个表达式时，它非常小巧。
- en: 'We can use this technique to sort these two-tuples with a function instead
    of `lambda`, as shown in the following code snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种技术使用函数而不是`lambda`来对这些双元组进行排序，如下面的代码片段所示：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We used a separate function to create a sorted copy of a sequence. The `sorted()`
    function requires an iterable item (the `year_cheese` list in this case) and a
    key function; it creates a new list from the old sequence that is sorted into
    order by the key function. In this case, our key function is the named function,
    `by_weight()`. Unlike the `list.sort()` method, the `sorted()` function does not
    modify the original sequence; the new list contains references to the original
    items.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个单独的函数来创建序列的排序副本。`sorted()`函数需要一个可迭代的项（在这种情况下是`year_cheese`列表）和一个键函数；它从旧序列中创建一个新的列表，该列表根据键函数排序。在这种情况下，我们的键函数是命名函数`by_weight()`。与`list.sort()`方法不同，`sorted()`函数不会修改原始序列；新列表包含对原始项的引用。
- en: Using generator expressions with list of tuples
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用元组列表的生成器表达式
- en: 'If we want to locate cheese production for a given year, we need to search
    this sequence of two-tuples for the matching year. We can''t simply use the `list.index()`
    function to locate an item, as we''re only using part of the item. One strategy
    is to extract the year from the list using a generator expression, as shown in
    the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要定位给定年份的奶酪生产，我们需要在这个双元组序列中搜索匹配的年份。我们不能简单地使用`list.index()`函数来定位项，因为我们只使用了项的一部分。一种策略是使用生成器表达式从列表中提取年份，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `item[0] for item in year_cheese` expression is a generator. It iterates
    through the `year_cheese` list, assigning each item to the variable named `item`.
    The `item[0]` subexpression is evaluated for each value of `item`. This will decompose
    the two-tuples, returning a single value from each tuple. The result is collected
    into a resulting list and assigned to the `years` variable. We'll return to this
    in the *Transforming sequences with generator functions* section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`item[0] for item in year_cheese`表达式是一个生成器。它遍历`year_cheese`列表，将每个项分配给名为`item`的变量。`item[0]`子表达式对每个`item`的值进行评估。这将分解双元组，从每个元组中返回一个值。结果收集到一个结果列表中，并分配给`years`变量。我们将在*使用生成器函数转换序列*部分回到这一点。'
- en: 'We can then use `years.index(2005)` to get the index for a given year, as shown
    in the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`years.index(2005)`来获取给定年份的索引，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As `years.index(2005)` gives us the position of a given year, we can use `year_cheese[
    years.index( 2005 ) ]` to get the `year-cheese` two-tuple for the year 2005.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`years.index(2005)`给出了给定年份的位置，我们可以使用`year_cheese[ years.index(2005) ]`来获取2005年的`year-cheese`双元组。
- en: This idea of mapping from year to cheese consumption is directly implemented
    by a Python dictionary.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将年份到奶酪消费的映射这一想法直接通过Python字典实现。
- en: The `in` operator and other comparison operators work for tuples in the same
    way they work for lists. They compare the target tuple to each tuple in the list
    using a simple item-by-item comparison between the items in the tuples.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符和其他比较运算符在元组上的工作方式与在列表上相同。它们通过在元组中的项之间进行简单的逐项比较，将目标元组与列表中的每个元组进行比较。'
- en: Using a Python dictionary mapping
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python字典映射
- en: A dictionary contains a mapping from keys to values. The Python dictionary class
    can be summarized as a mutable mapping. Mutability means that we can add, change,
    and remove items. Mapping means that the values are accessed based on their keys.
    Order is not preserved in a mapping.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 字典包含从键到值的映射。Python字典类可以概括为可变映射。可变性意味着我们可以添加、更改和删除项。映射意味着值是根据它们的键访问的。映射中不保留顺序。
- en: 'The syntax is pleasantly simple: we put the key-value pairs in `{}`, separate
    the key from the value with `:`, and separate the pairs with `,`. The values can
    be any kind of Python object. The keys, however, suffer from a restriction—they
    must be immutable objects. As strings and numbers are immutable, they make perfect
    keys. A tuple is immutable and a good key. A list is mutable though, and can''t
    be used as a key.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 语法简单愉快：我们在`{}`中放置键值对，用`:`将键与值分开，并用`,`将键值对分开。值可以是任何类型的Python对象。然而，键受到限制——它们必须是不可变对象。由于字符串和数字是不可变的，它们是完美的键。元组是不可变的，是一个好的键。列表是可变的，不能用作键。
- en: 'When we looked at creating an HTTP form data, in the *Getting more RESTful
    data* section, we used a mapping from field name to field value. We got back a
    response, which was a mapping from keys to values. The response looked like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看创建HTTP表单数据时，在*获取更多RESTful数据*部分，我们使用了从字段名到字段值的映射。我们得到了一个响应，它是一个从键到值的映射。响应看起来像这样：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: After creating the `spot_rate` dictionary, we used the `dict[key]` syntax to
    get values of two of the keys, `currency` and `amount`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`spot_rate`字典后，我们使用了`dict[key]`语法来获取两个键的值，即`currency`和`amount`。
- en: 'As a dictionary is mutable, we can easily change the values associated with
    the keys. Here''s how we can create and modify a form:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典是可变的，我们可以轻松地更改与键关联的值。以下是创建和修改表单的方法：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We created the `form` variable as a small dictionary. We can use this to make
    one spot-rate query. We then changed the value in the `form` dictionary. We can
    use this updated form to make a second spot-rate query.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`form`变量作为一个小的字典。我们可以使用这个字典来执行一个现货价格查询。然后我们更改了`form`字典中的值。我们可以使用这个更新的表单来执行第二个现货价格查询。
- en: 'When getting a value, the key must exist; otherwise, we''ll get an exception.
    As noted earlier, we can also use `dict.get(key, default)` to get values when
    a key might not exist in the dictionary. Here are several examples:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取值时，键必须存在；否则，我们会得到一个异常。如前所述，我们还可以使用`dict.get(key, default)`在键可能不在字典中时获取值。以下是一些示例：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we fetched the value mapped to the `currency` key. We tried to fetch
    a value mapped to the `oops` key. We got a `KeyError` exception because the `oops`
    key isn't in the `spot_rate` dictionary.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取了映射到`currency`键的值。我们尝试获取映射到`oops`键的值。我们得到了一个`KeyError`异常，因为`oops`键不在`spot_rate`字典中。
- en: We did the same kinds of things using the `get()` method. When we executed `spot_rate.get('amount')`,
    the key-value pair existed, so the value was returned.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`get()`方法做了同样的事情。当我们执行`spot_rate.get('amount')`时，键值对存在，因此返回了值。
- en: 'When we executed `spot_rate.get(''oops'')`, the key didn''t exist; the default
    return value was `None`. Python doesn''t print `None` values, so we don''t see
    any obvious result from this. When we executed `spot_rate.get(''oops'', ''#Missing'')`,
    we provided a return value that is not `None`, which displayed something visible.
    The idea is that we can then do things like this to make a series of related queries:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`spot_rate.get('oops')`时，键不存在；默认返回值是`None`。Python不打印`None`值，所以我们看不到任何明显的结果。当我们执行`spot_rate.get('oops',
    '#Missing')`时，我们提供了一个不是`None`的返回值，这显示了某些可见的内容。这个想法是，然后我们可以这样做来进行一系列相关的查询：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `for` statement includes a tuple of values: `''USD'', ''EUR'', ''UAH''`.
    We aren''t required to put `()` around the tuple in this particular case because
    the syntax is unambiguous.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句包含一个值元组：`''USD'', ''EUR'', ''UAH''`。在这种情况下，我们不需要在元组周围放置`()`，因为语法是明确的。'
- en: Each value from the literal tuple is used to set the `currency` value in the
    form. We can then use the `urllib.parse.urlencode()` function to build a query
    string. We might be using this in a `urllib.urlopen()` function to get a current
    spot price for bitcoins in that currency.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从字面元组中获取的每个值都用于设置表单中的`货币`值。然后我们可以使用`urllib.parse.urlencode()`函数构建查询字符串。我们可能会在`urllib.urlopen()`函数中使用它来获取该货币的比特币当前现货价格。
- en: Using the dictionary access methods
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字典访问方法
- en: 'Other interesting methods of a dictionary mapping include the `keys()`, `values()`,
    and `items()` methods. Here are some examples:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 字典映射的其他有趣方法包括`keys()`、`values()`和`items()`方法。以下是一些示例：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `keys()` method gave us a `dict_keys` object, which contains just the keys
    in a simple list. We can sort this list or do other processing outside the dictionary.
    Similarly, the `values()` method gave us a `dict_values` object, which contains
    just the values in a simple list.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys()`方法给了我们一个`dict_keys`对象，它只包含一个简单的列表中的键。我们可以对这个列表进行排序或对字典外的其他数据进行处理。同样，`values()`方法给了我们一个`dict_values`对象，它只包含一个简单的列表中的值。'
- en: 'The `items()` method gave us a sequence of two-tuples, as shown in the following
    code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`items()`方法给了我们一个由两个元组组成的序列，如下面的代码所示：'
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We created the `rate_as_list` variable from the `spot_rate.items()` list of
    two-tuples. We can easily convert a list of two-tuple to a dictionary using the
    `dict()` function and vice versa, as shown in the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`spot_rate.items()`的二元组列表中创建了`rate_as_list`变量。我们可以很容易地使用`dict()`函数将二元组列表转换为字典，反之亦然，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This gives us a way to deal with the 161 currencies. We'll look at this in the
    next section, *Transforming sequences with generator functions*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们处理161种货币提供了一种方法。我们将在下一节*使用生成器函数转换序列*中探讨这一点。
- en: 'Note that the `in` operator works against the dictionary keys, not the values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`in`运算符作用于字典的键，而不是值：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `currency` key exists in the `spot_rate` dictionary. The `USD` value is
    not checked by the `in` operator. If we''re looking for a specific value, we have
    to use the `values()` method explicitly:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`currency`键存在于`spot_rate`字典中。`USD`值没有被`in`运算符检查。如果我们正在寻找特定的值，我们必须显式地使用`values()`方法：'
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Other comparison operators don't really make sense for a dictionary. It's essential
    to explicitly compare a dictionary's keys, values, or items.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 其他比较运算符对于字典来说实际上没有意义。显式地比较字典的键、值或项是至关重要的。
- en: Transforming sequences with generator functions
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用生成器函数转换序列
- en: 'The data at [http://www.coinbase.com/api/v1/currencies/](http://www.coinbase.com/api/v1/currencies/),
    which was a RESTful request, was a giant list of lists. It started like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.coinbase.com/api/v1/currencies/](http://www.coinbase.com/api/v1/currencies/)上的数据，这是一个RESTful请求，是一个巨大的列表的列表。它开始如下所示：'
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we apply the `dict()` function to this list of lists, we''ll build a dictionary.
    However, this dictionary isn''t what we want; the following code is how it looks:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`dict()`函数应用于这个列表的列表，我们将构建一个字典。然而，这个字典并不是我们想要的；以下是如何显示它的代码：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The keys in this dictionary are long `country currency (code)` strings. The
    values are the three-letter currency code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典中的键是长的`country currency (code)`字符串。值是三位货币代码。
- en: 'We might want the keys of this as a handy lookup table for a person''s reference
    to track down the proper currency for a given country. We might use something
    like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望将这个列表的键作为方便的查找表，供个人参考以追踪特定国家的适当货币。我们可能使用如下所示的方法：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This shows how we can create a dictionary from a list of lists and then extract
    just the `keys()` from this dictionary. This is, in a way, an excessive amount
    of processing for a simple result.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何从一个列表的列表创建一个字典，然后从这个字典中提取`keys()`。从某种意义上说，这是对简单结果进行过度处理。
- en: 'We showed an example of picking up some data using a generator function in
    the *Using a Python tuple* section. Here''s how we''d apply it to this problem.
    We''ll create a list comprehension using a generator function. The generator,
    surrounded by `[]`, will lead to a new list object, as shown in the following
    code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*使用Python元组*部分展示了使用生成器函数获取一些数据的例子。以下是我们将如何应用这个问题的解决方案。我们将使用生成器函数创建一个列表推导式。被`[]`包围的生成器将导致一个新的列表对象，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `currencies` object is the original list of lists. The real one has 161
    items; we're working with a piece of it here to keep the output small.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`currencies`对象是原始的列表的列表。实际上有161个项目；我们在这里处理的是其中的一部分，以保持输出的小型化。'
- en: 'The generator expression has three clauses. These are *subexpressions* for
    *targets* in *source*. The `[]` characters are separate punctuations used to create
    a list objects from the generated values; they''re not part of the generator expression
    itself. The *subexpression* is evaluated for each target value. The *target* variable
    is assigned to each element from the *source* iterable object. Each two-tuple
    from the currencies list is assigned to the `name` and `code` target variables.
    The subexpression is just `name`. We can use this to build a dictionary from currency
    to full name:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式有三个子句。这些是针对源中的目标的子表达式。`[]`字符是用于从生成的值创建列表对象的分隔符号；它们本身不是生成器表达式的一部分。子表达式为每个目标值进行评估。目标变量被分配给源可迭代对象中的每个元素。货币列表中的每个二元组被分配给`name`和`code`目标变量。子表达式只是`name`。我们可以用这个来从货币到全名构建一个字典：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We used a generator function to swap the two elements of each item of the currency
    list. The targets were `name` and `code`; the resulting subexpression is the `(code,name)`
    two-tuple. We built a dictionary from this; this dictionary maps currency codes
    to country names.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用生成器函数来交换货币列表中每个项目的两个元素。目标是`name`和`code`；结果子表达式是`(code,name)`二元组。我们从这个构建了一个字典；这个字典将货币代码映射到国家名称。
- en: Using the defaultdict and counter mappings
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`defaultdict`和`Counter`映射
- en: There are a number of sophisticated mappings that are part of the standard library.
    Two of these are the `defaultdict` and `Counter` mappings. The `defaultdict` allows
    us to work more flexibly with keys that don't exist.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中包含许多复杂的映射。其中两个是`defaultdict`和`Counter`映射。`defaultdict`允许我们更灵活地处理不存在的键。
- en: Let's look at the word corpus we used to recover a ZIP file password. We can
    use this word corpus for other purposes. One of the things that can help the crypto
    department decode messages is knowledge of two-letter sequences (`digram` or `bigram`)
    that occur commonly in the source documents.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们用来恢复ZIP文件密码的单词`corpus`。我们可以用这个单词`corpus`用于其他目的。可以帮助加密部门解码消息的事情之一是了解在源文档中经常出现的双字母序列（`digram`或`bigram`）。
- en: 'What are the most common two-letter digrams in English? We can easily gather
    this from our dictionary, as shown in the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 英语中最常见的两个字母的字母组合是什么？我们可以很容易地从我们的字典中收集这些信息，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We need to import the `defaultdict` class from the `collections` module because
    it's not built in. We created an empty `defaultdict` object, `digram_count`, using
    `int` as the initialization function. The initialization function handles missing
    keys; we'll look at the details in the following section.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`collections`模块导入`defaultdict`类，因为它不是内置的。我们使用`int`作为初始化函数创建了一个空的`defaultdict`对象，名为`digram_count`。初始化函数处理缺失的键；我们将在下一节中查看细节。
- en: We opened our word `corpus`. We iterated through each line in `corpus`. We transformed
    each line into a word by stripping the trailing spaces and mapping it to lowercase.
    We used the `range()` function to generate a sequence of positions from zero to
    one less than the length of the word (`len(word)-1`). We can pluck a two-character
    digram from each word using the `word[position:position+2]` slice notation.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了我们的单词`corpus`。我们遍历`corpus`中的每一行。我们将每一行转换为一个单词，通过删除尾随空格并将其映射为小写。我们使用`range()`函数生成一个从零到单词长度减一的序列（`len(word)-1`）。我们可以使用`word[position:position+2]`切片符号从每个单词中提取一个双字符字母组合。
- en: 'When we evaluate `digram_count[digram]`, one of two things will happen:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`digram_count[digram]`时，会发生以下两种情况之一：
- en: If the key exists in the mapping, the value is returned, just like any ordinary
    dictionary. We can then add one to the value that is returned, thus updating the
    dictionary.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键存在于映射中，则返回值，就像任何普通字典一样。然后我们可以将返回的值加一，从而更新字典。
- en: If the key does not exist in this mapping, then the initialization function
    is evaluated to create a default value. The value of `int()` is `0`, which is
    ideal to count things. We can then add `1` to this value and update the dictionary.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键不存在于这个映射中，那么初始化函数将被评估以创建一个默认值。`int()`的值是`0`，这对于计数事物来说很理想。然后我们可以将`1`加到这个值上并更新字典。
- en: The cool feature of a `defaultdict` class is that no exception is raised for
    a missing key value. Instead of raising an exception, the initialization function
    is used.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`类的酷特性是，对于缺失的键值不会引发异常。而不是引发异常，使用初始化函数。'
- en: 'This `defaultdict(int)` class is so common that we can use the `Counter` class
    definition for this. We can make two tiny changes to the previous example. The
    first change is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`defaultdict(int)`类非常常见，我们可以使用`Counter`类定义来使用它。我们可以对前面的例子进行两个微小的更改。第一个更改如下：
- en: '[PRE55]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The second change is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更改如下：
- en: '[PRE56]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The reason for making this change is that `Counter` classes do some additional
    things. In particular, we often want to know the most common counts, as shown
    in the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这种更改的原因是`Counter`类执行一些附加操作。特别是，我们经常想知道最常见的计数，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `most_common()` method of a `Counter` object returns the counts in the descending
    order. This shows us that `er` is the most common English-language digram. This
    information might help the decoders back at HQ.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`对象的`most_common()`方法按降序返回计数。这表明`er`是最常见的英语双字母组合。这些信息可能有助于总部解码器。'
- en: Using a Python set
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python集合
- en: The Python set class is mutable; we can add, change, and remove items. Items
    are either present or absent. We don't use positions or keys; we merely add, remove,
    or test the items. This means that sets have no inherent order.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Python的集合类是可变的；我们可以添加、更改和删除项目。项目要么存在，要么不存在。我们不使用位置或键；我们只是添加、删除或测试项目。这意味着集合没有固有的顺序。
- en: The syntax is pleasantly simple; we put the data items in `{}` and separated
    the items with `,`. We can use any immutable Python objects in the set. It's important
    to note that the items must be immutable—we can include strings, numbers, and
    tuples. We can't include a list or dictionary in a set.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 语法简单明了；我们将数据项放在`{}`中，并用逗号`,`分隔项。我们可以使用任何不可变Python对象在集合中。重要的是要注意，项目必须是不可变的——我们可以包括字符串、数字和元组。我们不能在集合中包含列表或字典。
- en: As the `{}` characters are used both by dictionaries and sets, it's unclear
    what the empty pair, `{}`, means. Is this an empty dictionary or an empty set?
    It's much more clear if we use `dict()` to mean an empty dictionary and `set()`
    to mean an empty set.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大括号`{}`字符既用于字典也用于集合，因此空对大括号`{}`的含义不清楚。这是空字典还是空集合？如果我们用`dict()`表示空字典，用`set()`表示空集合，那就更清晰了。
- en: A set is a simple collection of things; it is perhaps the simplest possible
    collection of things.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是事物的一个简单集合；它可能是可能的最简单的事物集合。
- en: 'In looking at the digrams, we noticed that there were some digrams, including
    a `-` character. How many hyphenated words are in the dictionary? This is a simple
    set processing example:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看双字母组合时，我们注意到有一些双字母组合，包括连字符`-`字符。字典中有多少个带连字符的单词？这是一个简单的集合处理示例：
- en: '[PRE58]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We created an empty set and assigned it to the `hyphenated` variable. We checked
    each word in our collection of words to see if the `-` character is in the collection
    of characters. If we find the hyphen, we can add this word to our set of hyphenated
    words.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个空集合并将其赋值给`hyphenated`变量。我们检查我们的单词集合中的每个单词，看`-`字符是否在字符集合中。如果我们找到连字符，我们可以将这个单词添加到我们的连字符单词集合中。
- en: The word corpus on the author's computer had two hyphenated words. This raises
    more questions than it answers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 作者电脑上的单词“corpus”有两个带连字符的单词。这提出了比它回答的问题更多的问题。
- en: The `in` operator is essential for working with sets. The comparison operators
    implement subset and superset comparisons between two sets. The `a <= b` operation
    asks if `a` is a subset of `b`, mathematically, ![Using a Python set](img/0420OS_02_03.jpg).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符对于处理集合是必不可少的。比较运算符实现了两个集合之间的子集和超集比较。`a <= b`操作询问`a`是否是`b`的子集，从数学上讲，![使用Python集合](img/0420OS_02_03.jpg)。'
- en: Using the for statement with a collection
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用for语句与集合一起使用
- en: 'The `for` statement is the primary tool to iterate through the items in a collection.
    When working with lists, tuples, or sets, the `for` statement will pleasantly
    assure that all values in the collection are assigned to the target variable,
    one at a time. Something like this works out nicely:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句是遍历集合中项的主要工具。当与列表、元组或集合一起使用时，`for`语句将愉快地确保将集合中的所有值逐个分配给目标变量。如下所示的工作效果很好：'
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `for` statement assigns each item in the cheese sequence to the target variable.
    We simply print each value from the collection.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句将奶酪序列中的每个项分配给目标变量。我们只需简单地从集合中打印每个值。'
- en: 'When working with the list-of-tuples structures, we can do something a bit
    more interesting, as shown in the following code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理元组列表结构时，我们可以做一些更有趣的事情，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, each two-tuple was decomposed, and the two values were assigned
    to the target variables, `year` and `pounds`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个二元组都被分解，两个值被分配给目标变量，`year`和`pounds`。
- en: 'We can leverage this when transforming a `Count` object into percentages. Let''s
    look at our `digram_count` collection:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一点将`Count`对象转换为百分比。让我们看看我们的`digram_count`集合：
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: First, we computed the sum of the values in the collection. This is the total
    number of digrams found in the original corpus. In this example, it was 2,021,337\.
    Different corpora will have different numbers of digrams.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算了集合中值的总和。这是在原始语料库中找到的双元组的总数。在这个例子中，它是2,021,337。不同的语料库将会有不同数量的双元组。
- en: 'The `for` statement iterates through the sequence created by `digram_count.items()`.
    The `items()` method produces a sequence of two-tuples with the key and value.
    We assign these to two target variables: `digram` and `count`. We can then produce
    a nicely formatted table of all 620 digrams, their counts, and their relative
    frequency.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句遍历由`digram_count.items()`创建的序列。`items()`方法产生一个包含键和值的二元组的序列。我们将这些分配给两个目标变量：`digram`和`count`。然后我们可以生成一个包含所有620个双元组、它们的计数和它们相对频率的格式化表格。'
- en: This is the kind of thing that the folks in the crypto department love.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是加密部门的人喜欢的那种事情。
- en: 'When we apply the `for` statement to a dictionary directly, it iterates just
    over the keys. We could use something like this to iterate through the digram
    counts:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`for`语句直接应用于字典时，它仅遍历键。我们可以使用类似的方法遍历双元组计数：
- en: '[PRE62]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The target variable, `digram`, is assigned to each key. We can then use a syntax
    such as `digram_count[digram]` to extract the value for this key.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 目标变量`digram`被分配给每个键。然后我们可以使用如`digram_count[digram]`这样的语法来提取这个键的值。
- en: Using Python operators on collections
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python运算符在集合上操作
- en: 'Some of the mathematical operators work with collections. We can use the `+`
    and `*` operators with sequences such as lists and tuples, as shown in the following
    code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数学运算符可以与集合一起使用。我们可以使用`+`和`*`运算符与列表和元组等序列一起使用，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: These examples showed how we can concatenate two lists and multiply a list to
    create a longer list with multiple copies of the original list. The `[0]*10` statement
    shows a more useful technique to initialize a list to a fixed number of values.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了我们如何连接两个列表并将一个列表乘以创建一个包含原始列表多个副本的长列表。`[0]*10`语句显示了一种更有用的技术，可以初始化一个具有固定数量值的列表。
- en: 'Sets have a number of operators for union (`|`), intersection (`&`), difference
    (`-`), and symmetric difference (`^`). Also, the comparison operators are redefined
    to work as subset or superset comparisons. Here are some examples:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 集合有用于并集（`|`）、交集（`&`）、差集（`-`）和对称差集（`^`）的运算符。此外，比较运算符被重新定义以作为子集或超集比较。以下是一些示例：
- en: '[PRE64]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The union operator, `|`, combines the two sets. A set means an element only
    occurs once, so there are no duplicated elements in the union of the sets. The
    intersection of two sets, `&`, is the set of common elements in the two sets.
    The subtraction operator, `-`, removes elements from the set on the left-hand
    side. The symmetric difference operator, `^`, creates a new set that has elements
    which are in one or the other set but not both; essentially, it is the same as
    an exclusive `OR`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 并集运算符`|`将两个集合合并。集合意味着一个元素只出现一次，所以在集合的并集中没有重复的元素。两个集合的交集`&`是两个集合中共同元素的集合。减法运算符`-`从左侧集合中删除元素。对称差集运算符`^`创建一个新的集合，该集合包含一个或另一个集合中的元素，但不包含两者；本质上，它与排他`OR`相同。
- en: We showed just one comparison operator, the `<=` subset operator, between two
    sets. The other comparison operators perform just as can be expected.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只展示了两个集合之间的一个比较运算符，即`<=`子集运算符。其他比较运算符的表现正如预期的那样。
- en: Solving problems – currency conversion rates
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决问题——货币转换率
- en: The problem we have is that our informants are always asking for odd or unusual
    currencies. This isn't really all that surprising; we're dealing with spies and
    criminals on the run. They always seem to need obscure foreign currencies for
    their own nefarious projects.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的问题是我们的信息提供者总是要求奇数或非同寻常的货币。这并不真的那么令人惊讶；我们正在处理逃犯和罪犯。他们似乎总是需要不为人知的国外货币来完成他们自己的邪恶项目。
- en: 'We can get a big pile of international exchange rates using a piece of code
    like the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用如下代码获取一大堆国际汇率：
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The query string is a simple URL. When we make the request, we get back a long
    string of bytes. We decode this to make a proper string and use `json.loads()`
    to build a Python object.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串是一个简单的URL。当我们发出请求时，我们得到一个长的字节字符串。我们将其解码以生成正确的字符串，并使用`json.loads()`构建Python对象。
- en: 'The problem is that we get a giant dictionary object that''s not really all
    that useful. It looks like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们得到了一个巨大的字典对象，实际上并不那么有用。它看起来像这样：
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Also, it goes on and on for 632 different combinations of currencies.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它有632种不同的货币组合。
- en: The keys to this mapping involve two currencies separated by `_to_` and written
    in lowercase letters. The currency code pieces that we got in the earlier example
    (see the *Using a REST API in Python* section) are in uppercase. We got a bit
    of work on our hands to match this data up properly.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此映射的键涉及两个由`_to_`分隔的小写字母的货币。我们在早期示例中获得的货币代码（见*使用Python中的REST API*部分）是大写的。我们需要做一些工作来正确匹配这些数据。
- en: 'We need to break this long list of currencies down into sublists. The neat
    way to handle this is with a dictionary of lists. We can use the `defaultdict`
    class to build these lists. Here''s a typical approach:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这个长长的货币列表分解成子列表。处理这种方式的整洁方法是使用列表的字典。我们可以使用`defaultdict`类来构建这些列表。以下是一个典型的方法：
- en: '[PRE67]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We set the `rates` variable to be a `defaultdict(list)` object. When a key is
    not found in this dictionary, an empty list will be built as the value for that
    missing key.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`rates`变量设置为`defaultdict(list)`对象。当在这个字典中找不到键时，将为该缺失键构建一个空列表作为值。
- en: We can iterate through each conversion and rate in the `items()` method of the
    raw data. We'll convert the conversion string to uppercase and then partition
    the conversion on the `_TO_` string. This will separate the two currency codes,
    assigning them to `source` and `target`. As they're uppercase, we can also match
    them against our list of currency-to-country codes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历原始数据中的每个转换和汇率。我们将转换字符串转换为大写，然后根据`_TO_`字符串对转换进行分区。这将分离两个货币代码，将它们分配给`source`和`target`。由于它们是大写的，我们还可以将它们与我们的货币到国家代码列表相匹配。
- en: We also converted the rate from a string to a more useful `float` number. The
    string isn't useful for further calculations.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将汇率从字符串转换为更有用的`float`数字。字符串对进一步计算没有用。
- en: We can then accumulate a list for each currency within the `rates` dictionary.
    If the `source` currency exists, we'll append it to the list that's already present
    in the dictionary. If the `source` currency doesn't exist, we'll create an empty
    list and append it to that empty list.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`rates`字典中为每种货币累积一个列表。如果`source`货币存在，我们将将其追加到字典中已经存在的列表中。如果`source`货币不存在，我们将创建一个空列表并将其追加到该空列表中。
- en: We'll append a target currency and the conversion rate as a simple two-tuple.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将目标货币和转换率作为一个简单的二元组追加。
- en: 'When we''re done, we''ll have tidy, short lists. Here''s how we can pick a
    few currencies and display the conversions:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将拥有整洁、简短的列表。以下是我们可以选择一些货币并显示转换的方法：
- en: '[PRE68]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: For a select few currencies, we printed the currency and the list of conversion
    rates available right now.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于少数几种货币，我们打印了货币和当前可用的转换率列表。
- en: 'This shows us results like the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了以下结果：
- en: '[PRE69]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `USD` list is rather large, as it includes 159 other countries and currencies.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`USD`列表相当大，因为它包括了159个其他国家和货币。'
- en: 'As we got the currency details from our earlier query, we can do this to make
    our output a little more useful:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的查询中获取了货币详情后，我们可以这样做，使我们的输出更有用：
- en: '[PRE70]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We built a dictionary that maps a currency code to the full name for the currency.
    When we look up the details for a currency, our output looks a little nicer, as
    shown in the following snippet:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个将货币代码映射到货币全名的字典。当我们查找货币的详细信息时，我们的输出看起来更美观，如下面的片段所示：
- en: '[PRE71]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is the kind of thing that can help us convert the bribe amounts into budget
    numbers that the accountants at HQ will find useful. We can also use this information
    to send national assessments based on the value of the local currency.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这类东西可以帮助我们将贿赂金额转换为总部会计会发现有用的预算数字。我们还可以使用这些信息根据当地货币的价值发送国家评估。
- en: Also, we can use this for our own purposes to buy and sell bitcoins. This might
    help keep us one step ahead of international chaos. Alternatively, it may help
    us leverage the advantages of crypto currency.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以为此目的购买和出售比特币。这可能会帮助我们领先一步，避免国际混乱。或者，它可能有助于我们利用加密货币的优势。
- en: We can save our currency details to a file using `json.dump(currency_details,
    some_open_file)`. See the example in the *Saving our data via JSON* section for
    a refresher on how this is done.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `json.dump(currency_details, some_open_file)` 将我们的货币详细信息保存到文件中。参见“通过
    JSON 保存我们的数据”部分中的示例，以刷新如何执行此操作的方法。
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw the basics of using Python to access data available
    on the WWW. We used the HTTP protocol and the FTP protocol to transfer files around.
    We can use HTTPS and FTPS to assure that our data is kept secret.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了使用 Python 访问万维网上可用的数据的基本方法。我们使用了 HTTP 协议和 FTP 协议来传输文件。我们可以使用 HTTPS
    和 FTPS 来确保我们的数据保持机密。
- en: We looked at using RESTful web services to gather data from information sources
    that have a defined API. RESTful web services are available for many kinds of
    data. They allow us to gather and analyze data from a variety of sources without
    a lot of tedious, error-prone pointing and clicking.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何使用 RESTful 网络服务从具有定义好的 API 的信息源收集数据。许多类型的数据都提供了 RESTful 网络服务。它们使我们能够从各种来源收集和分析数据，而无需进行大量繁琐且容易出错的点击操作。
- en: 'We also saw how to work with the various Python collections: lists, tuples,
    dictionaries, and sets. This gives us ways to capture and manage larger collections
    of information.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了如何处理各种 Python 集合：列表、元组、字典和集合。这为我们提供了捕获和管理大量信息集合的方法。
- en: We looked at the JSON notation for Python objects. This is a handy way to transmit
    objects through the WWW. It's also handy for saving objects locally on our personal
    computer.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了 Python 对象的 JSON 表示法。这是一种方便的方法，可以通过万维网传输对象。它也便于在我们个人电脑上本地保存对象。
- en: In the next chapter, we'll look at how we can work with image files. These are
    a bit more complex than JSON files, but the Python `pillow` package makes them
    easy to work with. We'll specifically use image files as a way to transmit hidden
    messages.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何处理图像文件。这些文件比 JSON 文件复杂一些，但 Python 的 `pillow` 包使得它们易于处理。我们将特别使用图像文件作为传输隐藏信息的方式。
- en: In [Chapter 4](ch04.html "Chapter 4. Drops, Hideouts, Meetups, and Lairs"),
    *Drops, Hideouts, Meetups, and Lairs*, we'll expand on the web services we saw
    in this chapter. We'll use geocoding web services and extract data from more complex
    online datasets.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](ch04.html "第 4 章。水坑、藏身之处、聚会和巢穴")“水坑、藏身之处、聚会和巢穴”中，我们将扩展本章中看到的网络服务。我们将使用地理编码网络服务并从更复杂的在线数据集中提取数据。
