- en: Concurrent Image Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发图像处理
- en: This chapter analyzes the process of processing and manipulating images through
    concurrent programming, especially multiprocessing. Since images are processed
    independently of one another, concurrent programming can provide image processing
    with a significant speedup. This chapter discusses the basics behind image processing
    techniques, illustrates the improvements that concurrent programming provides,
    and finally, goes over some of the best practices used in image processing applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分析了通过并发编程，特别是多进程处理图像的处理和操作过程。由于图像是相互独立处理的，因此并发编程可以显著加快图像处理的速度。本章讨论了图像处理技术背后的基础知识，说明了并发编程提供的改进，并最终总结了图像处理应用中使用的一些最佳实践。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The idea behind image processing and a number of basic techniques in image processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理背后的理念和一些基本的图像处理技术
- en: How to apply concurrency to image processing, and how to analyze the improvements
    it provides
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将并发应用于图像处理，以及如何分析它提供的改进
- en: Best practices in concurrent image processing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发图像处理的最佳实践
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Following is a list of prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的先决条件列表：
- en: You must have Python 3 installed on your computer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须在计算机上安装Python 3
- en: You must have OpenCV and NumPy installed for your Python 3 distribution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须为您的Python 3发行版安装OpenCV和NumPy
- en: Download the GitHub repository from [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)下载GitHub存储库
- en: During this chapter, we will be working with the subfolder named `Chapter08`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用名为`Chapter08`的子文件夹
- en: Check out the following video to see the Code in Action: [http://bit.ly/2R8ydN8](http://bit.ly/2R8ydN8)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际运行情况：[http://bit.ly/2R8ydN8](http://bit.ly/2R8ydN8)
- en: Image processing fundamentals
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像处理基础知识
- en: Digital/computational image processing (which we will refer to simply as image
    processing from this point forward) has become so popular in the modern era that
    it exists in numerous aspects in our everyday life. Image processing and manipulation
    is involved when you take a picture with your camera or phone using different
    filters, or when advanced image editing software such as Adobe Photoshop is used,
    or even when you simply edit images using Microsoft Paint.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数字/计算图像处理（我们将在此后简称为图像处理）在现代时代变得如此受欢迎，以至于它存在于我们日常生活的许多方面。当您使用不同的滤镜使用相机或手机拍照时，涉及图像处理和操作，或者使用Adobe
    Photoshop等高级图像编辑软件时，甚至只是使用Microsoft Paint编辑图像时。
- en: Many of the techniques and algorithms used in image processing were developed
    in the early 1960s for various purposes such as medical imaging, satellite image
    analysis, character recognition, and so on. However, these image processing techniques
    required significant computing power, and the fact that the available computer
    equipment at the time was unable to accommodate the need for fast number-crunching
    slowed down the use of image processing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理中使用的许多技术和算法是在1960年代初为各种目的开发的，如医学成像、卫星图像分析、字符识别等。然而，这些图像处理技术需要大量的计算能力，当时可用的计算机设备无法满足快速计算的需求，这减缓了图像处理的使用。
- en: 'Fast-forwarding to the future, where powerful computers with fast, multicore
    processors were developed, image processing techniques consequently became much
    more accessible, and research on image processing increased significantly. Nowadays,
    numerous image processing applications are being actively developed and studied,
    including pattern recognition, classification, feature extraction, and so on.
    Specific image processing techniques, which take advantage of concurrent and parallel
    programming and would otherwise be extremely computationally time-consuming, include
    Hidden Markov models, independent component analysis, and even up-and-coming neural
    network models:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到未来，在那里拥有快速、多核处理器的强大计算机被开发出来，图像处理技术因此变得更加易于访问，并且图像处理的研究显著增加。如今，正在积极开发和研究许多图像处理应用，包括模式识别、分类、特征提取等。利用并发和并行编程的特定图像处理技术，否则将极其耗时的包括隐马尔可夫模型、独立成分分析，甚至新兴的神经网络模型：
- en: '![](assets/619ce7a1-3a6b-467e-ba32-3488783b8719.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/619ce7a1-3a6b-467e-ba32-3488783b8719.png)'
- en: 'One sample use of image processing: grayscaling'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理的一个示例用途：灰度处理
- en: Python as an image processing tool
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python作为图像处理工具
- en: As we have stated multiple times throughout this book, the Python programming
    language is on its way to becoming the most popular programming language. This
    is especially true in the field of computational image processing, which, most
    of the time, requires fast prototyping and designing, and significant automation
    capabilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中多次提到的，Python编程语言正在成为最受欢迎的编程语言。这在计算图像处理领域尤其如此，大多数时候需要快速原型设计和设计，以及显著的自动化能力。
- en: As we will find out in the following section, digital images are represented
    in two-dimensional and three-dimensional matrices so that computers can process
    them easily. Consequently, most of the time, digital image processing involves
    matrix calculation. Multiple Python libraries and modules not only provide efficient
    matrix calculation options, but also interact seamlessly with other libraries
    that handle image reading/writing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节中发现的那样，数字图像以二维和三维矩阵表示，以便计算机可以轻松处理它们。因此，大多数时候，数字图像处理涉及矩阵计算。多个Python库和模块不仅提供了高效的矩阵计算选项，而且与处理图像读取/写入的其他库无缝交互。
- en: 'As we already know, automating tasks and making them concurrent are both Python''s
    strong suit. This makes Python the prime candidate to implement your image processing
    applications. For this chapter, we will be working with two main Python libraries:
    **OpenCV** (which stands for **Open Source Computer Vision**), which is a library
    that provides image processing and computer vision options in C++, Java, and Python,
    and NumPy, which, as we know, is one of the most popular Python modules and performs
    efficient and parallelizable number-crunching calculations.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，自动化任务并使其并发都是Python的强项。这使得Python成为实现图像处理应用程序的首选候选。在本章中，我们将使用两个主要的Python库：**OpenCV**（代表**开源计算机视觉**），这是一个提供C++、Java和Python图像处理和计算机视觉选项的库，以及NumPy，正如我们所知，它是最受欢迎的Python模块之一，可以执行高效和可并行化的数值计算。
- en: Installing OpenCV and NumPy
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装OpenCV和NumPy
- en: 'To install NumPy for your Python distribution using the `pip` package manager,
    run the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`pip`软件包管理器为您的Python发行版安装NumPy，请运行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If, however, you are using Anaconda/Miniconda to manage your packages, run
    the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您使用Anaconda/Miniconda来管理您的软件包，请运行以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Installing OpenCV might be more complicated, depending on your operating system.
    The easiest option is to have Anaconda handle the installation process by following
    this guide ([https://anaconda.org/conda-forge/opencv](https://anaconda.org/conda-forge/opencv))
    after installing Anaconda ([https://www.anaconda.com/download/](https://www.anaconda.com/download/))
    as your main Python package manager. If, however, you are not using Anaconda,
    the main option for installing OpenCV is to follow its official documentation
    guide, which can be found at [https://docs.opencv.org/master/df/d65/tutorial_table_of_content_introduction.html](https://docs.opencv.org/master/df/d65/tutorial_table_of_content_introduction.html).
    After successfully installing OpenCV, open a Python interpreter and try importing
    the library, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 安装OpenCV可能更复杂，这取决于您的操作系统。最简单的选择是使用Anaconda处理安装过程，按照此指南进行操作（[https://anaconda.org/conda-forge/opencv](https://anaconda.org/conda-forge/opencv)），在安装Anaconda（[https://www.anaconda.com/download/](https://www.anaconda.com/download/)）后作为您的主要Python包管理器。然而，如果您没有使用Anaconda，安装OpenCV的主要选项是按照其官方文档指南进行操作，该指南可以在[https://docs.opencv.org/master/df/d65/tutorial_table_of_content_introduction.html](https://docs.opencv.org/master/df/d65/tutorial_table_of_content_introduction.html)找到。成功安装OpenCV后，打开Python解释器并尝试导入库，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import OpenCV using the name `cv2`, which is the library alias of OpenCV
    in Python. The success message indicates the version of my OpenCV library that
    has been downloaded (3.1.0).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用名称`cv2`导入OpenCV，这是Python中OpenCV的库别名。成功消息表示已下载的OpenCV库版本（3.1.0）。
- en: Computer image basics
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机图像基础
- en: Before we jump into processing and manipulating digital image files, we first
    need to discuss the fundamentals of those files, and how computers interpret data
    from them. Specifically, we need to understand how data regarding the colors and
    coordinates of individual pixels in an image file is represented, and how to extract
    it using Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理和操作数字图像文件之前，我们首先需要讨论这些文件的基础知识，以及计算机如何解释其中的数据。具体来说，我们需要了解图像文件中单个像素的颜色和坐标数据是如何表示的，以及如何使用Python提取它。
- en: RGB values
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RGB值
- en: RGB values are the basics of how colors are represented digitally. Standing
    for **Red**, **Green**, and **Blue**, **RGB** values are constructed from the
    fact that all colors can be generated from a specific combination of red, green,
    and blue. An RGB value therefore is a tuple of three integer numbers, each of
    which ranges from 0 (which indicates no color at all) to 255 (which indicates
    the deepest shade of that specific color).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: RGB值是数字表示颜色的基础。**红**、**绿**和**蓝**代表**RGB**值，这是因为所有颜色都可以通过红、绿和蓝的特定组合生成。因此，RGB值是由三个整数构成的元组，每个整数的取值范围从0（表示没有颜色）到255（表示该特定颜色的最深色调）。
- en: For example, the color red corresponds to the tuple (255, 0, 0); in the tuple,
    there is only the highest value for red and no value for the other colors, so
    the whole tuple represents the pure color red. Similarly, blue is represented
    by (0, 0, 255), and green is represented by (0, 255, 0). The color yellow is the
    result of mixing equal amounts of red and green, and is therefore represented
    by (255, 255, 0) (the maximum amount of red and green, with no blue). White, which
    is the combination of all three colors, is (255, 255, 255), while black, which
    is the opposite of white and therefore lacks all colors, is represented by (0,
    0, 0).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，红色对应元组（255, 0, 0）；在元组中，只有红色的最高值，其他颜色没有值，因此整个元组代表纯红色。类似地，蓝色由（0, 0, 255）表示，绿色由（0,
    255, 0）表示。黄色是将红色和绿色混合相等量得到的结果，因此由（255, 255, 0）表示（最大量的红色和绿色，没有蓝色）。白色是三种颜色的组合，为（255,
    255, 255），而黑色是白色的相反，因此缺乏所有颜色，表示为（0, 0, 0）。
- en: '![](assets/0bd643f3-32bd-4e8f-8171-1e753e515611.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0bd643f3-32bd-4e8f-8171-1e753e515611.png)'
- en: RGB values basics
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: RGB值基础
- en: Pixels and image files
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像素和图像文件
- en: 'So, an RGB value indicates a specific color, but how do we connect this to
    a computer image? If we were to view an image on our computer and try to zoom
    in as much as we can, we would observe that as we zoom in deeper and deeper, the
    image will start breaking apart into increasingly discernible colored squares—these
    squares are called pixels, which are the smallest units of color on a computer
    display or in a digital image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RGB值表示特定颜色，但我们如何将其与计算机图像连接起来呢？如果我们在计算机上查看图像并尝试尽可能放大，我们会观察到随着放大的深入，图像将开始分解为越来越可辨认的彩色方块——这些方块称为像素，在计算机显示器或数字图像中是最小的颜色单位：
- en: '![](assets/1f25d8d5-f3a4-46df-a447-c33daa714174.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1f25d8d5-f3a4-46df-a447-c33daa714174.png)'
- en: Examples of pixels in digital images
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数字图像中的像素示例
- en: A set of different pixels arranged in a tabular format (rows and columns of
    pixels) makes up a computer image. Each pixel, in turn, is an RGB value; in other
    words, a pixel is a tuple of three integers. This means that a computer image
    is simply a two-dimensional array of tuples, whose sides correspond to the size
    of the image. For example, a 128 x 128 image has 128 rows and 128 columns of RGB
    tuples for its data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以表格格式排列的一组不同像素（像素的行和列）组成了一幅计算机图像。每个像素，反过来，是一个RGB值；换句话说，一个像素是一个由三个整数组成的元组。这意味着计算机图像只是一个由元组组成的二维数组，其大小对应于图像的尺寸。例如，一个128
    x 128的图像有128行和128列的RGB元组作为其数据。
- en: Coordinates inside an image
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像内的坐标
- en: Similar to indexing for two-dimensional arrays, the coordinate for a digital
    image pixel is a pair of two integers, representing the *x*- and *y*-coordinates
    of that pixel; the *x*-coordinate indicates the pixel's location along the horizontal
    axis starting from the left, and the *y*-coordinate indicates the pixel's location
    along the vertical axis starting from the top.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与二维数组的索引类似，数字图像像素的坐标是一对整数，表示该像素的*x*和*y*坐标；*x*坐标表示像素沿水平轴从左侧开始的位置，*y*坐标表示像素沿垂直轴从顶部开始的位置。
- en: Here, we can see how heavy computational number-crunching processes are typically
    involved when it comes to image processing, as each image is a matrix of integer
    tuples. This also suggests that, with the help of the NumPy library and concurrent
    programming, we can implement significant improvements in execution time for Python
    image processing applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到在图像处理时通常涉及到大量的计算数值过程，因为每个图像都是一个整数元组的矩阵。这也表明，借助NumPy库和并发编程，我们可以在Python图像处理应用程序的执行时间上实现显著的改进。
- en: Following the convention of indexing two-dimensional arrays in NumPy, the location
    of a pixel is still a pair of integers, but the first number indicates the index
    of the row containing the pixel, which corresponds to the *y*-coordinate, and
    similarly, the second number indicates the *x*-coordinate of the pixel.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循NumPy中对二维数组进行索引的惯例，像素的位置仍然是一对整数，但第一个数字表示包含像素的行的索引，对应于*y*坐标，同样，第二个数字表示像素的*x*坐标。
- en: OpenCV API
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV API
- en: There are a surprising number of methods to read in, perform image processing,
    and display a digital image file in Python. However, OpenCV provides some of the
    easiest and most intuitive APIs to do this. One important thing to note regarding
    OpenCV is that it actually inverts RGB values to BGR values when interpreting
    its images, so instead of red, green, and blue in order, the tuples in an image
    matrix will represent blue, green, and red, in that order.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有许多方法来读取、处理图像和显示数字图像文件。然而，OpenCV提供了一些最简单和最直观的API来实现这一点。关于OpenCV的一个重要事项是，当解释其图像时，它实际上将RGB值反转为BGR值，因此在图像矩阵中，元组将表示蓝色、绿色和红色，而不是红色、绿色和蓝色。
- en: 'Let''s look at an example of interacting with OpenCV in Python. Let''s a take
    look at the `Chapter08/example1.py` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在Python中与OpenCV交互的例子。让我们来看一下`Chapter08/example1.py`文件：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a few methods from OpenCV that have been used in this script that
    we need to discuss:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中使用了一些OpenCV的方法，我们需要讨论一下：
- en: '`cv2.imread()`: This method takes in a path to an image file (common file extensions
    include `.jpeg`, `.jpg`, `.png`, and so on) and returns an image object, which,
    as we will see later, is represented by a NumPy array.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.imread()`: 这个方法接受一个图像文件的路径（常见的文件扩展名包括`.jpeg`、`.jpg`、`.png`等），并返回一个图像对象，正如我们后面将看到的，它由一个NumPy数组表示。'
- en: '`cv2.imshow()`: This method takes in a string and an image object and displays
    it in a separate window. The title of the window is specified by the passed-in
    string. The method should always be followed by the `cv2.waitKey()` method.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.imshow()`: 这个方法接受一个字符串和一个图像对象，并在一个单独的窗口中显示它。窗口的标题由传入的字符串指定。该方法应始终跟随`cv2.waitKey()`方法。'
- en: '`cv2.waitKey()`: This method takes in a number and blocks the program for a
    corresponding number of milliseconds, unless the number `0` is passed in, in which
    case it will block indefinitely until the user presses a key on their keyboard.
    This method should always follow the `cv2.imshow()` method.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.waitKey()`: 这个方法接受一个数字，并阻塞程序相应的毫秒数，除非传入数字`0`，在这种情况下，它将无限期地阻塞，直到用户在键盘上按下一个键。该方法应始终跟随`cv2.imshow()`方法。'
- en: 'After calling `cv2.imshow()` on the `ship.jpg` file inside the input subfolder so
    that it''s displayed from the Python interpreter, the program will stop until
    a key is pressed, at which point it will execute the rest of the program. If run
    successfully, the script will display the following image:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`input`子文件夹中调用`cv2.imshow()`来显示`ship.jpg`文件，程序将停止，直到按下一个键，此时它将执行程序的其余部分。如果成功运行，脚本将显示以下图像：
- en: '![](assets/1d32e99b-39a0-4c78-a822-9f9650519bbc.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d32e99b-39a0-4c78-a822-9f9650519bbc.png)'
- en: 'You should also obtain the following output for the rest of the main program
    after pressing any key to close the displayed picture:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭显示的图片后，按下任意键后，您还应该获得主程序的其余部分的以下输出：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output confirms a few of the things that we discussed earlier:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认了我们之前讨论的一些事项：
- en: First, when printing out the image object returned from the `cv2.imread()` function,
    we obtained a matrix of numbers.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，当打印出从`cv2.imread()`函数返回的图像对象时，我们得到了一个数字矩阵。
- en: 'Using the `type()` method from Python, we found out that the class of this
    matrix is indeed a NumPy array: `numpy.ndarray`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python的`type()`方法，我们发现这个矩阵的类确实是一个NumPy数组：`numpy.ndarray`。
- en: Calling the `shape` attribute of the array, we can see that the image is a three-dimensional
    matrix of the shape (`1118`, `1577`, `3`), which corresponds to a table with `1118`
    rows and `1577` columns, each element of which is a pixel (three-number tuple).
    The numbers for the rows and columns also correspond to the size of the image.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用数组的`shape`属性，我们可以看到图像是一个形状为（`1118`，`1577`，`3`）的三维矩阵，对应于一个具有`1118`行和`1577`列的表，其中每个元素都是一个像素（三个数字的元组）。行和列的数字也对应于图像的大小。
- en: Focusing on the top-left pixel in the matrix (the first pixel in the first row,
    that is, `im[0, 0]`), we obtained the BGR value of (`199`, `136`, `86`)—`199`
    blue, `136` green, and `86` red. By looking up this BGR value through any online
    converter, we can see that this is a light blue that corresponds to the sky, which
    is the upper part of the image.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚焦矩阵中的左上角像素（第一行的第一个像素，即`im[0, 0]`），我们得到了（`199`，`136`，`86`）的BGR值——`199`蓝色，`136`绿色，`86`红色。通过任何在线转换器查找这个BGR值，我们可以看到这是一种浅蓝色，对应于图像的上部分天空。
- en: Image processing techniques
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像处理技术
- en: We have already seen some Python APIs that are provided by OpenCV to read in
    data from image files. Before we can use OpenCV to perform various image processing
    tasks, let's discuss the theoretical foundation for a number of techniques that
    are commonly used in image processing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些由OpenCV提供的Python API，用于从图像文件中读取数据。在我们可以使用OpenCV执行各种图像处理任务之前，让我们讨论一些常用的图像处理技术的理论基础。
- en: Grayscaling
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灰度处理
- en: We saw an example of grayscaling earlier in this chapter. Arguably one of the
    most used image processing techniques, grayscaling is the process of reducing
    the dimensionality of the image pixel matrix by only considering the intensity
    information of each pixel, which is represented by the amount of light available.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面看到了一个灰度处理的例子。可以说，灰度处理是最常用的图像处理技术之一，它是通过仅考虑每个像素的强度信息（由光的数量表示）来减少图像像素矩阵的维度。
- en: As a result, pixels of grayscale images no longer hold three-dimensional information
    (red, green, and blue), and only one-dimensional black-and-white data. These images
    are exclusively composed of shades of gray, with black indicating the weakest
    light intensity and white indicating the strongest.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，灰度图像的像素不再包含三维信息（红色、绿色和蓝色），而只包含一维的黑白数据。这些图像完全由灰度色调组成，黑色表示最弱的光强度，白色表示最强的光强度。
- en: Grayscaling serves a number of important purposes in image processing. Firstly,
    as mentioned, it reduces the dimensionality of the image pixel matrix by mapping
    traditional three-dimensional color data to one-dimensional gray data. So, instead
    of having to analyze and process three layers of color data, image processing
    programs only have to do one third of the job with grayscale images. Additionally,
    by only representing colors using one spectrum, important patterns in the image
    are more likely to be recognized with just black and white data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度处理在图像处理中有许多重要用途。首先，正如前面提到的，它通过将传统的三维颜色数据映射到一维灰度数据，减少了图像像素矩阵的维度。因此，图像处理程序只需要处理灰度图像的三分之一的工作，而不是分析和处理三层颜色数据。此外，通过仅使用一个光谱表示颜色，图像中的重要模式更有可能在黑白数据中被识别出来。
- en: 'There are multiple algorithms for converting color to grayscale: colorimetric
    conversion, luma coding, single channel, and so on. Luckily, we do not have to
    implement one ourselves, as the OpenCV library provides a one-line method to convert
    normal images to grayscale ones. Still using the image of a ship from the last
    example, let''s look at the `Chapter08/example2.py` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种算法可以将彩色转换为灰度：色度转换、亮度编码、单通道等。幸运的是，我们不必自己实现一个，因为OpenCV库提供了一个一行代码的方法，将普通图像转换为灰度图像。仍然使用上一个例子中的船的图像，让我们看一下`Chapter08/example2.py`文件：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we are using the `cvtColor()` method from OpenCV to convert
    our original image to a grayscale one. After running this script, the following
    image should be displayed on your computer:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用OpenCV的`cvtColor()`方法将原始图像转换为灰度图像。运行此脚本后，您的计算机上应该显示以下图像：
- en: '![](assets/a394341f-5f55-45df-8dab-9b16b10cc36e.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a394341f-5f55-45df-8dab-9b16b10cc36e.png)'
- en: Output from Grayscaling
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度处理的输出
- en: 'Pressing any key to unblock your program, you should obtain the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 按任意键解除程序阻塞，您应该获得以下输出：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that the structure of our grayscale image object is different from
    what we saw with our original image object. Even though it is still represented
    by a NumPy array, it is now a two-dimensional array of integers, each of which
    ranges from 0 (for black) to 255 (for white). The table of pixels, however, still
    consists of `1118` rows and `1577` columns.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，灰度图像对象的结构与我们原始图像对象所见的不同。尽管它仍然由NumPy数组表示，但现在它是一个二维整数数组，每个整数的范围从0（黑色）到255（白色）。然而，像素表仍然由`1118`行和`1577`列组成。
- en: In this example, we also used the `cv2.imwrite()` method, which saves the image
    object to your local computer. The grayscale image can therefore be found in the
    output subfolder of this chapter's folder, as specified in our code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还使用了`cv2.imwrite()`方法，它将图像对象保存到您的本地计算机上。因此，灰度图像可以在本章文件夹的输出子文件夹中找到，如我们的代码中指定的那样。
- en: Thresholding
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阈值处理
- en: Another important technique in image processing is thresholding. With the goal
    of categorizing each pixel in a digital image into different groups (also known
    as image segmentation), thresholding provides a quick and intuitive way to create
    binary images (with just black and white pixels).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理中的另一个重要技术是阈值处理。目标是将数字图像中的每个像素分类到不同的组中（也称为图像分割），阈值处理提供了一种快速直观的方法来创建二值图像（只有黑色和白色像素）。
- en: The idea behind thresholding is to replace each pixel in an image with a white
    pixel if the pixel's intensity is greater than a previously specified threshold,
    and with a black pixel if the pixel's intensity is less than that threshold. Similar
    to the goal of grayscaling, thresholding amplifies the differences between high-
    and low-intensity pixels, and from that important features and patterns in an
    image can be recognized and extracted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值化的思想是，如果像素的强度大于先前指定的阈值，则用白色像素替换图像中的每个像素，如果像素的强度小于该阈值，则用黑色像素替换。与灰度化的目标类似，阈值化放大了高强度和低强度像素之间的差异，从而可以识别和提取图像中的重要特征和模式。
- en: Recall that grayscaling converts a fully colored image to a version that only
    has different shades of gray; in this case, each pixel has a value of an integer
    ranging from 0 to 255\. From a grayscale image, thresholding can convert it to
    a fully black-and-white one, each pixel of which is now only either 0 (black)
    or 255 (white). So, after performing thresholding on an image, each pixel of that
    image can only hold two possible values, also significantly reducing the complexity
    of our image data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，灰度化将完全彩色的图像转换为只有不同灰度的版本；在这种情况下，每个像素的值是从0到255的整数。从灰度图像，阈值化可以将其转换为完全的黑白图像，其中每个像素现在只是0（黑色）或255（白色）。因此，在图像上执行阈值化后，该图像的每个像素只能保持两个可能的值，也显著减少了图像数据的复杂性。
- en: 'The key to an effective thresholding process is therefore finding an appropriate
    threshold so that the pixels in an image are segmented in a way that allows separate
    regions in the image to become more obvious. The most simple form of thresholding
    is to use a constant threshold to process all pixels throughout a whole image.
    Let''s consider an example of this method in the `Chapter08/example3.py` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有效阈值处理的关键是找到一个适当的阈值，使图像中的像素以一种方式分割，使图像中的不同区域变得更加明显。最简单的阈值处理形式是使用一个常数阈值来处理整个图像中的所有像素。让我们在`Chapter08/example3.py`文件中考虑这种方法的一个例子。
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example, after converting the image of a ship that we have been using
    to grayscale, we call the `threshold(src, thresh, maxval, type)` function from
    OpenCV, which takes in the following arguments:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，将我们一直在使用的船的图像转换为灰度图像后，我们从OpenCV调用`threshold(src, thresh, maxval, type)`函数，该函数接受以下参数：
- en: '`src`: This argument takes in the input/source image.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：此参数接受输入/源图像。'
- en: '`thresh`: The constant threshold to be used throughout the image. Here, we
    are using `127`, as it is simply the middle point between 0 and 255.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thresh`：要在整个图像中使用的常数阈值。在这里，我们使用`127`，因为它只是0和255之间的中间点。'
- en: '`maxval`: Pixels whose original values are greater than the constant threshold
    will take this value after the thresholding process. We pass in 255 to specify
    that those pixels should be completely white.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxval`：原始值大于常数阈值的像素在阈值处理后将采用此值。我们传入255来指定这些像素应该完全是白色的。'
- en: '`type`: This value indicates the thresholding type used by OpenCV. We are performing
    a simple binary thresholding, so we pass in `cv2.THRESH_BINARY`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：此值指示OpenCV使用的阈值类型。我们执行简单的二进制阈值处理，因此我们传入`cv2.THRESH_BINARY`。'
- en: 'After running the script, you should be able to find the following image in
    the output with the name `custom_thresh_ship.jpg`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，您应该能够在输出中找到以下图像，名称为`custom_thresh_ship.jpg`：
- en: '![](assets/2370035f-c8e1-449c-a7ae-aa3daa1f3118.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2370035f-c8e1-449c-a7ae-aa3daa1f3118.png)'
- en: Output from simple thresholding
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 简单阈值输出
- en: 'We can see that with a simple threshold (`127`), we have obtained an image
    that highlights separate regions of the image: the sky, the ship, and the sea.
    However, there are a number of problems that this method of simple thresholding
    poses, the most common of which is finding the appropriate constant threshold.
    Since different images have different color tones, lighting conditions, and so
    on, it is undesirable to use a static value across different images as their threshold.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过简单的阈值（`127`），我们得到了一个突出显示图像的不同区域的图像：天空、船和海洋。然而，这种简单阈值方法存在一些问题，其中最常见的问题是找到适当的常数阈值。由于不同的图像具有不同的色调、光照条件等，使用静态值作为它们的阈值跨不同图像是不可取的。
- en: 'This issue is addressed by adaptive thresholding methods, which calculate the
    dynamic thresholds for small regions of an image. This process allows the threshold
    to adjust according to the input image, and not depend solely on a static value.
    Let''s consider two examples of these adaptive thresholding methods, namely Adaptive
    Mean Thresholding and Adaptive Gaussian Thresholding. Navigate to the `Chapter08/example4.py`
    file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题通过自适应阈值方法来解决，这些方法计算图像的小区域的动态阈值。这个过程允许阈值根据输入图像调整，而不仅仅依赖于静态值。让我们考虑这些自适应阈值方法的两个例子，即自适应均值阈值和自适应高斯阈值。导航到`Chapter08/example4.py`文件：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similar to what we did with the `cv2.threshold()` method earlier, here, we again
    convert the original image to its grayscale version, and then we pass it to the
    `adaptiveThreshold()` method from OpenCV. This method takes in similar arguments
    to the `cv2.threshold()` method, except that, instead of taking in a constant
    to be the threshold, it takes in an argument for the adaptive method. We used
    `cv2.ADAPTIVE_THRESH_MEAN_C` and `cv2.ADAPTIVE_THRESH_GAUSSIAN_C`, respectively.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们之前使用`cv2.threshold()`方法所做的，这里我们再次将原始图像转换为其灰度版本，然后将其传递给OpenCV的`adaptiveThreshold()`方法。该方法接受与`cv2.threshold()`方法类似的参数，只是它不是接受一个常数作为阈值，而是接受一个自适应方法的参数。我们分别使用了`cv2.ADAPTIVE_THRESH_MEAN_C`和`cv2.ADAPTIVE_THRESH_GAUSSIAN_C`。
- en: The second to last argument specifies the size of the window to perform thresholding;
    this number has to be an odd positive integer. Specifically, we used 11 in our
    example, so for each pixel in the image, the algorithm will consider the neighboring
    pixels (in an 11 x 11 square surrounding the original pixel). The last argument
    specifies the adjustment to make for each pixel in the final output. These two
    arguments, again, help localize the threshold for different regions of the image,
    thus making the thresholding process more dynamic and, as the name suggests, adaptive.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第二个参数指定了执行阈值处理的窗口大小；这个数字必须是奇数正整数。具体来说，在我们的例子中，我们使用了11，因此对于图像中的每个像素，算法将考虑相邻像素（在原始像素周围的11
    x 11方形中）。最后一个参数指定了要对最终输出中的每个像素进行的调整。这两个参数再次帮助定位图像不同区域的阈值，从而使阈值处理过程更加动态，并且正如名称所示，是自适应的。
- en: 'After running the script, you should be able to find the following images as
    output with the names `mean_thresh_ship.jpg` and `gauss_thresh_ship.jpg`. The
    output for `mean_thresh_ship.jpg` is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，您应该能够找到以下图像作为输出，名称为`mean_thresh_ship.jpg`和`gauss_thresh_ship.jpg`。`mean_thresh_ship.jpg`的输出如下：
- en: '![](assets/d12ef19b-305b-49f5-ad48-c133b5e6f301.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d12ef19b-305b-49f5-ad48-c133b5e6f301.png)'
- en: Output from mean thresholding
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 均值阈值处理的输出
- en: 'The output for `gauss_thresh_ship.jpg` is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`gauss_thresh_ship.jpg`的输出如下：'
- en: '![](assets/83cc9bc7-d419-44f5-a28b-bdf674724dc5.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/83cc9bc7-d419-44f5-a28b-bdf674724dc5.png)'
- en: Output from Gaussian thresholding
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯阈值处理的输出
- en: We can see that with adaptive thresholding, details in specific regions will
    be thresholded and highlighted in the final output image. These techniques are
    useful when we need to recognize small details in an image, while simple thresholding
    is useful when we only want to extract big regions of an image.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以看到，使用自适应阈值处理，特定区域的细节将在最终输出图像中进行阈值处理并突出显示。当我们需要识别图像中的小细节时，这些技术非常有用，而简单的阈值处理在我们只想提取图像的大区域时非常有用。 '
- en: Applying concurrency to image processing
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将并发应用于图像处理
- en: We have talked a lot about the basics of image processing and some common image
    processing techniques. We also know why image processing is a heavy number-crunching
    task, and that concurrent and parallel programming can be applied to speed up
    independent processing tasks. In this section, we will be looking at a specific
    example on how to implement a concurrent image processing application that can
    handle a large number of input images.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了图像处理的基础知识和一些常见的图像处理技术。我们也知道为什么图像处理是一个繁重的数值计算任务，以及并发和并行编程可以应用于加速独立处理任务。在本节中，我们将看一个具体的例子，介绍如何实现一个并发图像处理应用程序，可以处理大量的输入图像。
- en: First, head to the current folder for this chapter's code. Inside the `input`
    folder, there is a subfolder called `large_input`, which contains 400 images that
    we will be using for this example. These pictures are different regions in our
    original ship image, which have been cropped from it using the array-indexing
    and -slicing options that NumPy provides to slice OpenCV image objects. If you
    are curious as to how these images were generated, check out the `Chapter08/generate_input.py`
    file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，转到本章代码的当前文件夹。在`input`文件夹内，有一个名为`large_input`的子文件夹，其中包含我们将在此示例中使用的400张图像。这些图片是原始船舶图像中的不同区域，使用NumPy提供的数组索引和切片选项从中裁剪出来的。如果您想知道这些图像是如何生成的，请查看`Chapter08/generate_input.py`文件。
- en: 'Our goal in this section is to implement a program that can concurrently process
    these images using thresholding. To do this, let''s look at the `example5.py`
    file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是实现一个程序，可以同时处理这些图像并进行阈值处理。为此，让我们看一下`example5.py`文件：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we are using the `Pool` class from the `multiprocessing` module
    to manage our processes. As a refresher, a `Pool` object supplies convenient options
    to map a sequence of inputs to separate processes using the `Pool.map()` method.
    We are using the `Pool.starmap()` method in our example, however, to pass multiple
    arguments to the target function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`multiprocessing`模块中的`Pool`类来管理我们的进程。作为复习，`Pool`对象提供了方便的选项，可以使用`Pool.map()`方法将一系列输入映射到单独的进程。然而，在我们的例子中，我们使用了`Pool.starmap()`方法，以便将多个参数传递给目标函数。
- en: At the beginning of our program, we make a number of house-keeping assignments: the
    thresholding method to perform adaptive thresholding when processing the images,
    paths for the input and output folders, and the names of the images to process.
    The `process_threshold()` function is what we use to actually process the images;
    which takes in an image object, the name for the processed version of the image,
    and which thresholding method to use. Again, this is why we need to use the `Pool.starmap()`
    method instead of the traditional `Pool.map()` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的开头，我们进行了一些基本的赋值：在处理图像时执行自适应阈值处理的方法，输入和输出文件夹的路径，以及要处理的图像的名称。`process_threshold()`函数是我们用来实际处理图像的函数；它接受一个图像对象，图像的处理版本的名称，以及要使用的阈值处理方法。这也是为什么我们需要使用`Pool.starmap()`方法而不是传统的`Pool.map()`方法。
- en: In the main program, to demonstrate the differences between sequential and multiprocessing
    image processing, we want to run our program with different numbers of processes,
    specifically from one single process to six different processes. In each iteration
    of the `for` loop, we initialize a `Pool` object and map the necessary arguments
    of each image to the `process_threshold()` function, while keeping track of how
    much time it takes to process and save all of the images.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中，为了演示顺序和多进程图像处理之间的差异，我们希望以不同数量的进程运行我们的程序，具体来说，从一个单一进程到六个不同进程。在`for`循环的每次迭代中，我们初始化一个`Pool`对象，并将每个图像的必要参数映射到`process_threshold()`函数，同时跟踪处理和保存所有图像所需的时间。
- en: 'After running the script, the processed images can be found in the `output/large_output/`
    subfolder in our current chapter''s folder. You should obtain an output similar
    to the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，处理后的图像可以在当前章节文件夹中的`output/large_output/`子文件夹中找到。您应该获得类似以下的输出：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see a big difference in execution time when we go from one single process
    to two separate processes. However, there is negligible or even negative speedup
    after going from two to higher numbers of processes. Generally, this is because
    of the heavy overhead, which is the product of implementing a large number of
    separate processes, in comparison to a relatively low number of inputs. Even though
    we are not implementing this comparison in the interest of simplicity, with an
    increased number of inputs we would see better improvements from a high number
    of working processes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一个单一进程转到两个独立的进程时，执行时间有很大的差异。然而，当从两个进程转到更多的进程时，速度几乎没有或甚至是负的加速。一般来说，这是因为实现大量独立进程的重大开销，与相对较低数量的输入相比。尽管出于简单起见，我们没有实施这种比较，但随着输入数量的增加，我们会看到来自大量工作进程的更好的改进。
- en: 'So far, we have seen that concurrent programming could provide a significant
    speedup for image processing applications. However, if we take a look at our preceding
    program, we can see that there are additional adjustments that we can make to
    improve the execution time even further. Specifically, in our preceding program,
    we are reading in images in a sequential way by using list comprehension in the
    following line:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到并发编程可以为图像处理应用程序提供显著的加速。然而，如果我们看一下我们之前的程序，我们会发现有其他调整可以进一步提高执行时间。具体来说，在我们之前的程序中，我们通过使用列表推导式顺序读取图像：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Theoretically, if we were to make the process of reading in different image
    files concurrent, we could also gain additional speedup with our program. This
    is especially true in an image processing application that deals with large input
    files, where significant time is spent on waiting for input to be read. With that
    in mind, let''s consider the following example, in which we will implement concurrent
    input/output processing. Navigate to the `example6.py` file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，如果我们将不同图像文件的读取过程并发进行，我们也可以通过我们的程序获得额外的加速。这在处理大型输入文件的图像处理应用程序中尤其如此，在那里大量时间花在等待输入读取上。考虑到这一点，让我们考虑以下示例，在其中我们将实现并发输入/输出处理。导航到`example6.py`文件：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The structure of this program is similar to that of the previous one. However,
    instead of preparing the necessary images to be processed and other relevant input
    information, we implement them inside the `process_threshold()` function, which
    now only takes the name of the input image and handles reading the image itself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的结构与上一个程序类似。然而，我们不是准备要处理的必要图像和其他相关的输入信息，而是将它们实现在`process_threshold()`函数中，现在只需要输入图像的名称并处理读取图像本身。
- en: As a side note, we are using Python's built-in `functools.partial()` method
    in our main program to pass in a partial argument (hence the name), specifically
    `thresh_method`, to the `process_threshold()` function, as this argument is fixed
    across all images and processes. More information about this tool can be found
    at [https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个旁注，我们在主程序中使用Python的内置`functools.partial()`方法传递一个部分参数（因此得名），具体是`thresh_method`，传递给`process_threshold()`函数，因为这个参数在所有图像和进程中都是固定的。有关此工具的更多信息可以在[https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html)找到。
- en: 'After running the script, you should obtain an output similar to the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，您应该获得类似以下的输出：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compared to our last output, this implementation of the application indeed gives
    us a significantly better execution time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们上次的输出相比，这个应用程序的实现确实给我们带来了显著更好的执行时间。
- en: Good concurrent image processing practices
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好的并发图像处理实践
- en: Up until this point, you have most likely realized that image processing is
    quite an involved process, and implementing concurrent and parallel programming
    in an image processing application can add more complexity to our work. There
    are, however, good practices that will guide us in the right direction while developing
    our image processing applications. The following section discusses some of the
    most common practices that we should keep in mind.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您很可能已经意识到图像处理是一个相当复杂的过程，在图像处理应用程序中实现并发和并行编程可能会给我们的工作增加更多的复杂性。然而，有一些良好的实践将指导我们朝着正确的方向发展我们的图像处理应用程序。接下来的部分讨论了我们应该牢记的一些最常见的实践。
- en: Choosing the correct way (out of many)
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的方式（其中有很多）
- en: We have hinted at this practice briefly when we learned about thresholding.
    How an image processing application handles and processes its image data heavily
    depends on the problems it is supposed to solve, and what kind of data will be
    fed to it. Therefore, there is significant variability when it comes to choosing
    specific parameters when processing your image.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习阈值处理时，我们已经简要提到了这种实践。图像处理应用程序如何处理和处理其图像数据在很大程度上取决于它应该解决的问题，以及将要提供给它的数据的类型。因此，在处理图像时选择特定参数时存在显著的变异性。
- en: 'For example, as we have seen earlier, there are various ways to threshold an
    image, and each will result in very different output: if you want to focus on
    only the large, distinct regions of an image, simple constant thresholding will
    prove to be more beneficial than adaptive thresholding; if, however, you want
    to highlight small changes in the details of an image, adaptive thresholding will
    be significantly better.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，正如我们之前所看到的，有各种方法可以对图像进行阈值处理，每种方法都会产生非常不同的输出：如果您只想关注图像的大的、明显的区域，简单的常数阈值处理将比自适应阈值处理更有益；然而，如果您想突出图像细节中的小变化，自适应阈值处理将更好。
- en: Let's consider another example, in which we will see how tuning a specific parameter
    for an image processing function results in better output. In this example, we
    are using a simple Haar Cascade model to detect faces in images. We will not go
    too deeply into how the model handles and processes its data, since it is already
    built into OpenCV; again, we are only using this model on a high level, changing
    its parameters to obtain different results.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，我们将看到调整图像处理函数的特定参数如何产生更好的输出。在这个例子中，我们使用一个简单的Haar级联模型来检测图像中的面部。我们不会深入讨论模型如何处理和处理其数据，因为它已经内置在OpenCV中；同样，我们只是在高层次上使用这个模型，改变它的参数以获得不同的结果。
- en: 'Navigate to the `example7.py` file in this chapter''s folder. The script is
    designed to detect faces in the `obama1.jpeg` and `obama2.jpg` images in our input
    folder:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的文件夹中导航到`example7.py`文件。该脚本旨在检测我们输入文件夹中的`obama1.jpeg`和`obama2.jpg`图像中的面部：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, the program loads the pretrained Haar Cascade model from the `input`
    folder using the `cv2.CascadeClassifier` class. For each input image, the script
    converts it to grayscale and feeds it to the pretrained model. The script then
    draws a green rectangle around each face found in the image, and finally displays
    it in a separate window.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，程序使用`cv2.CascadeClassifier`类从`input`文件夹中加载预训练的Haar级联模型。对于每个输入图像，脚本将其转换为灰度并将其输入到预训练模型中。然后脚本在图像中找到的每张脸周围画一个绿色的矩形，最后在一个单独的窗口中显示它。
- en: 'Run the program, and you will see the following image with the title `5 face(s)
    found`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，你会看到以下带有标题`5个面部被发现`的图像：
- en: '![](assets/77c174ea-ffc8-46e8-824b-1756d783fa58.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/77c174ea-ffc8-46e8-824b-1756d783fa58.png)'
- en: Correct face detection
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的面部检测
- en: 'It looks like our program is working well so far. Press any key to continue,
    and you should see the following image with the title `7 face(s) found`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的程序到目前为止工作得很好。按任意键继续，你应该会看到以下带有标题`7个面部被发现`的图像：
- en: '![](assets/1048508c-d9f8-4da4-8fff-73ca7f8639a6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1048508c-d9f8-4da4-8fff-73ca7f8639a6.png)'
- en: Incorrect face detection
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的面部检测
- en: Now, our program is mistaking some other objects as actual faces, resulting
    in two false-positives. The reason behind this involves how the pretrained model
    was created. Specifically, the Haar Cascade model used a training dataset with
    images of specific (pixel) sizes, and when an input image contains faces of different
    sizes—which is common when it is a group picture with some people being close
    to the camera, while others are far away—is fed into this model, it will cause
    false-positives in the output.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的程序将一些其他物体误认为是真正的面部，导致了两个误报。这背后的原因涉及到预训练模型的创建方式。具体来说，Haar级联模型使用了一个训练数据集，其中包含特定（像素）大小的图像，当输入图像包含不同大小的面部时——这在一张集体照片中很常见，有些人离相机很近，而其他人离得很远——将输入到该模型中，会导致输出中出现误报。
- en: 'The `scaleFactor` parameter in the `detectMultiScale` method of the `cv2.CascadeClassifier`
    class addresses this issue. This parameter will scale down different areas of
    the input image before trying to predict whether those areas contain a face or
    not—doing this negates the potential difference in face sizes. To implement this,
    change the line where we pass the input images to the model to the following to
    specify the `scaleFactor` parameter as `1.2`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv2.CascadeClassifier`类的`detectMultiScale`方法中的`scaleFactor`参数解决了这个问题。该参数将在尝试预测这些区域是否包含面部之前，将输入图像的不同区域缩小。这样做可以消除面部大小的潜在差异。为了实现这一点，将我们传递输入图像到模型的那一行更改为以下内容，以指定`scaleFactor`参数为`1.2`：'
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the program, and you will see that this time our application is able to
    correctly detect all of the faces in our input images without making any false-positives.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，你会看到这次我们的应用能够正确检测输入图像中的所有面部，而不会产生任何误报。
- en: From this example, we can see that it is important to know about the potential
    challenges that the input images will pose to your image processing application
    in execution, and to try different methods or parameters within one method of
    processing to achieve the best results.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以看到了解输入图像对你的图像处理应用程序在执行中可能带来的潜在挑战是很重要的，并尝试在处理的一个方法中使用不同的方法或参数来获得最佳结果。
- en: Spawning an appropriate number of processes
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成适当数量的进程
- en: One point we noticed in our example for concurrent image processing is that
    the task of spawning processes takes a considerable amount of time. Due to this,
    if the number of processes available to analyze the data is too high in comparison
    to the amount of input, the improvement in execution time received from increasing
    the number of working processes will diminish and sometimes even become negative.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在并发图像处理的例子中注意到的一个问题是生成进程的任务需要相当长的时间。由于这个原因，如果可用于分析数据的进程数量与输入量相比太高，那么从增加工作进程数量中获得的执行时间改善将会减少，有时甚至会变得负面。
- en: However, there is no concrete way to tell whether a specific number of separate
    processes is appropriate for a program unless we also take into account its input
    images. For example, if the input images are relatively large files, and it takes
    a significant amount of time for the program to load them from storage, having
    a larger number of processes might be beneficial; when some processes are waiting
    for their images to load, others can proceed to perform processing on theirs.
    In other words, having a larger number of processes will allow for some overlapping
    between loading and processing time, which will result in better speedup.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非我们也考虑到其输入图像，否则没有一个具体的方法可以确定一个程序是否需要适当数量的独立进程。例如，如果输入图像是相对较大的文件，并且程序从存储中加载它们需要相当长的时间，那么拥有更多的进程可能是有益的；当一些进程在等待它们的图像加载时，其他进程可以继续对它们的图像进行处理。换句话说，拥有更多的进程将允许加载和处理时间之间的一些重叠，这将导致更好的加速。
- en: In short, it is important to test out different processes that are available
    for your image processing application to see what the optimal number for scalability
    is.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，重要的是测试图像处理应用程序中可用的不同进程，以查看可扩展性的最佳数字是多少。
- en: Processing input/output concurrently
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时处理输入/输出
- en: We saw that loading input images in a sequential way might have a negative effect
    on the execution time of an image processing application, as opposed to allowing
    separate processes to load their own inputs. This is specifically true if the
    image files are significantly large, as the loading time in separate processes
    might overlap with the loading/processing time in other processes. The same is
    applicable for writing output images to files.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，以顺序方式加载输入图像可能会对图像处理应用程序的执行时间产生负面影响，而不是允许单独的进程加载它们自己的输入。如果图像文件非常大，那么在单独的进程中加载时间可能会与其他进程中的加载/处理时间重叠，这一点尤为真实。对于将输出图像写入文件也是如此。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Image processing is the task of analyzing and manipulating digital image files
    to create new versions of the images or to extract important data from them. These
    digital images are represented by tables of pixels, which are RGB values, or in
    essence, tuples of numbers. Therefore, digital images are simply multidimensional
    matrices of numbers, which results in the fact that image processing tasks typically
    come down to heavy number-crunching.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理是分析和操作数字图像文件以创建图像的新版本或从中提取重要数据的任务。这些数字图像由像素表表示，这些像素表是RGB值，或者本质上是数字元组。因此，数字图像只是数字的多维矩阵，这导致图像处理任务通常归结为大量的数字计算。
- en: Since images can be analyzed and processed independently from each other in
    an image processing application, concurrent and parallel programming – specifically
    multiprocessing – provides a way to achieve significant improvements in execution
    time for the application. Additionally, there are a number of good practices to
    follow while implementing your own concurrent image processing program.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图像可以在图像处理应用程序中独立地进行分析和处理，因此并发和并行编程 – 特别是多进程 – 提供了一种实现应用程序执行时间显着改进的方法。此外，在实现自己的并发图像处理程序时，有许多良好的实践方法可遵循。
- en: 'So far in this book, we have covered the main two forms of concurrent programming:
    multithreading and multiprocessing. In the next chapter, we will be moving on
    to the topic of asynchronous I/O, which is also one of the key elements of concurrency
    and parallelism.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经涵盖了并发编程的两种主要形式：多线程和多进程。在下一章中，我们将转向异步I/O的主题，这也是并发和并行的关键要素之一。
- en: Questions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an image processing task?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是图像处理任务？
- en: What is the smallest unit of digital imaging? How is it represented in computers?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字成像的最小单位是什么？它在计算机中是如何表示的？
- en: What is grayscaling? What purpose does this technique serve?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是灰度处理？这种技术有什么作用？
- en: What is thresholding? What purpose does this technique serve?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是阈值处理？这种技术有什么作用？
- en: Why should image processing be made concurrent?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么图像处理应该并发进行？
- en: What are some good practices for concurrent image processing?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发图像处理的一些良好实践是什么？
- en: Further reading
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下链接：
- en: 'Automate the Boring Stuff with Python: Practical Programming for Total Beginners,
    Al Sweigart, No Starch Press, 2015'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Python自动化无聊的事情：初学者的实用编程，Al Sweigart，No Starch Press，2015
- en: '*Learning Image Processing with OpenCV*, Garcia, Gloria Bueno, et al, Packt
    Publishing Ltd, 2015'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用OpenCV学习图像处理*，Garcia，Gloria Bueno等人，Packt Publishing Ltd，2015'
- en: A Computational Introduction to Digital Image Processing, Alasdair McAndrew, Chapman
    and Hall/CRC, 2015
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字图像处理的计算介绍，Alasdair McAndrew，Chapman and Hall/CRC，2015
- en: 'Howse, J., P. Joshi, and M. Beyeler. OpenCV: *Computer Vision Projects with
    Python.* Packt Publishing Ltd, 2016'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 豪斯，J.，P. Joshi和M. Beyeler。OpenCV：*Python计算机视觉项目*。Packt Publishing Ltd，2016
