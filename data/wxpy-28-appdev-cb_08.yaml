- en: Chapter 8. Drawing to the Screen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 将绘图输出到屏幕
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Screen drawing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕绘图
- en: Drawing shapes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制形状
- en: Utilizing `SystemSettings`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `SystemSettings`
- en: Using a `GraphicsContext`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个`GraphicsContext`
- en: Drawing with `RendererNative`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `RendererNative` 绘制
- en: Reducing flicker in drawing routines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少绘图过程中的闪烁
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Being able to display objects on a computer's display is one of the most basic
    functionalities of a GUI toolkit. In wxPython, objects are shown on the display
    through drawing commands issued to a **Device Context** (**DC**). Underneath the
    hood, all controls are represented as bitmaps that are drawn on the screen's display.
    The interface provided by a DC allows for the customization of a control's appearance.
    When used in combination with events, they are also the basis for creating new
    controls.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在计算机显示上显示对象是GUI工具箱最基本的功能之一。在wxPython中，对象通过向**设备上下文**（**DC**）发出的绘图命令在显示上显示。在底层，所有控件都表示为绘制在屏幕显示上的位图。设备上下文提供的接口允许自定义控件的外观。当与事件结合使用时，它们也是创建新控件的基础。
- en: These rudimentary tools open a number of doors and possibilities that allow
    the application designer to fill the gaps in what the toolkit provides in order
    to meet the specific needs of an application. Now that the tool has been presented,
    it is time to pick it up and put it to use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基础工具打开了许多门和可能性，使得应用设计师能够填补工具箱提供的空白，以满足特定应用的需求。现在工具已经介绍完毕，是时候拿起它并投入使用。
- en: Screen drawing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕绘图
- en: All windows that are visible on the screen issue some drawing commands to a
    Device Context (often referred to as a DC) to tell the system what kind of pixel
    information to display on the screen. Some control's classes, such as `wx.Control,
    wx.Window`, and `wx.Panel` allow for user-defined control of what is drawn on
    the screen through the use of `wx.EVT_PAINT`. This recipe provides an introduction
    to screen drawing by creating a simple little slideshow widget that will load
    a PNG or JPG file from a directory, and then draw that image on the screen along
    with some label text below it, to show which image is out of the set.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上所有可见的窗口都会向设备上下文（通常称为DC）发出一些绘图命令，以告诉系统在屏幕上显示哪种像素信息。一些控件类，如`wx.Control`、`wx.Window`和`wx.Panel`，允许通过使用`wx.EVT_PAINT`来定义用户对屏幕上绘制内容的控制。本食谱通过创建一个简单的幻灯片小部件来介绍屏幕绘图，该部件将从目录中加载PNG或JPG文件，然后在屏幕上绘制该图像，并在其下方添加一些标签文本，以显示哪张图像是集合中的。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we will look at our `ImageCanvas` widget. Starting with its constructor
    we `Bind` to `EVT_PAINT` so that we can get call backs from the framework when
    a part of our window has been marked as needing to be redrawn:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将查看我们的`ImageCanvas`小部件。从其构造函数开始，我们将其`Bind`到`EVT_PAINT`，这样当我们的窗口的一部分被标记为需要重绘时，我们可以从框架中获取回调：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here we override `DoGetBestSize` so that the widget can be resized depending
    upon the size of the image that is displayed in it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重写`DoGetBestSize`方法，以便根据显示在其中的图像大小调整小部件的大小：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, in `OnPaint`, we handle `EVT_PAINT` and create a `PaintDC` to draw the
    current image on the Panel:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在 `OnPaint` 函数中，我们处理 `EVT_PAINT` 事件并创建一个 `PaintDC` 来在面板上绘制当前图像：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we add a few methods for client code to interact with in order to
    change the image and set the image source directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一些客户端代码可以与之交互的方法，以便更改图像并设置图像源目录：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: That was pretty easy, so let's take a quick walkthrough to see how everything
    works. First we derived our `ImageCanvas` panel from `PyPanel` so that we could
    get access to some of its virtual methods. Next, in the constructor, we `Bind`
    our paint handler to `EVT_PAINT` so that we will get `PaintEvent` notifications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，所以让我们快速浏览一下，看看一切是如何工作的。首先，我们从 `PyPanel` 派生出了我们的 `ImageCanvas` 面板，这样我们就可以访问它的一些虚拟方法。接下来，在构造函数中，我们将我们的绘图处理程序
    `Bind` 到 `EVT_PAINT`，这样我们就会收到 `PaintEvent` 通知。
- en: The next method, `DoGetBestSize`, is a virtual override. The framework will
    call this method when it wants us to tell it what our best size is. This occurs
    when the layout is being calculated. We base the best size on the size of the
    current image, but reserve a minimum rectangle of 300x300 pixels just to ensure
    that we have some space to work with.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法，`DoGetBestSize`，是一个虚拟覆盖。当框架需要我们告诉它我们的最佳尺寸时，将会调用此方法。这发生在布局计算时。我们根据当前图像的大小来确定最佳尺寸，但保留一个最小矩形区域300x300像素，以确保我们有足够的空间进行操作。
- en: Next we get to `OnPaint`. This is where the main focus of this recipe unfolds.
    The first thing to notice is that we create a `PaintDC`. This is a required step.
    If a `PaintDC` is not created within an `EVT_PAINT` handler, then on platforms
    such as Windows there will be errors when refreshing the window. The `PaintDC`
    provides the interface to the DC, which will allow us to draw on the screen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们来到 `OnPaint`。这里是本菜谱的主要焦点展开的地方。首先要注意的是，我们创建了一个 `PaintDC`。这是一个必须的步骤。如果在 `EVT_PAINT`
    处理器中未创建 `PaintDC`，那么在像 Windows 这样的平台上刷新窗口时将会出现错误。`PaintDC` 提供了与 DC 的接口，这将允许我们在屏幕上绘制。
- en: Most of the work in `OnPaint` is just calculating where to position what we
    want to draw. We do this by first getting the rectangle that we have to work in,
    which is simply returned by calling `GetClientRect`. From here, in the case where
    we have some images to display, we do some simple calculations to center the current
    image, and then use the DC's `DrawBitmap` method to draw our `Bitmap` object to
    the screen. Then we proceed to draw some text under the image to show what number
    the image is in the set. To do this, we use `GetTextExtent` to get the on-screen
    size that our string will require to be drawn with the current font. In the case
    where there are no images, we simply use the DC's `DrawLabel` function with the
    `ALIGN_CENTER` flag to draw a warning label in the middle of the rectangle.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnPaint`中的大部分工作只是计算我们要绘制的内容的位置。我们通过首先获取我们必须工作的矩形来完成这个任务，这个矩形可以通过调用`GetClientRect`简单地返回。从这里开始，如果我们有一些图像要显示，我们会进行一些简单的计算来居中当前图像，然后使用DC的`DrawBitmap`方法将我们的`Bitmap`对象绘制到屏幕上。然后我们继续在图像下方绘制一些文本，以显示图像在集合中的编号。为此，我们使用`GetTextExtent`来获取我们的字符串将需要用当前字体绘制的屏幕大小。在没有图像的情况下，我们简单地使用带有`ALIGN_CENTER`标志的DC的`DrawLabel`函数在矩形的中间绘制一个警告标签。
- en: 'To facilitate cycling through the images in the directory specified by calling
    `SetImageDir`, we have two methods: `Next` and `Previous`. These methods simply
    increment or decrement the index we are looking at in the list, and then call
    `Refresh. Refresh` will cause the system to issue a new `PaintEvent`. When this
    happens, our `OnPaint` handler will be called and will draw the new image. See
    the sample code that accompanies this recipe for a sample application using our
    `ImageCanvas` widget.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便在通过调用 `SetImageDir` 指定的目录中循环浏览图片，我们提供了两种方法：`Next` 和 `Previous`。这些方法只是简单地增加或减少我们在列表中查看的索引，然后调用
    `Refresh`。`Refresh` 将导致系统发出一个新的 `PaintEvent`。当这种情况发生时，我们的 `OnPaint` 处理程序将被调用，并将绘制新的图片。请参阅随此配方提供的示例代码，了解如何使用我们的
    `ImageCanvas` 小部件构建一个示例应用程序。
- en: See also
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using Bitmaps* recipe in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with wxPython"), *Getting Started with wxPython* discusses the basics of using
    Bitmaps in an application.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 使用位图")中的 *使用位图* 菜单，在 *wxPython 入门* 一书中讨论了在应用程序中使用位图的基本知识。'
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* explains
    the usage of the `Py` classes and how to override their virtual methods.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 使用wxPython入门")中的*理解继承限制*配方，*使用wxPython入门*解释了`Py`类的用法以及如何重写它们的虚拟方法。'
- en: Drawing shapes
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制形状
- en: Besides being able to draw text and bitmaps, DC's are also able to draw arbitrary
    shapes and lines. These rudimentary tools are what make it possible to create
    entirely custom widgets and controls, and to perform tasks such as drawing diagrams.
    This recipe explores these additional abilities of the `PaintDC` by creating a
    simple smiley face control.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够绘制文本和位图之外，DC 组件还能够绘制任意形状和线条。这些基本工具使得创建完全定制的控件和执行诸如绘制图表等任务成为可能。本食谱通过创建一个简单的笑脸控件来探索
    `PaintDC` 的这些附加功能。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we will define our simple smiley face control that is derived from PyControl:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义从 PyControl 派生出的简单笑脸控制：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here in, `OnPaint` is where we will draw our Smiley face onto the `PyControl''s`
    background:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`OnPaint` 是我们将要在 `PyControl` 的背景上绘制笑脸的地方：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First we will start by drawing the circle for the head, by finding the center
    of the control''s rectangle and using `DrawCircle` to draw a yellow circle with
    a black border, using the current Pen and Brush that was set above:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从绘制头部圆圈开始，通过找到控制矩形的中心，并使用 `DrawCircle` 函数绘制一个带有黑色边框的黄色圆圈，使用上面设置的当前笔刷和画笔：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next step is to draw the eyes. This smiley face is going to have blue,
    square-shaped eyes. To do this, we first calculate the size of the eyes as 1/8th
    of the total face area, set the brush to blue, and then use the DC''s `DrawRectangle`
    method to draw each of the eyes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是绘制眼睛。这个笑脸将拥有蓝色、方形的眼眸。为了做到这一点，我们首先计算眼睛的大小为整个面部面积的1/8，然后将画笔设置为蓝色，接着使用DC的`DrawRectangle`方法绘制每只眼睛：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Last but not least is to draw the smile onto the face. To do this, we set the
    brush back to yellow and then use the DC''s `DrawArc` method to draw a slice of
    a circle. Since all we want is the bottom part of the arc to use as the smile,
    we finish by drawing a yellow rectangle over the top part of the slice, to cover
    up the wedge:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是在脸上画出微笑。为了做到这一点，我们将画笔颜色设置为黄色，然后使用DC的`DrawArc`方法来绘制圆的一部分。由于我们只想使用弧的下半部分作为微笑，所以我们最后画一个黄色的矩形覆盖在切片的上半部分，以遮盖掉楔形：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we made use of a `Pen`, a `Brush`, and some of the rudimentary
    drawing routines that `PaintDC` provides us with. Let's take a look at our `OnPaint`
    method, to see how everything works.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了`笔`、`刷子`以及`PaintDC`为我们提供的某些基本绘图程序。让我们来看看我们的`OnPaint`方法，看看一切是如何工作的。
- en: First, we start off by setting up our DCs drawing tools. We set a black `Pen`,
    which will be used by the DC when it draws lines. We then set a yellow `Brush`.
    A `Brush` is used to fill the area inside of a shape when it is drawn. Next, we
    proceed to draw the face, which is a circle. To do this, we simply needed to find
    the center of our drawing area and then call the `DrawCircle` method with the
    center point and radius that we desire. The DC will then use our `Pen` and `Brush`
    to create a yellow circle with a black border drawn around it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始设置我们的直流绘图工具。我们设置了一支黑色`Pen`，当直流绘制线条时会使用它。然后我们设置了一块黄色`Brush`。`Brush`用于在绘制形状时填充形状内部的区域。接下来，我们开始绘制脸部，它是一个圆形。为此，我们只需要找到我们的绘图区域中心，然后调用带有我们所需的中心点和半径的`DrawCircle`方法。然后直流将使用我们的`Pen`和`Brush`来创建一个带有黑色边框的黄色圆形。
- en: Next, for the eyes, we decided to draw them as blue squares. So we changed to
    a blue `Brush` and called the `DrawRectangle` routine to draw the squares. This
    method's first two arguments are where the top left corner of the rectangle will
    be drawn from. The second two are the width and height of the rectangle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于眼睛，我们决定将它们绘制成蓝色方块。因此，我们切换到蓝色`Brush`，并调用`DrawRectangle`例程来绘制方块。此方法的前两个参数是矩形左上角将被绘制的位置。接下来的两个参数是矩形的宽度和高度。
- en: The final step is to draw the smile, which is just a simple arc. To perform
    this step, we need to figure out where we want the arc's two end points to be,
    which we just based on the center point of our circle. Then we called the `DrawArc`
    method, which will draw a slice of a circle. Because it draws a slice, there will
    be two unwanted lines from the center point extending to the start and end points
    of the arc. To get rid of this, we drew a yellow rectangle over the top of these
    two lines to erase it and only leave the arc which makes up the smile.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是绘制微笑，这只是一个简单的弧线。为了执行这一步，我们需要确定弧线的两个端点位置，这些端点是基于我们圆的中心点来确定的。然后我们调用了`DrawArc`方法，这个方法会绘制圆的一部分。因为它绘制的是圆的一部分，所以会有两条从中心点延伸到弧线起始点和结束点的多余线条。为了消除这些线条，我们在它们上方绘制了一个黄色的矩形来擦除它们，只留下构成微笑的弧线。
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here is a quick reference to the basic drawing functions of a `PaintDC`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`PaintDC`的基本绘图函数的快速参考。
- en: '| Functions | Description |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DrawArc(x1,y1,x2,y2, xcenter,ycenter)` | Draws a section of a circle with
    an arc from `x1,y1` to `x2,y2` centered from `xcenter,ycenter`. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `DrawArc(x1,y1,x2,y2, xcenter,ycenter)` | 绘制以`(xcenter,ycenter)`为中心，从`(x1,y1)`到`(x2,y2)`的圆弧部分。
    |'
- en: '| `DrawBitmap(bmp,x,y, useMask=False)` | Draws a bitmap at position `x,y`.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `DrawBitmap(bmp,x,y, useMask=False)` | 在位置 `x,y` 绘制位图。 |'
- en: '| `DrawCheckMark(x,y,width, height)` | Draws a checkmark in the given rectangle.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `DrawCheckMark(x,y,width, height)` | 在给定的矩形中绘制勾选标记。 |'
- en: '| `DrawCircle(x,y,radius)` | Draws a circle with center point `x,y` and the
    given radius. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `DrawCircle(x,y,radius)` | 绘制以点 `x,y` 为中心，给定半径的圆。 |'
- en: '| `DrawEllipse(x,y,width,height)` | Draws an ellipse in the given rectangle.
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `DrawEllipse(x,y,width,height)` | 在给定的矩形中绘制椭圆。 |'
- en: '| `DrawEllipticArc(x,y,w,h, start,end)` | Draw the arc of an ellipse in the
    given rectangle. The start and end parameters are angles that specify the start
    and end of the arc relative to the 3 o''clock position in the rectangle. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `DrawEllipticArc(x,y,w,h, start,end)` | 在给定的矩形中绘制椭圆的弧线。start和end参数是角度，用于指定弧线的起始和结束位置，相对于矩形中的3点钟位置。
    |'
- en: '| `DrawIcon(icon, x, y)` | Draw an icon at `x,y`. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `DrawIcon(icon, x, y)` | 在 `x,y` 位置绘制图标。 |'
- en: '| `DrawImageLabel(lbl,bmp,rect, align)` | Draw a label and a bitmap in the
    given rectangle, using the given alignment flags. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `DrawImageLabel(lbl,bmp,rect, align)` | 在给定的矩形内绘制一个标签和位图，使用给定的对齐标志。 |'
- en: '| `DrawLabel(text,rect,align)` | Draw the text in the rectangle with the given
    alignment flags. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `DrawLabel(text,rect,align)` | 在给定的对齐标志下，在矩形内绘制文本。 |'
- en: '| `DrawLine(x1,y1,x2,y2)` | Draw a line with the current pen from `x1,y1` to
    `x2,y2`. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `DrawLine(x1,y1,x2,y2)` | 使用当前笔从 `x1,y1` 到 `x2,y2` 绘制一条线。 |'
- en: '| `DrawPoint(x,y)` | Draw a point at `x,y` with the current pen. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `DrawPoint(x,y)` | 使用当前笔在 `x,y` 位置绘制一个点。 |'
- en: '| `DrawPolygon(points,x,y)` | Draw a polygon based on the list of points at
    position `x,y`. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `DrawPolygon(points,x,y)` | 基于点列表在位置 `x,y` 绘制多边形。 |'
- en: '| `DrawRectangle(x,y,w,h)` | Draw a rectangle of size `w,h` at position `x,y`.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `DrawRectangle(x,y,w,h)` | 在位置 `x,y` 绘制大小为 `w,h` 的矩形。 |'
- en: '| `DrawRotatedText(text,x,y, angle)` | Draw text at position `x,y` rotated
    to the given angle. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `DrawRotatedText(text,x,y, angle)` | 在位置 `x,y` 以给定角度旋转绘制文本。 |'
- en: '| `DrawRoundedRectangle(x,y,w,h, angle)` | Draw a rectangle with rounded corners.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `DrawRoundedRectangle(x,y,w,h, angle)` | 绘制具有圆角的矩形。 |'
- en: '| `DrawSpline(points)` | Draw a spline using the list of points. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `DrawSpline(points)` | 使用点列表绘制样条曲线。 |'
- en: '| `DrawText(text,x,y)` | Draw text at position `x,y`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `DrawText(text,x,y)` | 在位置 `x,y` 绘制文本。 |'
- en: See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Screen drawing* recipe in this chapter for the basics of creating and
    using a `DeviceContext`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的*屏幕绘图*配方，了解创建和使用`DeviceContext`的基本方法。
- en: Utilizing SystemSettings
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用系统设置
- en: The `SystemSettings` object allows a program to query the system for information
    about default colors and fonts. Being able to know this information can be very
    helpful when creating custom drawings, as it makes it possible to use the same
    colors and fonts that the native system components are using, so that your custom
    control or window decoration can blend in and look like it belongs with the other
    native components that share the same window with it. In this recipe, we will
    use `SystemSettings` to create a custom control that is similar to a `StaticBox`
    but with a caption that is similar to the title bar of the `Frame` bar.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SystemSettings` 对象允许程序查询系统以获取有关默认颜色和字体信息。在创建自定义绘图时，能够了解这些信息非常有帮助，因为它使得使用与原生系统组件相同的颜色和字体成为可能，这样你的自定义控件或窗口装饰就可以融入其中，看起来像是与其他共享同一窗口的原生组件属于一体。在本食谱中，我们将使用
    `SystemSettings` 创建一个类似于 `StaticBox` 的自定义控件，但其标题栏类似于 `Frame` 栏的标题栏。'
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this custom control, we will again start by deriving from `PyPanel` so
    that we have access to its `DoGetBestSize` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个自定义控件，我们再次从 `PyPanel` 派生出来，以便我们可以访问其 `DoGetBestSize` 方法：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, in our `EVT_PAINT` handler, we draw a simple caption at the top of the
    panel, and a border around the rest, using the caption color that we retrieve
    from the `SystemSettings` singleton:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在我们的 `EVT_PAINT` 处理程序中，我们使用从 `SystemSettings` 单例中检索到的标题颜色，在面板顶部绘制一个简单的标题，并在其余部分绘制一个边框：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we derived our new `CaptionBox` class from `PyPanel`. This was
    done because this control is going to be a container of other controls, and the
    use of `PyPanel` will allow the use of sizers to manage the layout and sizing
    of the control.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们是从 `PyPanel` 派生出了新的 `CaptionBox` 类。这样做的原因是，这个控件将成为其他控件的容器，而使用 `PyPanel`
    将允许使用布局和尺寸管理器来管理控件的布局和尺寸。
- en: As a part of the initial layout of the Panel in `__DoLayout`, we reserved 20
    pixels of space on the top and 8 pixels around the other sides, for the caption
    and border. This was done by putting in a spacer at the top plus an additional
    8 pixel border around the `BoxSizer` that will be used to layout the `CaptionBox's`
    children controls. Also as part of the layout management, we overrode `DoGetBestSize`
    in order to handle cases where the caption text is wider than the box's children
    windows. When using this class, its `AddItem` method must be used to add its children
    controls to it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`__DoLayout`中面板初始布局的一部分，我们在顶部预留了20像素的空间，在其余三边各预留了8像素的空间，用于标题和边框。这是通过在顶部添加一个间隔符，并在将要用于布局`CaptionBox`子控件`BoxSizer`周围额外添加8像素边框来实现的。同时，作为布局管理的一部分，我们重写了`DoGetBestSize`方法，以便处理标题文本宽度超过框子子窗口的情况。当使用这个类时，必须使用其`AddItem`方法来添加其子控件。
- en: Now let's check out how we draw the control. In `OnPaint`, the first thing we
    do is use the `SystemSettings` singleton to get the system-defined colours for
    a caption's background and text, which will allow the control to fit in and match
    other controls no matter what theme or operating system it is run on. Next, we
    shrink the drawing `Rect` by 2 pixels in both directions to define the controls
    border. After this, all there is to do is set the Pen to the caption color and
    call `DrawRect` to draw the border. The caption bar is also drawn in a similar
    fashion by creating a smaller rectangle in the upper space we had reserved in
    the layout and drawing a solid rectangle by setting the `Brush` to the caption
    color. All that leaves is the final step of drawing the caption text on the rectangle
    we just drew. See the following screenshot, which shows two `CaptionBoxes:`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何绘制控件。在`OnPaint`函数中，我们首先使用`SystemSettings`单例来获取系统定义的标题背景和文本颜色，这将使控件能够适应并匹配在任何主题或操作系统上运行的其它控件。接下来，我们将绘制`Rect`向两边各缩小2像素来定义控件的边框。之后，我们只需将画笔设置为标题颜色并调用`DrawRect`来绘制边框。标题栏也是通过在布局中预留的上部空间创建一个较小的矩形，并通过将`Brush`设置为标题颜色来绘制一个实心矩形来类似地绘制的。最后，我们只需在刚刚绘制的矩形上绘制标题文本。请参见以下截图，它显示了两个`CaptionBoxes:`
- en: '![How it works...](img/1780_08_01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1780_08_01.jpg)'
- en: There's more
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: In addition to being able to provide colors, the `SystemSettings` object can
    also provide system fonts and metrics. The three methods `GetColour, GetFont`,
    and `GetMetric` all take an index parameter that is one of the `wx.SYS_*` constants.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够提供颜色外，`SystemSettings` 对象还可以提供系统字体和度量。三个方法 `GetColour`、`GetFont` 和 `GetMetric`
    都接受一个索引参数，该参数是 `wx.SYS_*` 常量之一。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Screen drawing* recipe in this chapter for details of how to create
    and use a Device Context.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详见本章中关于如何创建和使用设备上下文的*屏幕绘图*配方。
- en: Using a GraphicsContext
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GraphicsContext
- en: The `GraphicsContext` is a new feature in wxPython2.8\. It provides access to
    the platform's higher-level drawing functionality. It provides features such as
    anti-aliasing, a floating point precision coordinate system, alpha blending, gradient
    brushes, and a handful of advanced methods. This recipe uses it to create a custom
    control that is like `StaticText`, but has a gradient-filled, pill-shaped background.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`GraphicsContext` 是 wxPython2.8 中的一个新特性。它提供了访问平台高级绘图功能的能力。它提供了诸如抗锯齿、浮点精度坐标系、透明度混合、渐变画笔以及一些高级方法等功能。这个示例使用它来创建一个类似于
    `StaticText` 的自定义控件，但其背景是渐变填充的药丸形状。'
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Much like the other recipes in this chapter, we will derive our new control
    from `PyControl` so that we can override its `DoGetBestSize` method to size the
    control to our label:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的其他配方类似，我们将从 `PyControl` 中派生我们的新控件，以便我们可以覆盖其 `DoGetBestSize` 方法来调整控件的大小以适应我们的标签：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time in `OnPaint`, we will create a GCDC from our `PaintDC` and do the
    drawing with the GCDC and its `GraphicsContext:`
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这次在 `OnPaint` 中，我们将从我们的 `PaintDC` 创建一个 GCDC，并使用 GCDC 和其 `GraphicsContext:` 进行绘图：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to draw this control in `OnPaint`, we took the `PaintDC` and wrapped
    it in a `GCDC`. A `GCDC` is a device context interface that uses a `GraphicsContext`
    internally. Using this interface makes it possible to use a `GraphicsContext`
    in a similar way to using a regular device context.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`OnPaint`中绘制这个控件，我们使用了`PaintDC`并将其包装在`GCDC`中。`GCDC`是一个内部使用`GraphicsContext`的设备上下文接口。使用这个接口使得在类似使用常规设备上下文的方式中使用`GraphicsContext`成为可能。
- en: When setting up the `Pen` and `Brush`, we used a transparent pen in order to
    not draw a border round the control. Drawing a gradient-colored background with
    a `GraphicsContext` is made simple with the use of the `GraphicsBrush` returned
    by the `CreateLinearGradientBrush` method of `GraphicsContext`. This method will
    create a brush that draws a gradient from the first set of coordinates to the
    second set, starting with the first color and blending it to the second. In this
    case, our second color only differs in its alpha level, so the gradient will fade
    to partially-transparent, which will show the panel behind it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置`Pen`和`Brush`时，我们使用了一种透明的笔来避免在控件周围绘制边框。使用`GraphicsContext`的`CreateLinearGradientBrush`方法返回的`GraphicsBrush`，可以轻松地用渐变色背景。此方法将创建一个从第一组坐标到第二组坐标绘制渐变的画刷，从第一种颜色开始，逐渐过渡到第二种颜色。在这种情况下，我们的第二种颜色仅在alpha级别上有所不同，因此渐变将淡化为半透明，这将显示出其背后的面板。
- en: All that is left now is to just call the `GraphicsContext's DrawRoundedRectangle`
    method, to draw a nice pill-shaped background that is filled with the gradient
    defined by the `GraphicsBrush` we created earlier. Then all that is left is to
    draw the label text on top of the background. To do this, we used the `DrawLabel`
    method of `GCDC` which is just like the `DrawLabel` method of `PaintDC` but uses
    the `GraphicsContext` under the hood to draw smooth, anti-aliased text. The following
    screenshot shows an example dialog with three instances of the `PodLabel` control
    on it. As can be seen, using the `GraphicsContext` has allowed the control to
    be drawn with smooth, anti-aliased edges and a gradient background that fades
    and becomes transparent near the bottom by taking advantage of the alpha blending
    of `GraphicsContext`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是调用 `GraphicsContext` 的 `DrawRoundedRectangle` 方法，绘制一个填充了我们之前定义的渐变的漂亮的药丸形背景。然后剩下的就是绘制背景上的标签文本。为此，我们使用了
    `GCDC` 的 `DrawLabel` 方法，它就像 `PaintDC` 的 `DrawLabel` 方法一样，但在底层使用 `GraphicsContext`
    来绘制平滑、抗锯齿的文本。下面的截图显示了一个示例对话框，其中包含三个 `PodLabel` 控件的实例。正如所见，使用 `GraphicsContext`
    允许控件以平滑、抗锯齿的边缘和渐变背景绘制，背景在底部通过利用 `GraphicsContext` 的 alpha 混合渐变并变得透明。
- en: '![How it works...](img/1780_08_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_08_02.jpg)'
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Screen drawing* recipe in this chapter discusses the use of Device Contexts.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于**屏幕绘图**的配方讨论了设备上下文的使用。
- en: See the *Drawing shapes* recipe in this chapter for an overview of the basic
    drawing routines.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的 *绘制形状* 菜单以了解基本绘图例程的概述。
- en: See the *Reducing flicker in drawing routines* recipe in this chapter for more
    examples of using a `GraphicsContext`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅本章中的*减少绘图例程中的闪烁*配方，以获取更多使用`GraphicsContext`的示例。
- en: Drawing with RendererNative
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RendererNative绘图
- en: '`RendererNative` is a class that contains a collection of functions that encapsulate
    the drawing of a native UI component. It allows you to draw things such as native-looking
    `Button` and `CheckBox` objects in a device context without needing to know any
    of the details about how it is done. This is a very powerful and useful class
    when you need to create generic widgets but want and maintain the native look
    and feel of the platform''s own widgets. This recipe uses `RendererNative` to
    create a custom button class for showing a drop-down menu.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`RendererNative` 是一个包含一系列封装了原生 UI 组件绘制功能的类。它允许你在设备上下文中绘制诸如看起来像原生的 `Button`
    和 `CheckBox` 对象，而无需了解任何关于如何实现它的细节。当你需要创建通用的控件但同时又想保持平台自身控件的原生外观和感觉时，这个类非常强大且实用。本食谱使用
    `RendererNative` 创建了一个自定义按钮类，用于显示下拉菜单。'
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This custom Button class will use `RendererNative` to do its drawing, based
    on the location and state of the mouse:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义按钮类将使用`RendererNative`根据鼠标的位置和状态来进行绘制：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We override `DoGetBestSize` and use the size of the label string as the basis
    for calculating the button''s size:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写`DoGetBestSize`函数，并使用标签字符串的大小作为计算按钮尺寸的基础：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here we add handlers for `EVT_LEFT_DOWN` and `EVT_LEFT_UP` to change the state
    of the control, and to show our pop-up menu:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了处理 `EVT_LEFT_DOWN` 和 `EVT_LEFT_UP` 的事件处理程序，以改变控件的状态，并显示我们的弹出菜单：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, in `OnPaint`, we create the required `PaintDC` and get a reference to
    the `RendererNative` singleton, which we will use to help us draw the Button''s
    background:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在 `OnPaint` 中，我们创建了所需的 `PaintDC` 并获取了对 `RendererNative` 单例的引用，我们将使用它来帮助我们绘制按钮的背景：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we have an API to allow the client code to set the Button''s pop-up
    menu:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提供了一个API，允许客户端代码设置按钮的弹出菜单：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a completely new custom button control that looks
    just like a regular native button but has a drop-down arrow and will show a `Menu`
    when clicked on. Using `RendererNative` to handle most of the drawing has greatly
    simplified the creation of this nice-looking control, so let's take a look at
    how it all came together.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个全新的自定义按钮控件，它看起来就像一个普通的本地按钮，但有一个下拉箭头，点击时会显示一个`菜单`。使用`RendererNative`来处理大部分绘图工作极大地简化了这个看起来很棒的控件的创建过程，所以让我们看看它是如何整合在一起的。
- en: 'Let''s start by looking at the `OnPaint` method, since it is where the control
    gets drawn. First, we created the required `PaintDC`, and then we used this to
    create a `GCDC` that will allow us to draw anti-aliased text just like the native
    control has. Then we get a reference to the `RendererNative` singleton by calling
    the classes `Get` method. Next, we start drawing the control. All the `RenderNative`
    methods take the same four arguments: the window we are drawing on, a DC, the
    `Rect`, and the renderer flags. `DrawPushButton` will draw a native button control
    with the given DC in the state specified by the renderer flag''s bitmask. We pass
    in one of three flags in this example: `0` for the default state, `CONTROL_CURRENT`
    for the hover-over state, and `CONTROL_PRESSED` for when the control is pressed.
    We finish up the rest with `DrawLabel` and `DrawDropArrow` to draw the button''s
    label with a down arrow to the right of it.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 `OnPaint` 方法开始，因为这是控件被绘制的地方。首先，我们创建了所需的 `PaintDC`，然后我们使用它来创建一个 `GCDC`，这将允许我们绘制与原生控件一样的抗锯齿文本。然后，我们通过调用类的
    `Get` 方法来获取 `RendererNative` 单例的引用。接下来，我们开始绘制控件。所有的 `RenderNative` 方法都接受相同的四个参数：我们正在绘制的窗口、一个
    DC、一个 `Rect` 和渲染器标志。`DrawPushButton` 将使用给定的 DC 和由渲染器标志的位掩码指定的状态绘制一个原生按钮控件。在这个例子中，我们传递了三个标志之一：`0`
    表示默认状态，`CONTROL_CURRENT` 表示悬停状态，`CONTROL_PRESSED` 表示控件被按下时。我们使用 `DrawLabel` 和
    `DrawDropArrow` 完成剩余部分，以绘制带有右侧向下箭头的按钮标签。
- en: To make this behave like a button, we bind to a number of mouse events in the
    `__init__` method of our control. `EVT_ENTER_WINDOW` and `EVT_LEAVE_WINDOW` are
    used to toggle the hover-over state by changing the control flag between `CONTROL_CURRENT`
    and `0\. EVT_LEFT_DOWN` is used to set the `CONTROL_PRESSED` state, and finally
    `EVT_LEFT_UP` is used to show the pop-up menu. After each state change, `Refresh`
    is called to re-invoke the `OnPaint` handler and draw the control in its new state.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个控件表现得像一个按钮，我们在控件的`__init__`方法中绑定了一系列鼠标事件。`EVT_ENTER_WINDOW`和`EVT_LEAVE_WINDOW`用于通过在`CONTROL_CURRENT`和`0`之间切换控件标志来切换悬停状态，`EVT_LEFT_DOWN`用于设置`CONTROL_PRESSED`状态，最后`EVT_LEFT_UP`用于显示弹出菜单。在每次状态改变后，调用`Refresh`以重新调用`OnPaint`处理程序并绘制控件的新状态。
- en: There's more...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Included below are some quick reference tables that list the drawing commands
    for `RendererNative`, and the state flags that affect how it draws the control.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了一些快速参考表格，其中包含了`RendererNative`的绘图命令以及影响其绘制控件状态的标志位。
- en: Drawing Methods
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘图方法
- en: 'The following table is a quick reference to the `RendererNative` methods. All
    the methods take the same first four arguments: `window, DC, rect`, and `flags`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格是`RendererNative`方法的快速参考。所有方法都接受相同的四个初始参数：`window, DC, rect`和`flags`。
- en: '| `RendererNative` methods | Description |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `RendererNative` 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `DrawCheckBox` | Draws a `CheckBox` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `DrawCheckBox` | 绘制复选框 |'
- en: '| `DrawChoice` | Draws a `Choice` control |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `DrawChoice` | 绘制一个 `Choice` 控件 |'
- en: '| `DrawComboBox` | Draws a `ComboBox` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `DrawComboBox` | 绘制一个 `ComboBox` |'
- en: '| `DrawComboBoxDropButton` | Draws a `ComboBox` button |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `DrawComboBoxDropButton` | 绘制一个 `ComboBox` 按钮 |'
- en: '| `DrawDropArrow` | Draws a drop arrow |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `DrawDropArrow` | 绘制下拉箭头 |'
- en: '| `DrawHeaderButton` | Draws a `ListCtrl` column header |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `DrawHeaderButton` | 绘制 `ListCtrl` 列表头 |'
- en: '| `DrawItemSelectionRect` | Draws a selection rectangle |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `DrawItemSelectionRect` | 绘制选择矩形 |'
- en: '| `DrawPushButton` | Draws a `Button` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `DrawPushButton` | 绘制一个 `按钮` |'
- en: '| `DrawRadioButton` | Draws a `RadioButton` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `DrawRadioButton` | 绘制一个 `RadioButton` |'
- en: '| `DrawSplitterBorder` | Draws the border of a `SplitterWindow` sash |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `DrawSplitterBorder` | 绘制 `SplitterWindow` 边框 |'
- en: '| `DrawSplitterSash` | Draws a `SplitterWindow` sash |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `DrawSplitterSash` | 绘制一个 `SplitterWindow` 分隔条 |'
- en: '| `DrawTextCtrl` | Draws a `TextCtrl` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `DrawTextCtrl` | 绘制一个 `TextCtrl` |'
- en: '| `DrawTreeItemButton` | Draws a `TreeCtrl` node button |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `DrawTreeItemButton` | 绘制 `TreeCtrl` 节点按钮 |'
- en: Control Flags
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制标志
- en: 'The following flags can be passed as a part of a bitmask to the draw method''s
    `flags` parameter. Not passing any flags, or passing `0` for the `flags` parameter,
    results in the control being drawn in its default state:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标志可以作为位掩码的一部分传递给绘制方法的`flags`参数。不传递任何标志，或为`flags`参数传递`0`，将导致控件以默认状态绘制：
- en: '| Flags | Description |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Flags | 描述 |'
- en: '| --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CONTROL_CHECKABLE` | Control can be checked (for `DrawCheckBox)` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_CHECKABLE` | 控件可以被检查（用于 `DrawCheckBox`） |'
- en: '| `CONTROL_CHECKED` | Control is checked (for `DrawCheckBox)` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_CHECKED` | 控件被检查（用于 `DrawCheckBox`） |'
- en: '| `CONTROL_CURRENT` | Mouse is over the control |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_CURRENT` | 鼠标悬停在控制上 |'
- en: '| `CONTROL_DISABLED` | Control is disabled |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_DISABLED` | 控制已禁用 |'
- en: '| `CONTROL_EXPANDED` | Only for `DrawTreeItemButton` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_EXPANDED` | 仅适用于 `DrawTreeItemButton` |'
- en: '| `CONTROL_FOCUSED` | Control has the keyboard focus |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_FOCUSED` | 控制拥有键盘焦点 |'
- en: '| `CONTROL_ISDEFAULT` | Is default control (for `DrawPushButton)` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_ISDEFAULT` | 是否为默认控制（对于 `DrawPushButton`） |'
- en: '| `CONTROL_PRESSED` | Button is pressed |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_PRESSED` | 按钮被按下 |'
- en: '| `CONTROL_SELECTED` | Control is selected |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_SELECTED` | 控制已选中 |'
- en: '| `CONTROL_UNDETERMINED` | `CheckBox` is in undetermined state |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `CONTROL_UNDETERMINED` | `复选框`处于不确定状态 |'
- en: See also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Playing with the mouse* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for some additional examples of working with
    `MouseEvents`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第2章](ch02.html "第2章。响应事件")中的*使用鼠标*食谱，*响应事件*部分，以获取一些使用`MouseEvents`的额外示例。
- en: Reducing flicker in drawing routines
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低绘图过程中的闪烁
- en: Flicker occurs when the redrawing of the window leads to a visible flashing
    in the user interface. Even simple drawing routines, when done improperly, can
    lead to flicker. Luckily there are a number of things that can be done to combat
    and minimize flicker, which will then lead to an improved look and feel in an
    application's interface. This recipe shows a few snippets of three techniques
    that can be used to reduce flicker in drawing routines. The sample code that accompanies
    this chapter includes a sample application that uses all of these techniques in
    a simple animated wristwatch control.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口重绘导致用户界面出现可见闪烁时，就会发生闪烁现象。即使简单的绘图程序，如果操作不当，也可能引起闪烁。幸运的是，有几种方法可以用来对抗和最小化闪烁，从而改善应用程序界面的外观和感觉。本食谱展示了三种可以用来减少绘图程序中闪烁的技术片段。本章附带的示例代码包括一个示例应用程序，该应用程序使用所有这些技术来创建一个简单的动画手表控制。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will start with one of the simplest techniques, which is to avoid unnecessary
    background erasure events by binding to `EVT_ERASE_BACKGROUND:`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的技术开始，即通过绑定到`EVT_ERASE_BACKGROUND:`来避免不必要的背景擦除事件。
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we need do nothing in the handler for it, in order to prevent it from
    erasing the background:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在处理程序中我们不需要对它做任何事情，以防止它擦除背景：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next technique is to use a buffered `PaintDC` in the `OnPaint` handler,
    so that all the individual drawing steps are performed off-screen, and then the
    finished product is displayed on the screen in one step:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技巧是在`OnPaint`处理程序中使用带缓冲的`PaintDC`，这样所有的单个绘图步骤都将在屏幕外执行，然后一次性将完成的产品显示在屏幕上：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The third technique is to just redraw the bare minimum of the screen when possible,
    by using the `Refresh` method''s `rect` argument to tell it the part of the window
    that needs to be updated:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种技巧是在可能的情况下只重新绘制屏幕的最小部分，通过使用`Refresh`方法的`rect`参数来告诉它需要更新的窗口部分：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first technique that was shown creates an empty event handler and bind it
    to the `EVT_ERASE_BACKGROUND` event. This is usually the first thing to try when
    you are running into flicker issues in your drawing routines. By doing nothing
    in the event handler, we prevent the system from clearing the background, so that
    when we draw it again in `OnPaint` it will draw over the existing background.
    This reduces the visibility of the redraw because the background won't flash to
    white in between `EVT_ERASE_BACKGROUND` and `EVT_PAINT`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的第一种技术是创建一个空的事件处理程序并将其绑定到 `EVT_ERASE_BACKGROUND` 事件。当你遇到绘图程序中的闪烁问题时，这通常是首先要尝试的事情。在事件处理程序中不执行任何操作，我们防止系统清除背景，这样当我们再次在
    `OnPaint` 中绘制时，它将覆盖现有的背景。这减少了重绘的可见性，因为背景在 `EVT_ERASE_BACKGROUND` 和 `EVT_PAINT`
    之间不会闪烁成白色。
- en: The second technique uses an `AutoBufferedPaintDCFactory` in order to create
    a buffered `PaintDC` instead of a regular `PaintDC` in the `OnPaint` handler.
    Buffered DCs do all the drawing in an off-screen `Bitmap` and then `Blit` the
    whole new `Bitmap` to the screen in one operation. This greatly reduces flicker
    because the screen gets updated in one single change instead of many individual
    changes when drawing to the screen directly in an unbuffered DC.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术使用`AutoBufferedPaintDCFactory`来在`OnPaint`处理程序中创建一个缓冲的`PaintDC`，而不是常规的`PaintDC`。缓冲的DC在屏幕外的`Bitmap`上完成所有绘图，然后在一个操作中将整个新的`Bitmap``Blit`到屏幕上。这大大减少了闪烁，因为屏幕的更新是在一次单一的改变中完成的，而不是在直接向未缓冲的DC绘制屏幕时进行的许多个别改变。
- en: The final technique shown was to only redraw the minimal part of the screen
    that needs to be redrawn. This technique can be used when a control needs to manually
    redraw only a part of itself due to a state change. For example, imagine a control
    that consists of some label text and an image. If the control has the behavior
    to change the label color on mouse over, it could call Refresh on itself using
    the `rect` argument to specify just the label's rectangle in the control, so that
    only that part of the control is updated, minimizing the area of the screen that
    is redrawn.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的最后一项技术是只重新绘制需要重新绘制的屏幕最小部分。这项技术可以在控制需要由于状态变化而手动重新绘制自身的一部分时使用。例如，想象一个由一些标签文本和一张图片组成的控制。如果控制具有在鼠标悬停时更改标签颜色的行为，它可以使用`rect`参数调用自身的Refresh方法来指定控制中标签的矩形，这样只有控制的那部分被更新，最小化重新绘制屏幕的面积。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Handling events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* explains the basics of event handling.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章。响应事件")中的“*处理事件*”食谱，*响应事件*解释了事件处理的基本原理。'
- en: See the *Using a GraphicsContext* recipe in this chapter for more detailed information
    on using the `GraphicsContext` class for drawing gradients.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的*使用 GraphicsContext* 菜谱，以获取有关使用 `GraphicsContext` 类绘制渐变的更详细信息。
- en: See the *Using Timers* recipe in [Chapter 11](ch11.html "Chapter 11. Using Threads
    and Timers to Create Responsive Interfaces"), *Using Threads and Timers to Create
    Responsive Interfaces* for more information on using timers.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第11章](ch11.html "第11章。使用线程和定时器创建响应式界面")中的*使用定时器*配方，以获取有关使用定时器的更多信息。
