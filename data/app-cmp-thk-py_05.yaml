- en: '*Chapter 4*: Understanding Logical Reasoning'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：理解逻辑推理'
- en: In this chapter, we will explore logical reasoning processes such as conditional
    statements, algorithmic reasoning, and Boolean logic. We will explore inductive
    and deductive reasoning before delving deeper into some logic operators. We will
    also learn about logic errors, how to identify them, and how to correct them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨条件语句、算法推理和布尔逻辑等逻辑推理过程。在深入研究一些逻辑运算符之前，我们将探讨归纳和演绎推理。我们还将学习逻辑错误，如何识别它们以及如何纠正它们。
- en: In addition, we will be looking at writing algorithms using logic to solve computational
    thinking problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将研究使用逻辑来编写算法以解决计算思维问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the importance of logical reasoning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解逻辑推理的重要性
- en: Using Boolean logic and operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔逻辑和运算符
- en: Identifying logic errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别逻辑错误
- en: When solving computational thinking problems, logical reasoning is necessary.
    We all know that programming code has steps that are followed linearly. Imagine
    we have 10 lines of code. If we do not apply logical reasoning, the code reads
    one line at a time—reads the first line, reads the second line, and so on until
    the last one. Using logical reasoning allows us to compare things before moving
    on, return to a previous line of code, and much more. Throughout this chapter,
    we will learn about logical reasoning in order to create algorithms that address
    problems in efficient ways using logic operators.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决计算思维问题时，逻辑推理是必要的。我们都知道编程代码有按顺序执行的步骤。想象一下我们有10行代码。如果我们不应用逻辑推理，代码会一行一行地读取——读取第一行，读取第二行，依此类推，直到最后一行。使用逻辑推理允许我们在继续之前比较事物，返回到以前的代码行，等等。在本章中，我们将学习逻辑推理，以便使用逻辑运算符以高效的方式解决问题并创建算法。
- en: In order to understand logical reasoning, we will begin by defining logic in
    general, then how to use logic when designing and writing algorithms.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解逻辑推理，我们将首先概括逻辑的一般定义，然后讨论在设计和编写算法时如何使用逻辑。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter04](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter04)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要最新版本的Python来运行本章中的代码。您可以在此处找到本章使用的完整源代码：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter04](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter04)
- en: Understanding the importance of logical reasoning
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解逻辑推理的重要性
- en: As we worked through [*Chapter 3*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056),
    *Understanding* *Algorithms and Algorithmic Thinking*, we learned how to design
    some basic algorithms while solving computational thinking problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过[*第3章*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056) *理解算法和算法思维*时，我们学会了如何在解决计算思维问题时设计一些基本算法。
- en: In this section, we will understand how important logical reasoning is and how
    to apply the types of logical reasoning with the help of examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解逻辑推理的重要性以及如何通过示例应用逻辑推理的类型。
- en: As we write algorithms, we'll need to use logical reasoning to create these
    algorithms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写算法时，我们需要使用逻辑推理来创建这些算法。
- en: 'In simple terms, **logical reasoning** is the set of steps followed to reach
    a conclusion. In computational thinking, when we design algorithms, the systematic
    set of steps we follow are part of the algorithm. The way a computer reads those
    algorithms depends on how we write that algorithm. There are two types of logical
    reasoning arguments, which are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**逻辑推理**是达成结论所遵循的一系列步骤。在计算思维中，当我们设计算法时，我们遵循的系统步骤是算法的一部分。计算机读取这些算法的方式取决于我们编写算法的方式。逻辑推理论证有两种类型，如下所示：
- en: '**Inductive reasoning**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**归纳推理**'
- en: '**Deductive reasoning**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演绎推理**'
- en: Before we define those in more depth, let's look at why logical reasoning is
    so important and why order matters when we create algorithms.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在更深入地定义这些之前，让我们看看为什么逻辑推理如此重要，以及在创建算法时为什么顺序很重要。
- en: In order to analyze a problem and provide an algorithm that helps us tackle
    the problem, we need to understand what logical reasoning is first. Logic can
    be daunting for some, but we use it every day subconsciously.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析问题并提供帮助我们解决问题的算法，我们首先需要了解什么是逻辑推理。对于一些人来说，逻辑可能令人望而生畏，但我们每天都在下意识地使用它。
- en: Let's look at a simple example. Say you take a shower every morning and go to
    work. *Well, would you get dressed for work before the shower?* No, because that
    would make absolutely no sense. Logically, you'd have to shower first before you
    put on your clothes for work. Now, I've skipped a ton of steps here, but those
    steps are logical steps. Other examples of logic include following recipes, using
    an umbrella if it's raining (or not), and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子。假设您每天早上洗澡然后去上班。*那么，您会在洗澡之前穿上工作服吗？*不会，因为那完全没有意义。从逻辑上讲，您必须先洗澡，然后再穿上工作服。现在，我在这里跳过了很多步骤，但这些步骤是逻辑步骤。其他逻辑的例子包括按照食谱制作食物，下雨时使用伞（或不使用），等等。
- en: Throughout this chapter, we'll weave in and out of logical reasoning and designing
    algorithms using **logical operators**. A logical operator allows a program to
    make decisions. We use those too in everyday life without realizing it. For example,
    if it's sunny and warm, we may want to go biking, but not if it's sunny and cold.
    The *and* here is a logical operator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将交替讨论逻辑推理和使用**逻辑运算符**设计算法。逻辑运算符允许程序做出决策。我们在日常生活中也会使用它们，只是没有意识到而已。例如，如果天气晴朗而温暖，我们可能想去骑自行车，但如果天气晴朗但寒冷就不想去。这里的*and*是一个逻辑运算符。
- en: We take a lot of things into consideration when we're making decisions. In computational
    thinking, especially in algorithm design, we need to consider those things and
    provide a way for the program to test those conditions. We will delve deeper into
    logical operators later in this chapter. For now, let's look more closely at the
    types of logical reasoning and how to apply them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在做决定时，我们考虑了很多因素。在计算思维中，特别是在算法设计中，我们需要考虑这些因素，并为程序提供一种测试这些条件的方法。我们将在本章后面更深入地探讨逻辑运算符。现在，让我们更仔细地看看逻辑推理的类型以及如何应用它们。
- en: Applying inductive reasoning
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用归纳推理
- en: When we talk about inductive reasoning, we're really working backward. Inductive
    reasoning starts from a conclusion, which may be true or not, and works backward
    to create the code using the existing data. Let's look at a simple problem first.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论归纳推理时，我们实际上是在向后工作。归纳推理从一个可能为真或假的结论开始，然后向后使用现有数据创建代码。让我们先看一个简单的问题。
- en: Solving an inductive reasoning sample problem
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决归纳推理样本问题
- en: 'We have a budget of $150 for buying supplies: art pencils and erasers. The
    art pencils are $1.75 each and the erasers are $1.50 each.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有150美元的预算用于购买美术用铅笔和橡皮擦。美术用铅笔每支1.75美元，橡皮擦每个1.50美元。
- en: Remember, in computational thinking, we decompose the problem first, then we
    identify the pattern, then we generalize that pattern, and then we create the
    algorithm. So, let's recognize that pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在计算思维中，我们首先分解问题，然后识别模式，然后概括该模式，然后创建算法。因此，让我们认识到这种模式。
- en: 'Let''s look at what we know so far and name some variables:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看到目前为止我们知道的内容并命名一些变量：
- en: The total budget is $150.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总预算是150美元。
- en: The cost of pencils is $1.75 each.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 铅笔的成本是每支1.75美元。
- en: The cost of erasers is $1.50 each.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 橡皮擦的成本是每个1.50美元。
- en: Let's denote the number of pencils by *p*.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在让我们用*p*表示铅笔的数量。
- en: Let's denote the number of erasers by *n*.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们用*n*表示橡皮擦的数量。
- en: Remember that when we get to that algorithm, we may want to rename those variables.
    But for now, since we're going to look at mathematical algorithms first, we'll
    keep the simple variables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们到达算法时，我们可能想要重新命名这些变量。但现在，因为我们首先要看数学算法，所以我们会保留简单的变量。
- en: We can do this in one inequality. *Why an inequality and not an equation?* Because
    our total may not be exactly $150\. But it can't be *more* than $150 because that's
    all the money we have.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个不等式来表示。*为什么是不等式而不是方程？*因为我们的总额可能不会正好是150美元。但它不能超过150美元，因为那是我们所有的钱。
- en: Because this is a simple problem, we're identifying and generalizing that pattern
    in one move.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个简单的问题，我们一举识别和概括了这个模式。
- en: 'So, the number of pencils times the cost plus the number of erasers times the
    cost is less than or equal to $150:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，铅笔的数量乘以成本加上橡皮擦的数量乘以成本小于或等于150美元：
- en: '![](image/Formula_B15413_04_001.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Formula_B15413_04_001.png)'
- en: Now let's talk about the algorithm design. Maybe this is something I buy regularly
    because I run art classes. I'm going to go off that scenario. Maybe my employer
    gives me at most $150, but depending on what I used before, I may need more pencils
    than erasers and vice versa. So, I need a program that I can use and reuse at
    the beginning of every term. *Was this part of my problem?* No, this was an ill-defined
    problem. So, I'm adapting the problem based on a set of particular needs. In short,
    I'm defining the problem I want to solve.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈算法设计。也许这是我定期购买的东西，因为我开美术课。我会根据这种情况进行。也许我的雇主最多给我150美元，但根据以前使用的情况，我可能需要更多的铅笔或橡皮擦，反之亦然。因此，我需要一个可以在每学期开始时使用和重复使用的程序。*这是我的问题的一部分吗？*不，这是一个定义不清晰的问题。因此，我正在根据一组特定需求调整问题。简而言之，我正在定义我想要解决的问题。
- en: 'Important Note:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: As a side note for an inductive and deductive reasoning dilemma, it is important
    to understand that conditional statements, such as the `if`/`then` statements
    we use often in programming, are usually associated with deductive reasoning.
    We can go into a debate about whether or not they can be inductive, but the truth
    is, inductive reasoning problems will use deductive reasoning. We will look in
    depth at deductive reasoning statements in the next section of this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为归纳和演绎推理困境的一则旁注，重要的是要理解，条件语句（例如我们在编程中经常使用的`if`/`then`语句）通常与演绎推理相关联。我们可以就它们是否可以是归纳的进行辩论，但事实是，归纳推理问题将使用演绎推理。我们将在本章的下一节深入研究演绎推理陈述。
- en: 'So, I want the program to ask me how many pencils I want or I want it to ask
    me how many erasers I want. It all depends! Let''s look at what the program should
    do for us. The following steps show us this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我希望程序问我想要多少支铅笔，或者问我想要多少个橡皮擦。这完全取决于情况！让我们看看程序应该为我们做些什么。以下步骤向我们展示了这一点：
- en: Ask whether your input will be pencils or erasers.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问您的输入是铅笔还是橡皮擦。
- en: Choose an inequality to use based on the input provided.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据提供的输入选择要使用的不等式。
- en: Identify how many of the pencils or erasers are possible (given the input).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定可能的铅笔或橡皮擦的数量（根据输入）。
- en: Give a total cost for the number of pencils and erasers.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出铅笔和橡皮擦的总成本。
- en: Please note that, as always, there are a lot of ways to arrive at the same answers
    in Python. While some of these programs are longer than what I would normally
    present, since we're learning both computational thinking and Python programming,
    it's important to show steps that are easy to understand.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像往常一样，有很多种方法可以在Python中得出相同的答案。虽然其中一些程序比我通常呈现的要长，但由于我们正在学习计算思维和Python编程，展示易于理解的步骤非常重要。
- en: For this particular program, we're going to need to import the math functions
    so that we can round down. *Why do we need to do that?* Well, we can't buy parts
    of erasers and pencils, only whole pencils and whole erasers. So, if the program
    says we can buy 19.5 pencils, that really means we can only purchase 19 pencils.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的程序，我们需要导入数学函数，以便我们可以向下取整。*为什么我们需要这样做？*嗯，我们不能购买部分橡皮擦和铅笔，只能购买整支铅笔和整个橡皮擦。因此，如果程序说我们可以购买19.5支铅笔，那实际上意味着我们只能购买19支铅笔。
- en: The `math.floor()` function allows us to round that number down to 19 with the
    simple function. We will explore more of the `math` functions as we go along in
    this book. Before we leave this quick topic, you should know that the `math` module
    in Python has built-in functions that align with the C language functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`math.floor()` 函数允许我们使用简单的函数将该数字向下舍入到 19。在本书中，我们将更多地探讨 `math` 函数。在我们离开这个快速主题之前，你应该知道
    Python 中的 `math` 模块具有与 C 语言函数相匹配的内置函数。'
- en: 'Let''s go back to the problem. Take a look at the following written program:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到问题。看一下下面的编程：
- en: ch4_inductiveP1.py
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_inductiveP1.py
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Remember that the preceding program will run the lines of code in order (sequentially).
    So, if a user inputs `erasers` first, then the first `if` statement and the nested
    `if` statement are ignored. If the user enters `pencils` first, then the algorithm
    runs normally from the first `if` statement and goes through the remaining conditions.
    Here''s what the program does, in order:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，上述程序将按顺序运行代码行（顺序）。因此，如果用户首先输入 `橡皮擦`，那么第一个 `if` 语句和嵌套的 `if` 语句将被忽略。如果用户首先输入
    `铅笔`，那么算法将从第一个 `if` 语句正常运行，并通过剩余条件。以下是程序的顺序操作：
- en: Asks the user to input whether they are buying pencils or erasers.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要求用户输入他们是在买铅笔还是橡皮擦。
- en: If the user enters pencils, then the program asks how many pencils they'll purchase.
    Then, it calculates the number of erasers they can afford to buy.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入铅笔，那么程序会询问他们要购买多少支铅笔。然后，它会计算他们能够购买多少个橡皮擦。
- en: If the user enters a number of pencils that is too large, they'll get a message
    that they can't afford that amount.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入的铅笔数量太多，他们将收到一条消息，说明他们买不起那么多。
- en: If the user enters erasers, then the program asks how many erasers they'll purchase,
    then calculates the number of pencils the user can afford to buy.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入橡皮擦，那么程序会询问他们要购买多少个橡皮擦，然后计算用户能够购买多少支铅笔。
- en: If the user enters a number of erasers that is too large, they'll get a message
    that they can't afford that amount.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入的橡皮擦数量太多，他们将收到一条消息，说明他们买不起那么多。
- en: If the user enters neither pencils nor erasers, they'll get a message to run
    the program again and enter one of those two options.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户既不输入铅笔也不输入橡皮擦，他们将收到一条消息，要求重新运行程序并输入这两个选项中的一个。
- en: The preceding is an oversimplified inductive reasoning problem. Some inductive
    reasoning problems will ask that you look at data, make some probable conclusions,
    and then write a program to test those conclusions. In the process of learning
    logical reasoning, we are essentially training ourselves to look at decisions
    and how to process them in a way that a program can return the output we are looking
    for.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上面是一个过于简化的归纳推理问题。一些归纳推理问题会要求你查看数据，得出一些可能的结论，然后编写一个程序来测试这些结论。在学习逻辑推理的过程中，我们基本上是在训练自己如何看待决策以及如何以程序可以返回我们所期望的输出的方式来处理它们。
- en: It is important to note here that there are multiple ways to look at problems
    and prepare solutions. While I prefer decision trees and flow-charts, other programmers
    and developers work more mathematically. Yet others like to write down what the
    program needs to do in simple sentences and/or paragraphs. The point of this process
    is to allow us to create a program that produces the necessary output and is easy
    to follow logically by both the programmers and developers and the computer running
    it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，有多种方法可以看待问题并准备解决方案。虽然我更喜欢决策树和流程图，其他程序员和开发人员更倾向于更数学化的方法。还有一些人喜欢用简单的句子和/或段落写下程序需要做的事情。这个过程的目的是让我们创建一个能够产生必要输出并且逻辑上易于程序员、开发人员和运行它的计算机理解的程序。
- en: Now, let's take a look at deductive reasoning.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看演绎推理。
- en: Applying deductive reasoning
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用演绎推理
- en: We're now at the section of this chapter that focuses on deductive reasoning.
    Even when I was a mathematics student, I found deductive reasoning fascinating.
    I quickly learned that mathematics taught us how to follow arguments logically
    in geometry and I fell in love with all things logic and truth tables.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到本章重点讨论演绎推理的部分。即使我是一名数学学生，我也发现演绎推理很迷人。我很快就学会了数学如何教导我们如何在几何中逻辑地跟随论点，我爱上了所有逻辑和真值表的事物。
- en: Logic is taught using proofs and inductive and deductive reasoning. Truth tables
    help us analyze conditions. In truth tables, some things are assumed. For example,
    a statement is either true or false. The other statement is true or false. A combination
    of those statements depends on whether or not the statements are true or false.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑是通过证明和归纳和演绎推理来教授的。真值表帮助我们分析条件。在真值表中，有一些假设。例如，一个陈述要么是真的，要么是假的。另一个陈述也是真的或假的。这些陈述的组合取决于这些陈述是真还是假。
- en: Alright, that's a bit complicated. Before I move on to explain deductive reasoning,
    let's look at a quick truth table and the logic process it contains.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这有点复杂。在我继续解释演绎推理之前，让我们先看一个快速的真值表和其中包含的逻辑过程。
- en: Truth tables were critical when I first started coding. They helped me understand
    the coding processes and how to work with conditions. Not every programmer or
    coder uses these tables, but I find them helpful, even if not used explicitly
    in the decision-making process. Let's look at one now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 真值表在我刚开始编码时非常重要。它们帮助我理解编码过程以及如何处理条件。并不是每个程序员或编码人员都使用这些表，但我发现它们很有帮助，即使在决策过程中没有明确使用。现在让我们来看一个。
- en: 'Let''s say we have a statement or condition `p` and that condition is `True`.
    Let''s say that we have another statement or condition `q` and that it is also
    `True`. In truth tables, we use the symbol ¬ to denote *NOT*. So, ¬ `p` ¬ is `False`
    and ¬ `q` is also `False`. That''s because if `p` is `True`, then *NOT* `p` is
    *NOT* `True`, in other words, `False`. The symbol ![](image/AND_symbol.png) is
    used for *AND*, so `p` *AND* `q` is written as `p ![](image/AND_symbol1.png) q`.
    The symbol `![](image/OR_symbol.png)` is used for *OR*, so `p` *OR* `q` is written
    as `p ![](image/OR_symbol.png) q`. In table format, our truth table looks as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个陈述或条件`p`，并且该条件为`True`。假设我们有另一个陈述或条件`q`，并且它也为`True`。在真值表中，我们使用符号¬来表示*NOT*。所以，¬`p`¬是`False`，¬`q`也是`False`。这是因为如果`p`是`True`，那么*NOT*`p`就是*NOT*`True`，换句话说，就是`False`。符号![](image/AND_symbol.png)用于*AND*，所以`p`*AND*`q`写作`p
    ![](image/AND_symbol1.png) q`。符号`![](image/OR_symbol.png)`用于*OR*，所以`p`*OR*`q`写作`p
    ![](image/OR_symbol.png) q`。在表格格式中，我们的真值表如下：
- en: '![Figure 4.1 – Truth table'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - 真值表'
- en: '](image/Figure_4.1_B15413.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.1_B15413.jpg)'
- en: Figure 4.1 – Truth table
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - 真值表
- en: Analyzing a truth table and understanding all the possible conditions can take
    time, but the process is similar to what we go through in logical reasoning when
    writing algorithms for problems. Now, let's take a closer look at deductive reasoning.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 分析真值表并理解所有可能的条件可能需要时间，但这个过程类似于我们在编写问题的逻辑推理时经历的过程。现在，让我们更仔细地看看演绎推理。
- en: Let's first define what deductive reasoning is. **Deductive reasoning** is the
    process of going from a statement or hypothesis to a conclusion. Because deductive
    reasoning is what we use in algorithmic design, for the most part, we will need
    to define some terms associated with it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义什么是演绎推理。**演绎推理**是从一个陈述或假设到结论的过程。因为演绎推理是我们在算法设计中使用的，所以在很大程度上，我们需要定义一些与之相关的术语。
- en: Let's start with conditional statements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从条件陈述开始。
- en: Learning about conditional statements
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习条件陈述
- en: '**Conditional statements** are if/then statements. Here are a few logical arguments
    using conditional statements:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件陈述**是if/then语句。以下是一些使用条件陈述的逻辑论据：'
- en: If it rains, then I'll use an umbrella.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下雨，我会用伞。
- en: If I drink water, then I won't be thirsty.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我喝水，那么我就不会渴了。
- en: If my dog needs to go out, then he stands by the door.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我的狗需要出去，那么它会站在门边。
- en: If a quadrilateral has four right angles, then it is a rectangle.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个四边形有四个直角，那么它是一个矩形。
- en: All the preceding statements are examples of conditional statements. The first
    part of the statement is called the **hypothesis**. The second part of the statement
    is the **conclusion**. In the statement *If it rains, then I'll use an umbrella*,
    the hypothesis is *it rains* and the conclusion is *use an umbrella*. We do not
    include *if* or *then* in the hypotheses and conclusions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述陈述都是条件陈述的例子。陈述的第一部分称为**假设**。陈述的第二部分是**结论**。在陈述*如果下雨，我会用伞*中，假设是*下雨*，结论是*用伞*。我们在假设和结论中不包括*if*或*then*。
- en: 'In Python, as you saw in the example in the *Applying inductive reasoning*
    section, we use `if`/`then` statements when writing algorithms often. Here are
    some of the logical statements we use in Python:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，正如您在*应用归纳推理*部分的示例中看到的，我们在编写算法时经常使用`if`/`then`语句。以下是我们在Python中使用的一些逻辑陈述：
- en: '`if`: When using `if` statements, we ask whether a condition is met, then do
    something based on that true or false condition.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`：在使用`if`语句时，我们询问条件是否满足，然后根据真假条件执行某些操作。'
- en: '`if-else`: When using `if-else` statements, we test one condition and do something,
    but if that condition is not met, then we do something else.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if-else`：在使用`if-else`语句时，我们测试一个条件并执行某些操作，但如果条件不满足，那么我们执行其他操作。'
- en: '`if-elif-else`: When using `if-elif-else` statements, we have one condition;
    if that''s not met, we test another condition—that is, the **else if** (**elif**)
    condition—otherwise, we do something else.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if-elif-else`：在使用`if-elif-else`语句时，我们有一个条件；如果条件不满足，我们测试另一个条件，即**else if**（**elif**）条件，否则，我们执行其他操作。'
- en: All of the preceding statements can be nested. I can test one condition, then
    another, then another. I can have multiple `elif` statements between `if` and
    `else`, and so on. Let's look at some examples.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述陈述都可以嵌套。我可以测试一个条件，然后另一个条件，然后另一个条件。我们可以在`if`和`else`之间有多个`elif`语句，依此类推。让我们看一些例子。
- en: if statements
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if语句
- en: 'Let''s look at a program that only uses one `if` statement:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个只使用一个`if`语句的程序：
- en: ch4_ifStatement.py
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_ifStatement.py
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the preceding code is a simple program, and one that only checks one condition.
    We could add conditions to test whether `number` is equal to `100`. We can add
    another one if `number` is larger than `100`, and so on. In this case, we only
    cared if `number` was below `100`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，上述代码是一个简单的程序，只检查一个条件。我们可以添加条件来测试`number`是否等于`100`。如果`number`大于`100`，我们可以添加另一个条件，依此类推。在这种情况下，我们只关心`number`是否小于`100`。
- en: 'If we input the number `53`, we''ll get the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入数字`53`，我们将得到以下输出：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we input the number `100`, we won''t get any message at all and the program
    will end:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入数字`100`，我们将得不到任何消息，程序将结束：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you see, the program doesn't have anything to add. The condition wasn't met,
    so it ended. That's why `if-else` statements can come in handy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，程序没有任何要添加的内容。条件没有满足，所以它结束了。这就是为什么`if-else`语句会派上用场的原因。
- en: if-else statements
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if-else语句
- en: 'Let''s look at the previous algorithm and add an `else` statement. The previous
    program only checked whether the number provided was less than `100`. If we add
    an `else` statement, we can print something else on the screen for all numbers
    greater than or equal to `100`. Take a look at the following program:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以前的算法，并添加一个`else`语句。以前的程序只检查提供的数字是否小于`100`。如果我们添加一个`else`语句，我们可以在屏幕上打印其他所有大于或等于`100`的数字。看看以下程序：
- en: ch4_if-elseStatement.py
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_if-elseStatement.py
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding program now prints out a message regardless of what number the
    user gives as input. Let''s test out `100` again:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序现在无论用户输入什么数字，都会打印出一条消息。让我们再次测试`100`：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `100` is included in the large numbers category because our
    condition is that the numbers are less than `100`. That means `100` is not included
    in the condition. Testing conditions is how we arrive at conclusions in Python.
    We write algorithms that gather information from the program itself or user input,
    then it tests conditions to make decisions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`100`包括在大数字类别中，因为我们的条件是数字小于`100`。这意味着`100`不包括在条件中。测试条件是我们在Python中得出结论的方式。我们编写算法从程序本身或用户输入中收集信息，然后测试条件以做出决定。
- en: 'The following chart diagram shows the flow chart for `if-else` decision-making.
    We''ll look at additional flowcharts when looking at `if-elif-else` statements
    and nested statements:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`if-else`决策的流程图。在查看`if-elif-else`语句和嵌套语句时，我们将查看其他流程图：
- en: '![Figure 4.2 – if-else statement decision flowchart'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - if-else语句决策流程图'
- en: '](image/Figure_4.2_B15413.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.2_B15413.jpg)'
- en: Figure 4.2 – if-else statement decision flowchart
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - if-else语句决策流程图
- en: As you can see in the preceding diagram, this is a binary decision. The statement
    will be tested to check whether it's **True** or **False**. If **True**, an action
    happens; otherwise, another action happens. For our number program, if the number
    was under `100`, one message is printed; otherwise, another message, `I guess
    you like large numbers`, is printed on the screen. Now, let's add multiple conditions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，这是一个二进制决策。语句将被测试以检查它是**True**还是**False**。如果**True**，则会发生一个动作；否则，会发生另一个动作。对于我们的数字程序，如果数字小于`100`，则打印一条消息；否则，在屏幕上打印另一条消息“我猜你喜欢大数字”。现在，让我们添加多个条件。
- en: if-elif-else statements
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if-elif-else语句
- en: 'An `if-elif-else` statement is a simplification of a multi-condition statement—that
    is, you can have multiple `elif` statements. As mentioned earlier, **elif** stands
    for **else if**. Let''s change our program up a bit. We''ll allow the user to
    input a number between `1` and `20`. Here''s what we''ll program the algorithm
    to do:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-elif-else`语句是多条件语句的简化形式 - 也就是说，您可以有多个`elif`语句。如前所述，**elif**代表**else if**。让我们稍微改变一下我们的程序。我们将允许用户输入一个介于`1`和`20`之间的数字。这是我们将编程算法的方式：'
- en: Ask for a number between `1` and `20`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要求输入一个介于`1`和`20`之间的数字。
- en: Test whether the number is between `1` and `10` and print a message.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试数字是否在`1`和`10`之间，并打印消息。
- en: Test whether the number is between `11` and `20` and print a message.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试数字是否在`11`和`20`之间，并打印消息。
- en: Print an error message.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印错误消息。
- en: Let's take a look at how we'd program this. We need to remember a few things
    before we write this algorithm. To check numbers between `1` and `10` easily,
    we need to check that the number is less than `10`. That means `10` is not included.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何编写这个程序。在编写此算法之前，我们需要记住一些事情。要轻松检查介于`1`和`10`之间的数字，我们需要检查数字是否小于`10`。这意味着`10`不包括在内。
- en: Our `elif` statement would then check for numbers under `21`, since it will
    only include numbers we haven't tested yet. That is, if the user inputs `12`,
    the first condition isn't met, so it moves to the second condition. Yes, that
    would include all numbers under `21`, but keep in mind that if the number had
    been less than `10`, it will have already met a condition and the program would
    have printed the right message.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`elif`语句将检查小于`21`的数字，因为它只包括我们尚未测试过的数字。也就是说，如果用户输入`12`，第一个条件不满足，所以它会转到第二个条件。是的，这将包括所有小于`21`的数字，但请记住，如果数字小于`10`，它将已经满足了一个条件，并且程序将打印正确的消息。
- en: 'Finally, if the condition isn''t met, we need to let users know they wrote
    a number that''s not between `1` and `20`. The following program demonstrates
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果条件不满足，我们需要让用户知道他们写了一个不在`1`和`20`之间的数字。以下程序演示了这一点：
- en: ch4_if-elif-elseStatement.py
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_if-elif-elseStatement.py
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s try to test this with a number under `10`. If we run the program with
    the number `8`, we see the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用一个小于`10`的数字进行测试。如果我们用数字`8`运行程序，我们会看到以下输出：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we run the program with the number `10`, we see the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用数字`10`运行程序，我们会看到以下输出：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, if we run the program with the number `21`, this is what we see:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们用数字`21`运行程序，我们会看到：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, each condition provides us with the answer for that given condition.
    Here''s the flowchart for `if-elif-else` statements:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个条件都为我们提供了该条件的答案。这是`if-elif-else`语句的流程图：
- en: '![Figure 4.3 – if-elif-else statements decision flowchart'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 - if-elif-else语句决策流程图'
- en: '](image/Figure_4.3_B15413.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.3_B15413.jpg)'
- en: Figure 4.3 – if-elif-else statements decision flowchart
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - if-elif-else语句决策流程图
- en: As you can see in the preceding diagram, `elif` just presents a new test. If
    **True**, we follow the action from the algorithm. If **False**, we move on to
    the `else` statement. That said, we can have multiple `elif` conditions. That
    means we can continue to test conditions one after the other unless and until
    we reach an `else` statement.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`elif`只是提出了一个新的测试。如果**True**，我们就会按照算法的行动。如果**False**，我们就会转到`else`语句。也就是说，我们可以有多个`elif`条件。这意味着我们可以继续一次又一次地测试条件，直到达到`else`语句为止。
- en: Understanding nested statements
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解嵌套语句
- en: 'Another type of logic statement we use in Python has to do with nested statements.
    In nested conditions, the `if` statement that is nested is only followed if the
    previous `if` statement is **True**. This is easier to understand with an example.
    Let''s go back to our `if-elif-else` statement and add some nested conditions.
    We had previously asked the user to give a number between `1` and `20`. Now, let''s
    say we want to subdivide the conditions further using the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python中我们使用的另一种逻辑语句类型涉及嵌套语句。在嵌套条件中，嵌套的`if`语句只有在前一个`if`语句为**True**时才会执行。通过一个例子更容易理解。让我们回到我们的`if-elif-else`语句，并添加一些嵌套条件。我们之前要求用户输入一个在`1`到`20`之间的数字。现在，让我们使用以下代码进一步细分条件：
- en: ch4_nestedStatements.py
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_nestedStatements.py
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, the code has a message for any time we enter
    numbers that do not meet the guidelines. For example, the input requested is between
    `1` and `20`. *But what happens if the user types 0 or 21, or another number not
    in that range?* Then, the `print()` statement provides a message that asks the
    user to run the program again.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，代码对于我们输入不符合规定的数字时有一条消息。例如，要求输入的数字在`1`到`20`之间。*但是如果用户输入0或21，或者其他不在这个范围内的数字会发生什么？*然后，`print()`语句会提供一条消息，要求用户重新运行程序。
- en: 'In this case, you can see that we have `if` statements, `elif` statements,
    nested `if` and `else` statements, and so on. Let''s see a few test cases that
    test a few conditions to see what our program says:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以看到我们有`if`语句、`elif`语句、嵌套的`if`和`else`语句等。让我们看一些测试案例，测试一些条件，看看我们的程序会说些什么：
- en: 'When we input `4`, the following output is seen:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入`4`时，我们看到以下输出：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we input `6`, we see the following:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入`6`时，我们看到以下内容：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we input `11`, we get this:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入`11`时，我们得到如下结果：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we input `18`, we get the following output:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入`18`时，我们得到以下输出：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see from the preceding test cases, we have more outputs based on
    the conditions given in the program. While this was a simple number program, we
    can use similar logic when we are solving more complex problems.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的测试案例中可以看出，我们根据程序中给定的条件有更多的输出。虽然这是一个简单的数字程序，但在解决更复杂的问题时，我们可以使用类似的逻辑。
- en: Let's say you run an online store. The selections a user makes for items are
    going to be used in similar algorithms, albeit much more complex ones. The algorithm
    tests the conditions, such as items selected, quantities selected, and so on to
    apply totals, coupons, and much more. That's why logic and logical reasoning is
    so important in programming.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你经营一个在线商店。用户选择的商品将会在类似的算法中使用，尽管这些算法要复杂得多。算法会测试条件，比如选择的商品、选择的数量等，以应用总额、优惠券等。这就是为什么逻辑和逻辑推理在编程中如此重要。
- en: Now, as mentioned previously, the logical processing we use can be different
    for individual programmers. However, regardless of preference, logical reasoning
    and logical processing are absolutely necessary when we are writing algorithms.
    Rather than diving into the writing, we process problems, look at the decision-making
    and which steps need to happen, and then we design the algorithm. That logical
    process is critical to creating effective algorithms. We will continue to look
    at logical reasoning throughout this book as we analyze problems, even if we don't
    explicitly state so.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如之前提到的，我们使用的逻辑处理对于每个程序员可能会有所不同。然而，无论偏好如何，逻辑推理和逻辑处理在我们编写算法时绝对是必不可少的。我们在编写算法时，不是直接开始写，而是处理问题，看决策和需要发生哪些步骤，然后设计算法。这种逻辑过程对于创建有效的算法至关重要。在本书中，我们将继续在分析问题时关注逻辑推理，即使我们没有明确说明。
- en: In this section, you learned about logical reasoning and its two types—inductive
    and deductive reasoning. We also learned about the conditional statements that
    will come in handy while coding.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了逻辑推理及其两种类型——归纳推理和演绎推理。我们还学习了在编码时会派上用场的条件语句。
- en: Some of the algorithms we write can be simplified using Boolean logic and operators,
    which is what we'll take a look at in the next section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的一些算法可以使用布尔逻辑和运算符进行简化，这就是我们将在下一节中看到的内容。
- en: Using Boolean logic and operators
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布尔逻辑和运算符
- en: Boolean logic refers to the operators, namely, `and`, `or`, and `not` in Python.
    You'll recall seeing this in the brief discussion on truth tables earlier in this
    chapter. As we'll see next, we use the same logical processing when writing the
    algorithms, even if the tables are not explicitly stated or used. When solving
    computational thinking problems, we sometimes have to meet multiple conditions
    at once. Let's look at this using just language for now.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑指的是Python中的`and`、`or`和`not`等运算符。你可能还记得在本章早些时候对真值表的简要讨论中看到过这些内容。接下来我们将看到，即使没有明确说明或使用这些表，我们在编写算法时仍然使用相同的逻辑处理。在解决计算思维问题时，我们有时需要同时满足多个条件。让我们现在用语言来看一下这个问题。
- en: 'Let''s sort some fruit. If the fruit is round and orange, green, or yellow,
    it will be sorted into **group 1**. If the fruit is not round, but is orange,
    green, or yellow, it will be sorted into **group 2**. If the fruit doesn''t match
    those requirements, it goes into **group 3**. Let''s simplify these groups:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分类一些水果。如果水果是圆形且橙色、绿色或黄色，它将被分类到**组1**。如果水果不是圆形，但是橙色、绿色或黄色，它将被分类到**组2**。如果水果不符合这些要求，它将被分类到**组3**。让我们简化这些组：
- en: '**Group 1**: Round AND (orange OR green OR yellow)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组1**：圆形和（橙色或绿色或黄色）'
- en: '**Group 2**: Not round AND (orange OR green OR yellow)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组2**：非圆形和（橙色或绿色或黄色）'
- en: '**Group 3**: All other fruit'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组3**：所有其他水果'
- en: 'I know I stated the round condition first. But if you take a look at *groups
    1* and *2*, the fruits need to be tested for those colors for both conditions—that
    is, if that condition is not met for color, it doesn''t matter whether the fruit
    is round or not, it goes in *group 3*. So, here''s what I''d write for an algorithm:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我先前提到了圆形条件。但是如果你看一下*组1*和*2*，水果需要针对这些颜色进行测试，无论是哪种条件——也就是说，如果颜色条件不满足，水果是否圆形并不重要，它都会被放入*组3*。所以，这是我会为算法写的内容：
- en: Test whether fruit is orange, green, or yellow.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试水果是橙色、绿色还是黄色。
- en: If yes, test whether round, and sort into *group 1* or *2*.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，测试是否圆形，并分类为*第1组*或*第2组*。
- en: If no, sort into *group 3*.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，分类为*第3组*。
- en: So, if we had a mandarin orange, that falls under *group 1*. If we had a banana,
    it would be in *group 2*. If we had strawberries, they would be in *group 3*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有一颗柑橘，那就属于*第1组*。如果我们有一根香蕉，它就属于*第2组*。如果我们有草莓，它们就属于*第3组*。
- en: Now, if we were going to write this, we'd need to make sure we've added the
    characteristics of the fruits so that we can test them against something. We will
    be looking at something like that in further chapters of this book, but for now,
    to simplify some of the learning, we'll create a similar algorithm but with numbers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们要编写这个，我们需要确保已经添加了水果的特征，以便我们可以对其进行测试。我们将在本书的后续章节中看到类似的内容，但现在，为了简化一些学习，我们将创建一个类似的算法，但使用数字。
- en: 'Before we move on too much, let''s take a quick look at the basic operators
    in Python:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们快速看一下Python中的基本运算符：
- en: '![Figure 4.4 – Basic Python operators'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 - 基本的Python运算符'
- en: '](image/Figure_4.4_B15413.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.4_B15413.jpg)'
- en: Figure 4.4 – Basic Python operators
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 基本的Python运算符
- en: We'll go deeper into these operators when we get to *Section 2*, *Applying Python
    and Computational Thinking*, and take a deeper look at the Python programming
    language. However, we will need to use some of these for the next algorithm. First,
    let's look at the `and` operator.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达*第2节*，*应用Python和计算思维*时，我们将更深入地了解这些运算符，并深入研究Python编程语言。然而，我们需要在下一个算法中使用其中一些。首先，让我们看看`and`运算符。
- en: The and operator
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: and运算符
- en: To understand the `and` operator better, it's best to look at a mathematical
    algorithm. Let's ask for a number and test whether that number is larger than
    `100` and a multiple of `2`. To test whether a number is a multiple of `2`, we
    use the **modulo operator** (**mod**). The symbol for `mod` is `%` in Python.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`and`运算符，最好看一个数学算法。让我们输入一个数字，并测试该数字是否大于`100`且是`2`的倍数。要测试一个数字是否是`2`的倍数，我们使用**取模运算符**（**mod**）。在Python中，`mod`的符号是`%`。
- en: 'So, looking at the code, if `number % 2 == 0`, then the number is divisible
    by `2`. If `number % 2 == 1`, then it is not divisible by `2`. We use the equal
    (`==`) operator or not equal (`!=`) operator to complete these conditions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从代码中可以看出，如果`number % 2 == 0`，那么这个数字是`2`的倍数。如果`number % 2 == 1`，那么它就不是`2`的倍数。我们使用等于（`==`）运算符或不等于（`!=`）运算符来完成这些条件：
- en: ch4_andOperator.py
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_andOperator.py
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, I know we''ve talked about different ways to write algorithms. *Did I
    need to use an AND operator for this one?* Probably not. I could have just written
    it as nested statements, `if-elif-else` statements, and so on. Some test cases
    and the results of the algorithm are shown as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我知道我们已经讨论了编写算法的不同方法。*我需要为这个使用AND运算符吗？* 可能不需要。我本可以只将其写成嵌套语句，`if-elif-else`语句等。一些测试用例和算法的结果如下所示：
- en: 'When we input `104`, we see the following output:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入`104`时，我们看到以下输出：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we input `80`, we see the following output:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入`80`时，我们看到以下输出：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we input `31`, we get the following output:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入`31`时，我们得到以下输出：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see from the previous test cases, the program tests our cases and
    provides the printed messages based on the conditions met. Now, let's take a look
    at the `or` operator.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的测试用例中可以看出，程序测试了我们的情况，并根据满足的条件提供了打印消息。现在，让我们来看一下`or`运算符。
- en: The or operator
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 或运算符
- en: As we saw in the fruit example earlier in this chapter, we checked whether the
    color of the fruit was orange, green, or yellow. That's how an `or` operator works.
    We check for something or the other. This time, we're going to look at some `True`
    and `False` statements. Let's say that variable `A` is `True` and variable `B`
    is `False`. If we were to use an `or` operator to check the result of `A` or `B`,
    then our answer would be `True`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面的水果示例中看到的，我们检查水果的颜色是橙色、绿色还是黄色。这就是`or`运算符的工作原理。我们检查某种情况或另一种情况。这次，我们将看一些`True`和`False`的陈述。假设变量`A`是`True`，变量`B`是`False`。如果我们使用`or`运算符来检查`A`或`B`的结果，那么我们的答案将是`True`。
- en: '*Why is that?* Because no matter what, the result will be either `True` or
    `False`, which is a `True` statement. *Confused?* Logic can be confusing. Let''s
    go ahead and test `A` `and` `B` as well as `A or B` in the following program to
    help you visualize this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？因为无论如何，结果要么是`True`，要么是`False`，这是一个`True`的陈述。*困惑吗？* 逻辑可能会让人困惑。让我们继续测试以下程序中的`A`
    `and` `B`以及`A or B`，以帮助您形象化：
- en: ch4_orOperator.py
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_orOperator.py
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, I added some conditions so that we'd get printouts and you could see that
    the logic I stated was right, but we didn't need to do all of this. We could have
    just printed `C` and `D`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我添加了一些条件，以便我们得到输出，并且您可以看到我所说的逻辑是正确的，但我们不需要做所有这些。我们本可以只打印`C`和`D`。
- en: 'When we run this program, this is the result:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，结果如下：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, `A and B` is `False` because one of the statements is `False`,
    which means the whole thing is `False`. `A or B` is `True` because one of them
    is `True`, so the condition is `True`. Now, let's look at the last operator (for
    now), the **not** operator.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`A and B`是`False`，因为其中一个陈述是`False`，这意味着整个事情是`False`。`A or B`是`True`，因为其中一个是`True`，所以条件是`True`。现在，让我们看看最后一个运算符（暂时），**not**运算符。
- en: The not operator
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: not运算符
- en: 'The `not` operator lets us test the opposite of things. So, if `A` is set as
    `True`, then `not A` is `False`. It''s as simple as that. Let''s look at a few
    examples through the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`运算符让我们测试事物的相反情况。因此，如果`A`设置为`True`，那么`not A`就是`False`。就是这么简单。让我们通过以下代码看一些例子：'
- en: ch4_notOperator.py
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_notOperator.py
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From the previous code, we've talked about the first printed statement here.
    Since `A` is `True`, `not` `A` is `False`. For the second `print` statement, we
    expect that result to be `True` because `B` is `False`. Now, we did the `A and
    B` and `A or B` statements previously. We know that `A and B` is `False`, so `not`
    `(A and B)` is `True`. We also know `A or B` is `True`, so `not` `(A or B)` is
    `False`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们已经讨论了这里的第一个打印语句。由于`A`是`True`，`not` `A`是`False`。对于第二个`print`语句，我们期望结果是`True`，因为`B`是`False`。现在，我们之前做了`A
    and B`和`A or B`语句。我们知道`A and B`是`False`，所以`not` `(A and B)`是`True`。我们也知道`A or
    B`是`True`，所以`not` `(A or B)`是`False`。
- en: 'Let''s look at what the program prints:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序打印了什么：
- en: 'It prints the following for `not A`:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`not A`，它打印如下内容：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, for `not B`, it prints the following:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，对于`not B`，它打印如下内容：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, for `not (A and B)`, it prints the following:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，对于`not (A and B)`，它打印如下内容：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, for `not (A or B)`, it prints the following:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，对于`not (A or B)`，它打印如下内容：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this section, you have learned about a few of the Boolean operators. With
    Boolean operators, we can write algorithms that test cases for us and provide
    outputs based on those cases. As mentioned, a program will run based on the instructions
    we write in the algorithm.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经了解了一些布尔运算符。使用布尔运算符，我们可以编写测试用例的算法，并根据这些情况提供输出。如前所述，程序将根据我们在算法中编写的指令运行。
- en: By writing our algorithms using these operators, we can ensure that conditions
    are applied only in the circumstances we want them to apply. Rather than having
    a program run on incorrect conditions, we can include statements and prompts to
    help produce the right outcomes. For example, if an input for distance is accidentally
    entered as negative, a Boolean statement could have checked conditions and provided
    the person with feedback within the program, then run again. Using Boolean operators
    provides clear logical processes and allows better and clearer algorithms.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些运算符编写我们的算法，我们可以确保条件仅在我们希望它们适用的情况下应用。我们可以包括语句和提示来帮助产生正确的结果，而不是让程序在不正确的条件下运行。例如，如果距离的输入被意外输入为负数，布尔语句可以检查条件并在程序内为人们提供反馈，然后再次运行。使用布尔运算符提供清晰的逻辑过程，并允许更好和更清晰的算法。
- en: Now that we've taken a look at the basic operators, it's important that we also
    look at errors. Identifying logic errors can help us avoid pitfalls in our algorithms.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过基本运算符，很重要的是我们也要看看错误。识别逻辑错误可以帮助我们避免算法中的陷阱。
- en: Identifying logic errors
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别逻辑错误
- en: Before we talk too much about logic errors, let's talk about why it's important
    to keep them in mind. In Python, not all errors lead to a failed or crashed program.
    Some logic errors will allow a program to run entirely without crashing at all
    or alerting the user of an error. Those errors are hard to identify.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们谈论太多逻辑错误之前，让我们谈谈为什么牢记它们的重要性。在Python中，并非所有错误都会导致程序失败或崩溃。一些逻辑错误将允许程序完全运行，而不会崩溃或警告用户发生错误。这些错误很难识别。
- en: 'Here are some logic errors that can get us in trouble, but keep in mind that
    there are many ways to incorporate logic errors into our programs accidentally:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能让我们陷入麻烦的逻辑错误，但请记住，有许多方法可以无意中将逻辑错误纳入我们的程序中：
- en: Using the wrong variable in an equation or statement
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在等式或语句中使用错误的变量
- en: Using the wrong operator to test conditions
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误的运算符来测试条件
- en: Using the wrong indentation when checking for conditions
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查条件时使用错误的缩进
- en: The one I am the guiltiest of is switching my variables, but I do also make
    mistakes in indentation often. Usually, those get identified more often when I
    try to run the program, because the program may fail to run in some instances.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我最内疚的是交换我的变量，但我也经常在缩进上犯错误。通常，当我尝试运行程序时，这些错误更容易被识别，因为在某些情况下程序可能无法运行。
- en: 'Let''s take a look at a simple algorithm that contains an error in a formula.
    In this first algorithm, the goal is to get the total cost after buying a number
    of orders of fries from a restaurant at a cost of $1.50 each:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个包含公式错误的简单算法。在第一个算法中，目标是在餐厅以每份1.50美元的价格购买一定数量的薯条后获得总费用：
- en: ch4_Error1.py
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_Error1.py
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we run the preceding program, the program will run without problems/errors
    and show the following output for `12` orders of fries:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述程序，程序将无问题/错误地运行，并为`12`份薯条显示以下输出：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, if we''re paying attention, we''ll realize that the cost for 12 orders
    of fries is too high at $144\. That''s because there is an error in our algorithm.
    The algorithm should contain the `total = cost * number` formula, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们注意到，我们会意识到12份薯条的费用为144美元太高了。这是因为我们的算法中存在错误。算法应该包含`total = cost * number`公式，如下所示：
- en: ch4_Error1_fixed.py
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_Error1_fixed.py
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we''ve fixed that formula, the output is correct:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修复了该公式，输出是正确的：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, `$18.0` seems a lot more reasonable for 12 orders of fries at
    $1.50 each.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，12份薯条每份1.50美元，总共18.0美元更合理。
- en: Errors in formulas can be difficult to find, especially if the program runs
    without alerting to the error. If we have a large algorithm with multiple formulas,
    finding those errors can become cumbersome and a lengthy process. The best recommendation
    for this is to test your algorithm at every step of the process you can. That
    way, finding errors becomes a simpler task.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 公式错误可能很难找到，特别是如果程序在不警告错误的情况下运行。如果我们有一个包含多个公式的大型算法，找到这些错误可能会变得繁琐和冗长。对此的最佳建议是在您能够的每个步骤中测试您的算法。这样，找到错误就变得更简单了。
- en: 'Let''s now take a look at an error when testing conditions. Much like errors
    in formula, errors in condition testing may be hard to spot, as the program may
    just run anyway:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下在测试条件时出现的错误。与公式错误类似，条件测试中的错误可能很难发现，因为程序可能仍然会运行：
- en: ch4_Error2.py
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_Error2.py
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, there is an error in the algorithm that causes us to
    get incorrect feedback when entering some odd numbers. Take a look at the second
    `elif` statement. That `or` will produce an error.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，算法中存在一个错误，导致我们在输入一些奇数时得到错误的反馈。看看第二个`elif`语句。那个`or`将产生一个错误。
- en: 'If we run this program, we get an output. Let''s run it with the number `99`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，我们会得到一个输出。让我们用数字`99`来运行它：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, the problem here is that `99` is not an even number. Somewhere in the
    algorithm, we introduced an error in the conditions. In this case, instead of
    using an `and` operator, we used `or`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题在于`99`不是一个偶数。在算法的某个地方，我们在条件中引入了一个错误。在这种情况下，我们使用了`or`而不是`and`运算符：
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once we replace the `or` with `and`, we can run the program again:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用`and`替换`or`，我们就可以再次运行程序：
- en: ch4_Error2_fixed.py
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_Error2_fixed.py
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using `99` as the input, we get the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`99`作为输入，我们得到以下输出：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the program with `98` as the input, we get the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`98`作为输入运行程序，我们得到以下结果：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, unless we're paying attention, we can miss errors in our conditions
    and logical operators. Because the program is able to run with these errors in
    our algorithm, catching where exactly we made the mistake is harder to do than
    when we incorporate errors that stop the program from running.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除非我们注意，否则我们可能会忽略条件和逻辑运算符中的错误。因为程序能够在我们的算法中运行这些错误，所以要捕捉到我们犯了错误的地方比起纳入会导致程序停止运行的错误要困难得多。
- en: 'Finally, let''s take a look at an indentation error using the same code for
    the condition testing. This time, with an indentation error added, we have the
    following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下使用相同的条件测试代码的缩进错误。这次，加入了一个缩进错误，我们得到了以下结果：
- en: ch4_Error3.py
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ch4_Error3.py
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, we can''t run the program. The second `elif` statement is indented
    incorrectly. When we try to run the program, we get an `Invalid Syntax` error
    message. Clicking **OK** on the message will take us to the code and the indentation
    error is highlighted, as shown in the following screenshot:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们无法运行程序。第二个`elif`语句的缩进不正确。当我们尝试运行程序时，我们会收到一个“无效语法”错误消息。单击消息上的**确定**将带我们到代码，缩进错误会被突出显示，如下面的屏幕截图所示：
- en: '![Figure 4.5 – Indentation error'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 - 缩进错误'
- en: '](image/Figure_4.5_B15413.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.5_B15413.jpg)'
- en: Figure 4.5 – Indentation error
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - 缩进错误
- en: Notice that the `print()` code below the `elif` statement is also indented incorrectly.
    Once we fix those two errors, we can run the code, as we did previously in this
    chapter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`elif`语句下面的`print()`代码也缩进错误。一旦我们修复了这两个错误，我们就可以运行代码，就像我们在本章中之前做的那样。
- en: Incorporating errors into our algorithms is a common mistake. As you can see
    from the previous examples, identifying some of the errors can be hard to do,
    since the program may be running as if there is no problem.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将错误纳入我们的算法是一个常见的错误。正如您从前面的例子中看到的，识别一些错误可能很难，因为程序可能会像没有问题一样运行。
- en: I may not have caught many errors with conditions in my algorithms, but that
    may just be because I never realized there was a mistake to begin with. That's
    one of the reasons why it's really important to run various instances of our programs
    to ensure that the results we get make sense. We will be discussing more errors
    as we look at programs and computational thinking problems throughout this book.
    In the meantime, test your programs and test them often. Triple check your math,
    your indentations, and your logic.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能没有在我的算法中捕捉到许多条件错误，但这可能只是因为我从未意识到一开始就有错误。这就是为什么运行我们的程序的各种实例以确保我们得到的结果是有意义的非常重要的原因之一。在本书中，我们将在查看程序和计算思维问题时讨论更多错误。与此同时，测试您的程序并经常测试。三次检查您的数学、缩进和逻辑。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed inductive and deductive reasoning, logical reasoning,
    logical operators, and Boolean logic. As we discussed, most of the algorithm designs
    fall under deductive reasoning. We learned how to use statements, such as `if`,
    `if-else`, `if-elif-else`, and nested statements, to write programs that test
    conditions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了归纳和演绎推理、逻辑推理、逻辑运算符和布尔逻辑。正如我们讨论的那样，大多数算法设计都属于演绎推理。我们学会了如何使用语句，如`if`、`if-else`、`if-elif-else`和嵌套语句，来编写测试条件的程序。
- en: In addition, we learned that some errors are difficult to identify, so it is
    important to verify our programs and test them often.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们了解到一些错误很难识别，因此验证我们的程序并经常测试它们是很重要的。
- en: After going through this chapter, you are now better equipped to write algorithms
    using logical reasoning. You also have the understanding to apply inductive and
    deductive reasoning when designing and planning algorithms and use Boolean logic
    and operators in your algorithms. You are now also able to test your algorithms
    for errors by identifying possible mistakes such as indentation errors, conditional
    errors, and formula errors.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 经过本章的学习，您现在更有能力使用逻辑推理编写算法。您还具备了在设计和规划算法时应用归纳和演绎推理的理解，并在算法中使用布尔逻辑和运算符的能力。您现在还能够通过识别可能的错误来测试您的算法，例如缩进错误、条件错误和公式错误。
- en: In the next chapter, we will be taking a deeper dive deeper into problem analysis,
    using the computational thinking elements to break down problems so that we can
    create meaningful and useful algorithms.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地分析问题，使用计算思维元素来分解问题，以便我们可以创建有意义和有用的算法。
