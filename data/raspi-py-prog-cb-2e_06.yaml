- en: Chapter 6. Using Python to Drive Hardware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。使用 Python 驱动硬件
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Controlling an LED
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制 LED
- en: Responding to a button
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应按钮
- en: A controlled shutdown button
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个受控的关机按钮
- en: The GPIO keypad input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPIO 键盘输入
- en: Multiplexed color LEDs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合色 LED
- en: Writing messages using Persistence of Vision
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视觉持久性写入消息
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the key features of a Raspberry Pi computer that sets it apart from most
    other home/office computers is that it has the ability to directly interface with
    other hardware. The hardware **General Purpose Input/Output** (**GPIO**) pins
    on the Raspberry Pi can control a wide range of low-level electronics, from **Light
    Emitting Diodes** (**LEDs**) to switches, sensors, motors, servos, and even extra
    displays.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 计算机的一个关键特性是它能够直接与其他硬件接口，这使得它区别于大多数其他家庭/办公室计算机。Raspberry Pi 上的硬件
    **通用输入/输出** （**GPIO**）引脚可以控制从 **发光二极管** （**LED**）到开关、传感器、电机、伺服机构和甚至额外显示器的广泛低级电子设备。
- en: This chapter will focus on connecting the Raspberry Pi with some simple circuits
    and getting to grips with using Python to control and respond to the connected
    components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍将 Raspberry Pi 与一些简单电路连接，并掌握使用 Python 控制和响应连接组件的方法。
- en: The Raspberry Pi hardware interface consists of 40 pins located along one side
    of the board.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 硬件接口由位于板边一侧的 40 个引脚组成。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GPIO pins and their layout will vary slightly according to the particular
    model you have.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 引脚及其布局会根据您所拥有的特定型号略有不同。
- en: The Raspberry Pi 2 and the Raspberry Pi 1 Model A Plus and B Plus all have the
    same 40-pin layout.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 2 和 Raspberry Pi 1 Model A Plus 以及 B Plus 都有相同的 40 引脚布局。
- en: The older Raspberry Pi 1 models (non-plus types) have a 26-pin header, which
    is the same as the 1-26 pins of the newer models.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的 Raspberry Pi 1 型号（非 plus 类型）有一个 26 引脚的排针，这与较新型号的 1-26 引脚相同。
- en: '![Introduction](img/6623OT_06_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/6623OT_06_001.jpg)'
- en: Raspberry Pi 2 and Raspberry Pi Model Plus GPIO header pins (pin functions)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 2 和 Raspberry Pi Model Plus GPIO 排针引脚（引脚功能）
- en: The layout of the connector is shown in the previous diagram; the pin numbers
    are shown as seen from pin 1 of the GPIO header.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器的布局在之前的图中显示；引脚编号是从 GPIO 排针的引脚 1 观察到的。
- en: '**Pin 1** is at the end that is nearest to the SD card, as shown in the following
    image:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**引脚 1** 位于最靠近 SD 卡的末端，如下面的图片所示：'
- en: '![Introduction](img/6623OT_06_002.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/6623OT_06_002.jpg)'
- en: The Raspberry Pi GPIO header location
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi GPIO 排针位置
- en: Care should be taken when using the GPIO header, since it also includes power
    pins (3V3 and 5V) as well as ground pins (GND). All of the GPIO pins can be used
    as standard GPIO, but several also have special functions; these are labeled and
    highlighted with different colors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GPIO 排针时需小心，因为它还包括电源引脚（3V3 和 5V）以及地线引脚（GND）。所有 GPIO 引脚都可以用作标准 GPIO，但其中几个也有特殊功能；这些被标记并用不同颜色突出显示。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is common for engineers to use a 3V3 notation to specify values in schematics
    to avoid using decimal places that could easily be missed (using 33V rather than
    3.3V would cause severe damage). The same can applied to other values such as
    resistors, so for example, 1.2k ohms can be written as 1k2 ohms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师通常使用 3V3 符号来指定原理图中的值，以避免使用容易遗漏的小数点（使用 33V 而不是 3.3V 会造成严重损坏）。同样，这也适用于其他值，例如电阻，因此例如，1.2k
    欧姆可以写成 1k2 欧姆。
- en: There are **TX** and **RX** pins that are used for serial RS232 communications,
    and with the aid of a voltage level convertor, information can be transferred
    via a serial cable to another computer or device.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有 **TX** 和 **RX** 引脚，用于串行 RS232 通信，借助电压等级转换器，信息可以通过串行电缆传输到另一台计算机或设备。
- en: 'We have **SDA** and **SCL** pins that are able to support a two-wire bus communication
    protocol called **I²C** (on Model Plus and Raspberry Pi 2 boards there are two
    I²C channels: **channel 1 ARM** is for general use while **channel 0 VC** is typically
    used for identifying Hardware Attached on Top (HAT) modules). There are also the
    **SPI MOSI**, **SPI MISO**, **SPI SCLK**, **SPI CE0**, and **SPI CE1** pins, which
    support another type of bus protocol called **SPI** for high-speed data. Finally,
    we have **PWM0/1**, which allows a **pulse width modulation** signal to be generated,
    which is useful for servos and generating analog signals.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有**SDA**和**SCL**引脚，它们能够支持一种称为**I²C**的双线总线通信协议（在Model Plus和Raspberry Pi 2板上，有两个I²C通道：**通道1
    ARM**用于通用，而**通道0 VC**通常用于识别顶部附加的硬件模块（HAT））。还有**SPI MOSI**、**SPI MISO**、**SPI SCLK**、**SPI
    CE0**和**SPI CE1**引脚，它们支持另一种称为**SPI**的高速数据总线协议。最后，我们还有**PWM0/1**，它允许生成**脉冲宽度调制**信号，这对于伺服和生成模拟信号非常有用。
- en: 'However, we will focus on using just the standard GPIO functions in this chapter.
    The GPIO pin layout is shown in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们将专注于使用标准的GPIO功能。GPIO引脚布局如图所示：
- en: '![Introduction](img/6623OT_06_003.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/6623OT_06_003.jpg)'
- en: Raspberry Pi GPIO header pins (GPIO.BOARD and GPIO.BCM)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi GPIO引脚（GPIO.BOARD和GPIO.BCM）
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The Raspberry Pi Rev 2 (pre-July 2014) has the following differences to the
    Raspberry Pi 2 GPIO layout:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Rev 2（2014年7月之前）与Raspberry Pi 2 GPIO布局有以下不同之处：
- en: 26 GPIO pins header (matching the first 26 pins)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 26个GPIO引脚头（与第一个26个引脚相匹配）
- en: 'An additional secondary set of eight holes (P5) located next to the pin header.
    The details are as follows:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引脚头旁边额外的一组八个孔（P5）。具体如下：
- en: '![Introduction](img/6623OT_06_004.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/6623OT_06_004.jpg)'
- en: Raspberry Pi Rev 2 P5 GPIO header pins
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Rev 2 P5 GPIO引脚头
- en: 'The original Raspberry Pi Rev 1 (pre-Oct 2012) has only 26 GPIO pins in total
    (matching the first 26 pins of the current Raspberry Pi, except for the following
    details):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Raspberry Pi Rev 1（2012年10月之前）总共只有26个GPIO引脚（与当前Raspberry Pi的前26个引脚相匹配，除了以下细节）：
- en: '![Introduction](img/6623OT_06_005.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/6623OT_06_005.jpg)'
- en: Raspberry Pi Rev 1 GPIO header differencesThe **RPi.GPIO** library can reference
    the pins on the Raspberry Pi using one of two systems. The numbers shown in the
    center are the physical position of the pins and are also the numbers referenced
    by RPi.GPIO when in the **GPIO.BOARD** mode. The numbers on the outside (**GPIO.BCM**)
    are the actual references for the physical ports of the processor to which the
    pins are wired (which is why they are not in any specific order). They are used
    when the mode is set to **GPIO.BCM** and allow control of the GPIO header pins
    and also any peripherals connected to other GPIO lines. This includes the LED
    on the add-on camera on BCM GPIO 4 and the status LED on the board. However, this
    can also include the GPIO lines used for reading/writing to the SD card, which
    would cause serious errors if interfered with.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Rev 1 GPIO引脚头差异**RPi.GPIO**库可以使用两种系统之一来引用Raspberry Pi上的引脚。中间显示的数字是引脚的物理位置，也是RPi.GPIO在**GPIO.BOARD**模式下引用的数字。外部的数字（**GPIO.BCM**）是引脚连接到的处理器物理端口的实际引用（这就是为什么它们没有特定的顺序）。当模式设置为**GPIO.BCM**时，它们用于控制GPIO引脚头和连接到其他GPIO线的任何外围设备。这包括BCM
    GPIO 4上的附加摄像头上的LED和板上的状态LED。然而，这也可以包括用于读取/写入SD卡的GPIO线，如果被干扰，将导致严重错误。
- en: If you use other programming languages to access the GPIO pins, the numbering
    scheme may be different, so it will be helpful if you are aware of the BCM GPIO
    references, which refer to the physical GPIO port of the processor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用其他编程语言来访问GPIO引脚，编号方案可能不同，因此了解BCM GPIO引用会有所帮助，这些引用指的是处理器的物理GPIO端口。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be sure to check out the [Appendix](apa.html "Appendix A. Hardware and Software
    List"), *Hardware and Software List*, which lists all the items used in this chapter
    and the places you can obtain them from.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看[附录](apa.html "附录 A. 硬件和软件列表")，*硬件和软件列表*，其中列出了本章中使用的所有项目及其获取地点。
- en: Controlling an LED
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制一个LED
- en: The hardware equivalent of `hello world` is an LED flash, which is a great test
    to ensure that everything is working and that you have wired it correctly. To
    make it a little more interesting, I've suggested using an RGB LED (it has red,
    green, and blue LEDs combined into a single unit), but feel free to use separate
    LEDs if that is all you have available.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件上的“hello world”等效于LED闪烁，这是一个很好的测试，以确保一切正常并且你已经正确接线。为了使其更有趣，我建议使用RGB LED（它将红、绿、蓝LED组合成一个单元），但如果你只有可用的单独LED，也可以使用。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You will need the following equipment:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下设备：
- en: 4 x DuPont female to male patch wires
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 x 杜邦公对母排线
- en: Mini breadboard (170 tie points) or a larger one
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型面包板（170个接线点）或更大的一个
- en: RGB LED (common cathode)/3 standard LEDs (ideally red/green/blue)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB LED（共阴极）/3个标准LED（理想情况下为红/绿/蓝）
- en: Breadboarding wire (solid core)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板线（实心芯线）
- en: 3 x 470 ohm resistors
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 x 470 欧姆电阻
- en: Each of the previous components should only cost a few dollars and can be reused
    for other projects afterwards. The breadboard is a particularly useful item that
    allows you to try out your own circuits without needing to solder them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的每个组件只需花费几美元，并且在之后的项目中可以重复使用。面包板是一个特别有用的物品，它允许你在不需要焊接的情况下尝试自己的电路。
- en: '![Getting ready](img/6623OT_06_006.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_06_006.jpg)'
- en: The diagrams of an RGB LED, standard LED, and RGB circuit
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED、标准LED和RGB电路的图示
- en: 'The following diagram shows the breadboard circuitry:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了面包板电路：
- en: '![Getting ready](img/6623OT_06_007.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_06_007.jpg)'
- en: The wiring of an RGB LED/standard LEDs connected to the GPIO header
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到GPIO引脚的RGB LED/标准LED的接线
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are several variations of RGB LEDs available, so check the datasheet of
    your component to confirm the pin order and type you have. Some are Red, Blue,
    and Green (RBG), so ensure that you wire accordingly or adjust the `RGB_` pin
    settings in the code. You can also get common anode variants, which will require
    the anode to be connected to 3V3 (GPIO-Pin1) for it to light up (and require `RGB_ENABLE`
    and `RGB_DISABLE` to be set to `0` and `1`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的RGB LED有多种变体，因此请检查你组件的数据表以确认你拥有的引脚顺序和类型。有些是红、蓝、绿（RBG），因此请确保相应地接线或调整代码中的`RGB_`引脚设置。你也可以得到共阳极变体，这将需要将阳极连接到3V3（GPIO-Pin1）才能点亮（并且需要将`RGB_ENABLE`和`RGB_DISABLE`设置为`0`和`1`）。
- en: The breadboard and component diagrams of this book have been created using a
    free tool called **Fritzing** ([www.fritzing.org](http://www.fritzing.org)); it
    is great for planning your own Raspberry Pi projects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的面包板和组件图是使用一个名为**Fritzing**的免费工具创建的（[www.fritzing.org](http://www.fritzing.org)）；它非常适合规划自己的树莓派项目。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create the `ledtest.py` script as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`ledtest.py`脚本如下：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `RPi.GPIO` library will require `sudo` permissions to access the GPIO pin
    hardware, so you will need to run the script using the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPi.GPIO`库需要`sudo`权限来访问GPIO引脚硬件，因此你需要使用以下命令运行脚本：'
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run the script, you should see the red, green, and blue parts of the
    LED (or each LED, if using separate ones) light up in turn. If not, double-check
    your wiring or confirm the LED is working by temporarily connecting the red, green,
    or blue wire to the 3V3 pin (pin 1 of the GPIO header).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行脚本时，你应该看到LED的红色、绿色和蓝色部分（或每个LED，如果使用单独的LED）依次点亮。如果没有，请检查你的接线，或者通过临时将红色、绿色或蓝色线连接到3V3引脚（GPIO引脚1）来确认LED是否工作。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `sudo` command is required for most hardware-related scripts because it
    isn't normal for users to directly control hardware at such a low level. For example,
    setting or clearing a control pin that is part of the SD card controller could
    corrupt data being written to it. Therefore, for security purposes, super user
    permissions are required to stop programs from using hardware by accident (or
    with malicious intent).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数与硬件相关的脚本，需要使用`sudo`命令，因为用户通常不会在如此低级别直接控制硬件。例如，设置或清除SD卡控制器的一部分控制引脚可能会损坏正在写入的数据。因此，出于安全考虑，需要超级用户权限以防止程序意外（或恶意意图）使用硬件。
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To access the GPIO pins using Python, we import `RPi.GPIO`, which allows direct
    control of the pins through the module functions. We also require the `time` module
    to pause the program for a set number of seconds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python访问GPIO引脚，我们导入`RPi.GPIO`，这允许通过模块函数直接控制引脚。我们还需要`time`模块来暂停程序设定的时间数秒。
- en: We define values for the LED wiring and active states (see *Controlling the
    GPIO current* in the *There's more…* section of this recipe).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为LED布线和活动状态定义值（见*更多内容…*部分中的*控制GPIO电流*）。
- en: Before the GPIO pins are used by the program, we need to set them up by specifying
    the numbering method (`GPIO.BOARD`) and the direction—`GPIO.OUT` or `GPIO.IN`
    (in this case, we set all the RGB pins to outputs). If a pin is configured as
    an output, we will be able to set the pin state; similarly, if it is configured
    as an input, we will be able to read the pin state.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序使用GPIO引脚之前，我们需要通过指定编号方法（`GPIO.BOARD`）和方向（`GPIO.OUT`或`GPIO.IN`）（在这种情况下，我们将所有RGB引脚设置为输出）来设置它们。如果将引脚配置为输出，我们将能够设置引脚状态；同样，如果将其配置为输入，我们将能够读取引脚状态。
- en: Next, we control the pins using `GPIO.ouput()` by stating the number of the
    GPIO pin and the state we want it to be in (`1` = high/on and `0` = low/off).
    We switch each LED on, wait 5 seconds, and then switch it back off.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`GPIO.output()`通过指定GPIO引脚的编号和我们希望其处于的状态（`1` = 高/开和`0` = 低/关）来控制引脚。我们打开每个LED，等待5秒钟，然后将其关闭。
- en: Finally, we use `GPIO.cleanup()` to return the GPIO pins back to their original
    default state and release control of the pins for use by other programs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`GPIO.cleanup()`将GPIO引脚恢复到其原始默认状态，并释放引脚以供其他程序使用。
- en: There's more…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Using the GPIO pins on the Raspberry Pi must be done with care since these pins
    are directly connected to the main processor of the Raspberry Pi without any additional
    protection. Caution must be used, as any incorrect wiring will probably damage
    the Raspberry Pi processor and cause it to stop functioning altogether.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Raspberry Pi上使用GPIO引脚时必须小心，因为这些引脚直接连接到Raspberry Pi的主处理器，没有任何额外的保护。必须小心操作，因为任何错误的接线都可能损坏Raspberry
    Pi处理器，并导致其完全停止工作。
- en: Alternatively, you could use one of the many modules available that plug directly
    into the GPIO header pins (reducing the chance of wiring mistakes).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用许多可直接插入GPIO引脚头部的模块之一（减少接线错误的机会）。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For example, the Pi-Stop is a simple pre-built LED board that simulates a set
    of traffic lights, designed to be a stepping stone for those interested in controlling
    hardware but want to avoid the risk of damaging their Raspberry Pi. After the
    basics have been mastered, it also makes an excellent indicator to aid debugging.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Pi-Stop是一个简单的预构建LED板，模拟一组交通信号灯，旨在为那些对控制硬件感兴趣但想避免损坏Raspberry Pi的风险的人提供一个跳板。在掌握基础知识之后，它也是一个出色的指示器，有助于调试。
- en: Just ensure you update the `LED CONFIG` pin references in the `ledtest.py` script
    to reference the pin layout and location used for the hardware you are using.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 只需确保更新`ledtest.py`脚本中的`LED CONFIG`引脚引用，以便引用您所使用的硬件的引脚布局和位置。
- en: '![There''s more…](img/6623OT_06_008.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容…](img/6623OT_06_008.jpg)'
- en: See the [Appendix](apa.html "Appendix A. Hardware and Software List"), *Hardware
    and Software List*, for a list of Raspberry Pi hardware retailers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[附录](apa.html "附录A. 硬件和软件列表")，*硬件和软件列表*，以获取Raspberry Pi硬件零售商的列表。
- en: Controlling the GPIO current
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制GPIO电流
- en: Each GPIO pin is only able to handle a certain current before it will burn out
    (not greater than 16 mA from a single pin or 30 mA in total), and similarly, the
    RGB LED should be limited to no more than 100 mA. By adding a resistor before
    or after an LED, we will be able to limit the current that will be passed through
    it and also control how bright it is (more current will equal a brighter LED).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GPIO引脚在烧毁之前只能处理一定量的电流（单个引脚不超过16 mA，总电流不超过30 mA），同样，RGB LED也应限制在不超过100 mA。通过在LED之前或之后添加电阻，我们可以限制通过它的电流，并控制其亮度（电流越大，LED越亮）。
- en: Since we may wish to drive more than one LED at a time, we typically aim to
    set the current as low as we can get away with while still providing enough power
    to light up the LED.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能希望同时驱动多个LED，我们通常试图将电流设置得尽可能低，同时仍然提供足够的功率来点亮LED。
- en: 'We can use Ohm''s law to tell us how much resistance to use to provide a particular
    current. The law is as shown in the following diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用欧姆定律来告诉我们需要使用多少电阻来提供特定的电流。该定律如下所示：
- en: '![Controlling the GPIO current](img/6623OT_06_009.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![控制GPIO电流](img/6623OT_06_009.jpg)'
- en: Ohm's law describes the relationship between the current, resistance, and voltage
    in electrical circuits
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 欧姆定律描述了电路中电流、电阻和电压之间的关系
- en: We will aim for a minimum current (3 mA) and maximum current (16 mA), while
    still producing a reasonably bright light from each of the LEDs. To get a balanced
    output for the RGB LEDs, I tested different resistors until they provided a near
    white light (when viewed through a card). A 470 ohm resistor was selected for
    each one (your LEDs may differ slightly).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将目标设定为最小电流（3 mA）和最大电流（16 mA），同时仍然从每个LED产生足够亮的光。为了得到RGB LED的平衡输出，我测试了不同的电阻，直到它们提供接近白色的光（通过卡片观察）。每个LED选择了470欧姆的电阻（你的LED可能略有不同）。
- en: '![Controlling the GPIO current](img/6623OT_06_010.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![控制GPIO电流](img/6623OT_06_010.jpg)'
- en: Resistors are needed to limit the current that passes through the LEDs
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 需要电阻来限制通过LED的电流
- en: 'The voltage across the resistor is equal to the GPIO voltage (Vgpio = 3.3V)
    minus the voltage drop on the particular LED (`Vfwd`); we can then use this resistance
    to calculate the current used by each of the LEDs, as shown in the following diagram:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻两端的电压等于GPIO电压（Vgpio = 3.3V）减去特定LED上的电压降（`Vfwd`）；然后我们可以使用这个电阻来计算每个LED使用的电流，如下图中所示：
- en: '![Controlling the GPIO current](img/6623OT_06_011.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![控制GPIO电流](img/6623OT_06_011.jpg)'
- en: We can calculate the current drawn by each of the LEDs
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算每个LED的电流消耗
- en: Responding to a button
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应按钮
- en: Many applications using the Raspberry Pi require that actions are activated
    without a keyboard and screen attached to it. The GPIO pins provide an excellent
    way for the Raspberry Pi to be controlled by your own buttons and switches without
    a mouse/keyboard and screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 许多使用树莓派的应用程序都需要在没有键盘和屏幕连接的情况下激活操作。GPIO引脚为树莓派提供了一个非常好的方式，通过你的按钮和开关来控制，而不需要鼠标/键盘和屏幕。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You will need the following equipment:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下设备：
- en: 2 x DuPont female to male patch wires
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 杜邦公对母跳线
- en: Mini breadboard (170 tie points) or a larger one
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型面包板（170个接线点）或更大的一个
- en: Push button switch (momentary close) or a wire connection to make/break the
    circuit
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮开关（瞬间闭合）或通过导线连接来闭合/断开电路
- en: Breadboarding wire (solid core)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板导线（实心芯）
- en: 1k ohm resistor
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1k欧姆电阻
- en: 'The switches are as seen in the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 开关如下图中所示：
- en: '![Getting ready](img/6623OT_06_012.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_06_012.jpg)'
- en: The push button switch and other types of switch
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮开关和其他类型的开关
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The switches used in the following examples are **single pole single throw**
    (**SPST**) momentary close push button switches. **Single pole** (**SP**) means
    that there is one set of contacts that makes a connection. In the case of the
    push switch used here, the legs on each side are connected together with a single
    pole switch in the middle. A **double pole** (**DP**) switch acts just like a
    single pole switch, except that the two sides are separated electrically, allowing
    you to switch two separate components on/off at the same time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中使用的开关是**单刀单掷**（**SPST**）瞬间闭合按钮开关。**单刀**（**SP**）意味着有一组触点会建立连接。在这里使用的按钮开关的情况下，每侧的腿通过中间的单刀开关连接在一起。**双刀**（**DP**）开关的行为就像单刀开关一样，除了两侧在电路上是分开的，允许你同时打开/关闭两个不同的组件。
- en: '**Single throw** (**ST**) means the switch will make a connection with just
    one position; the other side will be left open. **Double throw** (**DT**) means
    both positions of the switch will connect to different parts.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**单掷**（**ST**）表示开关将仅在一种位置上建立连接；另一侧将保持断开。**双掷**（**DT**）表示开关的两个位置都将连接到不同的部分。'
- en: '**Momentary close** means that the button will close the switch when pressed
    and automatically open it when released. A **latched** push button switch will
    remain closed until it is pressed again.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**瞬间闭合**意味着按钮在被按下时会闭合开关，并在释放时自动打开。**锁定**按钮开关将保持闭合，直到再次按下。'
- en: '![Getting ready](img/6623OT_06_013.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_06_013.jpg)'
- en: The layout of the button circuit
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮电路布局
- en: We will use sound in this example, so you will also need speakers or headphones
    attached to the audio socket of the Raspberry Pi.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用声音，因此你还需要将扬声器或耳机连接到树莓派的音频插座。
- en: 'You will need to install a program called `flite` using the following command,
    which will let us make the Raspberry Pi talk:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用以下命令安装名为`flite`的程序，这将使我们能够让树莓派说话：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After it has been installed, you can test it with the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以使用以下命令进行测试：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If it is a little too quiet (or too loud), you can adjust the volume (0-100
    percent) using the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声音有点太小（或太大），你可以使用以下命令调整音量（0-100%）：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the `btntest.py` script as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`btntest.py`脚本如下：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As in the previous recipe, we set up the GPIO pin as required, but this time
    as an input, and we also enable the internal pull-up resistor (see *Pull-up and
    pull-down resistor circuits* in the *There''s more…* section of this recipe for
    more information) using the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个配方中所述，我们设置了所需的GPIO引脚，但这次将其设置为输入，并且我们还启用了内部拉电阻（有关更多信息，请参阅本配方中“还有更多...”部分的*拉电阻和下拉电阻电路*），使用以下代码：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the GPIO pin is set up, we create a loop that will continuously check
    the state of `BTN` using `GPIO.input()`. If the value returned is `false`, the
    pin has been connected to 0V (ground) through the switch, and we will use `flite`
    to count out loud for us each time the button is pressed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置GPIO引脚后，我们创建一个循环，该循环将连续检查`BTN`的状态，使用`GPIO.input()`。如果返回的值是`false`，则引脚通过开关连接到0V（地），我们将使用`flite`大声计数每次按钮被按下。
- en: Since we have called the main function from within a `try`/`finally` condition,
    it will still call `GPIO.cleanup()` even if we close the program using *Ctrl*
    + *Z*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`try`/`finally`条件内调用了主函数，即使我们使用*Ctrl* + *Z*关闭程序，它仍然会调用`GPIO.cleanup()`。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use a short delay in the loop; this ensures that any noise from the contacts
    on the switch is ignored. This is because when we press the button, there isn't
    always perfect contact as we press or release it, and it may produce several triggers
    if we press it again too quickly. This is known as **software debouncing**; we
    ignore the bounce in the signal here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在循环中使用短暂的延迟；这确保了忽略开关接触上的任何噪声。这是因为当我们按下按钮时，我们按下或释放它时并不总是完美的接触，如果我们太快地再次按下它，可能会产生几个触发。这被称为**软件去抖动**；我们在这里忽略信号的抖动。
- en: There's more…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Raspberry Pi GPIO pins must be used with care; voltages used for inputs
    should be within specific ranges, and any current drawn from them should be minimized
    using protective resistors.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派的GPIO引脚必须谨慎使用；用于输入的电压应在特定范围内，并且应通过保护电阻最小化从它们中吸取的任何电流。
- en: Safe voltages
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全电压
- en: We must ensure that we only connect inputs that are between 0 (Ground) and 3.3V.
    Some processors use voltages between 0 and 5V, so extra components are required
    to interface safely with them. Never connect an input or component that uses 5V
    unless you are certain it is safe, or you will damage the GPIO ports of the Raspberry
    Pi.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保我们只连接介于0（地）和3.3V之间的输入。一些处理器使用0到5V之间的电压，因此需要额外的组件才能安全地与之接口。除非你确定它是安全的，否则不要连接使用5V的输入或组件，否则会损坏树莓派的GPIO端口。
- en: Pull-up and pull-down resistor circuits
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拉电阻和下拉电阻电路
- en: The previous code sets the GPIO pins to use an internal pull-up resistor. Without
    a pull-up resistor (or pull-down resistor) on the GPIO pin, the voltage is free
    to float somewhere between 3.3V and 0V, and the actual logical state remains undetermined
    (sometimes 1 and sometimes 0).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将GPIO引脚设置为使用内部拉电阻。如果没有在GPIO引脚上使用拉电阻（或下拉电阻），电压可以自由浮动在3.3V和0V之间，实际的逻辑状态将不确定（有时为1，有时为0）。
- en: Raspberry Pi's internal pull-up resistors are 50k ohm-65k ohm and the pull-down
    resistors are 50k ohm-65k ohm. External pull-up/pull-down resistors are often
    used in GPIO circuits (as shown in the following diagram), typically using 10k
    ohm or larger for similar reasons (giving a very small current draw when not active).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派的内部拉电阻为50k欧姆-65k欧姆，下拉电阻也是50k欧姆-65k欧姆。外部拉电阻/下拉电阻通常用于GPIO电路（如下所示），通常使用10k欧姆或更大的电阻，原因类似（在不活动时提供非常小的电流消耗）。
- en: 'A pull-up resistor allows a small amount of current to flow through the GPIO
    pin and will provide a high voltage when the switch isn''t pressed. When the switch
    is pressed, the small current is replaced by the larger one flowing to 0V, so
    we get a low voltage on the GPIO pin instead. The switch is active low and logic
    0 when pressed. It works as shown in the following diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拉电阻允许一小部分电流通过GPIO引脚，当开关未按下时，将提供高电压。当按下开关时，小电流被流向0V的大电流所取代，因此GPIO引脚上的电压变低。开关在按下时是低电平且逻辑0。它的工作原理如下所示：
- en: '![Pull-up and pull-down resistor circuits](img/6623OT_06_014.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![拉电阻和下拉电阻电路](img/6623OT_06_014.jpg)'
- en: A pull-up resistor circuit
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 拉电阻电路
- en: 'Pull-down resistors work in the same way, except the switch is active high
    (the GPIO pin is logic 1 when pressed). It works as shown in the following diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉电阻的工作方式相同，只是开关是高电平有效（当按下时GPIO引脚为逻辑1）。它的工作方式如下所示：
- en: '![Pull-up and pull-down resistor circuits](img/6623OT_06_015.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![上拉和下拉电阻电路](img/6623OT_06_015.jpg)'
- en: A pull-down resistor circuit
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个下拉电阻电路
- en: Protection resistors
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护电阻
- en: 'In addition to the switch, the circuit includes a resistor in series with the
    switch to protect the GPIO pin, as shown in the following diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开关外，电路还包括一个与开关串联的电阻来保护GPIO引脚，如下所示：
- en: '![Protection resistors](img/6623OT_06_016.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![保护电阻](img/6623OT_06_016.jpg)'
- en: A GPIO protective current-limiting resistor
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个GPIO保护限流电阻
- en: The purpose of the protection resistor is to protect the GPIO pin if it is accidentally
    set as an output rather than an input. Imagine, for instance, that we have our
    switch connected between the GPIO and ground. Now the GPIO pin is set as an output
    and switched on (driving it to 3.3V) as soon as we press the switch; without a
    resistor present, the GPIO pin will directly be connected to 0V. The GPIO will
    still try to drive it to 3.3V; this would cause the GPIO pin to burn out (since
    it would use too much current to drive the pin to the high state). If we use a
    1k ohm resistor here, the pin is able to be driven high using an acceptable amount
    of current (I = V/R = 3.3/1k = 3.3mA).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 保护电阻的目的是在GPIO引脚意外设置为输出而不是输入时保护GPIO引脚。想象一下，例如，我们的开关连接在GPIO和地之间。现在，GPIO引脚被设置为输出并在按下开关时立即打开（将其驱动到3.3V）。如果没有电阻，GPIO引脚将直接连接到0V。GPIO仍然会尝试将其驱动到3.3V；这会导致GPIO引脚烧毁（因为它会使用过多的电流将引脚驱动到高电平状态）。如果我们在这里使用一个1k欧姆的电阻，引脚就能够使用可接受的电流驱动到高电平（I
    = V/R = 3.3/1k = 3.3mA）。
- en: A controlled shutdown button
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个控制关断按钮
- en: The Raspberry Pi should always be shut down correctly to avoid the SD card being
    corrupted (by losing power while performing a write operation to the card). This
    can pose a problem if you don't have a keyboard or screen connected (if you are
    running an automated program or controlling it remotely over a network and forget
    to turn it off) as you can't type the command or see what you are doing. By adding
    our own buttons and LED indicator, we can easily command a shutdown, reset, and
    startup again to indicate when the system is active.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi应该始终正确关机，以避免SD卡在执行写入操作时因断电而损坏。如果你没有连接键盘或屏幕（如果你正在运行自动化程序或通过网络远程控制并忘记关闭它），这可能会造成问题，因为你无法输入命令或看到你在做什么。通过添加我们自己的按钮和LED指示灯，我们可以轻松地发出关机、重置和再次启动的命令，以指示系统何时处于活动状态。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'You will need the following equipment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下设备：
- en: 3 x Dupont female to male patch wires
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 x 杜邦公对母排线
- en: Mini breadboard (170 tie points) or a larger one
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型面包板（170个接线点）或更大的一个
- en: Push button switch (momentary close)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮开关（瞬间闭合）
- en: General purpose LED
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用LED
- en: 2 x 470-ohm resistors
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 470欧姆电阻
- en: Breadboarding wire (solid core)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板线（实心芯线）
- en: 'The entire layout of the shutdown circuit will look as shown in the following
    figure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关断电路的整体布局将如下所示：
- en: '![Getting ready](img/6623OT_06_017.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_06_017.jpg)'
- en: The controlled shutdown circuit layout
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 控制关断电路布局
- en: How to do it…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create the `shtdwn.py` script as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`shtdwn.py`脚本如下：
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To get this script to run automatically (once we have tested it), we can place
    the script in `~/bin` (we can use `cp` instead of `mv` if we just want to copy
    it) and add it to `crontab` with the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此脚本自动运行（一旦测试通过），我们可以将其放置在`~/bin`中（如果我们只想复制它，可以使用`cp`而不是`mv`）并将其添加到`crontab`中，如下所示：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the end of the file, we add the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，我们添加以下代码：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This time, when we set up the GPIO pin, we define the pin connected to the shutdown
    button as an input and the pin connected to the LED as an output. We turn the
    LED on to indicate that the system is running.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们设置GPIO引脚时，我们将连接到关断按钮的引脚定义为输入，将连接到LED的引脚定义为输出。我们打开LED以指示系统正在运行。
- en: By setting the `DEBUG` flag to `True`, we can test the functionality of our
    script without causing an actual shutdown (by reading the terminal messages);
    we just need to ensure to set `DEBUG` to `False` when using the script for real.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`DEBUG`标志设置为`True`，我们可以在不实际关机的情况下测试脚本的功能（通过读取终端消息）；我们只需确保在使用脚本时将`DEBUG`设置为`False`。
- en: We enter a `while` loop and check every second to see whether the GPIO pin is
    set to `LOW` (the switch has been pressed); if so, we enter the `doShutdown()`
    function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入一个`while`循环，每秒检查一次GPIO引脚是否设置为`LOW`（开关已被按下）；如果是，我们进入`doShutdown()`函数。
- en: The program will wait for 3 seconds and then test again to see whether the button
    is still being pressed. If the button is no longer being pressed, we return to
    the previous `while` loop. However, if it is still being pressed after 3 seconds,
    the program will flash the LED and trigger the shutdown (also providing an audio
    warning using `flite`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将等待3秒钟，然后再次测试以查看按钮是否仍在被按下。如果按钮不再被按下，我们将返回到之前的`while`循环。然而，如果在3秒后按钮仍然被按下，程序将闪烁LED并触发关机（同时使用`flite`提供音频警告）。
- en: When we are happy with how the script is operating, we can disable the `DEBUG`
    flag (by setting it to `False`) and add the script to `crontab`. Crontab is a
    special program that runs in the background and allows us to schedule (at specific
    times, dates, or periodically) programs and actions when the system is started
    (`@reboot`). This allows the script to be started automatically every time the
    Raspberry Pi is powered up. When we press and hold the shutdown button for more
    than 3 seconds, it safely shuts down the system and enters a low power state (the
    LED switches off just before this, indicating it is safe to remove the power shortly
    after). To restart the Raspberry Pi, we briefly remove the power; this will restart
    the system, and the LED will light up when the Raspberry Pi has loaded.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对我们脚本的运行方式满意时，我们可以禁用`DEBUG`标志（将其设置为`False`）并将脚本添加到`crontab`。Crontab是一个特殊的程序，它在后台运行，允许我们在系统启动时（`@reboot`）安排（在特定时间、日期或定期）程序和动作。这允许脚本在每次树莓派上电时自动启动。当我们按下并保持关机按钮超过3秒时，它会安全地关闭系统并进入低功耗状态（LED在此之前关闭，表示可以安全地在之后不久断电）。要重启树莓派，我们短暂地断电；这将重启系统，当树莓派加载时LED会点亮。
- en: There's more…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We can extend this example further using the reset header by adding extra functionality
    and making use of additional GPIO connections (if available).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用复位引脚来进一步扩展此示例，通过添加额外功能并利用额外的GPIO连接（如果可用）。
- en: Resetting and rebooting Raspberry Pi
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置和重启树莓派
- en: 'The Raspberry Pi has holes for mounting a reset header (marked **RUN** on the
    Raspberry Pi 2 / 3 and **P6** on the Raspberry Pi 1 Model B Rev 2 and Model As).
    The reset pin allows the device to be reset using a button rather than removing
    the micro USB connector each time to cycle the power:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派有孔可以安装复位引脚（在树莓派2/3上标记为**RUN**，在树莓派1 Model B Rev 2和Model As上标记为**P6**）。复位引脚允许使用按钮重置设备，而不是每次都拔掉微型USB连接器来循环电源：
- en: '![Resetting and rebooting Raspberry Pi](img/6623OT_06_018.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![重置和重启树莓派](img/6623OT_06_018.jpg)'
- en: Raspberry Pi reset headers – on the left, Raspberry Pi Model A/B (Rev2), and
    on the right, Raspberry Pi 2
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派复位引脚 – 左边是树莓派Model A/B（Rev2），右边是树莓派2
- en: 'To make use of it, you will need to solder a wire or pin header to the Raspberry
    Pi and connect a button to it (or briefly touch a wire between the two holes each
    time). Alternatively, we can extend our previous circuit, as shown in the following
    diagram:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，您需要将电线或引脚头焊接在树莓派上，并将其连接到按钮上（或每次短暂触摸两个孔之间的电线）。或者，我们可以扩展我们之前的电路，如下面的图所示：
- en: '![Resetting and rebooting Raspberry Pi](img/6623OT_06_019.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![重置和重启树莓派](img/6623OT_06_019.jpg)'
- en: The controlled shutdown circuit layout and reset button
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 控制关机电路布局和复位按钮
- en: We can add this extra button to our circuit, which can be connected to the reset
    header (this is the hole nearest the middle on the Raspberry Pi 2 or closest to
    the edge on other models). This pin, when temporarily pulled low by connecting
    to ground (such as the hole next to it or by another ground point such as pin
    6 of the GPIO header), will reset the Raspberry Pi and allow it to boot up again
    following a shutdown.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个额外的按钮添加到我们的电路中，该按钮可以连接到复位引脚（这是树莓派2上靠近中间的孔，在其他型号上靠近边缘的孔）。当通过连接到地（例如旁边的孔或GPIO引脚6等另一个地点）临时将其拉低时，该引脚将重置树莓派，并在关机后允许其重新启动。
- en: Adding extra functions
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加额外功能
- en: Since we now have the script monitoring the shutdown button all the time, we
    can add extra buttons/switches/jumpers to be monitored at the same time. This
    will allow us to trigger specific programs or set up particular states just by
    changing the inputs. The following example allows us to easily switch between
    automatic DHCP networking (the default networking setup) and using a direct IP
    address, as used in the *Networking directly to a laptop or computer* recipe of
    [Chapter 1](ch01.html "Chapter 1. Getting Started with a Raspberry Pi Computer"),
    *Getting Started with a Raspberry Pi Computer*, for direct LAN connections.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在始终在监控关机按钮的脚本，我们可以添加额外的按钮/开关/跳线以同时监控。这将允许我们通过更改输入来触发特定程序或设置特定状态。以下示例允许我们轻松地在自动DHCP网络（默认网络设置）和使用直接IP地址之间切换，正如在[第1章](ch01.html
    "第1章。使用树莓派计算机入门")中“直接连接到笔记本电脑或计算机”食谱中使用的，用于直接LAN连接。
- en: 'Add the following components to the previous circuit:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 向前面的电路添加以下组件：
- en: A 470-ohm resistor
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个470欧姆的电阻
- en: Two pin headers with a jumper connector (or optionally a switch)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个带有跳线连接器的引脚头（或可选的开关）
- en: Breadboarding wire (solid core)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板电线（实心芯）
- en: 'After adding the previous components, our controlled shutdown circuit now looks
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了前面的组件后，我们的控制关机电路现在看起来如下：
- en: '![Adding extra functions](img/6623OT_06_020.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![添加额外功能](img/6623OT_06_020.jpg)'
- en: The controlled shutdown circuit layout, reset button, and jumper pins
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 控制关机电路布局、复位按钮和跳线引脚
- en: 'In the previous script, we add an additional input to detect the status of
    the `LAN_SWA` pin (the jumper pins we added to the circuit) using the following
    code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，我们添加了一个额外的输入来检测`LAN_SWA`引脚的状态（我们添加到电路中的跳线引脚）使用以下代码：
- en: '[PRE10]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Ensure that it is set up as an input (with a pull-up resistor) in the `gpio_setup()`
    function using the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`gpio_setup()`函数中将它设置为输入（带有上拉电阻）使用以下代码：
- en: '[PRE11]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new function to switch between the LAN modes, and read out the new IP
    address. The `doChangeLAN()` function checks if the status of the `LAN_SWA` pin
    has changed since the last call, and if so, it sets the network adaptor to DHCP
    or sets the direct LAN settings accordingly (and uses `flite` to speak the new
    IP setting if available). Finally, the LAN being set for direct connection causes
    the LED to flash slowly while that mode is active. Use the following code to do
    so:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新函数以在LAN模式之间切换，并读取新的IP地址。`doChangeLAN()`函数检查自上次调用以来`LAN_SWA`引脚的状态是否已更改，如果是，则将网络适配器设置为DHCP或相应地设置直接LAN设置（如果可用，则使用`flite`说出新的IP设置）。最后，设置为直接连接的LAN会导致LED在此模式下缓慢闪烁。使用以下代码执行此操作：
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add another function, `flashled()`, which will just toggle the state of the
    LED each time it is called. The code for this function is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个函数`flashled()`，每次调用时只需切换LED的状态。此函数的代码如下：
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we adjust the main loop to also call `doChangeLAN()` and use the result
    to decide whether we call `flashled()` using `ledon` to keep track of the LED''s
    previous state each time. The `main()` function should now be updated as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调整主循环以也调用`doChangeLAN()`并使用结果来决定是否使用`ledon`调用`flashled()`以跟踪LED的先前状态。现在`main()`函数应该更新如下：
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The GPIO keypad input
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO键盘输入
- en: We have seen how we can monitor inputs on the GPIO to launch applications and
    control the Raspberry Pi; however, sometimes we need to control third-party programs.
    Using the `uInput` library, we can emulate key presses from a keyboard (or even
    mouse movement) to control any program, using our own custom hardware.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们可以如何监控GPIO上的输入以启动应用程序和控制树莓派；然而，有时我们需要控制第三方程序。使用`uInput`库，我们可以模拟键盘按键（甚至鼠标移动）来控制任何程序，使用我们自己的定制硬件。
- en: For more information about using `uInput`, visit [http://tjjr.fi/sw/python-uinput/](http://tjjr.fi/sw/python-uinput/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于使用`uInput`的信息，请访问[http://tjjr.fi/sw/python-uinput/](http://tjjr.fi/sw/python-uinput/)。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Perform the following steps to install `uInput`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以安装`uInput`：
- en: First, we need to download `uInput`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要下载`uInput`。
- en: 'You will need to download the `uInput` Python library from Github (~50 KB)
    using the following commands:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要使用以下命令从GitHub下载`uInput` Python库（约50 KB）：
- en: '[PRE15]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The library will unzip to a directory called `python-uinput-master`.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 库将解压到名为`python-uinput-master`的目录。
- en: 'Once completed, you can remove the ZIP file using the following command:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成后，您可以使用以下命令删除ZIP文件：
- en: '[PRE16]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Install the required packages (if you have installed them already, the `apt-get`
    command will ignore them) using the following commands:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装所需的软件包（如果您已经安装了它们，`apt-get` 命令将忽略它们）：
- en: '[PRE17]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compile and install `uInput` using the following commands:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译和安装 `uInput`：
- en: '[PRE18]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we load the new `uinput` kernel module using the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令加载新的 `uinput` 内核模块：
- en: '[PRE19]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To ensure it is loaded on startup, we can add `uinput` to the `modules` file
    using the following command:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保它在启动时加载，我们可以使用以下命令将 `uinput` 添加到 `modules` 文件中：
- en: '[PRE20]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Put `uinput` on a new line in the file and save it (*Ctrl* + *X*,*Y*).
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在文件中将 `uinput` 放在新的一行，并保存它（*Ctrl* + *X*, *Y*）。
- en: 'Create the following circuit using the following equipment:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下设备创建以下电路：
- en: Breadboard (half-sized or larger)
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板（半尺寸或更大）
- en: 7 x Dupont female to male patch wires
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7 x 杜邦公对母排线
- en: Six push buttons
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个按键
- en: 6 x 470-ohm resistors
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6 x 470 欧姆电阻
- en: Breadboarding wire (solid core)
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板线（实心芯线）
- en: '![Getting ready](img/6623OT_06_021.jpg)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_06_021.jpg)'
- en: GPIO keypad circuit layout
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GPIO 键盘电路布局
- en: 'The keypad circuit can also be built into a permanent circuit by soldering
    the components into a Vero prototype board (also known as a stripboard), as shown
    in the following image:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 键盘电路也可以通过将组件焊接到一个 Vero 原型板（也称为条形板）中而永久构建，如图所示：
- en: '![Getting ready](img/6623OT_06_022.jpg)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_06_022.jpg)'
- en: GPIO keypad Pi hardware module
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GPIO 键盘 Pi 硬件模块
- en: Note
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This circuit is available as a solder-yourself kit from [PiHardware.com](http://PiHardware.com).
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此电路可作为 [PiHardware.com](http://PiHardware.com) 的自焊套件获得。
- en: 'Connect the circuit to the Raspberry Pi GPIO pins as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式将电路连接到 Raspberry Pi 的 GPIO 引脚：
- en: '|   | Button | GPIO pin |'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|   | 按钮 | GPIO 引脚 |'
- en: '| --- | --- | --- |'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| GND |   | 6 |'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GND |   | 6 |'
- en: '| v | B_DOWN | 22 |'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| v | B_DOWN | 22 |'
- en: '| < | B_LEFT | 18 |'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| < | B_LEFT | 18 |'
- en: '| ^ | B_UP | 15 |'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ^ | B_UP | 15 |'
- en: '| > | B_RIGHT | 13 |'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| > | B_RIGHT | 13 |'
- en: '| 1 | B_1 | 11 |'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | B_1 | 11 |'
- en: '| 2 | B_2 | 7 |'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 2 | B_2 | 7 |'
- en: How to do it…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a `gpiokeys.py` script as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `gpiokeys.py` 脚本：
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we import `uinput` and define the wiring of the keypad buttons. For each
    of the buttons in `BTN`, we enable them as inputs with internal pull-ups enabled.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 `uinput` 并定义键盘按钮的布线。对于 `BTN` 中的每个按钮，我们将其启用为输入，并启用内部上拉电阻。
- en: Next, we set up `uinput`, defining the keys we want to emulate and adding them
    to the `uinput.Device()` function. We wait a few seconds to allow `uinput` to
    initialize, set the initial button and key states, and start our `main` loop.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置 `uinput`，定义我们想要模拟的按键并将它们添加到 `uinput.Device()` 函数中。我们等待几秒钟以允许 `uinput`
    初始化，设置初始按钮和按键状态，并开始我们的 `main` 循环。
- en: 'The `main` loop is split into two sections: the first part checks through the
    buttons and records the states in `btn_state`, and the second part compares the
    `btn_state` with the current `key_state` array. This way, we can detect a change
    in `btn_state` and call `device.emit()` to toggle the state of the key.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 循环分为两部分：第一部分检查按钮并记录在 `btn_state` 中的状态，第二部分将 `btn_state` 与当前的 `key_state`
    数组进行比较。这样，我们可以检测 `btn_state` 的变化并调用 `device.emit()` 来切换按键的状态。'
- en: 'To allow us to run this script in the background, we can run it with `&` as
    shown in the following command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许我们在后台运行此脚本，我们可以使用 `&` 如以下命令所示运行它：
- en: '[PRE22]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `&` character allows the command to run in the background, so we can continue
    with the command line to run other programs. You can use `fg` to bring it back
    to the foreground, or `%1`, `%2`, and so on if you have several commands running.
    Use `jobs` to get a list.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`&` 字符允许命令在后台运行，因此我们可以继续使用命令行运行其他程序。您可以使用 `fg` 将其带到前台，或者如果您有多个命令正在运行，可以使用 `%1`、`%2`
    等等。使用 `jobs` 获取列表。'
- en: You can even put a process/program on hold to get to the command prompt by pressing
    *Ctrl* + *Z* and then resume it with `bg` (which will let it run in the background).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过按 *Ctrl* + *Z* 暂停进程/程序以获取命令提示符，然后使用 `bg`（这将允许它在后台运行）来恢复它。
- en: You can test the keys using the game created in the *Creating an overhead scrolling
    game* recipe in [Chapter 4](ch04.html "Chapter 4. Creating Games and Graphics"),
    *Creating Games and Graphics*, which you can now control using your GPIO directional
    pad. Don't forget that if you are connecting to the Raspberry Pi remotely, any
    key presses will only be active on the locally connected screen.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用[第4章](ch04.html "第4章。创建游戏和图形")中*创建顶部滚动游戏*食谱中创建的游戏来测试按键，您现在可以使用GPIO方向垫来控制它。别忘了，如果您是通过远程连接到Raspberry
    Pi，任何按键操作都只会激活本地连接的屏幕。
- en: There's more…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: We can do more using `uinput` to provide hardware control for other programs,
    including those that require mouse input.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`uinput`来为其他程序提供硬件控制，包括那些需要鼠标输入的程序。
- en: Generating other key combinations
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成其他按键组合
- en: 'You can create several different key mappings in your file to support different
    programs. For instance, the `events_z80` key mapping would be useful for a Spectrum
    Emulator such as **fuze** (browse to [http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi](http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi)
    for details). The `events_omx` key mappings are suitable for controlling video
    played through the OMX Player using the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文件中创建多个不同的键映射来支持不同的程序。例如，`events_z80`键映射对于**fuze**这样的Spectrum模拟器非常有用（有关详细信息，请浏览[http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi](http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi)）。`events_omx`键映射适合通过以下命令控制通过OMX
    Player播放的视频：
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can get a list of keys supported by `omxplayer` by using the `-k` parameter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-k`参数获取`omxplayer`支持的按键列表。
- en: 'Replace the line that defines the `events` list with a new key mapping, and
    select different ones by assigning them to events using the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将定义`events`列表的行替换为新键映射，并通过以下代码将不同的映射分配给事件：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can find all the `KEY` definitions in the `input.h` file; you can view
    it using the `less` command (press *Q* to exit) as shown in the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`input.h`文件中找到所有的`KEY`定义；您可以使用`less`命令查看它（按*Q*退出），如下所示：
- en: '[PRE25]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Emulating mouse events
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟鼠标事件
- en: 'The `uinput` library can emulate mouse and joystick events as well as keyboard
    presses. To use the buttons to simulate a mouse, we can adjust the script to use
    mouse events (as well as defining `mousemove` to set the step size of the movement)
    using the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`uinput`库可以模拟鼠标和摇杆事件以及键盘按键。要使用按钮模拟鼠标，我们可以调整脚本以使用鼠标事件（以及定义`mousemove`来设置移动的步长）使用以下代码：'
- en: '[PRE26]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need to modify the button handling to provide continuous movement,
    as we don''t need to keep track of the state of the keys for the mouse. To do
    so, use the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改按钮处理，以提供连续的运动，因为我们不需要跟踪鼠标按键的状态。为此，请使用以下代码：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Multiplexed color LEDs
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复用彩色LED
- en: The next example in this chapter demonstrates that some seemingly simple hardware
    can produce some impressive results if controlled with software. We return to
    using some RGB LEDs that are wired so that we only need to use eight GPIO pins
    to control the red, green, and blue elements of five RGB LEDs using a method called
    **hardware multiplexing** (see the *Hardware multiplexing* subsection in the *There's
    more…* section of this recipe).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一个示例演示了，如果用软件控制，一些看似简单的硬件可以产生一些令人印象深刻的结果。我们回到使用一些RGB LED，这些LED的连接方式使得我们只需要使用八个GPIO引脚，通过一种称为**硬件复用**（见本食谱*更多内容*部分的*硬件复用*子部分）的方法来控制五个RGB
    LED的红色、绿色和蓝色元素。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You will need the RGB LED module shown in the following image:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下图片中显示的RGB LED模块：
- en: '![Getting ready](img/6623OT_06_023.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_06_023.jpg)'
- en: The RGB LED module from PiHardware.com
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 来自PiHardware.com的RGB LED模块
- en: As you can see in the preceding image, the RGB LED module from [PiHardware.com](http://PiHardware.com)
    comes with GPIO pins and a Dupont female to female cable for connecting it. Although
    there are two sets of pins labelled 1 to 5, only one side needs to be connected.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，来自[PiHardware.com](http://PiHardware.com)的RGB LED模块附带GPIO引脚和Dupont公对公电缆，用于连接。尽管有两套标有1到5的引脚，但只需连接其中一边。
- en: 'Alternatively, you can recreate your own with the following circuit using five
    common cathode RGB LEDs, 3 x 470-ohm resistors, and a Vero prototype board (or
    large breadboard). The circuit will look as shown in the following diagram:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下电路重新创建自己的电路，该电路使用五个常见的阴极RGB LED、3个470欧姆电阻和一个Vero原型板（或大型面包板）。电路将如下所示：
- en: '![Getting ready](img/6623OT_06_024.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_06_024.jpg)'
- en: Circuit diagram for the RGB LED module
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED模块电路图
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Strictly speaking, we should use 15 resistors in this circuit (one for each
    RGB LED element), which will avoid interference from LEDs sharing the same resistor
    and would also prolong the life of the LEDs themselves if switched on together.
    However, there is only a slight advantage, particularly since we intend to drive
    each RGB LED independently of the other four to achieve multicolor effects.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，在这个电路中我们应该使用15个电阻（每个RGB LED元件一个），这将避免LED共享相同电阻时的干扰，并且如果同时开启，也会延长LED本身的使用寿命。然而，这种优势微乎其微，尤其是当我们打算独立驱动每个RGB
    LED以实现多彩效果时。
- en: 'You will need to connect the circuit to the Raspberry Pi GPIO header as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将电路连接到Raspberry Pi的GPIO引脚，如下所示：
- en: '| RGB LED |   |   |   |   |   | 1 |   | 2 | 3 |   | 4 |   |   |   |   |   |
      |   |   |   |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| RGB LED |   |   |   |   |   | 1 |   | 2 | 3 |   | 4 |   |   |   |   |   |
      |   |   |   |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Rpi GPIO Pin** | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24
    | 26 | 28 | 30 | 32 | 34 | 36 | 38 | 40 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **Rpi GPIO 引脚** | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24 |
    26 | 28 | 30 | 32 | 34 | 36 | 38 | 40 |'
- en: '| **Rpi GPIO Pin** | 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 | 21 | 23 |
    25 | 27 | 29 | 31 | 33 | 35 | 37 | 39 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **Rpi GPIO 引脚** | 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 | 21 | 23 |
    25 | 27 | 29 | 31 | 33 | 35 | 37 | 39 |'
- en: '| **RGB LED** |   |   |   | 5 |   | R | G | B |   |   |   |   |   |   |   |
      |   |   |   |   |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **RGB LED** |   |   |   | 5 |   | R | G | B |   |   |   |   |   |   |   |
      |   |   |   |   |'
- en: How to do it…
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create the `rgbled.py` script and perform the following steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`rgbled.py`脚本并执行以下步骤：
- en: 'Import all the required modules and define values to be used with the help
    of the following code:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导入所有必需的模块并定义要使用的值：
- en: '[PRE28]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define functions to set up the GPIO pins using the following code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码定义设置GPIO引脚的函数：
- en: '[PRE29]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define our utility functions to help control the LEDs using the following code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码定义我们的实用函数，以帮助控制LED：
- en: '[PRE30]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a test function to demonstrate the functionality of the module:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试函数以演示模块的功能：
- en: '[PRE31]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To start with, we define the hardware setup by defining the states required
    to **Enable** and **Disable** the LED depending on the type of RGB LED (common
    cathode) used. If you are using a common anode device, just reverse the **Enable**/**Disable**
    states.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过定义根据使用的RGB LED（公共阴极）类型来**启用**和**禁用**LED所需的状态来定义硬件设置。如果您使用的是公共阳极设备，只需反转**启用**/**禁用**状态即可。
- en: Next, we define the GPIO mapping to the pins to match the wiring we did previously.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义GPIO到引脚的映射，以匹配我们之前所做的布线。
- en: 'We also define some basic color combinations by combining red, green, and/or
    blue together, as shown in the following diagram:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过组合红色、绿色和/或蓝色来定义一些基本的颜色组合，如下所示：
- en: '![How it works…](img/6623OT_06_025.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6623OT_06_025.jpg)'
- en: LED color combinations
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: LED颜色组合
- en: We define a series of useful functions, the first being `led_setup()`, which
    will set the GPIO numbering to `GPIO.BOARD` and define all the pins used to be
    outputs. We also call a function named `led_clear()`, which will set the pins
    to the default state with all the pins disabled.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一系列有用的函数，第一个是`led_setup()`，它将GPIO编号设置为`GPIO.BOARD`并定义所有用作输出的引脚。我们还调用一个名为`led_clear()`的函数，该函数将引脚设置为默认状态，所有引脚均被禁用。
- en: Note
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This means the LED pins, 1-5 (the common cathode on each LED), are set to `HIGH`,
    while the RGB pins (the separate anodes for each color) are set to `LOW`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着LED引脚1-5（每个LED的公共阴极）被设置为`HIGH`，而RGB引脚（每个颜色的独立阳极）被设置为`LOW`。
- en: We create a function called `led_gpiocontrol()` that will allow us to set the
    state of one or more pins. The `isinstance()` function allows us to test a value
    to see whether it matches a particular type (in this case, a single integer);
    then we can either set the state of that single pin or iterate through the list
    of pins and set each one.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `led_gpiocontrol()` 的函数，它将允许我们设置一个或多个引脚的状态。`isinstance()` 函数允许我们测试一个值以查看它是否与特定类型匹配（在这种情况下，一个单独的整数）；然后我们可以设置该单个引脚的状态，或者遍历引脚列表并设置每个引脚。
- en: Next, we define two functions, `led_activate()` and `led_deactivate()`, which
    will enable and disable the specified LED and color. Finally, we define `led_time()`,
    which will allow us to specify an LED, color, and time to switch it on for.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义两个函数，`led_activate()` 和 `led_deactivate()`，它们将启用和禁用指定的 LED 和颜色。最后，我们定义
    `led_time()`，它将允许我们指定一个 LED、颜色和时间来开启它。
- en: We also create `led_cleanup()` to reset the pins (and LEDs) to the default values
    and call `GPIO.cleanup()` to release the GPIO pins in use.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了 `led_cleanup()` 函数来将引脚（和LED）重置为默认值，并调用 `GPIO.cleanup()` 来释放使用的GPIO引脚。
- en: 'This script is intended to become a library file, so we will use the `if __name__==''__main__''`
    check to only run our test code when running the file directly:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本旨在成为一个库文件，因此我们将使用 `if __name__=='__main__'` 检查来仅在直接运行文件时执行我们的测试代码：
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By checking the value of `__name__`, we can determine whether the file was run
    directly (it will equal `__main__`) or whether it was imported by another Python
    script.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查 `__name__` 的值，我们可以确定文件是直接运行的（它将等于 `__main__`）还是被另一个Python脚本导入的。
- en: This allows us to define special test code that is only executed when we directly
    load and run the file. If we include this file as a module in another script,
    then this code will not be executed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们定义仅在直接加载和运行文件时执行的特定测试代码。如果我们将此文件作为模块包含在其他脚本中，则此代码将不会执行。
- en: We have used this technique previously in the *There's more…* section in the
    *Working with text and strings* recipe of [Chapter 2](ch02.html "Chapter 2. Starting
    with Python Strings, Files, and Menus"), *Starting with Python Strings, Files,
    and Menus*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第2章](ch02.html "第2章。从Python字符串、文件和菜单开始") 的 *There's more…* 部分和 *Working
    with text and strings* 菜单中使用了这种技术。
- en: As before, we will use `try`/`finally` to allow us to always perform cleanup
    actions, even if we exit early.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用 `try`/`finally` 来确保我们总是能够执行清理操作，即使我们在早期退出。
- en: To test the script, we will set the LEDs to light up in various colors one after
    another.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试脚本，我们将设置LED依次以各种颜色发光。
- en: There's more…
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can create a few different colors by switching on one or more parts of the
    RGB LED at a time. However, with some clever programming, we can create a whole
    spectrum of colors. Also, we can display different colors on each LED, seemingly
    at the same time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过同时开启RGB LED的一个或多个部分来创建几种不同的颜色。然而，通过一些巧妙的编程，我们可以创建整个光谱的颜色。此外，我们可以在每个LED上显示不同的颜色，看起来似乎是同时进行的。
- en: Hardware multiplexing
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件复用
- en: An LED requires a high voltage on the anode side and a lower voltage on the
    cathode side to light up. The RGB LEDs used in the circuit are common cathode,
    so we must apply a high voltage (3.3V) on the RGB pins and a low voltage (0V)
    on the cathode pin (wired to pins 1 to 5 for each of the LEDs).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一个LED需要在阳极侧施加高电压，在阴极侧施加低电压才能发光。电路中使用的RGB LED是共阴极，因此我们必须在RGB引脚上施加高电压（3.3V），在阴极引脚上施加低电压（0V）（每个LED连接到1到5号引脚）。
- en: 'The cathode and RGB pin states are as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 阴极和RGB引脚状态如下：
- en: '![Hardware multiplexing](img/6623OT_06_026.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![硬件复用](img/6623OT_06_026.jpg)'
- en: Cathode and RGB pin states
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 阴极和RGB引脚状态
- en: Therefore, we can enable one or more of the RGB pins but still control which
    of the LEDs are lit. We enable the pins of the LEDs we want to light up and disable
    the ones we don't. This allows us to use far fewer pins than we would need to
    control each of the 15 RGB lines separately.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以启用一个或多个RGB引脚，但仍能控制哪些LED是亮的。我们启用我们想要点亮的LED的引脚，并禁用我们不需要的引脚。这允许我们使用比单独控制每个15个RGB线所需的引脚数量少得多。
- en: Displaying random patterns
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示随机图案
- en: 'We can add new functions to our library to produce different effects, such
    as generating random colors. The following function uses `randint()` to get a
    value between 1 and the number of colors. We ignore any values that are over the
    number of the available colors so that we can control how often the LEDs may be
    switched off. Perform the following steps to add the required functions:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的库添加新功能以产生不同的效果，例如生成随机颜色。以下函数使用 `randint()` 获取1到颜色数量的值。我们忽略任何超过可用颜色数量的值，这样我们可以控制LED灯关闭的频率。执行以下步骤添加所需的函数：
- en: 'Add the `randint()` function from the `random` module to the `rgbled.py` script
    using the following code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `randint()` 函数从 `random` 模块添加到 `rgbled.py` 脚本中，使用以下代码：
- en: '[PRE32]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now add `led_rgbrandom()` using the following code:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加 `led_rgbrandom()` 使用以下代码：
- en: '[PRE33]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use the following commands in the `main()` function to create a series of flashing
    LEDs:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中使用以下命令创建一系列闪烁的LED：
- en: '[PRE34]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Mixing multiple colors
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合多种颜色
- en: Until now, we have only displayed a single color at a time on one or more of
    the LEDs. If you consider how the circuit is wired up, you might wonder how can
    we get one LED to display one color and another a different one at the same time?
    The simple answer is that we don't need to—we just do it quickly!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一次只在单个或多个LED上显示一种颜色。如果你考虑电路是如何连接的，你可能想知道我们如何让一个LED显示一种颜色，而另一个同时显示不同的颜色？简单的答案是，我们不需要——我们只是做得很快！
- en: 'All we need to do is display one color at a time but change it very quickly
    back and forth, so fast the color looks like a mix of the two (or even a combination
    of the three red/green/blue LEDs). Fortunately, this is something that computers
    such as the Raspberry Pi can do very easily, even allowing us to combine the RGB
    elements to make multiple shades of colors across all five LEDs. Perform the following
    steps to mix the colors:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是每次显示一种颜色，但非常快速地交替改变，这样颜色看起来就像两种（甚至三种红/绿/蓝LED的组合）。幸运的是，这是像Raspberry Pi这样的计算机可以非常容易做到的事情，甚至允许我们将RGB元素组合起来，使所有五个LED显示多种颜色的阴影。执行以下步骤来混合颜色：
- en: 'Add combo color definitions to the top of the `rgbled.py` script, after the
    definition of the mixed colors, using the following code:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `rgbled.py` 脚本的顶部添加组合颜色定义，在混合颜色定义之后，使用以下代码：
- en: '[PRE35]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code will provide the combination of colors to create our shades,
    with `RGB_COLORS` providing a smooth progression through the shades.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将提供颜色组合以创建我们的阴影，其中 `RGB_COLORS` 提供了阴影的平滑过渡。
- en: 'Next, we need to create a function called `led_combo()` to handle single or
    multiple colors. The code for the function will be as follows:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个名为 `led_combo()` 的函数来处理单色或多色。该函数的代码如下：
- en: '[PRE36]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can create a new script, `rgbledrainbow.py`, to make use of the new
    functions in our `rgbled.py` module. The `rgbledrainbow.py` script will be as
    follows:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的脚本，`rgbledrainbow.py`，来利用我们 `rgbled.py` 模块中的新功能。`rgbledrainbow.py`
    脚本如下：
- en: '[PRE37]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `main()` function will first cycle through the LEDs, setting each color
    from the `RGB_COLORS` array on all the LEDs. Then, it will cycle through the colors,
    creating a rainbow effect over the LEDs:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数将首先循环LED，将 `RGB_COLORS` 数组中的每种颜色设置在所有LED上。然后，它将循环颜色，在LED上创建彩虹效果：'
- en: '![Mixing multiple colors](img/6623OT_06_027.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![混合多种颜色](img/6623OT_06_027.jpg)'
- en: Cycle through multiple colors on the five RGB LEDs
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在五个RGB LED上循环多种颜色
- en: Writing messages using Persistence of Vision
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视觉持久性书写信息
- en: '**Persistence of Vision (POV)** displays can produce an almost magical effect,
    displaying images in the air by moving a line of LEDs back and forth very quickly
    or around in circles. The effect works because your eyes are unable to adjust
    fast enough to separate out the individual flashes of light, and so you observe
    a merged image (the message or picture being displayed).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉持久性 (POV)** 显示可以产生几乎神奇的效果，通过快速移动一串LED灯的来回或圆形旋转，在空中显示图像。这种效果之所以有效，是因为你的眼睛无法快速调整以分离出单个的光闪，因此你观察到的是一个合并的图像（显示的消息或图片）。'
- en: '![Writing messages using Persistence of Vision](img/6623OT_06_028.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![使用视觉持久性书写信息](img/6623OT_06_028.jpg)'
- en: Persistence of vision using RGB LEDs
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RGB LED的视觉持久性
- en: Getting ready
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe also uses the RGB LED kit used in the previous recipe; you will
    also need the following additional items:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方也使用之前配方中使用的RGB LED套件；你还需要以下额外物品：
- en: Breadboard (half-sized or larger)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板（半尺寸或更大）
- en: 2 x Dupont female to male patch wires
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 杜邦公对母排线
- en: Tilt switch (ball-bearing type is suitable)
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倾斜开关（球轴承类型适合）
- en: 1 x 470 ohm resistor (R_Protect)
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 470 欧姆电阻（R_Protect）
- en: Breadboarding wire (solid core)
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板线（实心芯）
- en: 'The tilt switch should be added to the RGB LED (as described in the *Getting
    ready* section of the *Multiplexed color LEDs* recipe). The tilt switch is wired
    as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关应添加到 RGB LED（如 *多路复用彩色 LED* 菜谱的 *准备就绪* 部分所述）。倾斜开关的接线如下：
- en: '![Getting ready](img/6623OT_06_029.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_06_029.jpg)'
- en: Tilt switch is connected to GPIO Input (GPIO pin 24) and Gnd (GPIO pin 6)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关连接到 GPIO 输入（GPIO 引脚 24）和 Gnd（GPIO 引脚 6）
- en: 'To reproduce the POV image, you will need to be able to quickly move the LEDs
    and tilt switch back and forth. Note how the tilt switch is mounted angled to
    the side, so the switch will open when moved to the left. It is recommended that
    the hardware is mounted onto a length of wood or similar. You can even use a portable
    USB battery pack along with a Wi-Fi dongle to power and control the Raspberry
    Pi through a remote connection (see [Chapter 1](ch01.html "Chapter 1. Getting
    Started with a Raspberry Pi Computer"), *Getting Started with a Raspberry Pi –
    Connecting Remotely to the Raspberry Pi over the Network using SSH (and X11 Forwarding)*,
    for details):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要重现 POV 图像，你需要能够快速移动 LED 和倾斜开关。注意倾斜开关是如何倾斜安装到侧面的，这样当移动到左侧时开关会打开。建议将硬件安装在一根木头或其他类似材料上。你甚至可以使用便携式
    USB 电池组和 Wi-Fi 拨号器，通过远程连接为 Raspberry Pi 提供电源和控制（有关详细信息，请参阅 [第 1 章](ch01.html "第
    1 章。使用 Raspberry Pi 计算机入门")，*使用 Raspberry Pi 入门 – 通过 SSH（和 X11 转发）在网络中远程连接到 Raspberry
    Pi*）：
- en: '![Getting ready](img/6623OT_06_030.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_06_030.jpg)'
- en: Persistence of Vision hardware setup
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉持久性硬件设置
- en: You will also need the completed `rgbled.py` file, which we will extend further
    in the *How to do it*… section.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要完成的 `rgbled.py` 文件，我们将在 *如何做到这一点*… 部分进一步扩展。
- en: How to do it…
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Create a script called `tilt.py` to report the state of the tilt switch:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `tilt.py` 的脚本，以报告倾斜开关的状态：
- en: '[PRE38]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can test the script by running it directly with the following command:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令直接运行脚本来测试脚本：
- en: '[PRE39]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the following `rgbled_pov()` function to the `rgbled.py` script we created
    previously; this will allow us to display a single line of our image:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 `rgbled_pov()` 函数添加到我们之前创建的 `rgbled.py` 脚本中；这将使我们能够显示图像的单行：
- en: '[PRE40]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will now create the following file, called `rgbledmessage.py`, to perform
    the required actions to display our message. First we will import the modules
    used, the updated `rgbled` module, the new `tilt` module, and the python `os`
    module. Initially, we set `DEBUG` to `True` so the Python terminal will display
    additional information while the script is running:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个名为 `rgbledmessage.py` 的文件，以执行显示消息所需的操作。首先我们将导入使用的模块，更新的 `rgbled` 模块，新的
    `tilt` 模块，以及 python 的 `os` 模块。最初，我们将 `DEBUG` 设置为 `True`，以便 Python 终端在脚本运行时显示额外的信息：
- en: '[PRE41]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add a `readMessageFile()` function to read the content of the `letters.txt`
    file and then add `processFileContent()` to generate a **Python dictionary** of
    the LED patterns for each letter:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `readMessageFile()` 函数来读取 `letters.txt` 文件的内容，然后添加 `processFileContent()`
    来生成每个字母的 LED 模式的 **Python 字典**：
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add a `createBuffer()` function, which will convert a message into a series
    of LED patterns for each letter (assuming the letter is defined by the `letters.txt`
    file):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `createBuffer()` 函数，该函数将消息转换为每个字母的 LED 模式序列（假设字母由 `letters.txt` 文件定义）：
- en: '[PRE43]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we define `displayBuffer()` to display the LED patterns using the `rgbled_pov()`
    function in the `rgbled` module:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `displayBuffer()` 来使用 `rgbled` 模块中的 `rgbled_pov()` 函数显示 LED 模式：
- en: '[PRE44]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we create a `main()` function to perform each of the required steps:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 `main()` 函数来执行每个必需的步骤：
- en: Set up the hardware components (RGB LEDs and the tilt switch).
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置硬件组件（RGB LED 和倾斜开关）。
- en: Read the `letters.txt` file.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 `letters.txt` 文件。
- en: Define the dictionary of LED letter patterns.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 LED 字母模式字典。
- en: Generate a buffer to represent the required message.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个缓冲区来表示所需的消息。
- en: 'Display the buffer using the `rgbled` module and control it with the `tilt`
    module:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `rgbled` 模块和 `tilt` 模块显示缓冲区：
- en: '[PRE45]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the following file, called `letters.txt`, to define the LED patterns
    needed to display the example `''_COOKBOOK_''` message. Note, this file only needs
    to define a pattern for each unique letter or symbol in the message:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下文件，命名为`letters.txt`，以定义显示示例`'_COOKBOOK_'`消息所需的LED模式。注意，此文件只需为消息中的每个唯一字母或符号定义一个模式：
- en: '[PRE46]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works…
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'The first function, `readMessageFile()`, will open and read the contents of
    a given file (as we did previously in [Chapter 2](ch02.html "Chapter 2. Starting
    with Python Strings, Files, and Menus"), *Starting with Python Strings, Files,
    and Menus*; see the *Using files and handling errors* recipe for more details).
    This will then use `processFileContent()` to return a Python **dictionary** containing
    corresponding patterns for the letters defined in the file provided. Each line
    in the file is processed, ignoring any line with a `#` character in and checking
    for `"` characters to indicate the name for the LED pattern that follows after.
    After the file has been processed, we end up with a Python dictionary that contains
    LED patterns for the `''_''`, `''C''`, `''B''`, `''K''` and `''O''` characters:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`readMessageFile()`将打开并读取给定文件的正文（正如我们在[第2章](ch02.html "第2章。从Python字符串、文件和菜单开始")中之前所做的那样，*从Python字符串、文件和菜单开始*；有关更多详细信息，请参阅*使用文件和处理错误*配方）。然后它将使用`processFileContent()`返回一个包含文件中定义的字母对应模式的Python
    **字典**。文件中的每一行都会被处理，忽略任何包含`#`字符的行，并检查`"`字符以指示随后的LED模式的名称。在文件被处理后，我们最终得到一个包含`'_'`、`'C'`、`'B'`、`'K'`和`'O'`字符的LED模式的Python字典：
- en: '[PRE47]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that we have a selection of letters to choose from, we can create a sequence
    of LED patterns using the `createBuffer()` function. As the name suggests, the
    function will build up a buffer of LED patterns by looking up each letter in the
    message and adding the related pattern row by row. If a letter isn't found in
    the dictionary, then a space will be used instead.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一组可供选择的字母，我们可以使用`createBuffer()`函数创建一个LED模式序列。正如其名所示，该函数将通过查找消息中的每个字母并逐行添加相关模式来构建一个LED模式的缓冲区。如果一个字母在字典中找不到，则将使用空格代替。
- en: 'Finally, we now have a list of LED patterns ready to display. To control when
    we start the sequence, we will use the TILT module and check the status of the
    tilt switch:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在有一个准备显示的LED模式列表。为了控制何时开始序列，我们将使用TILT模块并检查倾斜开关的状态：
- en: '![How it works…](img/6623OT_06_031.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_06_031.jpg)'
- en: The tilt switch position when not moving (left) and moving (right)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关在未移动（左侧）和移动（右侧）时的位置
- en: 'The tilt switch consists of a small ball bearing enclosed in a hollow insulated
    cylinder; the connection between the two pins is closed when the ball is resting
    at the bottom of the cylinder. The tilt switch is open when the ball is moved
    to the other end of the cylinder, out of contact of the pins:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关由一个装在空心绝缘圆柱体内的微型滚珠轴承组成；当球在圆柱体底部静止时，两个引脚之间的连接是闭合的。当球被移动到圆柱体的另一端，与引脚失去接触时，倾斜开关是打开的：
- en: '![How it works…](img/6623OT_06_032.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_06_032.jpg)'
- en: The tilt switch circuit, switch closed and switch open
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关电路，开关关闭和开关打开
- en: The tilt switch circuit shown previously will allow GPIO pin 24 to be connected
    to the ground when the switch is closed, then if we read the pin it will return
    `False` when it is at rest. By setting the GPIO pin as an input and enabling the
    internal pull-up resistor, when the tilt switch is open it will report `True`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的倾斜开关电路将允许GPIO引脚24在开关关闭时连接到地，然后如果我们读取该引脚，当它处于静止状态时将返回`False`。通过将GPIO引脚设置为输入并启用内部上拉电阻，当倾斜开关打开时，它将报告`True`。
- en: 'If the tilt switch is open (reporting `True`) then we will assume the unit
    is being moved and begin displaying the LED sequences, incrementing the current
    position each time we display a row of the LED pattern. Just to make the pattern
    a little more colorful (just because we can!) we repeat each row in another color.
    As soon as the `TILT.tilt_moving()` function reports we have stopped moving or
    we are moving in the opposite direction, we will reset the current position, ready
    to start the whole pattern over again:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果倾斜开关是打开的（报告`True`），则我们假设单元正在移动，并开始显示LED序列，每次显示LED模式的一行时，都会递增当前位置。为了使模式更加多彩（只是因为我们能这么做！），我们将每一行重复一遍，用另一种颜色。一旦`TILT.tilt_moving()`函数报告我们停止移动或正在朝相反方向移动，我们将重置当前位置，以便再次从头开始整个模式：
- en: '![How it works…](img/6623OT_06_033.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623OT_06_033.jpg)'
- en: The message is displayed by the RGB LEDs – here using Green and Blue together
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 信息是由RGB LED显示的——这里使用绿色和蓝色一起显示
- en: When the RGB LED module and tilt switch are moved back and forth, we should
    see the message displayed in the air!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当RGB LED模块和倾斜开关来回移动时，我们应该能看到空中显示的信息！
- en: Try experimenting with different color combinations, speeds, and arm waviness
    to see what effects you can produce. You could even create a similar setup mounted
    on a wheel to produce a continuous POV effect.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的颜色组合、速度和手臂摆动来观察你能产生哪些效果。你甚至可以创建一个安装在轮子上的类似装置，以产生连续的POV效果。
