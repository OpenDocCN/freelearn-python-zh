- en: Vision Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉处理
- en: It's really amazing what we can do using a simple combination of sensors and
    actuators. After all, these are the things that make robots what they are known
    for. There is a vast numbers of sensors available on the market today that we
    can use. We can put hundreds of sensors over a robot, but there is one thing that
    subsides the power of all other sensors. It's the camera. Sensors give us data
    about our physical environment, whereas the camera lets us see it. So, it is quite
    an important sensor to consider. In this chapter, we will go ahead and see how
    we can couple a camera to our Raspberry Pi and start computing with the image
    data that we get.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 真是令人惊叹，我们能够通过简单的传感器和执行器组合做到的事情。毕竟，这些就是让机器人成为我们所知的样子的事物。如今市场上可供我们使用的传感器数量庞大。我们可以在机器人上安装数百个传感器，但有一件事能够超越所有其他传感器的力量。那就是相机。传感器为我们提供了有关物理环境的数据，而相机则让我们能够看到它。因此，这是一个相当重要的传感器，值得我们考虑。在本章中，我们将继续探讨如何将相机连接到我们的树莓派，并开始使用我们获取到的图像数据进行计算。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basics of images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的基本知识
- en: Preparing Raspberry Pi for vision processing application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为视觉处理应用准备树莓派
- en: Installing OpenCV
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装OpenCV
- en: Image recognition
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像识别
- en: The basics of images
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像的基本知识
- en: When we say camera, we don't necessarily think of it as a sensor, even tough
    it is one. However, it is slightly different from all the sensors that we have
    studied until now. Most of the sensors are consisting of one sensing element such
    as proximity sensing, temperature sensing, or passive IR sensing. With a camera,
    what we are doing is capturing light; now, rather than having one light sensor,
    we have multiple, in fact an array of millions of these sensors grouped together
    on a single chip. But the story does not end here, and these sensors not only
    capture just light, but also different intensities of light; they can sense the
    color spectrum and its relative brightness. Every sensing element that does this
    functionality is named a **pixel**. Most of these pixels generate an RGB value,
    which is nothing but the intensity of red, green, and blue color. Why RGB, you
    might think? These are primary colors, and mixing these colors up in the right
    quantities results in making different shades of colors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到相机时，我们并不一定将其视为传感器，尽管它确实是一种。然而，它与到目前为止我们所研究的所有传感器都略有不同。大多数传感器都由一个感应元件组成，例如接近感应、温度感应或被动红外感应。而使用相机，我们所做的是捕捉光线；现在，我们不再只有一个光传感器，而是有多个，实际上是在单个芯片上组成了一个百万级别的传感器阵列。但故事还没有结束，这些传感器不仅捕捉光线，还能捕捉不同强度的光线；它们可以感知颜色光谱及其相对亮度。执行这种功能的每个感应元件都被称为**像素**。大多数这些像素生成RGB值，这不过是红色、绿色和蓝色颜色的强度。为什么是RGB呢？这些是原色，以正确的比例混合这些颜色会产生不同的颜色阴影。
- en: So, if we have a value of these colors, we can recreate the colors that we want.
    As we earlier understood, there are millions of these pixels in any camera, making
    up the length and the breadth of the image-sensing chip. The data from these image-sensing
    elements makes up the image. So far so good. But why are we talking about this? The
    reason is, this is how a camera sees the world and just to not how we see it.
    Biological vision is entirely a different story. So, we need to understand how
    the camera works and what the raw data that it gives is to go ahead and do the
    vision processing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有这些颜色的值，我们可以重新创建我们想要的颜色。正如我们之前所理解的，任何相机中都有数百万个这样的像素，构成了图像感应芯片的长度和宽度。这些图像感应元件的数据构成了图像。到目前为止，一切都很顺利。但我们为什么要谈论这个？原因在于，这就是相机看待世界的方式，而不仅仅是我们的视角。生物视觉完全是另一回事。因此，我们需要了解相机的工作原理以及它提供的原始数据，以便进行视觉处理。
- en: Now, let's get back to the pixels and their data. As there are millions of these
    pixels, there must be millions of readings of these pixels, and these readings
    would be in the form of RGB values. Now, this data must be arranged in a specific
    form so as to understand which pixel data we are dealing with. If it is not arranged,
    then none of this data would make any sense.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到像素及其数据。由于有数百万个这样的像素，因此必然有数百万个像素的读取值，这些读取值将以RGB值的形式出现。现在，这些数据必须以特定的形式排列，以便理解我们正在处理哪些像素数据。如果它们没有排列好，那么这些数据将没有任何意义。
- en: As you learned previously, an array/list is the best way to store large, structured
    data, and if you look at the data from the image, then it is nothing but the values
    of RGB for individual structured pixels. Perfect! So, now we know what we are
    dealing with and how we have to deal with it. Or do we?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所学，数组/列表是存储大量结构化数据的最佳方式，如果你看图像数据，那么它不过是单个结构化像素的RGB值。太棒了！所以，现在我们知道我们正在处理什么以及我们如何处理它。或者，我们真的知道吗？
- en: As you may recollect, the images we are talking about here are made by millions
    of pixels. So, the pixel data would also be in the magnitude of millions as well.
    This data is extremely huge, as we are not just talking about millions of pixels
    but each RGB value. In other words, every single pixel will give us three values,
    that is, the value of red, green, and blue. In other words, it's a lot of data.
    Normal lists cannot handle this much of data; hence, we have to install a special
    library named **NumPy** to take care of this vast arrays. In this chapter, there
    are multiple dependencies that we will have to install and update in order for
    the Raspberry Pi to go ahead and do vision processing. We will see how we will
    install it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆，我们在这里讨论的图像是由数百万个像素组成的。因此，像素数据也将达到数百万级别。这些数据极其庞大，因为我们不仅谈论数百万个像素，还包括每个RGB值。换句话说，每个单独的像素都会给我们三个值，即红色、绿色和蓝色的值。换句话说，这是一大批数据。普通的列表无法处理这么多数据；因此，我们必须安装一个名为**NumPy**的特殊库来处理这些庞大的数组。在本章中，我们将需要安装和更新多个依赖项，以便Raspberry
    Pi能够进行视觉处理。我们将看到如何安装它。
- en: Now moving forward, we have the data of every single pixel in a very structured
    way, but what are we exactly going to do with it? Well as you have learned in
    the previous chapters, when we have data in a structured form, then we can go
    ahead and do multiple operations as we have done in the previous chapter of lists.
    The data we are dealing with here is somewhat in a specific domain. That is, we
    know that the data we would be receiving would be image data. Hence, there are
    certain very specific libraries that has been made to do the tasks with ease.
    One of the most commonly used vision processing algorithm is OpenCV. It is widely
    used, and there are multiple functions in this library that are very specific
    to dealing with image data itself. So with a single command, you should be able
    to capture image, and with another command, we would be able to put filters over
    the image. No not the Instagram filters, but the filters that will segregate a
    specific type of object in the image from others.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续前进，我们以非常结构化的方式拥有每个单个像素的数据，但我们究竟要做什么呢？好吧，正如你在前面的章节中学到的，当我们有结构化的数据时，我们可以进行多项操作，就像我们在上一章的列表中做的那样。我们正在处理的数据在某种程度上属于特定领域。也就是说，我们知道我们将接收到的数据将是图像数据。因此，有一些非常特定的库被制作出来以轻松完成这些任务。最常用的视觉处理算法之一是OpenCV。它被广泛使用，并且这个库中有多个非常具体的功能，专门用于处理图像数据本身。所以，通过一个命令，你应该能够捕捉图像，通过另一个命令，我们将能够在图像上应用过滤器。不是Instagram的过滤器，而是将图像中的特定类型对象从其他对象中分离出来的过滤器。
- en: Finally, we would also be able to output the data in the desired image format.
    So, it is quite interesting on what all we can do with OpenCV. But do keep in
    mind that this is an introductory lesson. OpenCV itself can be a topic for an
    entire book, but here, I'm trying to give you all a heads-up regarding the vision
    processing. You would be learning the basic commands and how to use it to make
    out projects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将能够以所需的图像格式输出数据。因此，OpenCV能做什么确实非常有趣。但请记住，这只是一个入门课程。OpenCV本身可以是一个整本书的主题，但在这里，我试图给你们所有人一个关于视觉处理的预览。你们将学习基本命令以及如何使用它来制作项目。
- en: Now it is time to stop talking and start doing stuff. So, let's see what all
    we have to do.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候停止谈论并开始动手了。那么，让我们看看我们都需要做什么。
- en: Preparing Raspberry Pi for vision processing application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为视觉处理应用准备Raspberry Pi
- en: 'The first thing you need to do is to make sure that you have ample time on
    your side and perhaps some popcorn to pass on the time. Because what we are about
    to start can be slightly long. How long, perhaps a few hours. If you have a slow
    internet connection, then you might even be spending an entire day. Also, one
    thing to note is that with time, there are various new updates that might come
    along on both the software and hardware end. This might mean that some of the
    commands might not work or might need some modification. A bit of Google might
    help in that situation. So, don''t get worried if something doesn''t work at the
    first go. Having said this, let''s start by making your Raspberry Pi ready and
    make sure that we have all the prerequisites for the vision processing. First,
    we need to prepare our Raspberry Pi for vision processing application. To start
    it off, ensure that you are always connected to the internet at all times once
    that box is checked, then go ahead and fire up the terminal on your Raspberry
    Pi. Once you are on it, you need to type the following commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要确保你有足够的时间，也许还需要一些爆米花来打发时间。因为我们即将开始的过程可能会稍微长一些，可能需要几个小时。如果你有慢速的互联网连接，你甚至可能需要一整天。还有一点需要注意，随着时间的推移，软件和硬件两端可能会有各种新的更新。这可能会意味着一些命令可能无法工作或者可能需要一些修改。在这种情况下，搜索一下Google可能会有所帮助。所以，如果第一次尝试没有成功，不要担心。说了这么多，让我们开始准备你的Raspberry
    Pi，确保我们为视觉处理准备好了所有先决条件。首先，我们需要为视觉处理应用准备我们的Raspberry Pi。为了开始，确保你始终连接到互联网，一旦这个选项被勾选，然后继续在你的Raspberry
    Pi上打开终端。一旦你打开了终端，你需要输入以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/252614d1-3a6a-4073-a93d-b8e694d3cd3d.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/252614d1-3a6a-4073-a93d-b8e694d3cd3d.png)'
- en: Therefore, the first command downloads the updates for the operating system
    of your Raspberry Pi, and the second line will go ahead and download the upgrades
    for the OS of your Raspberry Pi. Did you get what I am saying? No? Let me tell
    you a bit more detail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一条命令会下载你的Raspberry Pi操作系统的更新，而第二条命令将会继续下载你的Raspberry Pi操作系统的升级。你明白我的意思了吗？不明白？让我再详细解释一下。
- en: Your Raspberry Pi's OS has multiple packages that are used to do different activities.
    Now over the time, these packages get added functionalities, so when you update
    OS, you basically update the functionalities of the packages on your OS. This
    being one thing, sometimes new packages are also added to your Raspberry Pi's
    OS. They can be for various added functionalities. So an upgrade adds the new
    packages on to your operating system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Raspberry Pi操作系统有多个用于执行不同活动的软件包。随着时间的推移，这些软件包会添加新的功能，所以当你更新操作系统时，你实际上是在更新你操作系统上软件包的功能。这是其中之一，有时也会向你的Raspberry
    Pi操作系统添加新的软件包。它们可能是为了各种附加功能。所以升级会在你的操作系统上添加新的软件包。
- en: You must be asking why is all this necessary? Good question. There are multiple
    libraries that we will be using to make our code work. Now, the developer who
    made these would want his libraries to be better than ever and to do that he uses
    the latest packages of the Raspberry Pi. So now when you are trying to use the
    developer's libraries, then there is a good chance that it might need the latest
    packages and updates for it to run. Hence, it's always a good idea to update and
    upgrade your OS every few weeks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么这一切都是必要的？好问题。我们将使用多个库来使我们的代码工作。现在，制作这些库的开发者希望他的库比以往任何时候都要好，为了做到这一点，他使用了Raspberry
    Pi的最新软件包。所以现在当你尝试使用开发者的库时，有很大可能会需要最新的软件包和更新才能运行。因此，每隔几周更新和升级你的操作系统总是一个好主意。
- en: 'Until now, we have only downloaded those updates and upgrades. We haven''t
    really installed them. So to install them, we need to type the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只下载了那些更新和升级。我们实际上并没有安装它们。所以为了安装它们，我们需要输入以下命令：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you do this, you might like to restart your Raspberry Pi so that everything
    is up and running smoothly. To do this, you can go ahead and restart it manually,
    or you can take the pro way by wiring this command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你可能想重启你的Raspberry Pi，以确保一切都能顺畅运行。为此，你可以手动重启它，或者你可以通过以下命令来采取专业的方法：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/08908a0a-c1b1-4293-8909-bb7486fc6b1e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08908a0a-c1b1-4293-8909-bb7486fc6b1e.png)'
- en: 'Perfect, so now our system is up to date. Now we need to install some more
    packages that are specific to image processing. Without these packages, it would
    be very hard to do any vision processing . These individual commands can take
    some time to go through, but just be patient and download it and then I''ll explain
    what all of these are doing.  So without much delay, let''s go ahead and install
    these one by one:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，所以现在我们的系统已经是最新的。现在我们需要安装一些特定于图像处理的包。没有这些包，进行任何视觉处理都会非常困难。这些单独的命令可能需要一些时间来执行，但请耐心等待，下载它们，然后我会解释这些都在做什么。所以，不要耽搁，让我们继续一个接一个地安装这些包：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/e63510b5-c4a5-4060-afef-cc144d586695.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e63510b5-c4a5-4060-afef-cc144d586695.png)'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/9185f990-a822-43fd-8987-f1a9e966bc9d.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9185f990-a822-43fd-8987-f1a9e966bc9d.png)'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/014af506-acb2-48e3-a1e0-7b34b38fe10e.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/014af506-acb2-48e3-a1e0-7b34b38fe10e.png)'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/1ef2c495-1153-4913-8139-6b79006bf0f4.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ef2c495-1153-4913-8139-6b79006bf0f4.png)'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/d8f11a8c-2ba6-48ec-9dfc-c918321b6e52.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8f11a8c-2ba6-48ec-9dfc-c918321b6e52.png)'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/41a9c65d-2cfd-4d97-8617-95cb9893f3a7.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41a9c65d-2cfd-4d97-8617-95cb9893f3a7.png)'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/cac5ce6f-b451-4d6e-b2d6-337cd531c81e.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cac5ce6f-b451-4d6e-b2d6-337cd531c81e.png)'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/365aa3c5-d52f-4132-9ad4-aaad093ce886.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/365aa3c5-d52f-4132-9ad4-aaad093ce886.png)'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/345f6a90-3af1-40a1-ac1f-aa973ca054f2.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/345f6a90-3af1-40a1-ac1f-aa973ca054f2.png)'
- en: 'Once done, your system will be ready with all the prerequisites required by
    the OS to do vision processing. Now, let''s understand what each one of them is
    doing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的系统将准备好所有由操作系统要求的进行视觉处理的前置条件。现在，让我们了解每个工具的作用：
- en: '`sudo apt-get install build-essential git cmake pkg-config`: This line is installing
    all the developer tools that you might need.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo apt-get install build-essential git cmake pkg-config`：这一行正在安装你可能需要的所有开发工具。'
- en: '`sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev` and `sudo
    apt-get install libxvidcore-dev libx264-dev`: In this line, we are installing
    video packages and codecs. This will make sure that the system is ready with I/O
    as the videos that we might be throwing at it later.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev`
    和 `sudo apt-get install libxvidcore-dev libx264-dev`：在这一行中，我们正在安装视频包和编解码器。这将确保系统准备好I/O，以便我们可能稍后向其投递的视频。'
- en: '`sudo apt-get install libjpeg8-dev libtiff5-dev libjasper-dev libpng12-dev`:
    As we installed the packages for videos, we are doing the same for the images
    as well.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo apt-get install libjpeg8-dev libtiff5-dev libjasper-dev libpng12-dev`：正如我们为视频安装了包，我们也为图像做了同样的事情。'
- en: '`sudo apt-get install libgtk2.0-dev`: We are installing a subpackage named
    the `gkt` development library. It is obvious that whenever we are processing some
    images, then we might also like to output it, perhaps in the form of images and
    simple GUI, and this library tells us to do exactly the same.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo apt-get install libgtk2.0-dev`：我们正在安装一个名为`gkt`的开发库子包。很明显，当我们处理一些图像时，我们也可能希望将其输出，可能是以图像和简单GUI的形式，这个库告诉我们如何做到这一点。'
- en: '`sudo apt-get install libatlas-base-dev gfortran`: Vision processing is a CPU-intensive
    task and when we are dealing with something that is not as powerful as a supercomputer,
    we must make sure that we are not wasting any CPU horsepower. To do this, we need
    to optimize the entire process, and this library helps us do that.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo apt-get install libatlas-base-dev gfortran`：视觉处理是一个CPU密集型任务，当我们处理的东西不像超级计算机那么强大时，我们必须确保我们没有浪费任何CPU性能。为了做到这一点，我们需要优化整个过程，而这个库帮助我们做到这一点。'
- en: '`sudo apt-get install python2.7-dev python3-dev`: Now in this line, we are
    installing Python 2.7 and Python 3 header files. This necessary as without them,
    we would not be able to compile our code.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo apt-get install python2.7-dev python3-dev`：现在，在这一行中，我们正在安装Python 2.7和Python
    3头文件。这是必要的，因为没有它们，我们就无法编译我们的代码。'
- en: 'Now, in all the preceding commands, we installed the dependencies of vision
    processing or in other words, the dependencies of OpenCV that we will be using
    to do the vision processing. Now it is time to prepare the environment of the
    Python so that we can run OpenCV. Go ahead, open the terminal, and type the following
    command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在所有前面的命令中，我们已经安装了视觉处理或换句话说，我们将要使用的OpenCV的依赖项。现在，我们需要准备Python的环境，以便我们可以运行OpenCV。继续，打开终端，并输入以下命令：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/7f53a5e0-bff3-41bf-a889-b0e8715f7033.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f53a5e0-bff3-41bf-a889-b0e8715f7033.png)'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](img/9f0b080f-5c13-407b-b29c-b25494192166.png)![](img/9f0b080f-5c13-407b-b29c-b25494192166.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f0b080f-5c13-407b-b29c-b25494192166.png)![](img/9f0b080f-5c13-407b-b29c-b25494192166.png)'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/f95894a9-ea6b-44b0-b633-c116ee95716c.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f95894a9-ea6b-44b0-b633-c116ee95716c.png)'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](img/b731cf0d-6729-43b3-9a2b-12d8c1e02f28.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b731cf0d-6729-43b3-9a2b-12d8c1e02f28.png)'
- en: 'Now, let''s see what we have done:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们做了什么：
- en: '`cd~`: **cd** stands for **change of directory**, and the `~` sign stands for
    the main directory. So basically, we are switching to the main directory and the
    things that will be doing from here on will be done in the main directory itself.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd~`: **cd** 代表 **更改目录**，而 `~` 符号代表主目录。所以基本上，我们正在切换到主目录，并且从现在开始要做的事情将在主目录本身完成。'
- en: '`wget -O opencv.zip https://github.com/Itseez/opencv/archive/3.4.0.zip`: This
    is pretty straightforward; we are downloading the OpenCV files from GitHub.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wget -O opencv.zip https://github.com/Itseez/opencv/archive/3.4.0.zip`: 这非常直接；我们正在从
    GitHub 下载 OpenCV 文件。'
- en: '`unzip opencv.zip`: Once we have downloaded all the files, we need to unzip
    those in order to use it.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unzip opencv.zip`: 一旦我们下载了所有文件，我们需要解压这些文件以便使用。'
- en: '`wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/3.4.0`:
    Now we are downloading `contrib` files. That is, these are added extra functionalities
    that have been developed for the OpenCV over and above the functionalities it
    already has.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/3.4.0`:
    现在我们正在下载 `contrib` 文件。也就是说，这些是针对 OpenCV 开发的额外功能，这些功能是在 OpenCV 已有的功能之上增加的。'
- en: '`unzip opencv_contrib.zip`: Now this is a no-brainier. We are unzipping the
    `contrib` files that we have just downloaded.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unzip opencv_contrib.zip`: 现在这是一个显而易见的事情。我们正在解压我们刚刚下载的 `contrib` 文件。'
- en: 'Perfect! I know it''s taking a long time, and it''s slightly a task. But this
    is something that is undeniably necessary and without this, we would not be able
    to go ahead and do the vision processing on our system. So now that we have done
    all of the preceding tasks, we need to then set up the Python. Let''s go ahead
    and do it, then we will see why this is necessary:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我知道这需要很长时间，这确实是一项任务。但这是不可否认的必要事情，没有它，我们就无法继续在我们的系统上进行视觉处理。所以现在我们已经完成了所有前面的任务，我们需要设置
    Python。让我们继续做，然后我们会看到为什么这是必要的：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](img/e3eda02c-1985-49b3-84fb-355d35e9b060.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3eda02c-1985-49b3-84fb-355d35e9b060.png)'
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/9bfdbd5e-44e9-445d-b734-e1810393f26d.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bfdbd5e-44e9-445d-b734-e1810393f26d.png)'
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/fbc21f6c-b2e9-43ba-a77d-d25f72ff9ab5.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbc21f6c-b2e9-43ba-a77d-d25f72ff9ab5.png)'
- en: 'Now, let''s see what this is all about:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这是关于什么的：
- en: '`wget https://bootstrap.pypa.io/get-pip.py`: Now we are getting the `pip` package.
    The basic work of PIP is to manage the packages over the Python system.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wget https://bootstrap.pypa.io/get-pip.py`: 现在我们正在获取 `pip` 包。PIP 的基本功能是管理
    Python 系统中的包。'
- en: '`sudo python get-pip.py`: Now once we have got the package, it is time to run
    it and to do that we simply need to write the command.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo python get-pip.py`: 现在我们已经获取了包，是时候运行它了，为了做到这一点，我们只需要写下命令。'
- en: '`sudo pip install virtualenv virtualenvwrapper`: This command is really interesting.
    What this is doing is installing something named `virtualenwrapper`. Now, this
    is an extension that lets us use the programs in a virtual environment. Why is
    this necessary? Well, it is a lifesaver when we talk about running various programs,
    which has various prerequisites. So, this helps us keeping all the programs running
    just fine by making a virtual environment where we have all the prerequisites
    already ready.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo pip install virtualenv virtualenvwrapper`: 这个命令非常有趣。这个命令正在安装一个名为 `virtualenvwrapper`
    的东西。现在，这是一个扩展，允许我们在虚拟环境中使用程序。为什么这是必要的？好吧，当我们谈论运行具有各种先决条件的各种程序时，这是一个救命稻草。所以，这通过在已经准备好所有先决条件的虚拟环境中运行所有程序，帮助我们让所有程序运行得很好。'
- en: '`sudo rm -rf ~/.cache/pip`: We are simply using this command to clear the cache.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo rm -rf ~/.cache/pip`: 我们只是使用这个命令来清除缓存。'
- en: 'Now, after we are done with this. We would have to open the `.profile` file.
    To do this, we need to type the `sudo nano ~/.profile` command. This command will
    open the profile and then once it is open, copy following commands at the end
    of the files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们完成这些之后。我们不得不打开 `.profile` 文件。为了做到这一点，我们需要输入 `sudo nano ~/.profile` 命令。这个命令将打开配置文件，然后一旦打开，就在文件的末尾复制以下命令：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/118706c3-a737-4fbb-a010-5b594b212818.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/118706c3-a737-4fbb-a010-5b594b212818.png)'
- en: 'Why did we do this? Basically, the terminal needs to know where the virtual
    environment is, and by doing this, the terminal will get to know it. Now, again,
    fire up the terminal; we have to load a few more things. So, this is what we need
    to do:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要这样做？基本上，终端需要知道虚拟环境在哪里，通过这样做，终端就会知道它。现在，再次启动终端；我们还需要加载一些其他的东西。所以，这就是我们需要做的：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now after you are done with all of these commands, let''s see what they means
    :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你完成了所有这些命令后，让我们看看它们意味着什么：
- en: '`source ~/.profile`: This is to make sure that everything is set up'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source ~/.profile`：这是为了确保一切设置就绪。'
- en: '`mkvirtualenv cv`: This is making a new environment named `cv`, and this is
    where we will be running all of the programs'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkvirtualenv cv`：这是创建一个名为`cv`的新环境，所有程序都将在这里运行。'
- en: '`source ~/.profile`: Now as we have made a new virtual environment, we need
    to again make sure that everything is set up, and to do that, we need to type
    this line again'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source ~/.profile`：现在，因为我们创建了一个新的虚拟环境，我们需要再次确保一切设置就绪，为此，我们需要再次输入这一行。'
- en: '`workon cv`: This command will tell the system that we are working on the virtual
    environment that we have just created by the name of  `cv`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workon cv`：这个命令将告诉系统我们正在使用我们刚刚通过名称`cv`创建的虚拟环境。'
- en: '`pip install numpy`: This is a very important step; `numpy` is a library that
    helps us manage huge multidimensional arrays'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install numpy`：这是一个非常重要的步骤；`numpy`是一个帮助我们管理大型多维数组的库。'
- en: 'After you have performed all the preceding commands, the time has finally come
    to install the OpenCV, and we need to use the following commands:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行了所有前面的命令后，安装OpenCV的时刻终于到来了，我们需要使用以下命令：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'OK, so what did we do here? Let''s see:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么我们在这里做了什么？让我们看看：
- en: The `workon cv` command is simple; we are telling Python that we have to work
    on a virtual environment by the name of `cv`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workon cv`命令很简单；我们告诉Python我们必须在一个名为`cv`的虚拟环境中工作。'
- en: Using the `cd ~/opencv-3.4.0/` command, we are changing the directory and moving
    inside the folder of the installed OpenCV.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cd ~/opencv-3.4.0/`命令，我们更改目录并移动到已安装的OpenCV文件夹中。
- en: In the `mkdir build` command, we are making a new folder named `build`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`mkdir build`命令中，我们创建了一个名为`build`的新文件夹。
- en: In the `cd build` command, again we are using the basic `cd` command. This is
    changing the directory to which we have just made by the name `build`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`cd build`命令中，我们再次使用了基本的`cd`命令。这是将目录更改为我们刚刚通过名称`build`创建的目录。
- en: The next command is `cmake`. What this does is compile whatever it is told to. So,
    in the entire next command, we are installing various settings onto our Python.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个命令是`cmake`。它所做的就是编译它被告诉编译的内容。所以，在接下来的整个命令中，我们正在将各种设置安装到我们的Python中。
- en: 'We have started compiling various settings, and now the next command is fairly
    important. Let''s see what it is:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始编译各种设置，现在下一个命令相当重要。让我们看看它是什么：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, this command tells the Raspberry Pi how many cores it has to do while vision
    processing. Essentially, Raspberry Pi has four cores in total, so by giving a
    command of `-j4`, we are telling the Pi that we would be using all the four cores.
    Obviously, you would be thinking that it is always a good idea to use all the
    horsepower that we have. But that's certainly not the case. As, if we use all
    the cores, then it might not be able to do any other tasks. Not even take commands
    from the user. So, if you want to do some simultaneous task that let's say takes
    the vision processing data and applies it to do something else, then it might
    not be possible as you would have exhausted all the CPU compute power in the processing
    itself. However, for now, it is not the case. Hence, for the sake of time, we
    will be using all the cores.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个命令告诉树莓派在视觉处理时需要使用多少核心。本质上，树莓派总共有四个核心，所以通过输入命令`-j4`，我们告诉Pi我们将使用所有四个核心。显然，你可能会想，总是使用我们所有的马力是个好主意。但那绝对不是事实。因为如果我们使用所有核心，那么它可能无法执行任何其他任务。甚至无法接收用户的命令。所以，如果你想做一些同时任务，比如说将视觉处理数据应用到其他事情上，那么可能就不可能，因为你已经在处理过程中耗尽了所有的CPU计算能力。然而，现在并不是这种情况。因此，为了节省时间，我们将使用所有核心。
- en: 'Now finally, the time has come at last that we install the OpenCV. So let''s
    see how we have to do that:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在终于到了安装OpenCV的时候了。那么让我们看看我们该如何做：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you would have guessed, `sudo make install` is compiling OpenCV, and `sudo
    ldconfig` creates cache and links to the important and recently shared libraries.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`sudo make install`正在编译OpenCV，而`sudo ldconfig`创建缓存并链接到重要的和最近共享的库。
- en: 'OK, so you think we are done. Well no, we need to finish the installation process,
    but there are a few additional steps. This is the last step, so just be patient
    for a little bit longer, and we should be there without any problems. Here are
    the steps that you need to do:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你认为我们已经完成了。不，我们需要完成安装过程，但还有一些额外的步骤。这是最后一步，所以请再耐心一点，我们应该没有问题。以下是你需要执行的步骤：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you have installed all the preceding steps, now OpenCV should be installed
    in this part of the directory. We are using an `ls` command, which is used to
    list the directories in the certain location. Once you are done with this, the
    system will revert back with the output shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经安装了所有前面的步骤，现在OpenCV应该安装在这个目录部分。我们使用`ls`命令，该命令用于列出特定位置的目录。一旦完成，系统将返回以下截图所示的输出：
- en: '![](img/36e18c46-cc00-4982-b78c-2f2d53e9c4fd.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/36e18c46-cc00-4982-b78c-2f2d53e9c4fd.png)'
- en: 'Finally, once this step is done, then we need to verify that everything we
    have done till now has been completed successfully. So, to do that, we simply
    need to run these commands:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦完成这一步，我们需要验证到目前为止我们所做的一切是否都已完成成功。为此，我们只需运行以下命令：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `workon cv ` command will be used every time we need to work on OpenCV,
    so once that command is done, then the command `python` will open the Python library.
    If in any case the Python library is not installed properly, then it will revert
    with some errors, which means that the steps were not successful in which case
    you would have to install the OpenCV again. If everything is fine, then it will
    return the details, as shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们需要在OpenCV上工作时，都会使用`workon cv`命令，所以一旦这个命令执行完毕，然后`python`命令将打开Python库。如果在任何情况下Python库没有正确安装，它将返回一些错误，这意味着步骤没有成功，在这种情况下，您将需要重新安装OpenCV。如果一切正常，它将返回以下截图所示的详细信息：
- en: '![](img/b71ff518-cccc-412c-93d8-129c13c4fb73.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/b71ff518-cccc-412c-93d8-129c13c4fb73.png)'
- en: Wo-hoo! At last, we have completed the installation. Now we are all set and
    ready to do vision processing over Raspberry Pi.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！最后，我们完成了安装。现在我们一切准备就绪，可以开始在树莓派上进行视觉处理。
- en: Image recognition
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像识别
- en: 'Now, to go ahead and start doing vision processing, let''s connect the camera
    to Raspberry Pi. Once you have done that, you need to write the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了继续进行视觉处理，让我们将摄像头连接到树莓派。一旦完成，你需要编写以下代码：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before you actually compile this code, let me tell you what exactly we are
    doing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在你实际编译此代码之前，让我告诉你我们到底在做什么：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding line, we are importing the library `numpy` as `np`, or in
    other words, we have imported the library, and every time we need to call is we
    simply need to write `np`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中，我们导入库`numpy`为`np`，换句话说，我们已经导入了库，每次需要调用时我们只需写`np`：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding line, we are telling Raspberry Pi to capture the video from
    a specific port. Now you must be thinking that how do we know which port it is
    connected to?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中，我们告诉树莓派从特定端口捕获视频。现在你可能想知道我们如何知道它连接到哪个端口？
- en: The thing with ports is that, unlike GPIOs, they are not hardware dependent
    rather they are software allocated. So, if your camera is the first device to
    be connected to the USB port, then it is very likely to be connected to port `0`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关于端口，与GPIO不同，它们不是硬件依赖的，而是软件分配的。所以如果你的摄像头是第一个连接到USB端口的设备，那么它很可能连接到端口`0`。
- en: In this example, a USB camera is the only piece of hardware that we are adding;
    hence, we can be very sure that it will be at port `0` only.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只添加了一个USB摄像头作为硬件；因此，我们可以非常确信它只会在端口`0`。
- en: 'Now the command is not only for port selection. The primary work for it is
    to capture the video from the camera. Now, every time we need to call it by our
    given name `cap` rather than the entire function itself:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在命令不仅用于端口选择。它的主要工作是捕获摄像头视频。现在，每次我们需要通过我们给定的名称`cap`而不是整个函数本身来调用它：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding line, we are using the function `cv.VideoCapture(0)` by the
    name of `cap`. We are also using a function named `read()`. Now, what this will
    do is that it will return two things. First, it will return a Boolean value, or
    in another words, a true or a false. That is, whether the image has been captured
    successfully or not. The second reading, which we are more concerned with, is
    entire  frame read from the image. This whole data would be stored in form of
    an array:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行，我们使用名为 `cap` 的函数 `cv.VideoCapture(0)`。我们还使用了一个名为 `read()` 的函数。现在，这将返回两件事。首先，它将返回一个布尔值，或者说，是或否。也就是说，图像是否已经成功捕获。第二个读取，我们更关心的是，是从图像中读取的整个帧。所有这些数据将以数组的形式存储：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this line, we are using the library `cv2` and a function of the library
    named `imshow()`. What this does is that it shows the image that has been captured
    by the camera. Now going ahead, we have two arguments that are being passed, that
    is, `"Frame"` and `image`. Frame is the name of the window that would show us
    the captured image. Further to this, we have the second argument `image`. Now
    as we remember, we have stored the image in the variable named `image`. So, it
    will directly show what we have already stored in the previous line:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们使用库 `cv2` 和该库的一个名为 `imshow()` 的函数。这样做的作用是显示由相机捕获的图像。现在继续前进，我们有两个参数正在传递，那就是，“帧”和
    `image`。帧是显示捕获图像的窗口的名称。进一步来说，我们有第二个参数 `image`。现在，正如我们记得的，我们已经将图像存储在名为 `image`
    的变量中。所以，它将直接显示我们在上一行中已经存储的内容：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this line, we are doing something amazing. The `cvtColour()` function is
    a converter. What does it convert? As we know, the image is made of an array of
    two-dimensional pixels. What this function does is convert the values that our
    camera gives into the desired value of the user.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们正在做一件令人惊叹的事情。`cvtColour()` 函数是一个转换器。它转换什么？众所周知，图像是由二维像素数组组成的。这个函数所做的就是将我们的相机给出的值转换成用户期望的值。
- en: Let me explain this in a bit more detail. The camera that we are using gives
    us RGB image. So whatever we can see is a mix of carried brightness of these three
    colors. Now for our detection, we would like to convert it into hue, saturation,
    and value. Why are we doing that you may as, first it makes the task pretty easy
    for us. So to understand this, let's see what this hue, saturation, and value
    is.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我更详细地解释一下。我们使用的相机给我们提供 RGB 图像。所以我们可以看到的是三种颜色的亮度混合。现在，为了我们的检测，我们希望将其转换为色调、饱和度和亮度。你可能会问，为什么我们要这样做，首先，这使我们的任务变得非常简单。所以为了理解这一点，让我们看看色调、饱和度和亮度是什么。
- en: 'Hue basically represents the color we are talking about. Every hue value represents
    a specific color, and the saturation is the color intensity. So the more the saturation,
    the deeper it is, and the lower the saturation, the more faint the color is. Finally,
    value—this term can be confusing; this basically means how much black is there
    in the images. So let me give you a rough example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 色调基本上代表我们正在谈论的颜色。每个色调值代表一种特定的颜色，饱和度是颜色的强度。所以饱和度越高，颜色越深，饱和度越低，颜色越淡。最后，亮度——这个术语可能会让人困惑；这基本上意味着图像中有多少黑色。所以让我给你一个粗略的例子：
- en: '![](img/375231a6-4584-47e8-bc92-0012f550d7a9.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/375231a6-4584-47e8-bc92-0012f550d7a9.png)'
- en: 'Now the first image shows you the hue: `100`, saturation: `100`, and value: `100`.
    Hence, black is zero, the color is green, and saturation is `100`%. In the subsequent
    picture, you can see the color has faded when the saturation is kept on a lower
    percentage. Finally, when value is reduced in the next image, then the color gets
    really dark.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第一张图像显示了色调：`100`，饱和度：`100`，和亮度：`100`。因此，黑色是零，颜色是绿色，饱和度是 `100`%。在随后的图片中，你可以看到当饱和度保持在较低百分比时，颜色已经变淡。最后，在下一张图像中，当亮度降低时，颜色变得非常暗。
- en: So now coming back to the point, why hue saturation value? So now to detect
    any color, we simply need one unit instead of three different unit forming that
    color hence making the job simpler. There are various other reasons to do so as
    well. But at this time, it is not a concern for us.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在回到要点，为什么要使用色调、饱和度和亮度？现在为了检测任何颜色，我们只需要一个单位，而不是形成该颜色的三个不同单位，这使得工作变得更简单。还有其他各种原因要做这件事，但在这个时候，这并不是我们关心的。
- en: 'Now moving forward, we have passed on two arguments—`image`, which is where
    the converting algorithm will take the raw data from, second is `cv.Colour_BGR2HSV`,
    which basically tells us the algorithm to use during the conversion. So as we
    have already discussed, we have to convert the RGB values to **hue saturation
    values** (**HSV**). Finally, these values will be returned to a variable named
    `hsv`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续前进，我们已经传递了两个参数——`image`，这是转换算法将从其中获取原始数据的地方，第二个是`cv.Colour_BGR2HSV`，它基本上告诉我们转换过程中要使用的算法。所以正如我们之前讨论的，我们必须将RGB值转换为**色调饱和度值**（**HSV**）。最后，这些值将返回到名为`hsv`的变量中：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this line, we are giving the upper and lower range values, which needs to
    be detected. As you can see, we are detecting a green color; hence, we would be
    providing the upper and lower values for both the ends. If you want to change
    the color that you want to detect, then you simply need to change this value and
    the job will be done:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们正在提供需要检测的上限和下限值。如您所见，我们正在检测绿色；因此，我们将为两端提供上限和下限值。如果您想更改要检测的颜色，那么您只需更改此值，工作就会完成：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we are segregating the objects that are falling in this color range and
    giving the value to an array. This is done by a section function named `inRange()`.
    So, there are three arguments that we need to pass. First, which image does it
    need to work on, what is the lower range value that it needs to detect, and the
    upper range value that we have provided as `hsv`, `lowerGreen`, `upperGreen`.
    The result of this would be an array that would have the value of the image that
    has all color to be blacked out and only the color that lies in the specific color
    range to be shown in a plain white color:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在将落在该颜色范围内的对象分离出来，并将值赋予一个数组。这是通过一个名为`inRange()`的函数部分完成的。因此，我们需要传递三个参数。首先，它需要处理哪张图像，它需要检测的下限值是什么，以及我们提供的上限值`hsv`、`lowerGreen`、`upperGreen`。这个结果将是一个数组，它将具有所有颜色变为黑色的值，而特定颜色范围内的颜色将以纯白色显示：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`bitwise_and` is a function of `cv2` library; what it does is simply logical
    and of the two values of the array. The arguments that we are passing are `image`
    and the image with `mask`, or in other words, we are passing two images—one being
    the raw and the other being the `mask`. With this function, we are ending those
    two images. The result of this would an image that has a black background all
    around and the object that lies in the specific color range will be shown in a
    proper color image:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitwise_and`是`cv2`库中的一个函数；它所做的只是对数组中的两个值进行逻辑与操作。我们传递的参数是`image`和带有`mask`的图像，或者换句话说，我们传递了两个图像——一个是原始图像，另一个是`mask`。使用这个函数，我们结束了这两张图像。这个结果将是一个背景全黑的图像，而位于特定颜色范围内的对象将以适当的颜色显示在一张彩色图像中：'
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have previously used a function named `cv2.inRange`, and what it did was
    to filter out the specific color ranges that we had defined. Now, that function
    gave us a new array by the name of `mask`. What it had is an array that has all
    the value as null, except for those who fall into the specific color range. The
    image in the range would be the only one to be shown here. This would result in
    an image that is black all around except for the points wherein the color is in
    the specified range resulting in a white image. In our program, we are using `cv2.inRange`
    and storing the value into a variable named `mask`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用了一个名为`cv2.inRange`的函数，它所做的就是过滤掉我们定义的特定颜色范围。现在，这个函数通过名为`mask`的新数组给我们。它有一个数组，除了那些落在特定颜色范围内的值之外，所有值都是null。范围内的图像将是这里唯一要显示的图像。这将导致一个周围全黑的图像，除了颜色在指定范围内，结果是一个白色图像。在我们的程序中，我们使用`cv2.inRange`并将值存储在一个名为`mask`的变量中。
- en: 'The `cv2.imshow()` function is something that we used before as well. This
    simply shows the resultant image of the array. Hence, we have given the command `cv2.imshow(''mask'',mask)`;
    hence, it would open a window by the name of `''mask''`, and thereafter in that
    window, it would show the resulting image stored in the `mask` variable:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv2.imshow()`函数是我们之前也使用过的一个函数。这个函数简单地显示了数组的最终图像。因此，我们给出了`cv2.imshow(''mask'',mask)`的命令；因此，它将打开一个名为`''mask''`的窗口，然后在该窗口中，它将显示存储在`mask`变量中的结果图像：'
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We are doing a similar thing here. In the previous lines, we have used the
    function named `cv2.bitwise_and()`. This was used to do the logical and of two
    image arrays, that is, `image` and `mask`, the result of which was `res`; hence,
    it would show us the image corresponding to it. Now that we have done the logical
    part of `image` and `mask`, the output will be an image that would be black all
    around, but the portion falling into our chosen category to be shown in their
    original color:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是类似的事情。在上面的行中，我们使用了名为 `cv2.bitwise_and()` 的函数。这个函数用于执行两个图像数组（即 `image`
    和 `mask`）的逻辑与操作，其结果是 `res`；因此，它会显示与之对应的图像。现在我们已经完成了 `image` 和 `mask` 的逻辑部分，输出将是一个周围都是黑色的图像，但属于我们选择的类别的那部分将以原始颜色显示：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now this is interesting. The `cv2.waitKey()` function gives us the value of
    the key pressed. But the problem is that it returns a 32-bit integer value. However,
    when we talk about ASCII, it returns only 8 bit of data. Hence, we would have
    to only look for this 8 bits out of the 32-bit integer value returned by the `waitKey()`
    function. Now to do that, we are doing a logical `and` of the value received by
    the `waitKey()` and a hexadecimal number `0xFF` what this hexadecimal translates
    to is `11111111` in decimal. So when we add the 32-bit int to the hexadecimal
    number, we would only be left with the last 8-bit value, which is also the only relevant
    part for us. Hence, the value of key would a 8-bit ASCII value:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣。`cv2.waitKey()` 函数给出了按下的键的值。但是问题在于它返回一个32位整数值。然而，当我们谈论ASCII时，它只返回8位数据。因此，我们只需要从`waitKey()`函数返回的32位整数值中查找这8位。现在为了做到这一点，我们正在对`waitKey()`接收到的值和十六进制数`0xFF`进行逻辑与操作。这个十六进制数在十进制中是`11111111`。所以当我们把32位整数加到十六进制数上时，我们只剩下最后8位值，这也是我们唯一相关的部分。因此，键的值将是一个8位的ASCII值：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we are taking a simple `if` statement and comparing the value of key to `ord(''q'')`.
    What the `ord` function does is that it takes in the argument and converts it
    into the ASCII value. So, in this function, if *q* key is pressed, then the loop
    would break and the program would come out of it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用一个简单的`if`语句将键的值与`ord('q')`进行比较。`ord`函数的作用是接收参数并将其转换为ASCII值。所以，在这个函数中，如果按下*q*键，那么循环就会中断，程序就会退出：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is a very simple command. It will close all the windows that we have opened
    using `cv2.imshow()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的命令。它将关闭我们使用`cv2.imshow()`打开的所有窗口。
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using this function, we are releasing the camera. Hence, making this resource
    free and ready to be used by any other program.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们正在释放相机。因此，使这个资源空闲并准备好被其他程序使用。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to compute image data that we got from coupling
    the image to Raspberry Pi. In the next chapter, you will learn how to make a guard
    robot that can perform facial recognition.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何计算从将图像与树莓派耦合中获取的图像数据。在下一章中，你将学习如何制作一个可以进行面部识别的守护机器人。
