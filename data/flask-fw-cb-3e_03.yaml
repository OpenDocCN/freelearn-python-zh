- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Data Modeling in Flask
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask中的数据建模
- en: This chapter covers one of the most important aspects of any application, which
    is the interaction with the database systems. In this chapter, you will see how
    Flask can connect to database systems, define models, and query the databases
    for the retrieval and feeding of data. Flask has been designed to be flexible
    enough to support any database. The simplest way would be to use the direct `SQLite3`
    package, which is a *DB-API 2.0* interface and does not give an actual **object-relational
    mapping** (**ORM**). Here, we need to write SQL queries to talk with the database.
    This approach is not recommended for large projects, as it can eventually become
    a nightmare to maintain the application. Also, with this approach, the models
    are virtually non-existent and everything happens in the view functions, and it
    is not a good practice to write database queries in your view functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了任何应用程序最重要的方面之一，即与数据库系统的交互。在本章中，您将了解Flask如何连接到数据库系统，定义模型，以及查询数据库以检索和传输数据。Flask被设计得足够灵活，以支持任何数据库。最简单的方法是使用直接的`SQLite3`包，这是一个*DB-API
    2.0*接口，并不提供实际的**对象关系映射**（**ORM**）。在这里，我们需要编写SQL查询来与数据库通信。这种方法不推荐用于大型项目，因为它最终可能成为维护应用程序的噩梦。此外，使用这种方法，模型几乎不存在，所有操作都在视图函数中完成，将数据库查询写入视图函数不是一种好的做法。
- en: In this chapter, we will talk about creating an ORM layer for our Flask applications
    with SQLAlchemy for relational database systems, which is recommended and widely
    used for applications of any size. Also, we will have a glance over how to write
    a Flask app with a NoSQL database system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何使用SQLAlchemy为我们的Flask应用程序创建ORM层，这对于任何大小的应用程序都是推荐和广泛使用的。此外，我们还将简要了解如何使用NoSQL数据库系统编写Flask应用程序。
- en: Information
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: ORM implies how our application’s data models store and deal with data at a
    conceptual level. A powerful ORM makes the designing and querying of business
    logic easy and streamlined.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ORM表示我们的应用程序数据模型在概念层面上如何存储和处理数据。一个强大的ORM使得设计和查询业务逻辑变得简单且流畅。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Creating an SQLAlchemy DB instance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个SQLAlchemy数据库实例
- en: Creating a basic product model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的产品模型
- en: Creating a relational category model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建关系型类别模型
- en: Migrating databases using Alembic and Flask-Migrate
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Alembic和Flask-Migrate迁移数据库
- en: Indexing model data with Redis
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis索引模型数据
- en: Opting for the NoSQL way with MongoDB
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择MongoDB的NoSQL方式
- en: Creating an SQLAlchemy DB instance
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个SQLAlchemy数据库实例
- en: SQLAlchemy is a Python SQL toolkit and provides ORM, which combines the flexibility
    and power of SQL with the feel of Python’s object-oriented nature. In this recipe,
    we will understand how to create an SQLAlchemy database instance that can be used
    to perform any database operation that shall be covered in future recipes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy是一个Python SQL工具包，它提供了ORM，它结合了SQL的灵活性和强大功能以及Python面向对象的特性。在本例中，我们将了解如何创建一个SQLAlchemy数据库实例，该实例可用于执行未来菜谱中将要涵盖的任何数据库操作。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Flask-SQLAlchemy is the extension that provides the SQLAlchemy interface for
    Flask. This extension can simply be installed by using `pip` as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy是提供Flask的SQLAlchemy接口的扩展。此扩展可以通过以下方式简单地使用`pip`安装：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing to keep in mind with Flask-SQLAlchemy is the application configuration
    parameter, which tells SQLAlchemy about the location of the database to be used:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Flask-SQLAlchemy时，首先要记住的是应用程序配置参数，它告诉SQLAlchemy要使用数据库的位置：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`SQLALCHEMY_DATABASE_URI` is a combination of the database protocol, any authentication
    needed, and also the name of the database. In the case of SQLite, this would look
    something like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLALCHEMY_DATABASE_URI`是数据库协议、所需的任何身份验证以及数据库名称的组合。在SQLite的情况下，它可能看起来如下所示：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the case of PostgreSQL, it would look like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL的情况下，它看起来如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This extension then provides a class named `Model`, which helps define models
    for our application. Read more about database URLs at [https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls](https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展提供了一个名为`Model`的类，它帮助我们为应用程序定义模型。有关数据库URL的更多信息，请参阅[https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls](https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls)。
- en: Tip
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The SQLite database URI is OS-specific, meaning the URI would be different for
    Unix/macOS/Linux and Windows. Please refer to the documentation at [https://docs.sqlalchemy.org/en/14/core/engines.html#sqlite](https://docs.sqlalchemy.org/en/14/core/engines.html#sqlite)
    for more details.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库URI是操作系统特定的，这意味着URI对于Unix/macOS/Linux和Windows会有所不同。请参阅[https://docs.sqlalchemy.org/en/14/core/engines.html#sqlite](https://docs.sqlalchemy.org/en/14/core/engines.html#sqlite)以获取更多详细信息。
- en: Information
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: For all database systems other than SQLite, separate libraries are needed. For
    example, for using PostgreSQL, you need `psycopg2`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQLite以外的所有数据库系统，都需要单独的库。例如，要使用PostgreSQL，你需要`psycopg2`。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s create a small application in this recipe to understand the basic database
    connection with Flask. We will build over this application in the next few recipes.
    Here, we will just see how to create a `db` instance and validate its existence.
    The file’s structure would look like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本食谱中创建一个小型应用程序，以了解Flask的基本数据库连接。我们将在接下来的几个食谱中构建这个应用程序。在这里，我们只需看看如何创建一个`db`实例并验证其存在。文件的结构看起来如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, we start with `flask_app/run.py`. This is the usual `run` file that
    we have read about previously in this book in multiple recipes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`flask_app/run.py`开始。这是我们在这本书的多个食谱中之前读到的常规`run`文件：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we configure our application configuration file, `flask_app/my_app/__init__.py`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们配置我们的应用程序配置文件，`flask_app/my_app/__init__.py`:'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we first configure our application to point `SQLALCHEMY_DATABASE_URI`
    to a specific location. Then, we create an object of `SQLAlchemy` with the name
    `db`. As the name suggests, this is the object that will handle all our ORM-related
    activities. As mentioned earlier, this object has a class named `Model`, which
    provides the base for creating models in Flask. Any class can just subclass or
    inherit the `Model` class to create models, which will act as database tables.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先配置我们的应用程序，将`SQLALCHEMY_DATABASE_URI`指向一个特定位置。然后，我们创建一个名为`db`的`SQLAlchemy`对象。正如其名所示，这个对象将处理我们所有的ORM相关活动。如前所述，这个对象有一个名为`Model`的类，它为Flask中的模型创建提供了基础。任何类都可以通过继承`Model`类来创建模型，这些模型将作为数据库表。
- en: Now, if we open the `http://127.0.0.1:5000` URL in a browser, we will see nothing.
    This is because we have just configured the database connection for this application
    and there is nothing to be seen on the browser. However, you can always head to
    the location specified in `app.config` for the database location to see the newly
    created `test.db` file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在一个浏览器中打开`http://127.0.0.1:5000` URL，我们将什么也看不到。这是因为我们刚刚为这个应用程序配置了数据库连接，浏览器上没有东西可以显示。然而，你总是可以前往`app.config`中指定的数据库位置，以查看新创建的`test.db`文件。
- en: There’s more…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Sometimes, you may want a single SQLAlchemy `db` instance to be used across
    multiple applications, or to create an application dynamically. In such cases,
    it is not preferable to bind the `db` instance to a single application. Here,
    you will have to work with the application context to achieve the desired outcome.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望单个SQLAlchemy `db`实例在多个应用程序中使用，或者动态创建应用程序。在这种情况下，将`db`实例绑定到单个应用程序不是首选的。在这里，你必须与应用程序上下文一起工作以实现预期的结果。
- en: 'In this case, register the application with SQLAlchemy differently, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，注册应用程序与SQLAlchemy的方式如下：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The preceding approach can be taken up while initializing the app with any Flask
    extension and is very common when dealing with real-life applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化应用程序时，可以使用任何Flask扩展采取这种方法，这在处理实际应用程序时非常常见。
- en: Now, all the operations that were earlier possible globally with the `db` instance
    will require a Flask application context at all times.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有之前通过`db`实例在全局范围内可能进行的操作都需要始终在Flask应用程序上下文中进行。
- en: 'The Flask application context is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Flask应用程序上下文如下：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or, you can use context manager, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用上下文管理器，如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next couple of recipes will extend the current application to make a complete
    application, which will help us to understand the ORM layer better.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个食谱将扩展当前应用程序以使其成为一个完整的应用程序，这将帮助我们更好地理解ORM层。
- en: Creating a basic product model
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的产品模型
- en: In this recipe, we will create an application that will help us to store products
    to be displayed on the catalog section of a website. It should be possible to
    add products to the catalog and then delete them as and when required. As you
    saw in the last chapter, this is possible to do using non-persistent storage as
    well. Here, however, we will store data in a database to have persistent storage.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个应用程序，帮助我们存储要在网站目录部分显示的产品。应该能够添加产品到目录，并在需要时删除它们。正如你在上一章中看到的，这也可以使用非持久存储来完成。然而，在这里，我们将数据存储在数据库中以实现持久存储。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The new directory layout would appear as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 新的目录布局如下所示：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First of all, start by modifying the application configuration file, `flask_catalog/my_app/__init__.py`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从修改应用程序配置文件`flask_catalog/my_app/__init__.py`开始：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last statement in the file is `db.create_all()`, which tells the application
    to create all the tables in the database specified. So, as soon as the application
    runs, all the tables will be created if they are not already there. Since you
    are not in an application request at this point, create a context manually using
    `with app.app_context():`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的最后一个语句是`db.create_all()`，它告诉应用程序创建指定数据库中的所有表。因此，一旦应用程序运行，如果表中还没有数据，所有表都将被创建。由于你现在不在应用程序请求中，请使用`with
    app.app_context():`手动创建上下文。
- en: 'Now is the time to create models that are placed in `flask_catalog/my_app/catalog/models.py`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建位于`flask_catalog/my_app/catalog/models.py`中的模型了：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this file, we have created a model named `Product`, which has three fields,
    namely `id`, `name`, and `price`. `id` is a self-generated field in the database,
    which will store the ID of the record and is the primary key. `name` is a field
    of the `string` type, and `price` is a field of the `float` type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们创建了一个名为`Product`的模型，它有三个字段，即`id`、`name`和`price`。`id`是数据库中自动生成的字段，它将存储记录的ID，是主键。`name`是`string`类型的字段，而`price`是`float`类型的字段。
- en: Now, add a new file for views, which is `lask_catalog/my_app/catalog/views.py`.
    In this file, we have multiple view methods, which control how we deal with the
    product model and the web application in general.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为视图添加一个新文件，该文件位于`lask_catalog/my_app/catalog/views.py`。在这个文件中，我们有多个视图方法，它们控制我们如何处理产品模型和整个Web应用程序。
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding method handles how the home page or the application landing page
    looks or responds to users. You would most probably want to use a template for
    rendering this in your applications. We will cover this in the next chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法处理主页或应用程序着陆页的外观或对用户的响应。你可能会想在你的应用程序中使用模板来渲染它。我们将在下一章中介绍。
- en: 'Have a look at the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding method controls the output to be shown when a user looks for a
    specific product using its ID. We filter for the product using the ID and then
    return its information if a product is found, or else abort with a `404` error.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法控制当用户使用其ID查找特定产品时显示的输出。我们使用ID过滤产品，如果找到产品，则返回其信息，否则以`404`错误终止。
- en: 'Consider the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding method returns a list of all products in the database in JSON
    format. If no product is found, it simply returns an empty JSON: `{}`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法以JSON格式返回数据库中所有产品的列表。如果没有找到产品，它将简单地返回一个空的JSON：`{}`。
- en: 'Consider the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding method controls the creation of a product in the database. We
    first get the information from the `request` object and then create a `Product`
    instance from this information.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法控制数据库中产品的创建。我们首先从`request`对象中获取信息，然后根据这些信息创建一个`Product`实例。
- en: Then, we add this `Product` instance to the database session and finally, use
    `commit` to save the record to the database.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这个`Product`实例添加到数据库会话中，最后使用`commit`将记录保存到数据库中。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the beginning, the database is empty and has no products. This can be confirmed
    by opening `http://127.0.0.1:5000/products` in a browser. This would result in
    an empty JSON response, or `{}`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，数据库是空的，没有产品。这可以通过在浏览器中打开`http://127.0.0.1:5000/products`来确认。这将导致一个空的JSON响应，或`{}`。
- en: 'Now, first, we would want to create a product. For this, we need to send a
    `POST` request, which can easily be sent from the Python prompt using the `requests`
    library:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先，我们想要创建一个产品。为此，我们需要发送一个`POST`请求，这可以通过使用`requests`库从Python提示符轻松发送：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To confirm whether the product is now in the database, we can again open `http://127.0.0.1:5000/products`
    in the browser. This time, it will show a JSON dump of the product details, which
    will look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认产品是否现在在数据库中，我们可以在浏览器中再次打开 `http://127.0.0.1:5000/products`。这次，它将显示产品详情的
    JSON 输出，看起来像这样：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a relational category model
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个关系型分类模型
- en: In our previous recipe, we created a simple product model, which had a couple
    of fields. In practice, however, applications are much more complex and have various
    relationships between their tables. These relationships can be one-to-one, one-to-many,
    many-to-one, or many-to-many. In this recipe, we will try to understand some of
    these relationships with the help of an example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的菜谱中，我们创建了一个简单的产品模型，它有几个字段。然而，在实践中，应用程序要复杂得多，并且它们之间的表之间存在各种关系。这些关系可以是一对一、一对多、多对一或多对多。在这个菜谱中，我们将通过一个例子来尝试理解这些关系之一。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let’s say we want to have product categories where each category can have multiple
    products, but each product should have only one category. Let’s do this by modifying
    some files from the application in the last recipe. We will make modifications
    to both models and views. In models, we will add a `Category` model, and, in views,
    we will add new methods to handle category-related calls and also modify the existing
    methods to accommodate the newly added feature.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要有产品分类，其中每个分类可以拥有多个产品，但每个产品只能有一个分类。让我们通过修改上一道菜谱中的应用程序中的某些文件来实现这一点。我们将对模型和视图进行修改。在模型中，我们将添加一个
    `Category` 模型，在视图中，我们将添加处理分类相关调用的新方法，并修改现有方法以适应新添加的功能。
- en: 'First, modify the `models.py` file to add the `Category` model and make some
    modifications to the `Product` model:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改 `models.py` 文件以添加 `Category` 模型并对 `Product` 模型进行一些修改：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding `Product` model, check the newly added fields for `category_id`
    and `category`. `category_id` is the foreign key to the `Category` model, and
    `category` represents the relationship table. As evident from the definitions
    themselves, one of them is a relationship, and the other uses this relationship
    to store the foreign key value in the database. This is a simple many-to-one relationship
    from `product` to `category`. Also, notice the `backref` argument in the `category`
    field; this argument allows us to access products from the `Category` model by
    writing something as simple as `category.products` in our views. This acts like
    a one-to-many relationship from the other end.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 `Product` 模型中，检查新添加的 `category_id` 和 `category` 字段。`category_id` 是到 `Category`
    模型的外键，而 `category` 代表关系表。从定义本身可以看出，其中一个是关系，另一个使用这个关系在数据库中存储外键值。这是一个从 `product`
    到 `category` 的简单多对一关系。注意 `category` 字段中的 `backref` 参数；这个参数允许我们通过在视图中写入 `category.products`
    这样简单的语句来从 `Category` 模型访问产品。这就像从另一端的一个一对多关系。
- en: Important information
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Just adding the field to the model would not get reflected in the database right
    away. You might need to drop the whole database and then run the application again
    or run migrations, which shall be covered in the next recipe, *Migrating databases
    using Alembic* *and Flask-Migrate*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在模型中添加字段并不会立即反映到数据库中。你可能需要删除整个数据库然后重新运行应用程序，或者运行迁移，这将在下一道菜谱中介绍，即 *使用 Alembic
    和 Flask-Migrate 迁移数据库*。
- en: For SQLite, you can simply delete the database file that was created while initializing
    the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQLite，你可以简单地删除在初始化应用程序时创建的数据库文件。
- en: 'Create a `Category` model that has just one field called `name`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个只有一个名为 `name` 字段的 `Category` 模型：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, modify `views.py` to accommodate the change in the models. Make the first
    change in the `products()` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改 `views.py` 以适应模型中的更改。首先在 `products()` 方法中进行第一次更改：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have just one change where we send the `category` name in the product’s
    JSON data, which is being generated to be returned as a response when a request
    is made to the preceding endpoint.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只做了一项修改，即在产品的 JSON 数据中发送 `category` 名称，该数据在向先前的端点发出请求时生成并作为响应返回。
- en: 'Change the `create_product()` method to look for the category before creating
    the product:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `create_product()` 方法，在创建产品之前先查找分类：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we will first search for an existing category with the category name in
    the request. If an existing category is found, we will use the same in the product
    creation; otherwise, we will create a new category.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将在请求中的类别名称中搜索现有的类别。如果找到现有类别，我们将使用它在产品创建中；如果没有找到，我们将创建一个新的类别。
- en: 'Create a new method, `create_category()`, to handle the creation of a category:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的方法，`create_category()`，用于处理类别的创建：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code is a relatively simple method for creating a category using
    the name provided in the request.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个相对简单的方法，用于使用请求中提供的名称创建一个类别。
- en: 'Create a new method, `categories()`, to handle the listing of all categories
    and corresponding products:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的方法，`categories()`，用于处理所有类别及其对应产品的列表：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding method does a bit of tricky stuff. Here, we fetched all the categories
    from the database and then, for each category, we fetched all the products and
    then returned all the data as a JSON dump.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法做了一些稍微复杂的事情。在这里，我们从数据库中检索了所有类别，然后对每个类别，我们检索了所有产品，然后以 JSON 格式返回所有数据。
- en: How it works…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe works very similarly to the preceding recipe, *Creating a basic*
    *product model*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的工作原理与上一个食谱，*创建基本* *产品模型*，非常相似。
- en: 'To create a product with a category, make a `POST` request to the `/``product-create`
    endpoint:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有类别的产品，向 `/product-create` 端点发送一个 `POST` 请求：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To view how the data now looks when fetched from the database, open `http://127.0.0.1:5000/categories`
    in your browser:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看从数据库中检索到的数据现在看起来如何，请在您的浏览器中打开 `http://127.0.0.1:5000/categories`：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Creating a basic product model* recipe to understand the context
    of this recipe and how this recipe works for a browser, given that its workings
    are very similar to the previous one.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 参考创建基本产品模型的食谱，以了解本食谱的上下文以及本食谱如何为浏览器工作，因为其工作原理与上一个食谱非常相似。
- en: Migrating databases using Alembic and Flask-Migrate
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Alembic 和 Flask-Migrate 迁移数据库
- en: Updating database schema is an important use case for all applications, as it
    involves adding or removing tables and/or columns or changing column types. One
    way is to drop the database and then create a new one using `db.drop_all()` and
    `db.create_all()`. However, this approach cannot be followed for applications
    in production or even in staging. We would like to migrate our database to match
    the newly updated model with all the data intact.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更新数据库模式是所有应用程序的重要用例，因为它涉及添加或删除表和/或列，或更改列类型。一种方法是通过 `db.drop_all()` 和 `db.create_all()`
    删除数据库，然后创建一个新的数据库。然而，这种方法不能用于生产环境或预发布环境。我们希望将数据库迁移到与最新更新的模型匹配，同时保留所有数据完整。
- en: For this, we have **Alembic**, a Python-based tool for managing database migrations,
    which uses SQLAlchemy as the underlying engine. Alembic provides automatic migrations
    to a great extent with some limitations (of course, we cannot expect any tool
    to be seamless). As the icing on the cake, we have a Flask extension called **Flask-Migrate**,
    which eases the process of migrations even more. In this recipe, we will cover
    the basics of database migration techniques using Alembic and Flask-Migrate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此，我们拥有 **Alembic**，这是一个基于 Python 的数据库迁移管理工具，它使用 SQLAlchemy 作为底层引擎。Alembic
    在很大程度上提供了自动迁移，但也存在一些限制（当然，我们不可能期望任何工具都能无缝运行）。作为锦上添花的部分，我们还有一个名为 **Flask-Migrate**
    的 Flask 扩展，它进一步简化了迁移过程。在本食谱中，我们将介绍使用 Alembic 和 Flask-Migrate 进行数据库迁移的基本技术。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First of all, run the following command to install `Flask-Migrate`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行以下命令来安装 `Flask-Migrate`：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will also install Alembic, among a number of other dependencies.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将安装 Alembic 以及其他许多依赖项。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To enable migrations, we need to modify our app definition a bit. Let’s understand
    how such a config appears if we modify the same for our `catalog` application:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用迁移，我们需要稍微修改我们的应用程序定义。让我们了解如果我们为我们的 `catalog` 应用程序进行相同的修改，这样的配置将如何出现：
- en: 'The following lines of code show how `my_app/__init__.py` appears:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行显示了 `my_app/__init__.py` 的外观：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we pass `--help` to the `flask` command while running it as a script, the
    terminal will show all the available options, as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在以脚本方式运行 `flask` 命令时传递 `--help`，终端将显示所有可用选项，如下面的截图所示：
- en: "![Figure 3.1 – Database migration\uFEFF option](img/B19111_03_1.jpg)"
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 数据库迁移选项](img/B19111_03_1.jpg)'
- en: Figure 3.1 – Database migration option
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 数据库迁移选项
- en: 'To initialize migrations, run the `init` command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化迁移，运行 `init` 命令：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Important information
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: 'For the migration commands to work, the Flask application should be locatable;
    otherwise, you will get the following error:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使迁移命令生效，Flask应用程序应该是可定位的；否则，您将收到以下错误：
- en: '`Error: Could not locate a Flask application. Use the ''flask --app'' option,
    ''FLASK_APP'' environment variable, or a ''wsgi.py'' or ''app.py'' file in the`
    `current directory.`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`错误：无法定位Flask应用程序。使用''flask --app''选项，''FLASK_APP''环境变量，或在当前目录中的''wsgi.py''或''app.py''文件。`'
- en: 'In our case, simply export the Flask application to the environment variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，只需将Flask应用程序导出到环境变量中：
- en: '`export FLASK_APP="my_app.__init__.py"`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`export FLASK_APP="my_app.__init__.py"`'
- en: 'Or, simply with the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，简单地使用以下命令：
- en: '`export FLASK_APP=my_app`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`export FLASK_APP=my_app`'
- en: 'Once changes are made to the models, call the `migrate` command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对模型进行了更改，请调用`migrate`命令：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To make the changes reflect on the database, call the `upgrade` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要使更改反映在数据库中，请调用`upgrade`命令：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now, let’s say we modify the model of our `product` table to add a new field
    called
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们修改了`product`表的模型，添加了一个名为
- en: '`company`, as shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`company`，如下所示：'
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result of `migrate` will be something like the following snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrate`的结果将类似于以下片段：'
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we can see that Alembic compares the new model with the
    database table and detects a newly added column for `company` in the `product`
    table (created by the `Product` model).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到Alembic将新模型与数据库表进行比较，并检测到`product`表（由`Product`模型创建）中新增的`company`列。
- en: 'Similarly, the output of `upgrade` will be something like the following snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`upgrade`的输出将类似于以下片段：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, Alembic performs the upgrade of the database for the migration detected
    earlier. We can see a hex code in the preceding output. This represents the revision
    of the migration performed. This is for internal use by Alembic to track the changes
    to database tables.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Alembic对之前检测到的迁移进行数据库升级。我们可以看到前一个输出中的十六进制代码。这代表了迁移执行的修订版本。这是Alembic内部用于跟踪数据库表更改的。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Creating a basic product model* recipe for the context of this
    recipe around the catalog models for `product`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考*创建基本产品模型*配方，了解此配方中关于`product`的目录模型的上下文。
- en: Indexing model data with Redis
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis索引模型数据
- en: There may be some features we want to implement but do not want to have persistent
    storage for them. In such a use case, it is a good approach to have these stored
    in cache-like storage temporarily – for example, when we want to show a list of
    recently viewed products to visitors on a website. In this recipe, we will understand
    how to use Redis as an effective cache to store non-persistent data that can be
    accessed at a high speed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一些我们想要实现但不想为它们提供持久存储的功能。在这种情况下，将这些功能暂时存储在类似缓存存储中是一个很好的方法 - 例如，当我们想在网站上向访客显示最近查看的产品列表时。在这个配方中，我们将了解如何使用Redis作为有效的缓存来存储非持久数据，这些数据可以以高速访问。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will do this with the help of Redis, which can be installed using the following
    command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Redis来完成此操作，可以使用以下命令安装：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Make sure that you run the Redis server for the connection to happen. To install
    and run a Redis server, refer to [http://redis.io/topics/quickstart](http://redis.io/topics/quickstart).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您运行Redis服务器以建立连接。有关安装和运行Redis服务器的信息，请参阅[http://redis.io/topics/quickstart](http://redis.io/topics/quickstart)。
- en: 'Then, we need to have the connection open to Redis. This can be done by adding
    the following lines of code to `my_app/__init__.py`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要保持与Redis的连接打开。这可以通过在`my_app/__init__.py`中添加以下代码行来实现：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can do this in our application file, where we will define the app, or in
    the views file, where we will use it. It is preferred that you do this in the
    application file because then, the connection will be open throughout the application,
    and the `redis` object can be used by just importing it where required.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在应用程序文件中这样做，在那里我们将定义应用程序，或者在视图文件中，我们将使用它。建议您在应用程序文件中这样做，因为这样，连接将贯穿整个应用程序，并且只需导入所需的`redis`对象即可使用。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will maintain a `set` in Redis, which will store the products visited recently.
    This will be populated whenever a product is visited. The entry will expire in
    10 minutes. This change goes in `views.py`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Redis中维护一个`set`，它将存储最近访问过的产品。每当访问产品时，它将被填充。条目将在10分钟后过期。此更改在`views.py`中：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding method, note the `set()` and `expire()` methods on the `redis`
    object. First, set the product ID using the `product_key` value in the Redis store.
    Then, set the `expire` time of the key to `600` seconds.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，注意`redis`对象上的`set()`和`expire()`方法。首先，使用Redis存储中的`product_key`值设置产品ID。然后，将键的`expire`时间设置为`600`秒。
- en: Tip
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It would be a good practice to fetch the `expire` time – that is, `600` – from
    a configuration value. This can be set on the application object in `my_app/__init__.py`,
    and can then be fetched from there.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最好从配置值中获取`expire`时间——即`600`。这可以在`my_app/__init__.py`中的应用程序对象上设置，然后从那里获取。
- en: 'Now, we will look for the keys that are still alive in the cache and then fetch
    the products corresponding to these keys and return them:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查找缓存中仍然存在的键，然后获取与这些键对应的产品并返回它们：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An entry is added to the store whenever a user visits a product, and the entry
    is kept there for 600 seconds (10 minutes). Now, this product will be listed in
    the recent products list for the next 10 minutes unless it is visited again, which
    will reset the time to 10 minutes again.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户访问产品时，都会向存储中添加一个条目，并且该条目将保留600秒（10分钟）。现在，除非再次访问，否则此产品将在接下来的10分钟内列在最近产品列表中，这将会再次将时间重置为10分钟。
- en: 'To test this, add a few products to your database:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这一点，向您的数据库添加一些产品：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, visit some products by simply opening the product URLs in the browser
    – for example, `http://127.0.0.1:5000/product/1` and `http://127.0.0.1:5000/product/3`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在浏览器中打开产品URL来简单地访问一些产品——例如，`http://127.0.0.1:5000/product/1`和`http://127.0.0.1:5000/product/3`。
- en: 'Now, open `http://127.0.0.1:5000/recent-products` in the browser to view the
    list of recent products:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开`http://127.0.0.1:5000/recent-products`以查看最近产品的列表：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Opting for the NoSQL way with MongoDB
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择MongoDB的NoSQL方式
- en: Sometimes, the data to be used in the application we are building may not be
    structured at all; it may be semi-structured, or there may be some data whose
    schema changes frequently over time. In such cases, we would refrain from using
    an RDBMS, as it adds to the pain and is difficult to scale and maintain. For such
    cases, it would be desirable to use a NoSQL database.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们在构建的应用程序中要使用的数据可能根本不是结构化的；它可能是半结构化的，或者可能有一些数据其模式随时间频繁变化。在这种情况下，我们会避免使用RDBMS，因为它增加了痛苦，并且难以扩展和维护。对于这种情况，最好使用NoSQL数据库。
- en: Also, as a result of fast and quick development in the currently prevalent development
    environment, it is not always possible to design the perfect schema the first
    time. NoSQL provides the flexibility to modify the schema without much hassle.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于当前流行的开发环境中的快速和快速开发，设计完美的模式并不总是可能的。NoSQL提供了修改模式而无需太多麻烦的灵活性。
- en: In production environments, the database usually grows to a huge size over a
    period of time. This drastically affects the performance of the overall system.
    Vertical and horizontal scaling techniques are available, but they can be very
    costly at times. In such cases, a NoSQL database can be considered, as it is designed
    from scratch for similar purposes. The ability of NoSQL databases to run on large
    multiple clusters and handle huge volumes of data generated with high velocity
    makes them a good choice when looking to handle scaling issues with traditional
    RDBMSes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，数据库通常会在一段时间内增长到巨大的规模。这极大地影响了整个系统的性能。有垂直和水平扩展技术可用，但有时它们可能非常昂贵。在这种情况下，可以考虑使用NoSQL数据库，因为它从头开始就是为了类似的目的而设计的。NoSQL数据库能够在大型多个集群上运行并处理以高速生成的大量数据，这使得它们在处理传统RDBMS的扩展问题时成为一个不错的选择。
- en: In this recipe, we will use MongoDB to learn how to integrate NoSQL with Flask.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用MongoDB来学习如何将NoSQL与Flask集成。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are many extensions available for using Flask with MongoDB. We will use
    `Flask-MongoEngine`, as it provides a good level of abstraction, which makes it
    easy to understand. It can be installed using the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多扩展可用于使用Flask与MongoDB。我们将使用`Flask-MongoEngine`，因为它提供了良好的抽象级别，这使得它易于理解。可以使用以下命令进行安装：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Remember to run the MongoDB server for the connection to happen. For more details
    on installing and running MongoDB, refer to [http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 记得运行MongoDB服务器以建立连接。有关安装和运行MongoDB的更多详细信息，请参阅[http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/)。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, manually create a database in MongoDB using the command line. Let’s
    name this database `my_catalog`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用命令行在 MongoDB 中手动创建一个数据库。让我们把这个数据库命名为 `my_catalog`：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following is a rewrite of our catalog application using MongoDB. The first
    change comes to our configuration file, `my_app/__init__.py`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们使用 MongoDB 重写的目录应用程序。第一个变化出现在我们的配置文件 `my_app/__init__.py` 中：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Information
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Note that instead of the usual SQLAlchemy-centric settings, we now have `MONGODB_SETTINGS`.
    Here, we just specify the name of the database to use, which, in our case, is
    `my_catalog`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再使用通常以 SQLAlchemy 为中心的设置，我们现在有 `MONGODB_SETTINGS`。在这里，我们只需指定要使用的数据库名称，在我们的例子中是
    `my_catalog`。
- en: 'Next, we will create a `Product` model using MongoDB fields. This happens as
    usual in the models file, `my_app/catalog/models.py`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 MongoDB 字段创建一个 `Product` 模型。这通常在模型文件 `my_app/catalog/models.py` 中完成：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Important information
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Now would be a good time to look at the MongoDB fields used to create the preceding
    model and their similarity to the SQLAlchemy fields used in the previous recipes.
    Here, instead of an `ID` field, we have a `key`, which stores the unique identifier
    that will be used to uniquely identify a record. Also, note the class that is
    inherited by `Product` while creating the model. In the case of SQLAlchemy, it
    is `db.Model`, and in the case of MongoDB, it is `db.Document`. This is in accordance
    with how these database systems work. SQLAlchemy works with conventional RDBMSes,
    but MongoDB is a NoSQL document database system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是查看用于创建前面模型的 MongoDB 字段及其与之前配方中使用的 SQLAlchemy 字段相似性的好时机。在这里，我们有一个 `key` 字段而不是
    `ID` 字段，它存储将用于唯一标识记录的唯一标识符。此外，请注意在创建模型时 `Product` 继承的类。在 SQLAlchemy 的情况下，它是 `db.Model`，而在
    MongoDB 的情况下，它是 `db.Document`。这符合这些数据库系统的工作方式。SQLAlchemy 与传统的 RDBMS 一起工作，但 MongoDB
    是一个 NoSQL 文档数据库系统。
- en: 'The following is the views file, namely, `my_app/catalog/views.py`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们文件，即 `my_app/catalog/views.py`：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You will notice that it is very similar to the views created for the SQLAlchemy-based
    models. There are just a few differences in the methods that are called from the
    MongoEngine extension, and these should be easy to understand.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到它与为基于 SQLAlchemy 的模型创建的视图非常相似。只是从 MongoEngine 扩展调用的方法有一些细微的差别，这些应该很容易理解。
- en: How it works…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, add products to the database by using the `/``product-create` endpoint:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过使用 `/product-create` 端点将产品添加到数据库中：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, validate the product addition by visiting the `http://127.0.0.1:5000/products`
    endpoint in the browser. The following is the resultant JSON value:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在浏览器中访问 `http://127.0.0.1:5000/products` 端点来验证产品添加。以下是将得到的 JSON 值：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Creating a basic product model* recipe to understand how this
    application is structured.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 参考创建基本产品模型的配方，了解此应用程序的结构。
