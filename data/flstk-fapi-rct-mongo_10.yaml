- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Web Development with Next.js 14
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Next.js 14进行Web开发
- en: Next.js is a React framework for building full stack web applications. While
    React is a library for building user interfaces (web or native), Next.js is a
    full-blown framework, built on React, that provides dozens of features and, most
    importantly, a structure for projects ranging from simple websites (like the one
    you are going to build in this chapter) to incredibly complex applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js是一个用于构建全栈Web应用的React框架。虽然React是一个用于构建用户界面（Web或原生）的库，但Next.js是一个完整的框架，基于React构建，提供了数十个特性，最重要的是，为从简单网站（如本章中将要构建的网站）到极其复杂的应用程序的项目结构。
- en: While React.js is an unopinionated declarative library for building UIs, as
    a framework, Next.js provides configurations, tooling, bundling, compiling, and
    much more, enabling the developer to focus solely on building the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然React.js是一个用于构建UI的无意见声明性库，但作为一个框架，Next.js提供了配置、工具、打包、编译等功能，使开发者能够专注于构建应用程序。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to create a Next.js project and deploy it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建Next.js项目并将其部署
- en: The newest Next.js App Router and its features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新的Next.js App Router及其特性
- en: 'The different types of page rendering: dynamic, server-side, static'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的页面渲染：动态、服务器端、静态
- en: 'Next.js useful tools: the `Image` component and the `Head` component'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js实用工具：`Image`组件和`Head`组件
- en: Server Actions along with cookie-based authentication
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器操作以及基于cookie的认证
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To create the sample application in this chapter, you should have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建本章中的示例应用程序，您应该具备以下条件：
- en: Node.js version 18.17 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js版本18.17或更高
- en: Python 3.11.7 for running the backend from the previous chapter (either locally
    or from a deployment, such as Render)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于运行上一章后端的Python 3.11.7（无论是本地还是从部署，如Render）
- en: The requirements are identical to those in the previous chapters, and the new
    packages you will install will be described as they are introduced.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要求与上一章相同，您将要安装的新包将在介绍时进行描述。
- en: Introduction to Next.js
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Next.js简介
- en: Next.js 14 is the latest version of the popular React-based framework for creating
    full-stack and production-ready web applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 14是流行的基于React的框架的最新版本，用于创建全栈和可生产就绪的Web应用程序。
- en: Next.js goes as far as providing even the possibility of creating the backend
    server through a new Next.js feature named **Route Handlers** ([https://nextjs.org/docs/app/building-your-application/routing/route-handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)).
    This feature provides functions that allow you to create custom HTTP request handlers
    and create full-fledged APIs by using the Web Request and Response APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js甚至提供了通过名为**Route Handlers**（[https://nextjs.org/docs/app/building-your-application/routing/route-handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)）的新特性来创建后端服务器的可能性。这个特性提供了允许你创建自定义HTTP请求处理器，并通过使用Web请求和响应API来创建完整API的函数。
- en: These route handlers expose HTTP methods similarly to FastAPI (`GET`, `POST`,
    and so on) and allow building complex APIs that support middleware, caching, dynamic
    functions, setting and getting cookies and headers, and much more.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由处理器类似于FastAPI（`GET`、`POST`等）公开HTTP方法，并允许构建支持中间件、缓存、动态函数、设置和获取cookie和头部的复杂API等。
- en: In the next few sections, you’ll be able to plug in your own, Python-based server
    and have that server run independently, maybe serving other applications simultaneously
    (a mobile application, for instance). You will be able to unleash the power of
    Python’s ecosystem for integrating some data science or AI libraries and work
    quickly to have a great developer experience with Python.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，您将能够插入自己的基于Python的服务器，并让该服务器独立运行，可能同时服务于其他应用程序（例如移动应用程序）。您将能够释放Python生态系统在集成某些数据科学或AI库方面的力量，并快速拥有与Python的出色开发者体验。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more detailed instructions on a particular topic, you can refer to the
    following website: [https://nextjs.org/docs](https://nextjs.org/docs).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解特定主题的更详细说明，您可以参考以下网站：[https://nextjs.org/docs](https://nextjs.org/docs)。
- en: Creating a Next.js 14 project
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Next.js 14项目
- en: In this project-oriented section, you will learn how to create and deploy your
    project using your React knowledge. You will create a brand new Next.js app by
    performing a series of simple steps. The project will use Tailwind CSS (integrated
    into Next.js) and JavaScript instead of TypeScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个以项目为导向的部分，你将学习如何利用你的React知识创建和部署你的项目。你将通过执行一系列简单的步骤来创建一个全新的Next.js应用。该项目将使用Tailwind
    CSS（集成到Next.js中）和JavaScript而不是TypeScript。
- en: The frontend that you will be building in this chapter requires a running backend—from
    the previous chapter. It can run either on your local machine or, in case you
    performed the deployment, from **Render**.com. During development, running the
    background from the previous chapter locally in a separate terminal will be easier
    and faster, with the virtual environment activated.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将构建的前端需要运行后端——来自上一章。它可以在你的本地机器上运行，或者在执行部署的情况下，从**Render**.com运行。在开发过程中，在单独的终端中本地运行上一章的背景，并激活虚拟环境，将会更容易和更快。
- en: 'To create a brand new Next.js project and set it up the way we have specified
    (JavaScript instead of Typescript, the new App Router, and so on), perform the
    following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个全新的Next.js项目并按照我们指定的方式设置（使用JavaScript而不是TypeScript，新的App Router等），请执行以下步骤：
- en: 'Open the terminal in the folder of your choice and enter the following command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择的文件夹中打开终端并输入以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The prompt will ask you if you wish to install the latest `create-next-app`
    package, which at the time of writing is *version 14.2.4*. Confirm the installation.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示将询问你是否希望安装最新的`create-next-app`包，在撰写本文时是*版本14.2.4*。确认安装。
- en: 'After the installation of the `create-next-app` package and starting it with
    the previous command, the CLI tool will pose a series of questions ([https://nextjs.org/docs/getting-started/installation](https://nextjs.org/docs/getting-started/installation)).
    For your project, you should choose the following:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在安装`create-next-app`包并使用之前的命令启动它之后，CLI工具将提出一系列问题（[https://nextjs.org/docs/getting-started/installation](https://nextjs.org/docs/getting-started/installation)）。对于你的项目，你应该选择以下选项：
- en: 'What is your project named? `src/` directory? `@/*`)? `cd` `FARM` command and
    run the development server:'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的项目叫什么名字？`src/`目录？`@/*`)? 使用`cd` `FARM`命令并运行开发服务器：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The CLI will inform you that the server is running on the URL `http://127.0.0.1:3000`.
    If you visit this page in your browser, the first render of the page could be
    a bit delayed, which is normal, because Next.js would be compiling the first and
    currently only page.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CLI将通知你服务器正在URL `http://127.0.0.1:3000`上运行。如果你在浏览器中访问这个页面，页面的首次渲染可能会有些延迟，这是正常的，因为Next.js会编译第一个也是目前唯一的页面。
- en: 'The page currently displays a lot of Next.js-specific styles, so to start with
    a clean slate, open the only automatically defined page in `/src/app/page.js`
    and make it an empty React component (you can use the `rafce` shortcut from the
    React Snippets extension):'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前页面显示了很多Next.js特定的样式，因此为了从零开始，打开`/src/app/page.js`中的唯一自动定义的页面，并将其变成一个空的React组件（你可以使用React
    Snippets扩展的`rafce`快捷键）：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, delete the Next-specific styles from the `/src/app/globals.css` file
    and leave just the three Tailwind imports at the top:'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，从`/src/app/globals.css`文件中删除Next.js特定的样式，只留下顶部的三个Tailwind导入：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you have a blank Next.js application running, and you are ready to define
    the application pages. Next.js uses a different type of routing system than React
    Router. In the next section, you will learn how to use the most important features
    of the Next.js framework as you need them. Before proceeding, you will briefly
    observe the Next.js project structure and get acquainted with the main folders
    and files in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经运行了一个空的Next.js应用，并且你准备好定义应用程序的页面。Next.js使用与React Router不同的路由系统。在下一节中，你将学习如何根据需要使用Next.js框架的最重要功能。在继续之前，你将简要观察Next.js项目结构，并在下一节中熟悉主要文件夹和文件。
- en: Next.js project structure
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Next.js项目结构
- en: While the documentation goes into great detail explaining each file and folder’s
    function ([https://nextjs.org/docs/getting-started/project-structure](https://nextjs.org/docs/getting-started/project-structure)),
    it is good to know where you started. The `/app` folder is the center of the application.
    Its structure will determine the application routing that will be covered in the
    following section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文档详细解释了每个文件和文件夹的功能（[https://nextjs.org/docs/getting-started/project-structure](https://nextjs.org/docs/getting-started/project-structure)），但了解你从哪里开始是很重要的。`/app`文件夹是应用程序的中心。其结构将决定以下部分中将要介绍的应用程序路由。
- en: 'The most important files and folders that define a Next.js project structure
    are the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义Next.js项目结构的最重要文件和文件夹如下：
- en: The `/public` folder in the root project directory can be used for serving static
    files, and they are referenced by the base URL.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根项目目录中的`/public`文件夹可用于提供静态文件，并且它们通过基本URL进行引用。
- en: The `next.config.js` file is a Node.js module used for configuring your Next.js
    application—prefixing assets, `gzip` compression, managing custom headers, allowing
    remote image hosts, logging, and much more can be configured from this file ([https://nextjs.org/docs/app/api-reference/next-config-js](https://nextjs.org/docs/app/api-reference/next-config-js)).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next.config.js`文件是一个Node.js模块，用于配置你的Next.js应用程序——从该文件中可以配置前缀资产、`gzip`压缩、管理自定义头、允许远程图像托管、日志记录等等（[https://nextjs.org/docs/app/api-reference/next-config-js](https://nextjs.org/docs/app/api-reference/next-config-js)）。'
- en: The `globals.css` file is the global CSS style imported into every route. In
    your application, you are keeping it minimal and importing only the Tailwind directives.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`globals.css`文件是导入到每个路由的全局CSS样式。在你的应用程序中，你保持它最小化，并仅导入Tailwind指令。'
- en: 'Optionally, you can create a `middleware.js` function that will contain middleware
    that will be applied on every or only selected requests. See the documentation
    on middleware to learn more: [https://nextjs.org/docs/app/building-your-application/routing/middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，你可以创建一个`middleware.js`函数，该函数将包含将在每个或仅选定请求上应用的中件。查看中件文档以了解更多信息：[https://nextjs.org/docs/app/building-your-application/routing/middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware)
- en: Optionally, you can create a `/components` directory outside the `/app` folder
    (which has the special routing role) and create your React components inside it.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，你可以在`/app`文件夹（具有特殊路由角色）外部创建一个`/components`目录，并在其中创建你的React组件。
- en: Now that you’ve gone through the brief project structure, you will create the
    pages for your application and learn the basics of the Next.js App Router along
    the way. You will keep styling intentionally to a minimum in order to showcase
    the functionalities and component boundaries.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了简要的项目结构，你将创建应用程序的页面，并在过程中学习Next.js App Router的基础知识。你将故意将样式保持到最小，以展示功能性和组件边界。
- en: Routing with Next.js 14
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Next.js 14进行路由
- en: The latest and recommended routing system in Next.js relies on the `src/App`
    folder—generally, every URL has a corresponding folder with the appropriate name
    and a `page.js` file inside of it. This structure allows you to even replace the
    `page.js` file with a `route.js` file, which is then treated as an API endpoint.
    You will create a simple route handler for demonstration purposes, but you will
    not use route handlers in the project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js中最新且推荐的路由系统依赖于`src/App`文件夹——通常，每个URL都有一个对应名称的文件夹，其中包含一个`page.js`文件。这种结构允许你甚至用`route.js`文件替换`page.js`文件，然后将其视为API端点。你将创建一个简单的路由处理程序用于演示目的，但在项目中你不会使用路由处理程序。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A detailed introduction to the App Router is available on the Next.js documentation
    website ([https://nextjs.org/docs/pages/building-your-application/routing](https://nextjs.org/docs/pages/building-your-application/routing)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Next.js文档网站上可以找到对App Router的详细介绍（[https://nextjs.org/docs/pages/building-your-application/routing](https://nextjs.org/docs/pages/building-your-application/routing)）。
- en: 'You will now build the basic page structure: a home page, a page for displaying
    all the cars as well as an individual car, a private page for inserting new cars
    (for authorized users only), and a login page.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将构建基本页面结构：一个主页、一个显示所有汽车以及单个汽车的页面、一个仅供授权用户插入新汽车的私有页面，以及一个登录页面。
- en: Creating the pages structure with the App Router
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用App Router创建页面结构
- en: You already have a `page.js` file in the root of the `App` directory; it maps
    to the `/root` URL of the website.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在`App`目录的根目录中有一个`page.js`文件；它映射到网站的`/root` URL。
- en: 'Now, you will build the routes for the remaining pages:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将构建剩余页面的路由：
- en: 'To create a route for displaying the cars (at `/cars` in the URL), create a
    new folder and name it `cars` in the `/app` directory, with a simple `page.js`
    file inside (the name `page.js` is mandatory):'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个显示汽车的路由（在URL中的`/cars`），在`/app`目录中创建一个新的文件夹，命名为`cars`，并在其中创建一个简单的`page.js`文件（文件名`page.js`是强制性的）：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While inside the `/src/app/cars` directory, create a nested folder for displaying
    the individual cars based on the ID of the car. Create another folder inside the
    `cars` directory and name it `[id]`. This will tell the router that the route
    should map to `/cars/someID`. The `/cars/` part is based on the fact that the
    folder is inside the `/cars` directory, while the brackets syntax notifies Next.js
    of the presence of a dynamic parameter (`id`, in this case). Inside the `[id]`
    folder create a `page.js` file and name the component inside `CarDetails`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在`/src/app/cars`目录内时，创建一个基于汽车ID显示单个汽车的嵌套文件夹。在`cars`目录内创建另一个文件夹，并命名为`[id]`。这将告诉路由器该路由应该映射到`/cars/someID`。`/cars/`部分是基于文件夹位于`/cars`目录内的事实，而括号语法通知Next.js存在一个动态参数（在这种情况下是`id`）。在`[id]`文件夹内创建一个`page.js`文件，并将组件命名为`CarDetails`。
- en: Repeat the same procedure and create a `/app/login/page.js` file and a `/app/private/page.js`
    file with the corresponding file structure. Run the `rafce` command and create
    a simple component corresponding to each page.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复相同的步骤，创建一个`/app/login/page.js`文件和一个`/app/private/page.js`文件，并使用相应的文件结构。运行`rafce`命令，为每个页面创建一个简单的组件。
- en: 'Now, you have the defined pages, and you can test their functionality by manually
    visiting the various URLs: `/`, `/cars`, `/private`, and `/login`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经定义了页面，可以通过手动访问各种URL来测试它们的功能：`/`, `/cars`, `/private`, 和 `/login`。
- en: This is a good moment to compare the App Router to other solutions that we used
    in the previous chapters—namely, React Router.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个很好的时机来比较App Router与其他我们在前几章中使用过的解决方案——即React Router。
- en: Layouts in Next.js
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Next.js中的布局
- en: Similar to React Router and its `Slot` component, the Next.js App Router provides
    a powerful `Layout` component that blends into the directory structure concept.
    `Layout` is a user interface that is shared among routes; it preserves state,
    remains interactive, and does not re-render. Instead of a `Slot` component used
    in React Router, the Next.js layout accepts a `children` prop that will render
    inside the base page—practically the entire application will be loaded inside
    this layout component.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与React Router及其`Slot`组件类似，Next.js App Router提供了一个强大的`Layout`组件，它融合到目录结构概念中。`Layout`是一个在路由间共享的用户界面；它保留状态，保持交互性，并且不会重新渲染。与React
    Router中使用的`Slot`组件不同，Next.js布局接受一个`children`属性，它将在基本页面内部渲染——实际上，整个应用程序都将加载在这个布局组件内部。
- en: You can inspect the mandatory root layout that is used throughout the entire
    Next.js application and is located in `/app/layout.js`. Try adding an element
    inside the body and before the `{{children}}` component and inspect on which pages
    the element is visible—it should be visible on every page. The root layout isn’t
    the only layout that you can use; in fact, you can and you should create layouts
    for related routes that encapsulate common functionality or user interface elements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查整个Next.js应用程序中使用的强制根布局，它位于`/app/layout.js`。尝试在body内部和`{{children}}`组件之前添加一个元素，并检查该元素在哪些页面上可见——它应该在每一页上都可见。根布局不是您能使用的唯一布局；实际上，您可以为相关路由创建布局，以封装共同的功能或用户界面元素。
- en: 'To create a simple layout that will be used for the cars list page and the
    individual cars (so it will be located inside the `/app/cars` folder), create
    a file named `layout.js` inside the `/``app/cars` directory:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个简单的布局，该布局将被用于汽车列表页面和单个汽车页面（因此它将位于`/app/cars`文件夹内），在`/app/cars`目录内创建一个名为`layout.js`的文件：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will notice that the layout affects the `/cars` and `/cars/id` routes, but
    not the other ones; it is the location of the layout file that defines when it
    will be loaded. This functionality enables you to create different nested routes
    and keep reusable UI functionality based on your application logic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到布局影响了`/cars`和`/cars/id`路由，但不会影响其他路由；布局文件的位置定义了它何时会被加载。这个功能使您能够创建不同的嵌套路由，并基于您的应用程序逻辑保持可重用的UI功能。
- en: 'Before moving on, there are a couple of features of the Next.js router that
    need to be mentioned:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，需要提到Next.js路由器的几个特性：
- en: '`template.js` that wraps the entire child layout or page but does not persist
    across requests. It can be used, for instance, with Framer Motion to add page
    transitions and animations between different pages.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template.js` 包裹整个子布局或页面，但不会跨请求持久化。例如，它可以与 Framer Motion 一起使用，以添加不同页面之间的页面转换和动画。'
- en: '`[… folderName]`. These segments will match more additional path parameters.
    The Next.js documentation on route segments is available at https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[… folderName]`。这些段将匹配更多的路径参数。关于 Next.js 路由段文档，请参阅 https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments。'
- en: '**Route groups** are useful when you want to prevent a folder from being included
    in the route’s URL path, while retaining the layout functionality. Route groups
    are documented at [https://nextjs.org/docs/app/building-your-application/routing/route-groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由组**在您想防止文件夹包含在路由的 URL 路径中，同时保留布局功能时非常有用。路由组文档请参阅 [https://nextjs.org/docs/app/building-your-application/routing/route-groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups)。'
- en: After having created the necessary pages and learned about the main features
    of the App Router, in the next section, you will learn about Next.js components
    and how to leverage layouts in your application structure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了必要的页面并了解了 App Router 的主要功能之后，在下一节中，您将学习 Next.js 组件以及如何在应用程序结构中利用布局。
- en: Next.js components
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Next.js 组件
- en: One of the main new concepts of Next.js is the distinction between `localstorage`,
    and so on).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 的一个主要新概念是区分 `localstorage` 等。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Next.js documentation explains the major but also the more subtle differences
    here: [https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 文档解释了这里的主要差异以及更微妙的不同之处：[https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns)。
- en: 'Generally speaking, since server components can access data on the server directly,
    they are preferred for tasks such as data fetching and working with sensitive
    information (access tokens, API keys, and so on). Client components are a better
    fit for classic React **single-page application** (**SPA**) tasks: adding interactivity,
    using React hooks, custom hooks that depend on the state, interfacing with the
    browser, geolocation, and so on.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，由于服务器组件可以直接在服务器上访问数据，因此它们更适合数据获取和敏感信息（访问令牌、API 密钥等）处理等任务。客户端组件更适合经典的 React
    **单页应用**（SPA）任务：添加交互性、使用 React 钩子、依赖于状态的自定义钩子、与浏览器接口、地理位置等。
- en: By default, Next.js components are *server* components. To turn them into client
    components, you must add the `"use client"` directive as the first line. This
    directive defines a boundary between a server and a client component module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Next.js 组件是 **服务器** 组件。要将它们转换为客户端组件，您必须在第一行添加 `"use client"` 指令。此指令定义了服务器和客户端组件模块之间的边界。
- en: Creating the navigation component
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建导航组件
- en: To begin crafting Next.js components, now you will create a simple navigation
    component and learn about the `Link` component in Next.js.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 开始构建 Next.js 组件，现在您将创建一个简单的导航组件，并了解 Next.js 中的 `Link` 组件。
- en: 'To create a navigation component, implement the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建导航组件，请执行以下步骤：
- en: 'Create a folder called `/src/components/` alongside the `/app` folder (not
    inside it, since these will not be user-navigable pages) and create the `NavBar.js`
    file inside it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/app` 文件夹旁边创建一个名为 `/src/components/` 的文件夹（不要放在里面，因为这些页面不会被用户导航）并在其中创建 `NavBar.js`
    文件：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `NavBar.js` component is very similar to the ones created in previous chapters.
    However, here, you have imported the `Link` component—the Next.js component that
    extends the `<a>` element (the native HTML link component) and provides data pre-fetching
    ([https://nextjs.org/docs/app/api-reference/components/link](https://nextjs.org/docs/app/api-reference/components/link)).
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NavBar.js` 组件与前面章节中创建的组件非常相似。然而，在这里，您已经导入了 `Link` 组件——这是扩展 `<a>` 元素（原生的 HTML
    链接组件）并提供数据预获取的 Next.js 组件。[https://nextjs.org/docs/app/api-reference/components/link](https://nextjs.org/docs/app/api-reference/components/link)'
- en: 'The previous code utilizes a Tailwind plugin that enables developers to target
    descendent selectors directly. To use it, open the `tailwind.config.js` file and
    edit the content by changing the `plugins` array value:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的代码使用了一个 Tailwind 插件，它允许开发者直接定位后代选择器。要使用它，打开 `tailwind.config.js` 文件并编辑内容，通过更改
    `plugins` 数组值：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now open the root layout, located at `/src/app/layout.js`, and insert the `NavBar.js`
    component before the `children` props by replacing the existing `RootLayout` function
    with the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开位于 `/src/app/layout.js` 的根布局，在 `children` 属性之前插入 `NavBar.js` 组件，用以下代码替换现有的
    `RootLayout` 函数：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this step, you added the newly created component to the root layout since
    it will be displayed on every page.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，您将新创建的组件添加到根布局中，因为它将在每个页面上显示。
- en: You now have defined the routes, scaffolded the basic pages of the application,
    and created a simple navigation menu. In the next section, you will see how Next.js
    simplifies data loading through server components.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已定义了路由，构建了应用程序的基本页面，并创建了一个简单的导航菜单。在下一节中，您将看到 Next.js 如何通过服务器组件简化数据加载。
- en: Data loading with server components
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用服务器组件加载数据
- en: The following process will help you learn how to load data from your FastAPI
    server into the `/cars` page without resorting to hooks and states, and see how
    Next.js extends the native fetch functionality.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程将帮助您学习如何从您的 FastAPI 服务器加载数据到 `/cars` 页面，而不需要使用钩子和状态，并了解 Next.js 如何扩展原生的
    fetch 功能。
- en: 'To load data from your FastAPI server into the `/cars` page without hooks,
    implement the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不使用钩子的情况下从您的 FastAPI 服务器加载数据到 `/cars` 页面，请执行以下步骤：
- en: 'Before creating the page that should display information about all the cars
    that are currently present in your cars collection, create a `.env` file in the
    root of the Next.js project (parallel to the `/src` folder) and use it to map
    the address of your API:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建应显示您当前汽车收藏中所有汽车信息的页面之前，在 Next.js 项目的根目录中（与 `/src` 文件夹平行）创建一个 `.env` 文件，并使用它来映射您的
    API 地址：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This value will have to change once you deploy and wish to use your Render.com
    API URL, or whatever backend deployment solution you might choose.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此值将在您部署并希望使用您的 Render.com API URL 或您可能选择的任何后端部署解决方案时需要更改。
- en: 'Once it has been set in the environment, the address will be available in your
    code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在环境中设置，地址将在您的代码中可用：
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is important to remember that in order to be visible in the browser, the
    environment variables need to be prepended by the `NEXT_PUBLIC_` string. In this
    case, however, you are doing data fetching on the server, in a server component,
    so it is perfectly fine to hide the API address.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是要记住，为了在浏览器中可见，环境变量需要以 `NEXT_PUBLIC_` 字符串开头。然而，在这种情况下，您正在服务器组件中进行数据获取，所以隐藏
    API 地址是完全可以接受的。
- en: Now you are ready to perform the first server-side fetch. Make sure that your
    backend server is running on the specified port `8000`.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在您已经准备好执行第一次服务器端获取。请确保您的后端服务器正在指定的端口 `8000` 上运行。
- en: 'Open the `/app/cars/page.js` file and edit it:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `/app/cars/page.js` 文件并编辑它：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The previous code might seem simple, but it represents a completely new paradigm
    in React-based development.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可能看起来很简单，但它代表了基于 React 的开发中的一种全新的范式。
- en: You used the Next.js `fetch` function, which extends the native Web API `fetch`
    method and provides some additional functionalities. It is an `async` function,
    so the entire component is asynchronous, and the call is awaited.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用了 Next.js 的 `fetch` 函数，它扩展了原生的 Web API `fetch` 方法并提供了一些额外的功能。它是一个 `async`
    函数，因此整个组件是异步的，调用被等待。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This fetch functionality is explained in great detail on the Next.js website:
    [https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此 fetch 功能在 Next.js 网站上有详细的解释：[https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating)。
- en: While providing various features such as access to headers and cookies, the
    `fetch` function allows granular control over caching and revalidating the received
    data. Revalidation in this context means the cache invalidation and re-fetching
    of the latest data. Your cars page might have very frequent updates, and you can
    set a time limit on the content. In the preceding code, the content is revalidated
    every 10 seconds. In some cases, it might make sense to revalidate the data after
    a couple of hours or even days.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供各种功能，如访问头和cookie的同时，`fetch` 函数允许对缓存和重新验证接收到的数据进行细粒度控制。在此上下文中，重新验证意味着缓存失效和重新获取最新数据。你的汽车页面可能非常频繁地更新，你可以设置内容的时间限制。在前面的代码中，内容每10秒重新验证一次。在某些情况下，在几小时或几天后重新验证数据可能是有意义的。
- en: Before moving on to specialized components provided by the framework, you will
    learn about the `error.js` file, which is used for catching errors while staying
    within the boundaries of a layout and route group.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习框架提供的专用组件之前，你将了解用于在布局和路由组边界内捕获错误的 `error.js` 文件。
- en: Error pages in Next.js
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Next.js 中的错误页面
- en: 'To catch unexpected errors that might arise in server components and client
    components, and to display a fallback user interface, you can create a file called
    `error.js` (the name is mandatory) inside the desired folder:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获服务器组件和客户端组件中可能出现的意外错误，并显示备用用户界面，你可以在所需文件夹内创建一个名为 `error.js` 的文件（文件名是强制性的）：
- en: 'Create a file, `/src/app/cars/error.js`, with the following simple content:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件，`/src/app/cars/error.js`，包含以下简单内容：
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The component must use the `"use client"` directive as per the documentation.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件必须按照文档使用 `"use client"` 指令。
- en: 'You can test the error handling page by throwing a generic error inside `[id]/page.js`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过在 `[id]/page.js` 中抛出一个通用错误来测试错误处理页面：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you now try to navigate to any car details page, you will see that the page
    is loaded—the navigation is present, and the main layout and the cars layout are
    rendered. Only the inside of the innermost route group, which contains the `error.js`
    file, displays the error message.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试导航到任何车辆详情页面，你会看到页面已加载——导航存在，主布局和车辆布局已渲染。只有包含 `error.js` 文件的内部最深层路由组显示错误信息。
- en: After learning how to get data inside the page directly from the server, in
    the following section, you will create a statically generated single-car page
    and learn about the powerful Next.js `Image` component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何直接从服务器获取页面内部数据之后，在下一节中，你将创建一个静态生成的单车辆页面，并了解强大的 Next.js `Image` 组件。
- en: Static page generation and the Image component
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态页面生成和 Image 组件
- en: Next.js provides yet another way of generating pages—*static rendering*. In
    this case, pages are rendered at build time (instead of at request time), or,
    in case of data revalidation, in the background. The resulting page is then cached
    and pushed to the content delivery network, for efficient and fast serving. This
    makes Next.js effectively behave like a static site generator, much like Gatsby.js
    or Hugo, and achieve maximum performance in terms of website speed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 提供了另一种生成页面的方法——*静态渲染*。在这种情况下，页面是在构建时（而不是在请求时）渲染的，或者在数据重新验证的情况下，在后台进行。然后生成的页面被缓存并推送到内容分发网络，以实现高效和快速的服务。这使得
    Next.js 有效地表现得像一个静态网站生成器，就像 Gatsby.js 或 Hugo 一样，并在网站速度方面实现最大性能。
- en: However, not all routes are suitable for static rendering; pages that are personalized
    and contain user-specific data are examples of pages that shouldn’t be statically
    generated. Blog posts, documentation pages, or even car ads, however, are not
    pages that should display different features to different users.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有路由都适合静态渲染；个性化页面和包含特定用户数据的页面是不应进行静态生成的页面示例。然而，博客文章、文档页面，甚至是汽车广告，都不是应该向不同用户显示不同功能的页面。
- en: In this section, you will first generate individual car pages as server-side
    rendered pages, like the cars page before, and afterward, you will modify the
    page(s) to be statically rendered.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将首先生成单个汽车页面作为服务器端渲染页面，就像之前的汽车页面一样，然后你将修改页面（们）以进行静态渲染。
- en: Before you begin working with the `Image` component, modify the `next.js.mjs`
    file—the Next.js configuration file—and let Next.js know that it should allow
    images from an external domain—in your case, Cloudinary—since this is where our
    car images are hosted.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始使用 `Image` 组件之前，修改 `next.js.mjs` 文件——Next.js 配置文件——并让 Next.js 知道它应该允许来自外部域的图片——在你的情况下，Cloudinary——因为我们的汽车图片就是托管在那里。
- en: 'Perform the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Open the `next.config.mjs` file and edit the configuration:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `next.config.mjs` 文件并编辑配置：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After this modification, restart the Next.js development server manually:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此修改之后，手动重新启动 Next.js 开发服务器：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now you will create the server-side rendered version of the cars page.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在您将创建汽车页面的服务器端渲染版本。
- en: 'Open `/app/cars/[id]/page.js` and modify it accordingly:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `/app/cars/[id]/page.js` 并相应地修改它：
- en: '[PRE16]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, you imported the `next/image` component and you destructured
    the parameters as `params` from the URL. Then, you performed a similar `fetch`
    request and checked the result status. In case of an error, you used the Next.js
    `redirect` function to redirect the user to the error page, which is yet to be
    created.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，您导入了 `next/image` 组件，并将 URL 的参数解构为 `params`。然后，您执行了一个类似的 `fetch` 请求并检查了结果状态。如果发生错误，您使用了
    Next.js 的 `redirect` 函数将用户重定向到尚未创建的错误页面。
- en: 'Now, continue editing the component and return some basic JSX:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续编辑组件并返回一些基本的 JSX：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The rest of the functional component is rather simple. You have used the `Image`
    component and provided the mandatory data, such as the `width`, `height`, and
    `alt text`. The Image component has a rich API that is documented on the Next.js
    website ([https://nextjs.org/docs/app/api-reference/components/image](https://nextjs.org/docs/app/api-reference/components/image)),
    and it should be used whenever possible because it vastly improves your site’s
    performance.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 功能组件的其余部分相当简单。您使用了 `Image` 组件并提供了必要的数据，例如 `width`、`height` 和 `alt` 文本。Image
    组件有一个丰富的 API，在 Next.js 网站上有文档（[https://nextjs.org/docs/app/api-reference/components/image](https://nextjs.org/docs/app/api-reference/components/image)），并且尽可能使用它，因为它大大提高了您网站的性能。
- en: The `redirect` function is imported from `next/navigation` ([https://nextjs.org/docs/app/building-your-application/routing/redirecting](https://nextjs.org/docs/app/building-your-application/routing/redirecting)).
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`redirect` 函数是从 `next/navigation` 导入的（[https://nextjs.org/docs/app/building-your-application/routing/redirecting](https://nextjs.org/docs/app/building-your-application/routing/redirecting)）。'
- en: The statically generated version of the page(s) includes providing a `generateStaticParams()`
    function to the page and exporting it; Next.js uses this function to know which
    pages to generate at build time.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 页面的静态生成版本包括向页面提供一个 `generateStaticParams()` 函数并将其导出；Next.js 使用此函数在构建时知道要生成哪些页面。
- en: 'For your `/app/cars/[id]/page.js` file, this function will need to loop over
    all the cars that need a static page (all cars in this case) and provide an array
    of IDs:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于您的 `/app/cars/[id]/page.js` 文件，此函数需要遍历所有需要静态页面的汽车（在这种情况下是所有汽车）并提供一个包含 ID 的数组：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you add the preceding `generateStaticParams()` function to the component,
    stop the development server and run another Next.js command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将前面的 `generateStaticParams()` 函数添加到组件中，请停止开发服务器并运行另一个 Next.js 命令：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next.js will produce an optimized build of the entire site, rendering the individual
    car pages at build time as static HTML pages. If you inspect the console, you
    will see the list of routes and a legend that shows which pages were rendered
    at build time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 将生成整个站点的优化构建，在构建时将单个汽车页面渲染为静态 HTML 页面。如果您检查控制台，您将看到路由列表和一个图例，显示哪些页面是在构建时渲染的。
- en: 'Running the production build is possible with the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令可以运行生产构建：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before closing this section, let’s take care of the cases in which the user
    hits the wrong URL, resulting in a nonexistent car. To handle these `404 Page
    Not Found` errors, create a new file called `/src/app/not-found.js` and populate
    it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭本节之前，让我们处理用户点击错误 URL，导致不存在汽车的情况。为了处理这些 `404 页面未找到` 错误，创建一个名为 `/src/app/not-found.js`
    的新文件并填充它：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This route will cover all the route groups, in a similar way to the `*` route
    in the React Router package.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由将涵盖所有路由组，类似于 React Router 包中的 `*` 路由。
- en: After having created the dynamic server-side and statically generated pages
    and exploring some of the most important features of Next.js, you will learn how
    to authenticate users with the existing API in the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了动态服务器端和静态生成的页面，并探索了 Next.js 的一些最重要的功能之后，您将在下一节中学习如何使用现有的 API 对用户进行身份验证。
- en: Authentication and Server Actions in Next.js
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Next.js 中的身份验证和服务器操作
- en: You have learned about quite a few Next.js features that make it stand out as
    the premier web framework, but the list of the most important functionalities
    wouldn’t be complete without a very brief introduction to **Server Actions**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了相当多的 Next.js 功能，这些功能使它成为首屈一指的 Web 框架，但如果没有对 **Server Actions** 的简要介绍，最重要的功能列表将不完整。
- en: Server Actions are simply asynchronous functions executed only on the server
    and designed to handle data fetching and mutations (through `POST`, `PUT`, and
    `DELETE` methods), and they can be called through plain form submissions (the
    default browser form handling method), but also through event handlers (a React-y
    approach) or by third-party libraries such as Axios.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器操作是仅在实际服务器上执行的异步函数，旨在处理数据获取和变更（通过 `POST`、`PUT` 和 `DELETE` 方法），并且可以通过普通表单提交（默认浏览器表单处理方法）调用，也可以通过事件处理程序（React
    风格的方法）或通过第三方库如 Axios 调用。
- en: The benefits of such an approach are numerous. Performance is improved because
    the client-side JavaScript is significantly reduced, and since the actions run
    only on the server, the overall security of the application is enhanced and applications
    can even run with JavaScript disabled, much like the old-school applications of
    a couple of decades ago.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处有很多。性能得到提升，因为客户端 JavaScript 显著减少，并且由于操作仅在服务器上运行，应用程序的整体安全性得到增强，甚至可以在禁用
    JavaScript 的情况下运行，就像几十年前的老式应用程序一样。
- en: 'You will now create your first server action that will be used for logging
    users in, with the help of a package called `localStorage`: signing and encrypting
    cookies. The usage is quite simple, and it is documented here: [https://github.com/vvo/iron-session](https://github.com/vvo/iron-session).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将创建第一个用于登录用户的服务器操作，这需要使用一个名为 `localStorage` 的包：签名和加密 cookies。使用方法相当简单，这里有所记录：[https://github.com/vvo/iron-session](https://github.com/vvo/iron-session)。
- en: 'Install the Iron Session package with the following command:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 Iron Session 包：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To use the `iron-session` functionality, create a `sessionOptions` object in
    a file called `/src/lib.js`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `iron-session` 功能，在名为 `/src/lib.js` 的文件中创建一个 `sessionOptions` 对象：
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The configuration object defines the options necessary for the cookie encryption
    and decryption and you should use a strong, computer-generated random password.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 配置对象定义了用于 cookie 加密和解密的选项，你应该使用一个强大、由计算机生成的随机密码。
- en: 'The Iron Session API is very simple as the session object allows for setting
    and getting dictionary-like values. You will use it to set two simple values:
    the currently logged-in username as well as the `jwt` itself, necessary for performing
    calls to your FastAPI endpoints.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Iron Session API 非常简单，因为会话对象允许设置和获取类似字典的值。你将用它来设置两个简单的值：当前登录的用户名以及 `jwt` 本身，这对于调用你的
    FastAPI 端点至关重要。
- en: 'Now you will begin creating the server actions needed for the application,
    beginning from the login action for authenticating users:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将开始创建应用程序所需的服务器操作，从用于验证用户的登录操作开始：
- en: 'Create a `/src/actions.js` file and import the necessary packages:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `/src/actions.js` 文件并导入必要的包：
- en: '[PRE24]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The previous code imports the cookies from Next.js and the `getIronSession()`
    function from Iron Session, as well as the `sessionOptions` class you defined
    earlier. You then created a simple function for getting the current session and
    the data within.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的代码从 Next.js 导入了 cookies，以及来自 Iron Session 的 `getIronSession()` 函数，以及你之前定义的
    `sessionOptions` 类。然后你创建了一个简单的函数来获取当前会话及其中的数据。
- en: 'Now, in the same file, handle the login functionality:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一个文件中处理登录功能：
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code is straightforward and not unlike the code you saw in the React Router
    and `localStorage` solution. The important parts are the ones related to the session
    object—if the `fetch` call returns a successful response, it means that a valid
    user was found, and the session is set with the username and the corresponding
    `jwt`. If not, the session is destroyed.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码结构简单，与你在 React Router 和 `localStorage` 解决方案中看到的代码相似。重要的是与会话对象相关的部分——如果 `fetch`
    调用返回成功响应，这意味着找到了有效的用户，并且会话已通过用户名和相应的 `jwt` 设置。如果没有，会话将被销毁。
- en: A redirect to the `/private` page is performed only when the user logs in and
    the session is successfully set.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有当用户登录并且会话成功设置时，才会执行重定向到 `/private` 页面的操作。
- en: Now that you have created your first Server Action, you are ready to create
    a Next.js client component—the login form that will be used on the login page.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你已经创建了第一个 Server Action，你就可以创建一个 Next.js 客户端组件了——登录表单，它将在登录页面上使用。
- en: 'Create a new component file, `/src/app/components/LoginForm.js`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的组件文件，`/src/app/components/LoginForm.js`：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`LoginForm` is, unlike the previously created `NavBar` component, a client
    component, which means that it will get rendered on the client and thus needs
    to begin with the `"use` `client"` directive.'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LoginForm` 与之前创建的 `NavBar` 组件不同，是一个客户端组件，这意味着它将在客户端渲染，因此需要以 `"use` `client"`
    指令开始。'
- en: The `useFormState` hook is one of the newest additions to the React ecosystem
    (it is, in fact, imported from the React-Dom package, and not Next.js) and it
    allows you to update the state based on the form action ([https://pl.react.dev/reference/react-dom/hooks/useFormState](https://pl.react.dev/reference/react-dom/hooks/useFormState)).
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useFormState` 钩子是 React 生态系统中最新的添加之一（实际上，它是从 React-Dom 包中导入的，而不是 Next.js），它允许你根据表单操作更新状态（[https://pl.react.dev/reference/react-dom/hooks/useFormState](https://pl.react.dev/reference/react-dom/hooks/useFormState)）。'
- en: 'Continue building the `LoginForm` component:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续构建 `LoginForm` 组件：
- en: '[PRE27]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This login form uses the `useFormState` hook, which provides the state—essentially
    the error object, and `formAction`. In the form, you are displaying the state
    as a stringified JSON object, but in a realistic scenario, you can access all
    the individual errors provided by the server (FastAPI in your case) and display
    them accordingly.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此登录表单使用 `useFormState` 钩子，它提供了状态——本质上是一个错误对象和 `formAction`。在表单中，你将状态显示为字符串化的
    JSON 对象，但在实际场景中，你可以访问服务器（在你的情况下是 FastAPI）提供的所有单个错误，并相应地显示它们。
- en: 'After updating the `/src/app/login/page.js` page and simply adding the `LoginForm`
    component, you will have the following:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新 `/src/app/login/page.js` 页面并简单地添加 `LoginForm` 组件后，你将得到以下内容：
- en: '[PRE28]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, if you try to navigate to the `/login` route and insert some invalid credentials,
    the error will be printed below the form in a stringified JSON format. If the
    credentials are valid, you should be redirected to the `/private` route, and in
    the `jwt`, available across the entire application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试导航到 `/login` 路由并输入一些无效凭据，错误将以字符串化的 JSON 格式打印在表单下方。如果凭据有效，你应该被重定向到 `/private`
    路由，并在整个应用程序中可用的 `jwt` 中。
- en: You have added the authentication functionality through the use of the `iron-session`
    package and with the Next.js Server Actions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经通过使用 `iron-session` 包和 Next.js 服务器操作添加了认证功能。
- en: In the next section, you will create a protected page that is visible only to
    authenticated users. Although there are different ways of protecting pages in
    Next.js, including the use of Next.js middleware, you are going to protect just
    one page with a simple session verification.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将创建一个仅对认证用户可见的受保护页面。尽管在 Next.js 中有不同方式来保护页面，包括使用 Next.js 中间件，但你将使用简单的会话验证来保护一个页面。
- en: Creating protected pages
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建受保护的页面
- en: In this section, you will create one protected page—the page for inserting new
    cars into the MongoDB database collection. Use Iron Session to check the validity
    of the cookie and to pass the value of the logged-in user’s username and `jwt`
    across pages.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个受保护的页面——用于将新车插入 MongoDB 数据库集合的页面。使用 Iron Session 检查 cookie 的有效性，并将登录用户的用户名和
    `jwt` 值跨页面传递。
- en: You will create a protected page by verifying the data from the session. If
    the session is present (and includes a username and `jwt`), the user will be able
    to navigate to it and perform an action to create new cars through the form and
    an associated Server Action. If not, the user will be redirected to the login
    page.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过验证会话中的数据来创建一个受保护的页面。如果会话存在（并且包含用户名和 `jwt`），用户将能够导航到它并通过表单和相关的服务器操作创建新车。如果没有，用户将被重定向到登录页面。
- en: 'The only authenticated page that you will need in this application is the one
    for inserting new cars, and Iron Session makes this job very easy:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，你将需要的唯一认证页面是用于插入新车的页面，Iron Session 使这项工作变得非常简单：
- en: 'Open `/src/app/private/page.js` and edit the file:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `/src/app/private/page.js` 并编辑该文件：
- en: '[PRE29]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The previous code uses the Iron Session object: if `jwt` in the session is
    present, the user is able to see the page that currently contains the session
    data. If the session is invalid, the user is redirected to the `/``login` page.'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的代码使用了 Iron Session 对象：如果会话中的 `jwt` 存在，用户能够看到当前包含会话数据的页面。如果会话无效，用户将被重定向到 `/login`
    页面。
- en: 'To add logout functionality with the session, add another action to the `/``src/actions.js`
    file:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用会话添加注销功能，请向 `/src/actions.js` 文件添加另一个操作：
- en: '[PRE30]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This action can now be invoked from the `NavBar` component, and the session
    object can be used to show or hide the login and logout links accordingly.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，这个操作可以从 `NavBar` 组件中调用，并且可以使用会话对象相应地显示或隐藏登录和登出链接。
- en: 'To incorporate the logout functionality into the website, create a simple one-button
    form for logging the user out in a new `LogoutForm.js` file:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将登出功能集成到网站中，在新的 `LogoutForm.js` 文件中创建一个简单的单按钮表单用于登出：
- en: '[PRE31]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`LogoutForm` consists of only one button that invokes the logout action defined
    earlier. Let’s add it to the navigation (`NavBar.js`) component with some conditional
    logic.'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LogoutForm` 只包含一个按钮，该按钮调用之前定义的登出操作。让我们使用一些条件逻辑将其添加到导航（`NavBar.js`）组件中。'
- en: 'Open the `src/components/Navbar.js` file and edit the navigation component:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/components/Navbar.js` 文件并编辑导航组件：
- en: '[PRE32]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After importing the `getSession` function—to track whether the user is logged
    in or not—and the `LogoutForm` button, you can define the component:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入 `getSession` 函数（用于跟踪用户是否已登录）和 `LogoutForm` 按钮之后，您可以定义组件：
- en: '[PRE33]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The component now keeps track of the logged user and displays conditionally
    the login or logout link depending on the user’s logged-in status. The private
    link is deliberately always visible, but you can test it out; if you are not logged
    in, you will not be able to visit the page and you will get redirected to the
    login page.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件现在跟踪已登录用户，并根据用户的登录状态条件性地显示登录或登出链接。私有链接故意总是可见的，但您可以测试一下；如果您未登录，您将无法访问该页面，并将被重定向到登录页面。
- en: You have now completely implemented the login functionality. There are a couple
    of factors to consider, starting with the duration of the cookie—set through the
    `maxAge` property in the file `/src/lib.js`—which should match the duration of
    `jwt` provided by FastAPI from the backend. The application intentionally lacks
    user registration functionality since the idea is to have a couple of employees—users
    who can be created through the API directly. As an exercise, you could write the
    page for registering users and using the FastAPI `/``users/register` endpoint.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已完全实现了登录功能。有几个因素需要考虑，首先是 cookie 的持续时间——通过文件 `/src/lib.js` 中的 `maxAge` 属性设置——它应该与
    FastAPI 从后端提供的 `jwt` 持续时间相匹配。该应用程序故意缺少用户注册功能，因为想法是有几个员工——可以通过 API 直接创建的用户。作为一个练习，您可以编写用户注册页面并使用
    FastAPI 的 `/users/register` 端点。
- en: In the next section, you will finalize the application by creating a private
    page that’s visible only to authenticated users and will allow only salespeople
    to insert new cars.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将通过创建一个仅对认证用户可见且仅允许销售人员插入新汽车的私有页面来最终完成应用程序。
- en: Implementing the new car page
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现新汽车页面
- en: In this section, you will create the form for inserting new cars. You will not
    use a form validation library, since that was covered in [*Chapter 8*](B22406_08.xhtml#_idTextAnchor137),
    *Building the Frontend of the Application*, with the Zod library. In a realistic
    application, the form would definitely have a similar type of validation. You
    will create a new Server Action for performing the POST API call and again use
    `useFormState`—the same pattern that you used for logging the users in.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，您将创建插入新汽车的表单。您将不会使用表单验证库，因为这在[*第8章*](B22406_08.xhtml#_idTextAnchor137)中已经介绍过，即使用
    Zod 库构建应用程序的前端。在实际应用中，表单肯定会有类似类型的验证。您将创建一个新的服务器操作来执行 POST API 调用，并再次使用 `useFormState`——这是您用于登录用户的相同模式。 '
- en: 'As the form for inserting cars contains a lot of fields (and there could be
    many, many more), you will start by abstracting the form field into a separate
    component. The implementation of the new car advert creation will be broken into
    the following steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于插入汽车的表单包含许多字段（并且可能会有更多），您将首先将表单字段抽象成一个单独的组件。新汽车广告创建的实现将分为以下步骤：
- en: 'Create a new `Field` component in a file named `/src/components/InputField.js`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `/src/components/InputField.js` 的文件中创建一个新的 `Field` 组件：
- en: '[PRE34]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With `InputField` now out of the way, create `CarForm`.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在 `InputField` 已经处理完毕，创建 `CarForm`。
- en: 'Create a new component in the `/src/components/CarForm.js` file and begin with
    the imports and the array of fields that will be needed:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/src/components/CarForm.js` 文件中创建一个新的组件，并从导入和所需字段的数组开始：
- en: '[PRE35]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The component uses the `useFormState` hook; you already know that it needs to
    be a client component.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该组件使用 `useFormState` 钩子；您已经知道它需要一个客户端组件。
- en: 'The rest of the component is just a mapping over the `fields` array and the
    implementation of the hook:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件的其余部分只是对 `fields` 数组的映射和钩子的实现：
- en: '[PRE36]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The form uses the `createCar` action that you will be defining in the `actions.js`
    file in a future step.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表单使用 `createCar` 动作，您将在后续步骤中定义该动作的 `actions.js` 文件。
- en: 'The form needs to be displayed on the private page, so edit the `/``src/app/private/page.js`
    file:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单需要在私有页面上显示，因此编辑 `/src/app/private/page.js` 文件：
- en: '[PRE37]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The form is created, and it is displayed on the `/private` page. The only thing
    that is missing is the corresponding action, which you will create in the next
    step.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表单已创建，并在 `/private` 页面上显示。唯一缺少的是相应的动作，您将在下一步中创建。
- en: 'Open the `/src/actions.js` file and add the following action to the end of
    the file for creating a new car:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `/src/actions.js` 文件，并在文件末尾添加以下动作以创建新汽车：
- en: '[PRE38]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The action is straightforward—that is the beauty of Server Actions. It is just
    a function that checks the session and `jwt` and performs the `API POST` request.
    The function should also include an earlier redirect to the login page in case
    `jwt` is not found, but this way, you let the `useFormState` hook display any
    errors coming from the backend.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 动作很简单——这就是服务器动作的美丽之处。它只是一个检查会话和 `jwt` 并执行 `API POST` 请求的函数。该函数还应包括在找不到 `jwt`
    的情况下将用户重定向到登录页面的早期重定向，但这样您可以让 `useFormState` 钩子显示来自后端的任何错误。
- en: You have implemented the website specification—users are able to log in and
    insert new cars and, after the period of revalidation (15-20 seconds), the cars
    are displayed on the `/car` page as well as on the dedicated page for the newly
    inserted car.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您已实现了网站规范——用户能够登录并插入新汽车，在重新验证期（15-20秒）后，汽车将在 `/car` 页面以及新插入汽车的专用页面上显示。
- en: In the next section, you will deploy your application to Netlify and learn how
    to streamline the process, while providing environment variables and configuring
    settings for a deployment.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将部署您的应用程序到 Netlify，并学习如何简化流程，同时提供环境变量并配置部署设置。
- en: Providing metadata
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供元数据
- en: One of the main features of Next.js is the ability to provide better **search
    engine optimization** (**SEO**) than SPAs. While generating static content that
    is easily picked up by crawlers is important, providing useful page metadata is
    essential.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 的一个主要特性是提供比 SPAs 更好的 **搜索引擎优化**（**SEO**）。虽然生成易于爬虫抓取的静态内容很重要，但提供有用的页面元数据是至关重要的。
- en: Metadata is an important feature of every web application or site, and Next.js
    solves this problem in an elegant way with the `Metadata` component. Metadata
    enables direct communication with search engines (such as Google), providing precise
    information about the site’s content, title, and description, as well as page-specific
    information.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据是每个网络应用程序或网站的重要特性，Next.js 通过 `Metadata` 组件以优雅的方式解决了这个问题。元数据使与搜索引擎（如 Google）的直接通信成为可能，提供有关网站内容、标题和描述的精确信息，以及页面特定的信息。
- en: 'In this brief section, you will learn how to set the title tags of pages. The
    Next.js documentation is very detailed ([https://nextjs.org/docs/app/building-your-application/optimizing/metadata](https://nextjs.org/docs/app/building-your-application/optimizing/metadata))
    and explains the various pieces of information that can be set, but in this case,
    you are only going to set the page titles:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何设置页面的标题标签。Next.js 文档非常详细（[https://nextjs.org/docs/app/building-your-application/optimizing/metadata](https://nextjs.org/docs/app/building-your-application/optimizing/metadata)），并解释了可以设置的各种信息片段，但在此情况下，您只需设置页面标题：
- en: 'Open the `src/app/layout.js` page and edit the `metadata` part:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/app/layout.js` 页面并编辑 `metadata` 部分：
- en: '[PRE39]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This simple change will cause all the pages within the layout to have the newly
    set title and description. Since you have edited the `Root` layout, which encloses
    all the pages, this means that every page on the website will be affected. These
    can be overridden on a per-page basis.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个简单的更改将导致布局内的所有页面都拥有新设置的标题和描述。由于您已编辑包含所有页面的 `Root` 布局，这意味着网站上的每个页面都将受到影响。这些可以在每个页面上进行覆盖。
- en: 'Open `/src/app/cars/[id]/page.js` for the individual cars page and add the
    following export:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `/src/app/cars/[id]/page.js` 以访问单个汽车页面，并添加以下导出：
- en: '[PRE40]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding export signals to Next.js that only these pages should have the
    title that is returned from the function, while the other pages will have the
    unaltered title.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述导出向 Next.js 传达了只有这些页面应该有从函数返回的标题，而其他页面将保留未更改的标题。
- en: You have successfully edited the pages’ metadata, and now it is time to deploy
    the application on the internet, which the next section will detail.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功编辑了页面的元数据，现在是时候将应用程序部署到互联网上了，下一节将详细介绍。
- en: Deployment on Netlify
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netlify部署
- en: Next.js is arguably the most popular full-stack and frontend framework, and
    there is a plethora of deployment options.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js可以说是最受欢迎的全栈和前端框架，并且有大量的部署选项。
- en: In this section, you will learn how to deploy your Next.js application on Netlify—one
    of the most popular web platforms for deployment, content orchestration, continuous
    integration, and much more.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在Netlify上部署你的Next.js应用程序——Netlify是最受欢迎的用于部署、内容编排、持续集成等功能的Web平台之一。
- en: In order to deploy your website on Netlify, you will need to deploy the FastAPI
    backend. If you haven’t already done so, please refer to [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118),
    *Building a Backend with FastAPI*, on how to do that. Once you have the backend
    address (in your example, the URL of the deployed FastAPI application is [https://chapter9backend2ed.onrender.com](https://chapter9backend2ed.onrender.com)),
    it will be used as the API URL for the Next.js frontend.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Netlify上部署你的网站，你需要部署FastAPI后端。如果你还没有这样做，请参考[*第7章*](B22406_07.xhtml#_idTextAnchor118)，*使用FastAPI构建后端*，了解如何进行操作。一旦你有了后端地址（在你的例子中，部署的FastAPI应用程序的URL是[https://chapter9backend2ed.onrender.com](https://chapter9backend2ed.onrender.com)），它将被用作Next.js前端的API
    URL。
- en: 'In order to perform the deployment to Netlify, perform the following steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行Netlify的部署，请执行以下步骤：
- en: '**Create a Netlify account**: Log in with your GitHub account and create a
    free Netlify account, since Netlify will pick your code from the repository that
    you will make for the Next.js app.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建Netlify账户**：使用GitHub账户登录并创建一个免费的Netlify账户，因为Netlify将从你为Next.js应用程序创建的仓库中提取代码。'
- en: '**Create a GitHub repository**: In order to be able to deploy to Netlify (or
    Vercel for that matter), you will need to create a GitHub repository for your
    Next.js project.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建GitHub仓库**：为了能够部署到Netlify（或者Vercel），你需要为你的Next.js项目创建一个GitHub仓库。'
- en: 'To create a GitHub repository, implement the following steps:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建GitHub仓库，请执行以下步骤：
- en: 'In your terminal, enter the project folder and type the following:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端中，进入项目文件夹并输入以下命令：
- en: '[PRE41]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This command adds the modified and newly created files to the repository.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将修改后的和新创建的文件添加到仓库中。
- en: 'Next, commit the changes:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，提交更改：
- en: '[PRE42]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that your project is under version control, create a new repository in your
    GitHub account and choose an appropriate name. In your case, the repository is
    named `chapter10frontend`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你的项目已置于版本控制之下，在你的GitHub账户中创建一个新的仓库并选择一个合适的名称。在你的情况下，仓库被命名为`chapter10frontend`。
- en: Pushing the changes to GitHub
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送更改到GitHub
- en: 'Now you can add the new origin to your local repository. In the same terminal
    inside the project, type the following commands:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将新的源添加到你的本地仓库。在项目中的同一终端内，输入以下命令：
- en: 'First, set the name of the branch to `main`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将分支名称设置为`main`：
- en: '[PRE43]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, set the origin to the newly created repository:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将源设置为新建的仓库：
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, you need to replace the name of the repository and your username: `(<username>`
    and `<name_of_the_repo>`).'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你需要替换仓库名称和你的用户名：`(<username>`和`<name_of_the_repo>`)。
- en: 'Finally, push the project to GitHub:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将项目推送到GitHub：
- en: '[PRE45]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, you can deploy the repository on Netlify in the following manner:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以以下述方式在Netlify上部署仓库：
- en: '`chapter10frontend` in your case).'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （在你的例子中是`chapter10frontend`）。
- en: '`main` as that is your only branch'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`，因为这是你唯一的分支'
- en: 'Base directory: Leave empty'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基础目录：保持为空
- en: 'Build command: Leave it as `npm` `run build`'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建命令：保持为`npm run build`
- en: 'Publish directory: Leave it as `.next`'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布目录：保持为`.next`
- en: 'Set the only environment variable: Click the `API_URL` and the value will be
    the FastAPI backend URL. If you followed the steps from the previous chapter to
    host your backend on Render, the value will be [https://chapter9backend2ed.onrender.com](https://chapter9backend2ed.onrender.com).'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置唯一的环境变量：点击`API_URL`，其值将是FastAPI后端URL。如果你遵循了上一章中关于在Render上托管后端的步骤，该值将是[https://chapter9backend2ed.onrender.com](https://chapter9backend2ed.onrender.com)。
- en: Hit the **Deploy** (**<name of your** **repo>**) button!
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**部署**（**你的** **repo**）按钮！
- en: After a while, you should have your website deployed to the address indicated
    on the page. Bear in mind, however, that the API must be working, and since the
    free tier of Render.com, for instance (if you used Render as your backend deployment
    option), can take up to a minute to wake up after going stale, be prepared to
    wake up the API. The recommendation is to wait until the backend is responsive—you
    can check it by simply visiting the API address—and then begin the deployment
    process. This way, you will prevent potential deployment and page generation errors.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，你应该能在页面上显示的地址看到你的网站已部署。然而，请注意，API必须处于工作状态，例如，如果你使用Render.com的免费层作为后端部署选项（如果你使用了Render作为后端部署选项），在数据过时后可能需要一分钟才能唤醒，因此请准备好唤醒API。建议等待后端响应——你可以通过简单地访问API地址来检查它——然后开始部署过程。这样，你将防止潜在的部署和页面生成错误。
- en: This is a good moment to analyze the command that you provided to Netlify to
    build the site—the `build` command. If you run `npm run build` in your Next.js
    command line, Next.js performs a series of operations and produces an optimized
    build.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个分析你提供给Netlify以构建网站的命令——`build`命令——的好时机。如果你在Next.js命令行中运行`npm run build`，Next.js将执行一系列操作并生成一个优化的构建。
- en: These operations include code optimizations (such as minification and code splitting),
    the creation of a `.next` directory that contains the optimized, production-ready
    code, and the directory that actually gets served on the internet.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作包括代码优化（如压缩和代码拆分）、创建包含优化、生产就绪代码的`.next`目录，以及实际上在互联网上提供服务的目录。
- en: 'The `build` command also generates the static pages and the route handlers.
    You can test the build after it successfully completes, with the following command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`命令还会生成静态页面和路由处理程序。在成功完成构建后，你可以使用以下命令测试构建：'
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You have now successfully deployed an optimized FastAPI MongoDB-powered Next.js
    website and you are ready to tackle a host of web development tasks with an incredibly
    powerful and flexible stack.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经成功部署了一个优化的、由FastAPI MongoDB驱动的Next.js网站，你准备好使用这个强大且灵活的堆栈来处理大量的Web开发任务了。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned the basics of Next.js, a popular React-based
    full-stack framework that, coupled with FastAPI and MongoDB, allows you to build
    any virtually any type of web application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Next.js的基础知识，这是一个流行的基于React的全栈框架，结合FastAPI和MongoDB，允许你构建几乎任何类型的Web应用程序。
- en: You have learned how to create a new Next.js project, how to implement routing
    with the new App Router, and how to fetch data with server components.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何创建新的Next.js项目，如何使用新的App Router实现路由，以及如何使用服务器组件获取数据。
- en: Important Next.js concepts, such as Server Actions, form handling, and cookies
    were also introduced and implemented. Apart from this, you explored some of the
    Next.js optimizations such as the `Image` component for serving optimized images,
    the `Metadata` tags, and how to create a production build.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 还介绍了并实现了重要的Next.js概念，如服务器操作、表单处理和cookies。除此之外，你还探索了一些Next.js优化，例如用于提供优化图像的`Image`组件、`Metadata`标签以及如何创建生产构建。
- en: Finally, you deployed your Next.js application on Netlify, but the underlying
    principles of deployment remain the same for other providers.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你在Netlify上部署了你的Next.js应用程序，但其他提供者的部署基本原理仍然相同。
- en: 'Next.js is a rich and complex ecosystem in its own right, and you should consider
    this chapter as a starting point for your next application, which blends the best
    of the three worlds: FastAPI, MongoDB, and React, with the addition of external
    third-party services that your application might need.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js本身就是一个丰富且复杂的生态系统，你应该将本章视为你下一个应用的起点，该应用融合了三个世界的最佳之处：FastAPI、MongoDB和React，并添加了应用程序可能需要的第三方外部服务。
- en: The next chapter will share some practical advice for you while working with
    the FARM stack, along with project ideas that can help you get started right away.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将分享一些在实际使用FARM堆栈时对你有帮助的实用建议，以及一些可以帮助你立即开始的项目想法。
