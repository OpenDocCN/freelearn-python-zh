- en: Chapter 1. Introduction to Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 设计模式简介
- en: 'In this chapter, we will go through the basics of object-oriented programming
    and discuss the object-oriented design principles in detail. This will get us
    prepared for the advanced topics covered later in the book. This chapter will
    also give a brief introduction to the concept of design patterns so that you will
    be able to appreciate the context and application of design patterns in software
    development. Here we also classify the design patterns under three main aspects—creational,
    structural, and Behavioral patterns. So, essentially, we will cover the following
    topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍面向对象编程的基础，并详细讨论面向对象设计原则。这将为我们准备书中后面章节涉及的高级主题。本章还将简要介绍设计模式的概念，以便您能够欣赏设计模式在软件开发中的背景和应用。在这里，我们也将设计模式分为三个主要方面——创建型模式、结构型模式和和行为型模式。因此，本质上，本章将涵盖以下内容：
- en: Understanding object-oriented programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解面向对象编程
- en: Discussing object-oriented design principles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论面向对象设计原则
- en: Understanding the concept of design patterns and their taxonomy and context
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设计模式及其分类和背景的概念
- en: Discussing patterns for dynamic languages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论动态语言的模式
- en: Classifying patterns—creational pattern, structural pattern, and behavioral
    pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对模式进行分类——创建型模式、结构型模式和和行为型模式
- en: Understanding object-oriented programming
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向对象编程
- en: Before you start learning about design patterns, it's always good to cover the
    basics and go through object-oriented paradigms in Python. The object-oriented
    world presents the concept of *objects* that have attributes (data members) and
    procedures (member functions). These functions are responsible for manipulating
    the attributes. For instance, take an example of the `Car` object. The `Car` object
    will have attributes such as `fuel level`, `isSedan`, `speed`, and `steering wheel`
    and `coordinates`, and the methods would be `accelerate()` to increase the speed
    and `takeLeft()` to make the car turn left. Python has been an object-oriented
    language since it was first released. As they say, *everything in Python is an
    object*. Each class instance or variable has its own memory address or identity.
    Objects, which are instances of classes, interact among each other to serve the
    purpose of an application under development. Understanding the core concepts of
    object-oriented programming involves understanding the concepts of objects, classes,
    and methods.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始学习设计模式之前，了解基础知识并熟悉Python中的面向对象范式总是好的。面向对象的世界提出了具有属性（数据成员）和程序（成员函数）的*对象*概念。这些函数负责操作属性。例如，以`Car`对象为例。`Car`对象将具有`fuel
    level`（燃油水平）、`isSedan`（是否为轿车）、`speed`（速度）和`steering wheel`（方向盘）以及`coordinates`（坐标）等属性，方法包括`accelerate()`（加速）以增加速度和`takeLeft()`（向左转）以使汽车向左转。Python自从首次发布以来就是面向对象的编程语言。正如他们所说，*Python中的万物都是对象*。每个类实例或变量都有自己的内存地址或标识符。作为类的实例，对象之间相互交互，以服务于正在开发的应用程序。理解面向对象编程的核心概念涉及理解对象、类和方法的概念。
- en: Objects
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'The following points describe objects:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点描述对象：
- en: They represent entities in your application under development.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们代表您正在开发的应用程序中的实体。
- en: Entities interact among themselves to solve real-world problems.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体之间相互交互以解决现实世界问题。
- en: For example, Person is an entity and Car is an entity. Person drives Car to
    move from one location to the other.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，Person是一个实体，Car也是一个实体。Person驾驶Car从一个地点移动到另一个地点。
- en: Classes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'Classes help developers to represent real-world entities:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类帮助开发者表示现实世界实体：
- en: Classes define objects in attributes and behaviors. Attributes are data members
    and behaviors are manifested by the member functions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类通过属性和行为定义对象。属性是数据成员，行为通过成员函数体现
- en: Classes consist of constructors that provide the initial state for these objects
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类由构造函数组成，这些构造函数为这些对象提供初始状态
- en: Classes are like templates and hence can be easily reused
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类就像模板，因此可以很容易地重用
- en: For example, class `Person` will have attributes `name` and `age` and member
    function `gotoOffice()` that defines his behavior for travelling to office for
    work.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Person`类将具有`name`（姓名）和`age`（年龄）属性以及`gotoOffice()`（去办公室）成员函数，该函数定义了他去办公室工作的行为。
- en: Methods
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'The following points talk about what methods do in the object-oriented world:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点讨论面向对象世界中方法的作用：
- en: They represent the behavior of the object
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们代表对象的行为
- en: Methods work on attributes and also implement the desired functionality
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法在属性上工作，并实现所需的功能
- en: 'A good example of a class and object created in Python v3.5 is given here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了在 Python v3.5 中创建的一个类和对象的良好示例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code should look as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出应该如下所示：
- en: '![Methods](img/00002.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![方法](img/00002.jpeg)'
- en: Major aspects of object-oriented programming
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程的主要方面
- en: Now that we have understood the basics of object-oriented programming, let's
    dive into the major aspects of OOP.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了面向对象编程的基础，让我们深入了解面向对象编程的主要方面。
- en: Encapsulation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: 'The key features of encapsulation are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的关键特性如下：
- en: An object's behavior is kept hidden from the outside world or objects keep their
    state information private.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的行为对外部世界或对象保持隐藏，或者对象保持其状态信息私有。
- en: Clients can't change the object's internal state by directly acting on them;
    rather, clients request the object by sending messages. Based on the type of requests,
    objects may respond by changing their internal state using special member functions
    such as `get` and `set`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端不能通过直接作用于对象来改变对象的内部状态；相反，客户端通过发送消息来请求对象。根据请求的类型，对象可能会通过使用特殊的成员函数（如 `get`
    和 `set`）来改变其内部状态。
- en: In Python, the concept of encapsulation (data and method hiding) is not implicit,
    as it doesn't have keywords such as **public**, **private**, and **protected**
    (in languages such as C++ or Java) that are required to support encapsulation.
    Of course, accessibility can be made private by prefixing `__` in the variable
    or function name.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中，封装（数据和方法隐藏）的概念不是隐式的，因为它没有像 C++ 或 Java 这样的语言中所需的 **public**、**private**
    和 **protected** 等关键字来支持封装。当然，可以通过在变量或函数名前加 `__` 来使访问性变为私有。
- en: Polymorphism
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态
- en: 'The major features of polymorphism are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 多态的主要特性如下：
- en: 'Polymorphism can be of two types:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态可以是两种类型：
- en: An object provides different implementations of the method based on input parameters
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象根据输入参数提供方法的不同实现
- en: The same interface can be used by objects of different types
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个接口可以被不同类型的对象使用
- en: In Python, polymorphism is a feature built-in for the language. For example,
    the `+` operator can act on two integers to add them or can work with strings
    to concatenate them
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中，多态是语言内置的特性。例如，`+` 运算符可以对两个整数进行相加，也可以用于字符串的连接。
- en: 'In the following example, strings, tuples, or lists can all be accessed with
    an integer index. This shows how Python demonstrates polymorphism in built-in
    types:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，字符串、元组或列表都可以使用整数索引进行访问。这展示了 Python 如何在内置类型中演示多态：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inheritance
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'The following points help us understand the inheritance process better:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点有助于我们更好地理解继承过程：
- en: Inheritance indicates that one class derives (most of its) functionality from
    the parent class.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承表示一个类从父类继承（大部分）功能。
- en: Inheritance is described as an option to reuse functionality defined in the
    base class and allow independent extensions of the original software implementation.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承被描述为一种重用基类中定义的功能的选项，并允许独立扩展原始软件实现。
- en: Inheritance creates hierarchy via the relationships among objects of different
    classes. Python, unlike Java, supports multiple inheritance (inheriting from multiple
    base classes).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承通过不同类对象之间的关系创建层次结构。Python 与 Java 不同，支持多重继承（从多个基类继承）。
- en: 'In the following code example, `class A` is the base class and `class B` derives
    its features from `class A`. So, the methods of `class A` can be accessed by the
    object of `class B`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，`class A` 是基类，`class B` 从 `class A` 继承其特性。因此，`class A` 的方法可以通过 `class
    B` 的对象访问：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Abstraction
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: 'The key features of abstraction are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的关键特性如下：
- en: It provides you with a simple interface to the clients, where the clients can
    interact with class objects and call methods defined in the interface
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为客户端提供了一个简单的接口，客户端可以通过这个接口与类对象交互并调用接口中定义的方法。
- en: It abstracts the complexity of internal classes with an interface so that the
    client need not be aware of internal implementations
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过接口抽象了内部类的复杂性，这样客户端就不必了解内部实现。
- en: 'In the following example, internal details of the `Adder` class are abstracted
    with the `add()` method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`Adder` 类的内部细节通过 `add()` 方法进行了抽象：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Composition
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: 'Composition refers to the following points:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 组合指的是以下要点：
- en: It is a way to combine objects or classes into more complex data structures
    or software implementations
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种将对象或类组合成更复杂的数据结构或软件实现的方法
- en: In composition, an object is used to call member functions in other modules
    thereby making base functionality available across modules without inheritance
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组合中，一个对象用于调用其他模块中的成员函数，从而在不使用继承的情况下使基本功能在模块间可用
- en: 'In the following example, the object of `class A` is composited under `class
    B`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`class A` 的对象被组合到 `class B` 中：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Object-oriented design principles
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象设计原则
- en: Now, let's talk about another set of concepts that are going to be crucial for
    us. These are nothing but the object-oriented design principles that will act
    as a toolbox for us while learning design patterns in detail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈另一组对我们至关重要的概念。这些概念不过是面向对象的设计原则，它们将作为我们在详细学习设计模式时的工具箱。
- en: The open/close principle
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放/关闭原则
- en: The open/close principle states that *classes or objects and methods should
    be open for extension but closed for modifications*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 开放/关闭原则指出，“类或对象和方法应该对扩展开放，但对修改关闭。”
- en: What this means in simple language is, when you develop your software application,
    make sure that you write your classes or modules in a generic way so that whenever
    you feel the need to extend the behavior of the class or object, then you shouldn't
    have to change the class itself. Rather, a simple extension of the class should
    help you build the new behavior.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话来说，这意味着当你开发软件应用程序时，确保你以通用方式编写你的类或模块，这样当你觉得需要扩展类或对象的行为时，你就不需要更改类本身。相反，对类的简单扩展应该帮助你构建新的行为。
- en: For example, the open/close principle is manifested in a case where a user has
    to create a class implementation by extending the abstract base class to implement
    the required behavior instead of changing the abstract class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，开放/关闭原则在用户必须通过扩展抽象基类来创建类实现以实现所需行为而不是更改抽象类的情况下体现出来。
- en: 'Advantages of this design principle are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计原则的优势如下：
- en: Existing classes are not changed and hence the chances of regression are less
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的类不会被修改，因此回归的风险较低
- en: It also helps maintain backward compatibility for the previous code
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还有助于保持先前代码的向后兼容性
- en: The inversion of control principle
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制反转原则
- en: The inversion of control principle states that *high-level modules shouldn't
    be dependent on low-level modules; they should both be dependent on abstractions.
    Details should depend on abstractions and not the other way round*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转原则指出，“高级模块不应该依赖于低级模块；它们都应该依赖于抽象。细节应该依赖于抽象，而不是相反。”
- en: This principle suggests that any two modules shouldn't be dependent on each
    other in a tight way. In fact, the base module and dependent module should be
    decoupled with an abstraction layer in between.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此原则建议，任何两个模块都不应该紧密依赖于对方。事实上，基础模块和依赖模块应该通过中间的抽象层解耦。
- en: This principle also suggests that the details of your class should represent
    the abstractions. In some cases, the philosophy gets inverted and implementation
    details itself decide the abstraction, which should be avoided.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此原则还建议，你类的细节应该代表抽象。在某些情况下，哲学被颠倒了，实现细节本身决定了抽象，这应该避免。
- en: 'Advantages of the inversion of control principle are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转原则的优势如下：
- en: The tight coupling of modules is no more prevalent and hence no complexity/rigidity
    in the system
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的紧密耦合不再普遍，因此系统中没有复杂性/刚性
- en: As there is a clear abstraction layer between dependent modules (provided by
    a hook or parameter), it's easy to deal with dependencies across modules in a
    better way
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于存在清晰的抽象层（由钩子或参数提供），因此更容易以更好的方式处理模块间的依赖关系
- en: The interface segregation principle
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: As the interface segregation principle states, *clients should not be forced
    to depend on interfaces they don't use*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如接口隔离原则所指出，“客户端不应该被迫依赖于它们不使用的接口。”
- en: This principle talks about software developers writing their interfaces well.
    For instance, it reminds the developers/architects to develop methods that relate
    to the functionality. If there is any method that is not related to the interface,
    the class dependent on the interface has to implement it unnecessarily.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则讨论的是软件开发者如何编写良好的接口。例如，它提醒开发者/架构师开发与功能相关的函数。如果有任何与接口无关的函数，依赖于接口的类就必须不必要地实现它。
- en: For example, a `Pizza` interface shouldn't have a method called `add_chicken()`.
    The `Veg Pizza` class based on the `Pizza` interface shouldn't be forced to implement
    this method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`Pizza`接口不应该有一个名为`add_chicken()`的方法。基于`Pizza`接口的`Veg Pizza`类不应该被迫实现这个方法。
- en: 'Advantages of this design principle are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计原则的优点如下：
- en: It forces developers to write thin interfaces and have methods that are specific
    to the interface
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它迫使开发者编写瘦接口，并拥有特定于接口的方法
- en: It helps you not to populate interfaces by adding unintentional methods
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助您不要通过添加无意的方法来填充接口
- en: The single responsibility principle
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: As the single responsibility principle states, *a class should have only one
    reason to change*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如单一职责原则所阐述的，*一个类应该只有一个改变的理由*。
- en: This principle says that when we develop classes, it should cater to the given
    functionality well. If a class is taking care of two functionalities, it is better
    to split them. It refers to functionality as a reason to change. For example,
    a class can undergo changes because of the difference in behavior expected from
    it, but if a class is getting changed for two reasons (basically, changes in two
    functionalities), then the class should be definitely split.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则说，当我们开发类时，它应该很好地满足给定的功能。如果一个类负责两个功能，最好是将其拆分。它将功能视为改变的理由。例如，一个类可能因为期望的行为差异而发生变化，但如果一个类因为两个原因（基本上，两个功能的变化）而发生变化，那么这个类肯定应该被拆分。
- en: 'Advantages of this design principle are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计原则的优点如下：
- en: Whenever there is a change in one functionality, this particular class needs
    to change, and nothing else
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当有一个功能发生变化时，这个特定的类就需要改变，其他什么也不需要
- en: Additionally, if a class has multiple functionalities, the dependent classes
    will have to undergo changes for multiple reasons, which gets avoided
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，如果一个类有多个功能，依赖于这个类的其他类将不得不因为多个原因进行更改，这可以避免
- en: The substitution principle
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换原则
- en: The substitution principle states that *derived classes must be able to completely
    substitute the base classes*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 替换原则指出，*派生类必须能够完全替换基类*。
- en: This principle is pretty straightforward in the sense that it says when application
    developers write derived classes, they should extend the base classes. It also
    suggests that the derived class should be as close to the base class as possible
    so much so that the derived class itself should replace the base class without
    any code changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则在意义上非常直接，它说当应用程序开发者编写派生类时，他们应该扩展基类。它还建议派生类应该尽可能接近基类，以至于派生类本身应该能够在不进行任何代码更改的情况下替换基类。
- en: The concept of design patterns
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式的概念
- en: Finally, now is the time that we start talking about design patterns! What are
    design patterns?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在是我们开始讨论设计模式的时候了！什么是设计模式？
- en: 'Design patterns were first introduced by **GoF** (**Gang of Four**), where
    they mentioned them as being solutions to given problems. If you would like to
    know more, GoF refers to the four authors of the book, *Design Patterns: Elements
    of Reusable Object-Oriented Software*. The book''s authors are *Erich Gamma*,
    *Richard Helm*, *Ralph Johnson*, and *John Vlissides*, with a foreword by *Grady
    Booch*. This book covers software engineering solutions to the commonly occurring
    problems in software design. There were 23 design patterns first identified, and
    the first implementation was done with respect to the Java program language. Design
    patterns are discoveries and not an invention in themselves.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式最初是由**GoF**（**四人帮**）引入的，他们将它们描述为给定问题的解决方案。如果您想了解更多信息，GoF指的是书籍《设计模式：可复用面向对象软件元素》的四个作者，*Erich
    Gamma*，*Richard Helm*，*Ralph Johnson*，和*John Vlissides*，由*Grady Booch*撰写序言。这本书涵盖了软件工程在软件设计中的常见问题解决方案。最初确定了23个设计模式，第一个实现是针对Java程序语言的。设计模式是发现，而不是发明本身。
- en: 'The key features of design patterns are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的关键特性如下：
- en: They are language-neutral and can be implemented across multiple languages
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是语言无关的，可以在多种语言中实现
- en: They are dynamic, as new patterns get introduced every now and then
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是动态的，因为不时会引入新的模式
- en: They are open for customization and hence useful for developers
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是可定制的，因此对开发者很有用
- en: 'Initially, when you hear about design patterns, you may feel the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，当你听到设计模式时，你可能会有以下感觉：
- en: It's a panacea to all the design problems that you've had so far
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是解决你迄今为止遇到的所有设计问题的万能药
- en: It's an extraordinary, specially clever way of solving a problem
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一种解决问题的非常巧妙、特别的方法
- en: Many experts in software development world agree to these solutions
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发世界的许多专家都同意这些解决方案
- en: There's something repeatable about the design, hence the word pattern
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计中存在某种可重复性，因此有“模式”这个词
- en: You too must have attempted to solve the problems that a design patterns intends
    to, but maybe your solution was incomplete, and the completeness that we're looking
    for is inherent or implicit in the design pattern. When we say completeness, it
    can refer to many factors such as the design, scalability, reuse, memory utilization,
    and others. Essentially, a design pattern is about learning from others' successes
    rather than your own failures!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你也一定尝试过解决设计模式试图解决的问题，但也许你的解决方案是不完整的，而我们寻求的完整性是设计模式中固有的或隐含的。当我们说完整性时，它可以指许多因素，如设计、可扩展性、重用、内存利用等。本质上，设计模式是关于从他人的成功中学习，而不是从自己的失败中学习！
- en: Another interesting discussion that comes up on design patterns is—when do I
    use them? Is it in the analysis or design phase of **Software Development Life
    Cycle** (**SDLC**)?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设计模式的另一个有趣讨论是——我何时使用它们？是在软件开发生命周期（**SDLC**）的分析或设计阶段吗？
- en: Interestingly, design patterns are solutions to known issues. So they can be
    very much used in analysis or design, and as expected, in the development phase
    because of the direct relation in the application code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，设计模式是已知问题的解决方案。因此，它们可以在分析或设计阶段非常广泛地使用，并且由于与应用程序代码的直接关系，在开发阶段也可以预期使用。
- en: Advantages of design patterns
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式的优势
- en: 'The advantages of design patterns are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的优势如下：
- en: They are reusable across multiple projects
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在多个项目中重用
- en: The architectural level of problems can be solved
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以解决架构级别的问题
- en: They are time-tested and well-proven, which is the experience of developers
    and architects
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是经过时间考验和充分验证的，这是开发者和架构师的经验
- en: They have reliability and dependence
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有可靠性和依赖性
- en: Taxonomy of design patterns
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式的分类
- en: 'Not every piece of code or design can be termed as a design pattern. For example,
    a programming construct or data structure that solves one problem can''t be termed
    as a pattern. Let''s understand terms in a very simplistic way below:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每一块代码或设计都可以称为设计模式。例如，解决一个问题的编程结构或数据结构不能称为模式。以下以非常简单的方式理解这些术语：
- en: '**Snippet**: This is code in some language for a certain purpose, for example,
    DB connectivity in Python can be a code snippet'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码片段**：这是为特定目的编写的某些语言的代码，例如，Python中的数据库连接可以是一个代码片段。'
- en: '**Design**: A better solution to solve this particular problem'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计**：这是解决这个特定问题的更好方案'
- en: '**Standard**: This is a way to solve some kind of problems, and can be very
    generic and applicable to a situation at hand'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准**：这是一种解决某些问题的方法，可以非常通用，适用于当前的情况'
- en: '**Pattern**: This is a time-tested, efficient, and scalable solution that will
    resolve the entire class of known issues'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式**：这是一个经过时间考验、高效且可扩展的解决方案，将解决整个已知问题类别'
- en: Context – the applicability of design patterns
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**上下文** – 设计模式的适用性'
- en: 'To use design patterns efficiently, application developers must be aware of
    the context where design patterns apply. We can classify the context into the
    following main categories:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用设计模式，应用程序开发者必须了解设计模式适用的上下文。我们可以将这些上下文分为以下主要类别：
- en: '**Participants**: They are classes that are used in design patterns. Classes
    play different roles to accomplish multiple goals in the pattern.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参与者**：它们是在设计模式中使用的类。类在模式中扮演不同的角色，以实现多个目标。'
- en: '**Non-functional requirements**: Requirements such as memory optimization,
    usability, and performance fall under this category. These factors impact the
    complete software solution and are thus critical.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能性需求**：如内存优化、可用性和性能等需求属于此类。这些因素影响整个软件解决方案，因此至关重要。'
- en: '**Trade-offs**: Not all design patterns fit in application development as it
    is, and trade-offs are necessary. These are decisions that you take while using
    a design pattern in an application.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权衡**：并非所有设计模式都适合直接应用于应用开发，权衡是必要的。这些是在使用设计模式时所做的决策。'
- en: '**Results**: Design patterns can have a negative impact on other parts of the
    code if the context is not appropriate. Developers should understand the consequences
    and use of design patterns.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：如果上下文不适当，设计模式可能会对代码的其他部分产生负面影响。开发者应该了解后果和使用设计模式。'
- en: Patterns for dynamic languages
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态语言的模式
- en: 'Python is a dynamic language like Lisp. The dynamic nature of Python can be
    represented as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种像Lisp一样的动态语言。Python的动态特性可以表示如下：
- en: Types or classes are objects at runtime.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型或类在运行时是对象。
- en: Variables can have type as a value and can be modified at runtime. For example,
    `a = 5` and `a = "John"`, the `a` variable is assigned at runtime and type also
    gets changed.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量可以作为值具有类型，并且可以在运行时修改。例如，`a = 5`和`a = "John"`，变量`a`在运行时被分配，类型也发生了变化。
- en: Dynamic languages have more flexibility in terms of class restrictions.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态语言在类限制方面具有更多灵活性。
- en: For example, in Python, polymorphism is built into the language, there are no
    keywords such as `private` and `protected` and everything is public by default.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，在Python中，多态是语言内置的，没有像`private`和`protected`这样的关键字，默认情况下一切都是公开的。
- en: Represents a case where design patterns can be easily implemented in dynamic
    languages.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表了设计模式在动态语言中易于实现的情况。
- en: Classifying patterns
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式分类
- en: 'The book by GoF on design patterns spoke about 23 design patterns and classified
    them under three main categories:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GoF关于设计模式的书籍讨论了23种设计模式，并将它们分为三大类：
- en: Creational patterns
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型模式
- en: Structural patterns
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构型模式
- en: Behavioral patterns
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为型模式
- en: The classification of patterns is done based primarily on how the objects get
    created, how classes and objects are structured in a software application, and
    also covers the way objects interact among themselves. Let's talk about each of
    the categories in detail in this section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的分类主要基于对象是如何被创建的，如何在软件应用程序中组织类和对象，以及对象之间相互交互的方式。让我们在本节中详细讨论每个类别。
- en: 'Creational patterns:'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建型模式：
- en: 'The following are the properties of Creational patterns:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建型模式的特性：
- en: They work on the basis of how objects can be created
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们基于对象如何被创建的原则工作
- en: They isolate the details of object creation
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们隔离了对象创建的细节
- en: Code is independent of the type of object to be created
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码独立于要创建的对象类型
- en: An example of a creational pattern is the Singleton pattern.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式的一个例子是单例模式。
- en: Structural patterns
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构型模式
- en: 'The following are the properties of Structural patterns:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构型模式的特性：
- en: They design the structure of objects and classes so that they can compose to
    achieve larger results
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们设计对象和类的结构，以便它们可以组合以实现更大的结果
- en: The focus is on simplifying the structure and identifying the relationship between
    classes and objects
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重点在于简化结构和识别类与对象之间的关系
- en: They focus on class inheritance and composition
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们关注类继承和组合
- en: An example of a behavior pattern is the Adapter pattern.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 行为型模式的一个例子是适配器模式。
- en: Behavioral patterns
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为型模式
- en: 'The following are the properties of Behavioral patterns:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是行为型模式的特性：
- en: They are concerned with the interaction among objects and responsibility of
    objects
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们关注对象之间的交互和对象的责任
- en: Objects should be able to interact and still be loosely coupled
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象应该能够交互，同时仍然保持松散耦合
- en: An example of a behavioral pattern is the Observer pattern.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 行为型模式的一个例子是观察者模式。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned about the basic concepts of object-oriented programming,
    such as objects, classes, variables, and features such as polymorphism, inheritance,
    and abstraction with code examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了面向对象编程的基本概念，例如对象、类、变量，以及代码示例中的多态、继承和抽象等特性。
- en: We are also now aware of object-oriented design principles that we, as developers/architects,
    should consider while designing an application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也意识到，作为开发者/架构师，在设计应用程序时，我们应该考虑面向对象设计原则。
- en: Finally, we went on to explore more about design patterns and their applications
    and context in which they can be applied and also discussed their classifications.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们继续探索设计模式及其应用和它们可以应用的上下文，并讨论了它们的分类。
- en: At the end of this chapter, we're now ready to take the next step and study
    design patterns in detail.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们现在已经准备好迈出下一步，详细研究设计模式。
