- en: Chapter 5. Fun with E-mails
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。电子邮件的乐趣
- en: E-mail communication has become a primary mode of information exchange over
    last couple of decades. You work with e-mails on a daily basis and for multiple
     reasons. But did it ever strike that you could manipulate your inbox with Python?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几十年中，电子邮件已成为信息交换的主要模式。您每天都会处理电子邮件，出于多种原因。但您是否曾想过可以用Python操作您的收件箱？
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Sending e-mail messages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件消息
- en: E-mail encryption
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件加密
- en: Beautifying e-mail messages with MIME messages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MIME消息美化电子邮件消息
- en: E-mail messages with attachments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带附件的电子邮件消息
- en: Connecting to your inbox
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到您的收件箱
- en: Fetching and reading e-mail messages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和阅读电子邮件消息
- en: Marking e-mail messages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记电子邮件消息
- en: Clearing up e-mail messages from your inbox
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除收件箱中的电子邮件消息
- en: Automating customer support flows with e-mail responses
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电子邮件响应自动化客户支持流程
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Hello, folks! Hope you're having a great day. In this chapter, we will talk
    about e-mails and the numerous operations we can achieve with e-mails using Python.
    We will also understand ways of automating business processes with e-mails with
    the help of real world business use case.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，朋友们！希望你们今天过得愉快。在本章中，我们将讨论电子邮件以及我们可以使用Python实现的众多电子邮件操作。我们还将通过实际业务用例了解如何利用电子邮件自动化业务流程。
- en: So, what are we waiting for? Let's get started and understand a bit about the
    history of e-mails and its technical implementation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们还在等什么呢？让我们开始，了解一下电子邮件的历史及其技术实现。
- en: E-mails don't need any introduction actually; of course, they're a method of
    exchanging digital messages between computer users. E-mails operate on computer
    networks available over Internet for information exchange. You can log in to your
    favorite e-mail client and start working on your messages stored in the e-mail
    servers. The most widely used web client is Gmail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，电子邮件无需介绍；当然，它们是用户之间交换数字消息的方法。电子邮件在互联网上的计算机网络上进行信息交换。您可以登录您喜欢的电子邮件客户端，开始处理存储在电子邮件服务器上的消息。最广泛使用的网络客户端是Gmail。
- en: E-mails have a very interesting history. In the past, e-mails needed the sender
    and the recipient to be online for the communication to succeed. That didn't make
    much sense, right? Gradually with time, e-mail servers became intelligent and
    started to work on a store-and-forward philosophy. Today, e-mail messages are
    stored asynchronously on the servers so that recipients can view them later at
    their convenience. E-mail servers are thus able to provide facilities such as
    accepting, forwarding, and marking messages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件有着非常有趣的历史。在过去，电子邮件需要发送者和接收者同时在线才能成功进行通信。这难道没有意义吗？随着时间的推移，电子邮件服务器变得智能，开始采用存储和转发哲学。今天，电子邮件消息异步存储在服务器上，以便接收者可以在方便的时候查看。因此，电子邮件服务器能够提供接受、转发和标记消息等服务。
- en: E-mail messages started with ASCII-only characters, which were later extended
    by **Multipurpose Internet Mail Extensions** (**MIME**) for rich text and attachments.
    From a protocols standpoint, e-mails initially worked with the **File Transfer
    Protocol** (**FTP**) to send messages across computers, but as you might be aware,
    **Simple Mail Transfer Protocol** (**SMTP**) is the most widely used protocol
    for working with e-mails.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件最初只使用ASCII字符，后来通过**多用途互联网邮件扩展**（**MIME**）扩展为支持富文本和附件。从协议的角度来看，电子邮件最初使用**文件传输协议**（**FTP**）在计算机之间发送消息，但如您所知，**简单邮件传输协议**（**SMTP**）是目前最广泛使用的电子邮件处理协议。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Please note that setting up of e-mail servers is not covered in this book. If
    you look on the Internet, you'll find many more resources that can help you get
    started. The scope of this chapter is to make you aware of things you can do with
    e-mail using Python programs. We take examples that apply to the Gmail web client
    so that you can try out code examples quickly and get to appreciate the power
    of using Python to automate e-mail tasks without having to set up your own e-mail
    server. While we use Gmail as an example, these snippets will work with any other
    e-mail servers that support SMTP for sending e-mails and IMAP for retrieving e-mails.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本书不涵盖电子邮件服务器的设置。如果你在网上搜索，你会找到更多可以帮助你入门的资源。本章的目的是让你了解使用Python程序可以做什么。我们使用Gmail网络客户端作为例子，这样你可以快速尝试代码示例，并欣赏使用Python自动化电子邮件任务而不必设置自己的电子邮件服务器的强大功能。虽然我们以Gmail为例，但这些代码片段也可以适用于任何其他支持SMTP发送电子邮件和IMAP检索电子邮件的电子邮件服务器。
- en: 'In this chapter, we''ll learn how to work with e-mails using Python. We''ll
    also use multiple Python modules, listed below, to perform various operations
    on e-mail messages:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Python处理电子邮件。我们还将使用以下列出的多个Python模块来对电子邮件消息执行各种操作：
- en: '`smtplib` ([https://docs.python.org/2/library/smtplib.html](https://docs.python.org/2/library/smtplib.html))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smtplib` ([https://docs.python.org/2/library/smtplib.html](https://docs.python.org/2/library/smtplib.html))'
- en: '`email` ([https://docs.python.org/2/library/email.html](https://docs.python.org/2/library/email.html))'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email` ([https://docs.python.org/2/library/email.html](https://docs.python.org/2/library/email.html))'
- en: '`imaplib` ([https://docs.python.org/2/library/imaplib.html](https://docs.python.org/2/library/imaplib.html))'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imaplib` ([https://docs.python.org/2/library/imaplib.html](https://docs.python.org/2/library/imaplib.html))'
- en: '`gmail` ([https://github.com/charlierguo/gmail](https://github.com/charlierguo/gmail))'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gmail` ([https://github.com/charlierguo/gmail](https://github.com/charlierguo/gmail))'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When it comes to working with e-mails using Python , what you need is a module
    that helps you construct messages, a module that can send e-mails, and a module
    that helps retrieve and update messages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用Python处理电子邮件时，你需要的是一个帮助你构建消息的模块，一个可以发送电子邮件的模块，以及一个帮助你检索和更新消息的模块。
- en: Sending e-mail messages
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送电子邮件消息
- en: The first and foremost thing that you may want to achieve with an e-mail client
    is to send a message to your friend's or colleague's e-mail address. Let's go
    ahead and see how we can achieve this in Python.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先想要通过电子邮件客户端实现的是向你的朋友或同事的电子邮件地址发送消息。让我们继续看看在Python中我们如何实现这一点。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to send e-mail messages, we will need to have Python''s `smtplib`
    module. This library, as the name suggests, uses the SMTP protocol to send e-mail
    messages. We can install `smtplib` with our favorite `pip` tool with the following
    command. But Python''s default installation should also have this module already:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送电子邮件，我们需要拥有Python的`smtplib`模块。正如其名所示，这个库使用SMTP协议来发送电子邮件。我们可以使用我们喜欢的`pip`工具通过以下命令安装`smtplib`。但Python的默认安装应该已经包含了这个模块：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On your computer, open your favorite editor and add the following code snippet.
    Let this be known as `config.py`. The configuration file has login details, such
    as e-mail address, password, and the e-mail address to which the e-mail needs
    to be sent:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的电脑上，打开你最喜欢的编辑器并添加以下代码片段。让我们称这个为`config.py`。配置文件包含登录详细信息，如电子邮件地址、密码以及需要发送电子邮件的电子邮件地址：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s write the code to send an e-mail using this configuration file:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写代码来使用这个配置文件发送电子邮件：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Store the preceding code as `basic_email.py`, and run the code using the following
    command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的代码保存为`basic_email.py`，并使用以下命令运行代码：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you run the preceding code, you'll see exceptions with `SMTPAuthenticationError`,
    and your program will fail with exit code  `1`. This is how your exception will
    look like:![How to do it...](img/image_06_001.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会看到带有`SMTPAuthenticationError`的异常，并且你的程序将因为退出代码`1`而失败。你的异常将如下所示：![如何操作...](img/image_06_001.jpg)
- en: Okay, that's bad, but on the contrary, it's good as well! Exception suggests
    that the login to the server was fine, but Gmail blocked you from sending the
    message. Now, if you log in to Gmail, you should see an e-mail suggesting there
    was a signup detected from a less secure app. Really?! Yes, that's because we
    tried to access the Gmail account from our Python program. This is why we get
    an e-mail from Google suggesting a possible security breach in case there was
    a malicious activity on our account. The e-mail message from Google can be viewed
    in the following screenshot:![How to do it...](img/image_06_002.jpg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，这很糟糕，但相反，这也很好！异常表明服务器登录是正常的，但Gmail阻止了您发送消息。现在，如果您登录Gmail，您应该会看到一封电子邮件建议检测到来自不安全应用的注册。真的吗？！是的，这是因为我们尝试从我们的Python程序访问Gmail账户。这就是为什么我们收到了来自Google的电子邮件，建议如果我们的账户有恶意活动，可能存在安全漏洞。Google的电子邮件消息可以在以下截图中查看：![如何操作...](img/image_06_002.jpg)
- en: But obviously, this was a legitimate attempt to use the Gmail account, so let's
    confirm that to Google. Open the e-mail message from Google and click on **ALLOW
    ACCESS.** You'll be taken to the **Less secure apps** page where you can turn
    this setting on, as shown in the following screenshot:![How to do it...](img/image_06_003.jpg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但显然，这是一个合法尝试使用Gmail账户，所以让我们向Google确认这一点。打开来自Google的电子邮件消息，点击**允许访问**。您将被带到**不安全应用**页面，在那里您可以开启此设置，如下面的截图所示：![如何操作...](img/image_06_003.jpg)
- en: Now, log out of the Gmail web client and log in again to let the settings take
    effect on your account. If this went through fine, you will receive an e-mail
    from Google that the **Access for less secure apps is turned on.** The confirmation
    e-mail from Google will look similar to this screenshot:![How to do it...](img/image_06_004.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请从Gmail网页客户端登出并再次登录，以便让设置对您的账户生效。如果一切顺利，您将收到来自Google的电子邮件，告知**不安全应用的访问已开启**。Google的确认电子邮件将类似于以下截图：![如何操作...](img/image_06_004.jpg)
- en: 'Now, if you run the Python program again, it should run successfully and you
    will receive an e-mail in your inbox:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果您再次运行Python程序，它应该会成功运行，并且您将在收件箱中收到一封电子邮件：
- en: '![How to do it...](img/image_06_005.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_005.jpg)'
- en: Cool! Notice, the message contents are the same as we added in our code snippet.
    Also, since the *from* and *to* addresses were the same, the e-mail came from
    you, but it doesn't have any subject, which is not great. We will do something
    about this in the next recipe.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！注意，消息内容与我们添加到代码片段中的内容相同。此外，由于*发件人*和*收件人*地址相同，邮件是从您那里发出的，但它没有任何主题，这并不理想。我们将在下一个菜谱中解决这个问题。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As stated earlier, SMTP is used to send e-mail messages. We use Python module,
    `smtplib`, for this purpose.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，SMTP用于发送电子邮件消息。我们使用Python模块`smtplib`来完成这个目的。
- en: If you look at the preceding code snippet, we use the constructor, `smtplib.SMTP()`
    to configure Gmail's SMTP settings and get access to the e-mail server. Gmail's
    SMTP server runs on `smtp.gmail.com` and on port 587.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看前面的代码片段，我们使用构造函数`smtplib.SMTP()`来配置Gmail的SMTP设置并获取对电子邮件服务器的访问权限。Gmail的SMTP服务器运行在`smtp.gmail.com`上，端口为587。
- en: 'Once we have the server object, `server`, we use this to log in to Gmail with
    our username and password. Note that we have another line in the preceding code:
    `server.starttls()`; we will come to this later in this chapter.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了服务器对象`server`，我们就使用它来用我们的用户名和密码登录Gmail。请注意，在前面代码中我们还有另一行：`server.starttls()`；我们将在本章后面讨论这个问题。
- en: We have created a test message and stored it in the variable `msg`, which is
    then sent using the `sendmail` method `('fromaddr', 'toddr', msg)`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个测试消息并将其存储在变量`msg`中，然后使用`sendmail`方法`('fromaddr', 'toddr', msg)`发送。
- en: Finally, we close the connection to the e-mail server with `server.quit()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`server.quit()`关闭与电子邮件服务器的连接。
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We looked at how to sign in to Gmail and send a basic e-mail using the SMTP
    protocol and Python's `smptlib` library. While this recipe gets us started, there
    are more details that we'll delve into in the next recipe. Let's look at them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何使用SMTP协议和Python的`smptlib`库登录Gmail并发送基本电子邮件。虽然这个菜谱让我们开始了，但还有一些细节我们将在下一个菜谱中深入探讨。让我们来看看它们。
- en: E-mail encryption
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件加密
- en: E-mail is prone to disclosure of information. Most e-mails are currently transmitted
    in clear text format. E-mail encryption involves encrypting or disguising content
    of the e-mail so that the content is read by the intended recipients. Always remember
    that security is of prime importance when dealing with e-mails. Let's see how
    we can encrypt e-mails with Python.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件容易泄露信息。目前大多数电子邮件都是以明文格式传输的。电子邮件加密涉及加密或伪装电子邮件的内容，以便只有预期的收件人可以阅读。始终记住，在处理电子邮件时，安全性是最重要的。让我们看看如何使用Python加密电子邮件。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We looked at sending a basic e-mail in the previous recipe, but what's the `starttls()`
    method? How does e-mail encryption work? We will get answers to these questions
    in this section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们看到了如何发送基本的电子邮件，但`starttls()`方法是什么？电子邮件加密是如何工作的？我们将在这部分得到这些问题的答案。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by opening our favorite editor and typing in the following code
    snippet:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先打开我们最喜欢的编辑器，并输入以下代码片段：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, let's run the Python code and see what it prints. We have outputs in three
    different segments. The first one is when we send an `ehlo()` message to our e-mail
    server:![How to do it...](img/image_06_006.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行Python代码并查看它打印的内容。我们有三个不同的输出段。第一个是我们向电子邮件服务器发送`ehlo()`消息时：![如何做...](img/image_06_006.jpg)
- en: The second one is when we call `starttls()` method on the server object. Check
    out the following screenshot:![How to do it...](img/image_06_007.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种情况是我们对服务器对象调用`starttls()`方法。查看以下截图：![如何做...](img/image_06_007.jpg)
- en: The third one is when we connect to the e-mail server with `ehlo()` again:![How
    to do it...](img/image_06_008.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个是我们再次使用`ehlo()`连接到电子邮件服务器时：![如何做...](img/image_06_008.jpg)
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's start with the basics. E-mail encryption means protecting e-mail messages
    from being read by someone other than the intended parties. E-mails are typically
    sent in clear text and can be sniffed by third parties. To avoid this, we encrypt
    e-mails at the protocol layer; this may include authentication as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。电子邮件加密意味着保护电子邮件消息不被除预期当事人之外的其他人阅读。电子邮件通常以明文发送，可以被第三方嗅探。为了避免这种情况，我们在协议层加密电子邮件；这可能包括身份验证。
- en: SMTP servers typically send e-mails on port 25 using SSL/TLS protocols. However,
    with the advent of STARTTLS (layer on top of SMTP) and the usage of port 587 for
    message submissions, e-mail clients like Gmail use STARTTLS and port 587 for sending
    e-mails. Gmail also has authentication implemented; remember that we used `server.login
    (username, password)` to login to the Gmail server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP服务器通常使用SSL/TLS协议在端口25上发送电子邮件。然而，随着STARTTLS（位于SMTP之上的一层）的出现以及使用端口587进行消息提交，像Gmail这样的电子邮件客户端使用STARTTLS和端口587来发送电子邮件。Gmail还实现了身份验证；记住我们使用`server.login
    (username, password)`登录到Gmail服务器。
- en: For STARTTLS to be used across the server and client, the client needs to first
    know if the server supports this protocol. When we issue `server.ehlo()`, the
    program sends an `EHLO` message to the SMTP server to establish communication.
    The server responds with the message and allowed extensions, as observed in the
    first screenshot.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让STARTTLS在服务器和客户端之间使用，客户端首先需要知道服务器是否支持此协议。当我们发出`server.ehlo()`时，程序会向SMTP服务器发送一个`EHLO`消息以建立通信。服务器会以消息和允许的扩展响应，如第一张截图所示。
- en: Now, from the code, we check whether the server supports the `STARTTLS` extension
    with `server.has_extn('STARTTLS')`. As we saw in the first screenshot, the SMTP
    server responded with the `STARTTLS` extension; this confirms that gmail supports
    the `STARTTLS` protocol layer, which is awesome.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从代码中，我们使用`server.has_extn('STARTTLS')`检查服务器是否支持`STARTTLS`扩展。正如我们在第一张截图中所见，SMTP服务器响应了`STARTTLS`扩展；这证实了Gmail支持`STARTTLS`协议层，这真是太棒了。
- en: Now, we communicate with the server using `server.starttls()`. The server responds
    to this by sending a message, `Ready to start TLS`. This way, we have encrypted
    our session. If you now look at the third screenshot, when we send `server.ehlo()`,
    we re-identify ourselves with the server over the TLS session. It also suggests
    that the server implements an authentication extension.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`server.starttls()`与服务器通信。服务器通过发送消息“Ready to start TLS”来响应。这样，我们就加密了我们的会话。如果你现在查看第三张截图，当我们发送`server.ehlo()`时，我们通过TLS会话重新向服务器确认身份。这也表明服务器实现了身份验证扩展。
- en: Finally, we quit our SMTP session using `server.quit()` and the server responds
    with `closing connection`, as shown in the third screenshot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `server.quit()` 退出 SMTP 会话，服务器响应为 `closing connection`，如第三张截图所示。
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Well, that was pretty detailed. Take a few moments to understand it. It's actually
    interesting what goes on behind the sending of a simple e-mail message. But don't
    worry about it too much; let's start the fun and get into many more examples.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这相当详细。花点时间理解它。实际上，了解简单电子邮件发送背后的过程很有趣。但不用担心太多；让我们开始有趣的部分，并探索更多示例。
- en: Beautifying e-mail messages with MIME
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MIME 美化电子邮件消息
- en: In the first few recipes, we sent e-mail messages in a simple plain old text
    format. The MIME Internet standard helps us construct messages with non-ASCII
    characters, multipart messages and images. It also helps with attachments and
    many other tasks. This way, we can construct enriched e-mail messages. Let's look
    at how the MIME format is used in this recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几个菜谱中，我们以简单的纯文本格式发送了电子邮件消息。MIME 互联网标准帮助我们构建包含非 ASCII 字符、multipart 消息和图像的消息。它还帮助处理附件和其他许多任务。这样，我们可以构建丰富的电子邮件消息。让我们看看
    MIME 格式在这个菜谱中的应用。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use the same module, `smtplib`, to send e-mail messages.
    We will also introduce another module `email`, which will help us construct better
    e-mail messages with the MIME format. The `email` module comes in with Python
    installation; hence, we don't need any new modules or installations to be carried
    out. In this section, we will look at how to use the MIME attributes to send better
    looking e-mails.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用相同的模块 `smtplib` 来发送电子邮件消息。我们还将介绍另一个模块 `email`，它将帮助我们使用 MIME 格式构建更好的电子邮件消息。`email`
    模块随 Python 安装而来；因此，我们不需要进行任何新的模块或安装。在本节中，我们将探讨如何使用 MIME 属性发送外观更好的电子邮件。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start by importing all of the modules we need:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先导入我们需要的所有模块：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s construct our e-mail message using the MIME module. The following
    code creates the message:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 MIME 模块构建我们的电子邮件消息。以下代码创建了消息：
- en: '[PRE6]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, now we have the details of whom to send the e-mail message to. We have
    also constructed the e-mail message in the MIME format. What are we waiting for?
    Let''s send it using the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们有了要发送电子邮件消息的收件人详细信息。我们已使用 MIME 格式构建了电子邮件消息。我们还在等什么呢？让我们使用以下代码发送它：
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The received e-mail looks as follows:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 收到的电子邮件如下所示：
- en: '![How to do it...](img/B05370_07_09.jpg)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/B05370_07_09.jpg)'
- en: Awesome! That's great, but hey... how did it work?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！太好了，但是...它是怎么工作的？
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the preceding example, we imported the configuration file from where we got
    `fromaddress` and `password` to log in to the SMTP server and `toaddress` to whom
    the e-mail message will be sent.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们导入配置文件，从中我们获得了 `fromaddress` 和 `password` 以登录 SMTP 服务器，以及 `toaddress`
    以发送电子邮件消息。
- en: Now, before sending the message, we construct a new MIME message object. We
    do that with `MIMEMultipart()` class from the `email.mime.multipart` module of
    Python. For those who are not aware, a MIME multipart message means both HTML
    and text content in a single e-mail. So, in this code, we create a new multipart
    MIME message and then add the text content to it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在发送消息之前，我们使用 `email.mime.multipart` 模块中的 `MIMEMultipart()` 类构建一个新的 MIME 消息对象。对于那些不知道的人来说，MIME
    multipart 消息意味着在单个电子邮件中既有 HTML 内容又有文本内容。因此，在这段代码中，我们创建了一个新的 multipart MIME 消息，并将其文本内容添加到其中。
- en: The text content, which is the body of the e-mail, is created with the `MIMEText()`
    constructor from the `email.mime.text` module and is then attached to the multipart
    message with the `attach()` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 文本内容，即电子邮件的正文，是通过 `email.mime.text` 模块中的 `MIMEText()` 构造函数创建的，然后使用 `attach()`
    方法将其附加到 multipart 消息中。
- en: 'The constructed MIME message is seen in the following screenshot, where the
    content-type is multipart and the MIME Version is 1.0, the **Subject**, **To**,
    and **From** details are as expected, and the e-mail body contains the expected
    text:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的 MIME 消息如下截图所示，其中内容类型为 multipart，MIME 版本为 1.0，**主题**、**收件人**和**发件人**的详细信息符合预期，电子邮件正文包含预期的文本：
- en: '![How it works...](img/B05370_07_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B05370_07_10.jpg)'
- en: Once we have the message and the recipient details, we send the e-mail as usual,
    using the `SMTP.sendmail()` method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了消息和收件人详细信息，我们就可以像往常一样使用 `SMTP.sendmail()` 方法发送电子邮件。
- en: E-mail messages with attachments
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有附件的电子邮件消息
- en: One of the most used and simple use cases with e-mail is the ability to add attachments
    to your e-mail messages. In this section, we will learn how to add attachments
    to our e-mails in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件中最常用且简单的用例之一是能够向你的电子邮件消息中添加附件。在本节中，我们将学习如何在 Python 中给我们的电子邮件添加附件。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We use the same `smtplib` and `email` modules for this example. So, don't bother
    about the modules to be installed. Let's get on with the recipe.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中使用了相同的 `smtplib` 和 `email` 模块。所以，不必担心要安装的模块。让我们继续进行。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's begin by quickly creating a small text file. We will call it `attach.txt`,
    and its contents are shown in the following screenshot:![How to do it...](img/image_06_011.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先快速创建一个小的文本文件。我们将称之为 `attach.txt`，其内容如下截图所示：![如何操作...](img/image_06_011.jpg)
- en: 'Let''s look at the code that will help add an attachment to our e-mail:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看将附件添加到我们的电子邮件中的代码：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you run the preceding code, you will receive the e-mail in your inbox,
    which will look similar to the following screenshot:![How to do it...](img/image_06_012.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行前面的代码时，你将在你的收件箱中收到电子邮件，其外观类似于以下截图：![如何操作...](img/image_06_012.jpg)
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We're already familiar with creating MIME message objects. So, in this code,
    we create a multipart message object, `msg`. We then add a text message to it
    with `msg.attach()`. The text body says `Click to open the attachment`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了创建 MIME 消息对象。因此，在这段代码中，我们创建了一个多部分消息对象 `msg`。然后我们使用 `msg.attach()` 向其中添加一条文本消息。文本正文说“点击打开附件”。
- en: In this recipe, we use another new class, `MIMEBase` from the `email` module
    that will be used to attach the text file. Remember, we already have the `attach.txt`
    file created, we open the file using Python's `open()` method and get the file
    handle `attachment`. We then create a `MIMEBase` object, `part`, and assign the
    contents of the file as payload to this object. The contents of the file are obtained
    with `attachment.read()` and the payload is set with the `set_payload()` method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了来自 `email` 模块的新类 `MIMEBase`，它将被用来附加文本文件。记住，我们已经创建了 `attach.txt`
    文件，我们使用 Python 的 `open()` 方法打开文件，并获取文件句柄 `attachment`。然后我们创建一个 `MIMEBase` 对象 `part`，并将文件的
    内容作为有效载荷分配给此对象。文件内容通过 `attachment.read()` 获取，有效载荷通过 `set_payload()` 方法设置。
- en: To attach the file, the `MIMEBase` object has to be encoded to base64 and the
    `Content-Disposition` header needs to be added to the `part` object. Now that
    we have the `part` object, it can be attached to the multipart object, `msg`,
    with the `attach()` method, as we did for the body text.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了附加文件，`MIMEBase` 对象必须被编码为 base64，并且需要将 `Content-Disposition` 标头添加到 `part` 对象中。现在我们有了
    `part` 对象，它可以像我们为正文文本所做的那样，使用 `attach()` 方法附加到多部分对象 `msg` 上。
- en: Cool, so we have the complete MIME message and the details of whom to send the
    message to. So, we go ahead and send the e-mail with the attachment. Just what
    we intended to achieve.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，所以我们已经有了完整的 MIME 消息以及发送消息给谁的具体信息。那么，我们就继续发送带有附件的电子邮件。这正是我们想要达成的目标。
- en: Connecting to your inbox
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到你的收件箱
- en: Throughout the chapter, we have been talking about sending e-mails with Python.
    However, at some point, you might also want to scan through your inbox and read
    the incoming messages. So, how do you do that? Let's understand and learn it in
    this recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在谈论使用 Python 发送电子邮件。然而，在某些时候，你也可能想要扫描你的收件箱并阅读收到的消息。那么，你该如何做呢？让我们在本食谱中理解和学习它。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we use a new Python module that will help us retrieve messages
    from the inbox. We use the Python module, `imaplib`, which is available in the
    default Python installation. Cool, so let's get started.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了一个新的 Python 模块，它将帮助我们从收件箱中检索消息。我们使用的是 Python 模块 `imaplib`，它是默认 Python
    安装的一部分。酷，那么让我们开始吧。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We start by using the configuration file, which we have already created to
    store our e-mail and password, to log in to the server. We then add our code to
    create a handle or an object to work with our inbox. This is how the code looks:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用配置文件，这是我们之前创建的用于存储我们的电子邮件和密码的文件，来登录服务器。然后我们添加我们的代码来创建一个处理或对象来处理我们的收件箱。代码如下所示：
- en: '[PRE9]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you run the preceding piece of code, you will get the following output:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码片段，你将得到以下输出：
- en: '![How to do it...](img/image_06_013.jpg)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_013.jpg)'
- en: 'By default, when we login to Gmail, default inbox gets selected, but if we
    have created other inboxes as well, we can get the list by adding a small line
    of code. Now, from all the labels, if we specifically want to select `Inbox`,
    even that can be achieved. Look at the following code example:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，当我们登录到 Gmail 时，默认收件箱会被选中，但如果我们还创建了其他收件箱，我们可以通过添加一小段代码来获取列表。现在，从所有标签中，如果我们特别想选择
    `Inbox`，这也可以实现。请看以下代码示例：
- en: '[PRE10]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding code snippet is shown in the following screenshot.
    Though I have many labels created, I have taken a screenshot with fewer labels:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码片段的输出显示在以下屏幕截图中。尽管我已经创建了多个标签，但我使用较少标签的屏幕截图：
- en: '![How to do it...](img/image_06_014.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_06_014.jpg)'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As discussed in the beginning of this chapter, we have three main protocols
    to work with e-mails. We used SMTP heavily for sending e-mails, but while reading
    e-mails, we can use either POP or IMAP to retrieve messages from the e-mail server.
    We will go through the code step by step.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，我们有三项主要协议用于处理电子邮件。我们大量使用 SMTP 发送电子邮件，但在阅读电子邮件时，我们可以使用 POP 或 IMAP 从电子邮件服务器检索消息。我们将逐步分析代码。
- en: Python's `imaplib` library helps us connect to our mailbox using the **Internet
    Message Access Protocol** (**IMAP**). The Gmail server is configured to IMAP,
    with the server running on `imap.gmail.com` and on port '993'.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `imaplib` 库帮助我们使用 **互联网消息访问协议**（**IMAP**）连接到我们的邮箱。Gmail 服务器配置为 IMAP，服务器运行在
    `imap.gmail.com` 上，端口为 '993'。
- en: In our code example, we create an object of type `imaplib` with the constructor
    `IMAP4_SSL("imap.gmail.com", 993)`; we call this object `M`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们使用构造函数 `IMAP4_SSL("imap.gmail.com", 993)` 创建了一个类型为 `imaplib` 的对象；我们称这个对象为
    `M`。
- en: Regarding the encryption, we use `IMAP4_SSL` for connecting to the server because
    it uses encrypted communications over SSL sockets. We avoid the usage of `IMAP4`
    class, which internally uses clear text sockets.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加密，我们使用 `IMAP4_SSL` 连接到服务器，因为它在 SSL 套接字上使用加密通信。我们避免使用 `IMAP4` 类，它内部使用明文套接字。
- en: Now, with object `M`, we can log in to Gmail with our username and password
    and get connected to our inbox.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用对象 `M`，我们可以使用我们的用户名和密码登录到 Gmail 并连接到我们的收件箱。
- en: When we call the `list()` method on object `M`, it returns all the labels you
    have already created. Now, in my case, I have created the `ACM` label (for my
    work with ACM), and hence it shows up in my list of labels.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在对象 `M` 上调用 `list()` 方法时，它会返回您已经创建的所有标签。现在，在我的情况下，我已经创建了 `ACM` 标签（用于我的与 ACM
    的工作），因此它出现在我的标签列表中。
- en: If you look at the code example, we can explicitly connect to the `INBOX` using
    the `select()` method. Once connected to the inbox, we can start fetching the
    e-mail messages from the inbox.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看代码示例，我们可以使用 `select()` 方法明确连接到 `INBOX`。一旦连接到收件箱，我们就可以开始从收件箱获取电子邮件消息。
- en: Finally, we close our connection with the inbox using the `M.logout()` method.
    Cool! That was nice and easy.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `M.logout()` 方法关闭与收件箱的连接。酷！这很简单。
- en: There's more...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: So, we learnt how to connect to our inbox in this recipe, but we may also want
    to read the messages, mark them, and perform interesting actions on them. Let's
    look at how to perform operations on the messages in the next recipe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这个食谱中学习了如何连接到我们的收件箱，但我们可能还想阅读消息、标记它们并在它们上执行有趣的操作。让我们看看如何在下一个食谱中执行消息操作。
- en: Fetching and reading e-mail messages
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和阅读电子邮件消息
- en: Retrieving e-mail messages with `imaplib` is also easy to achieve. In this recipe,
    we will learn how to do that with Python code. In this recipe, we will search
    for e-mails with a particular subject line and fetch the latest message from the
    inbox that matches a predefined criteria.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `imaplib` 获取电子邮件消息也很容易实现。在本食谱中，我们将学习如何使用 Python 代码来完成这项操作。在本食谱中，我们将搜索具有特定主题行的电子邮件，并从符合预定义标准的收件箱中获取最新消息。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We continue to use the `imaplib` module for reading e-mail messages, so no new
    installations are required for this recipe.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用 `imaplib` 模块来读取电子邮件消息，因此不需要为本食谱进行新安装。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We utilize the configuration file and import `fromaddress`, `password`, and
    `toaddress` to log in to the server. Once we''re logged in, we select the default
    inbox, fetch e-mail messages, and read them. Let''s look at the complete code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们利用配置文件并导入 `fromaddress`、`password` 和 `toaddress` 来登录到服务器。一旦登录，我们选择默认收件箱，获取电子邮件消息并阅读它们。让我们看看完整的代码：
- en: '[PRE11]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Store the preceding file as `inbox_search.py` and run the code using the following
    command:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的文件保存为 `inbox_search.py` 并使用以下命令运行代码：
- en: '[PRE12]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output of the preceding code snippet is shown in the following screenshot:![How
    to do it...](img/image_06_015.jpg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面代码片段的输出显示在以下截图：![如何操作...](img/image_06_015.jpg)
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: In the preceding code snippet, we first create an object of `IMAP_SSL4()` with
    the appropriate IMAP settings. We then log in to the client using the credentials
    from the configuration file with the help of the IMAP object. We then select our
    `INBOX` so that we can perform search operations on it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先使用适当的 IMAP 设置创建了一个 `IMAP_SSL4()` 对象。然后，我们借助 IMAP 对象，使用配置文件中的凭据登录到客户端。接着，我们选择我们的
    `INBOX` 以便在其上执行搜索操作。
- en: The `M.search()` method called on the IMAP object helps us search for e-mails
    with the subject *Email with an attachment*. The `search()` method returns an
    array of messages that match the criteria we searched for.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IMAP 对象上调用 `M.search()` 方法可以帮助我们搜索主题为 *带附件的电子邮件* 的电子邮件。`search()` 方法返回一个与搜索标准匹配的消息数组。
- en: Now, if we have to get to a particular message, and since we have to read the
    latest e-mail message that matched our criteria, we use the `M.fetch()` method.
    The `fetch()` method requires a given message object and the part of the message
    that you want to fetch. So, in this code example, we pass the latest e-mail object
    that matches the criteria and pass `RFC822`, which suggests that we want the e-mail
    body in the RFC 822 format.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要获取特定的消息，并且由于我们必须读取符合我们标准的最新的电子邮件，我们使用 `M.fetch()` 方法。`fetch()` 方法需要一个给定的消息对象和您想要获取的消息部分。因此，在这个代码示例中，我们传递符合标准的最新电子邮件对象，并传递
    `RFC822`，这表示我们想要以 RFC 822 格式获取电子邮件正文。
- en: When we print the message obtained from `fetch()`, we get the contents of the
    e-mail body for the latest e-mail that matched the search.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印从 `fetch()` 获取的消息时，我们得到与搜索匹配的最新电子邮件的电子邮件正文内容。
- en: Now, do you remember seeing the contents of the e-mail? Well, it's the same
    e-mail message we had sent in one of our earlier recipes, which was used for demonstrating
    the e-mail attachment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你还记得看到电子邮件的内容吗？嗯，这正是我们在之前的菜谱中发送的同一封电子邮件，当时我们用它来演示电子邮件附件。
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Good! So, now we can search for a message and fetch it too. There are many more
    granular operations such as marking messages that we'd like to perform on our
    inbox. Let's look at them in the next recipe.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！所以，现在我们可以搜索一条消息并获取它。在我们的收件箱中还有许多更细粒度的操作，比如标记我们想要执行的操作。让我们在下一个菜谱中看看它们。
- en: Marking e-mail messages
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记电子邮件消息
- en: In the previous recipe, we looked at fetching and reading messages. Wasn't it
    too complicated? Do we have to take care of so many details while doing a simple
    operation like search or read? In this section, let's look at another library
    that can help us not only to search or read better, but also to perform various
    operations on our e-mails.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们看了获取和读取消息。这不是太复杂了吗？在进行像搜索或读取这样的简单操作时，我们必须注意这么多细节吗？在本节中，我们将看看另一个可以帮助我们不仅更好地搜索或读取，还可以在我们的电子邮件上执行各种操作的库。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'For this section, we will install the `gmail` module. You can install this
    module through your Terminal using the `pip` command, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将安装 `gmail` 模块。您可以通过终端使用 `pip` 命令安装此模块，如下所示：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s look at how to search for e-mails and read them using `gmail` APIs.
    This will get us started with the `gmail` module. The following code snippet searches
    for e-mails that were received after July 22, 2016\. We then take the latest message
    and fetch it. Once we have the message fetched, we just go ahead and read the
    body of the e-mail:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `gmail` API 搜索和读取电子邮件。这将使我们开始使用 `gmail` 模块。以下代码片段搜索在 2016 年 7 月 22
    日之后收到的电子邮件。然后我们取最新的消息并获取它。一旦我们获取了消息，我们就可以继续读取电子邮件的正文：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output of the preceding code is shown in the following screenshot. Looks
    like I may have received an e-mail digest from Quora!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出显示在以下截图。看起来我可能收到了来自 Quora 的电子邮件摘要！
- en: '![Getting ready](img/image_06_016.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/image_06_016.jpg)'
- en: 'Here''s a screenshot from my inbox:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的收件箱的截图：
- en: '![Getting ready](img/Chapter5-Page-21.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/Chapter5-Page-21.jpg)'
- en: Wasn't that too easy? Incidentally, the `gmail` module is written on top of
    `imaplib` but has better APIs, so let's take advantage of this module and do some
    fantastic operations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是太简单了吗？顺便说一下，`gmail`模块是在`imaplib`之上编写的，但提供了更好的API，所以让我们利用这个模块做一些惊人的操作。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s open the inbox and look for an unread message that matches a certain
    criteria and mark the message as read. The following code easily does this:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开收件箱，寻找符合特定标准的未读邮件，并将其标记为已读。以下代码可以轻松完成此操作：
- en: '[PRE15]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Before running this program, I had one e-mail in my inbox from [https://glassdoor.com](https://glassdoor.com) that
    I hadn''t read. It looked like this in my inbox:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行此程序之前，我在收件箱中有一封来自[https://glassdoor.com](https://glassdoor.com)的未读电子邮件。在我的收件箱中它看起来是这样的：
- en: '![How to do it...](img/image_06_017.jpg)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_017.jpg)'
- en: 'After running the code snippet, it identified this e-mail as matching my criteria
    of unread messages from `noreply@glassdoor.com` and marked my message as read.
    So, now it looks like this in my inbox. Gmail un-bolds the read messages and that''s
    what happened in my inbox:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码片段后，它将这封电子邮件识别为符合来自`noreply@glassdoor.com`的未读邮件标准，并将我的邮件标记为已读。所以现在在我的收件箱中看起来是这样的。Gmail会取消粗体显示已读邮件，这就是我在收件箱中看到的情况：
- en: '![How to do it...](img/image_06_018.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_018.jpg)'
- en: Nice!
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很好！
- en: Let's look at another example. I have been receiving so many promotional e-mails
    from Amazon Now from Jan 2016\. This is how my mailbox looks:![How to do it...](img/image_06_019.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。从2016年1月开始，我收到了来自Amazon Now的大量促销电子邮件。我的邮箱看起来是这样的：![如何操作...](img/image_06_019.jpg)
- en: 'Now, I want to mark them all as `read` and assign them under one label, `AMAZON`.
    How can I do it? The following code does this operation:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我想将它们全部标记为`read`，并将它们分配到单个标签`AMAZON`下。我该如何操作？以下代码执行了这个操作：
- en: '[PRE16]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After running this code, a new label will appear in your inbox with the name, `AMAZON`.
    Now, if you search your inbox for all e-mails with the label `AMAZON`, you'll
    see that all these e-mail messages have been marked as read. Look at the following
    screenshot where I search for e-mails with the label `AMAZON`:![How to do it...](img/image_06_020.jpg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码后，您的收件箱中会出现一个新的标签，名为`AMAZON`。现在，如果您在收件箱中搜索所有带有标签`AMAZON`的电子邮件，您会看到所有这些电子邮件都已标记为已读。请看以下截图，我正在搜索带有标签`AMAZON`的电子邮件：![如何操作...](img/image_06_020.jpg)
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the first step, we created an object, `g` by logging into the Gmail server.
    Note that we didn't pass any parameters like IMAP settings or port to create the
    object. The `gmail` module internally handles this.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们通过登录Gmail服务器创建了一个名为`g`的对象。请注意，我们没有传递任何参数（如IMAP设置或端口）来创建对象。`gmail`模块内部处理这些。
- en: Now, using this object, we start searching our inbox for e-mails that are *unread*
    and sent by `noreply@glassdoor.in`', and all the mail objects matching this criteria
    are stored in *mails*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这个对象，我们开始搜索收件箱中未读且由`noreply@glassdoor.in`发送的电子邮件，所有符合这个标准的邮件对象都存储在`mails`中。
- en: Later, we fetch the latest record with the `fetch()` method and mark this mail
    as read with the `read()` method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`fetch()`方法获取最新记录，并使用`read()`方法将此邮件标记为已读。
- en: Similarly, in the second recipe, we iterate through all the e-mail messages
    that are *unread*, sent by `store-news@amazon.in`, and that were sent to me this
    year.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在第二个菜谱中，我们遍历所有未读的电子邮件，这些电子邮件是由`store-news@amazon.in`发送的，并且是在今年发送给我的。
- en: Each mail is then marked as read with the `read()` method and added to the label,
    `AMAZON`. Works like a breeze, awesome!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每封邮件随后都会使用`read()`方法标记为已读，并添加到标签`AMAZON`中。操作起来就像微风一样，太棒了！
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We looked at some of the operations that we can perform on our e-mail messages.
    There are many more. With the `gmail` module, you can mark messages as unread
    or even make them important with a star. Let's look at an example with which we
    can clear up our inbox.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了一些可以在我们的电子邮件上执行的操作。还有很多。使用`gmail`模块，您可以标记邮件为未读，甚至用星号标记它们为重要。让我们看看一个可以清理我们收件箱的例子。
- en: Clearing up e-mail messages from your inbox
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除收件箱中的电子邮件
- en: Last but not least, this recipe will take you through the steps with which you
    can delete e-mail messages from your inbox. As you'd expect, it's pretty straightforward
    to delete your e-mails programmatically.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，这个菜谱将向您展示如何从收件箱中删除电子邮件。正如您所期望的，通过编程删除电子邮件非常直接。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even if you delete the messages from your e-mail client, the e-mail server can
    still choose to store them. So, when you delete your messages, you're merely marking
    them to be hidden from your inbox while they can continue to stay on your e-mail
    server, based on the server implementation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你从电子邮件客户端删除了消息，电子邮件服务器仍然可以选择存储它们。所以，当你删除你的消息时，你只是在标记它们以隐藏在你的收件箱中，而它们可以根据服务器实现继续留在你的电子邮件服务器上。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We continue to use the `imaplib` module for deleting e-mail messages, so no
    new installations are required for this recipe.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用 `imaplib` 模块来删除电子邮件消息，因此不需要为这个配方安装任何新软件。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's utilize the configuration file and import the `fromaddress`, `password`,
    and `toaddress` to log in to the server.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们利用配置文件并导入 `fromaddress`、`password` 和 `toaddress` 来登录到服务器。
- en: 'This is how the complete code looks like:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是完整的代码看起来像什么：
- en: '[PRE17]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Store the preceding file as `inbox_delete.py` and run the code using the following
    command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的文件保存为 `inbox_delete.py` 并使用以下命令运行代码：
- en: '[PRE18]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Similar to what we saw in the previous examples, we first log in to Gmail with
    our login credentials from the configuration file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的例子类似，我们首先使用配置文件中的登录凭证登录到Gmail。
- en: We then connect to our inbox and search for e-mails coming from `junk@xyz.com`.
    If we find any e-mails that match this criteria, we want to delete them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后连接到我们的收件箱并搜索来自 `junk@xyz.com` 的电子邮件。如果我们找到符合这个标准的任何电子邮件，我们希望删除它们。
- en: So, we loop over the mail objects and perform the `delete()` operation on them,
    and that's it! Our inbox is now free from all messages that we deem as junk. :)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们遍历邮件对象并对它们执行 `delete()` 操作，就是这样！我们的收件箱现在已经没有我们认为的垃圾邮件了。 :)
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Excellent! So, now we know how to send e-mail messages, add attachments, and
    fetch and read them. We also learnt how to mark our message as read, add appropriate
    labels, and delete these messages if needed. Armed with this knowledge, can we
    do something for Kelly who has a few problems?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！所以，现在我们知道了如何发送电子邮件消息，添加附件，以及获取和读取它们。我们还学会了如何将我们的消息标记为已读，添加适当的标签，并在需要时删除这些消息。掌握了这些知识，我们能为凯利做些什么吗？
- en: Automating customer support flows with with e-mail responses
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用电子邮件响应自动化客户支持流程
- en: Kelly, Director of Customer Support, has a problem at hand. Most of her support
    engineers end up responding to Level 1 support requests where customers are looking
    for information that is already available on the website. Customers just end up
    sending e-mails to support without trying to search for themselves.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 客户支持部经理凯利手头有一个问题。她的大部分支持工程师最终都在处理一级支持请求，这些请求是客户在网站上已经可以找到信息的。客户只是简单地发送电子邮件给支持部门，而没有尝试自己搜索。
- en: This sequence of events is non-productive for the customer and support engineers.
    Customers simply wait for information instead of getting it on the website directly,
    and support engineers manually send a pointer to the **Frequently Asked Questions**
    (**FAQ**) section from the website to the customers. Kelly sees it as an opportunity
    to improve and wants to reduce the time spent on support by automating this flow. Can
    we do something to help her?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列事件对客户和支持工程师来说都是低效的。客户只是等待信息，而不是直接在网站上获取信息，支持工程师手动将网站上的**常见问题解答**（**FAQ**）部分的指针发送给客户。凯利认为这是一个改进的机会，并希望通过自动化这个流程来减少在支持上花费的时间。我们能做些什么来帮助她？
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Of course, this is a bigger problem to solve but at the very least, we can do
    something that will help automate the flow. Whenever the support team receives
    a new ticket via e-mail, we can auto respond to the ticket acknowledging the receipt
    of the ticket and also send the link to the FAQ section from the company's website.
    This way, the customers can browse and look up the information they need from
    the FAQ section. It also reduces the load on support engineers as the auto-response
    e-mail would have already resolved the customer query and that too in a quick
    time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个更大的问题，但至少我们可以做一些事情来自动化流程。每当支持团队通过电子邮件收到新的工单时，我们可以自动回复工单，确认已收到工单，并从公司网站上发送FAQ部分的链接。这样，客户就可以浏览并从FAQ部分查找他们所需的信息。这也减轻了支持工程师的负担，因为自动回复的电子邮件已经迅速解决了客户的查询。
- en: So now, what do we actually need? We need to monitor our support inbox, look
    at any new customer queries, and then auto-respond with our template e-mail.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们现在到底需要什么呢？我们需要监控我们的支持收件箱，查看任何新的客户查询，然后使用我们的模板电子邮件自动回复。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s directly jump to our solution. Create a Python file and copy the following code
    snippet into it. It does exactly what we need to automate the support flow:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们直接跳到我们的解决方案。创建一个Python文件，并将以下代码片段复制到其中。它正好完成了我们需要自动化支持流程的工作：
- en: '[PRE19]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Run the preceding code with Python, and you will observe that the program is
    still running. It is actually waiting for new e-mails, in this context, the customer
    requests for the support engineers.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python运行前面的代码，你会观察到程序仍在运行。实际上，它正在等待新的电子邮件，在这种情况下，是客户对支持工程师的请求。
- en: If you now send an e-mail to customer support, you will receive an auto reply
    from our Python program.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在给客户支持发送电子邮件，你将收到我们Python程序的自动回复。
- en: Note
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this case the support inbox is my e-mail address, but you can easily set
    up an e-mail account for your company so that the customer requests are directed
    to this account.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，支持收件箱是我的电子邮件地址，但你可以轻松地为你的公司设置一个电子邮件账户，以便客户请求被导向这个账户。
- en: 'This is how the auto response e-mail looks:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是自动回复电子邮件的样子：
- en: '![How to do it...](img/image_06_021.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_06_021.jpg)'
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start with a `while` loop that runs every one min (60 seconds). Every iteration
    reads the support inbox and searches for unread e-mails.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个每分钟运行一次（60秒）的`while`循环开始。每次迭代都会读取支持收件箱并搜索未读电子邮件。
- en: If the `while` loop finds any unread e-mail, it will fetch the e-mail and get
    the `fr` attribute. The `fr` attribute gets you the `from` field of the e-mail
    message. The `from` field is the e-mail address of the customer asking for information
    from the support engineer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`while`循环发现任何未读电子邮件，它将获取该电子邮件并获取`fr`属性。`fr`属性让你获取电子邮件消息的`from`字段。`from`字段是请求支持工程师信息的客户电子邮件地址。
- en: Once we have the customer's e-mail address, we send an automated response to
    the customer from our inbox. The preceding screenshot shows exactly what the auto
    response looks like. Cool, so now when the customers asks a question to the customer
    support engineer by sending an e-mail, they will get an automated e-mail response
    with the link to the Frequently Asked Questions section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了客户的电子邮件地址，我们就会从我们的收件箱向客户发送自动回复。前面的截图显示了自动回复的确切样子。太酷了，所以现在当客户通过发送电子邮件向客户支持工程师提问时，他们将会收到一个带有常见问题解答部分链接的自动电子邮件回复。
- en: This way, the customer gets the required information quickly from the FAQ link.
    Also, the load on the support engineers is reduced, as they don't have to respond
    to the mundane support requests manually.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，客户可以快速地从常见问题解答链接中获取所需信息。此外，由于支持工程师不需要手动回复日常支持请求，因此他们的工作负担也得到了减轻。
- en: I'm sure Kelly feels happy about this improvement. She understands that the
    customer support flow is automated to a certain extent and hopes to see productivity
    gains soon!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信凯莉会对这个改进感到高兴。她明白客户支持流程已经自动化到一定程度，并希望很快看到生产力的提升！
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Awesome! There are many other things that you can do with e-mails. Tried downloading
    e-mail attachments? Want to give it a shot? We'll let you try that for yourself.
    See you in the next chapter!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你还可以用电子邮件做很多事情。尝试下载电子邮件附件了吗？想试试看？我们会让你亲自尝试。下章再见！
