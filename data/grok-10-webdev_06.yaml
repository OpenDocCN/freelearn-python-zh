- en: 'Chapter 6. The Catalog: An Object-Oriented Search Engine'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：目录：面向对象的搜索引擎
- en: We now have an application with multiple projects and lists. As we start adding
    more lists, there will come a time when we'll need to find a particular list item.
    We might want to find all items containing a specific word, or maybe all of the
    items completed on a specific date. Since all of the application data is stored
    in the ZODB, we need a tool to help us look for specific objects contained therein.
    This tool comes with Grok by default and is called the catalog.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含多个项目和列表的应用程序。随着我们开始添加更多的列表，将会有一个时刻我们需要找到特定的列表项。我们可能想要找到所有包含特定单词的项目，或者可能想要找到所有在特定日期完成的项目。由于所有应用程序数据都存储在ZODB中，我们需要一个工具来帮助我们查找其中包含的特定对象。这个工具是Grok默认提供的，被称为目录。
- en: 'In this chapter, we are going to learn how to use the catalog. In particular,
    we will look at the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用目录。特别是，我们将探讨以下概念：
- en: What a catalog is and how it works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录是什么以及它是如何工作的
- en: What indexes are and how they work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引是什么以及它们是如何工作的
- en: Storing data in the catalog
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目录中存储数据
- en: Performing simple queries on the catalog
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目录上执行简单查询
- en: Creating a search interface for our application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建一个搜索界面
- en: Catalogs and indexes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录和索引
- en: When we work with small amounts of data, we can always look at all of the elements
    of a list, for example, to find the ones that we want. However, this approach
    obviously does not scale up when we are dealing with thousands or millions of
    objects. A common way of attacking this problem is to use some sort of lookup
    table that will allow us to quickly and easily find a specific object by using
    one of its attributes. This is known as an **index**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理少量数据时，我们可以总是查看列表中的所有元素，例如，以找到我们想要的元素。然而，当我们处理成千上万的对象时，这种方法显然无法扩展。解决这个问题的常见方法之一是使用某种类型的查找表，它将允许我们通过使用对象的一个属性快速轻松地找到特定的对象。这被称为**索引**。
- en: A **catalog** is a tool that allows us to manage a collection of related indexes
    and perform queries against the catalog by using one or more of them. We can add
    indexes to the catalog that will keep track of a specific attribute of an object.
    From then on, whenever we create a new object, we can call the catalog to index
    it, and it will take all of the objects' attributes that have an index setup and
    includes them in the corresponding index. Once they are there, we can query the
    catalog by using specific attribute values, and get back the objects that match
    the query.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**是一个工具，它允许我们管理一组相关的索引，并通过使用一个或多个索引来对目录进行查询。我们可以向目录添加索引，以跟踪对象的特定属性。从那时起，每次我们创建一个新的对象时，我们都可以调用目录来索引它，它将包括所有具有索引设置的属性，并将它们包含在相应的索引中。一旦它们被包含在内，我们就可以通过使用特定的属性值来查询目录，并获取与查询匹配的对象。'
- en: Adding a simple search function to the application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向应用程序添加一个简单的搜索功能
- en: The catalog contains references to the actual objects that are stored in the
    ZODB, and each index is related to one attribute of these objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 目录包含对存储在ZODB中的实际对象的引用，每个索引都与这些对象的一个属性相关。
- en: To be able to search for an object in the catalog, the object needs to be indexed
    by the catalog. This works better if it happens at specific events in the lifetime
    of the object, so that it gets indexed at creation time and when it gets modified.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要在目录中搜索对象，对象需要被目录索引。如果它在对象的生命周期中的特定事件发生，这将更有效，这样它就可以在创建时和修改时被索引。
- en: Since working with the catalog is the best way of dealing with searches when
    using the ZODB, Grok comes with a class that allows us to easily hook into the
    catalog, create indexes, and perform searches. This class is called `grok.Indexes`,
    and allows us to define indexes and hook our application objects with the appropriate
    life cycle events, for automatic indexing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在使用ZODB时，通过目录处理搜索是最佳方式，因此Grok附带了一个类，允许我们轻松地连接到目录、创建索引和执行搜索。这个类被称为`grok.Indexes`，允许我们定义索引并将我们的应用程序对象与适当的生命周期事件挂钩，以实现自动索引。
- en: Defining a simple index
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个简单的索引
- en: 'Let''s define a simple index for the `title` attribute of a project, and show
    how to perform a search on the catalog by using it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的索引，用于项目的`title`属性，并展示如何通过使用它来在目录上执行搜索：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are going to create an index for the `Project` class, so we name our class
    `ProjectIndexes`. The name is not important, as the key is using `grok.Indexes`
    as a base for the class. The `grok.site` class annotation is used to signal to
    Grok which type of object in our application is going to use the indexes defined
    here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个针对`Project`类的索引，因此我们将我们的类命名为`ProjectIndexes`。名称并不重要，因为关键是使用`grok.Indexes`作为类的基类。`grok.site`类注解用于通知Grok在我们的应用程序中哪种类型的对象将使用这里定义的索引。
- en: Next, we need to tell Grok which objects will be automatically indexed when
    they are modified. This is done by using `grok.context` with either a class or
    an interface as the parameter. In this case, we select `IProject` as the interface
    that will mark the objects to be indexed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉Grok哪些对象在修改时将被自动索引。这是通过使用`grok.context`并使用类或接口作为参数来完成的。在这种情况下，我们选择`IProject`作为将标记要索引的对象的接口。
- en: 'Finally, we define the indexes themselves. In this example, we want the whole
    text of the `title` attribute to be searchable, so we will use a `Text` index.
    We''ll have more to say about the types of indexes shortly. For now, just note
    that the attribute that will be indexed is the same as the name of the index,
    which in this case means that the `title` attribute from the project model will
    be indexed in this catalog. It is possible to have an index named differently
    than the attribute to be indexed, but then we need to specify the real attribute
    name with the keyword parameter `attribute`, like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义索引本身。在这个例子中，我们希望`title`属性的全部文本都是可搜索的，因此我们将使用`Text`索引。我们很快就会详细介绍索引的类型。现在，只需注意将要被索引的属性与索引的名称相同，在这种情况下意味着项目模型中的`title`属性将在这个目录中被索引。也有可能将索引命名为与要索引的属性不同的名称，但那时我们需要使用关键字参数`attribute`来指定实际的属性名称，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's it. Simply by declaring the indexes in this class, Grok will take it
    upon itself to create the catalog and append the indexes to it, as well as keeping
    track of when an object needs to be reindexed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。仅仅通过在这个类中声明索引，Grok就会自己创建目录并将索引附加到它上面，同时还会跟踪何时需要重新索引对象。
- en: Creating the search view
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建搜索视图
- en: 'We will now create the search view that will allow us to see the catalog in
    action. First, let''s take a look at the view code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个搜索视图，以便我们可以看到目录的实际应用。首先，让我们看一下视图代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a view for the main application, and is named search. The important
    bit is in the `update` method. We receive a query as a parameter, which represents
    the text that the user is looking for inside the title of the projects. We then
    have to get the actual catalog before we can perform a search. Note that the catalog
    at this point will already contain the indexes that we defined earlier for `Project`.
    We don't have to do anything else to connect them with the catalog; Grok takes
    care of all the plumbing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个主应用程序的视图，命名为search。重要的是`update`方法。我们接收一个作为参数的查询，它代表了用户在项目标题中寻找的文本。在我们能够执行搜索之前，我们必须先获取实际的目录。请注意，此时的目录已经包含了我们之前为`Project`定义的索引。我们不需要做任何其他事情来将它们与目录连接起来；Grok会处理所有管道。
- en: After we get the `catalog` object, we can search it by using the `searchResults`
    method, which accepts key/value pairs with index names and query values. In this
    case, we pass the query that came in the request to the `title` index, so that
    we get all of the projects that match this query text in their titles, as results.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取到`catalog`对象之后，我们可以通过使用`searchResults`方法来搜索它，该方法接受键/值对，其中包含索引名称和查询值。在这种情况下，我们将请求中传入的查询传递给`title`索引，这样我们就能得到所有标题中包含此查询文本的项目，作为结果。
- en: You might recall that earlier we mentioned that interfaces, besides being useful
    for documentation and attribute introspection, are very helpful for working with
    component architectures. Under the hood, Grok contains a registry, which keeps
    track of all of the interface declarations for objects, so that it's possible
    to find an object by querying its interface. A catalog always implements the interface
    `ICatalog`, which is found in the `zope.app.catalog.interfaces` package included
    with Grok.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，我们之前提到过，接口除了对文档和属性自省有用之外，对于处理组件架构也非常有帮助。在底层，Grok包含一个注册表，它跟踪所有对象的接口声明，这样就可以通过查询接口来找到对象。目录总是实现`ICatalog`接口，该接口位于Grok附带`zope.app.catalog.interfaces`包中。
- en: As Grok is making our lives simpler by not forcing us to instantiate a catalog
    and manually add and populate indexes to it, we do not control the code where
    this happens. So how do we find it? By using the registry, we can query it for
    an object that implements the `ICatalog` interface and that will be the catalog
    that we are looking for.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Grok通过不强制我们实例化目录并手动添加和填充索引来简化我们的生活，我们无法控制代码执行此操作的部分。那么我们如何找到它呢？通过使用注册表，我们可以查询实现`ICatalog`接口的对象，这将是我们正在寻找的目录。
- en: 'That''s precisely what the `getUtility` method from the `zope.component` package
    does. So, after calling this method we will have the catalog referenced by our
    `catalog` variable. This might seem to be a roundabout mechanism for getting at
    the catalog. Why not simply have Grok define a global catalog and use that directly?
    Well, we can answer that with another question or two: what if we need more than
    one catalog? Or what if we decide to replace the catalog that Grok creates with
    our own? When using interfaces and component registration we can cover these cases
    and the code barely needs to be changed.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是`zope.component`包中的`getUtility`方法所做的事情。因此，在调用此方法之后，我们将拥有由我们的`catalog`变量引用的目录。这看起来可能是一种绕弯子的机制来获取目录。为什么不直接让Grok定义一个全局目录并直接使用它呢？好吧，我们可以用另一个或两个问题来回答：如果我们需要多个目录怎么办？或者如果我们决定用我们自己的目录替换Grok创建的目录怎么办？当使用接口和组件注册时，我们可以处理这些情况，并且代码几乎不需要更改。
- en: Creating a template to display the search results
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个模板来显示搜索结果
- en: 'Once we have the results placed in the view in the last line of the `update`
    method, we need a template to show this result. Create a template called `todosearch.pt`
    inside the `app_templates` directory. First comes the header, with our stylesheet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`update`方法的最后一行将结果放置在视图中，我们需要一个模板来显示这个结果。在`app_templates`目录内创建一个名为`todosearch.pt`的模板。首先是标题，包括我们的样式表：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we are going to add a search box inside our top header. We use `tal:attributes`
    to set the text input value to whatever we searched for before, or leave it empty
    if there was no previous search.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在页面的顶部标题内添加一个搜索框。我们使用`tal:attributes`将文本输入值设置为之前搜索的内容，或者如果之前没有搜索，则留空。
- en: 'The form action is set to call the search view that we defined earlier:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表单操作设置为调用我们之前定义的搜索视图：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now come to the heart of the matter. Recall that in the view we performed
    a search by title, and defined an attribute named `results`. Now we can use those
    results in the template. First, we need to make sure that we have something to
    show, and if we don''t, we will display a message saying so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了问题的关键。回想一下，在视图中我们通过标题进行了搜索，并定义了一个名为`results`的属性。现在我们可以在模板中使用这些结果。首先，我们需要确保我们有东西可以展示，如果没有，我们将显示一条消息说明这一点：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, if there are results, we prepare a table with the correct headings, and
    use `tal:repeat` to loop through the results. The view variable `results` contains
    all of the projects whose title matched the query, so we iterate through these
    results and simply show all of their attributes in a table similar to the one
    that we used for the dashboard.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果有结果，我们将准备一个带有正确标题的表格，并使用`tal:repeat`来遍历结果。视图变量`results`包含所有标题与查询匹配的项目，因此我们遍历这些结果，并在与仪表板相似的表格中简单地显示它们的所有属性。
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can create a new application instance in the Grok admin UI and define
    some projects so that we can see how the search works. The reason why we need
    to define a new application is that indexes only get created when an application
    is installed. Our `ProjectIndexes` class will actually do nothing if it gets added
    after the application was created. Take a look at the following screenshot, to
    see how the search results are displayed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的应用程序实例在Grok管理UI中，并定义一些项目，以便我们可以看到搜索是如何工作的。我们需要定义一个新的应用程序的原因是，索引只有在安装应用程序时才会创建。如果我们的`ProjectIndexes`类在应用程序创建后被添加，实际上将不会做任何事情。请看下面的截图，以了解搜索结果是如何显示的：
- en: '![Creating a template to display the search results](img/7481_06_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个模板来显示搜索结果](img/7481_06_01.jpg)'
- en: 'A brief diversion: Structuring our application for search'
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简短的偏离：为搜索结构化我们的应用程序
- en: Now that we have experimented with the basics of catalog searches, we'll need
    to refactor our application a little to play well with the catalog, because our
    to-do items don't have all the attributes we will likely need to make the search
    powerful enough. For instance, we are certainly going to be interested in searching
    for them by date and eventually by user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝试了目录搜索的基本操作，我们需要对我们的应用程序进行一些重构，以便与目录良好地协同工作，因为我们的待办事项没有所有我们可能需要的属性来使搜索足够强大。例如，我们肯定会通过日期来搜索它们，最终通过用户来搜索。
- en: Let's pause a bit and reflect on where we want our application to go. If we
    are going to be managing 'projects', we'll need to add some more attributes to
    our models. We have not bothered about this until now, but as the complexity of
    our application grows, it becomes more important to have a clear plan.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍作停顿，思考一下我们的应用程序想要走向何方。如果我们将要管理“项目”，我们需要在我们的模型中添加一些更多的属性。我们之前没有关心这个问题，但随着我们应用程序的复杂性增加，有一个清晰的计划变得更加重要。
- en: The top-level unit of our application will be a project. For our purposes, a
    *project* is a collection of related to-do lists. We will need to store the project's
    creation date as well as the last time it was modified. A project is 'done' when
    all of the items in all of its lists are checked off.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的最高级单元将是一个项目。就我们的目的而言，一个*项目*是一系列相关待办事项的集合。我们需要存储项目的创建日期以及最后一次修改日期。当一个项目的所有列表中的所有事项都被勾选时，该项目即为“完成”。
- en: The project can have owners and members. Members are users who have one or more
    items assigned; owners are members who can also add, edit, or remove lists and
    items. We haven't seen yet how user management works in Grok, but we will see
    it in the next chapter, so for now we'll just store the project's creator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以有所有者和成员。成员是分配了一个或多个事项的用户；所有者是成员，他们还可以添加、编辑或删除列表和事项。我们还没有看到Grok中用户管理的工作方式，但我们将看到它将在下一章中，所以现在我们只需存储项目的创建者。
- en: A to-do list can have any number of items. We'll also store the list's creation
    date. An item will have a completed date as well as a creation date. We'll also
    keep track of who performed each of these.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个待办事项列表可以有任意数量的事项。我们还将存储列表的创建日期。一个事项将有一个完成日期以及一个创建日期。我们还将跟踪谁执行了这些操作。
- en: In the previous chapter, we worked with forms that were automatically constructed
    by using interface schemas as a base. At that time, we only added an interface
    for the `Project` class. Let's finish that work and do the same for the other
    classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用接口模式作为基础自动构建了表单。当时，我们只为`Project`类添加了一个接口。让我们完成这项工作，并为其他类做同样的事情。
- en: We are dealing with different kinds of objects, but surely there will be some
    attributes that are used in most of them. For example, every project, list, and
    item will have a creator and a creation date. We'd like to avoid repeating these
    attributes on every interface definition, so we'll create a general interface
    for them and make all other classes implement this.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理不同类型的对象，但肯定有一些属性在它们中的大多数都会用到。例如，每个项目、列表和事项都将有一个创建者和创建日期。我们希望避免在每个接口定义中重复这些属性，因此我们将为它们创建一个通用接口，并让所有其他类实现这个接口。
- en: We discussed interfaces briefly before, when working with forms, and saw that
    a class can promise to implement an interface simply by saying that it does so
    by using the `grok.implements` class annotation. However, a class is not limited
    to implementing a single interface. In fact, there's no limit to the number of
    interfaces that a class can implement. This will be useful for us because all
    of our classes can implement both the general metadata interfaces as well as their
    own particular interfaces.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在处理表单时简要讨论了接口，并看到一个类可以通过使用`grok.implements`类注解来承诺实现一个接口。然而，一个类并不局限于实现单个接口。实际上，一个类可以实现的接口数量是没有限制的。这对我们来说将是有用的，因为我们的所有类都可以实现通用的元数据接口以及它们自己的特定接口。
- en: 'Our refactored models will look like the code below. First, our shared attributes
    interface:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构后的模型将类似于下面的代码。首先，我们的共享属性接口：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The main application class does not need to use the metadata schema; only its
    own schema will be used:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 主要应用程序类不需要使用元数据模式；只使用它自己的模式：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We added `title` and `next_id` to the schema and set default values for the
    class, after the `grok.implements` call.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`grok.implements`调用之后向模式中添加了`title`和`next_id`，并为类设置了默认值。
- en: 'Now look at the `Project` class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看`Project`类：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, we define the `Project` schema, and then tell Grok that this
    class will use both the schemas this one and the metadata schema that we defined
    earlier. This is fairly simple: we just pass the two interface definitions as
    arguments to `grok.implements`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们定义了`Project`模式，然后告诉Grok这个类将使用这个模式和之前定义的元数据模式。这相当简单：我们只需将两个接口定义作为参数传递给`grok.implements`。
- en: 'We''ll use the new attributes when a new project is added to the application,
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当向应用程序添加新项目时，我们将使用新属性，如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After creating a new project and applying the form data to it, we set values
    for the dates and creator. Keep in mind that interfaces are informative. We are
    never required to use all of the fields in an interface's schema, but it's very
    convenient to be able to refer to the schema for documentation purposes. In some
    cases, it is used to generate a form using one or more fields from it. Incidentally,
    it's probably very clear what's happening in the date assignments, but the `self.request.principal.title`
    line may seem a bit odd. A **principal** is a user in Grok, and its title is a
    string description of who this user is.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新项目并将表单数据应用于它之后，我们为日期和创建者设置值。请记住，接口是信息性的。我们从不要求使用接口模式中的所有字段，但能够为了文档目的而引用模式是非常方便的。在某些情况下，它被用来使用一个或多个字段生成表单。顺便提一下，日期分配发生的事情可能非常清楚，但`self.request.principal.title`这一行可能看起来有点奇怪。**principal**是Grok中的一个用户，其标题是这个用户的字符串描述。
- en: 'That''s all there is to know for now about our model restructuring. Here are
    the final two models:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们模型重构的介绍到此为止。以下是最后的两个模型：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have added the desired attributes and interfaces, let''s create
    a home page template where we can see at a glance all our projects and their attributes,
    along with links to every project. This will be our application''s dashboard.
    While we are at it, let''s add a search box at the top, too. We''ll start by adding
    a view for our dashboard:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所需的属性和接口，让我们创建一个主页模板，我们可以一眼看到所有项目及其属性，以及每个项目的链接。这将是我们应用程序的仪表板。在此过程中，我们还在顶部添加了一个搜索框。我们将首先添加仪表板的视图：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, for the template, call the `dashboard.pt` file and place it inside `app_templates`.
    Notice how we use the name `index`, so that this will be the default view for
    the application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于模板，调用`dashboard.pt`文件并将其放置在`app_templates`中。注意我们使用名称`index`，这样它将成为应用程序的默认视图：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The template is very straightforward. We just get all of the projects by using
    the `context/values` call and then iterate through the results showing all of
    the attributes in a table. The template can be seen in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 模板非常直接。我们只需使用`context/values`调用获取所有项目，然后遍历结果，在表格中显示所有属性。模板可以在以下屏幕截图中看到：
- en: '![A brief diversion: Structuring our application for search](img/7481_06_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![一个简短的偏离：为搜索结构化我们的应用程序](img/7481_06_02.jpg)'
- en: 'Back to search: Using multiple indexes'
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到搜索：使用多个索引
- en: Let's recap briefly where we were with respect to the search before we set out
    to reorganize our code. The key thing to understand when using the catalog in
    Grok is that the indexes define the kinds of searches that we can perform. In
    our example, we used a `Text` index for the `title` attribute and the Grok context
    for that index was the `Project` model. This means that even if a project has
    several attributes, we can only search inside the title, at this point.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下在开始重新组织代码之前我们在搜索方面的位置。在使用Grok中的目录时，要理解的关键点是索引定义了我们能执行哪些类型的搜索。在我们的例子中，我们使用了`Text`索引来搜索`title`属性，而这个索引的Grok上下文是`Project`模型。这意味着即使一个项目有多个属性，我们目前也只能在标题中进行搜索。
- en: 'We are not limited to using only one index, of course. We can add any number
    of indexes even one for every attribute of the object. Let''s add one for `description`,
    immediately after the title in the `ProjectIndexes` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不仅限于使用一个索引。我们可以添加任意数量的索引，甚至可以为对象的每个属性添加一个。让我们在`ProjectIndexes`类中立即在标题之后添加一个用于`description`的索引：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that the only thing that changes is the index name, which points to the
    actual attribute to be indexed. To keep things simple for now, we can use the
    following query:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，唯一改变的是索引名称，它指向要索引的实际属性。为了保持简单，我们可以使用以下查询：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We pass the `query` parameter to both indexes, because all we have is a text
    box with room for one parameter. The results will be all of the projects for which
    both the title and description match the values specified in the query. If we
    had several parameters, we could pass a different value to each index and we would
    get back all of the items where all indexes match.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `query` 参数传递给两个索引，因为我们只有一个可以容纳一个参数的文本框。结果将包括所有标题和描述与查询中指定的值匹配的项目。如果我们有几个参数，我们可以为每个索引传递不同的值，并且我们会得到所有索引都匹配的所有条目。
- en: Let's consider how we would like the search box to work in this application.
    The ideal thing would be for it to be as inclusive as possible, so that we could
    type a word or two and have the catalog look at different indexes to find results.
    For example, it would be good if a text search could be performed in such a way
    that the catalog returns all items that match the query either on the `description`
    or the `title` indexes. As this is a common situation, Grok offers a solution
    that is generally useful and also easy to implement. Basically, we can define
    a method that can collect information from all of the attributes and return the
    collected information as a single index.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑在这个应用程序中我们希望搜索框如何工作。理想的情况是尽可能全面，这样我们就可以输入一个或两个词，让目录查看不同的索引以找到结果。例如，如果可以对
    `description` 或 `title` 索引执行文本搜索，并且目录返回所有在查询中匹配这些索引的条目，那就很好了。由于这是一个常见的情况，Grok
    提供了一个通常很有用且易于实现的解决方案。基本上，我们可以定义一个方法，它可以收集所有属性的信息，并将收集到的信息作为单个索引返回。
- en: First, we add an empty method definition to our interface. This is done both
    to document the method and to let the `grok.Indexes` class find the attribute
    when we declare its name as an index. Remember, the project indexes are connected
    to the `IProject` interface, so that every attribute or method defined here may
    be used as an index for searching.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在接口中添加一个空的方法定义。这样做既是为了记录方法，也是为了让 `grok.Indexes` 类在我们声明其名称为索引时找到该属性。记住，项目索引与
    `IProject` 接口相关联，因此这里定义的每个属性或方法都可以用作搜索索引。
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Pay attention to the absence of a `self` parameter inside the method definition.
    This parameter is not necessary because we are not defining a class, but an interface.
    It is customary to include a description of the method as a comment in the body
    of its definition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方法定义内部缺少 `self` 参数。这个参数不是必需的，因为我们不是定义一个类，而是一个接口。通常，我们会在定义体的注释中包含对方法的描述。
- en: 'We then add this method''s name as an index in the `ProjectIndexes` class,
    like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `ProjectIndexes` 类中将此方法的名称作为一个索引添加，如下所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Grok uses the interface definition to find a method or attribute with this
    name. If it''s a method, it will be called at the time of indexing, so what is
    happening here is that we are informing Grok that the full-text entry for a project
    will be available by calling its own `searchableText` method. This method is then
    defined in the `Project` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Grok 使用接口定义来查找具有该名称的方法或属性。如果是一个方法，它将在索引时被调用，因此这里发生的情况是我们正在通知 Grok，通过调用其自身的 `searchableText`
    方法，一个项目的全文条目将可用。这个方法在 `Project` 类中定义如下：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The method is extremely simple. We just return the `title` and `description`
    attributes as a single string, so that the index will actually include both fields.
    In this way, we can search both of them at the same time by querying the catalog
    with the new `searchableText` index:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常简单。我们只需将 `title` 和 `description` 属性作为单个字符串返回，这样索引实际上将包括这两个字段。通过使用新的 `searchableText`
    索引查询目录，我们可以同时搜索这两个字段：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's all we need to cover this requirement, but as we can see, this approach
    can be used to have the `index` method return any kind of content, which gives
    us enough freedom to create any number of combined indexes that we may need.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了对这个要求的覆盖，但正如我们所看到的，这种方法可以用来让 `index` 方法返回任何类型的内容，这给了我们足够的自由来创建我们可能需要的任何数量的组合索引。
