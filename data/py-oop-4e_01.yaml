- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Object-Oriented Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象设计
- en: In software development, design is often considered as the step that's done
    *before* programming. This isn't true; in reality, analysis, programming, and
    design tend to overlap, combine, and interweave. Throughout this book, we'll be
    covering a mixture of design and programming issues without trying to parse them
    into separate buckets. One of the advantages of a language like Python is the
    ability to express the design clearly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，设计通常被认为是编程之前进行的步骤。这并不正确；实际上，分析、编程和设计往往相互重叠、结合和交织。在这本书中，我们将涵盖设计和编程的混合问题，而不会试图将它们解析成单独的类别。Python语言的一个优点是能够清晰地表达设计。
- en: 'In this chapter, we will talk a little about how we can move from a good idea
    toward writing software. We''ll create some design artifacts – like diagrams –
    that can help clarify our thinking before we start writing code. We''ll cover
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要讨论如何从好的想法过渡到编写软件。我们将创建一些设计工件——如图表——在开始编写代码之前帮助我们澄清思路。我们将涵盖以下主题：
- en: What object-oriented means
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的意义
- en: The difference between object-oriented design and object-oriented programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象设计与面向对象编程之间的区别
- en: The basic principles of object-oriented design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象设计的基本原则
- en: Basic **Unified Modeling Language** (**UML**) and when it isn't evil
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的**统一建模语言**（**UML**）及其不是邪恶的一面
- en: 'We will also introduce this book''s object-oriented design case study, using
    the "4+1" architectural view model. We''ll touch on a number of topics here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍这本书的面向对象设计案例研究，使用“4+1”架构视图模型。在这里，我们将涉及以下主题：
- en: An overview of a classic machine learning application, the famous Iris classification
    problem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典机器学习应用概述，著名的鸢尾花分类问题
- en: The general processing context for this classifier
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此分类器的一般处理上下文
- en: Sketching out two views of the class hierarchy that look like they'll be adequate
    to solve the problem
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制两个看起来足以解决问题的类层次结构视图
- en: Introducing object-oriented
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍面向对象
- en: 'Everyone knows what an object is: a tangible thing that we can sense, feel,
    and manipulate. The earliest objects we interact with are typically baby toys.
    Wooden blocks, plastic shapes, and over-sized puzzle pieces are common first objects.
    Babies learn quickly that certain objects do certain things: bells ring, buttons
    are pressed, and levers are pulled.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道什么是对象：一个我们可以感知、触摸和操作的有形事物。我们最早与之互动的对象通常是婴儿玩具。木块、塑料形状和超大的拼图块是常见的第一种对象。婴儿很快就会学会某些对象会做某些事情：铃铛会响，按钮会被按下，杠杆会被拉动。
- en: The definition of an object in software development is not terribly different.
    Software objects may not be tangible things that you can pick up, sense, or feel,
    but they are models of something that can do certain things and have certain things
    done to them. Formally, an object is a collection of **data** and associated **behaviors**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中对象的定义与实际物体并没有太大的区别。软件对象可能不是你可以拿起、感知或触摸的有形事物，但它们是某些可以执行特定操作和被施加特定操作的模型。正式来说，一个对象是一组**数据**和相关的**行为**的集合。
- en: Considering what an object is, what does it mean to be object-oriented? In the
    dictionary, *oriented* means *directed toward*. Object-oriented programming means
    writing code directed toward modeling objects. This is one of many techniques
    used for describing the actions of complex systems. It is defined by describing
    a collection of interacting objects via their data and behavior.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到对象是什么，面向对象意味着什么？在词典中，“面向”意味着“指向”。面向对象编程意味着编写指向建模对象的代码。这是描述复杂系统行为所使用的技术之一。它通过描述一组通过其数据和行为的交互对象来定义。
- en: If you've read any hype, you've probably come across the terms *object-oriented
    analysis*, *object-oriented design*, *object-oriented analysis and design*, and *object-oriented
    programming*. These are all related concepts under the general *object-oriented* umbrella.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过任何炒作内容，你可能已经遇到过诸如*面向对象分析*、*面向对象设计*、*面向对象分析与设计*和*面向对象编程*等术语。这些都是属于一般*面向对象*范畴下的相关概念。
- en: In fact, analysis, design, and programming are all stages of software development.
    Calling them object-oriented simply specifies what kind of software development
    is being pursued.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，分析、设计和编程都是软件开发的不同阶段。将它们称为面向对象只是简单地指明了正在追求的软件开发类型。
- en: '**Object-oriented analysis** (**OOA**) is the process of looking at a problem,
    system, or task (that somebody wants to turn into a working software application)
    and identifying the objects and interactions between those objects. The analysis
    stage is all about *what* needs to be done.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象分析**（**OOA**）是查看一个问题、系统或任务（某人希望将其转换成可工作的软件应用）并识别这些对象及其之间交互的过程。分析阶段完全是关于
    *需要做什么*。'
- en: 'The output of the analysis stage is a description of the system, often in the
    form of *requirements*. If we were to complete the analysis stage in one step,
    we would have turned a task, such as *As a botanist, I need a website to help
    users classify plants so I can help with correct identification*, into a set of
    required features. As an example, here are some requirements as to what a website
    visitor might need to do. Each item is an action bound to an object; we''ve written
    them with *italics* to highlight the actions, and **bold** to highlight the objects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 分析阶段的输出是对系统的描述，通常以 *需求* 的形式呈现。如果我们一次性完成分析阶段，我们将一个任务，例如 *作为一个植物学家，我需要一个网站来帮助用户分类植物，以便我能帮助进行正确的识别*，转换成一系列所需的功能。以下是一些可能需要网站访问者执行的要求。每一项都是一个与对象相关的动作；我们用
    *斜体* 来突出动作，用 **粗体** 来突出对象：
- en: '*Browse* **Previous Uploads**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浏览* **之前的上传**'
- en: '*Upload new* **Known Examples**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上传新的* **已知示例**'
- en: '*Test* for **Quality**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试* **质量**'
- en: '*Browse* **Products**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浏览* **产品**'
- en: '*See* **Recommendations**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查看* **推荐**'
- en: In some ways, the term *analysis* is a misnomer. The baby we discussed earlier
    doesn't analyze the blocks and puzzle pieces. Instead, she explores her environment,
    manipulates shapes, and sees where they might fit. A better turn of phrase might
    be *object-oriented exploration*. In software development, the initial stages
    of analysis include interviewing customers, studying their processes, and eliminating
    possibilities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，术语 *分析* 是一个误称。我们之前讨论的那个婴儿并不是分析积木和拼图块。相反，她探索她的环境，操作形状，并看看它们可能适合在哪里。更好的说法可能是
    *面向对象探索*。在软件开发中，分析的初始阶段包括采访客户、研究他们的流程和排除可能性。
- en: '**Object-oriented design** (**OOD**) is the process of converting such requirements
    into an implementation specification. The designer must name the objects, define
    the behaviors, and formally specify which objects can activate specific behaviors
    on other objects. The design stage is all about transforming *what* should be
    done into *how* it should be done.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象设计**（**OOD**）是将此类需求转换成实现规范的过程。设计者必须命名对象、定义行为，并正式指定哪些对象可以激活其他对象上的特定行为。设计阶段完全是关于将
    *应该做什么* 转换为 *应该如何做*。'
- en: The output of the design stage is an implementation specification. If we were
    to complete the design stage in a single step, we would have turned the requirements
    defined during object-oriented analysis into a set of classes and interfaces that
    could be implemented in (ideally) any object-oriented programming language.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设计阶段的输出是实现规范。如果我们一次性完成设计阶段，我们将面向对象分析期间定义的需求转换成一组可以在（理想情况下）任何面向对象编程语言中实现的面类和接口。
- en: '**Object-oriented programming** (**OOP**) is the process of converting a design
    into a working program that does what the product owner originally requested.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）是将设计转换成能够执行产品所有者最初请求的功能的工作程序的过程。'
- en: Yeah, right! It would be lovely if the world met this ideal and we could follow
    these stages one by one, in perfect order, like all the old textbooks told us
    to. As usual, the real world is much murkier. No matter how hard we try to separate
    these stages, we'll always find things that need further analysis while we're
    designing. When we're programming, we find features that need clarification in
    the design.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，对吧！如果世界符合这个理想，我们能够按部就班地遵循这些阶段，就像所有老教科书告诉我们的那样，那将是多么美好。但通常情况下，现实世界要复杂得多。无论我们多么努力地试图将这些阶段分开，我们总会发现设计过程中需要进一步分析的事情。当我们编程时，我们会发现设计中的某些功能需要澄清。
- en: Most 21st century development recognizes that this cascade (or waterfall) of
    stages doesn't work out well. What seems to be better is an *iterative* development
    model. In iterative development, a small part of the task is modeled, designed,
    and programmed, and then the product is reviewed and expanded to improve each
    feature and include new features in a series of short development cycles.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 21世纪的大多数开发都认识到这种阶段（或瀑布）的级联并不奏效。似乎更好的是一个**迭代**的开发模型。在迭代开发中，一小部分任务被建模、设计和编程，然后产品被审查和扩展，以改进每个特性并在一系列短暂的开发周期中包含新特性。
- en: The rest of this book is about object-oriented programming, but in this chapter,
    we will cover the basic object-oriented principles in the context of design. This
    allows us to understand concepts without having to argue with software syntax
    or Python tracebacks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余部分将介绍面向对象编程，但本章我们将从设计角度介绍基本面向对象原则。这使我们能够在不与软件语法或Python跟踪回溯争论的情况下理解概念。
- en: Objects and classes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象和类
- en: An **object** is a collection of data with associated behaviors. How do we differentiate
    between types of objects? Apples and oranges are both objects, but it is a common
    adage that they cannot be compared. Apples and oranges aren't modeled very often
    in computer programming, but let's pretend we're doing an inventory application
    for a fruit farm. To facilitate this example, we can assume that apples go in
    barrels and oranges go in baskets.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**是一组具有相关行为的数据集合。我们如何区分不同类型的对象？苹果和橙子都是对象，但有一个常见的谚语说它们不能比较。在计算机编程中，苹果和橙子模型化得并不常见，但让我们假设我们正在为一个水果农场开发一个库存应用程序。为了方便这个例子，我们可以假设苹果放在桶里，橙子放在篮子里。'
- en: 'The problem domain we''ve uncovered so far has four kinds of objects: apples,
    oranges, baskets, and barrels. In object-oriented modeling, the term used for
    a *kind of object* is **class**. So, in technical terms, we now have four classes
    of objects.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止发现的问题域有四种类型的对象：苹果、橙子、篮子和桶。在面向对象建模中，用于表示“对象类型”的术语是**类**。因此，从技术角度讲，我们现在有四个对象类。
- en: 'It''s important to understand the difference between an object and a class.
    Classes describe related objects. They are like blueprints for creating an object.
    You might have three oranges sitting on the table in front of you. Each orange
    is a distinct object, but all three have the attributes and behaviors associated
    with one class: the general class of oranges.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理解对象和类之间的区别很重要。类描述相关对象。它们是创建对象的蓝图。你面前桌子上可能有三只橙子。每只橙子都是一个独特的对象，但它们都具有与一个类相关联的属性和行为：橙子的一般类别。
- en: 'The relationship between the four classes of objects in our inventory system
    can be described using a **Unified Modeling Language** (invariably referred to
    as **UML**, because three-letter acronyms never go out of style) class diagram.
    Here is our first *class diagram*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们库存系统中四个对象类之间的关系可以使用**统一建模语言**（通常简称为**UML**，因为三字母的首字母缩略词永远不会过时）类图来描述。这是我们第一个**类图**：
- en: '![Diagram  Description automatically generated](img/B17070_01_01.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图示  描述自动生成](img/B17070_01_01.png)'
- en: 'Figure 1.1: Class diagram'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：类图
- en: This diagram shows that instances of the **Orange** class (usually called "oranges")
    are somehow associated with a **Basket** and that instances of the **Apple** class
    ("apples") are also somehow associated with a **Barrel**. *Association* is the
    most basic way for instances of two classes to be related.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示**橙子**类（通常称为“橙子”）与某种方式关联着**篮子**，而**苹果**类（“苹果”）也与某种方式关联着**桶**。**关联**是两个类实例之间关系最基本的方式。
- en: The syntax of a UML diagram is generally pretty obvious; you don't have to read
    a tutorial to (mostly) understand what is going on when you see one. UML is also
    fairly easy to draw, and quite intuitive. After all, many people, when describing
    classes and their relationships, will naturally draw boxes with lines between
    them. Having a standard based on these intuitive diagrams makes it easy for programmers to
    communicate with designers, managers, and each other.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: UML图（统一建模语言）的语法通常很直观；你不需要阅读教程就能（大部分）理解你看到的内容。UML也相当容易绘制，而且非常直观。毕竟，当描述类及其关系时，许多人会自然地画上带有线条的盒子。基于这些直观的图的标准使得程序员与设计师、经理和彼此之间的沟通变得容易。
- en: Note that the UML diagram generally depicts the class definitions, but we're
    describing attributes of the objects. The diagram shows the class of Apple and
    the class of Barrel, telling us that a given apple is in a specific barrel. While
    we can use UML to depict individual objects, that's rarely necessary. Showing
    these classes tells us enough about the objects that are members of each class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，UML 图通常表示类定义，但我们描述的是对象的属性。该图显示了苹果类和桶类，告诉我们一个特定的苹果位于一个特定的桶中。虽然我们可以使用 UML 来表示单个对象，但这通常是不必要的。显示这些类足以让我们了解每个类成员对象的属性。
- en: Some programmers disparage UML as a waste of time. Citing iterative development,
    they will argue that formal specifications done up in fancy UML diagrams are going
    to be redundant before they're implemented, and that maintaining these formal
    diagrams will only waste time and not benefit anyone.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员贬低 UML 为浪费时间。引用迭代开发，他们会争辩说，用花哨的 UML 图做出来的正式规范在实施之前就会变得冗余，而且维护这些正式图只会浪费时间，对任何人都没有好处。
- en: Every programming team consisting of more than one person will occasionally
    have to sit down and hash out the details of the components being built. UML is
    extremely useful for ensuring quick, easy, and consistent communication. Even
    those organizations that scoff at formal class diagrams tend to use some informal
    version of UML in their design meetings or team discussions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个由多个人组成的编程团队都偶尔需要坐下来讨论正在构建的组件的细节。UML 对于确保快速、简单和一致的沟通非常有用。即使那些嘲笑正式类图的组织，在设计会议或团队讨论中也倾向于使用一些非正式版本的
    UML。
- en: Furthermore, the most important person you will ever have to communicate with
    is your future self. We all think we can remember the design decisions we've made,
    but there will always be *Why did I do that?* moments hiding in our future. If
    we keep the scraps of papers we did our initial diagramming on when we started
    a design, we'll eventually find them to be a useful reference.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将不得不与之沟通的最重要的人是你的未来的自己。我们都认为我们可以记住我们做出的设计决策，但总会有隐藏在我们未来的“我为什么这么做？”的时刻。如果我们保留我们在开始设计时进行初始绘图时所用的纸张碎片，我们最终会发现它们是有用的参考资料。
- en: This chapter, however, is not meant to be a tutorial on UML. There are many
    of those available on the internet, as well as numerous books on the topic. UML
    covers far more than class and object diagrams; it also has a syntax for use cases,
    deployment, state changes, and activities. We'll be dealing with some common class
    diagram syntax in this discussion of object-oriented design. You can pick up the
    structure by example, and then you'll subconsciously choose the UML-inspired syntax
    in your own team or personal design notes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章的目的并不是要成为 UML 的教程。互联网上有许多这样的教程，以及关于该主题的许多书籍。UML 不仅涵盖类和对象图，还有用例、部署、状态变化和活动的语法。在本章讨论面向对象设计时，我们将处理一些常见的类图语法。你可以通过示例来掌握结构，然后你会在自己的团队或个人设计笔记中无意识地选择受
    UML 启发的语法。
- en: Our initial diagram, while correct, does not remind us that apples go in barrels
    or how many barrels a single apple can go in. It only tells us that apples are
    somehow associated with barrels. The association between classes is often obvious
    and needs no further explanation, but we have the option to add further clarification
    as needed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始图虽然正确，但没有提醒我们苹果放入桶中，或者一个苹果可以放入多少个桶中。它只告诉我们苹果以某种方式与桶相关联。类之间的关联通常是显而易见的，不需要进一步解释，但我们有选择添加进一步说明的选项。
- en: The beauty of UML is that most things are optional. We only need to specify
    as much information in a diagram as makes sense for the current situation. In
    a quick whiteboard session, we might just draw simple lines between boxes. In
    a formal document, we might go into more detail.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: UML 的美在于大多数事情都是可选的。我们只需要在图中指定当前情况下有意义的信息。在快速的白板会议中，我们可能只是简单地画一些盒子之间的线条。在正式的文档中，我们可能会更详细一些。
- en: 'In the case of apples and barrels, we can be fairly confident that the association
    is **many apples go in one barrel**, but just to make sure nobody confuses it
    with **one apple spoils one barrel**, we can enhance the diagram, as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在苹果和桶的情况下，我们可以相当有信心地认为关联是**许多苹果放入一个桶中**，但为了确保没有人将其与**一个苹果毁了一个桶**混淆，我们可以增强该图，如图所示：
- en: '![Diagram  Description automatically generated with medium confidence](img/B17070_01_02.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成，置信度中等](img/B17070_01_02.png)'
- en: 'Figure 1.2: Class diagram with more detail'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：带有更多详细信息的类图
- en: This diagram tells us that oranges **go in** baskets, with a little arrow showing
    what goes in what. It also tells us the number of that object that can be used
    in the association on both sides of the relationship. One **Basket** can hold
    many (represented by a *****) **Orange** objects. Any one **Orange** can go in
    exactly one **Basket**. This number is referred to as the *multiplicity* of the
    object. You may also hear it described as the *cardinality*; it can help to think
    of cardinality as a specific number or range, and what we're using here, multiplicity,
    as a generalized "more-than-one instance".
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表告诉我们橙子**放入**篮子里，有一个小箭头显示是什么放入什么。它还告诉我们该对象在关系两边的关联中可以使用的数量。一个**篮子**可以容纳许多（用****表示）**橙子**对象。任何一个**橙子**可以放入恰好一个**篮子**。这个数字被称为对象的**多重性**。你也可能听到它被描述为**基数**；将基数视为一个特定的数字或范围，而在这里我们使用的多重性是一个广义的“多于一个实例”。
- en: We may sometimes forget which end of the relationship line is supposed to have
    which multiplicity number. The multiplicity nearest to a class is the number of
    objects of that class that can be associated with any one object at the other
    end of the association. For the apple goes in barrel association, reading from
    left to right, many instances of the **Apple** class (that is, many **Apple** objects)
    can go in any one **Barrel**. Reading from right to left, exactly one **Barrel** can
    be associated with any one **Apple**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时可能会忘记关系线哪一端应该有哪个多重性数字。离类最近的多重性是该类对象可以与关系另一端的任何单个对象关联的对象数量。对于苹果进桶的关联，从左到右读取，许多**苹果**类的实例（即许多**苹果**对象）可以放入任何一个**桶**。从右到左读取，恰好一个**桶**可以与任何一个**苹果**关联。
- en: We've seen the basics of classes, and how they specify relationships among objects.
    Now, we need to talk about the attributes that define an object's state, and the
    behaviors of an object that may involve state change or interaction with other
    objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了类的基本知识，以及它们如何指定对象之间的关系。现在，我们需要谈论定义对象状态的属性，以及可能涉及状态变化或与其他对象交互的对象行为。
- en: Specifying attributes and behaviors
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定属性和行为
- en: We now have a grasp of some basic object-oriented terminology. Objects are instances
    of classes that can be associated with each other. A class instance is a specific
    object with its own set of data and behaviors; a specific orange on the table
    in front of us is said to be an instance of the general class of oranges.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经掌握了某些基本的面向对象术语。对象是类的实例，它们可以相互关联。类实例是一个具有自己数据集和行为的具体对象；我们面前桌子上的一个特定橙子被称为橙子这一通用类的一个实例。
- en: The orange has a state, for example, ripe or raw; we implement the state of
    an object via the values of specific attributes. An orange also has behaviors.
    By themselves, oranges are generally passive. State changes are imposed on them.
    Let's dive into the meaning of those two words, *state* and *behaviors*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 橙子有一个状态，例如，成熟或生；我们通过特定属性值来实现对象的状态。橙子也有行为。单独来看，橙子通常是被动无反应的。状态变化是强加给它们的。让我们深入探讨这两个词的含义，即*状态*和*行为*。
- en: Data describes object state
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据描述对象状态
- en: Let's start with data. Data represents the individual characteristics of a certain
    object; its current state. A class can define specific sets of characteristics
    that are part of all objects that are members of that class. Any specific object
    can have different data values for the given characteristics. For example, the
    three oranges on our table (if we haven't eaten any) could each weigh a different
    amount. The orange class could have a weight attribute to represent that datum.
    All instances of the orange class have a weight attribute, but each orange has
    a different value for this attribute. Attributes don't have to be unique, though;
    any two oranges may weigh the same amount.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从数据开始。数据代表某个对象的个别特征；它的当前状态。一个类可以定义一组特定的特征，这些特征是那个类所有成员对象的一部分。任何特定对象都可以为给定的特征有不同的数据值。例如，我们桌子上的三个橙子（如果我们没有吃掉任何的话）可能每个的重量都不同。橙子类可以有一个重量属性来表示这个数据。橙子类的所有实例都有一个重量属性，但每个橙子这个属性的值都不同。属性不必是唯一的；任何两个橙子可能重量相同。
- en: Attributes are frequently referred to as **members** or **properties**. Some
    authors suggest that the terms have different meanings, usually that attributes
    are settable, while properties are read-only. A Python property can be defined
    as read-only, but the value will be based on attribute values that are – ultimately
    – writable, making the concept of *read-only* rather pointless; throughout this
    book, we'll see the two terms used interchangeably. In addition, as we'll discuss
    in *Chapter 5*, *When to Use Object-Oriented Programming*, the `property` keyword
    has a special meaning in Python for a particular kind of attribute.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通常被称为**成员**或**属性**。一些作者建议这两个术语有不同的含义，通常认为属性是可设置的，而属性是只读的。Python的属性可以被定义为只读的，但值将基于最终可写的属性值，这使得**只读**的概念变得相当没有意义；在这本书中，我们将看到这两个术语被交替使用。此外，正如我们将在*第5章*中讨论的，*何时使用面向对象编程*，Python中的`property`关键字对于特定类型的属性有特殊的意义。
- en: In Python, we can also call an attribute an **instance variable**. This can
    help clarify the way attributes work. They are variables with unique values for
    each instance of a class. Python has other kinds of attributes, but we'll focus
    on the most common kind to get started.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们也可以将属性称为**实例变量**。这有助于阐明属性的工作方式。它们是具有每个类实例唯一值的变量。Python有其他类型的属性，但我们将专注于最常见的类型以开始。
- en: In our fruit inventory application, the fruit farmer may want to know what orchard
    the orange came from, when it was picked, and how much it weighs. They might also
    want to keep track of where each **Basket** is stored. Apples might have a color
    attribute, and barrels might come in different sizes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的水果库存应用程序中，水果农民可能想知道橙子来自哪个果园，什么时候采摘的，以及它的重量。他们还可能想要跟踪每个**篮子**的存放位置。苹果可能有颜色属性，而桶可能有不同的大小。
- en: 'Some of these properties may also belong to multiple classes (we may want to
    know when apples are picked, too), but for this first example, let''s just add
    a few different attributes to our class diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些属性可能属于多个类（我们可能还想知道苹果何时采摘），但在这个第一个例子中，让我们只为我们的类图添加一些不同的属性：
- en: '![Diagram  Description automatically generated](img/B17070_01_03.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图示  描述自动生成](img/B17070_01_03.png)'
- en: 'Figure 1.3: Class diagram with attributes'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：具有属性的类图
- en: Depending on how detailed our design needs to be, we can also specify the type
    for each attribute's value. In UML, attribute types are often generic names common
    to many programming languages, such as integer, floating-point number, string,
    byte, or Boolean. However, they can also represent generic collections such as
    lists, trees, or graphs, or most notably, other, non-generic, application-specific
    classes. This is one area where the design stage can overlap with the programming
    stage. The various primitives and built-in collections available in one programming
    language may be different from what is available in another.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的设计需要有多详细，我们还可以指定每个属性值的类型。在UML中，属性类型通常是许多编程语言通用的通用名称，如整数、浮点数、字符串、字节或布尔值。然而，它们也可以表示通用集合，如列表、树或图，或者最值得注意的是，其他非通用、特定于应用程序的类。这是设计阶段可以与编程阶段重叠的一个领域。一种编程语言中可用的各种原语和内置集合可能与另一种语言中可用的不同。
- en: 'Here''s a version with (mostly) Python-specific type hints:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个（主要）针对Python特定类型提示的版本：
- en: '![Diagram  Description automatically generated](img/B17070_01_04.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图示  描述自动生成](img/B17070_01_04.png)'
- en: 'Figure 1.4: Class diagram with attributes and their types'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：具有属性及其类型的类图
- en: Usually, we don't need to be overly concerned with data types at the design
    stage, as implementation-specific details are chosen during the programming stage.
    Generic names are normally sufficient for design; that's why we included `date`
    as a placeholder for a Python type like `datetime.datetime`. If our design calls
    for a list container type, Java programmers can choose to use a `LinkedList` or
    an `ArrayList` when implementing it, while Python programmers (that's us!) might
    specify `List[Apple]` as a type hint, and use the `list` type for the implementation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在设计阶段，我们不需要过分关注数据类型，因为实现特定的细节是在编程阶段选择的。通用名称通常足以用于设计；这就是为什么我们包括了`date`作为Python类型`datetime.datetime`的占位符。如果我们的设计需要列表容器类型，Java程序员可以选择在实现时使用`LinkedList`或`ArrayList`，而Python程序员（也就是我们！）可能会指定`List[Apple]`作为类型提示，并使用`list`类型进行实现。
- en: In our fruit-farming example so far, our attributes are all basic primitives.
    However, there are some implicit attributes that we can make explicit – the associations.
    For a given orange, we have an attribute referring to the basket that holds that
    orange, the `basket` attribute, with a type hint of `Basket`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的果农例子中，我们的属性都是基本原语。然而，还有一些隐含的属性我们可以使其显式化——这些是关联。对于一个特定的橙子，我们有一个指向包含该橙子的篮子的属性，即`basket`属性，其类型提示为`Basket`。
- en: Behaviors are actions
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为是动作
- en: Now that we know how data defines the object's state, the last undefined term
    we need to look at is *behaviors*. Behaviors are actions that can occur on an
    object. The behaviors that can be performed on a specific class of object are
    expressed as the **methods** of the class. At the programming level, methods are
    like functions in structured programming, but they have access to the attributes
    – in particular, the instance variables with the data associated with this object.
    Like functions, methods can also accept **parameters** and return **values**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了数据如何定义对象的状态，我们需要查看的最后一个未定义的术语是*行为*。行为是在对象上可以发生的行为。可以在特定对象类上执行的行为作为该类的**方法**来表示。在编程层面，方法类似于结构化编程中的函数，但它们可以访问属性——特别是与该对象关联的数据的实例变量。像函数一样，方法也可以接受**参数**并返回**值**。
- en: A method's parameters are provided to it as a collection of objects that need
    to be **passed** into that method. The actual object instances that are passed
    into a method during a specific invocation are usually referred to as **arguments**.
    These objects are bound to **parameter** variables in the method body. They are
    used by the method to perform whatever behavior or task it is meant to do. Returned
    values are the results of that task. Internal state changes are another possible
    effect of evaluating a method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数作为需要传递到该方法中的对象集合提供给它。在特定调用期间传递到方法中的实际对象实例通常被称为**参数**。这些对象绑定到方法体内的**参数**变量上。它们被方法用来执行它打算做的任何行为或任务。返回值是该任务的结果。评估方法时的内部状态变化是另一种可能的影响。
- en: 'We''ve stretched our *comparing apples and oranges* example into a basic (if
    far-fetched) inventory application. Let''s stretch it a little further and see
    whether it breaks. One action that can be associated with oranges is the **pick** action.
    If you think about implementation, **pick** would need to do two things:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的“比较苹果和橙子”例子扩展成了一个基本的（如果有些牵强）库存应用程序。让我们再进一步扩展它，看看它是否会破裂。可以与橙子关联的一个动作是**pick**动作。如果你考虑实现，**pick**需要做两件事：
- en: Place the orange in a basket by updating the **Basket** attribute of the orange.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更新橙子的`**Basket**`属性，将橙子放入篮子中。
- en: Add the orange to the **Orange** list on the given **Basket**.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将橙子添加到给定的`Basket`上的`**Orange**`列表中。
- en: So, **pick** needs to know what basket it is dealing with. We do this by giving
    the **pick** method a **Basket** parameter. Since our fruit farmer also sells
    juice, we can add a **squeeze** method to the **Orange** class. When called, the **squeeze** method
    might return the amount of juice retrieved, while also removing the **Orange** from
    the **Basket** it was in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`**pick**`需要知道它正在处理哪个篮子。我们通过给`**pick**`方法提供一个`**Basket**`参数来实现这一点。由于我们的果农还卖果汁，我们可以在`**Orange**`类中添加一个`**squeeze**`方法。当被调用时，`**squeeze**`方法可能会返回提取的果汁量，同时也会将该`**Orange**`从它所在的`**Basket**`中移除。
- en: 'The class **Basket** can have a **sell** action. When a basket is sold, our
    inventory system might update some data on as-yet unspecified objects for accounting
    and profit calculations. Alternatively, our basket of oranges might go bad before
    we can sell them, so we add a **discard** method. Let''s add these methods to
    our diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类`**Basket**`可以有一个**sell**动作。当一个篮子被出售时，我们的库存系统可能会更新一些尚未指定的对象上的数据，用于会计和利润计算。或者，我们的橙子篮可能在我们可以出售之前就变质了，所以我们添加了一个**discard**方法。让我们将这些方法添加到我们的图中：
- en: '![Diagram  Description automatically generated with medium confidence](img/B17070_01_05.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图解 描述自动生成，置信度中等](img/B17070_01_05.png)'
- en: 'Figure 1.5: Class diagram with attributes and methods'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：包含属性和方法的类图
- en: Adding attributes and methods to individual objects allows us to create a **system** of
    interacting objects. Each object in the system is a member of a certain class.
    These classes specify what types of data the object can hold and what methods
    can be invoked on it. The data in each object can be in a different state from
    other instances of the same class; each object may react to method calls differently
    because of the differences in state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 向单个对象添加属性和方法允许我们创建一个**系统**，其中包含相互交互的对象。系统中的每个对象都是某个类的成员。这些类指定了对象可以持有哪些类型的数据以及可以对其调用的方法。每个对象中的数据可能与其他相同类的实例处于不同的状态；由于状态的不同，每个对象可能对方法调用的反应也不同。
- en: Object-oriented analysis and design is all about figuring out what those objects
    are and how they should interact. Each class has responsibilities and collaborations.
    The next section describes principles that can be used to make those interactions
    as simple and intuitive as possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象分析和设计全部关于弄清楚那些对象是什么以及它们应该如何交互。每个类都有责任和协作。下一节将描述可以用来使这些交互尽可能简单直观的原则。
- en: Note that selling a basket is not unconditionally a feature of the **Basket**
    class. It may be that some other class (not shown) cares about the various Baskets
    and where they are. We often have boundaries around our design. We will also have
    questions about responsibilities allocated to various classes. The responsibility
    allocation problem doesn't always have a tidy technical solution, forcing us to
    draw (and redraw) our UML diagrams more than once to examine alternative designs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，出售一个篮子并不一定是**篮子**类的一个无条件特性。可能存在其他一些（未展示的）类关心各种篮子及其位置。我们在设计时常常会有边界。我们也会对分配给各个类的责任有所疑问。责任分配问题并不总是有一个整洁的技术解决方案，这迫使我们多次绘制（和重新绘制）我们的UML图来检查替代设计。
- en: Hiding details and creating the public interface
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏细节和创建公共接口
- en: The key purpose of modeling an object in object-oriented design is to determine
    what the public **interface** of that object will be. The interface is the collection
    of attributes and methods that other objects can access to interact with that
    object. Other objects do not need, and in some languages are not allowed, to access
    the internal workings of the object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对象面向设计建模的关键目的是确定该对象的公共**接口**将是什么。接口是其他对象可以访问以与该对象交互的属性和方法集合。其他对象不需要，在某些语言中甚至不允许访问对象的内部工作原理。
- en: A common real-world example is the television. Our interface to the television
    is the remote control. Each button on the remote control represents a method that
    can be called on the television object. When we, as the calling object, access
    these methods, we do not know or care if the television is getting its signal
    from a cable connection, a satellite dish, or an internet-enabled device. We don't
    care what electronic signals are being sent to adjust the volume, or whether the
    sound is destined for speakers or headphones. If we open the television to access
    its internal workings, for example, to split the output signal to both external
    speakers and a set of headphones, we may void the warranty.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的现实世界例子是电视。我们与电视的接口是遥控器。遥控器上的每个按钮都代表可以在电视对象上调用的一个方法。当我们作为调用对象访问这些方法时，我们不知道或关心电视是从有线电视连接、卫星天线还是互联网设备接收信号。我们不在乎调整音量的电子信号是什么，或者声音是针对扬声器还是耳机。如果我们打开电视以访问其内部工作原理，例如，将输出信号分割到外部扬声器和一套耳机，我们可能会使保修失效。
- en: This process of hiding the implementation of an object is suitably called **information
    hiding**. It is also sometimes referred to as **encapsulation**, but encapsulation
    is actually a more encompassing term. Encapsulated data is not necessarily hidden.
    Encapsulation is, literally, creating a capsule (or wrapper) on the attributes.
    The TV's external case encapsulates the state and behavior of the television.
    We have access to the external screen, the speakers, and the remote. We don't
    have direct access to the wiring of the amplifiers or receivers within the TV's
    case.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个隐藏对象实现的过程通常被称为**信息隐藏**。它有时也被称为**封装**，但封装实际上是一个更广泛的概念。封装的数据不一定被隐藏。封装字面上是指在属性上创建一个胶囊（或包装器）。电视的外壳封装了电视的状态和行为。我们可以访问外部屏幕、扬声器和遥控器。我们无法直接访问电视外壳内部的放大器或接收器的线路。
- en: When we buy a component entertainment system, we change the level of encapsulation,
    exposing more of the interfaces between components. If we're an Internet of Things
    maker, we may decompose this even further, opening cases and breaking the information
    hiding attempted by the manufacturer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们购买一个组件娱乐系统时，我们改变了封装级别，暴露了组件之间的更多接口。如果我们是物联网制造商，我们甚至可以进一步分解它，打开外壳并打破制造商试图隐藏的信息。
- en: The distinction between encapsulation and information hiding is largely irrelevant,
    especially at the design level. Many practical references use these terms interchangeably.
    As Python programmers, we don't actually have or need information hiding via completely
    private, inaccessible variables (we'll discuss the reasons for this in *Chapter
    2*, *Objects in Python*), so the more encompassing definition for encapsulation
    is suitable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 封装和信息隐藏之间的区别在很大程度上是不相关的，尤其是在设计层面。许多实用参考手册将这些术语互换使用。作为Python程序员，我们实际上没有或不需要通过完全私有、不可访问的变量来实现信息隐藏（我们将在第
    2 章，*Python 中的对象*中讨论这一原因），因此封装的更广泛定义是合适的。
- en: The public interface, however, is very important. It needs to be carefully designed
    as it can be difficult to change when other classes depend on it. Changing an
    interface can break any client objects that depend on it. We can change the internals
    all we like, for example, to make it more efficient, or to access data over the
    network as well as locally, and the client objects will still be able to talk
    to it, unmodified, using the public interface. On the other hand, if we alter
    the interface by changing publicly accessed attribute names or the order or types
    of arguments that a method can accept, all client classes will also have to be
    modified. When designing public interfaces, keep it simple. Always design the
    interface of an object based on how easy it is to use, not how hard it is to code
    (this advice applies to user interfaces as well). For this reason, you'll sometimes
    see Python variables with a leading _ in their name as a warning that these aren't
    part of the public interface.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，公共接口非常重要。它需要精心设计，因为它在其他类依赖它时很难更改。更改接口可能会破坏任何依赖它的客户端对象。我们可以随意更改内部结构，例如，使其更高效，或者通过网络以及本地访问数据，客户端对象仍然可以通过公共接口与之通信，无需修改。另一方面，如果我们通过更改公开访问的属性名称或方法可以接受的参数的顺序或类型来更改接口，所有客户端类也必须进行修改。在设计公共接口时，请保持简单。始终根据使用难度来设计对象的接口，而不是编码难度（此建议也适用于用户界面）。因此，有时你会看到Python变量名以
    _ 开头，作为这些不是公共接口的警告。
- en: Remember, program objects may represent real objects, but that does not make
    them real objects. They are models. One of the greatest gifts of modeling is the
    ability to ignore irrelevant details. The model car one of the authors built as
    a child looked like a real 1956 Thunderbird on the outside, but it obviously didn't
    run. When they were too young to drive, these details were overly complex and
    irrelevant. The model is an **abstraction** of a real concept.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，程序对象可能代表真实对象，但这并不意味着它们是真实对象。它们是模型。建模的最大礼物之一就是能够忽略无关的细节。作者小时候制作的模型车在外观上看起来像1956年的雷鸟，但显然不能行驶。当他们太小无法驾驶时，这些细节过于复杂且无关紧要。这个模型是对真实概念的抽象。
- en: '**Abstraction** is another object-oriented term related to encapsulation and
    information hiding. Abstraction means dealing with the level of detail that is
    most appropriate to a given task. It is the process of extracting a public interface
    from the inner details. A car''s driver needs to interact with the steering, accelerator,
    and brakes. The workings of the motor, drive train, and brake subsystem don''t
    matter to the driver. A mechanic, on the other hand, works at a different level
    of abstraction, tuning the engine and bleeding the brakes. Here''s an example
    of two abstraction levels for a car:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象**是另一个与封装和信息隐藏相关的面向对象术语。抽象意味着处理与给定任务最合适的细节级别。它是从内部细节中提取公共接口的过程。汽车的驾驶员需要与方向盘、油门和刹车交互。发动机、传动系统和制动子系统的运作对驾驶员来说并不重要。另一方面，机械师在另一个抽象级别上工作，调整发动机和放刹车的空气。以下是一个关于汽车的两种抽象层次的例子：'
- en: '![Diagram  Description automatically generated](img/B17070_01_06.png)Figure
    1.6: Abstraction levels for a car'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 描述自动生成](img/B17070_01_06.png)图 1.6：汽车的抽象层次'
- en: 'Now, we have several new terms that refer to similar concepts. Let''s summarize
    all this jargon in a couple of sentences: abstraction is the process of encapsulating
    information with a separate public interface. Any private elements can be subject
    to information hiding. In UML diagrams, we might use a leading – instead of a
    leading + to suggest it''s not part of a public interface.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有几个新术语指的是类似的概念。让我们用几句话总结所有这些术语：抽象是将信息封装在独立的公共接口中的过程。任何私有元素都可以受到信息隐藏的影响。在UML图中，我们可能会使用一个前导破折号（-）而不是前导加号（+）来表示它不是公共接口的一部分。
- en: The important lesson to take away from all these definitions is to make our
    models understandable to other objects that have to interact with them. This means
    paying careful attention to small details.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些定义中吸取的重要教训是使我们的模型对必须与之交互的其他对象可理解。这意味着要仔细关注细节。
- en: Ensure methods and properties have sensible names. When analyzing a system,
    objects typically represent nouns in the original problem, while methods are normally
    verbs. Attributes may show up as adjectives or more nouns. Name your classes,
    attributes, and methods accordingly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确保方法和属性有合理的名称。在分析系统时，对象通常代表原始问题中的名词，而方法通常是动词。属性可能表现为形容词或更多的名词。相应地命名你的类、属性和方法。
- en: When designing the interface, imagine you are the object; you want clear definitions
    of your responsibility and you have a very strong preference for privacy to meet
    those responsibilities. Don't let other objects have access to data about you
    unless you feel it is in your best interest for them to have it. Don't give them
    an interface to force you to perform a specific task unless you are certain it's
    your responsibility to do that.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计界面时，想象你自己是对象；你希望对自己的责任有清晰的定义，并且你非常重视隐私来满足这些责任。除非你觉得自己有最好的利益让他们拥有这些信息，否则不要让其他对象访问关于你的数据。除非你确定这是你的责任去做，否则不要给他们一个界面来强迫你执行特定的任务。
- en: Composition
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: So far, we have learned to design systems as a group of interacting objects,
    where each interaction involves viewing objects at an appropriate level of abstraction.
    But we don't yet know how to create these levels of abstraction. There are a variety
    of ways to do this; we'll discuss some advanced design patterns in *Chapters 10*,
    *11*, and *12*. But even most design patterns rely on two basic object-oriented
    principles known as **composition** and **inheritance**. Composition is simpler,
    so let's start with that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了将系统设计为一组相互作用的对象，其中每个交互都涉及在适当的抽象级别上查看对象。但我们还不知道如何创建这些抽象级别。有各种方法可以做到这一点；我们将在第10章、第11章和第12章中讨论一些高级设计模式。但即使大多数设计模式也依赖于两个基本面向对象的原则，即**组合**和**继承**。组合更简单，所以让我们从它开始。
- en: Composition is the act of collecting several objects together to create a new
    one. Composition is usually a good choice when one object is part of another object.
    We've already seen a first hint of composition when talking about cars. A fossil-fueled
    car is composed of an engine, transmission, starter, headlights, and windshield,
    among numerous other parts. The engine, in turn, is composed of pistons, a crank
    shaft, and valves. In this example, composition is a good way to provide levels
    of abstraction. The **Car** object can provide the interface required by a driver,
    while also giving access to its component parts, which offers the deeper level
    of abstraction suitable for a mechanic. Those component parts can, of course,
    be further decomposed into details if the mechanic needs more information to diagnose
    a problem or tune the engine.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是将几个对象收集在一起以创建一个新的对象的行为。当其中一个对象是另一个对象的一部分时，组合通常是一个好的选择。当我们谈论汽车时，我们已经看到了组合的第一个暗示。一个化石燃料汽车由发动机、变速箱、起动机、前灯和挡风玻璃等众多部件组成。反过来，发动机由活塞、曲轴和阀门组成。在这个例子中，组合是一种提供抽象级别的良好方式。**Car**对象可以提供司机所需的接口，同时也可以访问其组成部分，这提供了适合机械师更深层次的抽象。当然，如果机械师需要更多信息来诊断问题或调整发动机，这些组成部分可以进一步分解成细节。
- en: A car is a common introductory example of composition, but it's not overly useful
    when it comes to designing computer systems. Physical objects are easy to break
    into component objects. People have been doing this at least since the ancient
    Greeks originally postulated that atoms were the smallest units of matter (they,
    of course, didn't have access to particle accelerators). Because computer systems
    involve a lot of peculiar concepts, identifying the component objects does not
    happen as naturally as with real-world valves and pistons.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车是组合的一个常见入门例子，但在设计计算机系统时并不特别有用。物理对象很容易分解成组件对象。人们至少从古希腊最初提出原子是物质的最小单位（他们当然没有粒子加速器）以来就在做这件事。由于计算机系统涉及许多**特殊概念**，识别组件对象并不像现实世界中的阀门和活塞那样自然发生。
- en: The objects in an object-oriented system occasionally represent physical objects
    such as people, books, or telephones. More often, however, they represent concepts.
    People have names, books have titles, and telephones are used to make calls. Calls,
    titles, accounts, names, appointments, and payments are not usually considered
    objects in the physical world, but they are all frequently-modeled components
    in computer systems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象系统中的对象有时代表物理对象，如人、书籍或电话。然而，更常见的是，它们代表概念。人们有名字，书籍有标题，电话用于打电话。通话、标题、账户、名字、约会和付款通常不被视为物理世界中的对象，但它们都是计算机系统中经常建模的组件。
- en: Let's try modeling a more computer-oriented example to see composition in action.
    We'll be looking at the design of a computerized chess game. This was a very popular
    pastime in the 80s and 90s. People were predicting that computers would one day
    be able to defeat a human chess master. When this happened in 1997 (IBM's Deep
    Blue defeated world chess champion, Gary Kasparov), interest in the problem of
    chess waned. Nowadays, the descendants of Deep Blue always win.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试模拟一个更面向计算机的例子，看看组合是如何发挥作用的。我们将研究一个计算机化棋盘游戏的设计。这在80年代和90年代是一个非常受欢迎的消遣活动。人们预测计算机有一天能够击败人类棋手。当1997年发生这种情况时（IBM的Deep
    Blue击败了世界棋王加里·卡斯帕罗夫），对棋类问题的兴趣减弱了。如今，Deep Blue的后代总是能赢。
- en: A *game* of chess is **played** between two *players*, using a chess set featuring
    a *board* containing 64 *positions* in an 8×8 grid. The board can have two sets
    of 16 *pieces* that can be **moved**, in alternating *turns* by the two players
    in different ways. Each piece can **take** other pieces. The board will be required
    to **draw** itself on the computer *screen* after each turn.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一场**棋局**是在两个**玩家**之间进行的，使用一个包含64个**位置**的8×8网格的**棋盘**。棋盘可以有两套16个**棋子**，可以由两个玩家交替**移动**，以不同的方式。每个棋子可以**吃掉**其他棋子。在每一步之后，棋盘都需要在计算机**屏幕**上**绘制**自己。
- en: I've identified some of the possible objects in the description using *italics*,
    and a few key methods using **bold**. This is a common first step in turning an
    object-oriented analysis into a design. At this point, to emphasize composition,
    we'll focus on the board, without worrying too much about the players or the different
    types of pieces.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用**斜体**标识了一些描述中可能的对象，并使用**粗体**标识了一些关键方法。这是将面向对象的分析转化为设计时的一个常见第一步。在这个阶段，为了强调组合，我们将专注于棋盘，而不太关心玩家或不同类型的棋子。
- en: 'Let''s start at the highest level of abstraction possible. We have two players
    interacting with a **Chess Set** by taking turns making moves:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从可能的最高的抽象层次开始。我们有两个玩家通过轮流移动棋子与**棋盘**进行交互：
- en: '![Diagram  Description automatically generated](img/B17070_01_07.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17070_01_07.png)'
- en: 'Figure 1.7: Object/instance diagram for a chess game'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：棋盘游戏的对象/实例图
- en: 'This doesn''t quite look like our earlier class diagrams, which is a good thing
    since it isn''t one! This is an **object diagram**, also called an **instance
    diagram**. It describes the system at a specific state in time, and is describing
    specific instances of objects, not the interaction between classes. Remember,
    both players are members of the same class, so the class diagram looks a little
    different:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全像我们之前的类图，这是好事，因为它不是！这是一个**对象图**，也称为**实例图**。它描述了系统在特定时间的状态，并描述了特定对象的具体实例，而不是类之间的交互。记住，两个玩家都是同一类的成员，所以类图看起来略有不同：
- en: '![](img/B17070_01_08.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B17070_01_08.png](img/B17070_01_08.png)'
- en: 'Figure 1.8: Class diagram for a chess game'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：棋盘游戏的类图
- en: This diagram shows that exactly two players can interact with one chess set.
    This also indicates that any one player can be playing with only one **Chess Set** at
    a time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示恰好两名玩家可以与一个棋盘互动。这也表明任何一名玩家一次只能玩一个 **棋盘**。
- en: However, we're discussing composition, not UML, so let's think about what the **Chess
    Set** is composed of. We don't care what the player is composed of at this time.
    We can assume that the player has a heart and brain, among other organs, but these
    are irrelevant to our model. Indeed, there is nothing stopping said player from
    being Deep Blue itself, which has neither a heart nor a brain.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们正在讨论组合，而不是UML，所以让我们考虑一下 **棋盘** 由什么组成。我们现在不关心玩家由什么组成。我们可以假设玩家有一颗心和大脑，以及其他器官，但这些对我们模型来说是不相关的。实际上，没有任何阻止该玩家成为没有心脏和大脑的Deep
    Blue的理由。
- en: The chess set, then, is composed of a board and 32 pieces. The board further
    comprises 64 positions. You could argue that these pieces are not part of the
    chess set, because you could replace the pieces of a chess set with a different
    set of pieces. While this is unlikely or impossible in a computerized version
    of chess, it introduces us to **aggregation**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，棋盘由一个棋盘和32个棋子组成。棋盘进一步由64个位置组成。你可以争论这些棋子不是棋盘的一部分，因为你可以用另一套棋子替换棋盘的棋子。虽然在计算机化的棋盘游戏中这不太可能或不可能，但它让我们了解了 **聚合**。
- en: Aggregation is almost exactly like composition. The difference is that aggregate
    objects can exist independently. It would be impossible for a position to be associated
    with a different chess board, so we say the board is composed of positions. But
    the pieces, which might exist independently of the chess set, are said to be in
    an aggregate relationship with that set.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合几乎与组合完全相同。区别在于聚合对象可以独立存在。一个位置与不同的棋盘相关联是不可能的，所以我们说棋盘由位置组成。但是，棋子可能独立于棋盘存在，因此我们说棋子与该棋盘处于聚合关系。
- en: 'Another way to differentiate between aggregation and composition is to think
    about the lifespan of the object:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 区分聚合和组合的另一种方法是考虑对象的生命周期：
- en: If the composite (outside) object controls when the related (inside) objects
    are created and destroyed, composition is most suitable.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果复合（外部）对象控制相关（内部）对象的创建和销毁时间，则组合是最合适的。
- en: If the related object is created independently of the composite object, or can
    outlast that object, an aggregate relationship makes more sense.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果相关对象独立于复合对象创建，或者可以比该对象存活更久，则聚合关系更有意义。
- en: Also, keep in mind that composition is aggregation; aggregation is simply a
    more general form of composition. Any composite relationship is also an aggregate
    relationship, but not vice versa.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，组合是聚合；聚合只是组合的一种更一般的形式。任何组合关系也是聚合关系，但反之则不然。
- en: 'Let''s describe our current **Chess Set** composition and add some attributes
    to the objects to hold the composite relationships:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述我们当前的 **棋盘** 组合，并为对象添加一些属性以保持复合关系：
- en: '![Diagram  Description automatically generated](img/B17070_01_09.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17070_01_09.png)'
- en: 'Figure 1.9: Class diagram for a chess game'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：棋局类图
- en: The composition relationship is represented in UML as a solid diamond. The hollow
    diamond represents the aggregate relationship. You'll notice that the board and
    pieces are stored as part of the **Chess Set** in exactly the same way a reference
    to them is stored as an attribute on the chess set. This shows that, once again,
    in practice, the distinction between aggregation and composition is often irrelevant
    once you get past the design stage. When implemented, they behave in much the
    same way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 组合关系在UML中以实心菱形表示。空心菱形表示聚合关系。你会注意到棋盘和棋子作为棋盘的一部分存储，就像它们作为属性存储在棋盘上一样。这表明，在实践中，一旦过了设计阶段，聚合与组合的区别通常无关紧要。实现后，它们的行为几乎相同。
- en: This distinction can help you differentiate between the two when your team is
    discussing how the different objects interact. You'll often need to distinguish
    between them when talking about how long related objects exist. In many cases,
    deleting a composite object (like the board) deletes all the locations. The aggregated
    objects, however, are not deleted automatically.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别可以帮助你在团队讨论不同对象如何相互作用时区分两者。在谈论相关对象存在的时间长度时，你通常会需要区分它们。在许多情况下，删除一个复合对象（如棋盘）会删除所有位置。然而，聚合对象则不会自动删除。
- en: Inheritance
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'We discussed three types of relationships between objects: association, composition,
    and aggregation. However, we have not fully specified our chess set, and these
    tools don''t seem to give us all the power we need. We discussed the possibility
    that a player might be a human or it might be a piece of software featuring artificial
    intelligence. It doesn''t seem right to say that a player is *associated* with
    a human, or that the artificial intelligence implementation is *part of* the player
    object. What we really need is the ability to say that *Deep Blue is a player*, or
    that *Gary Kasparov is a player*.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了三种对象之间的关系：关联、组合和聚合。然而，我们尚未完全指定我们的棋盘，这些工具似乎并没有给我们提供所有需要的功能。我们讨论了玩家可能是一个人类或者可能是一块具有人工智能功能的软件的可能性。说玩家与人类**关联**，或者人工智能实现是玩家对象的**部分**，似乎并不合适。我们真正需要的是能够说**Deep
    Blue是一个玩家**，或者**Gary Kasparov是一个玩家**。
- en: The *is a* relationship is formed by **inheritance**. Inheritance is the most
    famous, well-known, and overused relationship in object-oriented programming.
    Inheritance is sort of like a family tree. Dusty Phillips is one of this book's
    authors.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**关系形成了**is a**关系。继承是面向对象编程中最著名、最知名且被过度使用的关联。继承有点像家谱。Dusty Phillips是本书的作者之一。'
- en: His grandfather's last name was Phillips, and his father inherited that name.
    Dusty inherited it from him. In object-oriented programming, instead of inheriting
    features and behaviors from a person, one class can inherit attributes and methods
    from another class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 他的祖父的姓氏是Phillips，他的父亲继承了那个名字。Dusty从他那里继承了它。在面向对象编程中，不是从一个人那里继承特性和行为，一个类可以继承另一个类的属性和方法。
- en: 'For example, there are 32 chess pieces in our chess set, but there are only
    six different types of pieces (pawns, rooks, bishops, knights, king, and queen),
    each of which behaves differently when it is moved. All of these classes of piece
    have properties, such as color and the chess set they are part of, but they also
    have unique shapes when drawn on the chess board, and make different moves. Let''s
    see how the six types of pieces can inherit from a **Piece** class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的棋盘上共有32个棋子，但只有六种不同的棋子类型（兵、车、象、马、王和后），每种棋子在移动时表现都不同。所有这些棋子类别都有属性，例如颜色和它们所属的棋盘，但它们在棋盘上绘制时也有独特的形状，并且移动方式不同。让我们看看六种类型的棋子如何从**棋子**类中继承：
- en: '![Diagram  Description automatically generated](img/B17070_01_10.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17070_01_10.png)'
- en: 'Figure 1.10: How chess pieces inherit from the Piece class'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10：棋子如何从棋子类继承
- en: The hollow arrows indicate that the individual classes of pieces inherit from
    the **Piece** class. All the child classes automatically have a **chess_set**
    and **color** attribute inherited from the base class. Each piece provides a different
    shape property (to be drawn on the screen when rendering the board), and a different
    **move** method to move the piece to a new position on the board at each turn.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 空心箭头表示各个棋子类别从**棋子**类继承。所有子类自动从基类继承了一个**棋盘**和**颜色**属性。每个棋子提供不同的形状属性（在渲染棋盘时绘制），以及不同的**移动**方法，在每个回合将棋子移动到棋盘上的新位置。
- en: We actually know that all subclasses of the **Piece** class need to have a **move**
    method; otherwise, when the board tries to move the piece, it will get confused.
    It is possible that we would want to create a new version of the game of chess
    that has one additional piece (the wizard). Our current design will allow us to
    design this piece without giving it a **move** method. The board would then choke
    when it asked the piece to move itself.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们知道所有**棋子**类的子类都需要有一个**移动**方法；否则，当棋盘尝试移动棋子时，它会感到困惑。我们可能想要创建一个新版本的棋类游戏，增加一个额外的棋子（法师）。我们当前的设计将允许我们不给它一个**移动**方法来设计这个棋子。然后，当棋盘要求棋子移动自己时，它就会卡住。
- en: We can fix this by creating a dummy move method on the **Piece** class. The
    subclasses can then **override** this method with a more specific implementation.
    The default implementation might, for example, pop up an error message that says **That
    piece cannot be moved**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在**棋子**类上创建一个虚拟的移动方法来解决这个问题。子类可以随后用更具体的实现来**重写**这个方法。默认实现可能，例如，弹出一个错误消息，说**那个棋子不能移动**。
- en: Overriding methods in subclasses allows very powerful object-oriented systems
    to be developed. For example, if we wanted to implement a **Player** class with
    artificial intelligence, we might provide a **calculate_move** method that takes
    a **Board** object and decides which piece to move where. A very basic class might
    randomly choose a piece and direction and move it accordingly. We could then override
    this method in a subclass with the Deep Blue implementation. The first class would
    be suitable for play against a raw beginner; the latter would challenge a grand
    master. The important thing is that other methods in the class, such as the ones
    that inform the board as to which move was chosen, need not be changed; this implementation
    can be shared between the two classes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中重写方法可以开发出非常强大的面向对象系统。例如，如果我们想实现一个具有人工智能的**Player**类，我们可能会提供一个**calculate_move**方法，该方法接受一个**Board**对象并决定将哪个棋子移动到哪个位置。一个非常基本的类可能会随机选择一个棋子和方向，并相应地移动它。然后我们可以在子类中重写这个方法，使用Deep
    Blue的实现。第一个类适合与初学者对弈；后者则可以挑战大师。重要的是，类中的其他方法，比如通知棋盘选择了哪个移动的方法，不需要改变；这种实现可以在两个类之间共享。
- en: 'In the case of chess pieces, it doesn''t really make sense to provide a default
    implementation of the move method. All we need to do is specify that the move
    method is required in any subclasses. This can be done by making **Piece** an **abstract
    class** with the **move** method declared as **abstract**. Abstract methods basically
    say this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在棋子的例子中，提供移动方法的默认实现实际上并没有太多意义。我们只需要指定任何子类都需要实现移动方法。这可以通过将**Piece**类声明为**抽象类**并声明**move**方法为**抽象方法**来实现。抽象方法基本上是这样说的：
- en: '"We demand this method exist in any non-abstract subclass, but we are declining
    to specify an implementation in this class."'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我们要求任何非抽象子类都必须实现这个方法，但我们不打算在这个类中指定实现方式。”
- en: Indeed, it is possible to make an abstraction that does not implement any methods
    at all. Such a class would simply tell us what the class *should* do, but provides
    absolutely no advice on how to do it. In some languages, these purely abstract
    classes are called **interfaces**. It's possible to define a class with only abstract
    method placeholders in Python, but it's very rare.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可以创建一个完全不实现任何方法的高度抽象。这样的类只会告诉我们这个类**应该**做什么，但不会提供任何关于如何做的建议。在某些语言中，这些纯粹抽象的类被称为**接口**。在Python中，可以定义一个只包含抽象方法占位符的类，但这非常罕见。
- en: Inheritance provides abstraction
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承提供了抽象。
- en: Let's explore the longest word in object-oriented argot. **Polymorphism** is
    the ability to treat a class differently, depending on which subclass is implemented.
    We've already seen it in action with the pieces system we've described. If we
    took the design a bit further, we'd probably see that the **Board** object can
    accept a move from the player and call the **move** function on the piece. The
    board need not ever know what type of piece it is dealing with. All it has to
    do is call the **move** method, and the proper subclass will take care of moving
    it as a **Knight** or a **Pawn**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索面向对象术语中最长的单词。**多态性**是指根据实现的子类不同而以不同的方式处理类的能力。我们已经在我们描述的棋子系统中看到了它的实际应用。如果我们进一步扩展设计，我们可能会看到**Board**对象可以接受玩家的移动并调用棋子的**move**函数。棋盘不需要知道它正在处理的是什么类型的棋子。它只需要调用**move**方法，正确的子类就会负责将其移动为**骑士**或**兵**。
- en: Polymorphism is pretty cool, but it is a word that is rarely used in Python
    programming. Python goes an extra step past allowing a subclass of an object to
    be treated like a parent class. A board implemented in Python could take any object
    that has a **move** method, whether it is a bishop piece, a car, or a duck. When **move** is
    called, the **Bishop** will move diagonally on the board, the car will drive someplace,
    and the duck will swim or fly, depending on its mood.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性非常酷，但在Python编程中这个词很少被使用。Python允许一个对象的子类被当作父类来处理，但它在这一点上做得更多。在Python中实现的棋盘可以接受任何具有**move**方法的对象，无论是棋子、汽车还是鸭子。当调用**move**时，**主教**会在棋盘上斜着移动，汽车会驶向某个地方，鸭子会根据它的心情游泳或飞翔。
- en: This sort of polymorphism in Python is typically referred to as **duck typing**: *if
    it walks like a duck or swims like a duck, we call it a duck*. We don't care if
    it really *is a* duck (*is a* being a cornerstone of inheritance), only that it
    swims or walks. Geese and swans might easily be able to provide the duck-like
    behavior we are looking for. This allows future designers to create new types
    of birds without actually specifying a formal inheritance hierarchy for all possible
    kinds of aquatic birds. The chess examples, above, use formal inheritance to cover
    all possible pieces in the chess set. Duck typing also allows a programmer to
    extend a design, creating completely different drop-in behaviors the original
    designers never planned for. For example, future designers might be able to make
    a walking, swimming penguin that works with the same interface without ever suggesting
    that penguins have a common superclass with ducks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在Python中的多态通常被称为**鸭子类型**：**如果它像鸭子走路或游泳，我们就称它为鸭子**。我们不在乎它是否真的是一只鸭子（“是”是一个继承的核心），只在乎它是否能游泳或走路。鹅和天鹅可能很容易提供我们想要的类似鸭子的行为。这允许未来的设计者创建新的鸟类类型，而无需为所有可能的鸟类指定正式的继承层次结构。上面的棋类示例使用正式的继承来涵盖棋盘上的所有可能的棋子。鸭子类型还允许程序员扩展设计，创建原始设计者从未计划过的完全不同的即插即用行为。例如，未来的设计者可能能够制作一个既能行走又能游泳的企鹅，并且与相同的接口一起工作，而无需建议企鹅与鸭子有一个共同的超类。
- en: Multiple inheritance
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多继承
- en: When we think of inheritance in our own family tree, we can see that we inherit
    features from more than just one parent. When strangers tell a proud mother that
    her son has *his father's eyes*, she will typically respond along the lines of, *yes,
    but he got my nose*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考我们家族树中的继承时，我们可以看到我们不仅仅从父母一方继承了特征。当陌生人告诉一位自豪的母亲她的儿子有**他父亲的眼睛**时，她通常会这样回答，**是的，但他继承了了我的鼻子**。
- en: Object-oriented design can also feature such **multiple inheritance**, which
    allows a subclass to inherit functionality from multiple parent classes. In practice,
    multiple inheritance can be a tricky business, and some programming languages
    (most famously, Java) strictly prohibit it. However, multiple inheritance can
    have its uses. Most often, it can be used to create objects that have two distinct
    sets of behaviors. For example, an object designed to connect to a scanner to
    make an image and send a fax of the scanned image might be created by inheriting
    from two separate `scanner` and `faxer` objects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的设计也可以有这种**多继承**，它允许子类从多个父类继承功能。在实践中，多继承可能是一个棘手的问题，一些编程语言（最著名的是Java）严格禁止它。然而，多继承有其用途。最常见的是，它可以用来创建具有两个不同行为集的对象。例如，一个设计用来连接扫描仪以制作图像并发送扫描图像的传真对象可能通过从两个不同的`scanner`和`faxer`对象继承而创建。
- en: As long as two classes have distinct interfaces, it is not normally harmful
    for a subclass to inherit from both of them. However, it gets messy if we inherit
    from two classes that provide overlapping interfaces. The scanner and faxer don't
    have any overlapping features, so combining features from both is easy. Our counterexample
    is a motorcycle class that has a `move` method, and a boat class also featuring
    a `move` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 只要两个类有明确的接口，子类从它们两个继承通常不会造成伤害。然而，如果我们从提供重叠接口的两个类继承，就会变得混乱。扫描仪和传真机没有任何重叠的功能，所以结合它们的功能是容易的。我们的反例是一个具有`move`方法的摩托车类，以及一个也具有`move`方法的船类。
- en: If we want to merge them into the ultimate amphibious vehicle, how does the
    resulting class know what to do when we call `move`? At the design level, this
    needs to be explained. (As a sailor who lived on a boat, one of the authors really
    wants to know how this is supposed to work.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将它们合并成终极两栖车辆，当调用`move`时，结果类知道该做什么？在设计层面，这需要解释。（作为一个在船上生活的水手，一位作者真的想知道这是如何工作的。）
- en: Python has a defined **method resolution order** (**MRO**) to help us understand
    which of the alternative methods will be used. While the MRO rules are simple,
    avoiding overlap is even simpler. Multiple inheritance as a "mixin" technique
    for combining unrelated aspects can be helpful. In many cases, though, a composite
    object may be easier to design.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个定义的**方法解析顺序**（**MRO**）来帮助我们理解哪些替代方法将被使用。虽然MRO规则很简单，但避免重叠甚至更简单。将多继承作为一种“混合”技术来组合不相关的方面可能是有帮助的。然而，在许多情况下，组合对象可能更容易设计。
- en: Inheritance is a powerful tool for extending behavior and reusing features.
    It is also one of the most marketable advancements of object-oriented design over
    earlier paradigms. Therefore, it is often the first tool that object-oriented
    programmers reach for. However, it is important to recognize that owning a hammer
    does not turn screws into nails. Inheritance is the perfect solution for obvious *is
    a* relationships. Beyond this, it can be abused. Programmers often use inheritance
    to share code between two kinds of objects that are only distantly related, with
    no *is a* relationship in sight. While this is not necessarily a bad design, it
    is a terrific opportunity to ask just why they decided to design it that way,
    and whether a different relationship or design pattern would have been more suitable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是扩展行为和重用功能的有力工具。它也是面向对象设计相对于早期范式的最具市场潜力的进步之一。因此，它通常是面向对象程序员首先寻求的工具。然而，重要的是要认识到，拥有锤子并不意味着螺丝就会变成钉子。继承是解决明显“是”关系的完美方案。除此之外，它也可能被滥用。程序员经常使用继承在两种只有远亲关系的对象之间共享代码，而看不到任何“是”关系。虽然这不一定是一个坏的设计，但它是一个很好的机会去问为什么他们决定那样设计，以及是否另一种关系或设计模式可能更适合。
- en: Case study
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'Our case study will span many of the chapters of this book. We''ll be examining
    a single problem closely from a variety of perspectives. It''s very important
    to look at alternative designs and design patterns; more than once, we''ll point
    out that there''s no single right answer: there are a number of good answers.
    Our intent here is to provide a realistic example that involves realistic depth
    and complications and leads to difficult trade-off decisions. Our goal is to help
    the reader apply object-oriented programming and design concepts. This means choosing
    among the technical alternatives to create something useful.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的案例研究将涵盖这本书的许多章节。我们将从多个角度仔细研究一个问题。查看替代设计和设计模式非常重要；不止一次，我们会指出没有唯一的正确答案：有多个好的答案。我们的意图是提供一个涉及现实深度和复杂性的真实示例，并导致艰难的权衡决策。我们的目标是帮助读者应用面向对象编程和设计概念。这意味着在技术替代品中选择，以创建有用的东西。
- en: This first part of the case study is an overview of the problem and why we're
    tackling it. This background will cover a number of aspects of the problem to
    set up the design and construction of solutions in later chapters. Part of this
    overview will include some UML diagrams to capture elements of the problem to
    be solved. These will evolve in later chapters as we dive into the consequences
    of design choices and make changes to those design choices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究的第一部分是对问题的概述以及我们为什么要解决这个问题。这部分背景将涵盖问题的多个方面，为后续章节中解决方案的设计和构建奠定基础。概述的一部分将包括一些UML图来捕捉需要解决的问题的元素。这些图将在后续章节中随着我们深入设计选择的影响和修改这些设计选择而演变。
- en: As with many realistic problems, the authors bring personal bias and assumptions.
    For information on the consequences of this, consider books like *Technically
    Wrong*, by Sara Wachter-Boettcher.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多现实问题一样，作者们会带入个人的偏见和假设。关于这一点的后果，可以参考Sara Wachter-Boettcher所著的《Technically
    Wrong》一书。
- en: 'Our users want to automate a job often called **classification**. This is the
    underpinning idea behind product recommendations: last time, a customer bought
    product X, so perhaps they''d be interested in a similar product, Y. We''ve classified
    their desires and can locate other items in that class of products. This problem
    can involve complex data organization issues.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户希望自动化一个常被称为**分类**的工作。这是产品推荐背后的基本理念：上次，顾客购买了产品X，所以他们可能对类似的产品Y感兴趣。我们已经对他们的需求进行了分类，并可以定位到那个产品类中的其他项目。这个问题可能涉及复杂的数据组织问题。
- en: It helps to start with something smaller and more manageable. The users eventually
    want to tackle complex consumer products, but recognize that solving a difficult
    problem is not a good way to learn how to build this kind of application. It's
    better to start with something of a manageable level of complexity and then refine
    and expand it until it does everything they need. In this case study, therefore,
    we'll be building a classifier for iris species. This is a classic problem, and
    there's a great deal written about approaches to classifying iris flowers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从小而易于管理的事情开始是有帮助的。用户最终想要处理复杂的消费产品，但认识到解决一个难题并不是学习如何构建这类应用程序的好方法。最好是从小规模且复杂度可控的事情开始，然后逐步精炼和扩展，直到它满足他们的所有需求。因此，在本案例研究中，我们将构建一个用于鸢尾花物种的分类器。这是一个经典问题，关于如何对鸢尾花进行分类的方法有很多论述。
- en: A training set of data is required, which the classifier uses as examples of
    correctly classified irises. We will discuss what the training data looks like
    in the next section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个训练数据集，分类器将其用作正确分类的鸢尾花示例。我们将在下一节讨论训练数据的样子。
- en: We'll create a collection of diagrams using the **Unified Modeling Language**
    (**UML**) to help depict and summarize the software we're going to build.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**统一建模语言**（**UML**）创建一系列图表，以帮助描述和总结我们将要构建的软件。
- en: 'We''ll examine the problem using a technique called **4+1 Views**. The views
    are:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用称为**4+1视图**的技术来检查这个问题。这些视图包括：
- en: A **logical view** of the data entities, their static attributes, and their
    relationships. This is the heart of object-oriented design.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑视图**展示了数据实体、它们的静态属性以及它们之间的关系。这是面向对象设计的核心。'
- en: A **process view** that describes how the data is processed. This can take a
    variety of forms, including state models, activity diagrams, and sequence diagrams.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程视图**描述了数据是如何被处理的。这可以采取多种形式，包括状态模型、活动图和序列图。'
- en: A **development view** of the code components to be built. This diagram shows
    relationships among software components. This is used to show how class definitions
    are gathered into modules and packages.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发视图**展示了将要构建的代码组件。这张图显示了软件组件之间的关系。这用于展示类定义是如何被收集到模块和包中的。'
- en: A **physical view** of the application to be integrated and deployed. In cases
    where an application follows a common design pattern, a sophisticated diagram
    isn't necessary. In other cases, a diagram is essential to show how a collection
    of components are integrated and deployed.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理视图**展示了将要集成和部署的应用程序。在应用程序遵循常见设计模式的情况下，一个复杂的图表并不是必需的。在其他情况下，图表是必不可少的，以展示组件集合是如何集成和部署的。'
- en: 'A **context view** that provides a unifying context for the other four views.
    The context view will often describe the actors that use (or interact) with the
    system to be built. This can involve human actors as well as automated interfaces:
    both are outside the system, and the system must respond to these external actors.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文视图**为其他四个视图提供了一个统一的上下文。上下文视图通常描述使用（或与）将要构建的系统交互的参与者。这可能涉及人类参与者以及自动化接口：两者都在系统之外，系统必须对这些外部参与者做出响应。'
- en: It's common to start with the context view so that we have a sense of what the
    other views describe. As our understanding of the users and the problem domain
    evolves, the context will evolve also.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常从上下文视图开始，这样我们就有了一个关于其他视图描述的内容感。随着我们对用户和问题领域的理解不断演变，上下文也会随之演变。
- en: It's very important to recognize that all of these 4+1 views evolve together.
    A change to one will generally be reflected in other views. It's a common mistake
    to think that one view is in some way foundational, and that the other views build
    on it in a cascade of design steps that always lead to software.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到所有这些4+1视图是共同演化的非常重要。一个视图的变更通常会在其他视图中得到反映。一个常见的错误是认为一个视图在某种程度上是基础性的，而其他视图则在此基础上构建，形成一个设计步骤的级联，这些步骤总是导致软件的产生。
- en: We'll start with a summary of the problem and some background before we start
    trying to analyze the application or design software.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始尝试分析应用程序或设计软件之前，我们将对问题进行总结并提供一些背景信息。
- en: Introduction and problem overview
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言和问题概述
- en: As we mentioned previously, we'll be starting with a simpler problem – classifying
    flowers. We want to implement one popular approach called *k*-**nearest neighbors**,
    or *k*-**NN** for short. We require a training set of data, which the classifier
    algorithm uses as examples of correctly classified irises. Each training sample
    has a number of attributes, reduced to numeric scores, and a final, correct, classification
    (i.e. iris species). In this iris example, each training sample is an iris, with
    its attributes, such as petal shape, size, and so on, encoded into a numeric vector
    that is an overall representation of the iris, along with a correct species label
    for that iris.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们将从一个更简单的问题开始——分类花朵。我们希望实现一种流行的方法，称为**k**-**最近邻**，或简称**k**-**NN**。我们需要一个训练数据集，分类算法将使用它作为正确分类的鸢尾花示例。每个训练样本都有若干属性，这些属性被简化为数值分数，以及一个最终的、正确的分类（即鸢尾花种类）。在这个鸢尾花例子中，每个训练样本是一朵鸢尾花，其属性，如花瓣形状、大小等，被编码成一个数值向量，这是鸢尾花的整体表示，以及该鸢尾花的正确种类标签。
- en: Given an unknown sample, an iris whose species we want to know, we can measure
    the distance between the unknown sample and any of the known samples in the vector
    space. For some small group of nearby neighbors, we can take a vote. The unknown
    sample can be classified into the sub-population selected by the majority of the
    nearby neighbors.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个未知样本，一个我们想要知道种类的鸢尾花，我们可以在向量空间中测量未知样本与任何已知样本之间的距离。对于一些附近的邻居小群体，我们可以进行投票。未知样本可以被分类到由附近多数邻居选择的子群体中。
- en: 'If we only have two dimensions (or attributes), we can diagram the *k*-NN classification
    like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只有两个维度（或属性），我们可以这样绘制**k**-NN分类图：
- en: '![Diagram, engineering drawing  Description automatically generated](img/B17070_01_11.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图，工程图纸，自动生成描述](img/B17070_01_11.png)'
- en: 'Figure 1.11: k-nearest neighbors'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：k-最近邻
- en: Our unknown sample is a diamond tagged with "??". It's surrounded by known samples
    of the square and circle species. When we locate the three nearest neighbors,
    shown inside the dashed circle, we can take a vote and decide that the unknown
    is most like the Circle species.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们未知样本是一个标记为"???"的菱形。它被已知样本的正方形和圆形种类所包围。当我们找到三个最近的邻居，如虚线圆内所示，我们可以进行投票并决定未知样本最像圆形种类。
- en: One underpinning concept is having tangible, numeric measurements for the various
    attributes. Converting words, addresses, and other non-ordinal data into an ordinal
    measurement can be challenging. The good news is that the data we're going to
    start with data that already has properly ordinal measurements with explicit units
    of measure.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本概念是对于各种属性要有具体的数值测量。将文字、地址和其他非序数数据转换为序数测量可能具有挑战性。好消息是，我们将开始使用的数据已经具有适当的序数测量和明确的测量单位。
- en: Another supporting concept is the number of neighbors involved in the voting.
    This is the *k* factor in *k*-nearest neighbors. In our conceptual diagram, we've
    shown *k*=3 neighbors; two of the three nearest neighbors are circles, with the
    third being a square. If we change the *k*-value to 5, this will change the composition
    of the pool and tip the vote in favor of the squares. Which is right? This is
    checked by having test data with known right answers to confirm that the classification
    algorithm works acceptably well. In the preceding diagram, it's clear the diamond
    was cleverly chosen to be a midway between two clusters, intentionally creating
    a difficult classification problem.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个支持概念是参与投票的邻居数量。这是**k**-最近邻中的**k**因子。在我们的概念图中，我们展示了**k**=3个邻居；其中两个最近的邻居是圆形，第三个是正方形。如果我们把**k**值改为5，这将改变池子的组成，并将投票倾向于正方形。哪个是正确的？这通过使用已知正确答案的测试数据来检查，以确认分类算法工作得相当好。在前面的图中，很明显，菱形被巧妙地选择在两个簇之间，有意地创造了一个困难的分类问题。
- en: A popular dataset for learning how this works is the Iris Classification data.
    See [https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris)
    for some background on this data. This is also available at [https://www.kaggle.com/uciml/iris](https://www.kaggle.com/uciml/iris)
    and many other places.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何工作的流行数据集是鸢尾花分类数据集。有关此数据的背景信息，请参阅[https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris)。此数据也可在[https://www.kaggle.com/uciml/iris](https://www.kaggle.com/uciml/iris)和其他许多地方找到。
- en: More experienced readers may notice some gaps and possible contradictions as
    we move through the object-oriented analysis and design work. This is intentional.
    An initial analysis of a problem of any scope will involve learning and rework.
    This case study will evolve as we learn more. If you've spotted a gap or contradiction,
    formulate your own design and see if it converges with the lessons learned in
    subsequent chapters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 更有经验的读者可能会注意到，在我们进行面向对象的分析和设计工作时，存在一些差距和可能的矛盾。这是故意的。对任何范围的问题的初步分析将涉及学习和重做。随着我们了解更多，这个案例研究将不断发展。如果你发现了差距或矛盾，制定你自己的设计，看看它是否与后续章节中学到的经验相一致。
- en: Having looked at some aspects of the problem, we can provide a more concrete
    context with actors and the use cases or scenarios that describe how an actor
    interacts with the system to be built. We'll start with the context view.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了一些问题的方面之后，我们可以通过参与者和描述参与者如何与要构建的系统交互的用例或场景来提供更具体的上下文。我们将从上下文视图开始。
- en: Context view
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文视图
- en: 'The context for our application that classifies iris species involves these
    two classes of actors:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序对鸢尾花物种进行分类的上下文涉及以下两类参与者：
- en: A "Botanist" who provides the properly classified training data and a properly
    classified set of test data. The Botanist also runs the test cases to establish
    the proper parameters for the classification. In the simple case of *k*-NN, they
    can decide which *k* value should be used.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“植物学家”，他提供经过适当分类的训练数据和测试数据集。植物学家还运行测试用例以确定分类的正确参数。在简单的k-NN情况下，他们可以决定应该使用哪个k值。
- en: A "User" who needs to do classification of unknown data. The user has made careful
    measurements and makes a request with the measurement data to get a classification
    from this classifier system. The name "User" seems vague, but we're not sure what's
    better. We'll leave it for now, and put off changing it until we foresee a problem.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“用户”，他需要对未知数据进行分类。用户已经进行了仔细的测量，并使用测量数据向这个分类器系统提出请求以获得分类。名字“用户”听起来有些模糊，但我们不确定什么更好。我们暂时保留它，并推迟到我们预见问题再进行更改。
- en: 'This UML context diagram illustrates the two actors and the three scenarios
    we will explore:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UML上下文图说明了我们将探索的两个参与者和三个场景：
- en: '![Diagram  Description automatically generated](img/B17070_01_12.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17070_01_12.png)'
- en: 'Figure 1.12: UML context diagram'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12：UML上下文图
- en: The system as a whole is depicted as a rectangle. It encloses ovals to represent
    user stories. In the UML, specific shapes have meanings, and we reserve rectangles
    for objects. Ovals (and circles) are for user stories, which are interfaces to
    the system.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统被描绘成一个矩形。它包围着椭圆形来表示用户故事。在UML中，特定的形状具有意义，我们保留矩形用于对象。椭圆形（和圆形）用于用户故事，它们是系统的接口。
- en: 'In order to do any useful processing, we need training data, properly classified.
    There are two parts to each set of data: a training set and a test set. We''ll
    call the whole assembly "training data" instead of the longer (but more precise)
    "training and test data."'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行任何有用的处理，我们需要经过适当分类的训练数据。每一组数据包含两个部分：一个训练集和一个测试集。我们将整个集合称为“训练数据”，而不是更长的（但更精确的）“训练和测试数据”。
- en: 'The tuning parameters are set by the botanist, who must examine the test results
    to be sure the classifier works. These are the two parameters that can be tuned:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 调节参数由植物学家设置，他必须检查测试结果以确保分类器工作。这些是可以调节的两个参数：
- en: The distance computation to use
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用的距离计算方法
- en: The number of neighbors to consider for voting
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑投票的邻居数量
- en: We'll look at these parameters in detail in the *Processing view* section later
    in this chapter. We'll also revisit these ideas in subsequent case study chapters.
    The distance computation is an interesting problem.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的“处理视图”部分详细讨论这些参数。我们还将随后在案例研究章节中回顾这些想法。距离计算是一个有趣的问题。
- en: 'We can define a set of experiments as a grid of each alternative and methodically
    fill in the grid with the results of measuring the test set. The combination that
    provides the best fit will be the recommended parameter set from the botanist.
    In our case, there are two choices, and the grid is a two-dimensional table, like
    the one shown below. With more complex algorithms, the "grid" may be a multidimensional
    space:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一系列实验定义为一个网格，其中包含每个备选方案和方法，然后系统地用测试集的测量结果填充网格。提供最佳拟合的组合将是植物学家推荐的参数集。在我们的案例中，有两种选择，网格是一个二维表格，如下所示。对于更复杂的算法，“网格”可能是一个多维空间：
- en: '|  |  | Various k factors |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 各种k因子 |'
- en: '|  |  | k=3 | k=5 | k=7 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |  | k=3 | k=5 | k=7 |'
- en: '| Distance computationalgorithms | Euclidean | Test results… |  |  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 距离计算算法 | 欧几里得 | 测试结果… |  |  |'
- en: '| Manhattan |  |  |  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 曼哈顿 |  |  |  |'
- en: '| Chebyshev |  |  |  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 切比雪夫 |  |  |  |'
- en: '| Sorensen |  |  |  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 索伦森 |  |  |  |'
- en: '| Other? |  |  |  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 其他？ |  |  |  |'
- en: After the testing, a User can make requests. They provide unknown data to receive
    classification results from this trained classifier process. In the long run,
    this "User" won't be a person – they'll be a connection from some website's sales
    or catalog engine to our clever classifier-based recommendation engine.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，用户可以提出请求。他们提供未知数据以从经过训练的分类器过程中接收分类结果。从长远来看，这个“用户”不会是一个人——他们将是来自某个网站的销售或目录引擎到我们聪明的基于分类器的推荐引擎的连接。
- en: 'We can summarize each of these scenarios with a **use case** or **user story**
    statement:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用**用例**或**用户故事**语句来总结这些场景：
- en: As a Botanist, I want to provide properly classified training and testing data
    to this system so users can correctly identify plants.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名植物学家，我想向这个系统提供正确分类的训练和测试数据，以便用户能够正确识别植物。
- en: As a Botanist, I want to examine the test results from the classifier to be
    sure that new samples are likely to be correctly classified.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名植物学家，我想检查分类器的测试结果，以确保新样本很可能被正确分类。
- en: As a User, I want to be able to provide a few key measurements to the classifier
    and have the iris species correctly classified.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名用户，我希望能够向分类器提供一些关键测量值，并使鸢尾花物种得到正确分类。
- en: Given the nouns and verbs in the user stories, we can use that information to
    create a logical view of the data the application will process.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户故事中的名词和动词，我们可以使用这些信息来创建应用程序将处理的数据的逻辑视图。
- en: Logical view
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑视图
- en: 'Looking at the context diagram, processing starts with training data and testing
    data. This is properly classified sample data used to test our classification
    algorithm. The following diagram shows one way to look at a class that contains
    various training and testing datasets:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 观察上下文图，处理从训练数据和测试数据开始。这是用于测试我们分类算法的正确分类样本数据。以下图示展示了查看包含各种训练和测试数据集的类的一种方式：
- en: '![Diagram  Description automatically generated](img/B17070_01_13.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图示描述自动生成](img/B17070_01_13.png)'
- en: 'Figure 1.13: Class diagram for training and testing'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：训练和测试的类图
- en: 'This shows a `Training Data` class of objects with the attributes of each instance
    of this class. The `TrainingData` object gives our sample collection a name, and
    some dates where uploading and testing were completed. For now, it seems like
    each `TrainingData` object should have a single tuning parameter, `k`, used for
    the *k*-NN classifier algorithm. An instance also includes two lists of individual
    samples: a training list and a testing list.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了具有每个实例属性的对象的`Training Data`类。`TrainingData`对象给我们的样本集合起了一个名字，以及上传和测试完成的一些日期。目前，似乎每个`TrainingData`对象都应该有一个用于*k*-NN分类算法的单个调整参数`k`。实例还包括两个单独样本的列表：一个训练列表和一个测试列表。
- en: 'Each class of objects is depicted in a rectangle with a number of individual
    sections:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象类别都用一个矩形表示，其中包含多个单独的部分：
- en: The top-most section provides a name for the class of objects. In two cases,
    we've used a type hint, `List[Sample]`; the generic class, `list`, is used in
    a way that ensures the contents of the list are only `Sample` objects.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最顶部的部分为对象类提供了一个名称。在两种情况下，我们使用了类型提示`List[Sample]`；泛型类`list`的使用方式确保列表的内容只能是`Sample`对象。
- en: The next section of a class rectangle shows the attributes of each object; these
    attributes are also called the instance variables of this class.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类矩形的下一部分显示了每个对象的属性；这些属性也被称为此类实例的实例变量。
- en: Later, we'll add "methods" to the bottom section for instances of the class.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将在类底部的部分添加“方法”用于类的实例。
- en: 'Each object of the `Sample` class has a handful of attributes: four floating-point
    measurement values and a string value, which is the botanist-assigned classification
    for the sample. In this case, we used the attribute name `class` because that''s
    what it''s called in the source data.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample`类的每个对象都有一些属性：四个浮点测量值和一个字符串值，这是植物学家为样本分配的分类。在这种情况下，我们使用了属性名`class`，因为在源数据中它就是这样称呼的。'
- en: 'The UML arrows show two specific kinds of relationships, highlighted by filled
    or empty diamonds. A filled diamond shows **composition**: a `TrainingData` object
    is composed – in part – of two collections. The open diamond shows **aggregation**:
    a `List[Sample]` object is an aggregate of `Sample` items. To recap what we learned
    earlier:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: UML箭头显示了两种特定类型的关系，通过填充或空心的菱形突出显示。一个填充的菱形表示**组合**：一个`TrainingData`对象部分由两个集合组成。一个开放的菱形表示**聚合**：一个`List[Sample]`对象是`Sample`项的聚合。为了回顾我们之前学到的内容：
- en: 'A **composition** is an existential relationship: we can''t have `TrainingData`
    without the two `List[Sample]` objects. And, conversely, a `List[Sample]` object
    isn''t used in our application without being part of a `TrainingData` object.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**是一种存在关系：没有两个`List[Sample]`对象，我们无法拥有`TrainingData`。相反，一个`List[Sample]`对象在我们的应用程序中不被用作`TrainingData`对象的一部分。'
- en: An **aggregation**, on the other hand, is a relationship where items can exist
    independently of each other. In this diagram, a number of `Sample` objects can
    be part of `List[Sample]` or can exist independently of the list.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，**聚合**是一种可以独立存在的关系。在这个图中，多个`Sample`对象可以是`List[Sample]`的一部分，也可以独立于列表存在。
- en: It's not clear that the open diamond to show the aggregation of `Sample` objects
    into a `List` object is relevant. It may be an unhelpful design detail. When in
    doubt, it's better to omit these kinds of the details until they're clearly required
    to ensure there's an implementation that meets the user's expectations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，用开放的菱形来表示将`Sample`对象聚合到`List`对象中的聚合关系并不相关。这可能是一个无用的设计细节。在不确定的情况下，最好省略这些类型的细节，直到它们显然是必需的，以确保有一个满足用户期望的实现。
- en: 'We''ve shown a `List[Sample]` as a separate class of objects. This is Python''s
    generic `List`, qualified with a specific class of objects, `Sample`, that will
    be in the list. It''s common to avoid this level of detail and summarize the relationships
    in a diagram like the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`List[Sample]`显示为一个单独的对象类。这是Python的通用`List`，用特定的对象类`Sample`进行限定，这些对象将包含在列表中。通常避免这种级别的细节，并在以下类似的图中总结关系：
- en: '![Diagram  Description automatically generated](img/B17070_01_14.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17070_01_14.png)'
- en: 'Figure 1.14: Condensed class diagram'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14：压缩后的类图
- en: This slightly abbreviated form can help with doing analytical work, where the
    underlying data structures don't matter. It's less helpful for design work, as
    specific Python class information becomes more important.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种略微简化的形式有助于进行分析工作，其中底层的数据结构并不重要。对于设计工作来说，具体的Python类信息则更为重要。
- en: Given an initial sketch, we'll compare this logical view with each of the three
    scenarios mentioned in the context diagram, shown in *Figure 1.12* in the previous
    section. We want to be sure all of the data and processing in the user stories
    can be allocated as responsibilities scattered among the classes, attributes,
    and methods in the diagram.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个初始草图，我们将把这个逻辑视图与上下文图中提到的三个场景之一进行比较，如前节中*图1.12*所示。我们想要确保用户故事中的所有数据和处理都可以分配到图中分散在类、属性和方法中的责任。
- en: 'Walking through the user stories, we uncover these two problems:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历用户故事时，我们发现了这两个问题：
- en: It's not clear how the testing and parameter tuning fit with this diagram. We
    know there's a *k* factor that's required, but there are no relevant test results
    to show alternative *k* factors and the consequence of those choices.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和参数调整如何与这个图相匹配并不清楚。我们知道需要一个*k*因子，但没有相关的测试结果来显示替代*k*因子及其选择的结果。
- en: The user's request is not shown at all. Nor is the response to the user. No
    classes have these items as part of their responsibilities.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户请求根本未显示。对用户的响应也没有显示。没有类将这些项作为其责任的一部分。
- en: The first point suggests we'll need to re-read the user stories and try again
    to create a better logical view. The second point is a question of boundaries.
    While the web request and response details are missing, it's more important to
    describe the essential problem domain – classification and *k*-NN – first. The
    web services for handling a user's requests is one (of many) solution technologies,
    and we should set that aside when getting started.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点表明我们需要重新阅读用户故事，并再次尝试创建一个更好的逻辑视图。第二点是关于边界的问题。虽然缺少了网络请求和响应的细节，但首先描述基本的问题域——分类和*k*-NN——更为重要。处理用户请求的Web服务是（众多）解决方案技术之一，在开始时我们应该将其放在一边。
- en: Now, we'll turn our focus to the processing for the data. We're following what
    seems to be an effective order for creating a description of an application. The
    data has to be described first; it's the most enduring part, and the thing that
    is always preserved through each refinement of the processing. The processing
    can be secondary to the data, because this changes as the context changes and
    user experience and preferences change.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将关注数据处理。我们遵循创建应用程序描述的有效顺序。数据必须首先描述；这是最持久的部分，也是每次处理细化过程中始终保留的东西。处理可以次要于数据，因为随着上下文的变化以及用户体验和偏好的变化，它会发生变化。
- en: Process view
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理视图
- en: There are three separate user stories. This does not necessarily force us to
    create three process diagrams. For complex processing, there may be more process
    diagrams than user stories. In some cases, a user story may be too simple to require
    a carefully designed diagram.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个独立的故事。这并不一定迫使我们创建三个流程图。对于复杂的处理，流程图可能比用户故事多。在某些情况下，一个用户故事可能过于简单，不需要精心设计的图表。
- en: 'For our application, it seems as though there are at least three unique processes
    of interest, specifically these:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，似乎至少有三个独特的感兴趣的过程，具体如下：
- en: Upload the initial set of `Samples` that comprise some `TrainingData`.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传包含一些`TrainingData`的初始`Samples`集。
- en: Run a test of the classifier with a given *k* value.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定的`k`值运行分类器的测试。
- en: Make a classification request with a new `Sample` object.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的`Sample`对象进行分类请求。
- en: We'll sketch activity diagrams for these use cases. An activity diagram summarizes
    a number of state changes. The processing begins with a start node and proceeds
    until an end node is reached. In transaction-based applications, like web services,
    it's common to omit showing the overall web server engine. This saves us from
    describing common features of HTTP, including standard headers, cookies, and security
    concerns. Instead, we generally focus on the unique processing that's performed
    to create a response for each distinct kind of request.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这些用例绘制活动图。活动图总结了一系列状态变化。处理从开始节点开始，直到达到结束节点。在基于事务的应用程序中，如Web服务，通常省略显示整体Web服务器引擎。这使我们免于描述HTTP的常见特性，包括标准头、cookie和安全问题。相反，我们通常专注于为每种不同类型的请求创建响应的独特处理。
- en: The activities are shown in round-corner rectangles. Where specific classes
    of objects or software components are relevant, they can be linked to relevant
    activities.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 活动以圆角矩形表示。当特定类别的对象或软件组件相关时，它们可以链接到相关活动。
- en: What's more important is making sure that the logical view is updated as ideas
    arise while working on the processing view. It's difficult to get either view
    done completely in isolation. It's far more important to make incremental changes
    in each view as new solution ideas arise. In some cases, additional user input
    is required, and this too will lead to the evolution of these views.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是确保在处理视图工作时，逻辑视图随着新想法的出现而更新。完全独立完成任何一种视图都是困难的。当新的解决方案想法出现时，在每个视图中进行增量更改更为重要。在某些情况下，需要额外的用户输入，这也将导致这些视图的演变。
- en: 'We can sketch a diagram to show how the system responds when the Botanist provides
    the initial data. Here''s the first example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以绘制一个图表来展示当植物学家提供初始数据时系统如何响应。以下是第一个例子：
- en: '![Diagram  Description automatically generated](img/B17070_01_15.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17070_01_15.png)'
- en: 'Figure 1.15: Activity diagram'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：活动图
- en: 'The collection of `KnownSample` values will be partitioned into two subsets:
    a training subset and a testing subset. There''s no rule in our problem summary
    or user stories for making this distinction; the gap shows we''re missing details
    in the original user story. When details are missing from the user stories, then
    the logical view may be incomplete, also. For now, we can labor under an assumption
    that most of the data – say 75% - will be used for training, and the rest, 25%,
    will be used for testing.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`KnownSample`值的集合将被划分为两个子集：一个训练子集和一个测试子集。在我们的问题摘要或用户故事中并没有规则来区分这一点；差距表明我们在原始用户故事中缺少细节。当用户故事中缺少细节时，逻辑视图也可能不完整。目前，我们可以假设大部分数据——比如说75%——将用于训练，其余的25%将用于测试。'
- en: It often helps to create similar diagrams for each of the user stories. It also
    helps to be sure that the activities all have relevant classes to implement the
    steps and represent state changes caused by each step.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个用户故事创建类似的图示通常很有帮助。这也有助于确保所有活动都有相关的类来实现步骤并表示由每个步骤引起的状态变化。
- en: We've included a verb, `Partition`, in this diagram. This suggests a method
    will be required to implement the verb. This may lead to rethinking the class
    model to be sure the processing can be implemented.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个图示中包含了一个动词`Partition`。这表明需要实现这个动词的方法。这可能会导致重新思考类模型，以确保可以实施处理。
- en: We'll turn next to considering some of the components to be built. Since this
    is a preliminary analysis, our ideas will evolve as we do more detailed design
    and start creating class definitions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转向考虑需要构建的一些组件。由于这是一个初步分析，我们的想法将在我们进行更详细的设计并开始创建类定义时演变。
- en: Development view
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发视图
- en: There's often a delicate balance between the final deployment and the components
    to be developed. In rare cases, there are few deployment constraints, and the
    designer can think freely about the components to be developed. A physical view
    will evolve from the development. In more common cases, there's a specific target
    architecture that must be used, and elements of the physical view are fixed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终部署和要开发的组件之间往往有一个微妙的平衡。在罕见的情况下，部署约束很少，设计师可以自由地思考要开发的组件。物理视图将随着开发而演变。在更常见的情况下，必须使用特定的目标架构，物理视图的元素是固定的。
- en: There are several ways to deploy this classifier as part of a larger application.
    We might build a desktop application, a mobile application, or a website. Because
    of the ubiquity of internetworked computers, one common approach is to create
    a website and connect to it from desktops and mobile apps.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将这个分类器作为更大应用程序的一部分进行部署。我们可能构建一个桌面应用程序、一个移动应用程序或一个网站。由于互联网计算机的普遍性，一种常见的方法是创建一个网站，并从桌面和移动应用程序连接到它。
- en: A web services architecture, for example, means requests can be made to a server;
    the responses could be HTML pages for presentation in a browser, or JSON documents
    that can be displayed by a mobile application. Some requests will provide whole
    new sets of training data. Other requests will be seek to classify unknown samples.
    We'll detail the architecture in the physical view below. We might want to use
    the Flask framework to build a web service. For more information on Flask, see
    *Mastering Flask Web Development*, [https://www.packtpub.com/product/mastering-flask-web-development-second-edition/9781788995405](https://www.packtpub.com/product/mastering-flask-web-development-second-edition/9781788995405),
    or *Learning Flask Framework*, [https://www.packtpub.com/product/learning-flask-framework/9781783983360](https://www.packtpub.com/product/learning-flask-framework/9781783983360).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个网络服务架构意味着可以向服务器发送请求；响应可以是用于在浏览器中展示的HTML页面，或者可以被移动应用程序显示的JSON文档。一些请求将提供全新的训练数据集。其他请求将试图对未知样本进行分类。我们将在下面的物理视图中详细说明架构。我们可能希望使用Flask框架来构建网络服务。有关Flask的更多信息，请参阅*精通Flask
    Web开发*，[https://www.packtpub.com/product/mastering-flask-web-development-second-edition/9781788995405](https://www.packtpub.com/product/mastering-flask-web-development-second-edition/9781788995405)，或*学习Flask框架*，[https://www.packtpub.com/product/learning-flask-framework/9781783983360](https://www.packtpub.com/product/learning-flask-framework/9781783983360)。
- en: 'The following diagram shows some of the components we need would need to build
    for a Flask-based application:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了我们需要为基于Flask的应用程序构建的一些组件：
- en: '![Diagram  Description automatically generated](img/B17070_01_16.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图示描述自动生成](img/B17070_01_16.png)'
- en: 'Figure 1.16: Components to be built'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16：需要构建的组件
- en: 'This diagram shows a Python package, `Classifier`, that contains a number of
    modules. The three top-level modules are:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此图示显示了一个包含多个模块的Python包`Classifier`。三个顶级模块是：
- en: '**Data Model**: (Since this is still analysis time, the name here is not properly
    Pythonic; we''ll change it later as we move into implementation.) It''s often
    helpful to separate the classes that define the problem domain into modules. This
    makes it possible for us to test them in isolation from any particular application
    that uses those classes. We''ll focus on this part, since it is foundational.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据模型**：（由于这仍然是分析阶段，这里的命名并不完全符合Python风格；我们将在进入实现阶段时将其更改。）将定义问题域的类分离到模块中通常很有帮助。这使得我们能够在与使用这些类的任何特定应用程序隔离的情况下测试它们。我们将关注这部分，因为它构成了基础。'
- en: '**View Functions**: (Also an analysis name, not a Pythonic implementation name.)
    This module will create an instance of the `Flask` class, our application. It
    will define the functions that handle requests by creating responses that can
    be displayed by a mobile app or a browser. These functions expose features of
    the model, and don''t involve the same depth and complexity of the model itself;
    we won''t focus on this component in the case study.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图函数**:（也是一个分析名称，而不是Python实现名称。）此模块将创建`Flask`类的实例，即我们的应用程序。它将定义通过创建可以由移动应用程序或浏览器显示的响应来处理请求的函数。这些函数公开了模型的功能，并不涉及模型本身的深度和复杂性；在案例研究中，我们不会关注这个组件。'
- en: '**Tests**: This will have unit tests for the model and view functions. While
    tests are essential for being sure the software is usable, they are the subject
    of *Chapter 13*, *Testing Object-Oriented Programs*.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**: 这将为模型和视图函数提供单元测试。虽然测试对于确保软件可用性至关重要，但它们是第13章的主题，即*面向对象程序的测试*。'
- en: We have included dependency arrows, using dashed lines. These can be annotated
    with the Python-specific "imports" label to help clarify how the various packages
    and modules are related.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包括了依赖关系箭头，使用虚线。这些可以用Python特定的“导入”标签来注释，以帮助阐明各种包和模块之间的关系。
- en: As we move through the design in later chapters, we'll expand on this initial
    view. Having thought about what needs to be built, we can now consider how it's
    deployed by drawing a physical view of the application. As noted above, there's
    a delicate dance between development and deployment. The two views are often built
    together.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入后面的章节进行设计，我们将扩展这个初始视图。在思考了需要构建的内容之后，我们现在可以通过绘制应用程序的物理视图来考虑它的部署。如上所述，开发和部署之间存在微妙的平衡。这两个视图通常一起构建。
- en: Physical view
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理视图
- en: The physical view shows how the software will be installed into physical hardware.
    For web services, we often talk about a **continuous integration and continuous
    deployment** (**CI/CD**) pipeline. This means that a change to the software is
    tested as a unit, integrated with the existing applications, tested as an integrated
    whole, then deployed for the users.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 物理视图显示了软件将如何安装到物理硬件中。对于网络服务，我们经常谈论**持续集成和持续部署**（**CI/CD**）管道。这意味着软件的更改作为单元进行测试，与现有应用程序集成，作为一个整体进行测试，然后部署给用户。
- en: While it's common to assume a website, this can also be deployed as a command-line
    application. It might be run on a local computer. It might also be run on a computer
    in the cloud. Another choice is to build a web application around the core classifier.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常假设是网站，但这也可以部署为命令行应用程序。它可能运行在本地计算机上。它也可能运行在云端的计算机上。另一个选择是围绕核心分类器构建一个网络应用程序。
- en: 'The following diagram shows a view of a web application server:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了网络应用程序服务器的一个视图：
- en: '![Diagram  Description automatically generated](img/B17070_01_17.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B17070_01_17.png)'
- en: 'Figure 1.17: Application server diagram'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17：应用程序服务器图
- en: 'This diagram shows the client and server nodes as three-dimensional "boxes"
    with "components" installed on them. We''ve identified three components:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了客户端和服务器节点作为安装了“组件”的三维“盒子”。我们已经确定了三个组件：
- en: A Client running the **client app** application. This application connects to
    the classifier web service and makes RESTful requests. It might be a website,
    written in JavaScript. It might be a mobile application, written in Kotlin or
    Swift. All of these frontends have a common **HTTPS** connection to our web server.
    This secure connection requires some configuration of certificates and encryption
    key pairs.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行**客户端应用程序**的应用程序客户端。此应用程序连接到分类器网络服务并发出RESTful请求。它可能是一个用JavaScript编写的网站，也可能是一个用Kotlin或Swift编写的移动应用程序。所有这些前端都有一个通用的**HTTPS**连接到我们的网络服务器。这个安全连接需要一些证书和加密密钥对的配置。
- en: The **GUnicorn** web server. This server can handle a number of details of web
    service requests, including the important HTTPS protocol. See [https://docs.gunicorn.org/en/stable/index.html](https://docs.gunicorn.org/en/stable/index.html)
    for details.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GUnicorn**网络服务器。此服务器可以处理网络服务请求的许多细节，包括重要的HTTPS协议。有关详细信息，请参阅[https://docs.gunicorn.org/en/stable/index.html](https://docs.gunicorn.org/en/stable/index.html)。'
- en: Our **Classifier** application. From this view, the complexities have been omitted,
    and the entire `Classifier` package is reduced to a small component in a larger
    web services framework. This could be built using the Flask framework.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的**Classifier**应用程序。从这个视角来看，复杂性已经被省略，整个`Classifier`包被简化为更大Web服务框架中的一个小型组件。这可以使用Flask框架来实现。
- en: Of these components, the Client's **client app** is not part of the work being
    done to develop the classifier. We've included this to illustrate the context,
    but we're not really going to be building it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些组件中，客户的**客户端应用**不是开发分类器所做工作的组成部分。我们包含这部分内容是为了说明上下文，但我们实际上并不打算去构建它。
- en: We've used a dotted dependency arrow to show that our `Classifier` application
    is a dependency from the web server. **GUnicorn** will import our web server object
    and use it to respond to requests.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用虚线依赖箭头来表示我们的`Classifier`应用程序是来自Web服务器的依赖。**GUnicorn**将导入我们的Web服务器对象并使用它来响应请求。
- en: Now that we've sketched out the application, we can consider writing some code.
    As we write, it helps to keep the diagrams up-to-date. Sometimes, they serve as
    a handy roadmap in a wilderness of code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了应用程序，我们可以考虑编写一些代码。在编写过程中，保持图表更新是有帮助的。有时，它们可以作为代码荒野中的便捷路线图。
- en: Conclusion
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: 'There are several key concepts in this case study:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中有几个关键概念：
- en: Software applications can be rather complicated. There are five views to depict
    the users, the data, the processing, the components to be built, and the target
    physical implementation.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件应用可能相当复杂。有五种视图来描述用户、数据、处理、要构建的组件以及目标物理实现。
- en: Mistakes will be made. This overview has some gaps in it. It's important to
    move forward with partial solutions. One of Python's advantages is the ability
    to build software quickly, meaning we're not deeply invested in bad ideas. We
    can (and should) remove and replace code quickly.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误将会发生。这个概述中存在一些空白。向前推进部分解决方案是很重要的。Python的一个优点是能够快速构建软件，这意味着我们并没有深入投资于坏主意。我们可以（并且应该）快速移除和替换代码。
- en: Be open to extensions. After we implement this, we'll see that setting the *k* parameter
    is a tedious exercise. An important next step is to automate tuning using a grid
    search tuning algorithm. It's often helpful to set these things aside and get
    something that works first, then extend working software later to add this helpful
    feature.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对扩展持开放态度。在我们实现这个之后，我们会看到设置*k*参数是一个繁琐的练习。一个重要的下一步是使用网格搜索调优算法来自动化调优。通常，先把这些事情放在一边，先实现一个能工作的东西，然后再扩展工作软件以添加这个有用的功能。
- en: Try to assign clear responsibilities to each class. This has been moderately
    successful, and some responsibilities are vague or omitted entirely. We'll revisit
    this as we expand this initial analysis into implementation details.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽量为每个类分配清晰的职责。这已经相当成功，但有些职责是模糊的或完全省略了。随着我们将这个初步分析扩展到实现细节，我们将重新审视这个问题。
- en: In later chapters, we'll dive more deeply into these various topics. Because
    our intent is to present realistic work, this will involve rework. Some design
    decisions may be revised as the reader is exposed to more and more of the available
    objected-oriented programming techniques in Python. Additionally, some parts of
    the solution will evolve as our understanding of design choices and the problem
    itself evolves. Rework based on lessons learned is a consequence of an agile approach
    to development.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将更深入地探讨这些各种主题。因为我们的意图是展示现实的工作，这将会涉及重做。一些设计决策可能会随着读者接触到越来越多的Python面向对象编程技术而进行修订。此外，解决方案的一些部分将随着我们对设计选择和问题的理解而发展。基于所学知识的重做是敏捷开发方法的一个结果。
- en: Recall
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆
- en: 'Some key points in this chapter:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键点：
- en: Analyzing problem requirements in an object-oriented context
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面向对象的环境中分析问题需求
- en: How to draw **Unified Modeling Language** (**UML**) diagrams to communicate
    how the system works
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绘制**统一建模语言**（**UML**）图来传达系统的工作方式
- en: Discussing object-oriented systems using the correct terminology and jargon
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的术语和行话讨论面向对象系统
- en: Understanding the distinction between class, object, attribute, and behavior
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类、对象、属性和行为之间的区别
- en: 'Some OO design techniques are used more than others. In our case study example,
    we focused on a few:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些面向对象的设计技术比其他技术使用得更多。在我们的案例研究示例中，我们关注了以下几个：
- en: Encapsulating features into classes
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将特性封装到类中
- en: Inheritance to extend a class with new features
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承以扩展类的新功能
- en: Composition to build a class from component objects
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组件对象构建类的组合
- en: Exercises
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: This is a practical book. As such, we're not assigning a bunch of fake object-oriented
    analysis problems to create designs for you to analyze and design. Instead, we
    want to give you some ideas that you can apply to your own projects. If you have
    previous object-oriented experience, you won't need to put much effort into this
    chapter. However, they are useful mental exercises if you've been using Python
    for a while, but have never really cared about all that class stuff.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本实用的书。因此，我们不会分配一大堆虚假的面向对象分析问题来为你创建要分析和设计的设计。相反，我们希望给你一些你可以应用到自己的项目中的想法。如果你有面向对象的经验，你不需要在这个章节上投入太多精力。然而，如果你已经使用Python一段时间，但从未真正关心过所有这些类的东西，它们仍然是有用的心理练习。
- en: 'First, think about a recent programming project you''ve completed. Identify
    the most prominent object in the design. Try to think of as many attributes for
    this object as possible. Did it have the following: Color? Weight? Size? Profit?
    Cost? Name? ID number? Price? Style?'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，思考一下你最近完成的一个编程项目。确定设计中最突出的对象。尽量想出这个对象尽可能多的属性。它有下面的属性吗：颜色？重量？大小？利润？成本？名称？ID号码？价格？风格？
- en: Think about the attribute types. Were they primitives or classes? Were some
    of those attributes actually behaviors in disguise? Sometimes, what looks like
    data is actually calculated from other data on the object, and you can use a method
    to do those calculations. What other methods or behaviors did the object have?
    Which objects called those methods? What kinds of relationships did they have
    with this object?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 思考属性类型。它们是原始类型还是类？其中一些属性实际上是伪装成行为的行为？有时，看起来像是数据的东西实际上是从对象上的其他数据计算出来的，你可以使用一个方法来进行这些计算。对象还有哪些其他方法或行为？哪些对象调用了这些方法？它们与这个对象有什么样的关系？
- en: Now, think about an upcoming project. It doesn't matter what the project is;
    it might be a fun free-time project or a multi-million-dollar contract. It doesn't
    have to be a complete application; it could just be one subsystem. Perform a basic
    object-oriented analysis. Identify the requirements and the interacting objects.
    Sketch out a class diagram featuring the highest level of abstraction on that
    system. Identify the major interacting objects. Identify minor supporting objects.
    Go into detail for the attributes and methods of some of the most interesting
    ones. Take different objects to different levels of abstraction. Look for places
    where you can use inheritance or composition. Look for places where you should
    avoid inheritance.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一个即将到来的项目。项目是什么并不重要；它可能是一个有趣的空闲时间项目，或者是一个价值数百万美元的合同。它不必是一个完整的应用程序；它可能只是一个子系统。进行基本的面向对象分析。确定需求以及相互作用的对象。绘制一个展示该系统最高抽象级别的类图。确定主要相互作用的对象。确定次要支持对象。对一些最有趣的对象的属性和方法进行详细描述。将不同的对象带到不同的抽象级别。寻找可以使用继承或组合的地方。寻找应该避免继承的地方。
- en: The goal is not to design a system (although you're certainly welcome to do
    so if inclination meets both ambition and available time). The goal is to think
    about object-oriented design. Focusing on projects that you have worked on, or
    are expecting to work on in the future, simply makes it real.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 目标不是设计一个系统（尽管如果你有意愿并且有足够的时间，当然可以这样做）。目标是思考面向对象的设计。专注于你曾经工作过的项目，或者你未来打算工作的项目，这样可以使它变得真实。
- en: Lastly, visit your favorite search engine and look up some tutorials on UML.
    There are dozens, so find one that suits your preferred method of study. Sketch
    some class diagrams or a sequence diagram for the objects you identified earlier.
    Don't get too hung up on memorizing the syntax (after all, if it is important,
    you can always look it up again); just get a feel for the language. Something
    will stay lodged in your brain, and it can make communicating a bit easier if
    you can quickly sketch a diagram for your next OOP discussion.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，访问你最喜欢的搜索引擎，查找一些关于UML的教程。有很多，所以找到适合你学习偏好的一个。为之前识别出的对象绘制一些类图或序列图。不要过于纠结于记忆语法（毕竟，如果它很重要，你总是可以再次查找）；只需感受一下这种语言。一些东西会留在你的脑海中，如果你能快速绘制出你下一次面向对象讨论的图表，这可以使沟通变得容易一些。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a whirlwind tour through the terminology of the object-oriented
    paradigm, focusing on object-oriented design. We can separate different objects
    into a taxonomy of different classes and describe the attributes and behaviors
    of those objects via the class interface. Abstraction, encapsulation, and information
    hiding are highly-related concepts. There are many different kinds of relationships
    between objects, including association, composition, and inheritance. UML syntax
    can be useful for fun and communication.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速浏览了面向对象范式的术语，重点关注面向对象设计。我们可以将不同的对象分为不同类别的分类，并通过类接口描述这些对象的属性和行为。抽象、封装和信息隐藏是高度相关的概念。对象之间存在许多不同类型的关系，包括关联、组合和继承。UML语法对于娱乐和沟通非常有用。
- en: In the next chapter, we'll explore how to implement classes and methods in Python.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在Python中实现类和方法。
