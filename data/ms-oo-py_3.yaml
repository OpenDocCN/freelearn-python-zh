- en: Part 2. Persistence and Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分。持久性和序列化
- en: '*[Serializing and Saving – JSON, YAML, Pickle, CSV, and XML](ch09.html "Chapter 9. Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML")*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*[序列化和保存-JSON、YAML、Pickle、CSV和XML](ch09.html "第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML")*'
- en: '*[Storing and Retrieving Objects via Shelve](ch10.html "Chapter 10. Storing
    and Retrieving Objects via Shelve")*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[通过Shelve存储和检索对象](ch10.html "第10章。通过Shelve存储和检索对象")*'
- en: '*[Storing and Retrieving objects via SQLite](ch11.html "Chapter 11. Storing
    and Retrieving Objects via SQLite")*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*[通过SQLite存储和检索对象](ch11.html "第11章。通过SQLite存储和检索对象")*'
- en: '*[Transmitting and Sharing Objects](ch12.html "Chapter 12. Transmitting and
    Sharing Objects")*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*[传输和共享对象](ch12.html "第12章。传输和共享对象")*'
- en: '*[Configuration Files and Persistence](ch13.html "Chapter 13. Configuration
    Files and Persistence")*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*[配置文件和持久性](ch13.html "第13章。配置文件和持久性")*'
- en: Persistence and Serialization
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久性和序列化
- en: A persistent object is one that has been written to some storage medium. The
    object can be retrieved from storage and used in a Python application. Perhaps
    the object was represented in JSON and written to the filesystem. Perhaps an **object-relational
    mapping** (**ORM**) layer has represented the object as rows in SQL tables to
    store the object in a database.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 持久对象是已经写入某种存储介质的对象。可以从存储中检索对象并在Python应用程序中使用。也许对象以JSON形式表示并写入文件系统。也许一个**对象关系映射**（**ORM**）层已经将对象表示为SQL表中的行，以将对象存储在数据库中。
- en: 'Serializing objects has two purposes. We serialize objects in order to make
    them persistent in the local filesystem. We also serialize objects in order to
    exchange objects between processes or applications. While the focus is different,
    persistence generally includes serialization; so, a good persistence technique
    will also work for data interchange. We''ll look at several ways in which Python
    handles serialization and persistence. The chapters in this part are organized
    as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化对象有两个目的。我们对对象进行序列化是为了使它们在本地文件系统中持久化。我们还对对象进行序列化，以在进程或应用程序之间交换对象。虽然重点不同，但持久性通常包括序列化；因此，一个良好的持久性技术也将适用于数据交换。我们将看看Python处理序列化和持久性的几种方式。本部分的章节组织如下：
- en: '[Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*, covers
    simple persistence using libraries focused on various data representations: JSON,
    YAML, pickle, XML, and CSV. These are common, widely used formats for Python data.
    They''re suitable for persistence as well as data exchange. They tend to focus
    more on a single object rather than a large domain of objects.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML")，“序列化和保存-JSON、YAML、Pickle、CSV和XML”，涵盖了使用专注于各种数据表示的库进行简单持久化：JSON、YAML、pickle、XML和CSV。这些是Python数据的常见、广泛使用的格式。它们适用于持久性以及数据交换。它们更多地关注单个对象，而不是大量对象的持久性。'
- en: '[Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve*, covers basic database operations
    with Python modules such as Shelve (and dBm) in. These provide simple storage
    of Python objects and are focused on the persistence of multiple objects.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章。通过Shelve存储和检索对象")，“通过Shelve存储和检索对象”，涵盖了使用Python模块（如Shelve和dBm）进行基本数据库操作。这些提供了Python对象的简单存储，并专注于多个对象的持久性。'
- en: '[Chapter 11](ch11.html "Chapter 11. Storing and Retrieving Objects via SQLite"),
    *Storing and Retrieving objects via SQLite*, moves to the more complex world of
    SQL and the relational database. Because SQL features don''t match object-oriented
    programming features well, we have an impedance mismatch problem. A common solution
    is to use Object-Relational Mapping to allow us to persist a large domain of objects.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11章](ch11.html "第11章。通过SQLite存储和检索对象")，“通过SQLite存储和检索对象”，转向更复杂的SQL和关系数据库世界。由于SQL特性与面向对象编程特性不匹配，我们面临阻抗不匹配问题。一个常见的解决方案是使用对象关系映射来允许我们持久化大量对象。'
- en: For web applications, we'll often work with **Representation State Transfer**
    (**REST**). [Chapter 12](ch12.html "Chapter 12. Transmitting and Sharing Objects"),
    *Transmitting and Sharing Objects*, will look at the HTTP protocol, JSON, YAML,
    and XML representation for transmitting an object.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Web应用程序，我们经常使用**表述状态转移**（**REST**）。[第12章](ch12.html "第12章。传输和共享对象")，“传输和共享对象”，将研究HTTP协议，JSON，YAML和XML表示传输对象。
- en: Finally, [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, will cover various ways in which a Python
    application can work with a configuration file. There are a number of formats
    and a number of advantages and disadvantages to each. A configuration file is
    simply a collection of persistent objects that can be easily modified by a human
    user.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，[第13章](ch13.html "第13章。配置文件和持久性")，“配置文件和持久性”，将涵盖Python应用程序可以使用配置文件的各种方式。有许多格式，每种格式都有一些优点和缺点。配置文件只是一组可以轻松被人类用户修改的持久对象。
- en: Important topics that arise throughout this part are the design patterns that
    are used at a higher level of abstraction. We'll call these architectural patterns
    because they describe the overall architecture of an application, separating it
    into layers or tiers. We are forced to break an application into pieces so that
    we can practice the principle that is often articulated as **Separation of Concerns**.
    We'll need to separate persistence from other features such as the core processing
    of our application and the presentation of data to users. Mastering object-oriented
    design means looking at higher-level, architectural design patterns.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中经常出现的重要主题是在更高级别的抽象中使用的设计模式。我们将这些称为架构模式，因为它们描述了应用程序的整体架构，将其分成层或层。我们被迫将应用程序分解成片段，以便我们可以实践通常被表述为**关注点分离**的原则。我们需要将持久性与其他功能（如应用程序的核心处理和向用户呈现数据）分开。精通面向对象的设计意味着要查看更高级别的架构设计模式。
- en: Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and XML
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML
- en: To make a Python object persistent, we must convert it to bytes and write the
    bytes to a file. We'll call this **serialization**; it is also called marshaling,
    deflating or encoding. We'll look at several ways to convert a Python object to
    a string or a stream of bytes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Python对象持久，我们必须将其转换为字节并将字节写入文件。我们将其称为**序列化**；它也被称为编组、压缩或编码。我们将研究几种将Python对象转换为字符串或字节流的方法。
- en: Each of these serialization schemes can also be called a **physical data format**.
    Each format offers some advantages and disadvantages. There's no *best* format
    to represent the objects. We must distinguish a **logical data format**, which
    may be a simple reordering or change in the use of whitespace that doesn't change
    the value of the object but changes the sequence of bytes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些序列化方案中的每一个也可以称为**物理数据格式**。每种格式都有一些优点和缺点。没有*最佳*格式来表示对象。我们必须区分**逻辑数据格式**，它可能是简单的重新排序或更改空格使用方式，而不改变对象的值，但改变字节序列。
- en: It's important to note that (except for CSV) these representations are biased
    towards representing a single Python object. While that single object can be the
    list of objects, it's still list of a fixed size. In order to process one of the
    objects, the entire list must be de-serialized. There are ways to perform incremental
    serialization, but they involve extra work. Rather than fiddling with these formats
    to handle multiple objects, there are better approaches to process many distinct
    objects in [Chapters 10](ch10.html "Chapter 10. Storing and Retrieving Objects
    via Shelve"), *Storing and Retrieving Objects via Shelve*, [Chapter 11](ch11.html
    "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing and Retrieving
    objects via SQLite*, and [Chapter 12](ch12.html "Chapter 12. Transmitting and
    Sharing Objects"), *Transmitting and Sharing Objects*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意（除了CSV），这些表示法偏向于表示单个Python对象。虽然单个对象可以是对象列表，但它仍然是固定大小的列表。为了处理其中一个对象，整个列表必须被反序列化。有方法可以执行增量序列化，但这需要额外的工作。与摆弄这些格式以处理多个对象相比，有更好的方法来处理[第10章](ch10.html
    "第10章。通过Shelve存储和检索对象")中的许多不同对象的方法，*通过Shelve存储和检索对象*，[第11章](ch11.html "第11章。通过SQLite存储和检索对象")，*通过SQLite存储和检索对象*，以及[第12章](ch12.html
    "第12章。传输和共享对象")，*传输和共享对象*。
- en: 'As each of these schemes is focused on a single object, we''re limited to objects
    that fit in the memory. When we need to process a large number of distinct items,
    not all of which can be in memory at once, we can''t use these techniques directly;
    we''ll need to move to a larger database, server, or message queue. We''ll look
    at the following serialization representations:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个方案都专注于单个对象，我们受限于适合内存的对象。当我们需要处理大量不同的项目，而不是所有项目一次性放入内存时，我们无法直接使用这些技术；我们需要转移到更大的数据库、服务器或消息队列。我们将研究以下序列化表示：
- en: '**JavaScript Object Notation** (**JSON**): This is a widely used representation.
    For more information, see [http://www.json.org](http://www.json.org). The `json`
    module provides the classes and functions necessary to load and dump data in this
    format. In *Python Standard Library*, look at section 19, *Internet Data Handling*,
    not section 12, *Persistence*. The `json` module is focused narrowly on the JSON
    representation more than the more general problem of Python object persistence.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript对象表示法（JSON）：这是一种广泛使用的表示法。有关更多信息，请参见[http://www.json.org](http://www.json.org)。`json`模块提供了在此格式中加载和转储数据所需的类和函数。在*Python标准库*中，查看第19节*Internet
    Data Handling*，而不是第12节*Persistence*。`json`模块专注于JSON表示，而不是Python对象持久性的更一般问题。
- en: '**YAML Ain''t Markup Language** (**YAML**): This is an extension to JSON and
    can lead to some simplification of the serialized output. For more information,
    see [http://yaml.org](http://yaml.org). This is not a standard part of the Python
    library; we must add a module to handle this. The `PyYaml` package, specifically,
    has numerous Python persistence features.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML不是标记语言（YAML）：这是对JSON的扩展，可以简化序列化输出。有关更多信息，请参见[http://yaml.org](http://yaml.org)。这不是Python库的标准部分；我们必须添加一个模块来处理这个问题。具体来说，`PyYaml`包具有许多Python持久性特性。
- en: '**pickle**: The `pickle` module has its own Python-specific representation
    for data. As this is a first-class part of the Python library, we''ll closely
    look at how to serialize an object this way. This has the disadvantage of being
    a poor format for the interchange of data with non-Python programs. It''s the
    basis for the `shelve` module in [Chapter 10](ch10.html "Chapter 10. Storing and
    Retrieving Objects via Shelve"), *Storing and Retrieving Objects via Shelve*,
    as well as message queues in [Chapter 12](ch12.html "Chapter 12. Transmitting
    and Sharing Objects"), *Transmitting and Sharing Objects*.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pickle**：`pickle`模块具有其自己的Python特定的数据表示形式。由于这是Python库的一部分，我们将仔细研究如何以这种方式序列化对象。这的缺点是它不适合与非Python程序交换数据。这是[第10章](ch10.html
    "第10章。通过Shelve存储和检索对象")，“通过Shelve存储和检索对象”的`shelve`模块以及[第12章](ch12.html "第12章。传输和共享对象")，“传输和共享对象”中的消息队列的基础。'
- en: '**The Comma-Separated Values (CSV) module**: This can be inconvenient for representing
    complex Python objects. As it''s so widely used, we''ll need to work out ways
    to serialize Python objects in the CSV notation. For references, look at section
    14, *File Formats*, of *Python Standard Library*, not section 12, *Persistence*,
    because it''s simply a file format and little more. CSV allows us to perform an
    incremental representation of the Python object collections that cannot fit into
    memory.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逗号分隔值（CSV）模块：这对于表示复杂的Python对象来说可能不方便。由于它被广泛使用，我们需要想办法以CSV表示法序列化Python对象。有关参考，请查看《Python标准库》第14节“文件格式”，而不是第12节“持久性”，因为它只是一个文件格式，没有更多内容。CSV允许我们对无法放入内存的Python对象集合进行递增表示。
- en: '**XML**: In spite of some disadvantages, this is very widely used, so it''s
    important to be able to convert objects into an XML notation and recover objects
    from an XML document. XML parsing is a huge subject. The reference material is
    in section 20, *Structured Markup Processing Tools*, of *Python Standard Library*.
    There are many modules to parse XML, each with different advantages and disadvantages.
    We''ll focus on `ElementTree`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML**：尽管存在一些缺点，但这是非常广泛使用的，因此能够将对象转换为XML表示法并从XML文档中恢复对象非常重要。XML解析是一个庞大的主题。参考资料在《Python标准库》第20节“结构化标记处理工具”中。有许多模块用于解析XML，每个都有不同的优点和缺点。我们将重点关注`ElementTree`。'
- en: Beyond these simple categories, we can also have hybrid problems. One example
    is a spreadsheet encoded in XML. This means that we have a row-and-column data
    representation problem wrapped in the XML parsing problem. This leads to more
    complex software to disentangle the various kinds of data that were flattened
    to CSV-like rows so that we can recover useful Python objects. In [Chapter 12](ch12.html
    "Chapter 12. Transmitting and Sharing Objects"), *Transmitting and Sharing Objects*,
    and [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, we'll revisit a number of these topics
    as we use RESTful web services with serialized objects as well as editable serialized
    objects for configuration files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些简单的类别，我们还可能遇到混合问题。一个例子是用XML编码的电子表格。这意味着我们有一个包裹在XML解析问题中的行列数据表示问题。这导致了更复杂的软件，以解开被扁平化为类似CSV的行的各种数据，以便我们可以恢复有用的Python对象。在[第12章](ch12.html
    "第12章。传输和共享对象")，“传输和共享对象”，以及[第13章](ch13.html "第13章。配置文件和持久性")，“配置文件和持久性”中，我们将重新讨论这些主题，因为我们使用RESTful
    web服务与序列化对象以及可编辑的序列化对象用于配置文件。
- en: Understanding persistence, class, state, and representation
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解持久性、类、状态和表示形式
- en: Primarily, our Python objects exist in volatile computer memory. They can only
    live as long as the Python process is running. They may not even live that long;
    they may only live as long as they have references in a namespace. If we want
    an object that outlives the Python process or namespace, we need to make it persistent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主要地，我们的Python对象存在于易失性计算机内存中。它们只能存在于Python进程运行的时间。它们甚至可能活不了那么久；它们可能只能活到它们在命名空间中有引用的时间。如果我们想要一个超出Python进程或命名空间寿命的对象，我们需要使其持久化。
- en: Most operating systems offer persistent storage in the form of a filesystem.
    This usually includes disk drives, flash drives, or other forms of non-volatile
    storage. It seems like it's simply a matter of transferring bytes from the memory
    to a disk file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统以文件系统的形式提供持久存储。这通常包括磁盘驱动器、闪存驱动器或其他形式的非易失性存储。这似乎只是将字节从内存传输到磁盘文件的问题。
- en: The complexity arises because our in-memory Python objects have references to
    other objects. An object refers to its class. The class refers to its metaclass
    and any base classes. The object might be a container and refer to other objects.
    The in-memory version of an object is a web of references and relationships. As
    the memory locations are not fixed, the relationships would be broken by trying
    simply to dump and restore memory bytes without rewriting addresses into some
    kind of location-independent key.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性的原因在于我们的内存中的Python对象引用其他对象。一个对象引用它的类。类引用它的元类和任何基类。对象可能是一个容器，并引用其他对象。对象的内存版本是一系列引用和关系。由于内存位置不固定，尝试简单地转储和恢复内存字节而不将地址重写为某种位置无关的键将会破坏这些关系。
- en: Many of the objects in the web of references are largely static—class definitions,
    for example, change very slowly compared to variables. Ideally, a class definition
    doesn't change at all. However, we may have class-level instance variables. More
    importantly, we need to upgrade our application software, changing class definitions,
    which changes object features. We'll call this the **Schema Migration Problem**,
    managing change to the schema (or class) of our data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 引用网络中的许多对象在很大程度上是静态的——例如类定义变化非常缓慢，与变量相比。理想情况下，类定义根本不会改变。但是，我们可能有类级实例变量。更重要的是，我们需要升级我们的应用软件，改变类定义，从而改变对象特性。我们将这称为**模式迁移问题**，管理数据模式（或类）的变化。
- en: Python gives us a formal distinction between the instance variables of an object
    and other attributes that are part of the class. Our design decisions leverage
    this distinction. We define an object's instance variables to properly show the
    dynamic state of the object. We use class-level attributes for information that
    objects of that class will share. If we can persist only the dynamic state of
    an object—separated from the class and the web of references that are part of
    the class definition—that would be a workable solution to serialization and persistence.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python为对象的实例变量和类的其他属性之间给出了正式的区别。我们的设计决策利用了这一区别。我们定义对象的实例变量来正确显示对象的动态状态。我们使用类级属性来存储该类的对象将共享的信息。如果我们只能持久化对象的动态状态——与类和类定义的引用网络分开——那将是一种可行的序列化和持久化解决方案。
- en: We don't actually have to do anything to persist our class definitions; we already
    have an entirely separate and very simple method for that. Class definitions exist
    primarily as source code. The class definition in the volatile memory is rebuilt
    from the source (or the byte-code version of the source) every time it's needed.
    If we need to exchange class definition, we exchange Python modules or packages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不必做任何事情来持久化我们的类定义；我们已经有一个完全独立且非常简单的方法来做到这一点。类定义主要存在于源代码中。易失性内存中的类定义是从源代码（或源代码的字节码版本）中每次需要时重新构建的。如果我们需要交换类定义，我们交换Python模块或包。
- en: Common Python terminologies
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的Python术语
- en: 'Python terminology tends to focus on the words *dump* and *load*. Most of the
    various classes we''re going to work will define methods such as the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python术语往往侧重于*转储*和*加载*这两个词。我们将要使用的大多数各种类都将定义以下方法：
- en: '`dump(object, file)`: This will dump the given object to the given file'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dump(object, file)`: 这将把给定的对象转储到给定的文件中'
- en: '`dumps(object)`: This will dump an object, returning a string representation'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dumps(object)`: 这将转储一个对象，并返回一个字符串表示'
- en: '`load(file)`: This will load an object from the given file, returning the constructed
    object'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load(file)`: 这将从给定的文件加载一个对象，并返回构造的对象'
- en: '`loads(string)`: This will load an object from a string representation, returning
    the constructed object'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loads(string)`: 这将从一个字符串表示中加载一个对象，并返回构造的对象'
- en: There's no standard; the method names aren't *guaranteed* by any formal ABC
    inheritance or the mixin class definition. However, they're widely used. Generally,
    the file used for the dump or load can be any *file-like* object. A short list
    of methods such as `read()` and `readline()` are required for the load, but we
    need little more than this. We can, therefore, use the `io.StringIO` objects as
    well as the `urllib.request` objects as sources for the load. Similarly, dump
    places few requirements on the data source. We'll dig into these file object considerations
    next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 没有标准；方法名并不是由任何正式的ABC继承或混合类定义*保证*的。然而，它们被广泛使用。通常，用于转储或加载的文件可以是任何*类似文件*的对象。加载需要一些方法，如`read()`和`readline()`，但我们不需要更多。因此，我们可以使用`io.StringIO`对象以及`urllib.request`对象作为加载的来源。同样，转储对数据源的要求很少。我们将在下一节中深入探讨这些文件对象的考虑。
- en: Filesystem and network considerations
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统和网络考虑因素
- en: As the OS filesystem (and network) works in bytes, we need to represent the
    values of an object's instance variables as a serialized stream of bytes. Often,
    we'll use a two-step transformation to bytes; we'll represent the state of an
    object as a string and rely on the Python string to provide bytes in a standard
    encoding. Python's built-in features for encoding a string into bytes neatly solves
    this part of the problem.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统文件系统（和网络）以字节为单位工作，我们需要将对象的实例变量的值表示为序列化的字节流。通常，我们会使用两步转换为字节；我们将对象的状态表示为一个字符串，并依赖于Python字符串提供标准编码的字节。Python内置的将字符串编码为字节的功能很好地解决了问题的这一部分。
- en: 'When we look at our OS filesystems, we see two broad classes of devices: block-mode
    devices and character-mode devices. Block-mode devices can also be called *seekable*
    because the OS supports a seek operation that can access any byte in the file
    in an arbitrary order. Character-mode devices are not seekable; they are interfaces
    where bytes are transmitted serially. Seeking would involve travelling backwards
    in time.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看操作系统文件系统时，我们会看到两类广泛的设备：块模式设备和字符模式设备。块模式设备也可以称为*可寻址*，因为操作系统支持可以以任意顺序访问文件中的任何字节的寻址操作。字符模式设备不可寻址；它们是以串行方式传输字节的接口。寻址将涉及向后移动时间。
- en: 'This distinction between `character` and block mode can have an impact on how
    we represent the state of a complex object or a collection of objects. The serializations
    we''ll look at in this chapter focus on the simplest common feature set: an ordered
    stream of bytes; these formats make no use of seekable devices; they will save
    the stream of bytes into either character-mode or block-mode block-mode file.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 字符和块模式之间的这种区别可能会影响我们如何表示复杂对象或对象集合的状态。本章中我们将要讨论的序列化重点是最简单的常见特性集：有序的字节流；这些格式不使用可寻址设备；它们将将字节流保存到字符模式或块模式文件中。
- en: The formats we'll look at in [Chapter 10](ch10.html "Chapter 10. Storing and
    Retrieving Objects via Shelve"), *Storing and Retrieving Objects via Shelve*,
    and [Chapter 11](ch11.html "Chapter 11. Storing and Retrieving Objects via SQLite"),
    *Storing and Retrieving Objects via SQLite*, however, will require block-mode
    storage in order to encode more objects than could possibly fit into memory. The
    `shelve` module and the `SQLite` database make extensive use of seekable files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在[第10章](ch10.html "第10章。通过Shelve存储和检索对象")和[第11章](ch11.html "第11章。通过SQLite存储和检索对象")中我们将要讨论的格式，*通过Shelve存储和检索对象*和*通过SQLite存储和检索对象*，将需要块模式存储以便编码更多的对象，而不是可能适合内存的对象。`shelve`模块和`SQLite`数据库广泛使用可寻址文件。
- en: A minor confounding factor is the way that the OS unifies block- and character-mode
    devices into a single filesystem metaphor. Some parts of the Python Standard Library
    implement the lowest-common feature set between the block and character devices.
    When we use Python's `urllib.request`, we can access the network resources, as
    well as local files for the data. When we open a local file, this module must
    impose the limited character-mode interface on an otherwise seekable kind of file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的令人困惑的因素是操作系统将块和字符模式设备统一到一个单一的文件系统隐喻中的方式。Python 标准库的一些部分实现了块和字符设备之间的最低公共特性集。当我们使用
    Python 的 `urllib.request` 时，我们可以访问网络资源，以及本地文件的数据。当我们打开一个本地文件时，这个模块必须对一个本来是可寻址的文件施加有限的字符模式接口。
- en: Defining classes to support persistence
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义支持持久性的类
- en: 'Before we can work with persistence, we need some objects that we want to save.
    There are several design considerations related to persistence, so we''ll start
    with some simple class definitions. We''ll look at a simple microblog and the
    posts on that blog. Here''s a class definition for `Post`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以处理持久性之前，我们需要一些我们想要保存的对象。与持久性相关的有几个设计考虑，所以我们将从一些简单的类定义开始。我们将看一个简单的微博和该博客上的帖子。这里是
    `Post` 的一个类定义：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The instance variables are the attributes of each microblog post: a date, a
    title, some text, and some tags. Our attribute name provides us a hint that the
    text should be in RST markup, even though that''s largely irrelevant to the rest
    of the data model.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量是每个微博帖子的属性：日期、标题、一些文本和一些标签。我们的属性名称为我们提供了一个提示，即文本应该是 RST 标记，尽管这对于数据模型的其余部分来说并不重要。
- en: To support simple substitution into templates, the `as_dict()` method returns
    a dictionary of values that have been converted into string format. We'll look
    at the template processing using `string.Template` later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持简单的替换到模板中，`as_dict()` 方法返回一个值的字典，这些值已经转换为字符串格式。我们稍后会看一下使用 `string.Template`
    进行模板处理。
- en: 'Additionally, we''ve added a few values to help with creating the RST output.
    The `tag_text` attribute is a flattened text version of the tuple of tag values.
    The `underline` attribute produces an underline string with a length that matches
    the title string; this helps the RST formatting work out nicely. We''ll also create
    a blog as a collection of posts. We''ll make this collection more than a simple
    list by including an additional attribute of a title. We have three choices for
    the collection design: wrap, extend, or invent a new class. We''ll head off some
    confusion by providing this warning: don''t extend a `list` if you intend to make
    it persistent.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们添加了一些值来帮助创建 RST 输出。`tag_text` 属性是标签值元组的扁平文本版本。`underline` 属性生成一个与标题字符串长度相匹配的下划线字符串；这有助于
    RST 格式化工作得很好。我们还将创建一个博客作为帖子的集合。我们将通过包括标题的附加属性使这个集合不仅仅是一个简单的列表。我们有三种选择用于集合设计：包装、扩展或发明一个新的类。我们将通过提供这个警告来避免一些混淆：如果你打算使它持久化，不要扩展一个
    `list`。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Extending an iterable object can be confusing**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展可迭代对象可能会令人困惑**'
- en: When we extend a sequence, we might confuse some of the built-in serialization
    algorithms. The built-in algorithms may wind up bypassing the extended features
    we put in a subclass of a sequence. Wrapping a sequence is usually a better idea
    than extending one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展一个序列时，可能会混淆一些内置的序列化算法。内置算法可能会绕过我们在序列的子类中放入的扩展特性。包装序列通常比扩展序列更好。
- en: 'This forces us to look at wrapping or inventing. It''s a simple sequence, so
    why invent something new? Wrapping is what we''ll emphasize on as a design strategy.
    Here''s a collection of microblog posts. We''ve wrapped a list, as extending a
    list won''t always work well:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使我们考虑包装或发明。这是一个简单的序列，为什么要发明新的东西呢？包装是我们将强调的设计策略。这里有一系列微博帖子。我们已经包装了一个列表，因为扩展列表并不总是有效的：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to wrapping the list, we've also included an attribute that is the
    title of the microblog. The initializer uses a common technique to avoid providing
    a mutable object as a default value. We've provided `None` as the default value
    for `posts`. If `posts` is `None`, we use a freshly-minted empty list, `[]`. Otherwise,
    we use the given value for posts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包装列表，我们还包括了一个微博的标题属性。初始化程序使用了一种常见的技术，以避免提供可变对象作为默认值。我们为 `posts` 提供了 `None`
    作为默认值。如果 `posts` 是 `None`，我们使用一个新创建的空列表 `[]`。否则，我们使用给定的 `posts` 值。
- en: Additionally, we've defined a method that indexes the posts by their tags. In
    the resulting `defaultdict`, each key is a tag's text. Each value is a list of
    posts that share the given tag.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们定义了一个按标签索引帖子的方法。在生成的 `defaultdict` 中，每个键都是一个标签的文本。每个值都是共享给定标签的帖子的列表。
- en: 'To simplify the use of `string.Template`, we''ve added another `as_dict()`
    method that boils the entire blog down to a simple dictionary of strings and dictionaries.
    The idea here is to produce only built-in types that have simple string representations.
    We''ll show you the template rendering process next. Here''s some sample data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化使用 `string.Template`，我们添加了另一个 `as_dict()` 方法，将整个博客简化为一个简单的字符串和字典的字典。这里的想法是只产生具有简单字符串表示的内置类型。接下来我们将展示模板渲染过程。这里是一些示例数据：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've serialized the `Blog` and `Post` as the Python code. This isn't really
    all bad as a way to represent the blog. There are some use cases where Python
    code is a perfectly fine representation for an object. In [Chapter 13](ch13.html
    "Chapter 13. Configuration Files and Persistence"), *Configuration Files and Persistence*,
    we'll look more closely at simply using Python to encode data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `Blog` 和 `Post` 序列化为 Python 代码。这并不是一个完全糟糕的表示博客的方式。有一些用例中，Python 代码是对象的一个完全合适的表示。在[第13章](ch13.html
    "第13章。配置文件和持久性") *配置文件和持久性* 中，我们将更仔细地看一下简单地使用 Python 编码数据。
- en: Rendering a blog and posts
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染博客和帖子
- en: Just to be complete, here's a way to render the blog into RST. From this output
    file, the docutils `rst2html.py` tool can transform the RST output into the final
    HTML file. This saves us from having to digress into HTML and CSS. Also, we're
    going to use RST to write the documentation in [Chapter 18](ch18.html "Chapter 18. Quality
    and Documentation"), *Quality and Documentation* For more information on docutils,
    see *Some Preliminaries*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，这里有一种将博客呈现为RST的方法。从这个输出文件中，docutils的`rst2html.py`工具可以将RST输出转换为最终的HTML文件。这样我们就不必深入研究HTML和CSS了。此外，我们将使用RST来编写[第18章](ch18.html
    "第18章。质量和文档")中的文档，*质量和文档*有关docutils的更多信息，请参见*一些准备工作*。
- en: 'We can use the `string.Template` class to do this. However, it''s clunky and
    complex. There are a number of add-on template tools that can perform a more sophisticated
    substitution, including loops and conditional processing within the template itself.
    Here''s a list of alternatives: [https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating).
    We''re going to show you an example using the Jinja2 template tool. See [https://pypi.python.org/pypi/Jinja2](https://pypi.python.org/pypi/Jinja2).
    Here''s a script to render this data in RST using a template:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`string.Template`类来做到这一点。然而，这很笨拙和复杂。有许多附加的模板工具可以在模板本身内执行更复杂的替换，包括循环和条件处理。这里有一些替代方案：[https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating)。我们将向您展示一个使用Jinja2模板工具的示例。请参阅[https://pypi.python.org/pypi/Jinja2](https://pypi.python.org/pypi/Jinja2)。这是一个使用模板在RST中呈现这些数据的脚本：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `{{title}}` and `{{underline}}` elements (and all similar elements) show
    us how values are substituted into the text of the template. The `render()` method
    is called with `**travel.as_dict()` to ensure that attributes such as `title`
    and `underline` will be keyword arguments.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{title}}`和`{{underline}}`元素（以及所有类似的元素）向我们展示了如何将值替换为模板文本。使用`render()`方法调用`**travel.as_dict()`，以确保属性（如`title`和`underline`）将成为关键字参数。'
- en: 'The `{%for%}` and `{%endfor%}` constructs show us how Jinja can iterate through
    the sequence of `Post` entries in `Blog`. Within the body of this loop, the variable
    `e` will be the dictionary created from each `Post`. We''ve picked specific keys
    out of the dictionary for each post: `{{e.title}}`, `{{e.rst_text}}`, and so on.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`{%for%}`和`{%endfor%}`构造向我们展示了Jinja如何遍历`Blog`中`Post`条目的序列。在此循环的主体中，变量`e`将是从每个`Post`创建的字典。我们从字典中为每个帖子挑选了特定的键：`{{e.title}}`、`{{e.rst_text}}`等。'
- en: We also iterated through a `tags` collection for the `Blog`. This is a dictionary
    with the keys of each tag and the posts for the tag. The loop will visit each
    key, assigned to `t`. The body of the loop will iterate through the posts in the
    dictionary value, `tags[t]`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还遍历了`Blog`的`tags`集合。这是一个字典，其中包含每个标签的键和该标签的帖子。循环将访问每个键，分配给`t`。循环的主体将遍历字典值中的帖子，即`tags[t]`。
- en: The ``{{post.title}}`_` construct is an RST markup that generates a link to
    the section that has that title within the document. This kind of very simple
    markup is one of the strengths of RST. We've used the blog titles as sections
    and links within the index. This means that the titles *must* be unique or we'll
    get RST rendering errors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '``{{post.title}}`_`构造是一个RST标记，它生成一个链接到文档中具有该标题的部分。这种非常简单的标记是RST的优势之一。我们已经将博客标题用作索引中的部分和链接。这意味着标题*必须*是唯一的，否则我们将获得RST呈现错误。'
- en: Because this template iterates through a given blog, it will render all of the
    posts in one smooth motion. The `string.Template`, which is built-in to Python,
    can't iterate. This makes it a bit more complex to render all of the `Posts` of
    a `Blog`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个模板遍历给定的博客，它将以一种平稳的动作呈现所有的帖子。内置于Python的`string.Template`不能进行迭代。这使得呈现`Blog`的所有`Posts`变得更加复杂。
- en: Dumping and loading with JSON
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSON进行转储和加载
- en: 'What is JSON? A section from the [www.json.org](http://www.json.org) web page
    states that:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是什么？来自[www.json.org](http://www.json.org)网页的一节指出：
- en: JSON (JavaScript Object Notation) is a lightweight data-interchange format.
    It is easy for humans to read and write. It is easy for machines to parse and
    generate. It is based on a subset of the JavaScript Programming Language, Standard
    ECMA-262 3rd Edition - December 1999\. JSON is a text format that is completely
    language independent but uses conventions that are familiar to programmers of
    the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python,
    and many others. These properties make JSON an ideal data-interchange language.
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON（JavaScript对象表示）是一种轻量级的数据交换格式。人类很容易阅读和书写。机器很容易解析和生成。它基于JavaScript编程语言的一个子集，标准ECMA-262第3版-1999年12月。JSON是一种完全与语言无关的文本格式，但使用了熟悉C系列语言的程序员的约定，包括C、C++、C#、Java、JavaScript、Perl、Python等。这些特性使JSON成为一种理想的数据交换语言。
- en: This format is used by a broad spectrum of languages and frameworks. Databases
    such as CouchDB represent their data as JSON objects, simplifying the transmission
    of data between applications. JSON documents have the advantage of looking vague
    like Python `list` and `dict` literal values. They're easy to read and easy to
    edit manually.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式被广泛用于各种语言和框架。诸如CouchDB之类的数据库将其数据表示为JSON对象，简化了应用程序之间的数据传输。JSON文档具有类似Python
    `list`和`dict`文字值的优势。它们易于阅读和手动编辑。
- en: 'The `json` module works with the built-in Python types. It does not work with
    classes defined by us until we take some additional steps. We''ll look at these
    extension techniques next. For the following Python types, there''s a mapping
    to JavaScript types that JSON uses:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块与内置的Python类型一起使用。它不适用于我们定义的类，直到我们采取一些额外的步骤。接下来我们将看看这些扩展技术。对于以下Python类型，有一个映射到JSON使用的JavaScript类型：'
- en: '| Python type | JSON |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| Python类型 | JSON |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `dict` | `object` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `dict` | `object` |'
- en: '| `list, tuple` | `array` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `list, tuple` | `array` |'
- en: '| `str` | `string` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `str` | `string` |'
- en: '| `int, float` | `number` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `int, float` | `number` |'
- en: '| `True` | `true` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `True` | `true` |'
- en: '| `False` | `false` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `False` | `false` |'
- en: '| `None` | `null` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `None` | `null` |'
- en: 'Other types are not supported and must be coerced to one of these via the extension
    functions that we can plug into the dump and load functions. We can explore these
    built-in types by transforming our microblog objects into simpler Python `lists`
    and `dicts`. When we look at our `Post` and `Blog` class definitions, we have
    already defined the `as_dict()` methods that reduce our custom class objects to
    built-in Python objects. Here''s the code required to produce a JSON version of
    our blog data:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型不受支持，必须通过我们可以插入到dump和load函数中的扩展函数来强制转换为这些类型之一。我们可以通过将我们的微博对象转换为更简单的Python`lists`和`dicts`来探索这些内置类型。当我们查看我们的`Post`和`Blog`类定义时，我们已经定义了`as_dict()`方法，将我们的自定义类对象减少为内置的Python对象。以下是生成我们博客数据的JSON版本所需的代码：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s the output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding output shows us how each of the various objects are translated
    from Python to the JSON notation. What''s elegant about this is that our Python
    objects have been written into a standardized notation. We can share them with
    other applications. We can write them to disk files and preserve them. There are
    several unpleasant features of the JSON representation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出向我们展示了各种对象是如何从Python转换为JSON表示的。这种方法的优雅之处在于我们的Python对象已经被写入了一个标准化的表示法。我们可以与其他应用程序共享它们。我们可以将它们写入磁盘文件并保存它们。JSON表示的一些不愉快特性有：
- en: We had to rewrite our Python objects into dictionaries. It would be much nicer
    to transform Python objects more simply, without explicitly creating additional
    dictionaries.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不将我们的Python对象重写为字典。更好的方法是以更简单的方式转换Python对象，而不需要显式创建额外的字典。
- en: We can't rebuild our original `Blog` and `Post` objects easily when we load
    this JSON representation. When we use `json.load()`, we won't get `Blog` or `Post`
    objects; we'll just get `dict` and list objects. We need to provide some additional
    hints to rebuild the `Blog` and `Post` objects.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们加载这个JSON表示时，我们无法轻松地重建我们原来的`Blog`和`Post`对象。当我们使用`json.load()`时，我们得到的不是`Blog`或`Post`对象，而是`dict`和列表对象。我们需要提供一些额外的提示来重建`Blog`和`Post`对象。
- en: There are some values in the object's `__dict__` that we'd rather not persist,
    such as the underlined text for a `Post`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的`__dict__`中有一些值我们不想持久化，比如`Post`的下划线文本。
- en: We need something more sophisticated than the built-in JSON encoding.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要比内置的JSON编码更复杂的东西。
- en: Supporting JSON in our classes
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的类中支持JSON
- en: In order to properly support JSON, we need to inform the JSON encoders and decoders
    about our classes. For encoding our objects into JSON, we need to provide a function
    that will reduce our objects to Python primitive types. This is called a *default*
    function; it provides a default encoding for an object of an unknown class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确支持JSON，我们需要通知JSON编码器和解码器关于我们的类。为了将我们的对象编码为JSON，我们需要提供一个函数，将我们的对象减少为Python原始类型。这被称为*默认*函数；它为未知类的对象提供默认编码。
- en: To decode our objects from JSON, we need to provide a function that will transform
    a dictionary of Python primitive types back into an object of the proper class.
    This is called the *object hook* function; it's used to transform `dict` to an
    object of a customized class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从JSON中解码我们的对象，我们需要提供一个函数，将Python原始类型的字典转换回适当类的对象。这被称为*对象钩子*函数；它用于将`dict`转换为自定义类的对象。
- en: 'The `json` module documentation suggests that we might want to make use of
    class hinting. The Python documentation includes a reference to the JSON-RPC version
    1 specification. See [http://json-rpc.org/wiki/specification](http://json-rpc.org/wiki/specification).
    This suggestion is to encode an instance of a customized class as a dictionary
    like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块文档建议我们可能希望使用类提示。Python文档包括对JSON-RPC版本1规范的引用。参见[http://json-rpc.org/wiki/specification](http://json-rpc.org/wiki/specification)。这个建议是将自定义类的实例编码为以下的字典：'
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The suggested value associated with the `"__jsonclass__"` key is a list of
    two items: the class name and a list of arguments required to create an instance
    of that class. The specification allows for more features, but they''re not relevant
    to Python.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与`"__jsonclass__"`键关联的建议值是一个包含两个项目的列表：类名和创建该类实例所需的参数列表。规范允许更多的特性，但它们与Python无关。
- en: To decode an object from a JSON dictionary, we can look for the `"__jsonclass__"`
    key as a hint that one of our classes needs to be built, not a built-in Python
    object. The class name can be mapped to a class object and the argument sequence
    can be used to build the instance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSON字典中解码对象时，我们可以查找`"__jsonclass__"`键作为提示，表明我们需要构建一个类，而不是一个内置的Python对象。类名可以映射到一个类对象，并且参数序列可以用来构建实例。
- en: When we look at other sophisticated JSON encoders (such as the one that comes
    with the Django Web framework), we can see that they provide a bit more complex
    encoding of a custom class. They include the class, a database primary key, and
    the attribute values. We'll look at how we implement customized encoding and decoding.
    The rules are represented as simple functions that are plugged into the JSON encoding
    and decoding functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看其他复杂的JSON编码器（比如Django Web框架自带的编码器）时，我们可以看到它们提供了更复杂的自定义类编码。它们包括类、数据库主键和属性值。我们将看看如何实现自定义编码和解码。规则被表示为简单的函数，这些函数被插入到JSON编码和解码函数中。
- en: Customizing JSON encoding
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义JSON编码
- en: 'For class hinting, we''ll provide three pieces of information. We''ll include
    a `__class__` key that names the target class. The `__args__` key will provide
    a sequence of positional argument values. A `__kw__` key will provide a dictionary
    of keyword argument values. This will cover all the options of `__init__()`. Here''s
    an encoder that follows this design:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类提示，我们将提供三个信息。我们将包括一个`__class__`键，命名目标类。`__args__`键将提供一个位置参数值的序列。`__kw__`键将提供一个关键字参数值的字典。这将涵盖`__init__()`的所有选项。以下是遵循这种设计的编码器：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function shows us two different flavors of object encodings for the three
    classes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数展示了三个类的两种不同风格的对象编码：
- en: We encoded a `datetime.datetime` object as a dictionary of individual fields
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将一个`datetime.datetime`对象编码为一个单独字段的字典
- en: We also encoded a `Post` instance as a dictionary of individual fields
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将一个`Post`实例编码为一个单独字段的字典
- en: We encoded a `Blog` instance as a sequence of title and post entries
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将一个`Blog`实例编码为标题和文章条目的序列
- en: 'If we can''t process the class, we invoke the existing encoder''s default encoding.
    This will handle the built-in classes. We can use this function to encode as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法处理这个类，我们会调用现有编码器的默认编码。这将处理内置类。我们可以使用这个函数进行编码，如下所示：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We provided our function, `blog_encode()`, as the `default=` keyword parameter
    to the `json.dumps()` function. This function is used by the JSON encoder to determine
    the encoding for an object. This encoder leads to JSON objects that look like
    the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的函数`blog_encode()`作为`json.dumps()`函数的`default=`关键字参数提供。这个函数被JSON编码器用来确定对象的编码。这个编码器导致的JSON对象看起来像下面的代码：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've taken out the second blog entry because the output was rather long. A
    `Blog` object is now wrapped with a `dict` that provides the class and two positional
    argument values. The `Post` and `datetime` objects, similarly, are wrapped with
    the class name and the keyword argument values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除了第二个博客条目，因为输出太长了。现在，`Blog`对象用一个提供类和两个位置参数值的`dict`包装起来。同样，`Post`和`datetime`对象也用类名和关键字参数值包装起来。
- en: Customizing JSON decoding
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义JSON解码
- en: In order to decode a JSON object, we need to work within the structure of a
    JSON parsing. Objects of our customized class definitions were encoded as simple
    `dicts`. This means that each `dict` decoded by the JSON decoder *could* be one
    of our customized classes. Or, `dict` could just be a `dict`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解码一个JSON对象，我们需要在JSON解析的结构内工作。我们定制的类定义的对象被编码为简单的`dicts`。这意味着每个被JSON解码的`dict`
    *可能* 是我们定制的类之一。或者，`dict`可能只是一个`dict`。
- en: 'The JSON decoder "object hook" is a function that''s invoked for each `dict`
    to see if it represents a customized object. If `dict` isn''t recognized by the
    `hook` function, then it''s just a dictionary and should be returned without modification.
    Here''s our object hook function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JSON解码器的“对象钩子”是一个函数，它会为每个`dict`调用，以查看它是否表示一个定制对象。如果`dict`不被`hook`函数识别，那么它只是一个字典，应该原样返回。这是我们的对象钩子函数：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each time this function is invoked, it checks for the keys that define an encoding
    of our objects. If the three keys are present, then the given function is called
    with the arguments and keywords. We can use this object hook to parse a JSON object
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此函数时，它都会检查定义对象编码的键。如果存在这三个键，那么将使用给定的参数和关键字调用该函数。我们可以使用这个对象钩子来解析JSON对象，如下所示：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will decode a block of text, encoded in a JSON notation, using our `blog_decode()`
    function to transform `dict` into proper `Blog` and `Post` objects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解码一块以JSON表示的文本，使用我们的`blog_decode()`函数将`dict`转换为正确的`Blog`和`Post`对象。
- en: The security and the eval() issue
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全和eval()问题
- en: Some programmers will object to the use of the `eval()` function in our `blog_decode()`
    function, claiming that it is a pervasive security problem. What's silly is the
    claim that `eval()` is a pervasive problem. It's a *potential* security problem
    if malicious code is written into the JSON representation of an object by some
    **Evil Genius Programmer** (**EGP**). A local EGP has access to the Python source.
    Why mess with subtle tweaking JSON files? Why not just edit the Python source?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员会反对在我们的`blog_decode()`函数中使用`eval()`函数，声称这是一个普遍存在的安全问题。可笑的是声称`eval()`是一个普遍存在的问题。如果恶意代码被写入JSON对象的表示中，那么它就是一个*潜在*的安全问题，这是一个本地的EGP可以访问Python源代码。为什么要去微调JSON文件？为什么不直接编辑Python源代码呢？
- en: As a pragmatic issue, we have to look at transmission of the JSON documents
    through the Internet; this is an actual security problem. However, it does not
    indict `eval()` in general.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实际问题，我们必须考虑通过互联网传输JSON文档；这是一个实际的安全问题。然而，这并不是一般情况下对`eval()`的控诉。
- en: Some provision must be made for a situation where an untrustworthy document
    has been tweaked by a **Man In The Middle** attack. In this case, a JSON document
    is doctored while passing through a web interface that includes an untrustworthy
    server acting as a proxy. SSL is usually the preferred method to prevent this
    problem.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 必须考虑一种情况，即一个不可信的文档被**中间人**攻击篡改。在这种情况下，一个JSON文档在通过包括一个不可信的服务器作为代理的网络接口时被篡改。SSL通常是防止这个问题的首选方法。
- en: 'If necessary, we can replace `eval()` with a dictionary that maps from name
    to class. We can change `eval(some_dict[''__class__''])` to `{"Post":Post, "Blog":Blog,
    "datetime.datetime":datetime.datetime`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有必要，我们可以用一个从名称到类的映射字典来替换`eval()`。我们可以将`eval(some_dict['__class__'])`改为`{"Post":Post,
    "Blog":Blog, "datetime.datetime":datetime.datetime`：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will prevent problems in the event that a JSON document is passed through
    a non-SSL-encoded connection. It also leads to a maintenance requirement to tweak
    this mapping each time the application design changes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止在通过非SSL编码连接传递JSON文档时出现问题。这也导致了一个维护要求，即每当应用程序设计发生变化时，都需要微调这个映射。
- en: Refactoring the encode function
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构编码函数
- en: Ideally, we'd like to refactor our encoding function to focus on the responsibility
    for proper encoding on each defining class. We'd rather not pile all of the encoding
    rules into a separate function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望重构我们的编码函数，专注于每个定义类的正确编码的责任。我们不想把所有的编码规则堆积到一个单独的函数中。
- en: 'To do this with library classes such as `datetime`, we would need to extend
    `datetime.datetime` for our application. If we did that, we would need to be sure
    that our application used our extended `datetime` instead of the `datetime` library.
    This can become a bit of a headache to avoid using the built-in `datetime` classes.
    Often, we have to strike a balance between our customized classes and library
    classes. Here are two class extensions that will create JSON-encodable class definitions.
    We can add a property to `Blog`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用诸如`datetime`之类的库类来做到这一点，我们需要为我们的应用程序扩展`datetime.datetime`。如果我们这样做了，我们需要确保我们的应用程序使用我们扩展的`datetime`而不是`datetime`库。这可能会变得有点头疼，以避免使用内置的`datetime`类。通常，我们必须在我们定制的类和库类之间取得平衡。以下是将创建JSON可编码类定义的两个类扩展。我们可以向`Blog`添加一个属性：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This property will provide initialization arguments that are usable by our
    decoding function. We can add these two properties to `Post`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性将提供初始化参数，可供我们的解码函数使用。我们可以将这两个属性添加到`Post`中：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As with `Blog`, this property will provide initialization arguments that are
    usable by our decoding function. We can modify the encoder to make it somewhat
    simpler. Here''s a revised version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Blog`一样，这个属性将提供初始化参数，可供我们的解码函数使用。我们可以修改编码器，使其变得更简单一些。以下是修订后的版本：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We're still constrained by our choice to use the library `datetime` module.
    In this example, we elected not to introduce subclasses but handle the encoding
    as a special case, rather.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然受到使用库`datetime`模块的选择的限制。在这个例子中，我们选择不引入子类，而是将编码处理为特殊情况。
- en: Standardizing the date string
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准化日期字符串
- en: Our formatting of dates doesn't make use of the widely-used ISO standard text
    format for dates. To be more compatible with other languages, we should properly
    encode the `datetime` object in a standard string and parse a standard string.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对日期的格式化没有使用广泛使用的ISO标准文本日期格式。为了与其他语言更兼容，我们应该正确地对`datetime`对象进行标准字符串编码和解析标准字符串。
- en: 'As we''re already treating dates as a special case, this seems to be a sensible
    extension of that special case treatment. It can be done without too much change
    to our encoding and decoding. Consider this small change to the encoding:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将日期视为特殊情况，这似乎是对该特殊情况处理的合理扩展。这可以在不太改变我们的编码和解码的情况下完成。考虑对编码进行的这个小改变：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The encoded output names the static method `datetime.datetime.strptime()` and
    provides the argument encoded `datetime` as well as the format to be used to decode
    it. The output for a post now looks like the following snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 编码输出命名了静态方法`datetime.datetime.strptime()`，并提供了编码的参数`datetime`以及要用于解码的格式。现在，帖子的输出看起来像以下代码片段：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This shows us that we now have an ISO-formatted date instead of individual fields.
    We've also moved away from the object creation using a class name. The `__class__`
    value is expanded to be a class name or a static method name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们表明，现在我们有一个ISO格式的日期，而不是单独的字段。我们还摆脱了使用类名创建对象的方式。`__class__`值扩展为类名或静态方法名。
- en: Writing JSON to a file
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将JSON写入文件
- en: 'When we write JSON files, we generally do something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写JSON文件时，我们通常会这样做：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We open the file with the required encoding. We provide the file object to
    the `json.dump()` method. When we read JSON files, we will use a similar technique:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用所需的编码打开文件。我们将文件对象提供给`json.dump()`方法。当我们读取JSON文件时，我们将使用类似的技术：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The idea is to segregate the JSON representation as text from any conversion
    to bytes on the resulting file. There are a few formatting options that are available
    in JSON. We''ve shown you an indent of four spaces because that seems to produce
    nice-looking JSON. As an alternative, we can make the output more compact by leaving
    the indent option. We can compact it even further by making the separators more
    terse. The following is the output created in `temp.json`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是将JSON表示作为文本与生成文件上的字节转换分开。JSON中有一些可用的格式选项。我们展示了缩进四个空格，因为这似乎产生了漂亮的JSON。作为替代，我们可以通过留下缩进选项使输出更紧凑。通过使分隔符更简洁，我们甚至可以使其更加紧凑。以下是在`temp.json`中创建的输出：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Dumping and loading with YAML
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用YAML进行转储和加载
- en: 'The [yaml.org](http://yaml.org) web page states that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[yaml.org](http://yaml.org)网页指出：'
- en: YAML™ (rhymes with "camel") is a human-friendly, cross language, Unicode-based
    data serialization language designed around the common native data types of agile
    programming languages.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: YAML™（与“骆驼”押韵）是一种人性化的、跨语言的、基于Unicode的数据序列化语言，旨在围绕敏捷编程语言的常见本机数据类型设计。
- en: 'The Python Standard Library documentation for the `json` module states that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块的Python标准库文档指出：'
- en: JSON is a subset of YAML 1.2\. The JSON produced by this module's default settings
    (in particular, the default separators value) is also a subset of YAML 1.0 and
    1.1\. This module can thus also be used as a YAML serializer.
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JSON是YAML 1.2的子集。此模块的默认设置（特别是默认分隔符值）生成的JSON也是YAML 1.0和1.1的子集。因此，该模块也可以用作YAML序列化器。
- en: 'Technically, then, we can prepare YAML data using the `json` module. However,
    the `json` module cannot be used to de-serialize more sophisticated YAML data.
    There are two benefits of YAML. First, it''s a more sophisticated notation, allowing
    us to encode additional details about our objects. Second, the PyYAML implementation
    has a deep level of integration with Python that allows us to very simply create
    YAML encodings of Python objects. The drawback of YAML is that it is not as widely
    used as JSON. We''ll need to download and install a YAML module. A good one can
    be found at [http://pyyaml.org/wiki/PyYAML](http://pyyaml.org/wiki/PyYAML). Once
    we''ve installed the package, we can dump our objects in the YAML notation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们可以使用`json`模块准备YAML数据。但是，`json`模块无法用于反序列化更复杂的YAML数据。YAML的两个好处。首先，它是一种更复杂的表示法，允许我们对我们的对象编码更多的细节。其次，PyYAML实现与Python有深度集成，使我们能够非常简单地创建Python对象的YAML编码。YAML的缺点是它没有像JSON那样被广泛使用。我们需要下载和安装一个YAML模块。可以在[http://pyyaml.org/wiki/PyYAML](http://pyyaml.org/wiki/PyYAML)找到一个好的模块。安装了包之后，我们可以以YAML表示法转储我们的对象：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here''s what the YAML encoding for our microblog looks like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们微博的YAML编码：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output is relatively terse but also delightfully complete. Also, we can
    easily edit the YAML file to make updates. The class names are encoded with a
    YAML `!!` tag. YAML contains 11 standard tags. The `yaml` module includes a dozen
    Python-specific tags, plus five *complex* Python tags.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出相对简洁，但也非常完整。此外，我们可以轻松编辑YAML文件以进行更新。类名使用YAML `!!`标记进行编码。YAML包含11个标准标记。`yaml`模块包括十几个特定于Python的标记，以及五个*复杂*的Python标记。
- en: The Python class names are qualified by the defining module. In our case, the
    module happened to be a simple script, so the class names are `__main__.Blog`
    and `__main__.Post`. If we had imported these from another module, the class names
    would reflect the module that defined the classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Python类名由定义模块限定。在我们的情况下，该模块碰巧是一个简单的脚本，因此类名是`__main__.Blog`和`__main__.Post`。如果我们从另一个模块导入这些类，类名将反映定义类的模块。
- en: 'Items in a list are shown in a block sequence form. Each item starts with a
    `-` sequence; the rest of the items are indented with two spaces. When `list`
    or `tuple` is small enough, it can flow onto a single line. If it gets longer,
    it will wrap onto multiple lines. To load Python objects from a YAML document,
    we can use the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的项目以块序列形式显示。每个项目以`-`序列开头；其余项目缩进两个空格。当`list`或`tuple`足够小，它可以流到一行。如果它变得更长，它将换行到多行。要从YAML文档加载Python对象，我们可以使用以下代码：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will use the tag information to locate the class definitions and provide
    the values found in the YAML document to the class constructors. Our microblog
    objects will be fully reconstructed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用标记信息来定位类定义，并将在YAML文档中找到的值提供给类构造函数。我们的微博对象将被完全重建。
- en: Formatting YAML data on a file
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文件上格式化YAML数据
- en: 'When we write YAML files, we generally do something like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写YAML文件时，我们通常会做这样的事情：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We open the file with the required encoding. We provide the file object to
    the `yaml.dump()` method; the output is written there. When we read YAML files,
    we will use a similar technique:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以所需的编码打开文件。我们将文件对象提供给`yaml.dump()`方法；输出将写入那里。当我们读取YAML文件时，我们将使用类似的技术：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The idea is to segregate the YAML representation as text from any conversion
    to bytes on the resulting file. We have several formatting options to create prettier
    YAML representation of our data. Some of the options are shown in the following
    table:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将YAML表示作为文本与结果文件上的字节转换分开的想法。我们有几种格式选项来创建更漂亮的YAML表示我们的数据。以下表格显示了一些选项：
- en: '| `explicit_start` | If `true`, writes a `---` marker before each object. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '`explicit_start` 如果为`true`，在每个对象之前写入一个`---`标记。'
- en: '| `explicit_end` | If `true`, writes a `...` marker after each object. We might
    use this or `explicit_start` if we''re dumping a sequence of YAML documents to
    a single file and need to know when one ends and the next begins. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '`explicit_end` 如果为`true`，在每个对象之后写入一个`...`标记。如果我们将一系列YAML文档转储到单个文件并且需要知道一个结束和下一个开始时，我们可能会使用这个或`explicit_start`。'
- en: '| `version` | Given a pair of integers (x,y), writes a `%YAML x.y` directive
    at the beginning. This should be `version=(1,2)`. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '`version` 给定一对整数(x,y)，在开头写入`%YAML x.y`指令。这应该是`version=(1,2)`。'
- en: '| `tags` | Given a mapping, it emits a YAML `%TAG` directive with different
    tag abbreviations. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '`tags` 给定一个映射，它会发出一个带有不同标记缩写的YAML `%TAG`指令。'
- en: '| `canonical` | If `true`, includes a tag on every piece of data. If false,
    a number of tags are assumed. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '`canonical` 如果为`true`，则在每个数据片段上包括一个标记。如果为false，则假定一些标记。'
- en: '| `indent` | If set to a number, changes the indentation used for blocks. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '`indent` 如果设置为一个数字，改变用于块的缩进。'
- en: '| `width` | If set to a number, changes the width at which long items are wrapped
    to multiple, indented lines. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '`width` 如果设置为一个数字，改变长项换行到多个缩进行的宽度。'
- en: '| `allow_unicode` | If set to `true`, permits full Unicode without escapes.
    Otherwise, characters outside the ASCII subset will have escapes applied. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '`allow_unicode` 如果设置为`true`，允许完全使用Unicode而无需转义。否则，ASCII子集之外的字符将被应用转义。'
- en: '| `line_break` | Uses a different line-ending character; the default is a newline.
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '`line_break` 使用不同的换行符；默认为换行符。'
- en: Of these options, `explicit_end` and `allow_unicode` are perhaps the most useful.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些选项中，`explicit_end`和`allow_unicode`可能是最有用的。
- en: Extending the YAML representation
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展YAML表示
- en: Sometimes, one of our classes has a tidy representation that is nicer than the
    default YAML dump of attribute values. For example, the default YAML for our Blackjack
    `Card` class definitions will include several derived values that we don't really
    need to preserve.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的类之一具有整洁的表示，比默认的YAML转储属性值更好。例如，我们的Blackjack `Card`类定义的默认YAML将包括一些我们不需要保留的派生值。
- en: 'The `yaml` module includes a provision for adding a **representer** and a **constructor**
    to a class definition. The representer is used to create a YAML representation,
    including a tag and value. The constructor is used to build a Python object from
    the given value. Here''s yet another `Card` class hierarchy:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`yaml`模块包括为类定义添加**representer**和**constructor**的规定。representer用于创建YAML表示，包括标记和值。构造函数用于从给定值构建Python对象。这是另一个`Card`类层次结构：'
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've used the superclass for number cards and defined two subclasses for aces
    and face cards. In previous examples, we made extensive use of a factory function
    to simplify the construction. The factory handled mapping from a rank of 1 to
    a class of `AceCar` and from ranks of 11, 12, and 13 to class of `FaceCard`. This
    was essential so that we could easily build a deck using a simple `range(1,14)`
    for the rank values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了数字卡的超类，并为A和面值卡定义了两个子类。在先前的示例中，我们广泛使用了工厂函数来简化构建。工厂处理了从1到`AceCar`类的等级的映射，以及从11、12和13等级到`FaceCard`类的映射。这是必不可少的，这样我们就可以轻松地使用简单的`range(1,14)`来构建一副牌。
- en: 'When loading from YAML, the class will be fully spelled out via the YAML `!!`
    tags. The only missing information would be the hard and soft values associated
    with each subclass of the card. The hard and soft points have three relatively
    simple cases that can be handled through optional initialization parameters. Here''s
    how it looks when we dump these objects into the YAML format using default serialization:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从YAML加载时，类将通过YAML`!!`标记完全拼写出来。唯一缺少的信息将是与卡片的每个子类关联的硬值和软值。硬点和软点有三种相对简单的情况，可以通过可选的初始化参数来处理。当我们将这些对象转储到YAML格式时，它看起来是这样的：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These are correct, but perhaps a bit wordy for something as simple as a playing
    card. We can extend the `yaml` module to produce smaller and more focused output
    for these simple objects. What we''ll do is define representers and constructors
    for our `Card` subclasses. Here are the three functions and registrations:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是正确的，但对于像扑克牌这样简单的东西来说可能有点啰嗦。我们可以扩展`yaml`模块，以便为这些简单对象生成更小、更专注的输出。我们将为`Card`子类定义表示和构造函数。以下是三个函数和注册：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We've represented each `Card` instance as a short string. YAML includes a tag
    to show which class should be built from the string. All three classes use the
    same format string. This happens to match the `__str__()` method, leading to a
    potential optimization.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将每个`Card`实例表示为一个简短的字符串。YAML包括一个标记，显示应从字符串构建哪个类。所有三个类使用相同的格式字符串。这恰好与`__str__()`方法匹配，从而导致潜在的优化。
- en: 'The other problem we need to solve is constructing `Card` instances from the
    parsed YAML document. For that, we need constructors. Here are three constructors
    and the registrations:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的另一个问题是从解析的YAML文档构造`Card`实例。为此，我们需要构造函数。以下是三个构造函数和注册：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As a scalar value is parsed, the tag will be used to locate a specific constructor.
    The constructor can then decompose the string and build the proper subclass of
    a `Card` instance. Here''s a quick demo that dumps one card of each class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析标量值时，标记将用于定位特定的构造函数。然后构造函数可以分解字符串并构建`Card`实例的适当子类。这是一个快速演示，演示了每个类的一张卡片：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This gives us short, elegant YAML representations of cards that can be used
    to reconstruct Python objects.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了可以用来重建Python对象的卡片的简短而优雅的YAML表示。
- en: 'We can rebuild our 3-card deck using the following simple statement:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下简单语句重新构建我们的3张牌组：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will parse the representation, use the constructor functions, and build
    the expected objects. Because the constructor function ensures that proper initialization
    gets done, the internal attributes for the hard and soft values are properly rebuilt.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解析表示，使用构造函数，并构建预期的对象。因为构造函数确保适当的初始化完成，硬值和软值的内部属性将被正确重建。
- en: Security and safe loading
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全和安全加载
- en: In principle, YAML can build objects of any type. This allows an attack on an
    application that transmits YAML files through the Internet without proper SSL
    controls in place.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，YAML可以构建任何类型的对象。这允许对通过互联网传输YAML文件的应用程序进行攻击，而不需要适当的SSL控制。
- en: The YAML module offers a `safe_load()` method that refuses to execute arbitrary
    Python code as part of building an object. This severely limits what can be loaded.
    For insecure data exchanges, we can use `yaml.safe_load()` to create Python `dict`
    and `list` objects that contain only built-in types. We can then build our application
    classes from the `dict` and `list` instances. This is vaguely similar to the way
    we use JSON or CSV to exchange `dict` that must be used to create a proper object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: YAML模块提供了一个`safe_load()`方法，拒绝执行任意Python代码作为构建对象的一部分。这严重限制了可以加载的内容。对于不安全的数据交换，我们可以使用`yaml.safe_load()`来创建仅包含内置类型的Python`dict`和`list`对象。然后我们可以从`dict`和`list`实例构建我们的应用程序类。这与我们使用JSON或CSV交换必须用于创建正确对象的`dict`的方式有些相似。
- en: 'A better approach is to use the `yaml.YAMLObject` mixin class for our own objects.
    We use this to set some class-level attributes that provide hints to `yaml` and
    ensure the safe construction of objects. Here''s how we define a superclass for
    safe transmission:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是为我们自己的对象使用`yaml.YAMLObject`混合类。我们使用这个类来设置一些类级别的属性，为`yaml`提供提示，并确保对象的安全构建。以下是我们如何定义用于安全传输的超类：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The two attributes will alert `yaml` that these objects can be safely loaded
    without executing arbitrary and unexpected Python code. Each subclass of `Card2`
    only has to set the unique YAML tag that will be used:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性将警告`yaml`，这些对象可以安全加载，而不会执行任意和意外的Python代码。`Card2`的每个子类只需设置将要使用的唯一YAML标记：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We've added an attribute that alerts `yaml` that these objects use only this
    class definition. The objects can be safely loaded; they don't execute arbitrary
    untrustworthy code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个属性，警告`yaml`，这些对象仅使用此类定义。这些对象可以安全加载；它们不执行任意不可信代码。
- en: With these modifications to the class definitions, we can now use `yaml.safe_load()`
    on the YAML stream without worrying about the document having malicious code inserted
    over an unsecured Internet connection. The explicit use of the `yaml.YAMLObject`
    mixin class for our own objects coupled with setting the `yaml_tag` attribute
    has several advantages. It leads to slightly more compact files. It also leads
    to a better-looking YAML files—the long, generic `!!python/object:__main__.AceCard`
    tags are replaced with shorter `!AceCard2` tags.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对类定义进行这些修改，我们现在可以在YAML流上使用`yaml.safe_load()`，而不必担心文档在不安全的互联网连接上插入恶意代码。对我们自己的对象使用`yaml.YAMLObject`混合类以及设置`yaml_tag`属性具有几个优点。它导致文件稍微更紧凑。它还导致更美观的YAML文件——长而通用的`!!python/object:__main__.AceCard`标记被更短的`!AceCard2`标记替换。
- en: Dumping and loading with pickle
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pickle进行转储和加载
- en: The `pickle` module is Python's native format to make objects persistent.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块是Python的本机格式，用于使对象持久化。'
- en: 'The Python Standard Library says this about `pickle`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库对`pickle`的描述如下：
- en: The pickle module can transform a complex object into a byte stream and it can
    transform the byte stream into an object with the same internal structure. Perhaps
    the most obvious thing to do with these byte streams is to write them onto a file,
    but it is also conceivable to send them across a network or store them in a database.
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pickle模块可以将复杂对象转换为字节流，并且可以将字节流转换为具有相同内部结构的对象。对这些字节流最明显的用途可能是将它们写入文件，但也可以想象将它们发送到网络或存储在数据库中。
- en: The focus of `pickle` is Python and only Python. This is not a data interchange
    format such as JSON, YAML, CSV, or XML that can be used with applications written
    in other languages.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`的重点是Python，仅限于Python。这不是诸如JSON、YAML、CSV或XML之类的数据交换格式，可以与其他语言编写的应用程序一起使用。'
- en: The `pickle` module is tightly integrated with Python in a variety of ways.
    For example, the `__reduce__()` and `__reduce_ex__()` methods of a class exist
    to support the `pickle` processing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块与Python紧密集成在各种方式。例如，类的`__reduce__()`和`__reduce_ex__()`方法存在以支持`pickle`处理。'
- en: 'We can easily pickle our microblog in the following manner:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将我们的微博pickle如下：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This exports the entire `travel` object to the given file. The file is written
    as raw bytes, so the `open()` function uses the `"wb"` mode.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个`travel`对象导出到给定文件。该文件以原始字节形式写入，因此`open()`函数使用`"wb"`模式。
- en: 'We can easily recover a picked object in the following manner:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式轻松恢复一个picked对象：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As pickled data is written as bytes, the file must be opened in the `"rb"` mode.
    The pickled objects will be correctly bound to the proper class definitions. The
    underlying stream of bytes is not intended for human consumption. It is readable
    after a fashion, but it is not designed for readability like YAML.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于pickled数据是以字节形式写入的，因此文件必须以`"rb"`模式打开。pickled对象将正确绑定到适当的类定义。底层的字节流不是为人类消费而设计的。它在某种程度上是可读的，但它不像YAML那样设计用于可读性。
- en: Designing a class for reliable pickle processing
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计一个可靠的pickle处理类
- en: The `__init__()` method of a class is not actually used to unpickle an object.
    The `__init__()` method is bypassed by using `__new__()` and setting the pickled
    values into the object's `__dict__` directly. This distinction matters when our
    class definition includes some processing in `__init__()`. For example, if `__init__()`
    opens external files, creates some part of a GUI interface, or performs some external
    update to a database, then this will not be performed during unpickling.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类的`__init__()`方法实际上并不用于取消封存对象。通过使用`__new__()`并将pickled值直接设置到对象的`__dict__`中，`__init__()`方法被绕过。当我们的类定义包括`__init__()`中的一些处理时，这一区别很重要。例如，如果`__init__()`打开外部文件，创建GUI界面的某个部分，或者对数据库执行某些外部更新，则在取消封存时不会执行这些操作。
- en: If we compute a new instance variable during the `__init__()` processing, there
    is no real problem. For example, consider a Blackjack `Hand` object that computes
    the total of the `Card` instances when the `Hand` is created. The ordinary `pickle`
    processing will preserve this computed instance variable. It won't be recomputed
    when the object is unpickled. The previously computed value will simply be unpickled.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`__init__()`处理期间计算一个新的实例变量，就没有真正的问题。例如，考虑一个Blackjack`Hand`对象，在创建`Hand`时计算`Card`实例的总数。普通的`pickle`处理将保留这个计算出的实例变量。在取消封存对象时，不会重新计算它。先前计算出的值将被简单地取消封存。
- en: 'A class that relies on processing during `__init__()` has to make special arrangements
    to be sure that this initial processing will happen properly. There are two things
    we can do:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于`__init__()`期间处理的类必须特别安排以确保此初始处理将正确进行。我们可以做两件事：
- en: Avoid eager startup processing in `__init__()`. Instead, do one-time initialization
    processing. For example, if there are external file operations, these must be
    deferred until required.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在`__init__()`中进行急切的启动处理。相反，进行一次性的初始化处理。例如，如果有外部文件操作，必须推迟到需要时才执行。
- en: Define the `__getstate__()` and `__setstate__()` methods that can be used by
    pickle to preserve the state and restore the state. The `__setstate__()` method
    can then invoke the same method that `__init__()` invokes to perform a one-time
    initialization processing in ordinary Python code.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`__getstate__()`和`__setstate__()`方法，这些方法可以被pickle用来保存状态和恢复状态。然后，`__setstate__()`方法可以调用与`__init__()`在普通Python代码中执行一次性初始化处理的相同方法。
- en: 'We''ll look at an example where the initial `Card` instances loaded into a
    `Hand` are logged for audit purposes by the `__init__()` method. Here''s a version
    of `Hand` that doesn''t work properly when unpickling:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个例子，其中由`__init__()`方法记录为审计目的加载到`Hand`中的初始`Card`实例。以下是在取消封存时无法正常工作的`Hand`版本：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This has two logging locations: during `__init__()` and `append()`. The `__init__()`
    processing doesn''t work consistently between initial object creation and unpickling
    to recreate an object. Here''s the logging setup to see this problem:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个记录位置：在`__init__()`和`append()`期间。`__init__()`处理在初始对象创建和取消封存以重新创建对象之间不能一致工作。以下是用于查看此问题的日志设置：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This setup creates the log and ensures that the logging level is appropriate
    for seeing the audit information. Here''s a quick script that builds, pickles,
    and unpickles `Hand`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置创建日志并确保日志级别适合查看审计信息。以下是一个快速脚本，用于构建、pickle和unpickle`Hand`：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When we execute this, we see that the log entries that are written during `__init__()`
    processing are not written when unpickling `Hand`. In order to properly write
    an audit log for unpickling, we could put lazy logging tests throughout this class.
    For example, we could extend `__getattribute__()` to write the initial log entries
    whenever any attribute is requested from this class. This leads to stateful logging
    and an `if` statement that is executed every time a hand object does something.
    A better solution is to tap into the way state is saved and recovered by `pickle`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个时，我们发现在处理`__init__()`时写入的日志条目在反拾取`Hand`时没有被写入。为了正确地为反拾取编写审计日志，我们可以在这个类中放置延迟日志测试。例如，我们可以扩展`__getattribute__()`以在从这个类请求任何属性时写入初始日志条目。这导致了有状态的日志记录和每次手对象执行操作时执行的`if`语句。一个更好的解决方案是利用`pickle`保存和恢复状态的方式。
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `__getstate__()` method is used while picking to gather the current state
    of the object. This method can return anything. In the case of objects that have
    internal memoization caches, for example, the cache might not be pickled in order
    to save time and space. This implementation uses the internal `__dict__` without
    any modification.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getstate__()` 方法在拾取时用于收集对象的当前状态。这个方法可以返回任何东西。例如，对于具有内部记忆缓存的对象，缓存可能不会被拾取以节省时间和空间。这个实现使用内部的`__dict__`而没有任何修改。'
- en: The `__setstate__()` method is used while unpickling to reset the value of the
    object. This version merges the state into the internal `__dict__` and then writes
    the appropriate logging entries.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`__setstate__()` 方法在反拾取时用于重置对象的值。这个版本将状态合并到内部的`__dict__`中，然后写入适当的日志条目。'
- en: Security and the global issue
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全和全局问题
- en: During unpickling, a global name in the pickle stream can lead to the evaluation
    of arbitrary code. Generally, the global names are class names or a function name.
    However, it's possible to include a global name that is a function in a module
    such as `os` or `subprocess`. This allows an attack on an application that attempts
    to transmit pickled objects through the Internet without strong SSL controls in
    place. This is no concern for completely local files.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在反拾取期间，pickle流中的全局名称可能导致任意代码的评估。一般来说，全局名称是类名或函数名。然而，可能包括一个函数名是`os`或`subprocess`等模块中的全局名称。这允许对试图通过互联网传输拾取对象的应用程序进行攻击，而没有强大的SSL控制。这对于完全本地文件来说并不是问题。
- en: 'In order to prevent the execution of arbitrary code, we must extend the `pickle.Unpickler`
    class. We''ll override the `find_class()` method to replace it with something
    more secure. We have to account for several unpickling issues, such as the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止执行任意代码，我们必须扩展`pickle.Unpickler`类。我们将覆盖`find_class()`方法以替换为更安全的内容。我们必须考虑几个反拾取问题，例如：
- en: We have to prevent the use of the built-in `exec()` and `eval()` functions.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须防止使用内置的`exec()`和`eval()`函数。
- en: We have to prevent the use of modules and packages that might be considered
    unsafe. For example, `sys` and `os` should be prohibited.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须防止使用可能被认为是不安全的模块和包。例如，应该禁止使用`sys`和`os`。
- en: We have to permit the use of our application modules.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须允许使用我们的应用程序模块。
- en: 'Here''s an example that imposes some restrictions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个施加一些限制的示例：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This version of the `Unpickler` class will help us avoid a large number of potential
    problems that could stem from a pickle stream that was doctored. It permits the
    use of any built-in function except `exec()` and `eval()`. It permits the use
    of classes defined only in `__main__`. In all other cases, it raises an exception.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Unpickler`类的版本将帮助我们避免由篡改的pickle流可能引起的大量潜在问题。它允许使用除了`exec()`和`eval()`之外的任何内置函数。它允许仅在`__main__`中定义的类的使用。在所有其他情况下，它会引发异常。
- en: Dumping and loading with CSV
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CSV进行转储和加载
- en: The `csv` module encodes and decodes simple `list` or `dict` instances into
    the CSV notation. As with the `json` module, discussed previously, this is not
    a very complete persistence solution. The wide adoption of CSV files, however,
    means that it often becomes necessary to convert between Python objects and CSV.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv`模块将简单的`list`或`dict`实例编码和解码为CSV符号。与之前讨论的`json`模块一样，这并不是一个非常完整的持久性解决方案。然而，由于CSV文件的广泛采用，通常需要在Python对象和CSV之间进行转换。'
- en: Working with CSV files involves a manual mapping between our objects and CSV
    structures. We need to design the mapping carefully, remaining cognizant of the
    limitations of the CSV notation. This can be difficult because of the mismatch
    between the expressive powers of objects and the tabular structure of a CSV file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 处理CSV文件涉及我们的对象和CSV结构之间的手动映射。我们需要仔细设计映射，注意CSV符号的限制。这可能很困难，因为对象的表达能力与CSV文件的表格结构之间存在不匹配。
- en: The content of each column of a CSV file is—by definition—pure text. When loading
    data from a CSV file, we'll need to convert these values to more useful types
    inside our applications. This conversion can be complicated by the way spreadsheets
    perform unexpected type coercion. We might, for example, have a spreadsheet where
    US ZIP codes have been changed into floating-point numbers by the spreadsheet
    application. When the spreadsheet saves to CSV, the ZIP codes could become odd-looking
    numeric values.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件的每一列的内容—根据定义—都是纯文本。从CSV文件加载数据时，我们需要将这些值转换为更有用的类型。这种转换可能会受到电子表格执行意外类型强制转换的影响。例如，我们可能有一个电子表格，其中美国邮政编码已被电子表格应用程序更改为浮点数。当电子表格保存为CSV时，邮政编码可能会变成看起来奇怪的数值。
- en: Consequently, we might need to use a conversion such as `('00000'+row['zip'])[-5:]`
    to restore the leading zeroes. Another scenario is having to use something such
    as `"{0:05.0f}".format(float(row['zip']))` to restore the leading zeroes. Also,
    don't forget that a file might have a mixture of ZIP and ZIP+4 postal codes, making
    this even more challenging.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能需要使用转换，比如`('00000'+row['zip'])[-5:]`来恢复前导零。另一种情况是必须使用类似`"{0:05.0f}".format(float(row['zip']))`来恢复前导零。另外，不要忘记文件可能包含ZIP和ZIP+4邮政编码的混合，这使得这个过程更具挑战性。
- en: To further complicate working with CSV files, we have to be aware that they're
    often touched manually and are often subtly incompatible because of human tweaks.
    It's important for software to be flexible in the face of real-world irregularities
    that arise.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更复杂地处理CSV文件，我们必须意识到它们经常被手动操作，并且由于人为调整，它们经常不兼容。软件在面对现实世界中出现的不规则性时保持灵活是很重要的。
- en: When we have relatively simple class definitions, we can often transform each
    instance into a simple, flat row of data values. Often, `namedtuple` is a good
    match between a CSV source file and Python objects. Going the other way, we might
    need to design our Python classes around `namedtuples` if our application will
    save data in the CSV notation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有相对简单的类定义时，我们通常可以将每个实例转换为简单的扁平数据值行。通常情况下，`namedtuple`是CSV源文件和Python对象之间的良好匹配。反过来，如果我们的应用程序将数据保存在CSV符号中，我们可能需要围绕`namedtuples`设计我们的Python类。
- en: When we have classes that are containers, we often have a difficult time determining
    how to represent structured containers in flat CSV rows. This is an **impedance
    mismatch** between object models and flat normalized tabular structure used for
    CSV files or relational databases. There's no good solution for the impedance
    mismatch; it requires careful design. We'll start with simple, flat objects to
    show you some CSV mappings.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有容器类时，通常很难确定如何在扁平的CSV行中表示结构化容器。这是对象模型和用于CSV文件或关系数据库的扁平规范化表结构之间的**阻抗不匹配**。阻抗不匹配没有好的解决方案；它需要仔细设计。我们将从简单的扁平对象开始，向您展示一些CSV映射。
- en: Dumping simple sequences to CSV
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将简单序列转储到CSV
- en: 'An ideal mapping is between the `namedtuple` instances and rows in a CSV file.
    Each row represents a different `namedtuple`. Consider the following Python class:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的映射是`namedtuple`实例和CSV文件中的行之间的映射。每一行代表一个不同的`namedtuple`。考虑以下Python类：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''ve defined the objects to be a simple, flat sequence of attributes. The
    database architects call this **First Normal Form**. There are no repeating groups
    and each item is an atomic piece of data. We might produce these objects from
    a simulation that looks like the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了对象为简单的扁平属性序列。数据库架构师称之为**第一范式**。没有重复的组，每个项目都是原子数据。我们可能会从一个看起来像以下代码的模拟中产生这些对象：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This iterator will create Blackjack simulations with a given player and betting
    strategy. It will execute the game until the player is broke or has sat at the
    table for 100 individual rounds of play. At the end of each session, it will yield
    a `GameStat` object with the player strategy, betting strategy, the number of
    rounds, and the final stake. This will allow us to compute statistics for each
    play or betting strategy or combination. Here''s how we can write this to a file
    for later analysis:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代器将创建具有给定玩家和投注策略的二十一点模拟。它将执行游戏，直到玩家破产或者在100个独立的游戏回合中坐在桌子旁。在每个会话结束时，它将产生一个带有玩家策略、投注策略、回合数和最终赌注的`GameStat`对象。这将允许我们为每个玩法或投注策略或组合计算统计数据。以下是我们如何将其写入文件以供以后分析：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are three steps to create a CSV writer:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CSV写入器有三个步骤：
- en: Open a file with the newline option set to `""`. This will support the (possibly)
    nonstandard line ending for CSV files.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个带有newline选项设置为`""`的文件。这将支持CSV文件的（可能）非标准行结束。
- en: Create a CSV `writer` object. In this example, we created the `DictWriter` instance
    because it allows us to easily create rows from dictionary objects.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建CSV `writer`对象。在这个例子中，我们创建了`DictWriter`实例，因为它允许我们轻松地从字典对象创建行。
- en: Put a header in the first line of the file. This makes data exchange slightly
    simpler by providing some hint as to what's in the CSV file.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的第一行放一个标题。这样做可以通过提供一些关于CSV文件中内容的提示，使数据交换稍微简单一些。
- en: 'Once `writer` object has been prepared, we can use the writer''s `writerow()`
    method to write each dictionary to the CSV file. We can, to an extent, simplify
    this slightly by using the `writerows()` method. This method expects an iterator
    instead of an individual row. Here''s how we can use `writerows()` with an iterator:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`writer`对象准备好了，我们可以使用writer的`writerow()`方法将每个字典写入CSV文件。我们可以在一定程度上通过使用`writerows()`方法稍微简化这个过程。这个方法期望一个迭代器而不是一个单独的行。以下是我们如何使用`writerows()`与一个迭代器：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We've assigned the iterator to a variable, `data`. For the `writerows()` method,
    we get a dictionary from each row produced by the iterator.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将迭代器分配给一个变量`data`。对于`writerows()`方法，我们从迭代器产生的每一行得到一个字典。
- en: Loading simple sequences from CSV
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从CSV加载简单序列
- en: 'We can load simple sequential objects from a CSV file with a loop that looks
    like the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似以下代码的循环从CSV文件中加载简单的顺序对象：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We've defined a `reader` object for our file. As we know that our file has a
    proper heading, we can use `DictReader`. This will use the first row to define
    the attribute names. We can now construct the `GameStat` objects from the rows
    in the CSV file. We've used a generator expression to build rows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为文件定义了一个`reader`对象。由于我们知道文件有一个适当的标题，我们可以使用`DictReader`。这将使用第一行来定义属性名称。现在我们可以从CSV文件中的行构造`GameStat`对象。我们使用了一个生成器表达式来构建行。
- en: 'In this case, we''ve assumed that the column names match the attribute names
    of our `GameStat` class definition. We can, if necessary, confirm that the file
    matches the expected format by comparing `reader.fieldnames` with `GameStat._fields`.
    As the order doesn''t have to match, we need to transform each list of field names
    into a set. Here''s how we can check the column names:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们假设列名与我们的“GameStat”类定义的属性名匹配。如果必要，我们可以通过比较“reader.fieldnames”和“GameStat._fields”来确认文件是否与预期格式匹配。由于顺序不必匹配，我们需要将每个字段名称列表转换为集合。以下是我们如何检查列名：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''ve ignored the data types of the values that were read from the file. The
    two numeric columns will wind up being string values when we read from the CSV
    file. Because of this, we need a more sophisticated row-by-row transformation
    to create proper data values. Here''s a typical factory function that performs
    the required conversions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了从文件中读取的值的数据类型。当我们从CSV文件中读取时，两个数值列将最终成为字符串值。因此，我们需要进行更复杂的逐行转换，以创建正确的数据值。以下是执行所需转换的典型工厂函数：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''ve applied the `int` function to the columns that are supposed to have
    numeric values. In the rare event where the file has the proper headers but improper
    data, we''ll get an ordinary `ValueError` from a failed `int()` function. We can
    use this generator function as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将“int”函数应用于应该具有数值的列。在文件具有正确的标题但数据不正确的罕见情况下，我们将从失败的“int（）”函数中获得普通的“ValueError”。我们可以使用这个生成器函数如下：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This version of the reader has properly reconstructed the `GameStat` objects
    by performing conversions on the numeric values.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的读取器通过对数值进行转换，正确重建了“GameStat”对象。
- en: Handling containers and complex classes
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理容器和复杂类
- en: 'When we look back at our microblog example, we have a `Blog` object that contains
    many `Post` instances. We designed `Blog` as a wrapper around `list`, so that
    the `Blog` would contain a collection. When working with a CSV representation,
    we have to design a mapping from a complex structure to a tabular representation.
    We have three common solutions:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾我们的微博示例时，我们有一个包含许多“Post”实例的“Blog”对象。我们设计“Blog”作为“list”的包装器，以便“Blog”包含一个集合。在处理CSV表示时，我们必须设计从复杂结构到表格表示的映射。我们有三种常见的解决方案：
- en: 'We can create two files: a blog file and a posting file. The blog file has
    only the `Blog` instances. Each `Blog` has a title in our example. Each `Post`
    row can then have a reference to the `Blog` row to which the posting belongs.
    We need to add a key for each `Blog`. Each `Post` would then have a foreign key
    reference to the `Blog` key.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建两个文件：一个博客文件和一个帖子文件。博客文件只包含“Blog”实例。在我们的示例中，每个“Blog”都有一个标题。然后，每个“Post”行可以引用帖子所属的“Blog”行。我们需要为每个“Blog”添加一个键。然后，每个“Post”将具有对“Blog”键的外键引用。
- en: We can create two kinds of rows in a single file. We will have the `Blog` rows
    and `Post` rows. Our writers entangle the various types of data; our readers must
    disentangle the types of data.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在单个文件中创建两种类型的行。我们将有“Blog”行和“Post”行。我们的写入器纠缠了各种类型的数据；我们的读取器必须解开数据类型。
- en: We can perform a relational database join between the various kinds of rows,
    repeating the `Blog` parent information on each `Post` child.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在各种行之间执行关系数据库连接，重复在每个“Post”子行上的“Blog”父信息。
- en: There's no *best* solution among these choices. We have to design a solution
    to the impedance mismatch between flat CSV rows and more structured Python objects.
    The use cases for the data will define some of the advantages and disadvantages.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些选择中没有*最佳*解决方案。我们必须设计一个解决扁平CSV行和更结构化的Python对象之间的阻抗不匹配的解决方案。数据的用例将定义一些优点和缺点。
- en: Creating two files requires that we create some kind of unique identifier for
    each `Blog` so that a `Post` can properly refer to the `Blog`. We can't easily
    use the Python internal ID, as these are not guaranteed to be consistent each
    time Python runs.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个文件需要我们为每个“Blog”创建某种唯一标识符，以便“Post”可以正确地引用“Blog”。我们不能轻易使用Python内部ID，因为这些ID不能保证在每次Python运行时保持一致。
- en: A common assumption is that the `Blog` title is a unique key; as this is an
    attribute of `Blog`, it is called a natural primary key. This rarely works out
    well; we cannot change a `Blog` title without also updating all of the `Posts`
    that refer to the `Blog`. A better plan is to invent a unique identifier and update
    the class design to include that identifier. This is called a **surrogate key**.
    The Python `uuid` module can provide unique identifiers for this purpose.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的假设是“Blog”标题是一个唯一的键；由于这是“Blog”的属性，它被称为自然主键。这很少能奏效；我们不能更改“Blog”标题而不更新所有引用“Blog”的“Posts”。一个更好的计划是发明一个唯一标识符，并更新类设计以包括该标识符。这被称为**代理键**。Python的“uuid”模块可以为此目的提供唯一标识符。
- en: The code to use multiple files is nearly identical to the previous examples.
    The only change is to add a proper primary key to the `Blog` class. Once we have
    the keys defined, we can create writers and readers as shown previously to process
    the `Blog` and `Post` instances into their separate files.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个文件的代码几乎与先前的示例相同。唯一的变化是为“Blog”类添加适当的主键。一旦定义了键，我们就可以像以前一样创建写入器和读取器来处理“Blog”和“Post”实例到它们各自的文件中。
- en: Dumping and loading multiple row types in a CSV file
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在CSV文件中转储和加载多种行类型
- en: Creating multiple kinds of rows in a single file makes the format a bit more
    complex. The column titles must become a union of all the available column titles.
    Because of the possibility of name clashes between the various row types, we can
    either access rows by position—preventing us from simply using `csv.DictReader`—or
    we must invent a more sophisticated column title that combines class and attribute
    names.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个文件中创建多种类型的行使格式变得更加复杂。列标题必须成为所有可用列标题的并集。由于各种行类型之间可能存在名称冲突的可能性，我们可以通过位置访问行，防止我们简单地使用“csv.DictReader”，或者我们必须发明一个更复杂的列标题，结合类和属性名称。
- en: 'The process is simpler if we provide each row with an extra column that acts
    as a class discriminator. This extra column shows us what type of object the row
    represents. The object''s class name would work out well for this. Here''s how
    we might write blogs and posts to a single CSV file using two different row formats:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为每一行提供一个额外的列作为类别鉴别器，那么这个过程就会更简单。这个额外的列告诉我们行代表的是什么类型的对象。对象的类名会很好地起作用。以下是我们可能使用两种不同的行格式将博客和帖子写入单个CSV文件的方法：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We created two varieties of rows in the file. Some rows have `'Blog'` in the
    first column and contain just the attributes of a `Blog` object. Other rows have
    `'Post'` in the first column and contain just the attributes of a `Post` object.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文件中创建了两种行的变体。一些行在第一列中有`'Blog'`，只包含`Blog`对象的属性。其他行在第一列中有`'Post'`，只包含`Post`对象的属性。
- en: We did not make the titles unique, so we can't use a dictionary reader. When
    allocating columns by position like this, each row allocates unused columns based
    on the other types of rows with which it must coexist. These additional columns
    are filled with `None`. As the number of distinct row types grows, keeping track
    of the various positional column assignments can become challenging.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使标题唯一，因此无法使用字典读取器。像这样按位置分配列时，每行都会根据它必须共存的其他类型的行来分配未使用的列。这些额外的列填充为`None`。随着不同行类型的数量增加，跟踪各个位置列的分配可能变得具有挑战性。
- en: 'Also, the individual data type conversions can be somewhat baffling. In particular,
    we''ve ignored the data type of the timestamp and tags. We can try to reassemble
    our `Blogs` and `Posts` by examining the row discriminators:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单独的数据类型转换可能有些令人困惑。特别是，我们忽略了时间戳和标签的数据类型。我们可以尝试通过检查行鉴别器来重新组装我们的`Blogs`和`Posts`：
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This snippet will construct a list of `Blog` objects. Each `'Blog'` row uses
    columns in `slice(1,2)` to define the `Blog` object. Each `'Post'` row uses columns
    in `slice(2,6)` to define a `Post` object. This requires that each `Blog` be followed
    by the relevant `Post` instances. A foreign key is not used to tie the two objects
    together.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将构建一个`Blog`对象列表。每个`'Blog'`行使用`slice(1,2)`中的列来定义`Blog`对象。每个`'Post'`行使用`slice(2,6)`中的列来定义`Post`对象。这要求每个`Blog`后面都跟着相关的`Post`实例。外键不用于将这两个对象联系在一起。
- en: We've used two assumptions about the columns in the CSV file that has the same
    order and type as the parameters of the class constructors. For `Blog` objects,
    we used `blog= Blog( *r[1:2] )` because the one-and-only column is text, which
    matches the class constructor. When working with externally supplied data, this
    assumption might prove to be invalid.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对CSV文件中的列做了两个假设，即它们的顺序和类型与类构造函数的参数相同。对于`Blog`对象，我们使用了`blog= Blog( *r[1:2]
    )`，因为唯一的列是文本，这与类构造函数匹配。在处理外部提供的数据时，这个假设可能是无效的。
- en: 'To build the `Post` instances, we''ve used a separate function to map from
    columns to class constructor. Here''s the mapping function:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建`Post`实例，我们使用了一个单独的函数来从列映射到类构造函数。以下是映射函数：
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will properly build a `Post` instance from a row of text. It converts the
    text for `datetime` and the text for the tags to their proper Python types. This
    has the advantage of making the mapping explicit.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从文本行正确构建一个`Post`实例。它将`datetime`的文本和标签的文本转换为它们正确的Python类型。这有一个使映射明确的优点。
- en: 'In this example, we''re using `ast.literal_eval()` to decode more complex Python
    literal values. This allows the CSV data to include a tuple of string values:
    `"(''#RedRanger'', ''#Whitby42'', ''#ICW'')"`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`ast.literal_eval()`来解码更复杂的Python文字值。这允许CSV数据包括一个字符串值的元组："('#RedRanger',
    '#Whitby42', '#ICW')"。
- en: Filtering CSV rows with an iterator
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用迭代器过滤CSV行
- en: 'We can refactor the previous load example to iterate through the `Blog` objects
    rather than constructing a list of the `Blog` objects. This allows us to skim
    through a large CSV file and locate just the relevant `Blog` and `Post` rows.
    This function is a generator that yields each individual `Blog` instance separately:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构先前的加载示例，通过迭代`Blog`对象而不是构建`Blog`对象的列表。这使我们能够浏览大型CSV文件并定位只有相关的`Blog`和`Post`行。这个函数是一个生成器，分别产生每个单独的`Blog`实例：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This `blog_iter()` function creates the `Blog` object and appends the `Post`
    objects. Each time a `Blog` header appears, the previous `Blog` is complete and
    can be yielded. At the end, the final `Blog` object must also be yielded. If we
    want the large list of `Blog` instances, we can use the following code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`blog_iter()`函数创建`Blog`对象并附加`Post`对象。每当出现一个`Blog`标题时，前一个`Blog`就完成了并且可以被产出。最后，最终的`Blog`对象也必须被产出。如果我们想要大量的`Blog`实例列表，我们可以使用以下代码：
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will use the iterator to build a list of `Blogs` in the rare cases that
    we actually want the entire sequence in memory. We can use the following to process
    each `Blog` individually, rendering it to create RST files:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用迭代器在极少数情况下构建一个`Blogs`列表，实际上我们确实希望整个序列保存在内存中。我们可以使用以下方法逐个处理每个`Blog`，将其呈现为创建RST文件：
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We used the `blog_iter()` function to read each blog. After being read, it can
    be rendered to an RST-format file. A separate process can run `rst2html.py` to
    convert each blog to HTML.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`blog_iter()`函数来读取每个博客。读取后，它可以呈现为一个RST格式文件。一个单独的进程可以运行`rst2html.py`将每个博客转换为HTML。
- en: We can easily add a filter to process only selected `Blog` instances. Rather
    than simply rendering all the `Blog` instances, we can add an `if` statement to
    decide which `Blogs` should be rendered.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加一个过滤器来处理只选择的`Blog`实例。我们可以添加一个`if`语句来决定应该呈现哪些`Blogs`，而不仅仅是呈现所有的`Blog`实例。
- en: Dumping and loading joined rows in a CSV file
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在CSV文件中转储和加载连接的行
- en: Joining the objects together means that each row is a child object, joined with
    all of the parent objects that child. This leads to repetition of the parent object's
    attributes for each child object. When there are multiple levels of containers,
    this can lead to large amounts of repeated data.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象连接在一起意味着每一行都是一个子对象，与所有父对象连接在一起。这会导致每个子对象重复父对象的属性。当存在多层容器时，这可能导致大量重复的数据。
- en: The advantage of this repetition is that each row stands alone and doesn't belong
    to a context defined by the rows above it. We don't need a class discriminator
    as parent values are repeated for each child object.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重复的优势在于每行都是独立的，不属于由其上面的行定义的上下文。我们不需要类鉴别器，因为父值为每个子对象重复。
- en: This works well for data that forms a simple hierarchy; each child has some
    parent attributes added to it. When the data involves more complex relationships,
    the simplistic parent-child pattern breaks down. In these examples, we've lumped
    the `Post` tags into a single column of text. If we tried to break the tags into
    separate columns, they would become children of each `Post`, meaning that the
    text of `Post` might be repeated for each tag. Clearly, this isn't a good idea!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于形成简单层次结构的数据效果很好；每个子对象都添加了一些父属性。当数据涉及更复杂的关系时，简单的父子模式就会崩溃。在这些例子中，我们将`Post`标签合并到一个文本列中。如果我们尝试将标签分成单独的列，它们将成为每个`Post`的子对象，这意味着`Post`的文本可能会重复出现。显然，这不是一个好主意！
- en: 'The column titles must become a union of all the available column titles. Because
    of the possibility of name clashes between the various row types, we''ll qualify
    each column name with the class name. This will lead to column titles such as
    `''Blog.title''` and `''Post.title''`, which prevents name clashes. This allows
    for the use of `DictReader` and `DictWriter` rather than the positional assignment
    of the columns. However, these qualified names don''t trivially match the attribute
    names of the class definitions; this leads to somewhat more text processing to
    parse the column titles. Here''s how we can write a joined row that contains parent
    as well as child attributes:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列标题必须成为所有可用列标题的并集。由于各种行类型之间可能存在名称冲突的可能性，我们将用类名限定每个列名。这将导致列标题，如`'Blog.title'`和`'Post.title'`，从而避免名称冲突。这允许使用`DictReader`和`DictWriter`而不是列的位置赋值。然而，这些有资格的名称并不会简单地匹配类定义的属性名称；这会导致更多的文本处理来解析列标题。以下是我们如何编写一个包含父属性和子属性的联合行：
- en: '[PRE56]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We saw qualified column titles. In this format, each row now contains a union
    of the `Blog` attribute and the `Post` attributes. This is somewhat easier to
    prepare, as there''s no need to fill unused columns with `None`. As each column
    name is unique, we could easily switch to a `DictWriter` too. Here''s a way to
    reconstruct the original container from the CSV rows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了有资格的列标题。在这种格式中，每一行现在包含了`Blog`属性和`Post`属性的并集。这样更容易准备，因为不需要用`None`填充未使用的列。由于每个列名都是唯一的，我们也可以很容易地切换到`DictWriter`。以下是从CSV行重构原始容器的方法：
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first row of data is used to build a `Blog` instance and the first `Post`
    in that `Blog`. The invariant condition for the loop that follows assumes that
    there''s a proper `Blog` object. Having a valid `Blog` instance makes the processing
    logic much simpler. The `Post` instances are built with the following function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行数据用于构建`Blog`实例和该`Blog`中的第一个`Post`。随后的循环不变条件假设存在一个合适的`Blog`对象。拥有一个有效的`Blog`实例使得处理逻辑变得简单得多。`Post`实例是用以下函数构建的：
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We mapped the individual columns in each row through a conversion to the parameters
    of the class constructor. This makes all of the conversions explicit. It properly
    handles all of the type conversions from the CSV text to Python objects.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将每行中的单独列映射到类构造函数的参数来映射。这使得所有的转换都是显式的。它正确处理了从CSV文本到Python对象的所有类型转换。
- en: 'We might want to refactor the `Blog` builder to a separate function. However,
    it''s so small that adherence to the DRY principle seems a bit fussy. Because
    the column titles match the parameter names, we might try to use something like
    the following code to build each object:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要将`Blog`构建器重构为一个单独的函数。但是，它非常小，遵循DRY原则似乎有点麻烦。因为列标题与参数名称匹配，我们可以尝试使用以下代码构建每个对象：
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We used two generator expressions here. The first generator expression splits
    the column names into the class and attribute and builds a 3-tuple with the full
    key, the class name, and the attribute name. The second generator expression filters
    the class for the desired target class; it builds a sequence of 2-tuples with
    the attribute and value pairs that can be used to build a dictionary.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了两个生成器表达式。第一个生成器表达式将列名拆分为类和属性，并构建一个包含完整键、类名和属性名的3元组。第二个生成器表达式过滤了所需目标类的类；它构建了一个包含属性和值对的2元组序列，可以用来构建字典。
- en: This doesn't handle the data conversion for `Posts`. The individual column mappings
    simply don't generalize well. Adding lots of processing logic to this isn't very
    helpful when we compare it to the `post_builder5()` function.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不处理`Posts`的数据转换。单个列映射并不通用。当与`post_builder5()`函数相比时，向此添加大量处理逻辑并不是很有帮助。
- en: In the unlikely event that we have an empty file—one with a header row but zero
    `Blog` entries—the initial `row=next(rdr)` function will raise a `StopIteration`
    exception. As this generator function doesn't handle the exception, it will propagate
    to the loop that evaluated `blog_iter2()`; this loop will be terminated properly.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个空文件，即有标题行但没有`Blog`条目的文件，初始的`row=next(rdr)`函数将引发`StopIteration`异常。由于这个生成器函数没有处理异常，它将传播到评估`blog_iter2()`的循环；这个循环将被正确终止。
- en: Dumping and loading with XML
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XML进行转储和加载
- en: Python's `xml` package includes numerous modules that parse XML files. There
    is also a **Document Object Model** (**DOM**) implementation that can produce
    an XML document. As with the previous `json` module, this is not a very complete
    persistence solution for Python objects. Because of the wide adoption of the XML
    files, however, it often becomes necessary to convert between Python objects and
    XML documents.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`xml`包包括许多解析XML文件的模块。还有一个**文档对象模型**（**DOM**）实现，可以生成XML文档。与之前的`json`模块一样，这对于Python对象来说并不是一个非常完整的持久性解决方案。然而，由于广泛采用XML文件，通常需要在Python对象和XML文档之间进行转换。
- en: Working with XML files involves a manual mapping between our objects and XML
    structures. We need to design the mapping carefully, remaining cognizant of the
    constraints of XML's notation. This can be difficult because of the mismatch between
    the expressive powers of objects and the strictly hierarchical nature of an XML
    document.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 处理XML文件涉及我们的对象和XML结构之间的手动映射。我们需要仔细设计映射，同时要意识到XML符号的约束。这可能很困难，因为对象的表达能力与XML文档的严格分层性质之间存在不匹配。
- en: The content of an XML attribute or tag is pure text. When loading an XML document,
    we'll need to convert these values to more useful types inside our applications.
    In some cases, the XML document might include attributes or tags to indicate the
    expected type.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: XML属性或标记的内容是纯文本。在加载XML文档时，我们需要将这些值转换为我们应用程序内部更有用的类型。在某些情况下，XML文档可能包括属性或标记以指示预期的类型。
- en: If we are willing to put up with some limitations, we can use the `plistlib`
    module to emit some built-in Python structures as XML documents. We'll examine
    this module in [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, where we'll use it to load the configuration
    files.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意忍受一些限制，我们可以使用`plistlib`模块将一些内置的Python结构发出为XML文档。我们将在[第13章](ch13.html "第13章。配置文件和持久性")中详细介绍这个模块，*配置文件和持久性*，在那里我们将使用它来加载配置文件。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `json` module offers ways to extend the JSON encoding to include our customized
    classes; the `plistlib` module doesn't offer this additional hook.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块提供了将JSON编码扩展到包括我们自定义类的方法；`plistlib`模块没有提供此额外的钩子。'
- en: 'When we look at dumping a Python object to create an XML document, there are
    three common ways to build the text:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑将Python对象转储为XML文档时，有三种常见的构建文本的方法：
- en: Include XML output methods in our class design. In this case, our classes emit
    strings that can be assembled into an XML document.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的类设计中包含XML输出方法。在这种情况下，我们的类发出可以组装成XML文档的字符串。
- en: Use `xml.etree.ElementTree` to build the `ElementTree` nodes and return this
    structure. This can be rendered as text.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`xml.etree.ElementTree`构建`ElementTree`节点并返回此结构。这可以呈现为文本。
- en: Use an external template and fill attributes into that template. Unless we have
    a sophisticated template tool, this doesn't work out well. The `string.Template`
    class in the standard library is only suitable for very simple objects.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部模板并将属性填充到该模板中。除非我们有一个复杂的模板工具，否则这样做效果不佳。标准库中的`string.Template`类仅适用于非常简单的对象。
- en: There are some examples of generic Python XML serializers. The problem with
    trying to create a generic serializer is that XML is extremely flexible; each
    application of XML seems to have unique **XML Schema Definition** (**XSD**) or
    **Document Type Definition** (**DTD**) requirements.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些通用的Python XML序列化器示例。尝试创建通用序列化器的问题在于XML非常灵活；每个XML应用似乎都有独特的**XML模式定义**（**XSD**）或**文档类型定义**（**DTD**）要求。
- en: 'One open design question is how to encode an atomic value. There are a large
    number of choices. We could use a type-specific tag with an attribute name in
    the tag''s attributes: `<int name="the_answer">42</int>`. Another possibility
    is to use an attribute-specific tag with the type in the tag''s attributes: `<the_answer
    type="int">42</the_answer>`. We can also use nested tags: `<the_answer><int>42</int></the_answer>`.
    Or, we could rely on a separate schema definition to suggest that `the_answer`
    should be an integer and merely encode the value as text: `<the_answer>42</the_answer>`.
    We can also use adjacent tags: `<key>the_answer</key><int>42</int>`. This is not
    an exhaustive list; XML offers us a lot of choices.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开放的设计问题是如何编码原子值。有很多选择。我们可以在标记的属性中使用特定类型的标记：`<int name="the_answer">42</int>`。另一种可能性是在标记的属性中使用特定类型的标记：`<the_answer
    type="int">42</the_answer>`。我们还可以使用嵌套标记：`<the_answer><int>42</int></the_answer>`。或者，我们可以依赖于单独的模式定义，建议`the_answer`应该是一个整数，并仅将值编码为文本：`<the_answer>42</the_answer>`。我们还可以使用相邻的标记：`<key>the_answer</key><int>42</int>`。这并不是一个详尽的列表；XML为我们提供了很多选择。
- en: When it comes to recovering Python objects from an XML document, we are constrained
    by the APIs of our parsers. Generally, we have to parse the document and then
    examine the XML tag structure, assembling Python objects from the available data.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当从XML文档中恢复Python对象时，我们受到解析器API的限制。通常，我们必须解析文档，然后检查XML标记结构，从可用数据中组装Python对象。
- en: 'Some Web frameworks, such as Django, include XML serialization of Django-defined
    classes. This isn''t general serialization of arbitrary Python objects. The serialization
    is narrowly defined by Django''s data modeling components. Additionally, there
    are packages such as `dexml`, `lxml`, and `pyxser` as alternative bindings between
    Python objects and XML. See [http://pythonhosted.org/dexml/api/dexml.html](http://pythonhosted.org/dexml/api/dexml.html),
    [http://lxml.de](http://lxml.de), and [http://coder.cl/products/pyxser/](http://coder.cl/products/pyxser/).
    Here''s a longer list of candidate packages: [https://wiki.python.org/moin/PythonXml](https://wiki.python.org/moin/PythonXml).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Web框架，如Django，包括Django定义类的XML序列化。这不是任意Python对象的通用序列化。序列化由Django的数据建模组件严格定义。此外，还有诸如`dexml`、`lxml`和`pyxser`等软件包，作为Python对象和XML之间的替代绑定。请参阅[http://pythonhosted.org/dexml/api/dexml.html](http://pythonhosted.org/dexml/api/dexml.html)、[http://lxml.de](http://lxml.de)和[http://coder.cl/products/pyxser/](http://coder.cl/products/pyxser/)。以下是候选软件包的更长列表：[https://wiki.python.org/moin/PythonXml](https://wiki.python.org/moin/PythonXml)。
- en: Dumping objects using string templates
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字符串模板转储对象
- en: 'One way to serialize a Python object into XML is by creating the XML text.
    This is a kind of manual mapping that''s often implemented as a method function
    that emits a snippet of XML that corresponds to the Python object. In the case
    of a complex object, the container must get the XML for each item inside the container.
    Here are two simple extensions to our microblog class structure that add the XML
    output capability as text:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python对象序列化为XML的一种方法是创建XML文本。这是一种手动映射，通常实现为一个方法函数，该函数发出与Python对象对应的XML片段。对于复杂对象，容器必须获取容器内每个项目的XML。以下是我们的微博类结构的两个简单扩展，添加了文本的XML输出功能：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ve written some highly class-specific XML output methods. These will emit
    the relevant attributes wrapped in XML syntax. This approach doesn''t generalize
    well. The `Blog_X.xml()` method emits a `<blog>` tag with a title and entries.
    The `Post_X.xml()` method emits a `<post>` tag with the various attributes. In
    both of these methods, subsidiary objects were created using `"".join()` or `"\n".join()`
    to build a longer string from shorter string elements. When we convert a `Blog`
    object to XML, the results look like this:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一些高度特定于类的XML输出方法。这些方法将发出包装在XML语法中的相关属性。这种方法不太通用。`Blog_X.xml()`方法发出带有标题和条目的`<blog>`标记。`Post_X.xml()`方法发出带有各种属性的`<post>`标记。在这两种方法中，使用`"".join()`或`"\n".join()`创建了较短字符串元素的较长字符串。当我们将`Blog`对象转换为XML时，结果如下：
- en: '[PRE61]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This approach has two disadvantages:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个缺点：
- en: We've ignored the XML namespaces. That's a small change to the literal text
    for emitting the tags.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们忽略了XML命名空间。这是发出标记的文字的一个小改变。
- en: Each class would also need to properly escape the `<`, `&`, `>`, and `"` characters
    into the XML entities `&lt;`, `&gt;`, `&amp;`, and `&quot;`. The `html` module
    includes the `html.escape()` function that does this.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类还需要正确转义`<`、`&`、`>`和`"`字符为XML实体`&lt;`、`&gt;`、`&amp;`和`&quot;`。`html`模块包括`html.escape()`函数来执行此操作。
- en: This does emit proper XML; it can be relied upon to work; it isn't very elegant
    and doesn't generalize well.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实发出了正确的XML；可以依赖它工作；它不太优雅，也不太通用。
- en: Dumping objects with xml.etree.ElementTree
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用xml.etree.ElementTree转储对象
- en: We can use the `xml.etree.ElementTree` module to build `Element` structures
    that can be emitted as XML. It's challenging to use `xml.dom` and `xml.minidom`
    for this. The DOM API requires a top-level document that then builds individual
    elements. The presence of this necessary context object creates clutter when trying
    to serialize a simple class with several attributes. We have to create the document
    first and then serialize all the elements of the document, providing the document
    context as an argument.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`xml.etree.ElementTree`模块构建可以作为XML发出的`Element`结构。使用`xml.dom`和`xml.minidom`进行这项工作是具有挑战性的。DOM
    API需要一个顶级文档，然后构建单独的元素。当尝试序列化具有多个属性的简单类时，必要的上下文对象的存在会导致混乱。我们必须首先创建文档，然后序列化文档的所有元素，并将文档上下文作为参数提供。
- en: 'Generally, we''d like each class in our design to build a top-level element
    and return that. Most top-level elements will have a sequence of subelements.
    We can assign text as well as attributes to each element that we build. We can
    also assign a *tail* that is the extraneous text that follows a closed tag. In
    some content models, this is just whitespace. Because of the long name, it might
    be helpful to import `ElementTree` in the following manner:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望设计中的每个类都构建一个顶级元素并返回。大多数顶级元素将具有一系列子元素。我们可以为构建的每个元素分配文本以及属性。我们还可以分配一个*tail*，即跟在封闭标记后面的多余文本。在某些内容模型中，这只是空白。由于名称很长，可能有助于以以下方式导入`ElementTree`：
- en: '[PRE62]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here are two extensions to our microblog class structure that add the XML output
    capability as the `Element` instances. We add the following method to the `Blog`
    class:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的微博类结构的两个扩展，将XML输出功能添加为`Element`实例。我们向`Blog`类添加了以下方法：
- en: '[PRE63]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We add the following method to the `Post` class:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`Post`类添加了以下方法：
- en: '[PRE64]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We've written highly class-specific XML output methods. These will build the
    `Element` objects that have the proper text values.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了高度特定于类的XML输出方法。这些方法将构建具有适当文本值的`Element`对象。
- en: Note
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There's no fluent shortcut for building the subelements. We have to insert each
    text item individually.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 没有用于构建子元素的流畅快捷方式。我们必须逐个插入每个文本项。
- en: In the `blog` method, we were able to perform `Element.extend()` to put all
    of the individual post entries inside the `<entry>` element. This allows us to
    build the XML structure flexibly and simply. This approach can deal gracefully
    with the XML namespaces. We can use the `QName` class to build qualified names
    for XML namespaces. The `ElementTree` module correctly applies the namespace qualifiers
    to the XML tags. This approach also properly escapes the `<`, `&`, `>`, and `"`
    characters into the XML entities `&lt;`, `&gt;`, `&amp;`, and `&quot;`. The XML
    output from these methods will mostly match the previous section. The whitespace
    will be different.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blog`方法中，我们能够执行`Element.extend()`将所有单独的帖子条目放在`<entry>`元素内。这使我们能够灵活而简单地构建XML结构。这种方法可以优雅地处理XML命名空间。我们可以使用`QName`类为XML命名空间构建合格的名称。`ElementTree`模块正确地将命名空间限定符应用于XML标记。这种方法还可以将`<`、`&`、`>`和`"`字符正确转义为XML实体`&lt;`、`&gt;`、`&amp;`和`&quot;`。这些方法生成的XML输出大部分将与上一节相匹配。空格将不同。
- en: Loading XML documents
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载XML文档
- en: Loading Python objects from an XML document is a two-step process. First, we
    need to parse the XML text to create the document objects. Then, we need to examine
    the document objects to produce Python objects. As noted previously, the tremendous
    flexibility of XML notation means that there isn't a single XML-to-Python serialization.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从XML文档加载Python对象是一个两步过程。首先，我们需要解析XML文本以创建文档对象。然后，我们需要检查文档对象以生成Python对象。正如前面所述，XML符号的巨大灵活性意味着没有单一的XML到Python序列化。
- en: 'One approach to walk through an XML document involves making XPath-like queries
    to locate the various elements that were parsed. Here''s a function to walk an
    XML document, emitting the `Blog` and `Post` objects from the available XML:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历XML文档的一种方法涉及进行类似XPath的查询，以定位解析的各种元素。以下是一个遍历XML文档的函数，从可用的XML中发出`Blog`和`Post`对象：
- en: '[PRE65]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This snippet traverses a `<blog>` XML document. It locates the `<title>` tag
    and gathers all of the text within that element to create the top-level `Blog`
    instance. It then locates all the `<entry>` subelements found within the `<entries>`
    element. These are used to build each `Post` object. The various attributes of
    the `Post` object are converted individually. The text of each individual `<tag>`
    element within the `<tags>` element is turned into a list of text values. The
    date is parsed from its text representation. The `Post` objects are each appended
    to the overall `Blog` object. This *manual* mapping from XML text to Python objects
    is an essential feature of parsing XML documents.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历了一个`<blog>` XML文档。它定位了`<title>`标记，并收集该元素内的所有文本，以创建顶层的`Blog`实例。然后，它定位了`<entries>`元素内找到的所有`<entry>`子元素。这些用于构建每个`Post`对象。`Post`对象的各种属性被单独转换。`<tags>`元素内每个单独的`<tag>`元素的文本被转换为文本值列表。日期从其文本表示中解析出来。每个`Post`对象都被追加到整体的`Blog`对象中。这种从XML文本到Python对象的*手动*映射是解析XML文档的一个重要特性。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We've looked at a number of ways to serialize Python objects. We can encode
    our class definitions in notations, including JSON, YAML, pickle, XML, and CSV.
    Each of these notations has a variety of advantages and disadvantages.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了多种序列化Python对象的方法。我们可以在各种符号中对我们的类定义进行编码，包括JSON、YAML、pickle、XML和CSV。每种符号都有各种优点和缺点。
- en: These various library modules generally work around the idea of loading objects
    from an external file or dumping objects to a file. These modules aren't completely
    consistent with each other, but they're very similar, allowing us to apply some
    common design patterns.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的库模块通常围绕着从外部文件加载对象或将对象转储到文件的想法。这些模块并不完全一致，但它们非常相似，允许我们应用一些常见的设计模式。
- en: Using CSV and XML tends to expose the most difficult design problems. Our class
    definitions in Python can include object references that don't have a good representation
    in the CSV or XML notation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSV和XML往往会暴露出最困难的设计问题。我们在Python中的类定义可以包括在CSV或XML符号中没有很好表示的对象引用。
- en: Design considerations and trade-offs
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: 'There are many ways to serialize and persist Python objects. We haven''t seen
    all of them yet. The formats in this section are focused on two essential use
    cases:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以序列化和持久化Python对象。我们还没有看到它们的全部。本节中的格式侧重于两个基本用例：
- en: '**Data interchange with other applications**: We might be publishing data for
    other applications or accepting data from other applications. In this case, we''re
    often constrained by the other applications'' interfaces. Often, JSON and XML
    are used by other applications and frameworks as their preferred form of data
    interchange. In some cases, we''ll use CSV to exchange data.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与其他应用程序的数据交换**：我们可能会为其他应用程序发布数据或接受其他应用程序的数据。在这种情况下，我们通常受到其他应用程序接口的限制。通常，其他应用程序和框架使用JSON和XML作为其首选的数据交换形式。在某些情况下，我们将使用CSV来交换数据。'
- en: '**Persistent data for our own applications**: In this case, we''re often going
    to choose `pickle` because it''s complete and is already part of the Python Standard
    Library. However, one of the important advantages of YAML is its readability;
    we can view, edit and even modify the file.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们自己应用程序的持久数据**：在这种情况下，我们通常会选择`pickle`，因为它是完整的，并且已经是Python标准库的一部分。然而，YAML的一个重要优势是它的可读性；我们可以查看、编辑甚至修改文件。'
- en: When working with each of these formats, we have a number of design considerations.
    First and foremost, these formats are biased towards serializing a single Python
    object. It might be a list of other objects, but it is essentially a single object.
    JSON and XML, for example, have ending delimiters that are written after the serialized
    object. For persisting individual objects from a larger domain, we can look at
    `shelve` and `sqlite3` in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving
    Objects via Shelve"), *Storing and Retrieving Objects via Shelve* and [Chapter
    11](ch11.html "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing
    and Retrieving Objects via SQLite*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这些格式时，我们有许多设计考虑。首先，这些格式偏向于序列化单个Python对象。它可能是其他对象的列表，但本质上是单个对象。例如，JSON和XML具有在序列化对象之后编写的结束分隔符。对于从较大域中持久化单个对象，我们可以查看[第10章](ch10.html
    "第10章。通过Shelve存储和检索对象")中的`shelve`和`sqlite3`，*通过Shelve存储和检索对象*和[第11章](ch11.html
    "第11章。通过SQLite存储和检索对象")中的`shelve`和`sqlite3`，*通过SQLite存储和检索对象*。
- en: JSON is a widely-used standard. It's inconvenient for representing complex Python
    classes. When using JSON, we need to be cognizant of how our objects can be reduced
    to a JSON-compatible representation. JSON documents are human-readable. JSON's
    limitations make it potentially secure for the transmission of objects through
    the Internet.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一个广泛使用的标准。它不方便表示复杂的Python类。在使用JSON时，我们需要意识到我们的对象如何被简化为与JSON兼容的表示形式。JSON文档是人类可读的。JSON的限制使其在通过互联网传输对象时可能更安全。
- en: YAML is not as widely used as JSON, but it solves numerous problems in serialization
    and persistence. YAML documents are human-readable. For editable configuration
    files, YAML is ideal. We can make YAML secure using the safe-load options.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: YAML并不像JSON那样广泛使用，但它解决了序列化和持久性中的许多问题。YAML文档是人类可读的。对于可编辑的配置文件，YAML是理想的。我们可以使用safe-load选项使YAML安全。
- en: Pickle is ideal for the simple, fast local persistence of Python objects. It
    is a compact notation for the transmission from Python-to-Python. CSV is a widely-used
    standard. Working out representations for Python objects in CSV notation is challenging.
    When sharing data in the CSV notation, we often end up using `namedtuples` in
    our applications. We have to design a mapping from Python to CSV and CSV to Python.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Pickle非常适合于Python对象的简单，快速的本地持久性。它是从Python到Python的传输的紧凑表示。CSV是一个广泛使用的标准。在CSV表示中为Python对象制定表示形式是具有挑战性的。在CSV表示中共享数据时，我们经常在应用程序中使用`namedtuples`。我们必须设计一个从Python到CSV和从CSV到Python的映射。
- en: XML is another widely-used notation for serializing data. XML is extremely flexible,
    leading to a wide variety of ways to encode Python objects in XML notation. Because
    of the XML use cases, we often have external specifications in the form of an
    XSD or DTD. The process for parsing XML to create Python objects is always rather
    complex.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: XML是另一种广泛使用的序列化数据的表示形式。XML非常灵活，导致了多种在XML表示中编码Python对象的方式。由于XML用例，我们经常有外部规范，如XSD或DTD。解析XML以创建Python对象的过程总是相当复杂的。
- en: Because each CSV row is largely independent of the others, CSV allows us to
    encode or decode extremely large collections of objects. For this reason, CSV
    is often handy for encoding and decoding gargantuan collections that can't fit
    into the memory.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个CSV行在很大程度上独立于其他行，CSV允许我们编码或解码极大的对象集合。因此，CSV通常用于编码和解码无法放入内存的巨大集合。
- en: In some cases, we have a hybrid design problem. When reading most modern spreadsheet
    files, we have the CSV row-and-column problem wrapped in the XML parsing problem.
    For example, [OpenOffice.org](http://OpenOffice.org). ODS files are zipped archives.
    One of the files in the archive is the `content.xml` file. Using an XPath search
    for `body/spreadsheet/table` elements will locate the individual tabs of the spreadsheet
    document. Within each table, we'll find the `table-row` elements that (usually)
    map to Python objects. Within each row, we'll find the `table-cell` elements that
    contain the individual values that build up the attributes of an object.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们面临混合设计问题。在阅读大多数现代电子表格文件时，我们遇到了CSV行列问题和XML解析问题。例如，[OpenOffice.org](http://OpenOffice.org)。ODS文件是压缩存档。存档中的一个文件是`content.xml`文件。使用XPath搜索`body/spreadsheet/table`元素将定位电子表格文档的各个选项卡。在每个表格中，我们会找到通常映射到Python对象的`table-row`元素。在每行中，我们会找到包含构建对象属性的单个值的`table-cell`元素。
- en: Schema evolution
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式演变
- en: When working with persistent objects, we have to address the problem of schema
    evolution. Our objects have a dynamic state and a static class definition. We
    can easily persist the dynamic state. Our class definitions are the schema for
    the persistent data. The class, however, is not *absolutely* static. When a class
    changes, we need to make a provision to load data that was dumped by the previous
    release of our application.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理持久对象时，我们必须解决模式演变的问题。我们的对象具有动态状态和静态类定义。我们可以轻松地保存动态状态。我们的类定义是持久数据的模式。然而，类并非*绝对*静态。当类发生变化时，我们需要提供加载由应用程序的先前版本转储的数据的方法。
- en: It's best to think of external file compatibility to distinguish between major
    and minor release numbers. A major release should mean that a file is no longer
    compatible and a conversion must be done. A minor release should mean that the
    file formats are compatible and no data conversion will be involved in the upgrade.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最好考虑外部文件兼容性，以区分主要和次要发布版本号。主要发布应意味着文件不再兼容，必须进行转换。次要发布应意味着文件格式兼容，升级不涉及数据转换。
- en: One common approach is to include the major version number in the file extension.
    We might have filenames that end in `.json2` or `.json3` to indicate which format
    of data is involved. Supporting multiple versions of a persistent file format
    often becomes rather complex. To provide a seamless upgrade path, an application
    should be able to decode previous file formats. Often, it's best to persist data
    in the latest and greatest file format, even if the other formats are supported
    for input.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是在文件扩展名中包含主版本号。我们可能会有以`.json2`或`.json3`结尾的文件名，以指示涉及哪种数据格式。支持持久文件格式的多个版本通常变得相当复杂。为了提供无缝升级路径，应用程序应能够解码先前的文件格式。通常，最好将数据持久化在最新和最好的文件格式中，即使其他格式也支持输入。
- en: In the next chapters, we'll address serialization that's not focused on a single
    object. The `shelve` and `sqlite3` modules give us ways to serialize a universe
    of distinct objects. After that, we'll return to using these techniques for **Representational
    State Transfer** (**REST**) to transmit objects from process to process. Also,
    we'll use these techniques yet again to process the configuration files.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论不专注于单个对象的序列化。`shelve`和`sqlite3`模块为我们提供了序列化一系列不同对象的方法。之后，我们将再次使用这些技术来进行**表述状态转移**（**REST**）以将对象从一个进程传输到另一个进程。此外，我们还将再次使用这些技术来处理配置文件。
- en: Looking forward
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve* and [Chapter 11](ch11.html "Chapter 11. Storing
    and Retrieving Objects via SQLite"), *Storing and Retrieving Objects via SQLite*,
    we'll look at two common approaches to make larger collections of persistent objects.
    These two chapters show us different approaches to create a database of Python
    objects.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章。通过Shelve存储和检索对象")和[第11章](ch11.html "第11章。通过SQLite存储和检索对象")中，我们将看到两种常见的方法来创建更大的持久对象集合。这两章向我们展示了创建Python对象数据库的不同方法。
- en: In [Chapter 12](ch12.html "Chapter 12. Transmitting and Sharing Objects"), *Transmitting
    and Sharing Objects*, we'll apply these serialization techniques to the problem
    of making an object available in another process. We'll focus on RESTful web services
    as a simple and popular way to transmit an object among processes.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](ch12.html "第12章。传输和共享对象")中，*传输和共享对象*，我们将把这些序列化技术应用到使对象在另一个进程中可用的问题上。我们将专注于RESTful
    web服务作为在进程之间传输对象的简单和流行的方式。
- en: In [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, we'll apply these serialization techniques
    yet again. In this case, we'll use representations such as JSON and YAML to encode
    the configuration information for an application.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.html "第13章。配置文件和持久化")中，*配置文件和持久化*，我们将再次应用这些序列化技术。在这种情况下，我们将使用JSON和YAML等表示形式来编码应用程序的配置信息。
- en: Chapter 10. Storing and Retrieving Objects via Shelve
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。通过Shelve存储和检索对象
- en: There are many applications where we need to persist objects individually. The
    techniques we looked at in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving
    – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML*, were biased towards handling a single object. Sometimes, we need
    to persist separate, individual objects from a larger domain.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多应用程序需要单独持久化对象。我们在[第9章](ch09.html "第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML")中看到的技术，*序列化和保存-JSON、YAML、Pickle、CSV和XML*，偏向于处理单个对象。有时，我们需要持久化来自更大领域的单独对象。
- en: 'Applications with persistent objects may demonstrate four use cases, summarized
    as the **CRUD Operations**: Create, Retrieve, Update, and Delete. In the general
    case, any of these operations may be applied to any object in the domain; this
    leads to the need for a more sophisticated persistence mechanism than a monolithic
    load or dump to a file. In addition to squandering memory, simple loads and dumps
    are often less efficient than fine-grained, object-by-object storage.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 具有持久对象的应用程序可能展示四种用例，总结为**CRUD操作**：创建、检索、更新和删除。在一般情况下，这些操作中的任何一个都可以应用于域中的任何对象；这导致需要比单一的加载或转储到文件更复杂的持久化机制。除了浪费内存外，简单的加载和转储通常比精细的、逐个对象的存储效率低。
- en: 'Using more sophisticated storage will lead us to look more closely at the allocation
    of responsibility. The various concerns give us overall design patterns for the
    architecture of the application software. One example of these higher-level design
    patterns is the **Three-Tier Architecture**:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更复杂的存储将使我们更加关注责任的分配。各种关注点为我们提供了应用软件架构的整体设计模式。这些更高级别的设计模式之一是**三层架构**：
- en: '**Presentation tier**: This may be a web browser or mobile app, sometimes both.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：这可能是Web浏览器或移动应用程序，有时两者都有。'
- en: '**Application tier**: This is often deployed on an application server. The
    application tier should be subdivided into an application layer and a data model
    layer. The processing layer involves the classes that embody an application''s
    behavior. The data model layer defines the problem domain''s object model.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这通常部署在应用服务器上。应用层应该被细分为应用层和数据模型层。处理层涉及体现应用行为的类。数据模型层定义了问题域的对象模型。'
- en: '**Data tier**: This includes an access layer and a persistence layer. The access
    layer provides uniform access to persistent objects. The persistence layer serializes
    objects and writes them to the persistent storage.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**：这包括访问层和持久化层。访问层提供对持久对象的统一访问。持久化层将对象序列化并将其写入持久存储。'
- en: This model can be applied to a single GUI application. The presentation tier
    is the GUI; the application tier is the relevant processor and the data model;
    the access tier is the persistence modules. It even applies to a command-line
    application where the presentation tier is merely an options parser as well as
    the `print()` functions.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型可以应用于单个GUI应用程序。表示层是GUI；应用层是相关的处理器和数据模型；访问层是持久性模块。它甚至适用于命令行应用程序，其中表示层仅仅是一个选项解析器以及`print()`函数。
- en: The `shelve` module defines a mapping-like container in which we can store objects.
    Each stored object is pickled and written to a file. We can also unpickle and
    retrieve any object from the file. The `shelve` module relies on the `dbm` module
    to save and retrieve objects.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块定义了一个类似映射的容器，我们可以在其中存储对象。每个存储的对象都被pickled并写入文件。我们还可以从文件中unpickle并检索任何对象。`shelve`模块依赖于`dbm`模块来保存和检索对象。'
- en: This section will focus on the data model taken from the application tier and
    the access and persistence taken from the data tier. The interface between these
    tiers can simply be a class interface within a single application. Or, it can
    be a more elaborate networked interface. We'll focus on the simple class-to-class
    interface in this chapter. We'll look at a network-based interface in [Chapter
    12](ch12.html "Chapter 12. Transmitting and Sharing Objects"), *Transmitting and
    Sharing Objects*, using REST.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点关注从应用程序层获取的数据模型以及从数据层获取的访问和持久性。这两个层之间的接口可以简单地是单个应用程序内的类接口。或者，它可以是一个更复杂的网络接口。在本章中，我们将重点关注简单的类与类接口。我们将在第12章中，使用REST，*传输和共享对象*，关注基于网络的接口。
- en: Analyzing persistent object use cases
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析持久对象的用例
- en: 'The persistence mechanisms we looked at in [Chapter 9](ch09.html "Chapter 9. Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML*, focused on reading and writing a compact file with
    a serialized object. If we wanted to update any part of the file, we were forced
    to replace the entire file. This is a consequence of using a compact notation
    for the data; it''s difficult to reach the position of an object within a file,
    and it''s difficult to replace an object if the size changes. Rather than addressing
    these difficulties with clever, complex algorithms, the object was simply serialized
    and written. When we have a larger domain of many persistent, mutable objects,
    we introduce some additional depth to the use cases. Here are some additional
    considerations:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第9章中看到的持久性机制，*序列化和保存 - JSON、YAML、Pickle、CSV和XML*，侧重于读取和写入一个序列化对象的紧凑文件。如果我们想要更新文件的任何部分，我们被迫替换整个文件。这是使用紧凑表示法的后果；很难到达文件中对象的位置，如果大小发生变化，替换对象也很困难。我们并没有用巧妙、复杂的算法来解决这些困难，而是简单地对对象进行了序列化和写入。当我们有一个更大的领域，有许多持久的、可变的对象时，我们引入了一些额外的深度到用例中。以下是一些额外的考虑：
- en: We may not want to load all the objects into the memory at one time. For many
    *Big Data* applications, it might be impossible to load all the objects into the
    memory at one time.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能不想一次将所有对象加载到内存中。对于许多*大数据*应用程序，一次性加载所有对象可能是不可能的。
- en: We may be updating only small subsets—or individual instances—from our domain
    of objects. Loading and then dumping all the objects to update one object is relatively
    inefficient processing.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能只更新来自对象领域的小子集或单个实例。加载然后转储所有对象以更新一个对象是相对低效的处理。
- en: We may not be dumping all the objects at one time; we may be accumulating objects
    incrementally. Some formats such as YAML and CSV allow us to append themselves
    to a file with little complexity. Other formats such as JSON and XML have terminators
    that make it difficult to simply append to a file.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能不会一次性转储所有对象；我们可能会逐渐累积对象。一些格式，如YAML和CSV，允许我们以很少的复杂性将自己附加到文件上。其他格式，如JSON和XML，有终止符，使得简单地附加到文件变得困难。
- en: There are still more features we might want. It's common to conflate serialization,
    persistence, as well as concurrent update or write access into a single umbrella
    concept of *database*. The `shelve` module is not a comprehensive database solution
    by itself. The underlying `dbm` module used by `shelve` does not directly handle
    concurrent writes. It doesn't handle multioperation transactions either. It's
    possible to use low-level OS locking on the files to tolerate concurrent updating,
    but this tends to be highly OS-specific. For concurrent write access, it's better
    to either use a proper database or a RESTful data server. See [Chapter 11](ch11.html
    "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing and Retrieving
    objects via SQLite*, and [Chapter 12](ch12.html "Chapter 12. Transmitting and
    Sharing Objects"), *Transmitting and Sharing Objects*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想要更多的功能。将序列化、持久性以及并发更新或写访问混为一谈，统称为*数据库*是很常见的。`shelve`模块本身并不是一个全面的数据库解决方案。`shelve`使用的底层`dbm`模块并不直接处理并发写。它也不处理多操作事务。可以使用低级别的操作系统文件锁定来容忍并发更新，但这往往是高度依赖操作系统的。对于并发写访问，最好使用适当的数据库或RESTful数据服务器。参见[第11章](ch11.html
    "第11章。通过SQLite存储和检索对象")，*通过SQLite存储和检索对象*，以及[第12章](ch12.html "第12章。传输和共享对象")，*传输和共享对象*。
- en: The ACID properties
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ACID属性
- en: Our design must consider how the **ACID properties** apply to our `shelve` database.
    Our application will often make changes in bundles of related operations that
    should change the database from one consistent state to the next consistent state.
    The collection of operations to change a database can be called a transaction.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计必须考虑**ACID属性**如何适用于我们的`shelve`数据库。我们的应用程序通常会对相关操作进行捆绑更改，这些操作应该将数据库从一个一致的状态更改到下一个一致的状态。改变数据库的一系列操作可以称为事务。
- en: 'An example of multiple-operation transactions could involve updating two objects
    so that a total is kept invariant. We might be deducting from one financial account
    and depositing into another. The overall balance must be held constant for the
    database to be in a consistent, valid state. The ACID properties characterize
    how we want the database transactions to behave as a whole. There are four rules
    that define our expectations:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 多操作事务的一个例子可能涉及更新两个对象，以保持总和不变。我们可能会从一个财务账户中扣除并存入另一个账户。整体余额必须保持恒定，以使数据库处于一致的有效状态。ACID属性表征了我们希望数据库事务作为一个整体的行为。有四条规则定义了我们的期望：
- en: '**Atomicity**: A transaction must be atomic. If there are multiple operations
    in a transaction, either all the operations should be completed or none of them
    should be completed. It should never be possible to view a shelf with a partially-completed
    transaction.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：事务必须是原子的。如果事务中有多个操作，要么所有操作都完成，要么都不完成。不应该可能查看一个部分完成的事务的架子。'
- en: '**Consistency**: A transaction must assure consistency. It will change the
    database from one valid state to another. A transaction should not corrupt the
    database or create inconsistent views among concurrent users. All users see the
    same net effect of completed transactions.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：事务必须保证一致性。它将把数据库从一个有效状态改变为另一个有效状态。事务不应该损坏数据库或在并发用户之间创建不一致的视图。所有用户看到已完成事务的相同净效果。'
- en: '**Isolation**: Each transaction should operate properly as if in complete isolation.
    We can''t have two concurrent users interfering with each other''s attempted updates.
    We must be able to transform concurrent access into (possibly slower) serial access
    and the database updates will produce the same results.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：每个事务应该像完全隔离一样正常运行。我们不能让两个并发用户干扰彼此的尝试更新。我们必须能够将并发访问转换为（可能更慢的）串行访问，并且数据库更新将产生相同的结果。'
- en: '**Durability**: The changes to the database are **durable**; they persist properly
    in the filesystem.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：对数据库的更改是**持久的**；它们在文件系统中正确地持久存在。'
- en: When we work with in-memory Python objects, clearly, we get **ACI** but don't
    get **D**. In-memory objects are not durable by definition. If we attempt to use
    the `shelve` module from several concurrent processes without locking or versioning,
    we may get only D but lose the ACI properties.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用内存中的Python对象时，显然，我们得到了**ACI**，但没有得到**D**。内存中的对象根据定义是不持久的。如果我们尝试在几个并发进程中使用`shelve`模块而没有锁定或版本控制，我们可能只得到D，但失去ACI属性。
- en: The `shelve` module doesn't provide direct support for atomicity; it doesn't
    have a way to handle transactions that consists of multiple operations. If we
    have multiple-operation transactions and we need atomicity, we must ensure they
    all work or all fail as a unit. This can involve the rather complex `try:` statements
    that must restore the previous state of the database in the event of a failure.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块不直接支持原子性；它没有处理由多个操作组成的事务的方法。如果我们有多个操作的事务并且需要原子性，我们必须确保它们全部成功或全部失败。这可能涉及到相当复杂的`try:`语句，必须在失败的情况下恢复数据库的先前状态。'
- en: The `shelve` module doesn't guarantee durability for all kinds of changes. If
    we place a mutable object onto the shelf and then change the object in memory,
    the persistent version on the shelf file will not change *automatically*. If we're
    going to mutate shelved objects, our application must be explicit about updating
    the shelf. We can ask a shelf object to track changes via the *writeback mode*,
    but using this feature can lead to poor performance.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块不保证对所有种类的更改都是持久的。如果我们将一个可变对象放到架子上，然后在内存中更改对象，架子文件上的持久版本将不会*自动*更改。如果我们要改变架子上的对象，我们的应用程序必须明确地更新架子。我们可以要求架子对象通过*写回模式*跟踪更改，但使用这个特性可能会导致性能不佳。'
- en: Creating a shelf
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个架子
- en: The first part of creating a shelf is done using a module-level function, `shelve.open()`,
    to create a persistent shelf structure. The second part is closing the file properly
    so that all changes are written to the underlying filesystem. We'll look at this
    in a more complete example later.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 创建架子的第一部分是使用模块级函数`shelve.open()`来创建一个持久的架子结构。第二部分是正确关闭文件，以便所有更改都被写入底层文件系统。我们稍后会在一个更完整的例子中看到这一点。
- en: Under the hood, the `shelve` module is using the `dbm` module to do the real
    work of opening a file and mapping from key to value. The `dbm` module itself
    is a wrapper around an underlying DBM-compatible library. Consequently, there
    are a number of potential implementations for the `shelve` features. The good
    news is that the differences among the `dbm` implementations are largely irrelevant.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`shelve`模块使用`dbm`模块来进行真正的工作，打开文件并从键到值的映射。`dbm`模块本身是一个围绕底层DBM兼容库的包装器。因此，`shelve`功能有许多潜在的实现。好消息是，`dbm`实现之间的差异在很大程度上是无关紧要的。
- en: 'The `shelve.open()` module function requires two parameters: the filename and
    the file access mode. Often, we want the default mode of `''c''` to open an existing
    shelf or create one if it doesn''t exist. The alternatives are for specialized
    situations:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve.open()`模块函数需要两个参数：文件名和文件访问模式。通常，我们希望使用`''c''`的默认模式来打开一个现有的架子，如果不存在则创建一个。专门情况下的替代方案有：'
- en: '`''r''` is a read-only shelf'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''r''`是一个只读的架子'
- en: '`''w''` is a read-write shelf that *must* exist or an exception will be raised'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''w''`是一个读写的架子，*必须*存在，否则将引发异常'
- en: '`''n''` is a new, empty shelf; any previous version will be overwritten'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''n''`是一个新的、空的架子；任何以前的版本都将被覆盖'
- en: It's absolutely essential to close a shelf to be sure that it is properly persisted
    to disk. The shelf is not a context manager itself, but the `contextlib.closing()`
    function can be used to make sure the shelf is closed. For more information on
    context managers, see [Chapter 5](ch05.html "Chapter 5. Using Callables and Contexts"),
    *Using Callables and Contexts.*
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭架子以确保它被正确地持久化到磁盘是绝对必要的。架子本身不是上下文管理器，但`contextlib.closing()`函数可以用来确保架子被关闭。有关上下文管理器的更多信息，请参见[第5章](ch05.html
    "第5章。使用可调用和上下文")，“使用可调用和上下文”。
- en: 'Under some circumstances, we might also want to explicitly synchronize a shelf
    to a disk without closing the file. The `shelve.sync()` method will persist changes
    prior to a close. The ideal lifecycle looks something like the following code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能还希望显式地将架子与磁盘同步，而不关闭文件。`shelve.sync()`方法将在关闭之前持久化更改。理想的生命周期看起来像以下代码：
- en: '[PRE66]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We've opened a shelf and provided that open shelf to some function that does
    the real work of our application. When this process is finished, the context will
    ensure that the shelf is closed. If the `process()` function raises an exception,
    the shelf will still be properly closed.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了一个架子，并将打开的架子提供给一些执行我们应用程序真正工作的函数。当这个过程完成时，上下文将确保架子被关闭。如果`process()`函数引发异常，架子仍将被正确关闭。
- en: Designing shelvable objects
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计可架架对象
- en: If our objects are relatively simple, then putting them on a shelf will be trivial.
    For objects that are not complex containers or large collections, we only have
    to work out a key to value mapping. For objects that are more complex—typically
    objects that contain other objects—we have to make some additional design decisions
    regarding the granularity of access and references among objects.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的对象相对简单，那么将它们放在架子上将是微不足道的。对于不是复杂容器或大型集合的对象，我们只需要解决键到值的映射。对于更复杂的对象——通常包含其他对象的对象——我们必须就访问的粒度和对象之间的引用做出一些额外的设计决策。
- en: We'll look at the simple case first, where all we have to design is the key
    that is used to access our objects. Then, we'll look at the more complex cases,
    where granularity and object references come into play.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一个简单的情况，我们只需要设计用于访问我们对象的键。然后，我们将看一些更复杂的情况，其中粒度和对象引用起作用。
- en: Designing keys for our objects
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的对象设计键
- en: The important feature of `shelve` (and `dbm`) is immediate access to any object
    in an arbitrarily huge universe of objects. The `shelve` module works with a mapping
    that is much like a dictionary. The shelf mapping exists on the persistent storage,
    so any object we put onto the shelf will be serialized and saved. The `pickle`
    module is used to do the actual serialization.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`（和`dbm`）的重要特性是可以立即访问任意大的对象宇宙中的任何对象。`shelve`模块与类似字典的映射一起工作。架子映射存在于持久存储上，因此我们放在架子上的任何对象都将被序列化和保存。`pickle`模块用于执行实际的序列化。'
- en: We must identify our shelved objects with some kind of key that will map to
    the object. As with a dictionary, the keys are hashed, which is a very quick calculation.
    It's fast because the key is limited to being a byte string; the hash is a modulus
    summation of those bytes. Since Python strings are trivially encoded into bytes,
    it means that string values are a common choice for keys. This is unlike a built-in
    `dict`, where any immutable object can be used as a key.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须用某种键来标识我们的架子对象，这个键将映射到对象。与字典一样，键是经过哈希处理的，这是一个非常快速的计算。这很快是因为键被限制为字节字符串；哈希是这些字节的模和。由于Python字符串可以轻松编码为字节，这意味着字符串值是键的常见选择。这与内置的`dict`不同，其中任何不可变对象都可以用作键。
- en: 'Since the key locates the value, it means the key must be unique. This imposes
    some design considerations on our classes to provide an appropriate unique key.
    In some cases, the problem domain will have an attribute that is an obvious unique
    key. In that case, we can simply use that attribute to construct this key: `shelf[object.key_attribute]=
    object`. This is the simplest case but doesn''t generalize well.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 由于键定位值，这意味着键必须是唯一的。这对我们的类施加了一些设计考虑，以提供适当的唯一键。在某些情况下，问题域将具有一个明显的唯一键属性。在这种情况下，我们可以简单地使用该属性来构造这个键：`shelf[object.key_attribute]=
    object`。这是最简单的情况，但不太通用。
- en: In other cases, our application problem doesn't offer us an appropriate unique
    key. This problem arises frequently when every attribute of an object is potentially
    mutable or potentially non-unique. It arises when working with U.S. citizens,
    for example, because social security numbers are not unique; they can be reused
    by the Social Security Administration. Additionally, a person can misreport a
    SSN and the application might need to change it; as it can change, there's a second
    reason it's not acceptable as a primary key.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们的应用问题没有提供适当的唯一键。例如，当对象的每个属性都可能是可变的或潜在的非唯一时，就会经常出现这个问题。例如，在处理美国公民时，社会安全号码并不是唯一的；它们可以被社会安全管理局重新使用。此外，一个人可能会错误报告社会安全号码，应用程序可能需要更改它；因为它可以更改，这是它不适合作为主键的第二个原因。
- en: Our application may have non-string values that are candidate or primary keys.
    For example, we might have a `datetime` object, a number, or even a tuple as a
    unique identifier. In all of these cases, we might want to encode the value as
    bytes or a string.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可能有候选或主键的非字符串值。例如，我们可能有一个`datetime`对象、一个数字，甚至一个元组作为唯一标识符。在所有这些情况下，我们可能希望将值编码为字节或字符串。
- en: In the cases where there is no obvious primary key, we can try to locate a combination
    of values that create a unique **composite key**. This isn't always a terribly
    good idea, because now the key is not atomic, and a change to any of the parts
    of the key creates data update problems.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有明显主键的情况下，我们可以尝试找到一组值的组合，创建一个唯一的**复合键**。这并不总是一个非常好的主意，因为现在键不是原子的，对键的任何部分的更改都会创建数据更新问题。
- en: 'It''s often simplest to follow a design pattern called a **surrogate key**.
    This key doesn''t depend on data within an object; it''s a surrogate for the object.
    This means any of the attributes of the object can be changed without leading
    to complications or restrictions. Python''s internal object IDs are an example
    of a kind of surrogate key. The string representation of a shelf key can follow
    this pattern: `class:oid`.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循一种称为**代理键**的设计模式通常是最简单的。这个键不依赖于对象内部的数据；它是对象的代理。这意味着对象的任何属性都可以更改而不会导致复杂或限制。Python的内部对象ID就是一种代理键的例子。架子键的字符串表示可以遵循这种模式：`class:oid`。
- en: The key string includes the class of the object paired with the unique identifier
    for an instance of the class. We can easily store diverse classes of objects in
    a single shelf using keys of this form. Even when we think there will be only
    one type of object in the shelf, this format is still helpful to save a namespace
    for indexes, administrative metadata, and future expansion.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 键字符串包括与对象实例的唯一标识符配对的对象类。我们可以使用这种形式的键轻松地将各种类的对象存储在单个架子中。即使我们认为架子中只会有一种类型的对象，这种格式仍然有助于为索引、管理元数据和未来扩展保存命名空间。
- en: 'When we have a suitable natural key, we might do something like this to persist
    objects in the shelf: `self[object.__class__.__name__+":"+object.key_attribute]=
    object`'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个合适的自然键时，我们可以这样做来将对象持久化到架子中：`self[object.__class__.__name__+":"+object.key_attribute]=
    object`
- en: This provides us with a distinct class name along with the unique key value
    as a simple identifier for each object. For surrogate keys, we'll need to define
    some kind of generator for the key.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个独特的类名，以及一个简单的标识符作为每个对象的唯一键值。对于代理键，我们需要为键定义某种生成器。
- en: Generating surrogate keys for objects
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为对象生成代理键
- en: We'll generate unique surrogate keys with an integer counter. To be sure that
    we keep this counter properly updated, we will store it in the shelf along with
    the rest of our data. Even though Python has an internal object ID, we should
    not use Python's internal identifier for a surrogate key. Python's internal ID
    numbers have no guarantees of any kind.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用整数计数器生成唯一的代理键。为了确保我们正确更新这个计数器，我们将把它与我们的其他数据一起存储在架子中。尽管Python有一个内部对象ID，但我们不应该使用Python的内部标识符作为代理键。Python的内部ID号没有任何保证。
- en: 'As we''re going to add some administrative objects to our shelf, we must give
    these objects unique keys with a distinctive prefix. We''ll use `_DB`. This will
    be a fake class of the objects in our shelf. The design decisions for these administrative
    objects are similar to the design of the application objects. We need to choose
    the granularity of storage. We have two choices:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将向我们的架子中添加一些管理对象，我们必须给这些对象分配具有独特前缀的唯一键。我们将使用`_DB`。这将是我们架子中对象的一个虚假类。这些管理对象的设计决策与应用程序对象的设计类似。我们需要选择存储的粒度。我们有两种选择：
- en: '**Coarse-Grained**: We can create a single `dict` object with all the administrative
    overheads for surrogate key generations. A single key such as `_DB:max` can identify
    this object. Within this `dict`, we could map class names to maximum identifier
    values used. Every time we create a new object, we assign the ID from this mapping
    and then also replace the mapping in the shelf. We''ll show the coarse-grained
    solution in the next section.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粗粒度**：我们可以创建一个带有所有代理键生成的管理开销的单个`dict`对象。一个单一的键，比如`_DB:max`可以标识这个对象。在这个`dict`中，我们可以将类名映射到使用的最大标识符值。每次创建一个新对象，我们都会从这个映射中分配ID，然后在架子中替换映射。我们将在下一节展示粗粒度解决方案。'
- en: '**Fine-Grained**: We can add many items to the database, each of which has
    the maximum key value for a different class of objects. Each of these additional
    key items has the form `_DB:max:class`. The value for each of these keys is just
    an integer, the largest sequential identifier assigned so far for a given class.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度**：我们可以向数据库添加许多项目，每个项目都具有不同类的对象的最大键值。这些额外的键项中的每一个都具有形式`_DB:max:class`。每个键的值只是一个整数，迄今为止为给定类分配的最大顺序标识符。'
- en: An important consideration here is that we've separated the key design from
    the class design for our application's classes. We can (and should) design our
    application objects as simply as possible. We should add just enough overhead
    to make `shelve` work properly, but no more.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要考虑因素是，我们已经将应用程序类的键设计与类设计分开。我们可以（也应该）尽可能简单地设计我们的应用程序对象。我们应该添加足够的开销，使`shelve`正常工作，但不要过多。
- en: Designing a class with a simple key
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计一个带有简单键的类
- en: It is helpful to store the `shelve` key as an attribute of a shelved object.
    Keeping the key in the object makes the object easier to delete or replace. Clearly,
    when creating an object, we'll start with a keyless version of the object until
    it's stored in the shelf. Once stored, the Python object needs to have a key attribute
    set so that each object in the memory contains a correct key.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 将`shelve`键存储为存储对象的属性是有帮助的。将键保留在对象中使得删除或替换对象更容易。显然，在创建对象时，我们将从不带键的对象开始，直到它存储在架子上。一旦存储，Python对象需要设置一个键属性，以便内存中的每个对象都包含正确的键。
- en: When retrieving objects, there are two use cases. We might want a specific object
    that is known by the key. In this case, the shelf will map the key to the object.
    We might also want a collection of related objects, not known by their keys but
    perhaps known by the values of some other attributes. In this case, we'll discover
    the keys of objects through some kind of search or query. We'll look at the search
    algorithms in the next section.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索对象时，有两种用例。我们可能需要一个已知键的特定对象。在这种情况下，架子将键映射到对象。我们可能还需要一组相关对象，不是通过它们的键而是通过其他属性的值来识别。在这种情况下，我们将通过某种搜索或查询来发现对象的键。我们将在下一节中讨论搜索算法。
- en: 'To support saving the shelf keys in objects, we''ll add an `_id` attribute
    to each object. It will keep the shelve key in each object that has been put onto
    the shelf or retrieved from the shelf. This will simplify managing objects that
    need to be replaced in or removed from the shelf. We have the following choices
    for adding this to the class:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持在对象中保存架子键，我们将为每个对象添加一个`_id`属性。它将在每个放入架子或从架子中检索的对象中保留架子键。这将简化需要在架子中替换或移除的对象的管理。我们有以下选择来将其添加到类中：
- en: '**No**: It''s not essential to the class; it''s just an overhead for the persistence
    mechanism'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不：这对于课程并不重要；这只是持久性机制的开销
- en: '**Yes**: It''s important data, and we should initialize it properly in `__init__()`'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的：这是重要的数据，我们应该在`__init__()`中正确初始化它
- en: 'We suggest not defining surrogate keys in the `__init__()` method; they''re
    not essential, and are just part of a persistence implementation. A surrogate
    key won''t have any method functions, for example, and it is never part of the
    processing layer of the application tier or the presentation tier. Here''s a definition
    for an overall `Blog`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议不要在`__init__()`方法中定义代理键；它们并不重要，只是持久性实现的一部分。例如，代理键不会有任何方法函数，它永远不会成为应用程序层或表示层的处理层的一部分。这是一个整体`Blog`的定义：
- en: '[PRE67]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We've provided just a `title` attribute and a little more. The `Blog.as_dict()`
    method can be used with a template to provide string values in the RST notation.
    We'll leave the consideration of individual posts within the blog for the next
    section.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只提供了一个`title`属性和一点点更多。`Blog.as_dict()`方法可以与模板一起使用，以RST表示法提供字符串值。我们将把博客中的个别帖子的考虑留给下一节。
- en: 'We can create a `Blog` object in the following manner:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以以下方式创建一个`Blog`对象：
- en: '[PRE68]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When we store this simple object in the shelf, we can do things like this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这个简单对象存储在架子上时，我们可以做这样的事情：
- en: '[PRE69]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We started by opening a new shelf. The file was called "`blog`". We put a key,
    '`Blog:1`', into our `Blog` instance, `b1`. We stored that `Blog` instance in
    the shelf using the key given in an `_id` attribute.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先打开了一个新的架子。文件名为“`blog`”。我们在我们的`Blog`实例`b1`中放入了一个键“'Blog:1'”。我们使用`_id`属性中给定的键将该`Blog`实例存储在架子中。
- en: 'We can fetch the item back from the shelf like this:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样从架子上取回物品：
- en: '[PRE70]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When we refer to `shelf[''Blog:1'']`, it will fetch our original `Blog` instance
    from the shelf. We''ve put only one object on the shelf, as we can see from the
    list of keys. Because we closed the shelf, the object is persistent. We can quit
    Python, start back up again, open the shelf, and see that the object remains on
    the shelf, using the assigned key. Previously, we mentioned a second use case
    for retrieval: locating an item without knowing the key. Here''s a search that
    locates all blogs with a given title:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们引用`shelf['Blog:1']`时，它将从架子中获取我们原始的`Blog`实例。我们只在架子上放了一个对象，正如我们从键列表中看到的那样。因为我们关闭了架子，对象是持久的。我们可以退出Python，重新启动，打开架子，看到对象仍然在架子上，使用分配的键。之前，我们提到了检索的第二个用例：在不知道键的情况下定位项目。这是一个查找，找到所有标题为给定标题的博客：
- en: '[PRE71]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We opened the shelf to get access to the objects. The `results` generator expression
    examines each item in the shelf to locate those items where the key starts with
    `'Blog:'`, and the object's title attribute is the string `'Travel Blog'`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了架子以访问对象。`results`生成器表达式检查架子中的每个项目，以找到那些键以“'Blog:'”开头，并且对象的标题属性是字符串“'Travel
    Blog'”的项目。
- en: What's important is that the key, `'Blog:1'`, is stored within the object itself.
    The `_id` attribute ensures that we have the proper key for any item that our
    application is working with. We can now mutate the object and replace it in the
    shelf using its original key.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，键“'Blog:1'”存储在对象本身内。`_id`属性确保我们对应用程序正在处理的任何项目都有正确的键。现在我们可以改变对象并使用其原始键将其替换到架子中。
- en: Designing classes for containers or collections
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为容器或集合设计类
- en: When we have more complex containers or collections, we have more complex design
    decisions to make. The first question is about the scope of the containment. We
    must decide on the **granularity** of our shelved objects.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有更复杂的容器或集合时，我们需要做出更复杂的设计决策。第一个问题是关于包含范围。我们必须决定我们架子上的对象的粒度。
- en: When we have a container, we can persist the entire container as a single, complex
    object on our shelf. To an extent, this might defeat the purpose of having multiple
    objects on a shelf in the first place. Storing one large container gives us coarse-grained
    storage. If we change one contained object, the entire container must be serialized
    and stored. If we wind up effectively pickling the entire universe of objects
    in a single container, why use `shelve`? We must strike a balance that is appropriate
    to the application's requirements.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个容器时，我们可以将整个容器作为单个复杂对象持久化到我们的架子上。在某种程度上，这可能会破坏首先在架子上有多个对象的目的。存储一个大容器给我们粗粒度的存储。如果我们更改一个包含的对象，整个容器必须被序列化和存储。如果我们最终在单个容器中有效地将整个对象宇宙进行pickle，为什么要使用`shelve`？我们必须找到一个适合应用需求的平衡点。
- en: The alternative is to decompose the collection into separate, individual items.
    In this case, our top-level `Blog` object won't be a proper Python container anymore.
    The parent might refer to each child with a collection of keys. Each child object
    could refer to the parent by the key. This use of keys is unusual in object-oriented
    design. Normally, objects simply contain references to other objects. When using
    `shelve` (or other databases), we must use indirect references by the key.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将集合分解为单独的个体项目。在这种情况下，我们的顶级`Blog`对象将不再是一个适当的Python容器。父对象可能使用键的集合引用每个子对象。每个子对象可以通过键引用父对象。这种使用键的方式在面向对象设计中是不寻常的。通常，对象只包含对其他对象的引用。在使用`shelve`（或其他数据库）时，我们必须使用键的间接引用。
- en: 'Each child will now have two keys: its own primary key, plus a **foreign key**
    that is the primary key of the parent object. This leads to a second design question
    about representing the key strings for the parents and their children.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子对象现在将有两个键：它自己的主键，加上一个**外键**，这个外键是父对象的主键。这导致了一个关于表示父对象和子对象的键字符串的第二个设计问题。
- en: Referring to objects via foreign keys
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过外键引用对象
- en: 'The key that we use to uniquely identify an object is its **primary key**.
    When child objects refer to a parent object, we have additional design decisions
    to make. How do we structure the children''s primary keys? There are two common
    design strategies for child keys, based on the kind of dependence that exists
    between the classes of objects:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来唯一标识一个对象的键是它的**主键**。当子对象引用父对象时，我们需要做出额外的设计决策。我们如何构造子对象的主键？基于对象类之间的依赖关系的类型，有两种常见的子键设计策略：
- en: '`"Child:cid"`: We''ll use this when we have children that can exist independently
    of an owning parent. For example, an item on an invoice refers to a product; the
    product can exist even if there''s no invoice item for the product.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Child:cid"`: 当我们有子对象可以独立于拥有父对象存在时，我们将使用这个。例如，发票上的项目指的是一个产品；即使没有产品的发票项目，产品也可以存在。'
- en: '`"Parent:pid:Child:cid"`: We''ll use this when the child cannot exist without
    a parent. A customer address doesn''t exist without a customer to contain the
    address in the first place. When the children are entirely dependent on the parent,
    the child''s key can contain the owning parent''s ID to reflect this dependency.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Parent:pid:Child:cid"`: 当子对象不能没有父对象存在时，我们将使用这个。例如，顾客地址没有顾客的话就不存在。当子对象完全依赖于父对象时，子对象的键可以包含拥有父对象的ID以反映这种依赖关系。'
- en: 'As with the parent class design, it''s easiest if we keep the primary key and
    all foreign keys associated with each child object. We suggest not initializing
    them in the `__init__()` method, as they''re just features of persistence. Here''s
    the general definition for `Post` within `Blog`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 与父类设计一样，如果我们保留主键和与每个子对象关联的所有外键，那么最容易。我们建议不要在`__init__()`方法中初始化它们，因为它们只是持久性的特征。这是`Blog`中`Post`的一般定义：
- en: '[PRE72]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We''ve provided several attributes for each microblog post. The `Post.as_dict()`
    method can be used with a template to provide string values in the RST notation.
    We''ve avoided mentioning the primary key or any foreign keys for `Post`. Here
    are two examples of the `Post` instances:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个微博帖子提供了几个属性。`Post.as_dict()`方法可以与模板一起使用，以RST格式提供字符串值。我们避免提及`Post`的主键或任何外键。以下是两个`Post`实例的示例：
- en: '[PRE73]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can now associate these with their owning blog, both by setting attributes
    and by assigning keys that will define the relationships. We''ll do this through
    several steps:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过设置属性和分配键来将这些与它们拥有的博客关联起来。我们将通过几个步骤来做到这一点：
- en: 'We''ll open the shelf and retrieve a parent `Blog` object. We''ll call it `owner`:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将打开架子并取出一个父`Blog`对象。我们将称之为`owner`：
- en: '[PRE74]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We've used the primary key to locate the owner item. An actual application might
    have used a search to locate this item by title. We might also have created an
    index to optimize the search. We'll look at the index and search below.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用主键来定位拥有者项目。实际应用可能会使用搜索来通过标题定位这个项目。我们可能还创建了一个索引来优化搜索。我们将在下面看一下索引和搜索。
- en: 'Now, we can assign this owner''s key to each `Post` object and persist the
    objects:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个拥有者的键分配给每个`Post`对象并持久化这些对象：
- en: '[PRE75]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We put the parent information into each `Post`. We used the parent information
    to build the primary key. For this dependent kind of key, the `_parent` attribute
    value is redundant; it can be deduced from the key. If we used an independent
    key design for `Posts`, however, `_parent` would not be duplicated in the key.
    When we look at the keys, we can see the `Blog` plus both `Post` instances:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将父信息放入每个`Post`中。我们使用父信息来构建主键。对于这种依赖类型的键，`_parent`属性值是多余的；它可以从键中推断出来。然而，如果我们对`Posts`使用独立键设计，`_parent`就不会在键中重复。当我们查看键时，我们可以看到`Blog`加上两个`Post`实例：
- en: '[PRE76]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When we fetch any child `Post`, we''ll know the proper parent `Blog` for the
    individual posting:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取任何子`Post`时，我们将知道每个帖子的正确父`Blog`：
- en: '[PRE77]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Following the keys the other way—from parent `Blog` down to child `Post`—is
    a bit more complex. We'll address this separately because we often want to optimize
    the path from parent to children with an index.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 从父`Blog`到子`Post`的键的反向跟踪会更加复杂。我们将单独讨论这个，因为我们经常希望通过索引优化从父对象到子对象的路径。
- en: Designing CRUD operations for complex objects
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计复杂对象的CRUD操作
- en: When we decompose a larger collection into a number of separate fine-grained
    objects, we will have multiple classes of objects on the shelf. Because they are
    independent objects, they will lead to separate sets of CRUD operations for each
    class. In some cases, the objects are independent, and operations on an object
    of one class have no impact outside that individual object.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个更大的集合分解为多个独立的细粒度对象时，我们将在架子上有多个类别的对象。因为它们是独立的对象，它们将导致每个类别的对象有独立的CRUD操作集合。在某些情况下，这些对象是独立的，对一个类别的对象的操作不会影响到其他对象。
- en: 'In our example, however, the `Blog` and `Post` objects have a dependency relationship.
    The `Post` objects are children of a parent `Blog`; the child can''t exist without
    the parent. When we have these dependent relationships, we have a more entangled
    collection of operations to design. Here are some of the considerations:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的例子中，`Blog`和`Post`对象存在依赖关系。`Post`对象是父`Blog`的子对象；子对象不能没有父对象存在。当存在这些依赖关系时，我们需要设计更加复杂的操作集合。以下是一些考虑因素：
- en: 'CRUD operations on independent (or parent) objects:'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立（或父）对象上的CRUD操作：
- en: We may create a new, empty parent, assigning a new primary key to this object.
    We can later assign children to this parent. Code such as `shelf['parent:'+object._id]=
    object` will create parent objects.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的空父对象，为这个对象分配一个新的主键。我们以后可以将子对象分配给这个父对象。例如，`shelf['parent:'+object._id]=
    object`这样的代码将创建父对象。
- en: We may update or retrieve this parent without any effect on the children. We
    can perform `shelf['parent:'+some_id]` on the right-hand side of the assignment
    to retrieve a parent. Once we have the object, we can perform `shelf['parent:'+object._id]=
    object` to persist a change.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以更新或检索此父级，而不会对子级产生任何影响。我们可以在赋值的右侧执行`shelf['parent:'+some_id]`来检索父级。一旦我们有了对象，我们可以执行`shelf['parent:'+object._id]=
    object`来保存更改。
- en: Deleting the parent can lead to one of two behaviors. One choice is to cascade
    the deletion to include all the children that refer to the parent. Alternatively,
    we may write code to prohibit the deletion of parents that still have child references.
    Both are sensible, and the choice is driven by the requirements imposed by the
    problem domain.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除父级可能导致两种行为之一。一种选择是级联删除以包括所有引用父级的子级。或者，我们可以编写代码来禁止删除仍具有子级引用的父级。这两种选择都是合理的，选择取决于问题域所施加的要求。
- en: 'CRUD operations on dependent (or child) objects:'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对依赖（或子级）对象进行 CRUD 操作：
- en: We can create a new child that refers to an existing parent. We must tackle
    the key design issue to decide what kind of keys we want to use for children.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个引用现有父级的新子级。我们必须解决键设计问题，以决定我们想要为子级使用什么样的键。
- en: We can update, retrieve, or delete the child outside the parent. This can even
    include assigning the child to a different parent.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在父级之外更新、检索或删除子级。这甚至可以包括将子级分配给不同的父级。
- en: As the code to replace an object is the same as the code to update an object,
    half of the CRUD processing is handled through the simple assignment statement.
    Deletion is done with the `del` statement. The issue of deleting children associated
    with a parent might involve a retrieval to locate the children. What's left, then,
    is an examination of retrieve processing, which can be a bit more complex.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 由于替换对象的代码与更新对象的代码相同，因此 CRUD 处理的一半通过简单的赋值语句处理。删除使用`del`语句完成。删除与父级关联的子级可能涉及检索以定位子级。然后剩下的是检索处理的检查，这可能会更复杂一些。
- en: Searching, scanning, and querying
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索、扫描和查询
- en: '*Don''t panic; these are all just synonyms. We''ll use the words interchangeably*.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要惊慌；这些只是同义词。我们将交替使用这些词*。'
- en: We have two design choices when looking at database searches. We can either
    return a sequence of keys or we can return a sequence of objects. As our design
    emphasizes storing the keys in each object, getting a sequence of objects from
    the database is sufficient, so we'll focus on that kind of design.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '在查看数据库搜索时，我们有两种设计选择。我们可以返回键序列，也可以返回对象序列。由于我们的设计强调在每个对象中存储键，因此从数据库获取对象序列就足够了，因此我们将专注于这种设计。 '
- en: A search is inherently inefficient. We'd prefer to have more focused indices.
    We'll look at how we can create more useful indices in the following section.
    The fallback plan of brute-force scans, however, always works.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索本质上是低效的。我们更希望有更有针对性的索引。我们将在下一节中看看如何创建更有用的索引。然而，蛮力扫描的备用计划总是有效的。
- en: 'When a child class has an independent-style key, we can easily scan a shelf
    for all instances of some `Child` class using a simple iterator over the keys.
    Here''s a generator expression that locates all the children:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类具有独立风格的键时，我们可以轻松地使用简单的迭代器扫描所有某个`Child`类的实例的架子。以下是一个定位所有子级的生成器表达式：
- en: '[PRE78]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This looks at every single key in the shelf to pick the subset that begins
    with `"Child:"`. We can build on this to apply more criteria by using a more complex
    generator expression:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这会查看架子中的每个键，以选择以`"Child:"`开头的子集。我们可以在此基础上应用更多条件，使用更复杂的生成器表达式：
- en: '[PRE79]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We've used a nested generator expression to expand on the initial `children`
    query, adding criteria. Nested generator expressions like this are remarkably
    efficient in Python. This does not make two scans of the database. It's a single
    scan with two conditions. Each result from the inner generator feeds the outer
    generator to build the result.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了嵌套的生成器表达式来扩展初始的`children`查询，添加条件。这样的嵌套生成器表达式在 Python 中非常高效。这不会使数据库进行两次扫描。这是一个带有两个条件的单次扫描。内部生成器的每个结果都会传递给外部生成器以构建结果。
- en: 'When a child class has a dependent-style key, we can search the shelf for children
    of a specific parent using an iterator with a more complex matching rule. Here''s
    a generator expression that locates all children of a given parent:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类具有依赖风格的键时，我们可以使用更复杂的匹配规则的迭代器在架子中搜索特定父级的子级。以下是一个定位给定父级所有子级的生成器表达式：
- en: '[PRE80]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This dependent-style key structure makes it particularly easy to remove a parent
    and all children in a simple loop:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这种依赖风格的键结构使得在简单循环中特别容易删除父级和所有子级：
- en: '[PRE81]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When using hierarchical "`Parent:` *pid* `:Child:` *cid*" keys, we do have
    to be careful when separating parents from their children. With this multi-part
    key, we''ll see lots of object keys that start with "Parent:*pid*". One of these
    keys will be the proper parent, simply "`Parent:` *pid*". The other keys will
    be children with "`Parent:` *pid* `:Child:` *cid*". We have three kinds of conditions
    that we''ll often use for these brute-force searches:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用分层"`Parent:` *pid* `:Child:` *cid* "键时，我们在将父级与子级分开时必须小心。使用这种多部分键，我们会看到许多以"Parent:*pid*"开头的对象键。其中一个键将是正确的父级，简单地"`Parent:`
    *pid*"。其他键将是带有"`Parent:` *pid* `:Child:` *cid*"的子级。我们经常使用这三种条件进行蛮力搜索：
- en: '`key.startswith("Parent:pid")` finds a union of parents and children; this
    isn''t a common requirement.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key.startswith("Parent:pid")` 找到父级和子级的并集；这不是常见的要求。'
- en: '`key.startswith("Parent:pid:Child:")` finds just children of the given parent.
    We might use a regular expression such as `r"^(Parent:\d+):(Child:\d+)$"` to match
    the keys.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key.startswith("Parent:pid:Child:")` 找到给定父级的子级。我们可以使用正则表达式，如`r"^(Parent:\d+):(Child:\d+)$"`来匹配键。'
- en: '`key.startswith("Parent:pid")` and `":Child:"` key finds just parents, excluding
    children. We might use a regular expression such as `r"^Parent:\d+$"` to match
    the keys.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key.startswith("Parent:pid")` 和 `":Child:"` 键仅找到父级，不包括子级。我们可以使用正则表达式，如`r"^Parent:\d+$"`来匹配键。'
- en: All of these queries can be optimized by building indices.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些查询都可以通过构建索引来优化。
- en: Designing an access layer for shelve
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为架子设计访问层
- en: 'Here''s how `shelve` might be used by an application. We''ll look at parts
    of an application that edits and saves microblog posts. We''ll break the application
    into two tiers: the application tier and the data tier. Within an application
    tier, we''ll distinguish between two layers:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序如何使用`shelve`的方式。我们将查看编辑和保存微博帖子的应用程序的各个部分。我们将应用程序分为两个层：应用程序层和数据层。在应用程序层中，我们将区分两个层：
- en: '**Application processing**: These objects are not persistent. These classes
    will embody the behavior of the application as a whole. These classes respond
    to the user selection of commands, menu items, buttons, and other processing elements.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序处理**：这些对象不是持久的。这些类将体现整个应用程序的行为。这些类响应用户选择的命令、菜单项、按钮和其他处理元素。'
- en: '**Problem domain data model**: These are the objects that will get written
    to a shelf. These objects embody the state of the application as a whole.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题域数据模型**：这些对象将被写入架子。这些对象体现了整个应用程序的状态。'
- en: The definitions of blog and post shown previously have no formal association
    between blog and its collection of posts. The classes are independent so that
    we can process them separately on the shelf. We don't want to create a single,
    large container object by turning `Blog` into a collection class.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 先前显示的博客和帖子的定义之间没有正式的关联。这些类是独立的，因此我们可以在架子上分别处理它们。我们不想通过将`Blog`转换为集合类来创建一个单一的大容器对象。
- en: 'Within the data tier, there might be a number of features, depending on the
    complexity of the data storage. We''ll focus on just two features:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据层中，可能会有许多功能，这取决于数据存储的复杂性。我们将专注于两个功能：
- en: '**Access**: These components provide uniform access to the problem domain objects.
    We''ll define an `Access` class that provides access to the `Blog` and `Post`
    instances. It will also manage the keys to locate `Blog` and `Post` objects in
    the shelf.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：这些组件提供对问题域对象的统一访问。我们将定义一个`Access`类，它提供对`Blog`和`Post`实例的访问。它还将管理定位架子中的`Blog`和`Post`对象的键。'
- en: '**Persistence**: The components serialize and write problem domain objects
    to persistent storage. This is the `shelve` module.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：这些组件将问题域对象序列化并写入持久存储。这是`shelve`模块。'
- en: 'We''ll break the `Access` class into three separate pieces. Here''s the first
    part with various parts of file open and close:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Access`类分成三个独立的部分。这是第一部分，包括文件打开和关闭的各个部分：
- en: '[PRE82]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: For `Access.new()`, we'll create a new, empty shelf. For `Access.open()`, we'll
    open an existing shelf. For closing and synchronizing, we've made sure to post
    a small dictionary of the current maximum key values into the shelf.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Access.new()`，我们将创建一个新的空架子。对于`Access.open()`，我们将打开一个现有的架子。在关闭和同步时，我们确保将当前最大键值的小词典发布到架子中。
- en: 'We haven''t addressed things such as implementing a `Save As...` method to
    make a copy of the file. Nor have we addressed a quit-without-saving option to
    revert to the previous version of a database file. These additional features involve
    the use of the `os` module to manage the file copies. We''ve provided you with
    both `close()` and `quit()` methods. This can make it slightly simpler to design
    a GUI application. Here are the various methods to update the shelf with `Blog`
    and `Post` objects:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有解决诸如实现“另存为...”方法以复制文件的事情。我们也没有解决不保存退出以恢复到数据库文件的上一个版本的选项。这些附加功能涉及使用`os`模块来管理文件副本。我们为您提供了`close()`和`quit()`方法。这可以使设计GUI应用程序稍微简单一些。以下是更新架子中的`Blog`和`Post`对象的各种方法：
- en: '[PRE83]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We've provided a minimal set of methods to put `Blog` in the shelf with its
    associated `Post` instances. When we add `Blog`, the `add_blog()` method first
    computes a new key, then updates the `Blog` object with the key, and finally,
    it persists the `Blog` object in the shelf. We've highlighted the lines that change
    the shelf contents. Simply setting an item in the shelf, similar to setting an
    item in a dictionary, will make the object persistent.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一组最小的方法，将`Blog`与其关联的`Post`实例放入架子中。当我们添加`Blog`时，`add_blog()`方法首先计算一个新的键，然后更新`Blog`对象的键，最后将`Blog`对象持久化在架子中。我们已经突出显示了改变架子内容的行。简单地在架子中设置一个项目，类似于在字典中设置一个项目，将使对象持久化。
- en: When we add a post, we must provide the parent `Blog` so that the two are properly
    associated on the shelf. In this case, we get the `Blog` key, create a new `Post`
    key, and then update the `Post` with the key values. This updated `Post` can be
    persisted on the shelf. The highlighted line in `add_post()` makes the object
    persistent in the shelf.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加一个帖子时，我们必须提供父`Blog`，以便两者在架子上正确关联。在这种情况下，我们获取`Blog`键，创建一个新的`Post`键，然后更新`Post`的键值。这个更新的`Post`可以持久化在架子上。`add_post()`中的突出行使对象在架子中持久化。
- en: In the unlikely event that we try to add a `Post` without having previously
    added the parent `Blog`, we'll have attribute errors because the `Blog._id` attribute
    will not be available.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果我们尝试添加`Post`而没有先前添加父`Blog`，我们将会出现属性错误，因为`Blog._id`属性将不可用。
- en: 'We''ve provided representative methods to replace `Post` and delete `Post`.
    There are several other possible operations; we didn''t include methods to replace
    `Blog` or delete `Blog`. When we write the method to delete `Blog`, we have to
    address the question of preventing the deletion when there are still `Posts` or
    cascading the deletion to include `Posts`. Finally, there are some search methods
    that act as iterators to query `Blog` and `Post` instances:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了代表性的方法来替换`Post`和删除`Post`。还有一些其他可能的操作；我们没有包括替换`Blog`或删除`Blog`的方法。当我们编写删除`Blog`的方法时，我们必须解决防止在仍然有`Posts`时删除或级联删除以包括`Posts`的问题。最后，还有一些搜索方法，作为迭代器来查询`Blog`和`Post`实例：
- en: '[PRE84]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We've defined the default iterator, `__iter__()`, that filters out the internal
    objects that have keys beginning with `_`. So far, we've only defined one such
    key, `_DB:max`, but this design leaves us with room to invent others.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了默认迭代器 `__iter__()`，它过滤掉了以 `_` 开头的内部对象。到目前为止，我们只定义了一个这样的键 `_DB:max`，但这个设计给我们留下了发明其他键的空间。
- en: The `blog_iter()` method iterates through the `Blog` entries. As both `Blog`
    and `Post` entries have keys that begin with `"Blog:"`, we must explicitly discard
    the `Post` entries that are children of `Blog`. A purpose-built index object is
    often a better approach. We'll look at that in the following section.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog_iter()` 方法遍历 `Blog` 条目。由于 `Blog` 和 `Post` 条目都以 `"Blog:"` 开头，我们必须明确丢弃
    `Blog` 的子级 `Post` 条目。一个专门构建的索引对象通常是一个更好的方法。我们将在下一节中讨论这个问题。'
- en: The `post_iter()` method iterates through posts that are a part of a specific
    blog. The `title_iter()` method examines posts that match a particular title.
    This examines each key in the shelf—a potentially inefficient operation.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_iter()` 方法遍历属于特定博客的帖子。`title_iter()` 方法检查与特定标题匹配的帖子。这会检查架子中的每个键，这可能是一个低效的操作。'
- en: We've also defined an iterator that locates posts that have the requested title
    in a given blog. This is a simple generator function that uses the `post_iter()`
    method function and returns only matching titles.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个迭代器，它定位在给定博客中具有请求标题的帖子。这是一个简单的生成器函数，它使用 `post_iter()` 方法函数，并且只返回匹配的标题。
- en: Writing a demonstration script
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写演示脚本
- en: 'We''ll use a technology spike to show you how an application might use this
    `Access` class to process the microblog objects. The spike script will save some
    `Blog` and `Post` objects to a database to show a sequence of operations that
    an application might use. This demonstration script can be expanded into unit
    test cases. More complete unit tests would show us that all the features are present
    and work correctly. This small spike script shows us how `Access` works:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用技术尖峰来向您展示一个应用程序如何使用这个 `Access` 类来处理微博对象。尖峰脚本将保存一些 `Blog` 和 `Post` 对象到数据库中，以展示应用程序可能使用的一系列操作。这个演示脚本可以扩展为单元测试用例。更完整的单元测试将向我们展示所有功能是否存在并且是否正确工作。这个小的尖峰脚本向我们展示了
    `Access` 的工作方式：
- en: '[PRE85]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We've created the `Access` class on the access layer so that it's wrapped in
    a context manager. The objective is to be sure that the access layer is closed
    properly, irrespective of any exceptions that might get raised.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在访问层上创建了 `Access` 类，以便它被包装在上下文管理器中。目标是确保访问层被正确关闭，无论可能引发的任何异常。
- en: With `Access.new()`, we've created a new shelf named `'blog'`. This might be
    done by a GUI by navigating to **File** **|** **New**. We added the new blog,
    `b1`, to the shelf. The `Access.add_blog()` method will update the `Blog` object
    with its shelf key. Perhaps someone filled in the blanks on a page and clicked
    on **New Blog** on their GUI application.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Access.new()`，我们创建了一个名为 `'blog'` 的新架子。这可能是通过导航到**文件** **|** **新建**来完成的。我们将新的博客
    `b1` 添加到了架子中。`Access.add_blog()` 方法将更新 `Blog` 对象及其架子键。也许有人在页面上填写了一些空白，并在他们的 GUI
    应用程序上点击了**新建博客**。
- en: Once we've added `Blog`, we can add two posts to it. The key from the parent
    `Blog` entry will be used to build the keys for each of the child `Post` entries.
    Again, the idea is that a user filled in some fields and clicked on **New Post**
    on a GUI.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了 `Blog`，我们可以向其添加两篇帖子。父 `Blog` 条目的键将用于构建每个子 `Post` 条目的键。同样，这个想法是用户填写了一些字段，并在他们的
    GUI 上点击了**新建帖子**。
- en: There's a final set of queries that dumps the keys and objects from the shelf.
    This shows us the final outcome of this script. We can perform `Access.get_blog()`
    to retrieve a blog entry that was created. We can iterate through the posts that
    are part of that blog using `Access.post_iter()`. The final `Access.quit()` assures
    that the maxima used to generate unique keys are recorded and the shelf is closed
    properly.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组最终的查询，从架子中转储键和对象。这向我们展示了这个脚本的最终结果。我们可以执行 `Access.get_blog()` 来检索创建的博客条目。我们可以使用
    `Access.post_iter()` 遍历属于该博客的帖子。最后的 `Access.quit()` 确保了用于生成唯一键的最大值被记录下来，并且架子被正确关闭。
- en: Creating indexes to improve efficiency
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建索引以提高效率
- en: One of the rules of efficiency is to avoid search. Our previous example of using
    an iterator over the keys in a shelf is inefficient. To state that more strongly,
    search *defines* inefficiency. We'll emphasize this.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 效率的一个规则是避免搜索。我们之前使用架子中键的迭代器的例子是低效的。更明确地说，搜索*定义了*低效。我们将强调这一点。
- en: Tip
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Brute-force search is perhaps the worst possible way to work with data. We must
    always design indexes that are based on subsets or mappings to improve performance.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: Brute-force search 可能是处理数据的最糟糕的方式。我们必须始终设计基于子集或映射的索引来提高性能。
- en: To avoid searching, we need to create indexes that list the items we want. This
    saves reading through the entire shelf to find an item or subset of items. A shelf
    index can't reference Python objects, as that would change the granularity at
    which the objects are stored. A shelf index must only list key values. This makes
    navigation among objects indirect but still much faster than a brute-force search
    of all items in the shelf.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免搜索，我们需要创建列出我们想要的项目的索引。这样可以避免通过整个架子来查找项目或子集。架子索引不能引用 Python 对象，因为那样会改变对象存储的粒度。架子索引只能列出键值。这使得对象之间的导航间接，但仍然比在架子中搜索所有项目要快得多。
- en: 'As an example of an index, we can keep a list of the `Post` keys associated
    with each `Blog` in the shelf. We can easily change the `add_blog()`, `add_post()`,
    and `delete_post()` methods to update the associated `Blog` entry too. Here are
    the revised versions of these blog update methods:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 作为索引的一个例子，我们可以在架子中为每个 `Blog` 关联的 `Post` 键保留一个列表。我们可以很容易地修改 `add_blog()`、`add_post()`
    和 `delete_post()` 方法来更新相关的 `Blog` 条目。以下是这些博客更新方法的修订版本：
- en: '[PRE86]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `add_blog()` method ensures that each `Blog` has an extra attribute, `_post_list`.
    This will be updated by other methods to maintain a list of keys for each `Post`
    that belongs to `Blog`. Note that we're not adding `Posts` themselves. If we do
    this, we collapse an entire `Blog` into a single entry into the shelf. By adding
    just the key information, we keep the `Blog` and `Post` objects separated.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_blog()`方法确保每个`Blog`都有一个额外的属性`_post_list`。其他方法将更新这个属性，以维护属于`Blog`的每个`Post`的键列表。请注意，我们没有添加`Posts`本身。如果这样做，我们将整个`Blog`合并为一个shelf中的单个条目。通过只添加键信息，我们保持了`Blog`和`Post`对象的分离。'
- en: The `add_post()` method adds `Post` to the shelf. It also appends `Post._id`
    to a list of keys maintained at the `Blog` level. This means any `Blog` object
    will have `_post_list` that provides a sequence of keys for the child posts.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_post()`方法将`Post`添加到shelf。它还将`Post._id`附加到`Blog`级别维护的键列表中。这意味着任何`Blog`对象都将具有提供子帖子键序列的`_post_list`。'
- en: This method makes two updates to the shelf. The first is simply saving the `Post`
    object. The second update is important. We do not attempt to simply mutate the
    `Blog` object that exists in the shelf. We intentionally store the object to the
    shelf to be sure that the object is persisted in its updated form.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法对shelf进行了两次更新。第一次只是保存了`Post`对象。第二次更新很重要。我们没有试图简单地改变shelf中存在的`Blog`对象。我们有意将对象存储到shelf中，以确保对象以其更新后的形式持久化。
- en: 'Similarly, the `delete_post()` method keeps the index up-to-date by removing
    an unused post from `_post_list` of the owning blog. As with `add_post()`, two
    updates are done to the shelf: a `del` statement removes `Post` and then the `Blog`
    object is updated to reflect the change in the index.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`delete_post()`方法通过从所属博客的`_post_list`中移除一个未使用的帖子来保持索引的最新状态。与`add_post()`一样，对shelf进行了两次更新：`del`语句删除了`Post`，然后更新了`Blog`对象以反映索引的变化。
- en: 'This change alters our queries for the `Post` objects in profound ways. Here
    is the revised version of the search methods:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变深刻地改变了我们对`Post`对象的查询方式。这是搜索方法的修订版本：
- en: '[PRE87]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We''re able to replace the scan in `post_iter()` with a much more efficient
    operation. This loop will rapidly yield the `Post` objects based on the keys saved
    in the `_post_list` attribute of `Blog`. We could consider replacing this `for`
    statement with a generator expression:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够用更高效的操作替换`post_iter()`中的扫描。这个循环将根据在`Blog`的`_post_list`属性中保存的键快速产生`Post`对象。我们可以考虑用生成器表达式替换这个`for`语句：
- en: '[PRE88]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The point of this optimization to the `post_iter()` method is to eliminate
    the search of *all* the keys for the matching keys. We''ve replaced searching
    all keys with simple iteration over an appropriate sequence of relevant keys.
    A simple timing test, which alternates between updating `Blog` and `Post` and
    rendering the `Blog` to RST, shows us the following results:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 对`post_iter()`方法的这种优化的重点是消除对匹配键的*所有*键的搜索。我们用适当的相关键序列的简单迭代替换了搜索所有键。一个简单的时间测试，交替更新`Blog`和`Post`并将`Blog`呈现为RST，向我们展示了以下结果：
- en: '[PRE89]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As expected, eliminating the search reduced the time required to process `Blog`
    and its individual `Posts`. The change is profound; almost 25 percent of the processing
    time is wasted in the search.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，消除搜索减少了处理`Blog`及其各个`Posts`所需的时间。这个变化是巨大的；几乎25%的处理时间都浪费在搜索上。
- en: Creating top-level indices
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建顶层索引
- en: 'We added an index to each `Blog` that locates `Posts` which belong to that
    `Blog`. We can also add a top-level index to the shelf that locates all `Blog`
    instances. The essential design is similar to what''s been shown previously. For
    each blog to be added or deleted, we must update an index structure. We must also
    update the iterators to properly use the index. Here''s another class design for
    mediating the access to our objects:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个`Blog`添加了一个定位属于该`Blog`的`Posts`的索引。我们还可以为shelf添加一个顶层索引，以定位所有`Blog`实例。基本设计与之前展示的类似。对于要添加或删除的每个博客，我们必须更新一个索引结构。我们还必须更新迭代器以正确使用索引。这是另一个用于调解访问我们对象的类设计：
- en: '[PRE90]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When creating a new database, we add an administrative object and an index,
    with a key of `"_DB:Blog"`. This index will be a list where we'll store the keys
    to each `Blog` entry. When we add a new `Blog` object, we also update this `"_DB:Blog"`
    object with the revised list of keys. We didn't show the delete implementation.
    It should be self-evident.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新数据库时，我们添加了一个管理对象和一个索引，键为`"_DB:Blog"`。这个索引将是一个列表，我们将在其中存储每个`Blog`条目的键。当我们添加一个新的`Blog`对象时，我们还将使用修订后的键列表更新这个`"_DB:Blog"`对象。我们没有展示删除的实现。这应该是不言自明的。
- en: 'When we iterate through `Blog` postings, we use the index list instead of a
    brute-force search of keys in the database. Here are the performance results:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历`Blog`的帖子时，我们使用索引列表，而不是在数据库中对键进行蛮力搜索。以下是性能结果：
- en: '[PRE91]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We can conclude from this that *most* of the processing time is wasted in a
    brute-force search of keys in the database. This should reinforce the notion that
    everything we can possibly do to avoid the search will dramatically improve the
    performance of our programs.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以得出结论，*大部分*的处理时间都浪费在对数据库中键的蛮力搜索上。这应该加强这样一个观念，即我们尽可能地避免搜索，将极大地提高程序的性能。
- en: Adding yet more index maintenance
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加更多的索引维护
- en: 'Clearly, the index maintenance aspect of a shelf can grow. With our simple
    data model, we could easily add more top-level indexes for tags, dates, and titles
    of `Posts`. Here''s another access layer implementation that defines two indices
    for `Blogs`. One index simply lists the keys for `Blog` entries. The other index
    provides keys based on the `Blog` title. We''ll assume the titles are not unique.
    We''ll present this access layer in three parts. Here''s the *Create* part of
    the CRUD processing:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，shelf的索引维护方面可能会增长。对于我们简单的数据模型，我们可以很容易地为`Posts`的标签、日期和标题添加更多的顶层索引。这里是另一个访问层实现，为`Blogs`定义了两个索引。一个索引简单地列出了`Blog`条目的键。另一个索引根据`Blog`的标题提供键。我们假设标题不是唯一的。我们将分三部分介绍这个访问层。这是CRUD处理的*创建*部分：
- en: '[PRE92]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We''ve added two indices: a simple list of the `Blog` keys plus `defaultdict`
    that provides us with a list of keys for a given title string. If each title is
    unique, the lists will all be singletons. If the titles are not unique, then each
    title will have a list of the `Blog` keys.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个索引：`Blog`键的简单列表加上`defaultdict`，它为给定标题字符串提供了一个键列表。如果每个标题都是唯一的，那么列表都将是单例的。如果标题不唯一，那么每个标题将有一个`Blog`键列表。
- en: 'When we add a `Blog` instance, we also update the two indices. The simple list
    of keys is updated by appending the new key and saving it to the shelf. The title
    index requires us to get the existing `defaultdict` from the shelf, append to
    the list of keys mapped to the `Blog''s` title, and then put the `defaultdict`
    back onto the shelf. The next section shows us the *Update* part of the CRUD processing:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加一个`Blog`实例时，我们还会更新两个索引。通过追加新键并将其保存到架子上来更新`Blog`键的简单列表。标题索引要求我们从架子上获取现有的`defaultdict`，将其追加到映射到`Blog`标题的键列表中，然后将`defaultdict`放回架子上。下一节向我们展示了CRUD处理的*更新*部分：
- en: '[PRE93]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When we update a `Blog` object, we might be changing the title of the `Blog`
    attribute. If our model had more attributes and more indices, we might want to
    compare the revised value with the value in the shelf to see which attributes
    changed. For this simple model—with only one attribute—no comparison is required
    to determine which attributes have changed.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新`Blog`对象时，可能会更改`Blog`属性的标题。如果我们的模型有更多属性和更多索引，我们可能希望将修订后的值与架子上的值进行比较，以确定哪些属性已更改。对于这个简单的模型——只有一个属性——不需要比较来确定哪些属性已更改。
- en: The first part of the operation is to remove the key of the `Blog` from the
    index. As we haven't cached the previous value of the `Blog.title` attribute,
    we can't simply remove the key based on the old title. Instead, we're forced to
    search the index for the key of `Blog` and remove the key from whatever title
    it's associated with.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的第一部分是从索引中删除`Blog`的键。由于我们没有缓存`Blog.title`属性的先前值，所以不能简单地根据旧标题删除键。相反，我们被迫搜索与`Blog`关联的键，并从任何与其关联的标题中删除键。
- en: Note
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Blog` with a unique title will leave the title''s list of keys empty. We should
    clean up an unused title too.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`博客`具有唯一标题将使标题的键列表为空。我们也应该清理未使用的标题。'
- en: 'Once the key associated with the old title has been removed from the index,
    we can append the key to the index using the new title. These final two lines
    are identical to the code used when creating `Blog` in the first place. Here are
    some retrieve processing examples:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦与旧标题关联的键从索引中删除，我们就可以使用新标题将键追加到索引中。这最后两行与创建`Blog`时使用的代码相同。以下是一些检索处理的示例：
- en: '[PRE94]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The `blog_iter()` method function iterates through all the blogs by fetching
    the index object from the shelf. The `blog_title_iter()` method function uses
    the index to fetch all the blogs with a given title. When there are many individual
    blogs, this should find a blog by title very quickly.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog_iter()`方法函数通过从架子上获取索引对象来迭代所有的博客。`blog_title_iter()`方法函数使用索引来获取所有具有给定标题的博客。当有许多单独的博客时，这应该可以很快地按标题找到一个博客。'
- en: The writeback alternative to index updates
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引更新的写回替代方案
- en: We can request that a shelf be opened with `writeback=True`. This will track
    changes to mutable objects by keeping a cached version of each object. Rather
    than burdening the `shelve` module with tracking all accessed objects to detect
    and preserve changes, the designs shown here will update a mutable object and
    specifically force the shelf to update the persistent version of the object.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以要求使用`writeback=True`打开一个架子。这将通过保持每个对象的缓存版本来跟踪可变对象的更改。与负担`shelve`模块跟踪所有访问的对象以检测和保留更改不同，这里显示的设计将更新可变对象，并明确强制架子更新对象的持久版本。
- en: This is a small shift in the runtime performance. An `add_post()` operation,
    for example, becomes slightly more costly because it also involves updating a
    `Blog` entry. If multiple `Posts` are added, these additional `Blog` updates become
    a kind of an overhead. However, this cost may be balanced by the improved performance
    of rendering `Blog` by avoiding a lengthy search of the shelf keys to track down
    the posts for a given blog. The designs shown here avoid creating a `writeback`
    cache that could grow unbounded during the running of an application.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行时性能的一个小变化。例如，`add_post()`操作变得稍微更昂贵，因为它还涉及更新`Blog`条目。如果添加了多个`Posts`，这些额外的`Blog`更新将成为一种开销。然而，通过避免对架子键进行漫长的搜索来跟踪给定博客的帖子，这种成本可能会得到平衡。这里显示的设计避免了创建一个在应用程序运行期间可能无限增长的`writeback`缓存。
- en: Schema evolution
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式演变
- en: When working with `shelve`, we have to address the problem of schema evolution.
    Our objects have a dynamic state and a static class definition. We can easily
    persist the dynamic state. Our class definitions are the schema for the persistent
    data. The class, however, is not *absolutely* static. If we change a class definition,
    how will we fetch objects from the shelf? A good design often involves some combination
    of the following techniques.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`shelve`时，我们必须解决模式演变的问题。我们的对象具有动态状态和静态类定义。我们可以很容易地持久化动态状态。我们的类定义是持久化数据的模式。然而，类并不是*绝对*静态的。如果我们更改类定义，我们将如何从架子上获取对象？一个好的设计通常涉及以下技术的某种组合。
- en: Changes to method functions and properties don't change the persisted object
    state. We can classify these as minor changes, as the shelved data is still compatible
    with the changed class definition. A new software release can have a new minor
    version number and users should be confident that it will work without problems.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 方法函数和属性的更改不会改变持久化对象的状态。我们可以将这些分类为次要更改，因为架子上的数据仍然与更改后的类定义兼容。新软件发布可以有一个新的次要版本号，用户应该有信心它将可以正常工作。
- en: Changes to attributes will change the persisted objects. We can call these major
    changes, and the shelved data will no longer be compatible with the new class
    definition. These kinds of changes should not be made by *modifying* a class definition.
    These kinds of changes should be made by defining a new subclass and providing
    an updated factory function to create instances of any version of the class.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的更改将改变持久化的对象。我们可以称这些为重大变化，而存储的数据将不再与新的类定义兼容。这种改变不应该通过*修改*类定义来进行。这种改变应该通过定义一个新的子类，并提供一个更新的工厂函数来创建任何版本的类的实例。
- en: 'We can be flexible about supporting multiple versions, or we can use one-time
    conversions. To be flexible, we must rely on factory functions to create instances
    of objects. A flexible application will avoid creating objects directly. By using
    a factory function, we''re assured that all parts of an application can work consistently.
    We might do something like this to support flexible schema changes:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以灵活地支持多个版本，或者我们可以使用一次性转换。为了灵活，我们必须依赖于工厂函数来创建对象的实例。一个灵活的应用程序将避免直接创建对象。通过使用工厂函数，我们可以确保应用程序的所有部分可以一致地工作。我们可能会这样做来支持灵活的模式更改：
- en: '[PRE95]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This kind of factory function requires a `_version` keyword argument to specify
    which `Blog` class definition to use. This allows us to upgrade a schema to use
    different classes without breaking our application. The `Access` layer can rely
    on this kind of function to instantiate correct versions of objects. We can also
    make a fluent factory that looks like this:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工厂函数需要一个`_version`关键字参数来指定使用哪个`Blog`类定义。这允许我们升级模式以使用不同的类，而不会破坏我们的应用程序。`Access`层可以依赖这种函数来实例化正确版本的对象。我们还可以创建一个类似这样的流畅工厂：
- en: '[PRE96]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can use this factory as follows:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下使用这个工厂：
- en: '[PRE97]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: A shelf should include the schema version information, perhaps as a special
    `__version__` key. This will provide information for an access layer to determine
    what version of a class should be used. Applications should fetch this object
    first after opening the shelf and fail quickly when the schema version is wrong.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 一个架子应该包括模式版本信息，可能作为一个特殊的`__version__`键。这将为访问层提供信息，以确定应该使用哪个类的版本。应用程序在打开架子后应该首先获取这个对象，并在模式版本错误时快速失败。
- en: An alternative to this level of flexibility is a one-time conversion. This feature
    of the application will fetch all shelved objects using their old class definition,
    convert to the new class definition, and store them back to the shelf in the new
    format. For a GUI application, this may be part of an open file or a saved file.
    For a web server, this may be a script that is run by an administrator as part
    of an application release.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种灵活性的替代方案是一次性转换。应用程序的这个特性将使用旧的类定义获取所有存储的对象，转换为新的类定义，并以新格式存储回架子。对于GUI应用程序，这可能是打开文件或保存文件的一部分。对于Web服务器，这可能是由管理员作为应用程序发布的一部分运行的脚本。
- en: Summary
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We've seen the basics of how to use the `shelve` module. This includes creating
    a shelf and designing keys to access the objects we've placed in the shelf. We've
    also seen the need for an access layer to perform the lower-level CRUD operations
    on the shelf. The idea is that we need to distinguish between the class definitions
    that are focused on our application and other administrative details that support
    persistence.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何使用`shelve`模块的基础知识。这包括创建一个架子，并设计键来访问我们放在架子上的对象。我们还看到了需要一个访问层来执行架子上的低级CRUD操作的需求。这个想法是我们需要区分专注于我们应用程序的类定义和支持持久性的其他管理细节。
- en: Design considerations and trade-offs
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: One of the strengths of the `shelve` module is allowing us to persist distinct
    items. This imposes a design burden to identify the proper granularity of the
    items. Too fine a granularity and we waste time assembling containers from their
    pieces. Too coarse a granularity and we waste time fetching and storing items
    that aren't relevant.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块的一个优点是允许我们持久化不同的项目。这给我们带来了一个设计负担，即识别项目的适当粒度。粒度太细，我们会浪费时间从它们的部分组装容器。粒度太粗，我们会浪费时间获取和存储不相关的项目。'
- en: Since a shelf requires a key, we must design appropriate keys for our objects.
    We must also manage the keys for our various objects. This means using additional
    attributes to store keys and possibly creating additional collections of keys
    to act as indices for items on the shelf.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 由于架子需要一个键，我们必须为我们的对象设计适当的键。我们还必须管理我们各种对象的键。这意味着使用额外的属性来存储键，可能创建额外的键集合来充当架子上项目的索引。
- en: A key used to access an item in a `shelve` database is like a `weakref`; it's
    an indirect reference. This means that extra processing is required to track and
    access the items from the reference. For more information on `weakref`, see [Chapter
    2](ch02.html "Chapter 2. Integrating Seamlessly with Python Basic Special Methods"),
    *Integrating Seamlessly with Python – Basic Special Methods*.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问`shelve`数据库中项目的键就像`weakref`；它是一个间接引用。这意味着需要额外的处理来跟踪和访问引用的项目。有关`weakref`的更多信息，请参见[第2章](ch02.html
    "第2章。与Python基本特殊方法无缝集成")，“与Python基本特殊方法无缝集成”。
- en: One choice for a key is to locate an attribute or combination of attributes
    that are proper primary keys and cannot be changed. Another choice is to generate
    surrogate keys that cannot be changed; this allows all other attributes to be
    changed. As `shelve` relies on `pickle` to represent the items on the shelf, we
    have a high-performance native representation of the Python objects. This reduces
    the complexity of designing classes that will be placed onto a shelf. Any Python
    object can be persisted.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键的选择是定位一个属性或属性组合，这些属性是适当的主键，不能被更改。另一个选择是生成不能被更改的代理键；这允许所有其他属性被更改。由于`shelve`依赖于`pickle`来表示架子上的项目，我们有一个高性能的Python对象的本机表示。这减少了设计将放置到架子上的类的复杂性。任何Python对象都可以被持久化。
- en: Application software layers
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用软件层
- en: 'Because of the relative sophistication available when using `shelve`, our application
    software must become more properly layered. Generally, we''ll look at software
    architectures with layers such as the following:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`shelve`时可用的相对复杂性，我们的应用软件必须更加合理地分层。通常，我们将研究具有以下层次结构的软件架构：
- en: '**Presentation layer**: The top-level user interface, either a web presentation
    or a desktop GUI.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：顶层用户界面，可以是Web演示或桌面GUI。'
- en: '**Application layer**: The internal services or controllers that make the application
    work. This could be called the processing model, different from the logical data
    model.'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：使应用程序工作的内部服务或控制器。这可以称为处理模型，与逻辑数据模型不同。'
- en: '**Business layer or** **problem domain model layer**: The objects that define
    the business domain or problem space. This is sometimes called the logical data
    model. We''ve looked at how we might model these objects, using a microblog `Blog`
    and `Post` example.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务层或** **问题域模型层**：定义业务领域或问题空间的对象。有时被称为逻辑数据模型。我们已经看过如何对这些对象建模，使用微博`Blog`和`Post`的示例。'
- en: '**Infrastructure**: It often includes several layers as well as other cross-cutting
    concerns such as logging, security, and network access.'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施**：通常包括几个层次以及其他横切关注点，如日志记录、安全性和网络访问。'
- en: '**Data access layer**. These are protocols or methods to access data objects.
    We''ve looked at designing classes to access our application objects from the
    `shelve` storage.'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问层**。这些是访问数据对象的协议或方法。我们已经研究了设计类来从`shelve`存储中访问我们的应用对象。'
- en: '**Persistence layer**. This is the physical data model as seen in file storage.
    The `shelve` module implements persistence.'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久层**。这是文件存储中看到的物理数据模型。`shelve`模块实现了持久性。'
- en: When looking at this chapter and [Chapter 11](ch11.html "Chapter 11. Storing
    and Retrieving Objects via SQLite"), *Storing and Retrieving Objects via SQLite*,
    it becomes clear that mastering object-oriented programming involves some higher-level
    design patterns. We can't simply design classes in isolation, but we need to look
    at how classes are going to be organized into larger structures. Finally, and
    most importantly, brute-force search is a terrible thing. It simply must be avoided.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看本章和[第11章](ch11.html "第11章。通过SQLite存储和检索对象")*通过SQLite存储和检索对象*时，清楚地看到，掌握面向对象编程涉及一些更高级的设计模式。我们不能简单地孤立设计类，而是需要考虑类将如何组织成更大的结构。最后，最重要的是，蛮力搜索是一件可怕的事情。必须避免。
- en: Looking forward
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: The next chapter will roughly parallel this chapter. We'll look at using SQLite
    instead of shelve for the persistence of our objects. The complexity is that a
    SQL database doesn't provide a way to store complex Python objects, leading to
    the impedance mismatch problem. We'll look at two ways to solve this problem when
    using a relational database such as SQLite.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将与本章大致平行。我们将研究使用SQLite而不是shelve来持久保存我们的对象。复杂之处在于SQL数据库没有提供存储复杂Python对象的方法，导致阻抗不匹配问题。我们将研究在使用关系数据库（如SQLite）时解决这个问题的两种方法。
- en: '[Chapter 12](ch12.html "Chapter 12. Transmitting and Sharing Objects"), *Transmitting
    and Sharing Objects*, will shift the focus from simple persistence to transmitting
    and sharing objects. This will rely on the persistence we''ve seen in this part;
    it will add network protocols to the mix.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。传输和共享对象")*传输和共享对象*将把焦点从简单的持久性转移到传输和共享对象。这将依赖于我们在本部分看到的持久性；它将在网络协议中添加。'
- en: Chapter 11. Storing and Retrieving Objects via SQLite
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。通过SQLite存储和检索对象
- en: There are many applications where we need to persist objects individually. The
    techniques we looked at in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving
    – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving - JSON, YAML, Pickle,
    CSV, and XML*, were biased towards handling a single, monolithic object. Sometimes,
    we need to persist separate, individual objects from a larger domain. We might
    be saving blog entries, blog posts, authors, and advertising in a single file
    structure.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多应用程序需要单独持久化对象。我们在[第9章](ch09.html "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")*序列化和保存
    - JSON、YAML、Pickle、CSV和XML*中所研究的技术偏向于处理单个的、整体的对象。有时，我们需要持久化来自更大领域的单独的对象。我们可能会在单个文件结构中保存博客条目、博客帖子、作者和广告。
- en: In [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve*, we looked at storing distinct Python
    objects in a `shelve` data store. This allowed us to implement the CRUD processing
    on a large domain of objects. Any individual object can be created, retrieved,
    updated, or deleted without having to load and dump the entire file.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章。通过Shelve存储和检索对象")*通过Shelve存储和检索对象*中，我们研究了在`shelve`数据存储中存储不同的Python对象。这使我们能够对大量对象实现CRUD处理。任何单个对象都可以在不加载和转储整个文件的情况下进行创建、检索、更新或删除。
- en: In this chapter, we'll look at mapping Python objects to a relational database;
    specifically, the `sqlite3` database that is bundled with Python. This will be
    another example of the **Three-Tier Architecture** design pattern**.**
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究将Python对象映射到关系数据库；具体来说，是与Python捆绑在一起的`sqlite3`数据库。这将是**三层架构**设计模式的另一个示例**。**
- en: In this case, the SQLite data tier is a more sophisticated database than Shelve.
    SQLite can allow concurrent updates via locking. SQLite offers an access layer
    based on the SQL language. It offers persistence by saving SQL tables to the filesystem.
    Web applications are one example where a database is used instead of simple file
    persistence to handle concurrent updates to a single pool of data. RESTful data
    servers, too, frequently use a relational database to provide access to persistent
    objects.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，SQLite数据层比Shelve更复杂。SQLite可以通过锁定允许并发更新。SQLite提供了基于SQL语言的访问层。它通过将SQL表保存到文件系统来实现持久性。Web应用程序是数据库用于处理对单个数据池的并发更新而不是简单文件持久性的一个例子。RESTful数据服务器也经常使用关系数据库来提供对持久对象的访问。
- en: For scalability, a standalone database server process can be used to isolate
    all the database transactions. This means that they can be allocated to one relatively
    secure host computer, separate from the Web application servers and behind appropriate
    firewalls. MySQL, for example, can be implemented as a standalone server process.
    SQLite is not a standalone database server; it must exist as part of a host application;
    for our purposes, Python is the host.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可扩展性，可以使用独立的数据库服务器进程来隔离所有数据库事务。这意味着它们可以分配给一个相对安全的主机计算机，与Web应用服务器分开，并位于适当的防火墙后面。例如，MySQL可以作为独立的服务器进程实现。SQLite不是独立的数据库服务器；它必须作为主机应用程序的一部分存在；对于我们的目的，Python是主机。
- en: SQL databases, persistence, and objects
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL数据库，持久性和对象
- en: 'When using SQLite, we will use a relational database with an access layer based
    on the SQL language. The SQL language is a legacy from an era when object-oriented
    programming was a rarity. The SQL language is heavily biased towards procedural
    programming, creating what''s termed an impedance mismatch between the relational
    model of data and the object model of data. Within SQL databases, we generally
    focus on three tiers of data modeling, which are shown here:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SQLite时，我们将使用基于SQL语言的关系数据库访问层。SQL语言是来自对象导向编程稀有时代的遗留。SQL语言在很大程度上偏向于过程式编程，从而创建了所谓的关系数据模型和对象数据模型之间的阻抗不匹配。在SQL数据库中，我们通常关注三个数据建模层，如下所示：
- en: '**Conceptual model**: These are the entities and relationships implied by the
    SQL model. In most cases, these can map to Python objects and should correspond
    with the data model layer of the application tier. This is the place where an
    **Object-Relational Mapping** layer is useful.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概念模型**：这些是由SQL模型隐含的实体和关系。在大多数情况下，这些可以映射到Python对象，并应该与应用程序层的数据模型层对应。这是**对象关系映射**层有用的地方。'
- en: '**Logical model**: These are the tables, rows, and columns that appear to be
    in the SQL database. We''ll address these entities in our SQL data manipulation
    statements. We say that these appear to exist because they''re implemented by
    a physical model that may be somewhat different from the tables, rows, and columns
    in the database schema. The results of a SQL query, for example, look table-like,
    but may not involve storage that parallels the storage of any defined table.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑模型**：这些是似乎存在于SQL数据库中的表、行和列。我们将在我们的SQL数据操作语句中处理这些实体。我们说这些似乎存在是因为它们由一个物理模型实现，这个物理模型可能与数据库模式中定义的表、行和列有些不同。例如，SQL查询的结果看起来像表，但可能不涉及与任何定义的表的存储相平行的存储。'
- en: '**Physical model**: These are the files, blocks, pages, bits, and bytes of
    persistent physical storage. These entities are defined by the administrative
    SQL statements. In some more complex database products, we can exercise some control
    over the physical model of the data to further tweak the performance. In SQLite,
    however, we have almost no control over this.'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理模型**：这些是持久物理存储的文件、块、页、位和字节。这些实体由管理SQL语句定义。在一些更复杂的数据库产品中，我们可以对数据的物理模型行使一定的控制，以进一步调整性能。然而，在SQLite中，我们几乎无法控制这一点。'
- en: 'We are confronted with a number of design decisions when using SQL databases.
    Perhaps the most important one is deciding how to cover the impedance mismatch.
    How do we handle the mapping between SQL''s legacy data model to a Python object
    model? There are three common strategies:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SQL数据库时，我们面临许多设计决策。也许最重要的一个是决定如何处理阻抗不匹配。我们如何处理SQL的传统数据模型与Python对象模型之间的映射？有三种常见的策略：
- en: '**No mapping to Python**: This means that we don''t fetch complex Python objects
    from the database but work entirely within the SQL framework of independent atomic
    data elements and processing functions. This approach will avoid a deep emphasis
    on object-oriented programming with persistent database objects. This limits us
    to the four essential SQLite types of NULL, INTEGER, REAL, and TEXT, plus the
    Python additions of `datetime.date` and `datetime.datetime`.'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不映射到Python**：这意味着我们不从数据库中获取复杂的Python对象，而是完全在独立的原子数据元素和处理函数的SQL框架内工作。这种方法将避免对持久数据库对象的面向对象编程的深度强调。这将限制我们使用四种基本的SQLite类型NULL、INTEGER、REAL和TEXT，以及Python的`datetime.date`和`datetime.datetime`的添加。'
- en: '**Manual mapping**: We define an access layer to map between our class definitions
    and the SQL logical model of tables, columns, rows, and keys.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动映射**：我们定义一个访问层，用于在我们的类定义和SQL逻辑模型之间进行映射，包括表、列、行和键。'
- en: '**ORM layer**: We download and install an ORM layer to handle the mapping between
    classes and the SQL logical model.'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ORM层**：我们下载并安装一个ORM层来处理类和SQL逻辑模型之间的映射。'
- en: We'll look at all the three choices in the following examples. Before we can
    look at the mappings from SQL to objects, we'll look at the SQL logical model
    in some detail and cover the no-mapping option in the process.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中查看所有三种选择。在我们可以查看从SQL到对象的映射之前，我们将详细查看SQL逻辑模型，并在此过程中涵盖无映射选项。
- en: The SQL data model – rows and tables
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL数据模型 - 行和表
- en: The SQL data model is based on named tables with named columns. The table contains
    multiple rows of data. Each row is vaguely like a mutable `namedtuple`. The overall
    table is like `list`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据模型基于具有命名列的命名表。表包含多行数据。每一行都有点像可变的`namedtuple`。整个表就像`list`。
- en: When we define a SQL database, we define the tables and their columns. When
    we use a SQL database, we manipulate the rows of data in the tables. In the case
    of SQLite, we have a narrow domain of data types that SQL will process. SQLite
    handles `NULL`, `INTEGER`, `REAL`, `TEXT`, and `BLOB` data. Python types `None`,
    `int`, `float`, `str`, and `bytes` are mapped to these SQL types. Similarly, when
    data of these types is fetched from a SQLite database, the items are converted
    into Python objects.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个SQL数据库时，我们定义表及其列。当我们使用SQL数据库时，我们操作表中的数据行。在SQLite的情况下，我们有一个狭窄的数据类型领域，SQL将处理这些数据类型。SQLite处理`NULL`，`INTEGER`，`REAL`，`TEXT`和`BLOB`数据。Python类型`None`，`int`，`float`，`str`和`bytes`被映射到这些SQL类型。同样，当从SQLite数据库中获取这些类型的数据时，这些项目将被转换为Python对象。
- en: We can mediate this conversion by adding even more conversion functions to SQLite.
    The `sqlite3` module adds the `datetime.date` and `datetime.datetime` extensions
    this way. We'll address this under manual mapping, which follows in the next section.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向SQLite添加更多的转换函数来调解这种转换。`sqlite3`模块以这种方式添加了`datetime.date`和`datetime.datetime`扩展。我们将在下一节中介绍手动映射。
- en: 'The SQL language can be partitioned into three sublanguages: a **data definition
    language** (**DDL**), a **data manipulation language** (**DML**), and a **data
    control language** (**DCL**). The DDL is used to define tables, their columns,
    and indices. For an example of DDL, we might have some tables defined the following
    way:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语言可以分为三个子语言：**数据定义语言**（**DDL**），**数据操作语言**（**DML**）和**数据控制语言**（**DCL**）。DDL用于定义表、它们的列和索引。例如，我们可能以以下方式定义一些表：
- en: '[PRE98]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We''ve created four tables to represent the `Blog` and `Post` objects for a
    microblogging application. For more information on the SQL language processed
    by SQLite, see [http://www.sqlite.org/lang.html](http://www.sqlite.org/lang.html).
    For a broader background in SQL, books such as *Creating your MySQL Database:
    Practical Design Tips and Techniques* will introduce the SQL language in the context
    of the MySQL database. The SQL language is case insensitive. For no good reason,
    we prefer to see SQL in all uppercase to distinguish it from the surrounding Python
    code.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建了四个表来表示微博应用程序的`Blog`和`Post`对象。有关SQLite处理的SQL语言的更多信息，请参阅[http://www.sqlite.org/lang.html](http://www.sqlite.org/lang.html)。对于SQL的更广泛背景，像*Creating
    your MySQL Database: Practical Design Tips and Techniques*这样的书籍将介绍MySQL数据库上下文中的SQL语言。SQL语言是不区分大小写的。出于没有好的理由，我们更喜欢看到SQL全部大写，以区别于周围的Python代码。'
- en: The `BLOG` table defines a primary key with the `AUTOINCREMENT` option; this
    will allow SQLite to assign the key values, saving us from having to generate
    the keys in our code. The `TITLE` column is the title for a blog. We've defined
    it to be `TEXT`. In some database products, we must provide a maximum size; this
    is not required in SQLite, so we'll avoid the clutter.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLOG`表定义了一个带有`AUTOINCREMENT`选项的主键；这将允许SQLite分配键值，使我们不必在代码中生成键。`TITLE`列是博客的标题。我们将其定义为`TEXT`。在一些数据库产品中，我们必须提供最大大小；在SQLite中，这是不需要的，所以我们将避免混乱。'
- en: The `POST` table defines a primary key as well as date, title, and RST text
    for the body of the post. Note that we did not reference the tags in this table
    definition. We'll return to the design patterns required for the following SQL
    tables. The `POST` table does, however, include a formal `REFERENCES` clause to
    show us that this is a foreign key reference to the owning `BLOG`. The `TAG` table
    defines the individual tag text items, and nothing more.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`表定义了一个主键，以及日期，标题和RST文本作为帖子正文。请注意，在此表定义中我们没有引用标签。我们将在后续SQL表所需的设计模式中返回。然而，`POST`表包括一个正式的`REFERENCES`子句，以向我们显示这是对拥有`BLOG`的外键引用。`TAG`表定义了单个标签文本项，没有其他内容。'
- en: 'Finally, we have an association table between `POST` and `TAG`. This table
    has only two foreign keys. It associates tags and posts, allowing an unlimited
    number of tags per post as well as an unlimited number of posts to share a common
    tag. This association table is a common SQL design pattern to handle this kind
    of a relationship. We''ll look at some other SQL design patterns in the following
    section. We can execute the preceding definitions to create our database:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个`POST`和`TAG`之间的关联表。这个表只有两个外键。它关联标签和帖子，允许每个帖子有无限数量的标签，以及无限数量的帖子共享一个公共标签。这种关联表是处理这种关系的常见SQL设计模式。我们将在下一节中看一些其他SQL设计模式。我们可以执行上述定义来创建我们的数据库：
- en: '[PRE99]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: All database access requires a connection, created with the module function,
    `sqlite3.connect()`. We provided the name of the file to assign to our database.
    We'll look at the additional parameters for this function in separate sections.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据库访问都需要一个连接，使用模块函数`sqlite3.connect()`创建。我们提供了要分配给我们的数据库的文件名。我们将在单独的部分中查看此函数的其他参数。
- en: The DB-API presumes that there is a separate database server process on which
    our application process is connecting. In the case of SQLite, there isn't really
    a separate process. A `connect()` function is used, however, to comply with the
    standard.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: DB-API假设我们的应用程序进程连接到一个单独的数据库服务器进程。在SQLite的情况下，实际上并没有单独的进程。但是，为了符合标准，我们使用`connect()`函数。
- en: The `sql_ddl` variable is simply a long string variable with the four `CREATE
    TABLE` statements. If there are no error messages, then it means that the table
    structures have been defined.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`sql_ddl`变量只是一个长字符串变量，其中包含四个`CREATE TABLE`语句。如果没有错误消息，那么表结构已经定义。'
- en: 'The `Connection.executescript()` method is described in the Python Standard
    Library as a *nonstandard shortcut*. Technically, database operations involve
    `cursor`. The following is a standardized approach:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection.executescript()`方法在Python标准库中被描述为*非标准快捷方式*。从技术上讲，数据库操作涉及`cursor`。以下是一种标准化的方法：'
- en: '[PRE100]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: As we're focused on SQLite, we'll use the nonstandard shortcuts heavily. If
    we were concerned about portability to other databases, we'd shift focus to a
    more strict compliance with DB-API. We'll return to the nature of a cursor object
    in the following section, when looking at queries.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们专注于SQLite，我们将大量使用非标准快捷方式。如果我们关心对其他数据库的可移植性，我们将把重点转移到更严格地遵守DB-API。在下一节中，当查看查询时，我们将回到游标对象的性质。
- en: CRUD processing via SQL DML statements
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过SQL DML语句进行CRUD处理
- en: 'The following four canonical CRUD operations map directly to SQL language statements:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四个经典的CRUD操作直接映射到SQL语句：
- en: The creation is done via the `INSERT` statement
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建是通过`INSERT`语句完成的
- en: The Retrieval is done via the `SELECT` statement
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索是通过`SELECT`语句完成的
- en: The Updates is done via the `UPDATE` statement as well as the `REPLACE` statement,
    when it's supported
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新是通过`UPDATE`语句以及`REPLACE`语句（如果支持）来完成的
- en: The deletion is done via the `DELETE` statement
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除是通过`DELETE`语句完成的。
- en: We have to note that there's a literal SQL syntax, and syntax with binding variable
    placeholders instead of literal values. The literal SQL syntax is acceptable for
    scripts; however, because the values are always literal, it is perfectly awful
    for application programming. Building literal SQL statements in an application
    involves endless string manipulation and famous security problems. See [http://xkcd.com/327/](http://xkcd.com/327/)
    for a specific security issue with assembling literal SQL. We'll focus exclusively
    on SQL with binding variables.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意，有一种字面的SQL语法，以及带有绑定变量占位符而不是字面值的语法。字面的SQL语法适用于脚本；然而，因为值始终是字面的，它对应用程序编程来说非常糟糕。在应用程序中构建字面的SQL语句涉及无休止的字符串操作和著名的安全问题。请参阅[http://xkcd.com/327/](http://xkcd.com/327/)，了解组装字面SQL的特定安全问题。我们将专注于带有绑定变量的SQL。
- en: Literal SQL is widely used, which is a mistake.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 字面SQL被广泛使用，这是一个错误。
- en: Note
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Never build literal SQL DML statements with string manipulation.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用字符串操作构建字面的SQL DML语句。
- en: The Python DB-API interface, **Python Enhancement Proposal** (**PEP**) 249,
    [http://www.python.org/dev/peps/pep-0249/](http://www.python.org/dev/peps/pep-0249/),
    defines several ways to bind application variables into SQL statements. SQLite
    can use positional bindings with `?` or named bindings with `:name`. We'll show
    you both styles of binding variables.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: Python DB-API接口，**Python Enhancement Proposal**（**PEP**）249，[http://www.python.org/dev/peps/pep-0249/](http://www.python.org/dev/peps/pep-0249/)，定义了将应用程序变量绑定到SQL语句中的几种方法。SQLite可以使用带有`?`的位置绑定或带有`:name`的命名绑定。我们将向您展示这两种绑定变量的样式。
- en: 'We use an `INSERT` statement to create a new `BLOG` row as shown in the following
    code snippet:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`INSERT`语句来创建一个新的`BLOG`行，如下面的代码片段所示：
- en: '[PRE101]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We created a SQL statement with a positional bind variable, `?`, for the `TITLE`
    column of the `BLOG` table. We then execute that statement after binding a tuple
    of values to the bind variables. There's only one bind variable, so there's only
    one value in the tuple. Once the statement has been executed, we have a row in
    the database.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个带有位置绑定变量`?`的SQL语句，用于`BLOG`表的`TITLE`列。然后，在将一组值绑定到绑定变量后，执行该语句。只有一个绑定变量，所以元组中只有一个值。执行完语句后，数据库中就有一行数据。
- en: We show the SQL statements clearly separated from the surrounding Python code
    in triple-quoted long string literals. In some applications, the SQL is stored
    as a separate configuration item. Keeping SQL separate is best handled as a mapping
    from a statement name to the SQL text. We could, for example, keep the SQL in
    a JSON file. This means we can use `SQL=json.load("sql_config.json")` to fetch
    all SQL statements. We can then use `SQL["some statement name"]` to refer to the
    text of a particular SQL statement. This can simplify application maintenance
    by keeping the SQL out of the Python programming.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清楚地将SQL语句与周围的Python代码分开，使用三引号的长字符串文字。在一些应用程序中，SQL被存储为单独的配置项。将SQL保持分开最好是作为从语句名称到SQL文本的映射来处理。例如，我们可以将SQL保存在JSON文件中。这意味着我们可以使用`SQL=json.load("sql_config.json")`来获取所有SQL语句。然后，我们可以使用`SQL["some
    statement name"]`来引用特定SQL语句的文本。这可以通过将SQL从Python编程中分离出来，简化应用程序的维护。
- en: 'The `DELETE` and `UPDATE` statements require a `WHERE` clause to specify which
    rows will be changed or removed. To change a blog''s title, we might do something
    as follows:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`和`UPDATE`语句需要`WHERE`子句来指定将更改或删除哪些行。要更改博客的标题，我们可以这样做：'
- en: '[PRE102]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `UPDATE` statement has two named bind variables: `:new_title` and `:old_title`.
    This transaction will update all the rows in the `BLOG` table that have the given
    old title, setting the title to the new title. Ideally, the title is unique, and
    only a single row is touched. SQL operations are defined to work on sets of rows.
    It''s a matter of database design to ensure that a desired row is the content
    of a set. Hence, the suggestion is to have a unique primary key for every table.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE`语句有两个命名绑定变量：`:new_title`和`:old_title`。此事务将更新`BLOG`表中具有给定旧标题的所有行，将标题设置为新标题。理想情况下，标题是唯一的，只有一个行受到影响。SQL操作被定义为对一组行进行操作。确保所需行是集合的内容是数据库设计的问题。因此，建议为每个表设置唯一的主键。'
- en: 'When implementing a delete operation, we always have two choices. We can either
    prohibit deletes of a parent when children still exist, or we can cascade the
    deletion of a parent to also delete the relevant children. We''ll look at a cascading
    delete of `Blog`, `Post`, and tag associations. Here''s a `DELETE` sequence of
    statements:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现删除操作时，我们总是有两种选择。我们可以在子项仍然存在时禁止删除父项，或者我们可以级联删除父项以同时删除相关的子项。我们将看一下`Blog`，`Post`和标签关联的级联删除。以下是`DELETE`语句的序列：
- en: '[PRE103]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We've done a three-step delete operation. First, we deleted all the rows from
    `ASSOC_POST_TAG` for a given `Blog` based on the title. Note the nested query;
    we'll look at queries in the next section. Navigation among tables is a common
    issue with SQL construction. In this case, we have to query the `BLOG-POST` relationship
    to locate the `POST` IDs that will be removed; then, we can remove rows from `ASSOC_POST_TAG`
    for the posts associated with a blog that will be removed. Next, we deleted all
    the posts belonging to a particular blog. This too involves a nested query to
    locate the IDs of the blog based on the title. Finally, we can delete the blog
    itself.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了一个三步删除操作。首先，我们根据标题从给定的`Blog`中删除了`ASSOC_POST_TAG`的所有行。注意嵌套查询；我们将在下一节中讨论查询。在SQL构造中，表之间的导航是一个常见的问题。在这种情况下，我们必须查询`BLOG-POST`关系以定位将被移除的`POST`
    ID；然后，我们可以删除与将被移除的博客相关联的帖子的`ASSOC_POST_TAG`行。接下来，我们删除了属于特定博客的所有帖子。这也涉及到一个嵌套查询，以定位基于标题的博客的ID。最后，我们可以删除博客本身。
- en: This is an example of an explicit cascade delete design, where we have to cascade
    the operation from the `BLOG` table to two other tables. We wrapped the entire
    suite of deletes in a `with` context so that it would all commit as a single transaction.
    In the event of failure, it would roll back the partial changes, leaving the database
    as it was.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显式级联删除设计的示例，我们需要将操作从`BLOG`表级联到另外两个表。我们将所有删除操作包装在`with`上下文中，以便它作为一个单独的事务提交。在失败的情况下，它将回滚部分更改，使数据库保持原样。
- en: Querying rows with the SQL SELECT statement
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SQL SELECT语句查询行
- en: It's possible to write a substantial book on the `SELECT` statement alone. We'll
    skip all but the most fundamental features of `SELECT`. Our purpose is to cover
    just enough SQL to store and retrieve objects from a database.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 单单关于`SELECT`语句就可以写一本大部头的书。我们将跳过除了`SELECT`最基本的特性之外的所有内容。我们的目的是只涵盖足够的SQL来存储和检索数据库中的对象。
- en: Previously, we mentioned that, technically, we're supposed to use a cursor when
    executing SQL statements. For DDL and other DML statements, the presence or absence
    of a cursor doesn't matter very much. We'll use the explicit creation of the cursor
    because it greatly simplifies SQL programming.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到，从技术上讲，在执行SQL语句时，我们应该使用游标。对于DDL和其他DML语句，游标的存在与否并不太重要。我们将使用显式创建游标，因为它极大地简化了SQL编程。
- en: 'For a query, however, the cursor is essential for retrieving the rows from
    the database. To locate a blog by title, we can start with something as simple
    as the following code:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于查询来说，游标对于从数据库中检索行是必不可少的。要通过标题查找博客，我们可以从以下简单的代码开始：
- en: '[PRE104]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We need to fetch the resulting collection of row objects. Even when we're expecting
    one row as a response, in the SQL world, everything is a collection. Generally,
    every result set from a `SELECT` query looks like a table with rows and columns
    defined by the `SELECT` statement instead of any `CREATE TABLE` DDL.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要获取结果行对象的集合。即使我们期望作为响应的是一行，但在SQL世界中，一切都是一个集合。通常，从`SELECT`查询的每个结果集看起来都像是由`SELECT`语句定义的行和列的表，而不是任何`CREATE
    TABLE` DDL。
- en: 'In this case, using `SELECT *` means we''ve avoided enumerating the expected
    result columns. This might lead to a large number of columns being retrieved.
    Here''s a common optimization for doing this using the SQLite shortcuts:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用`SELECT *`意味着我们避免了枚举预期结果列。这可能导致检索到大量列。以下是使用SQLite快捷方式进行此操作的常见优化：
- en: '[PRE105]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In the `SELECT` statement, the `*` is shorthand for all the available columns.
    It's only really useful for simple queries that involve a single table.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SELECT`语句中，`*`是所有可用列的简写。它只对涉及单个表的简单查询真正有用。
- en: We've bound the requested blog title to the "`?`" parameter in the `SELECT`
    statement. The result of the `execute()` function is a cursor object. A cursor
    is iterable; it will yield all the rows in the result set and all the rows that
    match the selection criteria in the `WHERE` clause.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将请求的博客标题绑定到`SELECT`语句中的"`?`"参数。`execute()`函数的结果是一个游标对象。游标是可迭代的；它将产生结果集中的所有行和匹配`WHERE`子句中选择条件的所有行。
- en: 'To be fully compliant with the Python DB-API standard, we could break it down
    into the following steps:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全符合Python DB-API标准，我们可以将其分解为以下步骤：
- en: '[PRE106]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This shows us how we use the connection to create a cursor object. We can then
    execute a query statement using the cursor object. Once we've executed the query,
    we can fetch all the rows in the result set. Each row will be a tuple of the values
    from the `SELECT` clause. In this case, as the `SELECT` clause is `*`, it means
    that all the columns from the original `CREATE TABLE` statement will be used.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了如何使用连接来创建一个游标对象。然后我们可以使用游标对象执行查询语句。一旦我们执行了查询，我们就可以获取结果集中的所有行。每一行都将是来自`SELECT`子句的值的元组。在这种情况下，由于`SELECT`子句是`*`，这意味着将使用原始`CREATE
    TABLE`语句中的所有列。
- en: SQL transactions and the ACID properties
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL事务和ACID属性
- en: As we've seen, the SQL DML statements map to the CRUD operations. When discussing
    the features of the SQL transactions, we'll be looking at the sequences of the
    `INSERT`, `SELECT`, `UPDATE`, and `DELETE` statements.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，SQL DML语句映射到CRUD操作。在讨论SQL事务的特性时，我们将看到`INSERT`、`SELECT`、`UPDATE`和`DELETE`语句的序列。
- en: The SQL DML statements all work within the context of a SQL transaction. The
    SQL statements executed within a transaction are a logical unit of work. The entire
    transaction can be committed as a whole or rolled back as a whole. This supports
    the Atomicity property.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: SQL DML语句都在SQL事务的上下文中工作。在事务中执行的SQL语句是一个逻辑工作单元。整个事务可以作为一个整体提交，或者作为一个整体回滚。这支持原子性属性。
- en: SQL DDL statements (that is, `CREATE`, `DROP`) do not work within a transaction.
    They implicitly end any previous in-process transaction. After all, they're changing
    the structure of the database; they're a different kind of statement, and the
    transaction concept doesn't apply.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: SQL DDL语句（即`CREATE`，`DROP`）不能在事务中工作。它们隐式结束了任何先前的正在进行的事务。毕竟，它们正在改变数据库的结构；它们是一种不同类型的语句，事务概念不适用。
- en: The ACID properties are Atomic, Consistent, Isolated, and Durable. These are
    essential features of a transaction that consists of multiple database operations.
    For more information, see [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving
    Objects via Shelve"), *Storing and Retrieving Objects via Shelve*.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: ACID属性是原子性、一致性、隔离性和持久性。这些是由多个数据库操作组成的事务的基本特性。有关更多信息，请参见[第10章](ch10.html "第10章。通过Shelve存储和检索对象")*通过Shelve存储和检索对象*。
- en: Unless working in a special **read uncommitted** mode, each connection to the
    database sees a consistent version of the data containing only the results of
    the committed transactions. Uncommitted transactions are generally invisible to
    other database client processes, supporting the Consistency property.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在特殊的**读取未提交**模式下工作，否则对数据库的每个连接都只能看到包含已提交事务结果的一致版本的数据。未提交的事务通常对其他数据库客户端进程不可见，支持一致性属性。
- en: A SQL transaction also supports the Isolation property. SQLite supports several
    different **isolation level** settings. The isolation level defines how the SQL
    DML statements interact among multiple, concurrent processes. This is based on
    how locks are used and how a processes' SQL requests are delayed waiting for locks.
    From Python, the isolation level is set when the connection is made to the database.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: SQL事务还支持隔离属性。SQLite支持几种不同的**隔离级别**设置。隔离级别定义了SQL DML语句在多个并发进程中的交互方式。这是基于锁的使用方式以及进程的SQL请求等待锁的方式。从Python中，隔离级别在连接到数据库时设置。
- en: Each SQL database product takes a different approach to the isolation level
    and locking. There's no single model.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SQL数据库产品对隔离级别和锁定采取不同的方法。没有单一的模型。
- en: 'In the case of SQLite, there are four isolation levels that define the locking
    and the nature of transactions. For details, see [http://www.sqlite.org/isolation.html](http://www.sqlite.org/isolation.html).
    Here are the isolation levels:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite的情况下，有四个隔离级别定义了锁定和事务的性质。有关详细信息，请参见[http://www.sqlite.org/isolation.html](http://www.sqlite.org/isolation.html)。以下是隔离级别：
- en: '`isolation_level=None`: This is the default, otherwise known as the **autocommit**
    mode. In this mode, each individual SQL statement is committed to the database
    as it''s executed. This breaks Atomicity unless, by some weird quirk, all of the
    transactions happen to involve only a single SQL statement.'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isolation_level=None`：这是默认值，也称为**自动提交**模式。在这种模式下，每个单独的SQL语句在执行时都会提交到数据库。这会破坏原子性，除非出现一些奇怪的巧合，所有事务都只涉及单个SQL语句。'
- en: '`isolation_level=''DEFERRED''`: In this mode, locks are acquired as late as
    possible in the transaction. The `BEGIN` statement, for example, does not immediately
    acquire any locks. Other read operations (that is, the `SELECT` statements) will
    acquire shared locks. Write operations will acquire reserved locks. While this
    can maximize the concurrency, it can also lead to deadlocks among competing processes.'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isolation_level=''DEFERRED''`：在这种模式下，锁在事务中尽可能晚地获取。例如，`BEGIN`语句不会立即获取任何锁。其他读操作（即`SELECT`语句）将获取共享锁。写操作将获取保留锁。虽然这可以最大程度地提高并发性，但也可能导致竞争进程之间的死锁。'
- en: '`isolation_level=''IMMEDIATE''`: In this mode, the transaction `BEGIN` statement
    acquires a lock that prevents all writes. Reads, however, will continue normally.'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isolation_level=''IMMEDIATE''`：在这种模式下，事务`BEGIN`语句获取一个阻止所有写入的锁。但读取将继续进行。'
- en: '`isolation_level=''EXCLUSIVE''`: In this mode, the transaction `BEGIN` statement
    acquires a lock that prevents almost all access. There''s an exception for connections
    in a special read uncommitted mode that ignores locking.'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isolation_level=''EXCLUSIVE''`：在这种模式下，事务`BEGIN`语句获取一个阻止几乎所有访问的锁。对于处于特殊读取未提交模式的连接，它们忽略锁定有一个例外。'
- en: The Durability property is guaranteed for all committed transactions. The data
    is written to the database file.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有已提交的事务，持久性属性是得到保证的。数据被写入数据库文件。
- en: 'The SQL rules require us to execute `BEGIN TRANSACTION` and `COMMIT TRANSACTION`
    statements to bracket a sequence of steps. In the event of an error, a `ROLLBACK
    TRANSACTION` statement is required to unwind the potential changes. The Python
    interface simplifies this. We can execute a `BEGIN` statement. The other statements
    are provided as functions of the `sqlite3.Connection` object; we don''t execute
    SQL statements to end a transaction. We might write things such as the following
    code to be explicit:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: SQL规则要求我们执行`BEGIN TRANSACTION`和`COMMIT TRANSACTION`语句来框定一系列步骤。在出现错误的情况下，需要执行`ROLLBACK
    TRANSACTION`语句来撤销潜在的更改。Python接口简化了这一过程。我们可以执行`BEGIN`语句。其他语句作为`sqlite3.Connection`对象的函数提供；我们不执行SQL语句来结束事务。我们可能会编写诸如以下代码来明确表示：
- en: '[PRE107]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We selected an isolation level of `DEFERRED` when we made the database connection.
    This leads to a requirement that we explicitly begin and end each transaction.
    One typical scenario is to wrap the relevant DML in a `try` block and commit the
    transaction if things worked, or roll back the transaction in the case of a problem.
    We can simplify this by using the `sqlite3.Connection` object as a context manager:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在建立数据库连接时选择了`DEFERRED`的隔离级别。这导致我们需要明确开始和结束每个事务。一个典型的场景是将相关的DML包装在`try`块中，如果事情顺利，则提交事务，或者在出现问题的情况下回滚事务。我们可以通过使用`sqlite3.Connection`对象作为上下文管理器来简化这个过程：
- en: '[PRE108]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This is similar to the previous example. We opened the database in the same
    way. Rather than executing an explicit `BEGIN` statement, we entered a context;
    the context handles `Begin` for us.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这与先前的例子类似。我们以相同的方式打开了数据库。我们没有执行显式的`BEGIN`语句，而是进入了一个上下文；上下文为我们处理了`Begin`。
- en: At the end of the `with` context, `database.commit()` will be done automatically.
    In the event of an exception, a `database.rollback()` will be done, and the exception
    will be raised by the `with` statement.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`上下文的末尾，`database.commit()`将自动完成。在发生异常时，将执行`database.rollback()`，并且异常将由`with`语句引发。
- en: Designing primary and foreign database keys
  id: totrans-712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计主键和外键
- en: SQL tables don't specifically require a primary key. However, it's a rather
    poor design that omits primary keys for the rows of a given table. As we noted
    in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve*, there might be an attribute (or a
    combination of attributes) that makes a proper primary key. It's also entirely
    possible that no attribute is suitable as a primary key and we must define surrogate
    keys.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: SQL表不需要特定的主键。然而，对于给定表的行，省略主键是相当糟糕的设计。正如我们在[第10章](ch10.html "第10章。通过Shelve存储和检索对象")中所指出的，*通过Shelve存储和检索对象*，可能有一个属性（或属性的组合）可以成为适当的主键。也完全有可能没有属性适合作为主键，我们必须定义代理键。
- en: The previous examples use surrogate keys created by SQLite. This is perhaps
    the simplest kind of design because it imposes the fewest constraints on the data.
    One kind of constraint is that a primary key cannot be updated; this becomes a
    rule that the application programming must enforce. In some cases—for example,
    when correcting an error in the primary key value—we need to somehow update the
    primary key. One way to do this is to drop and recreate the constraints. Another
    way to do this is to delete the faulty row and reinsert the row with the corrected
    key. When there are cascading deletes, then the transaction required to correct
    a primary key can become very complex. Using a surrogate key prevents these kinds
    of problems.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用了SQLite创建的代理键。这可能是最简单的设计，因为它对数据施加了最少的约束。一个约束是主键不能被更新；这成为应用程序编程必须强制执行的规则。在某些情况下，例如在主键值中纠正错误时，我们需要以某种方式更新主键。做到这一点的一种方法是删除并重新创建约束。另一种方法是删除有错误的行，并重新插入具有更正键的行。当存在级联删除时，用于纠正主键的事务可能变得非常复杂。使用代理键可以防止这类问题。
- en: 'All relationships among tables are done via the primary keys and foreign key
    references. There are two extremely common design patterns for relationships.
    The preceding tables show us these two principle design patterns. There are three
    design patterns for relationships, shown in the following bullet list:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 所有表之间的关系都是通过主键和外键引用来完成的。关系有两种极为常见的设计模式。前面的表向我们展示了这两种主要的设计模式。关系有三种设计模式，如下符号列表所示：
- en: '**One-to-many**: This relationship is between one parent blog and many child
    posts. The `REFERENCES` clause shows us that many rows in the `POST` table will
    reference one row from the `BLOG` table. If viewed from the direction of child
    to parent, it would be called a **Many-to-One** relationship.'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对多：这种关系是一个父博客和许多子帖子之间的关系。“REFERENCES”子句向我们展示了“POST”表中的许多行将引用“BLOG”表中的一行。如果从子到父的方向来看，它将被称为多对一关系。
- en: '**Many-to-many**: This relationship is between many posts and many tags. This
    requires an intermediate association table between the `POST` and `TAG` tables;
    the intermediate table has two (or more) foreign keys. The many-to-many association
    table can also have attributes of its own.'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多：这种关系是许多帖子和许多标签之间的关系。这需要在“POST”和“TAG”表之间有一个中间关联表；中间表有两个（或更多）外键。多对多关联表也可以有自己的属性。
- en: '**One-to-one**: This relationship is a less common design pattern. There''s
    no technical difference from a one-to-many relationship; the cardinality of either
    zero rows or one row is a constraint that the application program must manage.'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一：这种关系是一种较少见的设计模式。与一对多关系没有技术上的区别；零行或一行的基数是应用程序必须管理的约束。
- en: 'In a database design, there might be constraints on the relationships: the
    relationship might be described as optional or mandatory; there might be cardinality
    limits on the relationship. Sometimes, these optionality and cardinality constraints
    are summarized with short descriptions such as "0:m" meaning "zero to many" or
    "optional one to many". The optionality and cardinality constraints are part of
    the application programming logic; there are no formal ways to state these constraints
    in the SQLite database. The essential table relationships can be implemented in
    the database in either or both of the following ways:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库设计中，关系可能会有约束：关系可能被描述为可选或强制性；关系可能有基数限制。有时，这些可选性和基数约束会用简短的描述来总结，比如“0:m”表示“零到多个”或“可选的一对多”。可选性和基数约束是应用程序编程逻辑的一部分；在SQLite数据库中没有正式的方法来说明这些约束。基本表关系可以以以下一种或两种方式在数据库中实现：
- en: '**Explicit**: We could call these declared, as they''re part of the DDL declaration
    for a database. Ideally, they''re enforced by the database server, and failure
    to comply with the relationship''s constraints can lead to an error of some kind.
    These relationships will also be repeated in queries.'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式：我们可以称这些为声明，因为它们是数据库的DDL声明的一部分。理想情况下，它们由数据库服务器强制执行，不遵守关系约束可能会导致某种错误。这些关系也将在查询中重复。
- en: '**Implicit**: These are relationships that are stated only in queries; they
    are not a formal part of the DDL.'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式：这些关系仅在查询中说明；它们不是DDL的正式部分。
- en: Note that our table definitions implemented a one-to-many relationship between
    a blog and the various entries within that blog. We've made use of these relationships
    in the various queries that we wrote.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的表定义实现了博客和该博客中各个条目之间的一对多关系。我们在编写的各种查询中使用了这些关系。
- en: Processing application data with SQL
  id: totrans-723
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQL处理应用程序数据
- en: 'The examples in the previous sections show us what we can call **procedural**
    SQL processing. We''ve eschewed any object-oriented design from our problem domain
    objects. Rather than working with the `Blog` and `Post` objects, we''re working
    with the data elements that SQLite can process: string, date, float, and integer
    values. We''ve used mostly procedural-style programming.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节中的示例向我们展示了我们可以称之为**过程式**SQL处理。我们避免了从问题域对象中使用任何面向对象的设计。我们不是使用`Blog`和`Post`对象，而是使用SQLite可以处理的数据元素：字符串、日期、浮点数和整数值。我们主要使用了过程式风格的编程。
- en: 'We can see that a series of queries can be done to locate a blog, all posts
    that are part of the blog, and all tags that are associated with a post associated
    with a blog. The processing would look like the following code:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一系列查询可以用来定位一个博客，所有属于该博客的帖子，以及与与博客相关联的帖子相关联的所有标签。处理看起来像下面的代码：
- en: '[PRE109]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: We defined three SQL queries. The first will fetch the blogs by the title. For
    each blog, we fetched all the posts that belong to this blog. Finally, we fetched
    all tags that are associated with a given post.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个SQL查询。第一个将按标题获取博客。对于每个博客，我们获取属于该博客的所有帖子。最后，我们获取与给定帖子相关联的所有标签。
- en: The second query implicitly repeats the `REFERENCES` definition between the
    `POST` table and the `BLOG` table. We're finding child posts of a specific blog
    parent; we need to repeat some of the table definitions during the query.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询隐含地重复了`POST`表和`BLOG`表之间的`REFERENCES`定义。我们正在查找特定博客父级的子帖子；我们需要在查询过程中重复一些表定义。
- en: The third query involves a relational join between rows of the `ASSOC_POST_TAG`
    table and the `TAG` table. The `JOIN` clause recapitulates the foreign key reference
    in the table definitions. The `WHERE` clause also repeats a `REFERENCES` clause
    in the table definitions.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个查询涉及`ASSOC_POST_TAG`表的行和`TAG`表之间的关系连接。`JOIN`子句重述了表定义中的外键引用。`WHERE`子句也重复了表定义中的`REFERENCES`子句。
- en: Because multiple tables were joined in the third query, using `SELECT *` will
    produce columns from all of the tables. We're really only interested in attributes
    of the `TAG` table, so we use `SELECT TAG.*` to produce only the desired columns.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第三个查询中连接了多个表，使用`SELECT *`将产生所有表的列。我们实际上只对`TAG`表的属性感兴趣，所以我们使用`SELECT TAG.*`只产生所需的列。
- en: These queries provide us with all of the individual bits and pieces of the data.
    However, these queries don't reconstruct Python objects for us. If we have more
    complex class definitions, we have to build objects from the individual pieces
    of data that we retrieved. In particular, if our Python class definitions have
    important method functions, we'll need a better SQL to Python mapping to make
    use of more complete Python class definitions.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询为我们提供了数据的所有单独的部分。然而，这些查询并没有为我们重建Python对象。如果我们有更复杂的类定义，我们必须从检索到的单个数据片段构建对象。特别是，如果我们的Python类定义有重要的方法函数，我们需要更好的SQL到Python映射来利用更完整的Python类定义。
- en: Implementing class-like processing in pure SQL
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在纯SQL中实现类似类的处理
- en: 'Let''s look at a somewhat more complex definition of a `Blog` class. This definition
    is repeated from [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV,
    and XML*; we''ve highlighted a method function that''s of interest:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的`Blog`类的定义。这个定义是从[第9章](ch09.html "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")中重复的，我们突出显示了一个感兴趣的方法函数：
- en: '[PRE110]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `Blog.by_tag()` feature of a blog will become a rather complex SQL query.
    As object-oriented programming, it simply iterates through a collection of `Post`
    instances, creating `defaultdict`, which maps each tag to a sequence of `Posts`
    that share that tag. Here''s a SQL query that produces similar results:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 博客的`Blog.by_tag()`功能将成为一个相当复杂的SQL查询。作为面向对象的编程，它只是遍历`Post`实例的集合，创建`defaultdict`，将每个标签映射到共享该标签的`Posts`序列。以下是一个产生类似结果的SQL查询：
- en: '[PRE111]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This query''s result set is a table-like sequence of rows with three attributes:
    `TAG.PHRASE`, `POST.TITLE`, and `POST.ID`. Each `POST` title and the `POST` ID
    will be repeated with all of the associated `TAG` phrases. To turn this into a
    simple-looking, HTML-friendly index, we need to group all the rows with the same
    `TAG.PHRASE` into a subsidiary list, as shown in the following code:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的结果集是一个类似表的行序列，有三个属性：`TAG.PHRASE`、`POST.TITLE`和`POST.ID`。每个`POST`标题和`POST`
    ID都将与所有相关的`TAG`短语重复。为了将其转换为一个简单的、HTML友好的索引，我们需要将所有具有相同`TAG.PHRASE`的行分组到一个辅助列表中，如下面的代码所示：
- en: '[PRE112]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This additional processing would group two-tuples of the `POST` title and the
    `POST` ID into a useful structure that can be used to produce the RST and HTML
    output. The SQL query plus associated Python processing is quite long—longer than
    the native object-oriented Python.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 这个额外的处理将`POST`标题和`POST` ID的两元组分组成一个有用的结构，可以用来生成RST和HTML输出。SQL查询加上相关的Python处理非常长
    - 比本地面向对象的Python更长。
- en: More importantly, the SQL query is dissociated from the table definition. SQL
    is not an object-oriented programming language. There's no tidy class to bundle
    data and processing together. Using procedural programming with SQL like this
    has effectively turned off object-oriented programming. From a strictly object-oriented
    programming perspective, we can label this "EPIC FAIL".
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，SQL查询与表定义是分离的。SQL不是一种面向对象的编程语言。没有整洁的类来捆绑数据和处理在一起。像这样使用SQL的过程式编程有效地关闭了面向对象的编程。从严格的面向对象编程的角度来看，我们可以将其标记为“失败”。
- en: There is a school of thought that suggests that this kind of SQL-heavy, object-free
    programming is more appropriate for certain kinds of problems than Python. Often,
    these kinds of problems involve the SQL `GROUP BY` clause. While it is convenient
    in SQL, it is also implemented very effectively by Python's `defaultdict` and
    `Counter`. The Python version is often so effective that a small program that
    queries lots of rows using a `defaultdict` might be faster than a database server
    doing SQL with `GROUP BY`. When in doubt, measure. When exhorted by database administrators
    that SQL is magically faster, measure.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种观点认为，这种SQL-heavy、无对象编程对于某些问题比Python更合适。通常，这些问题涉及SQL的`GROUP BY`子句。虽然在SQL中很方便，但Python的`defaultdict`和`Counter`也实现得非常有效。Python版本通常如此有效，以至于使用`defaultdict`查询大量行的小程序可能比使用`GROUP
    BY`的数据库服务器更快。如果有疑问，请测量。当数据库管理员力主SQL魔法般更快时，请测量。
- en: Mapping Python objects to SQLite BLOB columns
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Python对象映射到SQLite BLOB列
- en: We can map SQL columns to class definitions so that we can create proper Python
    object instances from data in a database. SQLite includes a **Binary Large Object**
    (**BLOB**) data type. We can pickle our Python objects and store them in the BLOB
    columns. We can work out a string representation of our Python objects (for example,
    using the JSON or YAML notation) and use SQLite text columns too.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将SQL列映射到类定义，以便我们可以从数据库中的数据创建适当的Python对象实例。SQLite包括一个**二进制大对象**（**BLOB**）数据类型。我们可以将我们的Python对象进行pickle并将其存储在BLOB列中。我们可以计算出我们的Python对象的字符串表示（例如，使用JSON或YAML表示法）并使用SQLite文本列。
- en: This technique must be used cautiously because it effectively defeats SQL processing.
    A BLOB column cannot be used for SQL DML operations. We can't index it or use
    it in the search criteria of DML statements.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术必须谨慎使用，因为它实际上破坏了SQL处理。BLOB列不能用于SQL DML操作。我们不能对其进行索引或在DML语句的搜索条件中使用它。
- en: SQLite BLOB mapping should be reserved for objects where it's acceptable to
    be opaque to the surrounding SQL processing. The most common examples are media
    objects such as videos, still images, or sound clips. SQL is biased towards text
    and numeric fields. It doesn't generally handle more complex objects.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite BLOB映射应该保留给那些可以对周围SQL处理不透明的对象。最常见的例子是媒体对象，如视频、静态图像或声音片段。SQL偏向于文本和数字字段。它通常不处理更复杂的对象。
- en: If we're working with financial data, our application should use the `decimal.Decimal`
    values. We might want to query or calculate in SQL using this kind of data. As
    `decimal.Decimal` is not directly supported by SQLite, we need to extend SQLite
    to handle values of this type.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理财务数据，我们的应用程序应该使用`decimal.Decimal`值。我们可能希望使用这种数据在SQL中进行查询或计算。由于`decimal.Decimal`不受SQLite直接支持，我们需要扩展SQLite以处理这种类型的值。
- en: 'There are two directions to this: conversion and adaptation. We need to **adapt**
    Python data to SQLite, and we need to **convert** SQLite data back to Python.
    Here are two functions and the requests to register them:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个方向：转换和适应。我们需要**适应**Python数据到SQLite，我们需要**转换**SQLite数据回到Python。以下是两个函数和注册它们的请求：
- en: '[PRE113]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We've written an `adapt_currency()` function that will adapt `decimal.Decimal`
    objects into a suitable form for the database. In this case, we've done nothing
    more than a simple conversion to a string. We've registered the adapter function
    so that SQLite's interface can convert objects of class `decimal.Decimal` using
    the registered adapter function.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个`adapt_currency()`函数，它将`decimal.Decimal`对象调整为适合数据库的形式。在这种情况下，我们只是简单地将其转换为字符串。我们注册了适配器函数，以便SQLite的接口可以使用注册的适配器函数转换`decimal.Decimal`类的对象。
- en: We've also written a `convert_currency()` function that will convert SQLite
    bytes objects into the Python `decimal.Decimal` objects. We've registered the
    `converter` function so that columns of the `DECIMAL` type will be properly converted
    to Python objects.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还编写了一个`convert_currency()`函数，它将SQLite字节对象转换为Python的`decimal.Decimal`对象。我们注册了`converter`函数，以便`DECIMAL`类型的列将被正确转换为Python对象。
- en: 'Once we''ve defined the adapters and converters, we can use `DECIMAL` as a
    fully supported column type. For this to work properly, we must inform SQLite
    by setting `detect_types=sqlite3.PARSE_DECLTYPES` when making the database connection.
    Here''s a table definition that uses our new column data type:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了适配器和转换器，我们就可以将`DECIMAL`作为一个完全支持的列类型。为了使其正常工作，我们必须通过在建立数据库连接时设置`detect_types=sqlite3.PARSE_DECLTYPES`来通知SQLite。以下是使用我们的新列数据类型的表定义：
- en: '[PRE114]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We can use our new column definition like this:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用我们的新列定义：
- en: '[PRE115]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: We created a database connection that requires declared types to be mapped via
    a converter function. Once we have the connection, we can create our table using
    a new `DECIMAL` column type.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个需要通过转换器函数映射声明类型的数据库连接。一旦我们有了连接，我们可以使用新的`DECIMAL`列类型创建我们的表。
- en: 'When we insert rows into the table, we use proper `decimal.Decimal` objects.
    When we fetch rows from the table, we''ll see that we get proper `decimal.Decimal`
    objects back from the database. The following is the output:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向表中插入行时，我们使用适当的`decimal.Decimal`对象。当我们从表中获取行时，我们会发现我们从数据库中得到了适当的`decimal.Decimal`对象。以下是输出：
- en: '[PRE116]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This shows us that our `decimal.Decimal` objects were properly stored and recovered
    from the database. We can write adapters and converters for any Python class.
    We need to invent a proper byte representation. As a string is so easily transformed
    into bytes, creating a string is often the simplest way to proceed.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们表明我们的`decimal.Decimal`对象已经被正确存储和从数据库中恢复。我们可以为任何Python类编写适配器和转换器。我们需要发明适当的字节表示。由于字符串很容易转换为字节，创建字符串通常是最简单的方法。
- en: Mapping Python objects to database rows manually
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动将Python对象映射到数据库行
- en: We can map SQL rows to class definitions so that we can create proper Python
    object instances from the data in a database. If we're careful with our database
    and class definitions, this isn't impossibly complex. If, however, we're careless,
    we can create Python objects where the SQL representation is quite complex. One
    consequence of the complexity is that numerous queries are involved in mapping
    between object and database rows. The challenge is to strike a balance between
    object-oriented design and the constraints imposed by the SQL database.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将SQL行映射到类定义，以便我们可以从数据库中的数据创建适当的Python对象实例。如果我们对数据库和类定义小心，这并不是不可能的复杂。然而，如果我们粗心大意，我们可能会创建SQL表示非常复杂的Python对象。复杂性的一个后果是在对象和数据库行之间的映射中涉及大量查询。挑战在于在面向对象设计和SQL数据库施加的约束之间取得平衡。
- en: We will have to modify our class definitions to be more aware of the SQL implementation.
    We'll make several modifications to the `Blog` and `Post` class designs shown
    in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via Shelve"),
    *Storing and Retrieving Objects via Shelve*.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不修改我们的类定义，使其更加了解SQL实现。我们将对[第10章](ch10.html "第10章。通过Shelve存储和检索对象")中显示的`Blog`和`Post`类设计进行几处修改，*通过Shelve存储和检索对象*。
- en: 'Here''s a `Blog` class definition:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Blog`类的定义：
- en: '[PRE117]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We allowed for a database ID as a first-class part of the object. Further, we've
    modified the initialization to be entirely based on keywords. Each keyword value
    is popped from the `kw` parameter. Any extra values will raise a `TooManyValues`
    exception.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 我们允许数据库ID作为对象的一部分。此外，我们已经修改了初始化，使其完全基于关键字。每个关键字值都从`kw`参数中弹出。任何额外的值都会引发`TooManyValues`异常。
- en: 'We have two previously unanswered questions. How do we handle the list of posts
    associated with a blog? We''ll modify the following class to add this feature.
    Here''s a `Post` class definition:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个之前未回答的问题。我们如何处理与博客相关联的帖子列表？我们将修改以下类以添加此功能。以下是`Post`类定义：
- en: '[PRE118]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'As with `Blog`, we''ve allowed for a database ID as a first-class part of the
    object. Further, we''ve modified the initialization to be entirely based on keywords.
    Here''s the exception class definition:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Blog`一样，我们允许数据库ID作为对象的一部分。此外，我们已经修改了初始化，使其完全基于关键字。以下是异常类定义：
- en: '[PRE119]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Once we have these class definitions, we can write an access layer that moves
    data between objects of these classes and the database. The access layer implements
    a more complex version of converting and adapting Python classes to rows of a
    table in the database.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些类定义，我们就可以编写一个访问层，将这些类的对象和数据库之间的数据移动。访问层实现了将Python类转换和适应为数据库表中的行的更复杂版本。
- en: Designing an access layer for SQLite
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为SQLite设计访问层
- en: For this small object model, we can implement the entire access layer in a single
    class. This class will include methods to perform CRUD operations on each of our
    persistent classes. In larger applications, we may have to decompose the access
    layer into an individual **Strategy** class for each persistent class. We'd then
    unify all of these under a single access layer **Facade** or **Wrapper**.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个小的对象模型，我们可以在一个类中实现整个访问层。这个类将包括对每个持久类执行CRUD操作的方法。在更大的应用程序中，我们可能需要将访问层分解为每个持久类的单独**策略**类。然后，我们将统一所有这些类在一个单一的访问层**Facade**或**Wrapper**下。
- en: 'This example won''t painstakingly include all of the methods for a complete
    access layer. We''ll show you the important ones. We''ll break this down into
    several sections to deal with `Blogs`, `Posts`, and iterators. Here''s the first
    part of our access layer:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子不会痛苦地包括完整访问层的所有方法。我们将向您展示重要的方法。我们将把这分解成几个部分来处理`Blogs`，`Posts`和迭代器。这是我们访问层的第一部分：
- en: '[PRE120]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This class sets `Connection.row_factory` to use the `sqlite3.Row` class instead
    of a simple tuple. The `Row` class allows access via the numeric index as well
    as the column name.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将`Connection.row_factory`设置为使用`sqlite3.Row`类，而不是简单的元组。`Row`类允许通过数字索引和列名访问。
- en: The `get_blog()` method constructs a `Blog` object from the database row that
    is fetched. Because we're using the `sqlite3.Row` object, we can refer to columns
    by name. This clarifies the mapping between SQL and Python class.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_blog()`方法从获取的数据库行构造一个`Blog`对象。因为我们使用`sqlite3.Row`对象，我们可以通过名称引用列。这澄清了SQL和Python类之间的映射。'
- en: The `add_blog()` method inserts a row into the `BLOG` table based on a `Blog`
    object. This is a two-step operation. First, we create the new row. Then, we perform
    a SQL query to get the row ID that was assigned to the row.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_blog()`方法根据`Blog`对象向`BLOG`表中插入一行。这是一个两步操作。首先，我们创建新行。然后，我们执行SQL查询以获取分配给该行的行ID。'
- en: 'Note that our table definitions use `INTEGER PRIMARY KEY AUTOINCREMENT`. Because
    of this, the table''s primary key will match the row ID and the assigned row ID
    will be available through the `last_insert_rowid()` function. This allows us to
    retrieve the row ID that was allocated; we can then put this into the Python object
    for future reference. Here''s how we can retrieve an individual `Post` object
    from the database:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的表定义使用`INTEGER PRIMARY KEY AUTOINCREMENT`。因此，表的主键将匹配行ID，并且分配的行ID将通过`last_insert_rowid()`函数可用。这允许我们检索分配的行ID；然后我们可以将其放入Python对象以供将来参考。以下是我们如何从数据库中检索单个`Post`对象：
- en: '[PRE121]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'To build `Post`, we have two queries: first, we fetch a row from the `POST`
    table to build part of the `Post` object. Then, we fetch the association rows
    joined with the rows from the `TAG` table. This is used to build the tag list
    for the `Post` object.'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建`Post`，我们有两个查询：首先，我们从`POST`表中获取一行，以构建`Post`对象的一部分。然后，我们获取与`TAG`表中的行连接的关联行。这用于构建`Post`对象的标签列表。
- en: 'When we save a `Post` object, it will have several parts. A row must be added
    to the `POST` table. Additionally, rows need to be added to the `ASSOC_POST_TAG`
    table. If a tag is new, then a row might need to be added to the `TAG` table.
    If the tag exists, then we''re simply associating the post with an existing tag''s
    ID. Here''s the `add_post()` method function:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存`Post`对象时，它将有几个部分。必须向`POST`表添加一行。此外，还需要向`ASSOC_POST_TAG`表添加行。如果标签是新的，则可能需要向`TAG`表添加行。如果标签存在，则我们只是将帖子与现有标签的ID关联。这是`add_post()`方法函数：
- en: '[PRE122]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The process of creating a complete post in the database involves several SQL
    steps. We've used the `insert_post` statement to create the row in the `POST`
    table. We'll also use the generic `get_last_id` query to return the assigned primary
    key for the new `POST` row.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中创建完整帖子的过程涉及几个SQL步骤。我们使用`insert_post`语句在`POST`表中创建行。我们还将使用通用的`get_last_id`查询返回新`POST`行的分配的主键。
- en: The `query_tag` statement is used to determine whether the tag exists in the
    database or not. If the result of the query is not `None`, it means that a `TAG`
    row was found, and we have the ID for that row. Otherwise, the `insert_tag` statement
    must be used to create a row; the `get_last_id` query must be used to determine
    the assigned ID.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '`query_tag`语句用于确定数据库中是否存在标签。如果查询的结果不是`None`，则意味着找到了`TAG`行，我们有该行的ID。否则，必须使用`insert_tag`语句创建一行；必须使用`get_last_id`查询确定分配的ID。'
- en: 'Each `POST` is associated with the relevant tags by inserting rows into the
    `ASSOC_POST_TAG` table. The `insert_association` statement creates the necessary
    row. Here are two iterator-style queries to locate `Blogs` and `Posts`:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`POST`都通过向`ASSOC_POST_TAG`表插入行与相关标签相关联。`insert_association`语句创建必要的行。这里有两种迭代器样式查询来定位`Blogs`和`Posts`：
- en: '[PRE123]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `blog_iter()` method function locates all the `BLOG` rows and builds `Blog`
    instances from the rows.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog_iter()`方法函数定位所有`BLOG`行并从这些行构建`Blog`实例。'
- en: The `post_iter()` method function locates `POST` IDs that are associated with
    a `BLOG` ID. The `POST` IDs are used with the `get_post()` method to build the
    `Post` instances. As `get_post()` will perform another query against the `POST`
    table, there's an optimization possible between these two methods.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_iter()`方法函数定位与`BLOG` ID相关联的`POST` ID。`POST` ID与`get_post()`方法一起用于构建`Post`实例。由于`get_post()`将对`POST`表执行另一个查询，因此在这两种方法之间可能存在优化。'
- en: Implementing container relationships
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现容器关系
- en: Our definition of the `Blog` class included two features that required access
    to all the posts contained within that blog. The `Blog.entries` attribute and
    `Blog.by_tag()` method functions both assume that a blog contains the complete
    collection of the `Post` instances.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`Blog`类的定义包括两个需要访问该博客中包含的所有帖子的特性。`Blog.entries`属性和`Blog.by_tag()`方法函数都假定博客包含`Post`实例的完整集合。
- en: 'For this to work, the `Blog` class must be made aware of the `Access` object
    so that it can use the `Access.post_iter()` method to implement `Blog.entries`.
    We have two overall design patterns for this:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，`Blog`类必须知道`Access`对象，以便它可以使用`Access.post_iter()`方法来实现`Blog.entries`。我们对此有两种整体设计模式：
- en: A global `Access` object is simple and works nicely. We have to be sure that
    the global database connection is opened appropriately, something that can be
    challenging with a global `Access` object.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局`Access`对象简单且工作得很好。我们必须确保全局数据库连接适当打开，这可能是全局`Access`对象的一个挑战。
- en: Inject the `Access` object into each `Blog` object that we're going to persist.
    This is a bit more complex because we have to tweak each object associated with
    the database.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Access`对象注入到每个要持久化的`Blog`对象中。这有点复杂，因为我们必须调整与数据库关联的每个对象。
- en: 'As each database-related object should be created by the `Access` class, the
    Access class would fit the **Factory** pattern. We can make three kinds of changes
    to this factory. These will ensure that a blog or post is made aware of the active
    `Access` object:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个与数据库相关的对象都应该由`Access`类创建，因此`Access`类将适合**工厂**模式。我们可以对这个工厂进行三种改变。这些将确保博客或帖子知道活动的`Access`对象：
- en: Each `return blog` needs to be expanded to `blog._access= self; return blog`.
    This happens in `get_blog()`, `add_blog()`, and `blog_iter()`.
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`return blog`都需要扩展为`blog._access= self; return blog`。这发生在`get_blog()`、`add_blog()`和`blog_iter()`中。
- en: Each `return post` needs to be expanded to `post._access= self; return post`.
    This happens in `get_post()`, `add_post()` and `post_iter()`.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`return post`都需要扩展为`post._access= self; return post`。这发生在`get_post()`、`add_post()`和`post_iter()`中。
- en: 'Revise the `add_blog()` method to accept arguments to build the `Blog` object
    rather than accepting a `Blog` or `Post` object that is built outside the `Access`
    factory. The definition would look something like the following: `def add_blog(
    self, title ):`'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`add_blog()`方法以接受构建`Blog`对象的参数，而不是接受在`Access`工厂之外构建的`Blog`或`Post`对象。定义看起来会像下面这样：`def
    add_blog( self, title ):`
- en: 'Revise the `add_post()` method to accept a blog and the arguments to build
    a `Post` object. The definition would look something like: `def add_post( self,
    blog, title, date, rst_text, tags ):`'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`add_post()`方法以接受一个博客和构建`Post`对象的参数。定义看起来会像这样：`def add_post( self, blog, title,
    date, rst_text, tags ):`
- en: 'Once we have the `_access` attribute injected into each `Blog` instance, we
    can do this:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`_access`属性注入到每个`Blog`实例中，我们就可以这样做：
- en: '[PRE124]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This will return the sequence of Post objects that belong to a Blog object.
    This allows us to define the methods in our class definitions that will process
    children or parents as if they were contained within the object.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回属于博客对象的一系列帖子对象。这使我们能够定义类定义中的方法，这些方法将处理子对象或父对象，就好像它们包含在对象中一样。
- en: Improving performance with indices
  id: totrans-801
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过索引提高性能
- en: One of the ways to improve the performance of a relational database such as
    SQLite is to make join operations faster. The ideal way to do this is to include
    enough index information so that slow search operations aren't done to find matching
    rows. Without an index, an entire table must be read to find referenced rows.
    With an index, just a relevant subset of rows can be read.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 改善SQLite等关系数据库性能的一种方法是加快连接操作。这样做的理想方式是包含足够的索引信息，以便不需要进行缓慢的搜索操作来查找匹配的行。没有索引，必须读取整个表才能找到引用的行。有了索引，只需读取相关的行子集。
- en: When we define a column that might be used in a query, we should consider building
    an index for that column. This means adding yet more SQL DDL statements to our
    table definitions.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个可能在查询中使用的列时，我们应该考虑为该列构建一个索引。这意味着在我们的表定义中添加更多的SQL DDL语句。
- en: 'An index is a separate storage but is tied to a specific table and column.
    The SQL looks like the following code:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是一个单独的存储，但与特定的表和列相关联。SQL看起来像以下代码：
- en: '[PRE125]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This will create an index on the `title` column of the `Blog` table. Nothing
    else needs to be done. The SQL database will use the index when performing queries
    based on the indexed column. When data is created, updated, or deleted, the index
    will be adjusted automatically.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`Blog`表的`title`列上创建一个索引。不需要做其他任何事情。SQL数据库在执行基于索引列的查询时将使用该索引。当数据被创建、更新或删除时，索引将自动调整。
- en: Indexes involve storage and computational overheads. An index that's rarely
    used might be so costly to create and maintain that it becomes a performance hindrance
    rather than a help. On the other hand, some indexes are so important that they
    can have spectacular performance improvements. In all cases, we don't have direct
    control over the database algorithms being used; the best we can do is create
    the index and measure the performance's impact.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 索引涉及存储和计算开销。很少使用的索引可能会因为创建和维护成本而成为性能障碍，而不是帮助。另一方面，一些索引非常重要，可以带来显著的性能改进。在所有情况下，我们无法直接控制正在使用的数据库算法；我们所能做的就是创建索引并测量性能的影响。
- en: 'In some cases, defining a column to be a key might automatically include having
    an index added. The rules for this are usually stated quite clearly in the database''s
    DDL section. SQLite, for example, says this:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将列定义为键可能会自动包括添加索引。这方面的规则通常在数据库的DDL部分中清楚地说明。例如，SQLite表示：
- en: In most cases, UNIQUE and PRIMARY KEY constraints are implemented by creating
    a unique index in the database.
  id: totrans-809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在大多数情况下，唯一和主键约束是通过在数据库中创建唯一索引来实现的。
- en: It goes on to list two exceptions. One of these, the integer primary key exception,
    is the design pattern we've been using to force the database to create surrogate
    keys for us. Therefore, our integer primary key design will not create any additional
    indices.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 它接着列出了两个例外。其中一个是整数主键例外，这是我们一直在使用的设计模式，用于强制数据库为我们创建代理键。因此，我们的整数主键设计不会创建任何额外的索引。
- en: Adding an ORM layer
  id: totrans-811
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加ORM层
- en: 'There are a fairly large number of Python ORM projects. A list of these can
    be found here: [https://wiki.python.org/moin/HigherLevelDatabaseProgramming](https://wiki.python.org/moin/HigherLevelDatabaseProgramming).'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 有相当多的Python ORM项目。这些项目的列表可以在这里找到：[https://wiki.python.org/moin/HigherLevelDatabaseProgramming](https://wiki.python.org/moin/HigherLevelDatabaseProgramming)。
- en: We're going to pick just one of these as an example. We'll use SQLAlchemy because
    it offers us a number of features and is reasonably popular. As with many things,
    there's no *best*; other ORM layers have different advantages and disadvantages.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择其中一个作为示例。我们将使用SQLAlchemy，因为它为我们提供了许多功能，并且相当受欢迎。与许多事物一样，并没有*最佳*；其他ORM层具有不同的优势和劣势。
- en: Because of the popularity of using a relational database to support Web development,
    Web frameworks often include ORM layers. Django has its own ORM layer, as does
    web.py. In some cases, we can tease the ORMs out of the larger framework. However,
    it seems simpler to work with a standalone ORM.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用关系数据库支持Web开发的流行，Web框架通常包括ORM层。Django有自己的ORM层，web.py也有。在某些情况下，我们可以从更大的框架中分离出ORM。但是，与独立的ORM一起工作似乎更简单。
- en: The documentation, installation guide, and code for SQLAlchemy is available
    at [http://www.sqlalchemy.org](http://www.sqlalchemy.org). When installing, using
    `--without-cextensions` can simplify the process if the high-performance optimizations
    aren't required.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的文档、安装指南和代码可在[http://www.sqlalchemy.org](http://www.sqlalchemy.org)找到。在安装时，如果不需要高性能优化，使用`--without-cextensions`可以简化流程。
- en: It's important to note that SQLAlchemy can completely replace all of an application's
    SQL statements with first-class Python constructs. This has the profound advantage
    of allowing us to write applications in a single language, Python, even though
    a second language (SQL) is used under the hood as part of the data access layer.
    This can save some complexity in the development and debugging.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，SQLAlchemy可以完全用一流的Python构造替换应用程序的所有SQL语句。这具有深远的优势，可以让我们使用单一语言Python编写应用程序，即使在数据访问层中使用了第二种语言SQL。这可以节省一些开发和调试的复杂性。
- en: This does not, however, remove the obligation to understand the underlying SQL
    database constraints and how our design must fit within these constraints. An
    ORM layer doesn't magically obviate the design considerations. It merely changes
    the implementation language from SQL to Python.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不消除理解底层SQL数据库约束以及我们的设计如何适应这些约束的义务。ORM层并不能神奇地消除设计考虑。它只是将实现语言从SQL更改为Python。
- en: Designing ORM-friendly classes
  id: totrans-818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计ORM友好的类
- en: 'When using an ORM, we will fundamentally change the way we design and implement
    our persistent classes. We''re going to expand the semantics of our class definitions
    to have three distinct levels of meaning:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM时，我们将根本改变设计和实现持久类的方式。我们将扩展类定义的语义，具有三个不同的层次含义：
- en: The class will be a Python class and can be used to create Python objects. The
    method functions are used by these objects.
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类将是一个Python类，可以用来创建Python对象。方法函数被这些对象使用。
- en: The class will also describe a SQL table and can be used by the ORM to create
    the SQL DDL that builds and maintains the database structure.
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类还将描述一个SQL表，并可以被ORM用来创建构建和维护数据库结构的SQL DDL。
- en: The class will also define the mappings between the SQL table and Python class.
    It will be the vehicle to turn Python operations into SQL DML and build Python
    objects from SQL queries.
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类还将定义SQL表和Python类之间的映射。它将成为将Python操作转换为SQL DML并从SQL查询构建Python对象的工具。
- en: Most ORMs are designed so that we will use descriptors to formally define the
    attributes of our class. We do not simply define attributes in the `__init__()`
    method. For more information on descriptors, see [Chapter 3](ch03.html "Chapter 3. Attribute
    Access, Properties, and Descriptors"), *Attribute Access, Properties, and Descriptors*.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数ORM都是设计成我们将使用描述符来正式定义类的属性。我们不只是在`__init__()`方法中定义属性。有关描述符的更多信息，请参见[第3章](ch03.html
    "第3章。属性访问、属性和描述符")，*属性访问、属性和描述符*。
- en: SQLAlchemy requires us to build a **declarative base class**. This base class
    provides a metaclass for our application's class definitions. It also serves as
    a repository for the metadata that we're defining for our database. If we follow
    the defaults, it's easy to call this class `Base`.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy要求我们构建一个**声明基类**。这个基类为我们应用程序的类定义提供了一个元类。它还作为我们为数据库定义的元数据的存储库。如果我们遵循默认设置，很容易将这个类称为`Base`。
- en: 'Here''s the list of imports that might be helpful:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能有用的导入列表：
- en: '[PRE126]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We imported some essential definitions to create a column of a table, column,
    and to create the rare table that doesn't specifically map to a Python class,
    `Table`. We imported all of the generic column type definitions. We'll only use
    a few of these column types. Not only does SQLAlchemy define these generic types,
    it defines the SQL standard types, and it also defines vendor-specific types for
    the various supported SQL dialects. It seems easy to stick to the generic types
    and allow SQLAlchemy to map between generic, standard, and vendor types.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了一些必要的定义来创建表的列，列和创建不特定地映射到Python类的稀有表，`Table`。我们导入了所有通用列类型定义。我们只会使用其中的一些列类型。SQLAlchemy不仅定义了这些通用类型，还定义了SQL标准类型，还为各种支持的SQL方言定义了特定于供应商的类型。似乎很容易坚持使用通用类型，并允许SQLAlchemy在通用、标准和供应商类型之间进行映射。
- en: 'We also imported two helpers to define the relationships among tables, `relationship`,
    and `backref`. SQLAlchemy''s metaclass is built by the `declarative_base()` function:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了两个助手来定义表之间的关系，`relationship`和`backref`。SQLAlchemy的元类是由`declarative_base()`函数构建的：
- en: '[PRE127]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The `Base` object that was created must be the metaclass for any persistent
    class that we're going to define. We'll define three tables that are mapped to
    Python classes. We'll also define a fourth table that's simply required by SQL
    to implement a many-to-many relationship.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`Base`对象必须是我们要定义的任何持久类的元类。我们将定义三个映射到Python类的表。我们还将定义第四个表，这个表仅仅是SQL实现多对多关系所需的。
- en: 'Here''s the `Blog` class:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Blog`类：
- en: '[PRE128]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Our `Blog` class is mapped to a table named `"BLOG"`. We've included two descriptors
    for the two columns we want in this table. The `id` column is defined as an `Integer`
    primary key. Implicitly, this will be an autoincrement field so that surrogate
    keys are generated for us.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Blog`类映射到一个名为`"BLOG"`的表。我们在这个表中包含了两个列的描述符。`id`列被定义为`Integer`主键。隐式地，这将是一个自动增量字段，以便为我们生成代理键。
- en: The title column is defined as a generic string. We could have used `Text`,
    `Unicode`, or even `UnicodeText` for this. The underlying engine might have different
    implementations for these various types. In our case, SQLite will treat all of
    these nearly identically. Also note that SQLite doesn't need an upper limit on
    the length of a column; other database engines might require an upper limit on
    the size of `String`.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 标题列被定义为通用字符串。我们可以使用`Text`、`Unicode`甚至`UnicodeText`。底层引擎可能对这些不同类型有不同的实现。在我们的情况下，SQLite将几乎相同地处理所有这些。还要注意，SQLite不需要对列的长度设置上限；其他数据库引擎可能需要对`String`的大小设置上限。
- en: 'The `as_dict()` method function refers to an `entries` collection that is clearly
    not defined in this class. When we look at the definition of the `Post` class,
    we''ll see how this `entries` attribute is built. Here''s the definition of the
    `Post` class:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '`as_dict()`方法函数指的是一个`entries`集合，在这个类中显然没有定义。当我们查看`Post`类的定义时，我们将看到`entries`属性是如何构建的。这是`Post`类的定义：'
- en: '[PRE129]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This class has five attributes, two relationships, and a method function. The
    `id` attribute is an integer primary key; this will be an autoincrement value
    by default. The `title` attribute is a simple string. The `date` attribute will
    be a `DateTime` column; `rst_text` is defined as `UnicodeText` to emphasize our
    expectation of any Unicode character in this field.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有五个属性，两个关系和一个方法函数。`id`属性是一个整数主键；这将是一个默认的自动增量值。`title`属性是一个简单的字符串。`date`属性将是一个`DateTime`列；`rst_text`被定义为`UnicodeText`，以强调我们对该字段中任何Unicode字符的期望。
- en: The `blog_id` is a foreign key reference to the parent blog that contains this
    post. In addition to the foreign key column definition, we also included an explicit
    `relationship` definition between post and the parent blog. This `relationship`
    definition becomes an attribute that we can use for navigation from the post to
    the parent blog.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog_id`是一个外键引用，指向包含此帖子的父博客。除了外键列的定义，我们还包括了帖子和父博客之间的显式`relationship`定义。这个`relationship`定义成为我们可以用于从帖子导航到父博客的属性。'
- en: The `backref` option includes a backwards reference that will be added to the
    `Blog` class. This reference in the `Blog` class will be the collection of `Posts`
    that are contained within the `Blog`. The `backref` option names the new attribute
    in the `Blog` class to reference the child `Posts`.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '`backref`选项包括一个将被添加到`Blog`类中的反向引用。`Blog`类中的这个引用将是包含在`Blog`中的`Posts`的集合。`backref`选项将在`Blog`类中命名新属性，以引用子`Posts`。'
- en: The `tags` attribute uses a `relationship` definition; this attribute will navigate
    via an association table to locate all the `Tag` instances associated with the
    post. We'll look at the following association table. This, too, uses `backref`
    to include an attribute in the `Tag` class that references the related collection
    of the `Post` instances.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags`属性使用`relationship`定义；这个属性将通过一个关联表导航，以定位与帖子相关联的所有`Tag`实例。我们将看看下面的关联表。这也使用`backref`来在`Tag`类中包含一个属性，引用`Post`实例的相关集合。'
- en: 'The `as_dict()` method makes use of the `tags` attribute to locate all of `Tags`
    associated with this `Post`. Here''s a definition for the `Tag` class:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '`as_dict()`方法利用`tags`属性来定位与此`Post`相关联的所有`Tags`。以下是`Tag`类的定义：'
- en: '[PRE130]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We defined a primary key and a `String` attribute. We included a constraint
    to ensure that each tag is explicitly unique. An attempt to insert a duplicate
    will lead to a database exception. The relationship in the `Post` class definition
    means that additional attributes will be created in this class.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个主键和一个`String`属性。我们包括了一个约束，以确保每个标签都是明确唯一的。尝试插入重复的标签将导致数据库异常。`Post`类定义中的关系意味着将在这个类中创建额外的属性。
- en: 'As required by SQL, we need an association table for the many-to-many relationship
    between tags and posts. This table is purely a technical requirement in SQL and
    need not be mapped to a Python class:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SQL的要求，我们需要一个关联表来处理标签和帖子之间的多对多关系。这个表纯粹是SQL中的技术要求，不需要映射到Python类：
- en: '[PRE131]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: We have to explicitly bind this to the `Base.metadata` collection. This binding
    is automatically a part of the classes that use `Base` as the metaclass. We defined
    a table that contains two `Column` instances. Each column is a foreign key to
    one of the other tables in our model.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须显式地将其绑定到`Base.metadata`集合。这种绑定自动成为使用`Base`作为元类的类的一部分。我们定义了一个包含两个`Column`实例的表。每个列都是我们模型中另一个表的外键。
- en: Building the schema with the ORM layer
  id: totrans-847
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ORM层构建模式
- en: 'In order to connect to a database, we''ll need to create an engine. One use
    for the engine is to build the database instance with our table declarations.
    The other use for the engine is to manage the data from a session, which we''ll
    look at later. Here''s a script that we can use to build a database:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到数据库，我们需要创建一个引擎。引擎的一个用途是使用我们的表声明构建数据库实例。引擎的另一个用途是管理会话中的数据，这是我们稍后会看到的。以下是一个我们可以用来构建数据库的脚本：
- en: '[PRE132]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: When we create an `Engine` instance, we use a URL-like string that names the
    vendor product and provides all the additional parameters required to create the
    connection to that database. In the case of SQLite, the connection is a filename.
    In the case of other database products, there might be server host names and authentication
    credentials.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个`Engine`实例时，我们使用类似URL的字符串，其中包含了命名供应商产品的名称以及创建与该数据库的连接所需的所有附加参数。在SQLite的情况下，连接是一个文件名。在其他数据库产品的情况下，可能会有服务器主机名和身份验证凭据。
- en: Once we have the engine, we've done some fundamental metadata operations. We've
    done the `create_all()`, which builds all of the tables. We might also perform
    a `drop_all()` that will drop all of the tables, losing all the data. We can,
    of course, create or drop an individual schema item, too.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了引擎，我们就完成了一些基本的元数据操作。我们已经执行了`create_all()`，它会构建所有的表。我们也可以执行`drop_all()`，它会删除所有的表，丢失所有的数据。当然，我们也可以创建或删除单个模式项。
- en: If we change a table definition during software development, it will not automagically
    mutate the SQL table definition. We need to explicitly drop and rebuild the table.
    In some cases, we might want to preserve some operational data, leading to potentially
    complex surgery to create and populate new table(s) from old table(s).
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在软件开发过程中更改表定义，它不会自动改变SQL表定义。我们需要显式地删除并重建表。在某些情况下，我们可能希望保留一些操作数据，从旧表中创建和填充新表可能会导致潜在的复杂手术。
- en: 'The `echo=True` option writes log entries with the generated SQL statements.
    This can be helpful to determine whether the declarations are complete and create
    the expected database design. Here''s a snippet of the output that is produced:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo=True`选项会写入生成的SQL语句的日志条目。这有助于确定声明是否完整并创建了预期的数据库设计。以下是生成的输出片段：'
- en: '[PRE133]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This shows SQL us the `CREATE TABLE` statements that were created based on our
    class definitions.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了基于我们的类定义创建的`CREATE TABLE`语句。
- en: Once the database has been built, we can create, retrieve, update, and delete
    objects. In order to work with database objects, we need to create a session that
    acts as a cache for the ORM-managed objects.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库建立后，我们可以创建、检索、更新和删除对象。为了处理数据库对象，我们需要创建一个作为ORM管理对象缓存的会话。
- en: Manipulating objects with the ORM layer
  id: totrans-857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ORM层操作对象
- en: 'In order to work with objects, we''ll need a session cache. This is bound to
    an engine. We''ll add new objects to the session cache. We''ll also use the session
    cache to query objects in the database. This assures us that all objects that
    need to be persistent are in the cache. Here is a way to create a working session:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用对象，我们需要一个会话缓存。这与一个引擎绑定在一起。我们将新对象添加到会话缓存中。我们还将使用会话缓存来查询数据库中的对象。这确保了所有需要持久存在的对象都在缓存中。以下是创建一个工作会话的方法：
- en: '[PRE134]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We used the SQLAlchemy `sessionmaker()` function to create a `Session` class.
    This is bound to the database engine that we created previously. We then used
    the `Session` class to build a `session` object that we can use to perform data
    manipulation. A session is required to work with the objects in general.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用SQLAlchemy的`sessionmaker()`函数来创建一个`Session`类。这个类绑定到我们之前创建的数据库引擎。然后我们使用`Session`类来构建一个`session`对象，我们可以用它来执行数据操作。通常需要一个会话来处理对象。
- en: Generally, we build one `sessionmaker` class along with the engine. We can then
    use that one `sessionmaker` class to build multiple sessions for our application
    processing.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会创建一个`sessionmaker`类以及引擎。然后我们可以使用那个`sessionmaker`类来为我们的应用程序处理构建多个会话。
- en: 'For simple objects, we create them and load them into the session as in the
    following code:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的对象，我们创建它们并将它们加载到会话中，如下所示的代码：
- en: '[PRE135]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This puts a new `Blog` object into the session named `session`. The `Blog` object
    is not *necessarily* written to the database. We need to commit the session before
    the database writes are performed. In order to meet the Atomicity requirements,
    we'll finish building a post before committing the session.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个新的`Blog`对象放入名为`session`的会话中。`Blog`对象不一定会被写入数据库。在执行数据库写入之前，我们需要提交会话。为了满足原子性要求，我们将在提交会话之前完成构建一个帖子。
- en: 'First, we''ll look up the `Tag` instances in the database. If they don''t exist,
    we''ll create them. If they do exist, we''ll use the tag found in the database:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在数据库中查找`Tag`实例。如果它们不存在，我们将创建它们。如果它们存在，我们将使用在数据库中找到的标签：
- en: '[PRE136]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We use the `session.query()` function to examine instances of the given class.
    Each `filter()` function appends a criterion to the query. The `one()` function
    ensures that we've found a single row. If an exception is raised, then it means
    that `Tag` doesn't exist. We need to build a new `Tag` and add it to the session.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`session.query()`函数来检查给定类的实例。每个`filter()`函数都会向查询中添加一个条件。`one()`函数确保我们找到了一行。如果引发异常，那么意味着`Tag`不存在。我们需要构建一个新的`Tag`并将其添加到会话中。
- en: 'Once we''ve found or created the `Tag` instance, we can append it to a local
    list named `tags`; we''ll use this list of `Tag` instances to create the `Post`
    object. Here''s how we build a `Post`:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到或创建了`Tag`实例，我们可以将其附加到一个名为`tags`的本地列表中；我们将使用这个`Tag`实例列表来创建`Post`对象。以下是我们如何构建一个`Post`：
- en: '[PRE137]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This includes a reference to the parent blog. It also includes the list of `Tag`
    instances that we built (or found in the database).
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括对父博客的引用。它还包括我们构建的（或在数据库中找到的）`Tag`实例的列表。
- en: The `Post.blog` attribute was defined as a relationship in the class definitions.
    When we assign an object, SQLAlchemy plucks out the proper ID values to create
    the foreign key reference that the SQL database uses to implement the relationship.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post.blog`属性在类定义中被定义为一个关系。当我们分配一个对象时，SQLAlchemy会提取出正确的ID值，以创建SQL数据库用来实现关系的外键引用。'
- en: The `Post.tags` attribute was also defined as a relationship. The `Tag` objects
    are referenced via the association table. SQLAlchemy tracks the ID values properly
    to build the necessary rows in the SQL association table for us.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post.tags`属性也被定义为一个关系。`Tag`对象通过关联表引用。SQLAlchemy正确跟踪ID值，以为我们构建SQL关联表中必要的行。'
- en: 'In order to associate the `Post` with the `Blog`, we''ll make use of the `Blog.posts`
    attribute. This, too, was defined as a relationship. When we assign a list of
    `Post` objects to this relationship attribute, the ORM will build the proper foreign
    key reference in each `Post` object. This works because we provided the `backref`
    attribute when defining the relationship. Finally, we commit the session:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`Post`与`Blog`关联起来，我们将利用`Blog.posts`属性。这也被定义为一个关系。当我们将`Post`对象列表分配给这个关系属性时，ORM将在每个`Post`对象中构建适当的外键引用。这是因为我们在定义关系时提供了`backref`属性。最后，我们提交会话：
- en: '[PRE138]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The database inserts are all handled in a flurry of automatically generated
    SQL. The objects remained cached in the session. If our application continues
    using this session instance, then the pool of objects remains available without
    necessarily performing any actual queries against the database.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库插入都是在自动生成的SQL中处理的。对象仍然保留在会话中的缓存中。如果我们的应用程序继续使用这个会话实例，那么对象池将保持可用，而不一定执行任何针对数据库的实际查询。
- en: If, on the other hand, we would like to be absolutely sure that any updates
    written by other concurrent processes are included in a query, we can create a
    new, empty session for that query. When we discard a session and use an empty
    session, objects must be fetched from the database to refresh the session.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们希望确保其他并发进程写入的任何更新都包含在查询中，我们可以为该查询创建一个新的空会话。当我们丢弃一个会话并使用一个空会话时，对象必须从数据库中获取以刷新会话。
- en: 'We can write a simple query to examine and print all of the `Blog` objects:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个简单的查询来检查并打印所有的`Blog`对象：
- en: '[PRE139]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This will retrieve all the `Blog` instances. The `Blog.as_dict()` method will
    retrieve all of the posts within a blog. The `Post.as_dict()` method will retrieve
    all of the tags. The SQL queries will be generated and executed automatically
    by SQLAlchemy.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检索所有的`Blog`实例。`Blog.as_dict()`方法将检索博客中的所有帖子。`Post.as_dict()`方法将检索所有标签。SQL查询将由SQLAlchemy自动生成并自动执行。
- en: We didn't include the rest of the template-based formatting from [Chapter 9](ch09.html
    "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and XML"), *Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML*. It doesn't change. We are able
    to navigate from the `Blog` object via the `entries` list to the `Post` objects
    without writing elaborate SQL queries. Translating navigation into queries is
    the job of SQLAlchemy. Using a Python iterator is sufficient for SQLAlchemy to
    generate the right queries to refresh the cache and return the expected objects.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有包括来自[第9章](ch09.html "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")的基于模板的格式的其余部分。它没有改变。我们能够从`Blog`对象通过`entries`列表导航到`Post`对象，而不需要编写复杂的SQL查询。将导航转换为查询是SQLAlchemy的工作。对于SQLAlchemy来说，使用Python迭代器就足以生成正确的查询来刷新缓存并返回预期的对象。
- en: If we have `echo=True` defined for the `Engine` instance, then we'll be able
    to see the sequence of SQL queries performed to retrieve the `Blog`, `Post`, and
    `Tag` instances. This information can help us understand the workload that our
    application places on the database server process.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`Engine`实例定义了`echo=True`，那么我们将能够看到执行检索`Blog`、`Post`和`Tag`实例的SQL查询序列。这些信息可以帮助我们了解应用程序对数据库服务器进程的工作负载。
- en: Querying post objects given a tag string
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给定一个标签字符串查询帖子对象
- en: An important benefit of a relational database is our ability to follow the relationships
    among the objects. Using SQLAlchemy's query capability, we can follow the relationship
    from `Tag` to `Post` and locate all `Posts` that share a given `Tag` string.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库的一个重要好处是我们能够遵循对象之间的关系。使用SQLAlchemy的查询功能，我们可以从`Tag`到`Post`的关系，并找到所有共享给定`Tag`字符串的`Posts`。
- en: A query is a feature of a session. This means that objects already in the session
    don't need to be fetched from the database, a potential time-saver. Objects not
    in the session are cached in the session so that updates or deletes can be handled
    at the time of the commit.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是会话的一个特性。这意味着已经在会话中的对象不需要从数据库中获取，这可能节省时间。不在会话中的对象被缓存在会话中，以便在提交时处理更新或删除。
- en: 'To gather all of the posts that have a given tag, we need to use the intermediate
    association table as well as the `Post` and `Tag` tables. We''ll use the query
    method of the session to specify what kinds of objects we expect to get back.
    We''ll use the fluent interface to join in the various intermediate tables and
    the final table that we want with the selection criteria. Here''s how it looks:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集所有具有特定标签的帖子，我们需要使用中间关联表以及`Post`和`Tag`表。我们将使用会话的查询方法来指定我们希望得到的对象类型。我们将使用流畅接口来加入各种中间表和我们希望的最终表以及选择条件。看起来是这样的：
- en: '[PRE140]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `session.query()` method specifies the table that we want to see. If we
    left it at that, we''d see every row. The `join()` methods identify the additional
    tables that must be matched. Because we provided the relationship information
    in the class definitions, SQLAlchemy can work out the SQL details required to
    use primary keys and foreign keys to match rows. The final `filter()` method provides
    the selection criteria for the desired subset of rows. Here''s the SQL that was
    generated:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '`session.query()`方法指定了我们想要查看的表。如果我们只是这样做，我们会看到每一行。`join()`方法标识必须匹配的附加表。因为我们在类定义中提供了关系信息，SQLAlchemy可以计算出使用主键和外键匹配行所需的SQL细节。最终的`filter()`方法为所需子集的行提供了选择条件。这是生成的SQL：'
- en: '[PRE141]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The Python version is a bit easier to understand, as the details of the key
    matching can be elided. The `print()` function uses `post.blog.title` to navigate
    from the `Post` instance to the associated blog and show the `title` attribute.
    If the blog was in the session cache, this navigation is done quickly. If the
    blog was not in the session cache, it will be fetched from the database.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本稍微更容易理解，因为关键匹配的细节可以被省略。`print()`函数使用`post.blog.title`从`Post`实例导航到相关的博客并显示`title`属性。如果博客在会话缓存中，这种导航会很快完成。如果博客不在会话缓存中，它将从数据库中获取。
- en: 'This navigation behavior applies to `[t.phrase for t in post.tags]`, too. If
    the object is in the session cache, it''s simply used. In this case, the collection
    of the `Tag` objects associated with a post might lead to a complex SQL query:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导航行为也适用于`[t.phrase for t in post.tags]`。如果对象在会话缓存中，它就会被简单地使用。在这种情况下，与帖子相关的`Tag`对象的集合可能会导致复杂的SQL查询：
- en: '[PRE142]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: In Python, we simply navigated via `post.tags`. SQLAlchemy generated and executed
    the SQL for us.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们只需通过`post.tags`进行导航。SQLAlchemy为我们生成并执行了SQL。
- en: Improving performance with indices
  id: totrans-893
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过索引提高性能
- en: One of the ways to improve the performance of a relational database such as
    SQLite is to make join operations faster. We don't want SQLite to read an entire
    table to find matching rows. By building an index on a particular column, SQLite
    can examine the index and read just the relevant rows from the table.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 改善关系数据库（如SQLite）性能的一种方法是加快连接操作。我们不希望SQLite读取整个表来查找匹配的行。通过在特定列上建立索引，SQLite可以检查索引并仅从表中读取相关行。
- en: When we define a column that might be used in a query, we should consider building
    an index for that column. This is a simple process that uses SQLAlchemy. We simply
    annotate the attribute of the class with `index=True`.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义可能在查询中使用的列时，我们应该考虑为该列建立索引。这是一个简单的过程，使用SQLAlchemy。我们只需用`index=True`注释类的属性。
- en: 'We can make fairly minor changes to our `Post` table, for example. We can do
    this to add indexes:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对我们的`Post`表进行相当小的更改，例如添加索引：
- en: '[PRE143]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Adding two indices for the title and date will usually speed up queries for
    the posts by the title or by the date. There's no guarantee that there must be
    an improvement in the performance. Relational database performance involves a
    number of factors. It's important to measure the performance of a realistic workload
    both with the index and without it.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 为标题和日期添加两个索引通常会加快按标题或日期查询帖子的速度。并不一定保证性能会有所改善。关系数据库的性能涉及许多因素。重要的是要在有索引和没有索引的情况下测量现实工作负载的性能。
- en: Adding an index by `blog_id`, similarly, might speed up the join operation between
    rows in the `Blog` and `Post` tables. It's also possible that the database engine
    uses an algorithm that doesn't benefit from having this index available.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`blog_id`添加索引，同样，可能会加快在`Blog`和`Post`表中行之间的连接操作。数据库引擎也可能使用一种不受此索引影响的算法。
- en: Indexes involve storage and computational overheads. An index that's rarely
    used might be so costly to create and maintain that it becomes a problem, not
    a solution. On the other hand, some indexes are so important that they can have
    spectacular performance improvements. In all cases, we don't have direct control
    over the database algorithms being used; the best we can do is create the index
    and measure the performance impact.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 索引涉及存储和计算开销。很少使用的索引可能创建和维护的成本如此之高，以至于它成为一个问题，而不是解决方案。另一方面，一些索引非常重要，可以带来显著的性能改进。在所有情况下，我们无法直接控制正在使用的数据库算法；我们能做的就是创建索引并测量性能影响。
- en: Schema evolution
  id: totrans-901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式演变
- en: When working with a SQL database, we have to address the problem of schema evolution.
    Our objects have a dynamic state and a static class definition. We can easily
    persist the dynamic state. Our class definitions are part of the schema for the
    persistent data; we also have mappings to the formal SQL schema. Neither class
    nor SQL schema is *absolutely* static.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理SQL数据库时，我们必须解决模式演变的问题。我们的对象具有动态状态和静态类定义。我们可以轻松地持久化动态状态。我们的类定义是持久数据的模式的一部分；我们还有对正式SQL模式的映射。无论是类还是SQL模式都不是*绝对*静态的。
- en: If we change a class definition, how will we fetch objects from the database?
    If the database must change, how do we upgrade the Python mappings and still map
    the data? A good design often involves some combination of several techniques.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改了类定义，我们如何从数据库中获取对象？如果数据库必须更改，我们如何升级Python映射并仍然映射数据？一个好的设计通常涉及几种技术的组合。
- en: The changes to the method functions and properties of the Python classes don't
    change the mapping to the SQL rows. These can be termed minor changes, as the
    tables in the database are still compatible with the changed class definition.
    A new software release can have a new minor version number.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: Python类的方法函数和属性的更改不会改变与SQL行的映射。这些可以称为次要更改，因为数据库中的表仍与更改后的类定义兼容。新软件发布可以有一个新的次要版本号。
- en: The changes to Python class attributes will not necessarily change the persisted
    object state. SQL can be somewhat flexible when converting the data types from
    the database to the Python objects. An ORM layer can add flexibility. In some
    cases, we can make some class or database changes and call it a minor version
    update because the existing SQL schema will still work with new class definitions.
    We can, for example, alter a SQL table from an integer to a string without significant
    breakage because of SQL and ORM conversions.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: Python类属性的更改不一定会改变持久化对象的状态。在将数据类型从数据库转换为Python对象时，SQL可能会有些灵活。ORM层可以增加灵活性。在某些情况下，我们可以进行一些类或数据库更改，并称其为次要版本更新，因为现有的SQL模式仍将与新的类定义一起工作。例如，我们可以将SQL表从整数更改为字符串，而不会因为SQL和ORM转换而出现重大破坏。
- en: Changes to the SQL table definitions will clearly modify the persisted objects.
    These can be called major changes when the existing database rows will no longer
    be compatible with the new class definition. These kinds of changes should not
    be made by *modifying* the Python class definitions. These kinds of changes should
    be made by defining a new subclass and providing an updated factory function to
    create instances of either the old or new class.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 对SQL表定义的更改将明显修改持久化对象。当现有数据库行不再与新类定义兼容时，这些可以称为重大更改。这些类型的更改不应该通过*修改*Python类定义来进行。这些类型的更改应该通过定义一个新的子类，并提供一个更新的工厂函数来创建旧类或新类的实例。
- en: 'When working with persistent SQL data, a schema change can be accomplished
    by one of the following two ways:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理持久的SQL数据时，可以通过以下两种方式之一进行模式更改：
- en: Using SQL `ALTER` statements on the existing schema. Some kinds of changes can
    be done incrementally to a SQL schema. There are a number of constraints and restrictions
    on what changes are permitted. This doesn't generalize well; it should be seen
    as an exceptional situation that might work for minor changes.
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQL的`ALTER`语句对现有模式进行更改。某些类型的更改可以逐步对SQL模式进行。对所允许的更改有许多约束和限制。这并不具有很好的泛化性；应该将其视为一种可能适用于较小更改的特殊情况。
- en: Creating new tables and dropping old tables. In general, a SQL schema change
    will be significant enough for us to require to create a new version of table(s)
    from old table(s), making profound changes to the data's structure.
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新表和删除旧表。一般来说，SQL模式更改将足够重要，以至于我们需要从旧表创建新版本的表，对数据结构进行深刻的更改。
- en: SQL database schema changes typically involve running a one-time conversion
    script. This script will use the old schema to query the existing data, transform
    it to new data, and use the new schema to insert new data into the database. Of
    course, this must be tested on a backup database before being run on the user's
    preferred, live, operational database. Once the schema change has been accomplished,
    the old schema can be safely ignored and later dropped to free up storage.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库模式更改通常涉及运行一次性转换脚本。此脚本将使用旧模式查询现有数据，将其转换为新数据，并使用新模式将新数据插入数据库。当然，这必须在用户首选的实时操作数据库之前在备份数据库上进行测试。一旦完成模式更改，就可以安全地忽略旧模式，并稍后删除以释放存储空间。
- en: This kind of transformation can be done in a single database using different
    table names or different schema names (for databases that support named schema.)
    If we keep old data and new data side-by-side, we have a flexible upgrade path
    from old applications to the new applications. This is particularly important
    with websites that try to offer 24 x 7 availability.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换可以在单个数据库中使用不同的表名或不同的模式名（对于支持命名模式的数据库）。如果我们将旧数据和新数据并排放置，我们就可以从旧应用程序灵活地升级到新应用程序。这对于试图提供全天候可用性的网站尤为重要。
- en: In some situations, it becomes necessary to add tables to the schema with purely
    administrative details such as the identification of schema version. Applications
    can then query this table first after establishing a database connection and fail
    quickly when the schema version is wrong.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，有必要向模式添加表，其中仅包含纯粹的管理细节，例如模式版本的标识。应用程序可以在建立数据库连接后首先查询此表，并在模式版本错误时快速失败。
- en: Summary
  id: totrans-913
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'We looked at the basics of using SQLite in three ways: directly, via an access
    layer, and via the SQLAlchemy ORM. We have to create SQL DDL statements; we can
    do this directly in our applications or in an access layer. We can also have DDL
    built by the SQLAlchemy class definitions. To manipulate data, we''ll use SQL
    DML statements; we can do this directly in a procedural style, or we can use our
    own access layer or SQLAlchemy to create the SQL.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以三种方式查看了使用SQLite的基础知识：直接使用、通过访问层、以及通过SQLAlchemy ORM。我们必须创建SQL DDL语句；我们可以直接在我们的应用程序中或在访问层中进行此操作。我们还可以通过SQLAlchemy类定义来构建DDL。为了操作数据，我们将使用SQL
    DML语句；我们可以以过程化风格直接进行此操作，或者我们可以使用我们自己的访问层或SQLAlchemy来创建SQL。
- en: Design considerations and trade-offs
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: One of the strengths of the `sqlite3` module is that it allows us to persist
    distinct items. As we're using a database that supports concurrent writes, we
    can have multiple processes updating the data, relying on SQLite to handle concurrency
    via its own internal locking.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3`模块的一个优点是它允许我们持久化不同的项目。由于我们使用支持并发写入的数据库，我们可以有多个进程更新数据，依靠SQLite通过其内部锁定处理并发。'
- en: 'Using a relational database imposes numerous restrictions. We must consider
    how to map our objects to rows of tables in the database:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关系数据库会施加许多限制。我们必须考虑如何将我们的对象映射到数据库表的行：
- en: We can use SQL directly, using only the supported SQL column types and largely
    eschewing object-oriented classes
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以直接使用SQL，仅使用支持的SQL列类型，并在很大程度上避免面向对象的类
- en: We can use a manual mapping that extends SQLite to handle our objects as SQLite
    BLOB columns
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用手动映射来扩展SQLite以处理我们的对象作为SQLite BLOB列
- en: We can write our own access layer to adapt and convert between our objects and
    SQL rows
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写自己的访问层来适应和转换我们的对象和SQL行
- en: We can use an ORM layer to implement a row-to-object mapping
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用ORM层来实现行到对象的映射。
- en: Mapping alternatives
  id: totrans-922
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射替代方案
- en: The problem with mixing Python and SQL is that there can be an impetus towards
    something that we might call the "All Singing, All Dancing, All SQL" solution.
    The idea here is that the relational database is somehow the ideal platform and
    Python corrupts this by injecting needless object-oriented features.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 混合Python和SQL的问题在于可能会产生一种我们可以称之为“全能SQL”解决方案的冲动。这里的想法是关系数据库在某种程度上是理想的平台，而Python通过注入不必要的面向对象特性来破坏这一点。
- en: The all-SQL, object-free design strategy is sometimes justified as being more
    appropriate for certain kinds of problems. Specifically, proponents will point
    out summarizing large sets of data using the SQL `GROUP BY` clause as an ideal
    use for SQL.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，全SQL、无对象的设计策略被证明更适合某些类型的问题。具体来说，支持者会指出使用SQL的`GROUP BY`子句对大量数据进行汇总是SQL的理想用途。
- en: This is implemented very effectively by Python's `defaultdict` and `Counter`.
    The Python version is often so effective that a small Python program querying
    lots of rows and accumulating summaries using `defaultdict` might be faster than
    a database server performing SQL with `GROUP BY`.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由Python的`defaultdict`和`Counter`非常有效地实现的。Python版本通常如此有效，以至于一个小型的Python程序查询大量行并使用`defaultdict`累积摘要可能比使用`GROUP
    BY`执行SQL的数据库服务器更快。
- en: When in doubt, measure. Some nonsense is spouted by SQL database proponents.
    When confronted with claims that SQL should magically be faster that Python, gather
    evidence. This data gathering is not confined to one-time initial technical spike
    situations either. As usage grows and changes, the relative merit of SQL database
    versus Python will shift too.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，就进行测量。SQL数据库支持者会说一些无稽之谈。当面对SQL应该神奇地比Python更快的说法时，收集证据。这种数据收集不仅限于一次性的初始技术尖峰情况。随着使用量的增长和变化，SQL数据库与Python的相对优点也会发生变化。
- en: A home-brewed access layer will tend to be highly specific to a problem domain.
    This might have the advantage of high performance and relatively transparent mapping
    from row to object. It might have the disadvantage of being annoying to maintain
    every time a class changes or the database implementation changes.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 自制的访问层往往会对问题域高度特定。这可能具有高性能和相对透明的从行到对象的映射的优势。但每当类发生变化或数据库实现发生变化时，维护可能会很烦人。
- en: A well-established ORM project might involve some initial effort to learn the
    features of the ORM, but the long-term simplifications are important benefits.
    Learning the features of an ORM layer can involve both initial work and rework
    as lessons are learned. The first attempts at a design that has good object features
    and still fits within the SQL framework will have to be redone as the application
    trade-offs and considerations become clearer.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成熟的ORM项目可能需要一些初始努力来学习ORM的特性，但长期的简化是重要的好处。学习ORM层的特性可能既涉及初始工作，也涉及重新工作，因为经验教训。首次尝试设计具有良好对象特性并仍适合SQL框架的设计将不得不重新进行，因为应用程序的权衡和考虑变得更加清晰。
- en: Keys and key designs
  id: totrans-929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键和关键设计
- en: Because SQL depends on keys, we must take care to design and manage keys for
    our various objects. We must design a mapping from an object to the key that will
    be used to identify that object. One choice is to locate an attribute (or combination
    of attributes) that are proper primary keys and cannot be changed. Another choice
    is to generate surrogate keys that cannot be changed; this allows all other attributes
    to be changed.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 因为SQL依赖于键，我们必须小心设计和管理各种对象的键。我们必须设计从对象到将用于标识该对象的键的映射。一种选择是找到适当的主键属性（或属性组合），并且不能更改。另一种选择是生成不能更改的代理键；这允许所有其他属性被更改。
- en: Most relational databases can generate surrogate keys for us. This is usually
    the best approach. For other unique attributes or candidate key attributes, we
    can define SQL indexes to improve the processing performance.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关系数据库可以为我们生成代理键。这通常是最好的方法。对于其他唯一属性或候选键属性，我们可以定义SQL索引以提高处理性能。
- en: 'We must also consider the foreign key relationships among objects. There are
    several common design patterns: One-to-Many, Many-to-One, Many-to-Many, and Optional
    One-to-One. We need to be cognizant of how SQL uses keys to implement these relationships
    and how SQL queries will be used to fill in the Python collections.'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须考虑对象之间的外键关系。有几种常见的设计模式：一对多，多对一，多对多和可选的一对一。我们需要知道SQL如何使用键来实现这些关系，以及SQL查询将用于填充Python集合。
- en: Application software layers
  id: totrans-933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用软件层
- en: 'Because of the relative sophistication available when using `sqlite3`, our
    application software must become more properly layered. Generally, we''ll look
    at software architectures with layers resembling the following ones:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`sqlite3`时相对复杂，我们的应用软件必须更加合理地分层。通常，我们将查看具有类似以下层的软件架构：
- en: 'The presentation layer: This is a top-level user interface, either a web presentation
    or a desktop GUI.'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示层：这是顶层用户界面，可以是Web演示或桌面GUI。
- en: 'The application layer: This is the internal service or controllers that make
    the application work. This could be called the processing model, different from
    the logical data model.'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层：这是使应用程序工作的内部服务或控制器。这可以称为处理模型，与逻辑数据模型不同。
- en: 'The business layer or the problem domain model layer: These are the objects
    that define the business domain or the problem space. This is sometimes called
    the logical data model. We looked at how we might model these objects using a
    microblog blog and post example.'
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务层或问题域模型层：这些是定义业务领域或问题空间的对象。有时被称为逻辑数据模型。我们看了如何使用微博博客和帖子示例来对这些对象进行建模。
- en: 'Infrastructure: This often includes several layers as well as other cross-cutting
    concerns such as logging, security, and network access:'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施：这通常包括几个层，以及其他横切关注点，如日志记录、安全性和网络访问：
- en: 'The data access layer: These are protocols or methods to access the data objects.
    It is often an ORM layer. We''ve looked at SQLAlchemy. There are numerous other
    choices for this.'
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问层：这些是访问数据对象的协议或方法。通常是ORM层。我们已经看过SQLAlchemy。还有许多其他选择。
- en: 'The persistence layer: This is the physical data model as seen in file storage.
    The `sqlite3` module implements persistence. When using an ORM layer such as SQLAlchemy,
    we only reference SQLite when creating an Engine.'
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性层：这是在文件存储中看到的物理数据模型。`sqlite3`模块实现了持久性。当使用诸如SQLAlchemy之类的ORM层时，我们只在创建引擎时引用SQLite。
- en: When looking at `sqlite3` in this chapter and `shelve` in [Chapter 10](ch10.html
    "Chapter 10. Storing and Retrieving Objects via Shelve"), *Storing and Retrieving
    Objects via Shelve*, it becomes clear that mastering object-oriented programming
    involves some higher-level design patterns. We can't simply design classes in
    isolation, but we need to look at how classes are going to be organized into larger
    structures.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中查看`sqlite3`和[第10章](ch10.html "第10章。通过Shelve存储和检索对象")中的`shelve`，*通过Shelve存储和检索对象*，清楚地表明掌握面向对象编程涉及一些更高级别的设计模式。我们不能简单地孤立设计类，而是需要考虑如何将类组织成更大的结构。
- en: Looking forward
  id: totrans-942
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In the next chapter, we'll look at transmitting and sharing objects using REST.
    This design pattern shows us how to manage the representation of the state and
    how to transfer the object state from process to process. We'll leverage a number
    of persistence modules to represent the state of an object that is being transmitted.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究如何使用REST传输和共享对象。这种设计模式向我们展示了如何管理状态的表示以及如何将对象状态从一个进程传输到另一个进程。我们将利用许多持久性模块来表示正在传输的对象的状态。
- en: In [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, we'll look at configuration files. We'll
    look at several ways to make use of persistent representations of data that controls
    an application.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.html "第13章。配置文件和持久性")中，*配置文件和持久性*，我们将研究配置文件。我们将研究利用持久性数据的几种方法，以控制应用程序。
- en: Chapter 12. Transmitting and Sharing Objects
  id: totrans-945
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。传输和共享对象
- en: We'll expand on our serialization techniques for the object representation shown
    in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*. When
    we need to transmit an object, we're performing some kind of **Representational
    State Transfer** (**REST**). When we serialize an object, we're creating a representation
    of the state of an object. This representation can be transferred to another process
    (usually on another host computer); the other process can then build a version
    of the original object from the representation of the state and a local definition
    of the class.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们在[第9章](ch09.html "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")中展示的对象表示的序列化技术，*序列化和保存
    - JSON、YAML、Pickle、CSV和XML*。当我们需要传输一个对象时，我们执行某种**表述性状态转移**（**REST**）。当我们序列化一个对象时，我们正在创建对象状态的表示。这种表示可以传输到另一个进程（通常在另一台主机上）；然后，另一个进程可以根据状态的表示和本地类的定义构建原始对象的版本。
- en: We can perform REST processing in a number of ways. One aspect of it is the
    state representation that we can use. Another aspect is the protocol to control
    the transfer. We won't cover all of the combinations of these aspects. Instead,
    we'll focus on two combinations.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式执行REST处理。其中之一是我们可以使用的状态表示。另一个方面是控制传输的协议。我们不会涵盖所有这些方面的组合。相反，我们将专注于两种组合。
- en: For internet transfers, we'll leverage the HTTP protocol to implement **Create-Retrieve-Update-Delete**
    (**CRUD**) processing operations. This is commonly called a REST web server. We'll
    look at providing RESTful web services as well. This will be based on Python's
    **Web Service Gateway Interface** (**WSGI**) reference implementation, the `wsgiref`
    package.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 对于互联网传输，我们将利用HTTP协议来实现**创建-检索-更新-删除**（**CRUD**）处理操作。这通常被称为REST Web服务器。我们还将研究提供RESTful
    Web服务。这将基于Python的**Web服务网关接口**（**WSGI**）参考实现，即`wsgiref`包。
- en: For local transfers among processes on the same host, we'll look at the local
    message queues provided by the `multiprocessing` module. There are numerous sophisticated
    queue management products. We'll focus on the standard library offerings.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在同一主机上的进程之间的本地传输，我们将研究`multiprocessing`模块提供的本地消息队列。有许多复杂的队列管理产品。我们将专注于标准库提供的内容。
- en: This kind of processing builds on using JSON or XML to represent an object.
    For WSGI, we're adding the HTTP protocol and a set of design patterns to define
    transactions in a web server. For multiprocessing, we're adding a processing pool.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理建立在使用JSON或XML来表示对象的基础上。对于WSGI，我们将添加HTTP协议和一组设计模式来定义Web服务器中的事务。对于多处理，我们将添加一个处理池。
- en: 'There is an additional consideration when working with REST transfers: the
    source or the data might not be trustworthy. We must implement some security.
    When it comes to the commonly used representations, JSON and XML, there are few
    security considerations. YAML introduces a security concern and supports a safe
    load operation; see [Chapter 9](ch09.html "Chapter 9. Serializing and Saving –
    JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML* for more information on this. Because of the security issue, the
    `pickle` module also offers a restricted unpickler that can be trusted to not
    import unusual modules and execute damaging code.'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理REST传输时，还有一个额外的考虑因素：源或数据可能不可信。我们必须实施一些安全措施。在使用常用表示形式JSON和XML时，几乎没有安全考虑。YAML引入了一个安全问题，并支持安全加载操作；有关更多信息，请参见[第9章](ch09.html
    "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")中的内容。由于安全问题，`pickle`模块还提供了一个受限制的反序列化器，可以信任不导入异常模块并执行有害代码。
- en: Class, state, and representation
  id: totrans-952
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类、状态和表示
- en: In some cases, we might be creating a server that will provide data to remote
    clients. In other cases, we might want to consume data from remote computers.
    We may have a hybrid situation where our application is both a client of remote
    computers and servers to mobile applications. There are many situations where
    our application works with objects that are persisted remotely.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能正在创建一个将向远程客户端提供数据的服务器。在其他情况下，我们可能希望从远程计算机消耗数据。我们可能有一个混合情况，即我们的应用既是远程计算机的客户端，又是移动应用程序的服务器。有许多情况下，我们的应用程序与远程持久化的对象一起工作。
- en: We need a way to transmit objects from process to process. We can decompose
    the larger problem into two smaller problems. The inter-networking protocols can
    help us transmit bytes from a process on one host to a process on another host.
    Serialization can transform our objects into bytes.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来从一个进程传输对象到另一个进程。我们可以将更大的问题分解为两个较小的问题。互联网协议可以帮助我们将字节从一个主机上的一个进程传输到另一个主机上的一个进程。序列化可以将我们的对象转换为字节。
- en: Unlike the object state, we transmit class definitions through an entirely separate
    and very simple method. We exchange class definitions via the source code. If
    we need to supply a class definition to a remote host, we send the Python source
    code to that host. The code must be properly installed to be useful; this is often
    a manual operation performed by an administrator.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象状态不同，我们通过一个完全独立且非常简单的方法传输类定义。我们通过源代码交换类定义。如果我们需要向远程主机提供类定义，我们将向该主机发送Python源代码。代码必须被正确安装才能有用；这通常是由管理员手动执行的操作。
- en: Our networks transmit bytes. Therefore, we need to represent the values of an
    object's instance variables as a stream of bytes. Often, we'll use a two-step
    transformation to bytes; we'll represent the state of an object as a string and
    rely on the string to provide bytes in one of the standard encodings.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络传输字节。因此，我们需要将对象实例变量的值表示为字节流。通常，我们将使用两步转换为字节；我们将对象的状态表示为字符串，并依赖于字符串以标准编码之一提供字节。
- en: Using HTTP and REST to transmit objects
  id: totrans-957
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTP和REST传输对象
- en: '**Hypertext Transfer Protocol** (**HTTP**) is defined through a series of **Request
    for Comments** (**RFC**) documents. We won''t review all of the particulars, but
    we will touch on three high points.'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）是通过一系列**请求评论**（**RFC**）文档定义的。我们不会审查所有细节，但我们将触及三个重点。'
- en: The HTTP protocol includes requests and replies. A request includes a method,
    a **Uniform Resource Identifier** (**URI**), some headers, and optional attachments.
    A number of available methods are defined in the standards. Most browsers focus
    on making the `GET` and `POST` requests. The standard browsers include the `GET`,
    `POST`, `PUT`, and `DELETE` requests, which are the ones that we'll leverage because
    they correspond to the CRUD operations. We'll ignore most of the headers and focus
    on the path portion of the URI.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议包括请求和响应。请求包括方法、**统一资源标识符**（**URI**）、一些标头和可选附件。标准中定义了许多可用的方法。大多数浏览器专注于进行`GET`和`POST`请求。标准浏览器包括`GET`、`POST`、`PUT`和`DELETE`请求，这些是我们将利用的，因为它们对应于CRUD操作。我们将忽略大部分标头，关注URI的路径部分。
- en: A reply includes a status code number and reason, headers, and some data. There
    are a variety of status code numbers. Of them, we're interested in just a few.
    The `200` status code is the generic `OK` response from a server. A `201` status
    code is the `Created` response, which might be appropriate to show us that a post
    worked and data was posted. A `204` status code is the `No Content` response,
    which might be appropriate for `DELETE`. The `400` status code is `Bad Request`,
    the `401` status code is `Unauthorized`, the `404` status code is `Not Found`.
    These status code are commonly used to reflect operations that cannot be performed,
    or are not valid.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包括状态码数字和原因、标头和一些数据。有各种各样的状态码数字。其中，我们只对其中的一些感兴趣。`200`状态码是服务器的通用`OK`响应。`201`状态码是`已创建`响应，可能适合显示我们的帖子已经成功并且数据已经发布。`204`状态码是`无内容`响应，可能适合`DELETE`。`400`状态码是`错误请求`，`401`状态码是`未经授权`，`404`状态码是`未找到`。这些状态码通常用于反映无法执行或无效的操作。
- en: Most `2xx` successful replies will include an encoded object or sequence of
    objects. A `4xx` error reply may include a more detailed error message.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`2xx`成功的响应将包括一个编码的对象或对象序列。`4xx`错误响应可能包括更详细的错误消息。
- en: HTTP is defined to be stateless. The server is not expected to have any recollection
    of previous interactions with a client. We have a number of candidate workarounds
    to this limitation. For interactive websites, cookies are used to track the transaction
    state and improve the application behavior. For web services, however, the client
    will not be a person; each request can include the authentication credentials.
    This imposes the further obligation to secure the connection. For our purposes,
    we'll assume that the server will use **Secure Sockets Layer** (**SSL**) and use
    an HTTPS connection on port 443 instead of HTTP on port 80.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP被定义为无状态的。服务器不应该记得先前与客户端的交互。我们有许多候选的解决方法来解决这个限制。对于交互式网站，使用cookie来跟踪事务状态并改善应用程序行为。然而，对于Web服务，客户端不会是一个人；每个请求都可以包括认证凭据。这进一步要求保护连接。对于我们的目的，我们将假设服务器将使用**安全套接字层**（**SSL**）并在端口443上使用HTTPS连接，而不是在端口80上使用HTTP。
- en: Implementing CRUD operations via REST
  id: totrans-963
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过REST实现CRUD操作
- en: We'll look at three fundamental ideas behind the REST protocol. The first idea
    is to use any handy text serialization of an object's state. Second, we can use
    the HTTP request URI to name an object; a URI can include any level of detail,
    including a schema, module, class, and object identity in a uniform format. Finally,
    we can use the HTTP method to map to CRUD rules to define the action to be performed
    on the named object.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论REST协议背后的三个基本理念。第一个理念是使用任何方便的文本序列化对象状态。其次，我们可以使用HTTP请求URI来命名一个对象；URI可以包括任何级别的细节，包括模式、模块、类和统一格式的对象标识。最后，我们可以使用HTTP方法来映射到CRUD规则，以定义对命名对象执行的操作。
- en: 'The use of HTTP for RESTful services pushes the envelope on the original definitions
    of HTTP requests and replies. This means that some of the request and reply semantics
    are open to active, ongoing discussion. Rather than presenting all of the alternatives,
    each of which has unique merits, we''ll suggest a single approach. Our focus is
    on the Python language, not the more general problem of designing RESTful web
    services. A REST server will often support CRUD operations via the following five
    essential use cases:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 将HTTP用于RESTful服务推动了HTTP请求和响应的原始定义的边界。这意味着一些请求和响应语义是开放的，正在进行讨论。我们不会呈现所有的替代方案，每个替代方案都有独特的优点，我们将建议一个单一的方法。我们的重点是Python语言，而不是设计RESTful
    Web服务的更一般的问题。REST服务器通常通过以下五个基本用例支持CRUD操作：
- en: '**Create**: We''ll use an `HTTP POST` request to create a new object and a
    URI that provides class information only. A path such as `//host/app/blog/` might
    name the class. The response could be a 201 message that includes a copy of the
    object as it was finally saved. The returned object information may include the
    URI assigned by the RESTful server for the newly created object or the relevant
    keys to construct the URI. A `POST` request is expected to change the RESTful
    resources by creating something new.'
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：我们将使用`HTTP POST`请求来创建一个新对象，并提供仅提供类信息的URI。例如`//host/app/blog/`这样的路径可能命名类。响应可能是一个包含对象副本的201消息，该对象最终被保存。返回的对象信息可能包括RESTful服务器为新创建的对象分配的URI，或者构建URI的相关键。`POST`请求预期通过创建新的东西来改变RESTful资源。'
- en: '**Retrieve – Search**: This is a request that can retrieve multiple objects.
    We''ll use an `HTTP GET` request and a URI that provides search criteria, usually
    in the form of a query string after the `?` character. The URI might be `//host/app/blog/?title="Travel
    2012-2013"`. Note that `GET` never makes a change to the state of any RESTful
    resources.'
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索-搜索：这是一个可以检索多个对象的请求。我们将使用`HTTP GET`请求和提供搜索条件的URI，通常是在`?`字符之后的查询字符串的形式。URI可能是`//host/app/blog/?title="Travel
    2012-2013"`。请注意，`GET`永远不会改变任何RESTful资源的状态。
- en: '**Retrieve – Instance**: This is a request for a single object. We''ll use
    an `HTTP GET` request and a URI that names a specific object in the URI path.
    The URI might be `//host/app/blog/id/`. While the response is expected to be a
    single object, it might still be wrapped in a list to make it compatible with
    a search response. As this response is `GET`, there''s no change in the state.'
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索-实例：这是一个请求单个对象的请求。我们将使用`HTTP GET`请求和在URI路径中命名特定对象的URI。URI可能是`//host/app/blog/id/`。虽然预期的响应是一个单一对象，但它可能仍然被包装在列表中，以使其与搜索响应兼容。由于此响应是`GET`，因此状态没有变化。
- en: '**Update**: We''ll use an `HTTP PUT` request and a URI that identifies the
    object to be replaced. The URI might be `//host/app/blog/id/`. The response could
    be a 200 message that includes a copy of the revised object. Clearly, this is
    expected to make a change to the RESTful resources. There are good reasons to
    use other status responses than 200\. We''ll stick to 200 for our examples here.'
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新：我们将使用`HTTP PUT`请求和标识要替换的对象的URI。URI可能是`//host/app/blog/id/`。响应可能是一个包含修订对象副本的200消息。显然，这预计会对RESTful资源进行更改。使用200以外的其他状态响应是有充分理由的。我们将在这里的示例中坚持使用200。
- en: '**Delete**: We''ll use an `HTTP DELETE` request and a URI that looks like `//host/app/blog/id/`.
    The response could be a simple `204 NO CONTENT` without providing any object details
    in the response.'
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：我们将使用`HTTP DELETE`请求和类似`//host/app/blog/id/`的URI。响应可能是一个简单的`204 NO CONTENT`，在响应中不提供任何对象细节。
- en: As the HTTP protocol is stateless, there's no provision for logon and logoff.
    Each request must be separately authenticated. We will often make use of the HTTP
    `Authorization` header to provide the username and password credentials. When
    doing this, we absolutely must also use SSL to provide security for the content
    of the `Authorization` header. There are more sophisticated alternatives that
    leverage separate identity management servers to provide authentication tokens
    rather than credentials.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP协议是无状态的，没有提供登录和注销的功能。每个请求必须单独进行身份验证。我们经常使用HTTP `Authorization`头来提供用户名和密码凭据。在这样做时，我们绝对必须使用SSL来保护`Authorization`头的内容。还有更复杂的替代方案，利用单独的身份管理服务器提供身份验证令牌而不是凭据。
- en: Implementing non-CRUD operations
  id: totrans-972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施非CRUD操作
- en: Some applications will have operations that can't be easily characterized as
    CRUD. We might, for example, have a **Remote Procedure Call** (**RPC**) style
    application that performs a complex calculation. The calculation's arguments are
    provided via the URI, so there's no change RESTful in the server state.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序将具有无法轻松归类为CRUD的操作。例如，我们可能有一个**远程过程调用**（**RPC**）风格的应用程序，执行复杂的计算。计算的参数通过URI提供，因此在服务器状态中没有RESTful的变化。
- en: Most of the time, these calculation-focused operations can be implemented as
    the `GET` requests as there's no change in the state. However, we might consider
    making them `POST` requests if we are going to preserve a log of the request and
    reply as part of a non-repudiation scheme. This is particularly important in websites
    where a fee is charged for the services.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些以计算为重点的操作可以实现为`GET`请求，因为状态没有变化。然而，如果我们要保留请求和回复的日志作为不可否认方案的一部分，我们可能会考虑将它们作为`POST`请求。这在收费网站中尤为重要。
- en: The REST protocol and ACID
  id: totrans-975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REST协议和ACID
- en: The ACID properties are defined in [Chapter 10](ch10.html "Chapter 10. Storing
    and Retrieving Objects via Shelve"), *Storing and Retrieving Objects via Shelve*.
    These properties are Atomic, Consistent, Isolated, and Durable. These are essential
    features of a transaction that consists of multiple database operations. These
    properties don't automatically become part of the REST protocol. We must consider
    how HTTP works when we ensure that the ACID properties are met.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: ACID属性在[第10章](ch10.html "第10章。通过Shelve存储和检索对象")中定义，*通过Shelve存储和检索对象*。这些属性是原子性、一致性、隔离性和持久性。这些是由多个数据库操作组成的事务的基本特征。这些属性不会自动成为REST协议的一部分。我们必须考虑当我们确保满足ACID属性时HTTP是如何工作的。
- en: Each HTTP request is atomic; therefore, we should avoid designing an application
    that makes a series of related `POST` requests that we hope become atomic. Instead,
    we should look for a way to bundle all of the information into a single request.
    Additionally, we have to be aware that requests will often be interleaved from
    a variety of clients; therefore, we don't have a tidy way to handle isolation
    among interleaved sequences of requests. If we have a properly multilayered design,
    we should delegate the durability to a separate persistence module.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP请求都是原子的；因此，我们应该避免设计一个应用程序，该应用程序进行一系列相关的`POST`请求，希望这些请求变得原子。相反，我们应该寻找一种将所有信息捆绑成一个单一请求的方法。此外，我们必须意识到请求通常会从各种客户端交错进行；因此，我们没有一种干净的方法来处理交错请求序列之间的隔离。如果我们有一个适当的多层设计，我们应该将持久性委托给一个单独的持久性模块。
- en: In order to achieve the ACID properties, a common technique is to define the
    `POST`, `PUT`, or `DELETE` requests that contain *all* the relevant information.
    By providing a single composite object, the application can perform all of the
    operations in a single REST request. These larger objects become *documents* that
    might contain several items that are part of the more complex transaction.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现ACID属性，一个常见的技术是定义包含*所有*相关信息的`POST`、`PUT`或`DELETE`请求。通过提供单个复合对象，应用程序可以在单个REST请求中执行所有操作。这些更大的对象成为*文档*，可能包含更复杂交易的几个部分。
- en: 'When looking at our blog and post relationships, we see that we might want
    to handle two kinds of `HTTP POST` requests to create a new `Blog` instance. The
    two requests are as follows:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看我们的博客和帖子关系时，我们发现我们可能希望处理两种`HTTP POST`请求来创建一个新的`Blog`实例。这两个请求如下：
- en: '**A blog with only a title and no additional post entries**: We can easily
    implement ACID properties for this, as it''s only a single object.'
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只有标题没有额外帖子条目的博客**：对于这个，我们可以很容易地实现ACID属性，因为它只是一个单一的对象。'
- en: '**A composite object that is a blog plus a collection of post entries**: We
    need to serialize the blog and all of the relevant `Post` instances. This needs
    to be sent as a single `POST` request. We can then implement the ACID properties
    by creating the blog, the related posts, and returning a single `201 Created`
    status when the entire collection of objects has been made durable. This may involve
    a complex multistatement transaction in the database that supports the RESTful
    web server.'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个复合对象，即博客加上一系列帖子条目**：我们需要序列化博客和所有相关的`Post`实例。这需要作为一个单独的`POST`请求发送。然后，我们可以通过创建博客、相关帖子，并在整个对象集合变得持久时返回单个`201
    Created`状态来实现ACID属性。这可能涉及支持RESTful web服务器的数据库中的复杂多语句事务。'
- en: Choosing a representation – JSON, XML, or YAML
  id: totrans-982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择一种表示形式 - JSON、XML或YAML
- en: 'There''s no good reason to pick a single representation; it''s relatively easy
    to support a number of representations. The client should be permitted to demand
    a representation. There are several places where a client can specify the representation:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个很好的理由来选择单一的表示；支持多种表示相对容易。客户端应该被允许要求一种表示。客户端可以在几个地方指定表示：
- en: We can use a part of a query string, `https://host/app/class/id/?form=XML`.
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用查询字符串的一部分，`https://host/app/class/id/?form=XML`。
- en: 'We can use a part of the URI: `https://host/app;XML/class/id/`. In this example,
    we''ve used a sub-delimiter for the application to identify the required representation.
    The `app;XML` syntax names the application, `app`, and the format, `XML`.'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用URI的一部分：`https://host/app;XML/class/id/`。在这个例子中，我们使用了一个子分隔符来标识所需的表示。`app;XML`语法命名了应用程序`app`和格式`XML`。
- en: We can use the fragment identifier, `https://host/app/class/id/#XML`.
  id: totrans-986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用片段标识符，`https://host/app/class/id/#XML`。
- en: We can provide it in a header. The `Accept` header, for example, can be used
    to specify the representation.
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在头部提供它。例如，`Accept`头可以用来指定表示形式。
- en: None of these is *clearly* superior. Compatibility with existing RESTful web
    services may suggest a particular format. The relative ease with which a framework
    parses a URI pattern may suggest a format.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都没有*明显*的优势。与现有的RESTful web服务的兼容性可能会建议特定的格式。框架解析URI模式的相对容易可能会建议一种格式。
- en: JSON is preferred by many JavaScript presentation layers. Other representations
    such as XML or YAML can be helpful for other presentation layers or other kinds
    of clients. In some cases, there may be yet another representation. For example,
    MXML or XAML might be required by a particular client application.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: JSON被许多JavaScript表示层所偏爱。其他表示形式，如XML或YAML，对其他表示层或其他类型的客户端也可能有帮助。在某些情况下，可能会有另一种表示形式。例如，特定客户端应用程序可能需要MXML或XAML。
- en: Implementing a REST server – WSGI and mod_wsgi
  id: totrans-990
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现REST服务器 - WSGI和mod_wsgi
- en: As REST is built on HTTP, a REST sever is an extension to an HTTP server. For
    robust, high-performance, secure operations, common practice is to build on a
    server such as **Apache httpd** or the **nginx**. These servers don't support
    Python by default; they require an extension module to interface with a Python
    application.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST是建立在HTTP之上的，因此REST服务器是对HTTP服务器的扩展。为了进行强大、高性能、安全的操作，通常的做法是在诸如**Apache httpd**或**nginx**之类的服务器上构建。这些服务器默认不支持Python；它们需要一个扩展模块来与Python应用程序进行接口。
- en: One widely used interface between web servers and Python is the WSGI. For more
    information, see [http://www.wsgi.org](http://www.wsgi.org). The Python Standard
    Library includes a WSGI reference implementation. See PEP 3333, [http://www.python.org/dev/peps/pep-3333/](http://www.python.org/dev/peps/pep-3333/),
    for the ways this reference implementation works in Python 3.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web服务器和Python之间广泛使用的接口是WSGI。有关更多信息，请参见[http://www.wsgi.org](http://www.wsgi.org)。Python标准库包括一个WSGI参考实现。请参阅PEP
    3333，[http://www.python.org/dev/peps/pep-3333/](http://www.python.org/dev/peps/pep-3333/)，了解这个参考实现在Python
    3中的工作方式。
- en: The idea behind WSGI is to standardize the HTTP request-reply processing around
    a relatively simple and extensible Python API. This allows us to architect complex
    Python solutions out of relatively independent components. The goal is to create
    a nested series of applications that perform incremental processing on the request.
    This creates a kind of pipeline where each stage adds information to the request
    environment.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI背后的理念是围绕一个相对简单和可扩展的Python API标准化HTTP请求-响应处理。这使我们能够从相对独立的组件中构建复杂的Python解决方案。目标是创建一个嵌套的应用程序系列，对请求进行增量处理。这创建了一种管道，其中每个阶段都向请求环境添加信息。
- en: 'Each WSGI application must have this API:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 每个WSGI应用程序必须具有此API：
- en: '[PRE144]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The `environ` variable must be `dict` with environmental information. The `start_response`
    function must be used to start preparing a response to the client; this is how
    the response status code and headers are sent. The return value must be an iterable
    over strings; that is, the body of the response.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '`environ`变量必须是包含环境信息的`dict`。必须使用`start_response`函数来开始准备向客户端发送响应；这是发送响应状态码和标头的方式。返回值必须是一个字符串的可迭代对象；也就是说，响应的正文。'
- en: The term *application* is used flexibly in the WSGI standard. A single server
    might have many WSGI applications. It's not the intent of WSGI to encourage or
    require programming at a low level of WSGI-compliant applications. The intent
    is to use larger, more sophisticated web frameworks. The web frameworks would
    all use the WSGI API definition to ensure compatibility.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 在WSGI标准中，术语*应用程序*被灵活地使用。一个单一的服务器可能有许多WSGI应用程序。WSGI的目的不是鼓励或要求在符合WSGI的应用程序的低级别进行编程。其目的是使用更大、更复杂的Web框架。所有的Web框架都会使用WSGI
    API定义来确保兼容性。
- en: The WSGI reference implementation is not intended to be a public-facing web
    server. This server doesn't handle SSL directly; some work needs to be done to
    wrap the sockets with proper SSL encryption. In order to access port 80 (or port
    443), the process must execute in the `setuid` mode with a privileged user ID.
    One common practice is to install the WSGI extension module in a web server or
    use a web server that supports a WSGI API. This means that web requests are routed
    to Python from the web server using the standard WSGI interface. This allows the
    web server to provide static content. The Python applications available through
    the WSGI interface will provide the dynamic content.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI参考实现不打算成为公共面向的Web服务器。此服务器不直接处理SSL；需要一些工作来使用适当的SSL加密包装套接字。为了访问端口80（或端口443），进程必须以`setuid`模式执行，使用特权用户ID。一种常见的做法是在Web服务器中安装WSGI扩展模块或使用支持WSGI
    API的Web服务器。这意味着Web请求通过标准WSGI接口从Web服务器路由到Python。这允许Web服务器提供静态内容。通过WSGI接口可用的Python应用程序将提供动态内容。
- en: Here's a list of web servers that are either written in Python or have Python
    plugins, [https://wiki.python.org/moin/WebServers](https://wiki.python.org/moin/WebServers).
    These servers (or plugins) are intended to provide robust, secure, public-facing
    web servers.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些要么用Python编写，要么具有Python插件的Web服务器的列表，[https://wiki.python.org/moin/WebServers](https://wiki.python.org/moin/WebServers)。这些服务器（或插件）旨在提供强大、安全的、面向公众的Web服务器。
- en: An alternative is to build a standalone Python server and use redirection to
    shunt requests from the public-facing server to the separate Python daemon. When
    working with Apache httpd, a separate Python daemon can be created via the `mod_wsgi`
    module. As our focus is Python, we'll avoid nginx or Apache httpd details.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是构建一个独立的Python服务器，并使用重定向将请求从面向公众的服务器转移到单独的Python守护程序。在使用Apache httpd时，可以通过`mod_wsgi`模块创建一个单独的Python守护程序。由于我们专注于Python，我们将避免nginx或Apache
    httpd的细节。
- en: Creating a simple REST application and server
  id: totrans-1001
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的REST应用程序和服务器
- en: We'll write a very simple REST server that provides spins of a Roulette wheel.
    This is an example of a service that makes a response to a simple request. We'll
    focus on the RESTful web server programming in Python. There are additional details
    required to plug this software into a larger web server such as Apache httpd or
    nginx.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个非常简单的REST服务器，提供轮盘赌的旋转。这是一个对简单请求做出响应的服务的示例。我们将专注于Python中的RESTful web服务器编程。还需要一些额外的细节来将此软件插入到较大的Web服务器中，例如Apache
    httpd或nginx。
- en: 'First, we''ll define a simplified Roulette wheel:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个简化的轮盘赌轮：
- en: '[PRE145]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The `Wheel` class is a list of bins. Each bin is `dict`; the keys are bets that
    will be winners if the ball lands in that bin. The values in a bin are the payout
    ratios. We've only shown you a short list of bets. The complete list of available
    Roulette bets is quite large.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wheel`类是一个箱子的列表。每个箱子都是`dict`；键是如果球落在该箱子中将获胜的赌注。箱子中的值是支付比例。我们只向您展示了一个简短的赌注列表。可用的轮盘赌赌注的完整列表相当庞大。'
- en: 'Also, we''ve omitted the zero or double zero bins. There are two different
    kinds of commonly used wheels. Here are two mixin classes that define the different
    kinds of commonly used wheels:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们省略了零或双零箱。有两种不同类型的常用轮子。以下是定义常用轮子不同类型的两个混合类：
- en: '[PRE146]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The `Zero` mixin includes an initialization for a single zero. The `DoubleZero`
    mixin includes the double zero. These are relatively simple bins; they only payoff
    if a bet is made on the number itself.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zero` mixin包括单个零的初始化。`DoubleZero` mixin包括双零。这些是相对简单的箱子；只有在对数字本身下注时才会有回报。'
- en: We've used mixins here because we're going to tweak the definition of `Wheel`
    in some of the following examples. By using mixins, we can ensure that each extension
    to the base class, `Wheel`, will work consistently. For more information on the
    mixin-style design, see [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用混合类，因为我们将在以下一些示例中调整`Wheel`的定义。通过使用混合类，我们可以确保对基类`Wheel`的每个扩展都能保持一致。有关混合样式设计的更多信息，请参见[第8章](ch08.html
    "第8章。装饰器和混合类-横切面")，*装饰器和混合类-横切面*。
- en: 'Here are the two subclasses that define the different kinds of commonly used
    wheels:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是定义常用轮子不同类型的两个子类：
- en: '[PRE147]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'These two definitions extend the basic `Wheel` class with mixins that will
    initialize the bins properly for each kind of wheel. These concrete subclasses
    of `Wheel` can be used as follows:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义使用混合类扩展了基本的`Wheel`类，这些混合类将为每种类型的轮子正确初始化箱子。`Wheel`的这些具体子类可以如下使用：
- en: '[PRE148]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Each evaluation of `spin()` produces a simple dictionary like the following
    one:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '`spin()`的每次评估都会产生一个简单的字典，如下所示：'
- en: '[PRE149]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The keys in this `dict` are the bet names. The value is a two-tuple with the
    payout ratio. The previous example shows us the Red 12 as a winner; it''s also
    low and even. If we had placed a bet on 12, our winnings would be 35 times our
    bet, a payout of 35 to 1\. The other propositions have payout of 1 to 1: we''d
    double our money.'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`dict`中的键是赌注名称。值是一个包含支付比例的两元组。前面的例子向我们展示了红色12作为赢家；它也是低和偶数。如果我们在12上下注，我们的赢利将是我们的赌注的35倍，支付比例为35比1。其他赌注的支付比例为1比1：我们会翻倍赢钱。
- en: We'll define a WSGI application that uses a simple path to determine which type
    of wheel to use. A URI such as `http://localhost:8080/european/` will use the
    European wheel. Any other path will use the American wheel.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个WSGI应用程序，使用简单的路径来确定使用哪种类型的轮子。例如`http://localhost:8080/european/`这样的URI将使用欧洲轮盘。任何其他路径将使用美式轮盘。
- en: 'Here''s a WSGI application that uses a `Wheel` instance:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`Wheel`实例的WSGI应用程序：
- en: '[PRE150]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This shows us some of the essential ingredients in a WSGI application.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了WSGI应用程序中的一些基本要素。
- en: First, we used the `wsgiref.util.shift_path_info()` function to examine the
    `environ['PATH_INFO']` value. This will parse one level of the path information
    in the request; it will either return the string value that was found, or return
    `None` in the case of a path not being provided at all.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`wsgiref.util.shift_path_info()`函数来检查`environ['PATH_INFO']`的值。这将解析请求中路径信息的一个级别；它将返回找到的字符串值，或者在没有提供路径的情况下返回`None`。
- en: Second, the logging line shows us that we *must* write to `sys.stderr` if we
    want to produce a log. Anything written to `sys.stdout` will be used as part of
    the response from the WSGI application. Anything that we attempt to print before
    the call to `start_response()` will lead to exceptions because the status and
    headers were not sent.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，日志行告诉我们，如果我们想生成日志，*必须*写入`sys.stderr`。写入`sys.stdout`的任何内容都将被用作WSGI应用程序的响应的一部分。在调用`start_response()`之前打印的任何内容都将导致异常，因为状态和标头尚未发送。
- en: Third, we evaluated the request to compute the response. We used two globals,
    `european` and `american`, to provide a consistently randomized sequence of responses.
    If we attempt to create a unique `Wheel` instance for each request, we make inappropriate
    use of the random number generator.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们评估请求以计算响应。我们使用两个全局变量`european`和`american`，以提供一致随机化的响应序列。如果我们尝试为每个请求创建一个唯一的`Wheel`实例，那么我们就不恰当地使用了随机数生成器。
- en: Fourth, we formulated a response with a proper status code and HTTP headers.
    The body of the response is a JSON document that we've encoded using UTF-8 to
    make a proper byte stream as required by HTTP.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，我们用适当的状态码和HTTP标头制定了一个响应。响应的主体是一个JSON文档，我们使用UTF-8进行编码，以生成符合HTTP要求的适当字节流。
- en: 'We can start a demonstration version of this server with a function such as
    the following:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下函数启动此服务器的演示版本：
- en: '[PRE151]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The `wsgiref.simple_server.make_server()` function creates the server object.
    The object will invoke the callable `wheel()` to process each request. We've used
    the local hostname `''` and a non-privileged port, `8080`. Using the privileged
    port `80` requires `setuid` privileges and is better handled by the **Apache httpd**
    server.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsgiref.simple_server.make_server()`函数创建服务器对象。该对象将调用可调用的`wheel()`来处理每个请求。我们使用本地主机名`''''`和非特权端口`8080`。使用特权端口`80`需要`setuid`权限，并且最好由**Apache
    httpd**服务器处理。'
- en: Once the server is built, it can be left to run by itself; this is the `httpd.serve_forever()`
    method. For unit testing, however, it often works out much better to handle a
    finite number of requests and then stop the server.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 构建服务器后，它可以自行运行；这是`httpd.serve_forever()`方法。然而，对于单元测试，通常最好处理有限数量的请求，然后停止服务器。
- en: We can run this function from the command line in a terminal window. Once we
    are running the function, we can use a browser to see the responses when we make
    requests to `http://localhost:8080/`. This can be helpful when creating a technical
    spike or debugging.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在终端窗口的命令行中运行此函数。一旦我们运行该函数，我们可以使用浏览器查看我们向`http://localhost:8080/`发出请求时的响应。这在创建技术性的突发情况或调试时非常有帮助。
- en: Implementing a REST client
  id: totrans-1030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现REST客户端
- en: 'Before looking at a smarter REST server application, we''ll look at writing
    a REST client. Here''s a function that will make a simple `GET` request to a REST
    server:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看更智能的REST服务器应用程序之前，我们将看一下编写REST客户端。以下是一个将向REST服务器发出简单的`GET`请求的函数：
- en: '[PRE152]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'This shows us the essence of working with a RESTful API. The `http.client`
    module has a four-step process:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了使用RESTful API的本质。`http.client`模块有一个四步过程：
- en: To establish a connection via `HTTPConnection()`
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`HTTPConnection()`建立连接
- en: To send a request with a command and a path
  id: totrans-1035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送带有命令和路径的请求
- en: To get a response
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取响应
- en: To read the data in the response
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要读取响应中的数据
- en: The request can include an attached document (used for POST) as well as additional
    headers. In this function, we printed several parts of the response. In this example,
    we read the status code number and the reason text. Most of the time, we expect
    a status of 200 and a reason of `OK`. We also read and printed all of the headers.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 请求可以包括附加的文档（用于POST）以及其他标头。在此函数中，我们打印了响应的几个部分。在此示例中，我们读取了状态码和原因文本，并将其打印出来。大多数情况下，我们期望状态码为200，原因为“OK”。我们还读取并打印了所有标头。
- en: Finally, we read the entire response into a temporary string, named `raw`. If
    the status code was 200, we used the `json` module to load objects from the response
    string. This recovered whatever JSON-encoded objects were serialized and sent
    from the server.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将整个响应读入临时字符串`raw`。如果状态码为200，我们使用`json`模块从响应字符串中加载对象。这将恢复从服务器发送的任何JSON编码对象。
- en: If the status code is not 200, we just print the available text. It might be
    an error message or other information that is useful for debugging.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态码不是200，我们只需打印可用文本。这可能是一个错误消息或其他有用于调试的信息。
- en: Demonstrating and unit testing the RESTful services
  id: totrans-1041
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演示和单元测试RESTful服务
- en: It's relatively easy to perform a spike demonstration of a RESTful server. We
    can import the server class and function definitions and run the server function
    from a terminal window. We can connect with `http://localhost:8080` to see the
    responses.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 进行RESTful服务器的突发演示相对较容易。我们可以导入服务器类和函数定义，并从终端窗口运行服务器函数。我们可以连接到`http://localhost:8080`来查看响应。
- en: For proper unit testing, we want a more formal exchange between a client and
    a server. For a controlled unit test, we'll want to start and then stop a server
    process. We can then exercise the server and examine the responses to the client.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行适当的单元测试，我们希望客户端和服务器之间进行更正式的交换。对于受控的单元测试，我们希望启动然后停止服务器进程。然后我们可以对服务器进行测试，并检查客户端的响应。
- en: 'We can use the `concurrent.futures` module to create a separate subprocess
    to run the server. Here''s a snippet that shows us the kind of processing that
    can become part of a unit test case:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`concurrent.futures`模块创建一个单独的子进程来运行服务器。以下是一个代码片段，展示了可以成为单元测试用例一部分的处理方式：
- en: '[PRE153]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: We created a separate process by creating an instance of `concurrent.futures.ProcessPoolExecutor`.
    We can then submit a function to this server, with appropriate argument values.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建`concurrent.futures.ProcessPoolExecutor`的实例来创建一个单独的进程。然后，我们可以提交一个函数到这个服务器，带有适当的参数值。
- en: In this case, we executed our `json_get()` client function to read the default
    path, `/`, twice. Then we performed the `GET` operation on the "`/european/`"
    path two times.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们执行了我们的`json_get()`客户端函数来读取默认路径`/`两次。然后我们在"`/european/`"路径上执行了两次`GET`操作。
- en: 'The `executor.submit()` function makes the process pool evaluate the `roulette_server(4)`
    function. This will handle four requests and then terminate. Because `ProcessPoolExecutor`
    is a context manager, we''re assured that all of the resources will be properly
    cleaned up. The output log from the unit test includes groups of lines in the
    following way:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '`executor.submit()`函数使进程池评估`roulette_server(4)`函数。这将处理四个请求，然后终止。因为`ProcessPoolExecutor`是一个上下文管理器，我们可以确保所有资源都会被正确清理。单元测试的输出日志以以下方式分组：'
- en: '[PRE154]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `wheel 'european'` line is the log output from our `wheel()` WSGI application.
    The `127.0.0.1 - - [08/Dec/2013 09:32:08] "GET /european/ HTTP/1.1" 200 62` log
    line is written by default from the WSGI server, which shows us that the request
    was processed completely without an error.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '`wheel ''european''`行是我们的`wheel()`WSGI应用程序的日志输出。`127.0.0.1 - - [08/Dec/2013
    09:32:08] "GET /european/ HTTP/1.1" 200 62`日志行是默认从WSGI服务器写入的，它告诉我们请求已经完全处理，没有错误。'
- en: The next three lines are written by the client `json_get()` function. The `200
    OK` line is the first `print()` function. These lines are the headers that were
    sent as part of the server response. Finally, we show you the decoded dictionary
    object that was sent from the server to the client. In this case, the winner was
    20 Black.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端`json_get()`函数编写了接下来的三行。`200 OK`行是第一个`print()`函数。这些行是作为服务器响应的一部分发送的标头。最后，我们向您展示了从服务器发送到客户端的解码字典对象。在这种情况下，赢家是20黑。
- en: 'Also, note that our original tuples were transformed into lists by the JSON
    encoding and decoding process. Our original dict had `''20'': (35, 1)`. The result
    here after encoding and decoding is `''20'': [35, 1]`.'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '另外，请注意，我们的原始元组在JSON编码和解码过程中被转换为列表。我们原始的字典是`''20'': (35, 1)`。在编码和解码后的结果是`''20'':
    [35, 1]`。'
- en: 'Note that the module being tested will be imported by the `ProcessPool` server.
    This import will locate the named function, `roulette_server()`. Because the server
    will import the module under test, the module under test must properly use `__name__
    == "__main__"` guards to be sure that it won''t perform any additional processing
    during the import; it must only provide definitions. We must be sure to use this
    kind of construct in the script that defines a server:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正在测试的模块将由`ProcessPool`服务器导入。这个导入将找到命名函数`roulette_server()`。因为服务器将导入被测试的模块，被测试的模块必须正确使用`__name__
    == "__main__"`保护，以确保在导入期间不会执行任何额外的处理；它只能提供定义。我们必须确保在定义服务器的脚本中使用这种构造：
- en: '[PRE155]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Using Callable classes for WSGI applications
  id: totrans-1055
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Callable类来实现WSGI应用程序
- en: We can implement WSGI applications as `Callable` objects instead of standalone
    functions. This allows us to have stateful processing in our WSGI server without
    the potential confusion of global variables. In our previous example, the `get_spin()`
    WSGI application relied on two global variables, `american` and `european`. The
    binding between the application and global can be mysterious.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将WSGI应用程序实现为`Callable`对象，而不是独立的函数。这允许我们在WSGI服务器中进行有状态的处理，而不会造成全局变量的混乱。在我们之前的例子中，`get_spin()`WSGI应用程序依赖于两个全局变量，`american`和`european`。应用程序和全局变量之间的绑定可能是神秘的。
- en: 'The point of defining a class is to encapsulate the processing and data into
    a single package. We can use `Callable` objects to encapsulate our applications
    in a better manner. This can make the binding between stateful `Wheel` and WSGI
    applications clearer. Here is an extension to the `Wheel` class that makes it
    into a callable WSGI application:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类的目的是将处理和数据封装到一个单一的包中。我们可以使用`Callable`对象以更好的方式封装我们的应用程序。这可以使有状态的`Wheel`和WSGI应用程序之间的绑定更清晰。这是对`Wheel`类的扩展，使其成为一个可调用的WSGI应用程序：
- en: '[PRE156]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'We extended the base `Wheel` class to include the WSGI interface. This doesn''t
    do any parsing of the request; the WSGI processing has been pared down to just
    two steps: evaluation and response. We''ll handle parsing and logging in a higher-level,
    wrapper application. This `Wheel2` application simply picks a result and encodes
    it as the result.'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了基本的`Wheel`类，以包括WSGI接口。这不会对请求进行任何解析；WSGI处理已经被简化为只有两个步骤：评估和响应。我们将在更高级别的包装应用程序中处理解析和日志记录。这个`Wheel2`应用程序只是选择一个结果并将其编码为结果。
- en: Note that we've added a distinct design feature to the `Wheel2` class. This
    is an example of a concern that is not part of the *is-a* definition of `Wheel`.
    This is more of an *acts-as* feature. This should, perhaps, be defined as a mixin
    or a decorator rather than a first-class feature of the class definition.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经为`Wheel2`类添加了一个独特的设计特性。这是一个不属于`Wheel`的*is-a*定义的关注点的例子。这更像是一个*acts-as*特性。这可能应该被定义为一个mixin或装饰器，而不是类定义的一流特性。
- en: 'Here are two subclasses that implement American and European variations on
    Roulette:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个子类，实现了轮盘的美式和欧式变体：
- en: '[PRE157]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: These two subclasses rely on the `__call__()` method function in the superclass.
    As with the preceding examples, we're using the mixins to add appropriate zero
    bins to the wheel.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个子类依赖于超类中的`__call__()`方法函数。与前面的例子一样，我们使用mixin来向轮盘添加适当的零箱。
- en: 'We''ve changed the wheel from being a simple object to being a WSGI application.
    This means that our higher-level wrapper application can be somewhat simpler.
    Rather than evaluating some other object, the higher-level application simply
    delegates the request to the object. Here''s a revised wrapper application that
    selects the wheel to be spun and delegates the request:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将轮子从一个简单的对象变成了一个WSGI应用程序。这意味着我们的高级包装应用程序可以更简单一些。高级应用程序不是评估其他对象，而是简单地将请求委托给对象。下面是一个修改后的包装应用程序，它选择要旋转的轮子并委托请求：
- en: '[PRE158]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: When we create an instance of this `Wheel3` class, it will create the two wheels.
    Each wheel is a WSGI application.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个`Wheel3`类的实例时，它将创建两个轮子。每个轮子都是一个WSGI应用程序。
- en: When a request is handled, the `Wheel3` WSGI application will parse the request.
    It will then hand the two arguments (`environ` and the `start_response` function)
    over to another application to perform the actual evaluation and compute a response.
    In many cases, this delegation will also include updating the `environ` variable
    with arguments and parameters parsed from the request path or headers. Finally,
    this `Wheel3.__call__()` function will return the response from the other application
    that was invoked.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理请求时，`Wheel3` WSGI应用程序将解析请求。然后将这两个参数（`environ`和`start_response`函数）传递给另一个应用程序来执行实际的评估并计算响应。在许多情况下，这种委托还包括从请求路径或标头解析的参数和参数更新`environ`变量。最后，这个`Wheel3.__call__()`函数将返回被调用的另一个应用程序的响应。
- en: 'This style of delegation is characteristic of WSGI applications. It''s the
    reason that WSGI applications nest together so elegantly. Note that a wrapper
    application has two places to inject the processing:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 这种委托方式是WSGI应用程序的特点。这就是WSGI应用程序如此优雅地嵌套在一起的原因。请注意，包装应用程序有两个地方可以注入处理：
- en: Before invoking another application, it will tweak the environment to add information
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用另一个应用程序之前，它将调整环境以添加信息。
- en: After invoking another application, it can tweak the response document
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用另一个应用程序后，它可以调整响应文档
- en: Generally, we like to focus on tweaking the environment in a wrapping application.
    In this case, however, there was no real need to update the environment with any
    additional information, as the request was so trivial.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们喜欢在包装应用程序中调整环境。然而，在这种情况下，没有真正需要使用额外信息更新环境，因为请求是如此微不足道。
- en: Designing RESTful object identifiers
  id: totrans-1072
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计RESTful对象标识符
- en: Object serialization involves defining some kind of identifier for each object.
    For `shelve` or `sqlite`, we need to define a string key for each object. A RESTful
    web server makes the same demands to define a workable key that can be used to
    unambiguously track down objects.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 对象序列化涉及为每个对象定义某种标识符。对于`shelve`或`sqlite`，我们需要为每个对象定义一个字符串键。RESTful web服务器也提出了相同的要求，以定义一个可用于明确跟踪对象的可行键。
- en: A simple, surrogate key can work out for a RESTful web service identifier as
    well. It can easily parallel the key used for `shelve` or `sqlite`.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的替代键也可以用于RESTful web服务标识符。它可以轻松地与`shelve`或`sqlite`使用的键并行。
- en: What's important is the idea that c*ool URIs don't change*. See [http://www.w3.org/Provider/Style/URI.html](http://www.w3.org/Provider/Style/URI.html).
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要明白“酷的URI不会改变”的概念。参见[http://www.w3.org/Provider/Style/URI.html](http://www.w3.org/Provider/Style/URI.html)。
- en: It is important for us to define a URI that isn't going to change, ever. It's
    essential that stateful aspects of an object are never used as part of the URI.
    For example, a microblogging application may support multiple authors. If we organize
    blog posts into folders by the author, we create problems for shared authorship
    and we create larger problems when one author takes over another author's content.
    We don't want the URI to switch when a purely administrative feature such as *ownership*
    changes.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，定义一个永远不会改变的URI是很重要的。重要的是对象的有状态方面永远不要作为URI的一部分。例如，微博应用程序可能支持多个作者。如果我们按作者将博客帖子组织成文件夹，就会为共享作者身份创建问题，当一个作者接管另一个作者的内容时，就会产生更大的问题。我们不希望URI在纯粹的管理功能（如*所有权*）发生变化时切换。
- en: A RESTful application may offer a number of indices or search criteria. However,
    the essential identification of a resource or object should never change as the
    indices are changed or reorganized.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful应用程序可能提供许多索引或搜索条件。然而，资源或对象的基本标识不应随索引的更改或重新组织而改变。
- en: For relatively simple objects, we can often find some sort of identifier—often,
    a database surrogate key. In the case of blog posts, it's common to use a publication
    date (as that can't change) and a version of the title with punctuation and spaces
    replaced by `_` characters. The idea is to create an identifier that will not
    change no matter how the site gets reorganized. Adding or changing indexes can't
    change the essential identification of a microblog post.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相对简单的对象，我们通常可以找到某种标识符，通常是数据库替代键。对于博客帖子，通常使用发布日期（因为它不会改变）和标题的版本，标点和空格用`_`字符替换。其目的是创建一个标识符，无论网站如何重新组织，都不会改变。添加或更改索引不会改变微博帖子的基本标识。
- en: For more complex objects that are containers, we have to decide on the granularity
    with which we can refer to these more complex objects. Continuing the microblog
    example, we have blogs as a whole, which contain a number of individual posts.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的容器对象，我们必须决定可以引用这些更复杂对象的粒度。继续微博示例，我们有整个博客，其中包含许多个别的帖子。
- en: 'The URI for a blog can be something simple like this:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 博客的URI可以是这样简单的：
- en: '[PRE159]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The top-most name (`microblog`) is the overall application. Then, we have the
    type of resource (`blog`) and finally, an ID for a specific instance.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 最顶层的名称（`微博`）是整个应用程序。然后，我们有资源类型（`博客`），最后是特定实例的ID。
- en: 'URI names for a post, however, have several choices:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，帖子的URI名称有几种选择：
- en: '[PRE160]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The first URI doesn't work well when different blogs have posts with the same
    title. In this case, an author may see their title made unique with an extra `_2`
    or some other decoration that forces the title to be unique. This is often undesirable.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同的博客有相同标题的帖子时，第一个URI效果不佳。在这种情况下，作者可能会看到他们的标题被添加了额外的`_2`或其他装饰，以强制标题变得唯一。这通常是不可取的。
- en: The second URI uses the blog ID (`bid`) as a context or namespace to ensure
    that the `Post` titles are treated as unique within the context of a blog. This
    kind of technique is often extended to include additional subdivisions such as
    a date to further shrink the search space.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个URI使用博客ID（`bid`）作为上下文或命名空间，以确保在博客的上下文中将`Post`标题视为唯一的。这种技术通常被扩展以包括额外的细分，比如日期，以进一步缩小搜索空间。
- en: 'The third example uses an explicit class/object naming at two levels: `blog/bid`
    and the `post/title_string`. This has the disadvantage of longer paths, but it
    has the advantage of allowing a complex container to have multiple items in distinct
    internal collections.'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个示例在两个级别上使用了显式的类/对象命名：`blog/bid`和`post/title_string`。这样做的缺点是路径更长，但它的优点是允许一个复杂的容器在不同的内部集合中有多个项目。
- en: Note that REST services have the effect of defining an API for persistent storage.
    In effect, the URIs are similar to names of the interface methods. They must be
    chosen with an eye toward clarity, meaning, and durability.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，REST服务的效果是定义持久存储的API。实际上，URI类似于接口方法的名称。它们必须选择得清晰、有意义和耐用。
- en: Multiple layers of REST services
  id: totrans-1089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多层REST服务
- en: 'Here''s a smarter, multilayered REST server application. We''ll show you this
    in pieces. First, we need to supplement our `Wheel` class with a Roulette table:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更智能、多层次的REST服务器应用程序。我们将分段展示给你。首先，我们需要用一个Roulette桌子来补充我们的`Wheel`类：
- en: '[PRE161]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The `Table` class tracks bets from a single, anonymous player. Each bet is a
    string name for a space on the Roulette table and an integer amount. When resolving
    the bets, a single spin from the `Wheel` class is provided to the `resolve()`
    method. The bets that are placed are compared to the winning bets from the spin
    and the player's stake is adjusted as bets are won or lost.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table`类跟踪来自单个匿名玩家的赌注。每个赌注都是轮盘桌上一个空间的字符串名称和一个整数金额。在解决赌注时，`Wheel`类提供了一个单次旋转给`resolve()`方法。下注与旋转中的获胜赌注进行比较，并且随着赌注的赢得或失去，玩家的赌注会进行调整。'
- en: 'We''ll define a RESTful Roulette server that shows us a stateful transaction
    that is implemented via an `HTTP POST` method. We''ll break the game of Roulette
    into three URIs:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个RESTful的Roulette服务器，它展示了通过`HTTP POST`方法实现的有状态事务。我们将把Roulette游戏分成三个URI：
- en: '`/player/`'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/player/`'
- en: '`GET` to this URI will retrieve a JSON-encoded `dict` with facts about the
    player, including their stake and the number of rounds played so far. A future
    expansion would be to define a proper `Player` object and return a serialized
    instance.'
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向这个URI发送`GET`请求将检索一个JSON编码的`dict`，其中包含有关玩家的信息，包括他们的赌注和迄今为止玩的轮数。未来的扩展将是定义一个适当的`Player`对象并返回一个序列化的实例。
- en: A future expansion would be to handle `POST` to create additional players who
    place bets.
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来的扩展将处理`POST`以创建额外的下注玩家。
- en: '`/bet/`'
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bet/`'
- en: '`POST` to this URI will include a JSON-encoded `dict` or a list of dicts that
    will create bets. Each bet dictionary will have two keys: `bet` and `amount`.'
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向这个URI发送`POST`请求将包括一个JSON编码的`dict`或一个创建赌注的字典列表。每个赌注字典将有两个键：`bet`和`amount`。
- en: '`GET` will return a JSON-encoded `dict` that shows us the bets and amounts
    placed so far.'
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`将返回一个JSON编码的`dict`，显示迄今为止下注和金额。'
- en: '`/wheel/`'
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/wheel/`'
- en: '`POST`—with no data—to this URI will spin and compute the payout. This is implemented
    as `POST` to reinforce the sense that it is making a stateful change to the available
    bets and the player.'
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向这个URI发送没有数据的`POST`请求将旋转并计算支付。这是作为`POST`实现的，以加强它正在对可用的赌注和玩家进行有状态的更改的感觉。
- en: '`GET` could, perhaps, repeat the previous results, showing us the last spin,
    last payout, and player''s stake. This might be part of a non-repudiation scheme;
    it returns an additional copy of a spin receipt.'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`可能会重复之前的结果，显示上次旋转，上次支付和玩家的赌注。这可能是非否认方案的一部分；它返回旋转收据的额外副本。'
- en: 'Here are two helpful class definitions for our family of WSGI applications:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们WSGI应用程序系列的两个有用的类定义：
- en: '[PRE162]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'We made a simple extension to `Callable` to make it clear that we''re going
    to define a WSGI application class. We also defined an exception that we can use
    within our WSGI applications to send back error status codes that are different
    from the generic 500 error that the `wsgiref` implementation provides for Python
    errors. Here''s the top level of the Roulette server:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`Callable`进行了简单的扩展，以明确表示我们将定义一个WSGI应用程序类。我们还定义了一个异常，我们可以在WSGI应用程序中使用它来发送与`wsgiref`实现提供的Python错误不同的错误状态代码。这是Roulette服务器的顶层：
- en: '[PRE163]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: We defined a WSGI application that wraps the other applications. The `wsgiref.util.shift_path_info()`
    function will parse the path, breaking on `/` to get the first word. Based on
    this, we'll invoke one of three other WSGI applications. In this case, each application
    is going to be a method function within this class definition.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个WSGI应用程序，它包装了其他应用程序。`wsgiref.util.shift_path_info()`函数将解析路径，在`/`上断开以获取第一个单词。基于此，我们将调用另外三个WSGI应用程序中的一个。在这种情况下，每个应用程序将是类定义内的一个方法函数。
- en: 'We provided an overall exception handler that will turn any of the `RESTException`
    instances into a proper RESTful response. Exceptions that we did not catch will
    turn into generic status code 500 errors from `wsgiref`. Here''s the `player_app`
    method function:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个总体异常处理程序，它将把任何`RESTException`实例转换为适当的RESTful响应。我们没有捕获的异常将转换为`wsgiref`提供的通用状态码500错误。这是`player_app`方法函数：
- en: '[PRE164]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: We created a response object, `details`. We then serialized this object into
    a JSON string and further encoded that string into bytes using UTF-8.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个响应对象`details`。然后我们将这个对象序列化为一个JSON字符串，并进一步使用UTF-8编码该字符串为字节。
- en: In the unlikely event of an attempt to Post (or Put or Delete) to the `/player/`
    path, an exception will be raised. This will be caught in the top-level `__call__()`
    method and transformed into an error response.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，尝试对`/player/`路径进行Post（或Put或Delete）将引发异常。这将在顶层`__call__()`方法中捕获，并转换为错误响应。
- en: 'Here''s the `bet_app()` function:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`bet_app()`函数：
- en: '[PRE165]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: This does two things, depending on the request method. When a `GET` request
    is used, the result is a dictionary of current bets. When a `POST` request is
    used, there must be some data to define the bets. When any other method is attempted,
    an error is returned.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 这做了两件事，取决于请求方法。当使用`GET`请求时，结果是当前下注的字典。当使用`POST`请求时，必须有一些数据来定义下注。当尝试任何其他方法时，将返回错误。
- en: In the `POST` case, information on the bet is provided as the data stream attached
    to the request. We have to perform several steps to read and process this data.
    The first step is to use the value of `environ['CONTENT_LENGTH']` to determine
    how many bytes to read. The second step is to decode the bytes to get the string
    value that was sent.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`POST`情况下，下注信息作为附加到请求的数据流提供。我们必须执行几个步骤来读取和处理这些数据。第一步是使用`environ['CONTENT_LENGTH']`的值来确定要读取多少字节。第二步是解码字节以获得发送的字符串值。
- en: We used the JSON encoding of the request. This, emphatically, is not the way
    a browser or web application server handles the `POST` data from an HTML form.
    When using a browser to post data from an HTML form, the encoding is a simple
    set of escapes, implemented by the `urllib.parse` module. The `urllib.parse.parse_qs()`
    module function will parse the encoded query string with HTML data.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了请求的JSON编码。这绝对不是浏览器或Web应用程序服务器处理来自HTML表单的`POST`数据的方式。当使用浏览器从HTML表单发布数据时，编码是`urllib.parse`模块实现的一组简单的转义。`urllib.parse.parse_qs()`模块函数将解析带有HTML数据的编码查询字符串。
- en: For RESTful web services, `POST` compatible data is sometimes used so that form-based
    processing is very similar to RESTful processing. In other cases, a separate encoding
    such as JSON is used to create data structures that are easier to work with than
    the quoted data produced by a web form.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RESTful Web服务，有时会使用`POST`兼容数据，以便基于表单的处理与RESTful处理非常相似。在其他情况下，会使用单独的编码，如JSON，以创建比Web表单产生的引号数据更容易处理的数据结构。
- en: Once we have the string, `raw`, we use `json.loads()` to get the object represented
    by that string. We expect one of the two classes of objects. A simple `dict` object
    will define a single bet. A sequence of `dict` objects will define multiple bets.
    As a simple generalization, we make the single `dict` into a singleton sequence.
    We can then use the general sequence of `dict` instances to place the required
    bets.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了字符串`raw`，我们使用`json.loads()`来获取该字符串表示的对象。我们期望两类对象中的一个。一个简单的`dict`对象将定义一个单独的下注。一系列`dict`对象将定义多个下注。作为一个简单的概括，我们将单个`dict`转换为单例序列。然后，我们可以使用一般的`dict`实例序列来放置所需的下注。
- en: Note that our exception handling will leave some bets in place but will send
    an overall `403 Forbidden` message. A better design is to follow the **Memento**
    design pattern. When placing bets, we would also create a memento object that
    can be used to undo any bets. One implementation of the Memento is to use the
    **Before Image** design pattern. The Memento could include a copy of all the bets
    prior to applying a change. In the event of an exception, we can delete the damaged
    version and restore the previous one. When working with nested containers of mutable
    objects, this can be complex, because we have to be sure to make a copy of any
    mutable objects. As this application uses only immutable strings and integers,
    a shallow copy of `table.bets` will work nicely.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的异常处理将保留一些下注，但会发送一个总体的`403 Forbidden`消息。更好的设计是遵循**Memento**设计模式。下注时，我们还会创建一个可以撤销任何下注的备忘录对象。备忘录的一个实现是使用**Before
    Image**设计模式。备忘录可以包括在应用更改之前的所有下注的副本。在发生异常时，我们可以删除损坏的版本并恢复以前的版本。当处理可变对象的嵌套容器时，这可能会很复杂，因为我们必须确保复制任何可变对象。由于此应用程序仅使用不可变的字符串和整数，因此`table.bets`的浅复制将非常有效。
- en: For both `POST` and `GET` methods, the response is the same. We'll serialize
    the `table.bets` dictionary into JSON and send it back to the REST client. This
    will confirm that the expected bets were placed.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`POST`和`GET`方法，响应是相同的。我们将`table.bets`字典序列化为JSON并发送回REST客户端。这将确认已下注的预期下注。
- en: 'The final part of this class is the `wheel_app()` method:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课的最后一部分是`wheel_app()`方法：
- en: '[PRE166]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: This method first checks that it is invoked with a post that supplies no data.
    Just to be sure that the socket is properly closed, all the data is read and ignored.
    This can prevent a poorly written client from crashing when the socket is closed
    with unread data.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先检查它是否被调用以提供没有数据的`post`。为了确保套接字被正确关闭，所有数据都被读取并忽略。这可以防止一个编写不良的客户端在套接字关闭时崩溃。
- en: Once that bit of housekeeping is out of the way, the remaining processing is
    performed to develop a new spin from the wheel, resolve the various bets, and
    produce a response that includes the spin, the payout, the player's stake, and
    the number of rounds. This report is built as a `dict` object. It's then serialized
    into JSON, encoded into UTF-8, and sent back to the client.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些琐事处理完毕，剩下的处理就是执行新的轮盘旋转，解决各种下注，并生成包括旋转、支付、玩家赌注和回合数的响应。这份报告被构建为一个`dict`对象。然后将其序列化为JSON，编码为UTF-8，并发送回客户端。
- en: Note that we've avoided handling multiple players. This would add a class and
    another `POST` method under the `/player/` path. It would add a bit of definition
    and bookkeeping. The `POST` processing to create a new player would be similar
    to the processing for placing a bet. This is an interesting exercise, but it doesn't
    introduce any new programming techniques.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经避免处理多个玩家。这将添加一个类和另一个`/player/`路径下的`POST`方法。这将增加一些定义和簿记。创建新玩家的`POST`处理将类似于下注处理。这是一个有趣的练习，但它并没有引入任何新的编程技术。
- en: Creating the roulette server
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建轮盘服务器
- en: 'Once we have a callable `Roulette` class, we can create a WSGI server in the
    following manner:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了可调用的`Roulette`类，我们可以按照以下方式创建一个WSGI服务器：
- en: '[PRE167]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: This function creates our Roulette WSGI application, `roulette`. It uses `wsgiref.simple_server.make_server()`
    to create a server that will use the `roulette` callable for each request.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建我们的Roulette WSGI应用程序`roulette`。它使用`wsgiref.simple_server.make_server()`创建一个服务器，该服务器将对每个请求使用`roulette`可调用。
- en: In this case, we've also included the `wsgiref.validate.validator()` WSGI application.
    This application validates the interface used by the roulette application; it
    decorates the various APIs with assert statements to provide some diagnostic information.
    It also produces slightly easier-to-read error messages in the event of a more
    serious programming problem in a WSGI application.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们还包括了`wsgiref.validate.validator()` WSGI应用程序。该应用程序验证了轮盘应用程序使用的接口；它使用assert语句装饰各种API以提供一些诊断信息。它还在WSGI应用程序出现更严重的编程问题时生成稍微更易读的错误消息。
- en: Creating the roulette client
  id: totrans-1131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建轮盘客户端
- en: It's common practice to define a module with a RESTful client API. Often, the
    client API will have functions that are specifically tailored to the requested
    services.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个具有RESTful客户端API的模块是常见做法。通常，客户端API将具有专门针对所请求服务的函数。
- en: 'Instead of defining a specialized client, we''ll define a generic client function
    that works with a variety of RESTful servers. This might serve as the foundation
    for a Roulette-specific client. Here''s a generic client function that will work
    with our `Roulette` server:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个通用的客户端函数，而不是定义一个专门的客户端，该函数将与各种RESTful服务器一起工作。这可能成为一个特定于Roulette的客户端的基础。以下是一个通用的客户端函数，它将与我们的`Roulette`服务器一起工作：
- en: '[PRE168]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: This client makes the `GET` or `POST` requests, and it will encode the data
    for a `POST` request as a JSON document. Note that the JSON encoding of the request
    data is emphatically not the way a browser handles an HTML form's `POST` data.
    Browsers use the encoding implemented by the `urllib.parse.urlencode()` module
    function.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 此客户端进行`GET`或`POST`请求，并将`POST`请求的数据编码为JSON文档。请注意，请求数据的JSON编码绝对不是浏览器处理HTML表单的`POST`数据的方式。浏览器使用`urllib.parse.urlencode()`模块函数实现的编码。
- en: 'Our client function decodes the JSON document and returns it when the status
    code is in the half-open range, ![Creating the roulette client](graphics/0971OS_12_01.jpg).
    These are the success status codes. We can exercise our client and server as follows:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端函数在半开范围内解码JSON文档并返回它，这些是成功的状态代码。我们可以按以下方式操作我们的客户端和服务器：
- en: '[PRE169]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: First, we create `ProcessPool` as the context for the exercise. We submit a
    request to this server; in effect, the request is `roulette_server_3(4)`. Once
    the server has started, we can exercise that server.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`ProcessPool`作为练习的上下文。我们向该服务器提交一个请求；实际上，请求是`roulette_server_3(4)`。一旦服务器启动，我们就可以操作该服务器。
- en: In this case, we made four requests. We check the player's status. We place
    a bet and then we check the bet. Finally, we spin the wheel. At each step, we
    print the JSON response documents.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们进行了四次请求。我们检查玩家的状态。我们下注然后检查下注。最后，我们转动轮盘。在每个步骤中，我们打印JSON响应文档。
- en: 'The log looks like this:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 日志如下：
- en: '[PRE170]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This shows us that our server responds to requests, creates bets on the table,
    creates random spins of the wheel, and properly updates the player with the outcomes.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了我们的服务器如何响应请求，如何在桌子上下注，如何随机旋转轮盘，并如何正确地更新玩家的结果。
- en: Creating a secure REST service
  id: totrans-1143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建安全的REST服务
- en: 'We can break application security down into two considerations: authentication
    and authorization. We need to know who the user is and we need to be sure that
    the user is authorized to execute the particular WSGI application. This is handled
    relatively simply using both the HTTP `Authorization` header for credentials to
    ensure an encrypted transmission of these credentials.'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将应用程序安全性分解为两个考虑因素：身份验证和授权。我们需要知道用户是谁，并且我们需要确保用户被授权执行特定的WSGI应用程序。这是相对简单地使用HTTP
    `Authorization`头来处理，以确保这些凭据的加密传输。
- en: If we use SSL, we can simply use the HTTP Basic Authorization mode. This version
    of the `Authorization` header can include a username and password in each request.
    For more elaborate measures, we can use HTTP Digest Authorization, which requires
    an exchange with the server to get a piece of data called a **nonce** that's used
    to create the digest in a more secure fashion.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用SSL，我们可以简单地使用HTTP基本授权模式。`Authorization`头的这个版本可以在每个请求中包含用户名和密码。对于更复杂的措施，我们可以使用HTTP摘要授权，它需要与服务器交换以获取一个称为**nonce**的数据片段，用于以更安全的方式创建摘要。
- en: Generally, we'll handle authentication as early in the process as possible.
    This means a frontend WSGI application that checks for the `Authorization` header
    and updates the environment or returns an error. Ideally, we'll be using a sophisticated
    web framework that offers us this feature. See the next section for more information
    on these web framework considerations.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会尽早在流程中处理身份验证。这意味着一个前端WSGI应用程序会检查`Authorization`头并更新环境或返回错误。理想情况下，我们将使用一个提供此功能的复杂Web框架。有关这些Web框架考虑的更多信息，请参见下一节。
- en: 'Perhaps the most important advice that can possibly be offered on the subject
    of security is the following:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安全性的最重要的建议可能是以下内容：
- en: Note
  id: totrans-1148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Never Store Passwords**'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '**永远不要存储密码**'
- en: The only thing that can be stored is a repeated cryptographic hash of password
    plus salt. The password itself must be unrecoverable; research fully on *Salted
    Password Hashing* or download a trusted library for this. Do not ever store a
    plaintext password or an encrypted password.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一可以存储的是密码加盐的重复加密哈希。密码本身必须是不可恢复的；完全研究*加盐密码哈希*或下载一个可信的库。永远不要存储明文密码或加密密码。
- en: 'Here''s an example class that shows us how salted password hashing works:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例类，向我们展示了加盐密码哈希的工作原理：
- en: '[PRE171]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: This class defines an `Authentication` object for a given username. The object
    contains the username, a unique random salt created each time the password is
    set or reset, and the final hash of the salt plus the password. This class also
    defines a `match()` method that will determine whether a given password will produce
    the same hash as the original password.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类为给定的用户名定义了一个`Authentication`对象。该对象包含用户名、每次设置或重置密码时创建的唯一随机盐，以及盐加上密码的最终哈希。这个类还定义了一个`match()`方法，确定给定的密码是否会产生与原始密码相同的哈希。
- en: Note that the passwords are not stored. Only hashes of passwords are retained.
    We provided a comment ("`# Constant Time is Best`") on the comparison function.
    An algorithm that runs in constant time—and isn't particularly fast—is ideal for
    this comparison. We haven't implemented it.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，密码没有被存储。只有密码的哈希值被保留。我们在比较函数上提供了一个注释（“`# Constant Time is Best`”）。一个在恒定时间内运行的算法——并且不是特别快——对于这种比较是理想的。我们还没有实现它。
- en: We also included an equality test and a hash test to emphasize that this object
    is immutable. We can't tweak any of the values. We can only discard and rebuild
    the entire `Authentication` object when users changes their password. An additional
    design feature would be to use `__slots__` to save storage.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括了一个相等测试和一个哈希测试，以强调这个对象是不可变的。我们不能调整任何值。当用户更改密码时，我们只能丢弃并重建整个`Authentication`对象。另一个设计特性是使用`__slots__`来保存存储空间。
- en: 'Note that these algorithms work with byte strings, not Unicode strings. We
    either need to work with bytes or we need to work with the ASCII encoding of a
    Unicode username or password. Here''s how we might create a collection of users:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些算法使用的是字节字符串，而不是Unicode字符串。我们要么使用字节，要么使用Unicode用户名或密码的ASCII编码。下面是我们可能创建一个用户集合的方法：
- en: '[PRE172]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: We created an extension to `dict` that introduces an `add()` method to save
    an `Authentication` instance and a match method that determines whether the users
    are in this dictionary and whether their credentials match.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`dict`的扩展，引入了一个`add()`方法来保存一个`Authentication`实例和一个匹配方法，确定用户是否在这个字典中，以及他们的凭证是否匹配。
- en: Note that our match needs to be a constant time comparison. We created an additional
    dummy user for a situation where an unknown username is supplied. By performing
    the match against a dummy user—which will always fail—the execution timing doesn't
    provide many hints as to what's wrong with the credentials. If we simply returned
    `False`, a mismatched username would respond faster than a mismatched password.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的匹配需要是一个恒定时间的比较。我们为一个未知的用户名提供了一个额外的虚拟用户。通过对虚拟用户进行匹配，执行时间不会提供太多关于凭证错误的提示。如果我们简单地返回`False`，那么不匹配的用户名会比不匹配的密码响应更快。
- en: 'We specifically disallowed setting the authentication for a username of `""`
    or matching a username of `""`. This will ensure that the dummy username is never
    changed to a valid entry that might possibly match, and any attempt to match it
    will always fail. Here''s a sample user that we built:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确禁止设置用户名为`""`的身份验证，或匹配用户名为`""`。这将确保虚拟用户名永远不会被更改为可能匹配的有效条目，任何尝试匹配它都将失败。下面是我们构建的一个示例用户：
- en: '[PRE173]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Just to see what''s going on inside this class, we can manually create a user:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了看看这个类里面发生了什么，我们可以手动创建一个用户：
- en: '[PRE174]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: The salt is a string of 24 bytes that's reset when the user's password is created
    or changed. The hash is a repeated hash of username, password, and salt.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 盐是一个由24个字节组成的字符串，在用户的密码被创建或更改时被重置。哈希是用户名、密码和盐的重复哈希。
- en: The WSGI Authentication application
  id: totrans-1165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WSGI身份验证应用程序
- en: 'Once we have a way to store the users and credentials, we can examine the `Authentication`
    header in a request. Here''s a WSGI application that checks the header and updates
    the environment for validated users:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了存储用户和凭证的方法，我们就可以检查请求中的`Authentication`头部。下面是一个检查头部并更新验证用户环境的WSGI应用程序：
- en: '[PRE175]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'This WSGI application contains a pool of users in addition to a a target application.
    When we create an instance of this `Authenticate` class, we''ll provide another
    WSGI application as `target_app`; this wrapped application will only see requests
    from authenticated users. When the `Authenticate` application is invoked, it performs
    several tests to be sure that the request is from an authenticated user:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个WSGI应用程序包含一个用户池，还有一个目标应用程序。当我们创建这个`Authenticate`类的实例时，我们将提供另一个WSGI应用程序作为`target_app`；这个包装应用程序只会看到经过身份验证的用户的请求。当调用`Authenticate`应用程序时，它会执行几个测试，以确保请求来自经过身份验证的用户：
- en: There must be an HTTP `Authorization` header. This header is saved with the
    `HTTP_AUTHORIZATION` key in the `environ` dict
  id: totrans-1169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个HTTP`Authorization`头。这个头部保存在`environ`字典中的`HTTP_AUTHORIZATION`键中
- en: The header must have `Basic` as the authentication scheme
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部必须使用`Basic`作为认证方案
- en: The credentials in the Basic scheme must be base 64 encoding of `username+b":"+password`;
    this must match the credentials of one of the defined users
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本方案中的凭证必须是`username+b":"+password`的base 64编码；这必须与定义的用户的凭证匹配
- en: If all of these tests are passed, we can update the `environ` dict with the
    authenticated username. Then, the target application can be invoked.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些测试都通过了，我们可以使用经过身份验证的用户名更新`environ`字典。然后，目标应用程序可以被调用。
- en: The wrapped application can then handle the authorization details knowing that
    the user is authenticated. This separation of concerns is one elegant feature
    of WSGI applications. We have put the authentication in exactly one place.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，包装应用程序可以处理授权细节，知道用户已经通过身份验证。这种关注点的分离是WSGI应用程序的一个优雅特性。我们把身份验证放在了一个地方。
- en: Implementing REST with a web application framework
  id: totrans-1174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Web应用程序框架实现REST
- en: As a REST web server is a web application, we can leverage any of the popular
    Python web application frameworks. Writing a RESTful server from scratch is a
    step that can be taken after demonstrating that a framework provides unacceptable
    problems. In many cases, a technical spike using a framework can help clarify
    any issues and allow a detailed comparison against a REST application written
    without a framework.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST web服务器是一个Web应用程序，我们可以利用任何流行的Python Web应用程序框架。从头开始编写RESTful服务器是在证明框架提供的问题不可接受之后可以采取的一步。在许多情况下，使用框架进行技术性的尝试可以帮助澄清任何问题，并允许与不使用框架编写的REST应用程序进行详细比较。
- en: Some of the Python web frameworks include one or more REST components. In some
    cases, the RESTful features are almost entirely built-in. In other cases, an add-on
    project can help define RESTful web services with minimal programming.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python Web框架包括一个或多个REST组件。在某些情况下，RESTful功能几乎完全内置。在其他情况下，附加项目可以帮助以最少的编程定义RESTful
    Web服务。
- en: 'Here''s a list of Python web frameworks: [https://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks).
    The point of these projects is to provide a reasonably complete environment to
    build web applications.'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python Web框架的列表：[https://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks)。这些项目的目的是提供一个相对完整的环境来构建Web应用程序。
- en: 'Here''s a list of Python web component packages: [https://wiki.python.org/moin/WebComponents](https://wiki.python.org/moin/WebComponents).
    These are bits and pieces that can be used to support web application development.'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python Web组件软件包的列表：[https://wiki.python.org/moin/WebComponents](https://wiki.python.org/moin/WebComponents)。这些都是可以用来支持Web应用程序开发的部分和片段。
- en: Searching PyPI, [https://pypi.python.org](https://pypi.python.org), for REST
    will turn up a large number of packages. Clearly, there are numerous solutions
    that are already available.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyPI，[https://pypi.python.org](https://pypi.python.org)，搜索REST将会找到大量的软件包。显然，已经有许多可用的解决方案。
- en: Taking time to search, download, and learn a number of existing frameworks can
    reduce some of the development effort. Security, in particular, is challenging.
    Home-brewed security algorithms are often filled with serious deficiencies. Using
    someone else's proven security tools can have some advantages.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间搜索、下载和学习一些现有的框架可以减少一些开发工作。特别是安全性方面是具有挑战性的。自制的安全算法通常存在严重的缺陷。使用他人验证过的安全工具可能有一些优势。
- en: Using a message queue to transmit objects
  id: totrans-1181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用消息队列传输对象
- en: The `multiprocessing` module uses serialization and transmission of objects,
    too. We can use queues and pipes to serialize objects that are then transmitted
    to other processes. There are numerous external projects to provide sophisticated
    message queue processing. We'll focus on the `multiprocessing` queue because it's
    built-in to Python and works nicely.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块也使用对象的序列化和传输。我们可以使用队列和管道对对象进行序列化，然后将其传输到其他进程。有许多外部项目可以提供复杂的消息队列处理。我们将专注于`multiprocessing`队列，因为它内置于Python并且运行良好。'
- en: For high-performance applications, a faster message queue may be necessary.
    It may also be necessary to use a faster serialization technique than pickling.
    For this chapter, we'll focus only on the Python design issues. The multiprocessing
    module relies on `pickle` to encode objects. See [Chapter 9](ch09.html "Chapter 9. Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML*, for more information. We can't provide a restricted
    unpickler easily; therefore, this module offers us some relatively simple security
    measures put into place to prevent unpickle problems.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高性能应用程序，可能需要更快的消息队列。可能还需要使用比pickling更快的序列化技术。在本章中，我们只关注Python设计问题。`multiprocessing`模块依赖于`pickle`来编码对象。有关更多信息，请参见[第9章](ch09.html
    "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")，“序列化和保存 - JSON、YAML、Pickle、CSV和XML”。我们无法轻松地提供受限制的unpickler；因此，该模块为我们提供了一些相对简单的安全措施，以防止unpickle问题。
- en: 'There is one important design consideration when using `multiprocessing`: it''s
    generally best to avoid having multiple processes (or multiple threads) attempting
    to update shared objects. The synchronization and locking issues are so profound
    (and easy to get wrong) that the standard joke is,'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`multiprocessing`时有一个重要的设计考虑：通常最好避免多个进程（或多个线程）尝试更新共享对象。同步和锁定问题是如此深刻（并且容易出错），以至于标准笑话是，
- en: When confronted with a problem, the programmer thinks, "I'll use multiple threads."
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当程序员面对问题时，他会想：“我会使用多个线程。”
- en: Using process-level synchronization via RESTful web services or `multiprocessing`
    can prevent synchronization issues because there are no shared objects. The essential
    design principle is to look at the processing as a pipeline of discrete steps.
    Each processing step will have an input queue and an output queue; the step will
    fetch an object, perform some processing, and write the object.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过RESTful Web服务或`multiprocessing`使用进程级同步可以防止同步问题，因为没有共享对象。基本的设计原则是将处理视为离散步骤的管道。每个处理步骤都将有一个输入队列和一个输出队列；该步骤将获取一个对象，执行一些处理，并写入该对象。
- en: The `multiprocessing` philosophy matches the POSIX concept of a shell pipeline
    written as `process1 | process2 | process3`. This kind of shell pipeline involves
    three concurrent processes interconnected with pipes. The important difference
    is that we don't need to use STDIN, STDOUT, and explicit serialization of the
    objects. We can trust the `multiprocessing` module to handle the OS-level infrastructure.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`的哲学与将POSIX概念写成`process1 | process2 | process3`的shell管道相匹配。这种shell管道涉及三个相互连接的并发进程。重要的区别在于，我们不需要使用STDIN、STDOUT和对象的显式序列化。我们可以相信`multiprocessing`模块来处理操作系统级的基础设施。'
- en: The POSIX shell pipelines are limited, in that each pipe has a single producer
    and a single consumer. The Python `multiprocessing` module allows us to create
    message queues that include multiple consumers. This allows us to have a pipeline
    that fans out from one source process to multiple sink processes. A queue can
    also have multiple consumers that allow us to build a pipeline where the results
    of multiple source processes can be combined by a single sink process.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX shell管道有限，每个管道只有一个生产者和一个消费者。Python的`multiprocessing`模块允许我们创建包括多个消费者的消息队列。这使我们能够创建一个从一个源进程到多个目标进程的扇出流水线。一个队列也可以有多个消费者，这使我们能够构建一个流水线，其中多个源进程的结果可以由单个目标进程组合。
- en: To maximize throughput on a given computer system, we need to have enough work
    pending so that no processor or core is ever left with nothing useful to do. When
    any given OS process is waiting for a resource, at least one other process should
    be ready to run.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化计算机系统的吞吐量，我们需要有足够的待处理工作，以便没有处理器或核心会闲置。当任何给定的操作系统进程正在等待资源时，至少应该有另一个进程准备好运行。
- en: When looking at our casino game simulations, for example, we need to gather
    statistically significant simulation data by exercising a player strategy or betting
    strategy (or both) a number of times. The idea is to create a queue of processing
    requests so that our computer's processors (and cores) are fully engaged in processing
    our simulations.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们观察我们的赌场游戏模拟时，我们需要通过多次执行玩家策略或投注策略（或两者）来收集具有统计学意义的模拟数据。我们的目标是创建一个处理请求队列，以便我们计算机的处理器（和核心）完全参与处理我们的模拟。
- en: Each processing request can be a Python object. The `multiprocessing` module
    will pickle that object so that it is transmitted via the queue to another process.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理请求可以是一个Python对象。`multiprocessing`模块将对该对象进行pickle处理，以便通过队列传输到另一个进程。
- en: We'll revisit this in [Chapter 14](ch14.html "Chapter 14. The Logging and Warning
    Modules"), *The Logging and Warning Modules*, when we look at how the `logging`
    module can use `multiprocessing` queues to provide a single, centralized log for
    separate producer processes. In these examples, the objects transmitted from process
    to process will be the `logging.LogRecord` instances.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第14章](ch14.html "第14章。日志和警告模块")中重新讨论这个问题，当我们看看`logging`模块如何使用`multiprocessing`队列为单独的生产者进程提供一个集中的日志时。在这些示例中，从一个进程传输到另一个进程的对象将是`logging.LogRecord`实例。
- en: Defining processes
  id: totrans-1193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义进程
- en: We must design each processing step as a simple loop that gets a request from
    a queue, processes that request, and places the results into another queue. This
    decomposes the larger problem into a number of stages that form a pipeline. As
    each of these stages will run concurrently, the system resource use will be maximized.
    Furthermore, as the stages involve simple gets and puts into independent queues,
    there's no issue with complex locking or shared resources. A process can be a
    simple function or a callable object. We'll focus on defining processes as subclasses
    of `multiprocessing.Process`. This gives us the most flexibility.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将每个处理步骤设计为一个简单的循环，从队列中获取请求，处理该请求，并将结果放入另一个队列。这将大问题分解为多个形成流水线的阶段。由于每个阶段都将同时运行，系统资源使用将被最大化。此外，由于这些阶段涉及简单的从独立队列获取和放置，所以没有复杂的锁定或共享资源问题。一个进程可以是一个简单的函数或可调用对象。我们将专注于将进程定义为`multiprocessing.Process`的子类。这给了我们最大的灵活性。
- en: 'For the simulation of our casino game, we can break the simulation down into
    a three-step pipeline:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们赌场游戏的模拟，我们可以将模拟分解为三个步骤的流水线：
- en: An overall driver puts simulation requests into a processing queue.
  id: totrans-1196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个总体驱动程序将模拟请求放入处理队列。
- en: A pool of simulators will get a request from the processing queue, perform the
    simulation, and put the statistics into a results queue.
  id: totrans-1197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一组模拟器将从处理队列获取请求，执行模拟，并将统计数据放入结果队列。
- en: A summarizer will get the results from the results queue and create a final
    tabulation of the results.
  id: totrans-1198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇总器将从结果队列获取结果，并创建最终的结果汇总。
- en: Using a process pool allows us to have as many simulations running concurrently
    as our CPU can handle. The pool of simulators can be configured to ensure that
    simulations run as quickly as possible.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用进程池允许我们同时运行尽可能多的模拟，以便我们的CPU可以处理。模拟器池可以配置，以确保模拟尽快运行。
- en: 'Here''s a definition of the simulator process:'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模拟器进程的定义：
- en: '[PRE176]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'We''ve extended `multiprocessing.Process`. This means that we must do two things
    to work properly with multiprocessing: we must assure that `super().__init__()`
    is executed, and we must override `run()`.'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经扩展了`multiprocessing.Process`。这意味着我们必须做两件事才能正确地使用多进程：我们必须确保执行`super().__init__()`，并且我们必须重写`run()`。
- en: 'Within the body of `run()`, we''re using two queues. The `setup_queue` queue
    instance will contain two-tuples of the `Table` and `Player` objects. The process
    will use these two objects to run a simulation. It will put the resulting three-tuple
    into `result_queue` queue instance. The API for the `Simulate` class is this:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run()`的主体内，我们使用了两个队列。`setup_queue`队列实例将包含`Table`和`Player`对象的两元组。进程将使用这两个对象来运行模拟。它将把结果放入`result_queue`队列实例中。`Simulate`类的API如下：
- en: '[PRE177]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The iterator will yield the requested number, `samples`, of statistical summaries.
    We''ve included a provision for a **sentinel object** to arrive via `setup_queue`.
    This object will be used to gracefully close down the processing. If we don''t
    use a sentinel object, we''re forced to terminate the processes, which can disrupt
    locks and other system resources. Here''s the summarization process:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器将产生请求的数量`samples`的统计摘要。我们已经包括了一个**sentinel对象**通过`setup_queue`到达。这个对象将被用来优雅地关闭处理。如果我们不使用一个sentinel对象，我们将被迫终止进程，这可能会破坏锁定和其他系统资源。以下是摘要过程：
- en: '[PRE178]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: This also extends `multiprocessing.Process`. In this case, we're fetching items
    from a queue and simply counting them. A more useful process might use several
    `collection.Counter` objects to accumulate more interesting statistics.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 这也扩展了`multiprocessing.Process`。在这种情况下，我们从队列中获取项目并简单地对其进行计数。一个更有用的进程可能会使用多个`collection.Counter`对象来累积更有趣的统计数据。
- en: As with the `Simulation` class, we're also going to detect a sentinel and gracefully
    close down the processing. The use of a sentinel object allows us to close down
    processing as soon as the work is completed by the process. In some applications,
    the child process can be left running indefinitely.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Simulation`类一样，我们还将检测到一个标记并优雅地关闭处理。使用标记对象可以让我们在进程完成工作后立即关闭处理。在一些应用中，子进程可以无限期地运行。
- en: Building queues and supplying data
  id: totrans-1209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建队列和提供数据
- en: 'Building queues involves creating instances of `multiprocessing.Queue` or one
    of its subclasses. For this example, we can use the following:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 构建队列涉及创建`multiprocessing.Queue`的实例或其子类的实例。对于这个例子，我们可以使用以下内容：
- en: '[PRE179]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'We created two queues that define the processing pipeline. When we put a simulation
    request into `setup_q`, we expect that a `Simulation` process will pick up the
    request pair and run the simulation. This should generate a results three-tuple
    of table, player and results in the `results_q` Queue. in `results_q`. The results
    triple should, in turn, lead to work being done by the `Summarize` process. Here''s
    how we can start a single `Summarize` process:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个定义处理流水线的队列。当我们将模拟请求放入`setup_q`时，我们期望`Simulation`进程会接收请求对并运行模拟。这应该在`results_q`队列中生成一个包含表、玩家和结果的三元组。这个结果三元组应该进一步导致`Summarize`进程进行工作。以下是如何启动单个`Summarize`进程的方法：
- en: '[PRE180]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Here''s how we can create four concurrent simulation processes:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建四个并发模拟进程的方法：
- en: '[PRE181]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The four concurrent simulators will be competing for work. Each one will be
    attempting to grab the next request from the queue of pending requests. Once all
    four simulators are busy working, the queue will start to get filled with unprocessed
    requests. Once the queues and processes are waiting, the driver function can start
    putting requests into the `setup_q` queue. Here''s a loop that will generate a
    flood of requests:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 四个并发模拟器将竞争工作。每个模拟器都将尝试从待处理请求的队列中获取下一个请求。一旦所有四个模拟器都忙于工作，队列将开始填充未处理的请求。一旦队列和进程都在等待，驱动函数就可以开始将请求放入`setup_q`队列。以下是一个将生成大量请求的循环：
- en: '[PRE182]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'We created a `Table` object. For each of the three betting strategies, we created
    a `Player` object, and then queued up a simulation request. The pickled two-tuple
    will be fetched from the queue by the `Simulation` object and then it will be
    processed. In order to have an orderly termination, we''ll need to queue sentinel
    objects for each simulator:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`Table`对象。对于三种投注策略，我们创建了一个`Player`对象，然后排队一个模拟请求。`Simulation`对象将从队列中获取pickled的两元组，然后对其进行处理。为了有序终止，我们需要为每个模拟器排队标记对象：
- en: '[PRE183]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: We put a sentinel object into the queue for each simulator to consume. Once
    all the simulators have consumed the sentinels, we can wait for the processes
    to finish execution and join back into the parent process.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个模拟器，我们将一个标记对象放入队列中以供消耗。一旦所有模拟器都消耗了标记对象，我们就可以等待进程完成执行并重新加入到父进程中。
- en: 'Once the `Process.join()` operation is finished, no more simulation data will
    be created. We can enqueue a sentinel object into the simulation results queue
    as well:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Process.join()`操作完成，将不会再创建模拟数据。我们也可以将一个标记对象放入模拟结果队列中：
- en: '[PRE184]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Once the results sentinel object is processed, the `Summarize` process will
    stop accepting input and we can `join()` it as well.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦结果标记对象被处理，`Summarize`进程将停止接受输入，我们也可以`join()`它。
- en: We used multiprocessing to transmit objects from one process to another. This
    gives us a relatively simple way to create high-performance, multi-processing
    data pipelines. The `multiprocessing` module uses `pickle`, so there are few limitations
    on the nature of objects that can be pushed through the pipelines.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用多进程将对象从一个进程传输到另一个进程。这为我们提供了一个相对简单的方法来创建高性能的多处理数据流水线。`multiprocessing`模块使用`pickle`，因此对可以通过流水线推送的对象的性质几乎没有限制。
- en: Summary
  id: totrans-1225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at transmitting and sharing objects using RESTful web services and
    the `wsgiref` module, as well as the `multiprocessing` module. Both of these architectures
    provide for communicating a representation of an object's state. In the case of
    `multiprocessing`, pickle is used to represent the state. In the case of building
    RESTful web services, we have to choose the representation(s) used. In the examples
    used here, we focused on JSON because it's widely used and has a simple implementation.
    Many frameworks will offer simple implementations of XML as well.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了使用RESTful web服务和`wsgiref`模块以及`multiprocessing`模块来传输和共享对象，这两种架构都提供了通信对象状态表示的方式。在`multiprocessing`的情况下，使用pickle来表示状态。在构建RESTful
    web服务的情况下，我们必须选择要使用的表示形式。在这里使用的示例中，我们专注于JSON，因为它被广泛使用并且具有简单的实现。许多框架也会提供XML的简单实现。
- en: Performing RESTful web services using a WSGI application framework formalizes
    the process of receiving HTTP requests, deserializing any objects, performing
    the requested processing, serializing any results, and providing a response. Because
    WSGI applications have a simple, standardized API, we can easily create composite
    applications and write wrapper applications. We can often leverage wrapper applications
    to handle the authentication elements of security in a simple, consistent manner.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WSGI应用程序框架执行RESTful web服务规范化了接收HTTP请求、反序列化任何对象、执行请求的处理、序列化任何结果和提供响应的过程。由于WSGI应用程序具有简单、标准化的API，我们可以轻松地创建复合应用程序和编写包装应用程序。我们通常可以利用包装应用程序以简单、一致的方式处理安全性的身份验证元素。
- en: We also looked at using `multiprocessing` to enqueue and dequeue messages from
    shared queues. The beauty of using message queues is that we can avoid the locking
    problems associated with concurrent updates to shared objects.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了使用`multiprocessing`来对共享队列中的消息进行入队和出队操作。使用消息队列的美妙之处在于我们可以避免与共享对象的并发更新相关的锁定问题。
- en: Design considerations and trade-offs
  id: totrans-1229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: 'We must also decide what grain of objects to make available and how to identify
    those objects with sensible URIs. With larger objects, we can easily achieve ACID
    properties. However, we may also be uploading and downloading too much data for
    our application''s use cases. In some cases, we''ll need to provide alternative
    levels of access: large objects to support ACID properties, small objects to allow
    rapid response when a client application wants a subset of the data.'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须决定要提供什么级别的对象以及如何使用明智的URI标识这些对象。对于较大的对象，我们可以轻松实现ACID属性。然而，我们可能也会上传和下载过多的数据以满足我们应用程序的用例。在某些情况下，我们需要提供替代级别的访问：大对象以支持ACID属性，小对象以在客户端应用程序需要数据子集时快速响应。
- en: To implement more localized processing, we can leverage the `multiprocessing`
    module. This is focused more on building high-performance processing pipelines
    within a trusted host or network of hosts.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现更加本地化的处理，我们可以利用`multiprocessing`模块。这更侧重于在受信任的主机或主机网络中构建高性能处理管道。
- en: In some cases, the two design patterns are combined so that a RESTful request
    is handled by a multiprocessing pipeline. A conventional web server (such as Apache
    HTTPD) working through the `mod_wsgi` extension can use multiprocessing techniques
    to pass a request through a named pipe from the Apache frontend to the WSGI application
    backend.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这两种设计模式结合在一起，以便一个RESTful请求由多进程管道处理。传统的Web服务器（如Apache HTTPD）通过`mod_wsgi`扩展可以使用多进程技术，通过命名管道将请求从Apache前端传递到WSGI应用程序后端。
- en: Schema evolution
  id: totrans-1233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式演变
- en: When working with a public-facing API for RESTful services, we have to address
    the schema evolution problem. If we change a class definition, how will we change
    the response messages? If the external RESTful API must change for compatibility
    with other programs, how do we upgrade the Python web services to support a changing
    API?
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理面向公众的RESTful服务的API时，我们必须解决模式演变问题。如果我们更改类定义，我们将如何更改响应消息？如果外部RESTful API必须更改以与其他程序兼容，我们如何升级Python
    Web服务以支持不断变化的API？
- en: Often, we'll have to provide a major release version number as part of our API.
    This might be provided explicitly as part of the path, or implicitly via data
    fields included in the `POST`, `PUT`, and `DELETE` requests.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们必须在我们的API中提供一个主要的发布版本号。这可能是作为路径的一部分明确提供，或者隐含地通过包括在`POST`，`PUT`和`DELETE`请求中的数据字段提供。
- en: We need to distinguish between changes that don't alter the URI paths or responses
    and changes that will alter a URI or response. Minor changes to functionality
    will not change a URI or the structure of a response.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要区分不会改变URI路径或响应的更改和将改变URI或响应的更改。对功能的较小更改不会改变URI或响应的结构。
- en: Changes to the URIs or the structure of a response may break an existing application.
    These are major changes. One way to make an application work gracefully through
    schema upgrades is to include version numbers in the URI paths. For example, `/roulette_2/wheel/`
    specifically names the second release of the roulette server.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 对URI或响应结构的更改可能会破坏现有的应用程序。这些是重大变化。使应用程序通过模式升级优雅地工作的一种方法是在URI路径中包含版本号。例如，`/roulette_2/wheel/`明确指定了轮盘服务器的第二个版本。
- en: Application software layers
  id: totrans-1238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用软件层
- en: Because of the relative sophistication available when using `sqlite3`, our application
    software must become more properly layered. For a REST client, we might look at
    a software architecture with layers.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`sqlite3`时相对复杂，我们的应用软件必须更加合理地分层。对于REST客户端，我们可能会考虑具有层的软件架构。
- en: When we are building a RESTful server, the presentation layer becomes greatly
    simplified. It is pared down to the essential request-response processing. It
    parses URIs and responds with documents in JSON or XML (or some other representation.)
    This layer should be reduced to a thin RESTful facade over the lower level features.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建一个RESTful服务器时，表示层变得大大简化。它被简化为基本的请求-响应处理。它解析URI并以JSON或XML（或其他表示形式）的文档进行响应。这一层应该被简化为对较低级别功能的薄RESTful外观。
- en: In some complex cases, the front-most application—as viewed by human users—involves
    data from several distinct sources. One easy way to integrate data from diverse
    sources is to wrap each source in a RESTful API. This provides us with a uniform
    interface over distinct sources of data. It allows us to write applications that
    gather these diverse kinds of data in a uniform way.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些复杂情况下，人类用户所看到的最前端应用涉及来自几个不同来源的数据。整合来自不同来源的数据的一种简单方法是将每个来源包装在RESTful API中。这为我们提供了对数据不同来源的统一接口。它允许我们编写应用程序以统一的方式收集这些不同类型的数据。
- en: Looking forward
  id: totrans-1242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In the next chapter, we'll use persistence techniques to handle configuration
    files. A file that's editable by humans is the primary requirement for the configuration
    data. If we use a well-known persistence module, then our application can parse
    and validate the configuration data with less programming on our part.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用持久化技术来处理配置文件。可由人类编辑的文件是配置数据的主要要求。如果我们使用一个知名的持久化模块，那么我们的应用程序可以在较少的编程下解析和验证配置数据。
- en: Chapter 13. Configuration Files and Persistence
  id: totrans-1244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。配置文件和持久性
- en: A configuration file is a form of object persistence. It contains a serialized,
    editable representation of some default state for an application program or server.
    We'll expand on our serialization techniques for the object representation shown
    in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML* to
    create configuration files.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件是一种对象持久化的形式。它包含了应用程序或服务器的一些默认状态的序列化、可编辑表示。我们将扩展我们在[第9章](ch09.html "第9章。序列化和保存
    - JSON、YAML、Pickle、CSV和XML")中展示的对象表示的序列化技术，*序列化和保存 - JSON、YAML、Pickle、CSV和XML*
    来创建配置文件。
- en: 'In addition to having a plain-text editable configuration file, we must also
    design our application to be configurable. Further, we must define some kind of
    configuration object (or collection) that our application can use. In many cases,
    we''ll have a series of default values that include system-wide defaults and user-specific
    overrides to those defaults. We''ll look at six representations for the configuration
    data:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拥有一个纯文本可编辑的配置文件，我们还必须设计我们的应用程序是可配置的。此外，我们必须定义一种应用程序可以使用的配置对象（或集合）。在许多情况下，我们将有一系列包括系统范围默认值和用户特定覆盖的默认值。我们将研究配置数据的六种表示：
- en: INI files use a format that was pioneered as part of Windows. It's popular in
    part because it is an incumbent format, and many other configuration files might
    use this notation.
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INI文件使用的格式是Windows的一部分。它之所以受欢迎，部分原因是它是一种现有的格式，许多其他配置文件可能使用这种表示法。
- en: PY files are plain-old Python code. This has numerous advantages because of
    the familiarity and simplicity of working with it.
  id: totrans-1248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PY文件是普通的Python代码。这有很多优势，因为人们熟悉并且简单地使用它。
- en: JSON or YAML are both designed to be human-friendly and easy to edit.
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON或YAML都设计成人性化和易于编辑。
- en: Property files are often used in a Java environment. They're relatively easy
    to work and are also designed to be human-friendly.
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性文件经常在Java环境中使用。它们相对容易使用，也设计成人性化。
- en: XML files are popular but are wordy and are sometimes difficult to edit properly.
    The Mac OS uses an XML-based format called a property list or the `.plist` file.
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML文件很受欢迎，但有时很啰嗦，有时很难正确编辑。Mac OS使用一种基于XML的格式，称为属性列表或`.plist`文件。
- en: Each of these forms offers us some advantages and some disadvantages. There's
    no single technique that's the best. In many cases, the choice is based on compatibility
    with other software or familiarity with another format in the user community.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 每种形式都为我们提供了一些优势和一些劣势。没有一种技术是最好的。在许多情况下，选择是基于与其他软件的兼容性或用户社区中对其他格式的熟悉程度。
- en: Configuration file use cases
  id: totrans-1253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件的用例
- en: 'There are two configuration file use cases. Sometimes, we can stretch the definition
    a bit to add a third use case. The first two should be pretty clear:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种配置文件的用例。有时，我们可以稍微扩展定义，添加第三种用例。前两种应该是相当清楚的：
- en: A person needs to edit a configuration file
  id: totrans-1255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个人需要编辑一个配置文件
- en: A piece of software will read a configuration file and make use of the options
    and arguments to tailor its behavior
  id: totrans-1256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件将读取配置文件并利用选项和参数来调整其行为
- en: Configuration files are rarely the *primary* input to an application program.
    The big exception is a simulation where the configuration might be the primary
    input. In most other cases, the configuration isn't primary. For example, a web
    server's configuration file might tailor the behavior of the server, but the web
    requests are one primary input, and a database or filesystem is the other primary
    input. In the case of a GUI application, the user's interactive events are one
    input, and files or database may be another input; a configuration file may fine-tune
    the application.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件很少是应用程序的*主要*输入。一个大的例外是模拟，其中配置可能是主要输入。在大多数其他情况下，配置不是主要输入。例如，Web服务器的配置文件可能调整服务器的行为，但Web请求是一个主要输入，数据库或文件系统是另一个主要输入。在GUI应用程序的情况下，用户的交互事件是一个输入，文件或数据库可能是另一个输入；配置文件可以微调应用程序。
- en: There's a blurry edge to this distinction between primary and configuration
    input. Ideally, an application has one behavior irrespective of the configuration
    details. Pragmatically, however, the configuration might introduce additional
    strategies or states to an existing application, changing its behavior. In this
    case, the configuration can straddle the line and become part of the code, not
    merely a configuration to a fixed code base.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 在主要输入和配置输入之间存在模糊的边界。理想情况下，一个应用程序的行为应该与配置细节无关。然而，从实用的角度来看，配置可能会引入额外的策略或状态到现有的应用程序中，从而改变其行为。在这种情况下，配置可以跨越界限，成为代码的一部分，而不仅仅是固定代码库的配置。
- en: 'A possible third use case is to save a configuration back to a file after an
    application has updated it. This use of persistent stateful objects is atypical
    because the configuration file has morphed into a primary input in which the program
    is saving its operating state. This use case may indicate that two things have
    been conflated into a single file: configuration parameters and the persistent
    operating state. It''s better to design this as a persistent state that uses a
    human-readable format.'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的第三种用例是在应用程序更新后将配置保存回文件。这种使用持久状态对象的方式是不典型的，因为配置文件已经变成了主要输入，程序正在保存其操作状态。这种用例可能表明两件事已经融合成一个文件：配置参数和持久操作状态。最好将其设计为使用人类可读格式的持久状态。
- en: 'A configuration file can provide a number of kinds of arguments and parameter
    values to an application. We need to look a little more deeply at some of these
    various kinds of data to decide how to represent them best:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件可以为应用程序提供多种参数和参数值。我们需要更深入地研究一些这些不同类型的数据，以决定如何最好地表示它们。
- en: Default values
  id: totrans-1261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认值
- en: Device names, which may overlap with the filesystem's location
  id: totrans-1262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备名称，可能与文件系统的位置重叠
- en: Filesystem locations and search paths
  id: totrans-1263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统位置和搜索路径
- en: Limits and boundaries
  id: totrans-1264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制和边界
- en: Message templates and data format specifications
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息模板和数据格式规范
- en: Message text, possibly translated for internationalization
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息文本，可能已经翻译成国际化
- en: Network names, addresses, and port numbers
  id: totrans-1267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络名称、地址和端口号
- en: Optional behaviors
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选行为
- en: Security keys, tokens, usernames, passwords
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全密钥、令牌、用户名、密码
- en: 'Value domains:'
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值域：
- en: 'These values are values of relatively common types: strings, integers, and
    floating-point numbers. All of those values have a tidy textual representation
    that''s relatively easy for a person to edit. They''re also straightforward for
    our Python applications to parse the human input.'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是相对常见类型的值：字符串、整数和浮点数。所有这些值都有一个整洁的文本表示，对于人来说相对容易编辑。它们对我们的Python应用程序来说也很容易解析人类输入。
- en: In some cases, we may have lists of values. For example, a domain of values
    or a path might be a collection of simpler types. Often, this is a simple sequence
    or a sequence of tuples. A dict-like mapping is often used for message texts so
    that an application's software key can be mapped to customized natural language
    wording.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能会有值的列表。例如，值域或路径可能是更简单类型的集合。通常，这是一个简单的序列或元组序列。类似字典的映射通常用于消息文本，以便将应用程序的软件密钥映射到定制的自然语言措辞。
- en: 'There is one additional configuration value that isn''t a simple type with
    a tidy text representation. We could add this bullet to the preceding list:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个不是简单类型的额外配置值，它没有整洁的文本表示。我们可以将这个项目添加到前面的列表中：
- en: 'Additional features, plugins, and extensions that are code:'
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的附加功能、插件和扩展：
- en: 'This is challenging because we''re not necessarily providing a simple string
    value to the application. The configuration provides an object that the application
    will use. When the plugin has more of Python code, we can provide the path to
    an installed Python module as it would be used in an `import` statement using
    this dotted name: ''`package.module.object`''. An application can then perform
    the expected ''`from package.module import object`'' code and use the given class
    or function.'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是具有挑战性的，因为我们不一定向应用程序提供一个简单的字符串值。配置提供了一个应用程序将使用的对象。当插件有更多的Python代码时，我们可以提供已安装的Python模块的路径，就像在`import`语句中使用这个点名一样：'`package.module.object`'。然后应用程序可以执行预期的'`from
    package.module import object`'代码并使用给定的类或函数。
- en: 'For non-Python code, we have two other techniques to import the code in a way
    it can be used:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非Python代码，我们有另外两种技术来导入代码，以便可以使用它：
- en: For binaries that aren't proper executable programs, we can try to use the `ctypes`
    module to call defined API methods
  id: totrans-1277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不是适当的可执行程序的二进制文件，我们可以尝试使用`ctypes`模块调用定义的API方法
- en: For binaries that are executable programs, the `subprocess` module gives us
    ways to execute them
  id: totrans-1278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可执行程序的二进制文件，`subprocess`模块为我们提供了执行它们的方法
- en: Both of these techniques aren't about Python specifically and push the edge
    of the envelope for this chapter. We'll focus on the core issue of getting the
    arguments or the parameter values. How these values are used is a very large topic.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都不是特定于Python的，并且推动了本章的边界。我们将专注于获取参数或参数值的核心问题。这些值的使用是一个非常大的话题。
- en: Representation, persistence, state, and usability
  id: totrans-1280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示、持久性、状态和可用性
- en: 'When looking at a configuration file, we''re looking at a human-friendly version
    of the state of one or more objects. When we edit a configuration file, we''re
    changing the persistent state of an object that will get reloaded when the application
    is started (or restarted.) We have two common ways to look at a configuration
    file:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 查看配置文件时，我们正在查看一个或多个对象状态的人性化版本。当我们编辑配置文件时，我们正在更改对象的持久状态，当应用程序启动（或重新启动）时将重新加载。我们有两种常见的查看配置文件的方式：
- en: A mapping or a group of mappings from parameter names to values
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从参数名称到值的映射或一组映射
- en: A serialized object that's more than a simple mapping
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个序列化的对象，不仅仅是一个简单的映射
- en: When we try to reduce a configuration file to a mapping, we might be limiting
    the scope of relationships that may exist within the configuration. In a simple
    mapping, everything must be referred to by a name, and we have to work through
    the same key design issues that we looked at in [Chapter 10](ch10.html "Chapter 10. Storing
    and Retrieving Objects via Shelve"), *Storing and Retrieving Objects via Shelve*,
    and [Chapter 11](ch11.html "Chapter 11. Storing and Retrieving Objects via SQLite"),
    *Storing and Retrieving Objects via SQLite*, when talking about the keys for `shelve`
    and `sqlite`. We provide a unique name in one part of a configuration so that
    other parts can refer to it properly.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图将配置文件简化为映射时，我们可能会限制配置中可能存在的关系范围。在简单映射中，一切都必须通过名称引用，并且我们必须解决与[第10章](ch10.html
    "第10章。通过Shelve存储和检索对象")中讨论的`shelve`和[第11章](ch11.html "第11章。通过SQLite存储和检索对象")中讨论的`sqlite`的键设计问题相同的键设计问题。我们在配置的一部分提供一个唯一的名称，以便其他部分可以正确引用它。
- en: It's helpful to look at the `logging` configuration for examples of how it can
    be very challenging to configure a complex system. The relationships among Python
    logging objects—loggers, formatters, filters, and handlers—must all be bound together
    to create usable loggers. Section 16.8 of *Standard Library Reference* shows us
    two different syntaxes for the logging configuration files. We'll look at logging
    in [Chapter 14](ch14.html "Chapter 14. The Logging and Warning Modules"), *The
    Logging and Warning Modules*.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`logging`配置的示例有助于理解如何配置复杂系统可能非常具有挑战性。Python日志对象之间的关系——记录器、格式化程序、过滤器和处理程序——必须全部绑定在一起才能创建可用的记录器。*标准库参考*的第16.8节向我们展示了日志配置文件的两种不同语法。我们将在[第14章](ch14.html
    "第14章。日志和警告模块")中查看日志，*日志和警告模块*。
- en: In some cases, it may be simpler to serialize complex Python objects or resort
    to using Python code directly as the configuration file. If a configuration file
    adds too much complexity, then it may not be of any real value.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将复杂的 Python 对象序列化或者使用 Python 代码直接作为配置文件可能更简单。如果配置文件增加了太多的复杂性，那么它可能并没有真正的价值。
- en: Application configuration design patterns
  id: totrans-1287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序配置设计模式
- en: 'There are two core design patterns for the application configuration:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序配置有两种核心设计模式：
- en: '**Global property map**: A global object will contain all of the configuration
    parameters. This can be either a map of `name:value` pairs, or a big namespace
    object of attribute values. This may follow a **Singleton** design pattern to
    ensure that only one instance exists.'
  id: totrans-1289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局属性映射**：一个全局对象将包含所有的配置参数。这可以是一个 `name:value` 对的映射，也可以是一个属性值的大型命名空间对象。这可能遵循**单例**设计模式，以确保只有一个实例存在。'
- en: '**Object Construction**: Instead of a single object, we''ll define a kind of
    **Factory** or collection of **Factories** that use the configuration data to
    build the objects of the application. In this case, the configuration information
    is used once when a program is started and never again. The configuration information
    isn''t kept around as a global object.'
  id: totrans-1290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象构造**：我们将定义一种**工厂**或**工厂**集合，使用配置数据来构建应用程序的对象。在这种情况下，配置信息在程序启动时使用一次，以后再也不使用。配置信息不会作为全局对象保留。'
- en: 'The global property map design is very popular because it is simple and extensible.
    We might have an object as simple as the following code:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 全局属性映射设计非常受欢迎，因为它简单且可扩展。我们可能会有一个如下代码简单的对象：
- en: '[PRE185]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'We can use the preceding class definition as a global container of attributes.
    During the initialization, we might have something like this as part of parsing
    a configuration file:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的类定义作为属性的全局容器。在初始化过程中，我们可能会在解析配置文件的一部分中有类似以下的内容：
- en: '[PRE186]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Everywhere else in the program, we can use the value of `Configuration.some_attribute`.
    A variation on this theme is to make a more formal **Singleton** object design
    pattern. This is often done with a global module, as that can be easily imported
    in a way that provides us with an accessible global definition.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的其他地方，我们可以使用 `Configuration.some_attribute` 的值。这个主题的一个变体是制作一个更正式的**单例**对象设计模式。这通常是通过全局模块来完成的，因为这样可以很容易地导入，从而为我们提供一个可访问的全局定义。
- en: 'We might have a module named `configuration.py`. In that file, we can have
    a definition like the following:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个名为 `configuration.py` 的模块。在那个文件中，我们可以有以下定义：
- en: '[PRE187]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Now, the application can use `configuration.settings` as a global repository
    for all of the application's settings. A function or class can parse the configuration
    file, loading this dictionary with the configuration values that the application
    will then use.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序可以使用 `configuration.settings` 作为应用程序所有设置的全局存储库。一个函数或类可以解析配置文件，加载这个字典与应用程序将使用的配置值。
- en: 'In a Blackjack simulation, we might see code like the following:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个二十一点模拟中，我们可能会看到类似以下的代码：
- en: '[PRE188]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Or, we might possibly see code like the following one:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能会看到类似以下的代码：
- en: '[PRE189]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Often, we'll try to avoid having a global variable. Because a global variable
    is implicitly present everywhere, it can be overlooked. Instead of a global variable,
    we can often handle the configuration slightly more neatly through object construction.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会尽量避免使用全局变量。因为全局变量隐式地存在于任何地方，所以它可能会被忽视。我们可以通过对象构造来更整洁地处理配置，而不是使用全局变量。
- en: Configuring via object construction
  id: totrans-1304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过对象构造进行配置
- en: When configuring an application via object construction, the objective is to
    build the required objects. In effect, the configuration file defines the various
    initialization parameters for the objects that will be built.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过对象构造配置应用程序时，目标是构建所需的对象。实际上，配置文件定义了将要构建的对象的各种初始化参数。
- en: We can often centralize much of this kind of initial object construction in
    a single, overall the `main()` function. This will create the objects that do
    the real work of the application. We'll revisit and expand on these design issues
    in [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping
    with the Command Line*.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常可以将这种初始对象构造的大部分集中在一个单一的 `main()` 函数中。这将创建应用程序的真正工作的对象。我们将在[第16章](ch16.html
    "第16章。处理命令行") *处理命令行*中重新讨论并扩展这些设计问题。
- en: 'Consider a simulation of Blackjack playing and betting strategies. When we
    run a simulation, we want to gather the performance of a particular combination
    of independent variables. These variables might include some casino policies including
    the number of decks, table limits, and dealer rules. The variables might include
    the player''s game strategies for when to hit, stand, split, and double down.
    It would also include the player''s betting strategies of flat betting, Martingale
    betting, or some more Byzantine betting system. Our baseline code starts out something
    like the following code:'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下二十一点玩法和投注策略的模拟。当我们运行模拟时，我们想要收集特定组合的独立变量的性能。这些变量可能包括一些赌场政策，包括牌组数量、桌面限制和庄家规则。这些变量可能包括玩家的游戏策略，例如何时要牌、停牌、分牌和加倍。它还将包括玩家的投注策略，如平注、马丁尼投注或更复杂的拜占庭投注系统。我们的基线代码开始如下所示：
- en: '[PRE190]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: This is a kind of technology spike that has hardcoded all of the object classes
    and initial values. We'll need to add configuration parameters to determine the
    classes of objects and their initial values.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种技术飞跃，它已经硬编码了所有的对象类和初始值。我们需要添加配置参数来确定对象的类和它们的初始值。
- en: 'The `Simulate` class has an API that looks like the following code:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '`Simulate` 类有一个 API，看起来像以下代码：'
- en: '[PRE191]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: This allows us to build the `Simulate()` object with some appropriate initialization
    parameters. Once we've built an instance of `Simulate()`, we can iterate through
    that object to get a series of statistical summary objects.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用一些适当的初始化参数构建`Simulate()`对象。一旦我们建立了`Simulate()`的实例，我们可以通过该对象进行迭代，以获得一系列统计摘要对象。
- en: The interesting part is using the configuration parameters instead of class
    names. For example, some parameter should be used to decide whether to create
    an instance of `Hit17` or `Stand17` for the `dealer_rule` value. Similarly, the
    `split_rule` value should be a choice among several classes that embody several
    different split rules used in casinos.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是使用配置参数而不是类名。例如，某些参数应该用于决定`dealer_rule`值是创建`Hit17`还是`Stand17`实例。同样，`split_rule`值应该是在几个类中选择，这些类体现了赌场中使用的几种不同的分牌规则。
- en: In other cases, parameters should be used to provide arguments to the class
    `__init__()` method. For example, the number of decks, the house betting limit,
    and the Blackjack payout values are configuration values used to create the `Table`
    instance.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，应该使用参数来为类的`__init__()`方法提供参数。例如，牌组数量、庄家下注限制和二十一点赔付值是用于创建`Table`实例的配置值。
- en: 'Once the objects are built, they interact normally via the `Simulate.run()`
    method to produce statistical output. No further need of a global pool of parameters
    is required: the parameter values are bound into the objects via their instance
    variables.'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象建立，它们通过`Simulate.run()`方法正常交互以产生统计输出。不再需要全局参数池：参数值通过它们的实例变量绑定到对象中。
- en: The object construction design is not as simple as a global property map. It
    has the advantage of avoiding a global variable, and it also has the advantage
    of making the parameter processing central and obvious in some main factory function.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 对象构造设计并不像全局属性映射那样简单。它避免了全局变量的优势，也使参数处理在一些主要工厂函数中变得集中和明显。
- en: Adding new parameters when using object construction may lead to refactoring
    the application to expose a parameter or a relationship. This can make it seem
    more complex than a global mapping from name to value.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用对象构造时添加新参数可能会导致重构应用程序以公开参数或关系。这可能会使其看起来比从名称到值的全局映射更复杂。
- en: One significant advantage of this technique is the removal of the complex `if`
    statements deep within the application. Using the `Strategy` design patterns tends
    to push decision making forward into object construction. In addition to simplifying
    the processing, the elimination of the `if` statements can be a performance boost.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的一个重要优势是消除了应用程序深处的复杂`if`语句。使用`Strategy`设计模式倾向于将决策推进到对象构造中。除了简化处理外，消除`if`语句还可以提高性能。
- en: Implementing a configuration hierarchy
  id: totrans-1319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施配置层次结构
- en: 'We often have several choices on where a configuration file should be placed.
    There are five common choices, and we can use all five to create a kind of inheritance
    hierarchy for the parameters:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常有几种选择来放置配置文件。有五种常见选择，我们可以使用所有五种来创建参数的一种继承层次结构：
- en: '**The application''s installation directory**: In effect, these are analogous
    to base class definitions. There are two subchoices here. Smaller applications
    can be installed in Python''s library structure; an initialization file too can
    be installed there. Larger applications will often have their own username that
    owns one or more installation directory trees.'
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序的安装目录**：实际上，这类似于基类定义。这里有两个子选择。较小的应用程序可以安装在Python的库结构中；初始化文件也可以安装在那里。较大的应用程序通常会有自己的用户名，拥有一个或多个安装目录树。'
- en: '**Python installation directory**: We can find the installed location for a
    module using the `__file__` attribute of the module. From here, we can use `os.path.split()`
    to locate a configuration file:'
  id: totrans-1322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python安装目录**：我们可以使用模块的`__file__`属性找到模块的安装位置。从这里，我们可以使用`os.path.split()`来定位配置文件：'
- en: '[PRE192]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '**Application installation directory**: This will be based on an owning username,
    so we can use `~theapp/` and `os.path.expanduser()` to track down the configuration
    defaults.'
  id: totrans-1324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序安装目录**：这将基于拥有的用户名，因此我们可以使用`~theapp/`和`os.path.expanduser()`来跟踪配置默认值。'
- en: '**A system-wide configuration directory**: This is often present in `/etc`.
    This can be transformed into `C:\etc` on Windows. Alternatives include the value
    of `os.environ[''WINDIR'']` or `os.environ[''ALLUSERSPROFILE'']`.'
  id: totrans-1325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统范围的配置目录**：这通常存在于`/etc`中。在Windows上，这可以转换为`C:\etc`。其他选择包括`os.environ[''WINDIR'']`或`os.environ[''ALLUSERSPROFILE'']`的值。'
- en: '**The current user''s home directory**: We can generally use `os.path.expanduser()`
    to translate `~/` into the user''s home directory. For Windows, Python will properly
    use the `%HOMEDRIVE%` and `%HOMEPATH%` environment variables.'
  id: totrans-1326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前用户的主目录**：通常可以使用`os.path.expanduser()`将`~/`转换为用户的主目录。对于Windows，Python将正确使用`%HOMEDRIVE%`和`%HOMEPATH%`环境变量。'
- en: '**The current working directory**: The directory is usually known as `./`,
    although `os.path.curdir` is more portable.'
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前工作目录**：该目录通常称为`./`，尽管`os.path.curdir`更具可移植性。'
- en: '**A file named in the command-line parameters**: This is an explicitly named
    file and no further processing should be done to the name.'
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在命令行参数中命名的文件**：这是一个明确命名的文件，不应进一步处理名称。'
- en: An application can integrate configuration options from all of these sources
    from the base class (listed first) to the command-line options. In this way, the
    installation default values are the most generic and least user-specific; these
    values can be overridden by more specific and less-generic values.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以从基类（首先列出）到命令行选项中集成所有这些来源的配置选项。通过这种方式，安装默认值是最通用且最不特定于用户的；这些值可以被更具体和不那么通用的值覆盖。
- en: 'This means that we''ll often have a list of files like the following code:'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们经常会有一系列文件，如以下代码所示：
- en: '[PRE193]'
  id: totrans-1331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: We've taken a tuple of alternative file directories and created a list of candidate
    filenames by joining the directory with the configuration filename.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取了一个备用文件目录的元组，并通过将目录与配置文件名连接起来创建了一个候选文件名列表。
- en: 'Once we have this list of configuration filenames, we can append any filename
    supplied via the command-line arguments to the end of the list with the following
    code:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个配置文件名列表，我们可以使用以下代码将通过命令行参数提供的任何文件名附加到列表的末尾：
- en: '[PRE194]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: This gives us a list of locations that we can examine to locate a configuration
    file or configuration defaults.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个可以检查以定位配置文件或配置默认值的位置列表。
- en: Storing the configuration in the INI files
  id: totrans-1336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将配置存储在INI文件中
- en: The INI file format has historical origins from early Windows OS. The module
    to parse these files is `configparser`.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: INI文件格式起源于早期的Windows操作系统。解析这些文件的模块是`configparser`。
- en: 'For additional details on the INI file, see this Wikipedia article: [http://en.wikipedia.org/wiki/INI_file](http://en.wikipedia.org/wiki/INI_file).'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 有关INI文件的更多细节，请参阅维基百科文章：[http://en.wikipedia.org/wiki/INI_file](http://en.wikipedia.org/wiki/INI_file)。
- en: 'An INI file has sections and properties within each section. Our sample main
    program has three sections: the table configuration, player configuration, and
    overall simulation data gathering.'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: INI文件有各个部分和每个部分内的属性。我们的示例主程序有三个部分：表配置，玩家配置和整体模拟数据收集。
- en: 'We can imagine an INI file that looks like the following code:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一个看起来像以下代码的INI文件：
- en: '[PRE195]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: We've broken the parameters into three sections. Within each section, we've
    provided some named parameters that correspond to the class names and initialization
    values shown in our preceding model application initialization.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将参数分为三个部分。在每个部分中，我们提供了一些命名参数，这些参数对应于我们前面模型应用初始化中显示的类名和初始化值。
- en: 'A single file can be parsed very simply:'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文件可以非常简单地解析：
- en: '[PRE196]'
  id: totrans-1344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: We've created an instance of the parser and provided the target configuration
    filename to that parser. The parser will read the file, locate the sections, and
    locate the individual properties within each section.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个解析器的实例，并将目标配置文件名提供给该解析器。解析器将读取文件，定位各个部分，并定位每个部分内的各个属性。
- en: If we want to support multiple locations for files, we can use `config.read(config_names)`.
    When we provide the list of filenames to `ConfigParser.read()`, it will read the
    files in an order. We want to provide the files from the most generic first to
    the most specific last. The generic configuration files that are part of the software
    installation will be parsed first to provide defaults. The user-specific configuration
    will be parsed later to override these defaults.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要支持文件的多个位置，我们可以使用`config.read(config_names)`。当我们将文件名列表提供给`ConfigParser.read()`时，它将按顺序读取文件。我们希望从最通用的文件到最具体的文件提供文件。软件安装中的通用配置文件将首先被解析以提供默认值。用户特定的配置将稍后被解析以覆盖这些默认值。
- en: 'Once we''ve parsed the file, we need to make use of the various parameters
    and settings. Here''s a function that constructs our objects based on a given
    configuration object created by parsing the configuration files. We''ll break
    this into three parts. Here''s the part that builds the `Table` instance:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们解析了文件，我们需要利用各种参数和设置。这是一个根据解析配置文件创建的配置对象构建我们对象的函数。我们将其分为三部分。这是构建`Table`实例的部分：
- en: '[PRE197]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'We''ve used properties from the `[table]` section of the INI file to select
    class names and provide initialization values. There are three broad kinds of
    cases here:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了INI文件中`[table]`部分的属性来选择类名并提供初始化值。这里有三种广泛的情况：
- en: '**Mapping string to a class name**: We''ve used a mapping to look up an object
    based on a string class name. This was done to create `dealer_rule` and `split_rule`.
    If this was subject to considerable change, we might be able to extract this mapping
    into a separate factory function.'
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将字符串映射到类名**：我们使用映射来根据字符串类名查找对象。这是为了创建`dealer_rule`和`split_rule`。如果这是一个需要大量更改的地方，我们可能能够将这个映射提取到一个单独的工厂函数中。'
- en: '**Getting a value that ConfigParser can parse for us**: The class can directly
    handle `str`, `int`, `float`, and `bool`. The class has a sophisticated mapping
    from string to Boolean, using a wide variety of common code and synonyms for `True`
    and `False`.'
  id: totrans-1351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取ConfigParser可以为我们解析的值**：该类可以直接处理`str`、`int`、`float`和`bool`。该类具有从字符串到布尔值的复杂映射，使用各种常见代码和`True`和`False`的同义词。'
- en: '**Evaluating something that''s not built-in**: In the case of `payout`, we
    had a string value, `''(3,2)''`, that is not a directly supported data type for
    `ConfigParser`. We have two choices to handle this. We can try and parse it ourselves,
    or we can insist that the value be a valid Python expression and make Python do
    this. In this case, we''ve used `eval()`. Some programmers call this a *security
    problem*. The next section deals with this.'
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估非内置内容**：在`payout`的情况下，我们有一个字符串值，`''(3,2)''`，这不是`ConfigParser`的直接支持的数据类型。我们有两种选择来处理这个问题。我们可以尝试自己解析它，或者坚持该值是有效的Python表达式，并让Python来处理。在这种情况下，我们使用了`eval()`。一些程序员称这是一个*安全问题*。下一节将处理这个问题。'
- en: 'Here''s the second section of this example, which uses properties from the
    `[player]` section of the INI file to select classes and argument values:'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个示例的第二部分，它使用了INI文件中`[player]`部分的属性来选择类和参数值：
- en: '[PRE198]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: This uses string-to-class mapping as well as built-in data types. It initializes
    two strategy objects and then creates `Player` from those two strategies plus
    two integer configuration values.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了字符串到类的映射以及内置数据类型。它初始化了两个策略对象，然后从这两个策略加上两个整数配置值创建了`Player`。
- en: 'Here''s the final section; this creates the overall simulator:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一部分；这创建了整体模拟器：
- en: '[PRE199]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: We've used two parameters from the `[simulator]` section that are outside the
    narrow confines of object creation. The `outputfile` property is used to name
    a file; the `samples` property is provided as an argument to a method function.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`[simulator]`部分使用了两个参数，这些参数超出了对象创建的狭窄范围。`outputfile`属性用于命名文件；`samples`属性作为方法函数的参数提供。
- en: Handling more literals via the eval() variants
  id: totrans-1359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过eval()变体处理更多文字
- en: A configuration file may have values of types that don't have simple string
    representations. For example, a collection might be provided as a `tuple` or `list`
    literal; a mapping might be provided as a `dict` literal. We have several choices
    to handle these more complex values.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件可能具有没有简单字符串表示的类型的值。例如，一个集合可以作为`tuple`或`list`文字提供；一个映射可以作为`dict`文字提供。我们有几种选择来处理这些更复杂的值。
- en: The choices resolve around an issue of how much Python syntax the conversion
    is able to tolerate. For some types (`int`, `float`, `bool`, `complex`, `decimal.Decimal`,
    `fractions.Fraction`), we can safely convert the string to a literal value because
    the object `__init__()` for these types handle string values without tolerating
    any additional Python syntax.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 选择解决了一个问题，即转换能够容忍多少Python语法。对于一些类型（`int`、`float`、`bool`、`complex`、`decimal.Decimal`、`fractions.Fraction`），我们可以安全地将字符串转换为文字值，因为这些类型的对象`__init__()`处理字符串值而不容忍任何额外的Python语法。
- en: 'For other types, however, we can''t simply do the string conversion. We have
    several choices on how to proceed:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于其他类型，我们不能简单地进行字符串转换。我们有几种选择来继续进行：
- en: Forbid these data types and rely on the configuration file syntax plus processing
    rules to assemble complex Python values from very simple parts. This is tedious
    but can be made to work.
  id: totrans-1363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止这些数据类型，并依赖于配置文件语法加上处理规则，从非常简单的部分组装复杂的Python值。这很繁琐，但可以做到。
- en: Use `ast.literal_eval()` as it handles many cases of Python literal values.
    This is often the ideal solution.
  id: totrans-1364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ast.literal_eval()`，因为它处理许多Python文字值的情况。这通常是理想的解决方案。
- en: Use `eval()` to simply evaluate the string and create the expected Python object.
    This will parse more kinds of objects than `ast.literal_eval()`. Is this level
    of generality really needed?
  id: totrans-1365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`eval()`来简单评估字符串并创建预期的Python对象。这将解析比`ast.literal_eval()`更多种类的对象。这种广泛性真的有必要吗？
- en: Use the `ast` module to compile and vet the resulting code object. This vetting
    process can check for the `import` statements as well as use some small set of
    permitted modules. This is quite complex; if we're effectively allowing code,
    perhaps we should be designing a framework instead of an application with a configuration
    file.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ast`模块来编译和审查结果代码对象。这个审查过程可以检查`import`语句以及使用一些允许的模块。这非常复杂；如果我们有效地允许代码，也许我们应该设计一个框架，而不是一个带有配置文件的应用程序。
- en: In the case where we are performing RESTful transfers of Python objects through
    the network, `eval()` of the resulting text absolutely cannot be trusted. See
    [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML") - *Serializing and Saving - JSON, YAML, Pickle, CSV and XML*.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过网络执行RESTful传输Python对象的情况下，绝对不能信任对结果文本的`eval()`。参见[第9章](ch09.html "第9章。序列化和保存
    - JSON、YAML、Pickle、CSV和XML") - *序列化和保存 - JSON、YAML、Pickle、CSV和XML*。
- en: In the case of reading a local configuration file, however, `eval()` may be
    usable. In some cases, the Python code is as easily modified as the configuration
    file. Worrying about `eval()` may not be helpful when the base code can be tweaked.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在读取本地配置文件的情况下，`eval()`可能是可用的。在某些情况下，Python代码和配置文件一样容易修改。当基本代码可以被调整时，担心`eval()`可能并不有用。
- en: 'Here''s how we use `ast.literal_eval()` instead of `eval()`:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用`ast.literal_eval()`而不是`eval()`：
- en: '[PRE200]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: This broadens the domain of possible values in a configuration file. It doesn't
    allow arbitrary objects, but it allows a broad spectrum of literal values.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 这扩大了配置文件中可能值的领域。它不允许任意对象，但允许广泛的文字值。
- en: Storing the configuration in PY files
  id: totrans-1372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将配置存储在PY文件中
- en: The PY file format means using Python code as the configuration file as well
    as the language to implement the application. We will have a configuration file
    that's simply a module; the configuration is written in the Python syntax. This
    removes the need to parse the module.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: PY文件格式意味着使用Python代码作为配置文件以及实现应用程序的语言。我们将有一个配置文件，它只是一个模块；配置是用Python语法编写的。这消除了解析模块的需要。
- en: 'Using Python gives us a number of design considerations. We have two overall
    strategies to use Python as the configuration file:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python给我们带来了许多设计考虑。我们有两种策略来使用Python作为配置文件：
- en: '**A top-level script**: In this case, the configuration file is simply the
    top-most main program'
  id: totrans-1375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶层脚本**：在这种情况下，配置文件只是最顶层的主程序'
- en: '**An exec() import**: In this case, our configuration file provides parameter
    values that are collected into module global variables'
  id: totrans-1376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exec()导入**：在这种情况下，我们的配置文件提供参数值，这些值被收集到模块全局变量中'
- en: 'We can design a top-level script file that looks like the following code:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计一个顶层脚本文件，看起来像以下代码：
- en: '[PRE201]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: This shows us our various configuration parameters that are used to create and
    initialize objects. We've simply written the configuration parameters directly
    into the code. We've factored out the processing into a separate function, `simulate()`.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们用来创建和初始化对象的各种配置参数。我们只是直接将配置参数写入代码中。我们将处理过程分解到一个单独的函数`simulate()`中。
- en: One potential disadvantage of using Python as the configuration language is
    the potential complexity of the Python syntax. This is usually an irrelevant problem
    for two reasons. First, with some careful design, the syntax of the configuration
    should be simple assignment statements with a few `()` and `,`. Second, and more
    important, other configuration files have their own complex syntax, distinct from
    the Python syntax. Using a single language with a single syntax is a reduction
    in the complexity.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python作为配置语言的一个潜在缺点是Python语法的复杂性。出于两个原因，这通常是一个无关紧要的问题。首先，通过一些精心设计，配置的语法应该是简单的赋值语句，带有一些`()`和`,`。其次，更重要的是，其他配置文件有其自己的复杂语法，与Python语法不同。使用单一语言和单一语法是减少复杂性的一种方式。
- en: 'The `simulate()` function is imported from the overall `simulator` application.
    This `simulate()` function might look like the following code:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '`simulate()`函数是从整个`simulator`应用程序中导入的。这个`simulate()`函数可能看起来像以下代码：'
- en: '[PRE202]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: This function is generic with respect to the table, player, filename, and number
    of samples.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是关于表、玩家、文件名和样本数量的通用函数。
- en: 'The difficulty with this kind of configuration technique is the lack of handy
    default values. The top-level script must be complete: *all* of the configuration
    parameters must be present. It can be tiresome to provide all of the values; why
    provide default values that are rarely changed?'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置技术的困难在于缺乏方便的默认值。顶层脚本必须完整：*所有*配置参数必须存在。提供所有值可能会很烦人；为什么要提供很少更改的默认值呢？
- en: In some cases, this is not a limitation. In the cases where default values are
    important, we'll look at two ways around this limitation.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这并不是一个限制。在需要默认值的情况下，我们将看看如何解决这个限制。
- en: Configuration via class definitions
  id: totrans-1386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过类定义进行配置
- en: 'The difficulty that we sometimes have with top-level script configuration is
    the lack of handy default values. To provide defaults, we can use ordinary class
    inheritance. Here''s how we can use the class definition to build an object with
    the configuration values:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们在顶层脚本配置中遇到的困难是缺乏方便的默认值。为了提供默认值，我们可以使用普通的类继承。以下是我们如何使用类定义来构建一个具有配置值的对象：
- en: '[PRE203]'
  id: totrans-1388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: This allows us to define `Default_App` with a default configuration. The class
    that we've defined here can be reduced to providing only override values from
    the `Default_App` version.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用默认配置定义`Default_App`。我们在这里定义的类可以简化为仅提供来自`Default_App`版本的覆盖值。
- en: We can also use mixins to break the definition down into reusable pieces. We
    might break our classes down into the table, player, and simulation components
    and combine them via mixins. For more information on the mixin class design, see
    [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins – Cross-cutting Aspects"),
    *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用mixin来将定义分解为可重用的部分。我们可以将我们的类分解为表、玩家和模拟组件，并通过mixin组合它们。有关mixin类设计的更多信息，请参见[第8章](ch08.html
    "第8章。装饰器和Mixin-横切面")，*装饰器和Mixin-横切面*。
- en: In two small ways, this use of a class definition pushes the envelope. There
    are no method definitions; we're only going to use this class to define one instance.
    However, it is a very tidy way to pack up a small block of code so that the assignment
    statements fill in a small namespace.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个小方面，这种类定义的使用推动了边界。没有方法定义；我们只会使用这个类来定义一个实例。然而，这是一种非常整洁的方式，可以将一小块代码打包起来，以便赋值语句填充一个小的命名空间。
- en: 'We can modify our `simulate()` function to accept this class definition as
    an argument:'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改我们的`simulate()`函数来接受这个类定义作为参数：
- en: '[PRE204]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'This function has picked out the relevant values from the overall configuration
    object and used them to build a `Simulate` instance and execute that instance.
    The results are the same as the previous `simulate()` function, but the argument
    structure is different. Here''s how we provide the single instance of the class
    to this function:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从整体配置对象中挑选出相关的值，并用它们构建一个`Simulate`实例并执行该实例。结果与之前的`simulate()`函数相同，但参数结构不同。以下是我们如何将这个类的单个实例提供给这个函数：
- en: '[PRE205]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: One small disadvantage of this approach is that it is not compatible with `argparse`
    to gather command-line arguments. We can solve this by using a `types.SimpleNamespace`
    object.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个小缺点是它与`argparse`不兼容，无法收集命令行参数。我们可以通过使用`types.SimpleNamespace`对象来解决这个问题。
- en: Configuration via SimpleNamespace
  id: totrans-1397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过SimpleNamespace进行配置
- en: 'Using a `types.SimpleNamespace` object allows us to simply add attributes as
    needed. This will be similar to using a class definition. When defining a class,
    all of the assignment statements are localized to the class. When creating a `SimpleNamespace`
    object, we''ll need to explicitly qualify every name with the `NameSpace` object
    that we''re populating. Ideally, we can create `SimpleNamespace` like the following
    code:'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`types.SimpleNamespace`对象允许我们根据需要简单地添加属性。这类似于使用类定义。在定义类时，所有赋值语句都局限于类。在创建`SimpleNamespace`对象时，我们需要明确地使用`NameSpace`对象来限定每个名称，我们正在填充的`NameSpace`对象。理想情况下，我们可以创建类似以下代码的`SimpleNamespace`：
- en: '[PRE206]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'This works delightfully well if all of the configuration values are independent
    of each other. In our case, however, we have some complex dependencies among configuration
    values. We can handle this in one of the following two ways:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有配置值彼此独立，则这种方法非常有效。然而，在我们的情况下，配置值之间存在一些复杂的依赖关系。我们可以通过以下两种方式之一来处理这个问题：
- en: We can provide only the independent values and leave it to the application to
    build the dependent values
  id: totrans-1401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以只提供独立的值，让应用程序构建依赖的值
- en: We can build the values in the namespace incrementally
  id: totrans-1402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以逐步构建命名空间中的值
- en: 'To create only the independent values, we might do something like this:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 只创建独立值，我们可以做如下操作：
- en: '[PRE207]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Here, we created `SimpleNamespace` with the six independent values for the configuration.
    Then, we updated the configuration to add two more values that are dependent on
    four of the independent values.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用六个独立值创建了`SimpleNamespace`的配置。然后，我们更新配置以添加另外两个值，这些值依赖于四个独立值。
- en: 'The `config5a` object is nearly identical to the object that was created by
    evaluating `Example4()` in the preceding example . The base class is different,
    but the set of attributes and their values are identical. Here''s the alternative,
    where we build the configuration incrementally in a top-level script:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '`config5a`对象几乎与前面示例中通过评估`Example4()`创建的对象相同。基类不同，但属性及其值的集合是相同的。以下是另一种方法，在顶层脚本中逐步构建配置：'
- en: '[PRE208]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The same `simulate_c()` function shown previously can be used for this kind
    of configuration.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前显示的`simulate_c()`函数相同，可以用于这种类型的配置。
- en: 'Sadly, this suffers from the same problem as configuration via a top-level
    script. There''s no handy way to provide default values to a configuration object.
    We might want to have a factory function that we can import, which creates `SimpleNamespace`
    with the appropriate default values:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，这与通过顶层脚本进行配置的问题相同。没有方便的方法为配置对象提供默认值。我们可能希望有一个可以导入的工厂函数，它使用适当的默认值创建`SimpleNamespace`：
- en: '[PRE209]'
  id: totrans-1410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: If we used something like the preceding code, then we could have the default
    values assigned by the factory function, `make_config()`. Each user-supplied configuration
    could then provide only the necessary overrides to the default values.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用类似上面的代码，那么默认值可以由工厂函数`make_config()`分配。然后每个用户提供的配置只需提供对默认值的必要覆盖。
- en: 'Our default-supplying `make_config()` function would have the following kind
    of code:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的默认提供`make_config()`函数将具有以下类型的代码：
- en: '[PRE210]'
  id: totrans-1413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'The `make_config()` function would build a default configuration through a
    sequence of assignment statements. An application can then set only the interesting
    *override* values:'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_config()`函数将通过一系列赋值语句构建默认配置。然后应用程序只能设置有趣的*覆盖*值：'
- en: '[PRE211]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'This allows the application to build the configuration and then use it in a
    relatively simple way. The main script is quite short and to the point. If we
    use keyword arguments, we can easily make this more flexible:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 这使应用程序能够构建配置，然后以相对简单的方式使用它。主脚本非常简短且简洁。如果使用关键字参数，我们可以很容易地使其更加灵活：
- en: '[PRE212]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'This allows us to create a configuration including the overrides like this:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够创建包括覆盖的配置，如下所示：
- en: '[PRE213]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: This is slightly shorter and seems to retain the clarity of the previous example.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 这略短一些，似乎保留了前面示例的清晰度。
- en: All of the techniques from [Chapter 1](ch01.html "Chapter 1. The __init__()
    Method"), *The __init__() Method*, apply to the definition of this kind of configuration
    factory function. We can build in a great deal of flexibility if we need to. This
    has the advantage of fitting nicely with the way that the `argparse` module parses
    command-line arguments. We'll expand on this in [Chapter 16](ch16.html "Chapter 16. Coping
    With the Command Line"), *Coping with the Command Line*
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 所有来自[第1章](ch01.html "第1章。__init__()方法")的技术，*__init__()方法*，都适用于定义这种类型的配置工厂函数。如果需要，我们可以构建出很大的灵活性。这有一个优点，它很好地符合`argparse`模块解析命令行参数的方式。我们将在[第16章](ch16.html
    "第16章。处理命令行")中扩展这一点，*处理命令行*
- en: Using Python with exec() for the configuration
  id: totrans-1422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python和exec()进行配置
- en: 'When we decide to use Python as the notation for a configuration, we can use
    the `exec()` function to evaluate a block of code in a constrained namespace.
    We can imagine writing configuration files that look like the following code:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们决定使用Python作为配置的表示时，我们可以使用`exec()`函数在受限制的命名空间中评估一块代码。我们可以想象编写看起来像以下代码的配置文件：
- en: '[PRE214]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'This is a pleasant, easy-to-read set of configuration parameters. It''s similar
    to an INI file and a property file that we''ll look at in the following section.
    We can evaluate this file, creating a kind of namespace, with the `exec()` function:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一组愉快、易于阅读的配置参数。它类似于INI文件和属性文件，我们将在下一节中进行讨论。我们可以评估此文件，使用`exec()`函数创建一种命名空间：
- en: '[PRE215]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: In this example, we decided to explicitly build a code object with the `compile()`
    function. This isn't required; we can simply provide the text of the file to the
    `exec()` function and it will compile the code.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们决定使用`compile()`函数显式构建代码对象。这不是必需的；我们可以简单地将文件的文本提供给`exec()`函数，它将编译代码。
- en: 'The call to `exec()` provides three arguments: the code, a dictionary that
    should be used to resolve any global names, and a dictionary that will be used
    for any locals that get created. When the code block is finished, the assignment
    statements will have been used to build values in the local dictionary; in this
    case, the `config` variable. The keys will be the variable names.'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 对`exec()`的调用提供了三个参数：代码、应该用于解析任何全局名称的字典，以及将用于创建任何局部变量的字典。当代码块完成时，赋值语句将用于在局部字典中构建值；在这种情况下，是`config`变量。键将是变量名。
- en: 'We can then use this to build objects during the program''s initialization.
    We pass the necessary objects to the `simulate()` function to perform the simulation.
    The `config` variable will get all the local assignments and will have a value
    like the following code:'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用这个在程序初始化期间构建对象。我们将必要的对象传递给`simulate()`函数来执行模拟。`config`变量将获得所有局部赋值，并将具有类似以下代码的值：
- en: '[PRE216]'
  id: totrans-1430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'However, the initialization must be a written dictionary notation: `config[''table'']`,
    `config[''player'']`.'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，初始化必须是一个书面的字典表示法：`config['table']`，`config['player']`。
- en: 'As the dictionary notation is inconvenient, we''ll use a design pattern based
    on ideas from [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties,
    and Descriptors"), *Attribute Access, Properties, and Descriptors*. This is a
    class that provides named attributes based on the keys of a dictionary:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典表示法不方便，我们将使用基于[第3章](ch03.html "第3章 属性访问、属性和描述符")，“属性访问、属性和描述符”中的想法的设计模式。这是一个根据字典键提供命名属性的类：
- en: '[PRE217]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'This class can only work if the keys are proper Python variable names. Interestingly,
    this is all that can be created by the `exec()` function if we initialize the
    `config` variable this way:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有在键是合适的Python变量名时才能工作。有趣的是，这是`exec()`函数初始化`config`变量的方式：
- en: '[PRE218]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Then, we can use a simpler attribute notation, `config.table`, `config.player`,
    for doing the initial object construction and initialization. This little bit
    of syntactic sugar can be helpful in a complex application. An alternative is
    to define this class:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用更简单的属性表示法，`config.table`，`config.player`，来进行初始对象构建和初始化。在复杂的应用程序中，这种少量的语法糖可能会有所帮助。另一种方法是定义这个类：
- en: '[PRE219]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'We can then do this to convert a simple `dict` to an object with pleasant,
    named attributes:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将简单的`dict`转换为具有愉快的命名属性的对象：
- en: '[PRE220]'
  id: totrans-1439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: This will convert `dict` to an object with easy-to-use attribute names. This
    only works, of course, if the dictionary keys are already Python variable names.
    It's also limited to structures that are flat. This won't work for nested dictionary-of-dictionary
    structures that we see with other formats.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`dict`转换为一个具有易于使用的属性名称的对象。当然，这只适用于字典键已经是Python变量名的情况。它也仅限于结构是平面的情况。对于我们在其他格式中看到的嵌套字典结构，这种方法是行不通的。
- en: Why is exec() a nonproblem?
  id: totrans-1441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么`exec()`不是问题？
- en: The previous section has a discussion on `eval()`. The same considerations apply
    to `exec()`.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节讨论了`eval()`。相同的考虑也适用于`exec()`。
- en: Generally, the set of available `globals()` is tightly controlled. Access to
    the `os` module or the `__import__()` function can be eliminated by removing them
    from the globals provided to `exec()`.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可用的`globals()`集合是受严格控制的。通过从提供给`exec()`的全局变量中删除它们来消除对`os`模块或`__import__()`函数的访问。
- en: If you have an evil programmer who will cleverly corrupt the configuration files,
    recall that they have complete access to all Python source. Why would they waste
    time cleverly tweaking configuration files when they can just change the application
    code itself?
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个邪恶的程序员，他会巧妙地破坏配置文件，那么请记住，他们可以完全访问所有的Python源代码。当他们可以直接改变应用程序代码本身时，为什么要浪费时间巧妙地调整配置文件呢？
- en: 'One common question is this: "What if someone thinks they can monkey patch
    a broken application by forcing new code in via the configuration file?" This
    person is just as likely to break the application into a number of other equally
    clever/deranged ways. Avoiding Python configuration files won''t stop the unscrupulous
    programmer from breaking things by doing something that''s ill-advised. There
    are a myriad of potential weaknesses; needless worrying about `exec()` may not
    be beneficial.'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是：“如果有人认为他们可以通过强制新代码进入配置文件来猴子补丁一个损坏的应用程序怎么办？”这个人很可能以同样聪明/疯狂的方式破坏应用程序。避免Python配置文件不会阻止不道德的程序员通过做一些不明智的事情来破坏事物。有无数潜在的弱点；不必要地担心`exec()`可能不会有益。
- en: In some cases, it may be necessary to change the overall philosophy. An application
    that's highly customizable might actually be a general framework, not a tidy,
    finished application.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要改变整体理念。一个高度可定制的应用程序实际上可能是一个通用框架，而不是一个整洁的成品应用程序。
- en: Using ChainMap for defaults and overrides
  id: totrans-1447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ChainMap进行默认值和覆盖
- en: We'll often have a configuration file hierarchy. Previously, we listed several
    locations where configuration files can be installed. The `configparser` module,
    for example, is designed to read a number of files in an order and integrate the
    settings by having later files override values from earlier files.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常会有一个配置文件层次结构。之前，我们列出了可以安装配置文件的几个位置。例如，`configparser`模块旨在按顺序读取多个文件，并通过后续文件覆盖先前文件的值来集成设置。
- en: We can implement an elegant default-value processing using the `collections.ChainMap`
    class. See [Chapter 6](ch06.html "Chapter 6. Creating Containers and Collections"),
    *Creating Containers and Collections*, for some background on this class. We'll
    need to keep the configuration parameters as `dict` instances, which is something
    that works out well using `exec()` to evaluate Python-language initialization
    files.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`collections.ChainMap`类实现优雅的默认值处理。有关此类的一些背景，请参阅[第6章](ch06.html "第6章 创建容器和集合")，“创建容器和集合”。我们需要将配置参数保留为`dict`实例，这在使用`exec()`来评估Python语言初始化文件时非常有效。
- en: Using this will require us to design our configuration parameters as a flat
    dictionary of values. This may be a bit of a burden for applications with a large
    number of complex configuration values that are integrated from several sources.
    We'll show you a sensible way to flatten names.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法需要我们将配置参数设计为一组平面值的字典。对于从多个来源集成的大量复杂配置值的应用程序来说，这可能有点麻烦。我们将向您展示一种合理的方式来展平名称。
- en: 'First, we''ll build a list of files based on the standard locations:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将根据标准位置构建一个文件列表：
- en: '[PRE221]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'We started with a list of directories: the installation directory, a system
    global directory, a user''s home directory, and the current working directory.
    We put the configuration filename into each directory and then confirmed that
    the file actually exists.'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个目录列表开始：安装目录、系统全局目录、用户的主目录和当前工作目录。我们将配置文件名放入每个目录，然后确认文件实际存在。
- en: 'Once we have the names of the candidate files, we can build `ChainMap` by folding
    each file in:'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了候选文件的名称，我们就可以通过折叠每个文件来构建`ChainMap`：
- en: '[PRE222]'
  id: totrans-1455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Each file involves creating a new, empty map that can be updated with local
    variables. The `exec()` function will add the file's local variables to the empty
    map created by `new_child()`. Each new child is more localized, overriding previously
    loaded configurations.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都涉及创建一个新的空映射，可以使用本地变量进行更新。`exec()`函数将文件的本地变量添加到`new_child()`创建的空映射中。每个新子代都更加本地化，覆盖先前加载的配置。
- en: 'In `ChainMap`, every name is resolved by searching through the sequence of
    maps looking for a value. When we''ve loaded two configuration files into `ChainMap`,
    we have a structure like the following code:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ChainMap`中，通过搜索映射序列来解析每个名称以查找值。当我们将两个配置文件加载到`ChainMap`中时，我们将得到以下结构的代码：
- en: '[PRE223]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: We have a sequence of maps; the first map is the most local variables, defined
    last. These are overrides. The second map has application defaults. There's a
    third, empty map because `ChainMap` always has at least one map; when we build
    the initial value for `config`, an empty map has to be created.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一系列映射；第一个映射是最后定义的最本地变量。这些是覆盖。第二个映射具有应用程序默认值。还有第三个空映射，因为`ChainMap`始终至少有一个映射；当我们构建`config`的初始值时，必须创建一个空映射。
- en: The only downside of this is that the initialization will be using dictionary
    notation, `config['table']`, `config['player']`. We can extend `ChainMap()` to
    implement the attribute access in addition to the dictionary item access.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是初始化将使用字典表示法，`config['table']`，`config['player']`。我们可以扩展`ChainMap()`以实现属性访问以及字典项访问。
- en: 'Here''s a subclass of `ChainMap` that we can use if we find the `getitem()`dictionary
    notation too cumbersome:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ChainMap`的一个子类，如果我们发现`getitem()`字典表示法太麻烦，我们可以使用它：
- en: '[PRE224]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'We can now say `config.table` instead of `config[''table'']`. This reveals
    an important restriction on our extension to `ChainMap`: we can''t use `maps`
    as an attribute. The `maps` key is a first-class attribute of the parent `ChainMap`
    class.'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`config.table`而不是`config['table']`。这揭示了我们对`ChainMap`的扩展的一个重要限制：我们不能将`maps`用作属性。`maps`键是父`ChainMap`类的一级属性。
- en: Storing the configuration in JSON or YAML files
  id: totrans-1464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将配置存储在JSON或YAML文件中
- en: 'We can store configuration values in JSON or YAML files with relative ease.
    The syntax is designed to be user friendly. We can represent a wide variety of
    things in YAML. We''re somewhat restricted to a narrower variety of object classes
    in JSON. We can use a JSON configuration file that looks like the following code:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以相对轻松地将配置值存储在JSON或YAML文件中。语法设计得用户友好。我们可以在YAML中表示各种各样的事物。在JSON中，我们受到更窄的对象类别的限制。我们可以使用类似以下代码的JSON配置文件：
- en: '[PRE225]'
  id: totrans-1466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'The JSON document looks like a dictionary of dictionaries. This is precisely
    the object that will be built when we load this file. We can load a single configuration
    file with the following code:'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: JSON文档看起来像字典的字典。这正是在加载此文件时将构建的对象。我们可以使用以下代码加载单个配置文件：
- en: '[PRE226]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: This allows us to use `config['table']['dealer']` to look up the specific class
    to be used for the dealer's rules. We can use `config['player']['betting']` to
    locate the player's particular betting strategy class name.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以使用`config['table']['dealer']`来查找用于荷官规则的特定类。我们可以使用`config['player']['betting']`来定位玩家特定的投注策略类名。
- en: Unlike INI files, we can easily encode `tuple` like a sequence of values. So,
    the `config['table']['payout']` value will be a proper two-element sequence. It
    won't—strictly speaking—be `tuple`, but it will be close enough for us to use
    it without having to use `ast.literal_eval()`.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 与INI文件不同，我们可以轻松地将`tuple`编码为值序列。因此，`config['table']['payout']`值将是一个正确的两元素序列。严格来说，它不会是`tuple`，但它足够接近，我们可以在不必使用`ast.literal_eval()`的情况下使用它。
- en: 'Here''s how we''d use this nested structure. We''ll only show you the first
    part of the `main_nested_dict()` function:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将如何使用此嵌套结构。我们只会向您展示`main_nested_dict()`函数的第一部分：
- en: '[PRE227]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: This is very similar to the `main_ini()` function shown previously. When we
    compare this with the preceding version, using `configparser`, it's clear that
    the complexity is almost the same. The naming is slightly simpler. We use `config.get('table',{}).get('decks')`
    instead of `config.getint('table','decks')`.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前显示的`main_ini()`函数非常相似。当我们将其与之前的使用`configparser`的版本进行比较时，很明显复杂性几乎相同。命名略微简单。我们使用`config.get('table',{}).get('decks')`代替`config.getint('table','decks')`。
- en: The largest difference is shown in the highlighted line. The JSON format provides
    us properly decoded integer values and proper sequences of values. We don't need
    to use `eval()` or `ast.literal_eval()` to decode the tuple. The other parts,
    to build `Player` and configure the `Simulate` object, are similar to the `main_ini()`
    version.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别显示在突出显示的行中。JSON格式为我们提供了正确解码的整数值和正确的值序列。我们不需要使用`eval()`或`ast.literal_eval()`来解码元组。其他部分，构建`Player`和配置`Simulate`对象，与`main_ini()`版本类似。
- en: Using flattened JSON configurations
  id: totrans-1475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用展平的JSON配置
- en: If we want to provide for default values by integrating multiple configuration
    files, we can't use both `ChainMap` and a nested dictionary-of-dictionaries like
    this. We have to either flatten out our program's parameters or look at an alternative
    to merging the parameters from different sources.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过集成多个配置文件来提供默认值，我们不能同时使用`ChainMap`和类似这样的嵌套字典。我们必须要么展平程序的参数，要么寻找合并来自不同来源的参数的替代方法。
- en: 'We can easily flatten the names by using simple `.` separators between names.
    Our JSON file might then look like the following code:'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在名称之间使用简单的“.”分隔符来轻松地展平名称。我们的JSON文件可能看起来像以下代码：
- en: '[PRE228]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'This has the advantage of allowing us to use `ChainMap` to accumulate the configuration
    values from various sources. It also slightly simplifies the syntax to locate
    a particular parameter value. Given a list of configuration filenames, `config_names`,
    we might do something like this:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 这有利于我们使用`ChainMap`从各种来源累积配置值。它还略微简化了定位特定参数值的语法。给定配置文件名列表`config_names`，我们可能会这样做：
- en: '[PRE229]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: This builds a proper `ChainMap` from a *reversed* list of configuration file
    names. Why reversed? We must reverse the list because we want the list to be ordered
    from the most specific first to the most general last. This is the reverse of
    how the list is used by `configparser` and the reverse of how we incrementally
    built `ChainMap` by adding children to the front of the list of mappings. Here,
    we're simply loading a list of `dict` into `ChainMap`, and the first `dict` will
    be the first one searched for by the key.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 从*反向*配置文件名列表构建一个适当的`ChainMap`。为什么是反向的？我们必须反转列表，因为我们希望列表从最具体的开始到最一般的结束。这与`configparser`使用列表的方式相反，也与我们通过将子项添加到映射列表的前面来逐步构建`ChainMap`的方式相反。在这里，我们只是将一系列`dict`加载到`ChainMap`中，第一个`dict`将是被键首先搜索的。
- en: 'We can use a method like this to exploit `ChainMap`. We''ll only show you the
    first part, which builds the `Table` instance:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似这样的方法来利用`ChainMap`。我们只会展示第一部分，构建`Table`实例：
- en: '[PRE230]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: The other parts, to build `Player` and configure the `Simulate` object, are
    similar to the `main_ini()` version.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 其他部分，构建`Player`和配置`Simulate`对象，与`main_ini()`版本类似。
- en: When we compare this to the previous version, using `configparser`, it's clear
    that the complexity is almost the same. The naming is slightly simpler. Here,
    we use `int(config.get('table.decks'))` instead of `config.getint('table','decks')`.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将其与使用`configparser`的先前版本进行比较时，很明显复杂性几乎相同。命名稍微简单。在这里，我们使用`int(config.get('table.decks'))`而不是`config.getint('table','decks')`。
- en: Loading a YAML configuration
  id: totrans-1486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载YAML配置
- en: 'As YAML syntax contains JSON syntax, the previous examples can be loaded with
    YAML as well as JSON. Here''s a version of the nested dictionary-of-dictionaries
    technique from the JSON file:'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 由于YAML语法包含JSON语法，前面的例子也可以用YAML和JSON加载。这是从JSON文件中的嵌套字典技术的版本：
- en: '[PRE231]'
  id: totrans-1488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'This is a better file syntax than pure JSON; it''s easier to edit. For applications
    where the configuration is dominated by strings and integers, this has a number
    of advantages. The process to load this file is the same as the process to load
    the JSON file:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比纯JSON更好的文件语法；更容易编辑。对于配置主要由字符串和整数控制的应用程序，这有很多优势。加载此文件的过程与加载JSON文件的过程相同：
- en: '[PRE232]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: This has the same limitations as the nested dictionaries. We don't have an easy
    way to handle default values unless we flatten the names.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 这与嵌套字典具有相同的限制。除非我们展平名称，否则我们没有处理默认值的简单方法。
- en: 'When we move beyond simple strings and integers, however, we can try to leverage
    YAML''s ability to encode class names and create instances of our customized classes.
    Here''s a YAML file that will directly build the configuration objects that we
    need for our simulation:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们超越简单的字符串和整数时，我们可以尝试利用YAML编码类名和创建我们定制类的实例的能力。这是一个YAML文件，将直接构建我们模拟所需的配置对象：
- en: '[PRE233]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'We have encoded class names and instance construction in YAML, allowing us
    to define the complete initialization for `Table` and `Player`. We can use this
    initialization file as follows:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在YAML中编码了类名和实例构造，允许我们定义`Table`和`Player`的完整初始化。我们可以像这样使用这个初始化文件：
- en: '[PRE234]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: This shows us that a YAML configuration file can be used for human editing.
    YAML provides us with the same capabilities as Python, but with a different syntax.
    For this type of example, a Python configuration script might be better than YAML.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了YAML配置文件可以用于人工编辑。YAML为我们提供了与Python相同的功能，但具有不同的语法。对于这种类型的示例，Python配置脚本可能比YAML更好。
- en: Storing the configuration in property files
  id: totrans-1497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将配置存储在属性文件中
- en: 'The property files are often used with Java programs. There''s no reason we
    can''t use them with Python. They''re relatively easy to parse and allow us to
    encode the configuration parameters in a handy, easy-to-use format. For more information
    on the format, see this: [http://en.wikipedia.org/wiki/.properties](http://en.wikipedia.org/wiki/.properties).
    Here''s what a properties file might look like:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件通常与Java程序一起使用。我们没有理由不使用它们与Python一起使用。它们相对容易解析，并允许我们以方便、易于使用的格式编码配置参数。有关格式的更多信息，请参阅：[http://en.wikipedia.org/wiki/.properties](http://en.wikipedia.org/wiki/.properties)。属性文件可能如下所示：
- en: '[PRE235]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: This has some advantages in terms of simplicity. The `section.property` qualified
    names are commonly used. These can become long in a very complex configuration
    file.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 这在简单性方面有一些优势。`section.property`限定名称通常被使用。这些在非常复杂的配置文件中可能会变得很长。
- en: Parsing a properties file
  id: totrans-1501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析属性文件
- en: There's no built-in properties parser in the Python Standard Library. We can
    download a property file parser from the Python Package Index ([https://pypi.python.org/pypi](https://pypi.python.org/pypi)).
    However, it's not a complex class, and it's a good exercise in advanced object-oriented
    programming.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中没有内置的属性解析器。我们可以从Python包索引（[https://pypi.python.org/pypi](https://pypi.python.org/pypi)）下载属性文件解析器。然而，这不是一个复杂的类，这是一个很好的高级面向对象编程练习。
- en: 'We''ll break the class down into the top-level API functions and the lower-level
    parsing functions. Here are some of the overall API methods:'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类分解为顶层API函数和较低级别的解析函数。以下是一些整体API方法：
- en: '[PRE236]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: The essential feature here is that it will parse a filename, a file, or a block
    of text. This follows the design pattern from `configparser`. A common alternative
    is to have fewer methods and use `isinstance()` to determine the type of the argument,
    and also determine what processing to perform on it.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本特性是它将解析文件名、文件或一块文本。这遵循了`configparser`的设计模式。一个常见的替代方法是减少方法的数量，并使用`isinstance()`来确定参数的类型，还确定要对其执行什么处理。
- en: 'File names are strings. Files themselves are generally instances of `io.TextIOBase`.
    A block of text is also a string. For this reason, many libraries use `load()`
    to work with files or filenames and `loads()` to work with a simple string. Something
    like this would echo the design pattern of `json`:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名是字符串。文件本身通常是`io.TextIOBase`的实例。一块文本也是一个字符串。因此，许多库使用`load()`来处理文件或文件名，使用`loads()`来处理简单的字符串。类似这样的东西会回显`json`的设计模式：
- en: '[PRE237]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'These methods will also handle a file, filename, or block of text. These extra
    method names give us an alternative API that might be easier to work. The deciding
    factor is achieving a coherent design among the various libraries, packages, and
    modules. Here''s the `_parse()` method:'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法也可以处理文件、文件名或文本块。这些额外的方法名称为我们提供了一个可能更容易使用的替代API。决定因素是在各种库、包和模块之间实现一致的设计。这是`_parse()`方法：
- en: '[PRE238]'
  id: totrans-1509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: This method starts with three generator expressions to handle some overall features
    of the physical lines and logical lines within a properties file. The generator
    expressions separate three syntax rules. Generator expressions have the advantage
    of being executed lazily; no intermediate results are created from these expressions
    until they're evaluated by the `for line in non_comment` statement.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法从三个生成器表达式开始，处理属性文件中物理行和逻辑行的一些整体特性。生成器表达式的优势在于它们被惰性执行；直到它们被`for line in non_comment`语句评估时，这些表达式才会创建中间结果。
- en: The first expression, assigned to `logical_lines`, merges physical lines that
    end with `\` to create longer logical lines. The leading (and trailing) spaces
    are stripped away, leaving just the line content. **Regular Expression** (**RE**)
    `r"\\\n\s*"` is intended to match `\` at the end of a line and all of the leading
    spaces from the next line.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式赋给`logical_lines`，合并以`\`结尾的物理行，以创建更长的逻辑行。前导（和尾随）空格被去除，只留下行内容。**正则表达式**（**RE**）`r"\\\n\s*"`旨在匹配行尾的`\`和下一行的所有前导空格。
- en: The second expression, assigned to `non_empty`, will only iterate over lines
    with a nonzero length. Blank lines will be rejected by this filter.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个表达式赋给`non_empty`，只会迭代长度非零的行。空行将被这个过滤器拒绝。
- en: Third, the `non_comment` expression will only iterate over lines that do not
    start with `#` or `!`. Lines that start with `#` or `!` will be rejected by this
    filter.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`non_comment`表达式只会迭代不以`#`或`!`开头的行。以`#`或`!`开头的行将被这个过滤器拒绝。
- en: Because of these three generator expressions, the `for line in non_comment`
    loop only iterates through noncomment, nonblank, logical lines that are properly
    merged with spaces stripped. The body of the loop picks apart each remaining line
    to separate the key and element and then apply the `self._escape()` function to
    expand any escape sequences.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三个生成器表达式，`for line in non_comment`循环只会迭代非注释、非空白、逻辑行，这些行已经合并并去除了空格。循环的主体将剩下的每一行分开，以分隔键和元素，然后应用`self._escape()`函数来扩展任何转义序列。
- en: The key-element pattern, `key_element_pat`, looks for explicit separators of
    non-escaped`:`, `=` or a space surrounded by whitespace. This pattern uses the
    negative look behind an assertion, an RE of `(?<!\\)`, to indicate that the following
    RE must be non-escaped; the following pattern must not be preceded by `\`. This
    means that `(?<!\\)[:=\s]` is non-escaped `:`, or `=`, or space.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 键-元素模式`key_element_pat`寻找非转义的显式分隔符`:`, `=`或由空白包围的空格。这个模式使用否定的后行断言，一个`(?<!\\)`的RE，表示接下来的RE必须是非转义的；接下来的模式前面不能有`\`。这意味着`(?<!\\)[:=\s]`是非转义的`:`，或`=`,
    或空格。
- en: If the key-element pattern can't be found, there's no separator. We interpret
    this lack of a matching pattern to indicate that the line is a degenerate case
    of only a key; no value was provided.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到键-元素模式，就没有分隔符。我们解释这种缺乏匹配模式表示该行是一个只有键的退化情况；没有提供值。
- en: 'As the keys and elements form a sequence of 2-tuples, the sequence can be easily
    turned into a dictionary, providing a configuration map much like other configuration
    representation schemes that we''ve seen. They can also be left as a sequence to
    show the original content of the file in an order. The final part is a small method
    function to transform the escapes to their final character:'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 由于键和元素形成了一个2元组的序列，这个序列可以很容易地转换成一个字典，提供一个配置映射，就像我们看到的其他配置表示方案一样。它们也可以保留为一个序列，以显示文件的原始内容。最后一部分是一个小的方法函数，将转义转换为它们的最终字符：
- en: '[PRE239]'
  id: totrans-1518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'This `_escape()` method function performs two substitution passes. The first
    pass replaces the escaped punctuation marks with their plain-text versions: `\:`,
    `\#`, `\!`, `\=`, and `\` all have `\` removed. For the Unicode escapes, the string
    of digits is used to create a proper Unicode character that replaces the `\uxxxx`
    sequence. The hex digits are turned into an integer, which is turned into a character
    for the replacement.'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`_escape()`方法函数执行两次替换。第一次替换将转义的标点符号替换为它们的纯文本版本：`\:`, `\#`, `\!`, `\=`, 和 `\`都去掉了`\`。对于Unicode转义，使用数字字符串创建一个适当的Unicode字符，替换`\uxxxx`序列。十六进制数字被转换为整数，然后转换为替换的字符。
- en: 'The two substitutions can be combined into a single operation to save creating
    an intermediate string that will only get discarded. This will improve the performance.
    It might look like the following code:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个替换可以合并成一个单独的操作，以节省创建一个只会被丢弃的中间字符串。这将提高性能。可能看起来像以下代码：
- en: '[PRE240]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: The benefit of better performance might be outweighed by the complexity of the
    RE and the replacement function.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 更好性能的好处可能会被正则表达式和替换函数的复杂性所抵消。
- en: Using a properties file
  id: totrans-1523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用属性文件
- en: We have two choices for how we use a properties file. We could follow the design
    pattern of `configparser` and parse multiple files to create a single mapping
    from the union of the various values. Or, we could follow the `ChainMap` pattern
    and create a sequence of properties mappings for each configuration file.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在如何使用属性文件上有两种选择。我们可以遵循`configparser`的设计模式，解析多个文件以创建一个从各种值的并集中得到的单一映射。或者，我们可以遵循`ChainMap`模式，为每个配置文件创建一个属性映射序列。
- en: 'The `ChainMap` processing is reasonably simple and provides us with all the
    required features:'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap`处理相当简单，并为我们提供了所有必需的功能：'
- en: '[PRE241]'
  id: totrans-1526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'We''ve taken the list in a reverse order: the most specific settings will be
    first in the internal list; the most general settings will be the last. Once `ChainMap`
    has been loaded, we can use the properties to initialize and build our `Player`,
    `Table`, and `Simulate` instances.'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照相反的顺序列出了列表：最具体的设置将首先出现在内部列表中；最一般的设置将是最后一个。一旦`ChainMap`被加载，我们就可以使用这些属性来初始化和构建我们的`Player`、`Table`和`Simulate`实例。
- en: This seems simpler than updating a single mapping from several sources. Also,
    this follows the pattern used to process JSON or YAML configuration files.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎比从几个来源更新单个映射更简单。此外，这遵循了处理JSON或YAML配置文件的模式。
- en: 'We can use a method like this to exploit `ChainMap`. This is very similar to
    the `main_cm()` function shown previously. We''ll only show you the first part,
    which builds the `Table` instance:'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似这样的方法来利用`ChainMap`。这与之前显示的`main_cm()`函数非常相似。我们只会向您展示构建`Table`实例的第一部分：
- en: '[PRE242]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: The difference between this version and the `main_cm()` function is the handling
    of the payout tuple. In the previous version, JSON (and YAML) could parse the
    tuple. When using the properties files, all values are simple strings. We must
    use `eval()` or `ast.literal_eval()` to evaluate the given value. The other portions
    of this `main_cm_str()` function are identical to `main_cm()`.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本与`main_cm()`函数的区别在于处理支付元组的方式。在以前的版本中，JSON（和YAML）可以解析元组。当使用属性文件时，所有值都是简单的字符串。我们必须使用`eval()`或`ast.literal_eval()`来评估给定的值。这个`main_cm_str()`函数的其他部分与`main_cm()`是相同的。
- en: Storing the configuration in XML files – PLIST and others
  id: totrans-1532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将配置存储在XML文件中 - PLIST和其他文件
- en: As we noted in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV,
    and XML*, Python's `xml` package includes numerous modules that parse the XML
    files. Because of the wide adoption of the XML files, it often becomes necessary
    to convert between XML documents and Python objects. Unlike JSON or YAML, the
    mapping from XML is not simple.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第9章](ch09.html "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")中所指出的，*序列化和保存 -
    JSON、YAML、Pickle、CSV和XML*，Python的`xml`包包括许多解析XML文件的模块。由于XML文件的广泛采用，通常需要在XML文档和Python对象之间进行转换。与JSON或YAML不同，从XML的映射并不简单。
- en: 'One common way to represent the configuration data in XML is the `.plist` file.
    For more information on the `.plist` format, see this: [http://developer.apple.com/documentation/Darwin/Reference/ManPages/man5/plist.5.html](http://developer.apple.com/documentation/Darwin/Reference/ManPages/man5/plist.5.html)'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML中表示配置数据的一种常见方式是`.plist`文件。有关`.plist`格式的更多信息，请参阅：[http://developer.apple.com/documentation/Darwin/Reference/ManPages/man5/plist.5.html](http://developer.apple.com/documentation/Darwin/Reference/ManPages/man5/plist.5.html)
- en: Macintosh users can perform `man plist` to see this man page. The advantages
    of the `.plist` format are that it uses a few, very general tags. This makes it
    easy to create `.plist` files and parse them. Here's the sample `.plist` file
    from with our configuration parameters.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: Macintosh用户可以执行`man plist`来查看这个man页面。`.plist`格式的优点是它使用了少量非常通用的标签。这使得创建和解析`.plist`文件变得容易。这是我们配置参数的示例`.plist`文件。
- en: '[PRE243]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: We're showing you the nested dictionary-of-dictionary structure in this example.
    There are a number of Python-compatible types encoded with XML tags.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们展示了嵌套的字典结构。有许多与XML标签编码兼容的Python类型。
- en: '| Python type | Plist tag |'
  id: totrans-1538
  prefs: []
  type: TYPE_TB
  zh: '| Python类型 | Plist标签 |'
- en: '| --- | --- |'
  id: totrans-1539
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `str` | `<string>` |'
  id: totrans-1540
  prefs: []
  type: TYPE_TB
  zh: '| `str` | `<string>` |'
- en: '| `float` | `<real>` |'
  id: totrans-1541
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `<real>` |'
- en: '| `int` | `<integer>` |'
  id: totrans-1542
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `<integer>` |'
- en: '| `datetime` | `<date>` |'
  id: totrans-1543
  prefs: []
  type: TYPE_TB
  zh: '| `datetime` | `<date>` |'
- en: '| `boolean` | `<true/> or <false/>` |'
  id: totrans-1544
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `<true/> 或 <false/>` |'
- en: '| `bytes` | `<data>` |'
  id: totrans-1545
  prefs: []
  type: TYPE_TB
  zh: '| `bytes` | `<data>` |'
- en: '| `list` | `<array>` |'
  id: totrans-1546
  prefs: []
  type: TYPE_TB
  zh: '| `list` | `<array>` |'
- en: '| `dict` | `<dict>` |'
  id: totrans-1547
  prefs: []
  type: TYPE_TB
  zh: '| `dict` | `<dict>` |'
- en: 'As shown in the preceding example, the dict `<key>` values are strings. This
    makes the plist a very pleasant encoding of our parameters for our simulation
    application. We can load a `.plist` with relative ease:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子所示，字典`<key>`的值是字符串。这使得plist成为我们模拟应用程序参数的非常愉快的编码方式。我们可以相对容易地加载`.plist`：
- en: '[PRE244]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: This will reconstruct our configuration parameters. We can then use this nested
    dictionary-of-dictionaries structure with the `main_nested_dict()` function shown
    in the preceding section on JSON configuration files.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重建我们的配置参数。然后，我们可以在JSON配置文件的前一节中使用`main_nested_dict()`函数显示的嵌套字典结构。
- en: Using a single module function to parse the file makes the `.plist` format very
    appealing. The lack of support for any customized Python class definitions makes
    this equivalent to JSON or a properties file.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个模块函数来解析文件使`.plist`格式非常吸引人。对于任何自定义的Python类定义的支持不足，这使得它等同于JSON或属性文件。
- en: Customized XML configuration files
  id: totrans-1552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义XML配置文件
- en: 'For a more complex XML configuration file, see [http://wiki.metawerx.net/wiki/Web.xml](http://wiki.metawerx.net/wiki/Web.xml).
    These files contain a mixture of special-purpose tags and general-purpose tags.
    These documents can be challenging to parse. There are two general approaches:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的XML配置文件，请参阅[http://wiki.metawerx.net/wiki/Web.xml](http://wiki.metawerx.net/wiki/Web.xml)。这些文件包含特定用途的标签和通用标签的混合。这些文档可能很难解析。有两种一般的方法：
- en: Write a document processing class that uses XPath queries to locate the tags
    in a document that contain interesting data. In this case, we'll write properties
    (or methods) that will locate the requested information in the XML document structure.
  id: totrans-1554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个文档处理类，使用XPath查询来定位文档中包含有趣数据的标签。在这种情况下，我们将编写能够在XML文档结构中定位请求信息的属性（或方法）。
- en: Unwind the XML document into a Python data structure. This is the approach followed
    by the `plist` module, shown previously.
  id: totrans-1555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将XML文档解开成Python数据结构。这是之前展示的`plist`模块所采用的方法。
- en: 'Based on examples of the `web.xml` files, we''ll design our own customized
    XML document to configure our simulation application:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`web.xml`文件的示例，我们将设计我们自己的定制XML文档来配置我们的模拟应用程序：
- en: '[PRE245]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'This is a specialized XML file. We didn''t provide a DTD or an XSD, so there''s
    no formal way to validate the XML against a schema. However, this file is small,
    easily debugged, and parallels other example initialization files. Here''s a `Configuration`
    class that can use XPath queries to retrieve information from this file:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个专门的XML文件。我们没有提供DTD或XSD，因此没有正式的方法来根据模式验证XML。但是，这个文件很小，易于调试，并且与其他示例初始化文件相似。这里有一个`Configuration`类，可以使用XPath查询从这个文件中检索信息：
- en: '[PRE246]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'We''ve implemented three methods to load the XML document: `read()`, `read_file()`,
    and `read_string()`. Each of these simply delegates itself to an existing method
    function of the `xml.etree.ElementTree` class. This parallels the `configparser`
    API. We could use `load()` and `loads()` too, as they would delegate themselves
    to `parse()` and `fromstring()`, respectively.'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了三种方法来加载XML文档：`read()`，`read_file()`和`read_string()`。这些方法只是将自己委托给`xml.etree.ElementTree`类的现有方法函数。这与`configparser`API相似。我们也可以使用`load()`和`loads()`，因为它们会将自己委托给`parse()`和`fromstring()`。
- en: 'For access to the configuration data, we implemented two methods: `get()` and
    `__getitem__()`. The `get()` method allows us to use code like this: `stake= int(config.get(''player.stake'',
    50))`. The `__getitem__()` method allows us to use code like this: `stake= config[''player''][''stake'']`.'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问配置数据，我们实现了两种方法：`get()`和`__getitem__()`。`get()`方法允许我们使用这样的代码：`stake= int(config.get('player.stake',
    50))`。`__getitem__()`方法允许我们使用这样的代码：`stake= config['player']['stake']`。
- en: The parsing is a trifle more complex than a `.plist` file. However, the XML
    document is much simpler than an equivalent `.plist` document.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 解析比`.plist`文件稍微复杂一些。但是，XML文档比等效的`.plist`文档简单得多。
- en: We can use the `main_cm_str()` function shown in the previous section on the
    property files to process this configuration.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前一节中显示的`main_cm_str()`函数来处理属性文件上的配置。
- en: Summary
  id: totrans-1564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at a number of ways to represent the configuration parameters. Most
    of these are based on more general serialization techniques that we saw in [Chapter
    9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and
    XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*. The `configparser`
    module provides an additional format that's comfortable for some users.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了许多表示配置参数的方法。其中大多数是基于我们在[第9章](ch09.html "第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML")中看到的更一般的序列化技术，*序列化和保存-JSON、YAML、Pickle、CSV和XML*。`configparser`模块提供了一个额外的格式，对一些用户来说更舒适。
- en: The key feature of a configuration file is that the content can be easily edited
    by a human. For this reason, pickle files aren't suggested as a good representation.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件的关键特征是内容可以轻松地由人类编辑。因此，pickle文件不建议作为良好的表示。
- en: Design considerations and trade-offs
  id: totrans-1567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: Configuration files can simplify running application programs or starting servers.
    This can put all the relevant parameters in one easy-to-read and easy-to-modify
    file. We can put these files under the configuration control, track change history,
    and generally use them to improve the software's quality.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件可以简化运行应用程序或启动服务器。这可以将所有相关参数放在一个易于阅读和易于修改的文件中。我们可以将这些文件放在配置控制下，跟踪更改历史，并通常使用它们来提高软件的质量。
- en: 'We have several alternative formats for these files, all of which are reasonably
    human friendly to edit. They vary in how easy they are to parse and any limitations
    on the Python data that can be encoded:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些文件，我们有几种替代格式，所有这些格式都相对友好，易于编辑。它们在解析的难易程度以及可以编码的Python数据的任何限制方面有所不同：
- en: '**INI files**: These files are easy to parse and are limited to strings and
    numbers.'
  id: totrans-1570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INI文件**：这些文件易于解析，仅限于字符串和数字。'
- en: '**Python code (PY files)**: These files use the main script for the configuration.
    No parsing, no limitations. They use an `exec()` file. It is easy to parse and
    has no limitations.'
  id: totrans-1571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python代码（PY文件）**：这些文件使用主脚本进行配置。没有解析，没有限制。它们使用`exec()`文件。易于解析，没有限制。'
- en: '**JSON or YAML files**: These files are easy to parse. They support strings,
    numbers, dicts, and lists. YAML can encode Python, but why not just use Python?'
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON或YAML文件**：这些文件易于解析。它们支持字符串，数字，字典和列表。YAML可以编码Python，但为什么不直接使用Python呢？'
- en: '**Property Files**: These files require a special parser. They are limited
    to strings.'
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性文件**：这些文件需要一个特殊的解析器。它们仅限于字符串。'
- en: '**XML files**:'
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML文件**：'
- en: '`.plist` **files**: These files are easy to parse. They supports strings, numbers,
    dicts, and lists.'
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.plist` **文件**：这些文件易于解析。它们支持字符串，数字，字典和列表。'
- en: '**Customized XML**: These files require a special parser. They are limited
    to strings.'
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定制XML**：这些文件需要一个特殊的解析器。它们仅限于字符串。'
- en: Coexistence with other applications or servers will often determine a preferred
    format for the configuration files. If we have other applications that use the
    `.plist` or INI files, then our Python applications should make choices that are
    more comfortable for users to use.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他应用程序或服务器的共存通常会确定配置文件的首选格式。如果我们有其他应用程序使用`.plist`或INI文件，那么我们的Python应用程序应该做出更符合用户使用习惯的选择。
- en: 'Viewed from the breadth of objects that can be represented, we have four broad
    categories of configuration files:'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 从可以表示的对象的广度来看，我们有四个广泛的配置文件类别：
- en: '**Simple files with only strings**: Custom XML, properties files.'
  id: totrans-1579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只包含字符串的简单文件**：定制XML，属性文件。'
- en: '**Simple files with simple Python literals**: INI files.'
  id: totrans-1580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单文件，只包含简单的Python文字**：INI文件。'
- en: '**More complex files with Python literals, lists, and dict**s: JSON, YAML,
    `.plist`, and XML.'
  id: totrans-1581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更复杂的文件，包含Python文字，列表和字典**：JSON，YAML，`.plist`和XML。'
- en: '**Anything. Python**: We can use YAML for this, but it seems silly when Python
    has a clearer syntax.'
  id: totrans-1582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任何东西。Python**：我们可以使用YAML，但当Python有更清晰的语法时，这似乎有些愚蠢。'
- en: Creating a shared configuration
  id: totrans-1583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建共享配置
- en: When we look at module design considerations in [Chapter 17](ch17.html "Chapter 17. The
    Module and Package Design"), The *Module and Package Design*, we'll see how a
    module conforms to the **Singleton** design pattern. This means that we can import
    a module only once, and the single instance is shared.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第17章](ch17.html "第17章。模块和包设计")中查看模块设计考虑时，*模块和包设计*，我们将看到模块如何符合**单例**设计模式。这意味着我们只能导入一个模块，并且单个实例是共享的。
- en: Because of this, it's often necessary to define a configuration in a distinct
    module and import it. This allows separate modules to share a common configuration.
    Each module will import the shared configuration module; the configuration module
    will locate the configuration file(s) and create the actual configuration objects.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常需要在一个独立的模块中定义配置并导入它。这允许单独的模块共享一个公共配置。每个模块都将导入共享配置模块；配置模块将定位配置文件并创建实际的配置对象。
- en: Schema evolution
  id: totrans-1586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式演变
- en: The configuration file is part of the public-facing API. As application designers,
    we have to address the problem of schema evolution. If we change a class definition,
    how will we change the configuration?
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件是公共API的一部分。作为应用程序设计者，我们必须解决模式演变的问题。如果我们改变一个类的定义，我们将如何改变配置？
- en: Because configuration files often have useful defaults, they are often very
    flexible. In principle, the content is entirely optional.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 因为配置文件通常具有有用的默认值，它们通常非常灵活。原则上，内容是完全可选的。
- en: As a piece of software undergoes major version changes— changes that alter the
    APIs or the database schema—the configuration files too might undergo major changes.
    The configuration file's version number may have to be included in order to disambiguate
    legacy configuration parameters from current release parameters.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件经历主要版本更改时，改变API或数据库模式的更改，配置文件也可能经历重大更改。配置文件的版本号可能必须包含以消除旧版配置参数和当前发布参数之间的歧义。
- en: For minor version changes, the configuration files, such as database, input
    and output files, and APIs should remain compatible. Any configuration parameter
    handling should have appropriate defaults to cope with minor version changes.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 对于次要版本更改，配置文件，如数据库、输入和输出文件以及API，应保持兼容。任何配置参数处理都应具有适当的默认值，以应对次要版本更改。
- en: A configuration file is a first-class input to an application. It's not an after-thought
    or a workaround. It must be as carefully designed as the other inputs and outputs.
    When we look at larger application architecture design in [Chapter 14](ch14.html
    "Chapter 14. The Logging and Warning Modules"), *The Logging and Warning Modules*
    and [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping
    with the Command Line*, we'll expand on the basics of parsing a configuration
    file.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件是应用程序的一流输入。它不是事后想法或变通方法。它必须像其他输入和输出一样经过精心设计。当我们在[第14章](ch14.html "第14章。日志和警告模块")中查看更大的应用程序架构设计时，*日志和警告模块*和[第16章](ch16.html
    "第16章。处理命令行")，*处理命令行*，我们将扩展解析配置文件的基础知识。
- en: Looking Forward
  id: totrans-1592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In the next chapters, we'll look at larger-scale design considerations. [Chapter
    14](ch14.html "Chapter 14. The Logging and Warning Modules"), *The Logging and
    Warning Modules*, will look at using the `logging` and `warnings` modules to create
    audit information as well as to debug. We'll look at designing for testability
    and how we use `unittest` and `doctest` in [Chapter 15](ch15.html "Chapter 15. Designing
    for Testability"), *Designing for Testability*. [Chapter 16](ch16.html "Chapter 16. Coping
    With the Command Line"), *Coping with the Command Line*, will look at using the
    `argparse` module to parse options and arguments. We'll take this a step further
    and use the **Command** design pattern to create program components that can be
    combined and expanded without resorting to writing shell scripts. In [Chapter
    17](ch17.html "Chapter 17. The Module and Package Design"), *The* *Module and
    Package Design*, we'll look at module and package design. In [Chapter 18](ch18.html
    "Chapter 18. Quality and Documentation"), *Quality and Documentation*, we'll look
    at how we can document our design to create the trust that our software is correct
    and is properly implemented.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到更大规模的设计考虑。[第14章](ch14.html "第14章。日志和警告模块")，*日志和警告模块*，将介绍如何使用`logging`和`warnings`模块来创建审计信息以及调试。我们将探讨为可测试性设计以及在[第15章](ch15.html
    "第15章。为可测试性设计")中如何使用`unittest`和`doctest`。[第16章](ch16.html "第16章。处理命令行")，*处理命令行*，将介绍如何使用`argparse`模块来解析选项和参数。我们将进一步使用**命令**设计模式来创建可以组合和扩展的程序组件，而不必编写shell脚本。在[第17章](ch17.html
    "第17章。模块和包设计")，*模块和包设计*，我们将探讨模块和包的设计。在[第18章](ch18.html "第18章。质量和文档")，*质量和文档*，我们将探讨如何记录我们的设计以创建对我们的软件正确性和正确实现的信任。
