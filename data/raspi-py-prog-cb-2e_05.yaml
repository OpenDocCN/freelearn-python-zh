- en: Chapter 5. Creating 3D Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：创建3D图形
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Starting with 3D coordinates and vertices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从3D坐标和顶点开始
- en: Creating and importing 3D models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和导入3D模型
- en: Creating a 3D world to roam in
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可以漫游的3D世界
- en: Building 3D maps and mazes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建3D地图和迷宫
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The chip at the heart of the original Raspberry Pi (a **Broadcom BCM2835** processor)
    was originally designed to be a **Graphical Processing Unit** (**GPU**) for mobile
    and embedded applications. The ARM core that drives most of the Raspberry Pi's
    functionality was added because some extra space was available on the chip; this
    enabled this powerful GPU to be used as a **System-On-Chip** (**SoC**) solution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 原始Raspberry Pi的核心芯片（一款**Broadcom BCM2835**处理器）最初是为了移动和嵌入式应用而设计的**图形处理单元**（**GPU**）。由于芯片上还有额外的空间，因此添加了驱动Raspberry
    Pi大部分功能的ARM核心；这使得这个强大的GPU可以作为**系统级芯片**（**SoC**）解决方案使用。
- en: As you can imagine, if that original ARM core (**ARM1176JZF-S**, which is the
    **ARMv6** architecture) consisted of only a small part of the chip on the Raspberry
    Pi, you would be right in thinking that the GPU must perform rather well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，如果那个原始的ARM核心（**ARM1176JZF-S**，这是**ARMv6**架构）仅占Raspberry Pi芯片上的一小部分，那么您认为GPU必须表现相当出色是正确的。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The processor at the heart of the Raspberry Pi 3 has been upgraded (to a **Broadcom
    BCM2837** processor); it now contains four ARM cores (**Cortex A53 ARMv8A**),
    each of which are more powerful than the original **ARMv6**. Coupled with the
    same GPU from the previous generation, the Raspberry Pi 3 is far better equipped
    to perform the calculations required to build 3D environments. However, although
    the Raspberry Pi 3 will load the examples faster, once the 3D models are generated,
    both versions of the chip perform just as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 3的核心处理器已经升级（到**Broadcom BCM2837**处理器）；它现在包含四个ARM核心（**Cortex A53
    ARMv8A**），每个都比原始的**ARMv6**更强大。与上一代相同的GPU相结合，Raspberry Pi 3在执行构建3D环境所需的计算方面装备得更加完善。然而，尽管Raspberry
    Pi 3可以更快地加载示例，但一旦生成3D模型，两种芯片版本的表现几乎相同。
- en: The **VideoCore IV GPU** consists of 48 purpose-built processors, with some
    providing support for 1080p high-definition encoding and decoding of video, while
    others support **OpenGL ES 2.0**, which provides fast calculations for 3D graphics.
    It has been said that its graphics processing power is equivalent to that of an
    Apple iPhone 4s and also the original Microsoft Xbox. This is even more apparent
    if you run **Quake 3** or **OpenArena** on the Raspberry Pi (go to [http://www.raspberrypi.org/openarena-for-raspberry-pi](http://www.raspberrypi.org/openarena-for-raspberry-pi)
    for details).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**VideoCore IV GPU**由48个专用处理器组成，其中一些提供对视频的1080p高清编码和解码支持，而其他则支持**OpenGL ES
    2.0**，这为3D图形提供了快速的运算。据说其图形处理能力相当于苹果iPhone 4s和原始的微软Xbox。如果您在Raspberry Pi上运行**Quake
    3**或**OpenArena**，这一点会更加明显（有关详细信息，请访问[http://www.raspberrypi.org/openarena-for-raspberry-pi](http://www.raspberrypi.org/openarena-for-raspberry-pi)）。'
- en: In this chapter, I hope to show you that while you can achieve a lot by performing
    operations using the ARM side of the Raspberry Pi, if you venture into the side
    where the GPU is hidden, you may see that there is even more to this little computer
    than first appears.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我希望向您展示，虽然您可以通过使用Raspberry Pi的ARM侧执行操作来实现很多功能，但如果您探索GPU隐藏的那一侧，您可能会发现这个小电脑比最初看起来更有潜力。
- en: The Pi3D library created by the Pi3D team (Patrick Gaunt, Tom Swirly, Tim Skillman,
    and others) provides a way to put the GPU to work by creating 3D graphics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Pi3D库是由Pi3D团队（Patrick Gaunt、Tom Swirly、Tim Skillman等人）创建的，它提供了一种通过创建3D图形来利用GPU的方法。
- en: 'The Pi3D wiki and documentation pages can be found at the following link:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Pi3D的维基百科和文档页面可以在以下链接找到：
- en: '[http://pi3d.github.io/html/index.html](http://pi3d.github.io/html/index.html)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://pi3d.github.io/html/index.html](http://pi3d.github.io/html/index.html)'
- en: 'The support/development group can be found at the following link:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 支持和开发小组可以在以下链接找到：
- en: '[https://groups.google.com/forum/#!forum/pi3d](https://groups.google.com/forum/#!forum/pi3d)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://groups.google.com/forum/#!forum/pi3d](https://groups.google.com/forum/#!forum/pi3d)'
- en: The library contains many features, so it will not be possible to cover everything
    that is available in the following examples. It is recommended that you also take
    some time to try out the Pi3D demos. To discover more options for the creation
    and handling of the 3D graphics, you can have a look through some of the Python
    modules, which make up the library itself (described in the documentation or the
    code on GitHub at [https://github.com/pi3d/pi3d.github.com](https://github.com/pi3d/pi3d.github.com)).
    It is hoped that this chapter will introduce you to enough concepts to illustrate
    some of the raw potential available to you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该库包含许多功能，因此在以下示例中不可能涵盖所有可用内容。建议您也花些时间尝试 Pi3D 演示。要发现更多用于创建和处理 3D 图形的选择，您可以查看构成库本身的某些
    Python 模块（在文档或 GitHub 上的代码中描述，网址为 [https://github.com/pi3d/pi3d.github.com](https://github.com/pi3d/pi3d.github.com)）。希望这一章能向您介绍足够的概念，以展示您可用的原始潜力。
- en: Starting with 3D coordinates and vertices
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 3D 坐标和顶点开始
- en: The world around us is three-dimensional, so in order to simulate parts of the
    world, we can create a 3D representation and display it on our 2D screen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们周围的世界是三维的，因此为了模拟世界的一部分，我们可以创建一个 3D 表示并在我们的 2D 屏幕上显示它。
- en: The Raspberry Pi enables us to simulate a 3D space, place 3D objects within
    it, and observe them from a selected viewpoint. We will use the GPU to produce
    a representation of the 3D view as a 2D image to display it on the screen.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派使我们能够模拟 3D 空间，在其中放置 3D 对象，并从选定的视角观察它们。我们将使用 GPU 将 3D 视图表示为 2D 图像，以便在屏幕上显示。
- en: The following example will show how we can use **Pi3D** (an OpenGL ES library
    for the Raspberry Pi) to place a single 3D object and display it within the 3D
    space. We will then allow the mouse to rotate the view around the object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将展示我们如何使用 **Pi3D**（树莓派的 OpenGL ES 库）放置单个 3D 对象并在 3D 空间内显示它。然后我们将允许鼠标围绕对象旋转视图。
- en: '![Starting with 3D coordinates and vertices](img/6623_05_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![从 3D 坐标和顶点开始](img/6623_05_001.jpg)'
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The Raspberry Pi must be directly connected to a display, either via the HDMI
    or an analog video output. The 3D graphics rendered by the GPU will only be displayed
    on a local display, even if you are connecting to the Raspberry Pi remotely over
    a network. You will also need to use a locally connected mouse for control (however,
    keyboard control does work via a SSH connection).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派必须直接连接到显示器，无论是通过 HDMI 还是模拟视频输出。GPU 渲染的 3D 图形将仅在本地显示器上显示，即使您通过网络远程连接到树莓派。您还需要使用本地连接的鼠标进行控制（然而，通过
    SSH 连接键盘控制也可以工作）。
- en: 'The first time we use Pi3D, we will need to download and install it with the
    following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用 Pi3D 时，我们需要按照以下步骤下载和安装它：
- en: The Pi3D library uses Pillow, a version of the Python Imaging Library that is
    compatible with Python 3, to import graphics used in models (such as textures
    and backgrounds).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pi3D 库使用 Pillow，这是与 Python 3 兼容的 Python 图像库版本，用于导入模型中使用的图形（如纹理和背景）。
- en: The installation of Pillow has been covered in the *Getting ready* section of
    [Chapter 3](ch03.html "Chapter 3. Using Python for Automation and Productivity"),
    *Using Python for Automation and Productivity*.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Pillow 的安装已在 [第 3 章](ch03.html "第 3 章。使用 Python 进行自动化和生产力") 的 *准备就绪* 部分中介绍，即
    *使用 Python 进行自动化和生产力*。
- en: 'The commands for the installation are shown in the following code (if you''ve
    installed them before, it will skip them and continue):'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装命令如下所示（如果您之前已安装，它将跳过它们并继续）：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now use PIP to install Pi3D using the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 PIP 使用以下命令安装 Pi3D：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Pi3D team is continuously developing and improving the library; if you are
    experiencing problems, it may mean that a new release is not compatible with the
    previous ones.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Pi3D 团队持续开发和改进库；如果您遇到问题，这可能意味着新版本与旧版本不兼容。
- en: You can also check in the [Appendix](apa.html "Appendix A. Hardware and Software
    List"), *Hardware and Software List*, to confirm which version of Pi3D you have
    and, if required, install the same version listed. Alternatively, contact the
    Pi3D team on the Google group; they will be happy to help!
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可以在 [附录](apa.html "附录 A. 硬件和软件列表") 中检查您拥有的 Pi3D 版本，如果需要，安装列出的相同版本。或者，联系 Google
    群组中的 Pi3D 团队；他们将乐意帮助您！
- en: 'Obtain Pi3D demos from the GitHub site, as shown in the following command lines.
    You will need around 90 MB of free space to download and extract the files:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从GitHub网站获取Pi3D演示，如下所示命令行。您需要大约90 MB的空闲空间来下载和提取文件：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will find that the demos have been unpacked to `pi3d_demos-master`. By
    default, the demos are expected to be located at `home/pi/pi3d`; therefore, we
    will rename this directory `pi3d`, as shown in the following command:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会发现演示已解压缩到 `pi3d_demos-master`。默认情况下，预期演示位于 `home/pi/pi3d`；因此，我们将此目录重命名为 `pi3d`，如下所示命令：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, check the Raspberry Pi memory split. Run **raspi-config** (`sudo raspi-config`)
    and ensure that your memory split is set to 128\. (You should only need to do
    this if you have changed it in the past, as 128 MB is the default.) This ensures
    that you have plenty of RAM allocated for the GPU, so it will be able to handle
    lots of 3D objects if required.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查树莓派的内存分割。运行 **raspi-config** (`sudo raspi-config`) 并确保您的内存分割设置为 128\. （如果您之前更改过，则可能需要这样做，因为128
    MB是默认值。）这确保您为GPU分配了足够的RAM，以便在需要时能够处理大量的3D对象。
- en: 'Test if everything is working properly. You should now be able to run any of
    the scripts in the `pi3d_demos-master` directory. See the Pi3D wiki pages for
    details of how they function ([http://pi3d.github.io/html/ReadMe.html](http://pi3d.github.io/html/ReadMe.html)).
    To get the best performance, it is recommended that the scripts are run from the
    command prompt (without loading the desktop):'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一切是否正常工作。现在您应该能够运行 `pi3d_demos-master` 目录中的任何脚本。有关它们如何工作的详细信息，请参阅Pi3D维基页面
    ([http://pi3d.github.io/html/ReadMe.html](http://pi3d.github.io/html/ReadMe.html))。为了获得最佳性能，建议从命令提示符（不加载桌面）运行脚本：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many of the demos require mouse and keyboard control.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多演示需要鼠标和键盘控制。
- en: Although it would be perfectly reasonable to use the methods from [Chapter 4](ch04.html
    "Chapter 4. Creating Games and Graphics"), *Creating Games and Graphics*, for
    mouse and keyboard input using **Tkinter**, many of the demos in the Pi3D library
    use **pi3d.Keyboard** and **pi3d.Mouse** objects to provide additional support
    for joysticks and gamepads. The **pi3d.Keyboard** object also supports keyboard
    control via SSH (see the *Connecting remotely to the Raspberry Pi over the network
    using SSH (and X11 Forwarding)* section of [Chapter 1](ch01.html "Chapter 1. Getting
    Started with a Raspberry Pi Computer"), *Getting Started with a Raspberry Pi Computer*).
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然使用[第4章](ch04.html "第4章。创建游戏和图形")中的方法，*创建游戏和图形*，对于使用 **Tkinter** 的鼠标和键盘输入是完全合理的，但Pi3D库中的许多演示使用
    **pi3d.Keyboard** 和 **pi3d.Mouse** 对象来提供对游戏手柄和游戏板的额外支持。**pi3d.Keyboard** 对象还支持通过SSH进行键盘控制（请参阅[第1章](ch01.html
    "第1章。开始使用树莓派计算机")的*通过SSH（和X11转发）远程连接到树莓派网络*部分，*开始使用树莓派计算机*）。
- en: 'Configure the setup for your own scripts. Since we will use some of the textures
    and models from the demos, it is recommended that you create your scripts within
    the `pi3d` directory. If you have a username that''s different from the default
    Pi account, you will need to adjust `/pi3d/demo.py`. Replace the `USERNAME` part
    with your own username by editing the file:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置您自己脚本的设置。由于我们将使用演示中的一些纹理和模型，建议您在 `pi3d` 目录中创建脚本。如果您有与默认树莓派账户不同的用户名，您需要调整 `/pi3d/demo.py`。通过编辑文件将
    `USERNAME` 部分替换为您自己的用户名：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you want to relocate your files somewhere else, ensure that you add a copy
    of `demo.py` in the folder with the correct path to any resource files you require.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想将文件移到其他位置，请确保在包含所需资源文件正确路径的文件夹中添加 `demo.py` 的副本。
- en: How to do it…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Create the following `3dObject.py` script:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `3dObject.py` 脚本：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To run the script, use `python3 3dObject.py`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本，请使用 `python3 3dObject.py`。
- en: How it works…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We import the math modules (for angle calculations—used to control the view
    based on mouse movements). We also import the demo module, which just provides
    the path to the **shaders** and **textures** in this example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入math模块（用于角度计算——用于根据鼠标移动控制视图）。我们还导入demo模块，它仅提供此示例中**着色器**和**纹理**的路径。
- en: We start by defining some key elements that will be used by Pi3D to generate
    and display our object. The space in which we shall place our object is the `pi3d.Display`
    object; this defines the size of the space and initializes the screen to generate
    and display OpenGL ES graphics.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一些关键元素，这些元素将被 Pi3D 用于生成和显示我们的对象。我们将放置对象的空间是 `pi3d.Display` 对象；这定义了空间的大小并初始化屏幕以生成和显示
    OpenGL ES 图形。
- en: Next, we define a `pi3d.Camera` object, which will allow us to define how we
    view the object within our space. To render our object, we define a texture to
    be applied to the surface and a shader that will apply the texture to the object.
    The shader is used to apply all the effects and lighting to the object, and it
    is coded to use the GPU's OpenGL ES core instead of the ARM processor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个 `pi3d.Camera` 对象，这将允许我们在我们的空间内定义如何查看对象。为了渲染我们的对象，我们定义一个要应用到表面的纹理和一个将纹理应用到对象的着色器。着色器用于将所有效果和光照应用到对象上，并且它被编码为使用
    GPU 的 OpenGL ES 内核而不是 ARM 处理器。
- en: 'We define the `keyboard` and `mouse` object using `pi3d.keyboard()` and `pi3d.mouse()`
    so that we can respond to the keyboard and mouse input. The `restrict` flag of
    the `mouse` object allows the absolute mouse position to continue past the screen
    limits (so we can continuously rotate our 3D object). The main loop, when running,
    will check if the *Esc* key is pressed and then close everything down (including
    calling `DISPLAY.destroy()` to release the screen). We use the `try: finally:`
    method to ensure that the display is closed correctly even if there is an exception
    within `main()`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用 `pi3d.keyboard()` 和 `pi3d.mouse()` 定义了 `keyboard` 和 `mouse` 对象，以便我们可以响应键盘和鼠标输入。`mouse`
    对象的 `restrict` 标志允许鼠标的绝对位置超出屏幕限制（这样我们就可以连续旋转我们的3D对象）。当主循环运行时，会检查是否按下了 *Esc* 键，然后关闭所有内容（包括调用
    `DISPLAY.destroy()` 释放屏幕）。我们使用 `try: finally:` 方法来确保即使在 `main()` 中发生异常，也能正确关闭显示。'
- en: The mouse movement is collected in the main display loop using `mymouse.position()`,
    which returns the *x* and *y* coordinates. The difference in the *x* and *y* movement
    is used to rotate around the object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 主显示循环中使用 `mymouse.position()` 收集鼠标移动，它返回 *x* 和 *y* 坐标。*x* 和 *y* 移动的差异用于围绕对象旋转。
- en: The mouse movements determine the position and angle of the camera. Any adjustment
    to the forward/backward position of the mouse is used to move it over or under
    the object and change the angle of the camera (using `tilt`) so it remains pointing
    at the object. Similarly, any sideways movement will move the camera around the
    object using the `CAMERA.reset()` function. This ensures that the display updates
    the camera view with the new position, `CAMERA.rotate()`, to change the angle
    and uses `CAMERA.position()` to move the camera to a position around the object,
    `camRad` units away from its center.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标移动决定了摄像机的位置和角度。任何调整鼠标的前后位置都会用来移动它穿过或位于对象下方，并改变摄像机的角度（使用 `tilt`），使其始终指向对象。同样，任何侧向移动都会使用
    `CAMERA.reset()` 函数将摄像机围绕对象移动。这确保了显示更新摄像机视图以显示新的位置，`CAMERA.rotate()` 用于改变角度，并使用
    `CAMERA.position()` 将摄像机移动到距离对象中心 `camRad` 单位的位置。
- en: 'We will draw a three-dimensional object called a **tetrahedron**, a shape made
    up of four triangles to form a pyramid with a triangular base. The four corners
    of the shape (three around the base and one at the top) will be defined by the
    three-dimensional coordinates A, B, C, and D, as shown in the following figure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个名为 **四面体** 的三维对象，这是一个由四个三角形组成的形状，形成一个具有三角形底部的金字塔。该形状的四个角（三个在底部周围，一个在顶部）将由三维坐标
    A、B、C 和 D 定义，如图所示：
- en: '![How it works…](img/6623_05_002.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623_05_002.jpg)'
- en: The tetrahedron placed within the X, Y, and Z axes
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 X、Y 和 Z 轴上放置的四面体
- en: The `pi3d.Tetrahedron` object is defined by specifying coordinates to position
    it in the space and then specify the corners that will be joined to form the four
    triangles that make up the shape.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d.Tetrahedron` 对象通过指定坐标来定位它在空间中的位置，然后指定将连接以形成构成形状的四个三角形的角。'
- en: Using `set_draw_details(flatsh,[text])`, we apply the shader(s) we wish to use
    and the texture(s) for the object. In our example, we are just using a single
    texture, but some shaders can use several textures for complex effects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `set_draw_details(flatsh,[text])`，我们应用我们希望使用的着色器（们）和对象的纹理。在我们的例子中，我们只使用了一个纹理，但某些着色器可以使用多个纹理来实现复杂效果。
- en: To help highlight where the coordinates are, we will add some `pi3d.String`
    objects by setting the string text to specify the ID and coordinates next to them
    and placing it at the required location. We will create two string objects for
    each location, one facing forward and another facing backwards (`ry=180` rotates
    the object by 180 degrees on the y axis). The `pi3d.String` objects are single-sided,
    so if we only had one side facing forward, it wouldn't be visible from behind
    when the view was rotated and would just disappear (plus, if it was visible, the
    text would be backwards anyway). Again, we use the `flatsh` shader to render it
    using the `set_shader()` string object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助突出坐标的位置，我们将通过设置字符串文本来指定ID和坐标，并将它们放置在所需的位置，添加一些`pi3d.String`对象。对于每个位置，我们将创建两个字符串对象，一个朝前，另一个朝后（`ry=180`在y轴上将对象旋转180度）。`pi3d.String`对象是单面的，所以如果我们只有一个面向前，当视图旋转时，它就不会从后面可见，并且会消失（此外，如果它是可见的，文本也会是反的）。再次使用`flatsh`着色器通过`set_shader()`字符串对象来渲染它。
- en: All that is left to do now is to draw our tetrahedron and the string objects
    while checking for any keyboard events. Each time the `while` loop completes,
    `DISPLAY.loop_running()` is called, which will update the display with any adjustments
    to the camera as required.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的工作就是绘制我们的四面体和字符串对象，同时检查任何键盘事件。每次`while`循环完成时，都会调用`DISPLAY.loop_running()`，这将根据需要更新显示，调整相机设置。
- en: There's more…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In addition to introducing how to draw a basic object within the 3D space, the
    preceding example makes use of the following four key elements used in 3D graphics
    programming.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了介绍如何在3D空间内绘制基本对象外，前面的示例还使用了以下四个在3D图形编程中使用的关键元素。
- en: Camera
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相机
- en: 'The camera represents our view in the 3D space; one way to explore and see
    more of the space is by moving the camera. The `Camera` class is defined as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 相机代表我们在3D空间中的视角；探索和查看更多空间的一种方法是通过移动相机。`Camera`类的定义如下：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The camera is defined by providing two locations, one to look at (usually the
    object we wish to see—defined by `at`) and another to look from (the object's
    position—defined by `eye`). Other features of the camera, such as its field of
    view (`lens`) and so on, can be adjusted or used with the default settings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相机是通过提供两个位置来定义的，一个是要看的对象（通常是我们希望看到的对象——由`at`定义），另一个是从哪个位置看（对象的位置——由`eye`定义）。相机的其他特性，如视野（`lens`）等，可以通过默认设置进行调整或使用。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we didn't define a camera in our display, a default one will be created that
    points at the origin (the center of the display, that is, `0,0,0`), positioned
    slightly in front of it (`0,0,-0.1`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在我们的显示中定义相机，将创建一个默认的相机，指向原点（即显示的中心，也就是`0,0,0`），并稍微向前定位（`0,0,-0.1`）。
- en: See the Pi3D documentation regarding the camera module for more details.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有关相机模块的更多详细信息，请参阅Pi3D文档。
- en: Shaders
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色器
- en: 'Shaders are very useful as they allow a lot of the complex work required to
    apply textures and lighting to an object by offloading the task to the more powerful
    GPU in the Raspberry Pi. The Shader class is defined as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器非常有用，因为它们允许将应用纹理和光照到对象上的复杂工作卸载到Raspberry Pi中更强大的GPU上。Shader类定义如下：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This allows you to specify a shader file (`shfile`) and specific vertex and
    fragment shaders (if required) within the file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你指定一个着色器文件（`shfile`）以及文件中的特定顶点和片段着色器（如果需要）。
- en: There are several shaders included in the Pi3D library, some of which allow
    multiple textures to be used for reflections, close-up details, and transparency
    effects. The implementation of the shader will determine how the lights and textures
    are applied to the object (and in some cases, such as `uv_flat`, the shader will
    ignore any lighting effects).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Pi3D库中包含了一些着色器，其中一些允许使用多个纹理进行反射、近距离细节和透明度效果。着色器的实现将决定光照和纹理如何应用到对象上（在某些情况下，例如`uv_flat`，着色器将忽略任何光照效果）。
- en: The shader files are listed in the `pi3d\shaders` directory. Try experimenting
    with different shaders, such as `mat_reflect`, which will ignore the textures/fonts
    but still apply the lighting effects; or `uv_toon`, which will apply a cartoon
    effect to the texture.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器文件列在`pi3d\shaders`目录中。尝试使用不同的着色器进行实验，例如`mat_reflect`，它将忽略纹理/字体，但仍然应用光照效果；或者`uv_toon`，它将对纹理应用卡通效果。
- en: Each shader consists of two files, `vs` (vertex shader) and `fs` (fragment shader),
    written in C-like code. They work together to apply the effects to the object
    as desired. The vertex shader is responsible for mapping the 3D location of the
    vertices to the 2D display. The fragment shader (or sometimes called the pixel
    shader) is responsible for applying lighting and texture effects to the pixels
    themselves. The construction and operation of these shaders is well beyond the
    scope of this chapter, but there are several example shaders that you can compare,
    change, and experiment with within the `pi3d\shaders` directory.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个着色器由两个文件组成，`vs`（顶点着色器）和`fs`（片段着色器），使用类似C的代码编写。它们协同工作以将所需的效果应用于对象。顶点着色器负责将顶点的3D位置映射到2D显示。片段着色器（有时也称为像素着色器）负责将光照和纹理效果应用于像素本身。这些着色器的构建和操作超出了本章的范围，但`pi3d\shaders`目录中有几个示例着色器，你可以比较、更改和实验。
- en: Lights
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灯光
- en: Lighting is very important in a 3D world; it could range from simple general
    lighting (as used in our example) to multiple lights angled from different directions
    providing different strengths and colors. How lights interact with objects and
    the effects they produce will be determined by the textures and shaders used to
    render them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D世界中，光照非常重要；它可以是从简单的通用光照（如我们的示例中使用的）到从不同方向提供不同强度和颜色的多个灯光。光照与物体相互作用以及它们产生的效果将由用于渲染它们的纹理和着色器决定。
- en: 'Lights are defined by their direction, their color and brightness, and also
    by an ambient light to define the background (non-directional) light. The `Light`
    class is defined as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 光照由其方向、颜色和亮度以及定义背景（非方向性）光的环境光定义。`Light`类定义如下：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'By default, the display will define a light that has the following properties:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，显示将定义一个具有以下属性的光照：
- en: '`lightpos=(10, -10, 20)`: This is a light that shines from the front of the
    space (near the top-left side) down towards the back of the space (towards the
    right).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightpos=(10, -10, 20)`: 这是一个从空间前方（靠近左上角）向下照射到空间后方的光（向右）。'
- en: '`lightcol=(1.0, 1.0, 1.0)`: This is a bright, white, directional light (the
    direction is defined in the preceding dimension, and it is the color defined by
    the RGB values `1.0, 1.0, 1.0`).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightcol=(1.0, 1.0, 1.0)`: 这是一个明亮、白色的方向性光（方向由前面的维度定义，颜色由RGB值`1.0, 1.0, 1.0`定义）。'
- en: '`lightamb=(0.1, 0.1, 0.2)`: This is overall a dull, slightly bluish light.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightamb=(0.1, 0.1, 0.2)`: 这是一个整体略显暗淡、略带蓝色的光。'
- en: Textures
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理
- en: Textures are able to add realism to an object by allowing fine detail to be
    applied to the object's surface; this could be an image of bricks for a wall or
    a person's face to be displayed on the character. When a texture is used by the
    shader, it can often be re-scaled and reflection can be added to it; some shaders
    even allow you to apply surface detail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理可以通过将精细细节应用于对象的表面来为对象增添真实感；这可以是墙上的砖块或显示在角色上的人脸。当着色器使用纹理时，它通常可以被重新缩放并添加反射；一些着色器甚至允许你应用表面细节。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can apply multiple textures to an object to combine them and produce different
    effects; it will be up to the shader to determine how they are applied.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个纹理应用于一个对象以将它们组合并产生不同的效果；具体如何应用将由着色器决定。
- en: Creating and importing 3D models
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和导入3D模型
- en: Creating complex shapes directly from code can often be cumbersome and time
    consuming. Fortunately, it is possible to import prebuilt models into your 3D
    space.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从代码中创建复杂形状通常既繁琐又耗时。幸运的是，可以将预构建的模型导入到你的3D空间中。
- en: 'It is even possible to use graphical 3D modeling programs to generate models
    and then export them as a suitable format for you to use. This example produces
    a Newell Teapot in the Raspberry Pi theme, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以使用图形3D建模程序生成模型，然后将其导出为适合你使用的格式。以下示例生成了一个Raspberry Pi主题的Newell茶壶，如图所示：
- en: '![Creating and importing 3D models](img/6623_05_003.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![创建和导入3D模型](img/6623_05_003.jpg)'
- en: Newell Raspberry Pi teapot
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Newell Raspberry Pi茶壶
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We shall use 3D models of a teapot (both `teapot.obj` and `teapot.mdl`) located
    in `pi3d\models`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用位于`pi3d\models`目录中的茶壶3D模型（`teapot.obj`和`teapot.mdl`）。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modeling a teapot is the traditional 3D equivalent of displaying *Hello World*.
    Computer graphics researcher Martin Newell first created the Newell Teapot in
    1975 as a basic test model for his work. The Newell Teapot soon became the standard
    model to quickly check if a 3D rendering system is working correctly (it even
    appeared in Toy Story and a 3D episode of The Simpsons).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 制作茶壶模型是3D中显示 *Hello World* 的传统做法。计算机图形研究员马丁·纽厄尔（Martin Newell）于1975年首次创建了纽厄尔茶壶（Newell
    Teapot），作为他工作的基本测试模型。纽厄尔茶壶很快成为快速检查3D渲染系统是否正常工作的标准模型（它甚至出现在《玩具总动员》和《辛普森一家》的3D集中）。
- en: Other models are available in the `pi3d\models` directory (`monkey.obj/mdl`,
    which has been used later on, is available in the book's resource files).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模型可在 `pi3d\models` 目录中找到（后来被使用的 `monkey.obj/mdl` 可在本书的资源文件中找到）。
- en: How to do it…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create and run the following `3dModel.py` script:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并运行以下 `3dModel.py` 脚本：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Like the `3dObject.py` example, we define the `DISPLAY` shader (this time using
    `uv_reflect`) and some additional textures—`bumptex` (`floor_nm.jpg`) and `shinetex`
    (`stars.jpg`)—to use later. We define a model that we want to import, placing
    it at `z=10` (if no coordinates are given, it will be placed at `(0,0,0)`. Since
    we do not specify a camera position, the default will place it within the view
    (see the section regarding the camera for more details).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `3dObject.py` 示例一样，我们定义了 `DISPLAY` 着色器（这次使用 `uv_reflect`）和一些额外的纹理——`bumptex`（`floor_nm.jpg`）和
    `shinetex`（`stars.jpg`）——以供以后使用。我们定义了一个我们想要导入的模型，将其放置在 `z=10`（如果没有给出坐标，它将被放置在
    `(0,0,0)`。由于我们没有指定相机位置，默认情况下它将被放置在视图中（有关相机的详细信息，请参阅相关部分）。
- en: We apply the shader using the `set_shader()` function. Next, we add some textures
    and effects using `bumptex` as a surface texture (scaled by `4`). We apply an
    extra shiny effect using `shinetex` and apply a reflection strength of `0.5` (the
    strength ranges from 0.0, the weakest, to 1.0, the strongest) using the `set_normal_shine()`
    function. If you look closely at the surface of the model, the `bumptex` texture
    provides additional surface detail and the `shinetex` texture can be seen as the
    reflection on the surface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `set_shader()` 函数应用着色器。接下来，我们使用 `bumptex` 作为表面纹理（按 `4` 缩放）添加一些纹理和效果。我们使用
    `shinetex` 应用额外的闪亮效果，并使用 `set_normal_shine()` 函数应用反射强度为 `0.5`（强度范围从 0.0，最弱，到 1.0，最强）。如果你仔细观察模型的表面，`bumptex`
    纹理提供了额外的表面细节，而 `shinetex` 纹理则可以看作是表面上的反射。
- en: To display our model within something more interesting than a default blue space,
    we create an `EnvironmentCube` object. This defines a large space that has a special
    texture applied to the inside space (in this instance, it will load the `sbox_front/back/bottom/left`
    and `sbox_right` images from the `textures\ecubes` directory), so it effectively
    encloses the objects within. The result is that you get a pleasant backdrop for
    your object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在比默认蓝色空间更有趣的环境中显示我们的模型，我们创建了一个 `EnvironmentCube` 对象。这定义了一个内部空间应用了特殊纹理的大空间（在这个例子中，它将从
    `textures\ecubes` 目录中加载 `sbox_front/back/bottom/left` 和 `sbox_right` 图像），因此它有效地包围了对象。结果是，你得到了一个令人愉快的环境背景。
- en: Again, we define a default `CAMERA` object with `rot` and `tilt` variables to
    control the view. Within the `DISPLAY.loop_running()` section, we can control
    the view of the `CAMERA` object using the mouse and rotate the model on its axis
    at different rates to let it spin and show all its sides (using the `RotateIncX/Y/Z()`
    function to specify the rate of rotation). Finally, we ensure that the `DISPLAY`
    is updated by drawing the model and the environment cube.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们定义了一个默认的 `CAMERA` 对象，带有 `rot` 和 `tilt` 变量来控制视图。在 `DISPLAY.loop_running()`
    部分中，我们可以使用鼠标控制 `CAMERA` 对象的视图，并以不同的速率旋转模型以使其旋转并展示其所有侧面（使用 `RotateIncX/Y/Z()` 函数来指定旋转速率）。最后，我们通过绘制模型和环境立方体来确保
    `DISPLAY` 被更新。
- en: There's more…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We can create a wide range of objects to place within our simulated environment.
    Pi3D provides methods to import our own models and apply multiple textures to
    them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在模拟环境中创建各种对象。Pi3D 提供了导入我们自己的模型并将多个纹理应用到它们上的方法。
- en: Creating or loading your own objects
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建或加载自己的对象
- en: If you wish to use your own models in this example, you shall need to create
    one in the correct format; Pi3D supports **obj** (wavefront object files) and
    **egg** (Panda3D).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在这个示例中使用自己的模型，你需要创建一个正确格式的模型；Pi3D 支持 **obj**（wavefront 对象文件）和 **egg**（Panda3D）。
- en: An excellent, free, 3D modeling program is called **Blender** (available at
    [http://www.blender.org](http://www.blender.org)). There are lots of examples
    and tutorials on their website to get you started with basic modeling ([http://www.blender.org/education-help/tutorials](http://www.blender.org/education-help/tutorials)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀、免费的 3D 建模程序叫做 **Blender**（可在 [http://www.blender.org](http://www.blender.org)
    获取）。他们的网站上有很多示例和教程，可以帮助你开始基本的建模（[http://www.blender.org/education-help/tutorials](http://www.blender.org/education-help/tutorials)）。
- en: Pi3D model support is limited and will not support all the features that Blender
    can embed in an exported model, for example, deformable meshes. Therefore, only
    basic multipart models are supported. There are a few steps required to simplify
    the model so it can be loaded by Pi3D.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Pi3D 对模型的支持有限，不会支持 Blender 可以嵌入到导出模型中的所有功能，例如可变形网格。因此，只支持基本的多部分模型。需要几个步骤来简化模型，以便它可以由
    Pi3D 加载。
- en: 'To convert an `.obj` model to use with Pi3D, proceed with the following steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `.obj` 模型转换为与 Pi3D 一起使用，请按照以下步骤操作：
- en: Create or load a model in Blender—try starting with a simple object before attempting
    more complex models.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Blender 中创建或加载一个模型——在尝试更复杂的模型之前，先从简单的对象开始。
- en: Select each **Object** and switch to **Edit** mode (press *Tab*).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每个 **对象** 并切换到 **编辑** 模式（按 *Tab*）。
- en: Select all vertices (press *A*) and uv-map them (press *U* and then select **Unwrap**).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有顶点（按 *A*）并对其 uv 映射（按 *U* 然后选择 **Unwrap**）。
- en: Return to **Object** mode (press *Tab*).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 **对象** 模式（按 *Tab*）。
- en: Export it as **obj**—from the **File** menu at the top, select **Export** and
    then **Wavefront (.obj)**. Ensure that **Include Normals** is also checked in
    the list of options in the bottom-left list.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其导出为 **obj** 格式——从顶部的 **文件** 菜单中选择 **导出**，然后选择 **Wavefront (.obj)**。确保在左下角的选项列表中也选中了
    **Include Normals**。
- en: 'Click on **Save** and place the `.obj` and `.mtl` files in the `pi3d\models`
    directory, and ensure that you update the script with the model''s filename, as
    follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **保存**，并将 `.obj` 和 `.mtl` 文件放置在 `pi3d\models` 目录中，并确保更新脚本以包含模型的文件名，如下所示：
- en: '[PRE11]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you run your updated script, you will see your model displayed in the
    3D space. For example, the `monkey.obj` model is shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行更新后的脚本时，你将在 3D 空间中看到你的模型。例如，下面的截图显示了 `monkey.obj` 模型：
- en: '![Creating or loading your own objects](img/6623_05_004.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![创建或加载自己的对象](img/6623_05_004.jpg)'
- en: A monkey head model created in Blender and displayed by Pi3D
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Blender 创建并由 Pi3D 显示的猴子头模型
- en: Changing the object's textures and .mtl files
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改对象的纹理和 .mtl 文件
- en: The texture that is applied to the surface of the model is contained within
    the `.mtl` file of the model. This file defines the textures and how they are
    applied as set by the modeling software. Complex models may contain multiple textures
    for various parts of the object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到模型表面的纹理包含在模型的 `.mtl` 文件中。此文件定义了纹理及其应用方式，这些方式由建模软件设置。复杂模型可能包含多个纹理，用于对象的各个部分。
- en: 'If no material is defined, the first texture in the shader is used (in our
    example, this is the `bumptex` texture). To add a new texture to the object, add
    (or edit) the following line in the `.mtl` file (that is, to use `water.jpg`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有定义材质，则使用着色器中的第一个纹理（在我们的例子中，这是 `bumptex` 纹理）。要向对象添加新纹理，请在 `.mtl` 文件中添加（或编辑）以下行（即使用
    `water.jpg`）：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'More information about `.mtl` files and `.obj` files can be found at the following
    Wikipedia link:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `.mtl` 文件和 `.obj` 文件的更多信息可以在以下维基百科链接中找到：
- en: '[https://en.wikipedia.org/wiki/Wavefront_.obj_file](https://en.wikipedia.org/wiki/Wavefront_.obj_file)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Wavefront_.obj_file](https://en.wikipedia.org/wiki/Wavefront_.obj_file)'
- en: Taking screenshots
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拍摄截图
- en: 'The Pi3D library includes a useful screenshot function to capture the screen
    in a `.jpg` or `.png` file. We can add a new key event to trigger it and call
    `pi3d.screenshot("filename.jpg")` to save an image (or use a counter to take multiple
    screenshots), as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Pi3D 库包含一个有用的截图功能，可以捕获屏幕并将其保存为 `.jpg` 或 `.png` 文件。我们可以添加一个新的按键事件来触发它，并调用 `pi3d.screenshot("filename.jpg")`
    来保存图像（或使用计数器来拍摄多张截图），如下面的代码所示：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating a 3D world to roam in
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可以漫游的 3D 世界
- en: Now that we are able to create models and objects within our 3D space, as well
    as generate backgrounds, we may want to create a more interesting environment
    within which to place them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够在我们的 3D 空间中创建模型和对象，以及生成背景，我们可能想要创建一个更有趣的环境来放置它们。
- en: '3D terrain maps provide an elegant way to define very complex landscapes. The
    terrain is defined using a grayscale image to set the elevation of the land. The
    following example shows how we can define our own landscape and simulate flying
    over it, or even walk on its surface:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 3D地形图提供了一种优雅的方式来定义非常复杂的地形。地形是通过使用灰度图像来设置土地的高程来定义的。以下示例显示了我们可以如何定义自己的景观并模拟在其上飞行，甚至在其表面上行走：
- en: '![Creating a 3D world to roam in](img/6623_05_005.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个可以漫游的3D世界](img/6623_05_005.jpg)'
- en: A 3D landscape generated from a terrain map
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由地形图生成的3D景观
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to place the `Map.png` file (available in the book resource files)
    in the `pi3d/textures` directory of the Pi3D library. Alternatively, you can use
    one of the elevation maps already present—replace the reference to `Map.png` with
    another one of the elevation maps, such as `testislands.jpg`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将`Map.png`文件（可在本书的资源文件中找到）放置在Pi3D库的`pi3d/textures`目录中。或者，您可以使用现有的高程图之一——将`Map.png`的引用替换为另一个高程图，例如`testislands.jpg`。
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create the following `3dWorld.py` script:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下`3dWorld.py`脚本：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: Once we have defined the display, camera, textures, and shaders that we are
    going to use, we can define the `ElevationMap` object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了将要使用的显示、摄像头、纹理和着色器，我们就可以定义`ElevationMap`对象。
- en: 'It works by assigning a height to the terrain image based on the pixel value
    of selected points of the image. For example, a single line of an image will provide
    a slice of the `ElevationMap` object and a row of elevation points on the 3D surface:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过根据图像选定点的像素值给地形图像分配高度来实现。例如，图像的单行将提供`ElevationMap`对象的切片和3D表面上的高程点行：
- en: '![How it works…](img/6623_05_006.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623_05_006.jpg)'
- en: Mapping the map.png pixel shade to the terrain height
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将map.png像素阴影映射到地形高度
- en: 'We create an `ElevationMap` object by providing the filename of the image we
    will use for the gradient information (`textures/Map.png`), and we also create
    the dimensions of the map (`width`, `depth`, and `height`—which is how high the
    white spaces will be compared to the black spaces):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过提供用于梯度信息的图像文件名（`textures/Map.png`）来创建一个`ElevationMap`对象，并且我们还创建了地图的尺寸（`width`、`depth`和`height`——这是白色空间相对于黑色空间的高度）：
- en: '![How it works…](img/6623_05_007.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/6623_05_007.jpg)'
- en: The light parts of the map will create high points and the dark ones will create
    low points
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的亮部将创建高点，而暗部将创建低点
- en: The `Map.png` texture provides an example terrain map, which is converted into
    a three-dimensional surface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map.png`纹理提供了一个示例地形图，该图被转换成三维表面。'
- en: We also specify `divx` and `divy`, which determine how much detail of the terrain
    map is used (how many points from the terrain map are used to create the elevation
    surface). Finally, `ntiles` specifies that the texture used will be scaled to
    fit `20 times` across the surface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定`divx`和`divy`，这决定了使用地形图的多少细节（使用地形图中的多少点来创建高程表面）。最后，`ntiles`指定使用的纹理将被缩放到覆盖表面`20倍`。
- en: Within the main `DISPLAY.loop_running()` section, we will control the camera,
    draw `ElevationMap`, respond to inputs, and limit movements in our space.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`DISPLAY.loop_running()`部分中，我们将控制摄像头，绘制`ElevationMap`，响应用户输入，并限制我们在空间中的移动。
- en: As before, we use a `Keyboard` object to capture mouse movements and translate
    them to control the camera. We will also use `mykeys.read()` to determine if *W*,
    *S*, *R*, and *T* have been pressed, which allow us to move forward and backwards,
    as well as rise up and down.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用一个`Keyboard`对象来捕捉鼠标移动并将它们转换为控制摄像头的操作。我们还将使用`mykeys.read()`来确定是否按下了*W*、*S*、*R*和*T*键，这允许我们前进和后退，以及上升和下降。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To allow easy conversion between the values returned from the `Keyboard` object
    and their equivalent meaning, we will use a Python dictionary:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许轻松地在`Keyboard`对象返回的值及其等效意义之间进行转换，我们将使用一个Python字典：
- en: '`KEY = {''R'':114,''S'':115,''T'':116,''W'':119,''ESC'':27,''NONE'':-1}`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`KEY = {''R'':114,''S'':115,''T'':116,''W'':119,''ESC'':27,''NONE'':-1}`'
- en: The dictionary provides an easy way to translate between a given value and the
    resulting string. To access a key's value, we use `KEY['W']`. We also used a dictionary
    in [Chapter 3](ch03.html "Chapter 3. Using Python for Automation and Productivity"),
    *Displaying Photo Information in an Application*, to translate between the image
    Exif TAG names and IDs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 字典提供了一个简单的方法，在给定的值和结果字符串之间进行转换。要访问键的值，我们使用`KEY['W']`。我们还在[第3章](ch03.html "第3章。使用Python进行自动化和生产力")中使用了字典，*在应用程序中显示照片信息*，以在图像Exif标签名称和ID之间进行转换。
- en: To ensure that we do not fall through the surface of the `ElevationMap` object
    when we move over it, we can use `mymap.calcHeight()` to provide us with the height
    of the terrain at a specific location (`x,y,z`). We can either follow the ground
    by ensuring the camera is set to equal this, or fly through the air by just ensuring
    that we never go below it. When we detect that we are on the ground, we ensure
    that we remain on the ground until we press *R* to rise again.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们在移动到`ElevationMap`对象表面时不会掉下去，我们可以使用`mymap.calcHeight()`来为我们提供特定位置（`x,y,z`）的地形高度。我们可以通过确保相机设置为等于这个高度来跟随地面，或者通过确保我们永远不会低于它来在空中飞行。当我们检测到我们在地面上时，我们确保我们保持在地面，直到我们按下*R*键再次上升。
- en: Building 3D maps and mazes
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建3D地图和迷宫
- en: We've seen that the Pi3D library can be used to create lots of interesting objects
    and environments. Using some of the more complex classes (or by constructing our
    own), whole custom spaces can be designed for the user to explore.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Pi3D库可以用来创建许多有趣的对象和环境。通过使用一些更复杂的类（或者通过构建自己的类），可以为用户设计出整个自定义空间来探索。
- en: 'In the following example, we use a special module called **Building**, which
    has been designed to allow you to construct a whole building using a single image
    file to provide the layout:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用一个名为**Building**的特殊模块，该模块被设计为允许您使用单个图像文件来构建整个建筑：
- en: '![Building 3D maps and mazes](img/6623_05_008.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![构建3D地图和迷宫](img/6623_05_008.jpg)'
- en: Explore the maze and find the sphere that marks the exit
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 探索迷宫并找到标记出口的球体
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need to ensure that you have the following files in the `pi3d/textures`
    directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保在`pi3d/textures`目录中具有以下文件：
- en: '`squareblocksred.png`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`squareblocksred.png`'
- en: '`floor.png`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floor.png`'
- en: '`inside_map0.png, inside_map1.png, inside_map2.png`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inside_map0.png, inside_map1.png, inside_map2.png`'
- en: These files are available as part of the book's resources placed in `Chapter05\resource\source_files\textures`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件作为本书的资源的一部分提供，位于`Chapter05\resource\source_files\textures`。
- en: How to do it…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s run the following `3dMaze.py` script by performing the following steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤运行以下`3dMaze.py`脚本：
- en: 'First, we set up the keyboard, mouse, display, and settings for the model using
    the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用以下代码设置键盘、鼠标、显示和模型的设置：
- en: '[PRE15]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then create functions to allow us to reload the levels and display messages
    to the player using the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建函数，使我们能够重新加载关卡并使用以下代码向玩家显示消息：
- en: '[PRE16]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Within the main function, we set up the 3D environment and draw all the objects
    using the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们使用以下代码设置3D环境并绘制所有对象：
- en: '[PRE17]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we monitor for key presses, handle any collisions with objects, and
    move within the maze as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们监控按键，处理与对象的任何碰撞，并在迷宫中移动如下：
- en: '[PRE18]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define many of the elements we used in the preceding examples, such as the
    display, textures, shaders, font, and lighting. We also define the objects, such
    as the building itself, the `ElevationMap` object, as well as the start and end
    points of the maze. We also use **SolidObjects** to help detect movement within
    the space. See the *Using SolidObjects to detect collisions* subsection in the
    *There's more…* section of this recipe for more information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了在先前的示例中使用的大多数元素，例如显示、纹理、着色器、字体和照明。我们还定义了对象，如建筑本身、`ElevationMap`对象，以及迷宫的起点和终点。我们还使用**SolidObjects**来帮助检测空间内的移动。有关更多信息，请参阅此食谱*更多内容*部分的*使用SolidObjects检测碰撞*子部分。
- en: Finally, we create the actual `Building` object based on the selected map image
    (using the `loadLevel()` function) and locate the camera (which represents our
    first-person viewpoint) at the start. See the *The Building module* subsection
    in the *There's more…* section of this recipe for more information.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据所选的地图图像（使用`loadLevel()`函数）创建实际的`Building`对象，并将相机（代表我们的第一人称视角）定位在起点。有关更多信息，请参阅此食谱的*更多内容*部分的*Building模块*子部分。
- en: Within the `main` loop, we draw all the objects in our space and apply the lighting
    effects. We will also monitor for movement in the mouse (to control the tilt and
    rotation of the camera) or the keyboard to move the player (or exit/provide help).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`循环中，我们绘制我们空间中的所有对象并应用光照效果。我们还将监控鼠标（以控制相机的倾斜和旋转）或键盘以移动玩家（或退出/提供帮助）。
- en: 'The controls are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 控制方式如下：
- en: '**Mouse movement**: This changes the camera tilt and rotation.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鼠标移动**：这会改变相机的倾斜和旋转。'
- en: '**'' or / key**: This changes the camera to tilt either downwards or upwards.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**'' 或 / 键**：这会改变相机向下或向上倾斜。'
- en: '**A or D**: This changes the camera to rotate from left to right or vice versa.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A 或 D**：这会改变相机从左向右或相反方向旋转。'
- en: '**W or S**: This moves the player forwards or backwards.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**W 或 S**：这会使玩家向前或向后移动。'
- en: '**H**: This helps the player by rotating them to face the end of the maze.
    The useful `CAMERA.point_at()` function is used to quickly rotate and tilt the
    camera''s viewpoint towards the provided coordinates (the end position).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H**：这通过将玩家旋转以面对迷宫的尽头来帮助玩家。有用的`CAMERA.point_at()`函数用于快速旋转和倾斜相机的视角，使其指向提供的坐标（终点位置）。'
- en: Whenever the player moves, we check if the new position (`NewPos`) collides
    with another `SolidObject` using `CollisionList(NewPos)`. The function will return
    a list of any other SolidObjects that overlap the coordinates provided.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每当玩家移动时，我们都会检查新的位置（`NewPos`）是否与另一个`SolidObject`发生碰撞，使用`CollisionList(NewPos)`。该函数将返回任何与提供的坐标重叠的其他SolidObject的列表。
- en: If there are no SolidObjects in the way, we make the player move; otherwise,
    we check to see if one of the SolidObject's names is the `end` object, in which
    case we have reached the end of the maze.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有障碍物阻挡，我们将使玩家移动；否则，我们将检查是否有SolidObject的名称是`end`对象，在这种情况下，我们已经到达了迷宫的尽头。
- en: When the player reaches the end, we remove the walls from the old `Building`
    object and display a loading message. If we don't remove the walls, all the SolidObjects
    belonging to the previous `Building` will still remain, creating invisible obstacles
    in the next level.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家到达终点时，我们将从旧的`Building`对象中移除墙壁并显示一个加载消息。如果我们不移除墙壁，属于前一个`Building`的所有SolidObject仍然会保留，在下一个关卡中创建不可见的障碍物。
- en: We use the `showMessage()` function to inform the user that the next level will
    be loaded soon (since it can take a while for the building object to be constructed).
    We need to ensure that we call `DISPLAY.loop_running()` after we draw the message.
    This ensures it is displayed on screen before we start loading the level (after
    which the person will be unable to move while loading takes place). We need to
    ensure that the message is always facing the player regardless of which of their
    sides collides with the `end` object by using the camera rotation (`rot`) for
    its angle.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`showMessage()`函数通知用户下一个关卡将很快被加载（因为构建建筑对象可能需要一段时间）。我们需要确保在绘制消息后调用`DISPLAY.loop_running()`。这确保了在开始加载关卡（之后人物将无法移动，因为正在加载）之前，消息已显示在屏幕上。我们需要确保无论玩家的哪一侧与`end`对象碰撞，消息总是面向玩家，通过使用相机的旋转（`rot`）来设置其角度。
- en: '![How it works...](img/6623_05_009.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/6623_05_009.jpg)'
- en: When the exit ball is found, the next level is loaded
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到出口球时，将加载下一个关卡
- en: When the next level in the list has been loaded (or the first level has been
    loaded again when all the levels have been completed), we replace the message
    with a blank one to remove it and reset the person's position back to the start.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表中的下一个关卡被加载（或者当所有关卡都完成后，再次加载第一个关卡），我们将消息替换为一个空白消息以移除它，并将人物的位置重置回起点。
- en: You can design and add your own levels by creating additional map files (20
    x 20 PNG files with walls marked out with black pixels and walkways in white)
    and listing them in `levelList`. The player will start at the top-left corner
    of the map, and the exit is placed at the center.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建额外的地图文件（20 x 20的PNG文件，用黑色像素标记墙壁，用白色标记通道）并在`levelList`中列出它们来设计和添加自己的关卡。玩家将从地图的左上角开始，出口放置在中心。
- en: You will notice that loading the levels can take quite a long time; this is
    the relatively slow ARM processor in the Raspberry Pi performing all the calculations
    required to construct the maze and locate all the components. As soon as the maze
    has been built, the more powerful GPU takes over, which results in fast and smooth
    graphics as the player explores the space.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到加载层级可能需要相当长的时间；这是相对较慢的树莓派ARM处理器，它执行构建迷宫和定位所有组件所需的所有计算。一旦迷宫构建完成，更强大的GPU接管，这使得玩家探索空间时图形快速且流畅。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe demonstrates the difference between the original Raspberry Pi processor
    and the Raspberry Pi 2\. The Raspberry Pi 2 takes around 1 minute 20 seconds to
    load the first level, while the original Raspberry Pi can take up to 4 minutes
    20 seconds. The Raspberry Pi 3 takes a stunning 4 seconds to load the same level.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方展示了原始树莓派处理器与树莓派2之间的区别。树莓派2加载第一个层级大约需要1分20秒，而原始树莓派可能需要长达4分20秒。树莓派3加载相同层级仅需惊人的4秒。
- en: There's more...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The preceding example creates a building for the player to explore and interact
    with. In order to achieve this, we use the `Building` module of Pi3D to create
    a building and use `SolidObject` to detect collisions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例创建了一个玩家可以探索和交互的建筑。为了实现这一点，我们使用Pi3D的`Building`模块创建建筑，并使用`SolidObject`检测碰撞。
- en: The Building module
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建筑模块
- en: 'The `pi3d.Building` module allows you to define a whole level or floor of a
    building using map files. Like the terrain maps used in the preceding example,
    the color of the pixels will be converted into different parts of the level. In
    our case, black is for the walls and white is for the passages and halls, complete
    with ceilings:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi3d.Building`模块允许您使用地图文件定义整个建筑层级或楼层。就像前面示例中使用的地形地图一样，像素的颜色将被转换为不同层级的各个部分。在我们的案例中，黑色代表墙壁，白色代表通道和走廊，包括天花板：'
- en: '![The Building module](img/6623_05_010.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![建筑模块](img/6623_05_010.jpg)'
- en: The building layout is defined by the pixels in the image
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑布局由图像中的像素定义
- en: 'The sections built by the `Building` object are defined by the **Scheme** used.
    The `Scheme` is defined by two sections, by the number of models, and then by
    the definitions for various aspects of the model, as seen in the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由`Building`对象构建的部分由使用的**方案**定义。`Scheme`由两部分定义，即模型数量，然后是模型各个方面的定义，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first **tuple** defines the type of cell/square that the selected model
    should be applied to. Since there are two pixel colors in the map, the squares
    will either be black (`0`) or white (`1`). By determining the position and type
    of a particular cell/square, we can define which models (wall, ceiling, or roof)
    we want to apply.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个**元组**定义了所选模型应应用到的单元格/方块类型。由于地图中有两种像素颜色，方块将是黑色（`0`）或白色（`1`）。通过确定特定单元格/方块的位置和类型，我们可以定义我们想要应用哪些模型（墙壁、天花板或屋顶）。
- en: 'We define three main types of cell/square location:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三种主要的单元格/方块位置类型：
- en: 'A whole square `(1,None)`: This is a white cell representing open space in
    the building.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个方块 `(1,None)`：这是一个代表建筑中开放空间的白色单元格。
- en: 'One cell bordering another, on the edge `(0,1,"edge")`: This is a black cell
    next to a white one on the map edge. This also includes `(1,0,"edge")`. This will
    represent the outer wall of the building.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单元格与另一个单元格相邻，在边缘 `(0,1,"edge")`：这是地图边缘处的黑色单元格旁边的一个白色单元格。这也包括 `(1,0,"edge")`。这将代表建筑的外墙。
- en: 'Any black cell that is next to a white cell `(0,1)`: This will represent all
    the internal walls of the building.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何与白色单元格相邻的黑色单元格 `(0,1)`：这将代表建筑的所有内部墙壁。
- en: 'Next, we allocate a type of object(s) to be applied for that type (`W` or `C`):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为该类型（`W`或`C`）分配要应用的对象类型：
- en: '**Wall** (`W`): This is a vertical wall that is placed between the specified
    cells (such as between black and white cells).'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**墙壁** (`W`): 这是一个放置在指定单元格之间（如黑色和白色单元格之间）的垂直墙壁。'
- en: '**Ceiling** (`C`): This is a horizontal section of the ceiling to cover the
    current cell.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天花板** (`C`): 这是一个用于覆盖当前单元格的天花板水平部分。'
- en: '**Roof** (`R`): This is an additional horizontal section that is placed slightly
    above the ceiling to provide a roofing effect. It is typically used for buildings
    that may need to be viewed from the outside (this is not used in our example).'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屋顶** (`R`): 这是一个放置在天花板稍上方的额外水平部分，以提供屋顶效果。它通常用于可能需要从外部观看的建筑（在我们的示例中不使用）。'
- en: '**Ceiling Edge** (`CE`): This is used to join the ceiling sections to the roof
    around the edges of the building (it is not used in our example since ours is
    an indoor model).'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天花板边缘** (`CE`): 这用于将天花板部分连接到建筑边缘的屋顶（在我们的例子中，由于我们是一个室内模型，所以不使用它）。'
- en: Finally, we specify the model that will be used for each object. We are using
    three models in this example (normal walls, walls on an edge, and the ceiling),
    so we can define the model used by specifying `0`, `1`, or `2`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们指定每个对象将使用的模型。在这个例子中，我们使用三个模型（普通墙面、边缘墙面和天花板），因此可以通过指定 `0`、`1` 或 `2` 来定义使用的模型。
- en: 'Each of the models are defined in the `details` array, which allows us to set
    the required textures and shaders for each one (this contains the same information
    that would normally be set by the `.set_draw_details()` function), as shown in
    the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型都在 `details` 数组中定义，这使得我们可以为每个模型设置所需的纹理和着色器（这包含通常由 `.set_draw_details()`
    函数设置的相同信息），如下面的代码所示：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our example, the inside walls are allocated to the `wallimg` texture (`textures/squareblocksred.png`)
    and the ceilings are allocated to the `ceilingimg` texture (`textures/squareblocks4.png`).
    You may be able to note from the following screenshot that we can apply different
    texture models (in our case, a slightly different scaling) to the different types
    of blocks. The walls that border the outside of the maze (with the edge identifier)
    will use the `wallimg` model texture scaled by 4x8 (`details[1]`) while the same
    model texture will be scaled 4x16 for the internal walls (`details[0]`):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，内部墙面分配给 `wallimg` 纹理（`textures/squareblocksred.png`），天花板分配给 `ceilingimg`
    纹理（`textures/squareblocks4.png`）。您可能可以从下面的屏幕截图中注意到，我们可以将不同的纹理模型（在我们的情况下，是稍微不同的缩放）应用于不同类型的方块。迷宫外部的墙面（带有边缘标识符）将使用
    `wallimg` 模型纹理按 4x8 缩放（`details[1]`），而对于内部墙面，相同的模型纹理将按 4x16 缩放（`details[0]`）：
- en: '![The Building module](img/6623_05_011.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![建筑模块](img/6623_05_011.jpg)'
- en: The outward facing wall on the left has a different scaling applied compared
    to the other walls
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧朝外的墙面与其他墙面相比应用了不同的缩放比例
- en: 'Both `scheme` and `draw_details` are set when the `pi3d.Building` object is
    created, as shown in the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `pi3d.Building` 对象时，会设置 `scheme` 和 `draw_details`，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the map file (`levelList[next_level`]), the scheme (`mazeScheme`), and
    draw details (`details`), the entire building is created within the environment:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地图文件（`levelList[next_level`]）、方案（`mazeScheme`）和绘制细节（`details`），在环境中创建整个建筑：
- en: '![The Building module](img/6623_05_012.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![建筑模块](img/6623_05_012.jpg)'
- en: An overhead view of the 3D maze we created
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 3D 迷宫的俯视图
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although we use just black and white in this example, other colored pixels can
    also be used to define additional block types (and therefore different textures,
    if required). If another color (such as gray) is added, the indexing of the color
    mapping is shifted so that black blocks are referenced as `0`, the new colored
    blocks as `1`, and the white blocks as `2`. See the **Silo** example in the Pi3D
    demos for details.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中我们只使用了黑白两种颜色，但也可以使用其他颜色的像素来定义额外的方块类型（以及如果需要的话，不同的纹理）。如果添加了另一种颜色（如灰色），则颜色映射的索引会移动，使得黑色方块被引用为
    `0`，新的彩色方块为 `1`，白色方块为 `2`。有关详细信息，请参阅 Pi3D 演示中的 **Silo** 示例。
- en: We also need to define an `ElevationMap` object—`mymap`. The `pi3d.Building`
    module makes use of the `ElevationMap` object's `calcHeight()` function to correctly
    place the walls on top of the `ElevationMap` object's surface. In this example,
    we will apply a basic `ElevationMap` object using `textures/floor.png`, which
    will generate a flat surface that the `Building` object will be placed on.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义一个 `ElevationMap` 对象——`mymap`。`pi3d.Building` 模块使用 `ElevationMap` 对象的
    `calcHeight()` 函数来正确地将墙面放置在 `ElevationMap` 对象的表面上。在这个例子中，我们将使用 `textures/floor.png`
    应用基本的 `ElevationMap` 对象，这将生成一个平面表面，`Building` 对象将放置在其上。
- en: Using SolidObjects to detect collisions
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SolidObjects 检测碰撞
- en: In addition to the `Building` object, we will define an object for the player
    and also define two objects to mark the start and end points of the maze. Although
    the player's view is the first-person viewpoint (that is, we don't actually see
    them since the view is effectively through their eyes), we need to define a **SolidObject**
    to represent them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Building` 对象外，我们还将定义一个玩家对象，并定义两个对象来标记迷宫的起点和终点。尽管玩家的视角是第一人称视角（也就是说，我们实际上看不到他们，因为视角是有效通过他们的眼睛），但我们需要定义一个
    **SolidObject** 来代表他们。
- en: A SolidObject is a special type of invisible object that can be checked to determine
    if the space that would be occupied by one SolidObject has overlapped another.
    This will allow us to use `person.CollisionList(NewPos)` to get a list of any
    other SolidObjects that the `person` object will be in contact with at the `NewPos`
    position. Since the `Building` class defines SolidObjects for all the parts of
    the `Building` object, we will be able to detect when the player tries to move
    through a wall (or, for some reason, the roof/ceiling) and stop them from moving
    through it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: SolidObject是一种特殊类型的不可见对象，可以通过检查来确定一个SolidObject将要占据的空间是否与另一个对象重叠。这将使我们能够使用`person.CollisionList(NewPos)`来获取任何其他SolidObjects的列表，这些SolidObjects将在`NewPos`位置与`person`对象接触。由于`Building`类为`Building`对象的各个部分定义了SolidObjects，因此我们能够检测到玩家试图穿过墙壁（或者，出于某种原因，屋顶/天花板）并阻止他们穿过。
- en: We also use SolidObjects for the start and end locations in the maze. The place
    where the player starts is set as the top-left corner of the map (the white-space
    pixel from the top left of the map) and is marked by the `startpos` object (a
    small `pi3d.Sphere` with the `rock1.jpg` texture) placed above the person's head.
    The end of the maze is marked with another `pi3d.Sphere` object (with the `water.jpg`
    texture) located at the center of the map. We also define another SolidObject
    at the end so that we can detect when the player reaches it and collides with
    it (and load the next level!).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在迷宫的起点和终点使用SolidObjects。玩家开始的位置被设置为地图的左上角（地图左上角的空白像素）并由`startpos`对象（一个带有`rock1.jpg`纹理的小`pi3d.Sphere`）标记，该对象位于玩家的头部上方。迷宫的终点由另一个位于地图中心的`pi3d.Sphere`对象（带有`water.jpg`纹理）标记。我们还定义了另一个SolidObject在终点，这样我们就可以检测到玩家到达它并与之碰撞（并加载下一级！）。
